<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::Class::Relationship::Base - Inter-table relationships</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-class-perl">libdbix-class-perl_0.082844-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::Class::Relationship::Base - Inter-table relationships

</pre><h4><b>SYNOPSIS</b></h4><pre>
         __PACKAGE__-&gt;add_relationship(
           spiders =&gt; 'My::DB::Result::Creatures',
           sub {
             my $args = shift;
             return {
               "$args-&gt;{foreign_alias}.id"   =&gt; { -ident =&gt; "$args-&gt;{self_alias}.id" },
               "$args-&gt;{foreign_alias}.type" =&gt; 'arachnid'
             };
           },
         );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class provides methods to describe the relationships between the tables in your database model.
       These are the "bare bones" relationships methods, for predefined ones, look in DBIx::Class::Relationship.

</pre><h4><b>METHODS</b></h4><pre>
   <b>add_relationship</b>
       Arguments: $rel_name, $foreign_class, $condition, $attrs

         __PACKAGE__-&gt;add_relationship('rel_name',
                                       'Foreign::Class',
                                       $condition, $attrs);

       Create a custom relationship between one result source and another source, indicated by its class name.

       <u>condition</u>

       The condition argument describes the "ON" clause of the "JOIN" expression used to connect the two sources
       when creating SQL queries.

       Simple equality

       To  create  simple equality joins, supply a hashref containing the remote table column name as the key(s)
       prefixed by 'foreign.', and the corresponding local  table  column  name  as  the  value(s)  prefixed  by
       'self.'.   Both  "foreign"  and  "self"  are  pseudo  aliases and must be entered literally. They will be
       replaced with the actual correct table alias when the SQL is produced.

       For example given:

         My::Schema::Author-&gt;has_many(
           books =&gt; 'My::Schema::Book',
           { 'foreign.author_id' =&gt; 'self.id' }
         );

       A query like:

         $author_rs-&gt;search_related('books')-&gt;next

       will result in the following "JOIN" clause:

         ... FROM author me LEFT JOIN book books ON books.author_id = me.id ...

       This describes a relationship between the "Author" table and the "Book" table where the "Book" table  has
       a column "author_id" containing the ID value of the "Author".

       Similarly:

         My::Schema::Book-&gt;has_many(
           editions =&gt; 'My::Schema::Edition',
           {
             'foreign.publisher_id' =&gt; 'self.publisher_id',
             'foreign.type_id'      =&gt; 'self.type_id',
           }
         );

         ...

         $book_rs-&gt;search_related('editions')-&gt;next

       will result in the "JOIN" clause:

         ... FROM book me
             LEFT JOIN edition editions ON
                  editions.publisher_id = me.publisher_id
              AND editions.type_id = me.type_id ...

       This describes the relationship from "Book" to "Edition", where the "Edition" table refers to a publisher
       and a type (e.g. "paperback"):

       Multiple groups of simple equality conditions

       As  is the default in SQL::Abstract::Classic, the key-value pairs will be "AND"ed in the resulting "JOIN"
       clause. An "OR" can be achieved with an arrayref. For example a condition like:

         My::Schema::Item-&gt;has_many(
           related_item_links =&gt; My::Schema::Item::Links,
           [
             { 'foreign.left_itemid'  =&gt; 'self.id' },
             { 'foreign.right_itemid' =&gt; 'self.id' },
           ],
         );

       will translate to the following "JOIN" clause:

        ... FROM item me JOIN item_relations related_item_links ON
                related_item_links.left_itemid = me.id
             OR related_item_links.right_itemid = me.id ...

       This describes the relationship from "Item" to  "Item::Links",  where  "Item::Links"  is  a  many-to-many
       linking table, linking items back to themselves in a peer fashion (without a "parent-child" designation)

       Custom join conditions

         NOTE: The custom join condition specification mechanism is capable of
         generating JOIN clauses of virtually unlimited complexity. This may limit
         your ability to traverse some of the more involved relationship chains the
         way you expect, *and* may bring your RDBMS to its knees. Exercise care
         when declaring relationships as described here.

       To  specify  joins which describe more than a simple equality of column values, the custom join condition
       coderef syntax can be used. For example:

         My::Schema::Artist-&gt;has_many(
           cds_80s =&gt; 'My::Schema::CD',
           sub {
             my $args = shift;

             return {
               "$args-&gt;{foreign_alias}.artist" =&gt; { -ident =&gt; "$args-&gt;{self_alias}.artistid" },
               "$args-&gt;{foreign_alias}.year"   =&gt; { '&gt;', "1979", '&lt;', "1990" },
             };
           }
         );

         ...

         $artist_rs-&gt;search_related('cds_80s')-&gt;next;

       will result in the "JOIN" clause:

         ... FROM artist me LEFT JOIN cd cds_80s ON
               cds_80s.artist = me.artistid
           AND cds_80s.year &lt; ?
           AND cds_80s.year &gt; ?

       with the bind values:

          '1990', '1979'

       "$args-&gt;{foreign_alias}" and "$args-&gt;{self_alias}" are supplied the same values that would  be  otherwise
       substituted for "foreign" and "self" in the simple hashref syntax case.

       The  coderef  is  expected  to  return a valid SQL::Abstract::Classic query-structure, just like what one
       would supply as the first argument to "search" in DBIx::Class::ResultSet. The return value will be passed
       directly to DBIx::Class::SQLMaker and the resulting SQL will be used verbatim as the "ON" clause  of  the
       "JOIN" statement associated with this relationship.

       While  every coderef-based condition must return a valid "ON" clause, it may elect to additionally return
       a simplified <b>optional</b> join-free condition consisting of a hashref with <b>all</b>  <b>keys</b>  <b>being</b>  <b>fully</b>  <b>qualified</b>
       <b>names</b> <b>of</b> <b>columns</b> <b>declared</b> <b>on</b> <b>the</b> <b>corresponding</b> <b>result</b> <b>source</b>. This boils down to two scenarios:

       •   When    relationship    resolution   is   invoked   after   "$result-&gt;$rel_name",   as   opposed   to
           "$rs-&gt;related_resultset($rel_name)",   the   $result   object   is   passed   to   the   coderef   as
           "$args-&gt;{self_result_object}".

       •   Alternatively  when  the  user-space  invokes resolution via "$result-&gt;set_from_related( $rel_name =&gt;
           $foreign_values_or_object   )",   the   corresponding   data   is   passed   to   the   coderef    as
           "$args-&gt;{foreign_values}",  <b>always</b>  in  the form of a hashref. If a foreign result object is supplied
           (which is valid usage of "set_from_related"), its values will  be  extracted  into  hashref  form  by
           calling get_columns.

       Note  that  the  above scenarios are mutually exclusive, that is you will be supplied none or only one of
       "self_result_object" and "foreign_values". In other words if you define your condition coderef as:

         sub {
           my $args = shift;

           return (
             {
               "$args-&gt;{foreign_alias}.artist" =&gt; { -ident =&gt; "$args-&gt;{self_alias}.artistid" },
               "$args-&gt;{foreign_alias}.year"   =&gt; { '&gt;', "1979", '&lt;', "1990" },
             },
             ! $args-&gt;{self_result_object} ? () : {
               "$args-&gt;{foreign_alias}.artist" =&gt; $args-&gt;{self_result_object}-&gt;artistid,
               "$args-&gt;{foreign_alias}.year"   =&gt; { '&gt;', "1979", '&lt;', "1990" },
             },
             ! $args-&gt;{foreign_values} ? () : {
               "$args-&gt;{self_alias}.artistid" =&gt; $args-&gt;{foreign_values}{artist},
             }
           );
         }

       Then this code:

           my $artist = $schema-&gt;resultset("Artist")-&gt;find({ id =&gt; 4 });
           $artist-&gt;cds_80s-&gt;all;

       Can skip a "JOIN" altogether and instead produce:

           SELECT cds_80s.cdid, cds_80s.artist, cds_80s.title, cds_80s.year, cds_80s.genreid, cds_80s.single_track
             FROM cd cds_80s
             WHERE cds_80s.artist = ?
               AND cds_80s.year &lt; ?
               AND cds_80s.year &gt; ?

       With the bind values:

           '4', '1990', '1979'

       While this code:

           my $cd = $schema-&gt;resultset("CD")-&gt;search({ artist =&gt; 1 }, { rows =&gt; 1 })-&gt;single;
           my $artist = $schema-&gt;resultset("Artist")-&gt;new({});
           $artist-&gt;set_from_related('cds_80s');

       Will properly set the "$artist-&gt;artistid" field of this new object to 1

       Note that in order to be able to use "set_from_related" (and by extension  $result-&gt;create_related),  the
       returned  join  free condition <b>must</b> contain only plain values/deflatable objects. For instance the "year"
       constraint in the above example prevents the relationship from being used to create related objects using
       "$artst-&gt;create_related( cds_80s =&gt; { title =&gt; 'blah' } )" (an exception will be thrown).

       In order to allow the user to go truly crazy when generating a custom  "ON"  clause,  the  $args  hashref
       passed to the subroutine contains some extra metadata. Currently the supplied coderef is executed as:

         $relationship_info-&gt;{cond}-&gt;({
           self_resultsource   =&gt; The resultsource instance on which rel_name is registered
           rel_name            =&gt; The relationship name (does *NOT* always match foreign_alias)

           self_alias          =&gt; The alias of the invoking resultset
           foreign_alias       =&gt; The alias of the to-be-joined resultset (does *NOT* always match rel_name)

           # only one of these (or none at all) will ever be supplied to aid in the
           # construction of a join-free condition

           self_result_object  =&gt; The invocant *object* itself in case of a call like
                                  $result_object-&gt;$rel_name( ... )

           foreign_values      =&gt; A *hashref* of related data: may be passed in directly or
                                  derived via -&gt;get_columns() from a related object in case of
                                  $result_object-&gt;set_from_related( $rel_name, $foreign_result_object )

           # deprecated inconsistent names, will be forever available for legacy code
           self_rowobj         =&gt; Old deprecated slot for self_result_object
           foreign_relname     =&gt; Old deprecated slot for rel_name
         });

       <u>attributes</u>

       The  standard  ResultSet  attributes  may  be used as relationship attributes. In particular, the 'where'
       attribute is useful for filtering relationships:

            __PACKAGE__-&gt;has_many( 'valid_users', 'MyApp::Schema::User',
               { 'foreign.user_id' =&gt; 'self.user_id' },
               { where =&gt; { valid =&gt; 1 } }
           );

       The following attributes are also valid:

       join_type
           Explicitly specifies the type of join to use in the relationship. Any SQL join type  is  valid,  e.g.
           "LEFT" or "RIGHT". It will be placed in the SQL command immediately before "JOIN".

       proxy =&gt; $column | \@columns | \%column
           The  'proxy' attribute can be used to retrieve values, and to perform updates if the relationship has
           'cascade_update' set. The 'might_have' and 'has_one' relationships have this set by default;  if  you
           want a proxy to update across a 'belongs_to' relationship, you must set the attribute yourself.

           \@columns
               An  arrayref containing a list of accessors in the foreign class to create in the main class. If,
               for example, you do the following:

                 MyApp::Schema::CD-&gt;might_have(liner_notes =&gt; 'MyApp::Schema::LinerNotes',
                   undef, {
                     proxy =&gt; [ qw/notes/ ],
                   });

               Then, assuming MyApp::Schema::LinerNotes has an accessor named notes, you can do:

                 my $cd = MyApp::Schema::CD-&gt;<a href="../man1/find.1.html">find</a>(1);
                 $cd-&gt;notes('Notes go here'); # set notes -- LinerNotes object is
                                              # created if it doesn't exist

               For a 'belongs_to relationship, note the 'cascade_update':

                 MyApp::Schema::Track-&gt;belongs_to( cd =&gt; 'MyApp::Schema::CD', 'cd,
                     { proxy =&gt; ['title'], cascade_update =&gt; 1 }
                 );
                 $track-&gt;title('New Title');
                 $track-&gt;update; # updates title in CD

           \%column
               A hashref where each key is the accessor you want installed in the main class, and its  value  is
               the name of the original in the foreign class.

                 MyApp::Schema::Track-&gt;belongs_to( cd =&gt; 'MyApp::Schema::CD', 'cd', {
                     proxy =&gt; { cd_title =&gt; 'title' },
                 });

               This will create an accessor named "cd_title" on the $track result object.

           NOTE: you can pass a nested struct too, for example:

             MyApp::Schema::Track-&gt;belongs_to( cd =&gt; 'MyApp::Schema::CD', 'cd', {
               proxy =&gt; [ 'year', { cd_title =&gt; 'title' } ],
             });

       accessor
           Specifies  the  type  of  accessor  that  should  be  created for the relationship.  Valid values are
           "single" (for when there is only a single related object), "multi" (when  there  can  be  many),  and
           "filter"  (for  when there is a single related object, but you also want the relationship accessor to
           double as a column accessor). For "multi" accessors, an add_to_* method is also created, which  calls
           "create_related" for the relationship.

       is_foreign_key_constraint
           If  you  are using SQL::Translator to create SQL for you and you find that it is creating constraints
           where it shouldn't, or not creating them where it should, set this attribute to a true or false value
           to override the detection of when to create constraints.

       cascade_copy
           If "cascade_copy" is true on a "has_many" relationship for an object, then when you copy  the  object
           all  the  related objects will be copied too. To turn this behaviour off, pass "cascade_copy =&gt; 0" in
           the $attr hashref.

           The behaviour defaults to "cascade_copy =&gt; 1" for "has_many" relationships.

       cascade_delete
           By default, DBIx::Class cascades deletes across "has_many", "has_one" and "might_have" relationships.
           You can disable this behaviour on a per-relationship basis by supplying "cascade_delete =&gt; 0" in  the
           relationship attributes.

           The  cascaded  operations  are  performed  after  the  requested  delete,  so  if your database has a
           constraint on the relationship, it will  have  deleted/updated  the  related  records  or  raised  an
           exception before DBIx::Class gets to perform the cascaded operation.

       cascade_update
           By  default,  DBIx::Class  cascades  updates across "has_one" and "might_have" relationships. You can
           disable this behaviour on a  per-relationship  basis  by  supplying  "cascade_update  =&gt;  0"  in  the
           relationship attributes.

           The  "belongs_to"  relationship  does  not  update  across relationships by default, so if you have a
           'proxy' attribute on a belongs_to and want to use 'update' on it, you must set "cascade_update =&gt; 1".

           This is not a RDMS style cascade update - it purely means that when an object has  update  called  on
           it,  all the related objects also have update called. It will not change foreign keys automatically -
           you must arrange to do this yourself.

       on_delete / on_update
           If you are using SQL::Translator to create SQL for you, you can use these  attributes  to  explicitly
           set  the  desired  "ON  DELETE"  or "ON UPDATE" constraint type. If not supplied the SQLT parser will
           attempt to infer the constraint type by interrogating the attributes of  the  <b>opposite</b>  relationship.
           For  any  'multi'  relationship with "cascade_delete =&gt; 1", the corresponding belongs_to relationship
           will be created with an "ON DELETE CASCADE" constraint. For any relationship bearing "cascade_copy =&gt;
           1" the resulting belongs_to constraint will be "ON UPDATE CASCADE".  If  you  wish  to  disable  this
           autodetection,  and  just  use  the  RDBMS'  default  constraint  type,  pass "on_delete =&gt; undef" or
           "on_delete =&gt; ''", and the same for "on_update" respectively.

       is_deferrable
           Tells SQL::Translator that the foreign key constraint it  creates  should  be  deferrable.  In  other
           words,  the  user  may  request  that  the  constraint  be  ignored until the end of the transaction.
           Currently, only the PostgreSQL producer actually supports this.

       add_fk_index
           Tells SQL::Translator to add an index for this constraint. Can also be specified globally in the args
           to "deploy" in DBIx::Class::Schema or "create_ddl_dir" in DBIx::Class::Schema. Default is on, set  to
           0 to disable.

   <b>register_relationship</b>
       Arguments: $rel_name, $rel_info

       Registers a relationship on the class. This is called internally by DBIx::Class::ResultSourceProxy to set
       up Accessors and Proxies.

   <b>related_resultset</b>
       Arguments: $rel_name
       Return Value: $related_resultset

         $rs = $cd-&gt;related_resultset('artist');

       Returns a DBIx::Class::ResultSet for the relationship named $rel_name.

   <b>$relationship_accessor</b>
       Arguments: none
       Return Value: $result | $related_resultset | undef

         # These pairs do the same thing
         $result = $cd-&gt;related_resultset('artist')-&gt;single;  # has_one relationship
         $result = $cd-&gt;artist;
         $rs = $cd-&gt;related_resultset('tracks');           # has_many relationship
         $rs = $cd-&gt;tracks;

       This  is the recommended way to traverse through relationships, based on the "accessor" name given in the
       relationship definition.

       This will return either a Result or a ResultSet, depending on if the relationship  is  "single"  (returns
       only  one  row)  or  "multi" (returns many rows).  The method may also return "undef" if the relationship
       doesn't exist for this instance (like in the case of "might_have" relationships).

   <b>search_related</b>
       Arguments: $rel_name, $cond?, \%attrs?
       Return Value: $resultset (scalar context) | @result_objs (list context)

       Run a search on a related resultset. The search will be restricted to  the  results  represented  by  the
       DBIx::Class::ResultSet it was called upon.

       See "search_related" in DBIx::Class::ResultSet for more information.

   <b>search_related_rs</b>
       This method works exactly the same as search_related, except that it guarantees a resultset, even in list
       context.

   <b>count_related</b>
       Arguments: $rel_name, $cond?, \%attrs?
       Return Value: $count

       Returns  the  count  of  all the rows in the related resultset, restricted by the current result or where
       conditions.

   <b>new_related</b>
       Arguments: $rel_name, \%col_data
       Return Value: $result

       Create a new result object of the related foreign class.  It will magically set any foreign  key  columns
       of  the  new  object  to the related primary key columns of the source object for you.  The newly created
       result will not be saved into your storage until you call "insert" in DBIx::Class::Row on it.

   <b>create_related</b>
       Arguments: $rel_name, \%col_data
       Return Value: $result

         my $result = $obj-&gt;create_related($rel_name, \%col_data);

       Creates a new result object, similarly to new_related, and also  inserts  the  result's  data  into  your
       storage medium. See the distinction between "create" and "new" in DBIx::Class::ResultSet for details.

   <b>find_related</b>
       Arguments: $rel_name, \%col_data | @pk_values, { key =&gt; $unique_constraint, %attrs }?
       Return Value: $result | undef

         my $result = $obj-&gt;find_related($rel_name, \%col_data);

       Attempt  to  find  a  related  object  using  its  primary  key  or  unique  constraints.   See "find" in
       DBIx::Class::ResultSet for details.

   <b>find_or_new_related</b>
       Arguments: $rel_name, \%col_data, { key =&gt; $unique_constraint, %attrs }?
       Return Value: $result

       Find a result object of a related class.  See "find_or_new" in DBIx::Class::ResultSet for details.

   <b>find_or_create_related</b>
       Arguments: $rel_name, \%col_data, { key =&gt; $unique_constraint, %attrs }?
       Return Value: $result

       Find or create a result object of a related class. See  "find_or_create"  in  DBIx::Class::ResultSet  for
       details.

   <b>update_or_create_related</b>
       Arguments: $rel_name, \%col_data, { key =&gt; $unique_constraint, %attrs }?
       Return Value: $result

       Update or create a result object of a related class. See "update_or_create" in DBIx::Class::ResultSet for
       details.

   <b>set_from_related</b>
       Arguments: $rel_name, $result
       Return Value: not defined

         $book-&gt;set_from_related('author', $author_obj);
         $book-&gt;author($author_obj);                      ## same thing

       Set column values on the current object, using related values from the given related object. This is used
       to  associate  previously  separate  objects, for example, to set the correct author for a book, find the
       Author object, then call set_from_related on the book.

       This is called internally when you pass existing objects as values to "create" in DBIx::Class::ResultSet,
       or pass an object to a belongs_to accessor.

       The columns are only set in the local copy of the object, call update to update them in the storage.

   <b>update_from_related</b>
       Arguments: $rel_name, $result
       Return Value: not defined

         $book-&gt;update_from_related('author', $author_obj);

       The same as "set_from_related", but the changes are immediately updated in storage.

   <b>delete_related</b>
       Arguments: $rel_name, $cond?, \%attrs?
       Return Value: $underlying_storage_rv

       Delete any related row, subject to the given conditions.  Internally, this calls:

         $self-&gt;search_related(@_)-&gt;delete

       And returns the result of that.

   <b>add_to_$rel</b>
       <b>Currently</b> <b>only</b> <b>available</b> <b>for</b> <b>"has_many",</b> <b>"many_to_many"</b> <b>and</b> <b>'multi'</b> <b>type</b> <b>relationships.</b>

       <u>has_many</u> <u>/</u> <u>multi</u>

       Arguments: \%col_data
       Return Value: $result

       Creates/inserts a new result object.  Internally, this calls:

         $self-&gt;create_related($rel, @_)

       And returns the result of that.

       <u>many_to_many</u>

       Arguments: (\%col_data | $result), \%link_col_data?
       Return Value: $result

         my $role = $schema-&gt;resultset('Role')-&gt;<a href="../man1/find.1.html">find</a>(1);
         $actor-&gt;add_to_roles($role);
             # creates a My::DBIC::Schema::ActorRoles linking table result object

         $actor-&gt;add_to_roles({ name =&gt; 'lead' }, { salary =&gt; 15_000_000 });
             # creates a new My::DBIC::Schema::Role result object and the linking table
             # object with an extra column in the link

       Adds a linking table object. If the first argument is a hash reference, the  related  object  is  created
       first  with the column values in the hash. If an object reference is given, just the linking table object
       is created. In either case, any additional column values for the linking table object can be specified in
       "\%link_col_data".

       See "many_to_many" in DBIx::Class::Relationship for additional details.

   <b>set_$rel</b>
       <b>Currently</b> <b>only</b> <b>available</b> <b>for</b> <b>"many_to_many"</b> <b>relationships.</b>

       Arguments: (\@hashrefs_of_col_data | \@result_objs), $link_vals?
       Return Value: not defined

         my $actor = $schema-&gt;resultset('Actor')-&gt;<a href="../man1/find.1.html">find</a>(1);
         my @roles = $schema-&gt;resultset('Role')-&gt;search({ role =&gt;
            { '-in' =&gt; ['Fred', 'Barney'] } } );

         $actor-&gt;set_roles(\@roles);
            # Replaces all of $actor's previous roles with the two named

         $actor-&gt;set_roles(\@roles, { salary =&gt; 15_000_000 });
            # Sets a column in the link table for all roles

       Replace all the related objects with the given reference to a list of objects. This does  a  "delete"  <b>on</b>
       <b>the</b>  <b>link</b>  <b>table</b>  <b>resultset</b> to remove the association between the current object and all related objects,
       then calls "add_to_$rel" repeatedly to link all the new objects.

       Note that this means that this method will <b>not</b> delete any objects in the table on the right side  of  the
       relation, merely that it will delete the link between them.

       Due  to a mistake in the original implementation of this method, it will also accept a list of objects or
       hash references. This is <b>deprecated</b> and will be removed in a future version.

   <b>remove_from_$rel</b>
       <b>Currently</b> <b>only</b> <b>available</b> <b>for</b> <b>"many_to_many"</b> <b>relationships.</b>

       Arguments: $result
       Return Value: not defined

         my $role = $schema-&gt;resultset('Role')-&gt;<a href="../man1/find.1.html">find</a>(1);
         $actor-&gt;remove_from_roles($role);
             # removes $role's My::DBIC::Schema::ActorRoles linking table result object

       Removes the link between the current object and the related object. Note that the related  object  itself
       won't  be  deleted  unless  you  call -&gt;<b>delete()</b> on it. This method just removes the link between the two
       objects.

</pre><h4><b>FURTHER</b> <b>QUESTIONS?</b></h4><pre>
       Check the list of additional DBIC resources.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This module is free software copyright by the DBIx::Class (DBIC) authors. You can redistribute it  and/or
       modify it under the same terms as the DBIx::Class library.

perl v5.40.0                                       2025-02-01               <u>DBIx::Class::Relationship::<a href="../man3pm/Base.3pm.html">Base</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>