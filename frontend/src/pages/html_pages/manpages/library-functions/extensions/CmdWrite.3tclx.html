<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TclCommandWriting - Writing C language extensions to Tcl.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tclx8.4-doc">tclx8.4-doc_8.4.1-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       TclCommandWriting - Writing C language extensions to Tcl.

</pre><h4><b>OVERVIEW</b></h4><pre>
       This  document  is intended to help the programmer who wishes to extend Tcl with C language routines.  It
       should also be useful to someone wishing to add Tcl to an existing editor, communications program, window
       manager, etc.  C programming information can also be found in the <u>*.3</u> manual pages in the  <u>doc</u>  directory
       of the Berkeley distribution, and in the <u>*.3</u> manpages in the <u>man</u> directory of Extended Tcl.

</pre><h4><b>WRITING</b> <b>TCL</b> <b>EXTENSIONS</b> <b>IN</b> <b>C</b></h4><pre>
       All  C-based  Tcl commands are called with four arguments: a client data pointer, an interpreter pointer,
       an argument count and a pointer to an array of pointers to character strings containing the Tcl arguments
       to the command.

       A simple Tcl extension in C is now presented, and described below:

           #include "tcl.h"

           int App_EchoCmd(clientData, interp, argc, argv)
               void       *clientData;
               Tcl_Interp *interp;
               int         argc;
               char      **argv;
           {
                   int i;

                   for (i = 1; i &lt; argc; i++) {
                           printf("%s",argv[i]);
                     if (i &lt; argc - 1) printf(" ");
                   }
                   printf("\n");
                   return TCL_OK;
           }

       The client data pointer will be described later.

       The interpreter pointer is the ``key'' to an interpreter.  It is returned by <b>Tcl_CreateInterp</b> and is used
       extensively within Tcl, and will be by  your  C  extensions.   The  data  structure  pointed  to  by  the
       interpreter  pointer,  and  all  of  the  subordinate  structures  that  branch  off of it, make up a Tcl
       interpreter, which includes all of the currently defined procedures, commands, variables, arrays and  the
       execution state of that interpreter.  (For more information on creating and deleting interpreters, please
       examine  the  <b><a href="../man3/CrtInterp.3.html">CrtInterp</a></b>(3)  manpage  in  the  Berkeley  Tcl  distribution.   For  information on creating
       interpreters that include the commands provided by Extended Tcl, check out the  <b><a href="../man3/TclX_Init.3.html">TclX_Init</a></b>(3)  manpage  of
       Extended  Tcl.  For a manual page describing the user-visible fields of a Tcl interpreter, please look at
       <b><a href="../man3/Interp.3.html">Interp</a></b>(3) in Berkeley Tcl.)

       The argument count and pointer to an array of pointers to textual arguments is handled by your C code  in
       the  same  manner  that  you  would  use  in writing a C <u>main</u> function -- the argument count and array of
       pointers works the same as in a C <u>main</u> call; pointers to the arguments to the function are  contained  in
       the  <u>argv</u> array.  Similar to a C main, the first argument (<u>argv[0]</u>) is the name the routine was called as
       (in a main, the name the program was invoked as).

       In the above example, all of the arguments are output with a space between each one  by  looping  through
       <u>argv</u>  from  one to the argument count, <u>argc</u>, and a newline is output to terminate the line -- an ``echo''
       command.

       All arguments from a Tcl call to a Tcl C extension are passed as strings.   If  your  C  routine  expects
       certain  numeric  arguments,  your  routine must first convert them using the <b>Tcl_GetInt</b> or <b>Tcl_GetDouble</b>
       function, Extended Tcl's <b>Tcl_GetLong</b> or <b>Tcl_GetUnsigned</b>, or some  other  method  of  your  own  devising.
       Likewise  for  converting  boolean  values,  <b>Tcl_GetBoolean</b> should be used.  These routines automatically
       leave an appropriate error message in the Tcl interpreter's result  buffer  and  return  <b>TCL_ERROR</b>  if  a
       conversion  error occurs.   (For more information on these routines, please look at the <b><a href="../man3/GetInt.3.html">GetInt</a></b>(3) manpage
       in the Berkeley Tcl distribution.)

       Likewise, if you program produces a numeric result, it should return a string equivalent to that  numeric
       value.  A common way of doing this is something like...

            sprintf(interp-&gt;result, "%ld", result);

       Writing  results directly into the interpreter's result buffer is only good for relatively short results.
       Tcl has a function, <b>Tcl_SetResult</b>, which provides the ability for your C extensions to return very  large
       strings to Tcl, with the ability to tell the interpreter whether it ``owns'' the string (meaning that Tcl
       should  delete the string when it's done with it), that the string is likely to be changed or overwritten
       soon (meaning that Tcl should make a copy of the string right away), or that the string won't change  (so
       Tcl  can  use the string as is and not worry about it).  Understanding how results are passed back to Tcl
       is essential to the  C  extension  writer.   Please  study  the  <b><a href="../man3/SetResult.3.html">SetResult</a></b>(3)  manual  page  in  the  Tcl
       distribution.

       Sophisticated  commands  should  verify their arguments whenever possible, both by examining the argument
       count, by verifying that numeric fields are really numeric, that values are in range (when  their  ranges
       are known), and so forth.

       Tcl  is  designed  to  be as bullet-proof as possible, in the sense that no Tcl program should be able to
       cause Tcl to dump core.  Please carry this notion forward with your C extensions by validating  arguments
       as above.

</pre><h4><b>ANOTHER</b> <b>C</b> <b>EXTENSION</b> <b>-</b> <b>THE</b> <b>MAX</b> <b>COMMAND</b></h4><pre>
       In  the command below, two or more arguments are compared and the one with the maximum value is returned,
       if all goes well.  It is an error if there are fewer than three arguments (the  pointer  to  the  ``max''
       command text itself, <u>argv[0]</u>, and pointers to at least two arguments to compare the values of).

       This  routine  also  shows  the use of the programmer labor-saving <b>Tcl_AppendResult</b> routine.  See the Tcl
       manual page, <b><a href="../man3/SetResult.3.html">SetResult</a></b>(3), for details.  Also examine the calls  <b>Tcl_AddErrorInfo</b>,  <b>Tcl_SetErrorCode</b>  and
       <b>Tcl_PosixError</b> documented in the Tcl manual page <b><a href="../man3/AddErrInfo.3.html">AddErrInfo</a></b>(3).

           int
           Tcl_MaxCmd (clientData, interp, argc, argv)
               char       *clientData;
               Tcl_Interp *interp;
               int         argc;
               char      **argv;
           {
               int maxVal = MININT;
               int maxIdx = 1;
               int value, idx;

               if (argc &lt; 3) {
                   Tcl_AppendResult (interp, "bad # arg: ", argv[0],
                                     " num1 num2 [..numN]", (char *)NULL);
                   return TCL_ERROR;
               }

               for (idx = 1; idx &lt; argc; idx++) {
                   if (Tcl_GetInt (argv[idx], 10, &amp;Value) != TCL_OK)
                       return TCL_ERROR;

                   if (value &gt; maxVal) {
                       maxVal = value;
                       maxIdx = idx;
                   }
               }
               Tcl_SetResult (interp, argv [maxIdx], TCL_VOLATILE);
               return TCL_OK;
           }

       When  Tcl-callable  functions  complete,  they  should  normally  return  <b>TCL_OK</b> or <b>TCL_ERROR</b>.  <b>TCL_OK</b> is
       returned when the command succeeded and <b>TCL_ERROR</b> is  returned  when  the  command  has  failed  in  some
       abnormal  way.  <b>TCL_ERROR</b> should be returned for all syntax errors, non-numeric values (when numeric ones
       were expected), and so forth.  Less clear in some cases is whether  Tcl  errors  should  be  returned  or
       whether  a  function should just return a status value.  For example, end-of-file during a <u>gets</u> returns a
       status, but <u>open</u> returns an error if the open fails.  Errors can be caught from Tcl  programs  using  the
       <u>catch</u> command.  (See Tcl's <b>catch</b>(n) and <b>error</b>(n) manual pages.)

       Less  common  return values are <b>TCL_RETURN</b>, <b>TCL_BREAK</b> and <b>TCL_CONTINUE</b>.  These are used if you are adding
       new control and/or looping structures to Tcl.  To see these values in action, examine the source code  to
       Tcl's <u>while</u>, <u>for</u> and <u>if</u>, and Extended Tcl's <u>loop</u> commands.

       Note the call to <u>Tcl_SetResult</u> in the above command to set the return value to Tcl.  <b>TCL_VOLATILE</b> is used
       because the memory containing the result will be freed upon the function's return.

</pre><h4><b>ANOTHER</b> <b>C</b> <b>EXTENSION</b> <b>-</b> <b>THE</b> <b>LREVERSE</b> <b>COMMAND</b></h4><pre>
       In the command below, one list is passed as an argument, and a list containing all of the elements of the
       list  in  reverse order is returned.  It is an error if anything other than two arguments are passed (the
       pointer to the ``lreverse'' command text itself, <u>argv[0]</u>, and a pointer to the list to reverse.

       Once <u>lreverse</u> has determined that it has received the  correct  number  of  arguments,  <b>Tcl_SplitList</b>  is
       called to break the list into an <u>argc</u> and <u>argv</u> array of pointers.

       <u>lreverse</u>  then  operates on the array of pointers, swapping them from lowest to highest, second-lowest to
       second-highest, and so forth.

       Finally <b>Tcl_Merge</b> is calleds to create a single new string containing the reversed list and it is set  as
       the  result  via <b>Tcl_SetResult</b>.  Note that <b>TCL_DYNAMIC</b> is used to tell <b>Tcl_SetResult</b> that it now owns the
       string and it is up to Tcl to free the string when it is done with it.

       Note that it <u>is</u> safe to play around with the <u>argv</u> list like this, and that a single call to <b>ckfree</b> can be
       made to free all the data returned by <b>Tcl_SplitList</b> in this manner.

       int
       Tcl_LreverseCmd(notUsed, interp, argc, argv)
           ClientData notUsed;           /* Not used. */
           Tcl_Interp *interp;           /* Current interpreter. */
           int argc;                /* Number of arguments. */
           char **argv;             /* Argument strings. */
       {
           int listArgc, lowListIndex, hiListIndex;
           char **listArgv;
           char *temp, *resultList;

           if (argc != 2) {
            Tcl_AppendResult(interp, "wrong # args: should be
                 " list
            return TCL_ERROR;
           }

           if (Tcl_SplitList(interp, argv[1], &amp;listArgc, &amp;listArgv) != TCL_OK) {
            return TCL_ERROR;
           }
           for (lowListIndex = 0, hiListIndex = listArgc;
             --hiListIndex &gt; lowListIndex; lowListIndex++) {
            temp = listArgv[lowListIndex];
            listArgv[lowListIndex] = listArgv[hiListIndex];
            listArgv[hiListIndex] = temp;
           }
           resultList = Tcl_Merge (listArgc, listArgv);
           ckfree (listArgv);
           Tcl_SetResult (interp, resultList, TCL_DYNAMIC);
           return TCL_OK;
       }

</pre><h4><b>INSTALLING</b> <b>YOUR</b> <b>COMMAND</b></h4><pre>
       To install your command into Tcl  you  must  call  <b>Tcl_CreateCommand</b>,  passing  it  the  pointer  to  the
       interpreter  you  want  to install the command into, the name of the command, a pointer to the C function
       that implements the command, a client data pointer, and a pointer to an optional callback routine.

       The client data pointer and the callback routine will be described later.

       For example, for the max function above  (which,  incidentally,  comes  from  TclX's  tclXmath.c  in  the
       <u>TclX7.4/src</u> directory):

           Tcl_CreateCommand (interp, "max", Tcl_MaxCmd, (ClientData)NULL,
                             (void (*)())NULL);

       In  the  above  example, the max function is added to the specified interpreter.  The client data pointer
       and callback function pointer are NULL.  (For complete information on <b>Tcl_CreateCommand</b> and its companion
       routine,  <b>Tcl_CommandInfo</b>,  please  examine  the  <b><a href="../man3/CrtCommand.3.html">CrtCommand</a></b>(3)  command  page  in   the   Berkeley   Tcl
       distribution.)

</pre><h4><b>DYNAMIC</b> <b>STRINGS</b></h4><pre>
       <u>Dynamic</u>  <u>strings</u> are an important abstraction that first became available with Tcl 7.0.  Dynamic strings,
       or <u>DStrings</u>, provide a way to build up arbitrarily long strings through a repeated process  of  appending
       information to them.  DStrings reduce the amount of allocating and copying required to add information to
       a  string.  Further, they simplify the process of doing so.  For complete information on dynamic strings,
       please examine the <b><a href="../man3/DString.3.html">DString</a></b>(3) manual page in the Berkeley Tcl distribution.

</pre><h4><b>CLIENT</b> <b>DATA</b></h4><pre>
       The client data pointer provides a means for Tcl commands to have data associated with them that  is  not
       global  to  the  C program nor included in the Tcl core.  Client data is essential in a multi-interpreter
       environment (where a single program has created and is making use of multiple Tcl interpreters) for the C
       routines to maintain any permanent data they need on a per-interpreter basis.  Otherwise there  would  be
       reentrancy  problems.   Tcl  solves  this  through the client data mechanism.  When you are about to call
       <b>Tcl_CreateCommand</b> to add a new command to an interpreter, if that command needs to keep  some  read/write
       data  across  invocations, you should allocate the space, preferably using <b>ckalloc</b>, then pass the address
       of that space as the ClientData pointer to <b>Tcl_CreateCommand</b>.

       When your command is called from Tcl, the ClientData pointer you gave to <b>Tcl_CreateCommand</b> when you added
       the command to that interpreter is passed to your  C  routine  through  the  ClientData  pointer  calling
       argument.

       Commands  that  need  to  share this data with one another can do so by using the same ClientData pointer
       when the commands are added.

       It is important to note that the Tcl extensions in the <u>tclX7.4/src</u> directory have had all of  their  data
       set  up  in  this  way.   Since  release 6.2, Extended Tcl has supported multiple interpreters within one
       invocation of Tcl.

</pre><h4><b>THEORY</b> <b>OF</b> <b>HANDLES</b></h4><pre>
       Sometimes you need to have a data element that isn't readily representable as a string  within  Tcl,  for
       example  a  pointer  to a complex C data structure.  It is not a good idea to try to pass pointers around
       within Tcl as strings by converting them to and from hex or integer representations, for example.  It  is
       too easy to mess one up, and the likely outcome of doing that is a core dump.

       Instead  we have developed and made use of the concept of <u>handles</u>.  Handles are identifiers a C extension
       can pass to, and accept from, Tcl to make the transition between what your C code knows something as  and
       what  name  Tcl  knows  it  by  to  be  as safe and painless as possible.  For example, the stdio package
       included in Tcl uses file handles.  When you open a file from Tcl, a handle is returned of the form <b>file</b><u>n</u>
       where <u>n</u> is a file number.  When you pass the file handle back to <u>puts</u>, <u>gets</u>, <u>seek</u>, <u>flush</u>  and  so  forth,
       they  validate  the file handle by checking the the <b>file</b> text is present, then converting the file number
       to an integer that they use to look into a data structure of pointers to Tcl open file structures,  which
       contain  a  Unix file descriptor, flags indicating whether or not the file is currently open, whether the
       file is a file or a pipe and so forth.

       Handles have proven so useful that, as of release 6.1a, general support has been added for them.  If  you
       need  a  similar  capability,  it  would  be best to use the handle routines, documented in <b><a href="../man3/Handles.3.html">Handles</a></b>(3) in
       Extended Tcl.  We recommend that you use a unique-to-your-package textual handle coupled with a  specific
       identifier  and  let the handle management routines validate it when it's passed back.  It is much easier
       to track down a bug with an implicated handle named something like <b>file4</b> or <b>bitmap6</b> than just <b>6</b>.

</pre><h4><b>TRACKING</b> <b>MEMORY</b> <b>CORRUPTION</b> <b>PROBLEMS</b></h4><pre>
       Occasionally you may write code that scribbles past the end of an allocated piece of memory.  The  memory
       debugging routines included in Tcl can help find these problems.  See <u>Memory(TCL)</u> for details.

</pre><h4><b>INSTALLING</b> <b>YOUR</b> <b>EXTENSIONS</b> <b>INTO</b> <b>EXTENDED</b> <b>TCL</b></h4><pre>
       To add your extensions to Extended Tcl, you must compile them and cause them to be linked with TclX.  For
       the  routines  to  be  linked  into  the  <b>tcl</b> and <b>wishx</b> executables, they must be referenced (directly or
       indirectly) from TclX.  For these extensions to be visible as Tcl commands, they must be  installed  into
       Tcl with <b>Tcl_CreateCommand</b>.

       Application-specific  startup  is  accomplished  by  creating  or  editing  the <u>Tcl_AppInit</u> function.  In
       <u>Tcl_AppInit</u> you should add a call to an  application-specific  init  function  which  you  create.   This
       function  should  take  the address of the interpreter it should install its commands into, and it should
       install those commands with <b>Tcl_CreateCommand</b> and do  any  other  application-specific  startup  that  is
       necessary.

       The  naming  convention  for  application  startup  routines  is  <b>App_Init</b>, where <u>App</u> is the name of your
       application.  For example, to add an application named <u>cute</u> one would create  a  <u>Cute_Init</u>  routine  that
       expected a <b>Tcl_Interp</b> pointer as an argument, and add the following code to <u>Tcl_AppInit</u>:

           if (Cute_Init (interp) == TCL_ERROR) {
            return TCL_ERROR;
           }

       As  you  can  guess  from  the above example, if your init routine is unable to initialize, it should use
       <b>Tcl_AppendResult</b> to provide some kind of useful error message back to  TclX,  then  return  <b>TCL_ERROR</b>  to
       indicate that an error occurred.  If the routine executed successfully, it should return <b>TCL_OK</b>.

       When  you examine <u>Tcl_AppInit</u>, note that there is one call already there to install an application -- the
       call to <u>TclX_Init</u> installs Extended Tcl into the Tcl core.

</pre><h4><b>MAKING</b> <b>APPLICATION</b> <b>INFORMATION</b> <b>VISIBLE</b> <b>FROM</b> <b>EXTENDED</b> <b>TCL</b></h4><pre>
       TclX's <b>infox</b> command can return several pieces of information relevant to  Extended  Tcl,  including  the
       application's  name, descriptive name, patch level and version.  Your application's startup can set these
       variables to application-specific values.  If it doesn't, they are given default values for Extended Tcl.

       To set these values, first be sure that you include either <b>tclExtend.h</b> or <b>tclExtdInt.h</b>  from  the  source
       file  that  defines  your init routine.  This will create external declarations for the variables.  Then,
       set the variables in your init route, for example:

           tclAppName = "cute";
           tclAppLongName = "Call Unix/Tcl Environment";
           tclAppVersion = "2.1";

       Note that the default values are set by <u>TclX_Init</u>, so if you wish to override them, you  must  call  your
       init routine in <u>Tcl_AppInit</u> after its call to <u>TclX_Init</u>.

</pre><h4><b>EXTENDED</b> <b>TCL</b> <b>EXIT</b></h4><pre>
       When  Extended  Tcl exits, <b>Tcl_DeleteInterp</b> may be called to free memory used by Tcl -- normally, this is
       only called if <b>TCL_MEM_DEBUG</b> was defined, since Unix will return all of the allocated memory back to  the
       system, anyway.  If <b>TCL_MEM_DEBUG</b> was defined, it is called so that any memory that was allocated without
       ever  being  freed  can  be  detected.   This greatly reduces the amount of work to detect and track down
       memory leaks, a situation where some piece of your code allocates memory repeatedly without ever  freeing
       it, or without always freeing it.

       It  is  often  necessary  for an application to perform special cleanup functions upon the deletion of an
       interpreter as well.  To facilitate this activity,  Tcl  provides  the  ability  to  perform  a  function
       callback  when  an interpreter is deleted.  To arrange for a C function to be called when the interpreter
       is deleted, call <b>Tcl_CallWhenDeleted</b> from your application initialization routine.  For details on how to
       use this function, read the <b><a href="../man3/CallDel.3.html">CallDel</a></b>(3) manual page that ships with Berkeley Tcl.

</pre><h4><b>EXECUTING</b> <b>TCL</b> <b>CODE</b> <b>FROM</b> <b>YOUR</b> <b>C</b> <b>EXTENSION</b></h4><pre>
       Suppose you are in the middle of coding a C extension and  you  realize  that  you  need  some  operation
       performed, one that would be simple from Tcl but possibly excruciating to do directly in C.  Tcl provides
       the  <b>Tcl_Eval</b>,  <b>Tcl_VarEval</b>,  <b>Tcl_EvalFile</b>  and <b>Tcl_GlobalEval</b> functions for the purpose of executing Tcl
       code from within a C extension.  The results of the call will be in <b>interp-&gt;result</b>.  For more information
       please consult the <b><a href="../man3/Eval.3.html">Eval</a></b>(3) manual page within the Tcl distribution.

</pre><h4><b>ACCESSING</b> <b>TCL</b> <b>VARIABLES</b> <b>AND</b> <b>ARRAYS</b> <b>FROM</b> <b>YOUR</b> <b>C</b> <b>EXTENSIONS</b></h4><pre>
       Tcl variables and arrays can be read from a C extension through the <b>Tcl_GetVar</b> and <b>Tcl_GetVar2</b> functions,
       and set from C extensions through the <b>Tcl_SetVar</b> and <b>Tcl_SetVar2</b> functions.  They can also be  unset  via
       the  <b>Tcl_UnsetVar</b> and <b>Tcl_UnsetVar2</b> functions.  For complete information on these functions, please refer
       to the <b><a href="../man3/SetVar.3.html">SetVar</a></b>(3) manual page in the <u>doc</u> directory of the Berkeley Tcl distribution.

</pre><h4><b>LINKING</b> <b>TCL</b> <b>VARIABLES</b> <b>TO</b> <b>C</b> <b>VARIABLES</b></h4><pre>
       <b>Tcl_LinkVar</b> and <b>Tcl_UnlinkVar</b>  can  be  used  to  automatically  keep  Tcl  variables  synchronized  with
       corresponding C variables.  Once a Tcl variable has been linked to a C variable with <b>Tcl_LinkVar</b>, anytime
       the  Tcl  variable  is  read  the  value of the C variable will be returned, and when the Tcl variable is
       written, the C variable will be updated with the new value.

       <b>Tcl_LinkVar</b> uses variable traces to keep the Tcl variable named by <u>varName</u> in sync with the C variable at
       the address given by <u>addr</u>.

       Whenever the Tcl variable is read the value of the C variable will be  returned,  and  whenever  the  Tcl
       variable is written the C variable will be updated to have the same value.

       <u>Int</u>,  <u>double</u>,  <u>boolean</u>  and  <u>char</u>  <u>*</u>  variables  are supported.  For more information, please examine the
       <b><a href="../man3/LinkVar.3.html">LinkVar</a></b>(3) manual page in the Berkeley Tcl distribution.

</pre><h4><b>ADDING</b> <b>NEW</b> <b>MATH</b> <b>FUNCTIONS</b> <b>TO</b> <b>TCL</b></h4><pre>
       As of Tcl version 7.0, math  functions  such  as  <u>sin</u>,  <u>cos</u>,  etc,  are  directly  supported  within  Tcl
       expressions.   These  obsolete the Extended Tcl commands that provided explicit calls for these functions
       for many releases.

       New math functions can be added  to  Tcl,  or  existing  math  functions  can  be  replaced,  by  calling
       <b>Tcl_CreateMathFunc</b>.

       For  more  information  on  adding  math  functions,  please examine the <b><a href="../man3/CrtMathFnc.3.html">CrtMathFnc</a></b>(3) manual page in the
       Berkeley Tcl distribution.

</pre><h4><b>PERFORMING</b> <b>TILDE</b> <b>SUBSTITUTIONS</b> <b>ON</b> <b>FILENAMES</b></h4><pre>
       The <b>Tcl_TildeSubst</b> function is available to  C  extension  writers  to  perform  tilde  substitutions  on
       filenames.   If  the name starts with a ``~'' character, the function returns a new string where the name
       is replaced with the home directory  of  the  given  user.   For  more  information  please  consult  the
       <b><a href="../man3/TildeSubst.3.html">TildeSubst</a></b>(3) manual page in the Berkeley Tcl distribution.

</pre><h4><b>SETTING</b> <b>THE</b> <b>RECURSION</b> <b>LIMIT</b></h4><pre>
       Tcl  has  a  preset  recursion  limit  that limits the maximum allowable nesting depth of calls within an
       interpreter.  This is useful for detecting infinite recursions before other limits such  as  the  process
       memory limit or, worse, available swap space on the system, are exceeded.

       The default limit is just a guess, however, and applications that make heavy use of recursion may need to
       call  <b>Tcl_SetRecursionLimit</b>  to  raise this limit.  For more information, please consult the <b><a href="../man3/SetRecLmt.3.html">SetRecLmt</a></b>(3)
       manual page in the Berkeley Tcl distribution.

</pre><h4><b>HANDLING</b> <b>SIGNALS</b> <b>FROM</b> <b>TCL</b> <b>EXTENSIONS</b></h4><pre>
       If an event such as a signal occurs while a Tcl script is being executed, it isn't safe to do much in the
       signal handling routine -- the Tcl environment cannot be safely manipulated  at  this  point  because  it
       could  be  in  the  middle  of  some  operation, such as updating pointers, leaving the interpreter in an
       unreliable state.

       The only safe approach is to set a flag indicating that the event occurred, then handle the  event  later
       when the interpreter has returned to a safe state, such as after the current Tcl command completes.

       The  <b>Tcl_AsyncCreate</b>,  <b>Tcl_AsyncMark</b>,  <b>Tcl_AsyncInvoke</b>,  and  <b>Tcl_AsyncDelete</b>  functions  provide  a safe
       mechanism for dealing with signals and other asynchronous events.  For more information  on  how  to  use
       this capability, please refer to the <b><a href="../man3/Async.3.html">Async</a></b>(3) manual page in the Berkeley Tcl distribution.

</pre><h4><b>PARSING</b> <b>BACKSLASH</b> <b>SEQUENCES</b></h4><pre>
       The <b>Tcl_Backslash</b> function is called to parse Tcl backslash sequences.  These backslash sequences are the
       usual  sort  that  you  see  in the C programming language, such as <b>\n</b> for newline, <b>\r</b> for return, and so
       forth.  <b>Tcl_Backslash</b> parses a single backslash sequence and returns a single character corresponding  to
       the backslash sequence.

       For  more  info on this call, look at the <b><a href="../man3/Backslash.3.html">Backslash</a></b>(3) manual page in the Berkeley Tcl distribution.  For
       information on the valid backslash sequences, consult the summary of Tcl language syntax, <b>Tcl</b>(n)  in  the
       same distribution.

</pre><h4><b>HASH</b> <b>TABLES</b></h4><pre>
       <u>Hash</u>  <u>tables</u>  provide  Tcl  with  a high-performance facility for looking up and managing key-value pairs
       located and maintained in memory.  Tcl uses hash tables internally to locate procedure  definitions,  Tcl
       variables, array elements, file handles and so forth.  Tcl makes the hash table functions accessible to C
       extension writers as well.

       Hash  tables  grow  automatically  to  maintain  efficiency,  rather  than exposing the table size to the
       programmer at allocation time, which would needlessly add  complexity  to  Tcl  and  would  be  prone  to
       inefficiency  due to the need to guess the number of items that will go into the table, and the seemingly
       inevitable growth in amount of data processed per run over the life of the program.

       For more information on hash tables,  please  consult  the  <b><a href="../man3/Hash.3.html">Hash</a></b>(3)  manual  page  in  the  Berkeley  Tcl
       distribution.

</pre><h4><b>TRACING</b> <b>VARIABLE</b> <b>ACCESSES</b></h4><pre>
       The  C  extension writer can arrange to have a C routine called whenever a Tcl variable is read, written,
       or unset.  Variable traces are the mechanism by which Tk toolkit widgets such as radio and  checkbuttons,
       messages  and  so forth update without Tcl programmer intervention when their data variables are changed.
       They are also used by the routine that links Tcl and C variables, <b>Tcl_LinkVar</b>, described above.

       <b>Tcl_TraceVar</b> is called to establish a variable trace.  Entire arrays and individual array elements can be
       traced as well.  If the programmer already has an array name  in  one  string  and  a  variable  name  in
       another,  <b>Tcl_TraceVar2</b>  can be called.  Calls are also available to request information about traces and
       to delete them.

       For more information on variable traces,  consult  the  <b><a href="../man3/TraceVar.3.html">TraceVar</a></b>(3)  manual  page  in  the  Berkeley  Tcl
       distribution.

</pre><h4><b>TRACING</b> <b>EXECUTION</b></h4><pre>
       Tcl  has the ability to call C routines for every command it executes, up to a specified depth of nesting
       levels.  The command <b>Tcl_CreateTrace</b> creates an execution trace; <b>Tcl_DeleteTrace</b> deletes it.

       Command tracing is used in Extended Tcl to implement the <u>cmdtrace</u>  Tcl  command,  a  useful  command  for
       debugging Tcl applications.

       For  complete  information  on  execution  tracing,  please  look  at the <b><a href="../man3/CrtTrace.3.html">CrtTrace</a></b>(3) manual pages in the
       Berkeley Tcl distribution.

</pre><h4><b>EVALUATING</b> <b>TCL</b> <b>EXPRESSIONS</b> <b>FROM</b> <b>C</b></h4><pre>
       <b>Tcl_ExprLong</b>, <b>Tcl_ExprDouble</b>, <b>Tcl_ExprBool</b>, and <b>Tcl_ExprString</b> can be called to evaluate Tcl  expressions
       from  within  a  C  routine.  Depending on the routine called, the result is either a C <u>long</u>, a <u>double</u>, a
       boolean (<u>int</u> with a value of <b>0</b> or <u>1</u>), or a <u>char</u> <u>*</u> (pointed to by <u>interp-&gt;result</u>).

       For complete information on evaluating Tcl expressions from C, you are invited to examine the <b><a href="../man3/ExprLong.3.html">ExprLong</a></b>(3)
       manpage in the Berkeley Tcl distribution.

</pre><h4><b>PATTERN</b> <b>MATCHING</b></h4><pre>
       The  <b>Tcl_StringMatch</b>  function  can  be  called  to  see  if  a  string  matches  a  specified   pattern.
       <b>Tcl_StringMatch</b>  is called by the Tcl <u>string</u> <u>match</u> command, so the format for patterns is identical.  The
       pattern format is similar to the one used by the C-shell; <b>string</b>(n) describes this format.

       More information about <b>Tcl_StringMatch</b> is available in  the  <b><a href="../man3/StrMatch.3.html">StrMatch</a></b>(3)  manpage  in  the  Berkeley  Tcl
       distribution.

</pre><h4><b>REGULAR</b> <b>EXPRESSION</b> <b>PATTERN</b> <b>MATCHING</b></h4><pre>
       <b>Tcl_RegExpMatch</b>   can   be   called   to  determine  whether  a  string  matches  a  regular  expression.
       <b>Tcl_RegExpMatch</b> is used internally by the <u>regexp</u> Tcl command.

       For more information on this  function,  please  consult  the  <b><a href="../man3/RegExp.3.html">RegExp</a></b>(3)  manpage  in  the  Berkeley  Tcl
       distribution.

</pre><h4><b>MANIPULATING</b> <b>TCL</b> <b>LISTS</b> <b>FROM</b> <b>C</b> <b>EXTENSIONS</b></h4><pre>
       The C extension writer often needs to create, manipulate and decompose Tcl lists.  <b>Tcl_SplitList</b> parses a
       list  into  an  <u>argv</u>  and  <u>argc</u>  like  to  the  way command-line arguments are passed to a Tcl extension.
       <b>Tcl_Merge</b>, likewise, creates a single string (pointer to a <u>char</u> <u>*</u>) from an <u>argv</u> and <u>argc</u>.

       Two routines, <b>Tcl_ScanElement</b> and <b>Tcl_ConvertElement</b>, do most of the work of <b>Tcl_Merge</b>, and may  also  be
       of use to the C programmer.

       For  more  information on these commands, please consult the <b><a href="../man3/SplitList.3.html">SplitList</a></b>(3) manual page in the Berkeley Tcl
       distribution.

</pre><h4><b>CONCATENATING</b> <b>STRINGS</b></h4><pre>
       <b>Tcl_Concat</b> concatenates zero or more strings into a single  string.   The  strings  are  space-separated.
       <b>Tcl_Concat</b>  works  like  <u>Tcl_Merge</u>,  except that <b>Tcl_Concat</b> does not attempt to make the resulting string
       into a valid Tcl list.

       <b>Tcl_Concat</b> is documented in the <b><a href="../man3/Concat.3.html">Concat</a></b>(3) manpage in the Berkeley Tcl distribution.

</pre><h4><b>DETECTING</b> <b>WHETHER</b> <b>OR</b> <b>NOT</b> <b>YOU</b> <b>HAVE</b> <b>A</b> <b>COMPLETE</b> <b>COMMAND</b></h4><pre>
       C routines that collect data to form a command to be passed to <u>Tcl_Eval</u> often need a way to tell  whether
       they  have  a  complete command already or whether they need more data.  (Programs that read typed-in Tcl
       input such as Tcl shells need this capability.)  <b>Tcl_CommandComplete</b> can be used to tell whether  or  not
       you have a complete command.

       For more information examine <b><a href="../man3/CmdCmplt.3.html">CmdCmplt</a></b>(3) in the Berkeley Tcl distribution.

</pre><h4><b>RECORDING</b> <b>COMMANDS</b> <b>FOR</b> <b>COMMAND</b> <b>HISTORY</b></h4><pre>
       Tcl has a history mechanism that is accessed from Tcl through the <u>history</u> command.  To propagate commands
       into  the  command  history,  your extension should call <u>Tcl_RecordAndEval</u>.  This command works just like
       <u>Tcl_Eval</u>, except that it records the command as well as executing it.

       <u>Tcl_RecordAndEval</u> should only be called with user-entered top-level commands, since the history mechanism
       exists to allow the user to easily access, edit and reissue previously issued commands.

       For complete information on this function, please examine the <b>RecordEval</b>.3 manual page  in  the  Berkeley
       Tcl distribution.

</pre><h4><b>CONVERTING</b> <b>FLOATING</b> <b>POINT</b> <b>VALUES</b> <b>TO</b> <b>STRINGS</b></h4><pre>
       <b>Tcl_PrintDouble</b>  converts  a  C  <u>double</u>  into  an  ASCII  string.  It ensures that the string output will
       continue to be interpreted as a floating point number, rather than an integer, by always putting a  ``.''
       or  ``e''  into  the string representing the number.  The precision of the output string is controlled by
       the Tcl <b>tcl_precision</b> variable.

       For complete information on <u>Tcl_PrintDouble</u>, examine <b><a href="../man3/PrintDbl.3.html">PrintDbl</a></b>(3) in the Berkeley Tcl distribution.

</pre><h4><b>CREATING</b> <b>CHILD</b> <b>PROCESSES</b> <b>AND</b> <b>PIPELINES</b> <b>FROM</b> <b>C</b></h4><pre>
       <b>Tcl_CreatePipeline</b> is a useful procedure for  spawning  child  processes.   The  child  (or  pipeline  of
       children)  can  have  its standard input, output and error redirected from files, variables or pipes.  To
       understand the meaning of the redirection symbols understood by this function, look at  the  <b>exec</b>(n)  Tcl
       command.  For complete information on <b>Tcl_CreatePipeline</b>, please examine <b><a href="../man3/CrtPipelin.3.html">CrtPipelin</a></b>(3).

</pre><h4><b>ACCESSING</b> <b>TCL</b> <b>FILEHANDLES</b> <b>FROM</b> <b>C</b></h4><pre>
       Files  opened from your C code can be made visible to Tcl code via the <b>Tcl_EnterFile</b> function.  Likewise,
       Tcl filehandles passed to your C extension can be translated to  a  Posix  <u>FILE</u>  <u>*</u>  structure  using  the
       <b>Tcl_GetOpenFile</b> function.

       For  complete  explanations  of  these  commands,  please  look  at  <b><a href="../man3/EnterFile.3.html">EnterFile</a></b>(3)  in  the  Berkeley  Tcl
       distribution.

</pre><h4><b>MANAGING</b> <b>BACKGROUND</b> <b>PROCESS</b> <b>TERMINATION</b> <b>AND</b> <b>CLEANUP</b></h4><pre>
       When a Posix system does a <u>fork</u> to create a new process, the process ID of the child is returned  to  the
       caller.   After the child process exits, its process table entry (and some other data associated with the
       process) cannot be reclaimed by the operating system until a call to <u>waitpid</u>,  or  one  of  a  couple  of
       other, similar system calls, has been made by the parent process.

       The  C extension writer who has created a subprocess, by whatever mechanism, can turn over responsibility
       for detecting the processes' termination and calling  <u>waitpid</u>  to  obtain  its  exit  status  by  calling
       <b>Tcl_DetachPids</b>.

       <b>Tcl_ReapDetachedProcs</b>  is  the C routine that will detect the termination of any processes turned over to
       Tcl, permitting the processes to be fully reclaimed by the operating system.

       For  complete  information  on  these  routines,  please  look  at  <u><a href="../man3/DetachPids.3.html">DetachPids</a>(3)</u>  in  the  Berkeley  Tcl
       distribution.

</pre><h4><b>FOR</b> <b>MORE</b> <b>INFORMATION</b></h4><pre>
       In addition to the documentation referenced above, you can learn a lot by studying the source code of the
       commands  added  by  Tcl,  Tk  and  Extended  Tcl.  The <u>comp.lang.tcl</u> Usenet newsgroup is read by tens of
       thousands of Tcl people, and is a good place to ask questions.  Finally, if you have interactive Internet
       access, you can ftp to <u>ftp.aud.alcatel.com</u>, the site for contributed Tcl  sources.   This  site  contains
       quite a few extensions, applications, and so forth, including several object-oriented extension packages.

</pre><h4><b>AUTHORS</b></h4><pre>
       Extended Tcl was created by Karl Lehenbauer (<a href="mailto:karl@neosoft.com">karl@neosoft.com</a>) and Mark Diekhans (<a href="mailto:markd@grizzly.com">markd@grizzly.com</a>).

Tcl                                                                                       <u>Command</u> <u><a href="../man3tclx/Writing.3tclx.html">Writing</a></u>(3tclx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>