<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TclCommandWriting - Writing C language extensions to Tcl.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tclx8.4-doc">tclx8.4-doc_8.4.1-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       TclCommandWriting - Writing C language extensions to Tcl.

</pre><h4><b>OVERVIEW</b></h4><pre>
       This  document  is intended to help the programmer who wishes to extend Tcl with C language routines.  It
       should also be useful to someone wishing to add Tcl to an existing editor, communications program, window
       manager, etc.  Experienced extension writers may find this manual helpful in rewriting their applications
       to use the new Tcl object system.  We assume you are already fluent in the  C  programming  language  and
       that you have built and installed Tcl on your machine.

       Information  on the available C interface routines to Tcl can be found in the <u>*.3</u> manual pages in the <u>doc</u>
       directory of the baseline Tcl distribution, and in the <u>*.3</u> manpages in the <u>doc</u> directory of Extended Tcl.

</pre><h4><b>TCL</b> <b>OBJECT</b> <b>SYSTEM</b></h4><pre>
       With the release of Tcl version 8, Tcl has a new system for managing Tcl values internally.  To  the  Tcl
       programmer,  the new objects look and act like strings, as before.  But at the C level, these objects can
       now also hold cached internal representations of the strings in various native datatypes.   For  example,
       an  object  containing  a  string  consisting  of  an  integer,  will now maintain a machine-code integer
       representation, if an integer representation has been needed.  Using these objects is much more efficient
       than using the older-style Tcl strings, although the older style is still (currently) supported.

       Although the object system has almost no effect at all on how the Tcl programmer  uses  Tcl,  the  object
       system's  C  interfaces to strings, integers, lists, etc., have changed considerably.  While converting a
       package to use the new system can be a lot of work, the combination of the object system, which saves Tcl
       from having to constantly convert strings to  integers  and  back,  etc.,  and  the  on-the-fly  bytecode
       compiler  (which  keeps  Tcl from having to continually reparse code it is to execute) yield Tcl programs
       that routinely execute several times more quickly than with previous versions (Tcl 7 and before), and  in
       some cases run as much as 2500 (!) times faster than before.

       We  have chosen, then, to rewrite the Command Writer's manpage, which has been shipping with Extended Tcl
       for a number of years, to produce this new version based on the new  object  system.   The  old  manpage,
       based  on  the  older string-oriented routines, will still be included in TclX releases for now, as it is
       still relevant to Tcl releases through version 7, and may be of use to those modifying/upgrading packages
       written for the old model.  The old manual will be dropped from the release once we deem it unneeded; the
       old interfaces should now be considered legacy interfaces, and all new development should be  done  using
       the new object interfaces, unless backwards compatibility to pre-Tcl-8 releases is needed.

</pre><h4><b>A</b> <b>SIMPLE</b> <b>C</b> <b>EXTENSION</b></h4><pre>
       All  C-based  Tcl commands are called with four arguments: a client data pointer, an interpreter pointer,
       an argument count and a pointer to an array of Tcl objects containing the arguments to the command.

       A simple C extension to Tcl is now presented, and described below:

           #include "tcl.h"

           int App_DumpArgsObjCmd(clientData, interp, objc, objv)
               void          *clientData;
               Tcl_Interp    *interp;
               int            objc;
               Tcl_Obj      **objv;
           {
                   int   i;
                int   stringLen;
                char *stringPtr;

                   for (i = 1; i &lt; objc; i++) {
                     stringPtr = Tcl_GetStringFromObj (objv [i], &amp;stringLen);
                           printf("%s", stringPtr);
                     if (i &lt; objc - 1) printf(" ");
                   }
                   printf("\n");
                   return TCL_OK;
           }

       The client data pointer will be described later.

</pre><h4><b>INTERPRETERS</b></h4><pre>
       The interpreter pointer is the ``key'' to an interpreter.  It is returned by <b>Tcl_CreateInterp</b> and is used
       extensively within Tcl, and will be used by your C extensions.  The data  structure  pointed  to  by  the
       interpreter  pointer,  and  all  of  the  subordinate  structures  that  branch  off of it, make up a Tcl
       interpreter, which includes all of the currently defined procedures, commands, variables, arrays and  the
       execution state of that interpreter.  (For more information on creating and deleting interpreters, please
       examine  the <b><a href="../man3/CrtInterp.3.html">CrtInterp</a></b>(3) manpage in the core Tcl distribution.  For information on creating interpreters
       that include the commands provided by Extended Tcl, check out the <b><a href="../man3/TclX_Init.3.html">TclX_Init</a></b>(3) manpage of  Extended  Tcl.
       For  a  manual  page describing the user-visible fields of a Tcl interpreter, please look at <b><a href="../man3/Interp.3.html">Interp</a></b>(3) in
       core Tcl.)

</pre><h4><b>OBJECT</b> <b>COUNT</b> <b>AND</b> <b>ARGUMENTS</b></h4><pre>
       The argument count, or object count (objc), and pointer to an array of pointers to  Tcl  objects  of  the
       command's  arguments  (objv)  is  handled by your C code, in a manner similar to the one you would use in
       writing a C <u>main</u> function -- an argument count and array of pointers works the same as in a C <u>main</u>  call;
       pointers  to  the  arguments  to  the function are contained in the <u>objv</u> array.  Similar to a C main, the
       first argument (<u>objv[0]</u>) is an object containing the name the routine was called as (in  a  C  main,  the
       name the program was invoked as).

       In  Tcl,  however, the array of pointers are not pointers to character strings (although they were in all
       version of Tcl before 8.0).

       In the above example, all of the arguments are output with a space between each one  by  looping  through
       elements of the <u>objv</u> array from one to the argument count, <u>objc</u>, and a newline is output to terminate the
       line  --  a  simple  ``echo'' command.  This example uses printf for simplicity.  Of course in production
       code you would want to  use  the  Tcl  filesystem  interfaces.   See  <b><a href="../man3/GetFile.3.html">GetFile</a></b>(3)  and  friends  for  more
       information.

       All arguments from a Tcl call to a Tcl C extension are passed as Tcl Objects.  If your C routine wants to
       look  at  one  of  those  arguments  as  an  integer,  you  need to make a call to a routine to fetch the
       representation of the object that you need.  In the earlier example, for  instance,  <b>Tcl_GetStringFromObj</b>
       is  called  to  obtain a textual representation of an object.  Additional routines are available to fetch
       the representation of a data element as other data types.   Tcl_GetBooleanFromObj,  Tcl_GetDoubleFromObj,
       Tcl_GetIntFromObj,  Tcl_GetLongFromObj,   and  Tcl_GetIndexFromObj,  fetch  object representations of Tcl
       strings as booleans, double-precision floating point, integer, long integer, and lists, among others.

       These routines automatically leave an appropriate error message in the Tcl  interpreter's  result  object
       and return <b>TCL_ERROR</b> if a conversion error occurs.   (For more information on these routines, please look
       at the <b><a href="../man3/Object.3.html">Object</a></b>(3) manpage in the core Tcl distribution.)

</pre><h4><b>RETURNING</b> <b>RESULTS</b></h4><pre>
       As  you  might  expect, the API for setting results from C extensions has changed significantly under the
       object system.  The old technique of writing small results directory into the interpreter's result buffer
       is no longer used, for example.  The notion of having to tell Tcl whether a result is static  or  dynamic
       is  also a thing of the past.  Under the object system, results are objects that are set up by your code,
       and objects are freed when their reference counts say they should be.  More on this later.

       If you program produces a numeric result, it should set the result object to contain that numeric  value.
       A common way of doing this is something like...

               Tcl_Obj *obj;

               obj = Tcl_GetObjResult (interp);
            Tcl_SetIntObj (obj, value);

       The  above  code  obtains  a  pointer to the result object (an object made available to your routine that
       you're supposed to store your results into) and sets the integer value <u>value</u> into it.

       Another way to do it would be to set up a new object and tell Tcl that this object contains the result...

               Tcl_Obj *resultObj;

               /* create a new object for use as a result */
            resultObj = Tcl_NewObj ();

            Tcl_SetIntObj (obj, value);
            Tcl_SetObjResult (interp, resultObj);

       Understanding how results are passed back to Tcl is essential to the C extension  writer.   Please  study
       the <b><a href="../man3/SetObjResult.3.html">SetObjResult</a></b>(3) manual page in the Tcl distribution for more information.

</pre><h4><b>VALIDATING</b> <b>ARGUMENTS</b></h4><pre>
       It  is  a design goal of Tcl that no Tcl program be able to cause Tcl to dump core.  It is important that
       the extension writers, likewise, use the available methods and tools to make sure that  their  extensions
       do not allow unchecked input, for example, to cause the code to get some kind of runtime exception.

       The  object  system  has simplified, to some degree, the task of validating arguments, in that the object
       system automatically attempts type conversions as needed, and will return an error when a type conversion
       fails.

       A simple, but important, check that every C extension should do is verify that it has the right number of
       arguments.

       The act of trying to use, say, a string as an integer, implicitly performs the  type  conversion  of  the
       string  and,  if  it  doesn't  work as an integer, returns TCL_ERROR.  The developer should check for the
       TCL_ERROR return from all of the GetXxxFromObj commands, and handle them as  appropriate.   Usually  this
       will mean propagating the error on back to the user, or to an intevening catch, as the case may be.

       You  should also check that values are in range (when their ranges are known), and so forth.  When C data
       structures need to be handled in Tcl in some form or another, yet the contents of the  data  must  remain
       opaque  to Tcl, as is usually the case with binary data (although futures releases of Tcl are expected to
       have native abilities to read, write and manipulate binary data instrinsically), <u>handles</u> need to be used.
       Handles will be described and examples presented, later in this doc.

</pre><h4><b>ANOTHER</b> <b>C</b> <b>EXTENSION</b> <b>-</b> <b>THE</b> <b>MAX</b> <b>COMMAND</b></h4><pre>
       In the command below, two or more arguments are compared, and the one with the maximum value is returned,
       if all goes well.  It is an error if there are fewer than two  arguments  (the  pointer  to  the  ``max''
       command text itself, <u>objv[0]</u>, and a pointer to at least one object to compare the values of).

           int
           Tcl_MaxCmd (clientData, interp, objc, objv)
               char         *clientData;
               Tcl_Interp   *interp;
               int           objc;
               Tcl_Obj     **objv;
           {
               int maxVal = MININT;
               int value, idx;

               if (objc &lt; 3)
                return TclX_WrongArgs (interp, objv[0],
                                          " num1 num2 [..numN]");

               for (idx = 1; idx &lt; objc; idx++) {
                   if (Tcl_GetIntFromObj (interp, objv[idx], &amp;value) != TCL_OK)
                       return TCL_ERROR;

                   if (value &gt; maxVal) {
                       maxVal = value;
                   }
               }
            Tcl_SetIntObj (Tcl_GetObjResult (interp), value);
               return TCL_OK;
           }

       Here  we introduce the Extended Tcl helper function <b>TclX_WrongArgs</b>.  This routine makes it easy to create
       an error message and error return in response to the common mistake of being called with a wrong number.

       <b>Tcl_GetIntFromObj</b> is used to fetch the integer values of the remaining arguments.   If  any  fail  to  be
       converted,  we  return  a Tcl error.  If an interpreter is specified in the call to <b>Tcl_GetIntFromObj</b>, an
       appropriate error message about the conversion failure will be left in the result, so we do that here.

       After examining all of the arguments to find the largest value, we set the result object to contain  that
       value, and return <b>TCL_OK</b>.

</pre><h4><b>RETURNING</b> <b>RESULTS</b></h4><pre>
       When  Tcl-callable  functions  complete,  they  should  normally  return  <b>TCL_OK</b> or <b>TCL_ERROR</b>.  <b>TCL_OK</b> is
       returned when the command succeeded, and <b>TCL_ERROR</b> is returned  when  the  command  has  failed  in  some
       abnormal  way.   <b>TCL_ERROR</b> should be returned for all syntax errors, non-numeric values when numeric ones
       were expected, and so forth.  Less clear in some cases is  whether  Tcl  errors  should  be  returned  or
       whether  a  function should just return a status value.  For example, end-of-file during a <u>gets</u> returns a
       status, but <u>open</u> returns an error if it fails.  Errors can be caught from Tcl programs  using  the  <u>catch</u>
       command.  (See Tcl's <b>catch</b>(n) and <b>error</b>(n) manual pages.)

       Less  common  return values are <b>TCL_RETURN</b>, <b>TCL_BREAK</b> and <b>TCL_CONTINUE</b>.  These are used if you are adding
       new control and/or looping structures to Tcl.  To see these values in action, examine the source code  to
       Extended Tcl's <u>loop</u> commands.  Tcl's <u>while</u>, <u>for</u> and <u>if</u> commands used to work in the just same manner, but
       are now compiled into bytecode by the bytecode for performance.

</pre><h4><b>ANOTHER</b> <b>C</b> <b>EXTENSION</b> <b>-</b> <b>THE</b> <b>LREVERSE</b> <b>COMMAND</b></h4><pre>
       In  the  command below, a list is passed as an argument, and a list containing all of the elements of the
       list in reverse order is returned.  It is an error if anything other than two arguments are  passed  (the
       pointer to the ``lreverse'' command text itself, <u>objv[0]</u>, and a pointer to the list to reverse.

       Once <u>lreverse</u> has determined that it has received the correct number of arguments, <b>Tcl_ListObjGetElements</b>
       is  called to split the list into its own <u>objc</u> count of elements and <u>objv</u> array of pointers to the list's
       elements.

       <u>lreverse</u> then operates on the array of pointers, swapping them from lowest to highest,  second-lowest  to
       second-highest, and so forth.

       <b>Tcl_ListObjAppendElement</b> is called on successive list elements to build up the new list, which is finally
       returned as result of the command.

       int
       Tcl_LreverseObjCmd(notUsed, interp, objc, objv)
           ClientData    notUsed;        /* Not used. */
           Tcl_Interp   *interp;         /* Current interpreter. */
           int           objc;           /* Number of arguments. */
           Tcl_Obj     **obj;            /* Argument strings. */
       {
           int listObjc, lowListIndex, hiListIndex;
           Tcl_Obj **listObjv;
           char *temp, *resultList;
           Tcl_Obj **newListObjv;

           /* Verify argument count.  Since we take only one argument, argument
            * count must be 2 (command plus one argument).
            */
           if (objc != 2)
            return TclX_WrongArgs (interp, objv [0], "list");

           /* Create an object to handle the new list we're creating */
           newListObjv = Tcl_NewObj();

           /* Crack the list at objv[1] into its own count and array of object
            * pointers.
            */
           if (Tcl_ListObjGetElements (interp, objv[1], &amp;listObjc, &amp;listObjv) != TCL_OK) {
            return TCL_ERROR;
           }

           /* For each element in the source list from last to first, append an
            * element to the new list.
            */
           for (listIndex = listObjc - 1; listIndex &gt;= 0; listIndex--) {
            Tcl_ListObjAppendElement (interp, newListObjv, listObjv[listIndex]);
           }
       FIX: NEED TO RETURN THE LIST.
           return TCL_OK;
       }

</pre><h4><b>INSTALLING</b> <b>YOUR</b> <b>COMMAND</b></h4><pre>
       To  install  your  command  into  Tcl  you  must call <b>Tcl_CreateObjCommand</b>, passing it the pointer to the
       interpreter you want to install the command into, the name of the command, a pointer to  the  C  function
       that implements the command, a client data pointer, and a pointer to an optional callback routine.

       The client data pointer and the callback routine will be described later.

       For  example,  for  the  max  function  above  (which,  incidentally, comes from TclX's tclXmath.c in the
       <u>TclX7.4/src</u> directory):

           Tcl_CreateCommand (interp, "max", Tcl_MaxCmd, (ClientData)NULL,
                             (void (*)())NULL);

       In the above example, the max function is added to the specified interpreter.  The  client  data  pointer
       and callback function pointer are NULL.  (For complete information on <b>Tcl_CreateCommand</b> and its companion
       routine, <b>Tcl_CommandInfo</b>, please examine the <b><a href="../man3/CrtCommand.3.html">CrtCommand</a></b>(3) command page in the core Tcl distribution.)

</pre><h4><b>DYNAMIC</b> <b>STRINGS</b></h4><pre>
       <u>Dynamic</u>  <u>strings</u> are an important abstraction that first became available with Tcl 7.0.  Dynamic strings,
       or <u>DStrings</u>, provide a way to build up arbitrarily long strings through a repeated process  of  appending
       information to them.  DStrings reduce the amount of allocating and copying required to add information to
       a string.  Further, they simplify the process of doing so.

       At  first  glance,  it  may  seem  that  the object system supersedes DStrings.  It does not, in that the
       performance improvements made possible by the lazy conversion of  an  object's  representation  from  one
       datatype  to another does not come into play much while constructing strings as the string representation
       is always available either without any type conversion or where type conversion would be necessary in any
       case as a string representation of  the  object  is  required  when  strings  are  being  constructed  by
       concatenation, etc.

       It  should  be  noted,  however,  that  the  C level string manipulation capabilities of objects, such as
       <b>Tcl_AppendToObj</b> and <b>Tcl_AppendStringsToObj</b>, are often plenty  enough  for  what  you  need  to  do.   For
       complete  information  on  dynamic  strings,  please  examine  the <b><a href="../man3/DString.3.html">DString</a></b>(3) manual page in the core Tcl
       distribution.  For more on  Tcl  object's  string-oriented  calls,  seek  <b><a href="../man3/Tcl_StringObj.3.html">Tcl_StringObj</a></b>(3)  in  the  same
       location.

</pre><h4><b>CLIENT</b> <b>DATA</b></h4><pre>
       The  client  data pointer provides a means for Tcl commands to have data associated with them that is not
       global to the C program nor included in the Tcl core.  Client data is essential  in  a  multi-interpreter
       environment (where a single program has created and is making use of multiple Tcl interpreters) for the C
       routines  to maintain any permanent data they need on a per-interpreter basis.  If needed static data was
       simply declared static in C, you will probably have reentrancy  problems  when  you  work  with  multiple
       interpreters.

       Tcl  solves  this  through the client data mechanism.  When you are about to call <b>Tcl_CreateObjCommand</b> to
       add a new command to an  interpreter,  if  your  command  needs  to  keep  some  read/write  data  across
       invocations,  you  should allocate the space, preferably using <b>Tcl_Alloc</b> instead of <b>malloc</b>, then pass the
       address of that space as the ClientData pointer to <b>Tcl_CreateObjCommand</b>.

       When your command is called from Tcl, the ClientData pointer you passed to <b>Tcl_CreateObjCommand</b>  will  be
       passed to your C routine through the ClientData pointer calling argument.

       Commands  that  need  to  share this data with one another can do so by using the same ClientData pointer
       when the commands are added.

       It is important to note that the Tcl extensions in the <u>tclX8.0.0</u> directory have had all of their data set
       up in this way.  Since  release  6.2,  Extended  Tcl  has  supported  multiple  interpreters  within  one
       invocation of Tcl.

</pre><h4><b>THEORY</b> <b>OF</b> <b>HANDLES</b></h4><pre>
       Sometimes  you  need  to have a data element that isn't readily representable as a string within Tcl, for
       example a pointer to a complex C data structure.  It is not a good idea to try to  pass  pointers  around
       within  Tcl as strings by converting them to and from hex or integer representations, for example.  It is
       too easy to mess one up, and the likely outcome of doing that is a core dump.

       Instead we have developed and made use of the concept of <u>handles</u>.  Handles are identifiers a C  extension
       can  pass to, and accept from, Tcl to make the transition between what your C code knows something as and
       what name Tcl knows it by to be as safe and painless as possible.  For example, the I/O  system  included
       in  Tcl uses file handles.  When you open a file from Tcl, a handle is returned of the form <b>file</b><u>n</u> where <u>n</u>
       is a file number.  When you pass the file handle back to <u>puts</u>, <u>gets</u>,  <u>seek</u>,  <u>flush</u>  and  so  forth,  they
       validate  the file handle by checking the the <b>file</b> text is present, then converting the file number to an
       integer that they use to look into a data structure of  pointers  to  Tcl  open  file  structures,  which
       contain  a  Unix file descriptor, flags indicating whether or not the file is currently open, whether the
       file is a file or a pipe and so forth.

       Handles have proven so useful that, since TclX release 6.1a, general support has been available  to  help
       create  and  manipulate them.  Many of these capabilities have migrated into baseline Tcl.  If you have a
       similar need, you might like to use the handle routines documented in <b><a href="../man3/Handles.3.html">Handles</a></b>(3)  in  Extended  Tcl.   We
       recommend that you use a unique-to-your-package textual handle coupled with a specific identifier and let
       the  handle management routines validate it when it's passed back.  It is much easier to track down a bug
       with an implicated handle named something like <b>file4</b> or <b>bitmap6</b> than just <b>6</b>.

       Note that Tcl's object offers another way for complex data structures  to  exist  in  parallel  with  and
       underneath  Tcl  strings.  As of this writing (May 30, 1997) this is fairly new territory, but things are
       looking good for the prospects of using the Tcl object system in this manner, and for enhancements to the
       object system that allow even Tcl objects to have methods in a very straightforward and simple way.

</pre><h4><b>USING</b> <b>COMMANDS</b> <b>TO</b> <b>DO</b> <b>THE</b> <b>SAME</b> <b>THING,</b> <b>AND</b> <b>MORE</b></h4><pre>
       Another handle-like technique, first popularized in the Tk toolkit, offers  handle-like  capabilities  as
       well  as  some  neat  additional  capabilities.   That  is to create a new Tcl command, from C, that uses
       ClientData to keep a "handle" on its complex underlying data structure.  Then by having that command look
       at its second argument for what it is to do (its sub-functions), you get these nice  methods,  where  you
       have  several  additional  sub-commands that don't pollute the global namespace and only work on (and are
       available with) the objects (new commands) they  are  relevant  to.   For  example,  in  Tk,  creating  a
       checkbutton  (<b>checkbutton</b>  <b>.b)</b>  <b>creates</b> <b>a</b> <b>new</b> <b>Tcl</b> <b>command</b> <b>(.b),</b> <b>that</b> <b>has</b> <b>methods</b> <b>to</b> <b>configure</b> <b>the</b> <b>button,</b>
       <b>select,</b> <b>deselect,</b> <b>toggle</b> <b>and</b> <b>flash</b> <b>it.</b>

       A lot of people think this is really the way to go, and I am pretty much leaning that way myself.  If you
       use the <b>incr</b> <b>tcl</b> script-level object system for Tcl, objects that  you  define  in  Tcl  will  be  highly
       compatible in terms of their command interfaces and configuration management with objects you create in C
       using the the command-and-ClientData technique described here.  I believe <b>Tk</b> has some nice facilities for
       making this easy for the Tcl programmer.  <b>Itcl</b> certainly does.

</pre><h4><b>TRACKING</b> <b>MEMORY</b> <b>CORRUPTION</b> <b>PROBLEMS</b></h4><pre>
       Occasionally  you  may write code that scribbles past the end of an allocated piece of memory.  This will
       usually result in a core dump  or  memory  allocation  failure  sometime  later  in  the  program,  often
       implicating  code  that  is not actually responsible for the problem (as you start looking from the point
       where the error is detected, which is usually where the later routine has failed).

       The memory debugging routines included in Tcl can help find these problems.  Developed by Mark and  Karl,
       the  memory debugging routines are now part of baseline Tcl, and is to our knowledge the largest piece of
       TclX to drop into the core without being reengineered first.  (You see, summer  back  in  '91,  John  was
       sitting  in  his  office in the CS building at UC Berkeley trying to find a memory leak somewhere in Tcl,
       when he was paid a visit by two long-haired-yet-polite programmers bearing  gifts  in  the  form  of  the
       technology  grab-bag  known  as  Extended  Tcl.   He saw that, using TclX's malloc routines, Tcl could be
       prompted to print the filename and line number of every single memory allocation  that  did  not  have  a
       corresponding free.  It was just what the doctor ordered ;-) See <u>Memory(TCL)</u> for details.

</pre><h4><b>INSTALLING</b> <b>YOUR</b> <b>EXTENSIONS</b> <b>INTO</b> <b>TCL</b></h4><pre>
       To  add  your  extensions  to  Tcl,  you  used  to  have to statically link them, together with any other
       extensions, into a single binary executable image.  Today, although the statically linked  executable  is
       still  an  option,  most operating systems, even Microsoft Windows, support shared libraries, and in most
       cases, Tcl can now make use of those shared libraries such that you extensions, and most others, can  now
       be  built  a  shared  libraries  that can be loaded in (using <b>package</b> <b>require</b>) by scripts that need them.
       Shared libraries can simplify a Tcl installation, because only one copy of Tcl is required, rather than a
       hodepodge of combinations of applications that you might have found at a big Tcl  site  in  the  previous
       era.

</pre><h4><b>GNU</b> <b>AUTOCONF</b></h4><pre>
       While the build procedure for shared libraries varies from system to system, most Unix and Unix workalike
       systems will figure out the nuances of the compiler and linker arguments automatically when the <u>configure</u>
       script  is  run.   If  you  are building a package that you plan to make generally available, we strongly
       recommend that you use <b>GNU</b> <b>autoconf</b> (<a href="ftp://prep.ai.mit.edu/pub/gnu">ftp://prep.ai.mit.edu/pub/gnu</a>) to  set  up  an  automatic  <u>configure</u>
       script for it.  Be forewarned that <u>autoconf</u> uses some pretty heavy duty shell and sed script magic to get
       the  job  done,  and  the  learning  curve  can  be pretty steep.  Once done and shaken out, though, it's
       rewarding to know that your package can build and run on everything from a notebook to a Cray to  a  RISC
       SMP server.

       Application-specific  startup  is  accomplished  by  creating  or  editing  the <u>Tcl_AppInit</u> function.  In
       <u>Tcl_AppInit</u> you should add a call to an  application-specific  init  function  which  you  create.   This
       function  should  take  the address of the interpreter it should install its commands into, and it should
       install those commands with <b>Tcl_CreateCommand</b> and do  any  other  application-specific  startup  that  is
       necessary.

       The  naming  convention  for  application  startup  routines  is  <b>App_Init</b>, where <u>App</u> is the name of your
       application.  For example, to add an application named <u>cute</u> one would create  a  <u>Cute_Init</u>  routine  that
       expected a <b>Tcl_Interp</b> pointer as an argument, and add the following code to <u>Tcl_AppInit</u>:

           if (Cute_Init (interp) == TCL_ERROR) {
            return TCL_ERROR;
           }

       As  you  can  guess  from  the above example, if your init routine is unable to initialize, it should use
       <b>Tcl_AppendResult</b> to provide some kind of useful error message back to  TclX,  then  return  <b>TCL_ERROR</b>  to
       indicate that an error occurred.  If the routine executed successfully, it should return <b>TCL_OK</b>.

       When  you examine <u>Tcl_AppInit</u>, note that there is one call already there to install an application -- the
       call to <u>TclX_Init</u> installs Extended Tcl into the Tcl core.

</pre><h4><b>MAKING</b> <b>APPLICATION</b> <b>INFORMATION</b> <b>VISIBLE</b> <b>FROM</b> <b>EXTENDED</b> <b>TCL</b></h4><pre>
       TclX's <b>infox</b> command can return several pieces of information relevant to  Extended  Tcl,  including  the
       application's  name, descriptive name, patch level and version.  Your application's startup can set these
       variables to application-specific values.  If it doesn't, they are given default values for Extended Tcl.

       To set these values, first be sure that you include either <b>tclExtend.h</b> or <b>tclExtdInt.h</b>  from  the  source
       file  that  defines  your init routine.  This will create external declarations for the variables.  Then,
       set the variables in your init route, for example:

           tclAppName = "cute";
           tclAppLongName = "Call Unix/Tcl Environment";
           tclAppVersion = "2.1";

       Note that the default values are set by <u>TclX_Init</u>, so if you wish to override them, you  must  call  your
       init routine in <u>Tcl_AppInit</u> after its call to <u>TclX_Init</u>.

</pre><h4><b>EXTENDED</b> <b>TCL</b> <b>EXIT</b></h4><pre>
       When  Extended  Tcl exits, <b>Tcl_DeleteInterp</b> may be called to free memory used by Tcl -- normally, this is
       only called if <b>TCL_MEM_DEBUG</b> was defined, since Unix will return all of the allocated memory back to  the
       system, anyway.  If <b>TCL_MEM_DEBUG</b> was defined, it is called so that any memory that was allocated without
       ever  being  freed  can  be  detected.   This greatly reduces the amount of work to detect and track down
       memory leaks, a situation where some piece of your code allocates memory repeatedly without ever  freeing
       it, or at least without always freeing it.

       It  is  often  necessary  for an application to perform special cleanup functions upon the deletion of an
       interpreter as well.  To facilitate this activity,  Tcl  provides  the  ability  to  perform  a  function
       callback  when  an interpreter is deleted.  To arrange for a C function to be called when the interpreter
       is deleted, call <b>Tcl_CallWhenDeleted</b> from your application initialization routine.  For details on how to
       use this function, read the <b><a href="../man3/CallDel.3.html">CallDel</a></b>(3) manual page that ships with core Tcl.

</pre><h4><b>EXECUTING</b> <b>TCL</b> <b>CODE</b> <b>FROM</b> <b>YOUR</b> <b>C</b> <b>EXTENSION</b></h4><pre>
       Suppose you are in the middle of coding a C extension and  you  realize  that  you  need  some  operation
       performed,  one  that  would  be  simple  from  Tcl,  but possibly excruciating to do directly in C.  Tcl
       provides a number of C-level interfaces whereby you can cause Tcl code to be  executeed.   The  old-style
       calls  are <b>Tcl_Eval</b>, <b>Tcl_VarEval</b>, <b>Tcl_EvalFile</b> and <b>Tcl_GlobalEval</b>.  The results of these calls can be dug
       out of the interpreter using <b>Tcl_GetStringResult</b>, if you want a string representation of the  result,  or
       <b>Tcl_GetObjResult</b> if you want the object.  (The use of <b>interp-&gt;result</b> to access the result string has been
       deprecated.)

       The  Tcl  object  system  adds  <b>Tcl_EvalObj</b>  and  <b>Tcl_GlobalEvalObj</b>.   The difference here is that we are
       evaluating an object, not just a string, and using these routines in  preference  to  the  aforementioned
       ones  can  result  in  a major performance improvement in your code, when the code is executed repeatedly
       (even if it only executes once but loops several times within itself), as these routines make it possible
       for the bytecode compiler to compile the code being evaluated and save the compiled code  with  the  data
       structure, in an implementation-dependent manner.

       For more information please consult the <b><a href="../man3/EvalObj.3.html">EvalObj</a></b>(3) and <b><a href="../man3/Eval.3.html">Eval</a></b>(3) manual pages within the Tcl distribution.

</pre><h4><b>ACCESSING</b> <b>TCL</b> <b>VARIABLES</b> <b>AND</b> <b>ARRAYS</b> <b>FROM</b> <b>YOUR</b> <b>C</b> <b>EXTENSIONS</b></h4><pre>
       In  addition  to  the non-object-system ways of reading from and storing to Tcl variables, using routines
       such as <b>Tcl_SetVar2</b> and <b>Tcl_GetVar2</b>, Tcl variables and arrays can be read  from  a  C  extension  as  Tcl
       objects  by  using  the  <b>Tcl_ObjGetVar2</b>  function,  and  set from C extensions through the <b>Tcl_ObjSetVar2</b>
       function.

       Please note that the object versions do not carry forward  analogues  to  the  one-variable-name-argument
       <b>Tcl_GetVar</b>,  <b>Tcl_SetVar</b>,  and  <b>Tcl_UnsetVar</b>.  If you know you have a scalar, call the object variable get
       and set functions with a NULL second argument.  If your variable name might contain  an  array  reference
       via  a self-contained embedded array index (i.e., I'm asking <b>Tcl_ObjGetVar2</b> for <b>"<a href="../man5/foo.5.html">foo</a>(5)"</b> instead of <b>"foo"</b>
       <b>"5"</b>), add the <b>TCL_PARSE_PART1</b> to the flags in your call.

       While the fact that <b>Tcl_ObjGetVar2</b> retrieves Tcl objects, rather than strings, is critical for the object
       system to be able to provide the performance boosts from "lazy"  type  conversion  and  the  binary  data
       capabilities,  the  arguments containing the variable name, or the array name and element name if they've
       been split out, also must be specified as Tcl objects rather than  strings.   While  this  is  useful  on
       occasion,  those  writing  C  extensions  for  Tcl  in  the post-object-system era usually have the names
       available as plain old <u>char</u> <u>*</u> variables, requiring conversion of the strings to objects  before  use  and
       account for their possible destruction afterwards.

       To  simplify  the  task  in  those  cases, TclX adds the <b>TclX_ObjGetVar2S</b> subroutine.  It works just like
       <b>Tcl_ObjGetVar2</b>, except the one or two variable name arguments are specified as strings, and  the  routine
       takes care of making and disposing of object equivalents.

       Tcl  variables can be unset from C via the <b>Tcl_UnsetVar</b> and <b>Tcl_UnsetVar2</b> functions.  There are currently
       (as of 8.0) no object-system equivalents, so in the rare case where you have the name of the variable you
       want unset as an object instead of a string, you can  call  <b>Tcl_GetStringFromObj</b>  to  obtain  the  string
       representation first.

       For  complete information on these functions, please refer to the <b><a href="../man3/ObjSetVar.3.html">ObjSetVar</a></b>(3) and <b><a href="../man3/SetVar.3.html">SetVar</a></b>(3) manual pages
       in the <u>doc</u> directory of the core Tcl distribution.

</pre><h4><b>LINKING</b> <b>TCL</b> <b>VARIABLES</b> <b>TO</b> <b>C</b> <b>VARIABLES</b></h4><pre>
       <b>Tcl_LinkVar</b> and <b>Tcl_UnlinkVar</b>  can  be  used  to  automatically  keep  Tcl  variables  synchronized  with
       corresponding C variables.  Once a Tcl variable has been linked to a C variable with <b>Tcl_LinkVar</b>, anytime
       the  Tcl variable is read, the value of the C variable is converted (if necessary) and returned, and when
       the Tcl variable is written, the C variable will be updated with the new value.

       <b>Tcl_LinkVar</b> uses variable traces to keep the Tcl variable named by <u>varName</u> in sync with the C variable at
       the address given by <u>addr</u>.

       <u>Int</u>, <u>double</u>, <u>boolean</u> and <u>char</u> <u>*</u> variables are supported.  You can make your linked  variables  read  only
       from  the  Tcl  side,  as  well.   Please note that the C variables must continually exist while they are
       linked, in other words, linking "automatic" C variables, those created on the stack while  a  routine  is
       being  executed  and destroyed afterwards, will result in a malfunctioning program at best and a coredump
       or more at worst.

       For more information, please examine the <b><a href="../man3/LinkVar.3.html">LinkVar</a></b>(3) manual page in the core Tcl distribution.

</pre><h4><b>ADDING</b> <b>NEW</b> <b>MATH</b> <b>FUNCTIONS</b> <b>TO</b> <b>TCL</b></h4><pre>
       As of Tcl version 7.0, math  functions  such  as  <u>sin</u>,  <u>cos</u>,  etc,  are  directly  supported  within  Tcl
       expressions.   These  obsolete  the  Extended  Tcl  commands  that  provided  explicit commands for these
       functions for many, many releases, although procs equivalencing the old TclX commands  to  the  new  math
       functions are still provided for backwards compatibility.

       New  math  functions  can  be  added  to  Tcl,  or  existing  math  functions can be replaced, by calling
       <b>Tcl_CreateMathFunc</b>.

</pre><h4><b>ACCESSING</b> <b>AND</b> <b>MANIPULATING</b> <b>THE</b> <b>RANDOM</b> <b>NUMBER</b> <b>GENERATOR</b></h4><pre>
       Prior to Tcl version 8.0, the Tcl core did not provide access to a random number generator, but TclX did,
       through its <u>random</u> command.  As of Tcl version 8.0, access to a random number generator  is  provided  by
       baseline Tcl through the new math functions, <u>rand</u> and <u>srand</u>.

       The  TclX  <u>random</u>  command is still available -- it has some useful capabilities not directly provided by
       the new baseline functions.

       For more information on adding your own math functions to Tcl, please study the <b><a href="../man3/CrtMathFnc.3.html">CrtMathFnc</a></b>(3) manual page
       in the core Tcl distribution.

</pre><h4><b>CONVERTING</b> <b>FILENAMES</b> <b>TO</b> <b>NATIVE</b> <b>FORM</b> <b>AND</b> <b>PERFORMING</b> <b>TILDE</b> <b>SUBSTITUTIONS</b></h4><pre>
       The <b>Tcl_TranslateFileName</b> function is available to C extension writers to translate filenames to  a  form
       suitable  for  use by the local operating system.  It converts network names to their native form, and if
       the name starts with a ``~'' character, the function returns a new string where the name is replaced with
       the home directory of the given user.

       For more information please consult the <b><a href="../man3/Translate.3.html">Translate</a></b>(3) manual page in the core Tcl distribution.

</pre><h4><b>SETTING</b> <b>THE</b> <b>RECURSION</b> <b>LIMIT</b></h4><pre>
       Tcl has a preset recursion limit that limits the maximum allowable  nesting  depth  of  calls  within  an
       interpreter.   This  is  useful for detecting infinite recursions before other limits such as the process
       memory limit or, worse, available swap space on the system, run out.

       The default limit is just a guess, however, and applications that make heavy use of recursion may need to
       call <b>Tcl_SetRecursionLimit</b> to raise this limit.  For more information, please  consult  the  <b><a href="../man3/SetRecLmt.3.html">SetRecLmt</a></b>(3)
       manual page in the core Tcl distribution.

</pre><h4><b>HANDLING</b> <b>SIGNALS</b> <b>FROM</b> <b>TCL</b> <b>EXTENSIONS</b></h4><pre>
       If an event such as a signal occurs while a Tcl script is being executed, it isn't safe to do much in the
       signal  handling  routine  --  the  Tcl environment cannot be safely manipulated at this point because it
       could be in the middle of some operation, such as  updating  pointers,  leaving  the  interpreter  in  an
       unreliable state.

       The  only  safe approach is to set a flag indicating that the event occurred, then handle the event later
       when the interpreter has returned to a safe state, such as after the current Tcl command completes.

       The <b>Tcl_AsyncCreate</b>,  <b>Tcl_AsyncMark</b>,  <b>Tcl_AsyncInvoke</b>,  and  <b>Tcl_AsyncDelete</b>  functions  provide  a  safe
       mechanism  for  dealing  with  signals and other asynchronous events.  For more information on how to use
       this capability, please refer to the <b><a href="../man3/Async.3.html">Async</a></b>(3) manual page in the core Tcl distribution.

       Note that Extended Tcl provides built-in  support  for  managing  signals  in  numerous  ways,  including
       generating  them  with <u><a href="../man2/alarm.2.html">alarm</a></u>(2) and <u><a href="../man2/kill.2.html">kill</a></u>(2), ignoring them, trapping them, getting, setting, blocking and
       unblocking them.  You can cause specific code to execute at a safe point after a signal occurs, or  cause
       a Tcl error backtrace on one's occurrence.  For more information, please examine the TclX documentation.

</pre><h4><b>PARSING</b> <b>BACKSLASH</b> <b>SEQUENCES</b></h4><pre>
       The <b>Tcl_Backslash</b> function is called to parse Tcl backslash sequences.  These backslash sequences are the
       usual  sort  that  you  see  in the C programming language, such as <b>\n</b> for newline, <b>\r</b> for return, and so
       forth.  <b>Tcl_Backslash</b> parses a single backslash sequence and returns a single character corresponding  to
       the backslash sequence.

       For  more  info  on  this  call,  look at the <b><a href="../man3/Backslash.3.html">Backslash</a></b>(3) manual page in the core Tcl distribution.  For
       information on the valid backslash sequences, consult the summary of Tcl language syntax, <b>Tcl</b>(n)  in  the
       same distribution.

</pre><h4><b>HASH</b> <b>TABLES</b></h4><pre>
       <u>Hash</u>  <u>tables</u>  provide  Tcl  with  a high-performance facility for looking up and managing key-value pairs
       located and maintained in memory.  Tcl uses hash tables internally to locate procedure  definitions,  Tcl
       variables, array elements, file handles and so forth.  Tcl makes the hash table functions accessible to C
       extension writers as well.

       Hash  tables  grow  automatically  to  maintain  efficiency,  rather  than exposing the table size to the
       programmer at allocation time, which would needlessly add  complexity  to  Tcl  and  would  be  prone  to
       inefficiency  due to the need to guess the number of items that will go into the table, and the seemingly
       inevitable growth in amount of data processed per run over the useful life of the program.

       For more information on hash tables, please consult the <b><a href="../man3/Hash.3.html">Hash</a></b>(3) manual page in the core Tcl distribution.

</pre><h4><b>TRACING</b> <b>VARIABLE</b> <b>ACCESSES</b></h4><pre>
       The C extension writer can arrange to have a C routine called whenever a Tcl variable is  read,  written,
       or  unset.  Variable traces are the mechanism by which Tk toolkit widgets such as radio and checkbuttons,
       messages and so forth update without Tcl programmer intervention when their data variables  are  changed.
       They are also used by the routine that links Tcl and C variables, <b>Tcl_LinkVar</b>, described above.

       <b>Tcl_TraceVar</b> is called to establish a variable trace.  Entire arrays and individual array elements can be
       traced  as  well.   If  the  programmer  already  has  an array name in one string and a variable name in
       another, <b>Tcl_TraceVar2</b> can be called.  Calls are also available to request information about  traces  and
       to delete them.

       For  more  information  on  variable  traces,  consult  the  <b><a href="../man3/TraceVar.3.html">TraceVar</a></b>(3)  manual  page  in  the  core Tcl
       distribution.

</pre><h4><b>TRACING</b> <b>TCL</b> <b>EXECUTION</b></h4><pre>
       Tcl has the ability to call C routines each time it executes a Tcl command, up to a  specified  depth  of
       nesting levels.  The command <b>Tcl_CreateTrace</b> creates an execution trace; <b>Tcl_DeleteTrace</b> deletes it.

       Command  tracing  is  used  in  Extended  Tcl to implement the <u>cmdtrace</u> Tcl command, a useful command for
       debugging Tcl applications.

       For complete information on execution tracing, please look at the <b><a href="../man3/CrtTrace.3.html">CrtTrace</a></b>(3) manual pages  in  the  core
       Tcl distribution.

</pre><h4><b>EVALUATING</b> <b>TCL</b> <b>EXPRESSIONS</b> <b>FROM</b> <b>C</b></h4><pre>
       <b>Tcl_ExprLong</b>,  <b>Tcl_ExprDouble</b>,  <b>Tcl_ExprBool</b>,  and  <b>Tcl_ExprString</b>  all  take  string arguments and, when
       called, evaluate those strings as Tcl expressions.  Depending on the routine called, the result is either
       a C <u>long</u>, a <u>double</u>, a boolean  (<u>int</u>  with  a  value  of  <b>0</b>  or  <u>1</u>),  or  a  <u>char</u>  <u>*</u>  (obtainable  through
       <b>Tcl_GetResult</b>).

       To  take  advantage  of  the  performance gains available through the bytecode compiler, <b>Tcl_ExprLongObj</b>,
       <b>Tcl_ExprDoubleObj</b>, <b>Tcl_ExprBoolObj</b>, and <b>Tcl_ExprObj</b> all take an object containing  an  expression  to  be
       evaluated (rather than a string.)  The result is that bytecode-compiled version of the expression will be
       kept  in  the object, alongside the string representation.  If the expression is evaluated again, without
       being changed, it does not have to be recompiled... a major performance win.

       For complete information on evaluating Tcl expressions from C, you are invited to examine the <b><a href="../man3/ExprLong.3.html">ExprLong</a></b>(3)
       and <b><a href="../man3/ExprLongObj.3.html">ExprLongObj</a></b>(3) manpages in the core Tcl distribution.

</pre><h4><b>PATTERN</b> <b>MATCHING</b></h4><pre>
       The  <b>Tcl_StringMatch</b>  function  can  be  called  to  see  if  a  string  matches  a  specified   pattern.
       <b>Tcl_StringMatch</b>  is called by the Tcl <u>string</u> <u>match</u> command, so the format for patterns is identical.  The
       pattern format is similar to the one used by the C-shell; <b>string</b>(n) describes this format.

       More information about  <b>Tcl_StringMatch</b>  is  available  in  the  <b><a href="../man3/StrMatch.3.html">StrMatch</a></b>(3)  manpage  in  the  core  Tcl
       distribution.

</pre><h4><b>REGULAR</b> <b>EXPRESSION</b> <b>PATTERN</b> <b>MATCHING</b></h4><pre>
       <b>Tcl_RegExpMatch</b>   can   be   called   to  determine  whether  a  string  matches  a  regular  expression.
       <b>Tcl_RegExpMatch</b> is used internally by the <u>regexp</u> Tcl command.

       As regular expressions are typically "compiled" before use, a fairly involved process, Tcl also  supports
       routines that separate the compilation of an expression from its use:  <b>Tcl_RegExpCompile</b>, <b>Tcl_RegExpExec</b>,
       and  <b>Tcl_RegExpRange</b>.   If  an  expression  is going to be matched many times, doing the compile once and
       caching the compiled regular expression result, then reusing the cached version by using  <b>Tcl_RegExpExec</b>,
       can be a significant performance win.

       For more information on this function, please consult the <b><a href="../man3/RegExp.3.html">RegExp</a></b>(3) manpage in the core Tcl distribution.

</pre><h4><b>MANIPULATING</b> <b>TCL</b> <b>LISTS</b> <b>FROM</b> <b>C</b> <b>EXTENSIONS</b></h4><pre>
       The  C  extension  writer  often  needs to create, manipulate and decompose Tcl lists.  <b>Tcl_SplitList</b> and
       <b>Tcl_Merge</b> used to be the only way to parse strings into lists and vice versa.  As of Tcl 8, lists can  be
       parsed  and  assembled, object-style, using <b>Tcl_ListObjGetElements</b> and <b>Tcl_SetListObj</b>, and friends.  Once
       again the "win" of using object-system-based list manipulation, instead  of  the  previous  string  based
       routines,  is  that the parsing of a string in an object to a list is cached in the object structure, the
       same as with integers and floating point numbers, compiled procedures, etc.  The next  time  this  string
       needs to be looked at as a list, if the contents of the string have not changed, the string does not have
       to be parsed.

       In  the  author's  experience,  working  with  an  admittedly  degenerate test whereby we iterated rather
       inefficiently across a 6,000-element list, a speedup factor of more  than  2500  was  obtained  over  the
       previous non-object-based version of Tcl.

       For  more  information  on  these  commands,  please  consult  the <b><a href="../man3/ListObj.3.html">ListObj</a></b>(3) manual page in the core Tcl
       distribution.

</pre><h4><b>CONCATENATING</b> <b>STRINGS</b></h4><pre>
       <b>Tcl_ConcatObj</b> concatenates the string representation of zero or more objects into a  single  new  object.
       The  elements  of  the  new  string  are space-separated.  <b>Tcl_Concat</b> does the same thing for strings, as
       <b>Tcl_ConcatObj</b> does for objects.

       Concatenating strings is  similar  to  constructing  lists  from  them,  except  that  <b>Tcl_ConcatObj</b>  and
       <b>Tcl_Concat</b> do not attempt to make the resulting string into a valid Tcl list.

       <b>Tcl_Concat</b> is documented in the <b><a href="../man3/Concat.3.html">Concat</a></b>(3) manpage, and <b>Tcl_ConcatObj</b> in the <b>tringObj</b> manpage, both in the
       core Tcl distribution.

</pre><h4><b>DETECTING</b> <b>WHETHER</b> <b>OR</b> <b>NOT</b> <b>YOU</b> <b>HAVE</b> <b>A</b> <b>COMPLETE</b> <b>COMMAND</b></h4><pre>
       C  routines that collect data to form a command to be passed to <u>Tcl_Eval</u> often need a way to tell whether
       they have a complete command already or whether they need more data.  (Programs that  read  typed-in  Tcl
       input  such  as  Tcl shells need this capability, for instance.)  <b>Tcl_CommandComplete</b> can be used to tell
       whether or not you have a complete command.

       For more information examine <b><a href="../man3/CmdCmplt.3.html">CmdCmplt</a></b>(3) in the core Tcl distribution.

</pre><h4><b>RECORDING</b> <b>COMMANDS</b> <b>FOR</b> <b>COMMAND</b> <b>HISTORY</b></h4><pre>
       Tcl has a history mechanism that is accessed from Tcl through the <u>history</u>  command.   If  you  want  your
       extension  to  propagate  commands into the command history, you should call <u>Tcl_RecordAndEvalObj</u> (object
       system) or <u>Tcl_RecordAndEval</u> (old system),

       These commands work like <u>Tcl_EvalObj</u> and <u>Tcl_Eval</u>, respectively, except that these  versions  record  the
       command as well as executing it.

       <u>Tcl_RecordAndEval</u>  and  <u>Tcl_RecordAndEvlObj</u>  should  only be called with user-entered top-level commands,
       since the history mechanism exists to allow the user to easily access, edit and reissue previously issued
       commands.

       For complete information on these functions, please examine  the  <b>RecordEval</b>.3  and  <b>RecEvalObj</b>.3  manual
       pages in the core Tcl distribution.

</pre><h4><b>CONVERTING</b> <b>FLOATING</b> <b>POINT</b> <b>VALUES</b> <b>TO</b> <b>STRINGS</b></h4><pre>
       The  Tcl  object  system's  <b>Tcl_GetDoubleFromObj</b>  and  <b>Tcl_SetDoubleObj</b>  use Tcl objects, rather than the
       strings used by <b>Tcl_PrintDouble</b>, and convert, when necessary, an ASCII string to a <u>double</u> and back again.

       These routines ensure that the string output will continue  to  be  interpretable  as  a  floating  point
       number,  rather  than  an  integer,  by  always putting a ``.'' or ``e'' into the string representing the
       number.

       The precision of the output string is controlled by the Tcl <b>tcl_precision</b> variable.

       For complete information on these routines, please examine <b><a href="../man3/DoubleObj.3.html">DoubleObj</a></b>(3) and <b><a href="../man3/PrintDbl.3.html">PrintDbl</a></b>(3) in the  core  Tcl
       distribution.

</pre><h4><b>CREATING</b> <b>CHILD</b> <b>PROCESSES</b> <b>AND</b> <b>PIPELINES</b> <b>FROM</b> <b>C</b></h4><pre>
       <b>Tcl_OpenCommandChannel</b>  provides  a  C-level  interface  to  the  <b>exec</b>  and <b>open</b> commands.  The child (or
       pipeline of children) can have its standard input, output and error redirected from files,  variables  or
       pipes.   To  understand  the  meaning of the redirection symbols understood by this function, look at the
       <b>exec</b>(n) Tcl command.  For complete information on <b>Tcl_OpenCommandChannel</b>, please examine <b><a href="../man3/OpenFileChnl.3.html">OpenFileChnl</a></b>(3).

</pre><h4><b>ACCESSING</b> <b>TCL</b> <b>FILEHANDLES</b> <b>FROM</b> <b>C</b></h4><pre>
       On Posix/Unix systems, Tcl filehandles passed to your C extension can be translated to  a  Posix  <u>FILE</u>  <u>*</u>
       structure using the <b>Tcl_GetOpenFile</b> function, documented in <b>GetOpnFl</b>.3.

</pre><h4><b>MANAGING</b> <b>BACKGROUND</b> <b>PROCESS</b> <b>TERMINATION</b> <b>AND</b> <b>CLEANUP</b></h4><pre>
       When  a  Posix system does a <u>fork</u> to create a new process, the process ID of the child is returned to the
       caller.  After the child process exits, its process table entry (and some other data associated with  the
       process)  cannot  be  reclaimed  by  the  operating system until a call to <u>waitpid</u>, or one of a couple of
       other, similar system calls, has been made by the parent process.

       The C extension writer who has created a subprocess, by whatever mechanism, can turn over  responsibility
       for  detecting  the  processes'  termination  and  calling  <u>waitpid</u> to obtain its exit status, by calling
       <b>Tcl_DetachPids</b> on it.

       <b>Tcl_ReapDetachedProcs</b> is the C routine that will detect the termination of any processes turned  over  to
       Tcl, permitting the processes to be fully reclaimed by the operating system.  It is usually not necessary
       to call <b>Tcl_ReapDetachedProcs</b>, as it is called automatically every time <b>exec</b> is performed.

       For complete information on these routines, please look at <u><a href="../man3/DetachPids.3.html">DetachPids</a>(3)</u> in the core Tcl distribution.

</pre><h4><b>FOR</b> <b>MORE</b> <b>INFORMATION</b></h4><pre>
       In addition to the documentation referenced above, you can learn a lot by studying the source code of the
       commands  added by Tcl, Tk and Extended Tcl, etc.  The <u>comp.lang.tcl</u> Usenet newsgroup is read by hundreds
       of thousands of Tcl people.  A number of Frequently Asked Questions (FAQs) about  Tcl  are  posted  there
       periodically.  The newsgroup is a good place to ask questions (after you've made sure they're not already
       answered in the FAQ ;-)

       Finally,  if you have interactive Internet access, you can ftp to <u><a href="ftp://ftp.neosoft.com/pub/tcl">ftp://ftp.neosoft.com/pub/tcl</a></u>, the site
       for contributed Tcl sources.  This site contains quite a few  extensions,  applications,  and  so  forth,
       including several object-oriented extension packages.

       If    you   have   access   via   the   world-wide   web,   check   out   the   Sun   Microsystems   site
       (<u><a href="http://sunscript.sun.com">http://sunscript.sun.com</a></u>), the contributed sources archive website (<u><a href="http://www.neosoft.com/tcl">http://www.neosoft.com/tcl</a></u>), and the
       homepage for Extended Tcl (<u><a href="http://www.neosoft.com/tclx">http://www.neosoft.com/tclx</a></u>).

</pre><h4><b>AUTHORS</b></h4><pre>
       Extended Tcl was created by Karl Lehenbauer (<a href="mailto:karl@neosoft.com">karl@neosoft.com</a>) and Mark Diekhans (<a href="mailto:markd@grizzly.com">markd@grizzly.com</a>).

Tcl                                                                                       <u>Command</u> <u><a href="../man3tclx/Writing.3tclx.html">Writing</a></u>(3tclx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>