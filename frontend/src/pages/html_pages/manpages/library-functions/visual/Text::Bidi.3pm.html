<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::Bidi - Unicode bidi algorithm using libfribidi</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-bidi-perl">libtext-bidi-perl_2.18-1build4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::Bidi - Unicode bidi algorithm using libfribidi

</pre><h4><b>VERSION</b></h4><pre>
       version 2.18

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # Each displayed line is a "paragraph"
           use Text::Bidi qw(log2vis);
           ($par, $map, $visual) = log2vis($logical);
           # or just
           $visual = log2vis(...);

           # For real paragraphs, need to specify the display width
           ($par, $map, $visual) = log2vis($logical, $width);

           # object oriented approach allows one to display line by line
           $p = new Text::Bidi::Paragraph $logical;
           $visual = $p-&gt;visual($off, $len);

</pre><h4><b>EXPORT</b></h4><pre>
       The following functions can be exported (nothing is exported by default):

       •   "log2vis"

       •   "is_bidi"

       •   "get_mirror_char"

       •   "get_bidi_type_name"

       •   "fribidi_version"

       •   "unicode_version"

       •   "fribidi_version_num"

       All of them can be exported together using the ":all" tag.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  provides  basic support for the Unicode bidirectional (Bidi) text algorithm, for displaying
       text consisting of both left-to-right and right-to-left written languages (such as Hebrew and Arabic.) It
       does so via a <u>swig</u> interface file to the <u>libfribidi</u> library.

       The fundamental purpose of the bidi algorithm is to reorder text given in  logical  order  into  text  in
       visually  correct  order,  suitable for display using standard printing commands. ``Logical order'' means
       that the characters are given in the order in  which  they  would  be  read  if  printed  correctly.  The
       direction  of  the text is determined by properties of the Unicode characters, usually without additional
       hints.  See &lt;<a href="http://www.unicode.org/unicode/reports/tr9/">http://www.unicode.org/unicode/reports/tr9/</a>&gt;  for  more  details  on  the  problem  and  the
       algorithm.

   <b>Standard</b> <b>usage</b>
       The  bidi algorithm works in two stages. The first is on the level of a paragraph, where the direction of
       each character is computed. The second is on the level of the lines to be displayed. The  main  practical
       difference  is  that  the  first stage requires only the text of the paragraph, while the second requires
       knowledge of the width of the displayed lines. The module (or the library) does  not  determine  how  the
       text is broken into paragraphs.

       The  full  interface is provided by Text::Bidi::Paragraph, see there for details. This module provides an
       abbreviation,  "log2vis",  which  combines  creating  a  paragraph  object  with  calling   "visual"   in
       Text::Bidi::Paragraph  on  it.   It is particularly useful in the case that the whole paragraph should be
       displayed at once, and the display width is known:

           $visual = log2vis($logical, $width);

       There are more options (see "log2vis"), but this is essentially it. The rest of this  documentation  will
       probably  be  useful only to people who are familiar with <u>libfribidi</u> and who wish to extend or modify the
       module.

   <b>The</b> <b>object-oriented</b> <b>approach</b>
       All functions here can be called using either a procedural or an object oriented approach.  For  example,
       you may do either

               $visual = log2vis($logical);

       or

               $bidi = new Text::Bidi;
               $visual = $bidi-&gt;log2vis($logical);

       The  advantages  of  the  second  form  is that it is easier to move to a sub-class, and that two or more
       objects with different parameters can be used simultaneously. If you are interested in deriving from this
       class, please see "SUBCLASSING".

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>get_bidi_type_name</b>
           say $tb-&gt;get_bidi_type_name($Text::Bidi::Type::LTR); # says 'LTR'

       Return the string representation of a Bidi character type, as in <b><a href="../man3/fribidi_get_bidi_type_name.3.html">fribidi_get_bidi_type_name</a></b>(3). Note that
       for the above example, one needs to use Text::Bidi::Constants.

   <b>log2vis</b>
           ($p, $visual) = log2vis($logical[,$width[,$dir[,$flags]]]);

       Convert the input paragraph <b>$logical</b> to visual. This constructs a Text::Bidi::Paragraph object, and calls
       "visual" in Text::Bidi::Paragraph several times, as required. <b>$width</b> is the  maximum  width  of  a  line,
       defaulting to the whole length of the paragraph.  <b>$dir</b> is the base direction of the paragraph, determined
       automatically  if not provided.  <b>$flags</b> is as in "visual" in Text::Bidi::Paragraph. The paragraph will be
       justified to the right if it is RTL.

       The output consists of the Text::Bidi::Paragraph object <b>$p</b> and the visual string <b>$visual</b>.

   <b>is_bidi()</b>
           my $bidi = is_bidi($logical);

       Returns true if the input <b>$logical</b> contains bidi characters. Otherwise, the output of the bidi  algorithm
       will be identical to the input, hence this helps if we want to short-circuit.

   <b>get_mirror_char()</b>
           my $mir = get_mirror_char('['); # $mir == ']'

       Return the mirror character of the input, possibly itself.

   <b>fribidi_version</b>
           say fribidi_version();

       Returns the version information for the fribidi library

   <b>fribidi_version_num</b>
           say fribidi_version_num();

       Returns the version number for the fribidi library

   <b>unicode_version</b>
           say unicode_version();

       Returns the Unicode version used by the fribidi library

</pre><h4><b>SUBCLASSING</b></h4><pre>
       The  rest  of  the  documentation  is  only  interesting if you would like to derive from this class. The
       methods listed under "METHODS" are wrappers around the similarly named functions in libfribidi,  and  may
       be useful for this purpose.

       If you do sub-class this class, and would like the procedural interface to use your functions, put a line
       like

               $Text::Bidi::GlobalClass = __PACKAGE__;

       in your module.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
           $tb = new Text::Bidi [tie_byte =&gt; ..., tie_long =&gt; ...];

       Create  a  new Text::Bidi object. If the <u>tie_byte</u> or <u>tie_long</u> options are given, they should be the names
       (strings) of the classes used as dual life arrays, most probably derived class of Text::Bidi::Array::Byte
       and Text::Bidi::Array::Long, respectively.

       This method is probably of little interest for standard (procedural) use.

   <b>utf8_to_internal</b>
           $la = $tb-&gt;utf8_to_internal($str);

       Convert the Perl string <u>$str</u>  into  the  representation  used  by  libfribidi.   The  result  will  be  a
       Text::Bidi::Array::Long.

   <b>internal_to_utf8</b>
           $str = $tb-&gt;internal_to_utf8($la);

       Convert  the  long  array <u>$la</u>, representing a string encoded in to format used by libfribidi, into a Perl
       string. The array <u>$la</u> can be either a Text::Bidi::Array::Long, or anything that can be used to  construct
       it.

   <b>get_bidi_types</b>
           $types = $tb-&gt;get_bidi_types($internal);

       Returns  a  Text::Bidi::Array::Long  with  the  list  of  Bidi  types  of  the text given by $internal, a
       representation of the paragraph text, as returned by <b>utf8_to_internal()</b>. Wraps <b><a href="../man3/fribidi_get_bidi_types.3.html">fribidi_get_bidi_types</a></b>(3).

   <b>get_joining_types</b>
           $types = $tb-&gt;get_joining_types($internal);

       Returns a Text::Bidi::Array::Byte with the list of joining types  of  the  text  given  by  <b>$internal</b>,  a
       representation    of    the    paragraph    text,    as    returned    by    "utf8_to_internal".    Wraps
       <b><a href="../man3/fribidi_get_joining_types.3.html">fribidi_get_joining_types</a></b>(3).

   <b>get_joining_type_name</b>
           say $tb-&gt;get_joining_type_name($Text::Bidi::Joining::U); # says 'U'

       Return the string representation of a joining character  type,  as  in  <b><a href="../man3/fribidi_get_joining_type_name.3.html">fribidi_get_joining_type_name</a></b>(3).
       Note that for the above example, one needs to use Text::Bidi::Constants.

   <b>get_par_embedding_levels</b>
          ($odir, $lvl) = $tb-&gt;get_par_embedding_levels($types[, $dir]);

       Return  the  embedding  levels  of  the  characters,  whose  types  are  given  by  <u>$types</u>.  <u>$types</u>  is a
       Text::Bidi::Array::Long of Bidi types, as returned  by  "get_bidi_types".  <u>$dir</u>  is  the  base  paragraph
       direction. If not given, it defaults to "FRIBIDI_PAR_ON" (neutral).

       The  output  is  the  resolved  paragraph  direction <u>$odir</u>, and the Text::Bidi::Array::Byte array <u>$lvl</u> of
       embedding levels.

   <b>join_arabic</b>
           $props = $tb-&gt;join_arabic($bidi_types, $lvl, $join_types);

       Returns a Text::Bidi::Array::Byte with <b>$props</b>, as returned  by  <b><a href="../man3/fribidi_join_arabic.3.html">fribidi_join_arabic</a></b>(3).  The  inputs  are
       <b>$bidi_types</b>,  as  returned  by  "get_bidi_types",  <b>$lvl</b>,  as  returned by "get_par_embedding_levels", and
       <b>$join_types</b> as returned by "get_joining_types".  Wraps <b><a href="../man3/fribidi_join_arabic.3.html">fribidi_join_arabic</a></b>(3).

   <b>shaped</b>
           ($newp, $shaped) = $tb-&gt;shaped($flags, $lvl, $prop, $internal);

       Returns the internal representation of the paragraph, with shaping applied.  The internal  representation
       of  the  original  paragraph (as returned by "utf8_to_internal") should be passed in <b>$internal</b>, while the
       embedding levels (as returned by "get_par_embedding_levels") should be in <b>$lvl</b>.  See the documentation of
       <u>fribidi-arabic.h</u> for <b>$flags</b>, but as a special case, a value of  "undef"  here  skips  shaping  (returning
       <b>($prop,</b>  <b>$internal)</b>),  while  any  other  false  value  becomes  the  default.  <b>$prop</b>  is  as returned by
       "join_arabic".  This method wraps <b><a href="../man3/fribidi_shape_arabic.3.html">fribidi_shape_arabic</a></b>(3).

   <b>mirrored</b>
           $mirrored = $tb-&gt;mirrored($lvl, $internal);

       Returns  the  internal  representation  of  the  paragraph,  with  mirroring   applied.    The   internal
       representation  of  the  original  paragraph  (as  returned  by  "utf8_to_internal")  should be passed in
       <b>$internal</b>, while the embedding levels (as returned by  "get_par_embedding_levels")  should  be  in  <b>$lvl</b>.
       This method wraps <b><a href="../man3/fribidi_shape_mirroring.3.html">fribidi_shape_mirroring</a></b>(3).

   <b>reorder</b>
           $str = $tb-&gt;reorder($in, $map[, $offset[, $len]]);
           say $tb-&gt;reorder([qw(A B C)], [2, 0, 1]); # says CAB

       View  the  array ref <b>$map</b> as a permutation, and permute the list (of characters) <b>$in</b> according to it. The
       result is joined, to obtain a string.  If <b>$offset</b> and <b>$len</b> are given,  returns  only  that  part  of  the
       resulting string.

   <b>reorder_map</b>
           ($elout, $mout) = $tb-&gt;reorder_map($types, $offset, $len, $par,
                                              $map, $el, $flags);

       Compute  the  reordering  map  for  bidi types given by <b>$types</b>, for the interval starting with <b>$offset</b> of
       length <b>$len</b>. Note that this part of the algorithm depends on the interval in an essential way. <b>$types</b>  is
       an array of types, as computed by "get_bidi_types". The other arguments are optional:

       <b>$par</b>
           The base paragraph direction. Computed via "get_par_embedding_levels" if not defined.

       <b>$map</b>
           An  array  ref  (or  a Text::Bidi::Array::Long) from a previous call (with a different interval). The
           method is called repeatedly for the same paragraph, with different intervals, and the reordering  map
           is updated for the given interval. If not defined, initialised to the identity map.

       <b>$el</b> The embedding levels. If not given, computed by a call to "get_par_embedding_levels".

       <b>$flags</b>
           A specification of flags, as described in <b><a href="../man3/fribidi_reorder_line.3.html">fribidi_reorder_line</a></b>(3). The flags can be given either as a
           number  (using  "$Text::Bidi::Flags::.."  from  Text::Bidi::Constants),  or  as a hashref of the form
           "{REORDER_NSM =&gt; 1}". Defaults to "FRIBIDI_FLAGS_DEFAULT".

       The output consists of  the  modified  map  <b>$mout</b>  (a  Text::Bidi::Array::Long),  and  possibly  modified
       embedding levels <b>$elout</b>.

       method remove_bidi_marks

           ($v, $to, $from, $levels) =
               $tb-&gt;remove_bidi_marks($v[, $to[, $from[, $levels]]])

       Remove the explicit bidi marks from $v. The optional arguments, if given, are the map from the logical to
       the visual string, the inverse map, and embedding levels, respectively, as returned by "reorder_map". The
       inverse map $from can be obtained from the direct one $to by a command like:

           @$from[@$map] = 0..$#$map

       Each  of  the  arguments  can  be "undef", in which case it will be skipped. This implements step X9, see
       <b><a href="../man3/fribidi_remove_bidi_marks.3.html">fribidi_remove_bidi_marks</a></b>(3).

</pre><h4><b>BUGS</b></h4><pre>
       There are no real tests for any of this.

       Shaping is not supported (probably), since I don't know what it is. Help welcome!

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Text::Bidi::Paragraph

       Text::Bidi::Constants

       Encode

       The fribidi library &lt;<a href="http://fribidi.org/">http://fribidi.org/</a>&gt;

       Swig &lt;<a href="http://www.swig.org">http://www.swig.org</a>&gt;

       The unicode bidi algorithm &lt;<a href="http://www.unicode.org/unicode/reports/tr9/">http://www.unicode.org/unicode/reports/tr9/</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Moshe Kamensky &lt;<a href="mailto:kamensky@cpan.org">kamensky@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2015 by Moshe Kamensky.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.40.0                                       2024-10-20                                    <u>Text::<a href="../man3pm/Bidi.3pm.html">Bidi</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>