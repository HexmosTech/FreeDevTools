<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ets - Built-in term storage.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ets - Built-in term storage.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module is an interface to the Erlang built-in term storage BIFs. These provide the ability to store
       very large quantities of data in an Erlang runtime system, and to have constant access time to the  data.
       (In  the  case  of  <u>ordered_set</u>, see below, access time is proportional to the logarithm of the number of
       stored objects.)

       Data is organized as a set of dynamic tables, which can store tuples. Each table is created by a process.
       When the process terminates, the table is automatically destroyed. Every table has access rights  set  at
       creation.

       Tables  are  divided  into  four  different  types,  <u>set</u>,  <u>ordered_set</u>,  <u>bag</u>, and <u>duplicate_bag</u>. A <u>set</u> or
       <u>ordered_set</u> table can only have one object associated with each key. A <u>bag</u>  or  <u>duplicate_bag</u>  table  can
       have many objects associated with each key.

   <b>Note:</b>
       The  number of tables stored at one Erlang node <u>used</u> to be limited. This is no longer the case (except by
       memory usage). The previous default limit was about 1400 tables and could be  increased  by  setting  the
       environment  variable <u>ERL_MAX_ETS_TABLES</u> or the command line option <u>+e</u> before starting the Erlang runtime
       system. This hard limit has been removed, but it  is  currently  useful  to  set  the  <u>ERL_MAX_ETS_TABLES</u>
       anyway.  It  should be set to an approximate of the maximum amount of tables used since an internal table
       for  named  tables  is  sized  using  this  value.  If  large  amounts  of  named  tables  are  used  and
       <u>ERL_MAX_ETS_TABLES</u> hasn't been increased, the performance of named table lookup will degrade.

       Notice  that  there  is  no automatic garbage collection for tables. Even if there are no references to a
       table from any process, it is not automatically destroyed unless the owner process terminates. To destroy
       a table explicitly, use function <u>delete/1</u>. The default owner is the process that created  the  table.  To
       transfer table ownership at process termination, use option <u>heir</u> or call <u>give_away/3</u>.

       Some implementation details:

         * In  the  current  implementation,  every object insert and look-up operation results in a copy of the
           object.

         * <u>'$end_of_table'</u> is not to be used as a key, as this atom is used to mark the end of  the  table  when
           using functions <u>first/1</u> and <u>next/2</u>.

       Notice  the  subtle difference between <u>matching</u> and <u>comparing</u> <u>equal</u>, which is demonstrated by table types
       <u>set</u> and <u>ordered_set</u>:

         * Two Erlang terms <u>match</u> if they are of the same type and have the same value, so that <u>1</u> matches <u>1</u>, but
           not <u>1.0</u> (as <u>1.0</u> is a <u>float()</u> and not an <u>integer()</u>).

         * Two Erlang terms <u>compare</u> <u>equal</u> if they either are of the same type and value, or if both are  numeric
           types and extend to the same value, so that <u>1</u> compares equal to both <u>1</u> and <u>1.0</u>.

         * The <u>ordered_set</u> works on the <u>Erlang</u> <u>term</u> <u>order</u> and no defined order exists between an <u>integer()</u> and a
           <u>float()</u>  that  extends to the same value. Hence the key <u>1</u> and the key <u>1.0</u> are regarded as equal in an
           <u>ordered_set</u> table.

</pre><h4><b>FAILURES</b></h4><pre>
       Functions in this module fail by raising an error exception with error reason:

         <u>badarg</u>:
           If any argument has the wrong format.

         <u>badarg</u>:
           If the table identifier is invalid.

         <u>badarg</u>:
           If the operation is denied because of table access rights (protected or private).

         <u>system_limit</u>:
           Modification of a value causes it to  not  be  representable  internally  in  the  VM.  For  example,
           incrementation of a counter past the largest integer representable.

         <u>system_limit</u>:
           If  a  match  specification  passed  as  argument  has excessive nesting which causes scheduler stack
           exhaustion for the scheduler that the calling process is executing on. Scheduler stack  size  can  be
           configured when starting the runtime system.

</pre><h4><b>CONCURRENCY</b></h4><pre>
       This  module  provides  some  limited  support  for  concurrent access. All updates to single objects are
       guaranteed to be both <u>atomic</u> and <u>isolated</u>. This means that an  updating  operation  to  a  single  object
       either  succeeds  or  fails completely without any effect (atomicity) and that no intermediate results of
       the update can be seen by other processes (isolation). Some functions that update many objects state that
       they even guarantee atomicity and isolation for the entire operation. In  database  terms  the  isolation
       level  can  be  seen as "serializable", as if all isolated operations are carried out serially, one after
       the other in a strict order.

</pre><h4><b>TABLE</b> <b>TRAVERSAL</b></h4><pre>
       There are different ways to traverse through the objects of a table.

         * <u>Single-step</u> traversal one key at at time, using <u>first/1</u>, <u>next/2</u>, <u>last/1</u> and <u>prev/2</u>.

         * Search with simple <u>match</u> <u>patterns</u>, using <u>match/1/2/3</u>, <u>match_delete/2</u> and <u>match_object/1/2/3</u>.

         * Search with more powerful <u>match</u> <u>specifications</u>, using <u>select/1/2/3</u>, <u>select_count/2</u>,  <u>select_delete/2</u>,
           <u>select_replace/2</u> and <u>select_reverse/1/2/3</u>.

         * <u>Table</u> <u>conversions</u>, using <u>tab2file/2/3</u> and <u>tab2list/1</u>.

       No  table traversal will guarantee a consistent snapshot of the entire table if the table is also updated
       by concurrent processes during the traversal. The result of each concurrently updated object may be  seen
       (or  not)  depending on if it has happened when the traversal visits that part of the table. The only way
       to guarantee a full consistent table snapshot (if you really need that) is to disallow concurrent updates
       during the entire traversal.

       Moreover, traversals not done in a <u>safe</u> way, on tables where keys are  inserted  or  deleted  during  the
       traversal, may yield the following undesired effects:

         * Any key may be missed.

         * Any key may be found more than once.

         * The traversal may fail with <u>badarg</u> exception if keys are deleted.

       A table traversal is <u>safe</u> if either

         * the table is of type <u>ordered_set</u>.

         * the entire table traversal is done within one ETS function call.

         * function <u>safe_fixtable/2</u> is used to keep the table fixated during the entire traversal.

   <b>Note:</b>
       Even  though the access of a single object is always guaranteed to be atomic and isolated, each traversal
       through a table to find the next key is not done with such guarantees. This is often not a  problem,  but
       may  cause  rare  subtle "unexpected" effects if a concurrent process inserts objects during a traversal.
       For example, consider one process doing

       ets:new(t, [ordered_set, named_table]),
       ets:insert(t, {1}),
       ets:insert(t, {2}),
       ets:insert(t, {3}),

       A concurrent call to <u>ets:first(t)</u>, done by another process, may then in rare cases return <u>2</u> even though <u>2</u>
       has never existed in the table ordered as  the  first  key.  In  the  same  way,  a  concurrent  call  to
       <u>ets:next(t,</u> <u>1)</u> may return <u>3</u> even though <u>3</u> never existed in the table ordered directly after <u>1</u>.

       Effects like this are improbable but possible. The probability will further be reduced (if not vanish) if
       table  option <u>write_concurrency</u> is not enabled. This can also only be a potential concern for <u>ordered_set</u>
       where the traversal order is defined.

       Traversals using <u>match</u> and <u>select</u> functions may not need to scan the entire table depending  on  how  the
       key  is specified. A match pattern with a <u>fully</u> <u>bound</u> <u>key</u> (without any match variables) will optimize the
       operation to a single key lookup without any table traversal at all. For <u>ordered_set</u>  a  <u>partially</u>  <u>bound</u>
       <u>key</u>  will  limit  the traversal to only scan a subset of the table based on term order. A partially bound
       key is either a list or a tuple with a prefix that is fully bound. Example:

       1&gt; T = ets:new(t,[ordered_set]), ets:insert(T, {"555-1234", "John Smith"}).
       true
       2&gt; %% Efficient search of all with area code 555
       2&gt; ets:match(T,{[$5,$5,$5,$- |'$1'],'$2'}).
       [["1234","John Smith"]]

</pre><h4><b>MATCH</b> <b>SPECIFICATIONS</b></h4><pre>
       Some of the functions use a <u>match</u> <u>specification</u>, <u>match_spec</u>. For a brief explanation, see <u>select/2</u>. For a
       detailed description, see section  Match Specifications in Erlang in ERTS User's Guide.

       A match specifications with excessive nesting will cause a <u>system_limit</u> error exception to be raised.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>access()</b> = public | protected | private

       <b>continuation()</b>

              Opaque continuation used by <u>select/1,3</u>, <u>select_reverse/1,3</u>, <u>match/1,3</u>, and <u>match_object/1,3</u>.

       <b>match_spec()</b> = [{match_pattern(), [term()], [term()]}]

              A match specification, see above.

       <b>comp_match_spec()</b>

              A compiled match specification.

       <b>match_pattern()</b> = atom() | tuple()

       <b>tab()</b> = atom() | tid()

       <b>tid()</b>

              A table identifier, as returned by <u>new/2</u>.

       <b>type()</b> = set | ordered_set | bag | duplicate_bag

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>all()</b> <b>-&gt;</b> <b>[Tab]</b>

              Types:

                 Tab = tab()

              Returns a list of all tables at the node. Named tables  are  specified  by  their  names,  unnamed
              tables are specified by their table identifiers.

              There  is  no  guarantee  of  consistency in the returned list. Tables created or deleted by other
              processes "during" the <u>ets:all()</u> call either are or are not included  in  the  list.  Only  tables
              created/deleted <u>before</u> <u>ets:all()</u> is called are guaranteed to be included/excluded.

       <b>delete(Tab)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Tab = tab()

              Deletes the entire table <u>Tab</u>.

       <b>delete(Tab,</b> <b>Key)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Tab = tab()
                 Key = term()

              Deletes all objects with key <u>Key</u> from table <u>Tab</u>.

       <b>delete_all_objects(Tab)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Tab = tab()

              Delete all objects in the ETS table <u>Tab</u>. The operation is guaranteed to be atomic and isolated.

       <b>delete_object(Tab,</b> <b>Object)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Tab = tab()
                 Object = tuple()

              Delete  the  exact  object  <u>Object</u> from the ETS table, leaving objects with the same key but other
              differences (useful for type <u>bag</u>). In a <u>duplicate_bag</u> table,  all  instances  of  the  object  are
              deleted.

       <b>file2tab(Filename)</b> <b>-&gt;</b> <b>{ok,</b> <b>Tab}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = file:name()
                 Tab = tab()
                 Reason = term()

              Reads a file produced by <u>tab2file/2</u> or <u>tab2file/3</u> and creates the corresponding table <u>Tab</u>.

              Equivalent to <u>file2tab(Filename,</u> <u>[])</u>.

       <b>file2tab(Filename,</b> <b>Options)</b> <b>-&gt;</b> <b>{ok,</b> <b>Tab}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = file:name()
                 Tab = tab()
                 Options = [Option]
                 Option = {verify, boolean()}
                 Reason = term()

              Reads a file produced by <u>tab2file/2</u> or <u>tab2file/3</u> and creates the corresponding table <u>Tab</u>.

              The  only  supported  option  is  <u>{verify,boolean()}</u>.  If verification is turned on (by specifying
              <u>{verify,true}</u>), the function uses whatever information is present in the file to assert  that  the
              information  is  not  damaged.  How  this is done depends on which <u>extended_info</u> was written using
              <u>tab2file/3</u>.

              If no <u>extended_info</u> is present in the file and <u>{verify,true}</u> is specified, the number  of  objects
              written  is  compared  to  the size of the original table when the dump was started. This can make
              verification fail if the table was <u>public</u> and objects were added or removed while  the  table  was
              dumped  to  file.  To  avoid  this  problem,  either  do  not  verify  files  dumped while updated
              simultaneously or use option <u>{extended_info,</u> <u>[object_count]}</u>  to  <u>tab2file/3</u>,  which  extends  the
              information in the file with the number of objects written.

              If  verification  is  turned  on  and  the file was written with option <u>{extended_info,</u> <u>[md5sum]}</u>,
              reading the file is slower and consumes radically more CPU time than otherwise.

              <u>{verify,false}</u> is the default.

       <b>first(Tab)</b> <b>-&gt;</b> <b>Key</b> <b>|</b> <b>'$end_of_table'</b>

              Types:

                 Tab = tab()
                 Key = term()

              Returns the first key <u>Key</u> in table <u>Tab</u>. For an <u>ordered_set</u> table, the first  key  in  Erlang  term
              order  is  returned.  For  other table types, the first key according to the internal order of the
              table is returned. If the table is empty, <u>'$end_of_table'</u> is returned.

              To find subsequent keys in the table, use <u>next/2</u>.

       <b>foldl(Function,</b> <b>Acc0,</b> <b>Tab)</b> <b>-&gt;</b> <b>Acc1</b>

              Types:

                 Function = fun((Element :: term(), AccIn) -&gt; AccOut)
                 Tab = tab()
                 Acc0 = Acc1 = AccIn = AccOut = term()

              <u>Acc0</u> is returned if the table is empty. This function  is  similar  to  <u>lists:foldl/3</u>.  The  table
              elements  are  traversed  in  an  unspecified order, except for <u>ordered_set</u> tables, where they are
              traversed first to last.

              If <u>Function</u> inserts objects into the table, or another process inserts  objects  into  the  table,
              those objects <u>can</u> (depending on key ordering) be included in the traversal.

       <b>foldr(Function,</b> <b>Acc0,</b> <b>Tab)</b> <b>-&gt;</b> <b>Acc1</b>

              Types:

                 Function = fun((Element :: term(), AccIn) -&gt; AccOut)
                 Tab = tab()
                 Acc0 = Acc1 = AccIn = AccOut = term()

              <u>Acc0</u>  is  returned  if  the  table  is empty. This function is similar to <u>lists:foldr/3</u>. The table
              elements are traversed in an unspecified order, except for  <u>ordered_set</u>  tables,  where  they  are
              traversed last to first.

              If  <u>Function</u>  inserts  objects  into the table, or another process inserts objects into the table,
              those objects <u>can</u> (depending on key ordering) be included in the traversal.

       <b>from_dets(Tab,</b> <b>DetsTab)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Tab = tab()
                 DetsTab = dets:tab_name()

              Fills an already created ETS table with the objects in the  already  opened  Dets  table  <u>DetsTab</u>.
              Existing objects in the ETS table are kept unless overwritten.

              If any of the tables does not exist or the Dets table is not open, a <u>badarg</u> exception is raised.

       <b>fun2ms(LiteralFun)</b> <b>-&gt;</b> <b>MatchSpec</b>

              Types:

                 LiteralFun = function()
                 MatchSpec = match_spec()

              Pseudo function that by a <u>parse_transform</u> translates <u>LiteralFun</u> typed as parameter in the function
              call  to  a match specification. With "literal" is meant that the fun must textually be written as
              the parameter of the function, it cannot be held in a variable that  in  turn  is  passed  to  the
              function.

              The  parse  transform  is  provided  in  the  <u>ms_transform</u> module and the source <u>must</u> include file
              <u>ms_transform.hrl</u> in STDLIB for this pseudo function to work. Failing to include the  hrl  file  in
              the  source  results  in  a  runtime  error, not a compile time error. The include file is easiest
              included by adding line <u>-include_lib("stdlib/include/ms_transform.hrl").</u> to the source file.

              The fun is very restricted, it can take only a single parameter (the  object  to  match):  a  sole
              variable  or  a  tuple.  It  must  use  the  <u>is</u><b>_</b>  guard  tests.  Language  constructs that have no
              representation in a match specification (<u>if</u>, <u>case</u>, <u>receive</u>, and so on) are not allowed.

              The return value is the resulting match specification.

              <u>Example:</u>

              1&gt; ets:fun2ms(fun({M,N}) when N &gt; 3 -&gt; M end).
              [{{'$1','$2'},[{'&gt;','$2',3}],['$1']}]

              Variables from the environment can be imported, so that the following works:

              2&gt; X=3.
              3
              3&gt; ets:fun2ms(fun({M,N}) when N &gt; X -&gt; M end).
              [{{'$1','$2'},[{'&gt;','$2',{const,3}}],['$1']}]

              The imported variables are replaced by match specification <u>const</u> expressions, which is  consistent
              with  the static scoping for Erlang funs. However, local or global function calls cannot be in the
              guard or body of the fun. Calls to built-in match specification functions is of course allowed:

              4&gt; ets:fun2ms(fun({M,N}) when N &gt; X, my_fun(M) -&gt; M end).
              Error: fun containing local Erlang function calls
              ('my_fun' called in guard) cannot be translated into match_spec
              {error,transform_error}
              5&gt; ets:fun2ms(fun({M,N}) when N &gt; X, is_atom(M) -&gt; M end).
              [{{'$1','$2'},[{'&gt;','$2',{const,3}},{is_atom,'$1'}],['$1']}]

              As shown by the example, the function can be called from the shell also. The fun must be literally
              in the call when used from the shell as well.

          <b>Warning:</b>
              If the <u>parse_transform</u> is not applied to a module that calls this pseudo function, the call  fails
              in  runtime  (with a <u>badarg</u>). The <u>ets</u> module exports a function with this name, but it is never to
              be called except when using the function in the shell. If the <u>parse_transform</u> is properly  applied
              by  including  header  file  <u>ms_transform.hrl</u>,  compiled  code  never  calls the function, but the
              function call is replaced by a literal match specification.

              For more information, see <u><a href="../man3erl/ms_transform.3erl.html">ms_transform</a>(3erl)</u>.

       <b>give_away(Tab,</b> <b>Pid,</b> <b>GiftData)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Tab = tab()
                 Pid = pid()
                 GiftData = term()

              Make   process   <u>Pid</u>   the   new   owner   of   table   <u>Tab</u>.   If   successful,   message   <u>{'ETS-</u>
              <u>TRANSFER',Tab,FromPid,GiftData}</u> is sent to the new owner.

              The  process <u>Pid</u> must be alive, local, and not already the owner of the table. The calling process
              must be the table owner.

              Notice that this function does not affect option <u>heir</u>  of  the  table.  A  table  owner  can,  for
              example, set <u>heir</u> to itself, give the table away, and then get it back if the receiver terminates.

       <b>i()</b> <b>-&gt;</b> <b>ok</b>

              Displays information about all ETS tables on a terminal.

       <b>i(Tab)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Tab = tab()

              Browses table <u>Tab</u> on a terminal.

       <b>info(Tab)</b> <b>-&gt;</b> <b>InfoList</b> <b>|</b> <b>undefined</b>

              Types:

                 Tab = tab()
                 InfoList = [InfoTuple]
                 InfoTuple =
                     {compressed, boolean()} |
                     {decentralized_counters, boolean()} |
                     {heir, pid() | none} |
                     {id, tid()} |
                     {keypos, integer() &gt;= 1} |
                     {memory, integer() &gt;= 0} |
                     {name, atom()} |
                     {named_table, boolean()} |
                     {node, node()} |
                     {owner, pid()} |
                     {protection, access()} |
                     {size, integer() &gt;= 0} |
                     {type, type()} |
                     {write_concurrency, boolean()} |
                     {read_concurrency, boolean()}

              Returns  information  about table <u>Tab</u> as a list of tuples. If <u>Tab</u> has the correct type for a table
              identifier, but does not refer to an existing ETS table, <u>undefined</u> is returned. If <u>Tab</u> is  not  of
              the correct type, a <u>badarg</u> exception is raised.

                <u>{compressed,</u> <u>boolean()}</u>:
                  Indicates if the table is compressed.

                <u>{decentralized_counters,</u> <u>boolean()}</u>:
                  Indicates whether the table uses <u>decentralized_counters</u>.

                <u>{heir,</u> <u>pid()</u> <u>|</u> <u>none}</u>:
                  The pid of the heir of the table, or <u>none</u> if no heir is set.

                <u>{id,tid()}</u>:
                  The table identifier.

                <u>{keypos,</u> <u>integer()</u> <u>&gt;=</u> <u>1}</u>:
                  The key position.

                <u>{memory,</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  The number of words allocated to the table.

                <u>{name,</u> <u>atom()}</u>:
                  The table name.

                <u>{named_table,</u> <u>boolean()}</u>:
                  Indicates if the table is named.

                <u>{node,</u> <u>node()}</u>:
                  The  node  where  the table is stored. This field is no longer meaningful, as tables cannot be
                  accessed from other nodes.

                <u>{owner,</u> <u>pid()}</u>:
                  The pid of the owner of the table.

                <u>{protection,access()}</u>:
                  The table access rights.

                <u>{size,</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  The number of objects inserted in the table.

                <u>{type,type()}</u>:
                  The table type.

                <u>{read_concurrency,</u> <u>boolean()}</u>:
                  Indicates whether the table uses <u>read_concurrency</u> or not.

                <u>{write_concurrency,</u> <u>boolean()}</u>:
                  Indicates whether the table uses <u>write_concurrency</u>.

          <b>Note:</b>
              The execution time of this function is affected by the <u>decentralized_counters</u>  table  option.  The
              execution  time is much longer when the <u>decentralized_counters</u> option is set to <u>true</u> than when the
              <u>decentralized_counters</u> option is set to <u>false</u>.

       <b>info(Tab,</b> <b>Item)</b> <b>-&gt;</b> <b>Value</b> <b>|</b> <b>undefined</b>

              Types:

                 Tab = tab()
                 Item =
                     binary | compressed | decentralized_counters | fixed | heir |
                     id | keypos | memory | name | named_table | node | owner |
                     protection | safe_fixed | safe_fixed_monotonic_time | size |
                     stats | type | write_concurrency | read_concurrency
                 Value = term()

              Returns the information associated with <u>Item</u> for table <u>Tab</u>, or returns <u>undefined</u> if <u>Tab</u>  does  not
              refer  an  existing  ETS  table.  If  <u>Tab</u> is not of the correct type, or if <u>Item</u> is not one of the
              allowed values, a <u>badarg</u> exception is raised.

              In addition to the <u>{Item,Value}</u> pairs defined for <u>info/1</u>, the following items are allowed:

                * <u>Item=binary,</u> <u>Value=BinInfo</u>

                  <u>BinInfo</u> is a list containing miscellaneous information about binaries kept by the table.  This
                  <u>Item</u>  can be changed or removed without prior notice. In the current implementation <u>BinInfo</u> is
                  a list of tuples <u>{BinaryId,BinarySize,BinaryRefcCount}</u>.

                * <u>Item=fixed,</u> <u>Value=boolean()</u>

                  Indicates if the table is fixed by any process.

                *

                  <u>Item=safe_fixed|safe_fixed_monotonic_time,</u> <u>Value={FixationTime,Info}|false</u>

                  If the table is fixed using <u>safe_fixtable/2</u>, the call returns a tuple  where  <u>FixationTime</u>  is
                  the last time when the table changed from unfixed to fixed.

                  The format and value of <u>FixationTime</u> depends on <u>Item</u>:

                  <u>safe_fixed</u>:
                    <u>FixationTime</u>  corresponds  to  the  result  returned  by  <u>erlang:timestamp/0</u>  at the time of
                    fixation. Notice that when the system uses single or multi time warp modes this can  produce
                    strange  results,  as the use of <u>safe_fixed</u> is not  time warp safe. Time warp safe code must
                    use <u>safe_fixed_monotonic_time</u> instead.

                  <u>safe_fixed_monotonic_time</u>:
                    <u>FixationTime</u> corresponds to the result returned by <u>erlang:monotonic_time/0</u> at  the  time  of
                    fixation. The use of <u>safe_fixed_monotonic_time</u> is  time warp safe.

                  <u>Info</u> is a possibly empty lists of tuples <u>{Pid,RefCount}</u>, one tuple for every process the table
                  is fixed by now. <u>RefCount</u> is the value of the reference counter and it keeps track of how many
                  times the table has been fixed by the process.

                  Table  fixations  are  not limited to <u>safe_fixtable/2</u>. Temporary fixations may also be done by
                  for example traversing functions like <u>select</u> and <u>match</u>. Such table fixations are automatically
                  released before the corresponding functions returns, but they may be seen by a concurrent call
                  to <u>ets:info(T,safe_fixed|safe_fixed_monotonic_time)</u>.

                  If the table is not fixed at all, the call returns <u>false</u>.

                * <u>Item=stats,</u> <u>Value=tuple()</u>

                  Returns internal statistics about tables on an internal format used by OTP  test  suites.  Not
                  for production use.

          <b>Note:</b>
              The  execution  time  of this function is affected by the <u>decentralized_counters</u> table option when
              the second argument of the function is <u>size</u> or <u>memory</u>. The execution time is much longer when  the
              <u>decentralized_counters</u> option is set to <u>true</u> than when the <u>decentralized_counters</u> option is set to
              <u>false</u>.

       <b>init_table(Tab,</b> <b>InitFun)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Tab = tab()
                 InitFun = fun((Arg) -&gt; Res)
                 Arg = read | close
                 Res = end_of_input | {Objects :: [term()], InitFun} | term()

              Replaces  the  existing  objects  of  table <u>Tab</u> with objects created by calling the input function
              <u>InitFun</u>, see below. This function is provided for compatibility with the <u>dets</u> module,  it  is  not
              more efficient than filling a table by using <u>insert/2</u>.

              When  called with argument <u>read</u>, the function <u>InitFun</u> is assumed to return <u>end_of_input</u> when there
              is no more input, or <u>{Objects,</u> <u>Fun}</u>, where <u>Objects</u> is a list of objects and <u>Fun</u>  is  a  new  input
              function.  Any  other  value  <u>Value</u> is returned as an error <u>{error,</u> <u>{init_fun,</u> <u>Value}}</u>. Each input
              function is called exactly once, and if an error occur, the last function is called with  argument
              <u>close</u>, the reply of which is ignored.

              If  the  table type is <u>set</u> and more than one object exists with a given key, one of the objects is
              chosen. This is not necessarily the last object with the given key  in  the  sequence  of  objects
              returned  by  the input functions. This holds also for duplicated objects stored in tables of type
              <u>bag</u>.

       <b>insert(Tab,</b> <b>ObjectOrObjects)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Tab = tab()
                 ObjectOrObjects = tuple() | [tuple()]

              Inserts the object or all of the objects in list <u>ObjectOrObjects</u> into table <u>Tab</u>.

                * If the table type is <u>set</u> and the key of the inserted objects <u>matches</u> the key of any object  in
                  the table, the old object is replaced.

                * If  the table type is <u>ordered_set</u> and the key of the inserted object <u>compares</u> <u>equal</u> to the key
                  of any object in the table, the old object is replaced.

                * If the list contains more than one object with <u>matching</u> keys and the table type is <u>set</u>, one is
                  inserted, which one is not defined. The same holds for table  type  <u>ordered_set</u>  if  the  keys
                  <u>compare</u> <u>equal</u>.

              The  entire  operation  is  guaranteed  to  be atomic and isolated, even when a list of objects is
              inserted.

       <b>insert_new(Tab,</b> <b>ObjectOrObjects)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Tab = tab()
                 ObjectOrObjects = tuple() | [tuple()]

              Same as <u>insert/2</u> except that instead of  overwriting  objects  with  the  same  key  (for  <u>set</u>  or
              <u>ordered_set</u>)  or  adding  more  objects  with  keys  already  existing  in  the table (for <u>bag</u> and
              <u>duplicate_bag</u>), <u>false</u> is returned.

              If <u>ObjectOrObjects</u> is a list, the function checks <u>every</u> key before inserting anything. Nothing  is
              inserted  unless <u>all</u> keys present in the list are absent from the table. Like <u>insert/2</u>, the entire
              operation is guaranteed to be atomic and isolated.

       <b>is_compiled_ms(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Checks if a term represent a valid compiled match specification. A compiled  match  specifications
              is only valid on the Erlang node where it was compiled by calling <u>match_spec_compile/1</u>.

          <b>Note:</b>
              Before   STDLIB   3.4   (OTP  20.0)  compiled  match  specifications  did  not  have  an  external
              representation. If passed through <u>binary_to_term(term_to_binary(CMS))</u> or sent to another node  and
              back, the result was always an empty binary <u>&lt;&lt;&gt;&gt;</u>.

              After  STDLIB  3.4  (OTP  20.0) compiled match specifications have an external representation as a
              node  specific  reference  to  the  original  compiled  match  specification.  If  passed  through
              <u>binary_to_term(term_to_binary(CMS))</u> or sent to another node and back, the result <u>may</u> <u>or</u> <u>may</u> <u>not</u> be
              a valid compiled match specification depending on if the original compiled match specification was
              still alive.

       <b>last(Tab)</b> <b>-&gt;</b> <b>Key</b> <b>|</b> <b>'$end_of_table'</b>

              Types:

                 Tab = tab()
                 Key = term()

              Returns  the  last  key  <u>Key</u>  according to Erlang term order in table <u>Tab</u> of type <u>ordered_set</u>. For
              other table types, the function is synonymous to <u>first/1</u>. If the table is  empty,  <u>'$end_of_table'</u>
              is returned.

              To find preceding keys in the table, use <u>prev/2</u>.

       <b>lookup(Tab,</b> <b>Key)</b> <b>-&gt;</b> <b>[Object]</b>

              Types:

                 Tab = tab()
                 Key = term()
                 Object = tuple()

              Returns a list of all objects with key <u>Key</u> in table <u>Tab</u>.

                * For tables of type <u>set</u>, <u>bag</u>, or <u>duplicate_bag</u>, an object is returned only if the specified key
                  <u>matches</u> the key of the object in the table.

                * For  tables  of type <u>ordered_set</u>, an object is returned if the specified key <u>compares</u> <u>equal</u> to
                  the key of an object in the table.

              The difference is the same as between <u>=:=</u> and <u>==</u>.

              As an example, one can insert an object with <u>integer()</u> <u>1</u> as a key in an <u>ordered_set</u>  and  get  the
              object returned as a result of doing a <u>lookup/2</u> with <u>float()</u> <u>1.0</u> as the key to search for.

              For  tables  of type <u>set</u> or <u>ordered_set</u>, the function returns either the empty list or a list with
              one element, as there cannot be more than one object with the same key. For tables of type <u>bag</u>  or
              <u>duplicate_bag</u>, the function returns a list of arbitrary length.

              Notice  that  the time order of object insertions is preserved; the first object inserted with the
              specified key is the first in the resulting list, and so on.

              Insert and lookup times in tables of type <u>set</u>, <u>bag</u>, and <u>duplicate_bag</u> are constant, regardless  of
              the  table  size.  For the <u>ordered_set</u> datatype, time is proportional to the (binary) logarithm of
              the number of objects.

       <b>lookup_element(Tab,</b> <b>Key,</b> <b>Pos)</b> <b>-&gt;</b> <b>Elem</b>

              Types:

                 Tab = tab()
                 Key = term()
                 Pos = integer() &gt;= 1
                 Elem = term() | [term()]

              For a table <u>Tab</u> of type <u>set</u> or <u>ordered_set</u>, the function returns the <u>Pos</u>:th element of the  object
              with key <u>Key</u>.

              For  tables  of type <u>bag</u> or <u>duplicate_bag</u>, the functions returns a list with the <u>Pos</u>:th element of
              every object with key <u>Key</u>.

              If no object with key <u>Key</u> exists, the function exits with reason <u>badarg</u>.

              The difference between <u>set</u>, <u>bag</u>, and <u>duplicate_bag</u> on one hand,  and  <u>ordered_set</u>  on  the  other,
              regarding  the  fact that <u>ordered_set</u> view keys as equal when they <u>compare</u> <u>equal</u> whereas the other
              table types regard them equal only when they <u>match</u>, holds for <u>lookup_element/3</u>.

       <b>match(Continuation)</b> <b>-&gt;</b> <b>{[Match],</b> <b>Continuation}</b> <b>|</b> <b>'$end_of_table'</b>

              Types:

                 Match = [term()]
                 Continuation = continuation()

              Continues a match started with <u>match/3</u>. The next chunk  of  the  size  specified  in  the  initial
              <u>match/3</u>  call  is returned together with a new <u>Continuation</u>, which can be used in subsequent calls
              to this function.

              When there are no more objects in the table, <u>'$end_of_table'</u> is returned.

       <b>match(Tab,</b> <b>Pattern)</b> <b>-&gt;</b> <b>[Match]</b>

              Types:

                 Tab = tab()
                 Pattern = match_pattern()
                 Match = [term()]

              Matches the objects in table <u>Tab</u> against pattern <u>Pattern</u>.

              A pattern is a term that can contain:

                * Bound parts (Erlang terms)

                * <u>'_'</u> that matches any Erlang term

                * Pattern variables <u>'$N'</u>, where <u>N</u>=0,1,...

              The function returns a list with one element for each matching object, where each  element  is  an
              ordered list of pattern variable bindings, for example:

              6&gt; ets:match(T, '$1'). % Matches every object in table
              [[{rufsen,dog,7}],[{brunte,horse,5}],[{ludde,dog,5}]]
              7&gt; ets:match(T, {'_',dog,'$1'}).
              [[7],[5]]
              8&gt; ets:match(T, {'_',cow,'$1'}).
              []

              If  the key is specified in the pattern, the match is very efficient. If the key is not specified,
              that is, if it is a variable or an underscore, the entire table must be searched. The search  time
              can be substantial if the table is very large.

              For tables of type <u>ordered_set</u>, the result is in the same order as in a <u>first</u>/<u>next</u> traversal.

       <b>match(Tab,</b> <b>Pattern,</b> <b>Limit)</b> <b>-&gt;</b>
                {[Match], Continuation} | '$end_of_table'

              Types:

                 Tab = tab()
                 Pattern = match_pattern()
                 Limit = integer() &gt;= 1
                 Match = [term()]
                 Continuation = continuation()

              Works  like  <u>match/2</u>,  but  returns  only  a  limited  (<u>Limit</u>)  number  of  matching objects. Term
              <u>Continuation</u> can then be used in subsequent calls to <u>match/1</u> to get the  next  chunk  of  matching
              objects.  This  is  a  space-efficient  way  to  work  on objects in a table, which is faster than
              traversing the table object by object using <u>first/1</u> and <u>next/2</u>.

              If the table is empty, <u>'$end_of_table'</u> is returned.

              Use <u>safe_fixtable/2</u> to guarantee safe traversal for subsequent calls to <u>match/1</u>.

       <b>match_delete(Tab,</b> <b>Pattern)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Tab = tab()
                 Pattern = match_pattern()

              Deletes all objects that match pattern <u>Pattern</u> from table <u>Tab</u>. For a description of patterns,  see
              <u>match/2</u>.

       <b>match_object(Continuation)</b> <b>-&gt;</b>
                       {[Object], Continuation} | '$end_of_table'

              Types:

                 Object = tuple()
                 Continuation = continuation()

              Continues a match started with <u>match_object/3</u>. The next chunk of the size specified in the initial
              <u>match_object/3</u>  call is returned together with a new <u>Continuation</u>, which can be used in subsequent
              calls to this function.

              When there are no more objects in the table, <u>'$end_of_table'</u> is returned.

       <b>match_object(Tab,</b> <b>Pattern)</b> <b>-&gt;</b> <b>[Object]</b>

              Types:

                 Tab = tab()
                 Pattern = match_pattern()
                 Object = tuple()

              Matches the objects in table <u>Tab</u> against pattern <u>Pattern</u>.  For  a  description  of  patterns,  see
              <u>match/2</u>. The function returns a list of all objects that match the pattern.

              If  the key is specified in the pattern, the match is very efficient. If the key is not specified,
              that is, if it is a variable or an underscore, the entire table must be searched. The search  time
              can be substantial if the table is very large.

              For tables of type <u>ordered_set</u>, the result is in the same order as in a <u>first</u>/<u>next</u> traversal.

       <b>match_object(Tab,</b> <b>Pattern,</b> <b>Limit)</b> <b>-&gt;</b>
                       {[Object], Continuation} | '$end_of_table'

              Types:

                 Tab = tab()
                 Pattern = match_pattern()
                 Limit = integer() &gt;= 1
                 Object = tuple()
                 Continuation = continuation()

              Works  like  <u>match_object/2</u>,  but  only returns a limited (<u>Limit</u>) number of matching objects. Term
              <u>Continuation</u> can then be used in subsequent calls to <u>match_object/1</u>  to  get  the  next  chunk  of
              matching  objects.  This  is  a space-efficient way to work on objects in a table, which is faster
              than traversing the table object by object using <u>first/1</u> and <u>next/2</u>.

              If the table is empty, <u>'$end_of_table'</u> is returned.

              Use <u>safe_fixtable/2</u> to guarantee safe traversal for subsequent calls to <u>match_object/1</u>.

       <b>match_spec_compile(MatchSpec)</b> <b>-&gt;</b> <b>CompiledMatchSpec</b>

              Types:

                 MatchSpec = match_spec()
                 CompiledMatchSpec = comp_match_spec()

              Transforms a match specification into an internal representation that can be  used  in  subsequent
              calls  to  <u>match_spec_run/2</u>.  The  internal  representation  is opaque. To check the validity of a
              compiled match specification, use <u>is_compiled_ms/1</u>.

              If term <u>MatchSpec</u> does not represent a valid match specification, a <u>badarg</u> exception is raised.

          <b>Note:</b>
              This function has limited use in normal code. It is  used  by  the  <u>dets</u>  module  to  perform  the
              <u>dets:select()</u> operations.

       <b>match_spec_run(List,</b> <b>CompiledMatchSpec)</b> <b>-&gt;</b> <b>list()</b>

              Types:

                 List = [term()]
                 CompiledMatchSpec = comp_match_spec()

              Executes  the  matching  specified  in  a  compiled  match  specification on a list of terms. Term
              <u>CompiledMatchSpec</u> is to be the result of a call to <u>match_spec_compile/1</u> and is hence the  internal
              representation of the match specification one wants to use.

              The  matching  is  executed on each element in <u>List</u> and the function returns a list containing all
              results. If an element in <u>List</u> does not match, nothing is returned for that element. The length of
              the result list is therefore equal or less than the length of parameter <u>List</u>.

              <u>Example:</u>

              The following two calls give the same result (but certainly not the same execution time):

              Table = ets:new...
              MatchSpec = ...
              % The following call...
              ets:match_spec_run(ets:tab2list(Table),
                                 ets:match_spec_compile(MatchSpec)),
              % ...gives the same result as the more common (and more efficient)
              ets:select(Table, MatchSpec),

          <b>Note:</b>
              This function has limited use in normal code. It is  used  by  the  <u>dets</u>  module  to  perform  the
              <u>dets:select()</u> operations and by Mnesia during transactions.

       <b>member(Tab,</b> <b>Key)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Tab = tab()
                 Key = term()

              Works  like <u>lookup/2</u>, but does not return the objects. Returns <u>true</u> if one or more elements in the
              table has key <u>Key</u>, otherwise <u>false</u>.

       <b>new(Name,</b> <b>Options)</b> <b>-&gt;</b> <b>tid()</b> <b>|</b> <b>atom()</b>

              Types:

                 Name = atom()
                 Options = [Option]
                 Option =
                     Type | Access | named_table |
                     {keypos, Pos} |
                     {heir, Pid :: pid(), HeirData} |
                     {heir, none} |
                     Tweaks
                 Type = type()
                 Access = access()
                 Tweaks =
                     {write_concurrency, boolean()} |
                     {read_concurrency, boolean()} |
                     {decentralized_counters, boolean()} |
                     compressed
                 Pos = integer() &gt;= 1
                 HeirData = term()

              Creates a new table and returns a table identifier that can be used in subsequent operations.  The
              table  identifier  can  be sent to other processes so that a table can be shared between different
              processes within a node.

              Parameter <u>Options</u> is a list of options that specifies table type, access rights, key position, and
              whether the table is named. Default values are used for  omitted  options.  This  means  that  not
              specifying  any  options  (<u>[]</u>) is the same as specifying <u>[set,</u> <u>protected,</u> <u>{keypos,1},</u> <u>{heir,none},</u>
              <u>{write_concurrency,false},</u> <u>{read_concurrency,false},</u> <u>{decentralized_counters,false}]</u>.

                <u>set</u>:
                  The table is a <u>set</u> table: one key, one object, no order among objects.  This  is  the  default
                  table type.

                <u>ordered_set</u>:
                  The  table is a <u>ordered_set</u> table: one key, one object, ordered in Erlang term order, which is
                  the order implied by the &lt; and &gt; operators. Tables of this  type  have  a  somewhat  different
                  behavior  in  some situations than tables of other types. Most notably, the <u>ordered_set</u> tables
                  regard keys as equal when they <u>compare</u> <u>equal</u>, not only when they match. This means that to  an
                  <u>ordered_set</u> table, <u>integer()</u> <u>1</u> and <u>float()</u> <u>1.0</u> are regarded as equal. This also means that the
                  key  used  to  lookup  an element not necessarily <u>matches</u> the key in the returned elements, if
                  <u>float()</u>'s and <u>integer()</u>'s are mixed in keys of a table.

                <u>bag</u>:
                  The table is a <u>bag</u> table, which can have many objects, but only one instance of  each  object,
                  per key.

                <u>duplicate_bag</u>:
                  The  table is a <u>duplicate_bag</u> table, which can have many objects, including multiple copies of
                  the same object, per key.

                <u>public</u>:
                  Any process can read or write to the table.

                <u>protected</u>:
                  The owner process can read and write to the table. Other processes can only  read  the  table.
                  This is the default setting for the access rights.

                <u>private</u>:
                  Only the owner process can read or write to the table.

                <u>named_table</u>:
                  If  this  option  is  present,  the  table is registered under its <u>Name</u> which can then be used
                  instead of the table identifier in subsequent operations.

                  The function will also return the <u>Name</u> instead of the  table  identifier.  To  get  the  table
                  identifier of a named table, use <u>whereis/1</u>.

                <u>{keypos,Pos}</u>:
                  Specifies  which  element  in  the  stored  tuples  to use as key. By default, it is the first
                  element, that is, <u>Pos=1</u>. However, this is not always appropriate. In  particular,  we  do  not
                  want the first element to be the key if we want to store Erlang records in a table.

                  Notice that any tuple stored in the table must have at least <u>Pos</u> number of elements.

                <u>{heir,Pid,HeirData}</u> <u>|</u> <u>{heir,none}</u>:
                  Set  a  process  as  heir. The heir inherits the table if the owner terminates. Message <u>{'ETS-</u>
                  <u>TRANSFER',tid(),FromPid,HeirData}</u> is sent to the heir when that occurs. The  heir  must  be  a
                  local process. Default heir is <u>none</u>, which destroys the table when the owner terminates.

                <u>{write_concurrency,boolean()}</u>:
                  Performance tuning. Defaults to <u>false</u>, in which case an operation that mutates (writes to) the
                  table  obtains  exclusive  access,  blocking  any  concurrent  access  of the same table until
                  finished. If set to <u>true</u>, the table is optimized to concurrent write access. Different objects
                  of the same table can be mutated (and read) by concurrent processes. This is achieved to  some
                  degree  at  the  expense  of  memory  consumption and the performance of sequential access and
                  concurrent reading.

                  The  <u>write_concurrency</u>  option  can  be  combined  with  the  options   <u>read_concurrency</u>   and
                  <u>decentralized_counters</u>.  You typically want to combine <u>write_concurrency</u> with <u>read_concurrency</u>
                  when large concurrent read bursts and large concurrent  write  bursts  are  common;  for  more
                  information,  see  option  <u>read_concurrency</u>. The <u>decentralized_counters</u> option is turned on by
                  default for tables of type <u>ordered_set</u> with the  <u>write_concurrency</u>  option  enabled,  and  the
                  <u>decentralized_counters</u>  option  is  turned  off by default for all other table types. For more
                  information, see the documentation for the <u>decentralized_counters</u> option.

                  Notice that this option  does  not  change  any  guarantees  about  atomicity  and  isolation.
                  Functions  that  makes  such promises over many objects (like <u>insert/2</u>) gain less (or nothing)
                  from this option.

                  The memory consumption inflicted by both <u>write_concurrency</u> and <u>read_concurrency</u> is a  constant
                  overhead per table for <u>set</u>, <u>bag</u> and <u>duplicate_bag</u>. For <u>ordered_set</u> the memory overhead depends
                  on  the  number  of inserted objects and the amount of actual detected concurrency in runtime.
                  The memory overhead can be especially large when both options are combined.

            <b>Note:</b>
                Prior to stdlib-3.7 (OTP-22.0) <u>write_concurrency</u> had no effect on <u>ordered_set</u>.

                <u>{read_concurrency,boolean()}</u>:
                  Performance tuning. Defaults to <u>false</u>. When set to <u>true</u>, the table is optimized for concurrent
                  read operations. When this option is enabled read operations become much  cheaper;  especially
                  on  systems  with  multiple  physical  processors.  However,  switching between read and write
                  operations becomes more expensive.

                  You typically want to enable this  option  when  concurrent  read  operations  are  much  more
                  frequent  than  write  operations, or when concurrent reads and writes comes in large read and
                  write bursts (that is, many reads not interrupted by writes, and many writes  not  interrupted
                  by reads).

                  You  typically  do <u>not</u> want to enable this option when the common access pattern is a few read
                  operations interleaved with a few write operations repeatedly. In this case, you would  get  a
                  performance degradation by enabling this option.

                  Option  <u>read_concurrency</u>  can be combined with option <u>write_concurrency</u>. You typically want to
                  combine these when large concurrent read bursts and large concurrent write bursts are common.

                <u>{decentralized_counters,boolean()}</u>:
                  Performance tuning. Defaults to <u>true</u> for tables of type <u>ordered_set</u> with the <u>write_concurrency</u>
                  option enabled, and defaults to false for all other table types. This option has no effect  if
                  the <u>write_concurrency</u> option is set to <u>false</u>.

                  When  this  option  is  set  to  <u>true</u>, the table is optimized for frequent concurrent calls to
                  operations that modify the tables size and/or  its  memory  consumption  (e.g.,  <u>insert/2</u>  and
                  <u>delete/2</u>).  The  drawback is that calls to <u>info/1</u> and <u>info/2</u> with <u>size</u> or <u>memory</u> as the second
                  argument can get much slower when the <u>decentralized_counters</u> option is turned on.

                  When this option is enabled the counters  for  the  table  size  and  memory  consumption  are
                  distributed  over  several  cache  lines and the scheduling threads are mapped to one of those
                  cache lines. The <u>erl</u> option <u>+dcg</u> can be used to control the number of  cache  lines  that  the
                  counters are distributed over.

                <u>compressed</u>:
                  If  this  option is present, the table data is stored in a more compact format to consume less
                  memory. However, it will make table operations slower.  Especially  operations  that  need  to
                  inspect  entire  objects,  such  as  <u>match</u> and <u>select</u>, get much slower. The key element is not
                  compressed.

       <b>next(Tab,</b> <b>Key1)</b> <b>-&gt;</b> <b>Key2</b> <b>|</b> <b>'$end_of_table'</b>

              Types:

                 Tab = tab()
                 Key1 = Key2 = term()

              Returns the next key <u>Key2</u>, following key <u>Key1</u> in table <u>Tab</u>. For table type <u>ordered_set</u>,  the  next
              key  in  Erlang  term  order  is  returned.  For  other table types, the next key according to the
              internal order of the table is returned. If no next key exists, <u>'$end_of_table'</u> is returned.

              To find the first key in the table, use <u>first/1</u>.

              Unless a table of type <u>set</u>, <u>bag</u>, or <u>duplicate_bag</u> is fixated  using  <u>safe_fixtable/2</u>,  a  call  to
              <u>next/2</u>  will  fail if <u>Key1</u> no longer exists in the table. For table type <u>ordered_set</u>, the function
              always returns the next key after <u>Key1</u> in term order, regardless whether <u>Key1</u> ever existed in  the
              table.

       <b>prev(Tab,</b> <b>Key1)</b> <b>-&gt;</b> <b>Key2</b> <b>|</b> <b>'$end_of_table'</b>

              Types:

                 Tab = tab()
                 Key1 = Key2 = term()

              Returns  the  previous key <u>Key2</u>, preceding key <u>Key1</u> according to Erlang term order in table <u>Tab</u> of
              type <u>ordered_set</u>. For other table types, the function is synonymous to <u>next/2</u>. If no previous  key
              exists, <u>'$end_of_table'</u> is returned.

              To find the last key in an <u>ordered_set</u> table, use <u>last/1</u>.

       <b>rename(Tab,</b> <b>Name)</b> <b>-&gt;</b> <b>Name</b>

              Types:

                 Tab = tab()
                 Name = atom()

              Renames  the  named  table  <u>Tab</u>  to  the new name <u>Name</u>. Afterwards, the old name cannot be used to
              access the table. Renaming an unnamed table has no effect.

       <b>repair_continuation(Continuation,</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>Continuation</b>

              Types:

                 Continuation = continuation()
                 MatchSpec = match_spec()

              Restores an opaque continuation returned by <u>select/3</u> or <u>select/1</u> if the  continuation  has  passed
              through external term format (been sent between nodes or stored on disk).

              The  reason for this function is that continuation terms contain compiled match specifications and
              may therefore be invalidated if converted to external term format. Given that the  original  match
              specification  is kept intact, the continuation can be restored, meaning it can once again be used
              in subsequent <u>select/1</u> calls even though it has been stored on disk or on another node.

              <u>Examples:</u>

              The following sequence of calls may fail:

              T=ets:new(x,[]),
              ...
              MS = ets:fun2ms(fun({N,_}=A) when (N rem 10) =:= 0 -&gt; A end),
              {_,C} = ets:select(T, MS, 10),
              MaybeBroken = binary_to_term(term_to_binary(C)),
              ets:select(MaybeBroken).

              The following sequence works, as the call to <u>repair_continuation/2</u> reestablishes  the  <u>MaybeBroken</u>
              continuation.

              T=ets:new(x,[]),
              ...
              MS = ets:fun2ms(fun({N,_}=A) when (N rem 10) =:= 0 -&gt; A end),
              {_,C} = ets:select(T,MS,10),
              MaybeBroken = binary_to_term(term_to_binary(C)),
              ets:select(ets:repair_continuation(MaybeBroken,MS)).

          <b>Note:</b>
              This  function  is  rarely needed in application code. It is used by Mnesia to provide distributed
              <u>select/3</u> and <u>select/1</u> sequences. A  normal  application  would  either  use  Mnesia  or  keep  the
              continuation from being converted to external format.

              The  actual  behavior  of  compiled  match  specifications when recreated from external format has
              changed and may change in future releases, but this interface remains for backward  compatibility.
              See <u>is_compiled_ms/1</u>.

       <b>safe_fixtable(Tab,</b> <b>Fix)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Tab = tab()
                 Fix = boolean()

              Fixes  a  table  of  type  <u>set</u>,  <u>bag</u>, or <u>duplicate_bag</u> for  safe traversal using <u>first/1</u> &amp; <u>next/2</u>,
              <u>match/3</u> &amp; <u>match/1</u>, <u>match_object/3</u> &amp; <u>match_object/1</u>, or <u>select/3</u> &amp; <u>select/1</u>.

              A process fixes a table by calling <u>safe_fixtable(Tab,</u> <u>true)</u>. The table  remains  fixed  until  the
              process releases it by calling <u>safe_fixtable(Tab,</u> <u>false)</u>, or until the process terminates.

              If  many  processes  fix a table, the table remains fixed until all processes have released it (or
              terminated). A reference counter is kept on a per process basis, and N consecutive fixes  requires
              N releases to release the table.

              When  a  table  is fixed, a sequence of <u>first/1</u> and <u>next/2</u> calls are guaranteed to succeed even if
              keys are removed during the traversal. The keys for objects inserted or deleted during a traversal
              may or may not be returned by <u>next/2</u> depending on the ordering of keys within the table and if the
              key exists at the time <u>next/2</u> is called.

              <u>Example:</u>

              clean_all_with_value(Tab,X) -&gt;
                  safe_fixtable(Tab,true),
                  clean_all_with_value(Tab,X,ets:first(Tab)),
                  safe_fixtable(Tab,false).

              clean_all_with_value(Tab,X,'$end_of_table') -&gt;
                  true;
              clean_all_with_value(Tab,X,Key) -&gt;
                  case ets:lookup(Tab,Key) of
                      [{Key,X}] -&gt;
                          ets:delete(Tab,Key);
                      _ -&gt;
                          true
                  end,
                  clean_all_with_value(Tab,X,ets:next(Tab,Key)).

              Notice that deleted objects are not freed from a fixed table until it  has  been  released.  If  a
              process  fixes  a  table  but  never  releases it, the memory used by the deleted objects is never
              freed. The performance of operations on the table also degrades significantly.

              To  retrieve  information  about  which  processes  have  fixed  which   tables,   use   <u>info(Tab,</u>
              <u>safe_fixed_monotonic_time)</u>.  A  system  with  many processes fixing tables can need a monitor that
              sends alarms when tables have been fixed for too long.

              Notice that <u>safe_fixtable/2</u> is not necessary for table type <u>ordered_set</u> and for traversals done by
              a single ETS function call, like <u>select/2</u>.

       <b>select(Continuation)</b> <b>-&gt;</b> <b>{[Match],</b> <b>Continuation}</b> <b>|</b> <b>'$end_of_table'</b>

              Types:

                 Match = term()
                 Continuation = continuation()

              Continues a match started with <u>select/3</u>. The next chunk of  the  size  specified  in  the  initial
              <u>select/3</u>  call is returned together with a new <u>Continuation</u>, which can be used in subsequent calls
              to this function.

              When there are no more objects in the table, <u>'$end_of_table'</u> is returned.

       <b>select(Tab,</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>[Match]</b>

              Types:

                 Tab = tab()
                 MatchSpec = match_spec()
                 Match = term()

              Matches the objects in table <u>Tab</u> using a match specification. This is a  more  general  call  than
              <u>match/2</u> and <u>match_object/2</u> calls. In its simplest form, the match specification is as follows:

              MatchSpec = [MatchFunction]
              MatchFunction = {MatchHead, [Guard], [Result]}
              MatchHead = "Pattern as in ets:match"
              Guard = {"Guardtest name", ...}
              Result = "Term construct"

              This  means  that the match specification is always a list of one or more tuples (of arity 3). The
              first element of the tuple is to be a pattern as described in <u>match/2</u>. The second element  of  the
              tuple  is  to be a list of 0 or more guard tests (described below). The third element of the tuple
              is to be a list containing a description of the value to return. In almost all normal  cases,  the
              list contains exactly one term that fully describes the value to return for each object.

              The  return  value  is  constructed  using  the  "match variables" bound in <u>MatchHead</u> or using the
              special match variables <u>'$_'</u> (the whole matching object) and <u>'$$'</u> (all match variables in a list),
              so that the following <u>match/2</u> expression:

              ets:match(Tab,{'$1','$2','$3'})

              is exactly equivalent to:

              ets:select(Tab,[{{'$1','$2','$3'},[],['$$']}])

              And that the following <u>match_object/2</u> call:

              ets:match_object(Tab,{'$1','$2','$1'})

              is exactly equivalent to

              ets:select(Tab,[{{'$1','$2','$1'},[],['$_']}])

              Composite terms can be constructed in the <u>Result</u> part either by simply writing a list, so that the
              following code:

              ets:select(Tab,[{{'$1','$2','$3'},[],['$$']}])

              gives the same output as:

              ets:select(Tab,[{{'$1','$2','$3'},[],[['$1','$2','$3']]}])

              That is, all the bound variables in the match head as a list. If tuples are to be constructed, one
              has to write a tuple of arity 1 where the single element in the tuple is the tuple  one  wants  to
              construct (as an ordinary tuple can be mistaken for a <u>Guard</u>).

              Therefore the following call:

              ets:select(Tab,[{{'$1','$2','$1'},[],['$_']}])

              gives the same output as:

              ets:select(Tab,[{{'$1','$2','$1'},[],[{{'$1','$2','$3'}}]}])

              This  syntax  is equivalent to the syntax used in the trace patterns (see the <u><a href="../man3erl/dbg.3erl.html">dbg</a>(3erl)</u>) module in
              Runtime_Tools.

              The <u>Guard</u>s are constructed as tuples, where the first element is the test name and  the  remaining
              elements  are  the test parameters. To check for a specific type (say a list) of the element bound
              to the match variable <u>'$1'</u>, one would write the test as <u>{is_list,</u> <u>'$1'}</u>. If the  test  fails,  the
              object  in the table does not match and the next <u>MatchFunction</u> (if any) is tried. Most guard tests
              present in Erlang can be used, but only the new  versions  prefixed  <u>is</u><b>_</b>  are  allowed  (<u>is_float</u>,
              <u>is_atom</u>, and so on).

              The  <u>Guard</u>  section  can  also contain logic and arithmetic operations, which are written with the
              same syntax as the guard tests (prefix notation), so that the  following  guard  test  written  in
              Erlang:

              is_integer(X), is_integer(Y), X + Y &lt; 4711

              is expressed as follows (<u>X</u> replaced with <u>'$1'</u> and <u>Y</u> with <u>'$2'</u>):

              [{is_integer, '$1'}, {is_integer, '$2'}, {'&lt;', {'+', '$1', '$2'}, 4711}]

              For  tables  of  type  <u>ordered_set</u>,  objects  are  visited  in  the  same order as in a <u>first</u>/<u>next</u>
              traversal. This means that the match specification is executed against objects with  keys  in  the
              <u>first</u>/<u>next</u> order and the corresponding result list is in the order of that execution.

       <b>select(Tab,</b> <b>MatchSpec,</b> <b>Limit)</b> <b>-&gt;</b>
                 {[Match], Continuation} | '$end_of_table'

              Types:

                 Tab = tab()
                 MatchSpec = match_spec()
                 Limit = integer() &gt;= 1
                 Match = term()
                 Continuation = continuation()

              Works  like  <u>select/2</u>,  but  only  returns  a  limited  (<u>Limit</u>)  number  of matching objects. Term
              <u>Continuation</u> can then be used in subsequent calls to <u>select/1</u> to get the next  chunk  of  matching
              objects.  This  is a space-efficient way to work on objects in a table, which is still faster than
              traversing the table object by object using <u>first/1</u> and <u>next/2</u>.

              If the table is empty, <u>'$end_of_table'</u> is returned.

              Use <u>safe_fixtable/2</u> to guarantee safe traversal for subsequent calls to <u>select/1</u>.

       <b>select_count(Tab,</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>NumMatched</b>

              Types:

                 Tab = tab()
                 MatchSpec = match_spec()
                 NumMatched = integer() &gt;= 0

              Matches the objects in table <u>Tab</u> using a match specification. If the match  specification  returns
              <u>true</u>  for  an object, that object considered a match and is counted. For any other result from the
              match specification the object is not considered a match and is therefore not counted.

              This function can be described as a <u>select_delete/2</u> function that does not  delete  any  elements,
              but only counts them.

              The function returns the number of objects matched.

       <b>select_delete(Tab,</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>NumDeleted</b>

              Types:

                 Tab = tab()
                 MatchSpec = match_spec()
                 NumDeleted = integer() &gt;= 0

              Matches  the  objects in table <u>Tab</u> using a match specification. If the match specification returns
              <u>true</u> for an object, that object is removed from the table. For any other  result  from  the  match
              specification the object is retained. This is a more general call than the <u>match_delete/2</u> call.

              The function returns the number of objects deleted from the table.

          <b>Note:</b>
              The  match  specification  has  to  return  the atom <u>true</u> if the object is to be deleted. No other
              return value gets the object deleted. So one cannot use the same match specification  for  looking
              up elements as for deleting them.

       <b>select_replace(Tab,</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>NumReplaced</b>

              Types:

                 Tab = tab()
                 MatchSpec = match_spec()
                 NumReplaced = integer() &gt;= 0

              Matches  the  objects  in  the table <u>Tab</u> using a match specification. For each matched object, the
              existing object is replaced with the match specification result.

              The match-and-replace operation for  each  individual  object  is  guaranteed  to  be  atomic  and
              isolated. The <u>select_replace</u> table traversal as a whole, like all other select functions, does not
              give such guarantees.

              The  match  specifiction  must  be  guaranteed  to  <u>retain</u>  <u>the</u> <u>key</u> of any matched object. If not,
              <u>select_replace</u> will fail with <u>badarg</u> without updating any objects.

              For the moment, due to performance and semantic constraints,  tables  of  type  <u>bag</u>  are  not  yet
              supported.

              The function returns the total number of replaced objects.

              <u>Example</u>

              For all 2-tuples with a list in second position, add atom <u>'marker'</u> first in the list:

              1&gt; T = ets:new(x,[]), ets:insert(T, {key, [1, 2, 3]}).
              true
              2&gt; MS = ets:fun2ms(fun({K, L}) when is_list(L) -&gt; {K, [marker | L]} end).
              [{{'$1','$2'},[{is_list,'$2'}],[{{'$1',[marker|'$2']}}]}]
              3&gt; ets:select_replace(T, MS).
              1
              4&gt; ets:tab2list(T).
              [{key,[marker,1,2,3]}]

              A generic single object compare-and-swap operation:

              [Old] = ets:lookup(T, Key),
              New = update_object(Old),
              Success = (1 =:= ets:select_replace(T, [{Old, [], [{const, New}]}])),

       <b>select_reverse(Continuation)</b> <b>-&gt;</b>
                         {[Match], Continuation} | '$end_of_table'

              Types:

                 Continuation = continuation()
                 Match = term()

              Continues  a match started with <u>select_reverse/3</u>. For tables of type <u>ordered_set</u>, the traversal of
              the table continues to objects with keys earlier in the Erlang term order. The returned list  also
              contains  objects  with  keys in reverse order. For all other table types, the behavior is exactly
              that of <u>select/1</u>.

              <u>Example:</u>

              1&gt; T = ets:new(x,[ordered_set]).
              2&gt; [ ets:insert(T,{N}) || N &lt;- lists:seq(1,10) ].
              ...
              3&gt; {R0,C0} = ets:select_reverse(T,[{'_',[],['$_']}],4).
              ...
              4&gt; R0.
              [{10},{9},{8},{7}]
              5&gt; {R1,C1} = ets:select_reverse(C0).
              ...
              6&gt; R1.
              [{6},{5},{4},{3}]
              7&gt; {R2,C2} = ets:select_reverse(C1).
              ...
              8&gt; R2.
              [{2},{1}]
              9&gt; '$end_of_table' = ets:select_reverse(C2).
              ...

       <b>select_reverse(Tab,</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>[Match]</b>

              Types:

                 Tab = tab()
                 MatchSpec = match_spec()
                 Match = term()

              Works like <u>select/2</u>, but returns the list in reverse order for table  type  <u>ordered_set</u>.  For  all
              other table types, the return value is identical to that of <u>select/2</u>.

       <b>select_reverse(Tab,</b> <b>MatchSpec,</b> <b>Limit)</b> <b>-&gt;</b>
                         {[Match], Continuation} | '$end_of_table'

              Types:

                 Tab = tab()
                 MatchSpec = match_spec()
                 Limit = integer() &gt;= 1
                 Match = term()
                 Continuation = continuation()

              Works like <u>select/3</u>, but for table type <u>ordered_set</u> traversing is done starting at the last object
              in  Erlang  term  order  and  moves  to  the first. For all other table types, the return value is
              identical to that of <u>select/3</u>.

              Notice that this is <u>not</u> equivalent to reversing the result list of a <u>select/3</u> call, as the  result
              list is not only reversed, but also contains the last <u>Limit</u> matching objects in the table, not the
              first.

       <b>setopts(Tab,</b> <b>Opts)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Tab = tab()
                 Opts = Opt | [Opt]
                 Opt = {heir, pid(), HeirData} | {heir, none}
                 HeirData = term()

              Sets  table  options.  The only allowed option to be set after the table has been created is <u>heir</u>.
              The calling process must be the table owner.

       <b>slot(Tab,</b> <b>I)</b> <b>-&gt;</b> <b>[Object]</b> <b>|</b> <b>'$end_of_table'</b>

              Types:

                 Tab = tab()
                 I = integer() &gt;= 0
                 Object = tuple()

              This function is mostly for debugging purposes, Normally <u>first</u>/<u>next</u> or <u>last</u>/<u>prev</u> are  to  be  used
              instead.

              Returns  all  objects  in  slot <u>I</u> of table <u>Tab</u>. A table can be traversed by repeatedly calling the
              function, starting with the first slot  <u>I=0</u>  and  ending  when  <u>'$end_of_table'</u>  is  returned.  If
              argument <u>I</u> is out of range, the function fails with reason <u>badarg</u>.

              Unless  a table of type <u>set</u>, <u>bag</u>, or <u>duplicate_bag</u> is protected using <u>safe_fixtable/2</u>, a traversal
              can fail if concurrent updates are made to the table. For table  type  <u>ordered_set</u>,  the  function
              returns a list containing object <u>I</u> in Erlang term order.

       <b>tab2file(Tab,</b> <b>Filename)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Tab = tab()
                 Filename = file:name()
                 Reason = term()

              Dumps table <u>Tab</u> to file <u>Filename</u>.

              Equivalent to <u>tab2file(Tab,</u> <u>Filename,[])</u>

       <b>tab2file(Tab,</b> <b>Filename,</b> <b>Options)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Tab = tab()
                 Filename = file:name()
                 Options = [Option]
                 Option = {extended_info, [ExtInfo]} | {sync, boolean()}
                 ExtInfo = md5sum | object_count
                 Reason = term()

              Dumps table <u>Tab</u> to file <u>Filename</u>.

              When dumping the table, some information about the table is dumped to a header at the beginning of
              the  dump.  This  information contains data about the table type, name, protection, size, version,
              and if it is a named table. It also contains notes about what extended information is added to the
              file, which can be a count of the objects in the file or a MD5 sum of the header  and  records  in
              the file.

              The  size  field  in  the  header might not correspond to the number of records in the file if the
              table is public and records are added or removed from the  table  during  dumping.  Public  tables
              updated  during  dump,  and  that  one  wants  to verify when reading, needs at least one field of
              extended information for the read verification process to be reliable later.

              Option <u>extended_info</u> specifies what extra information is written to the table dump:

                <u>object_count</u>:
                  The number of objects written to the file is noted in the file footer, so file truncation  can
                  be verified even if the file was updated during dump.

                <u>md5sum</u>:
                  The  header  and objects in the file are checksummed using the built-in MD5 functions. The MD5
                  sum of all objects is written in the file footer, so that verification while  reading  detects
                  the slightest bitflip in the file data. Using this costs a fair amount of CPU time.

              Whenever option <u>extended_info</u> is used, it results in a file not readable by versions of ETS before
              that in STDLIB 1.15.1

              If  option  <u>sync</u>  is  set  to <u>true</u>, it ensures that the content of the file is written to the disk
              before <u>tab2file</u> returns. Defaults to <u>{sync,</u> <u>false}</u>.

       <b>tab2list(Tab)</b> <b>-&gt;</b> <b>[Object]</b>

              Types:

                 Tab = tab()
                 Object = tuple()

              Returns a list of all objects in table <u>Tab</u>.

       <b>tabfile_info(Filename)</b> <b>-&gt;</b> <b>{ok,</b> <b>TableInfo}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = file:name()
                 TableInfo = [InfoItem]
                 InfoItem =
                     {name, atom()} |
                     {type, Type} |
                     {protection, Protection} |
                     {named_table, boolean()} |
                     {keypos, integer() &gt;= 0} |
                     {size, integer() &gt;= 0} |
                     {extended_info, [ExtInfo]} |
                     {version,
                      {Major :: integer() &gt;= 0, Minor :: integer() &gt;= 0}}
                 ExtInfo = md5sum | object_count
                 Type = bag | duplicate_bag | ordered_set | set
                 Protection = private | protected | public
                 Reason = term()

              Returns information about the table dumped to file by <u>tab2file/2</u> or <u>tab2file/3</u>.

              The following items are returned:

                <u>name</u>:
                  The name of the dumped table. If the table was a named table,  a  table  with  the  same  name
                  cannot  exist when the table is loaded from file with <u>file2tab/2</u>. If the table is not saved as
                  a named table, this field has no significance when loading the table from file.

                <u>type</u>:
                  The ETS type of the dumped table (that is, <u>set</u>, <u>bag</u>, <u>duplicate_bag</u>, or <u>ordered_set</u>). This type
                  is used when loading the table again.

                <u>protection</u>:
                  The protection of the dumped table (that is, <u>private</u>, <u>protected</u>, or <u>public</u>).  A  table  loaded
                  from the file gets the same protection.

                <u>named_table</u>:
                  <u>true</u>  if  the table was a named table when dumped to file, otherwise <u>false</u>. Notice that when a
                  named table is loaded from a file, there cannot exist a table in  the  system  with  the  same
                  name.

                <u>keypos</u>:
                  The <u>keypos</u> of the table dumped to file, which is used when loading the table again.

                <u>size</u>:
                  The  number  of  objects in the table when the table dump to file started. For a <u>public</u> table,
                  this number does not need to correspond to the number of objects saved to the file, as objects
                  can have been added or deleted by another process during table dump.

                <u>extended_info</u>:
                  The extended information written in the file footer  to  allow  stronger  verification  during
                  table  loading  from  file,  as  specified to <u>tab2file/3</u>. Notice that this function only tells
                  <u>which</u> information is present, not the  values  in  the  file  footer.  The  value  is  a  list
                  containing one or more of the atoms <u>object_count</u> and <u>md5sum</u>.

                <u>version</u>:
                  A  tuple <u>{Major,Minor}</u> containing the major and minor version of the file format for ETS table
                  dumps. This version field was added beginning with  STDLIB  1.5.1.  Files  dumped  with  older
                  versions return <u>{0,0}</u> in this field.

              An  error  is returned if the file is inaccessible, badly damaged, or not produced with <u>tab2file/2</u>
              or <u>tab2file/3</u>.

       <b>table(Tab)</b> <b>-&gt;</b> <b>QueryHandle</b>

       <b>table(Tab,</b> <b>Options)</b> <b>-&gt;</b> <b>QueryHandle</b>

              Types:

                 Tab = tab()
                 QueryHandle = qlc:query_handle()
                 Options = [Option] | Option
                 Option = {n_objects, NObjects} | {traverse, TraverseMethod}
                 NObjects = default | integer() &gt;= 1
                 TraverseMethod =
                     first_next | last_prev | select |
                     {select, MatchSpec :: match_spec()}

              Returns a Query List Comprehension (QLC) query handle. The <u>qlc</u> module provides  a  query  language
              aimed  mainly  at  Mnesia,  but  ETS  tables, Dets tables, and lists are also recognized by QLC as
              sources of data. Calling <u>table/1,2</u> is the means to make the ETS table <u>Tab</u> usable to QLC.

              When there are only simple restrictions on the key position, QLC uses  <u>lookup/2</u>  to  look  up  the
              keys. When that is not possible, the whole table is traversed. Option <u>traverse</u> determines how this
              is done:

                <u>first_next</u>:
                  The table is traversed one key at a time by calling <u>first/1</u> and <u>next/2</u>.

                <u>last_prev</u>:
                  The table is traversed one key at a time by calling <u>last/1</u> and <u>prev/2</u>.

                <u>select</u>:
                  The  table  is  traversed  by  calling  <u>select/3</u> and <u>select/1</u>. Option <u>n_objects</u> determines the
                  number of objects returned (the third argument of <u>select/3</u>); the  default  is  to  return  <u>100</u>
                  objects  at  a time. The match specification (the second argument of <u>select/3</u>) is assembled by
                  QLC: simple filters are translated into equivalent match specifications while more complicated
                  filters must be applied to all objects returned by <u>select/3</u> given a match  specification  that
                  matches all objects.

                <u>{select,</u> <u>MatchSpec}</u>:
                  As for <u>select</u>, the table is traversed by calling <u>select/3</u> and <u>select/1</u>. The difference is that
                  the  match  specification  is  explicitly specified. This is how to state match specifications
                  that cannot easily be expressed within the syntax provided by QLC.

              <u>Examples:</u>

              An explicit match specification is here used to traverse the table:

              9&gt; true = ets:insert(Tab = ets:new(t, []), [{1,a},{2,b},{3,c},{4,d}]),
              MS = ets:fun2ms(fun({X,Y}) when (X &gt; 1) or (X &lt; 5) -&gt; {Y} end),
              QH1 = ets:table(Tab, [{traverse, {select, MS}}]).

              An example with an implicit match specification:

              10&gt; QH2 = qlc:q([{Y} || {X,Y} &lt;- ets:table(Tab), (X &gt; 1) or (X &lt; 5)]).

              The latter example is equivalent to the former, which can be verified using function <u>qlc:info/1</u>:

              11&gt; qlc:info(QH1) =:= qlc:info(QH2).
              true

              <u>qlc:info/1</u> returns information about a query handle, and in this  case  identical  information  is
              returned for the two query handles.

       <b>take(Tab,</b> <b>Key)</b> <b>-&gt;</b> <b>[Object]</b>

              Types:

                 Tab = tab()
                 Key = term()
                 Object = tuple()

              Returns and removes a list of all objects with key <u>Key</u> in table <u>Tab</u>.

              The specified <u>Key</u> is used to identify the object by either <u>comparing</u> <u>equal</u> the key of an object in
              an  <u>ordered_set</u>  table,  or  <u>matching</u> in other types of tables (for details on the difference, see
              <u>lookup/2</u> and <u>new/2</u>).

       <b>test_ms(Tuple,</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>{ok,</b> <b>Result}</b> <b>|</b> <b>{error,</b> <b>Errors}</b>

              Types:

                 Tuple = tuple()
                 MatchSpec = match_spec()
                 Result = term()
                 Errors = [{warning | error, string()}]

              This function is a utility to test a match specification used in calls to <u>select/2</u>.  The  function
              both  tests  <u>MatchSpec</u> for "syntactic" correctness and runs the match specification against object
              <u>Tuple</u>.

              If the match specification is syntactically correct,  the  function  either  returns  <u>{ok,Result}</u>,
              where  <u>Result</u>  is  what  would have been the result in a real <u>select/2</u> call, or <u>false</u> if the match
              specification does not match object <u>Tuple</u>.

              If the match specification contains errors, tuple <u>{error,</u> <u>Errors}</u> is returned, where <u>Errors</u>  is  a
              list of natural language descriptions of what was wrong with the match specification.

              This is a useful debugging and test tool, especially when writing complicated <u>select/2</u> calls.

              See also:  erlang:match_spec_test/3.

       <b>to_dets(Tab,</b> <b>DetsTab)</b> <b>-&gt;</b> <b>DetsTab</b>

              Types:

                 Tab = tab()
                 DetsTab = dets:tab_name()

              Fills  an already created/opened Dets table with the objects in the already opened ETS table named
              <u>Tab</u>. The Dets table is emptied before the objects are inserted.

       <b>update_counter(Tab,</b> <b>Key,</b> <b>UpdateOp)</b> <b>-&gt;</b> <b>Result</b>

       <b>update_counter(Tab,</b> <b>Key,</b> <b>UpdateOp,</b> <b>Default)</b> <b>-&gt;</b> <b>Result</b>

       <b>update_counter(Tab,</b> <b>Key,</b> <b>X3</b> <b>::</b> <b>[UpdateOp])</b> <b>-&gt;</b> <b>[Result]</b>

       <b>update_counter(Tab,</b> <b>Key,</b> <b>X3</b> <b>::</b> <b>[UpdateOp],</b> <b>Default)</b> <b>-&gt;</b> <b>[Result]</b>

       <b>update_counter(Tab,</b> <b>Key,</b> <b>Incr)</b> <b>-&gt;</b> <b>Result</b>

       <b>update_counter(Tab,</b> <b>Key,</b> <b>Incr,</b> <b>Default)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Tab = tab()
                 Key = term()
                 UpdateOp = {Pos, Incr} | {Pos, Incr, Threshold, SetValue}
                 Pos = Incr = Threshold = SetValue = Result = integer()
                 Default = tuple()

              This function provides an efficient way to update one or more counters,  without  the  trouble  of
              having  to  look  up  an  object,  update  the  object  by incrementing an element, and insert the
              resulting object into the table again. The operation is guaranteed to be atomic and isolated.

              This function destructively update the object with key <u>Key</u> in table <u>Tab</u>  by  adding  <u>Incr</u>  to  the
              element  at  position  <u>Pos</u>.  The  new  counter value is returned. If no position is specified, the
              element directly following key (<u>&lt;keypos&gt;+1</u>) is updated.

              If a <u>Threshold</u> is specified, the counter is reset to value <u>SetValue</u> if  the  following  conditions
              occur:

                * <u>Incr</u> is not negative (<u>&gt;=</u> <u>0</u>) and the result would be greater than (<u>&gt;</u>) <u>Threshold</u>.

                * <u>Incr</u> is negative (<u>&lt;</u> <u>0</u>) and the result would be less than (<u>&lt;</u>) <u>Threshold</u>.

              A  list of <u>UpdateOp</u> can be supplied to do many update operations within the object. The operations
              are carried out in the order specified in the list. If the same counter position occurs more  than
              once  in  the  list,  the corresponding counter is thus updated many times, each time based on the
              previous result. The return value is a list of the new counter values from each  update  operation
              in  the same order as in the operation list. If an empty list is specified, nothing is updated and
              an empty list is returned. If the function fails, no updates are done.

              The specified <u>Key</u> is used to identify the object by either <u>matching</u> the key of an object in a  <u>set</u>
              table,  or  <u>compare</u>  <u>equal</u>  to  the  key  of an object in an <u>ordered_set</u> table (for details on the
              difference, see <u>lookup/2</u> and <u>new/2</u>).

              If a default object <u>Default</u> is specified, it is used as the object to be updated  if  the  key  is
              missing  from  the  table. The value in place of the key is ignored and replaced by the proper key
              value. The return value is as if the default object had not been used, that is, a  single  updated
              element or a list of them.

              The function fails with reason <u>badarg</u> in the following situations:

                * The table type is not <u>set</u> or <u>ordered_set</u>.

                * No object with the correct key exists and no default object was supplied.

                * The object has the wrong arity.

                * The default object arity is smaller than <u>&lt;keypos&gt;</u>.

                * Any field from the default object that is updated is not an integer.

                * The element to update is not an integer.

                * The element to update is also the key.

                * Any of <u>Pos</u>, <u>Incr</u>, <u>Threshold</u>, or <u>SetValue</u> is not an integer.

       <b>update_element(Tab,</b> <b>Key,</b> <b>ElementSpec</b> <b>::</b> <b>{Pos,</b> <b>Value})</b> <b>-&gt;</b> <b>boolean()</b>

       <b>update_element(Tab,</b> <b>Key,</b> <b>ElementSpec</b> <b>::</b> <b>[{Pos,</b> <b>Value}])</b> <b>-&gt;</b>
                         boolean()

              Types:

                 Tab = tab()
                 Key = term()
                 Value = term()
                 Pos = integer() &gt;= 1

              This  function  provides an efficient way to update one or more elements within an object, without
              the trouble of having to look up, update, and write back the entire object.

              This function destructively updates the object with key <u>Key</u> in table <u>Tab</u>. The element at  position
              <u>Pos</u> is given the value <u>Value</u>.

              A  list of <u>{Pos,Value}</u> can be supplied to update many elements within the same object. If the same
              position occurs more than once in the list, the last value in the list is written. If the list  is
              empty  or  the  function fails, no updates are done. The function is also atomic in the sense that
              other processes can never see any intermediate results.

              Returns <u>true</u> if an object with key <u>Key</u> is found, otherwise <u>false</u>.

              The specified <u>Key</u> is used to identify the object by either <u>matching</u> the key of an object in a  <u>set</u>
              table,  or  <u>compare</u>  <u>equal</u>  to  the  key  of an object in an <u>ordered_set</u> table (for details on the
              difference, see <u>lookup/2</u> and <u>new/2</u>).

              The function fails with reason <u>badarg</u> in the following situations:

                * The table type is not <u>set</u> or <u>ordered_set</u>.

                * <u>Pos</u> &lt; 1.

                * <u>Pos</u> &gt; object arity.

                * The element to update is also the key.

       <b>whereis(TableName)</b> <b>-&gt;</b> <b>tid()</b> <b>|</b> <b>undefined</b>

              Types:

                 TableName = atom()

              This function returns the <u>tid()</u> of the named table identified by <u>TableName</u>,  or  <u>undefined</u>  if  no
              such  table  exists.  The <u>tid()</u> can be used in place of the table name in all operations, which is
              slightly faster since the name does not have to be resolved on each call.

              If the table is deleted, the <u>tid()</u> will be invalid even if another named table is created with the
              same name.

Ericsson AB                                        stdlib 3.17                                         <u><a href="../man3erl/ets.3erl.html">ets</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>