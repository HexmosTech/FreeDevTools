<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::Class::Storage::DBI::Replicated::Balancer - A Software Load Balancer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-class-perl">libdbix-class-perl_0.082844-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::Class::Storage::DBI::Replicated::Balancer - A Software Load Balancer

</pre><h4><b>SYNOPSIS</b></h4><pre>
       This role is used internally by DBIx::Class::Storage::DBI::Replicated.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Given a pool (DBIx::Class::Storage::DBI::Replicated::Pool) of replicated database's
       (DBIx::Class::Storage::DBI::Replicated::Replicant), defines a method by which query load can be spread
       out across each replicant in the pool.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       This class defines the following attributes.

   <b>auto_validate_every</b> <b>($seconds)</b>
       If auto_validate has some sort of value, run "validate_replicants" in
       DBIx::Class::Storage::DBI::Replicated::Pool every $seconds.  Be careful with this, because if you set it
       to 0 you will end up validating every query.

   <b>master</b>
       The DBIx::Class::Storage::DBI object that is the master database all the replicants are trying to follow.
       The balancer needs to know it since it's the ultimate fallback.

   <b>pool</b>
       The DBIx::Class::Storage::DBI::Replicated::Pool object that we are trying to balance.

   <b>current_replicant</b>
       Replicant storages (slaves) handle all read only traffic.  The assumption is that your database will
       become readbound well before it becomes write bound and that being able to spread your read only traffic
       around to multiple databases is going to help you to scale traffic.

       This attribute returns the next slave to handle a read request.  Your "pool" attribute has methods to
       help you shuffle through all the available replicants via its balancer object.

</pre><h4><b>METHODS</b></h4><pre>
       This class defines the following methods.

   <b>_build_current_replicant</b>
       Lazy builder for the "current_replicant" attribute.

   <b>next_storage</b>
       This method should be defined in the class which consumes this role.

       Given a pool object, return the next replicant that will serve queries.  The default behavior is to grab
       the first replicant it finds but you can write your own subclasses of
       DBIx::Class::Storage::DBI::Replicated::Balancer to support other balance systems.

       This returns from the pool of active replicants.  If there are no active replicants, then you should have
       it return the master as an ultimate fallback.

   <b>around:</b> <b>next_storage</b>
       Advice on next storage to add the autovalidation.  We have this broken out so that it's easier to break
       out the auto validation into a role.

       This also returns the master in the case that none of the replicants are active or just forgot to create
       them :)

   <b>increment_storage</b>
       Rolls the Storage to whatever is next in the queue, as defined by the Balancer.

   <b>around:</b> <b>select</b>
       Advice on the select attribute.  Each time we use a replicant we need to change it via the storage pool
       algorithm.  That way we are spreading the load evenly (hopefully) across existing capacity.

   <b>around:</b> <b>select_single</b>
       Advice on the select_single attribute.  Each time we use a replicant we need to change it via the storage
       pool algorithm.  That way we are spreading the load evenly (hopefully) across existing capacity.

   <b>before:</b> <b>columns_info_for</b>
       Advice on the current_replicant_storage attribute.  Each time we use a replicant we need to change it via
       the storage pool algorithm.  That way we are spreading the load evenly (hopefully) across existing
       capacity.

   <b>_get_forced_pool</b> <b>($name)</b>
       Given an identifier, find the most correct storage object to handle the query.

</pre><h4><b>FURTHER</b> <b>QUESTIONS?</b></h4><pre>
       Check the list of additional DBIC resources.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This module is free software copyright by the DBIx::Class (DBIC) authors. You can redistribute it and/or
       modify it under the same terms as the DBIx::Class library.

perl v5.40.0                                       2025-02-01              <u>DBIx::Class::S...cated::<a href="../man3pm/Balancer.3pm.html">Balancer</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>