<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_Preserve, Tcl_Release, Tcl_EventuallyFree - avoid freeing storage while it is being used</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_Preserve, Tcl_Release, Tcl_EventuallyFree - avoid freeing storage while it is being used

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       <b>Tcl_Preserve</b>(<u>clientData</u>)

       <b>Tcl_Release</b>(<u>clientData</u>)

       <b>Tcl_EventuallyFree</b>(<u>clientData,</u> <u>freeProc</u>)

</pre><h4><b>ARGUMENTS</b></h4><pre>
       void <u>*clientData</u> (in)                 Token  describing  structure to be freed or reallocated.  Usually a
                                             pointer to memory for structure.

       Tcl_FreeProc <u>*freeProc</u> (in)           Procedure to invoke to free <u>clientData</u>.
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These three procedures help implement a simple reference count mechanism for managing storage.  They  are
       designed  to  solve  a  problem  having  to  do  with  widget deletion, but are also useful in many other
       situations.  When a widget is deleted, its widget record (the structure holding information  specific  to
       the widget) must be returned to the storage allocator.  However, it is possible that the widget record is
       in  active  use  by one of the procedures on the stack at the time of the deletion.  This can happen, for
       example, if the command associated with a button widget causes the button to be destroyed:   an  X  event
       causes  an  event-handling  C  procedure  in  the button to be invoked, which in turn causes the button's
       associated Tcl command to be executed, which in turn causes the button  to  be  deleted,  which  in  turn
       causes  the  button's widget record to be de-allocated.  Unfortunately, when the Tcl command returns, the
       button's event-handling procedure will need to reference the button's widget record.   Because  of  this,
       the  widget  record  must  not  be  freed  as part of the deletion, but must be retained until the event-
       handling procedure has finished with it.  In other situations where the widget  is  deleted,  it  may  be
       possible to free the widget record immediately.

       <b>Tcl_Preserve</b>  and  <b>Tcl_Release</b>  implement short-term reference counts for their <u>clientData</u> argument.  The
       <u>clientData</u> argument identifies an object and usually  consists  of  the  address  of  a  structure.   The
       reference  counts  guarantee  that  an  object  will not be freed until each call to <b>Tcl_Preserve</b> for the
       object has been matched by calls to <b>Tcl_Release</b>.  There may be any number of unmatched <b>Tcl_Preserve</b> calls
       in effect at once.

       <b>Tcl_EventuallyFree</b> is invoked to free up its  <u>clientData</u>  argument.   It  checks  to  see  if  there  are
       unmatched <b>Tcl_Preserve</b> calls for the object.  If not, then <b>Tcl_EventuallyFree</b> calls <u>freeProc</u> immediately.
       Otherwise  <b>Tcl_EventuallyFree</b>  records  the  fact that <u>clientData</u> needs eventually to be freed.  When all
       calls to <b>Tcl_Preserve</b> have been matched with calls  to  <b>Tcl_Release</b>  then  <u>freeProc</u>  will  be  called  by
       <b>Tcl_Release</b> to do the cleanup.

       All  the  work of freeing the object is carried out by <u>freeProc</u>.  <u>FreeProc</u> must have arguments and result
       that match the type <b>Tcl_FreeProc</b>:

              typedef void <b>Tcl_FreeProc</b>(
                      void *<u>blockPtr</u>);

       The <u>blockPtr</u> argument to <u>freeProc</u> will be the same as the <u>clientData</u> argument to <b>Tcl_EventuallyFree</b>.

       When the <u>clientData</u> argument to <b>Tcl_EventuallyFree</b> refers to storage allocated and returned  by  a  prior
       call  to <b>Tcl_Alloc</b> or another function of the Tcl library, then the <u>freeProc</u> argument should be given the
       special value of <b>TCL_DYNAMIC</b>.

       This mechanism can be used to solve the problem described above by placing <b>Tcl_Preserve</b>  and  <b>Tcl_Release</b>
       calls  around actions that may cause undesired storage re-allocation.  The mechanism is intended only for
       short-term use (i.e. while procedures are pending on the stack);  it  will  not  work  efficiently  as  a
       mechanism  for long-term reference counts.  The implementation does not depend in any way on the internal
       structure of the objects being freed;  it keeps the reference counts in a separate structure.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Tcl_Interp, Tcl_Alloc

</pre><h4><b>KEYWORDS</b></h4><pre>
       free, reference count, storage

Tcl                                                    7.5                                    <u><a href="../man3tcl/Tcl_Preserve.3tcl.html">Tcl_Preserve</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>