<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dets - A disk-based term storage.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dets - A disk-based term storage.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module provides a term storage on file. The stored terms, in this module called <u>objects</u>, are tuples
       such that one element is defined to be the key. A Dets <u>table</u> is a collection of objects with the  key  at
       the same position stored on a file.

       This  module  is  used by the Mnesia application, and is provided "as is" for users who are interested in
       efficient storage of Erlang terms on disk only. Many applications only need to  store  some  terms  in  a
       file.  Mnesia adds transactions, queries, and distribution. The size of Dets files cannot exceed 2 GB. If
       larger tables are needed, table fragmentation in Mnesia can be used.

       Three types of Dets tables exist:

         * <u>set</u>. A table of this type has at most one object with a given key. If an object with  a  key  already
           present in the table is inserted, the existing object is overwritten by the new object.

         * <u>bag</u>. A table of this type has zero or more different objects with a given key.

         * <u>duplicate_bag</u>. A table of this type has zero or more possibly matching objects with a given key.

       Dets  tables  must  be opened before they can be updated or read, and when finished they must be properly
       closed. If a table is not properly closed,  Dets  automatically  repairs  the  table.  This  can  take  a
       substantial  time  if  the table is large. A Dets table is closed when the process which opened the table
       terminates. If many Erlang processes (users) open the same Dets table, they share the table. The table is
       properly closed when all users have either terminated or closed the table. Dets tables are  not  properly
       closed if the Erlang runtime system terminates abnormally.

   <b>Note:</b>
       A <u>^C</u> command abnormally terminates an Erlang runtime system in a Unix environment with a break-handler.

       As all operations performed by Dets are disk operations, it is important to realize that a single look-up
       operation  involves  a  series  of  disk  seek and read operations. The Dets functions are therefore much
       slower than the corresponding <u><a href="../man3erl/ets.3erl.html">ets</a>(3erl)</u> functions, although Dets exports a similar interface.

       Dets organizes data as a linear hash list and the hash list grows gracefully as  more  data  is  inserted
       into  the  table. Space management on the file is performed by what is called a buddy system. The current
       implementation keeps the entire buddy system in RAM,  which  implies  that  if  the  table  gets  heavily
       fragmented,  quite some memory can be used up. The only way to defragment a table is to close it and then
       open it again with option <u>repair</u> set to <u>force</u>.

       Notice that type <u>ordered_set</u> in Ets is not yet provided by Dets,  neither  is  the  limited  support  for
       concurrent  updates  that  makes a sequence of <u>first</u> and <u>next</u> calls safe to use on fixed ETS tables. Both
       these features may be provided by Dets in  a  future  release  of  Erlang/OTP.  Until  then,  the  Mnesia
       application  (or  some  user-implemented  method for locking) must be used to implement safe concurrency.
       Currently, no Erlang/OTP library has support for ordered disk-based term storage.

       All Dets functions return <u>{error,</u> <u>Reason}</u> if an error occurs (<u>first/1</u> and  <u>next/2</u>  are  exceptions,  they
       exit  the  process with the error tuple). If badly formed arguments are specified, all functions exit the
       process with a <u>badarg</u> message.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>access()</b> = read | read_write

       <b>auto_save()</b> = infinity | integer() &gt;= 0

       <b>bindings_cont()</b>

              Opaque continuation used by <u>match/1</u> and <u>match/3</u>.

       <b>cont()</b>

              Opaque continuation used by <u>bchunk/2</u>.

       <b>keypos()</b> = integer() &gt;= 1

       <b>match_spec()</b> = ets:match_spec()

              Match specifications, see section  Match Specification in Erlang in  ERTS  User's  Guide  and  the
              <u><a href="../man3erl/ms_transform.3erl.html">ms_transform</a>(3erl)</u> module.

       <b>no_slots()</b> = default | integer() &gt;= 0

       <b>object()</b> = tuple()

       <b>object_cont()</b>

              Opaque continuation used by <u>match_object/1</u> and <u>match_object/3</u>.

       <b>pattern()</b> = atom() | tuple()

              For a description of patterns, see <u>ets:match/2</u>.

       <b>select_cont()</b>

              Opaque continuation used by <u>select/1</u> and <u>select/3</u>.

       <b>tab_name()</b> = term()

       <b>type()</b> = bag | duplicate_bag | set

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>all()</b> <b>-&gt;</b> <b>[tab_name()]</b>

              Returns a list of the names of all open tables on this node.

       <b>bchunk(Name,</b> <b>Continuation)</b> <b>-&gt;</b>
                 {Continuation2, Data} |
                 '$end_of_table' |
                 {error, Reason}

              Types:

                 Name = tab_name()
                 Continuation = start | cont()
                 Continuation2 = cont()
                 Data = binary() | tuple()
                 Reason = term()

              Returns  a  list of objects stored in a table. The exact representation of the returned objects is
              not public. The lists of data can be used for initializing a table by specifying value  <u>bchunk</u>  to
              option  <u>format</u> of function <u>init_table/3</u> The Mnesia application uses this function for copying open
              tables.

              Unless the table is protected using <u>safe_fixtable/2</u>, calls to <u>bchunk/2</u> do  possibly  not  work  as
              expected if concurrent updates are made to the table.

              The first time <u>bchunk/2</u> is called, an initial continuation, the atom <u>start</u>, must be provided.

              <u>bchunk/2</u>  returns a tuple <u>{Continuation2,</u> <u>Data}</u>, where <u>Data</u> is a list of objects. <u>Continuation2</u> is
              another continuation that is to be passed on to a subsequent call to <u>bchunk/2</u>. With  a  series  of
              calls to <u>bchunk/2</u>, all table objects can be extracted.

              <u>bchunk/2</u>  returns  <u>'$end_of_table'</u>  when  all objects are returned, or <u>{error,</u> <u>Reason}</u> if an error
              occurs.

       <b>close(Name)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Reason = term()

              Closes a table. Only processes that have opened a table are allowed to close it.

              All open tables must be closed before the system is stopped. If an attempt is made to open a table
              that is not properly closed, Dets automatically tries to repair it.

       <b>delete(Name,</b> <b>Key)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Key = Reason = term()

              Deletes all objects with key <u>Key</u> from table <u>Name</u>.

       <b>delete_all_objects(Name)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Reason = term()

              Deletes all objects from a table in  almost  constant  time.  However,  if  the  table  if  fixed,
              <u>delete_all_objects(T)</u> is equivalent to <u>match_delete(T,</u> <u>'_')</u>.

       <b>delete_object(Name,</b> <b>Object)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Object = object()
                 Reason = term()

              Deletes  all  instances  of  a  specified  object  from  a  table.  If  a  table is of type <u>bag</u> or
              <u>duplicate_bag</u>, this function can be used to delete only some of the objects with a specified key.

       <b>first(Name)</b> <b>-&gt;</b> <b>Key</b> <b>|</b> <b>'$end_of_table'</b>

              Types:

                 Name = tab_name()
                 Key = term()

              Returns the first key stored in table <u>Name</u> according to  the  internal  order  of  the  table,  or
              <u>'$end_of_table'</u> if the table is empty.

              Unless  the  table  is protected using <u>safe_fixtable/2</u>, subsequent calls to <u>next/2</u> do possibly not
              work as expected if concurrent updates are made to the table.

              If an error occurs, the process is exited with an error tuple <u>{error,</u> <u>Reason}</u>. The error tuple  is
              not returned, as it cannot be distinguished from a key.

              There  are two reasons why <u>first/1</u> and <u>next/2</u> are not to be used: they are not efficient, and they
              prevent the use of key <u>'$end_of_table'</u>, as this atom is used to indicate the end of the table.  If
              possible, use functions <u>match</u>, <u>match_object</u>, and <u>select</u> for traversing tables.

       <b>foldl(Function,</b> <b>Acc0,</b> <b>Name)</b> <b>-&gt;</b> <b>Acc</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>foldr(Function,</b> <b>Acc0,</b> <b>Name)</b> <b>-&gt;</b> <b>Acc</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Function = fun((Object :: object(), AccIn) -&gt; AccOut)
                 Acc0 = Acc = AccIn = AccOut = Reason = term()

              Calls  <u>Function</u>  on  successive  elements of table <u>Name</u> together with an extra argument <u>AccIn</u>. The
              table elements are traversed in unspecified order. <u>Function</u> must return a new accumulator that  is
              passed to the next call. <u>Acc0</u> is returned if the table is empty.

       <b>from_ets(Name,</b> <b>EtsTab)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 EtsTab = ets:tab()
                 Reason = term()

              Deletes  all  objects  of table <u>Name</u> and then inserts all the objects of the ETS table <u>EtsTab</u>. The
              objects are inserted in unspecified order. As <u>ets:safe_fixtable/2</u> is called, the ETS table must be
              public or owned by the calling process.

       <b>info(Name)</b> <b>-&gt;</b> <b>InfoList</b> <b>|</b> <b>undefined</b>

              Types:

                 Name = tab_name()
                 InfoList = [InfoTuple]
                 InfoTuple =
                     {file_size, integer() &gt;= 0} |
                     {filename, file:name()} |
                     {keypos, keypos()} |
                     {size, integer() &gt;= 0} |
                     {type, type()}

              Returns information about table <u>Name</u> as a list of tuples:

                * <u>{file_size,</u> <u>integer()</u> <u>&gt;=</u> <u>0}}</u> - The file size, in bytes.

                * <u>{filename,</u> <u>file:name()}</u> - The name of the file where objects are stored.

                * <u>{keypos,</u> <u>keypos()}</u> - The key position.

                * <u>{size,</u> <u>integer()</u> <u>&gt;=</u> <u>0}</u> - The number of objects stored in the table.

                * <u>{type,</u> <u>type()}</u> - The table type.

       <b>info(Name,</b> <b>Item)</b> <b>-&gt;</b> <b>Value</b> <b>|</b> <b>undefined</b>

              Types:

                 Name = tab_name()
                 Item =
                     access | auto_save | bchunk_format | hash | file_size |
                     filename | keypos | memory | no_keys | no_objects | no_slots |
                     owner | ram_file | safe_fixed | safe_fixed_monotonic_time |
                     size | type
                 Value = term()

              Returns the information associated with <u>Item</u> for table <u>Name</u>. In  addition  to  the  <u>{Item,</u>  <u>Value}</u>
              pairs defined for <u>info/1</u>, the following items are allowed:

                * <u>{access,</u> <u>access()}</u> - The access mode.

                * <u>{auto_save,</u> <u>auto_save()}</u> - The autosave interval.

                * <u>{bchunk_format,</u>  <u>binary()}</u> - An opaque binary describing the format of the objects returned by
                  <u>bchunk/2</u>. The binary can be used as argument to <u>is_compatible_chunk_format/2</u>.

                * <u>{hash,</u> <u>Hash}</u> - Describes which BIF is used to calculate the hash values of the objects  stored
                  in the Dets table. Possible values of <u>Hash</u>:

                  * <u>phash</u> - Implies that the <u>erlang:phash/2</u> BIF is used.

                  * <u>phash2</u> - Implies that the <u>erlang:phash2/1</u> BIF is used.

                * <u>{memory,</u>  <u>integer()</u>  <u>&gt;=</u>  <u>0}</u>  - The file size, in bytes. The same value is associated with item
                  <u>file_size</u>.

                * <u>{no_keys,</u> <u>integer</u> <u>&gt;=</u> <u>0()}</u> - The number of different keys stored in the table.

                * <u>{no_objects,</u> <u>integer</u> <u>&gt;=</u> <u>0()}</u> - The number of objects stored in the table.

                * <u>{no_slots,</u> <u>{Min,</u> <u>Used,</u> <u>Max}}</u> - The number of slots of the table. <u>Min</u> is the minimum number  of
                  slots, <u>Used</u> is the number of currently used slots, and <u>Max</u> is the maximum number of slots.

                * <u>{owner,</u> <u>pid()}</u> - The pid of the process that handles requests to the Dets table.

                * <u>{ram_file,</u> <u>boolean()}</u> - Whether the table is kept in RAM.

                * <u>{safe_fixed_monotonic_time,</u>  <u>SafeFixed}</u>  -  If  the  table  is  fixed,  <u>SafeFixed</u>  is  a tuple
                  <u>{FixedAtTime,</u> <u>[{Pid,RefCount}]}</u>. <u>FixedAtTime</u> is the time when the table was first  fixed,  and
                  <u>Pid</u>  is the pid of the process that fixes the table <u>RefCount</u> times. There can be any number of
                  processes in the list. If the table is not fixed, <u>SafeFixed</u> is the atom <u>false</u>.

                  <u>FixedAtTime</u> corresponds to the result returned  by  <u>erlang:monotonic_time/0</u>  at  the  time  of
                  fixation. The use of <u>safe_fixed_monotonic_time</u> is  time warp safe.

                * <u>{safe_fixed,</u> <u>SafeFixed}</u> - The same as <u>{safe_fixed_monotonic_time,</u> <u>SafeFixed}</u> except the format
                  and value of <u>FixedAtTime</u>.

                  <u>FixedAtTime</u>  corresponds to the result returned by <u>erlang:timestamp/0</u> at the time of fixation.
                  Notice that when the system uses single or multi time warp modes,  this  can  produce  strange
                  results.  This  is  because  the use of <u>safe_fixed</u> is not  time warp safe. Time warp safe code
                  must use <u>safe_fixed_monotonic_time</u> instead.

       <b>init_table(Name,</b> <b>InitFun)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>init_table(Name,</b> <b>InitFun,</b> <b>Options)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 InitFun = fun((Arg) -&gt; Res)
                 Arg = read | close
                 Res =
                     end_of_input |
                     {[object()], InitFun} |
                     {Data, InitFun} |
                     term()
                 Options = Option | [Option]
                 Option = {min_no_slots, no_slots()} | {format, term | bchunk}
                 Reason = term()
                 Data = binary() | tuple()

              Replaces the existing objects of table <u>Name</u> with objects created by  calling  the  input  function
              <u>InitFun</u>,  see  below.  The  reason for using this function rather than calling <u>insert/2</u> is that of
              efficiency. Notice that the input functions are called by the process that handles requests to the
              Dets table, not by the calling process.

              When called with argument <u>read</u>, function <u>InitFun</u> is assumed to return <u>end_of_input</u> when  there  is
              no  more  input,  or  <u>{Objects,</u>  <u>Fun}</u>,  where  <u>Objects</u> is a list of objects and <u>Fun</u> is a new input
              function. Any other value <u>Value</u> is returned as an error <u>{error,</u>  <u>{init_fun,</u>  <u>Value}}</u>.  Each  input
              function is called exactly once, and if an error occurs, the last function is called with argument
              <u>close</u>, the reply of which is ignored.

              If  the  table type is <u>set</u> and more than one object exists with a given key, one of the objects is
              chosen. This is not necessarily the last object with the given key  in  the  sequence  of  objects
              returned  by  the  input functions. Avoid duplicate keys, otherwise the file becomes unnecessarily
              fragmented. This holds also for duplicated objects stored in tables of type <u>bag</u>.

              It is important that the table has a sufficient number of slots for the objects. If not, the  hash
              list  starts to grow when <u>init_table/2</u> returns, which significantly slows down access to the table
              for a period of time. The minimum number of slots is set by the  <u>open_file/2</u>  option  <u>min_no_slots</u>
              and returned by the <u>info/2</u> item <u>no_slots</u>. See also option <u>min_no_slots</u> below.

              Argument <u>Options</u> is a list of <u>{Key,</u> <u>Val}</u> tuples, where the following values are allowed:

                * <u>{min_no_slots,</u>  <u>no_slots()}</u> - Specifies the estimated number of different keys to be stored in
                  the table. The <u>open_file/2</u> option with the same name is ignored, unless the table is  created,
                  in  which  case  performance  can  be  enhanced by supplying an estimate when initializing the
                  table.

                * <u>{format,</u> <u>Format}</u> - Specifies the format of the objects returned by function <u>InitFun</u>. If <u>Format</u>
                  is <u>term</u> (the default), <u>InitFun</u> is assumed to return a list of tuples.  If  <u>Format</u>  is  <u>bchunk</u>,
                  <u>InitFun</u>  is  assumed  to  return  <u>Data</u>  as  returned by <u>bchunk/2</u>. This option overrides option
                  <u>min_no_slots</u>.

       <b>insert(Name,</b> <b>Objects)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Objects = object() | [object()]
                 Reason = term()

              Inserts one or more objects into the table <u>Name</u>. If there already exists  an  object  with  a  key
              matching  the  key  of some of the given objects and the table type is <u>set</u>, the old object will be
              replaced.

       <b>insert_new(Name,</b> <b>Objects)</b> <b>-&gt;</b> <b>boolean()</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Objects = object() | [object()]
                 Reason = term()

              Inserts one or more objects into table <u>Name</u>. If there  already  exists  some  object  with  a  key
              matching  the key of any of the specified objects, the table is not updated and <u>false</u> is returned.
              Otherwise the objects are inserted and <u>true</u> returned.

       <b>is_compatible_bchunk_format(Name,</b> <b>BchunkFormat)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Name = tab_name()
                 BchunkFormat = binary()

              Returns <u>true</u> if it would be possible to initialize table  <u>Name</u>,  using  <u>init_table/3</u>  with  option
              <u>{format,</u>  <u>bchunk}</u>,  with  objects  read with <u>bchunk/2</u> from some table <u>T</u>, such that calling <u>info(T,</u>
              <u>bchunk_format)</u> returns <u>BchunkFormat</u>.

       <b>is_dets_file(Filename)</b> <b>-&gt;</b> <b>boolean()</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = file:name()
                 Reason = term()

              Returns <u>true</u> if file <u>Filename</u> is a Dets table, otherwise <u>false</u>.

       <b>lookup(Name,</b> <b>Key)</b> <b>-&gt;</b> <b>Objects</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Key = term()
                 Objects = [object()]
                 Reason = term()

              Returns a list of all objects with key <u>Key</u> stored in table <u>Name</u>, for example:

              2&gt; dets:open_file(abc, [{type, bag}]).
              {ok,abc}
              3&gt; dets:insert(abc, {1,2,3}).
              ok
              4&gt; dets:insert(abc, {1,3,4}).
              ok
              5&gt; dets:lookup(abc, 1).
              [{1,2,3},{1,3,4}]

              If the table type is <u>set</u>, the function returns either the empty list or a list with one object, as
              there cannot be more than one object with a given key. If the table type is <u>bag</u> or  <u>duplicate_bag</u>,
              the function returns a list of arbitrary length.

              Notice  that  the  order  of  objects  returned  is unspecified. In particular, the order in which
              objects were inserted is not reflected.

       <b>match(Continuation)</b> <b>-&gt;</b>
                {[Match], Continuation2} |
                '$end_of_table' |
                {error, Reason}

              Types:

                 Continuation = Continuation2 = bindings_cont()
                 Match = [term()]
                 Reason = term()

              Matches some objects stored in a table and returns a non-empty list of  the  bindings  matching  a
              specified  pattern  in  some  unspecified order. The table, the pattern, and the number of objects
              that are matched are all defined by <u>Continuation</u>, which has been returned by a  previous  call  to
              <u>match/1</u> or <u>match/3</u>.

              When all table objects are matched, <u>'$end_of_table'</u> is returned.

       <b>match(Name,</b> <b>Pattern)</b> <b>-&gt;</b> <b>[Match]</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Pattern = pattern()
                 Match = [term()]
                 Reason = term()

              Returns  for each object of table <u>Name</u> that matches <u>Pattern</u> a list of bindings in some unspecified
              order. For a description of patterns, see <u>ets:match/2</u>. If the  keypos'th  element  of  <u>Pattern</u>  is
              unbound,  all  table objects are matched. If the keypos'th element is bound, only the objects with
              the correct key are matched.

       <b>match(Name,</b> <b>Pattern,</b> <b>N)</b> <b>-&gt;</b>
                {[Match], Continuation} |
                '$end_of_table' |
                {error, Reason}

              Types:

                 Name = tab_name()
                 Pattern = pattern()
                 N = default | integer() &gt;= 0
                 Continuation = bindings_cont()
                 Match = [term()]
                 Reason = term()

              Matches some or all objects of table <u>Name</u> and returns a non-empty list of the bindings that  match
              <u>Pattern</u> in some unspecified order. For a description of patterns, see <u>ets:match/2</u>.

              A  tuple  of the bindings and a continuation is returned, unless the table is empty, in which case
              <u>'$end_of_table'</u> is returned. The continuation is to be  used  when  matching  further  objects  by
              calling <u>match/1</u>.

              If  the  keypos'th  element  of  <u>Pattern</u> is bound, all table objects are matched. If the keypos'th
              element is unbound, all table objects are matched, <u>N</u> objects at a time, until at least one  object
              matches  or the end of the table is reached. The default, indicated by giving <u>N</u> the value <u>default</u>,
              is to let the number of objects vary depending on the sizes of the objects. All objects  with  the
              same key are always matched at the same time, which implies that more than N objects can sometimes
              be matched.

              The table is always to be protected using <u>safe_fixtable/2</u> before calling <u>match/3</u>, otherwise errors
              can occur when calling <u>match/1</u>.

       <b>match_delete(Name,</b> <b>Pattern)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Pattern = pattern()
                 Reason = term()

              Deletes  all  objects  that  match  <u>Pattern</u>  from  table  <u>Name</u>. For a description of patterns, see
              <u>ets:match/2</u>.

              If the keypos'th element of <u>Pattern</u> is bound, only the objects with the correct key are matched.

       <b>match_object(Continuation)</b> <b>-&gt;</b>
                       {Objects, Continuation2} |
                       '$end_of_table' |
                       {error, Reason}

              Types:

                 Continuation = Continuation2 = object_cont()
                 Objects = [object()]
                 Reason = term()

              Returns a non-empty list of some objects stored in a table that match  a  given  pattern  in  some
              unspecified  order.  The  table,  the  pattern, and the number of objects that are matched are all
              defined by <u>Continuation</u>, which  has  been  returned  by  a  previous  call  to  <u>match_object/1</u>  or
              <u>match_object/3</u>.

              When all table objects are matched, <u>'$end_of_table'</u> is returned.

       <b>match_object(Name,</b> <b>Pattern)</b> <b>-&gt;</b> <b>Objects</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Pattern = pattern()
                 Objects = [object()]
                 Reason = term()

              Returns  a  list  of all objects of table <u>Name</u> that match <u>Pattern</u> in some unspecified order. For a
              description of patterns, see <u>ets:match/2</u>.

              If the keypos'th element of <u>Pattern</u> is unbound, all table objects are matched.  If  the  keypos'th
              element of <u>Pattern</u> is bound, only the objects with the correct key are matched.

              Using  the  <u>match_object</u> functions for traversing all table objects is more efficient than calling
              <u>first/1</u> and <u>next/2</u> or <u>slot/2</u>.

       <b>match_object(Name,</b> <b>Pattern,</b> <b>N)</b> <b>-&gt;</b>
                       {Objects, Continuation} |
                       '$end_of_table' |
                       {error, Reason}

              Types:

                 Name = tab_name()
                 Pattern = pattern()
                 N = default | integer() &gt;= 0
                 Continuation = object_cont()
                 Objects = [object()]
                 Reason = term()

              Matches some or all objects stored in table <u>Name</u> and returns a non-empty list of the objects  that
              match <u>Pattern</u> in some unspecified order. For a description of patterns, see <u>ets:match/2</u>.

              A  list  of  objects  and  a  continuation  is  returned, unless the table is empty, in which case
              <u>'$end_of_table'</u> is returned. The continuation is to be  used  when  matching  further  objects  by
              calling <u>match_object/1</u>.

              If  the  keypos'th  element  of  <u>Pattern</u> is bound, all table objects are matched. If the keypos'th
              element is unbound, all table objects are matched, <u>N</u> objects at a time, until at least one  object
              matches  or the end of the table is reached. The default, indicated by giving <u>N</u> the value <u>default</u>,
              is to let the number of objects vary depending on the sizes of the objects. All  matching  objects
              with  the  same  key are always returned in the same reply, which implies that more than N objects
              can sometimes be returned.

              The table is always to be protected using <u>safe_fixtable/2</u> before calling <u>match_object/3</u>, otherwise
              errors can occur when calling <u>match_object/1</u>.

       <b>member(Name,</b> <b>Key)</b> <b>-&gt;</b> <b>boolean()</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Key = Reason = term()

              Works like <u>lookup/2</u>, but does not return the objects. Returns <u>true</u> if one or more  table  elements
              has key <u>Key</u>, otherwise <u>false</u>.

       <b>next(Name,</b> <b>Key1)</b> <b>-&gt;</b> <b>Key2</b> <b>|</b> <b>'$end_of_table'</b>

              Types:

                 Name = tab_name()
                 Key1 = Key2 = term()

              Returns  either the key following <u>Key1</u> in table <u>Name</u> according to the internal order of the table,
              or <u>'$end_of_table'</u> if there is no next key.

              If an error occurs, the process is exited with an error tuple <u>{error,</u> <u>Reason}</u>.

              To find the first key in the table, use <u>first/1</u>.

       <b>open_file(Filename)</b> <b>-&gt;</b> <b>{ok,</b> <b>Reference}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = file:name()
                 Reference = reference()
                 Reason = term()

              Opens an existing table. If the table is  not  properly  closed,  it  is  repaired.  The  returned
              reference is to be used as the table name. This function is most useful for debugging purposes.

       <b>open_file(Name,</b> <b>Args)</b> <b>-&gt;</b> <b>{ok,</b> <b>Name}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Args = [OpenArg]
                 OpenArg =
                     {access, access()} |
                     {auto_save, auto_save()} |
                     {estimated_no_objects, integer() &gt;= 0} |
                     {file, file:name()} |
                     {max_no_slots, no_slots()} |
                     {min_no_slots, no_slots()} |
                     {keypos, keypos()} |
                     {ram_file, boolean()} |
                     {repair, boolean() | force} |
                     {type, type()}
                 Reason = term()

              Opens a table. An empty Dets table is created if no file exists.

              The  atom  <u>Name</u> is the table name. The table name must be provided in all subsequent operations on
              the table. The name can be used by other processes as well,  and  many  processes  can  share  one
              table.

              If  two  processes  open  the  same table by giving the same name and arguments, the table has two
              users. If one user closes the table, it remains open until the second user closes it.

              Argument <u>Args</u> is a list of <u>{Key,</u> <u>Val}</u> tuples, where the following values are allowed:

                * <u>{access,</u> <u>access()}</u> - Existing tables can be opened in read-only mode. A table that  is  opened
                  in  read-only  mode is not subjected to the automatic file reparation algorithm if it is later
                  opened after a crash. Defaults to <u>read_write</u>.

                * <u>{auto_save,</u> <u>auto_save()}</u> - The autosave interval. If the interval  is  an  integer  <u>Time</u>,  the
                  table  is  flushed to disk whenever it is not accessed for <u>Time</u> milliseconds. A table that has
                  been flushed requires no reparation when reopened after an uncontrolled emulator halt. If  the
                  interval is the atom <u>infinity</u>, autosave is disabled. Defaults to 180000 (3 minutes).

                * <u>{estimated_no_objects,</u> <u>no_slots()}</u> - Equivalent to option <u>min_no_slots</u>.

                * <u>{file,</u> <u>file:name()}</u> - The name of the file to be opened. Defaults to the table name.

                * <u>{max_no_slots,</u>  <u>no_slots()}</u>  - The maximum number of slots to be used. Defaults to 32 M, which
                  is the maximal value. Notice that a higher value can increase the table fragmentation,  and  a
                  smaller value can decrease the fragmentation, at the expense of execution time.

                * <u>{min_no_slots,</u>  <u>no_slots()}</u>  -  Application  performance  can  be  enhanced  with this flag by
                  specifying, when the table is created, the estimated number of different keys to be stored  in
                  the table. Defaults to 256, which is the minimum value.

                * <u>{keypos,</u> <u>keypos()}</u> - The position of the element of each object to be used as key. Defaults to
                  1.  The  ability to explicitly state the key position is most convenient when we want to store
                  Erlang records in which the first position of the record is the name of the record type.

                * <u>{ram_file,</u> <u>boolean()}</u> - Whether the table is to be kept in RAM. Keeping the table in  RAM  can
                  sound  like  an  anomaly,  but  can enhance the performance of applications that open a table,
                  insert a set of objects, and then close the table. When the table is closed, its contents  are
                  written to the disk file. Defaults to <u>false</u>.

                * <u>{repair,</u> <u>Value}</u> - <u>Value</u> can be either a <u>boolean()</u> or the atom <u>force</u>. The flag specifies if the
                  Dets  server  is to invoke the automatic file reparation algorithm. Defaults to <u>true</u>. If <u>false</u>
                  is specified, no attempt is made to repair the file, and <u>{error,</u> <u>{needs_repair,</u> <u>FileName}}</u>  is
                  returned if the table must be repaired.

                  Value  <u>force</u>  means  that a reparation is made even if the table is properly closed. This is a
                  seldom needed option.

                  Option <u>repair</u> is ignored if the table is already open.

                * <u>{type,</u> <u>type()}</u> - The table type. Defaults to <u>set</u>.

       <b>pid2name(Pid)</b> <b>-&gt;</b> <b>{ok,</b> <b>Name}</b> <b>|</b> <b>undefined</b>

              Types:

                 Pid = pid()
                 Name = tab_name()

              Returns the table name given the pid of a process that handles requests to a table,  or  <u>undefined</u>
              if there is no such table.

              This function is meant to be used for debugging only.

       <b>repair_continuation(Continuation,</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>Continuation2</b>

              Types:

                 Continuation = Continuation2 = select_cont()
                 MatchSpec = match_spec()

              This  function  can  be used to restore an opaque continuation returned by <u>select/3</u> or <u>select/1</u> if
              the continuation has passed through external term format (been sent between  nodes  or  stored  on
              disk).

              The  reason for this function is that continuation terms contain compiled match specifications and
              therefore are invalidated if converted to external term format.  Given  that  the  original  match
              specification  is kept intact, the continuation can be restored, meaning it can once again be used
              in subsequent <u>select/1</u> calls even though it has been stored on disk or on another node.

              For more information and examples, see the <u><a href="../man3erl/ets.3erl.html">ets</a>(3erl)</u> module.

          <b>Note:</b>
              This function is rarely needed in application code. It is used by application  Mnesia  to  provide
              distributed  <u>select/3</u> and <u>select/1</u> sequences. A normal application would either use Mnesia or keep
              the continuation from being converted to external format.

              The reason for  not  having  an  external  representation  of  compiled  match  specifications  is
              performance.  It  can  be  subject  to change in future releases, while this interface remains for
              backward compatibility.

       <b>safe_fixtable(Name,</b> <b>Fix)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Name = tab_name()
                 Fix = boolean()

              If <u>Fix</u> is <u>true</u>, table <u>Name</u> is fixed (once more) by the calling process,  otherwise  the  table  is
              released. The table is also released when a fixing process terminates.

              If  many  processes  fix  a table, the table remains fixed until all processes have released it or
              terminated. A reference counter is kept on a per process basis, and N consecutive fixes require  N
              releases to release the table.

              It is not guaranteed that calls to <u>first/1</u>, <u>next/2</u>, or select and match functions work as expected
              even  if  the table is fixed; the limited support for concurrency provided by the <u><a href="../man3erl/ets.3erl.html">ets</a>(3erl)</u> module
              is not yet provided by Dets. Fixing a table currently only disables resizing of the hash  list  of
              the table.

              If  objects have been added while the table was fixed, the hash list starts to grow when the table
              is released, which significantly slows down access to the table for a period of time.

       <b>select(Continuation)</b> <b>-&gt;</b>
                 {Selection, Continuation2} |
                 '$end_of_table' |
                 {error, Reason}

              Types:

                 Continuation = Continuation2 = select_cont()
                 Selection = [term()]
                 Reason = term()

              Applies a match specification to some objects stored in a table and returns a  non-empty  list  of
              the  results.  The  table, the match specification, and the number of objects that are matched are
              all defined by <u>Continuation</u>, which is returned by a previous call to <u>select/1</u> or <u>select/3</u>.

              When all objects of the table have been matched, <u>'$end_of_table'</u> is returned.

       <b>select(Name,</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>Selection</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 MatchSpec = match_spec()
                 Selection = [term()]
                 Reason = term()

              Returns the results of applying match specification <u>MatchSpec</u> to all or  some  objects  stored  in
              table  <u>Name</u>. The order of the objects is not specified. For a description of match specifications,
              see the ERTS User's Guide.

              If the keypos'th element of <u>MatchSpec</u> is unbound,  the  match  specification  is  applied  to  all
              objects of the table. If the keypos'th element is bound, the match specification is applied to the
              objects with the correct key(s) only.

              Using  the  <u>select</u>  functions for traversing all objects of a table is more efficient than calling
              <u>first/1</u> and <u>next/2</u> or <u>slot/2</u>.

       <b>select(Name,</b> <b>MatchSpec,</b> <b>N)</b> <b>-&gt;</b>
                 {Selection, Continuation} |
                 '$end_of_table' |
                 {error, Reason}

              Types:

                 Name = tab_name()
                 MatchSpec = match_spec()
                 N = default | integer() &gt;= 0
                 Continuation = select_cont()
                 Selection = [term()]
                 Reason = term()

              Returns the results of applying match specification <u>MatchSpec</u> to some or  all  objects  stored  in
              table  <u>Name</u>. The order of the objects is not specified. For a description of match specifications,
              see the ERTS User's Guide.

              A tuple of the results of applying the match specification and a continuation is returned,  unless
              the table is empty, in which case <u>'$end_of_table'</u> is returned. The continuation is to be used when
              matching more objects by calling <u>select/1</u>.

              If  the keypos'th element of <u>MatchSpec</u> is bound, the match specification is applied to all objects
              of the table with the correct key(s). If the keypos'th element of <u>MatchSpec</u> is unbound, the  match
              specification  is  applied  to  all  objects of the table, <u>N</u> objects at a time, until at least one
              object matches or the end of the table is reached. The default, indicated by giving  <u>N</u>  the  value
              <u>default</u>,  is  to let the number of objects vary depending on the sizes of the objects. All objects
              with the same key are always handled at the same time, which implies that the match  specification
              can be applied to more than N objects.

              The  table  is  always  to  be  protected using <u>safe_fixtable/2</u> before calling <u>select/3</u>, otherwise
              errors can occur when calling <u>select/1</u>.

       <b>select_delete(Name,</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>N</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 MatchSpec = match_spec()
                 N = integer() &gt;= 0
                 Reason = term()

              Deletes each object from table <u>Name</u> such that applying match specification <u>MatchSpec</u> to the object
              returns value <u>true</u>. For a description of match specifications, see the ERTS User's Guide.  Returns
              the number of deleted objects.

              If  the keypos'th element of <u>MatchSpec</u> is bound, the match specification is applied to the objects
              with the correct key(s) only.

       <b>slot(Name,</b> <b>I)</b> <b>-&gt;</b> <b>'$end_of_table'</b> <b>|</b> <b>Objects</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 I = integer() &gt;= 0
                 Objects = [object()]
                 Reason = term()

              The objects of a table are distributed among slots, starting with slot <u>0</u> and ending with  slot  <u>n</u>.
              Returns the list of objects associated with slot <u>I</u>. If <u>I</u> &gt; <u>n</u>, <u>'$end_of_table'</u> is returned.

       <b>sync(Name)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Reason = term()

              Ensures  that all updates made to table <u>Name</u> are written to disk. This also applies to tables that
              have been opened with flag <u>ram_file</u> set to <u>true</u>. In this case, the contents of the  RAM  file  are
              flushed to disk.

              Notice that the space management data structures kept in RAM, the buddy system, is also written to
              the disk. This can take some time if the table is fragmented.

       <b>table(Name)</b> <b>-&gt;</b> <b>QueryHandle</b>

       <b>table(Name,</b> <b>Options)</b> <b>-&gt;</b> <b>QueryHandle</b>

              Types:

                 Name = tab_name()
                 Options = Option | [Option]
                 Option = {n_objects, Limit} | {traverse, TraverseMethod}
                 Limit = default | integer() &gt;= 1
                 TraverseMethod = first_next | select | {select, match_spec()}
                 QueryHandle = qlc:query_handle()

              Returns  a  Query  List  Comprehension  (QLC)  query handle. The <u><a href="../man3erl/qlc.3erl.html">qlc</a>(3erl)</u> module provides a query
              language aimed mainly for Mnesia, but ETS tables, Dets tables, and lists are  also  recognized  by
              <u>qlc</u> as sources of data. Calling <u>dets:table/1,2</u> is the means to make Dets table <u>Name</u> usable to <u>qlc</u>.

              When there are only simple restrictions on the key position, <u>qlc</u> uses <u>dets:lookup/2</u> to look up the
              keys. When that is not possible, the whole table is traversed. Option <u>traverse</u> determines how this
              is done:

                * <u>first_next</u> - The table is traversed one key at a time by calling <u>dets:first/1</u> and <u>dets:next/2</u>.

                * <u>select</u>  -  The table is traversed by calling <u>dets:select/3</u> and <u>dets:select/1</u>. Option <u>n_objects</u>
                  determines the number of  objects  returned  (the  third  argument  of  <u>select/3</u>).  The  match
                  specification (the second argument of <u>select/3</u>) is assembled by <u>qlc</u>:

                  * Simple filters are translated into equivalent match specifications.

                  * More  complicated  filters must be applied to all objects returned by <u>select/3</u> given a match
                    specification that matches all objects.

                * <u>{select,</u>  match_spec()<u>}</u> - As for <u>select</u>, the table is traversed by calling  <u>dets:select/3</u>  and
                  <u>dets:select/1</u>. The difference is that the match specification is specified explicitly. This is
                  how  to  state match specifications that cannot easily be expressed within the syntax provided
                  by <u>qlc</u>.

              The following example uses an explicit match specification to traverse the table:

              1&gt; dets:open_file(t, []),
              ok = dets:insert(t, [{1,a},{2,b},{3,c},{4,d}]),
              MS = ets:fun2ms(fun({X,Y}) when (X &gt; 1) or (X &lt; 5) -&gt; {Y} end),
              QH1 = dets:table(t, [{traverse, {select, MS}}]).

              An example with implicit match specification:

              2&gt; QH2 = qlc:q([{Y} || {X,Y} &lt;- dets:table(t), (X &gt; 1) or (X &lt; 5)]).

              The latter example is equivalent to the former, which can be verified using function <u>qlc:info/1</u>:

              3&gt; qlc:info(QH1) =:= qlc:info(QH2).
              true

              <u>qlc:info/1</u> returns information about a  query  handle.  In  this  case  identical  information  is
              returned for the two query handles.

       <b>to_ets(Name,</b> <b>EtsTab)</b> <b>-&gt;</b> <b>EtsTab</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 EtsTab = ets:tab()
                 Reason = term()

              Inserts  the  objects  of  the  Dets  table <u>Name</u> into the ETS table <u>EtsTab</u>. The order in which the
              objects are inserted is not specified. The existing objects of  the  ETS  table  are  kept  unless
              overwritten.

       <b>traverse(Name,</b> <b>Fun)</b> <b>-&gt;</b> <b>Return</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = tab_name()
                 Fun = fun((Object) -&gt; FunReturn)
                 Object = object()
                 FunReturn =
                     continue | {continue, Val} | {done, Value} | OtherValue
                 Return = [term()] | OtherValue
                 Val = Value = OtherValue = Reason = term()

              Applies  <u>Fun</u>  to each object stored in table <u>Name</u> in some unspecified order. Different actions are
              taken depending on the return value of <u>Fun</u>. The following <u>Fun</u> return values are allowed:

                <u>continue</u>:
                  Continue to perform the traversal. For example, the following function can be  used  to  print
                  the contents of a table:

                fun(X) -&gt; io:format("~p~n", [X]), continue end.

                <u>{continue,</u> <u>Val}</u>:
                  Continue  the  traversal and accumulate <u>Val</u>. The following function is supplied to collect all
                  objects of a table in a list:

                fun(X) -&gt; {continue, X} end.

                <u>{done,</u> <u>Value}</u>:
                  Terminate the traversal and return <u>[Value</u> <u>|</u> <u>Acc]</u>.

              Any other value <u>OtherValue</u> returned by <u>Fun</u> terminates the traversal and is returned immediately.

       <b>update_counter(Name,</b> <b>Key,</b> <b>Increment)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Name = tab_name()
                 Key = term()
                 Increment = {Pos, Incr} | Incr
                 Pos = Incr = Result = integer()

              Updates the object with key <u>Key</u> stored in table <u>Name</u> of type <u>set</u> by adding <u>Incr</u> to the element  at
              the  <u>Pos</u>:th  position. The new counter value is returned. If no position is specified, the element
              directly following the key is updated.

              This functions provides a way of updating a counter, without having to look up an  object,  update
              the object by incrementing an element, and insert the resulting object into the table again.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/ets.3erl.html">ets</a>(3erl)</u>, <u><a href="../man3erl/mnesia.3erl.html">mnesia</a>(3erl)</u>, <u><a href="../man3erl/qlc.3erl.html">qlc</a>(3erl)</u>

Ericsson AB                                        stdlib 3.17                                        <u><a href="../man3erl/dets.3erl.html">dets</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>