<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::Class::Storage - Generic Storage Handler</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-class-perl">libdbix-class-perl_0.082844-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::Class::Storage - Generic Storage Handler

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A base implementation of common Storage methods.  For specific information about DBI-based storage, see
       DBIx::Class::Storage::DBI.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       Arguments: $schema

       Instantiates the Storage object.

   <b>set_schema</b>
       Used to reset the schema class or object which owns this storage object, such as during "clone" in
       DBIx::Class::Schema.

   <b>connected</b>
       Returns true if we have an open storage connection, false if it is not (yet) open.

   <b>disconnect</b>
       Closes any open storage connection unconditionally.

   <b>ensure_connected</b>
       Initiate a connection to the storage if one isn't already open.

   <b>throw_exception</b>
       Throws an exception - croaks.

   <b>txn_do</b>
       Arguments: $coderef, @coderef_args?
       Return Value: The return value of $coderef

       Executes  $coderef  with (optional) arguments @coderef_args atomically, returning its result (if any). If
       an exception is caught, a rollback is issued and the exception is rethrown. If the rollback fails,  (i.e.
       throws an exception) an exception is thrown that includes a "Rollback failed" message.

       For example,

         my $author_rs = $schema-&gt;resultset('Author')-&gt;<a href="../man1/find.1.html">find</a>(1);
         my @titles = qw/Night Day It/;

         my $coderef = sub {
           # If any one of these fails, the entire transaction fails
           $author_rs-&gt;create_related('books', {
             title =&gt; $_
           }) foreach (@titles);

           return $author-&gt;books;
         };

         my $rs;
         try {
           $rs = $schema-&gt;txn_do($coderef);
         } catch {
           my $error = shift;
           # Transaction failed
           die "something terrible has happened!"
             if ($error =~ /Rollback failed/);          # Rollback failed

           deal_with_failed_transaction();
         };

       In  a nested transaction (calling <b>txn_do()</b> from within a <b>txn_do()</b> coderef) only the outermost transaction
       will issue a "txn_commit", and <b>txn_do()</b> can be called in void, scalar and list context and it will behave
       as expected.

       Please note that all of the  code  in  your  coderef,  including  non-DBIx::Class  code,  is  part  of  a
       transaction.  This transaction may fail out halfway, or it may get partially double-executed (in the case
       that our DB connection failed halfway through the transaction, in which case we reconnect and restart the
       txn).   Therefore  it  is  best that any side-effects in your coderef are idempotent (that is, can be re-
       executed multiple times and get the same result), and that you check up on your side-effects in the  case
       of transaction failure.

   <b>txn_begin</b>
       Starts a transaction.

       See the preferred "txn_do" method, which allows for an entire code block to be executed transactionally.

   <b>txn_commit</b>
       Issues a commit of the current transaction.

       It does <u>not</u> perform an actual storage commit unless there's a DBIx::Class transaction currently in effect
       (i.e. you called "txn_begin").

   <b>txn_rollback</b>
       Issues    a    rollback    of    the    current   transaction.   A   nested   rollback   will   throw   a
       DBIx::Class::Storage::NESTED_ROLLBACK_EXCEPTION exception, which allows the rollback to propagate to  the
       outermost transaction.

   <b>svp_begin</b>
       Arguments: $savepoint_name?

       Created  a  new savepoint using the name provided as argument. If no name is provided, a random name will
       be used.

   <b>svp_release</b>
       Arguments: $savepoint_name?

       Release the savepoint provided as argument. If none is  provided,  release  the  savepoint  created  most
       recently. This will implicitly release all savepoints created after the one explicitly released as well.

   <b>svp_rollback</b>
       Arguments: $savepoint_name?

       Rollback  to  the  savepoint provided as argument. If none is provided, rollback to the savepoint created
       most recently. This will implicitly release all savepoints created after the savepoint we rollback to.

   <b>txn_scope_guard</b>
       An alternative way of transaction handling based on DBIx::Class::Storage::TxnScopeGuard:

        my $txn_guard = $storage-&gt;txn_scope_guard;

        $result-&gt;col1("val1");
        $result-&gt;update;

        $txn_guard-&gt;commit;

       If an exception occurs, or the guard object otherwise leaves the  scope  before  "$txn_guard-&gt;commit"  is
       called,  the  transaction will be rolled back by an explicit "txn_rollback" call. In essence this is akin
       to using a "txn_begin"/"txn_commit" pair, without having to worry about  calling  "txn_rollback"  at  the
       right  places. Note that since there is no defined code closure, there will be no retries and other magic
       upon database disconnection. If you need such functionality see "txn_do".

   <b>sql_maker</b>
       Returns a "sql_maker" object - normally an object of class "DBIx::Class::SQLMaker".

   <b>debug</b>
       Causes trace information to be emitted on the "debugobj" object.  (or  "STDERR"  if  "debugobj"  has  not
       specifically been set).

       This is the equivalent to setting "DBIC_TRACE" in your shell environment.

   <b>debugfh</b>
       An opportunistic proxy to -&gt;debugobj-&gt;debugfh(@_)

       If the currently set "debugobj" does not have a "debugfh" method, caling this is a no-op.

   <b>debugobj</b>
       Sets   or   retrieves   the   object   used   for   metric   collection.   Defaults  to  an  instance  of
       DBIx::Class::Storage::Statistics that is compatible with the original method of  using  a  coderef  as  a
       callback.  See the aforementioned Statistics class for more information.

   <b>debugcb</b>
       Sets a callback to be executed each time a statement is run; takes a sub reference.  Callback is executed
       as  $sub-&gt;($op,  $info)  where  $op  is  SELECT/INSERT/UPDATE/DELETE  and $info is what would normally be
       printed.

       See "debugobj" for a better way.

   <b>cursor_class</b>
       The cursor class for this Storage object.

   <b>deploy</b>
       Deploy the tables to storage (CREATE TABLE and friends in a SQL-based Storage class). This would normally
       be called through "deploy" in DBIx::Class::Schema.

   <b>connect_info</b>
       The arguments of "connect_info" are always a single array reference, and are Storage-handler specific.

       This is normally accessed via "connection" in DBIx::Class::Schema, which encapsulates its  argument  list
       in an arrayref before calling "connect_info" here.

   <b>select</b>
       Handle a select statement.

   <b>insert</b>
       Handle an insert statement.

   <b>update</b>
       Handle an update statement.

   <b>delete</b>
       Handle a delete statement.

   <b>select_single</b>
       Performs a select, fetch and return of data - handles a single row only.

   <b>columns_info_for</b>
       Returns  metadata  for the given source's columns.  This is *deprecated*, and will be removed before 1.0.
       You should be specifying the metadata yourself if you need it.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
   <b>DBIC_TRACE</b>
       If "DBIC_TRACE" is set then trace information is produced (as when the "debug" method is set).

       If the value is of the form "1=/path/name" then the trace output is written to the file "/path/name".

       This environment variable is checked when the storage object is first created (when you call  connect  on
       your schema).  So, run-time changes to this environment variable will not take effect unless you also re-
       connect on your schema.

   <b>DBIC_TRACE_PROFILE</b>
       If  "DBIC_TRACE_PROFILE"  is  set,  DBIx::Class::Storage::Debug::PrettyTrace  will  be used to format the
       output from "DBIC_TRACE".  The value it is set to is the "profile" that it will be used.  If the value is
       a filename the file is read with Config::Any and the results are used as the configuration  for  tracing.
       See "new" in SQL::Abstract::Tree for what that structure should look like.

   <b>DBIX_CLASS_STORAGE_DBI_DEBUG</b>
       Old name for DBIC_TRACE

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       DBIx::Class::Storage::DBI   -   reference   storage   implementation   using   DBI   and  a  subclass  of
       SQL::Abstract::Classic ( or similar )

</pre><h4><b>FURTHER</b> <b>QUESTIONS?</b></h4><pre>
       Check the list of additional DBIC resources.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This module is free software copyright by the DBIx::Class (DBIC) authors. You can redistribute it  and/or
       modify it under the same terms as the DBIx::Class library.

perl v5.40.0                                       2025-02-01                          <u>DBIx::Class::<a href="../man3pm/Storage.3pm.html">Storage</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>