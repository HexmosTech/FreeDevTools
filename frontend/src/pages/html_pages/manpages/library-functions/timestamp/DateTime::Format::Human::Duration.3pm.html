<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DateTime::Format::Human::Duration - Get a locale specific string describing the span of a given duration</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdatetime-format-human-duration-perl">libdatetime-format-human-duration-perl_0.64-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DateTime::Format::Human::Duration - Get a locale specific string describing the span of a given duration

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use DateTime;
           use DateTime::Format::Human::Duration

           my $span = DateTime::Format::Human::Duration-&gt;new();
           my $dur = $dta - $dtb;
           print $span-&gt;format_duration($dur); # 1 year, 2 months, 3 minutes, and 1 second

           print $span-&gt;format_duration_between($dta, $dtb); # 1 year, 2 months, 3 minutes, and 1 second

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Get a localized string representing the duration.

       For example:

           1 second
           2 minutes and 3 seconds
           3 weeks, 1 day, and 5 seconds
           4 years, 1 month, 2 days, 6 minutes, 1 second, and 345000028 nanoseconds

</pre><h4><b>INTERFACE</b></h4><pre>
   <b>new()</b>
       Create span object, no args

   <b>format_duration()</b>
       First argument is a DateTime::Duration object

       After that you can optionally pass some "standard args" as a hash as described below

   <b>format_duration_between()</b>
       First two args are DateTime objects

       After that you can optionally pass some "standard args" as a hash as described below

   <b>standard</b> <b>args</b>
       1. 'locale'
           locale of the $dt object will be used if you do not specify this

           Valid  values  are  a  string  of  the  locale  (E.g 'fr'), a DateTime object, or a DateTime object's
           'locale' key.

       2. Since we're working with 2 DateTime objects of known points we can have past and future tenses.
           •   past

               String to use if duration is past tense. Can have a sprintf '%s' or  else  is  prepended  with  a
               trailing space.

           •   future

               String  to  use  if duration is future tense. Can have a sprintf '%s' or else is prepended with a
               trailing space.

           •   no_time

               Override the 'no_time' in the locale hash.

           If duration is baseless (IE ambiguous) then 'past' and 'future' is used based  on  if  $dur-&gt;in_units
           has negatives or not.

           Also by nature it's not split into type groups:

           An example is

             DateTime::Duration-&gt;new('seconds'=&gt; 62)

           Will result in '62 seconds' not '1 minute and 2 seconds'

           For more sane results always be specific by using 2 datetime object to get a duration object

               print $dt-&gt;format_duration_between(
                   $dta,
                   $dtb,
                   'past'   =&gt; 'Your account expired %s ago.',
                   'future' =&gt; 'Your account expires in %s.',
                   'no_time'=&gt; 'Your account just expired.',
               );

           This facilitates, for example, this Locale::Maketext vernacular which becomes:

              'Your account [duration,_1,_2,expired %s ago,expires in,just expired].' =&gt; '[Votre compte [duration,_1,_2,a expire il ya,expire dans,vient d'expirer].'

       3. Time Resolution and Units
           •   units

               Specify  units  to format duration with. Arguments will be passed to DateTime::Format's <b>in_unit()</b>
               method.

               Example:

                   my $fmt = DateTime::Format::Human::Duration-&gt;new();
                   my $d = DateTime::Duration-&gt;new(...);

                   my $s = $fmt-&gt;format_duration($d, 'units' =&gt; [qw/years months days/] );
                   # $s == '1 year, 7 months, and 16 days'

               Possible values include: years months weeks days hours minutes seconds nanoseconds

           •   precision

               By default, the duration will be formatted using nanosecond resolution. Resolution can be reduced
               by  passing  'years',  'months',  'weeks',  'days',  'hours',  'minutes',  or  'seconds'  to  the
               'precision' argument.

               Example:

                   my $fmt = DateTime::Format::Human::Duration-&gt;new();
                   my $d = DateTime::Duration-&gt;new(...);

                   print $fmt-&gt;format_duration($d);
                   # '1 year, 7 months, 2 weeks, 2 days, 13 hours, 43 minutes, and 15 seconds'

                   print $fmt-&gt;format_duration($d, 'precision' =&gt; 'days');
                   # '1 year, 7 months, 2 weeks, and 2 days'

           •   significant_units

               By  default, the duration will be formatted using all specified units.  To restrict the number of
               units output, set this to a value of one or more.

               Example:

                   my $fmt = DateTime::Format::Human::Duration-&gt;new();
                   my $d = DateTime::Duration-&gt;new(...);

                   print $fmt-&gt;format_duration($d, 'significant_units' =&gt; 1);
                   # '3 days'
                   print $fmt-&gt;format_duration($d, 'significant_units' =&gt; 2);
                   # '3 days and 10 hours'
                   print $fmt-&gt;format_duration($d, 'significant_units' =&gt; 3);
                   # '3 days, 10 hours, and 27 minutes'

</pre><h4><b>LOCALIZATION</b></h4><pre>
       Localization is provided by the included DateTime::Format::Human::Duration::Locale modules.

       Included                        are                        DateTime::Format::Human::Duration::Locale::es,
       DateTime::Format::Human::Duration::Locale::fr,             DateTime::Format::Human::Duration::Locale::pt,
       DateTime::Format::Human::Duration::Locale::de, DateTime::Format::Human::Duration::Locale::it

       More will be included as time permits/folks volunteer/CLDR becomes an option

       They are setup this way:

       DateTime::Format::Human::Duration::Locale::XYZ where 'XYZ' is the ISO code of DateTime::Locale

       It can have one of 2 functions:

       <b>get_human_span_hashref()</b>
           Takes no arguments, should return a hashref of this structure:

               sub get_human_span_hashref {
                   return {
                       'no_oxford_comma' =&gt; 1,
                       'no_time' =&gt; 'pas le temps',
                       'and'     =&gt; 'et',
                       'year'  =&gt; 'an',
                       'years' =&gt; 'ans',
                       'month'  =&gt; 'mois',
                       'months' =&gt; 'mois',
                       'week'  =&gt; 'semaine',
                       'weeks' =&gt; 'semaines',
                       'day'  =&gt; 'jour',
                       'days' =&gt; 'jours',
                       'hour'  =&gt; 'heure',
                       'hours' =&gt; 'heures',
                       'minute'  =&gt; 'minute',
                       'minutes' =&gt; 'minutes',
                       'second'  =&gt; 'seconde',
                       'seconds' =&gt; 'seconds',
                       'nanosecond'  =&gt; 'nanoseconde',
                       'nanoseconds' =&gt; 'nanosecondes',
                   };
               }

       <b>get_human_span_from_units()</b>
           Try to use "<b>get_human_span_hashref()</b>" if the locale allows for it since  it's  much  easier.  If  you
           cannot, however, then this will give you the maximum level of configurability.

           This  function receives a hashref of duration values, and a hashref of the "standard args". It should
           return the localized string.

               sub get_human_span_from_units {
                   my ($duration_values_hr, $args_hr) = @_;
                   ...;
                   return $string; # 1 year, 2days, 4 hours, and 17 minutes
               }

           Please see the example in "t/lib/DateTime/Format/Human/Duration/Locale/nb.pm".

</pre><h4><b>LOCALIZATION</b> <b>of</b> <b>DateTime::Format</b> <b>modules</b></h4><pre>
       DateTime does an excellent job at implementing localization. Often DateTime::Format based class's  either
       don't support localization or they implement it haphazardly and inconsistently.

       With this module I hope to model a localization scheme that is inline with DateTime and is consistent and
       reuseable between &lt;DateTime::Format&gt; based classes.

       The idea is to determine the locale to use based on a DateTime object.

       XYZ::Locale  should  handle  looking up (and caching if appropriate) the locale and loading the necessary
       locale module XYZ::Locale::fr

       The specific locale module holds the data and possibly logic  necessary  to  do  what  XYZ  does  in  the
       vernacular of the given locale.

   <b>TODO</b>
       Eventually  the generic logic will be re-broken out into its own module for re-use by your class and I'll
       have more detailed POD about how to do it.

       In the meantime if you're interested please contact me and I'd be happy to  help  and/or  expediate  this
       TODO.

       Also,  Dave  Rolksy  has  mentioned  to  me  that  this  sort  of  locale  data  might be appropriate for
       DateTime::Locale directly from CLDR. If that happens this module will be changed to use that if possible.

</pre><h4><b>FAQ</b></h4><pre>
   <b>Why</b> <b>would</b> <b>I</b> <b>want</b> <b>to</b> <b>use</b> <b>this?</b>
       So you can localize your application's output of time periods without having to do a lot  of  logic  each
       time you wanted to say it.

       Locale::Maketext::Utils  has/will  have a <b>duration()</b> bracket notation method which prompted this module's
       existence

       <b>duration()</b> was prompted by its <b>datetime()</b> brother, all of which uses the most excellent DateTime project!

   <b>Why</b> <b>did</b> <b>my</b> <b>duration</b> <b>say</b> <b>'62</b> <b>seconds'</b> <b>instead</b> <b>of</b> <b>'1</b> <b>minute</b> <b>and</b> <b>2</b> <b>seconds'</b>
       Because you used an ambiguous duration (one without a base) so there is no way to  apply  date  math  and
       accurately  represent  the  number  of  each  given  item  in  that duration since it may or may not span
       leap-[second, days, years, etc..]

       In other words do this (so that your duration can be specifically calculated):

           $dtb = $dta-&gt;clone-&gt;add('seconds'=&gt; 62);
           my $duration = $dta - $dtb; # has a base, its not ambiguous
           print $span-&gt;format_duration($duration); # 1 minutes and 2 seconds

       not this:

           my $duration = DateTime::Duration-&gt;new('seconds'=&gt; 62); # no base, it is ambiguous
           print $span-&gt;format_duration($duration); # 62 seconds

       Note "format_duration_between"(), does not suffer from this since we're using a specific DateTime  object
       already.

           print $span-&gt;format_duration_between( $dt, $dt-&gt;clone()-&gt;add('seconds'=&gt; 62) ); # 1 minute and 2 seconds

   <b>Why</b> <b>do</b> <b>you</b> <b>put</b> <b>a</b> <b>comma</b> <b>before</b> <b>the</b> <b>'and'</b> <b>in</b> <b>a</b> <b>group</b> <b>of</b> <b>more</b> <b>than</b> <b>2</b> <b>items?</b>
       We want to use the so-called Oxford comma to avoid ambiguity.

   <b>My</b> <b>DateTime::Format::Human::Duration::Locale::XX</b> <b>still</b> <b>outputs</b> <b>in</b> <b>English!</b>
       That  is  because  it defined neither the "<b>get_human_span_hashref()</b>" or the "<b>get_human_span_from_units()</b>"
       functions

       It must define one of them or defaults are used.

   <b>Why</b> <b>didn't</b> <b>you</b> <b>just</b> <b>use</b> <b>'DateTime::Format::Duration'</b>
       Essencially DateTime::Format::Duration is an object representing a single <b>strftime()</b> type string to apply
       to any given duration. This is not flexible enough for the intent of this module.

       DateTime::Format::Duration  is  not  a   bad   module   its   just   for   a   different   purpose   than
       DateTime::Format::Human::Duration

       •   It was not localizable

           You  either  got  '2  days'  or '1 days' which a) forces it to be in English and b) doesn't even make
           sense in English.

           You could get around that by adding logic each time you wanted to call it but that is just messy.

       •   Had to keep an item even if it was zero

           If 'days' was in there you got '0 days', we only want items with a value to show.

           That'd also require a lot of logic each time you wanted to call which is again messy.

       •   This module has no need for reparsing output back into an object

           Since the datetime info for 2 points in time are generally in a form easily rendered into a  DateTime
           object  it'd  be  silly  to  even  attempt  to store and parse the output of this module back into an
           object.

           Plus since it all depends on the locale it is in it'd be difficult.

       The purpose of DateTime::Format::Human::Duration was to generate a localized human  language  description
       of a duration without the caller needing to supply any logic.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Throws no warnings or errors of its own

</pre><h4><b>CONFIGURATION</b> <b>AND</b> <b>ENVIRONMENT</b></h4><pre>
       DateTime::Format::Human::Duration requires no configuration files or environment variables.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       None.

</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
       None reported.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       No bugs have been reported.

       Please  report any bugs or feature requests to "<a href="mailto:bug-datetime-format-span@rt.cpan.org">bug-datetime-format-span@rt.cpan.org</a>", or through the web
       interface at &lt;<a href="http://rt.cpan.org">http://rt.cpan.org</a>&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       Daniel Muey  "&lt;<a href="http://drmuey.com/cpan_contact.pl">http://drmuey.com/cpan_contact.pl</a>&gt;"

</pre><h4><b>LICENCE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2008, Daniel Muey "&lt;<a href="http://drmuey.com/cpan_contact.pl">http://drmuey.com/cpan_contact.pl</a>&gt;". All rights reserved.

       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself. See perlartistic.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       BECAUSE  THIS  SOFTWARE  IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE, TO THE EXTENT
       PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS  AND/OR  OTHER
       PARTIES  PROVIDE  THE  SOFTWARE  "AS  IS"  WITHOUT  WARRANTY  OF  ANY  KIND, EITHER EXPRESSED OR IMPLIED,
       INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS  FOR  A  PARTICULAR
       PURPOSE.  THE  ENTIRE  RISK  AS  TO  THE  QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE
       SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

       IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER,  OR  ANY
       OTHER  PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
       TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING  OUT  OF
       THE  USE  OR  INABILITY  TO  USE  THE  SOFTWARE  (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
       RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE  TO  OPERATE
       WITH  ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
       DAMAGES.

perl v5.34.0                                       2022-06-13             <u>DateTime::Format::Human::<a href="../man3pm/Duration.3pm.html">Duration</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>