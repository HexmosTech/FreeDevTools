<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DateTime::Format::Flexible - DateTime::Format::Flexible - Flexibly parse strings and turn them into</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdatetime-format-flexible-perl">libdatetime-format-flexible-perl_0.37-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DateTime::Format::Flexible - DateTime::Format::Flexible - Flexibly parse strings and turn them into
       DateTime objects.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use DateTime::Format::Flexible;
         my $dt = DateTime::Format::Flexible-&gt;parse_datetime(
             'January 8, 1999'
         );
         # $dt = a DateTime object set at 1999-01-08T00:00:00

</pre><h4><b>DESCRIPTION</b></h4><pre>
       If you have ever had to use a program that made you type in the date a certain way and thought "Why can't
       the computer just figure out what date I wanted?", this module is for you.

       <u>DateTime::Format::Flexible</u> attempts to take any string you give it and parse it into a DateTime object.

</pre><h4><b>USAGE</b></h4><pre>
       This module uses <u>DateTime::Format::Builder</u> under the covers.

   <b>parse_datetime</b>
       Give it a string and it attempts to parse it and return a DateTime object.

       If it cannot it will throw an exception.

        my $dt = DateTime::Format::Flexible-&gt;parse_datetime( $date );

        my $dt = DateTime::Format::Flexible-&gt;parse_datetime(
            $date,
            strip    =&gt; [qr{\.\z}],                  # optional, remove a trailing period
            tz_map   =&gt; {EDT =&gt; 'America/New_York'}, # optional, map the EDT timezone to America/New_York
            lang     =&gt; ['es'],                      # optional, only parse using spanish
            european =&gt; 1,                           # optional, catch some cases of DD-MM-YY
        );

       •   "base" (optional)

           Does  the  same  thing  as the method "base".  Sets a base datetime for incomplete dates.  Requires a
           valid DateTime object as an argument.

           example:

            my $base_dt = DateTime-&gt;new( year =&gt; 2005, month =&gt; 2, day =&gt; 1 );
            my $dt = DateTime::Format::Flexible-&gt;parse_datetime(
               '18 Mar',
                base =&gt; $base_dt,
            );
            # $dt is now 2005-03-18T00:00:00

       •   "strip" (optional)

           Remove a substring from the string you are trying to parse.  You can  pass  multiple  regexes  in  an
           arrayref.

           example:

            my $dt = DateTime::Format::Flexible-&gt;parse_datetime(
                '2011-04-26 00:00:00 (registry time)',
                strip =&gt; [qr{\(registry time\)\z}],
            );
            # $dt is now 2011-04-26T00:00:00

           This  is  helpful  if  you  have  a  load  of  dates you want to normalize and you know of some weird
           formatting beforehand.

       •   "tz_map" (optional)

           Map a given timezone to another recognized timezone Values are given as a hashref.

           example:

            my $dt = DateTime::Format::Flexible-&gt;parse_datetime(
                '25-Jun-2009 EDT',
                tz_map =&gt; {EDT =&gt; 'America/New_York'},
            );
            # $dt is now 2009-06-25T00:00:00 with a timezone of America/New_York

           This is helpful if you have a  load  of  dates  that  have  timezones  that  are  not  recognized  by
           <u>DateTime::Timezone</u>.

       •   "lang" (optional)

           Specify the language map plugins to use.

           When  DateTime::Format::Flexible  parses  a  date  with  a  string in it, it will search for a way to
           convert that string to a number.  By default it will search  through  all  the  language  plugins  to
           search for a match.

           NOTE: as of 0.22, it will only do this search if it detects a string in the given date.

           Setting "lang" this lets you limit the scope of the search.

           example:

            my $dt = DateTime::Format::Flexible-&gt;parse_datetime(
                'Wed, Jun 10, 2009',
                lang =&gt; ['en'],
            );
            # $dt is now 2009-06-10T00:00:00

           Currently  supported  languages  are  english  (en),  spanish  (es)  and  german (de). Contributions,
           corrections, requests and examples are VERY welcome.

           See    the    <u>DateTime::Format::Flexible::lang::en</u>,     <u>DateTime::Format::Flexible::lang::es</u>,     and
           <u>DateTime::Format::Flexible::lang::de</u> for examples of the plugins.

       •   "european" (optional)

           If  european is set to a true value, an attempt will be made to parse as a DD-MM-YYYY date instead of
           the default MM-DD-YYYY.  There is a chance that this will not do the right thing due to ambiguity.

           example:

            my $dt = DateTime::Format::Flexible-&gt;parse_datetime(
                '16/06/2010' , european =&gt; 1,
            );
            # $dt is now 2010-06-16T00:00:00

       •   "MMYY" (optional)

           By default, this module will parse 12/10 as December 10th of the current year (MM/DD).

           If you want it to parse this as MM/YY instead, you can enable the "MMYY" option.

           example:

            my $dt = DateTime::Format::Flexible-&gt;parse_datetime('12/10');
            # $dt is now [current year]-12-10T00:00:00

            my $dt = DateTime::Format::Flexible-&gt;parse_datetime(
                '12/10', MMYY =&gt; 1,
            );
            # $dt is now 2010-12-01T00:00:00

           This is useful if you know you are going to be parsing a credit card expiration date.

   <b>base</b>
       gets/sets the base DateTime for incomplete dates.  Requires a valid DateTime object as an  argument  when
       setting.  This defaults to DateTime-&gt;now.

       example:

        DateTime::Format::Flexible-&gt;base( DateTime-&gt;new(
            year =&gt; 2009, month =&gt; 6, day =&gt; 22
        ));
        my $dt = DateTime::Format::Flexible-&gt;parse_datetime( '23:59' );
        # $dt is now 2009-06-22T23:59:00

   <b>build</b>
       an alias for parse_datetime

   <b>Example</b> <b>formats</b>
       A small list of supported formats:

       YYYYMMDDTHHMMSS
       YYYYMMDDTHHMM
       YYYYMMDDTHH
       YYYYMMDD
       YYYYMM
       MM-DD-YYYY
       MM-D-YYYY
       MM-DD-YY
       M-DD-YY
       YYYY/DD/MM
       YYYY/M/DD
       YYYY/MM/D
       M-D
       MM-D
       M-D-Y
       Month D, YYYY
       Mon D, YYYY
       Mon D, YYYY HH:MM:SS
       ... thousands more

       there are 9000+ variations that are detected correctly in the test files (see t/data/* for most of them).
       If you can think of any that I do not cover, please let me know.

</pre><h4><b>NOTES</b></h4><pre>
       As  of  version 0.11 you will get a DateTime::Infinite::Future object if the passed in date is 'infinity'
       and a DateTime::Infinite::Past object if the passed in date is '-infinity'.  If you are  expecting  these
       types of strings, you might want to check for '<b>is_infinite()</b>' from the object returned.

       example:

        my $dt = DateTime::Format::Flexible-&gt;parse_datetime( 'infinity' );
        if ( $dt-&gt;is_infinite )
        {
             # you have a Infinite object.
        }

</pre><h4><b>BUGS/LIMITATIONS</b></h4><pre>
       You cannot use a 1 or 2 digit year as the first field unless the year is &gt; 31:

        YY-MM-DD # not supported if YY is &lt;= 31
        Y-MM-DD  # not supported

       It gets confused with MM-DD-YY

</pre><h4><b>AUTHOR</b></h4><pre>
       Tom Heady &lt;<a href="mailto:cpan@punch.net">cpan@punch.net</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2007-2018 Tom Heady.

       This program is free software; you can redistribute it and/or modify it under the terms of either:

       •   the GNU General Public License as published by the Free
               Software Foundation; either version 1, or (at your option) any
               later version, or

       •   the Artistic License.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>DateTime::Format::Builder</u>, <u>DateTime::Timezone</u>, <u>DateTime::Format::Natural</u>

perl v5.40.0                                       2025-01-11                    <u>DateTime::Format::<a href="../man3pm/Flexible.3pm.html">Flexible</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>