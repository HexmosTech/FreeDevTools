<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::Class::InflateColumn::DateTime - Auto-create DateTime objects from date and datetime columns.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-class-perl">libdbix-class-perl_0.082844-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::Class::InflateColumn::DateTime - Auto-create DateTime objects from date and datetime columns.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Load this component and then declare one or more columns to be of the datetime, timestamp or date
       datatype.

         package Event;
         use base 'DBIx::Class::Core';

         __PACKAGE__-&gt;load_components(qw/InflateColumn::DateTime/);
         __PACKAGE__-&gt;add_columns(
           starts_when =&gt; { data_type =&gt; 'datetime' }
           create_date =&gt; { data_type =&gt; 'date' }
         );

       Then you can treat the specified column as a DateTime object.

         print "This event starts the month of ".
           $event-&gt;starts_when-&gt;month_name();

       If you want to set a specific timezone and locale for that field, use:

         __PACKAGE__-&gt;add_columns(
           starts_when =&gt; { data_type =&gt; 'datetime', timezone =&gt; "America/Chicago", locale =&gt; "de_DE" }
         );

       If you want to inflate no matter what data_type your column is, use inflate_datetime or inflate_date:

         __PACKAGE__-&gt;add_columns(
           starts_when =&gt; { data_type =&gt; 'varchar', inflate_datetime =&gt; 1 }
         );

         __PACKAGE__-&gt;add_columns(
           starts_when =&gt; { data_type =&gt; 'varchar', inflate_date =&gt; 1 }
         );

       It's also possible to explicitly skip inflation:

         __PACKAGE__-&gt;add_columns(
           starts_when =&gt; { data_type =&gt; 'datetime', inflate_datetime =&gt; 0 }
         );

       NOTE: Don't rely on "InflateColumn::DateTime" to parse date strings for you.  The column is set directly
       for any non-references and "InflateColumn::DateTime" is completely bypassed.  Instead, use an input
       parser to create a DateTime object. For instance, if your user input comes as a 'YYYY-MM-DD' string, you
       can use "DateTime::Format::ISO8601" thusly:

         use DateTime::Format::ISO8601;
         my $dt = DateTime::Format::ISO8601-&gt;parse_datetime('YYYY-MM-DD');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module figures out the type of DateTime::Format::* class to inflate/deflate with based on the type
       of DBIx::Class::Storage::DBI::* that you are using.  If you switch from one database to a different one
       your code should continue to work without modification (though note that this feature is new as of 0.07,
       so it may not be perfect yet - bug reports to the list very much welcome).

       If the data_type of a field is "date", "datetime" or "timestamp" (or a derivative of these datatypes,
       e.g. "timestamp with timezone"), this module will automatically call the appropriate parse/format method
       for deflation/inflation as defined in the storage class. For instance, for a "datetime" field the methods
       "parse_datetime" and "format_datetime" would be called on deflation/inflation. If the storage class does
       not provide a specialized inflator/deflator, "[parse|format]_datetime" will be used as a fallback. See
       "Formatters And Stringification" in DateTime for more information on date formatting.

       For more help with using components, see "USING" in DBIx::Class::Manual::Component.

   <b>register_column</b>
       Chains with the "register_column" in DBIx::Class::Row method, and sets up datetime columns appropriately.
       This would not normally be directly called by end users.

       In the case of an invalid date, DateTime will throw an exception.  To bypass these exceptions and just
       have the inflation return undef, use the "datetime_undef_if_invalid" option in the column info:

           "broken_date",
           {
               data_type =&gt; "datetime",
               default_value =&gt; '0000-00-00',
               is_nullable =&gt; 1,
               datetime_undef_if_invalid =&gt; 1
           }

</pre><h4><b>USAGE</b> <b>NOTES</b></h4><pre>
       If you have a datetime column with an associated "timezone", and subsequently create/update this column
       with a DateTime object in the DateTime::TimeZone::Floating timezone, you will get a warning (as there is
       a very good chance this will not have the result you expect). For example:

         __PACKAGE__-&gt;add_columns(
           starts_when =&gt; { data_type =&gt; 'datetime', timezone =&gt; "America/Chicago" }
         );

         my $event = $schema-&gt;resultset('EventTZ')-&gt;create({
           starts_at =&gt; DateTime-&gt;new(year=&gt;2007, month=&gt;12, day=&gt;31, ),
         });

       The warning can be avoided in several ways:

       Fix your broken code
           When  calling  "set_time_zone"  on  a  Floating  DateTime  object,  the timezone is simply set to the
           requested value, and <b>no</b> <b>time</b> <b>conversion</b> <b>takes</b> <b>place</b>. It is always a good idea to be  supply  explicit
           times to the database:

             my $event = $schema-&gt;resultset('EventTZ')-&gt;create({
               starts_at =&gt; DateTime-&gt;new(year=&gt;2007, month=&gt;12, day=&gt;31, time_zone =&gt; "America/Chicago" ),
             });

       Suppress the check on per-column basis
             __PACKAGE__-&gt;add_columns(
               starts_when =&gt; { data_type =&gt; 'datetime', timezone =&gt; "America/Chicago", floating_tz_ok =&gt; 1 }
             );

       Suppress the check globally
           Set the environment variable DBIC_FLOATING_TZ_OK to some true value.

       Putting  extra  attributes  like  timezone, locale or floating_tz_ok into extra =&gt; {} has been <b>DEPRECATED</b>
       because this gets you into trouble using DBIx::Class::Schema::Versioned.  Instead put  it  directly  into
       the  columns  definition  like in the examples above. If you still use the old way you'll see a warning -
       please fix your code then!

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       More information about the add_columns method, and column metadata, can be found in the documentation for
       DBIx::Class::ResultSource.
       Further discussion of problems inherent to the Floating timezone: Floating DateTimes and
       $dt-&gt;set_time_zone

</pre><h4><b>FURTHER</b> <b>QUESTIONS?</b></h4><pre>
       Check the list of additional DBIC resources.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This module is free software copyright by the DBIx::Class (DBIC) authors. You can redistribute it  and/or
       modify it under the same terms as the DBIx::Class library.

perl v5.40.0                                       2025-02-01             <u>DBIx::Class::In...olumn::<a href="../man3pm/DateTime.3pm.html">DateTime</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>