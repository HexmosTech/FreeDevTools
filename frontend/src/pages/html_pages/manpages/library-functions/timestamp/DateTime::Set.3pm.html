<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DateTime::Set - Datetime sets and set math</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdatetime-set-perl">libdatetime-set-perl_0.3900-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DateTime::Set - Datetime sets and set math

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use DateTime;
           use DateTime::Set;

           $date1 = DateTime-&gt;new( year =&gt; 2002, month =&gt; 3, day =&gt; 11 );
           $set1 = DateTime::Set-&gt;from_datetimes( dates =&gt; [ $date1 ] );
           #  set1 = 2002-03-11

           $date2 = DateTime-&gt;new( year =&gt; 2003, month =&gt; 4, day =&gt; 12 );
           $set2 = DateTime::Set-&gt;from_datetimes( dates =&gt; [ $date1, $date2 ] );
           #  set2 = 2002-03-11, and 2003-04-12

           $date3 = DateTime-&gt;new( year =&gt; 2003, month =&gt; 4, day =&gt; 1 );
           print $set2-&gt;next( $date3 )-&gt;ymd;      # 2003-04-12
           print $set2-&gt;previous( $date3 )-&gt;ymd;  # 2002-03-11
           print $set2-&gt;current( $date3 )-&gt;ymd;   # 2002-03-11
           print $set2-&gt;closest( $date3 )-&gt;ymd;   # 2003-04-12

           # a 'monthly' recurrence:
           $set = DateTime::Set-&gt;from_recurrence(
               recurrence =&gt; sub {
                   return $_[0] if $_[0]-&gt;is_infinite;
                   return $_[0]-&gt;truncate( to =&gt; 'month' )-&gt;add( months =&gt; 1 )
               },
               span =&gt; $date_span1,    # optional span
           );

           $set = $set1-&gt;union( $set2 );         # like "OR", "insert", "both"
           $set = $set1-&gt;complement( $set2 );    # like "delete", "remove"
           $set = $set1-&gt;intersection( $set2 );  # like "AND", "while"
           $set = $set1-&gt;complement;             # like "NOT", "negate", "invert"

           if ( $set1-&gt;intersects( $set2 ) ) { ...  # like "touches", "interferes"
           if ( $set1-&gt;contains( $set2 ) ) { ...    # like "is-fully-inside"

           # data extraction
           $date = $set1-&gt;min;           # first date of the set
           $date = $set1-&gt;max;           # last date of the set

           $iter = $set1-&gt;iterator;
           while ( $dt = $iter-&gt;next ) {
               print $dt-&gt;ymd;
           };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       DateTime::Set is a module for datetime sets.  It can be used to handle two different types of sets.

       The first is a fixed set of predefined datetime objects.  For example, if we wanted to create a set of
       datetimes containing the birthdays of people in our family for the current year.

       The second type of set that it can handle is one based on a recurrence, such as "every Wednesday", or
       "noon on the 15th day of every month".  This type of set can have fixed starting and ending datetimes,
       but neither is required.  So our "every Wednesday set" could be "every Wednesday from the beginning of
       time until the end of time", or "every Wednesday after 2003-03-05 until the end of time", or "every
       Wednesday between 2003-03-05 and 2004-01-07".

       This module also supports set math operations, so you do things like create a new set from the union or
       difference of two sets, check whether a datetime is a member of a given set, etc.

       This is different from a "DateTime::Span", which handles a continuous range as opposed to individual
       datetime points. There is also a module "DateTime::SpanSet" to handle sets of spans.

</pre><h4><b>METHODS</b></h4><pre>
       •   from_datetimes

           Creates a new set from a list of datetimes.

              $dates = DateTime::Set-&gt;from_datetimes( dates =&gt; [ $dt1, $dt2, $dt3 ] );

           The datetimes can be objects from class "DateTime", or from a "DateTime::Calendar::*" class.

           "DateTime::Infinite::*" objects are not valid set members.

       •   from_recurrence

           Creates a new set specified via a "recurrence" callback.

               $months = DateTime::Set-&gt;from_recurrence(
                   span =&gt; $dt_span_this_year,    # optional span
                   recurrence =&gt; sub {
                       return $_[0]-&gt;truncate( to =&gt; 'month' )-&gt;add( months =&gt; 1 )
                   },
               );

           The "span" parameter is optional. It must be a "DateTime::Span" object.

           The  span  can  also  be specified using "start" / "after" and "end" / "before" parameters, as in the
           "DateTime::Span" constructor.  In this case, if there is a "span" parameter it will be ignored.

               $months = DateTime::Set-&gt;from_recurrence(
                   after =&gt; $dt_now,
                   recurrence =&gt; sub {
                       return $_[0]-&gt;truncate( to =&gt; 'month' )-&gt;add( months =&gt; 1 );
                   },
               );

           The recurrence function will be passed a single parameter, a datetime object. The parameter can be an
           object from class "DateTime", or from one of the "DateTime::Calendar::*" classes.  The parameter  can
           also be a "DateTime::Infinite::Future" or a "DateTime::Infinite::Past" object.

           The  recurrence  must  return the <u>next</u> event after that object.  There is no guarantee as to what the
           returned object will be set to, only  that  it  will  be  greater  than  the  object  passed  to  the
           recurrence.

           If  there are no more datetimes after the given parameter, then the recurrence function should return
           "DateTime::Infinite::Future".

           It is ok to modify the parameter $_[0] inside the recurrence function.  There are no side-effects.

           For example, if you wanted a recurrence that generated datetimes in  increments  of  30  seconds,  it
           would look like this:

             sub every_30_seconds {
                 my $dt = shift;
                 if ( $dt-&gt;second &lt; 30 ) {
                     return $dt-&gt;truncate( to =&gt; 'minute' )-&gt;add( seconds =&gt; 30 );
                 } else {
                     return $dt-&gt;truncate( to =&gt; 'minute' )-&gt;add( minutes =&gt; 1 );
                 }
             }

           Note  that  this  recurrence  takes  leap  seconds into account.  Consider using "truncate()" in this
           manner to avoid complicated arithmetic problems!

           It is also possible to create a recurrence by specifying either or  both  of  'next'  and  'previous'
           callbacks.

           The  callbacks  can  return  "DateTime::Infinite::Future"  and "DateTime::Infinite::Past" objects, in
           order to define <u>bounded</u> <u>recurrences</u>.  In this case, both 'next'  and  'previous'  callbacks  must  be
           defined:

               # "monthly from $dt until forever"

               my $months = DateTime::Set-&gt;from_recurrence(
                   next =&gt; sub {
                       return $dt if $_[0] &lt; $dt;
                       $_[0]-&gt;truncate( to =&gt; 'month' );
                       $_[0]-&gt;add( months =&gt; 1 );
                       return $_[0];
                   },
                   previous =&gt; sub {
                       my $param = $_[0]-&gt;clone;
                       $_[0]-&gt;truncate( to =&gt; 'month' );
                       $_[0]-&gt;subtract( months =&gt; 1 ) if $_[0] == $param;
                       return $_[0] if $_[0] &gt;= $dt;
                       return DateTime::Infinite::Past-&gt;new;
                   },
               );

           Bounded recurrences are easier to write using "span" parameters. See above.

           See  also  "DateTime::Event::Recurrence"  and  the  other  "DateTime::Event::*"  factory  modules for
           generating specialized recurrences, such as sunrise and sunset times, and holidays.

       •   empty_set

           Creates a new empty set.

               $set = DateTime::Set-&gt;empty_set;
               print "empty set" unless defined $set-&gt;max;

       •   is_empty_set

           Returns true is the set is empty; false otherwise.

               print "nothing" if $set-&gt;is_empty_set;

       •   clone

           This object method returns a replica of the given object.

           "clone" is useful if you want to apply a transformation to a set, but you want to keep  the  previous
           value:

               $set2 = $set1-&gt;clone;
               $set2-&gt;add_duration( year =&gt; 1 );  # $set1 is unaltered

       •   add_duration( $duration )

           This method adds the specified duration to every element of the set.

               $dt_dur = new DateTime::Duration( year =&gt; 1 );
               $set-&gt;add_duration( $dt_dur );

           The original set is modified. If you want to keep the old values use:

               $new_set = $set-&gt;clone-&gt;add_duration( $dt_dur );

       •   add

           This method is syntactic sugar around the "add_duration()" method.

               $meetings_2004 = $meetings_2003-&gt;clone-&gt;add( years =&gt; 1 );

       •   subtract_duration( $duration_object )

           When  given  a  "DateTime::Duration"  object,  this method simply calls "invert()" on that object and
           passes that new duration to the "add_duration" method.

       •   subtract( DateTime::Duration-&gt;new parameters )

           Like "add()", this is syntactic sugar for the "subtract_duration()" method.

       •   set_time_zone( $tz )

           This method will attempt to apply the "set_time_zone" method to every datetime in the set.

       •   set( locale =&gt; .. )

           This method can be used to change the "locale" of a datetime set.

       •   start, min

       •   end, max

           The first and last "DateTime" in the set.

           These methods may return "undef" if the set is empty.

           It  is  also   possible   that   these   methods   may   return   a   "DateTime::Infinite::Past"   or
           "DateTime::Infinite::Future" object.

           These  methods return just a <u>copy</u> of the actual value.  If you modify the result, the set will not be
           modified.

       •   span

           Returns the total span of the set, as a "DateTime::Span" object.

       •   iterator / next / previous

           These methods can be used to iterate over the datetimes in a set.

               $iter = $set1-&gt;iterator;
               while ( $dt = $iter-&gt;next ) {
                   print $dt-&gt;ymd;
               }

               # iterate backwards
               $iter = $set1-&gt;iterator;
               while ( $dt = $iter-&gt;previous ) {
                   print $dt-&gt;ymd;
               }

           The boundaries of the iterator can be limited by passing it a "span" parameter.   This  should  be  a
           "DateTime::Span"  object which delimits the iterator's boundaries.  Optionally, instead of passing an
           object, you can pass any  parameters  that  would  work  for  one  of  the  "DateTime::Span"  class's
           constructors, and an object will be created for you.

           Obviously,  if  the  span you specify is not restricted both at the start and end, then your iterator
           may iterate forever, depending on the nature of your set.  User beware!

           The "next()" or "previous()" method will return "undef" when there  are  no  more  datetimes  in  the
           iterator.

       •   as_list

           Returns  the set elements as a list of "DateTime" objects.  Just as with the "iterator()" method, the
           "as_list()" method can be limited by a span.

             my @dt = $set-&gt;as_list( span =&gt; $span );

           Applying "as_list()" to a large recurrence set is a very expensive operation, both in CPU time and in
           the memory used.  If you <u>really</u> need to extract elements from a large set, you can limit the set with
           a shorter span:

               my @short_list = $large_set-&gt;as_list( span =&gt; $short_span );

           For <u>infinite</u> sets, "as_list()" will return "undef".  Please note that this is explicitly not an empty
           list, since an empty list is a valid return value for empty sets!

       •   count

           Returns a count of "DateTime" objects in  the  set.   Just  as  with  the  "iterator()"  method,  the
           "count()" method can be limited by a span.

             defined( my $n = $set-&gt;count) or die "can't count";

             my $n = $set-&gt;count( span =&gt; $span );
             die "can't count" unless defined $n;

           Applying  "count()"  to a large recurrence set is a very expensive operation, both in CPU time and in
           the memory used.  If you <u>really</u> need to count elements from a large set, you can limit the set with a
           shorter span:

               my $count = $large_set-&gt;count( span =&gt; $short_span );

           For <u>infinite</u> sets, "count()" will return "undef".  Please note that this is explicitly not  a  scalar
           zero, since a zero count is a valid return value for empty sets!

       •   union

       •   intersection

       •   complement

           These set operation methods can accept a "DateTime" list, a "DateTime::Set", a "DateTime::Span", or a
           "DateTime::SpanSet" object as an argument.

               $set = $set1-&gt;union( $set2 );         # like "OR", "insert", "both"
               $set = $set1-&gt;complement( $set2 );    # like "delete", "remove"
               $set = $set1-&gt;intersection( $set2 );  # like "AND", "while"
               $set = $set1-&gt;complement;             # like "NOT", "negate", "invert"

           The  "union"  of  a "DateTime::Set" with a "DateTime::Span" or a "DateTime::SpanSet" object returns a
           "DateTime::SpanSet" object.

           If "complement" is called without any arguments, then the  result  is  a  "DateTime::SpanSet"  object
           representing  the spans between each of the set's elements.  If complement is given an argument, then
           the return value is a "DateTime::Set" object representing the <u>set</u> <u>difference</u> between the sets.

           All other operations will always return a "DateTime::Set".

       •   intersects

       •   contains

           These set operations result in a boolean value.

               if ( $set1-&gt;intersects( $set2 ) ) { ...  # like "touches", "interferes"
               if ( $set1-&gt;contains( $dt ) ) { ...    # like "is-fully-inside"

           These  methods  can  accept  a  "DateTime"  list,  a  "DateTime::Set",  a  "DateTime::Span",   or   a
           "DateTime::SpanSet" object as an argument.

           <b>intersects()</b>  returns  1  for true, and 0 for false. In a few cases the algorithm can't decide if the
           sets intersect at all, and <b>intersects()</b> will return "undef".

       •   previous

       •   next

       •   current

       •   closest

             my $dt = $set-&gt;next( $dt );
             my $dt = $set-&gt;previous( $dt );
             my $dt = $set-&gt;current( $dt );
             my $dt = $set-&gt;closest( $dt );

           These methods are used to find a set member relative to a given datetime.

           The "current()" method returns $dt if $dt is an event, otherwise it returns the previous event.

           The "closest()" method returns $dt if $dt is  an  event,  otherwise  it  returns  the  closest  event
           (previous or next).

           All of these methods may return "undef" if there is no matching datetime in the set.

           These  methods  will  try to set the returned value to the same time zone as the argument, unless the
           argument has a 'floating' time zone.

       •   map ( sub { ... } )

               # example: remove the hour:minute:second information
               $set = $set2-&gt;map(
                   sub {
                       return $_-&gt;truncate( to =&gt; day );
                   }
               );

               # example: postpone or antecipate events which
               #          match datetimes within another set
               $set = $set2-&gt;map(
                   sub {
                       return $_-&gt;add( days =&gt; 1 ) while $holidays-&gt;contains( $_ );
                   }
               );

           This method is the "set" version of Perl "map".

           It evaluates a subroutine for each element of the set (locally setting "$_"  to  each  datetime)  and
           returns the set composed of the results of each such evaluation.

           Like  Perl  "map",  each  element  of the set may produce zero, one, or more elements in the returned
           value.

           Unlike Perl "map", changing "$_" does not change the original set. This means  that  calling  map  in
           void context has no effect.

           The  callback  subroutine may be called later in the program, due to lazy evaluation.  So don't count
           on subroutine side-effects. For example, a "print" inside the subroutine may happen  later  than  you
           expect.

           The  callback return value is expected to be within the span of the "previous" and the "next" element
           in the original set.  This is a limitation of the backtracking algorithm used in the  "Set::Infinite"
           library.

           For example: given the set "[ 2001, 2010, 2015 ]", the callback result for the value 2010 is expected
           to be within the span "[ 2001 .. 2015 ]".

       •   grep ( sub { ... } )

               # example: filter out any sundays
               $set = $set2-&gt;grep(
                   sub {
                       return ( $_-&gt;day_of_week != 7 );
                   }
               );

           This method is the "set" version of Perl "grep".

           It  evaluates  a  subroutine  for each element of the set (locally setting "$_" to each datetime) and
           returns the set consisting of those elements for which the expression evaluated to true.

           Unlike Perl "grep", changing "$_" does not change the original set. This means that calling  grep  in
           void context has no effect.

           Changing "$_" does change the resulting set.

           The  callback  subroutine may be called later in the program, due to lazy evaluation.  So don't count
           on subroutine side-effects. For example, a "print" inside the subroutine may happen  later  than  you
           expect.

       •   iterate ( sub { ... } )

           <u>deprecated</u> <u>method</u> <u>-</u> <u>please</u> <u>use</u> <u>"map"</u> <u>or</u> <u>"grep"</u> <u>instead.</u>

</pre><h4><b>SUPPORT</b></h4><pre>
       Support is offered through the "<a href="mailto:datetime@perl.org">datetime@perl.org</a>" mailing list.

       Please report bugs using rt.cpan.org

</pre><h4><b>AUTHOR</b></h4><pre>
       Flavio Soibelmann Glock &lt;<a href="mailto:fglock@gmail.com">fglock@gmail.com</a>&gt;

       The API was developed together with Dave Rolsky and the DateTime Community.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2003-2006 Flavio Soibelmann Glock. All rights reserved.  This program is free software; you
       can distribute it and/or modify it under the same terms as Perl itself.

       The full text of the license can be found in the LICENSE file included with this module.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Set::Infinite

       For details on the Perl DateTime Suite project please see &lt;<a href="http://datetime.perl.org">http://datetime.perl.org</a>&gt;.

perl v5.34.0                                       2022-06-13                                 <u>DateTime::<a href="../man3pm/Set.3pm.html">Set</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>