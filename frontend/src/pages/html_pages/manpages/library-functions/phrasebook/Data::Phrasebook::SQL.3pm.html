<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Phrasebook::SQL - The SQL/DBI Phrasebook Model.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-phrasebook-perl">libdata-phrasebook-perl_0.35-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Phrasebook::SQL - The SQL/DBI Phrasebook Model.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Data::Phrasebook;
           use DBI;

           my $dbh = DBI-&gt;connect(...);

           my $book = Data::Phrasebook-&gt;new(
               class =&gt; 'SQL',
               dbh   =&gt; $dbh,
               file  =&gt; 'queries.txt',
           );
           my $q = $book-&gt;query( 'find_author', {
                   author =&gt; "Lance Parkin"
               });
           while ( my $row = $q-&gt;fetchrow_hashref ) {
               print "He wrote $row-&gt;{title}\n";
           }
           $q-&gt;finish;

       <u>queries.txt</u>:

           find_author=select title,author from books where author = :author

</pre><h4><b>DESCRIPTION</b></h4><pre>
       In order to make use of features like placeholders in DBI in conjunction with phrasebooks, it's helpful
       to have a phrasebook be somewhat more aware of how DBI operates. Thus, you get "Data::Phrasebook::SQL".

       "Data::Phrasebook::SQL" has knowledge of how DBI works and creates and executes your queries
       appropriately.

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
   <b>new</b>
       Not to be accessed directly, but via the parent Data::Phrasebook, by specifying the class as SQL.

       Additional arguments to those described in Data::Phrasebook::Generic are:

       â€¢   "dbh" - a DBI database handle.

</pre><h4><b>METHODS</b></h4><pre>
   <b>dbh</b>
       Set, or get, the current DBI handle.

   <b>query</b>
       Constructs a Data::Phrasebook::SQL::Query object from a template. Takes at least one argument, this being
       the  identifier  for  the  query.  The  identifier  is used as a key into the phrasebook "file". A second
       argument can be provided, which is an optional hashref of key to value mappings.

       If phrasebook has a YAML source looking much like the following:

           ---
           find_author:
               sql: select class,title,author from books where author = :author

       You could write:

           my $q = $book-&gt;query( 'find_author' );

           OR

           my $q = $book-&gt;query( 'find_author', {
               author =&gt; 'Lance Parkin'
           } );

           OR

           my $author = 'Lance Parkin';
           my $q = $book-&gt;query( 'find_author', {
               author =&gt; \$author,
           } );

           # sql  = select class,title,author from books where author = ?
           # args = 'Lance Parkin'

       In the above examples, the parameters are bound to the SQL using the bind parameters functionality.  This
       is more efficient in most cases where the same SQL is reused with different values for fields.

       However,  not  all  SQL  statements just need to bind parameters, some may require the ability to replace
       parameters, such as a field list.

           ---
           find_author:
               sql: select :fields from books where author = :author

           my $q = $book-&gt;query( 'find_author',
               replace =&gt; { fields =&gt; 'class,title,author' },
               bind    =&gt; { author =&gt; 'Lance Parkin' }
               );

           # sql  = select class,title,author from books where author = ?
           # args = 'Lance Parkin'

       In all instances, if the SQL template requested does not exist or has no definition, then an  error  will
       be thrown.

       Consult Data::Phrasebook::SQL::Query for what you can then do with your returned object.

       For reference: the bind hashref argument, if it is given, is given to the query object's "order_args" and
       then "args" methods.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Data::Phrasebook, Data::Phrasebook::Generic, Data::Phrasebook::SQL::Query.

</pre><h4><b>SUPPORT</b></h4><pre>
       Please see the README file.

</pre><h4><b>AUTHOR</b></h4><pre>
         Original author: Iain Campbell Truskett (16.07.1979 - 29.12.2003)
         Maintainer: Barbie &lt;<a href="mailto:barbie@cpan.org">barbie@cpan.org</a>&gt; since January 2004.
         for Miss Barbell Productions &lt;<a href="http://www.missbarbell.co.uk">http://www.missbarbell.co.uk</a>&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
         Copyright (C) 2003 Iain Truskett.
         Copyright (C) 2004-2013 Barbie for Miss Barbell Productions.

         This distribution is free software; you can redistribute it and/or
         modify it under the Artistic License v2.

perl v5.36.0                                       2022-11-19                         <u>Data::Phrasebook::<a href="../man3pm/SQL.3pm.html">SQL</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>