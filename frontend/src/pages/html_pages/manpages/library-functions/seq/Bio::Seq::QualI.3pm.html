<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::Seq::QualI - Interface definition for a Bio::Seq::Qual</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-perl-perl">libbio-perl-perl_1.7.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::Seq::QualI - Interface definition for a Bio::Seq::Qual

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # get a Bio::Seq::Qual compliant object somehow

           # to test this is a seq object

           $obj-&gt;isa("Bio::Seq::QualI")
              || $obj-&gt;throw("$obj does not implement the Bio::Seq::QualI interface");

           # accessors

           $string    = $obj-&gt;qual();
           $substring = $obj-&gt;subqual(12,50);
           $display   = $obj-&gt;display_id(); # for human display
           $id        = $obj-&gt;primary_id(); # unique id for this object,
                                            # implementation defined
           $unique_key= $obj-&gt;accession_number();
                              # unique biological id

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This object defines an abstract interface to basic quality information. PrimaryQual is an object just for
       the quality and its name(s), nothing more. There is a pure perl implementation of this in
       Bio::Seq::PrimaryQual. If you just want to use Bio::Seq::PrimaryQual objects, then please read that
       module first. This module defines the interface, and is of more interest to people who want to wrap their
       own Perl Objects/RDBs/FileSystems etc in way that they "are" bioperl quality objects, even though it is
       not using Perl to store the sequence etc.

       This interface defines what bioperl consideres necessary to "be" a sequence of qualities, without
       providing an implementation of this. (An implementation is provided in Bio::Seq::PrimaryQual). If you
       want to provide a Bio::Seq::PrimaryQual 'compliant' object which in fact wraps another
       object/database/out-of-perl experience, then this is the correct thing to wrap, generally by providing a
       wrapper class which would inherit from your object and this Bio::Seq::QualI interface. The wrapper class
       then would have methods lists in the "Implementation Specific Functions" which would provide these
       methods for your object.

</pre><h4><b>FEEDBACK</b></h4><pre>
   <b>Mailing</b> <b>Lists</b>
       User feedback is an integral part of the evolution of this and other Bioperl modules. Send your comments
       and suggestions preferably to one of the Bioperl mailing lists.  Your participation is much appreciated.

         <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>                  - General discussion
         <a href="http://bioperl.org/wiki/Mailing_lists">http://bioperl.org/wiki/Mailing_lists</a>  - About the mailing lists

   <b>Support</b>
       Please direct usage questions or support issues to the mailing list:

       <u><a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a></u>

       rather than to the module maintainer directly. Many experienced and reponsive experts will be able look
       at the problem and quickly address it. Please include a thorough description of the problem with code and
       data examples if at all possible.

   <b>Reporting</b> <b>Bugs</b>
       Report bugs to the Bioperl bug tracking system to help us keep track the bugs and their resolution.  Bug
       reports can be submitted via the web:

         https://github.com/bioperl/bioperl-live/issues

</pre><h4><b>AUTHOR</b> <b>-</b> <b>Chad</b> <b>Matsalla</b></h4><pre>
       This module is heavily based on Bio::Seq::PrimarySeq and is modeled after or outright copies sections of
       it. Thanks Ewan!

       Email <a href="mailto:bioinformatics@dieselwurks.com">bioinformatics@dieselwurks.com</a>

</pre><h4><b>APPENDIX</b></h4><pre>
       The rest of the documentation details each of the object methods.  Internal methods are usually preceded
       with a _

</pre><h4><b>Implementation</b> <b>Specific</b> <b>Functions</b></h4><pre>
       These functions are the ones that a specific implementation must define.

   <b>qual()</b>
        Title   : qual()
        Usage   : @quality_values  = @{$obj-&gt;qual()};
        Function: Returns the quality as a reference to an array containing the
               quality values. The individual elements of the quality array are
               not validated and can be any numeric value.
        Returns : A reference to an array.
        Status  :

   <b>subqual($start,$end)</b>
        Title   : subqual($start,$end)
        Usage   : @subset_of_quality_values = @{$obj-&gt;subseq(10,40)};
        Function: returns the quality values from $start to $end, where the
               first value is 1 and the number is inclusive, ie 1-2 are the first
               two bases of the sequence. Start cannot be larger than end but can
               be equal.
        Returns : A reference to an array.
        Args    : a start position and an end position

   <b>display_id()</b>
        Title   : display_id()
        Usage   : $id_string = $obj-&gt;display_id() _or_
                  $id_string = $obj-&gt;display_id($new_display_id);
        Function: Returns the display id, aka the common name of the Quality
               object.
               The semantics of this is that it is the most likely string to be
               used as an identifier of the quality sequence, and likely to have
               "human" readability.  The id is equivalent to the ID field of the
               GenBank/EMBL databanks and the id field of the Swissprot/sptrembl
               database. In fasta format, the &gt;(\S+) is presumed to be the id,
               though some people overload the id to embed other information.
               Bioperl does not use any embedded information in the ID field,
               and people are encouraged to use other mechanisms (accession field
               for example, or extending the sequence object) to solve this.
               Notice that $seq-&gt;id() maps to this function, mainly for
               legacy/convience issues
        Returns : A string
        Args    : If an arg is provided, it will replace the existing display_id
               in the object.

   <b>accession_number()</b>
        Title   : accession_number()
        Usage   : $unique_biological_key = $obj-&gt;accession_number(); _or_
                  $unique_biological_key = $obj-&gt;accession_number($new_acc_num);
        Function: Returns the unique biological id for a sequence, commonly
               called the accession_number. For sequences from established
               databases, the implementors should try to use the correct
               accession number. Notice that primary_id() provides the unique id
               for the implementation, allowing multiple objects to have the same
               accession number in a particular implementation. For sequences
               with no accession number, this method should return "unknown".
        Returns : A string.
        Args    : If an arg is provided, it will replace the existing
               accession_number in the object.

   <b>primary_id()</b>
        Title   : primary_id()
        Usage   : $unique_implementation_key = $obj-&gt;primary_id(); _or_
                  $unique_implementation_key = $obj-&gt;primary_id($new_prim_id);
        Function: Returns the unique id for this object in this implementation.
               This allows implementations to manage their own object ids in a
               way the implementation can control clients can expect one id to
               map to one object. For sequences with no accession number, this
               method should return a stringified memory location.
        Returns : A string
        Args    : If an arg is provided, it will replace the existing
               primary_id in the object.

   <b>can_call_new()</b>
        Title   : can_call_new()
        Usage   : if( $obj-&gt;can_call_new ) {
                    $newobj = $obj-&gt;new( %param );
                }
        Function: can_call_new returns 1 or 0 depending on whether an
               implementation allows new constructor to be called. If a new
               constructor is allowed, then it should take the followed hashed
               constructor list.
                  $myobject-&gt;new( -qual =&gt; $quality_as_string,
                                  -display_id  =&gt; $id,
                                  -accession_number =&gt; $accession,
                                  );
        Example :
        Returns : 1 or 0
        Args    :

   <b>qualat($position)</b>
        Title   : qualat($position)
        Usage   : $quality = $obj-&gt;<a href="../man10/qualat.10.html">qualat</a>(10);
        Function: Return the quality value at the given location, where the
               first value is 1 and the number is inclusive, ie 1-2 are the first
               two bases of the sequence. Start cannot be larger than end but can
               be equal.
        Returns : A scalar.
        Args    : A position.

</pre><h4><b>Optional</b> <b>Implementation</b> <b>Functions</b></h4><pre>
       The following functions rely on the above functions. A implementing class does not need to provide these
       functions, as they will be provided by this class, but is free to override these functions.

       All of <b>revcom()</b>, <b>trunc()</b>, and <b>translate()</b> create new sequence objects. They will call <b>new()</b> on the class
       of the sequence object instance passed as argument, unless <b>can_call_new()</b> returns FALSE. In the latter
       case a Bio::PrimarySeq object will be created. Implementors which really want to control how objects are
       created (eg, for object persistence over a database, or objects in a CORBA framework), they are
       encouraged to override these methods

   <b>revcom</b>
        Title   : revcom
        Usage   : @rev = @{$qual-&gt;revcom()};
        Function: Produces a new Bio::Seq::QualI implementing object which
               is reversed from the original quality array.
               The id is the same id as the original sequence, and the accession number
               is also identical. If someone wants to track that this sequence has
               been reversed, it needs to define its own extensions

               To do an inplace edit of an object you can go:

               $qual = $qual-&gt;revcom();

               This of course, causes Perl to handle the garbage collection of the old
               object, but it is roughly speaking as efficient as an inplace edit.
        Returns : A new (fresh) Bio::Seq::PrimaryQualI object
        Args    : none

   <b>trunc()</b>
        Title   : trunc
        Usage   : $subseq = $myseq-&gt;trunc(10,100);
        Function: Provides a truncation of a sequence,
        Returns : a fresh Bio::Seq::QualI implementing object
        Args    : Two integers denoting first and last base of the sub-sequence.

   <b>translate()</b>
        Title   : translate()
        Usage   : $protein_seq_obj = $dna_seq_obj-&gt;translate
                  #if full CDS expected:
                  $protein_seq_obj = $cds_seq_obj-&gt;translate(undef,undef,undef,undef,1);
        Function: Completely useless in this interface.
        Returns : Nothing.
        Args    : Nothing.

   <b>id()</b>
        Title   : id()
        Usage   : $id = $qual-&gt;id()
        Function: ID of the quality. This should normally be (and actually is in
                  the implementation provided here) just a synonym for display_id().
        Example :
        Returns : A string.
        Args    :

   <b>length()</b>
        Title   : length()
        Usage   : $length = $qual-&gt;length();
        Function: Return the length of the array holding the quality values.
               Under most circumstances, this should match the number of quality
               values but no validation is done when the PrimaryQual object is
               constructed and non-digits could be put into this array. Is this a
               bug? Just enough rope...
        Returns : A scalar (the number of elements in the quality array).
        Args    : None.

   <b>desc()</b>
        Title   : desc()
        Usage   : $qual-&gt;desc($newval);
                  $description = $seq-&gt;desc();
        Function: Get/set description text for a qual object
        Example :
        Returns : value of desc
        Args    : newvalue (optional)

</pre><h4><b>Private</b> <b>functions</b></h4><pre>
       These are some private functions for the PrimarySeqI interface. You do not need to implement these
       functions

   <b>_attempt_to_load_Seq</b>
        Title   : _attempt_to_load_Seq
        Usage   :
        Function:
        Example :
        Returns :
        Args    :

perl v5.32.1                                       2021-08-15                               <u>Bio::Seq::<a href="../man3pm/QualI.3pm.html">QualI</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>