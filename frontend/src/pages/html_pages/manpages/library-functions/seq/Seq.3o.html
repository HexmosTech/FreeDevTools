<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seq - Sequences.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Seq - Sequences.

</pre><h4><b>Module</b></h4><pre>
       Module   Seq

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Seq</b>
        : <b>sig</b> <b>end</b>

       Sequences.

       A  sequence  of  type  <b>'a</b>  <b>Seq.t</b>  can be thought of as a delayed list, that is, a list whose elements are
       computed only when they are demanded by a consumer. This allows sequences to be produced and  transformed
       lazily  (one element at a time) rather than eagerly (all elements at once). This also allows constructing
       conceptually infinite sequences.

       The type <b>'a</b> <b>Seq.t</b> is defined as a synonym for <b>unit</b> <b>-&gt;</b> <b>'a</b> <b>Seq.node</b> .  This is a function type:  therefore,
       it  is  opaque.  The  consumer  can    query a sequence in order to request the next element (if there is
       one), but cannot otherwise inspect the sequence in any way.

       Because it is opaque, the type <b>'a</b> <b>Seq.t</b> does not reveal whether a sequence is:

       -persistent, which means that the sequence can be used as many  times  as  desired,  producing  the  same
       elements every time, just like an immutable list; or

       -ephemeral,  which  means that the sequence is not persistent.  Querying an ephemeral sequence might have
       an observable side effect, such as incrementing  a  mutable  counter.   As  a  common  special  case,  an
       ephemeral sequence can be affine, which means that it must be queried at most once.

       It also does not reveal whether the elements of the sequence are:

       -pre-computed and stored in memory, which means that querying the sequence is cheap;

       -computed  when first demanded and then stored in memory, which means that querying the sequence once can
       be expensive, but querying the same sequence again is cheap; or

       -re-computed every time they are demanded, which may or may not be cheap.

       It is up to the programmer to keep these distinctions in mind so as to  understand  the  time  and  space
       requirements of sequences.

       For  the  sake  of  simplicity,  most  of  the  documentation  that follows is written under the implicit
       assumption that the sequences at hand are persistent.  We normally do not point  out  when  or  how  many
       times  each  function is invoked, because that would be too verbose.  For instance, in the description of
       <b>map</b> , we write: "if <b>xs</b> is the sequence <b>x0;</b> <b>x1;</b> <b>...</b>  then <b>map</b> <b>f</b> <b>xs</b> is the sequence <b>f</b> <b>x0;</b> <b>f</b> <b>x1;</b> <b>...</b>  ".  If
       we wished to be more explicit, we could point out that the transformation takes place on demand: that is,
       the elements of <b>map</b> <b>f</b> <b>xs</b> are computed only when they are demanded. In other words, the definition <b>let</b>  <b>ys</b>
       <b>=</b>  <b>map</b>  <b>f</b>  <b>xs</b> terminates immediately and does not invoke <b>f</b> . The function call <b>f</b> <b>x0</b> takes place only when
       the first element of <b>ys</b> is demanded, via the function call <b>ys()</b> .  Furthermore, calling <b>ys()</b> twice causes
       <b>f</b> <b>x0</b> to be called twice as well. If one wishes for <b>f</b> to be applied at most once to each element of  <b>xs</b>  ,
       even in scenarios where <b>ys</b> is queried more than once, then one should use <b>let</b> <b>ys</b> <b>=</b> <b>memoize</b> <b>(map</b> <b>f</b> <b>xs)</b> .

       As a general rule, the functions that build sequences, such as <b>map</b> , <b>filter</b> , <b>scan</b> , <b>take</b> , etc., produce
       sequences  whose elements are computed only on demand. The functions that eagerly consume sequences, such
       as <b>is_empty</b> , <b>find</b> , <b>length</b> , <b>iter</b> , <b>fold_left</b> , etc., are the functions that force computation  to  take
       place.

       When  possible,  we recommend using sequences rather than dispensers (functions of type <b>unit</b> <b>-&gt;</b> <b>'a</b> <b>option</b>
       that produce elements upon demand). Whereas sequences can be  persistent  or  ephemeral,  dispensers  are
       always ephemeral, and are typically more difficult to work with than sequences. Two conversion functions,
       <b>Seq.to_dispenser</b> and <b>Seq.of_dispenser</b> , are provided.

       <b>Since</b> 4.07

       <u>type</u> <b>'a</b> <u>t</u> = <b>unit</b> <b>-&gt;</b> <b>'a</b> <b>node</b>

       A  sequence  <b>xs</b>  of  type  <b>'a</b>  <b>t</b> is a delayed list of elements of type <b>'a</b> . Such a sequence is queried by
       performing a function application <b>xs()</b> . This function application returns a node, allowing the caller to
       determine whether the sequence is empty or nonempty, and in the latter case, to obtain its head and tail.

       <u>type</u> <b>'a</b> <u>node</u> =
        | Nil
        | Cons <b>of</b> <b>'a</b> <b>*</b> <b>'a</b> <b>t</b>

       A node is either <b>Nil</b> , which means that the sequence is empty, or <b>Cons</b> <b>(x,</b> <b>xs)</b> , which means  that  <b>x</b>  is
       the first element of the sequence and that <b>xs</b> is the remainder of the sequence.

   <b>Consuming</b> <b>sequences</b>
       The functions in this section consume their argument, a sequence, either partially or completely:

       -  <b>is_empty</b>  and <b>uncons</b> consume the sequence down to depth 1.  That is, they demand the first argument of
       the sequence, if there is one.

       - <b>iter</b> , <b>fold_left</b> , <b>length</b> , etc., consume the sequence all the way to its end. They terminate  only  if
       the sequence is finite.

       -  <b>for_all</b>  ,  <b>exists</b>  ,  <b>find</b>  ,  etc.  consume  the sequence down to a certain depth, which is a priori
       unpredictable.

       Similarly, among the functions that consume two sequences, one can distinguish two groups:

       - <b>iter2</b> and <b>fold_left2</b> consume both sequences all the way to the end, provided  the  sequences  have  the
       same length.

       -  <b>for_all2</b>  , <b>exists2</b> , <b>equal</b> , <b>compare</b> consume the sequences down to a certain depth, which is a priori
       unpredictable.

       The functions that consume two sequences can be applied to two sequences of  distinct  lengths:  in  that
       case, the excess elements in the longer sequence are ignored. (It may be the case that one excess element
       is demanded, even though this element is not used.)

       None of the functions in this section is lazy. These functions are consumers: they force some computation
       to take place.

       <u>val</u> <u>is_empty</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>is_empty</b> <b>xs</b> determines whether the sequence <b>xs</b> is empty.

       It  is  recommended  that  the  sequence  <b>xs</b>  be persistent.  Indeed, <b>is_empty</b> <b>xs</b> demands the head of the
       sequence <b>xs</b> , so, if <b>xs</b> is ephemeral, it may be the case that <b>xs</b> cannot be used any more after this  call
       has taken place.

       <b>Since</b> 4.14

       <u>val</u> <u>uncons</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'a</b> <b>t)</b> <b>option</b>

       If <b>xs</b> is empty, then <b>uncons</b> <b>xs</b> is <b>None</b> .

       If <b>xs</b> is nonempty, then <b>uncons</b> <b>xs</b> is <b>Some</b> <b>(x,</b> <b>ys)</b> where <b>x</b> is the head of the sequence and <b>ys</b> its tail.

       <b>Since</b> 4.14

       <u>val</u> <u>length</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b>

       <b>length</b> <b>xs</b> is the length of the sequence <b>xs</b> .

       The sequence <b>xs</b> must be finite.

       <b>Since</b> 4.14

       <u>val</u> <u>iter</u> : <b>('a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>iter</b> <b>f</b> <b>xs</b> invokes <b>f</b> <b>x</b> successively for every element <b>x</b> of the sequence <b>xs</b> , from left to right.

       It terminates only if the sequence <b>xs</b> is finite.

       <u>val</u> <u>fold_left</u> : <b>('acc</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_left</b> <b>f</b> <b>_</b> <b>xs</b> invokes <b>f</b> <b>_</b> <b>x</b> successively for every element <b>x</b> of the sequence <b>xs</b> , from left to right.

       An accumulator of type <b>'a</b> is threaded through the calls to <b>f</b> .

       It terminates only if the sequence <b>xs</b> is finite.

       <u>val</u> <u>iteri</u> : <b>(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>iteri</b> <b>f</b> <b>xs</b> invokes <b>f</b> <b>i</b> <b>x</b> successively for every element <b>x</b> located at index <b>i</b> in the sequence <b>xs</b> .

       It terminates only if the sequence <b>xs</b> is finite.

       <b>iteri</b> <b>f</b> <b>xs</b> is equivalent to <b>iter</b> <b>(fun</b> <b>(i,</b> <b>x)</b> <b>-&gt;</b> <b>f</b> <b>i</b> <b>x)</b> <b>(zip</b> <b>(ints</b> <b>0)</b> <b>xs)</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>fold_lefti</u> : <b>('acc</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_lefti</b>  <b>f</b> <b>_</b> <b>xs</b> invokes <b>f</b> <b>_</b> <b>i</b> <b>x</b> successively for every element <b>x</b> located at index <b>i</b> of the sequence <b>xs</b>
       .

       An accumulator of type <b>'b</b> is threaded through the calls to <b>f</b> .

       It terminates only if the sequence <b>xs</b> is finite.

       <b>fold_lefti</b> <b>f</b> <b>accu</b> <b>xs</b> is equivalent to <b>fold_left</b> <b>(fun</b> <b>accu</b> <b>(i,</b> <b>x)</b> <b>-&gt;</b> <b>f</b> <b>accu</b> <b>i</b> <b>x)</b> <b>accu</b> <b>(zip</b> <b>(ints</b> <b>0)</b> <b>xs)</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>for_all</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>for_all</b> <b>p</b> <b>xs</b> determines whether all elements <b>x</b> of the sequence <b>xs</b> satisfy <b>p</b> <b>x</b> .

       The sequence <b>xs</b> must be finite.

       <b>Since</b> 4.14

       <u>val</u> <u>exists</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>exists</b> <b>xs</b> <b>p</b> determines whether at least one element <b>x</b> of the sequence <b>xs</b> satisfies <b>p</b> <b>x</b> .

       The sequence <b>xs</b> must be finite.

       <b>Since</b> 4.14

       <u>val</u> <u>find</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       <b>find</b> <b>p</b> <b>xs</b> returns <b>Some</b> <b>x</b> , where <b>x</b> is the first element of the sequence <b>xs</b> that satisfies <b>p</b> <b>x</b> , if  there
       is such an element.

       It returns <b>None</b> if there is no such element.

       The sequence <b>xs</b> must be finite.

       <b>Since</b> 4.14

       <u>val</u> <u>find_index</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>option</b>

       <b>find_index</b>  <b>p</b>  <b>xs</b>  returns  <b>Some</b>  <b>i</b>  ,  where <b>i</b> is the index of the first element of the sequence <b>xs</b> that
       satisfies <b>p</b> <b>x</b> , if there is such an element.

       It returns <b>None</b> if there is no such element.

       The sequence <b>xs</b> must be finite.

       <b>Since</b> 5.1

       <u>val</u> <u>find_map</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       <b>find_map</b> <b>f</b> <b>xs</b> returns <b>Some</b> <b>y</b> , where <b>x</b> is the first element of the sequence <b>xs</b> such that <b>f</b> <b>x</b> <b>=</b> <b>Some</b>  <b>_</b>  ,
       if there is such an element, and where <b>y</b> is defined by <b>f</b> <b>x</b> <b>=</b> <b>Some</b> <b>y</b> .

       It returns <b>None</b> if there is no such element.

       The sequence <b>xs</b> must be finite.

       <b>Since</b> 4.14

       <u>val</u> <u>find_mapi</u> : <b>(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       Same  as  <b>find_map</b> , but the predicate is applied to the index of the element as first argument (counting
       from 0), and the element itself as second argument.

       The sequence <b>xs</b> must be finite.

       <b>Since</b> 5.1

       <u>val</u> <u>iter2</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>iter2</b> <b>f</b> <b>xs</b> <b>ys</b> invokes <b>f</b> <b>x</b> <b>y</b> successively for every pair <b>(x,</b> <b>y)</b> of elements drawn synchronously  from  the
       sequences <b>xs</b> and <b>ys</b> .

       If  the  sequences  <b>xs</b>  and  <b>ys</b>  have  different lengths, then iteration stops as soon as one sequence is
       exhausted; the excess elements in the other sequence are ignored.

       Iteration terminates only if at least one of the sequences <b>xs</b> and <b>ys</b> is finite.

       <b>iter2</b> <b>f</b> <b>xs</b> <b>ys</b> is equivalent to <b>iter</b> <b>(fun</b> <b>(x,</b> <b>y)</b> <b>-&gt;</b> <b>f</b> <b>x</b> <b>y)</b> <b>(zip</b> <b>xs</b> <b>ys)</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>fold_left2</u> : <b>('acc</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_left2</b> <b>f</b> <b>_</b> <b>xs</b> <b>ys</b> invokes <b>f</b> <b>_</b> <b>x</b> <b>y</b> successively for every pair <b>(x,</b> <b>y)</b> of elements  drawn  synchronously
       from the sequences <b>xs</b> and <b>ys</b> .

       An accumulator of type <b>'a</b> is threaded through the calls to <b>f</b> .

       If  the  sequences  <b>xs</b>  and  <b>ys</b>  have  different lengths, then iteration stops as soon as one sequence is
       exhausted; the excess elements in the other sequence are ignored.

       Iteration terminates only if at least one of the sequences <b>xs</b> and <b>ys</b> is finite.

       <b>fold_left2</b> <b>f</b> <b>accu</b> <b>xs</b> <b>ys</b> is equivalent to <b>fold_left</b> <b>(fun</b> <b>accu</b> <b>(x,</b> <b>y)</b> <b>-&gt;</b> <b>f</b> <b>accu</b> <b>x</b> <b>y)</b> <b>(zip</b> <b>xs</b> <b>ys)</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>for_all2</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>for_all2</b> <b>p</b> <b>xs</b> <b>ys</b> determines whether all pairs <b>(x,</b> <b>y)</b> of elements drawn synchronously from  the  sequences
       <b>xs</b> and <b>ys</b> satisfy <b>p</b> <b>x</b> <b>y</b> .

       If  the  sequences  <b>xs</b>  and  <b>ys</b>  have  different lengths, then iteration stops as soon as one sequence is
       exhausted; the excess elements in the other sequence are ignored.  In particular, if <b>xs</b> or <b>ys</b>  is  empty,
       then  <b>for_all2</b>  <b>p</b> <b>xs</b> <b>ys</b> is true. This is where <b>for_all2</b> and <b>equal</b> differ: <b>equal</b> <b>eq</b> <b>xs</b> <b>ys</b> can be true only
       if <b>xs</b> and <b>ys</b> have the same length.

       At least one of the sequences <b>xs</b> and <b>ys</b> must be finite.

       <b>for_all2</b> <b>p</b> <b>xs</b> <b>ys</b> is equivalent to <b>for_all</b> <b>(fun</b> <b>b</b> <b>-&gt;</b> <b>b)</b> <b>(map2</b> <b>p</b> <b>xs</b> <b>ys)</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>exists2</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>exists2</b> <b>p</b> <b>xs</b> <b>ys</b> determines whether some pair <b>(x,</b> <b>y)</b> of elements drawn synchronously from the sequences <b>xs</b>
       and <b>ys</b> satisfies <b>p</b> <b>x</b> <b>y</b> .

       If the sequences <b>xs</b> and <b>ys</b> have different lengths, then iteration must stop as soon as  one  sequence  is
       exhausted; the excess elements in the other sequence are ignored.

       At least one of the sequences <b>xs</b> and <b>ys</b> must be finite.

       <b>exists2</b> <b>p</b> <b>xs</b> <b>ys</b> is equivalent to <b>exists</b> <b>(fun</b> <b>b</b> <b>-&gt;</b> <b>b)</b> <b>(map2</b> <b>p</b> <b>xs</b> <b>ys)</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>equal</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       Provided the function <b>eq</b> defines an equality on elements, <b>equal</b> <b>eq</b> <b>xs</b> <b>ys</b> determines whether the sequences
       <b>xs</b> and <b>ys</b> are pointwise equal.

       At least one of the sequences <b>xs</b> and <b>ys</b> must be finite.

       <b>Since</b> 4.14

       <u>val</u> <u>compare</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b> <b>-&gt;</b> <b>int</b>

       Provided the function <b>cmp</b> defines a preorder on elements, <b>compare</b> <b>cmp</b> <b>xs</b> <b>ys</b> compares the sequences <b>xs</b> and
       <b>ys</b> according to the lexicographic preorder.

       For more details on comparison functions, see <b>Array.sort</b> .

       At least one of the sequences <b>xs</b> and <b>ys</b> must be finite.

       <b>Since</b> 4.14

   <b>Constructing</b> <b>sequences</b>
       The  functions  in this section are lazy: that is, they return sequences whose elements are computed only
       when demanded.

       <u>val</u> <u>empty</u> : <b>'a</b> <b>t</b>

       <b>empty</b> is the empty sequence.  It has no elements. Its length is 0.

       <u>val</u> <u>return</u> : <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>return</b> <b>x</b> is the sequence whose sole element is <b>x</b> .  Its length is 1.

       <u>val</u> <u>cons</u> : <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>cons</b> <b>x</b> <b>xs</b> is the sequence that begins with the element <b>x</b> , followed with the sequence <b>xs</b> .

       Writing <b>cons</b> <b>(f())</b> <b>xs</b> causes the function call <b>f()</b> to take place immediately. For this call to be delayed
       until the sequence is queried, one must instead write <b>(fun</b> <b>()</b> <b>-&gt;</b> <b>Cons(f(),</b> <b>xs))</b> .

       <b>Since</b> 4.11

       <u>val</u> <u>init</u> : <b>int</b> <b>-&gt;</b> <b>(int</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>init</b> <b>n</b> <b>f</b> is the sequence <b>f</b> <b>0;</b> <b>f</b> <b>1;</b> <b>...;</b> <b>f</b> <b>(n-1)</b> .

       <b>n</b> must be nonnegative.

       If desired, the infinite sequence <b>f</b> <b>0;</b> <b>f</b> <b>1;</b> <b>...</b>  can be defined as <b>map</b> <b>f</b> <b>(ints</b> <b>0)</b> .

       <b>Since</b> 4.14

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is negative.

       <u>val</u> <u>unfold</u> : <b>('b</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>option)</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>unfold</b> constructs a sequence out of a step function and an initial state.

       If <b>f</b> <b>u</b> is <b>None</b> then <b>unfold</b> <b>f</b> <b>u</b> is the empty sequence.  If <b>f</b> <b>u</b> is <b>Some</b> <b>(x,</b> <b>u')</b> then  <b>unfold</b>  <b>f</b>  <b>u</b>  is  the
       nonempty sequence <b>cons</b> <b>x</b> <b>(unfold</b> <b>f</b> <b>u')</b> .

       For example, <b>unfold</b> <b>(function</b> <b>[]</b> <b>-&gt;</b> <b>None</b> <b>|</b> <b>h</b> <b>::</b> <b>t</b> <b>-&gt;</b> <b>Some</b> <b>(h,</b> <b>t))</b> <b>l</b> is equivalent to <b>List.to_seq</b> <b>l</b> .

       <b>Since</b> 4.11

       <u>val</u> <u>repeat</u> : <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>repeat</b> <b>x</b> is the infinite sequence where the element <b>x</b> is repeated indefinitely.

       <b>repeat</b> <b>x</b> is equivalent to <b>cycle</b> <b>(return</b> <b>x)</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>forever</u> : <b>(unit</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>forever</b> <b>f</b> is an infinite sequence where every element is produced (on demand) by the function call <b>f()</b> .

       For instance, <b>forever</b> <b>Random.bool</b> is an infinite sequence of random bits.

       <b>forever</b> <b>f</b> is equivalent to <b>map</b> <b>f</b> <b>(repeat</b> <b>())</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>cycle</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>cycle</b> <b>xs</b> is the infinite sequence that consists of an infinite number of repetitions of the sequence <b>xs</b> .

       If <b>xs</b> is an empty sequence, then <b>cycle</b> <b>xs</b> is empty as well.

       Consuming  (a  prefix  of)  the sequence <b>cycle</b> <b>xs</b> once can cause the sequence <b>xs</b> to be consumed more than
       once.  Therefore, <b>xs</b> must be persistent.

       <b>Since</b> 4.14

       <u>val</u> <u>iterate</u> : <b>('a</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>iterate</b> <b>f</b> <b>x</b> is the infinite sequence whose elements are <b>x</b> , <b>f</b> <b>x</b> , <b>f</b> <b>(f</b> <b>x)</b> , and so on.

       In other words, it is the orbit of the function <b>f</b> , starting at <b>x</b> .

       <b>Since</b> 4.14

   <b>Transforming</b> <b>sequences</b>
       The functions in this section are lazy: that is, they return sequences whose elements are  computed  only
       when demanded.

       <u>val</u> <u>map</u> : <b>('a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b>

       <b>map</b> <b>f</b> <b>xs</b> is the image of the sequence <b>xs</b> through the transformation <b>f</b> .

       If <b>xs</b> is the sequence <b>x0;</b> <b>x1;</b> <b>...</b>  then <b>map</b> <b>f</b> <b>xs</b> is the sequence <b>f</b> <b>x0;</b> <b>f</b> <b>x1;</b> <b>...</b>  .

       <u>val</u> <u>mapi</u> : <b>(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b>

       <b>mapi</b> is analogous to <b>map</b> , but applies the function <b>f</b> to an index and an element.

       <b>mapi</b> <b>f</b> <b>xs</b> is equivalent to <b>map2</b> <b>f</b> <b>(ints</b> <b>0)</b> <b>xs</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>filter</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>filter</b> <b>p</b> <b>xs</b> is the sequence of the elements <b>x</b> of <b>xs</b> that satisfy <b>p</b> <b>x</b> .

       In other words, <b>filter</b> <b>p</b> <b>xs</b> is the sequence <b>xs</b> , deprived of the elements <b>x</b> such that <b>p</b> <b>x</b> is false.

       <u>val</u> <u>filter_map</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b>

       <b>filter_map</b> <b>f</b> <b>xs</b> is the sequence of the elements <b>y</b> such that <b>f</b> <b>x</b> <b>=</b> <b>Some</b> <b>y</b> , where <b>x</b> ranges over <b>xs</b> .

       <b>filter_map</b> <b>f</b> <b>xs</b> is equivalent to <b>map</b> <b>Option.get</b> <b>(filter</b> <b>Option.is_some</b> <b>(map</b> <b>f</b> <b>xs))</b> .

       <u>val</u> <u>scan</u> : <b>('b</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b>

       If  <b>xs</b>  is  a  sequence <b>[x0;</b> <b>x1;</b> <b>x2;</b> <b>...]</b>  , then <b>scan</b> <b>f</b> <b>a0</b> <b>xs</b> is a sequence of accumulators <b>[a0;</b> <b>a1;</b> <b>a2;</b>
       <b>...]</b>  where <b>a1</b> is <b>f</b> <b>a0</b> <b>x0</b> , <b>a2</b> is <b>f</b> <b>a1</b> <b>x1</b> , and so on.

       Thus, <b>scan</b> <b>f</b> <b>a0</b> <b>xs</b> is conceptually related to <b>fold_left</b> <b>f</b> <b>a0</b> <b>xs</b> . However, instead of performing an eager
       iteration and immediately returning the final accumulator, it returns a sequence of accumulators.

       For instance, <b>scan</b> <b>(+)</b> <b>0</b> transforms a sequence of integers into the sequence of its partial sums.

       If <b>xs</b> has length <b>n</b> then <b>scan</b> <b>f</b> <b>a0</b> <b>xs</b> has length <b>n+1</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>take</u> : <b>int</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>take</b> <b>n</b> <b>xs</b> is the sequence of the first <b>n</b> elements of <b>xs</b> .

       If <b>xs</b> has fewer than <b>n</b> elements, then <b>take</b> <b>n</b> <b>xs</b> is equivalent to <b>xs</b> .

       <b>n</b> must be nonnegative.

       <b>Since</b> 4.14

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is negative.

       <u>val</u> <u>drop</u> : <b>int</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>drop</b> <b>n</b> <b>xs</b> is the sequence <b>xs</b> , deprived of its first <b>n</b> elements.

       If <b>xs</b> has fewer than <b>n</b> elements, then <b>drop</b> <b>n</b> <b>xs</b> is empty.

       <b>n</b> must be nonnegative.

       <b>drop</b> is lazy: the first <b>n+1</b> elements of the sequence <b>xs</b> are demanded only when the first element of  <b>drop</b>
       <b>n</b> <b>xs</b> is demanded.

       <b>Since</b> 4.14

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is negative.

       <u>val</u> <u>take_while</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>take_while</b> <b>p</b> <b>xs</b> is the longest prefix of the sequence <b>xs</b> where every element <b>x</b> satisfies <b>p</b> <b>x</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>drop_while</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>drop_while</b> <b>p</b> <b>xs</b> is the sequence <b>xs</b> , deprived of the prefix <b>take_while</b> <b>p</b> <b>xs</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>group</u> : <b>('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>t</b>

       Provided the function <b>eq</b> defines an equality on elements, <b>group</b> <b>eq</b> <b>xs</b> is the sequence of the maximal runs
       of adjacent duplicate elements of the sequence <b>xs</b> .

       Every element of <b>group</b> <b>eq</b> <b>xs</b> is a nonempty sequence of equal elements.

       The concatenation <b>concat</b> <b>(group</b> <b>eq</b> <b>xs)</b> is equal to <b>xs</b> .

       Consuming  <b>group</b>  <b>eq</b>  <b>xs</b> , and consuming the sequences that it contains, can cause <b>xs</b> to be consumed more
       than once. Therefore, <b>xs</b> must be persistent.

       <b>Since</b> 4.14

       <u>val</u> <u>memoize</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       The sequence <b>memoize</b> <b>xs</b> has the same elements as the sequence <b>xs</b> .

       Regardless of whether <b>xs</b> is ephemeral or persistent, <b>memoize</b> <b>xs</b> is persistent:  even  if  it  is  queried
       several times, <b>xs</b> is queried at most once.

       The  construction of the sequence <b>memoize</b> <b>xs</b> internally relies on suspensions provided by the module <b>Lazy</b>
       . These suspensions are not thread-safe. Therefore, the sequence  <b>memoize</b>  <b>xs</b>  must  not  be  queried  by
       multiple threads concurrently.

       <b>Since</b> 4.14

       <u>exception</u> <u>Forced_twice</u>

       This  exception  is  raised when a sequence returned by <b>Seq.once</b> (or a suffix of it) is queried more than
       once.

       <b>Since</b> 4.14

       <u>val</u> <u>once</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       The sequence <b>once</b> <b>xs</b> has the same elements as the sequence <b>xs</b> .

       Regardless of whether <b>xs</b> is ephemeral or persistent, <b>once</b> <b>xs</b> is an ephemeral sequence: it can be  queried
       at  most  once.   If it (or a suffix of it) is queried more than once, then the exception <b>Forced_twice</b> is
       raised. This can be useful, while debugging or testing, to ensure that a sequence  is  consumed  at  most
       once.

       <b>Since</b> 4.14

       <b>Raises</b> <b>Forced_twice</b> if <b>once</b> <b>xs</b> , or a suffix of it, is queried more than once.

       <u>val</u> <u>transpose</u> : <b>'a</b> <b>t</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>t</b>

       If  <b>xss</b> is a matrix (a sequence of rows), then <b>transpose</b> <b>xss</b> is the sequence of the columns of the matrix
       <b>xss</b> .

       The rows of the matrix <b>xss</b> are not required to have the same length.

       The matrix <b>xss</b> is not required to be finite (in either direction).

       The matrix <b>xss</b> must be persistent.

       <b>Since</b> 4.14

   <b>Combining</b> <b>sequences</b>
       <u>val</u> <u>append</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>append</b> <b>xs</b> <b>ys</b> is the concatenation of the sequences <b>xs</b> and <b>ys</b> .

       Its elements are the elements of <b>xs</b> , followed by the elements of <b>ys</b> .

       <b>Since</b> 4.11

       <u>val</u> <u>concat</u> : <b>'a</b> <b>t</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       If <b>xss</b> is a sequence of sequences, then <b>concat</b> <b>xss</b> is its concatenation.

       If <b>xss</b> is the sequence <b>xs0;</b> <b>xs1;</b> <b>...</b>  then <b>concat</b> <b>xss</b> is the sequence <b>xs0</b> <b>@</b> <b>xs1</b> <b>@</b> <b>...</b>  .

       <b>Since</b> 4.13

       <u>val</u> <u>flat_map</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>t)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b>

       <b>flat_map</b> <b>f</b> <b>xs</b> is equivalent to <b>concat</b> <b>(map</b> <b>f</b> <b>xs)</b> .

       <u>val</u> <u>concat_map</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>t)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b>

       <b>concat_map</b> <b>f</b> <b>xs</b> is equivalent to <b>concat</b> <b>(map</b> <b>f</b> <b>xs)</b> .

       <b>concat_map</b> is an alias for <b>flat_map</b> .

       <b>Since</b> 4.13

       <u>val</u> <u>zip</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>t</b>

       <b>zip</b> <b>xs</b> <b>ys</b> is the sequence of pairs <b>(x,</b> <b>y)</b> drawn synchronously from the sequences <b>xs</b> and <b>ys</b> .

       If the sequences <b>xs</b> and <b>ys</b> have different lengths, then the sequence ends as  soon  as  one  sequence  is
       exhausted; the excess elements in the other sequence are ignored.

       <b>zip</b> <b>xs</b> <b>ys</b> is equivalent to <b>map2</b> <b>(fun</b> <b>a</b> <b>b</b> <b>-&gt;</b> <b>(a,</b> <b>b))</b> <b>xs</b> <b>ys</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>map2</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'c)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b> <b>-&gt;</b> <b>'c</b> <b>t</b>

       <b>map2</b>  <b>f</b> <b>xs</b> <b>ys</b> is the sequence of the elements <b>f</b> <b>x</b> <b>y</b> , where the pairs <b>(x,</b> <b>y)</b> are drawn synchronously from
       the sequences <b>xs</b> and <b>ys</b> .

       If the sequences <b>xs</b> and <b>ys</b> have different lengths, then the sequence ends as  soon  as  one  sequence  is
       exhausted; the excess elements in the other sequence are ignored.

       <b>map2</b> <b>f</b> <b>xs</b> <b>ys</b> is equivalent to <b>map</b> <b>(fun</b> <b>(x,</b> <b>y)</b> <b>-&gt;</b> <b>f</b> <b>x</b> <b>y)</b> <b>(zip</b> <b>xs</b> <b>ys)</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>interleave</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>interleave</b>  <b>xs</b>  <b>ys</b>  is  the  sequence that begins with the first element of <b>xs</b> , continues with the first
       element of <b>ys</b> , and so on.

       When one of the sequences <b>xs</b> and <b>ys</b> is exhausted, <b>interleave</b> <b>xs</b> <b>ys</b> continues with the rest of  the  other
       sequence.

       <b>Since</b> 4.14

       <u>val</u> <u>sorted_merge</u> : <b>('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       If  the  sequences <b>xs</b> and <b>ys</b> are sorted according to the total preorder <b>cmp</b> , then <b>sorted_merge</b> <b>cmp</b> <b>xs</b> <b>ys</b>
       is the sorted sequence obtained by merging the sequences <b>xs</b> and <b>ys</b> .

       For more details on comparison functions, see <b>Array.sort</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>product</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>t</b>

       <b>product</b> <b>xs</b> <b>ys</b> is the Cartesian product of the sequences <b>xs</b> and <b>ys</b> .

       For every element <b>x</b> of <b>xs</b> and for every element <b>y</b> of <b>ys</b> , the pair <b>(x,</b> <b>y)</b> appears once as an  element  of
       <b>product</b> <b>xs</b> <b>ys</b> .

       The order in which the pairs appear is unspecified.

       The sequences <b>xs</b> and <b>ys</b> are not required to be finite.

       The sequences <b>xs</b> and <b>ys</b> must be persistent.

       <b>Since</b> 4.14

       <u>val</u> <u>map_product</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'c)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b> <b>-&gt;</b> <b>'c</b> <b>t</b>

       The  sequence <b>map_product</b> <b>f</b> <b>xs</b> <b>ys</b> is the image through <b>f</b> of the Cartesian product of the sequences <b>xs</b> and
       <b>ys</b> .

       For every element <b>x</b> of <b>xs</b> and for every element <b>y</b> of <b>ys</b> , the element <b>f</b> <b>x</b> <b>y</b> appears once as an element of
       <b>map_product</b> <b>f</b> <b>xs</b> <b>ys</b> .

       The order in which these elements appear is unspecified.

       The sequences <b>xs</b> and <b>ys</b> are not required to be finite.

       The sequences <b>xs</b> and <b>ys</b> must be persistent.

       <b>map_product</b> <b>f</b> <b>xs</b> <b>ys</b> is equivalent to <b>map</b> <b>(fun</b> <b>(x,</b> <b>y)</b> <b>-&gt;</b> <b>f</b> <b>x</b> <b>y)</b> <b>(product</b> <b>xs</b> <b>ys)</b> .

       <b>Since</b> 4.14

   <b>Splitting</b> <b>a</b> <b>sequence</b> <b>into</b> <b>two</b> <b>sequences</b>
       <u>val</u> <u>unzip</u> : <b>('a</b> <b>*</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>*</b> <b>'b</b> <b>t</b>

       <b>unzip</b> transforms a sequence of pairs into a pair of sequences.

       <b>unzip</b> <b>xs</b> is equivalent to <b>(map</b> <b>fst</b> <b>xs,</b> <b>map</b> <b>snd</b> <b>xs)</b> .

       Querying either of the sequences returned by <b>unzip</b> <b>xs</b> causes <b>xs</b> to be queried.  Therefore, querying  both
       of  them causes <b>xs</b> to be queried twice.  Thus, <b>xs</b> must be persistent and cheap.  If that is not the case,
       use <b>unzip</b> <b>(memoize</b> <b>xs)</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>split</u> : <b>('a</b> <b>*</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>*</b> <b>'b</b> <b>t</b>

       <b>split</b> is an alias for <b>unzip</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>partition_map</u> : <b>('a</b> <b>-&gt;</b> <b>('b,</b> <b>'c)</b> <b>Either.t)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b> <b>*</b> <b>'c</b> <b>t</b>

       <b>partition_map</b> <b>f</b> <b>xs</b> returns a pair of sequences <b>(ys,</b> <b>zs)</b> , where:

       - <b>ys</b> is the sequence of the elements <b>y</b> such that <b>f</b> <b>x</b> <b>=</b> <b>Left</b> <b>y</b> , where <b>x</b> ranges over <b>xs</b> ;

       - <b>zs</b> is the sequence of the elements <b>z</b> such that <b>f</b> <b>x</b> <b>=</b> <b>Right</b> <b>z</b> , where <b>x</b> ranges over <b>xs</b> .

       <b>partition_map</b> <b>f</b> <b>xs</b> is equivalent to a pair of <b>filter_map</b>  <b>Either.find_left</b>  <b>(map</b>  <b>f</b>  <b>xs)</b>  and  <b>filter_map</b>
       <b>Either.find_right</b> <b>(map</b> <b>f</b> <b>xs)</b> .

       Querying  either  of  the  sequences  returned by <b>partition_map</b> <b>f</b> <b>xs</b> causes <b>xs</b> to be queried.  Therefore,
       querying both of them causes <b>xs</b> to be queried twice.  Thus, <b>xs</b> must be persistent and cheap.  If that  is
       not the case, use <b>partition_map</b> <b>f</b> <b>(memoize</b> <b>xs)</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>partition</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>*</b> <b>'a</b> <b>t</b>

       <b>partition</b> <b>p</b> <b>xs</b> returns a pair of the subsequence of the elements of <b>xs</b> that satisfy <b>p</b> and the subsequence
       of the elements of <b>xs</b> that do not satisfy <b>p</b> .

       <b>partition</b> <b>p</b> <b>xs</b> is equivalent to <b>filter</b> <b>p</b> <b>xs,</b> <b>filter</b> <b>(fun</b> <b>x</b> <b>-&gt;</b> <b>not</b> <b>(p</b> <b>x))</b> <b>xs</b> .

       Consuming  both of the sequences returned by <b>partition</b> <b>p</b> <b>xs</b> causes <b>xs</b> to be consumed twice and causes the
       function <b>f</b> to be applied twice to each element of the list.  Therefore,  <b>f</b>  should  be  pure  and  cheap.
       Furthermore, <b>xs</b> should be persistent and cheap.  If that is not the case, use <b>partition</b> <b>p</b> <b>(memoize</b> <b>xs)</b> .

       <b>Since</b> 4.14

   <b>Converting</b> <b>between</b> <b>sequences</b> <b>and</b> <b>dispensers</b>
       A  dispenser  is a representation of a sequence as a function of type <b>unit</b> <b>-&gt;</b> <b>'a</b> <b>option</b> . Every time this
       function is invoked, it returns the next element of the sequence. When there are  no  more  elements,  it
       returns  <b>None</b>  .  A  dispenser  has  mutable internal state, therefore is ephemeral: the sequence that it
       represents can be consumed at most once.

       <u>val</u> <u>of_dispenser</u> : <b>(unit</b> <b>-&gt;</b> <b>'a</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>of_dispenser</b> <b>it</b> is the sequence of the elements produced by  the  dispenser  <b>it</b>  .  It  is  an  ephemeral
       sequence:  it can be consumed at most once. If a persistent sequence is needed, use <b>memoize</b> <b>(of_dispenser</b>
       <b>it)</b> .

       <b>Since</b> 4.14

       <u>val</u> <u>to_dispenser</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       <b>to_dispenser</b> <b>xs</b> is a fresh dispenser on the sequence <b>xs</b> .

       This dispenser has mutable internal state, which is not protected by a lock; so, it must not be  used  by
       several threads concurrently.

       <b>Since</b> 4.14

   <b>Sequences</b> <b>of</b> <b>integers</b>
       <u>val</u> <u>ints</u> : <b>int</b> <b>-&gt;</b> <b>int</b> <b>t</b>

       <b>ints</b> <b>i</b> is the infinite sequence of the integers beginning at <b>i</b> and counting up.

       <b>Since</b> 4.14

OCamldoc                                           2025-06-12                                            <u><a href="../man3o/Seq.3o.html">Seq</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>