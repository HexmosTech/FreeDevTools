<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDL::Tutorial::Animation - Creating animations with SDL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsdl-perl">libsdl-perl_2.548-5build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SDL::Tutorial::Animation - Creating animations with SDL

   <b>CATEGORY</b>
       Tutorials

</pre><h4><b>SYNOPSIS</b></h4><pre>
               # to read this tutorial
               $ perldoc SDL::Tutorial::Animation

               # to create a demo animation program based on this tutorial
               $ perl -MSDL::Tutorial::Animation=sdl_anim.pl -e 1

</pre><h4><b>ANIMATING</b> <b>A</b> <b>RECTANGLE</b></h4><pre>
       Now that you can display a rectangle on the screen, the next step is to animate that rectangle.  As with
       movies, there's no actual motion.  Computer animations are just very very fast slideshows.  The hard work
       is creating nearly identical images in every slide (or frame, in graphics terms).

       Okay, it's not that difficult.

       There is one small difficulty to address, however.  Once you blit one surface onto another, the
       destination is changed permanently.  There's no concept of layers here unless you write it yourself.  If
       you fail to take this into account (and just about everyone does at first), you'll end up with blurry
       graphics moving around on the screen.

       There are two approaches to solve this problem, redrawing the screen on every frame and saving and
       restoring the background for every object drawn.

   <b>Redrawing</b> <b>the</b> <b>Screen</b>
       Since you have to draw the screen in the right order once to start with it's pretty easy to make this
       into a loop and redraw things in the right order for every frame.  Given a SDLx::App object $app, a
       SDL::Rect $rect, and a SDL::Color $color, you only have to create a new SDL::Rect $bg, representing the
       whole of the background surface and a new mapped color $bg_color, representing the background color.  The
       colors need to be mapped to the format of the current display. This is done by SDL::Video::map_RGB.

       my $color = SDL::Video::map_RGB (       $app-&gt;format,       $rect_r,       $rect_g,       $rect_b, );

       my $bg_color = SDL::Video::map_RGB (       $app-&gt;format,
              $bg_r,       $bg_g,       $bg_b, );

       You can write a draw_frame() function as follows:

               sub draw_frame
               {
                       my ($app, %args) = @_;

                       SDL::Video::fill_rect($app,  $args{bg},   $args{bg_color}   );
                       SDL::Video::fill_rect($app, $args{rect}, $args{rect_color} );
                       SDL::Video::update_rects($app, $args{bg} );
               }

       Since you can change the "x" and "y" coordinates of a rect with the x() and y() methods, you can move a
       rectangle across the screen with a loop like this:

               for my $x (0 .. 640)
               {
                       $rect-&gt;x( $x );
                       draw_frame( $app,
                               bg   =&gt; $bg,   bg_color   =&gt; $bg_color,
                               rect =&gt; $rect, rect_color =&gt; $color,
                       );
               }

       If $rect's starting y position is 190 and its height and width are 100, the rectangle (er, square) will
       move across the middle of the screen.

       Provided you can keep track of the proper order in which to redraw rectangles and provided you don't need
       the optimal speed necessary (since blitting every object takes more work than just blitting the portions
       you need), this works quite well.

   <b>Undrawing</b> <b>the</b> <b>Updated</b> <b>Rectangle</b>
       If you need more speed or want to make a different complexity tradeoff, you can take a snapshot of the
       destination rectangle <u>before</u> you blit onto it.  That way, when you need to redraw, you can blit the old
       snapshot back before blitting to the new position.

       <b>Note:</b>  I have no idea how this will work in the face of alpha blending, which, admittedly, I haven't even
       mentioned yet.  If you don't know what this means, forget it.  If you do know what this means and know
       why I'm waving my hands here, feel free to explain what should and what does happen and why.  :)

       With this technique, the frame-drawing subroutine has to be a little more complicated.  Instead of the
       background rect, it needs a rect for the previous position.  It also needs to do two updates (or must
       perform some scary math to figure out the rectangle of the correct size to update().  No thanks!).

               sub undraw_redraw_rect
               {
                       my ($app, %args) = @_;

                       SDL::Video::fill_rect($app, $args{old_rect}, $args{bg_color}   );
                       SDL::Video::fill_rect($app,  $args{rect},     $args{rect_color} );
                       SDL::Video::update_rects($app, $args{old_rect} );
                       SDL::Video::update_rects($app, $args{rect} );
               }

       We'll need to create a new SDL::Rect, $old_rect, that is a duplicate of $rect, at the same position at
       first.  You should already know how to do this.

       As before, the loop to call undraw_redraw_rect() would look something like:

               for my $x (0 .. 640)
               {
                       $rect-&gt;x( $x );

                       undraw_redraw_rect( $app,
                               rect       =&gt; $rect,  old_rect =&gt; $old_rect,
                               rect_color =&gt; $color, bg_color =&gt; $bgcolor,
                       );

                       $old_rect-&gt;x( $x );
               }

       If you run this code, you'll probably notice that it's tremendously faster than the previous version.  It
       may be too fast, where the alternate technique was just fast enough.  There are a couple of good ways to
       set a fixed animation speed regardless of the speed of the processor and graphics hardware (provided
       they're good enough, which is increasingly often the case), and we'll get to them soon.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       SDL::Tutorial::Drawing
           basic drawing with SDL Perl

       SDL::Tutorial::Images
           animating images

</pre><h4><b>AUTHOR</b></h4><pre>
       chromatic, &lt;<a href="mailto:chromatic@wgz.org">chromatic@wgz.org</a>&gt;

       Written for and maintained by the Perl SDL project, &lt;<a href="http://sdl.perl.org/">http://sdl.perl.org/</a>&gt;.  See "AUTHORS" in SDL.

</pre><h4><b>BUGS</b></h4><pre>
       No known bugs.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright  (c)  2003  - 2004, chromatic.  All rights reserved.  This module is distributed under the same
       terms as Perl itself, in the hope that it is useful but certainly under no guarantee.

perl v5.40.0                                       2024-10-20                <u>pods::SDL::Tutorial::<a href="../man3pm/Animation.3pm.html">Animation</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>