<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gmpy2 - gmpy2 Documentation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/python-gmpy2-common">python-gmpy2-common_2.2.1-2build2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gmpy2 - gmpy2 Documentation

       gmpy2  is  a  C-coded  Python  extension  module  that supports multiple-precision arithmetic.  It is the
       successor to the original gmpy module (supported only the GMP library). gmpy2 adds support for  the  MPFR
       (correctly  rounded  real  floating-point  arithmetic)  and MPC (correctly rounded complex floating-point
       arithmetic) libraries.

       The following libraries are supported:

       • GMP for integer and rational arithmetic (<u>https://gmplib.org</u>)

       • MPFR (<u>https://www.mpfr.org</u>)

       • MPC (<u>https://www.multiprecision.org/mpc/</u>)

       • Generalized Lucas sequences and primality tests are based on the following code:

            • mpz_lucas: <u>https://sourceforge.net/projects/mpzlucas/</u>

            • mpz_prp: <u>https://sourceforge.net/projects/mpzprp/</u>

</pre><h4><b>CONTENTS</b></h4><pre>
   <b>Overview</b>
       The <u>mpz</u> and <u>mpq</u> types support arbitrary precision integers and rationals  via  the  GMP  library.   These
       types  should be drop-in replacements for Python's <b>int</b>'s and <b>Fraction</b>'s, but are significantly faster for
       large values.   The cutover point for performance varies, but can be as low as 20 to 40 digits.  All  the
       special integer functions in the GMP are supported.

       <b>WARNING:</b>
          gmpy2 can crash the Python interpreter in case of memory allocation failure.  To mitigate this feature
          of  memory  management  in  the  GMP  library, you should estimate the size of all results and prevent
          calculations that can exaust available memory.

       The <u>mpfr</u> and <u>mpc</u> types provide  support  for  correctly  rounded  multiple  precision  real  and  complex
       arithmetic  via  the  MPFR  and  MPC  libraries.  The <u>context</u> type is used to control precision, rounding
       modes, and exceptional conditions.  For example, division by zero can either return an Infinity or  raise
       an  exception.   It  is  possible to specify different precision and rounding modes for both the real and
       imaginary components of an <u>mpc</u>.  The default precision is 53 bits --- just same as for Python's <b>float</b> and
       <b>complex</b> types.

       Operator  overloading  is  fully  supported.   Coversion  from  native  Python  types  is  optimized  for
       performance.

   <b>Installation</b>
       gmpy2  requires CPython 3.7 or above.  Pre-compiled binary wheels are available on PyPI.  You can install
       latest release with pip:

          pip install gmpy2

       or some specific version with:

          pip install gmpy2==2.1.5

   <b>From</b> <b>Sources</b>
       If pre-compiled binary wheels aren't available for your platform, the pip will fallback  to  installation
       from  sources.   In  this  case  you  will  need  to  have required libraries (GMP, MPFR and MPC) already
       installed on your system, along with the include files for those libraries.   On Debian you  can  install
       them systed-wide with:

          sudo apt install libgmp-dev libmpfr-dev libmpc-dev

       <b>TIP:</b>
          On Windows we recommend using <u>MSYS2</u> to build the gmpy2 from sources.  To install required dependencies
          before, run:

              pacman -S gcc gmp-devel mpfr-devel mpc-devel python-setuptools python-pip

       If  you  are  a developer or like to get the latest updates as they come, be sure to install from the git
       repository and include required extra dependencies, for example the optional "tests" list, which  include
       packages required for testing:

          git clone git://github.com/aleaxit/gmpy.git
          cd gmpy
          pip install -e .[tests]

       Next you may want to run full set of unit tests to make sure everything works:

          pytest test/

   <b>Tutorial</b>
       Start by importing the contents of the package with:

          &gt;&gt;&gt; from gmpy2 import *

       <b>NOTE:</b>
          The  use  of <b>from</b> <b>gmpy2</b> <b>import</b> <b>*</b> is not recommended in real code.  The names in gmpy2 have been chosen
          to avoid conflict with Python's builtin names but gmpy2 does use names that may  conflict  with  other
          modules  or  variable  names.   In  normal  usage  you’ll probably only want to import the classes and
          functions that you actually need.

       Lets look first on some examples of arbitrary precision arithmetic with integer and rational types:

          &gt;&gt;&gt; <a href="../man99/mpz.99.html">mpz</a>(99) * 43
          <a href="../man4257/mpz.4257.html">mpz</a>(4257)
          &gt;&gt;&gt; pow(<a href="../man99/mpz.99.html">mpz</a>(99), 37, 59)
          <a href="../man18/mpz.18.html">mpz</a>(18)
          &gt;&gt;&gt; <a href="../man99/isqrt.99.html">isqrt</a>(99)
          <a href="../man9/mpz.9.html">mpz</a>(9)
          &gt;&gt;&gt; <a href="../man99/isqrt_rem.99.html">isqrt_rem</a>(99)
          (<a href="../man9/mpz.9.html">mpz</a>(9), <a href="../man18/mpz.18.html">mpz</a>(18))
          &gt;&gt;&gt; gcd(123, 27)
          <a href="../man3/mpz.3.html">mpz</a>(3)
          &gt;&gt;&gt; lcm(123, 27)
          <a href="../man1107/mpz.1107.html">mpz</a>(1107)
          &gt;&gt;&gt; (<a href="../man123/mpz.123.html">mpz</a>(123) + 12) / 5
          mpfr('27.0')
          &gt;&gt;&gt; (<a href="../man123/mpz.123.html">mpz</a>(123) + 12) // 5
          <a href="../man27/mpz.27.html">mpz</a>(27)
          &gt;&gt;&gt; (<a href="../man123/mpz.123.html">mpz</a>(123) + 12) / 5.0
          mpfr('27.0')
          &gt;&gt;&gt; mpz('123') + 1
          <a href="../man124/mpz.124.html">mpz</a>(124)
          &gt;&gt;&gt; 10 - <a href="../man1/mpz.1.html">mpz</a>(1)
          <a href="../man9/mpz.9.html">mpz</a>(9)
          &gt;&gt;&gt; <a href="../man17/is_prime.17.html">is_prime</a>(17)
          True
          &gt;&gt;&gt; mpz('1_000_000')
          <a href="../man1000000/mpz.1000000.html">mpz</a>(1000000)
          &gt;&gt;&gt; mpq(3, 7)/7
          mpq(3,49)
          &gt;&gt;&gt; mpq(45, 3) * mpq(11, 8)
          mpq(165,8)
          &gt;&gt;&gt; mpq(1, 7) * 11
          mpq(11,7)

       But gmpy2 also supports correctly rounded multiple precision real and complex arithmetic.  The  following
       example shows how to control precision settings and rounding modes:

          &gt;&gt;&gt; mpfr('1.2')
          mpfr('1.2')
          &gt;&gt;&gt; mpfr(float('1.2'))
          mpfr('1.2')
          &gt;&gt;&gt; ctx = get_context()
          &gt;&gt;&gt; ctx.precision
          53
          &gt;&gt;&gt; ctx.precision = 100
          &gt;&gt;&gt; mpfr('1.2')
          mpfr('1.2000000000000000000000000000006',100)
          &gt;&gt;&gt; mpfr(float('1.2'))
          mpfr('1.1999999999999999555910790149937',100)
          &gt;&gt;&gt; ctx.precision = 53
          &gt;&gt;&gt; ctx.round = RoundUp
          &gt;&gt;&gt; const_pi()
          mpfr('3.1415926535897936')
          &gt;&gt;&gt; ctx.round = RoundToNearest
          &gt;&gt;&gt; const_pi()
          mpfr('3.1415926535897931')

       You  have  seen,  that if the precision is changed, then <b>mpfr(float('1.2'))</b> differs from <b>mpfr('1.2')</b>.  To
       take advantage of the higher precision provided by the <u>mpfr</u> type, always pass constants as strings.

       Floating point contexts also are used to control exceptional conditions.  For example, division  by  zero
       can either return a floating-point positive infinity (default) or raise an exception.

          &gt;&gt;&gt; ctx.divzero
          False
          &gt;&gt;&gt; <a href="../man1/mpfr.1.html">mpfr</a>(1)/0
          mpfr('inf')
          &gt;&gt;&gt; ctx.trap_divzero = True
          &gt;&gt;&gt; <a href="../man1/mpfr.1.html">mpfr</a>(1)/0
          Traceback (most recent call last):
          ...
          gmpy2.DivisionByZeroError: division by zero
          &gt;&gt;&gt; ctx.divzero
          True

       Exceptions  are  normally  raised  in  Python when the result of a real operation is not defined over the
       reals; for example, <b>math.sqrt(-2)</b> will raise a  <b>ValueError</b>  exception.   The  default  context  in  gmpy2
       implements similar behavior, but by setting <u>allow_complex</u> flag, complex results will be returned.

          &gt;&gt;&gt; sqrt(mpfr(-2))
          mpfr('nan')
          &gt;&gt;&gt; ctx.allow_complex = True
          &gt;&gt;&gt; sqrt(mpfr(-2))
          mpc('0.0+1.4142135623730951j')

       Contexts  can also be used as context managers in conjunction with Python's <b>with</b> statement to temporarily
       change the current context settings for a block of code.

          &gt;&gt;&gt; print(const_pi())
          3.1415926535897931
          &gt;&gt;&gt; with context(precision=100) as ctx:
          ...   print(const_pi())
          ...   ctx.precision += 20
          ...   print(const_pi())
          ...
          3.1415926535897932384626433832793
          3.1415926535897932384626433832795028847
          &gt;&gt;&gt; print(const_pi())
          3.1415926535897931

       It's possible to set different precision settings for real and imaginary components.

          &gt;&gt;&gt; ctx = get_context()
          &gt;&gt;&gt; ctx.real_prec = 60
          &gt;&gt;&gt; ctx.imag_prec = 70
          &gt;&gt;&gt; sqrt(mpc('1+2j'))
          mpc('1.272019649514068965+0.78615137775742328606947j',(60,70))

       All gmpy2 numeric types support Python's "new style" string  formatting  available  in  <u>formatted</u>  <u>string</u>
       <u>literals</u>  or  with <b>str.format()</b>; see <u>Format</u> <u>Specification</u> <u>Mini-Language</u> for a description of the standard
       formatting syntax.  The precision value optionally can be followed by the  rounding  mode  type  ('U'  to
       round toward plus infinity, 'D' to round toward minus infinity, 'Y' to round away from zero, 'Z' to round
       toward zero and 'N' - round to the nearest value.

          &gt;&gt;&gt; a = mpfr("1.23456")
          &gt;&gt;&gt; "{0:15.3f}".format(a)
          '          1.235'
          &gt;&gt;&gt; "{0:15.3Uf}".format(a)
          '          1.235'
          &gt;&gt;&gt; "{0:15.3Df}".format(a)
          '          1.234'
          &gt;&gt;&gt; "{0:.3Df}".format(a)
          '1.234'
          &gt;&gt;&gt; "{0:+.3Df}".format(a)
          '+1.234'

   <b>Integers</b>
   <b>mpz</b> <b>type</b>
       <b>class</b> <b>gmpy2.mpz(n=0,</b> <b>/)</b>

       <b>class</b> <b>gmpy2.mpz(s,</b> <b>/,</b> <b>base=0)</b>
              Return  an immutable integer constructed from a numeric value n (truncating n to its integer part)
              or a string s made of digits in the given base.  Every input, that is accepted  by  the  <b>int</b>  type
              constructor is also accepted.

              The  base  may  vary from 2 to 62, or if base is 0, then binary, octal, or hexadecimal strings are
              recognized by leading '0b', '0o', or '0x' characters (case is ignored), otherwise  the  string  is
              assumed  to  be  decimal.   For  bases  up  to  36,  digits  case is ignored.  For bases 37 to 62,
              upper-case letter represent the usual 10..35 range,  while  lower-case  letter  represent  36..61.
              Optionally  the  string  can  be  preceded  by  '+'  or '-'.  White space and underscore is simply
              ignored.

              <b>__format__(fmt)</b> <b>-&gt;</b> <b>str</b>
                     Return a Python string by formatting <u>mpz</u> 'x' using the format string 'fmt'. A valid  format
                     string consists of:
                        optional alignment code:
                            '&lt;' -&gt; left shifted in field '&gt;' -&gt; right shifted in field '^' -&gt; centered in field

                        optional leading sign code:
                            '+'  -&gt;  always display leading sign '-' -&gt; only display minus sign ' ' -&gt; minus for
                            negative values, space for positive values

                        optional base indicator
                            '#' -&gt; precede binary, octal, or hex with 0b, 0o or 0x

                        optional width

                        optional conversion code:
                            'd' -&gt; decimal format 'b' -&gt; binary format 'o' -&gt; octal format 'x' -&gt; hex format 'X'
                            -&gt; upper-case hex format

                     The default format is 'd'.

              <b>as_integer_ratio()</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
                     Return a pair of integers, whose ratio is exactly equal to the original number.  The  ratio
                     is in lowest terms and has a positive denominator.

              <b>bit_clear(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
                     Return a copy of x with the n-th bit cleared.

              <b>bit_count()</b> <b>-&gt;</b> <b>int</b>
                     Return the number of 1-bits set in abs(x).

              <b>bit_flip(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
                     Return a copy of x with the n-th bit inverted.

              <b>bit_length()</b> <b>-&gt;</b> <b>int</b>
                     Return  the  number  of  significant  bits  in  the  radix-2  representation  of  x.  Note:
                     <a href="../man0/mpz.0.html">mpz</a>(0).bit_length() returns 0.

              <b>bit_scan0(n=0,</b> <b>/)</b> <b>-&gt;</b> <b>int</b> <b>|</b> <b>None</b>
                     Return the index of the first 0-bit of x with index &gt;= n. n &gt;= 0.  If  there  are  no  more
                     0-bits in x at or above index n (which can only happen for x&lt;0, assuming an infinitely long
                     2's complement format), then <b>None</b> is returned.

              <b>bit_scan1(n=0,</b> <b>/)</b> <b>-&gt;</b> <b>int</b> <b>|</b> <b>None</b>
                     Return  the  index  of  the first 1-bit of x with index &gt;= n. n &gt;= 0.  If there are no more
                     1-bits in x at or above index n (which can only happen for  x&gt;=0,  assuming  an  infinitely
                     long 2's complement format), then <b>None</b> is returned.

              <b>bit_set(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
                     Return a copy of x with the n-th bit set.

              <b>bit_test(n,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
                     Return the value of the n-th bit of x.

              <b>conjugate()</b> <b>-&gt;</b> <u>mpz</u>
                     Return  the  conjugate  of  x  (which is just a new reference to x since x is not a complex
                     number).

              <b>digits(base=10,</b> <b>/)</b> <b>-&gt;</b> <b>str</b>
                     Return Python string representing x in the given base. Values for base can range between  2
                     to 62. A leading '-' is present if x&lt;0 but no leading '+' is present if x&gt;=0.

              <b>from_bytes(bytes,</b> <b>byteorder='big',</b> <b>*,</b> <b>signed=False)</b> <b>-&gt;</b> <u>mpz</u>
                     Return the integer represented by the given array of bytes.

                        <b>bytes</b>  Holds the array of bytes to convert.  The argument must either support the buffer
                               protocol  or  be  an  iterable  object  producing bytes.  <b>bytes</b> and <b>bytearray</b> are
                               examples of built-in objects that support the buffer protocol.

                        <b>byteorder</b>
                               The byte order used to represent the integer.  If byteorder is  'big',  the  most
                               significant  byte  is  at  the  beginning  of  the  byte  array.  If byteorder is
                               'little', the most significant byte is at the end of the byte array.  To  request
                               the  native  byte  order  of the host system, use <b>sys.byteorder</b> as the byte order
                               value.

                        <b>signed</b> Indicates whether two's complement is used to represent the integer.

              <b>is_congruent(y,</b> <b>m,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
                     Returns <b>True</b> if x is congruent to y modulo m, else return <b>False</b>.

              <b>is_divisible(d,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
                     Returns <b>True</b> if x is divisible by d, else return <b>False</b>.

              <b>is_even()</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is even, <b>False</b> otherwise.

              <b>is_odd()</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is odd, <b>False</b> otherwise.

              <b>is_power()</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is a perfect power (there exists a y and an n &gt; 1, such that x=y**n), else
                     return <b>False</b>.

              <b>is_prime(n=25,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is <u>probably</u> prime, else <b>False</b> if x is definitely composite. x  is  checked
                     for small divisors and up to n Miller-Rabin tests are performed.

              <b>is_probab_prime(n=25,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
                     Return 2 if x is definitely prime, 1 if x is probably prime, or return 0 if x is definitely
                     non-prime.   x  is checked for small divisors and up to n Miller-Rabin tests are performed.
                     Reasonable values of n are between 15 and 50.

              <b>is_square()</b> <b>-&gt;</b> <b>bool</b>
                     Returns <b>True</b> if x is a perfect square, else return <b>False</b>.

              <b>num_digits(base=10,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
                     Return length of string representing the absolute value of x in the given base. Values  for
                     base can range between 2 and 62. The value returned may be 1 too large.

              <b>to_bytes(length=1,</b> <b>byteorder='big',</b> <b>*,</b> <b>signed=False)</b> <b>-&gt;</b> <b>bytes</b>
                     Return an array of bytes representing an integer.

                        <b>length</b> Length of bytes object to use.  An <b>OverflowError</b> is raised if the integer is  not
                               representable with the given number of bytes.

                        <b>byteorder</b>
                               The  byte  order  used to represent the integer.  If byteorder is 'big', the most
                               significant byte is at  the  beginning  of  the  byte  array.   If  byteorder  is
                               'little',  the most significant byte is at the end of the byte array.  To request
                               the native byte order of the host system, use <b>sys.byteorder</b>  as  the  byte  order
                               value.

                        <b>signed</b> Determines  whether two's complement is used to represent the integer.  If signed
                               is <b>False</b> and a negative integer is given, an <b>OverflowError</b> is raised.

              <b>denominator</b>
                     the denominator of a rational number in lowest terms

              <b>imag</b>   the imaginary part of a complex number

              <b>numerator</b>
                     the numerator of a rational number in lowest terms

              <b>real</b>   the real part of a complex number

   <b>mpz</b> <b>Functions</b>
       <b>gmpy2.bincoef(n,</b> <b>k,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the binomial coefficient ('n choose k'). k &gt;= 0.

       <b>gmpy2.bit_clear(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return a copy of x with the n-th bit cleared.

       <b>gmpy2.bit_count(x,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
              Return the number of 1-bits set in abs(x).

       <b>gmpy2.bit_flip(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return a copy of x with the n-th bit inverted.

       <b>gmpy2.bit_length(x,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
              Return the number of significant bits in the radix-2  representation  of  x.  Note:  <a href="../man0/bit_length.0.html">bit_length</a>(0)
              returns 0.

       <b>gmpy2.bit_mask(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return an <u>mpz</u> exactly n bits in length with all bits set.

       <b>gmpy2.bit_scan0(x,</b> <b>n=0,</b> <b>/)</b> <b>-&gt;</b> <b>int</b> <b>|</b> <b>None</b>
              Return  the index of the first 0-bit of x with index &gt;= n. n &gt;= 0.  If there are no more 0-bits in
              x at or above index n (which can only happen for x&lt;0, assuming an infinitely long  2's  complement
              format), then <b>None</b> is returned.

       <b>gmpy2.bit_scan1(x,</b> <b>n=0,</b> <b>/)</b> <b>-&gt;</b> <b>int</b> <b>|</b> <b>None</b>
              Return  the index of the first 1-bit of x with index &gt;= n. n &gt;= 0.  If there are no more 1-bits in
              x at or above index n (which can only happen for x&gt;=0, assuming an infinitely long 2's  complement
              format), then <b>None</b> is returned.

       <b>gmpy2.bit_set(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return a copy of x with the n-th bit set.

       <b>gmpy2.bit_test(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return the value of the n-th bit of x.

       <b>gmpy2.c_div(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return  the quotient of x divided by y. The quotient is rounded towards +Inf (ceiling rounding). x
              and y must be integers.

       <b>gmpy2.c_div_2exp(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Returns the quotient of x  divided  by  2**n.  The  quotient  is  rounded  towards  +Inf  (ceiling
              rounding). x must be an integer. n must be &gt;0.

       <b>gmpy2.c_divmod(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
              Return the quotient and remainder of x divided by y. The quotient is rounded towards +Inf (ceiling
              rounding) and the remainder will have the opposite sign of y. x and y must be integers.

       <b>gmpy2.c_divmod_2exp(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
              Return  the  quotient  and  remainder  of  x divided by 2**n. The quotient is rounded towards +Inf
              (ceiling rounding) and the remainder will be negative. x must be an integer. n must be &gt;0.

       <b>gmpy2.c_mod(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the remainder of x divided by y. The remainder will have the opposite sign of y.  x  and  y
              must be integers.

       <b>gmpy2.c_mod_2exp(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the remainder of x divided by 2**n. The remainder will be negative. x must be an integer. n
              must be &gt;0.

       <b>gmpy2.comb(n,</b> <b>k,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the number of combinations of 'n things, taking k at a time'. k &gt;= 0. Same as bincoef(n, k)

       <b>gmpy2.divexact(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the quotient of x divided by y. Faster than standard division but requires the remainder is
              zero!

       <b>gmpy2.divm(a,</b> <b>b,</b> <b>m,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return x such that b*x == a mod m. Raises a <b>ZeroDivisionError</b> exception if no such value x exists.

       <b>gmpy2.double_fac(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the exact double factorial (n!!) of n. The double factorial is defined as n*(n-2)*(n-4)...

       <b>gmpy2.f_div(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return  the  quotient  of x divided by y. The quotient is rounded towards -Inf (floor rounding). x
              and y must be integers.

       <b>gmpy2.f_div_2exp(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the quotient of x divided by 2**n. The quotient is rounded towards -Inf (floor rounding). x
              must be an integer. n must be &gt;0.

       <b>gmpy2.f_divmod(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
              Return the quotient and remainder of x divided by y. The quotient is rounded towards  -Inf  (floor
              rounding) and the remainder will have the same sign as y. x and y must be integers.

       <b>gmpy2.f_divmod_2exp(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
              Return  quotient  and  remainder  after  dividing  x by 2**n. The quotient is rounded towards -Inf
              (floor rounding) and the remainder will be positive. x must be an integer. n must be &gt;0.

       <b>gmpy2.f_mod(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the remainder of x divided by y. The remainder will have the same sign as y. x and  y  must
              be integers.

       <b>gmpy2.f_mod_2exp(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return  remainder  of  x  divided by 2**n. The remainder will be positive. x must be an integer. n
              must be &gt;0.

       <b>gmpy2.fac(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the exact factorial of n.

              See factorial(n) to get the floating-point approximation.

       <b>gmpy2.fib(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the n-th Fibonacci number.

       <b>gmpy2.fib2(n,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
              Return a 2-tuple with the (n-1)-th and n-th Fibonacci numbers.

       <b>gmpy2.gcd(*integers,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the greatest common divisor of integers.

       <b>gmpy2.gcdext(a,</b> <b>b,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
              Return a 3-element tuple (g,s,t) such that g == gcd(a,b) and g == a*s + b*t.

       <b>gmpy2.hamdist(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
              Return the Hamming distance (number of bit-positions where the bits differ) between integers x and
              y.

       <b>gmpy2.invert(x,</b> <b>m,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return y such that x*y == 1 modulo m. Raises <b>ZeroDivisionError</b> if no inverse exists.

       <b>gmpy2.iroot(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <b>bool]</b>
              Return the integer n-th root of x and boolean value that is <b>True</b> iff the root is exact. x &gt;= 0.  n
              &gt; 0.

       <b>gmpy2.iroot_rem(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
              Return  a 2-element tuple (y,r), such that y is the integer n-th root of x and x=y**n + r. x &gt;= 0.
              n &gt; 0.

       <b>gmpy2.is_congruent(x,</b> <b>y,</b> <b>m,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Returns <b>True</b> if x is congruent to y modulo m, else return <b>False</b>.

       <b>gmpy2.is_divisible(x,</b> <b>d,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Returns <b>True</b> if x is divisible by d, else return <b>False</b>.

       <b>gmpy2.is_even(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if x is even, <b>False</b> otherwise.

       <b>gmpy2.is_odd(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if x is odd, <b>False</b> otherwise.

       <b>gmpy2.is_power(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if x is a perfect power (there exists a y and an n &gt; 1, such that x=y**n), else return
              <b>False</b>.

       <b>gmpy2.is_prime(x,</b> <b>n=25,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if x is <u>probably</u> prime, else <b>False</b> if x is definitely  composite.  x  is  checked  for
              small divisors and up to n Miller-Rabin tests are performed.

       <b>gmpy2.is_probab_prime(x,</b> <b>n=25,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
              Return  2  if  x  is  definitely  prime,  1 if x is probably prime, or return 0 if x is definitely
              non-prime.  x is checked for small  divisors  and  up  to  n  Miller-Rabin  tests  are  performed.
              Reasonable values of n are between 15 and 50.

       <b>gmpy2.is_square(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Returns <b>True</b> if x is a perfect square, else return <b>False</b>.

       <b>gmpy2.isqrt(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the integer square root of a non-negative integer x.

       <b>gmpy2.isqrt_rem(x,</b> <b>/)</b>
              Return a 2-element tuple (s,t) such that s=isqrt(x) and t=x-s*s.  x &gt;=0.

       <b>gmpy2.jacobi(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the Jacobi symbol (x|y). y must be odd and &gt;0.

       <b>gmpy2.kronecker(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the Kronecker-Jacobi symbol (x|y).

       <b>gmpy2.lcm(*integers,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the lowest common multiple of integers.

       <b>gmpy2.legendre(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the Legendre symbol (x|y). y is assumed to be an odd prime.

       <b>gmpy2.lucas(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the n-th Lucas number.

       <b>gmpy2.lucas2(n,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
              Return a 2-tuple with the (n-1)-th and n-th Lucas numbers.

       <b>gmpy2.mpz_random(random_state,</b> <b>int,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return uniformly distributed random integer between 0 and n-1.

       <b>gmpy2.mpz_rrandomb(random_state,</b> <b>bit_count,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return  a  random integer between 0 and 2**bit_count-1 with long sequences of zeros and one in its
              binary representation.

       <b>gmpy2.mpz_urandomb(random_state,</b> <b>bit_count,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return uniformly distributed random integer between 0 and 2**bit_count-1.

       <b>gmpy2.multi_fac(n,</b> <b>m,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the exact m-multi factorial of n. The m-multifactorial is defined as n*(n-m)*(n-2m)...

       <b>gmpy2.next_prime(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the next <u>probable</u> prime number &gt; x.

       <b>gmpy2.num_digits(x,</b> <b>base=10,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
              Return length of string representing the absolute value of x in the given base. Values   for  base
              can range between 2 and 62. The value returned may be 1 too large.

       <b>gmpy2.pack(lst,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Pack  a  list of integers lst into a single <u>mpz</u> by concatenating each integer element of lst after
              padding to length n bits. Raises an error if any integer is negative or greater  than  n  bits  in
              length.

       <b>gmpy2.popcount(x,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
              Return  the  number of 1-bits set in x. If x&lt;0, the number of 1-bits is infinite so -1 is returned
              in that case.

       <b>gmpy2.powmod(x,</b> <b>y,</b> <b>m,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return (x**y) mod m. Same as the three argument version of Python's built-in <b>pow</b>, but converts all
              three arguments to <u>mpz</u>.

       <b>gmpy2.powmod_exp_list(base,</b> <b>exp_lst,</b> <b>mod,</b> <b>/)</b> <b>-&gt;</b> <b>list[</b><u>mpz</u><b>,</b> <b>...]</b>
              Returns list(powmod(base, i, mod) for i in exp_lst). Will always release the GIL. (Experimental in
              gmpy2 2.1.x).

       <b>gmpy2.powmod_base_list(base_lst,</b> <b>exp,</b> <b>mod,</b> <b>/)</b> <b>-&gt;</b> <b>list[</b><u>mpz</u><b>,</b> <b>...]</b>
              Returns list(powmod(i, exp, mod) for i in base_lst). Will always release the GIL. (Experimental in
              gmpy2 2.1.x).

       <b>gmpy2.powmod_sec(x,</b> <b>y,</b> <b>m,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return (x**y) mod m. Calculates x ** y (mod m) but using a constant time algorithm to  reduce  the
              risk of side channel attacks. y must be an integer &gt;0. m must be an odd integer.

       <b>gmpy2.prev_prime(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return  the  previous  <u>probable</u>  prime  number  &lt; x.  Only present when compiled with GMP 6.3.0 or
              later.

       <b>gmpy2.primorial(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the product of all positive prime numbers less than or equal to n.

       <b>gmpy2.remove(x,</b> <b>f,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
              Return a 2-element tuple (y,m) such that x=y*(f**m) and f does not divide y. Remove the  factor  f
              from x as many times as possible. m is the multiplicity f in x. f &gt; 1.

       <b>gmpy2.t_div(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return  the  quotient  of  x  divided  by  y.  The  quotient is rounded towards 0. x and y must be
              integers.

       <b>gmpy2.t_div_2exp(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the quotient of x divided by 2**n. The quotient is rounded  towards  zero  (truncation).  n
              must be &gt;0.

       <b>gmpy2.t_divmod(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
              Return  the  quotient  and  remainder  of  x  divided  by  y. The quotient is rounded towards zero
              (truncation) and the remainder will have the same sign as x. x and y must be integers.

       <b>gmpy2.t_divmod_2exp(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
              Return the quotient and remainder of x divided by 2**n.  The  quotient  is  rounded  towards  zero
              (truncation) and the remainder will have the same sign as x. x must be an integer. n must be &gt;0.

       <b>gmpy2.t_mod(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return  the  remainder of x divided by y. The remainder will have the same sign as x. x and y must
              be integers.

       <b>gmpy2.t_mod_2exp(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the remainder of x divided by 2**n. The remainder will have the same sign as x. x  must  be
              an integer. n must be &gt;0.

       <b>gmpy2.unpack(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <b>list</b>
              Unpack  an  integer x into a list of n-bit values. Equivalent to repeated division by 2**n. Raises
              error if x is negative.

   <b>Integers</b> <b>(Advanced</b> <b>topics)</b>
       gmpy2 provides access to an experimental integer type called <u>xmpz</u>. The <u>xmpz</u> type  is  a  mutable  integer
       type.  In-place  operations  (+=,  //=,  etc.) modify the original object and do not create a new object.
       Instances of <u>xmpz</u> cannot be used as dictionary keys.

          &gt;&gt;&gt; from gmpy2 import xmpz
          &gt;&gt;&gt; a = <a href="../man123/xmpz.123.html">xmpz</a>(123)
          &gt;&gt;&gt; b = a
          &gt;&gt;&gt; a += 1
          &gt;&gt;&gt; a
          <a href="../man124/xmpz.124.html">xmpz</a>(124)
          &gt;&gt;&gt; b
          <a href="../man124/xmpz.124.html">xmpz</a>(124)

       The ability to change an <u>xmpz</u> object in-place allows for efficient and rapid bit manipulation.

       Individual bits can be set or cleared:

          &gt;&gt;&gt; a[10]=1
          &gt;&gt;&gt; a
          <a href="../man1148/xmpz.1148.html">xmpz</a>(1148)

       Slice notation is supported. The bits referenced by a slice can be either 'read from' or 'written to'. To
       clear a slice of bits, use a source value of 0. In 2s-complement format, 0 is represented by an arbitrary
       number of 0-bits. To set a slice of bits, use a source value  of  ~0.  The  <u>tilde</u>  operator  inverts,  or
       complements  the  bits  in  an integer. (~0 is -1 so you can also use -1.) In 2s-complement format, -1 is
       represented by an arbitrary number of 1-bits.

       If a value for <u>stop</u> is specified in a slice assignment and the actual bit-length of the <u>xmpz</u> is less than
       <u>stop</u>, then the destination <u>xmpz</u> is logically padded with 0-bits to length <u>stop</u>.

          &gt;&gt;&gt; a=<a href="../man0/xmpz.0.html">xmpz</a>(0)
          &gt;&gt;&gt; a[8:16] = ~0
          &gt;&gt;&gt; bin(a)
          '0b1111111100000000'
          &gt;&gt;&gt; a[4:12] = ~a[4:12]
          &gt;&gt;&gt; bin(a)
          '0b1111000011110000'

       Bits can be reversed:

          &gt;&gt;&gt; a = <a href="../man1148/xmpz.1148.html">xmpz</a>(1148)
          &gt;&gt;&gt; bin(a)
          '0b10001111100'
          &gt;&gt;&gt; a[::] = a[::-1]
          &gt;&gt;&gt; bin(a)
          '0b111110001'

       The <u>iter_bits()</u> method returns a generator that returns True or False for each bit position. The  methods
       <u>iter_clear()</u>, and <u>iter_set()</u> return generators that return the bit positions that are 1 or 0. The methods
       support  arguments  <u>start</u>  and  <u>stop</u> that define the beginning and ending bit positions that are used. To
       mimic the behavior of slices. the bit positions checked include <u>start</u> but the last  position  checked  is
       <u>stop</u> - 1.

          &gt;&gt;&gt; a=<a href="../man117/xmpz.117.html">xmpz</a>(117)
          &gt;&gt;&gt; bin(a)
          '0b1110101'
          &gt;&gt;&gt; list(a.iter_bits())
          [True, False, True, False, True, True, True]
          &gt;&gt;&gt; list(a.iter_clear())
          [1, 3]
          &gt;&gt;&gt; list(a.iter_set())
          [0, 2, 4, 5, 6]
          &gt;&gt;&gt; list(a.iter_bits(stop=12))
          [True, False, True, False, True, True, True, False, False, False, False, False]

       The following program uses the Sieve of Eratosthenes to generate a list of prime numbers.

          import time
          import gmpy2

          def sieve(limit=1000000):
              '''Returns a generator that yields the prime numbers up to limit.'''

              # Increment by 1 to account for the fact that slices  do not include
              # the last index value but we do want to include the last value for
              # calculating a list of primes.
              sieve_limit = gmpy2.isqrt(limit) + 1
              limit += 1

              # Mark bit positions 0 and 1 as not prime.
              bitmap = <a href="../man3/gmpy2.xmpz.3.html">gmpy2.xmpz</a>(3)

              # Process 2 separately. This allows us to use p+p for the step size
              # when sieving the remaining primes.
              bitmap[4 : limit : 2] = -1

              # Sieve the remaining primes.
              for p in bitmap.iter_clear(3, sieve_limit):
                  bitmap[p*p : limit : p+p] = -1

              return bitmap.iter_clear(2, limit)

          if __name__ == "__main__":
              start = time.time()
              result = list(sieve())
              print(time.time() - start)
              print(len(result))

   <b>The</b> <b>xmpz</b> <b>type</b>
       <b>class</b> <b>gmpy2.xmpz(n=0,</b> <b>/)</b>

       <b>class</b> <b>gmpy2.xmpz(s,</b> <b>/,</b> <b>base=0)</b>
              Return  a  mutable  integer constructed from a numeric value n or a string s made of digits in the
              given base.  Every input, that is accepted by the <u>mpz</u> type constructor is also accepted.

              Note: This type can be faster when used for augmented assignment (+=, -=, etc), but  <u>xmpz</u>  objects
              cannot be used as dictionary keys.

              <b>__format__(fmt)</b> <b>-&gt;</b> <b>str</b>
                     Return  a Python string by formatting <u>mpz</u> 'x' using the format string 'fmt'. A valid format
                     string consists of:
                        optional alignment code:
                            '&lt;' -&gt; left shifted in field '&gt;' -&gt; right shifted in field '^' -&gt; centered in field

                        optional leading sign code:
                            '+' -&gt; always display leading sign '-' -&gt; only display minus sign ' ' -&gt;  minus  for
                            negative values, space for positive values

                        optional base indicator
                            '#' -&gt; precede binary, octal, or hex with 0b, 0o or 0x

                        optional width

                        optional conversion code:
                            'd' -&gt; decimal format 'b' -&gt; binary format 'o' -&gt; octal format 'x' -&gt; hex format 'X'
                            -&gt; upper-case hex format

                     The default format is 'd'.

              <b>bit_clear(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
                     Return a copy of x with the n-th bit cleared.

              <b>bit_count()</b> <b>-&gt;</b> <b>int</b>
                     Return the number of 1-bits set in abs(x).

              <b>bit_flip(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
                     Return a copy of x with the n-th bit inverted.

              <b>bit_length()</b> <b>-&gt;</b> <b>int</b>
                     Return  the  number  of  significant  bits  in  the  radix-2  representation  of  x.  Note:
                     <a href="../man0/mpz.0.html">mpz</a>(0).bit_length() returns 0.

              <b>bit_scan0(n=0,</b> <b>/)</b> <b>-&gt;</b> <b>int</b> <b>|</b> <b>None</b>
                     Return the index of the first 0-bit of x with index &gt;= n. n &gt;= 0.  If  there  are  no  more
                     0-bits in x at or above index n (which can only happen for x&lt;0, assuming an infinitely long
                     2's complement format), then <b>None</b> is returned.

              <b>bit_scan1(n=0,</b> <b>/)</b> <b>-&gt;</b> <b>int</b> <b>|</b> <b>None</b>
                     Return  the  index  of  the first 1-bit of x with index &gt;= n. n &gt;= 0.  If there are no more
                     1-bits in x at or above index n (which can only happen for  x&gt;=0,  assuming  an  infinitely
                     long 2's complement format), then <b>None</b> is returned.

              <b>bit_set(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
                     Return a copy of x with the n-th bit set.

              <b>bit_test(n,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
                     Return the value of the n-th bit of x.

              <b>conjugate()</b> <b>-&gt;</b> <u>mpz</u>
                     Return  the  conjugate  of  x  (which is just a new reference to x since x is not a complex
                     number).

              <b>copy()</b> <b>-&gt;</b> <u>xmpz</u>
                     Return a copy of a x.

              <b>digits(base=10,</b> <b>/)</b> <b>-&gt;</b> <b>str</b>
                     Return Python string representing x in the given base. Values for base can range between  2
                     to 62. A leading '-' is present if x&lt;0 but no leading '+' is present if x&gt;=0.

              <b>iter_bits(start=0,</b> <b>stop=-1)</b> <b>-&gt;</b> <b>collections.abc.Iterator</b>
                     Return  <b>True</b>  or <b>False</b> for each bit position in x beginning at 'start'. If a positive value
                     is specified for 'stop', iteration is continued until 'stop'  is  reached.  If  a  negative
                     value  is  specified,  iteration  is continued until the last 1-bit. Note: the value of the
                     underlying <u>xmpz</u> object can change during iteration.

              <b>iter_clear(start=0,</b> <b>stop=-1)</b> <b>-&gt;</b> <b>collections.abc.Iterator</b>
                     Return every bit position that is clear in x, beginning at 'start'. If a positive value  is
                     specified  for  'stop', iteration is continued until 'stop' is reached. If a negative value
                     is specified, iteration is  continued  until  the  last  1-bit.  Note:  the  value  of  the
                     underlying <u>xmpz</u> object can change during iteration.

              <b>iter_set(start=0,</b> <b>stop=-1)</b> <b>-&gt;</b> <b>collections.abc.Iterator</b>
                     Return  an  iterator yielding the bit position for every bit that is set in x, beginning at
                     'start'. If a positive value is specified for 'stop', iteration is continued  until  'stop'
                     is  reached. To match the behavior of slicing, 'stop' is not included.  If a negative value
                     is specified, iteration is  continued  until  the  last  1-bit.  Note:  the  value  of  the
                     underlying <u>xmpz</u> object can change during iteration.

              <b>limbs_finish(n,</b> <b>/)</b> <b>-&gt;</b> <b>None</b>
                     Must   be   called   after   writing   to  the  address  returned  by  x.limbs_write(n)  or
                     x.limbs_modify(n) to update the limbs of x.

              <b>limbs_modify(n,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
                     Returns the address of a mutable buffer representing the limbs of x, resized so that it may
                     hold at least n limbs.  Must be followed by a call to x.limbs_finish(n)  after  writing  to
                     the returned address in order for the changes to take effect.

              <b>limbs_read()</b> <b>-&gt;</b> <b>int</b>
                     Returns the address of the immutable buffer representing the limbs of x.

              <b>limbs_write(n,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
                     Returns the address of a mutable buffer representing the limbs of x, resized so that it may
                     hold  at  least  n limbs.  Must be followed by a call to x.limbs_finish(n) after writing to
                     the returned address in order for the changes to take effect.  WARNING: this  operation  is
                     destructive and may destroy the old value of x.

              <b>make_mpz()</b> <b>-&gt;</b> <u>mpz</u>
                     Return an <u>mpz</u> by converting x as quickly as possible.

                     NOTE: Optimized for speed so the original <u>xmpz</u> value is set to 0!

              <b>num_digits(base=10,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
                     Return length of string representing the absolute value of x in the given base. Values  for
                     base can range between 2 and 62. The value returned may be 1 too large.

              <b>num_limbs()</b> <b>-&gt;</b> <b>int</b>
                     Return the number of limbs of x.

              <b>denominator</b>
                     the denominator of a rational number in lowest terms

              <b>numerator</b>
                     the numerator of a rational number in lowest terms

              <b>real</b>   the real part of a complex number

   <b>Advanced</b> <b>Number</b> <b>Theory</b> <b>Functions</b>
       The following functions are based on mpz_lucas.c and mpz_prp.c by David Cleaver.

       A good reference for probable prime testing is <u><a href="http://www.pseudoprime.com/pseudo.html">http://www.pseudoprime.com/pseudo.html</a></u>

       <b>gmpy2.is_bpsw_prp(n,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return  <b>True</b>  if n is a Baillie-Pomerance-Selfridge-Wagstaff probable prime. A BPSW probable prime
              passes the <u>is_strong_prp()</u> test with base 2 and the <u>is_selfridge_prp()</u> test.

       <b>gmpy2.is_euler_prp(n,</b> <b>a,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if n is an Euler (also known as  Solovay-Strassen)  probable  prime  to  the  base  a.
              Assuming:
                 gcd(n,a) == 1 n is odd

              Then an Euler probable prime requires:
                 a**((n-1)/2) == (a/n) (mod n)

              where (a/n) is the Jacobi symbol.

       <b>gmpy2.is_extra_strong_lucas_prp(n,</b> <b>p,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if n is an extra strong Lucas probable prime with parameters (p,1). Assuming:
                 n is odd D = p*p - 4, D != 0 gcd(n, 2*D) == 1 n = s*(2**r) + Jacobi(D,n), s odd

              Then an extra strong Lucas probable prime requires:
                 lucasu(p,1,s)  == 0 (mod n) and lucasv(p,1,s) == +/-2 (mod n) or lucasv(p,1,s*(2**t)) == 0 (mod
                 n) for some t, 0 &lt;= t &lt; r

       <b>gmpy2.is_fermat_prp(n,</b> <b>a,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if n is a Fermat probable prime to the base a.  Assuming:
                 gcd(n,a) == 1

              Then a Fermat probable prime requires:
                 a**(n-1) == 1 (mod n)

       <b>gmpy2.is_fibonacci_prp(n,</b> <b>p,</b> <b>q,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if n is a Fibonacci probable prime with parameters (p,q).  Assuming:
                 n is odd p &gt; 0, q = +/-1 p*p - 4*q != 0

              Then a Fibonacci probable prime requires:
                 lucasv(p,q,n) == p (mod n).

       <b>gmpy2.is_lucas_prp(n,</b> <b>p,</b> <b>q,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if n is a Lucas probable prime with parameters (p,q).  Assuming:
                 n is odd D = p*p - 4*q, D != 0 gcd(n, 2*q*D) == 1

              Then a Lucas probable prime requires:
                 lucasu(p,q,n - Jacobi(D,n)) == 0 (mod n)

       <b>gmpy2.is_selfridge_prp(n,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if n is  a  Lucas  probable  prime  with  Selfidge  parameters  (p,q).  The  Selfridge
              parameters are chosen by finding the first element D in the sequence {5, -7, 9, -11, 13, ...} such
              that Jacobi(D,n) == -1. Then let p=1 and q = (1-D)/4. Then perform a Lucas probable prime test.

       <b>gmpy2.is_strong_bpsw_prp(n,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return  <b>True</b>  if  n is a strong Baillie-Pomerance-Selfridge-Wagstaff probable prime. A strong BPSW
              probable prime passes the <u>is_strong_prp()</u> test with base and the <u>is_strong_selfridge_prp()</u> test.

       <b>gmpy2.is_strong_lucas_prp(n,</b> <b>p,</b> <b>q,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if n is a strong Lucas probable prime with parameters (p,q).  Assuming:
                 n is odd D = p*p - 4*q, D != 0 gcd(n, 2*q*D) == 1 n = s*(2**r) + Jacobi(D,n), s odd

              Then a strong Lucas probable prime requires:
                 lucasu(p,q,s) == 0 (mod n) or lucasv(p,q,s*(2**t)) == 0 (mod n) for some t, 0 &lt;= t &lt; r

       <b>gmpy2.is_strong_prp(n,</b> <b>a,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if n is a strong (also known as Miller-Rabin) probable prime to the base a.  Assuming:
                 gcd(n,a) == 1 n is odd n = s*(2**r) + 1, with s odd

              Then a strong probable prime requires one of the following is true:
                 a**s == 1 (mod n) or a**(s*(2**t)) == -1 (mod n) for some t, 0 &lt;= t &lt; r.

       <b>gmpy2.is_strong_selfridge_prp(n,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if n is a strong Lucas probable prime with Selfidge parameters  (p,q).  The  Selfridge
              parameters are chosen by finding the first element D in the sequence {5, -7, 9, -11, 13, ...} such
              that  Jacobi(D,n)  == -1. Then let p=1 and q = (1-D)/4. Then perform a strong Lucas probable prime
              test.

       <b>gmpy2.lucasu(p,</b> <b>q,</b> <b>k,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the k-th element of the Lucas U sequence defined by p,q.  p*p - 4*q must  not  equal  0;  k
              must be greater than or equal to 0.

       <b>gmpy2.lucasu_mod(p,</b> <b>q,</b> <b>k,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return  the k-th element of the Lucas U sequence defined by p,q (mod n).  p*p - 4*q must not equal
              0; k must be greater than or equal to 0; n must be greater than 0.

       <b>gmpy2.lucasv(p,</b> <b>q,</b> <b>k,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return the k-th element of the Lucas V sequence defined by p,q.  p*p - 4*q must  not  equal  0;  k
              must be greater than or equal to 0.

       <b>gmpy2.lucasv_mod(p,</b> <b>q,</b> <b>k,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u>
              Return  the k-th element of the Lucas V sequence defined by p,q (mod n).  p*p - 4*q must not equal
              0; k must be greater than or equal to 0; n must be greater than 0.

   <b>Rationals</b>
   <b>mpq</b> <b>type</b>
       <b>class</b> <b>gmpy2.mpq(n=0,</b> <b>/)</b>

       <b>class</b> <b>gmpy2.mpq(n,</b> <b>m,</b> <b>/)</b>

       <b>class</b> <b>gmpy2.mpq(s,</b> <b>/,</b> <b>base=10)</b>
              Return a rational number constructed from a non-complex  number  n  exactly  or  from  a  pair  of
              <b>Rational</b> values n and m or from a string s made up of digits in the given base.  Every input, that
              is accepted by the <b>Fraction</b> type constructor is also accepted.

              A string may be made up to two integers in the same base separated by a '/' character, both parsed
              the  same  as the <u>mpz</u> type constructor does.  If base is 0 then the leading characters are used to
              recognize the base, this is done separately for the numerator and denominator.   If  base=10,  any
              string that represents a finite value and is accepted by the <b>float</b> constructor is also accepted.

              <b>as_integer_ratio()</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
                     Return  a pair of integers, whose ratio is exactly equal to the original number.  The ratio
                     is in lowest terms and has a positive denominator.

              <b>conjugate()</b> <b>-&gt;</b> <u>mpz</u>
                     Return the conjugate of x (which is just a new reference to x since  x  is  not  a  complex
                     number).

              <b>digits(base=10,</b> <b>/)</b> <b>-&gt;</b> <b>str</b>
                     Return a Python string representing x in the given base (2 to 62, default is 10). A leading
                     '-' is present if x&lt;0, but no leading '+' is present if x&gt;=0.

              <b>from_decimal(dec,</b> <b>/)</b> <b>-&gt;</b> <u>mpq</u>
                     Converts a finite <b>decimal.Decimal</b> instance to a rational number, exactly.

              <b>from_float(f,</b> <b>/)</b> <b>-&gt;</b> <u>mpq</u>
                     Converts a finite float to a rational number, exactly.

              <b>denominator</b>
                     the denominator of a rational number in lowest terms

              <b>imag</b>   the imaginary part of a complex number

              <b>numerator</b>
                     the numerator of a rational number in lowest terms

              <b>real</b>   the real part of a complex number

   <b>mpq</b> <b>Functions</b>
       <b>gmpy2.qdiv(x,</b> <b>y=1,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u>
              Return x/y as <u>mpz</u> if possible, or as <u>mpq</u> if x is not exactly divisible by y.

   <b>Contexts</b>
       <u>context()</u> creates a new context.  <u>set_context()</u> will set the active context.  <u>get_context()</u> will return a
       reference  to  the  active  context.  Note that contexts are mutable: modifying the reference returned by
       <u>get_context()</u> will modify the active context until a new context  is  enabled  with  <u>set_context()</u>.   The
       <u>context.copy()</u>  method  will  return a copy of the context.  Contexts that implement the standard <u>single</u>,
       <u>double</u>, and <u>quadruple</u> precision floating point types can be created using <u>ieee()</u>.

   <b>Context</b> <b>Type</b>
       <b>class</b> <b>gmpy2.context(**kwargs)</b>

       <b>class</b> <b>gmpy2.context(ctx,</b> <b>/,</b> <b>**kwargs)</b>
              Return a new context for controlling gmpy2 arithmetic, based either on the default context or on a
              given by ctx value.  Context options additionally can be overridden by keyword arguments.

              <b>abs(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u>
                     Return abs(x), the context is applied to the result.

              <b>acos(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return inverse cosine of x; result in radians.

              <b>acosh(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return inverse hyperbolic cosine of x.

              <b>add(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return x + y.

              <b>agm(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return arithmetic-geometric mean of x and y.

              <b>ai(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return Airy function of x.

              <b>asin(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return inverse sine of x; result in radians.

              <b>asinh(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return inverse hyperbolic sine of x.

              <b>atan(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return inverse tangent of x; result in radians.

              <b>atan2(y,</b> <b>x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return arc-tangent of (y/x); result in radians.

              <b>atanh(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return inverse hyperbolic tanget of x.

              <b>cbrt(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the cube root of x.

              <b>ceil(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return an <u>mpfr</u> that is the smallest integer &gt;= x.

              <b>check_range(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return a new <u>mpfr</u> with exponent that lies within the range of emin and  emax  specified  by
                     context.

              <b>clear_flags()</b> <b>-&gt;</b> <b>None</b>
                     Clear all MPFR exception flags.

              <b>const_catalan()</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the catalan constant using the context's precision.

              <b>const_euler()</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the euler constant using the context's precision.

              <b>const_log2()</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the log2 constant using the context's precision.

              <b>const_pi()</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the constant pi using the context's precision.

              <b>copy()</b> <b>-&gt;</b> <u>context</u>
                     Return a copy of a context.

              <b>cos(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return cosine of x; x in radians.

              <b>cosh(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return hyperbolic cosine of x.

              <b>cot(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return cotangent of x; x in radians.

              <b>coth(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return hyperbolic cotangent of x.

              <b>csc(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return cosecant of x; x in radians.

              <b>csch(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return hyperbolic cosecant of x.

              <b>degrees(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Convert  angle  x  from  radians  to  degrees.   Note:  In rare cases the result may not be
                     correctly rounded.

              <b>digamma(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return digamma of x.

              <b>div(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return x / y; uses true division.

              <b>div_2exp(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return <u>mpfr</u> or <u>mpc</u> divided by 2**n.

              <b>divmod(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u> <b>|</b> <u>mpfr</u><b>,</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u><b>]</b>
                     Return divmod(x, y).

                     Note: overflow, underflow, and inexact exceptions are not supported for <u>mpfr</u> arguments.

              <b>eint(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return exponential integral of x.

              <b>erf(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return error function of x.

              <b>erfc(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return complementary error function of x.

              <b>exp(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return the exponential of x.

              <b>exp10(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return 10**x.

              <b>exp2(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return 2**x.

              <b>expm1(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return exp(x) - 1.

              <b>factorial(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the floating-point approximation to the factorial of n.

                     See <u>fac()</u> to get the exact integer result.

              <b>floor(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return an <u>mpfr</u> that is the largest integer &lt;= x.

              <b>floor_div(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpfr</u>
                     Return x // y; uses floor division.

              <b>fma(x,</b> <b>y,</b> <b>z,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return correctly rounded result of (x * y) + z.

              <b>fmma(x,</b> <b>y,</b> <b>z,</b> <b>t,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return correctly rounded result of (x * y) + (z * t).

              <b>fmms(x,</b> <b>y,</b> <b>z,</b> <b>t,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return correctly rounded result of (x * y) - (z * t).

              <b>fmod(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return x - n*y where n is the integer quotient of x/y, rounded to 0.

              <b>fms(x,</b> <b>y,</b> <b>z,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return correctly rounded result of (x * y) - z.

              <b>frac(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return fractional part of x.

              <b>frexp(x,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[int,</b> <u>mpfr</u><b>]</b>
                     Return a <b>tuple</b> containing the exponent and mantissa of x.

              <b>fsum(iterable,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return an accurate sum of the values in the iterable.

              <b>gamma(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return gamma of x.

              <b>gamma_inc(a,</b> <b>x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return (upper) incomplete gamma of a and x.

              <b>hypot(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return square root of (x**2 + y**2).

              <b>is_finite(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is an actual number (i.e. non NaN or Infinity). If x  is  an  <u>mpc</u>,  return
                     <b>True</b> if both x.real and x.imag are finite.

              <b>is_infinite(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is +Infinity or -Infinity. If x is an <u>mpc</u>, return <b>True</b> if either x.real or
                     x.imag is infinite. Otherwise return <b>False</b>.

              <b>is_integer(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is an integer; <b>False</b> otherwise.

              <b>is_nan(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is NaN (Not-A-Number) else <b>False</b>.

              <b>is_regular(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is not zero, NaN, or Infinity; <b>False</b> otherwise.

              <b>is_signed(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if the sign bit of x is set.

              <b>is_zero(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
                     Return  <b>True</b>  if x is equal to 0. If x is an <u>mpc</u>, return <b>True</b> if both x.real and x.imag are
                     equal to 0.

              <b>j0(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return first kind Bessel function of order 0 of x.

              <b>j1(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return first kind Bessel function of order 1 of x.

              <b>jn(n,</b> <b>x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the first kind Bessel function of order n of x.  Note: the order  of  the  arguments
                     changed in gmpy2 2.2.0a2

              <b>lgamma(x,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpfr</u><b>,</b> <b>int]</b>
                     Return  a  <b>tuple</b> containing the logarithm of the absolute value of gamma(x) and the sign of
                     gamma(x)

              <b>li2(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return real part of dilogarithm of x.

              <b>lngamma(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return natural logarithm of gamma(x).

              <b>log(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return the natural logarithm of x.

              <b>log10(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return the base-10 logarithm of x.

              <b>log1p(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return natural logarithm of (1+x).

              <b>log2(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return base-2 logarithm of x.

              <b>maxnum(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the maximum number of x and y. If x and y are not <u>mpfr</u>, they are converted to  <u>mpfr</u>.
                     The  result  is rounded to match the specified context.  If only one of x or y is a number,
                     then that number is returned.

              <b>minnum(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the minimum number of x and y. If x and y are not <u>mpfr</u>, they are converted to  <u>mpfr</u>.
                     The  result  is rounded to match the specified context.  If only one of x or y is a number,
                     then that number is returned.

              <b>minus(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return -x. The context is applied to the result.

              <b>mod(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u>
                     Return mod(x, y).  Note: overflow, underflow, and inexact exceptions are not supported  for
                     <u>mpfr</u> arguments.

              <b>modf(x,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpfr</u><b>,</b> <u>mpfr</u><b>]</b>
                     Return a <b>tuple</b> containing the integer and fractional portions of x.

              <b>mul(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return x * y.

              <b>mul_2exp(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return <u>mpfr</u> or <u>mpc</u> multiplied by 2**n.

              <b>next_above(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the next <u>mpfr</u> from x toward +Infinity.

              <b>next_below(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the next <u>mpfr</u> from x toward -Infinity.

              <b>next_toward(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the next <u>mpfr</u> from x in the direction of y. The result has the same precision as x.

              <b>norm(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return  the norm of a complex x. The norm(x) is defined as x.real**2 + x.imag**2. abs(x) is
                     the square root of norm(x).

              <b>phase(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the phase angle, also known as argument, of a complex x.

              <b>plus(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return +x, the context is applied to the result.

              <b>polar(x,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpfr</u><b>,</b> <u>mpfr</u><b>]</b>
                     Return the polar coordinate form of a complex x that is in rectangular form.

              <b>pow(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return x ** y.

              <b>proj(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpc</u>
                     Returns the projection of a complex x on to the Riemann sphere.

              <b>radians(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Convert angle x from degrees to radians.  Note:  In  rare  cases  the  result  may  not  be
                     correctly rounded.

              <b>rec_sqrt(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the reciprocal of the square root of x.

              <b>rect(r,</b> <b>phi,</b> <b>/)</b> <b>-&gt;</b> <u>mpc</u>
                     Return the rectangular coordinate form of a complex number that is given in polar form.

              <b>reldiff(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return the relative difference between x and y. Result is equal to abs(x-y)/x.

              <b>remainder(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return  x  - n*y where n is the integer quotient of x/y, rounded to the nearest integer and
                     ties rounded to even.

              <b>remquo(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpfr</u><b>,</b> <b>int]</b>
                     Return a <b>tuple</b> containing the remainder(x,y) and the low bits of the quotient.

              <b>rint(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return x rounded to the nearest integer using the context rounding mode.

              <b>rint_ceil(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return x rounded to the nearest integer by first rounding  to  the  next  higher  or  equal
                     integer and then, if needed, using the context rounding mode.

              <b>rint_floor(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return  x  rounded  to  the  nearest  integer  by first rounding to the next lower or equal
                     integer and then, if needed, using the context rounding mode.

              <b>rint_round(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return x rounded to the nearest integer by first rounding to the nearest integer (ties away
                     from 0) and then, if needed, using the context rounding mode.

              <b>rint_trunc(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return x rounded to the nearest integer by first rounding towards zero and then, if needed,
                     using the context rounding mode.

              <b>root(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return n-th root of x. The result always an  <u>mpfr</u>.   Note:  not  IEEE  754-2008  compliant;
                     result differs when x = -0 and n is even. See <u>context.rootn()</u>.

              <b>root_of_unity(n,</b> <b>k,</b> <b>/)</b> <b>-&gt;</b> <u>mpc</u>
                     Return the n-th root of <a href="../man1/mpc.1.html">mpc</a>(1) raised to the k-th power..

              <b>rootn(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return  n-th  root  of x. The result always an <u>mpfr</u>.  Note: this is IEEE 754-2008 compliant
                     version of <u>context.root()</u>.

              <b>round2(x,</b> <b>n=0,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return x rounded  to  n  bits.   Uses  default  precision  if  n  is  not  specified.   See
                     <u>context.round_away()</u> to access the mpfr_round() function of the MPFR.

              <b>round_away(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return an <u>mpfr</u> that is x rounded to the nearest integer, with ties rounded away from 0.

              <b>sec(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return secant of x; x in radians.

              <b>sech(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return hyperbolic secant of x.

              <b>sin(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return sine of x; x in radians.

              <b>sin_cos(x,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpfr</u> <b>|</b> <u>mpc</u><b>,</b> <u>mpfr</u> <b>|</b> <u>mpc</u><b>]</b>
                     Return a tuple containing the sine and cosine of x; x in radians.

              <b>sinh(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return hyperbolic sine of x.

              <b>sinh_cosh(x,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpfr</u><b>,</b> <u>mpfr</u><b>]</b>
                     Return a <b>tuple</b> containing the hyperbolic sine and cosine of x.

              <b>sqrt(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return the square root of x.

              <b>square(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return x * x.

              <b>sub(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return x - y.

              <b>tan(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return tangent of x; x in radians.

              <b>tanh(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
                     Return hyperbolic tangent of x.

              <b>trunc(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return an <u>mpfr</u> that is x truncated towards 0. Same as x.floor() if x&gt;=0 or x.ceil() if x&lt;0.

              <b>y0(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return second kind Bessel function of order 0 of x.

              <b>y1(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return second kind Bessel function of order 1 of x.

              <b>yn(n,</b> <b>x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return  the  second kind Bessel function of order n of x.  Note: the order of the arguments
                     changed in gmpy2 2.2.0a2

              <b>zeta(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
                     Return Riemann zeta of x.

              <b>allow_complex</b>
                     This attribute controls whether or not an <u>mpc</u> result can be  returned  if  an  <u>mpfr</u>  result
                     would normally not be possible.

              <b>allow_release_gil</b>
                     If set to <b>True</b>, many <u>mpz</u> and <u>mpq</u> computations will release the GIL.

                     This is considered an experimental feature.

              <b>divzero</b>
                     This flag is not user controllable.  It is automatically set if a division by zero occurred
                     and NaN result was returned.

              <b>emax</b>   This  attribute  controls  the  maximum  allowed  exponent  of an <u>mpfr</u> result.  The maximum
                     exponent is platform dependent and can be retrieved with <u>get_emax_max()</u>.

              <b>emin</b>   This attribute controls the minimum allowed  exponent  of  an  <u>mpfr</u>  result.   The  minimum
                     exponent is platform dependent and can be retrieved with <u>get_emin_min()</u>.

              <b>erange</b> This flag is not user controllable.  It is automatically set if an erange error occurred.

              <b>imag_prec</b>
                     This attribute controls the precision of the imaginary part of an <u>mpc</u> result.  If the value
                     is Default, then the value of <u>real_prec</u> is used.

              <b>imag_round</b>
                     This  attribute  controls the rounding mode for the imaginary part of an <u>mpc</u> result. If the
                     value is Default, then the value of the <u>real_round</u> attribute is used.  Note:  RoundAwayZero
                     is not a valid rounding mode for <u>mpc</u>.

              <b>inexact</b>
                     This  flag  is  not  user  controllable.  It  is  automatically set if an inexact result is
                     returned.

              <b>invalid</b>
                     This flag is not user controllable.  It is automatically set if an  invalid  (Not-A-Number)
                     result is returned.

              <b>overflow</b>
                     This  flag  is  not  user  controllable.  It is automatically set if a result overflowed to
                     +/-Infinity and <u>trap_overflow</u> is <b>False</b>.

              <b>precision</b>
                     This attribute controls the precision of an <u>mpfr</u> result.  The  precision  is  specified  in
                     bits,  not  decimal  digits.   The  maximum  precision  that  can  be specified is platform
                     dependent and can be retrieved with <u>get_max_precision()</u>.

                     Note: Specifying a value for precision that is too close  to  the  maximum  precision  will
                     cause the MPFR library to fail.

              <b>rational_division</b>
                     If set to <b>True</b>, <u>mpz</u> / <u>mpz</u> will return an <u>mpq</u> instead of an <u>mpfr</u>.

              <b>real_prec</b>
                     This  attribute  controls the precision of the real part of an <u>mpc</u> result.  If the value is
                     Default, then the value of the <u>precision</u> attribute is used.

              <b>real_round</b>
                     This attribute controls the rounding mode for the real part of an <u>mpc</u> result.  If the value
                     is Default, then the value of the round attribute is used.  Note: RoundAwayZero  is  not  a
                     valid rounding mode for <u>mpc</u>.

              <b>round</b>  There are five rounding modes available to <u>mpfr</u> type:

                     • RoundAwayZero - The result is rounded away from 0.0.

                     • RoundDown - The result is rounded towards -Infinity.

                     • RoundToNearest - Round to the nearest value; ties are rounded to an even value.

                     • RoundToZero - The result is rounded towards 0.0.

                     • RoundUp - The result is rounded towards +Infinity.

              <b>subnormalize</b>
                     The  usual  IEEE-754  floating  point  representation  supports  gradual underflow when the
                     minimum exponent is reached.  The MFPR library does not enable gradual underflow by default
                     but it can be enabled to precisely mimic the results of IEEE-754 floating point operations.

              <b>trap_divzero</b>
                     This attribute controls whether  or  not  a  <u>DivisionByZeroError</u>  exception  is  raised  if
                     division   by   0   occurs.    The   <u>DivisionByZeroError</u>   is   a   sub-class  of  Python’s
                     <b>ZeroDivisionError</b>.

              <b>trap_erange</b>
                     This attribute controls whether or not  a  <u>RangeError</u>  exception  is  raised  when  certain
                     operations are performed on NaN and/or Infinity values.  Setting <u>trap_erange</u> to <b>True</b> can be
                     used to raise an exception if comparisons are attempted with a NaN.

              <b>trap_inexact</b>
                     This  attribute  controls  whether  or  not an <u>InexactResultError</u> exception is raised if an
                     inexact result is returned.  To check if the result is  greater  or  less  than  the  exact
                     result, check the rc attribute of the <u>mpfr</u> result.

              <b>trap_invalid</b>
                     This  attribute  controls  whether or not an <u>InvalidOperationError</u> exception is raised if a
                     numerical result is not defined.  A special NaN (Not-A-Number) value will be returned if an
                     exception is not raised. The <u>InvalidOperationError</u> is a sub-class of Python’s <b>ValueError</b>.

                     For example, gmpy2.sqrt(-2) will normally return mpfr(‘nan’). However, if <u>allow_complex</u>  is
                     set to <b>True</b>, then an <u>mpc</u> result will be returned.

              <b>trap_overflow</b>
                     If  set  to <b>False</b>, a result that is larger than the largest possible <u>mpfr</u> given the current
                     exponent range will be replaced by +/-Infinity.  If set  to  <b>True</b>,  an  <u>OverflowResultError</u>
                     exception is raised.

              <b>trap_underflow</b>
                     If set to <b>False</b>, a result that is smaller than the smallest possible <u>mpfr</u> given the current
                     exponent  range  will  be  replaced  by  +/-0.0.   If  set to <b>True</b>, an <u>UnderflowResultError</u>
                     exception is raised.

              <b>underflow</b>
                     This flag is not user controllable. It is automatically set  if  a  result  underflowed  to
                     +/-0.0 and <u>trap_underflow</u> is <b>False</b>.

   <b>Context</b> <b>Functions</b>
       <b>gmpy2.get_context()</b> <b>-&gt;</b> <u>context</u>
              Return a reference to the current context.

       <b>gmpy2.ieee(size,</b> <b>/,</b> <b>subnormalize=True)</b> <b>-&gt;</b> <u>context</u>
              Return  a  new context corresponding to a standard IEEE floating point format. The supported sizes
              are 16, 32, 64, 128, and multiples of 32 greater than 128.

       <b>gmpy2.local_context(**kwargs)</b> <b>-&gt;</b> <u>context</u>

       <b>gmpy2.local_context(context,</b> <b>/,</b> <b>**kwargs)</b> <b>-&gt;</b> <u>context</u>
              Return a new context for controlling gmpy2 arithmetic, based either on the current context or on a
              ctx value.  Context options additionally can be overridden by keyword arguments.

       <b>gmpy2.set_context(context,</b> <b>/)</b> <b>-&gt;</b> <b>None</b>
              Activate a context object controlling gmpy2 arithmetic.

   <b>Exceptions</b>
       <b>exception</b> <b>gmpy2.RangeError</b>

       <b>exception</b> <b>gmpy2.InexactResultError</b>

       <b>exception</b> <b>gmpy2.OverflowResultError</b>

       <b>exception</b> <b>gmpy2.UnderflowResultError</b>

       <b>exception</b> <b>gmpy2.InvalidOperationError</b>

       <b>exception</b> <b>gmpy2.DivisionByZeroError</b>

   <b>Multiple-precision</b> <b>Reals</b>
   <b>mpfr</b> <b>Type</b>
       <b>class</b> <b>gmpy2.mpfr(n=0,</b> <b>/,</b> <b>precision=0)</b>

       <b>class</b> <b>gmpy2.mpfr(n,</b> <b>/,</b> <b>precision,</b> <b>context)</b>

       <b>class</b> <b>gmpy2.mpfr(s,</b> <b>/,</b> <b>precision=0,</b> <b>base=0)</b>

       <b>class</b> <b>gmpy2.mpfr(s,</b> <b>/,</b> <b>precision,</b> <b>base,</b> <b>context)</b>
              Return a floating-point number after converting a numeric value n or a string s made of digits  in
              the given base.

              A  string  can  be  with fraction-part (with a period as a separator) and/or exponent-part with an
              exponent marker 'e' or 'E' for bases up to 10, else '@' in any base.   In  bases  2  and  16,  the
              exponent prefix can also be 'p' or 'P', in which case the exponent indicates a multiplication by a
              power  of  2  instead  of  the  base.  The value of an exponent is always written in base 10.  The
              fractional-part digits are parsed the same as the <u>mpz</u> type constructor does  and  both  the  whole
              number  and  exponent-part optionally can be preceded by ‘+’ or ‘-’.  Every input, accepted by the
              <b>float</b> type constructor or the <b>float.fromhex</b> method is also accepted.

              If a precision greater than or equal to 2 is specified, then it is used.  A precision  of  0  (the
              default)  implies the precision of either the specified context or the current context is used.  A
              precision of 1 minimizes the loss of precision by following these rules:

                 1. If n is a radix-2 floating point number, then the full precision of n is retained.

                 2. If n is an integer, then the precision is the bit length of the integer.

              <b>__format__(fmt)</b> <b>-&gt;</b> <b>str</b>
                     Return a Python string by formatting 'x' using the format  string  'fmt'.  A  valid  format
                     string consists of:
                        optional alignment code:
                            '&lt;' -&gt; left shifted in field '&gt;' -&gt; right shifted in field '^' -&gt; centered in field

                        optional leading sign code
                            '+' -&gt; always display leading sign '-' -&gt; only display minus for negative values ' '
                            -&gt; minus for negative values, space for positive values

                        optional width.precision

                        optional rounding mode:
                            'U'  -&gt;  round  toward plus Infinity 'D' -&gt; round toward minus Infinity 'Y' -&gt; round
                            away from zero 'Z' -&gt; round toward zero 'N' -&gt; round to nearest

                        optional conversion code:
                            'a','A' -&gt; hex format 'b'     -&gt; binary format 'e','E' -&gt; scientific format  'f','F'
                            -&gt; fixed point format 'g','G' -&gt; fixed or float format

                     The default format is '.6f'.

              <b>as_integer_ratio()</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
                     Return  the  exact  rational equivalent of an <u>mpfr</u>. Value is a <b>tuple</b> for compatibility with
                     Python's <b>float.as_integer_ratio</b>.

              <b>as_mantissa_exp()</b> <b>-&gt;</b> <b>tuple[</b><u>mpz</u><b>,</b> <u>mpz</u><b>]</b>
                     Return the mantissa and exponent of an <u>mpfr</u>.

              <b>as_simple_fraction(precision=0)</b> <b>-&gt;</b> <u>mpq</u>
                     Return a simple rational approximation to x. The result will  be  accurate  to  'precision'
                     bits. If 'precision' is 0, the precision of 'x' will be used.

              <b>conjugate()</b> <b>-&gt;</b> <u>mpz</u>
                     Return  the  conjugate  of  x  (which is just a new reference to x since x is not a complex
                     number).

              <b>digits(base=10,</b> <b>prec=0,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[str,</b> <b>int,</b> <b>int]</b>
                     Returns up to 'prec' digits in the given base. If 'prec' is 0,  as  many  digits  that  are
                     available  are  returned.  No  more digits than available given x's precision are returned.
                     'base' must be between 2 and 62, inclusive. The result is a three element <b>tuple</b>  containing
                     the mantissa, the exponent, and the number of bits of precision.

              <b>is_finite()</b> <b>-&gt;</b> <b>bool</b>
                     Return  <b>True</b>  if  x  is an actual number (i.e. non NaN or Infinity). If x is an <u>mpc</u>, return
                     <b>True</b> if both x.real and x.imag are finite.

              <b>is_infinite()</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is +Infinity or -Infinity. If x is an <u>mpc</u>, return <b>True</b> if either x.real or
                     x.imag is infinite. Otherwise return <b>False</b>.

              <b>is_integer()</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is an integer; <b>False</b> otherwise.

              <b>is_nan()</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is NaN (Not-A-Number) else <b>False</b>.

              <b>is_regular()</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is not zero, NaN, or Infinity; <b>False</b> otherwise.

              <b>is_signed()</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if the sign bit of x is set.

              <b>is_zero()</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is equal to 0. If x is an <u>mpc</u>, return <b>True</b> if both x.real and  x.imag  are
                     equal to 0.

              <b>imag</b>   imaginary component

              <b>precision</b>
                     precision in bits

              <b>rc</b>     return code

              <b>real</b>   real component

   <b>mpfr</b> <b>Functions</b>
       <b>gmpy2.agm(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return arithmetic-geometric mean of x and y.

       <b>gmpy2.ai(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return Airy function of x.

       <b>gmpy2.atan2(y,</b> <b>x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return arc-tangent of (y/x); result in radians.

       <b>gmpy2.cbrt(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return the cube root of x.

       <b>gmpy2.ceil(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return an 'mpfr' that is the smallest integer &gt;= x.

       <b>gmpy2.check_range(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return a new <u>mpfr</u> with exponent that lies within the current range of emin and emax.

       <b>gmpy2.cmp(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
              Return  -1  if  x  &lt; y; 0 if x = y; or 1 if x &gt; y. Both x and y must be integer, rational or real.
              Note: 0 is returned (and exception flag set) if either argument is NaN.

       <b>gmpy2.const_catalan(precision=0)</b> <b>-&gt;</b> <u>mpfr</u>
              Return the catalan constant using the specified precision.  If  no  precision  is  specified,  the
              default precision is used.

       <b>gmpy2.const_euler(precision=0)</b> <b>-&gt;</b> <u>mpfr</u>
              Return the euler constant using the specified precision. If no precision is specified, the default
              precision is used.

       <b>gmpy2.const_log2(precision=0)</b> <b>-&gt;</b> <u>mpfr</u>
              Return  the log2 constant using the specified precision. If no precision is specified, the default
              precision is used.

       <b>gmpy2.const_pi(precision=0)</b> <b>-&gt;</b> <u>mpfr</u>
              Return the constant pi using the specified precision. If no precision is  specified,  the  default
              precision is used.

       <b>gmpy2.cot(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return cotangent of x; x in radians.

       <b>gmpy2.coth(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return hyperbolic cotangent of x.

       <b>gmpy2.csc(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return cosecant of x; x in radians.

       <b>gmpy2.csch(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return hyperbolic cosecant of x.

       <b>gmpy2.degrees(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Convert  angle  x  from  radians  to degrees.  Note: In rare cases the result may not be correctly
              rounded.

       <b>gmpy2.digamma(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return digamma of x.

       <b>gmpy2.eint(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return exponential integral of x.

       <b>gmpy2.erf(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return error function of x.

       <b>gmpy2.erfc(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return complementary error function of x.

       <b>gmpy2.exp10(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return 10**x.

       <b>gmpy2.exp2(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return 2**x.

       <b>gmpy2.expm1(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return exp(x) - 1.

       <b>gmpy2.factorial(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return the floating-point approximation to the factorial of n.

              See <u>fac()</u> to get the exact integer result.

       <b>gmpy2.floor(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return an <u>mpfr</u> that is the largest integer &lt;= x.

       <b>gmpy2.fmma(x,</b> <b>y,</b> <b>z,</b> <b>t,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return correctly rounded result of (x * y) + (z + t).

       <b>gmpy2.fmms(x,</b> <b>y,</b> <b>z,</b> <b>t,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return correctly rounded result of (x * y) - (z + t).

       <b>gmpy2.fmod(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return x - n*y where n is the integer quotient of x/y, rounded to 0.

       <b>gmpy2.frac(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return fractional part of x.

       <b>gmpy2.frexp(x,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[int,</b> <u>mpfr</u><b>]</b>
              Return a <b>tuple</b> containing the exponent and mantissa of x.

       <b>gmpy2.fsum(iterable,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return an accurate sum of the values in the iterable.

       <b>gmpy2.gamma(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return gamma of x.

       <b>gmpy2.gamma_inc(a,</b> <b>x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return (upper) incomplete gamma of a and x.

       <b>gmpy2.get_exp(x,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
              Return the exponent of x. Returns 0 for NaN or Infinity and sets the <u>context.erange</u>  flag  of  the
              current context and will raise an exception if <u>context.trap_erange</u> is set.

       <b>gmpy2.hypot(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return square root of (x**2 + y**2).

       <b>gmpy2.inf(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return  an  <u>mpfr</u> initialized to Infinity with the same sign as n.  If n is not given, +Infinity is
              returned.

       <b>gmpy2.is_finite(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if x is an actual number (i.e. non NaN or Infinity). If x is an <u>mpc</u>,  return  <b>True</b>  if
              both x.real and x.imag are finite.

       <b>gmpy2.is_infinite(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if x is +Infinity or -Infinity. If x is an <u>mpc</u>, return <b>True</b> if either x.real or x.imag
              is infinite. Otherwise return <b>False</b>.

       <b>gmpy2.is_regular(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if x is not zero, NaN, or Infinity; <b>False</b> otherwise.

       <b>gmpy2.is_signed(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if the sign bit of x is set.

       <b>gmpy2.is_unordered(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if either x and/or y is NaN.

       <b>gmpy2.j0(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return first kind Bessel function of order 0 of x.

       <b>gmpy2.j1(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return first kind Bessel function of order 1 of x.

       <b>gmpy2.jn(n,</b> <b>x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return  the  first kind Bessel function of order n of x.  Note: the order of the arguments changed
              in gmpy2 2.2.0a2

       <b>gmpy2.lgamma(x,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpfr</u><b>,</b> <b>int]</b>
              Return a <b>tuple</b> containing the logarithm of the absolute value of gamma(x) and the sign of gamma(x)

       <b>gmpy2.li2(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return real part of dilogarithm of x.

       <b>gmpy2.lngamma(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return natural logarithm of gamma(x).

       <b>gmpy2.log1p(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return natural logarithm of (1+x).

       <b>gmpy2.log2(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return base-2 logarithm of x.

       <b>gmpy2.maxnum(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return the maximum number of x and y. If x and y are not <u>mpfr</u>, they are  converted  to  <u>mpfr</u>.  The
              result  is  rounded  to  match  the current context.  If only one of x or y is a number, then that
              number is returned.

       <b>gmpy2.minnum(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return the minimum number of x and y. If x and y are not <u>mpfr</u>, they are  converted  to  <u>mpfr</u>.  The
              result  is  rounded  to  match  the current context.  If only one of x or y is a number, then that
              number is returned.

       <b>gmpy2.modf(x,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpfr</u><b>,</b> <u>mpfr</u><b>]</b>
              Return a <b>tuple</b> containing the integer and fractional portions of x.

       <b>gmpy2.mpfr_from_old_binary(string,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return an <u>mpfr</u> from a GMPY 1.x binary mpf format.

       <b>gmpy2.mpfr_grandom(random_state,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpfr</u><b>,</b> <u>mpfr</u><b>]</b>
              Return two random numbers with gaussian distribution.

       <b>gmpy2.mpfr_nrandom(random_state,</b> <b>/)</b>
              Return a random number with gaussian distribution.

       <b>gmpy2.mpfr_random(random_state,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return uniformly distributed number between [0,1].

       <b>gmpy2.nan()</b> <b>-&gt;</b> <u>mpfr</u>
              Return an <u>mpfr</u> initialized to NaN (Not-A-Number).

       <b>gmpy2.next_above(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return the next <u>mpfr</u> from x toward +Infinity.

       <b>gmpy2.next_below(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return the next <u>mpfr</u> from x toward -Infinity.

       <b>gmpy2.radians(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Convert angle x from degrees to radians.  Note: In rare cases the  result  may  not  be  correctly
              rounded.

       <b>gmpy2.rec_sqrt(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return the reciprocal of the square root of x.

       <b>gmpy2.reldiff(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return the relative difference between x and y. Result is equal to abs(x-y)/x.

       <b>gmpy2.remainder(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return  x  -  n*y  where n is the integer quotient of x/y, rounded to the nearest integer and ties
              rounded to even.

       <b>gmpy2.remquo(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpfr</u><b>,</b> <b>int]</b>
              Return a <b>tuple</b> containing the remainder(x,y) and the low bits of the quotient.

       <b>gmpy2.rint(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return x rounded to the nearest integer using the current rounding mode.

       <b>gmpy2.rint_ceil(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return x rounded to the nearest integer by first rounding to the next higher or equal integer  and
              then, if needed, using the current rounding mode.

       <b>gmpy2.rint_floor(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return  x  rounded to the nearest integer by first rounding to the next lower or equal integer and
              then, if needed, using the current rounding mode.

       <b>gmpy2.rint_round(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return x rounded to the nearest integer by first rounding to the nearest integer (ties  away  from
              0) and then, if needed, using the current rounding mode.

       <b>gmpy2.rint_trunc(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return  x rounded to the nearest integer by first rounding towards zero and then, if needed, using
              the current rounding mode.

       <b>gmpy2.root(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return n-th root of x. The result always an <u>mpfr</u>.   Note:  not  IEEE  754-2008  compliant;  result
              differs when x = -0 and n is even. See <u>rootn()</u>.

       <b>gmpy2.rootn(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return  n-th  root of x. The result always an <u>mpfr</u>.  Note: this is IEEE 754-2008 compliant version
              of <u>root()</u>.

       <b>gmpy2.round2(x,</b> <b>n=0,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return x rounded to n bits.  Uses default precision if n is not specified.   See  <u>round_away()</u>  to
              access the mpfr_round() function of the MPFR.

       <b>gmpy2.round_away(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return an <u>mpfr</u> that is x rounded to the nearest integer, with ties rounded away from 0.

       <b>gmpy2.sec(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return secant of x; x in radians.

       <b>gmpy2.sech(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return hyperbolic secant of x.

       <b>gmpy2.set_exp(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Set  the  exponent of x to n. If n is outside the range of valid exponents, <u>set_exp()</u> will set the
              <u>context.erange</u> flag of the current context and either  return  the  original  value  or  raise  an
              exception if <u>context.trap_erange</u> is set.

       <b>gmpy2.set_sign(x,</b> <b>s,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              If s is <b>True</b>, then return x with the sign bit set.

       <b>gmpy2.sign(x,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
              Return -1 if x &lt; 0, 0 if x == 0, or +1 if x &gt;0.

       <b>gmpy2.sinh_cosh(x,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpfr</u><b>,</b> <u>mpfr</u><b>]</b>
              Return a <b>tuple</b> containing the hyperbolic sine and cosine of x.

       <b>gmpy2.trunc(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return an <u>mpfr</u> that is x truncated towards 0. Same as x.floor() if x&gt;=0 or x.ceil() if x&lt;0.

       <b>gmpy2.y0(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return second kind Bessel function of order 0 of x.

       <b>gmpy2.y1(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return second kind Bessel function of order 1 of x.

       <b>gmpy2.yn(n,</b> <b>x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return  the second kind Bessel function of order n of x.  Note: the order of the arguments changed
              in gmpy2 2.2.0a2

       <b>gmpy2.zero(n,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return an <u>mpfr</u> initialized to 0.0 with the same sign as n.  If n is not given, +0.0 is returned.

       <b>gmpy2.zeta(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return Riemann zeta of x.

       <b>gmpy2.get_max_precision()</b> <b>-&gt;</b> <b>int</b>
              Return the maximum bits of precision that can be used for  calculations.   Note:  to  allow  extra
              precision for intermediate calculations, avoid setting precision close the maximum precision.

       <b>gmpy2.get_emax_max()</b> <b>-&gt;</b> <b>int</b>
              Return the maximum possible exponent that can be set for <u>mpfr</u>.

       <b>gmpy2.get_emin_min()</b> <b>-&gt;</b> <b>int</b>
              Return the minimum possible exponent that can be set for <u>mpfr</u>.

       <b>gmpy2.copy_sign(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return an <u>mpfr</u> composed of x with the sign of y.

       <b>gmpy2.can_round(b,</b> <b>err,</b> <b>rnd1,</b> <b>rnd2,</b> <b>prec,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Let  b  be an approximation to an unknown number x that is rounded according to rnd1. Assume the b
              has an error at most two to the power of E(b)-err where E(b) is the exponent  of  b.  Then  return
              <b>True</b> if x can be rounded correctly to prec bits with rounding mode rnd2.

       <b>gmpy2.free_cache()</b> <b>-&gt;</b> <b>None</b>
              Free the internal cache of constants maintained by MPFR.

   <b>Multiple-precision</b> <b>Complex</b>
   <b>mpc</b> <b>Type</b>
       <b>class</b> <b>gmpy2.mpc(c=0,</b> <b>/,</b> <b>precision=0)</b>

       <b>class</b> <b>gmpy2.mpc(c=0,</b> <b>/,</b> <b>precision,</b> <b>context)</b>

       <b>class</b> <b>gmpy2.mpc(real,</b> <b>/,</b> <b>imag=0,</b> <b>precision=0)</b>

       <b>class</b> <b>gmpy2.mpc(real,</b> <b>/,</b> <b>imag,</b> <b>precision,</b> <b>context)</b>

       <b>class</b> <b>gmpy2.mpc(s,</b> <b>/,</b> <b>precision=0,</b> <b>base=10)</b>

       <b>class</b> <b>gmpy2.mpc(s,</b> <b>/,</b> <b>precision,</b> <b>base,</b> <b>context)</b>
              Return  a  complex  floating-point number constructed from a numeric value c or from a pair of two
              non-complex numbers real and imag or from a string s made of digits in the given base.

              A string can be possibly with real-part  and/or  imaginary-part  (that  have  'j'  as  a  suffix),
              separated by '+' and parsed the same as the <u>mpfr</u> constructor does (but the base must be up to 36).

              The  precision  can  be  specified  by  either  a single number that is used for both the real and
              imaginary components, or as a pair of different precisions for the real and imaginary  components.
              For  every  component,  the  meaning  of  its  precision  value  is  the  same as in the <u>mpfr</u> type
              constructor.

              <b>__format__(fmt)</b> <b>-&gt;</b> <b>str</b>
                     Return a Python string by formatting 'x' using the format  string  'fmt'.  A  valid  format
                     string consists of:
                        optional alignment code:
                            '&lt;' -&gt; left shifted in field '&gt;' -&gt; right shifted in field '^' -&gt; centered in field

                        optional leading sign code
                            '+' -&gt; always display leading sign '-' -&gt; only display minus for negative values ' '
                            -&gt; minus for negative values, space for positive values

                        optional width.real_precision.imag_precision

                        optional rounding mode:
                            'U'  -&gt;  round  toward plus infinity 'D' -&gt; round toward minus infinity 'Z' -&gt; round
                            toward zero 'N' -&gt; round to nearest

                        optional output style:
                            'P' -&gt; Python style, 1+2j, (default) 'M' -&gt; MPC style, (1 2)

                        optional conversion code:
                            'a','A' -&gt; hex format 'b'     -&gt; binary format 'e','E' -&gt; scientific format  'f','F'
                            -&gt; fixed point format 'g','G' -&gt; fixed or scientific format

                     The default format is 'f'.

              <b>conjugate()</b> <b>-&gt;</b> <u>mpc</u>
                     Returns the conjugate of x.

              <b>digits(base=10,</b> <b>prec=0,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[tuple[str,</b> <b>int,</b> <b>int],</b> <b>tuple[str,</b> <b>int,</b> <b>int]]</b>
                     Returns  up  to  'prec'  digits  in the given base. If 'prec' is 0, as many digits that are
                     available given c's precision are returned. 'base' must be between 2  and  62.  The  result
                     consists  of 2 three-element tuples that contain the mantissa, exponent, and number of bits
                     of precision of the real and imaginary components.

              <b>is_finite()</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is an actual number (i.e. non NaN or Infinity). If x  is  an  <u>mpc</u>,  return
                     <b>True</b> if both x.real and x.imag are finite.

              <b>is_infinite()</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is +Infinity or -Infinity. If x is an <u>mpc</u>, return <b>True</b> if either x.real or
                     x.imag is infinite. Otherwise return <b>False</b>.

              <b>is_nan()</b> <b>-&gt;</b> <b>bool</b>
                     Return <b>True</b> if x is NaN (Not-A-Number) else <b>False</b>.

              <b>is_zero()</b> <b>-&gt;</b> <b>bool</b>
                     Return  <b>True</b>  if x is equal to 0. If x is an <u>mpc</u>, return <b>True</b> if both x.real and x.imag are
                     equal to 0.

              <b>imag</b>   imaginary component

              <b>precision</b>
                     precision in bits

              <b>rc</b>     return code

              <b>real</b>   real component

   <b>mpc</b> <b>Functions</b>
       <b>gmpy2.acos(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return inverse cosine of x; result in radians.

       <b>gmpy2.acosh(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return inverse hyperbolic cosine of x.

       <b>gmpy2.asin(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return inverse sine of x; result in radians.

       <b>gmpy2.asinh(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return inverse hyperbolic sine of x.

       <b>gmpy2.atan(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return inverse tangent of x; result in radians.

       <b>gmpy2.atanh(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return inverse hyperbolic tangent of x.

       <b>gmpy2.cos(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return cosine of x; x in radians.

       <b>gmpy2.cosh(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return hyperbolic cosine of x.

       <b>gmpy2.div_2exp(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return x divided by 2**n.

       <b>gmpy2.exp(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return the exponential of x.

       <b>gmpy2.is_nan(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if x is NaN (Not-A-Number) else <b>False</b>.

       <b>gmpy2.is_zero(x,</b> <b>/)</b> <b>-&gt;</b> <b>bool</b>
              Return <b>True</b> if x is equal to 0. If x is an <u>mpc</u>, return <b>True</b> if both x.real and x.imag are equal to
              0.

       <b>gmpy2.log(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return the natural logarithm of x.

       <b>gmpy2.log10(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return the base-10 logarithm of x.

       <b>gmpy2.mpc_random(random_state,</b> <b>/)</b> <b>-&gt;</b> <u>mpc</u>
              Return uniformly distributed number in the unit square [0,1]x[0,1].

       <b>gmpy2.mul_2exp(x,</b> <b>n,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return x multiplied by 2**n.

       <b>gmpy2.norm(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return the norm of a complex x. The norm(x) is defined as x.real**2 +  x.imag**2.  abs(x)  is  the
              square root of norm(x).

       <b>gmpy2.phase(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u>
              Return the phase angle, also known as argument, of a complex x.

       <b>gmpy2.polar(x,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpfr</u><b>,</b> <u>mpfr</u><b>]</b>
              Return the polar coordinate form of a complex x that is in rectangular form.

       <b>gmpy2.proj(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpc</u>
              Returns the projection of a complex x on to the Riemann sphere.

       <b>gmpy2.rect(r,</b> <b>phi,</b> <b>/)</b> <b>-&gt;</b> <u>mpc</u>
              Return the rectangular coordinate form of a complex number that is given in polar form.

       <b>gmpy2.root_of_unity(n,</b> <b>k,</b> <b>/)</b> <b>-&gt;</b> <u>mpc</u>
              Return the n-th root of <a href="../man1/mpc.1.html">mpc</a>(1) raised to the k-th power..

       <b>gmpy2.sin(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return sine of x; x in radians.

       <b>gmpy2.sin_cos(x,</b> <b>/)</b> <b>-&gt;</b> <b>tuple[</b><u>mpfr</u> <b>|</b> <u>mpc</u><b>,</b> <u>mpfr</u> <b>|</b> <u>mpc</u><b>]</b>
              Return a tuple containing the sine and cosine of x; x in radians.

       <b>gmpy2.sinh(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return hyperbolic sine of x.

       <b>gmpy2.sqrt(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return the square root of x.

       <b>gmpy2.tan(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return tangent of x; x in radians.

       <b>gmpy2.tanh(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return hyperbolic tangent of x.

   <b>Generic</b> <b>Functions</b>
       <b>gmpy2.add(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return x + y.

       <b>gmpy2.div(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return x / y; uses true division.

       <b>gmpy2.mul(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return x * y.

       <b>gmpy2.sub(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return x - y.

       <b>gmpy2.square(x,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return x * x.

       <b>gmpy2.f2q(x,</b> <b>err=0,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u>
              Return  the  'best' <u>mpq</u> approximating x to within relative error err.  Default is the precision of
              x. Uses Stern-Brocot tree to find the 'best' approximation. An  <u>mpz</u>  object  is  returned  if  the
              denominator is 1. If err&lt;0, relative error is 2.0 ** err.

       <b>gmpy2.fma(x,</b> <b>y,</b> <b>z,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return correctly rounded result of (x * y) + z.

       <b>gmpy2.fms(x,</b> <b>y,</b> <b>z,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return correctly rounded result of (x * y) - z.

       <b>gmpy2.cmp_abs(x,</b> <b>y,</b> <b>/)</b> <b>-&gt;</b> <b>int</b>
              Return -1 if abs(x) &lt; abs(y); 0 if abs(x) = abs(y); or 1 else.

   <b>Miscellaneous</b> <b>Functions</b>
       <b>gmpy2.digits(x,</b> <b>base=10,</b> <b>prec=0,</b> <b>/)</b> <b>-&gt;</b> <b>str</b>
              Return string representing a number x.

       <b>gmpy2.from_binary(bytes,</b> <b>/)</b> <b>-&gt;</b> <u>mpz</u> <b>|</b> <u>xmpz</u> <b>|</b> <u>mpq</u> <b>|</b> <u>mpfr</u> <b>|</b> <u>mpc</u>
              Return a Python object from a byte sequence created by <u>to_binary()</u>.

       <b>gmpy2.license()</b> <b>-&gt;</b> <b>str</b>
              Return string giving license information.

       <b>gmpy2.mp_limbsize()</b> <b>-&gt;</b> <b>int</b>
              Return the number of bits per limb.

       <b>gmpy2.mp_version()</b> <b>-&gt;</b> <b>str</b>
              Return string giving current GMP version.

       <b>gmpy2.mpc_version()</b> <b>-&gt;</b> <b>str</b>
              Return string giving current MPC version.

       <b>gmpy2.mpfr_version()</b> <b>-&gt;</b> <b>str</b>
              Return string giving current MPFR version.

       <b>gmpy2.random_state(seed=0,</b> <b>/)</b> <b>-&gt;</b> <b>object</b>
              Return  new  object  containing  state  information  for  the random number generator. An optional
              integer can be specified as the seed value.

       <b>gmpy2.to_binary(x,</b> <b>/)</b> <b>-&gt;</b> <b>bytes</b>
              Return a Python byte sequence that is a portable binary representation of a gmpy2  object  x.  The
              byte  sequence  can  be  passed  to  <u>from_binary()</u> to obtain an exact copy of x's value.  Raises a
              <b>TypeError</b> if x is not a gmpy2 object.

       <b>gmpy2.version()</b> <b>-&gt;</b> <b>str</b>
              Return string giving current GMPY2 version.

   <b>Cython</b> <b>usage</b>
       The gmpy2 module provides a C-API that can be conveniently used from Cython.  All types and functions are
       declared in the header gmpy2.pxd that is installed automatically in your Python path  together  with  the
       library.

   <b>Initialization</b>
       In order to use the C-API you need to make one call to the function <b>void</b> <b>import_gmpy2(void)</b>.

   <b>Types</b>
       The  types  <u>mpz</u>,  <u>mpq</u>,  <u>mpfr</u>  and  <u>mpc</u>  are  declared  as  extension  types in gmpy2.pxd. They correspond
       respectively to the C structures <b>MPZ_Object</b>, <b>MPQ_Object</b>, <b>MPFR_Object</b> and <b>MPC_Object</b>.

       Fast type checking can be done with the following C functions

       <b>bint</b> <b>MPZ_Check(object)</b>
              equivalent to <b>isinstance(obj,</b> <b>mpz)</b>

       <b>bint</b> <b>MPQ_Check(object)</b>
              equivalent to <b>isinstance(obj,</b> <b>mpq)</b>

       <b>bint</b> <b>MPFR_Check(object)</b>
              equivalent to <b>isinstance(obj,</b> <b>mpfr)</b>

       <b>bint</b> <b>MPC_Check(object)</b>
              equivalent to <b>isinstance(obj,</b> <b>mpc)</b>

   <b>Object</b> <b>creation</b>
       To create a new gmpy2 types there are four basic functions

       <b>mpz</b> <b>GMPy_MPZ_New(void</b> <b>*</b> <b>ctx)</b>
              create a new mpz object from a given context ctx

       <b>mpq</b> <b>GMPy_MPQ_New(void</b> <b>*</b> <b>ctx)</b>
              create a new mpq object from a given context ctx

       <b>mpfr</b> <b>MPFR_New(void</b> <b>*</b> <b>ctx,</b> <b>mpfr_prec_t</b> <b>prec)</b>
              create a new mpfr object with given context ctx and precision prec

       <b>mpc</b> <b>MPC_New(void</b> <b>*</b> <b>ctx,</b> <b>mpfr_prec_t</b> <b>rprec,</b> <b>mpfr_prec_t</b> <b>iprec)</b>
              create a new mpc object with given context ctx, precisions rprec and iprec  of  respectively  real
              and imaginary parts

       The context can be set to <b>NULL</b> and controls the default behavior (e.g. precision).

       The  gmpy2.pxd  header  also  provides  convenience macro to wrap a (copy of) a mpz_t, mpq_t, mpfr_t or a
       mpc_t object into the corresponding gmpy2 type.

       <b>mpz</b> <b>GMPy_MPZ_From_mpz(mpz_srcptr</b> <b>z)</b>
              return a new mpz object with a given mpz_t value z

       <b>mpq</b> <b>GMPy_MPQ_From_mpq(mpq_srcptr</b> <b>q)</b>
              return a new mpq object from a given mpq_t value q

       <b>mpq</b> <b>GMPy_MPQ_From_mpz(mpz_srcptr</b> <b>num,</b> <b>mpz_srcptr</b> <b>den)</b>
              return a new mpq object with a given mpz_t numerator num and mpz_t denominator den

       <b>mpfr</b> <b>GMPy_MPFR_From_mpfr(mpfr_srcptr</b> <b>x)</b>
              return a new mpfr object with a given mpfr_t value x

       <b>mpc</b> <b>GMPy_MPC_From_mpc(mpc_srcptr</b> <b>c)</b>
              return a new mpc object with a given mpc_t value c

       <b>mpc</b> <b>GMPy_MPC_From_mpfr(mpfr_srcptr</b> <b>re,</b> <b>mpfr_srcptr</b> <b>im)</b>
              return a new mpc object with a given mpfr_t real part re and mpfr_t imaginary part im

   <b>Access</b> <b>to</b> <b>the</b> <b>underlying</b> <b>C</b> <b>type</b>
       Each of the gmpy2 objects has a field corresponding to the underlying C  type.  The  following  functions
       give access to this field

       <b>mpz_t</b> <b><a href="../manmpz/MPZ.mpz.html">MPZ</a>(mpz)</b>

       <b>mpq_t</b> <b><a href="../manmpq/MPQ.mpq.html">MPQ</a>(mpq)</b>

       <b>mpfr_t</b> <b><a href="../manmpfr/MPFR.mpfr.html">MPFR</a>(mpfr)</b>

       <b>mpc_t</b> <b><a href="../manmpc/MPC.mpc.html">MPC</a>(mpc)</b>

   <b>Compilation</b>
       The  header  gmpy2.pxd  as well as the C header gmpy2.h from which it depends are installed in the Python
       path. In order to make Cython and the C compiler aware of the existence of these files, the  Python  path
       should be part of the include directories.

       Recall that <b>import_gmpy2()</b> needs to be called <u>before</u> any other function of the C-API.

       Here is a minimal example of a Cython file test_gmpy2.pyx:

          "A minimal cython file test_gmpy2.pyx"

          from gmpy2 cimport *

          cdef extern from "gmp.h":
              void mpz_set_si(mpz_t, long)

          import_gmpy2()   # needed to initialize the C-API

          cdef mpz z = GMPy_MPZ_New(NULL)
          mpz_set_si(MPZ(z), -7)

          print(z + 3)

       The corresponding setup.py is given below.

          "A minimal setup.py for compiling test_gmpy2.pyx"

          import sys

          from setuptools import Extension, setup
          from Cython.Build import cythonize

          ext = Extension("test_gmpy2", ["test_gmpy2.pyx"],
                          include_dirs=sys.path, libraries=['gmp', 'mpfr', 'mpc'])

          setup(name="cython_gmpy_test",
                ext_modules=cythonize([ext], include_path=sys.path))

       With these two files in the same repository, you should be able to compile your module using

          $ python setup.py build_ext --inplace

       For  more  about  compilation and installation of cython files and extension modules, please refer to the
       official documentation of Cython and distutils.

   <b>Conversion</b> <b>Methods</b>
       A python object could interact with gmpy2 if it implements one of the following methods:

       • <b>__mpz__</b> : return an object of type <u>mpz</u>.

       • <b>__mpq__</b> : return an object of type <u>mpq</u>.

       • <b>__mpfr__</b> : return an object of type <u>mpfr</u>.

       • <b>__mpc__</b> : return an object of type <u>mpc</u>.

       Implementing on of these methods allow gmpy2 to convert a python object into a gmpy2 type.  Example:

          &gt;&gt;&gt; from gmpy2 import mpz
          &gt;&gt;&gt; class CustInt:
          ...     def __init__(self, x):
          ...             self.x = x
          ...     def __mpz__(self):
          ...             return mpz(self.x)
          ...
          &gt;&gt;&gt; ci = <a href="../man5/CustInt.5.html">CustInt</a>(5)
          &gt;&gt;&gt; z = mpz(ci); z
          <a href="../man5/mpz.5.html">mpz</a>(5)
          &gt;&gt;&gt; type(z)
          &lt;class 'gmpy2.mpz'&gt;

   <b>Arithmetic</b> <b>operations</b>
       gmpy2 allow arithmetic operations between gmpy2 numbers and objects with conversion  methods.   Operation
       with  object  that  implements  floating conversion and exact conversion methods are not supported.  That
       means that only the following cases are supported:

       • An integer type have to implement <b>__mpz__</b>

       • A rational type have to implement <b>__mpq__</b> and can implement <b>__mpz__</b>

       • A real type have to implement <b>__mpfr__</b>

       • A complex type have to implement <b>__mpc__</b> and can implement <b>__mpfr__</b>

       Examples:

          &gt;&gt;&gt; import gmpy2
          &gt;&gt;&gt; from gmpy2 import mpz, mpq, mpfr, mpc
          &gt;&gt;&gt; gmpy2.set_context(gmpy2.context())
          &gt;&gt;&gt; class Q:
          ...     def __mpz__(self): return <a href="../man1/mpz.1.html">mpz</a>(1)
          ...     def __mpq__(self): return mpq(3,2)
          &gt;&gt;&gt; q = Q()
          &gt;&gt;&gt; <a href="../man2/mpz.2.html">mpz</a>(2) + q
          mpq(7,2)
          &gt;&gt;&gt; mpq(1,2) * q
          mpq(3,4)
          &gt;&gt;&gt; <a href="../man10/mpfr.10.html">mpfr</a>(10) * q
          mpfr('15.0')

   <b>Release</b> <b>Notes</b>
   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.2.1</b>
       • Fix internal use of char when int should be used. (jamesjer)

       • Add <u>xmpz.bit_count()</u>. (skirpichev)

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.2.0</b>
       • Remove support for versions of Python &lt; 3.7.  (skirpichev)

       • Support more modern build tools.  (skirpichev)

       • Use contextvars to manage gmpy2 contexts.  (casevh)

       • _mpmath functions now use vectorcall protocol.  (casevh)

       • Many documentation updates.  (skirpichev)

       • Add <u>mpz.as_integer_ratio()</u> / <u>mpz.to_bytes()</u> and <u>mpz.from_bytes()</u>.  (skirpichev)

       • Add <u>is_probab_prime()</u> to directly expose the GMP behavior.  (skirpichev)

       • <u>gcd()</u>/<u>lcm()</u> now uses vectorcall protocol.  (skirpichev)

       • Expose <u>context</u> type.  (skirpichev)

       • Correct error in <u>is_strong_bpsw_prp()</u>.  (casevh)

       • Added <u>prev_prime()</u> when GMP &gt;= 6.3.  (sethtroisi)

       • Change argument order of <u>jn()</u> and <u>yn()</u> to match MPFR.  (casevh)

       • Fix documentation and code for <u>is_extra_strong_lucas_prp()</u>.  (casevh)

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.5</b>
       • Version bump to fix wheel issues.  No code changes.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.4</b>
       • Version bump to fix wheel issues.  No code changes.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.3</b>
       • Fix mpz(-3).is_prime().

       • Add powmod_sec().

       • Fix mpfr('inf') and mpfr('nan') if subnormalization is enabled.

       • powmod() and powmod_sec() release the GIL.

       • Fix error messages for iroot(x,n) for large n.

       • Add powmod_base_list() and powmod_exp_list() (experimental).

       • Fix gmpy2.mpq(mpq, int).

       • Fix issues with INF, NAN, and mpfr("-0") when subnormalization is True

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.2</b>
       • Code cleanup.

       • Support Apple Silicon binary wheels.

       • is_prime(-2) now returns False.  Issue #312.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.1</b>
       • Code cleanup.

       • Properly return NOTIMPLEMENTED for unsupported arguments in <b>**</b>.  Issue #319.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.0</b>
       • Improvements to setup.py.

       • Add thread-safe contexts.

       • MPFR and MPC are now required.

       • Invalid Operation exception now raised for addition, etc.

       • inverse() now raises exception if inverse does not exist.

       • Add context methods.

       • Major code refactoring required to properly support thread-safe contexts.

       • `` __str__`` and <b>__repr__</b> no longer append "L" on Python 2.

       • <a href="../manmpfr/mpq.mpfr.html">mpq</a>(mpfr) now returns the exact result.

       • Fix <a href="../manmpc/repr.mpc.html">repr</a>(mpc) for precision &gt;325 bits.

       • Intermediate conversions of Integer to mpfr are now done with the full precision of the Integer.

       • Remove support for interaction with Decimal type.

       • No longer attempt to override the memory allocation functions.

       • Register gmpy2 types into the numeric tower.

       • mpz(x) call int(x) if mpz() does not know how to convert x directly.

       • Convert <u>mpz</u> to a type using <b>__new__</b> instead of a factory function.

       • Bug fix for <b>&lt;&lt;small</b> <b>mpfr&gt;&gt;</b> <b>**</b> <b>&lt;&lt;small</b> <b>Python</b> <b>integer&gt;&gt;</b>.

       • Compile with Python 3.11.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.0rc2</b>
       • Documentation updates.

       • Improvements to build environment.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.0rc1</b>
       • Added support for embedded underscore characters in string literals.

       • Allow GIL release for <u>mpz</u>/<u>xmpz</u>/<u>mpq</u> types only.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.0b6</b>
       • Improve argument type processing by saving type information to decrease the number of type check calls.
         Especially helpful for <u>mpfr</u> and <u>mpc</u> types. (Not complete but common operations are done.)

       • Resolve bug in <u>mpfr</u> to <u>mpq</u> conversion; issue #287.

       • Added limited support for releasing the GIL; disabled by default; see <u>context.allow_release_gil</u>.

       • Refactored handling of inplace operations for <u>mpz</u> and <u>xmpz</u> types; inplace operations on <u>xmpz</u> will  only
         return an <u>xmpz</u> result.

       • Refactored  handling  of  conversion to C integer types. Some exception types changes to reflect Python
         types.

       • <u>gcd()</u> and <u>lcm()</u> now support more than two arguments to align with the corresponding  functions  in  the
         math module.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.0b5</b>
       • Avoid  MPFR  bug  in  mfr_fac_ui  (<u>factorial()</u>)  on  platforms where long is 32-bits and argument is &gt;=
         44787929.

       • Fixed testing bugs with Python 2.7.

       • Fixed <b><a href="../man0/mpz.0.html">mpz</a>(0)</b> to C long or long long.

       • Fixed incorrect results in <u>f2q()</u>.

       • Adjust test suite to reflect changes in output in MPFR 4.1.0.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.0b4</b>
       • Fix comparisons with <u>mpq</u> and custom rational objects.

       • Fixes for some uncommon integer conversions scenarios.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.0b3</b>
       • Version bump only.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.0b2</b>
       • Many bug fixes.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.0b1</b>
       • Added <u>cmp()</u> and <u>cmp_abs()</u>.

       • Improved compatibility with the <b>numbers</b> module protocol.

       • Many bug fixes.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.a05</b>
       • Fix <u>qdiv()</u> not returning <u>mpz</u> when it should.

       • Added <u>root_of_unity()</u>.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.0a4</b>
       • Fix issue 204; missing file for Cython.

       • Additional support for MPFR 4

            • Add <u>fmma()</u> and <u>fmms()</u>.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.0a3</b>
       • Updates to <b>setup.py</b>.

       • Initial support for MPFR4

            • Add <u>mpfr_nrandom()</u>

            • <u>mpfr_grandom()</u> now calls nrandom twice; may return different values versus MPFR3.

            • Add <u>rootn()</u>; same as <u>root()</u> except different sign when taking even root of -0.0.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.0a2</b>
       • Revised build process.

       • Removal of unused code/macros.

       • Cleanup of Cython interface.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.1.0a1</b>
       • Thread-safe contexts are now supported. Properly integrating thread-safe contexts required an extensive
         rewrite of almost all internal functions.

       • MPFR and MPC are now required. It is no longer possible to build a version of gmpy2 that only  supports
         the GMP library.

       • The function <b>inverse()</b> now raises an exception if the inverse does not exist.

       • Context methods have been added for MPFR/MPC related functions.

       • A  new  context option (<u>rational_division</u>) has been added that changes the behavior of integer division
         involving <u>mpz</u> instances to return a rational result instead of a floating point result.

       • gmpy2 types are now registered in the numeric tower of the <b>numbers</b> module.

       • In previous versions of gmpy2, <b>mpz()</b> was a factory function that returned an  <u>mpz</u> instance.  It is  now
         an actual type. The same is true for the other gmpy2 types.

       • If  a Python object has an <b>__mpz__</b> method, it will be called bye <b>mpz()</b> to allow an unrecognized type to
         be converted to an mpz instance. The same is true for the other gmpy2 types.

       • A new C-API and Cython interface has been added.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.0.4</b>
       • Fix <u>bit_scan0()</u> for negative values.

       • Changes to <b>setup.py</b> to allow static linking.

       • Fix performance regression with mpmath and Python 3.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.0.3</b>
       • Fix <u>lucas2()</u> and <u>atanh()</u>; they were returning incorrect values.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.0.2</b>
       • Rebuild Windows binary installers due to MPIR 2.6.0 bug in <u>next_prime()</u>.

       • Another fix for <u>is_extra_strong_lucas_prp()</u>.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.0.1</b>
       • Updated <b>setup.py</b> to work in more situations.

       • Corrected exception handling in basic operations with <u>mpfr</u> type.

       • Correct <b>InvalidOperation</b> exception not raised in certain circumstances.

       • <u>invert()</u> now raises an exception if the modular inverse does not exist.

       • Fixed internal exception in <u>is_bpsw_prp()</u> and <u>is_strong_bpsw_prp()</u>.

       • Updated <u>is_extra_strong_lucas_prp()</u> to latest version.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.0.0</b>
       • Fix segmentation fault in <b>_mpmath_normalize()</b> (an undocumented helper function for mpmath).  (casevh)

       • Fix issues when compiled without support for MPFR.  (casevh)

       • Conversion of too large an <u>mpz</u> to <b>float</b> now raises <b>OverflowError</b> instead of returning <b>inf</b>.  (casevh)

       • Renamed <b>min2()/max2()</b> to <u>minnum()</u>/<u>maxnum()</u>.  (casevh)

       • The build and install process (i.e. <b>setup.py</b>) has been  completely  rewritten.   See  the  Installation
         section for more information.  (casevh)

       • <u>get_context()</u> no longer accepts keyword arguments.  (casevh)

   <b>Known</b> <b>issues</b> <b>in</b> <b>gmpy2</b> <b>2.0.0</b>
       • The test suite is still incomplete.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.0.0b4</b>
       • Added <b>__ceil__()</b>, <b>__floor__()</b>, <b>__trunc__()</b>, and <b>__round__()</b> methods to <u>mpz</u> and <u>mpq</u> types.  (casevh)

       • Added <b>__complex__()</b> to <u>mpc</u> type.  (casevh)

       • <b><a href="../manmpfr/round.mpfr.html">round</a>(mpfr)</b> now correctly returns an <u>mpz</u> type.  (casevh)

       • Add mpz.denominator and mpz.numerator.  (casevh)

       • If no arguments are given to <u>mpz</u>, <u>mpq</u>, <u>mpfr</u>, <u>mpc</u>, and <u>xmpz</u>, return 0 of the appropriate type.  (casevh)

       • Fix broken comparison between <u>mpz</u> and <u>mpq</u> when <u>mpz</u> is on the left.  (casevh)

       • Added  <b>__sizeof__()</b>  to all types. Note: <b>sys.getsizeof()</b> calls <b>__sizeof__()</b> to get the memory size of a
         gmpy2 object. The returned value reflects the size of the allocated memory which may be larger than the
         actual minimum memory required by the object.  (casevh)

   <b>Known</b> <b>issues</b> <b>in</b> <b>gmpy2</b> <b>2.0.0b4</b>
       • The new test suite (<b>test/runtest.py</b>) is incomplete and some tests fail on Python 2.x due to  formatting
         issues.

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.0.0b3</b>
       • <u>mp_version()</u>,  <u>mpc_version()</u>,  and  <u>mpfr_version()</u>  now  return normal strings on Python 2.x instead of
         Unicode strings.  (casevh)

       • Fix warnings when shifting 32-bit integer by 32 bits.  (casevh)

       • Faster conversion of the standard library <b>Fraction</b> type to <u>mpq</u>.  (casevh)

       • Improved conversion of the <b>Decimal</b> type to <u>mpfr</u>.  (casevh)

       • Consistently return <b>OverflowError</b> when converting <b>inf</b>.  (casevh)

       • Fix <u>mpz.</u><b>__</b><u>format</u><b>__</b><u>()</u> when the format code includes "#".  (casevh)

       • Add <u>is_infinite()</u> and deprecate <b>is_inf()</b>.  (casevh)

       • Add <u>is_finite()</u> and deprecate <b>is_number()</b>.  (casevh)

       • Fixed the various <b>is_XXX()</b> tests when used with <u>mpc</u>.  (casevh)

       • Fixed error handling with mpc(); mpc(1,"nan") is properly handled.  (casevh)

       • Added caching for <u>mpc</u> objects.  (casevh)

       • Faster code path for basic operation is both operands are <u>mpfr</u> or <u>mpc</u>.  (casevh)

       • Fix <u>mpfr</u> + <b>float</b> segmentation fault.  (casevh)

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.0.0b2</b>
       • Allow <u>xmpz</u> slice assignment to increase length of  <u>xmpz</u>  instance  by  specifying  a  value  for  stop.
         (casevh)

       • Fixed reference counting bug in several <b>is_xxx_prp()</b> tests.  (casevh)

       • Added <u>iter_bits()</u>, <u>iter_clear()</u>, <u>iter_set()</u> methods to <u>xmpz</u>.  (casevh)

       • Added <u>powmod()</u> for easy access to three argument <b>pow()</b>.  (casevh)

       • Removed  <b>addmul()</b> and <b>submul()</b> which were added in 2.0.0b1 since they are slower than just using Python
         code.  (casevh)

       • Bug fix in gcd_ext when both arguments are not <u>mpz</u>.  (casevh)

       • Added <u>ieee()</u> to create contexts for 32, 64, or 128 bit <b>float</b>'s.  (casevh)

       • Bug fix in <u>context()</u> not setting <u>emax</u>/<u>emin</u> correctly if they had been changed earlier.  (casevh)

       • Contexts can be  directly  used  in  with  statement  without  requiring  <u>set_context()</u>/<u>local_context()</u>
         sequence.  (casevh)

       • <u>local_context()</u> now accepts an optional context.  (casevh)

   <b>Changes</b> <b>in</b> <b>gmpy2</b> <b>2.0.0b1</b>
       • Rename to gmpy2 to allow backwards incompatible changes (casevh)

       • Renamed 'mpf' to 'mpfr' to reflect use of MPFR (casevh)

       • Renamed functions that manipulate individual bits to <b>bit_XXX()</b> to align with <b>bit_length()</b>.

       • Added caching for <u>mpq</u>.  (casevh)

       • Added <b>rootrem()</b>, <u>fib2()</u>, <u>lucas()</u>, <u>lucas2()</u>.  (casevh)

       • Support changed hash function in Python 3.2.  (casevh)

       • Added <u>is_even()</u>, <u>is_odd()</u>.  (casevh)

       • Add caching of the calculated hash value.  (casevh)

       • Add <u>xmpz</u> (mutable <u>mpz</u>) type.  (casevh)

       • Fix <u>mpq</u> formatting issue.  (casevh)

       • Add read/write bit access using slices to <u>xmpz</u>.  (casevh)

       • Add read-only bit access using slices to <u>mpz</u>.  (casevh)

       • Add <u>pack()</u>/<u>unpack()</u> methods to split/join an integer into n-bit chunks.  (casevh)

       • Add support for MPFR (casevh)

       • Removed fcoform float conversion modifier.  (casevh)

       • Add support for MPC.  (casevh)

       • Added context manager.  (casevh)

       • Allow building with just GMP/MPIR if MPFR not available.  (casevh)

       • Allow building with GMP/MPIR and MPFR if MPC not available.  (casevh)

       • Removed  most  instance methods in favor of gmpy2.function. The general guideline is that <u>properties</u> of
         an instance can be done via instance methods but <u>functions</u> that return a  new  result  are  done  using
         gmpy2.function.  (casevh)

       • Added  <b>__ceil__()</b>,  <b>__floor__()</b>,  and  <b>__trunc__()</b>  methods  since  they  are  called  by  <b>math.ceil()</b>,
         <b>math.floor()</b>, and <b>math.trunc()</b>.  (casevh)

       • Removed <b>gmpy2.pow()</b> to avoid conflicts.  (casevh)

       • Removed <b>gmpy2._copy()</b> and added <u>xmpz.copy()</u>.  (casevh)

       • Added support for <b>__format__()</b>.  (casevh)

       • Added <b>as_integer_ratio()</b>, <b>as_mantissa_exp()</b>, <b>as_simple_fraction()</b>.  (casevh)

       • Updated rich_compare.  (casevh)

       • Require MPFR 3.1.0+ to get divby0 support.  (casevh)

       • Added <u>fsum()</u>, <u>degrees()</u>, <u>radians()</u>.  (casevh)

       • Updated random number generation support.  (casevh)

       • Changed license to LGPL 3+.  (casevh)

       • Added <u>lucasu()</u>, <u>lucasu_mod()</u>, <u>lucasv()</u>, and <u>lucasv_mod()</u>.  (casevh) <u>Based</u> <u>on</u> <u>code</u> <u>contributed</u> <u>by</u>  <u>David</u>
         <u>Cleaver.</u>

       • Added probable-prime tests.  (casevh) <u>Based</u> <u>on</u> <u>code</u> <u>contributed</u> <u>by</u> <u>David</u> <u>Cleaver.</u>

       • Added <u>to_binary()</u>/<u>from_binary()</u>.  (casevh)

       • Renamed <b>numdigits()</b> to <u>num_digits()</u>.  (casevh)

       • Added keyword precision to constants.  (casevh)

       • Added <b>addmul()</b> and <b>submul()</b>.  (casevh)

       • Added <b>__round__()</b>, <u>round2()</u>, <u>round_away()</u> for <u>mpfr</u>.  (casevh)

       • <b>round()</b> is no longer a module level function.  (casevh)

       • Renamed module functions <b>min()/max()</b> to <b>min2()/max2()</b>.  (casevh) No longer conflicts with builtin <b>min()</b>
         and <b>max()</b>

       • Removed <b>set_debug()</b> and related functionality.  (casevh)

       • Removed mpf.setprec(), use mpf.round() (casevh)

       • Fix test compatibility with Python 3.1.2 and 3.2 (casevh)

       • Remove old random number functions, to be replaced later (casevh)

       • Remove tagoff option (casevh)

       • Debug messages only available if compiled with -DDEBUG (casevh)

       • Renamed context() -&gt; local_context(), new_context() -&gt; context() (casevh)

       • Added get_context() (casevh)

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>1.11</b>
       • Recognize True/False (bug in 1.10) (casevh)

       • Optimize argument handling (casevh)

       • Added caching for mpz (casevh)

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>1.10</b>
       • Remove dependancy on pymemcompat.h (casevh)

       • Remove callback (casevh)

       • Added support for -DMPIR to include MPIR instead of GMP (casevh)

       • Major code revisions to add support for Python 3.x (casevh)

       • Fixed bug in binary() and qbinary() (casevh)

       • Fixed bug in rich comparisons (casevh)

       • Added % and divmod support to mpq and mpf (casevh)

       • Changed memory allocation functions to use PyMem (casevh)

       • Removed small number interning (casevh)

       • Added tdivmod, cdivmod, and fdivmod (casevh)

       • Added more helper functions for mpmath (casevh)

       • Faster mpz&lt;&gt;PyLong conversion (casevh)

       • Faster <a href="../manmpz/hash.mpz.html">hash</a>(mpz) (casevh)

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>1.04</b>
       • Avoid GMP/mingw32 bug when converting very small floats to mpz. (casevh)

       • Significant performance improvement for long-&gt;mpz and mpz-&gt;long. (casevh)

       • Added "rich comparisons" to mpz, mpq and mpf types (aleaxit)

       • Added additional tests (casevh, aleaxit)

       • Fixed bug when converting very large mpz to str (casevh)

       • Faster conversion from mpz-&gt;binary and binary-&gt;mpz (casevh)

       • Added support for pickling (casevh)

       • Added divexact (casevh)

       • Fixed mpf comparisons by rounding mpf results when GMP returns a longer result. Added fround() (casevh)

       • Added bit_length (Thanks Mario Pernici)

       • Added helper functions for mpmath (casevh)

       • Faster conversion from mpq-&gt;binary and binary-&gt;mpq (casevh)

       • Recognize MPIR, mpir_version() (casevh)

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>1.03</b>
       • Fixed  the  bug  that caused crashes on gmpy.mpf(float('inf')) and other such conversions, implicit and
         explicit

       • Fixed a bug in get_zconst's prototype affecting 64-bit machines, thanks to Gary Bunting

       • Fixed a bug in hashing on 64-bit systems. hash(long) now equals <a href="../manmpz/hash.mpz.html">hash</a>(mpz) for large values. (casevh)

       • Changed int() to return a long value instead of OverFlowError.  Complies with PEP 237. (casevh)

       • Added support in setup.py for darwinports/macports build of GMP on MacOSX. (aleaxit)

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>1.02</b>
       • fix warning in comparison of mpq's

       • added support of mpq('12.34') [[string w/o a slash, but with a dot]]

       • fixes for 64-bit build (thanks to a patch by dmcooke)

       • added experimental support for  decimal.Decimal  (and  user-coded  types)  via  wider  use  of  special
         conversion methods (if present) and their sly insertion on-the-fly into the decimal.Decimal class (!)

       • two bugfixes, thanks to Simon Burton

       • Brought  back  into  C89  compliance  (thanks  to Chip Turner), had drifted to C99 (declarations in the
         middle of the code).

       • Python 2.5 support (Py_ssize_t, __index__) thanks to Chip Turner

       • Pushed coverage to 93.3% (missing only "sanity check"  level  error  tests  [mostly  for  out-of-memory
         conditions], output to stderr conditioned by global.debug, &amp; a couple of very obscure cases)

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>1.01</b>
       • cleanups,  ensure  support  for Python 2.4.1 on MacOSX 10.4/XCode 2.1 as well as Python 2.2 and 2.3 (on
         MacOSX and Linux)

       • fixed memory leak on divm (thanks to <u><a href="mailto:mensanator@aol.com">mensanator@aol.com</a></u>)

       • fixed bug on mpq('123') [[str2mpq on string w/o a slash]]

       • added floordiv and truediv operators, and tests for them

       • NOT tested on GMP 3 (have none left around...), ONLY on GMP 4.*

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>1.0</b>
       • minor cleanups, ensure support for Python 2.3

       • fixed misdiagnosis of some argument counts in macro

       • SELF_ONE_ARG_CONVERTED (tx to Paul Rubin!)

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>0.9</b>
       • change ValueError to OverflowError for 'too-large' errors

       • fix bug in mpq_pow (negative base, exp. with odd denominator) (fix now corrected -- _even_  denominator
         is the error!)

       • fixed gcc warnings reported by K. Briggs

       • support GMP 4 (but added no GMP4-only functionality yet)

       • updated tests to 0.9, better coverage

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>0.8</b>
       (again, requests &amp; suggestions by great Pearu!)

       • raise test coverage 72.5% -&gt; 90.0%

       • introduced callbacks (not documented/tested for now; Pearu will test/support/document in PySymbolic)

       • some errors went undiagnosed, caused crash: now fixed

       • workaround for GMP bug(?s?) in mpz_fits_... (?)

       • added exposure of mpf_ sqrt and pow_ui

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>0.7</b>
       Good feedback from Keith Briggs, some advice from Tim Peters and Fred Lundh --- thanks all!

       • fixed bug of '"%d" where "%ld" was meant' in many places and other sundry minor warnings given by gcc

       • fixed  hash  (delegating to Python) so mp[nqz](x) will produce the same value as hash(x) for any Python
         number x

       • workaround for GMP 3.1.1 bug, mpz_root wrongly returning 'exact' for non-exact  root  if  dest==source,
         which stopped needed value-error for inexact mpq**mpq operations

       • determined correct 'actual precision' of floats

       • explicitly stored precision with binary-form mpf's

       • extended  explicit-bits  request  to  all  -&gt;mpf operations (good in itself, plus, preparing for future
         MPFR)

       • removed the limitation of no binary-form for &lt;0 mpz

       • introduced macros to parse args, for conciseness

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>0.6</b>
       (lots of good ideas from Pearu once more!-)

       • fixed silly bugs in kronecker and mpq_abs

       • gmpy-level workaround for scan0/scan1 bugs (?) in gmp 3.1.1

       • added qdiv; anynum-&gt;mpq substituted for all such  conversions  (also  anynum-&gt;mpz  and  anynum-&gt;mpf  by
         analogy, with care!)

       • added  global.fcoform  for  optional  use  of intermediate string in float2mpf (used for any float-&gt;mpf
         conversion)

       • added set_fcoform function for global.fcoform access

       • general cleanup of sources; added alloca for msvc++; - many sundry minor bugfixes &amp; uniformization; - a
         little useful refactoring (more would be good...)

       • added caching of mpq objects

       • power for mpq

       • stern-brocot algorithm for mpf-&gt;mpq (also exposed as f2q) - also used for float-&gt;mpq  -  with  stricter
         tracking of mpf's requested-precision - added getrprec method to mpf, getrprec module-function

       • exposed ceil, floor and trunc methods/functions for mpf's

       • changed a couple exceptions from value to zerodivision

       • added 'qual' and 'floa' options to gmpy.rand

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>0.5</b>
       • added jacobi, legendre, kronecker

       • added random-number generation, seed set/save, shuffling

       • added mpq (at last!-)

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>0.4</b>
       • split gmpy.c/gmpy.h introducing C-API interface (Pearu's suggestion)

       • cleanup some casts using Pearu's new macros

       • further cache-tweaks at Pearu's suggestion (macros introduced)

       • added sign (Pearu's request), getbit, setbit

       • added docstrings

       • renamed copy functions to start with _ ('internal, private')

       • added .comb as a synonym of .bincoef

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>0.3</b>
       • performance tweaks via mpz-caching &amp; fixed-constants

       • added get/set functions for zcache, zco min/max

       • added get-only function for versions (of gmp, and of gmpy)

       • removed all 'traces' of mutability (to be re-done... much later!)

       • cleaned up all of the mpz_cmp_ui(X,0) to mpz_sgn(X)

       • cleaned up Py_BuildValue usage (N vs O, explicit-() for tuples)

       • added numdigits, lowbits, root, next_prime, invert, popcount,

       • hamdist, scan0, scan1

       • renamed bin to bincoef

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>0.2</b>
       15 Nov 2000

       • pre-alpha: bugfixes re formatting (tx, Peanu!)

       • no tags on oct() and hex() of mpz's

       • insert 'tagoff' in options (gmpy.mpz() vs mpz() in repr) (for Peanu!)

       • speedups for _nonzero &amp; _cmp (tx, Peanu!)

       • slight speedup (7/8%?) for excess reallocs 4&lt;-&gt;8 bytes (Peanu's help!)

       • added copy/fcopy; bin; fib; remove

   <b>Changes</b> <b>in</b> <b>gmpy</b> <b>0.1</b>
       6 Nov 2000

       • pre-alpha --- first placed on sourceforge

       • <u>Index</u>

       • <u>Search</u> <u>Page</u>

</pre><h4><b>AUTHOR</b></h4><pre>
       Case Van Horsen

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2012 - 2024, Case Van Horsen

2.2                                                1741132066                                           <u><a href="../man3/GMPY2.3.html">GMPY2</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>