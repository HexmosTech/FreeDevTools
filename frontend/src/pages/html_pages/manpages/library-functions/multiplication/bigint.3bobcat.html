<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::BigInt - Arithmetic on Integers of Unlimited Size</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::BigInt - Arithmetic on Integers of Unlimited Size

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/bigint&gt;</b>
       Linking option: <u>-lbobcat</u> <u>-lcrypto</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  class  is defined as a wrapper class around the <u>openSSL</u> <u>BN</u> series of functions, offering members to
       perform arithmetic on integral values of unlimited sizes. Members are offered to generate primes  and  to
       perform  all kinds of common arithmetic operations on <u>BigInt</u> objects. Also, conversions to characters and
       standard numerical value types are offered.

       Below, the phrase <u>the</u> <u>object</u> may also refer to the object’s value. The context in which this occurs  will
       make clear that the object’s value rather than the object as-is is referred to.

       Various  constructors accept <u>BIGNUM</u> arguments. Type <u>BIGNUM</u> is the type containing an integer of unlimited
       precision as defined by OpenSSL.  <u>BIGNUM’s</u> definition is

           typedef struct bignum_st BIGNUM;

           struct bignum_st
           {
               BN_ULONG *d;    // Pointer to an array of ’BN_BITS2’ bit chunks.
               int top;        // Index of last used d +1.
               // The next are internal book keeping for bn_expand.
               int dmax;       // Size of the d array.
               int neg;        // one if the number is negative
               int flags;
           };

       Signs of <u>BigInt</u> are handled in a special way. Whether a <u>BigInt</u> is negative or positive is  determined  by
       its  sign-flag,  and  not  by  a  sign bit as is the case with <u>int</u> typed values. Since <u>BigInt</u> values have
       unlimited precision shifting values to the left won’t change their signs.

       Operators return either a reference to the current (modified) object or return a <u>BigInt</u> object containing
       the computed value. The rule followed here was to implement the operators  analogously  to  the  way  the
       operators  work  on  <u>int</u>  type  values  and  variables.  E.g., <u>operator+()</u> returns a <u>BigInt</u> value whereas
       <u>operator+=()</u> returns a <u>BigInt</u> <u>&amp;</u> reference.

       All members modifying their objects return a reference to the current (modified) object. All members  not
       modifying  the  current  object  return  a  <u>BigInt</u>  object.  If  both  members exists performing the same
       functionality the name of the member returning a <u>BigInt</u> object ends in a  <u>c</u>  (const)  (e.g.,  <u>addMod</u>  and
       <u>addModc</u>).

       Almost  all  operators,  members  and  constructors  (except for the default constructor) throw <u>Exception</u>
       exceptions on failure.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       -

</pre><h4><b>TYPE</b></h4><pre>
       The class <b>BigInt</b> defines the type <u>Word</u>, which is equal to the type <u>BN_ULONG</u>  used  by  <u>OpenSSL</u>  to  store
       integral  values  of  unlimited  precision.  A  <u>Word</u>  is  an  <u>unsigned</u>  <u>long</u>,  which is, depending on the
       architecture, usually 64 or 32 bits long.

</pre><h4><b>ENUMERATIONS</b></h4><pre>
       <b>Msb</b>
       This (most significant bit) enumeration is used when generating a cryptographically strong random number.
       Its values are:

       o      <b>MSB_UNKNOWN</b>:
              The most significant bit may be 0 or 1.

       o      <b>MSB_IS_ONE</b>:
              The most significant bit is guaranteed to be 1.

       o      <b>TOP_TWO_BITS_ONE</b>:
              The two most significant bits are guaranteed to be 1, resulting in a product of  two  values  each
              containing <u>nBits</u> having <u>2</u> <u>*</u> <u>nBits</u> bits.

       <b>Lsb</b>
       This  (least  significant  bit)  enumeration  is  used  when generating random numbers, ensuring that the
       resulting value is either odd or even.

       o      <b>EVEN</b>:
              The random value will be an even value;

       o      <b>ODD</b>:
              The random value will be an odd value.

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
       o      <b>BigInt()</b>:
              The default constructor initializes a <u>BigInt</u> value to 0;

       o      <b>explicit</b> <b>BigInt(BIGNUM</b> <b>const</b> <b>&amp;value)</b>:
              This constructor initializes a <u>BigInt</u> from a <u>const</u> <u>BIGNUM</u>;

       o      <b>explicit</b> <b>BigInt(BIGNUM</b> <b>const</b> <b>*value)</b>:
              This constructor initializes a <u>BigInt</u> from a pointer to a <u>const</u> <u>BIGNUM</u>;

       o      <b>explicit</b> <b>BigInt(BIGNUM</b> <b>*value)</b>:
              This constructor initializes a <u>BigInt</u> from a pointer to a <u>BIGNUM</u> (the <u>BIGNUM</u> value pointed  to  by
              <u>value</u> is <u>not</u> mondified by the constructor.  This constructor is a mere wrapper around the previous
              constructor).  Note  that  none  of  the  constructors  expecting  a  <u>BIGNUM</u> argument modify their
              argument. If the memory used by the <u>BIGNUM</u> argument  must  be  returned  to  the  common  pool  an
              explicit <b><a href="../man3ssl/BN_free.3ssl.html">BN_free</a></b>(3ssl) call is required;

       o      <b>BigInt(Type</b> <b>value)</b>:
              This  constructor  is  defined as a member template. Any type that can be converted using a static
              cast to an <u>unsigned</u> <u>long</u> can be used as argument to this constructor. Promotion is allowed, so  in
              many situations where <u>BigInt</u>s are expected a plain numerical value can be used as well;

       o      <b>BigInt(char</b> <b>const</b> <b>*bigEndian,</b> <b>size_t</b> <b>length,</b> <b>bool</b> <b>negative</b> <b>=</b> <b>false)</b>:
              This  constructor  initializes  a  <u>BigInt</u> from <u>length</u> big-endian encoded bytes stored in <u>bigEndian</u>
              (having its most significant value at index  0).  This  constructor  interprets  the  <u>char</u>  values
              pointed  at  by  <u>bigEndian</u> as unsigned values. Use this constructor to reconstruct a <u>BigInt</u> object
              from the data made available by the <u>bigEndian</u> member (most significant byte at index  0).  If  the
              number represents a negative value, then provide a third argument <u>true</u>;

       o      <b>explicit</b> <b>BigInt(std::string</b> <b>const</b> <b>&amp;bigEndian,</b> <b>bool</b> <b>negative</b> <b>=</b> <b>false)</b>:
              This constructor initializes a <u>BigInt</u> from the bytes stored in <u>bigEndian</u>, which must be big-endian
              encoded  (having  its  most  significant  value  at index 0). This constructor interprets the <u>char</u>
              values stored in <u>bigEndian</u> as  unsigned  values.  If  the  number  that  is  stored  in  <u>bigEndian</u>
              represents a negative value, then provide a second argument <u>true</u>;

       o      <b>BigInt(size_t</b> <b>length,</b> <b>char</b> <b>const</b> <b>*littleEndian,</b> <b>bool</b> <b>negative</b> <b>=</b> <b>false)</b>:
              This  constructor  initializes  a  <u>BigInt</u>  from  <u>length</u>  little-endian  encoded  bytes  stored  in
              <u>littleEndian</u> (having its least significant value at index 0). This constructor interprets the <u>char</u>
              values pointed at by <u>littleEndian</u> as unsigned values. Use this constructor to reconstruct a <u>BigInt</u>
              object from the data made available by the <u>littleEndian</u> member (most significant byte at index 0).
              If the number represents a negative value, then provide a third argument <u>true</u>;

       o      <b>explicit</b> <b>BigInt(BigInt::Little</b> <b>endian,</b> <b>std::string</b> <b>littleEndian,</b> <b>bool</b> <b>negative</b> <b>=</b> <b>false)</b>:
              This constructor initializes a <u>BigInt</u> from  the  bytes  stored  in  <u>littleEndian</u>,  which  must  be
              little-endian encoded (having its least significant value at index 0). This constructor interprets
              the  <u>char</u>  values  stored  in  <u>littleEndian</u>  as  unsigned  values. If the number that is stored in
              <u>littleEndian</u> represents a negative value, then provide a third  argument  <u>true</u>.  The  consructor’s
              first parameter is used to distinguish this constructor from the constructor expecting a t(string)
              whose  bytes  represent a big-endian encoded value, and is not used by this constructor itself. It
              can be specified as <u>BigInt::Little{}</u>.

       Copy and move constructors (and assignment operators) are available.

</pre><h4><b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       o      <b>BigInt</b> <b>&amp;addMod(BigInt</b> <b>const</b> <b>&amp;rhs,</b> <b>BigInt</b> <b>const</b> <b>&amp;mod)</b> :
              <u>Rhs</u> is added (modulo <u>mod</u>) to the current object;

       o      <b>BigInt</b> <b>addModc(BigInt</b> <b>const</b> <b>&amp;rhs,</b> <b>BigInt</b> <b>const</b> <b>&amp;mod)</b> :
              The sum (modulo <u>mod</u>) of the current object and <u>rhs</u> is returned;

       o      <b>BigInt::Word</b> <b>at(size_t</b> <b>index)</b> <b>const</b>:
              Returns the <u>Word</u> at <u>index</u>. E.g., on a 32 bit architecture, if the  <b>BigInt</b>  value  equals  2,  then
              <u><a href="../man0/at.0.html">at</a>(0)</u>  returns  0, and <u><a href="../man1/at.1.html">at</a>(1)</u> returns 2. If <u>index</u> equals or exceeds the value returned by <u>nWords</u> an
              <u>FBB::Exception</u> is thrown;

       o      <b>BIGNUM</b> <b>const</b> <b>&amp;bignum()</b> <b>const</b>:
              A reference to the <u>BIGNUM</u> value maintained by the current <u>BigInt</u> object is returned;

       o      <b>char</b> <b>*bigEndian()</b> <b>const</b>:
              The value represented by the current object is  stored  in  a  series  of  <u>char</u>  typed  values  in
              big-endian order. If a value consists of 5 <u>char</u>s the eight most significant bits will be stored in
              the  <u>char</u> having index value 0, the eight least significant bits will be stored in the <u>char</u> having
              index value 4. When needed simply swap <u>char[i]</u> with <u>char[j]</u> (i = 0 .. nBytes/2, j  =  nBytes-1  ..
              nBytes/2)  to  convert  to  little-endian  order  or  use  the  member <u>littleEndian</u> to receive the
              representation in little-endian order. The return value consists of a series of <u>sizeInBytes()</u> (see
              below) dynamically allocated <u>char</u> values. The caller of <u>bigEndian</u> owns the  allocated  memory  and
              should  eventually  delete  it again using <u>delete[]</u>. Note that the current object’s <u>sign</u> cannot be
              inferred from the return value;

       o      <b>BigInt</b> <b>&amp;clearBit(size_t</b> <b>index)</b>:
              The current object’s bit at index position <u>index</u> is cleared;

       o      <b>BigInt</b> <b>clearBit(size_t</b> <b>index)</b> <b>const</b>:
              A copy of the current object having its bit at index position <u>index</u> cleared;

       o      <b>BigInt</b> <b>&amp;div(BigInt</b> <b>*remainder,</b> <b>BigInt</b> <b>const</b> <b>&amp;rhs)</b>:
              The current object is divided by <u>rhs</u>. The division’s remainder is returned in <u>*remainder</u>;

       o      <b>BigInt</b> <b>divc(BigInt</b> <b>*remainder,</b> <b>BigInt</b> <b>const</b> <b>&amp;rhs)</b> <b>const</b>:
              The quotient of the current object and <u>rhs</u> is returned. The division’s remainder  is  returned  in
              <u>*remainder</u>;

       o      <b>int</b> <b>compare(BigInt</b> <b>const</b> <b>&amp;rsh)</b> <b>const</b>:
              Using signed values, if the current object is smaller than <u>rhs</u> -1 is returned; if they are equal 0
              is returned; if the current object is larger than <u>ths</u> 1 is returned (see also <u>uCompare</u>);

       o      <b>BigInt</b> <b>&amp;exp(BigInt</b> <b>const</b> <b>&amp;exponent)</b>:
              The current object is raised to the power <u>exponent</u>;

       o      <b>BigInt</b> <b>expc(BigInt</b> <b>const</b> <b>&amp;exponent)</b> <b>const</b>:
              The current object raised to the power <u>exponent</u> is returned;

       o      <b>BigInt</b> <b>&amp;expMod(BigInt</b> <b>const</b> <b>&amp;exponent,</b> <b>BigInt</b> <b>const</b> <b>&amp;mod)</b>:
              The current object is raised to the power <u>exponent</u> modulo <u>mod</u>;

       o      <b>BigInt</b> <b>expModc(BigInt</b> <b>const</b> <b>&amp;exponent,</b> <b>BigInt</b> <b>const</b> <b>&amp;mod)</b> <b>const</b>:
              The current object raised to the power <u>exponent</u> modulo <u>mod</u> is returned;

       o      <b>BigInt</b> <b>&amp;gcd(BigInt</b> <b>const</b> <b>&amp;rhs)</b>:
              The greatest common divisor (gcd) of the current object and <u>rhs</u> is assigned to the current object.
              To compute the least common multiple (lcm) the following relationship can be used:

                  lcm(a, b) = a * b / a.gcd(b)

       o      <b>BigInt</b> <b>gcdc(BigInt</b> <b>const</b> <b>&amp;rhs)</b> <b>const</b>:
              The  greatest common divisor (gcd) of the current object and <u>rhs</u> is returned. To compute the least
              common multiple (lcm) the following relationship can be used:

                  lcm(a, b) = a * b / a.gcd(b)

       o      <b>bool</b> <b>hasBit(size_t</b> <b>index)</b>:
              <u>True</u> is returned if the bit at index position <u>index</u> has been set, <u>false</u> otherwise;

       o      <b>BigInt</b> <b>&amp;inverseMod(BigInt</b> <b>const</b> <b>&amp;mod)</b>:
              The inverse of the current object modulo <u>mod</u> is assigned to the current object. This is the  value
              <u>ret</u> for which the following expression holds true:

                      (*this * ret) % mod = 1

       o      <b>BigInt</b> <b>inverseModc(BigInt</b> <b>const</b> <b>&amp;mod)</b> <b>const</b>:
              This  inverse of the current object modulo <u>mod</u> is returned;

       o      <b>bool</b> <b>isNegative()</b> <b>const</b>:
              Returns <u>true</u> if the current object contains a negative value;

       o      <b>bool</b> <b>isOdd()</b> <b>const</b>:
              Returns <u>true</u> if the current object is an odd value;

       o      <b>bool</b> <b>isOne()</b> <b>const</b>:
              Returns <u>true</u> if the current object equals one (1);

       o      <b>BigInt</b> <b>&amp;isqrt()</b>:
              The  current  object’s  integer  square  root value is assigned to the current object. The integer
              square root of a value <u>x</u> is the biggest integral value whose  square  does  not  exceed  <u>x</u>.  E.g.,
              <u><a href="../man17/isqrt.17.html">isqrt</a>(17)</u>  <u>==</u>  <u>4</u>.  An  <u>Exception</u> exception is thrown if the current object’s value is smaller than
              one;

       o      <b>BigInt</b> <b>isqrtc()</b> <b>const</b>:
              The integer square root of the current object is returned. An <u>Exception</u> exception is thrown if the
              current object’s value is smaller than one;

       o      <b>bool</b> <b>isZero()</b> <b>const</b>:
              Returns <u>true</u> if the current object equals zero (0);

       o      <b>char</b> <b>*littleEndian()</b> <b>const</b>:
              The value represented by the current object is  stored  in  a  series  of  <u>char</u>  typed  values  in
              little-endian  order.  If  a  value  consists  of 5 <u>char</u>s the eight least significant bits will be
              stored in the <u>char</u> having index value 0. To receive the  bytes  in  big-endian  order  the  member
              <u>bigEndian</u>  can  be  used.  The  return  value  consists  of  a series of <u>sizeInBytes()</u> (see below)
              dynamically allocated <u>char</u> values. The caller of <u>littleEndian</u> owns the allocated memory and should
              eventually delete it again using <u>delete[]</u>. Note that the current object’s <u>sign</u> cannot be  inferred
              from the return value;

       o      <b>BigInt</b> <b>&amp;lshift()</b>:
              The current object’s bits are shifted one bit to the left. The object’s sign remains unaltered;

       o      <b>BigInt</b> <b>lshiftc()</b>:
              The  current  object’s  bits  shifted  one bit to the left are returned. The object’s sign will be
              equal to the current object’s sign;

       o      <b>BigInt</b> <b>&amp;lshift(size_t</b> <b>nBits)</b>:
              The current object’s bits are shifted <u>nBits</u> to the left. The object’s sign remains unaltered;

       o      <b>BigInt</b> <b>lshiftc(size_t</b> <b>nBits)</b> <b>const</b>:
              The current object’s bits shifted <u>nBits</u> bit to the left are returned. The object’s  sign  will  be
              equal to the current object’s sign;

       o      <b>BigInt</b> <b>&amp;maskBits(size_t</b> <b>lowerNBits)</b>:
              The   current  object’s  <u>lowerNBits</u>  lower  bits  are kept, its higher order bits are cleared. The
              object’s sign is not affected;

       o      <b>BigInt</b> <b>maskBitsc(size_t</b> <b>lowerNBits)</b> <b>const</b>:
              A copy of the current object is returned having all but its <u>lowerNBits</u>  lower  bits  cleared.  The
              sign of the returned object will be equal to the current object’s sign;

       o      <b>size_t</b> <b>maxWordIndex()</b> <b>const</b>:
              Returns  the  maximum  <u>Word</u>-index that can be used with the <u>at</u> and <u>setWord</u> members for the current
              <b>BigInt</b> value;

       o      <b>BigInt</b> <b>&amp;mulMod(BigInt</b> <b>const</b> <b>&amp;rhs,</b> <b>BigInt</b> <b>const</b> <b>&amp;mod)</b>:
              The current object is multiplied  (modulo <u>mod</u>) by <u>rhs</u>;

       o      <b>BigInt</b> <b>mulModc(BigInt</b> <b>const</b> <b>&amp;rhs,</b> <b>BigInt</b> <b>const</b> <b>&amp;mod)</b> <b>const</b>:
              The current object multiplied (modulo <u>mod</u>) by <u>rhs</u> is returned;

       o      <b>BigInt</b> <b>&amp;negate()</b>:
              The current object’s value is negated (i.e., the value changes its sign);

       o      <b>BigInt</b> <b>negatec()</b> <b>const</b>:
              The  negated value of the current object is returned;

       o      <b>size_t</b> <b>nWords()</b> <b>const</b>:
              The number of `words’ required to store the <b>BigInt</b> value is returned. Note that the returned value
              depends on the architecture’s number of bytes per word. For 32-bit architectures  there  are  four
              bytes per word, for 64-bit architectures eight bytes per word;

       o      <b>BigInt</b> <b>&amp;rshift()</b>:
              The current object’s bits are shifted one bit to the right. The object’s sign remains unaltered;

       o      <b>BigInt</b> <b>rshiftc()</b>:
              The  current  object’s  bits  shifted one bit to the right are returned. The object’s sign will be
              equal to the current object’s sign;

       o      <b>BigInt</b> <b>&amp;rshift(size_t</b> <b>nBits)</b>:
              The current object’s bits are shifted <u>nBits</u> to the right. The object’s sign remains unaltered;

       o      <b>BigInt</b> <b>rshiftc(size_t</b> <b>nBits)</b> <b>const</b>:
              The current object’s bits shifted <u>nBits</u> bit to the right are returned. The object’s sign  will  be
              equal to the current object’s sign;

       o      <b>BigInt</b> <b>&amp;setBit(size_t</b> <b>index)</b>:
              The bit at index position <u>index</u> is set;

       o      <b>BigInt</b> <b>setBitc(size_t</b> <b>index)</b> <b>const</b>:
              A copy of the current object is returned having its bit at index position <u>index</u> set;

       o      <b>BigInt</b> <b>&amp;setBit(size_t</b> <b>index,</b> <b>bool</b> <b>value)</b>:
              The bit at index position <u>index</u> is set to <u>value</u>;

       o      <b>BigInt</b> <b>setBitc(size_t</b> <b>index,</b> <b>bool</b> <b>value)</b> <b>const</b>:
              A copy of the current object is returned having its bit at index position <u>index</u> set to <u>value</u>;

       o      <b>BigInt</b> <b>&amp;setNegative(bool</b> <b>negative)</b>:
              The  current  object’s sign will be set to negative if the function’s argument is <u>true</u>, it will be
              set to positive if the function’s argument is <u>false</u>;

       o      <b>BigInt</b> <b>setNegativec(bool</b> <b>negative)</b> <b>const</b>:
              A copy of the current object is return having a negative sign if the function’s argument  is  <u>true</u>
              and a positive sign if the function’s argument is <u>false</u>;

       o      <b>void</b> <b>setWord(size_t</b> <b>index,</b> <b>BigInt::Word</b> <b>value)</b>:
              Assigns  <u>value</u> to the <u>Word</u> at <u>index</u>. E.g., on a 32 bit architecture, if the <b>BigInt</b> value equals 2,
              then after <u>setWord(1,</u> <u>1)</u> the value has become 2. If <u>index</u> exceeds the value returned by <u>nWords</u>  an
              <u>FBB::Exception</u> is thrown;

       o      <b>size_t</b> <b>size()</b> <b>const</b>:
              The number of significant <u>bits</u> required to store the current <u>BIGNUM</u> value is returned;

       o      <b>size_t</b> <b>sizeInBytes()</b> <b>const</b>:
              The number of bytes required to store the current <u>BIGNUM</u> value is returned;

       o      <b>size_t</b> <b>constexpr</b> <b>sizeOfWord()</b> <b>const</b>:
              <b>BigInt</b>  values  are  stored  in units of `words’, which are unsigned long values. These values may
              consist of, e.g., 32 or 64 bits. The number of bytes occupied by a `word’ is returned: 4 for a  32
              bit  value,  8  for  a 64 bit value, and possibly other values, depending on specific architecture
              peculiarities. The value returned by this member, therefore, is architecture dependent;

       o      <b>BigInt</b> <b>&amp;sqr()</b>:
              The current object’s value is squared;

       o      <b>BigInt</b> <b>sqrc()</b> <b>const</b>:
              The square of the current object is returned;

       o      <b>BigInt</b> <b>&amp;sqrMod(BigInt</b> <b>const</b> <b>&amp;mod)</b> <b>const</b>:
              The current object’s value is squared modulo <u>mod</u>;

       o      <b>BigInt</b> <b>sqrModc(BigInt</b> <b>const</b> <b>&amp;mod)</b> <b>const</b>:
              The square (modulo <u>mod</u>) of the current object is returned;

       o      <b>BigInt</b> <b>&amp;subMod(BigInt</b> <b>const</b> <b>&amp;rhs,</b> <b>BigInt</b> <b>const</b> <b>&amp;mod)</b>:
              <u>Rhs</u> is subtracted modulo <u>mod</u> from the current object;

       o      <b>BigInt</b> <b>subModc(BigInt</b> <b>const</b> <b>&amp;rhs,</b> <b>BigInt</b> <b>const</b> <b>&amp;mod)</b> <b>const</b>:
              The difference (modulo <u>mod</u>) of the current object and <u>rhs</u> is returned;

       o      <b>void</b> <b>swap(BigInt</b> <b>&amp;other)</b>:
              The current object swaps its value with <u>other</u>;

       o      <b>BigInt</b> <b>&amp;tildeBits()</b>:
              All the bits in the bytes of the current object and the sign of the current  object  are  toggled.
              So, after

                      Bigint <a href="../man5/b.5.html">b</a>(5);
                      b.tildeBits();

              <u>b</u> contains the value -250. Also see the discussion with <u>operator~()</u> below;

       o      <b>BigInt</b> <b>tildeBitsc()</b> <b>const</b>:
              A copy of the current object whose bits are toggled is returned;

       o      <b>BigInt</b> <b>&amp;tildeInt()</b>:
              The  `tilde’  operation is performed on the current object using the standard <u>int</u> semantics. E.g.,
              ~5 results in -6.  Also see the discussion with <u>operator~()</u> below;

       o      <b>BigInt</b> <b>tildeIntc()</b> <b>const</b>:
              A copy of the current object is returned to which the `tilde’ operation has been  performed  using
              the standard <u>int</u> semantics;

       o      <b>unsigned</b> <b>long</b> <b>ulong()</b> <b>const</b>:
              The  absolute  value stored in the current object is returned as an unsigned long. If it cannot be
              represented by an unsigned long it returns <u>0xffffffffL</u>;

       o      <b>int</b> <b>uCompare(BigInt</b> <b>const</b> <b>&amp;rsh)</b> <b>const</b>:
              Using absolute values, if the current object is smaller than <u>rhs</u> -1 is returned; if they are equal
              0 is returned; if the current object is larger than <u>ths</u> 1 is returned (see also <u>uCompare</u>).

</pre><h4><b>OVERLOADED</b> <b>OPERATORS</b></h4><pre>
       Except for some operators all operators perform their intuitive operations. Where that  isn’t  completely
       true  an explanatory remark is provided. E.g., <u>operator*()</u> multiplies two <u>BigInt</u>s, possibly promoting one
       of the operands; <u>operator*=()</u> multiplies the lhs by the rhs <u>BigInt</u>, possibly promoting the rhs operand.

       Here are the available operators:

       <b>Unary</b> <b>operators:</b>

       o      <b>bool</b> <b>operator</b> <b>bool()</b> <b>const</b>:
              Returns <u>true</u> if the <u>BigInt</u> value is unequal zero, otherwise <u>false</u> is returned;

       o      <b>BigInt</b> <b>&amp;operator++()</b>:
              Unary prefix increment operator;

       o      <b>BigInt</b> <b>operator++(int)</b>:
              Unary postfix increment operator;

       o      <b>BigInt</b> <b>&amp;operator--()</b>:
              Unary prefix decrement operator;

       o      <b>BigInt</b> <b>operator--(int)</b>:
              Unary postfix decrement operator;

       o      <b>BigInt</b> <b>operator-()</b>:
              Unary negation operator;

       o      <b>int</b> <b>operator[](size_t</b> <b>idx)</b> <b>const</b>:
              With <u>BigInt</u> objects it returns the bit-value of the object’s <u>idx</u>th bit as the value 0 or 1;

       o      <b>BigInt::Bit</b> <b>operator[](size_t</b> <b>idx)</b>:
              With non-const <u>BigInt</u> objects it returns a reference to the bit-value of the object’s  <u>idx</u>th  bit.
              When  used  as  <u>lvalue</u>  assigning a 0 or non-zero value to the operator’s return value will either
              clear or set the bit.  Likewise, the following arithmetic assignment operators may be used: binary
              or (<u>|=</u>), binary and (<u>&amp;=</u>) or binary xor (<u>^=</u>). When used as <u>rvalue</u> the value of the  object’s  <u>idx</u>th
              bit  is  returned as a <u>bool</u> value. When inseerted into a <u>std::ostream</u> the bit’s value is displayed
              as 0 or 1;

       o      <b>BigInt</b> <b>operator~()</b>:
              This operator is <u>not</u> implemented as it cannot be implemented so that it  matches  the  actions  of
              this operator when applied to <u>int</u> type values;

              When  used on <u>int</u> values this operator toggles all the <u>int</u>’s bits. E.g., ~5 represents -6, and ~-6
              again equals five. The -6 is the result of the sign bit of <u>int</u> values. The obvious  implementation
              of  <u>BigInt::operator~()</u>  is  to toggle all the value’s bits and to toggle its sign bit. For 5 this
              would result in -250: 5, being 101 (binary), fits in one byte, so ~5  becomes  11111010  (binary),
              which  is  250.  Its sign must be reversed as well, so it becomes -250.  This clearly differs from
              the value represented by the <u>int</u> constant ~5:  when  constructing  <u>BigInt(~5)</u>,  the  value  -6  is
              obtained.

              It is possible to change the implementation. E.g., after

                      Bigint <a href="../man5/b.5.html">b</a>(5);
                      b = ~b;

              <u>~b</u>  could  be  implemented  so  that  it results in the value -6. But this too leads to unexpected
              results. While <u>5</u> <u>&amp;</u> <u>~5</u> <u>==</u> <u>0</u>, this would no longer hold true for <u>BigInt</u> objects: Assuming <u>b</u> contains
              5 then <u>b</u> <u>&amp;</u> <u>~b</u> would expand to (binary) <u>101</u> <u>&amp;</u> <u>(negative)110</u> which equals (binary) 100;

              Since either implementation produces unexpected results <u>BigInt::operator~()</u> was  not  implemented.
              Instead  two  members  are offered: <u>tildeBits()</u>, toggling all the bits of all the <u>BigInt</u> bytes and
              toggling its sign (so

                      Bigint <a href="../man5/b.5.html">b</a>(5);
                      b.tildeBits();

              changes <u>b</u>’s value into -250), and <u>tildeInt()</u> changing the object’s value into the value that would
              have been obtained if a <u>BigInt</u> was a mere <u>int</u> (so

                      Bigint <a href="../man5/b.5.html">b</a>(5);
                      b.tildeInt();

              changes <u>b</u>’s value into -6).

       <b>Binary</b> <b>operators:</b>

       o      <b>BigInt</b> <b>operator*(BigInt</b> <b>const</b> <b>&amp;lhs,</b> <b>BigInt</b> <b>const</b> <b>&amp;rhs)</b>:

       o      <b>BigInt</b> <b>operator/(BigInt</b> <b>const</b> <b>&amp;lhs,</b> <b>BigInt</b> <b>const</b> <b>&amp;rhs)</b>:
              This operator returns the quotient of the <u>lhs</u> object divided by the <u>rhs</u> object. The  remainder  is
              lost (The member <u>div</u> performs the division and makes the remainder available as well);

       o      <b>BigInt</b> <b>operator%(BigInt</b> <b>const</b> <b>&amp;lhs,</b> <b>BigInt</b> <b>const</b> <b>&amp;rhs)</b>:

       o      <b>BigInt</b> <b>operator+(BigInt</b> <b>const</b> <b>&amp;lhs,</b> <b>BigInt</b> <b>const</b> <b>&amp;rhs)</b>:

       o      <b>BigInt</b> <b>operator-(BigInt</b> <b>const</b> <b>&amp;lhs,</b> <b>BigInt</b> <b>const</b> <b>&amp;rhs)</b>:

       o      <b>BigInt</b> <b>operator&lt;&lt;(BigInt</b> <b>const</b> <b>&amp;lhs,</b> <b>size_t</b> <b>nBits)</b>:
              See also the <u>lshift</u> member;

       o      <b>BigInt</b> <b>operator&gt;&gt;=(BigInt</b> <b>const</b> <b>&amp;lhs,</b> <b>size_t</b> <b>nBits)</b>:
              See also the <u>rshift</u> member;

       o      <b>BigInt</b> <b>operator&amp;(BigInt</b> <b>const</b> <b>&amp;lhs,</b> <b>BigInt</b> <b>const</b> <b>&amp;rhs)</b>:
              This  operator  returns a <u>BigInt</u> value consisting of the <u>bit_and</u>-ed bits and sign flags of lhs and
              rhs operands. Consequently, if one operand is positive, the resulting value will be positive;

       o      <b>BigInt</b> <b>operator|(BigInt</b> <b>const</b> <b>&amp;lhs,</b> <b>BigInt</b> <b>const</b> <b>&amp;rhs)</b>:
              This operator returns a <u>BigInt</u> value consisting of the <u>bit_or</u>-ed bits and sign flags  of  lhs  and
              rhs operands. Consequently, if either operand is negative, the result will be negative;

       o      <b>BigInt</b> <b>operator^(BigInt</b> <b>const</b> <b>&amp;lhs,</b> <b>BigInt</b> <b>const</b> <b>&amp;rhs)</b>:
              This  operator  returns a <u>BigInt</u> value consisting of the <u>bit_xor</u>-ed bits and sign flags of lhs and
              rhs operands. Consequently, if exactly one operand is negative, the result will be negative.

       <b>(Arithmetic)</b> <b>assignment</b> <b>operator(s):</b>

       o      <b>BigInt</b> <b>&amp;operator*=(BigInt</b> <b>const</b> <b>&amp;rhs)</b>:

       o      <b>BigInt</b> <b>&amp;operator/=(BigInt</b> <b>const</b> <b>&amp;rhs)</b>:
              This operator assigns the result of the (integer) division of the current <u>BigInt</u> object by <u>ths</u>  to
              the  current  object.  The  remainder  is  lost.  The  member  <u>div</u> divides and makes the remainder
              available as well;

       o      <b>BigInt</b> <b>&amp;operator%=(BigInt</b> <b>const</b> <b>&amp;rhs)</b>:

       o      <b>BigInt</b> <b>&amp;operator+=(BigInt</b> <b>const</b> <b>&amp;rhs)</b>:

       o      <b>BigInt</b> <b>&amp;operator-=(BigInt</b> <b>const</b> <b>&amp;rhs)</b>:

       o      <b>BigInt</b> <b>&amp;operator&lt;&lt;=(size_t</b> <b>nBits)</b>:
              See also the <u>lshift</u> members;

       o      <b>BigInt</b> <b>&amp;operator&gt;&gt;=(size_t</b> <b>nBits)</b>:
              See also the <u>rshift</u> members;

       o      <b>BigInt</b> <b>&amp;operator&amp;=(BigInt</b> <b>const</b> <b>&amp;rhs)</b>:
              This operator <u>bit_and</u>s the bits and sign flags of the current object and the rhs operand;

       o      <b>BigInt</b> <b>&amp;operator|=(BigInt</b> <b>const</b> <b>&amp;rhs)</b>:
              This operator <u>bit_or</u>s the bits and sign flags of the current object and the rhs operand;

       o      <b>BigInt</b> <b>&amp;operator^=(BigInt</b> <b>const</b> <b>&amp;rhs)</b>:
              This operator <u>bit_xor</u>s the bits and sign flags of the current object and the rhs operand.

</pre><h4><b>STATIC</b> <b>MEMBERS</b></h4><pre>
       All members returning a <u>BigInt</u> computed from a set of arguments and  not  requiring  an  existing  <u>BigInt</u>
       object  are defined as static members.  The first <u>diophantus</u> member, returning a <u>long</u> <u>long</u> value, also is
       a static member.

       o      <b>long</b> <b>long</b> <b>diophantus(long</b> <b>long</b> <b>*factor1,</b> <b>long</b> <b>long</b> <b>*factor2,</b> <b>long</b> <b>long</b> <b>value1,</b> <b>long</b> <b>long</b> <b>value2)</b>:
              The integral solution of <u>factor1</u> <u>*</u> <u>value1</u> <u>+</u> <u>factor2</u> <u>*</u> <u>value2</u>  <u>=</u>  <u>gcd</u>  is  computed.  The  function
              returns  the  greatest common divisor (<u>gcd</u>) of <u>value1</u> and <u>value2</u>, and returns their multiplication
              factors in, respectively, <u>*factor1</u> and <u>*factor2</u>. The solution is not unique: another  solution  is
              obtained  by  adding  <u>k</u>  <u>*</u>  <u>value2</u>  to <u>factor1</u> and subtracting <u>k</u> <u>*</u> <u>value1</u> from <u>factor2</u>. For values
              exceeding <u>std::numeric_limits&lt;long,</u> <u>long&gt;::max()</u> the next member can be used;

       o      <b>BigInt</b> <b>diophantus(BigInt</b> <b>*factor1,</b> <b>BigInt</b> <b>*factor2,</b> <b>BigInt</b> <b>const</b> <b>&amp;value1,</b> <b>BigInt</b> <b>const</b> <b>&amp;value2)</b>:
              The integral solution of <u>factor1</u> <u>*</u> <u>value1</u> <u>+</u> <u>factor2</u> <u>*</u> <u>value2</u>  <u>=</u>  <u>gcd</u>  is  computed.  The  function
              returns  the  greatest common divisor (<u>gcd</u>) of <u>value1</u> and <u>value2</u>, and returns their multiplication
              factors in, respectively, <u>*factor1</u> and <u>*factor2</u>. The solution is not unique: another  solution  is
              obtained by adding <u>k</u> <u>*</u> <u>value2</u> to <u>factor1</u> and subtracting <u>k</u> <u>*</u> <u>value1</u> from <u>factor2</u>;

       o      <b>BigInt</b> <b>fromText(std::string</b> <b>text,</b> <b>int</b> <b>mode</b> <b>=</b> <b>0)</b>:
              This  member converts a textual representation of a number to a <u>BigInt</u> value. Conversion continues
              until the end of <u>text</u> or until a character outside of an expected range is encountered;

              The expected range may be preset by specifying <u>mode</u> as <u>ios::dec,</u> <u>ios::oct,</u>  or  <u>ios::hex</u>  or  (the
              default) the expected range is determined by <u>fromText</u> itself by inspecting the characters in <u>text</u>.

              By  default  if  <u>text</u>  contains  hexadecimal  characters  then <u>fromText</u> assumes that the number is
              represented as a hexadecimal value (e.g., <u>"abc"</u> is converted to the (decimal) value 2748); if <u>text</u>
              starts with 0 and contains only characters in the  range  0  until  (including)  7  then  <u>fromText</u>
              assumes  the  number is represented as an octal value (e.g., <u>"01234"</u> is converted to the (decimal)
              value 668). Otherwise a decimal value is assumed.

              If the text does not represent a valid numerical value (of  the  given  extraction  mode)  then  a
              <u>FBB::Exception</u> exception is thrown (<u>fromText:</u> <u>text</u> <u>does</u> <u>not</u> <u>represent</u> <u>a</u> <u>BigInt</u> <u>value</u>);

       o      <b>BigInt</b> <b>rand(size_t</b> <b>size,</b> <b>Msb</b> <b>msb</b> <b>=</b> <b>MSB_IS_ONE,</b> <b>Lsb</b> <b>lsb</b> <b>=</b> <b>ODD)</b>:
              This  member  returns  a  cryptographically  strong  pseudo-random  number  of <u>size</u> bits. The most
              significant bit(s) can be controlled by <u>msb</u> (by default <b>MSB_IS_ONE</b>), the least significant bit can
              be controlled by <u>lsb</u> (by default <b>ODD</b>). Before calling this  member  for  real  the  random  number
              generator must have been seeded.

              From the <b><a href="../man3ssl/RAND_add.3ssl.html">RAND_add</a></b>(3ssl) man-page:

              OpenSSL  makes  sure  that  the  PRNG  state  is  unique  for each thread. On systems that provide
              <u>/dev/urandom</u>, the randomness device is used to seed the PRNG transparently. However, on all  other
              systems,  the  application  is  responsible  for  seeding  the  PRNG  by  calling  <b><a href="../man3ssl/RAND_add.3ssl.html">RAND_add</a></b>(3ssl),
              <b><a href="../man3ssl/RAND_egd.3ssl.html">RAND_egd</a></b>(3ssl), <b><a href="../man3ssl/RAND_load_file.3ssl.html">RAND_load_file</a></b>(3ssl), or <b><a href="../man3ssl/RAND_seed.3ssl.html">RAND_seed</a></b>(3ssl);

       o      <b>BigInt</b> <b>randRange(BigInt</b> <b>const</b> <b>&amp;max)</b>:
              This member returns a cryptographically strong pseudo-random number in the range  <u>0</u>  <u>&lt;=</u>  <u>number</u>  <u>&lt;</u>
              <u>max</u>.  Before  calling  this member for real the random number generator must have been seeded (see
              also <b>rand</b>, described above);

       o      <b>BigInt</b> <b>setBigEndian(std::string</b> <b>const</b> <b>&amp;bytes)</b>:
              The <u>bytes.length()</u> bytes of <u>bytes</u> are used to compute a <u>BigInt</u> object which is  returned  by  this
              function.  The  characters  in <u>bytes</u> are interpreted as a series of bytes in big-endian order. See
              also the member function <u>bigEndian()</u> above. The returned <u>BigInt</u> has a positive value;

       o      <b>BigInt</b> <b>prime(size_t</b> <b>nBits,</b> <b>BigInt</b> <b>const</b> <b>*mod</b> <b>=</b> <b>0,</b> <b>BigInt</b> <b>const</b> <b>*rem</b> <b>=</b>  <b>0,</b>  <b>PrimeType</b>  <b>primeType</b>  <b>=</b>
              <b>ANY)</b>:
              This  member returns a prime number of <u>bBits</u> bits. If both <u>mod</u> and <u>rem</u> are non-zero, the condition
              prime % mod == rem.  (E.g., use <u>prime</u> <u>%</u> <u>mod</u> <u>==</u>  <u>1</u>  in  order  to  suit  a  given  generator).  The
              parameter  <u>primeType</u>  can  be  <u>ANY</u>,  <u>(prime</u> <u>-</u> <u>1)</u> <u>/</u> <u>2</u> may or may not be a prime. If it is <u>SAFE</u> then
              <u>(prime</u> <u>-</u> <u>1)</u> <u>/</u> <u>2</u> will be a (so-called <u>safe</u>) prime;

       o      <b>BigInt</b> <b>pseudoRand(size_t</b> <b>size,</b> <b>Msb</b> <b>msb</b> <b>=</b> <b>MSB_IS_ONE,</b> <b>Lsb</b> <b>lsb</b> <b>=</b> <b>ODD)</b>:
              This member merely calls <u>BigInt::rand</u>;

       o      <b>BigInt</b> <b>pseudoRandRange(BigInt</b> <b>const</b> <b>&amp;max)</b>:
              This member merely calls <u>BigInt::randRange</u>.

</pre><h4><b>FREE</b> <b>FUNCTIONS</b> <b>IN</b> <b>THE</b> <b>FBB</b> <b>NAMESPACE</b></h4><pre>
       o      <b>std::ostream</b> <b>&amp;operator&lt;&lt;(ostream</b> <b>&amp;out,</b> <b>BigInt</b> <b>const</b> <b>&amp;value)</b>:
              Inserts <u>value</u> into the provided <u>ostream</u>. If the <u>hex</u> manipulator has been inserted into the  stream
              before  inserting  the  <u>BigInt</u> value the value will be displayed as a hexadecimal value (without a
              leading <u>0x</u>); if the <u>oct</u> manipulator has been inserted the value will be represented  as  an  octal
              value  (starting  with a 0). The value will be displayed as a decimal value if the <u>dec</u> manipulator
              is active. If the <u>BigInt</u> value is negative its value will be preceded by a minus character.

              This conversion isn’t very  fast.  For  faster  conversion  consider  using  the  LDC  class  (cf.
              <b><a href="../man3bobcat/ldc.3bobcat.html">ldc</a></b>(3bobcat)) in statements like

              BigInt value;           // contains a positive value
                                      // insert value using decimal digits:
              std::cout &lt;&lt; LDC{ value };

       o      <b>std::istream</b> <b>&amp;operator&gt;&gt;(istream</b> <b>&amp;in,</b> <b>BigInt</b> <b>&amp;value)</b>:
              Extracts  <u>value</u>  from  the  provided <u>istream</u>. Depending on the currently set extraction mode (<u>dec,</u>
              <u>oct,</u> or <u>hex</u>) the matching set of characters will be extracted from <u>in</u> and converted  to  a  number
              which  is  stored in <u>value</u>. Extraction stops at EOF or at the first character outside of the range
              of characters matching the extraction mode. if no numerical characters were extracted the stream’s
              <u>failbit</u> is set. The extracted value may  be  preceded  by  a  minus  character,  resulting  in  an
              extracted negative value.

</pre><h4><b>EXAMPLE</b></h4><pre>
       #include &lt;iostream&gt;
       #include &lt;bobcat/bigint&gt;

       using namespace std;
       using namespace FBB;

       int main()
       {
           BigInt value(BigInt::<a href="../man100/prime.100.html">prime</a>(100));
           BigInt mod(BigInt::<a href="../man50/rand.50.html">rand</a>(50));
           BigInt inverse(<a href="../manmod/value.inverseModc.mod.html">value.inverseModc</a>(mod));

           cout &lt;&lt; ’(’ &lt;&lt; value &lt;&lt; " * " &lt;&lt; inverse &lt;&lt; ") % " &lt;&lt; mod &lt;&lt; " = " &lt;&lt;
                    (    value       *      inverse     ) %      mod &lt;&lt; ’\n’;
       }

       // shows:
       // (1258586273445895786081124957771 * 828997573545038) %
       //                                                  1007205247048889 = 1

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/bigint</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7),  <b><a href="../man3bobcat/diffiehellman.3bobcat.html">diffiehellman</a></b>(3bobcat),  <b><a href="../man3bobcat/ldc.3bobcat.html">ldc</a></b>(3bobcat),  <b><a href="../man3ssl/RAND_add.3ssl.html">RAND_add</a></b>(3ssl), <b><a href="../man3ssl/RAND_egd.3ssl.html">RAND_egd</a></b>(3ssl), <b><a href="../man3ssl/RAND_load_file.3ssl.html">RAND_load_file</a></b>(3ssl),
       <b><a href="../man3/RAND_seed.3.html">RAND_seed</a></b>(3).

       For <u>BIGNUM</u>:
       <u>https://www.openssl.org/docs/man1.0.2/man3/bn_sub_words.html</u>

</pre><h4><b>BUGS</b></h4><pre>
       None Reported.

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>: debian package containing the static library, headers, manual pages, and  developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                               <u>FBB::<a href="../man3bobcat/BigInt.3bobcat.html">BigInt</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>