<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree - An N-ary tree</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtree-perl">libtree-perl_1.10-0ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tree - An N-ary tree

</pre><h4><b>SYNOPSIS</b></h4><pre>
         my $tree = Tree-&gt;new( 'root' );
         my $child = Tree-&gt;new( 'child' );
         $tree-&gt;add_child( $child );

         $tree-&gt;add_child( { at =&gt; 0 }, Tree-&gt;new( 'first child' ) );
         $tree-&gt;add_child( { at =&gt; -1 }, Tree-&gt;new( 'last child' ) );

         $tree-&gt;set_value( 'toor' );
         my $value = $tree-&gt;value;

         my @children = $tree-&gt;children;
         my @some_children = $tree-&gt;children( 0, 2 );

         my $height = $tree-&gt;height;
         my $width  = $tree-&gt;width;
         my $depth  = $tree-&gt;depth;
         my $size   = $tree-&gt;size;

         if ( $tree-&gt;has_child( $child ) ) {
             $tree-&gt;remove_child( $child );
         }

         $tree-&gt;remove_child( 0 );

         my @nodes = $tree-&gt;traverse( $tree-&gt;POST_ORDER );
         my $clone = $tree-&gt;clone;
         my $mirror = $tree-&gt;clone-&gt;mirror;

         $tree-&gt;add_event_handler({
             add_child    =&gt; sub { ... },
             remove_child =&gt; sub { ... },
             value        =&gt; sub { ... },
         });

         my $old_default_error_handler = $tree-&gt;error_handler(Tree-&gt;DIE);
         my $old_object_error_handler  = $tree-&gt;error_handler($tree-&gt;DIE);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is meant to be a full-featured N-ary tree representation with configurable error-handling and a
       simple events system that allows for transparent persistence to a variety of datastores. It is derived
       from Tree::Simple, but has a simpler interface and much, much more.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Constructors</b>
   <b>new([$value])</b>
       Here, [] indicate an optional parameter.

       This will return a "Tree" object. It will accept one parameter which, if passed, will become the <u>value</u>
       (accessible by value()). All other parameters will be ignored.

       If you call "$tree-&gt;new([$value])", it will instead call clone(), then set the <u>value</u> of the clone to
       $value.

   <b>clone()</b>
       This will return a clone of $tree. The clone will be a root tree, but all children will be cloned.

       If you call "Tree-&gt;clone([$value])", it will instead call new($value).

       <b>NOTE:</b> the value is merely a shallow copy. This means that all references will be kept.

   <b>Behaviors</b>
   <b>add_child([$options],</b> <b>@nodes)</b>
       This will add all the @nodes as children of $tree. $options is a optional unblessed hashref that
       specifies options for add_child(). The optional parameters are:

       •   at

           This  specifies the index to add @nodes at. If specified, this will be passed into <b>splice()</b>. The only
           exceptions are if this is 0, it will act as an <b>unshift()</b>. If it is unset or undefined, it will act as
           a <b>push()</b>. Lastly, if it is out of range (too negative or too big [beyond the number of children]) the
           child is not added, and an error msg will be available in "<b>last_error()</b>".

       <b>add_child()</b> resets <b>last_error()</b> upon entry.

   <b>remove_child([$options],</b> <b>@nodes)</b>
       Here, [] indicate an optional parameter.

       This will remove all the @nodes from the children of $tree. You can  either  pass  in  the  actual  child
       object you wish to remove, the index of the child you wish to remove, or a combination of both.

       $options  is  a  optional  unblessed  hashref that specifies parameters for <b>remove_child()</b>. Currently, no
       parameters are used.

       <b>remove_child()</b> resets <b>last_error()</b> upon entry.

   <b>mirror()</b>
       This will modify the tree such that it is a mirror of what it was before. This means that  the  order  of
       all children is reversed.

       <b>NOTE</b>: This is a destructive action. It <u>will</u> modify the internal structure of the tree. If you wish to get
       a mirror, yet keep the original tree intact, use "my $mirror = $tree-&gt;clone-&gt;mirror".

       <b>mirror()</b>  does  not  reset <b>last_error()</b> because it (<b>mirror()</b> ) is implemented in Tree::Fast, which has no
       error handling.

   <b>traverse([$order])</b>
       Here, [] indicate an optional parameter.

       This will return a list of the nodes in the given traversal order. The default traversal  order  is  pre-
       order.

       The various traversal orders do the following steps:

       •   Pre-order

           This  will  return  the node, then the first sub tree in pre-order traversal, then the next sub tree,
           etc.

           Use "$tree-&gt;PRE_ORDER" as the $order.

       •   Post-order

           This will return the each sub-tree in post-order traversal, then the node.

           Use "$tree-&gt;POST_ORDER" as the $order.

       •   Level-order

           This will return the node, then the all children of the node, then all  grandchildren  of  the  node,
           etc.

           Use "$tree-&gt;LEVEL_ORDER" as the $order.

       <b>traverse()</b>  does  not reset <b>last_error()</b> because it (<b>traverse()</b> ) is implemented in Tree::Fast, which has
       no error handling.

   <b>tree2string($options)</b>
       Returns an arrayref of lines, suitable for printing. These lines do not end in "\n".

       Draws a nice ASCII-art representation of the tree structure.

       The tree looks like:

               Root. Attributes: {uid =&gt; "0"}
                   |--- H. Attributes: {uid =&gt; "1"}
                   |    |--- I. Attributes: {uid =&gt; "2"}
                   |    |    |--- J. Attributes: {uid =&gt; "3"}
                   |    |--- K. Attributes: {uid =&gt; "4"}
                   |    |--- L. Attributes: {uid =&gt; "5"}
                   |--- M. Attributes: {uid =&gt; "6"}
                   |--- N. Attributes: {uid =&gt; "7"}
                        |--- O. Attributes: {uid =&gt; "8"}
                             |--- P. Attributes: {uid =&gt; "9"}
                                  |--- Q. Attributes: {uid =&gt; "10"}

       Or, without attributes:

               Root
                   |--- H
                   |    |--- I
                   |    |    |--- J
                   |    |--- K
                   |    |--- L
                   |--- M
                   |--- N
                        |--- O
                             |--- P
                                  |--- Q

       See scripts/print.tree.pl.

       Example usage:

         print map("$_\n", @{$tree -&gt; tree2string});

       If you do not wish to supply options, use tree2string() or tree2string({}).

       Possible keys in the $options hashref (which defaults to {}):

       o no_attributes =&gt; $Boolean
           If 1, the node attributes are not included in the string returned.

           Default: 0 (include attributes).

       Calls "node2string($options, $node, $vert_dashes)".

   <b>State</b> <b>Queries</b>
   <b>is_root()</b>
       This will return true if $tree has no parent and false otherwise.

   <b>is_leaf()</b>
       This will return true if $tree has no children and false otherwise.

   <b>has_child(@nodes)</b>
       This will return true if $tree has each of the @nodes as a child.  Otherwise, it will return false.

       The test to see if a node is in the tree uses <b>refaddr()</b> from Scalar::Util, not the  <u>value</u>  of  the  node.
       This means @nodes must be an array of "Tree" objects.

   <b>get_index_for(@nodes)</b>
       This will return the index into the children list of $tree for each of the @nodes passed in.

   <b>Accessors</b>
   <b>parent()</b>
       This will return the parent of $tree.

   <b>children(</b> <b>[</b> <b>$idx,</b> <b>[$idx,</b> <b>..]</b> <b>]</b> <b>)</b>
       Here, [] indicate optional parameters.

       This  will  return  the children of $tree. If called in list context, it will return all the children. If
       called in scalar context, it will return the number of children.

       You may optionally pass in a list of indices to retrieve. This will return the children in the order  you
       asked for them. This is very much like an arrayslice.

   <b>root()</b>
       This will return the root node of the tree that $tree is in. The root of the root node is itself.

   <b>height()</b>
       This  will  return  the  height  of $tree. A leaf has a height of 1. A parent has a height of its tallest
       child, plus 1.

   <b>width()</b>
       This will return the width of $tree. A leaf has a width of 1. A parent has a width equal to  the  sum  of
       all the widths of its children.

   <b>depth()</b>
       This  will  return the depth of $tree. A root has a depth of 0. A child has the depth of its parent, plus
       1.

       This is the distance from the root. It is useful for things like pretty-printing the tree.

   <b>size()</b>
       This will return the number of nodes within $tree. A leaf has a size of 1.  A parent has a size equal  to
       the 1 plus the sum of all the sizes of its children.

   <b>value()</b>
       This will return the value stored in the node.

   <b>set_value([$value])</b>
       Here, [] indicate an optional parameter.

       This will set the <u>value</u> stored in the node to $value, then return $self.

       If $value is not provided, undef is used.

   <b>meta()</b>
       This  will  return  a hashref that can be used to store whatever metadata the client wishes to store. For
       example, Tree::Persist::DB uses this to store database row ids.

       It is recommended that you store your metadata in a subhashref and not in the top-level metadata hashref,
       keyed by your package name. Tree::Persist does this, using  a  unique  key  for  each  persistence  layer
       associated with that tree.  This will help prevent clobbering of metadata.

   <b>format_node($options,</b> <b>$node)</b>
       Returns a string consisting of the node's name and, optionally, it's attributes.

       Possible keys in the $options hashref:

       o no_attributes =&gt; $Boolean
           If 1, the node attributes are not included in the string returned.

           Default: 0 (include attributes).

       Calls "hashref2string($hashref)".

       Called by "node2string($options, $node, $vert_dashes)".

       You would not normally call this method.

       If you do not wish to supply options, use format_node({}, $node).

   <b>hashref2string($hashref)</b>
       Returns the given hashref as a string.

       Called by "format_node($options, $node)".

   <b>node2string($options,</b> <b>$node,</b> <b>$vert_dashes)</b>
       Returns a string of the node name and attributes, with a leading indent, suitable for printing.

       Possible keys in the $options hashref:

       o no_attributes =&gt; $Boolean
           If 1, the node attributes are not included in the string returned.

           Default: 0 (include attributes).

       Ignore the parameter $vert_dashes. The code uses it as temporary storage.

       Calls "format_node($options, $node)".

       Called by "tree2string($options)".

</pre><h4><b>ERROR</b> <b>HANDLING</b></h4><pre>
       Describe what the default error handlers do and what a custom error handler is expected to do.

   <b>Error-related</b> <b>methods</b>
   <b>error_handler(</b> <b>[</b> <b>$handler</b> <b>]</b> <b>)</b>
       This will return the current error handler for the tree. If a value is passed in, then it will be used to
       set the error handler for the tree.

       If called as a class method, this will instead work with the default error handler.

   <b>error(</b> <b>$error,</b> <b>[</b> <b>arg1</b> <b>[,</b> <b>arg2</b> <b>...]</b> <b>]</b> <b>)</b>
       Call  this  when  you wish to report an error using the currently defined error_handler for the tree. The
       only guaranteed parameter is an error string describing the issue. There may be other arguments, and  you
       may certainly provide other arguments in your subclass to be passed to your custom handler.

   <b>last_error()</b>
       If  an  error  occurred  during the last behavior, this will return the error string. It is reset only by
       <b>add_child()</b> and <b>remove_child()</b>.

   <b>Default</b> <b>error</b> <b>handlers</b>
       QUIET
           Use this error handler if you want to have  quiet  error-handling.  The  "<b>last_error()</b>"  method  will
           retrieve  the error from the last operation, if there was one. If an error occurs, the operation will
           return undefined.

       WARN
       DIE

</pre><h4><b>EVENT</b> <b>HANDLING</b></h4><pre>
       Tree provides for basic event handling. You may choose to register one or more  callbacks  to  be  called
       when the appropriate event occurs. The events are:

       •   add_child

           This event will trigger as the last step in an "add_child([$options], @nodes)" call.

           The  parameters  will  be "( $self, @args )" where @args is the arguments passed into the <b>add_child()</b>
           call.

       •   remove_child

           This event will trigger as the last step in an "remove_child([$options], @nodes)" call.

           The parameters will be "( $self, @args )" where @args is the arguments passed into the <b>remove_child()</b>
           call.

       •   value

           This event will trigger as the last step in a <b>set_value()</b> call.

           The parameters will be "( $self, $old_value )" where $old_value is what the value was before  it  was
           changed. The new value can be accessed through "$self-&gt;value()".

   <b>Event</b> <b>handling</b> <b>methods</b>
   <b>add_event_handler(</b> <b>{$type</b> <b>=&gt;</b> <b>$callback</b> <b>[,</b> <b>$type</b> <b>=&gt;</b> <b>$callback,</b> <b>...</b> <b>]}</b> <b>)</b>
       You  may  choose  to  add event handlers for any known type. Callbacks must be references to subroutines.
       They will be called in the order they are defined.

   <b>event(</b> <b>$type,</b> <b>$actor,</b> <b>@args</b> <b>)</b>
       This will trigger an event of type $type. All event handlers registered on  $tree  will  be  called  with
       parameters  of "($actor, @args)". Then, the parent will be notified of the event and its handlers will be
       called, on up to the root.

       This allows you specify an event handler on the root and be guaranteed that it will fire every  time  the
       appropriate event occurs anywhere in the tree.

</pre><h4><b>NULL</b> <b>TREE</b></h4><pre>
       If you call "$self-&gt;parent" on a root node, it will return a Tree::Null object. This is an implementation
       of  the Null Object pattern optimized for usage with Tree. It will evaluate as false in every case (using
       <u>overload</u>) and all methods called on it will return a Tree::Null object.

   <b>Notes</b>
       •   Tree::Null does <b>not</b> inherit from Tree. This is so that all the methods will go through  AUTOLOAD  vs.
           the actual method.

       •   However, calling <b>isa()</b> on a Tree::Null object will report that it is-a any object that is either Tree
           or in the Tree:: hierarchy.

       •   The Tree::Null object is a singleton.

       •   The  Tree::Null  object  <u>is</u> defined, though. I could not find a way to make it evaluate as undefined.
           That may be a good thing.

</pre><h4><b>CIRCULAR</b> <b>REFERENCES</b></h4><pre>
       Please q.v. Forest for more info on this topic.

</pre><h4><b>FAQ</b></h4><pre>
   <b>Which</b> <b>is</b> <b>the</b> <b>best</b> <b>tree</b> <b>processing</b> <b>module?</b>
       Tree::DAG_Node. More details: "SEE ALSO".

   <b>How</b> <b>do</b> <b>I</b> <b>implement</b> <b>the</b> <b>visitor</b> <b>pattern?</b>
       I have deliberately chosen to not implement the Visitor pattern as described by  Gamma  et  al.  Given  a
       sufficiently  powerful  traverse()  and  the  capabilities  of Perl, an explicit visitor object is almost
       always unneeded. If you want one, it is easy to write one yourself. Here is a simple one  I  wrote  in  5
       minutes:

         package My::Visitor;

         sub new {
             my $class = shift;
             my $opts  = @_;

             return bless {
                 tree =&gt; $opts-&gt;{tree},
                 action =&gt; $opts-&gt;{action},
             }, $class;
         }

         sub visit {
             my $self = shift;
             my ($mode) = @_;

             foreach my $node ( $self-&gt;{tree}-&gt;traverse( $mode ) ) {
                 $self-&gt;{action}-&gt;( $node );
             }
         }

   <b>Should</b> <b>I</b> <b>implement</b> <b>the</b> <b>visitor</b> <b>pattern?</b>
       No. You are better off using the "walk_down($options)" in Tree::DAG_Node method.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       o Tree::Binary
           Lightweight.

       o Tree::DAG_Node
           Lightweight, and with a long list of methods.

       o Tree::DAG_Node::Persist
           Lightweight.

       o Tree::Persist
           Lightweight.

       o Forest
           Uses Moose.

       "Tree" itself is also lightweight.

</pre><h4><b>CODE</b> <b>COVERAGE</b></h4><pre>
       These statistics are as of V 1.01.

       We  use  Devel::Cover  to  test  the code coverage of our tests. Below is the Devel::Cover report on this
       module's test suite.

         ---------------------------- ------ ------ ------ ------ ------ ------ ------
         File                           stmt   bran   cond    sub    pod   time  total
         ---------------------------- ------ ------ ------ ------ ------ ------ ------
         blib/lib/Tree.pm              100.0  100.0   94.4  100.0  100.0   67.3   99.7
         blib/lib/Tree/Binary.pm        96.4   95.0  100.0  100.0  100.0   10.7   96.7
         blib/lib/Tree/Fast.pm          99.4   95.5   91.7  100.0  100.0   22.0   98.6
         Total                          98.9   96.8   94.9  100.0  100.0  100.0   98.5
         ---------------------------- ------ ------ ------ ------ ------ ------ ------

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       •   Stevan Little for writing Tree::Simple, upon which Tree is based.

</pre><h4><b>Repository</b></h4><pre>
       &lt;https://github.com/ronsavage/Tree&gt;

</pre><h4><b>SUPPORT</b></h4><pre>
       The mailing list is at <a href="mailto:TreeCPAN@googlegroups.com">TreeCPAN@googlegroups.com</a>. I  also  read  &lt;<a href="http://www.perlmonks.com">http://www.perlmonks.com</a>&gt;  on  a  daily
       basis.

</pre><h4><b>AUTHORS</b></h4><pre>
       Rob Kinyon &lt;<a href="mailto:rob.kinyon@iinteractive.com">rob.kinyon@iinteractive.com</a>&gt;

       Stevan Little &lt;<a href="mailto:stevan.little@iinteractive.com">stevan.little@iinteractive.com</a>&gt;

       Thanks to Infinity Interactive for generously donating our time.

       Co-maintenance since V 1.02 is by Ron Savage &lt;<a href="mailto:rsavage@cpan.org">rsavage@cpan.org</a>&gt;.  Uses of 'I' in previous versions is not
       me, but will be hereafter.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2004, 2005 by Infinity Interactive, Inc.

       &lt;<a href="http://www.iinteractive.com">http://www.iinteractive.com</a>&gt;

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.38.2                                       2024-02-17                                          <u><a href="../man3pm/Tree.3pm.html">Tree</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>