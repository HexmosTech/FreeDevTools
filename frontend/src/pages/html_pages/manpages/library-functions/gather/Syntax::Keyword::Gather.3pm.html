<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Syntax::Keyword::Gather - Implements the Perl 6 'gather/take' control structure in Perl 5</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsyntax-keyword-gather-perl">libsyntax-keyword-gather-perl_1.003002-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Syntax::Keyword::Gather - Implements the Perl 6 'gather/take' control structure in Perl 5

</pre><h4><b>VERSION</b></h4><pre>
       version 1.003002

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Syntax::Keyword::Gather;

        my @list = gather {
           # Try to extract odd numbers and odd number names...
           for (@data) {
              if (/(one|three|five|seven|nine)$/) { take qq{'$_'} }
              elsif (/^\d+$/ &amp;&amp; $_ %2)            { take $_ }
           }
           # But use the default set if there aren't any of either...
           take @defaults unless gathered;
        }

       or to use the stuff that Sub::Exporter gives us, try

        # this is a silly idea
        use syntax gather =&gt; {
          gather =&gt; { -as =&gt; 'bake' },
          take   =&gt; { -as =&gt; 'cake' },
        };

        my @vals = bake { cake (1...10) };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Perl 6 provides a new control structure -- "gather" -- that allows lists to be constructed procedurally,
       without the need for a temporary variable. Within the block/closure controlled by a "gather" any call to
       "take" pushes that call's argument list to an implicitly created array.  "take" returns the number of
       elements it took.  This module implements that control structure.

       At the end of the block's execution, the "gather" returns the list of values stored in the array (in a
       list context) or a reference to the array (in a scalar context).

       For example, instead of writing:

        print do {
           my @wanted;
           while (my $line = &lt;&gt;) {
              push @wanted, $line  if $line =~ /\D/;
              push @wanted, -$line if some_other_condition($line);
           }
           push @wanted, 'EOF';
           join q{, }, @wanted;
        };

       instead we can write:

        print join q{, }, gather {
           while (my $line = &lt;&gt;) {
              take $line  if $line =~ /\D/;
              take -$line if some_other_condition($line);
           }
           take 'EOF';
        }

       and instead of:

        my $text = do {
           my $string;
           while (&lt;&gt;) {
              next if /^#|^\s*$/;
              last if /^__[DATA|END]__\n$/;
              $string .= $_;
           }
           $string;
        };

       we could write:

        my $text = join q{}, gather {
           while (&lt;&gt;) {
              next if /^#|^\s*$/;
              last if /^__[DATA|END]__\n$/;
              take $_;
           }
        };

       There is also a third function -- "gathered" -- which returns a reference to the implicit array being
       gathered. This is useful for handling defaults:

        my @odds = gather {
           for @data {
              take $_ if $_ % 2;
              take to_num($_) if /[one|three|five|nine]$/;
           }
           take (1,3,5,7,9) unless gathered;
        }

       Note that -- as the example above implies -- the "gathered" function returns a special Perl 5 array
       reference that acts like a Perl 6 array reference in boolean, numeric, and string contexts.

       It's also handy for creating the implicit array by some process more complex than by simple sequential
       pushing. For example, if we needed to prepend a count of non-numeric items:

        my @odds = gather {
           for @data {
              take $_ if $_ %2;
              take to_num($_) if /[one|three|five|seven|nine]$/;
           }
           unshift gathered, +grep(/[a-z]/i, @data);
        }

       Conceptually "gather"/"take" is the generalized form from which both "map" and "grep" derive. That is, we
       could implement those two functions as:

        sub map (&amp;@) {
          my $coderef = shift;
          my @list = @{shift @_};

          return gather {
             take $coderef-&gt;($_) for (@list)
          };
        }

        sub grep (&amp;@) {
          my $coderef = shift;
          my @list = @{shift @_};

          return gather {
             do { take $_ if $coderef-&gt;($_) } for @list
          };
        }

       A "gather" is also a very handy way of short-circuiting the construction of a list. For example, suppose
       we wanted to generate a single sorted list of lines from two sorted files, but only up to the first line
       they have in common. We could gather the lines like this:

        my @merged_diff = gather {
           my $a = &lt;$fh_a&gt;;
           my $b = &lt;$fh_b&gt;;
           while (1) {
              if ( defined $a &amp;&amp; defined $b ) {
                 if    ($a eq $b) { last }     # Duplicate means end of list
                 elsif ($a lt $b) { take $a; $a = &lt;$fh_a&gt;; }
                 else             { take $b; $b = &lt;$fh_b&gt;; }
              }
              elsif (defined $a)  { take $a; $a = &lt;$fh_a&gt;; }
              elsif (defined $b)  { take $b; $b = &lt;$fh_b&gt;; }
              else                { last }
           }
        }

       If you like it really short, you can also "gather"/"take" $_ magically:

       my @numbers_with_two = gather {
           for (1..20) {
               take if /2/
           } }; # @numbers_with_two contains 2, 12, 20

       Be aware that $_ in Perl5 is a global variable rather than the current topic like in Perl6.

</pre><h4><b>HISTORY</b></h4><pre>
       This module was forked from Damian Conway's Perl6::Gather for a few reasons.

       to avoid the slightly incendiary name
       to avoid the use of the Perl6::Exporter
       ~ doesn't overload to mean string context

</pre><h4><b>BUGS</b> <b>AND</b> <b>IRRITATIONS</b></h4><pre>
       It would be nice to be able to code the default case as:

        my @odds = gather {
           for (@data) {
              take if $_ % 2;
              take to_num($_) if /(?:one|three|five|nine)\z/;
           }
        } or (1,3,5,7,9);

       but  Perl  5's "or" imposes a scalar context on its left argument.  This is arguably a bug and definitely
       an irritation.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Arthur Axel "fREW" Schmidt &lt;frioux+<a href="mailto:cpan@gmail.com">cpan@gmail.com</a>&gt;

       •   Damian Conway

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2018 by Arthur Axel "fREW" Schmidt.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.36.0                                       2022-12-04                       <u>Syntax::Keyword::<a href="../man3pm/Gather.3pm.html">Gather</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>