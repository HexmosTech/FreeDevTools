<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zerg - a lexical scanner for BLAST reports.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libzerg-perl">libzerg-perl_1.0.4-8build6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Zerg - a lexical scanner for BLAST reports.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       use Zerg;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This manpage describes the Zerg library and its interface for use with Perl.

       The Zerg library contains a C/flex lexical scanner for BLAST reports and a set of supporting functions.
       It is centered on a "get_token" function that scans the input for specified lexical elements and, when
       one is found, returns its code and value to the user.

       It is intended to be fast: for that we used flex, which provides simple regular expression matching and
       input buffering in the generated C scanner. And it is intended to be simple in the sense of providing
       just a lexical scanner, with no features whose support could slow down its main function.

   <b>FUNCTIONS</b>
       <b>zerg_get_token()</b> is the core function of this module. Each time it is called, it scans the input BLAST
       report for the next "interesting" lexical element and returns its code and value. Codes are listed in the
       section "EXPORTED CONSTANTS (TOKEN CODES)". Code zero (not listed) means end of file.

         ($code, $value) = Zerg::zerg_get_token();

       zerg_open_file($filename) opens $filename in read-only mode and set it as the input to the scanner. If
       this function is not called, the standard input is used.

         Zerg::zerg_open_file($filename);

       <b>zerg_close_file()</b> closes the file opened with <b>zerg_open_file()</b>.

       <b>zerg_get_token_offset()</b> returns the byte offset (relative to the beginning of file) of the last token
       read. (See section BUGS).

       zerg_ignore($code) instructs zerg_get_token not to return when it finds a token with code $code.

       <b>zerg_ignore_all()</b> does zerg_ignore on all token codes.

       zerg_unignore($code) instructs zerg_get_token to return when it finds a token with code $code.

       <b>zerg_unignore_all()</b> does zerg_unignore on all token codes.

         Example:
         Zerg::zerg_ignore_all();
         Zerg::zerg_unignore(QUERY_NAME);
         Zerg::zerg_unignore(SUBJECT_NAME);

   <b>EXPORTED</b> <b>CONSTANTS</b> <b>(TOKEN</b> <b>CODES)</b>
           ALIGNMENT_LENGTH
           BLAST_VERSION
           CONVERGED
           DATABASE
           DESCRIPTION_ANNOTATION
           DESCRIPTION_EVALUE
           DESCRIPTION_HITNAME
           DESCRIPTION_SCORE
           END_OF_REPORT
           EVALUE
           GAPS
           HSP_METHOD
           IDENTITIES
           NOHITS
           PERCENT_IDENTITIES
           PERCENT_POSITIVES
           POSITIVES
           QUERY_ALI
           QUERY_ANNOTATION
           QUERY_END
           QUERY_FRAME
           QUERY_LENGTH
           QUERY_NAME
           QUERY_ORIENTATION
           QUERY_START
           REFERENCE
           ROUND_NUMBER
           ROUND_SEQ_FOUND
           ROUND_SEQ_NEW
           SCORE
           SCORE_BITS
           SEARCHING
           SUBJECT_ALI
           SUBJECT_ANNOTATION
           SUBJECT_END
           SUBJECT_FRAME
           SUBJECT_LENGTH
           SUBJECT_NAME
           SUBJECT_ORIENTATION
           SUBJECT_START
           TAIL_OF_REPORT
           UNMATCHED

   <b>NOTES</b> <b>ON</b> <b>THE</b> <b>SCANNER</b>
       Some BLAST parsers rely on some simple regular expression matches to conclude about token types and
       values. For example: an input line matching /^Query=\s(\S+)/ should make such a "loose" parser to infer
       that a token was found, it is a query name and its value is $1. Although improbable, it is perfectly
       possible for an anotation field to match /^Query=\s(\S+)<a href="file:/.">/.</a> Worse than this is the fact that those parsers
       are often unable to detect corrupt or truncated BLAST reports, possibly producing inaccurate information.

       The scanner provided by this library is much more stringent: for a token to match it must be in its place
       in the context of a BLAST report. For example: in a single BLAST report, a QUERY_NAME cannot follow
       another QUERY_NAME. The scanner can be thought as, and in fact it is, a big regular expression that
       matches an entire BLAST report.

       A special token code (UNMATCHED) is provided for cases in which the input text does not match any other
       lexical rule of the scanner. When an umnacthed character is found, either the report is corrupt or the
       scanner has a bug.

       If you are interested in only a few token codes, try to <b>zerg_ignore()</b> as much codes you can. This will
       avoid unnecessary function calls that eat a lot of CPU.

</pre><h4><b>EXAMPLES</b></h4><pre>
       This program prints the code and the value of each token it finds.

         #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
         use strict;
         use Zerg;

         my ($code, $value);
         while((($code, $value)= Zerg::zerg_get_token()) &amp;&amp; $code)
         {
             print "$code\t$value\n";
         }

       The program below is a "syntax checker". The presence of UNMATCHEDs is a strong indicator of problems in
       the BLAST report. (See section NOTES ON THE SCANNER)

         #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
         use strict;
         use Zerg;

         my ($code, $value);

         Zerg::zerg_ignore_all();
         Zerg::zerg_unignore(UNMATCHED);

         while((($code, $value)= Zerg::zerg_get_token()) &amp;&amp; $code)
         {
             print "UNMATCHED CHAR:\t$value\n";
         }

</pre><h4><b>BUGS</b></h4><pre>
       The tokens DESCRIPTION_ANNOTATION, DESCRIPTION_SCORE and DESCRIPTION_EVALUE are scanned all at once and
       released one by one on user request. So, if the user wants to get any of these fields, they must be
       unignored BEFORE scanning DESCRIPTION_ANNOTATION.

       <b>zerg_get_token_offset()</b> may return incorrect values for these tokens and those that are modified by the
       parser, namely: QUERY_LENGTH, SUBJECT_LENGTH, EVALUE, GAPS.

</pre><h4><b>TODO</b></h4><pre>
       Add more tokens to the scanner as the need for that appears.

</pre><h4><b>AUTHOR</b></h4><pre>
       Apu√£ Paquola, IQ-USP Bioinformatics Lab, <a href="mailto:apua@iq.usp.br">apua@iq.usp.br</a>

       Laszlo Kajan &lt;<a href="mailto:lkajan@rostlab.org">lkajan@rostlab.org</a>&gt;, Technical University of Munich, Germany

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), <b><a href="../man1/flex.1.html">flex</a></b>(1), <a href="http://www.bioperl.org">http://www.bioperl.org</a>, <a href="http://www.ncbi.nlm.nih.gov/BLAST">http://www.ncbi.nlm.nih.gov/BLAST</a>

perl v5.40.0                                       2024-10-20                                          <u><a href="../man3pm/Zerg.3pm.html">Zerg</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>