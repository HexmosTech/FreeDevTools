<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lmdif_, lmdif1_ - minimize the sum of squares of m nonlinear functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/minpack-dev">minpack-dev_19961126+dfsg1-5build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       lmdif_, lmdif1_ - minimize the sum of squares of m nonlinear functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>include</b> <b>&lt;minpack.h&gt;</b>

       <b>void</b> <b>lmdif1_</b> <b>(</b> <b>void</b> <b>(*</b><u>fcn</u><b>)(int</b> <b>*</b><u>m</u><b>,</b> <b>int</b> <b>*</b><u>n</u><b>,</b> <b>double</b> <b>*</b><u>x</u><b>,</b> <b>double</b> <b>*</b><u>fvec</u><b>,</b> <b>int</b> <b>*</b><u>iflag</u><b>),</b>
         <b>int</b> <b>*</b><u>m</u><b>,</b> <b>int</b> <b>*</b> <u>n</u><b>,</b> <b>double</b> <b>*</b><u>x</u><b>,</b> <b>double</b> <b>*</b><u>fvec</u><b>,</b>
         <b>double</b> <b>*</b><u>tol</u><b>,</b> <b>int</b> <b>*</b><u>info</u><b>,</b> <b>int</b> <b>*</b><u>iwa</u><b>,</b> <b>double</b> <b>*</b><u>wa</u><b>,</b> <b>int</b> <b>*</b><u>lwa</u><b>);</b>

       <b>void</b> <b>lmdif_</b> <b>(</b> <b>void</b> <b>(*</b><u>fcn</u><b>)(int</b> <b>*</b><u>m</u><b>,</b> <b>int</b> <b>*</b><u>n</u><b>,</b> <b>double</b> <b>*</b><u>x</u><b>,</b> <b>double</b> <b>*</b><u>fvec</u><b>,</b> <b>int</b> <b>*</b><u>iflag</u><b>),</b>
         <b>int</b> <b>*</b><u>m</u><b>,</b> <b>int</b> <b>*</b><u>n</u><b>,</b> <b>double</b> <b>*</b><u>x</u><b>,</b> <b>double</b> <b>*</b><u>fvec</u><b>,</b>
         <b>double</b> <b>*</b><u>ftol</u><b>,</b> <b>double</b> <b>*</b><u>xtol</u><b>,</b> <b>double</b> <b>*</b><u>gtol</u><b>,</b> <b>int</b> <b>*</b><u>maxfev</u><b>,</b> <b>double</b> <b>*</b><u>epsfcn</u><b>,</b> <b>double</b> <b>*</b><u>diag</u><b>,</b> <b>int</b> <b>*</b><u>mode</u><b>,</b> <b>double</b>
         <b>*</b><u>factor</u><b>,</b> <b>int</b> <b>*</b><u>nprint</u><b>,</b> <b>int</b> <b>*</b><u>info</u><b>,</b> <b>int</b> <b>*</b><u>nfev</u><b>,</b> <b>double</b> <b>*</b><u>fjac</u><b>,</b>
         <b>int</b> <b>*</b><u>ldfjac</u><b>,</b> <b>int</b> <b>*</b><u>ipvt</u><b>,</b> <b>double</b> <b>*</b><u>qtf</u><b>,</b>
         <b>double</b> <b>*</b><u>wa1</u><b>,</b> <b>double</b> <b>*</b><u>wa2</u><b>,</b> <b>double</b> <b>*</b><u>wa3</u><b>,</b> <b>double</b> <b>*</b><u>wa4</u> <b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  purpose of <b>lmdif_</b> is to minimize the sum of the squares of <u>m</u> nonlinear functions in <u>n</u> variables by a
       modification of the Levenberg-Marquardt algorithm. The user must provide a  subroutine  which  calculates
       the functions. The Jacobian is then calculated by a forward-difference approximation.

       <b>lmdif1_</b> serves the same purpose but has a simplified calling sequence.

   <b>Language</b> <b>notes</b>
       These functions are written in FORTRAN. If calling from C, keep these points in mind:

       Name mangling.
              With <b>gfortran</b>, all the function names end in an underscore.

       Compile with <b>gfortran</b>.
              Even  if  your program is all C code, you should link with <b>gfortran</b> so it will pull in the FORTRAN
              libraries automatically.  It's easiest just to use <b>gfortran</b> to do all the compiling.  (It  handles
              C just fine.)

       Call by reference.
              All function parameters must be pointers.

       Column-major arrays.
              Suppose  a  function  returns an array with 5 rows and 3 columns in an array <u>z</u> and in the call you
              have declared a leading dimension of 7.  The FORTRAN and equivalent C references are:

                   z(1,1)         z[0]
                   z(2,1)         z[1]
                   z(5,1)         z[4]
                   z(1,2)         z[7]
                   z(1,3)         z[14]
                   z(i,j)         z[(i-1) + (j-1)*7]
              <u>fcn</u> is the name of the user-supplied subroutine which calculates the functions.  In  FORTRAN,  <u>fcn</u>
              must  be  declared  in an external statement in the user calling program, and should be written as
              follows:

                subroutine fcn(m,n,x,fvec,iflag)
                integer m,n,iflag
                double precision x(n),<a href="../manm/fvec.m.html">fvec</a>(m)
                ----------
                calculate the functions at x and
                return this vector in fvec.
                ----------
                return
                end

              In C, <u>fcn</u> should be written as follows:

                void fcn(int *m, int *n, double *x, double *fvec, int *iflag)
                {
                       /* calculate the functions at x and return
                          the values in fvec[0] through fvec[m-1] */
                }

              The value of <u>iflag</u> should not be changed by <u>fcn</u> unless the user wants to  terminate  execution  of
              <b>lmdif_</b> (or <b>lmdif1_</b>). In this case set <u>iflag</u> to a negative integer.

   <b>Parameters</b> <b>for</b> <b>both</b> <b>lmdif_</b> <b>and</b> <b>lmdif1_</b>
       <u>m</u> is a positive integer input variable set to the number of functions.

       <u>n</u> is a positive integer input variable set to the number of variables. <u>n</u> must not exceed <u>m</u>.

       <u>x</u>  is an array of length <u>n</u>. On input <u>x</u> must contain an initial estimate of the solution vector. On output
       <u>x</u> contains the final estimate of the solution vector.

       <u>fvec</u> is an output array of length <u>m</u> which contains the functions evaluated at the output <u>x</u>.

   <b>Parameters</b> <b>for</b> <b>lmdif1_</b>
       <u>tol</u> is a nonnegative input variable.  Termination occurs when the algorithm  estimates  either  that  the
       relative error in the sum of squares is at most <u>tol</u> or that the relative error between <u>x</u> and the solution
       is at most <u>tol</u>.

       <u>info</u>  is  an integer output variable. if the user has terminated execution, <u>info</u> is set to the (negative)
       value of iflag. see description of <u>fcn</u>. otherwise, <u>info</u> is set as follows.

         <u>info</u> = 0  improper input parameters.

         <u>info</u> = 1  algorithm estimates that the relative error in the sum of squares is at most <u>tol</u>.

         <u>info</u> = 2  algorithm estimates that the relative error between x and the solution is at most <u>tol</u>.

         <u>info</u> = 3  conditions for <u>info</u> = 1 and <u>info</u> = 2 both hold.

         <u>info</u> = 4  <u>fvec</u> is orthogonal to the columns of the Jacobian to machine precision.

         <u>info</u> = 5  number of calls to <u>fcn</u> has reached or exceeded 200*(<u>n</u>+1).

         <u>info</u> = 6  <u>tol</u> is too small. no further reduction in the sum of squares is possible.

         <u>info</u> = 7  <u>tol</u> is too small. no further improvement in the approximate solution x is possible.

       <u>iwa</u> is an integer work array of length <u>n</u>.

       <u>wa</u> is a work array of length <u>lwa</u>.

       <u>lwa</u> is an integer input variable not less than <u>m</u>*<u>n</u> + 5*<u>n</u> + <u>m</u>.

   <b>Parameters</b> <b>for</b> <b>lmdif_</b>
       <u>ftol</u> is a nonnegative input variable. Termination occurs when both the actual and predicted relative  re‐
       ductions  in the sum of squares are at most <u>ftol</u>.  Therefore, <u>ftol</u> measures the relative error desired in
       the sum of squares.

       <u>xtol</u> is a nonnegative input variable. Termination occurs when the relative error between two  consecutive
       iterates  is  at  most <u>xtol</u>. Therefore, <u>xtol</u> measures the relative error desired in the approximate solu‐
       tion.

       <u>gtol</u> is a nonnegative input variable. Termination occurs when the cosine of the angle  between  <u>fvec</u>  and
       any  column of the Jacobian is at most <u>gtol</u> in absolute value. Therefore, <u>gtol</u> measures the orthogonality
       desired between the function vector and the columns of the Jacobian.

       <u>maxfev</u> is a positive integer input variable. Termination occurs when the number of calls  to  <u>fcn</u>  is  at
       least <u>maxfev</u> by the end of an iteration.

       <u>epsfcn</u> is an input variable used in determining a suitable step length for the forward-difference approx‐
       imation. This approximation assumes that the relative errors in the functions are of the order of <u>epsfcn</u>.
       If <u>epsfcn</u> is less than the machine precision, it is assumed that the relative errors in the functions are
       of the order of the machine precision.

       <u>diag</u>  is  an  array  of length <u>n</u>. If <u>mode</u> = 1 (see below), <u>diag</u> is internally set. If <u>mode</u> = 2, <u>diag</u> must
       contain positive entries that serve as multiplicative scale factors for the variables.

       <u>mode</u> is an integer input variable. If <u>mode</u> = 1, the variables will be scaled internally. If <u>mode</u> = 2, the
       scaling is specified by the input <u>diag</u>. Other values of mode are equivalent to <u>mode</u> = 1.

       <u>factor</u> is a positive input variable used in determining the initial step bound. This bound is set to  the
       product of <u>factor</u> and the euclidean norm of <u>diag</u>*<u>x</u> if the latter is nonzero, or else to <u>factor</u> itself. In
       most cases factor should lie in the interval (.1,100.). 100. is a generally recommended value.

       <u>nprint</u>  is  an  integer input variable that enables controlled printing of iterates if it is positive. In
       this case, fcn is called with <u>iflag</u> = 0 at the beginning of the first iteration and every  <u>nprint</u>  itera‐
       tions  thereafter  and  immediately prior to return, with <u>x</u> and <u>fvec</u> available for printing. If <u>nprint</u> is
       not positive, no special calls of fcn with <u>iflag</u> = 0 are made.

       <u>info</u> is an integer output variable. If the user has terminated execution, info is set to  the  (negative)
       value of iflag. See description of fcn. Otherwise, info is set as follows.

         <u>info</u> = 0  improper input parameters.

         <u>info</u> = 1  both actual and predicted relative reductions in the sum of squares are at most <u>ftol</u>.

         <u>info</u> = 2  relative error between two consecutive iterates is at most <u>xtol</u>.

         <u>info</u> = 3  conditions for <u>info</u> = 1 and <u>info</u> = 2 both hold.

         <u>info</u>  =  4   the cosine of the angle between fvec and any column of the Jacobian is at most gtol in ab‐
       solute value.

         <u>info</u> = 5  number of calls to <u>fcn</u> has reached or exceeded maxfev.

         <u>info</u> = 6  <u>ftol</u> is too small. No further reduction in the sum of squares is possible.

         <u>info</u> = 7  <u>xtol</u> is too small. No further improvement in the approximate solution x is possible.

         <u>info</u> = 8 <u>gtol</u> is too small. <u>fvec</u> is orthogonal to the columns of the Jacobian to machine precision.

       <u>nfev</u> is an integer output variable set to the number of calls to <u>fcn</u>.

       <u>fjac</u> is an output <u>m</u> by <u>n</u> array. The upper <u>n</u> by <u>n</u> submatrix of <u>fjac</u> contains an upper triangular matrix  <u>r</u>
       with diagonal elements of nonincreasing magnitude such that

                t     t           t
               p *(jac *jac)*p = r *r,

       where <u>p</u> is a permutation matrix and <u>jac</u> is the final calculated Jacobian. column <b>j</b> of <u>p</u> is column <u>ipvt</u>(<b>j</b>)
       (see  below)  of  the  identity matrix. The lower trapezoidal part of <u>fjac</u> contains information generated
       during the computation of <u>r</u>.

       <u>ldfjac</u> is a positive integer input variable not less than <u>m</u> which specifies the leading dimension of  the
       array <u>fjac</u>.

       <u>ipvt</u>  is  an integer output array of length <u>n</u>. <u>ipvt</u> defines a permutation matrix <u>p</u> such that <u>jac</u>*<u>p</u> = <u>q</u>*<u>r</u>,
       where <u>jac</u> is the final calculated Jacobian, <u>q</u> is orthogonal (not stored), and <u>r</u> is upper triangular  with
       diagonal elements of nonincreasing magnitude.  Column <b>j</b> of <u>p</u> is column <u>ipvt</u>(<b>j</b>) of the identity matrix.

       <u>qtf</u> is an output array of length <u>n</u> which contains the first <u>n</u> elements of the vector (<u>q</u> transpose)*<u>fvec</u>.

       <u>wa1</u>, <u>wa2</u>, and <u>wa3</u> are work arrays of length <u>n</u>.

       <u>wa4</u> is a work array of length <u>m</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/lmder.3.html">lmder</a></b>(3), <b><a href="../man3/lmder1.3.html">lmder1</a></b>(3), <b><a href="../man3/lmstr.3.html">lmstr</a></b>(3), <b><a href="../man3/lmstr1.3.html">lmstr1</a></b>(3).

</pre><h4><b>AUTHORS</b></h4><pre>
       Jorge More', Burt Garbow, and Ken Hillstrom at Argonne National Laboratory.  This manual page was written
       by Jim Van Zandt &lt;<a href="mailto:jrv@debian.org">jrv@debian.org</a>&gt;, for the Debian GNU/Linux system (but may be used by others).

Minpack                                           March 8, 2002                                        <u>LMDIF</u><b><a href="../man3/_.3.html">_</a></b>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>