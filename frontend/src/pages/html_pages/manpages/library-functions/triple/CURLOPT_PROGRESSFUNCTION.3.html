<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CURLOPT_PROGRESSFUNCTION - progress meter callback</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CURLOPT_PROGRESSFUNCTION - progress meter callback

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       int progress_callback(void *clientp,
                             double dltotal,
                             double dlnow,
                             double ultotal,
                             double ulnow);

       CURLcode curl_easy_setopt(CURL *handle, CURLOPT_PROGRESSFUNCTION,
                                 progress_callback);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Pass a pointer to your callback function, which should match the prototype shown above.

       This option is deprecated and we encourage users to use the newer <u><a href="../man3/CURLOPT_XFERINFOFUNCTION.3.html">CURLOPT_XFERINFOFUNCTION</a>(3)</u> instead, if
       you can.

       This  function  gets called by libcurl instead of its internal equivalent with a frequent interval. While
       data is being transferred it is invoked frequently, and during slow periods like when  nothing  is  being
       transferred it can slow down to about one call per second.

       <u>clientp</u>  is  the  pointer  set with <u><a href="../man3/CURLOPT_PROGRESSDATA.3.html">CURLOPT_PROGRESSDATA</a>(3)</u>, it is not used by libcurl but is only passed
       along from the application to the callback.

       The callback gets told how much data libcurl is about to transfer  and  has  transferred,  in  number  of
       bytes.  <u>dltotal</u>  is  the total number of bytes libcurl expects to download in this transfer. <u>dlnow</u> is the
       number of bytes downloaded so far. <u>ultotal</u> is the total number of bytes libcurl expects to upload in this
       transfer. <u>ulnow</u> is the number of bytes uploaded so far.

       Unknown/unused argument values passed to the callback are be set to zero (like if you only download data,
       the upload size remains 0). Many times the callback is called one or more times first,  before  it  knows
       the data sizes so a program must be made to handle that.

       Return zero from the callback if everything is fine.

       If  your callback function returns CURL_PROGRESSFUNC_CONTINUE it causes libcurl to continue executing the
       default progress function.

       Return 1 from this callback to make libcurl abort the transfer and return <u>CURLE_ABORTED_BY_CALLBACK</u>.

       If you transfer data with the multi interface, this function is not called  during  periods  of  idleness
       unless you call the appropriate libcurl function that performs transfers.

       <u><a href="../man3/CURLOPT_NOPROGRESS.3.html">CURLOPT_NOPROGRESS</a>(3)</u> must be set to 0 to make this function actually get called.

</pre><h4><b>DEFAULT</b></h4><pre>
       NULL. libcurl has an internal progress meter. That is rarely wanted by users.

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects all supported protocols

</pre><h4><b>EXAMPLE</b></h4><pre>
       struct progress {
         char *private;
         size_t size;
       };

       static int progress_callback(void *clientp,
                                    double dltotal,
                                    double dlnow,
                                    double ultotal,
                                    double ulnow)
       {
         struct progress *memory = clientp;
         printf("private: %p\n", memory-&gt;private);

         /* use the values */

         return 0; /* all is good */
       }

       int main(void)
       {
         struct progress data;

         CURL *curl = curl_easy_init();
         if(curl) {
           /* pass struct to callback  */
           curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, &amp;data);
           curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, progress_callback);

           curl_easy_perform(curl);
         }
       }

</pre><h4><b>DEPRECATED</b></h4><pre>
       Deprecated since 7.32.0.

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.1

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <u><a href="../man3/curl_easy_setopt.3.html">curl_easy_setopt</a>(3)</u> returns a CURLcode indicating success or error.

       CURLE_OK (0) means everything was OK, non-zero means an error occurred, see <u><a href="../man3/libcurl-errors.3.html">libcurl-errors</a>(3)</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/CURLOPT_NOPROGRESS.3.html">CURLOPT_NOPROGRESS</a></b>(3), <b><a href="../man3/CURLOPT_VERBOSE.3.html">CURLOPT_VERBOSE</a></b>(3), <b><a href="../man3/CURLOPT_XFERINFOFUNCTION.3.html">CURLOPT_XFERINFOFUNCTION</a></b>(3)

libcurl                                            2025-06-16                        <u><a href="../man3/CURLOPT_PROGRESSFUNCTION.3.html">CURLOPT_PROGRESSFUNCTION</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>