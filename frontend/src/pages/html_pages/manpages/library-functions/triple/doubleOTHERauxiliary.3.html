<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>doubleOTHERauxiliary - double</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/liblapack-doc">liblapack-doc_3.10.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       doubleOTHERauxiliary - double

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>dlabrd</b> (M, N, NB, A, LDA, D, E, TAUQ, TAUP, X, LDX, Y, LDY)
           <b>DLABRD</b> reduces the first nb rows and columns of a general matrix to a bidiagonal form.
       subroutine <b>dlacn2</b> (N, V, X, ISGN, EST, KASE, ISAVE)
           <b>DLACN2</b> estimates the 1-norm of a square matrix, using reverse communication for evaluating matrix-
           vector products.
       subroutine <b>dlacon</b> (N, V, X, ISGN, EST, KASE)
           <b>DLACON</b> estimates the 1-norm of a square matrix, using reverse communication for evaluating matrix-
           vector products.
       subroutine <b>dladiv</b> (A, B, C, D, P, Q)
           <b>DLADIV</b> performs complex division in real arithmetic, avoiding unnecessary overflow.
       subroutine <b>dladiv1</b> (A, B, C, D, P, Q)
       double precision function <b>dladiv2</b> (A, B, C, D, R, T)
       subroutine <b>dlaein</b> (RIGHTV, NOINIT, N, H, LDH, WR, WI, VR, VI, B, LDB, WORK, EPS3, SMLNUM, BIGNUM, INFO)
           <b>DLAEIN</b> computes a specified right or left eigenvector of an upper Hessenberg matrix by inverse
           iteration.
       subroutine <b>dlaexc</b> (WANTQ, N, T, LDT, Q, LDQ, J1, N1, N2, WORK, INFO)
           <b>DLAEXC</b> swaps adjacent diagonal blocks of a real upper quasi-triangular matrix in Schur canonical
           form, by an orthogonal similarity transformation.
       subroutine <b>dlag2</b> (A, LDA, B, LDB, SAFMIN, SCALE1, SCALE2, WR1, WR2, WI)
           <b>DLAG2</b> computes the eigenvalues of a 2-by-2 generalized eigenvalue problem, with scaling as necessary
           to avoid over-/underflow.
       subroutine <b>dlag2s</b> (M, N, A, LDA, SA, LDSA, INFO)
           <b>DLAG2S</b> converts a double precision matrix to a single precision matrix.
       subroutine <b>dlags2</b> (UPPER, A1, A2, A3, B1, B2, B3, CSU, SNU, CSV, SNV, CSQ, SNQ)
           <b>DLAGS2</b> computes 2-by-2 orthogonal matrices U, V, and Q, and applies them to matrices A and B such
           that the rows of the transformed A and B are parallel.
       subroutine <b>dlagtm</b> (TRANS, N, NRHS, ALPHA, DL, D, DU, X, LDX, BETA, B, LDB)
           <b>DLAGTM</b> performs a matrix-matrix product of the form C = αAB+βC, where A is a tridiagonal matrix, B
           and C are rectangular matrices, and α and β are scalars, which may be 0, 1, or -1.
       subroutine <b>dlagv2</b> (A, LDA, B, LDB, ALPHAR, ALPHAI, BETA, CSL, SNL, CSR, SNR)
           <b>DLAGV2</b> computes the Generalized Schur factorization of a real 2-by-2 matrix pencil (A,B) where B is
           upper triangular.
       subroutine <b>dlahqr</b> (WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI, ILOZ, IHIZ, Z, LDZ, INFO)
           <b>DLAHQR</b> computes the eigenvalues and Schur factorization of an upper Hessenberg matrix, using the
           double-shift/single-shift QR algorithm.
       subroutine <b>dlahr2</b> (N, K, NB, A, LDA, TAU, T, LDT, Y, LDY)
           <b>DLAHR2</b> reduces the specified number of first columns of a general rectangular matrix A so that
           elements below the specified subdiagonal are zero, and returns auxiliary matrices which are needed to
           apply the transformation to the unreduced part of A.
       subroutine <b>dlaic1</b> (JOB, J, X, SEST, W, GAMMA, SESTPR, S, C)
           <b>DLAIC1</b> applies one step of incremental condition estimation.
       subroutine <b>dlaln2</b> (LTRANS, NA, NW, SMIN, CA, A, LDA, D1, D2, B, LDB, WR, WI, X, LDX, SCALE, XNORM, INFO)
           <b>DLALN2</b> solves a 1-by-1 or 2-by-2 linear system of equations of the specified form.
       double precision function <b>dlangt</b> (NORM, N, DL, D, DU)
           <b>DLANGT</b> returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value
           of any element of a general tridiagonal matrix.
       double precision function <b>dlanhs</b> (NORM, N, A, LDA, WORK)
           <b>DLANHS</b> returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value
           of any element of an upper Hessenberg matrix.
       double precision function <b>dlansb</b> (NORM, UPLO, N, K, AB, LDAB, WORK)
           <b>DLANSB</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a symmetric band matrix.
       double precision function <b>dlansp</b> (NORM, UPLO, N, AP, WORK)
           <b>DLANSP</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a symmetric matrix supplied in packed form.
       double precision function <b>dlantb</b> (NORM, UPLO, DIAG, N, K, AB, LDAB, WORK)
           <b>DLANTB</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a triangular band matrix.
       double precision function <b>dlantp</b> (NORM, UPLO, DIAG, N, AP, WORK)
           <b>DLANTP</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a triangular matrix supplied in packed form.
       double precision function <b>dlantr</b> (NORM, UPLO, DIAG, M, N, A, LDA, WORK)
           <b>DLANTR</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a trapezoidal or triangular matrix.
       subroutine <b>dlanv2</b> (A, B, C, D, RT1R, RT1I, RT2R, RT2I, CS, SN)
           <b>DLANV2</b> computes the Schur factorization of a real 2-by-2 nonsymmetric matrix in standard form.
       subroutine <b>dlapll</b> (N, X, INCX, Y, INCY, SSMIN)
           <b>DLAPLL</b> measures the linear dependence of two vectors.
       subroutine <b>dlapmr</b> (FORWRD, M, N, X, LDX, K)
           <b>DLAPMR</b> rearranges rows of a matrix as specified by a permutation vector.
       subroutine <b>dlapmt</b> (FORWRD, M, N, X, LDX, K)
           <b>DLAPMT</b> performs a forward or backward permutation of the columns of a matrix.
       subroutine <b>dlaqp2</b> (M, N, OFFSET, A, LDA, JPVT, TAU, VN1, VN2, WORK)
           <b>DLAQP2</b> computes a QR factorization with column pivoting of the matrix block.
       subroutine <b>dlaqps</b> (M, N, OFFSET, NB, KB, A, LDA, JPVT, TAU, VN1, VN2, AUXV, F, LDF)
           <b>DLAQPS</b> computes a step of QR factorization with column pivoting of a real m-by-n matrix A by using
           BLAS level 3.
       subroutine <b>dlaqr0</b> (WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI, ILOZ, IHIZ, Z, LDZ, WORK, LWORK, INFO)
           <b>DLAQR0</b> computes the eigenvalues of a Hessenberg matrix, and optionally the matrices from the Schur
           decomposition.
       subroutine <b>dlaqr1</b> (N, H, LDH, SR1, SI1, SR2, SI2, V)
           <b>DLAQR1</b> sets a scalar multiple of the first column of the product of 2-by-2 or 3-by-3 matrix H and
           specified shifts.
       subroutine <b>dlaqr2</b> (WANTT, WANTZ, N, KTOP, KBOT, NW, H, LDH, ILOZ, IHIZ, Z, LDZ, NS, ND, SR, SI, V, LDV,
           NH, T, LDT, NV, WV, LDWV, WORK, LWORK)
           <b>DLAQR2</b> performs the orthogonal similarity transformation of a Hessenberg matrix to detect and deflate
           fully converged eigenvalues from a trailing principal submatrix (aggressive early deflation).
       subroutine <b>dlaqr3</b> (WANTT, WANTZ, N, KTOP, KBOT, NW, H, LDH, ILOZ, IHIZ, Z, LDZ, NS, ND, SR, SI, V, LDV,
           NH, T, LDT, NV, WV, LDWV, WORK, LWORK)
           <b>DLAQR3</b> performs the orthogonal similarity transformation of a Hessenberg matrix to detect and deflate
           fully converged eigenvalues from a trailing principal submatrix (aggressive early deflation).
       subroutine <b>dlaqr4</b> (WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI, ILOZ, IHIZ, Z, LDZ, WORK, LWORK, INFO)
           <b>DLAQR4</b> computes the eigenvalues of a Hessenberg matrix, and optionally the matrices from the Schur
           decomposition.
       subroutine <b>dlaqr5</b> (WANTT, WANTZ, KACC22, N, KTOP, KBOT, NSHFTS, SR, SI, H, LDH, ILOZ, IHIZ, Z, LDZ, V,
           LDV, U, LDU, NV, WV, LDWV, NH, WH, LDWH)
           <b>DLAQR5</b> performs a single small-bulge multi-shift QR sweep.
       subroutine <b>dlaqsb</b> (UPLO, N, KD, AB, LDAB, S, SCOND, AMAX, EQUED)
           <b>DLAQSB</b> scales a symmetric/Hermitian band matrix, using scaling factors computed by spbequ.
       subroutine <b>dlaqsp</b> (UPLO, N, AP, S, SCOND, AMAX, EQUED)
           <b>DLAQSP</b> scales a symmetric/Hermitian matrix in packed storage, using scaling factors computed by
           sppequ.
       subroutine <b>dlaqtr</b> (LTRAN, LREAL, N, T, LDT, B, W, SCALE, X, WORK, INFO)
           <b>DLAQTR</b> solves a real quasi-triangular system of equations, or a complex quasi-triangular system of
           special form, in real arithmetic.
       subroutine <b>dlar1v</b> (N, B1, BN, LAMBDA, D, L, LD, LLD, PIVMIN, GAPTOL, Z, WANTNC, NEGCNT, ZTZ, MINGMA, R,
           ISUPPZ, NRMINV, RESID, RQCORR, WORK)
           <b>DLAR1V</b> computes the (scaled) r-th column of the inverse of the submatrix in rows b1 through bn of the
           tridiagonal matrix LDLT - λI.
       subroutine <b>dlar2v</b> (N, X, Y, Z, INCX, C, S, INCC)
           <b>DLAR2V</b> applies a vector of plane rotations with real cosines and real sines from both sides to a
           sequence of 2-by-2 symmetric/Hermitian matrices.
       subroutine <b>dlarf</b> (SIDE, M, N, V, INCV, TAU, C, LDC, WORK)
           <b>DLARF</b> applies an elementary reflector to a general rectangular matrix.
       subroutine <b>dlarfb</b> (SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV, T, LDT, C, LDC, WORK, LDWORK)
           <b>DLARFB</b> applies a block reflector or its transpose to a general rectangular matrix.
       subroutine <b>dlarfb_gett</b> (IDENT, M, N, K, T, LDT, A, LDA, B, LDB, WORK, LDWORK)
           <b>DLARFB_GETT</b>
       subroutine <b>dlarfg</b> (N, ALPHA, X, INCX, TAU)
           <b>DLARFG</b> generates an elementary reflector (Householder matrix).
       subroutine <b>dlarfgp</b> (N, ALPHA, X, INCX, TAU)
           <b>DLARFGP</b> generates an elementary reflector (Householder matrix) with non-negative beta.
       subroutine <b>dlarft</b> (DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT)
           <b>DLARFT</b> forms the triangular factor T of a block reflector H = I - vtvH
       subroutine <b>dlarfx</b> (SIDE, M, N, V, TAU, C, LDC, WORK)
           <b>DLARFX</b> applies an elementary reflector to a general rectangular matrix, with loop unrolling when the
           reflector has order ≤ 10.
       subroutine <b>dlarfy</b> (UPLO, N, V, INCV, TAU, C, LDC, WORK)
           <b>DLARFY</b>
       subroutine <b>dlargv</b> (N, X, INCX, Y, INCY, C, INCC)
           <b>DLARGV</b> generates a vector of plane rotations with real cosines and real sines.
       subroutine <b>dlarrv</b> (N, VL, VU, D, L, PIVMIN, ISPLIT, M, DOL, DOU, MINRGP, RTOL1, RTOL2, W, WERR, WGAP,
           IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ, WORK, IWORK, INFO)
           <b>DLARRV</b> computes the eigenvectors of the tridiagonal matrix T = L D LT given L, D and the eigenvalues
           of L D LT.
       subroutine <b>dlartv</b> (N, X, INCX, Y, INCY, C, S, INCC)
           <b>DLARTV</b> applies a vector of plane rotations with real cosines and real sines to the elements of a pair
           of vectors.
       subroutine <b>dlaswp</b> (N, A, LDA, K1, K2, IPIV, INCX)
           <b>DLASWP</b> performs a series of row interchanges on a general rectangular matrix.
       subroutine <b>dlat2s</b> (UPLO, N, A, LDA, SA, LDSA, INFO)
           <b>DLAT2S</b> converts a double-precision triangular matrix to a single-precision triangular matrix.
       subroutine <b>dlatbs</b> (UPLO, TRANS, DIAG, NORMIN, N, KD, AB, LDAB, X, SCALE, CNORM, INFO)
           <b>DLATBS</b> solves a triangular banded system of equations.
       subroutine <b>dlatdf</b> (IJOB, N, Z, LDZ, RHS, RDSUM, RDSCAL, IPIV, JPIV)
           <b>DLATDF</b> uses the LU factorization of the n-by-n matrix computed by sgetc2 and computes a contribution
           to the reciprocal Dif-estimate.
       subroutine <b>dlatps</b> (UPLO, TRANS, DIAG, NORMIN, N, AP, X, SCALE, CNORM, INFO)
           <b>DLATPS</b> solves a triangular system of equations with the matrix held in packed storage.
       subroutine <b>dlatrd</b> (UPLO, N, NB, A, LDA, E, TAU, W, LDW)
           <b>DLATRD</b> reduces the first nb rows and columns of a symmetric/Hermitian matrix A to real tridiagonal
           form by an orthogonal similarity transformation.
       subroutine <b>dlatrs</b> (UPLO, TRANS, DIAG, NORMIN, N, A, LDA, X, SCALE, CNORM, INFO)
           <b>DLATRS</b> solves a triangular system of equations with the scale factor set to prevent overflow.
       subroutine <b>dlauu2</b> (UPLO, N, A, LDA, INFO)
           <b>DLAUU2</b> computes the product UUH or LHL, where U and L are upper or lower triangular matrices
           (unblocked algorithm).
       subroutine <b>dlauum</b> (UPLO, N, A, LDA, INFO)
           <b>DLAUUM</b> computes the product UUH or LHL, where U and L are upper or lower triangular matrices (blocked
           algorithm).
       subroutine <b>drscl</b> (N, SA, SX, INCX)
           <b>DRSCL</b> multiplies a vector by the reciprocal of a real scalar.
       subroutine <b>dtprfb</b> (SIDE, TRANS, DIRECT, STOREV, M, N, K, L, V, LDV, T, LDT, A, LDA, B, LDB, WORK, LDWORK)
           <b>DTPRFB</b> applies a real or complex 'triangular-pentagonal' blocked reflector to a real or complex
           matrix, which is composed of two blocks.
       subroutine <b>slatrd</b> (UPLO, N, NB, A, LDA, E, TAU, W, LDW)
           <b>SLATRD</b> reduces the first nb rows and columns of a symmetric/Hermitian matrix A to real tridiagonal
           form by an orthogonal similarity transformation.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       This is the group of double other auxiliary routines

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>dlabrd</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>TAUQ,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAUP,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldy,</b> <b>*</b> <b>)</b> <b>Y,</b> <b>integer</b> <b>LDY)</b>
       <b>DLABRD</b> reduces the first nb rows and columns of a general matrix to a bidiagonal form.

       <b>Purpose:</b>

            DLABRD reduces the first NB rows and columns of a real general
            m by n matrix A to upper or lower bidiagonal form by an orthogonal
            transformation Q**T * A * P, and returns the matrices X and Y which
            are needed to apply the transformation to the unreduced part of A.

            If m &gt;= n, A is reduced to upper bidiagonal form; if m &lt; n, to lower
            bidiagonal form.

            This is an auxiliary routine called by DGEBRD

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows in the matrix A.

           <u>N</u>

                     N is INTEGER
                     The number of columns in the matrix A.

           <u>NB</u>

                     NB is INTEGER
                     The number of leading rows and columns of A to be reduced.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     On entry, the m by n general matrix to be reduced.
                     On exit, the first NB rows and columns of the matrix are
                     overwritten; the rest of the array is unchanged.
                     If m &gt;= n, elements on and below the diagonal in the first NB
                       columns, with the array TAUQ, represent the orthogonal
                       matrix Q as a product of elementary reflectors; and
                       elements above the diagonal in the first NB rows, with the
                       array TAUP, represent the orthogonal matrix P as a product
                       of elementary reflectors.
                     If m &lt; n, elements below the diagonal in the first NB
                       columns, with the array TAUQ, represent the orthogonal
                       matrix Q as a product of elementary reflectors, and
                       elements on and above the diagonal in the first NB rows,
                       with the array TAUP, represent the orthogonal matrix P as
                       a product of elementary reflectors.
                     See Further Details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (NB)
                     The diagonal elements of the first NB rows and columns of
                     the reduced matrix.  D(i) = A(i,i).

           <u>E</u>

                     E is DOUBLE PRECISION array, dimension (NB)
                     The off-diagonal elements of the first NB rows and columns of
                     the reduced matrix.

           <u>TAUQ</u>

                     TAUQ is DOUBLE PRECISION array, dimension (NB)
                     The scalar factors of the elementary reflectors which
                     represent the orthogonal matrix Q. See Further Details.

           <u>TAUP</u>

                     TAUP is DOUBLE PRECISION array, dimension (NB)
                     The scalar factors of the elementary reflectors which
                     represent the orthogonal matrix P. See Further Details.

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (LDX,NB)
                     The m-by-nb matrix X required to update the unreduced part
                     of A.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X. LDX &gt;= max(1,M).

           <u>Y</u>

                     Y is DOUBLE PRECISION array, dimension (LDY,NB)
                     The n-by-nb matrix Y required to update the unreduced part
                     of A.

           <u>LDY</u>

                     LDY is INTEGER
                     The leading dimension of the array Y. LDY &gt;= max(1,N).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The matrices Q and P are represented as products of elementary
             reflectors:

                Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nb)  and  P = <a href="../man1/G.1.html">G</a>(1) <a href="../man2/G.2.html">G</a>(2) . . . G(nb)

             Each H(i) and G(i) has the form:

                H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T

             where tauq and taup are real scalars, and v and u are real vectors.

             If m &gt;= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
             A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
             A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

             If m &lt; n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
             A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
             A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

             The elements of the vectors v and u together form the m-by-nb matrix
             V and the nb-by-n matrix U**T which are needed, with X and Y, to apply
             the transformation to the unreduced part of the matrix, using a block
             update of the form:  A := A - V*Y**T - X*U**T.

             The contents of A on exit are illustrated by the following examples
             with nb = 2:

             m = 6 and n = 5 (m &gt; n):          m = 5 and n = 6 (m &lt; n):

               (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
               (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
               (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
               (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
               (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
               (  v1  v2  a   a   a  )

             where a denotes an element of the original matrix which is unchanged,
             vi denotes an element of the vector defining H(i), and ui an element
             of the vector defining G(i).

   <b>subroutine</b> <b>dlacn2</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISGN,</b> <b>double</b> <b>precision</b> <b>EST,</b> <b>integer</b> <b>KASE,</b> <b>integer,</b> <b>dimension(</b> <b>3</b> <b>)</b> <b>ISAVE)</b>
       <b>DLACN2</b> estimates the 1-norm of a square matrix, using reverse communication for evaluating matrix-vector
       products.

       <b>Purpose:</b>

            DLACN2 estimates the 1-norm of a square, real matrix A.
            Reverse communication is used for evaluating matrix-vector products.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                    The order of the matrix.  N &gt;= 1.

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension (N)
                    On the final return, V = A*W,  where  EST = norm(V)/norm(W)
                    (W is not returned).

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (N)
                    On an intermediate return, X should be overwritten by
                          A * X,   if KASE=1,
                          A**T * X,  if KASE=2,
                    and DLACN2 must be re-called with all the other parameters
                    unchanged.

           <u>ISGN</u>

                     ISGN is INTEGER array, dimension (N)

           <u>EST</u>

                     EST is DOUBLE PRECISION
                    On entry with KASE = 1 or 2 and <a href="../man1/ISAVE.1.html">ISAVE</a>(1) = 3, EST should be
                    unchanged from the previous call to DLACN2.
                    On exit, EST is an estimate (a lower bound) for norm(A).

           <u>KASE</u>

                     KASE is INTEGER
                    On the initial call to DLACN2, KASE should be 0.
                    On an intermediate return, KASE will be 1 or 2, indicating
                    whether X should be overwritten by A * X  or A**T * X.
                    On the final return from DLACN2, KASE will again be 0.

           <u>ISAVE</u>

                     ISAVE is INTEGER array, dimension (3)
                    ISAVE is used to save variables between calls to DLACN2

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Originally named SONEST, dated March 16, 1988.

             This is a thread safe version of DLACON, which uses the array ISAVE
             in place of a SAVE statement, as follows:

                DLACON     DLACN2
                 JUMP     <a href="../man1/ISAVE.1.html">ISAVE</a>(1)
                 J        <a href="../man2/ISAVE.2.html">ISAVE</a>(2)
                 ITER     <a href="../man3/ISAVE.3.html">ISAVE</a>(3)

       <b>Contributors:</b>
           Nick Higham, University of Manchester

       <b>References:</b>
           N.J. Higham, 'FORTRAN codes for estimating the one-norm of
             a real or complex matrix, with applications to condition estimation', ACM Trans. Math. Soft., vol.
           14, no. 4, pp. 381-396, December 1988.

   <b>subroutine</b> <b>dlacon</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISGN,</b> <b>double</b> <b>precision</b> <b>EST,</b> <b>integer</b> <b>KASE)</b>
       <b>DLACON</b> estimates the 1-norm of a square matrix, using reverse communication for evaluating matrix-vector
       products.

       <b>Purpose:</b>

            DLACON estimates the 1-norm of a square, real matrix A.
            Reverse communication is used for evaluating matrix-vector products.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                    The order of the matrix.  N &gt;= 1.

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension (N)
                    On the final return, V = A*W,  where  EST = norm(V)/norm(W)
                    (W is not returned).

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (N)
                    On an intermediate return, X should be overwritten by
                          A * X,   if KASE=1,
                          A**T * X,  if KASE=2,
                    and DLACON must be re-called with all the other parameters
                    unchanged.

           <u>ISGN</u>

                     ISGN is INTEGER array, dimension (N)

           <u>EST</u>

                     EST is DOUBLE PRECISION
                    On entry with KASE = 1 or 2 and JUMP = 3, EST should be
                    unchanged from the previous call to DLACON.
                    On exit, EST is an estimate (a lower bound) for norm(A).

           <u>KASE</u>

                     KASE is INTEGER
                    On the initial call to DLACON, KASE should be 0.
                    On an intermediate return, KASE will be 1 or 2, indicating
                    whether X should be overwritten by A * X  or A**T * X.
                    On the final return from DLACON, KASE will again be 0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Nick Higham, University of Manchester.
            Originally named SONEST, dated March 16, 1988.

       <b>References:</b>
           N.J. Higham, 'FORTRAN codes for estimating the one-norm of
             a real or complex matrix, with applications to condition estimation', ACM Trans. Math. Soft., vol.
           14, no. 4, pp. 381-396, December 1988.

   <b>subroutine</b> <b>dladiv</b> <b>(double</b> <b>precision</b> <b>A,</b> <b>double</b> <b>precision</b> <b>B,</b> <b>double</b> <b>precision</b> <b>C,</b> <b>double</b> <b>precision</b> <b>D,</b> <b>double</b>
       <b>precision</b> <b>P,</b> <b>double</b> <b>precision</b> <b>Q)</b>
       <b>DLADIV</b> performs complex division in real arithmetic, avoiding unnecessary overflow.

       <b>Purpose:</b>

            DLADIV performs complex division in  real arithmetic

                                  a + i*b
                       p + i*q = ---------
                                  c + i*d

            The algorithm is due to Michael Baudin and Robert L. Smith
            and can be found in the paper
            "A Robust Complex Division in Scilab"

       <b>Parameters</b>
           <u>A</u>

                     A is DOUBLE PRECISION

           <u>B</u>

                     B is DOUBLE PRECISION

           <u>C</u>

                     C is DOUBLE PRECISION

           <u>D</u>

                     D is DOUBLE PRECISION
                     The scalars a, b, c, and d in the above expression.

           <u>P</u>

                     P is DOUBLE PRECISION

           <u>Q</u>

                     Q is DOUBLE PRECISION
                     The scalars p and q in the above expression.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlaein</b> <b>(logical</b> <b>RIGHTV,</b> <b>logical</b> <b>NOINIT,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b>
       <b>integer</b> <b>LDH,</b> <b>double</b> <b>precision</b> <b>WR,</b> <b>double</b> <b>precision</b> <b>WI,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>VR,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>VI,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>double</b> <b>precision</b> <b>EPS3,</b> <b>double</b> <b>precision</b> <b>SMLNUM,</b> <b>double</b> <b>precision</b> <b>BIGNUM,</b> <b>integer</b>
       <b>INFO)</b>
       <b>DLAEIN</b> computes a specified right or left eigenvector of an upper Hessenberg matrix by inverse iteration.

       <b>Purpose:</b>

            DLAEIN uses inverse iteration to find a right or left eigenvector
            corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg
            matrix H.

       <b>Parameters</b>
           <u>RIGHTV</u>

                     RIGHTV is LOGICAL
                     = .TRUE. : compute right eigenvector;
                     = .FALSE.: compute left eigenvector.

           <u>NOINIT</u>

                     NOINIT is LOGICAL
                     = .TRUE. : no initial vector supplied in (VR,VI).
                     = .FALSE.: initial vector supplied in (VR,VI).

           <u>N</u>

                     N is INTEGER
                     The order of the matrix H.  N &gt;= 0.

           <u>H</u>

                     H is DOUBLE PRECISION array, dimension (LDH,N)
                     The upper Hessenberg matrix H.

           <u>LDH</u>

                     LDH is INTEGER
                     The leading dimension of the array H.  LDH &gt;= max(1,N).

           <u>WR</u>

                     WR is DOUBLE PRECISION

           <u>WI</u>

                     WI is DOUBLE PRECISION
                     The real and imaginary parts of the eigenvalue of H whose
                     corresponding right or left eigenvector is to be computed.

           <u>VR</u>

                     VR is DOUBLE PRECISION array, dimension (N)

           <u>VI</u>

                     VI is DOUBLE PRECISION array, dimension (N)
                     On entry, if NOINIT = .FALSE. and WI = 0.0, VR must contain
                     a real starting vector for inverse iteration using the real
                     eigenvalue WR; if NOINIT = .FALSE. and WI.ne.0.0, VR and VI
                     must contain the real and imaginary parts of a complex
                     starting vector for inverse iteration using the complex
                     eigenvalue (WR,WI); otherwise VR and VI need not be set.
                     On exit, if WI = 0.0 (real eigenvalue), VR contains the
                     computed real eigenvector; if WI.ne.0.0 (complex eigenvalue),
                     VR and VI contain the real and imaginary parts of the
                     computed complex eigenvector. The eigenvector is normalized
                     so that the component of largest magnitude has magnitude 1;
                     here the magnitude of a complex number (x,y) is taken to be
                     |x| + |y|.
                     VI is not referenced if WI = 0.0.

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB,N)

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= N+1.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (N)

           <u>EPS3</u>

                     EPS3 is DOUBLE PRECISION
                     A small machine-dependent value which is used to perturb
                     close eigenvalues, and to replace zero pivots.

           <u>SMLNUM</u>

                     SMLNUM is DOUBLE PRECISION
                     A machine-dependent value close to the underflow threshold.

           <u>BIGNUM</u>

                     BIGNUM is DOUBLE PRECISION
                     A machine-dependent value close to the overflow threshold.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     = 1:  inverse iteration did not converge; VR is set to the
                           last iterate, and so is VI if WI.ne.0.0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlaexc</b> <b>(logical</b> <b>WANTQ,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>integer</b> <b>J1,</b> <b>integer</b> <b>N1,</b> <b>integer</b> <b>N2,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAEXC</b> swaps adjacent diagonal blocks of a real upper quasi-triangular matrix in Schur canonical form, by
       an orthogonal similarity transformation.

       <b>Purpose:</b>

            DLAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
            an upper quasi-triangular matrix T by an orthogonal similarity
            transformation.

            T must be in Schur canonical form, that is, block upper triangular
            with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
            has its diagonal elements equal and its off-diagonal elements of
            opposite sign.

       <b>Parameters</b>
           <u>WANTQ</u>

                     WANTQ is LOGICAL
                     = .TRUE. : accumulate the transformation in the matrix Q;
                     = .FALSE.: do not accumulate the transformation.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix T. N &gt;= 0.

           <u>T</u>

                     T is DOUBLE PRECISION array, dimension (LDT,N)
                     On entry, the upper quasi-triangular matrix T, in Schur
                     canonical form.
                     On exit, the updated matrix T, again in Schur canonical form.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= max(1,N).

           <u>Q</u>

                     Q is DOUBLE PRECISION array, dimension (LDQ,N)
                     On entry, if WANTQ is .TRUE., the orthogonal matrix Q.
                     On exit, if WANTQ is .TRUE., the updated matrix Q.
                     If WANTQ is .FALSE., Q is not referenced.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= 1; and if WANTQ is .TRUE., LDQ &gt;= N.

           <u>J1</u>

                     J1 is INTEGER
                     The index of the first row of the first block T11.

           <u>N1</u>

                     N1 is INTEGER
                     The order of the first block T11. N1 = 0, 1 or 2.

           <u>N2</u>

                     N2 is INTEGER
                     The order of the second block T22. N2 = 0, 1 or 2.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     = 1: the transformed matrix T would be too far from Schur
                          form; the blocks are not swapped and T and Q are
                          unchanged.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlag2</b> <b>(double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b>
       <b>B,</b> <b>integer</b> <b>LDB,</b> <b>double</b> <b>precision</b> <b>SAFMIN,</b> <b>double</b> <b>precision</b> <b>SCALE1,</b> <b>double</b> <b>precision</b> <b>SCALE2,</b> <b>double</b>
       <b>precision</b> <b>WR1,</b> <b>double</b> <b>precision</b> <b>WR2,</b> <b>double</b> <b>precision</b> <b>WI)</b>
       <b>DLAG2</b> computes the eigenvalues of a 2-by-2 generalized eigenvalue problem, with scaling as necessary to
       avoid over-/underflow.

       <b>Purpose:</b>

            DLAG2 computes the eigenvalues of a 2 x 2 generalized eigenvalue
            problem  A - w B, with scaling as necessary to avoid over-/underflow.

            The scaling factor "s" results in a modified eigenvalue equation

                s A - w B

            where  s  is a non-negative scaling factor chosen so that  w,  w B,
            and  s A  do not overflow and, if possible, do not underflow, either.

       <b>Parameters</b>
           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA, 2)
                     On entry, the 2 x 2 matrix A.  It is assumed that its 1-norm
                     is less than 1/SAFMIN.  Entries less than
                     sqrt(SAFMIN)*norm(A) are subject to being treated as zero.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= 2.

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB, 2)
                     On entry, the 2 x 2 upper triangular matrix B.  It is
                     assumed that the one-norm of B is less than 1/SAFMIN.  The
                     diagonals should be at least sqrt(SAFMIN) times the largest
                     element of B (in absolute value); if a diagonal is smaller
                     than that, then  +/- sqrt(SAFMIN) will be used instead of
                     that diagonal.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= 2.

           <u>SAFMIN</u>

                     SAFMIN is DOUBLE PRECISION
                     The smallest positive number s.t. 1/SAFMIN does not
                     overflow.  (This should always be DLAMCH('S') -- it is an
                     argument in order to avoid having to call DLAMCH frequently.)

           <u>SCALE1</u>

                     SCALE1 is DOUBLE PRECISION
                     A scaling factor used to avoid over-/underflow in the
                     eigenvalue equation which defines the first eigenvalue.  If
                     the eigenvalues are complex, then the eigenvalues are
                     ( WR1  +/-  WI i ) / SCALE1  (which may lie outside the
                     exponent range of the machine), SCALE1=SCALE2, and SCALE1
                     will always be positive.  If the eigenvalues are real, then
                     the first (real) eigenvalue is  WR1 / SCALE1 , but this may
                     overflow or underflow, and in fact, SCALE1 may be zero or
                     less than the underflow threshold if the exact eigenvalue
                     is sufficiently large.

           <u>SCALE2</u>

                     SCALE2 is DOUBLE PRECISION
                     A scaling factor used to avoid over-/underflow in the
                     eigenvalue equation which defines the second eigenvalue.  If
                     the eigenvalues are complex, then SCALE2=SCALE1.  If the
                     eigenvalues are real, then the second (real) eigenvalue is
                     WR2 / SCALE2 , but this may overflow or underflow, and in
                     fact, SCALE2 may be zero or less than the underflow
                     threshold if the exact eigenvalue is sufficiently large.

           <u>WR1</u>

                     WR1 is DOUBLE PRECISION
                     If the eigenvalue is real, then WR1 is SCALE1 times the
                     eigenvalue closest to the (2,2) element of A B**(-1).  If the
                     eigenvalue is complex, then WR1=WR2 is SCALE1 times the real
                     part of the eigenvalues.

           <u>WR2</u>

                     WR2 is DOUBLE PRECISION
                     If the eigenvalue is real, then WR2 is SCALE2 times the
                     other eigenvalue.  If the eigenvalue is complex, then
                     WR1=WR2 is SCALE1 times the real part of the eigenvalues.

           <u>WI</u>

                     WI is DOUBLE PRECISION
                     If the eigenvalue is real, then WI is zero.  If the
                     eigenvalue is complex, then WI is SCALE1 times the imaginary
                     part of the eigenvalues.  WI will always be non-negative.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlag2s</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b>
       <b>dimension(</b> <b>ldsa,</b> <b>*</b> <b>)</b> <b>SA,</b> <b>integer</b> <b>LDSA,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAG2S</b> converts a double precision matrix to a single precision matrix.

       <b>Purpose:</b>

            DLAG2S converts a DOUBLE PRECISION matrix, SA, to a SINGLE
            PRECISION matrix, A.

            RMAX is the overflow for the SINGLE PRECISION arithmetic
            DLAG2S checks that all the entries of A are between -RMAX and
            RMAX. If not the conversion is aborted and a flag is raised.

            This is an auxiliary routine so there is no argument checking.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of lines of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     On entry, the M-by-N coefficient matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>SA</u>

                     SA is REAL array, dimension (LDSA,N)
                     On exit, if INFO=0, the M-by-N coefficient matrix SA; if
                     INFO&gt;0, the content of SA is unspecified.

           <u>LDSA</u>

                     LDSA is INTEGER
                     The leading dimension of the array SA.  LDSA &gt;= max(1,M).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     = 1:  an entry of the matrix A is greater than the SINGLE
                           PRECISION overflow threshold, in this case, the content
                           of SA in exit is unspecified.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlags2</b> <b>(logical</b> <b>UPPER,</b> <b>double</b> <b>precision</b> <b>A1,</b> <b>double</b> <b>precision</b> <b>A2,</b> <b>double</b> <b>precision</b> <b>A3,</b> <b>double</b>
       <b>precision</b> <b>B1,</b> <b>double</b> <b>precision</b> <b>B2,</b> <b>double</b> <b>precision</b> <b>B3,</b> <b>double</b> <b>precision</b> <b>CSU,</b> <b>double</b> <b>precision</b> <b>SNU,</b>
       <b>double</b> <b>precision</b> <b>CSV,</b> <b>double</b> <b>precision</b> <b>SNV,</b> <b>double</b> <b>precision</b> <b>CSQ,</b> <b>double</b> <b>precision</b> <b>SNQ)</b>
       <b>DLAGS2</b> computes 2-by-2 orthogonal matrices U, V, and Q, and applies them to matrices A and B such that
       the rows of the transformed A and B are parallel.

       <b>Purpose:</b>

            DLAGS2 computes 2-by-2 orthogonal matrices U, V and Q, such
            that if ( UPPER ) then

                      U**T *A*Q = U**T *( A1 A2 )*Q = ( x  0  )
                                        ( 0  A3 )     ( x  x  )
            and
                      V**T*B*Q = V**T *( B1 B2 )*Q = ( x  0  )
                                       ( 0  B3 )     ( x  x  )

            or if ( .NOT.UPPER ) then

                      U**T *A*Q = U**T *( A1 0  )*Q = ( x  x  )
                                        ( A2 A3 )     ( 0  x  )
            and
                      V**T*B*Q = V**T*( B1 0  )*Q = ( x  x  )
                                      ( B2 B3 )     ( 0  x  )

            The rows of the transformed A and B are parallel, where

              U = (  CSU  SNU ), V = (  CSV SNV ), Q = (  CSQ   SNQ )
                  ( -SNU  CSU )      ( -SNV CSV )      ( -SNQ   CSQ )

            Z**T denotes the transpose of Z.

       <b>Parameters</b>
           <u>UPPER</u>

                     UPPER is LOGICAL
                     = .TRUE.: the input matrices A and B are upper triangular.
                     = .FALSE.: the input matrices A and B are lower triangular.

           <u>A1</u>

                     A1 is DOUBLE PRECISION

           <u>A2</u>

                     A2 is DOUBLE PRECISION

           <u>A3</u>

                     A3 is DOUBLE PRECISION
                     On entry, A1, A2 and A3 are elements of the input 2-by-2
                     upper (lower) triangular matrix A.

           <u>B1</u>

                     B1 is DOUBLE PRECISION

           <u>B2</u>

                     B2 is DOUBLE PRECISION

           <u>B3</u>

                     B3 is DOUBLE PRECISION
                     On entry, B1, B2 and B3 are elements of the input 2-by-2
                     upper (lower) triangular matrix B.

           <u>CSU</u>

                     CSU is DOUBLE PRECISION

           <u>SNU</u>

                     SNU is DOUBLE PRECISION
                     The desired orthogonal matrix U.

           <u>CSV</u>

                     CSV is DOUBLE PRECISION

           <u>SNV</u>

                     SNV is DOUBLE PRECISION
                     The desired orthogonal matrix V.

           <u>CSQ</u>

                     CSQ is DOUBLE PRECISION

           <u>SNQ</u>

                     SNQ is DOUBLE PRECISION
                     The desired orthogonal matrix Q.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlagtm</b> <b>(character</b> <b>TRANS,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>double</b> <b>precision</b> <b>ALPHA,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>DL,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DU,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>double</b> <b>precision</b> <b>BETA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b>
       <b>)</b> <b>B,</b> <b>integer</b> <b>LDB)</b>
       <b>DLAGTM</b> performs a matrix-matrix product of the form C = αAB+βC, where A is a tridiagonal matrix, B and C
       are rectangular matrices, and α and β are scalars, which may be 0, 1, or -1.

       <b>Purpose:</b>

            DLAGTM performs a matrix-vector product of the form

               B := alpha * A * X + beta * B

            where A is a tridiagonal matrix of order N, B and X are N by NRHS
            matrices, and alpha and beta are real scalars, each of which may be
            0., 1., or -1.

       <b>Parameters</b>
           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the operation applied to A.
                     = 'N':  No transpose, B := alpha * A * X + beta * B
                     = 'T':  Transpose,    B := alpha * A'* X + beta * B
                     = 'C':  Conjugate transpose = Transpose

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices X and B.

           <u>ALPHA</u>

                     ALPHA is DOUBLE PRECISION
                     The scalar alpha.  ALPHA must be 0., 1., or -1.; otherwise,
                     it is assumed to be 0.

           <u>DL</u>

                     DL is DOUBLE PRECISION array, dimension (N-1)
                     The (n-1) sub-diagonal elements of T.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     The diagonal elements of T.

           <u>DU</u>

                     DU is DOUBLE PRECISION array, dimension (N-1)
                     The (n-1) super-diagonal elements of T.

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (LDX,NRHS)
                     The N by NRHS matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(N,1).

           <u>BETA</u>

                     BETA is DOUBLE PRECISION
                     The scalar beta.  BETA must be 0., 1., or -1.; otherwise,
                     it is assumed to be 1.

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB,NRHS)
                     On entry, the N by NRHS matrix B.
                     On exit, B is overwritten by the matrix expression
                     B := alpha * A * X + beta * B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(N,1).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlagv2</b> <b>(double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b>
       <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>2</b> <b>)</b> <b>ALPHAR,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>2</b> <b>)</b> <b>ALPHAI,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>2</b> <b>)</b> <b>BETA,</b> <b>double</b> <b>precision</b> <b>CSL,</b> <b>double</b> <b>precision</b> <b>SNL,</b> <b>double</b> <b>precision</b> <b>CSR,</b>
       <b>double</b> <b>precision</b> <b>SNR)</b>
       <b>DLAGV2</b> computes the Generalized Schur factorization of a real 2-by-2 matrix pencil (A,B) where B is upper
       triangular.

       <b>Purpose:</b>

            DLAGV2 computes the Generalized Schur factorization of a real 2-by-2
            matrix pencil (A,B) where B is upper triangular. This routine
            computes orthogonal (rotation) matrices given by CSL, SNL and CSR,
            SNR such that

            1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0
               types), then

               [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
               [  0  a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]

               [ b11 b12 ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
               [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ],

            2) if the pencil (A,B) has a pair of complex conjugate eigenvalues,
               then

               [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
               [ a21 a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]

               [ b11  0  ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
               [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ]

               where b11 &gt;= b22 &gt; 0.

       <b>Parameters</b>
           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA, 2)
                     On entry, the 2 x 2 matrix A.
                     On exit, A is overwritten by the ``A-part'' of the
                     generalized Schur form.

           <u>LDA</u>

                     LDA is INTEGER
                     THe leading dimension of the array A.  LDA &gt;= 2.

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB, 2)
                     On entry, the upper triangular 2 x 2 matrix B.
                     On exit, B is overwritten by the ``B-part'' of the
                     generalized Schur form.

           <u>LDB</u>

                     LDB is INTEGER
                     THe leading dimension of the array B.  LDB &gt;= 2.

           <u>ALPHAR</u>

                     ALPHAR is DOUBLE PRECISION array, dimension (2)

           <u>ALPHAI</u>

                     ALPHAI is DOUBLE PRECISION array, dimension (2)

           <u>BETA</u>

                     BETA is DOUBLE PRECISION array, dimension (2)
                     (ALPHAR(k)+i*ALPHAI(k))/BETA(k) are the eigenvalues of the
                     pencil (A,B), k=1,2, i = sqrt(-1).  Note that BETA(k) may
                     be zero.

           <u>CSL</u>

                     CSL is DOUBLE PRECISION
                     The cosine of the left rotation matrix.

           <u>SNL</u>

                     SNL is DOUBLE PRECISION
                     The sine of the left rotation matrix.

           <u>CSR</u>

                     CSR is DOUBLE PRECISION
                     The cosine of the right rotation matrix.

           <u>SNR</u>

                     SNR is DOUBLE PRECISION
                     The sine of the right rotation matrix.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA

   <b>subroutine</b> <b>dlahqr</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WR,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>WI,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAHQR</b> computes the eigenvalues and Schur factorization of an upper Hessenberg matrix, using the double-
       shift/single-shift QR algorithm.

       <b>Purpose:</b>

               DLAHQR is an auxiliary routine called by DHSEQR to update the
               eigenvalues and Schur decomposition already computed by DHSEQR, by
               dealing with the Hessenberg submatrix in rows and columns ILO to
               IHI.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     = .TRUE. : the full Schur form T is required;
                     = .FALSE.: only eigenvalues are required.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     = .TRUE. : the matrix of Schur vectors Z is required;
                     = .FALSE.: Schur vectors are not required.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix H.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER
                     It is assumed that H is already upper quasi-triangular in
                     rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
                     ILO = 1). DLAHQR works primarily with the Hessenberg
                     submatrix in rows and columns ILO to IHI, but applies
                     transformations to all of H if WANTT is .TRUE..
                     1 &lt;= ILO &lt;= max(1,IHI); IHI &lt;= N.

           <u>H</u>

                     H is DOUBLE PRECISION array, dimension (LDH,N)
                     On entry, the upper Hessenberg matrix H.
                     On exit, if INFO is zero and if WANTT is .TRUE., H is upper
                     quasi-triangular in rows and columns ILO:IHI, with any
                     2-by-2 diagonal blocks in standard form. If INFO is zero
                     and WANTT is .FALSE., the contents of H are unspecified on
                     exit.  The output state of H if INFO is nonzero is given
                     below under the description of INFO.

           <u>LDH</u>

                     LDH is INTEGER
                     The leading dimension of the array H. LDH &gt;= max(1,N).

           <u>WR</u>

                     WR is DOUBLE PRECISION array, dimension (N)

           <u>WI</u>

                     WI is DOUBLE PRECISION array, dimension (N)
                     The real and imaginary parts, respectively, of the computed
                     eigenvalues ILO to IHI are stored in the corresponding
                     elements of WR and WI. If two eigenvalues are computed as a
                     complex conjugate pair, they are stored in consecutive
                     elements of WR and WI, say the i-th and (i+1)th, with
                     WI(i) &gt; 0 and WI(i+1) &lt; 0. If WANTT is .TRUE., the
                     eigenvalues are stored in the same order as on the diagonal
                     of the Schur form returned in H, with WR(i) = H(i,i), and, if
                     H(i:i+1,i:i+1) is a 2-by-2 diagonal block,
                     WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                     Specify the rows of Z to which transformations must be
                     applied if WANTZ is .TRUE..
                     1 &lt;= ILOZ &lt;= ILO; IHI &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (LDZ,N)
                     If WANTZ is .TRUE., on entry Z must contain the current
                     matrix Z of transformations accumulated by DHSEQR, and on
                     exit Z has been updated; transformations are applied only to
                     the submatrix Z(ILOZ:IHIZ,ILO:IHI).
                     If WANTZ is .FALSE., Z is not referenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z. LDZ &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                      = 0:  successful exit
                      &gt; 0:  If INFO = i, DLAHQR failed to compute all the
                             eigenvalues ILO to IHI in a total of 30 iterations
                             per eigenvalue; elements i+1:ihi of WR and WI
                             contain those eigenvalues which have been
                             successfully computed.

                             If INFO &gt; 0 and WANTT is .FALSE., then on exit,
                             the remaining unconverged eigenvalues are the
                             eigenvalues of the upper Hessenberg matrix rows
                             and columns ILO through INFO of the final, output
                             value of H.

                             If INFO &gt; 0 and WANTT is .TRUE., then on exit
                     (*)       (initial value of H)*U  = U*(final value of H)
                             where U is an orthogonal matrix.    The final
                             value of H is upper Hessenberg and triangular in
                             rows and columns INFO+1 through IHI.

                             If INFO &gt; 0 and WANTZ is .TRUE., then on exit
                                 (final value of Z)  = (initial value of Z)*U
                             where U is the orthogonal matrix in (*)
                             (regardless of the value of WANTT.)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

                02-96 Based on modifications by
                David Day, Sandia National Laboratory, USA

                12-04 Further modifications by
                Ralph Byers, University of Kansas, USA
                This is a modified version of DLAHQR from LAPACK version 3.0.
                It is (1) more robust against overflow and underflow and
                (2) adopts the more conservative Ahues &amp; Tisseur stopping
                criterion (LAWN 122, 1997).

   <b>subroutine</b> <b>dlahr2</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>integer</b> <b>NB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>nb</b> <b>)</b> <b>TAU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldt,</b> <b>nb</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldy,</b> <b>nb</b> <b>)</b> <b>Y,</b> <b>integer</b> <b>LDY)</b>
       <b>DLAHR2</b> reduces the specified number of first columns of a general rectangular matrix A so that elements
       below the specified subdiagonal are zero, and returns auxiliary matrices which are needed to apply the
       transformation to the unreduced part of A.

       <b>Purpose:</b>

            DLAHR2 reduces the first NB columns of A real general n-BY-(n-k+1)
            matrix A so that elements below the k-th subdiagonal are zero. The
            reduction is performed by an orthogonal similarity transformation
            Q**T * A * Q. The routine returns the matrices V and T which determine
            Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.

            This is an auxiliary routine called by DGEHRD.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.

           <u>K</u>

                     K is INTEGER
                     The offset for the reduction. Elements below the k-th
                     subdiagonal in the first NB columns are reduced to zero.
                     K &lt; N.

           <u>NB</u>

                     NB is INTEGER
                     The number of columns to be reduced.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N-K+1)
                     On entry, the n-by-(n-k+1) general matrix A.
                     On exit, the elements on and above the k-th subdiagonal in
                     the first NB columns are overwritten with the corresponding
                     elements of the reduced matrix; the elements below the k-th
                     subdiagonal, with the array TAU, represent the matrix Q as a
                     product of elementary reflectors. The other columns of A are
                     unchanged. See Further Details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>TAU</u>

                     TAU is DOUBLE PRECISION array, dimension (NB)
                     The scalar factors of the elementary reflectors. See Further
                     Details.

           <u>T</u>

                     T is DOUBLE PRECISION array, dimension (LDT,NB)
                     The upper triangular matrix T.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= NB.

           <u>Y</u>

                     Y is DOUBLE PRECISION array, dimension (LDY,NB)
                     The n-by-nb matrix Y.

           <u>LDY</u>

                     LDY is INTEGER
                     The leading dimension of the array Y. LDY &gt;= N.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The matrix Q is represented as a product of nb elementary reflectors

                Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nb).

             Each H(i) has the form

                H(i) = I - tau * v * v**T

             where tau is a real scalar, and v is a real vector with
             v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
             A(i+k+1:n,i), and tau in TAU(i).

             The elements of the vectors v together form the (n-k+1)-by-nb matrix
             V which is needed, with T and Y, to apply the transformation to the
             unreduced part of the matrix, using an update of the form:
             A := (I - V*T*V**T) * (A - Y*V**T).

             The contents of A on exit are illustrated by the following example
             with n = 7, k = 3 and nb = 2:

                ( a   a   a   a   a )
                ( a   a   a   a   a )
                ( a   a   a   a   a )
                ( h   h   a   a   a )
                ( v1  h   a   a   a )
                ( v1  v2  a   a   a )
                ( v1  v2  a   a   a )

             where a denotes an element of the original matrix A, h denotes a
             modified element of the upper Hessenberg matrix H, and vi denotes an
             element of the vector defining H(i).

             This subroutine is a slight modification of LAPACK-3.0's DLAHRD
             incorporating improvements proposed by Quintana-Orti and Van de
             Gejin. Note that the entries of A(1:K,2:NB) differ from those
             returned by the original LAPACK-3.0's DLAHRD routine. (This
             subroutine is not backward compatible with LAPACK-3.0's DLAHRD.)

       <b>References:</b>
           Gregorio Quintana-Orti and Robert van de Geijn, 'Improving the
             performance of reduction to Hessenberg form,' ACM Transactions on Mathematical Software,
           <a href="../man2/32.2.html">32</a>(2):180-194, June 2006.

   <b>subroutine</b> <b>dlaic1</b> <b>(integer</b> <b>JOB,</b> <b>integer</b> <b>J,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>j</b> <b>)</b> <b>X,</b> <b>double</b> <b>precision</b> <b>SEST,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>j</b> <b>)</b> <b>W,</b> <b>double</b> <b>precision</b> <b>GAMMA,</b> <b>double</b> <b>precision</b> <b>SESTPR,</b> <b>double</b> <b>precision</b> <b>S,</b> <b>double</b>
       <b>precision</b> <b>C)</b>
       <b>DLAIC1</b> applies one step of incremental condition estimation.

       <b>Purpose:</b>

            DLAIC1 applies one step of incremental condition estimation in
            its simplest version:

            Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
            lower triangular matrix L, such that
                     twonorm(L*x) = sest
            Then DLAIC1 computes sestpr, s, c such that
            the vector
                            [ s*x ]
                     xhat = [  c  ]
            is an approximate singular vector of
                            [ L       0  ]
                     Lhat = [ w**T gamma ]
            in the sense that
                     twonorm(Lhat*xhat) = sestpr.

            Depending on JOB, an estimate for the largest or smallest singular
            value is computed.

            Note that [s c]**T and sestpr**2 is an eigenpair of the system

                diag(sest*sest, 0) + [alpha  gamma] * [ alpha ]
                                                      [ gamma ]

            where  alpha =  x**T*w.

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is INTEGER
                     = 1: an estimate for the largest singular value is computed.
                     = 2: an estimate for the smallest singular value is computed.

           <u>J</u>

                     J is INTEGER
                     Length of X and W

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (J)
                     The j-vector x.

           <u>SEST</u>

                     SEST is DOUBLE PRECISION
                     Estimated singular value of j by j matrix L

           <u>W</u>

                     W is DOUBLE PRECISION array, dimension (J)
                     The j-vector w.

           <u>GAMMA</u>

                     GAMMA is DOUBLE PRECISION
                     The diagonal element gamma.

           <u>SESTPR</u>

                     SESTPR is DOUBLE PRECISION
                     Estimated singular value of (j+1) by (j+1) matrix Lhat.

           <u>S</u>

                     S is DOUBLE PRECISION
                     Sine needed in forming xhat.

           <u>C</u>

                     C is DOUBLE PRECISION
                     Cosine needed in forming xhat.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlaln2</b> <b>(logical</b> <b>LTRANS,</b> <b>integer</b> <b>NA,</b> <b>integer</b> <b>NW,</b> <b>double</b> <b>precision</b> <b>SMIN,</b> <b>double</b> <b>precision</b> <b>CA,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>double</b> <b>precision</b> <b>D1,</b> <b>double</b> <b>precision</b> <b>D2,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>double</b> <b>precision</b> <b>WR,</b> <b>double</b> <b>precision</b> <b>WI,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>double</b> <b>precision</b> <b>SCALE,</b> <b>double</b> <b>precision</b> <b>XNORM,</b> <b>integer</b>
       <b>INFO)</b>
       <b>DLALN2</b> solves a 1-by-1 or 2-by-2 linear system of equations of the specified form.

       <b>Purpose:</b>

            DLALN2 solves a system of the form  (ca A - w D ) X = s B
            or (ca A**T - w D) X = s B   with possible scaling ("s") and
            perturbation of A.  (A**T means A-transpose.)

            A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
            real diagonal matrix, w is a real or complex value, and X and B are
            NA x 1 matrices -- real if w is real, complex if w is complex.  NA
            may be 1 or 2.

            If w is complex, X and B are represented as NA x 2 matrices,
            the first column of each being the real part and the second
            being the imaginary part.

            "s" is a scaling factor (&lt;= 1), computed by DLALN2, which is
            so chosen that X can be computed without overflow.  X is further
            scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
            than overflow.

            If both singular values of (ca A - w D) are less than SMIN,
            SMIN*identity will be used instead of (ca A - w D).  If only one
            singular value is less than SMIN, one element of (ca A - w D) will be
            perturbed enough to make the smallest singular value roughly SMIN.
            If both singular values are at least SMIN, (ca A - w D) will not be
            perturbed.  In any case, the perturbation will be at most some small
            multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
            are computed by infinity-norm approximations, and thus will only be
            correct to a factor of 2 or so.

            Note: all input quantities are assumed to be smaller than overflow
            by a reasonable factor.  (See BIGNUM.)

       <b>Parameters</b>
           <u>LTRANS</u>

                     LTRANS is LOGICAL
                     =.TRUE.:  A-transpose will be used.
                     =.FALSE.: A will be used (not transposed.)

           <u>NA</u>

                     NA is INTEGER
                     The size of the matrix A.  It may (only) be 1 or 2.

           <u>NW</u>

                     NW is INTEGER
                     1 if "w" is real, 2 if "w" is complex.  It may only be 1
                     or 2.

           <u>SMIN</u>

                     SMIN is DOUBLE PRECISION
                     The desired lower bound on the singular values of A.  This
                     should be a safe distance away from underflow or overflow,
                     say, between (underflow/machine precision) and  (machine
                     precision * overflow ).  (See BIGNUM and ULP.)

           <u>CA</u>

                     CA is DOUBLE PRECISION
                     The coefficient c, which A is multiplied by.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,NA)
                     The NA x NA matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of A.  It must be at least NA.

           <u>D1</u>

                     D1 is DOUBLE PRECISION
                     The 1,1 element in the diagonal matrix D.

           <u>D2</u>

                     D2 is DOUBLE PRECISION
                     The 2,2 element in the diagonal matrix D.  Not used if NA=1.

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB,NW)
                     The NA x NW matrix B (right-hand side).  If NW=2 ("w" is
                     complex), column 1 contains the real part of B and column 2
                     contains the imaginary part.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of B.  It must be at least NA.

           <u>WR</u>

                     WR is DOUBLE PRECISION
                     The real part of the scalar "w".

           <u>WI</u>

                     WI is DOUBLE PRECISION
                     The imaginary part of the scalar "w".  Not used if NW=1.

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (LDX,NW)
                     The NA x NW matrix X (unknowns), as computed by DLALN2.
                     If NW=2 ("w" is complex), on exit, column 1 will contain
                     the real part of X and column 2 will contain the imaginary
                     part.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of X.  It must be at least NA.

           <u>SCALE</u>

                     SCALE is DOUBLE PRECISION
                     The scale factor that B must be multiplied by to insure
                     that overflow does not occur when computing X.  Thus,
                     (ca A - w D) X  will be SCALE*B, not B (ignoring
                     perturbations of A.)  It will be at most 1.

           <u>XNORM</u>

                     XNORM is DOUBLE PRECISION
                     The infinity-norm of X, when X is regarded as an NA x NW
                     real matrix.

           <u>INFO</u>

                     INFO is INTEGER
                     An error flag.  It will be set to zero if no error occurs,
                     a negative number if an argument is in error, or a positive
                     number if  ca A - w D  had to be perturbed.
                     The possible values are:
                     = 0: No error occurred, and (ca A - w D) did not have to be
                            perturbed.
                     = 1: (ca A - w D) had to be perturbed to make its smallest
                          (or only) singular value greater than SMIN.
                     NOTE: In the interests of speed, this routine does not
                           check the inputs for errors.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>dlangt</b> <b>(character</b> <b>NORM,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DL,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DU)</b>
       <b>DLANGT</b> returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value of
       any element of a general tridiagonal matrix.

       <b>Purpose:</b>

            DLANGT  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real tridiagonal matrix A.

       <b>Returns</b>
           DLANGT

               DLANGT = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in DLANGT as described
                     above.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, DLANGT is
                     set to zero.

           <u>DL</u>

                     DL is DOUBLE PRECISION array, dimension (N-1)
                     The (n-1) sub-diagonal elements of A.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     The diagonal elements of A.

           <u>DU</u>

                     DU is DOUBLE PRECISION array, dimension (N-1)
                     The (n-1) super-diagonal elements of A.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>dlanhs</b> <b>(character</b> <b>NORM,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b>
       <b>LDA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>DLANHS</b> returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value of
       any element of an upper Hessenberg matrix.

       <b>Purpose:</b>

            DLANHS  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            Hessenberg matrix A.

       <b>Returns</b>
           DLANHS

               DLANHS = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in DLANHS as described
                     above.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, DLANHS is
                     set to zero.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     The n by n upper Hessenberg matrix A; the part of A below the
                     first sub-diagonal is not referenced.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(N,1).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I'; otherwise, WORK is not
                     referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>dlansb</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>DLANSB</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a symmetric band matrix.

       <b>Purpose:</b>

            DLANSB  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the element of  largest absolute value  of an
            n by n symmetric band matrix A,  with k super-diagonals.

       <b>Returns</b>
           DLANSB

               DLANSB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in DLANSB as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     band matrix A is supplied.
                     = 'U':  Upper triangular part is supplied
                     = 'L':  Lower triangular part is supplied

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, DLANSB is
                     set to zero.

           <u>K</u>

                     K is INTEGER
                     The number of super-diagonals or sub-diagonals of the
                     band matrix A.  K &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                     The upper or lower triangle of the symmetric band matrix A,
                     stored in the first K+1 rows of AB.  The j-th column of A is
                     stored in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j&lt;=i&lt;=min(n,j+k).

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= K+1.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I' or '1' or 'O'; otherwise,
                     WORK is not referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>dlansp</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>AP,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>DLANSP</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a symmetric matrix supplied in packed form.

       <b>Purpose:</b>

            DLANSP  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real symmetric matrix A,  supplied in packed form.

       <b>Returns</b>
           DLANSP

               DLANSP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in DLANSP as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix A is supplied.
                     = 'U':  Upper triangular part of A is supplied
                     = 'L':  Lower triangular part of A is supplied

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, DLANSP is
                     set to zero.

           <u>AP</u>

                     AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the symmetric matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I' or '1' or 'O'; otherwise,
                     WORK is not referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>dlantb</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>DLANTB</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a triangular band matrix.

       <b>Purpose:</b>

            DLANTB  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the element of  largest absolute value  of an
            n by n triangular band matrix A,  with ( k + 1 ) diagonals.

       <b>Returns</b>
           DLANTB

               DLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in DLANTB as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, DLANTB is
                     set to zero.

           <u>K</u>

                     K is INTEGER
                     The number of super-diagonals of the matrix A if UPLO = 'U',
                     or the number of sub-diagonals of the matrix A if UPLO = 'L'.
                     K &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                     The upper or lower triangular band matrix A, stored in the
                     first k+1 rows of AB.  The j-th column of A is stored
                     in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j&lt;=i&lt;=min(n,j+k).
                     Note that when DIAG = 'U', the elements of the array AB
                     corresponding to the diagonal elements of the matrix A are
                     not referenced, but are assumed to be one.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= K+1.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I'; otherwise, WORK is not
                     referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>dlantp</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>DLANTP</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a triangular matrix supplied in packed form.

       <b>Purpose:</b>

            DLANTP  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            triangular matrix A, supplied in packed form.

       <b>Returns</b>
           DLANTP

               DLANTP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in DLANTP as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, DLANTP is
                     set to zero.

           <u>AP</u>

                     AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)
                     The upper or lower triangular matrix A, packed columnwise in
                     a linear array.  The j-th column of A is stored in the array
                     AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     Note that when DIAG = 'U', the elements of the array AP
                     corresponding to the diagonal elements of the matrix A are
                     not referenced, but are assumed to be one.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I'; otherwise, WORK is not
                     referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>dlantr</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>DLANTR</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a trapezoidal or triangular matrix.

       <b>Purpose:</b>

            DLANTR  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            trapezoidal or triangular matrix A.

       <b>Returns</b>
           DLANTR

               DLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in DLANTR as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower trapezoidal.
                     = 'U':  Upper trapezoidal
                     = 'L':  Lower trapezoidal
                     Note that A is triangular instead of trapezoidal if M = N.

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A has unit diagonal.
                     = 'N':  Non-unit diagonal
                     = 'U':  Unit diagonal

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0, and if
                     UPLO = 'U', M &lt;= N.  When M = 0, DLANTR is set to zero.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0, and if
                     UPLO = 'L', N &lt;= M.  When N = 0, DLANTR is set to zero.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     The trapezoidal matrix A (A is triangular if M = N).
                     If UPLO = 'U', the leading m by n upper trapezoidal part of
                     the array A contains the upper trapezoidal matrix, and the
                     strictly lower triangular part of A is not referenced.
                     If UPLO = 'L', the leading m by n lower trapezoidal part of
                     the array A contains the lower trapezoidal matrix, and the
                     strictly upper triangular part of A is not referenced.  Note
                     that when DIAG = 'U', the diagonal elements of A are not
                     referenced and are assumed to be one.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(M,1).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= M when NORM = 'I'; otherwise, WORK is not
                     referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlanv2</b> <b>(double</b> <b>precision</b> <b>A,</b> <b>double</b> <b>precision</b> <b>B,</b> <b>double</b> <b>precision</b> <b>C,</b> <b>double</b> <b>precision</b> <b>D,</b> <b>double</b>
       <b>precision</b> <b>RT1R,</b> <b>double</b> <b>precision</b> <b>RT1I,</b> <b>double</b> <b>precision</b> <b>RT2R,</b> <b>double</b> <b>precision</b> <b>RT2I,</b> <b>double</b> <b>precision</b> <b>CS,</b>
       <b>double</b> <b>precision</b> <b>SN)</b>
       <b>DLANV2</b> computes the Schur factorization of a real 2-by-2 nonsymmetric matrix in standard form.

       <b>Purpose:</b>

            DLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
            matrix in standard form:

                 [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
                 [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]

            where either
            1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
            2) AA = DD and BB*CC &lt; 0, so that AA + or - sqrt(BB*CC) are complex
            conjugate eigenvalues.

       <b>Parameters</b>
           <u>A</u>

                     A is DOUBLE PRECISION

           <u>B</u>

                     B is DOUBLE PRECISION

           <u>C</u>

                     C is DOUBLE PRECISION

           <u>D</u>

                     D is DOUBLE PRECISION
                     On entry, the elements of the input matrix.
                     On exit, they are overwritten by the elements of the
                     standardised Schur form.

           <u>RT1R</u>

                     RT1R is DOUBLE PRECISION

           <u>RT1I</u>

                     RT1I is DOUBLE PRECISION

           <u>RT2R</u>

                     RT2R is DOUBLE PRECISION

           <u>RT2I</u>

                     RT2I is DOUBLE PRECISION
                     The real and imaginary parts of the eigenvalues. If the
                     eigenvalues are a complex conjugate pair, RT1I &gt; 0.

           <u>CS</u>

                     CS is DOUBLE PRECISION

           <u>SN</u>

                     SN is DOUBLE PRECISION
                     Parameters of the rotation matrix.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Modified by V. Sima, Research Institute for Informatics, Bucharest,
             Romania, to reduce the risk of cancellation errors,
             when computing real eigenvalues, and to ensure, if possible, that
             abs(RT1R) &gt;= abs(RT2R).

   <b>subroutine</b> <b>dlapll</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>Y,</b> <b>integer</b> <b>INCY,</b> <b>double</b> <b>precision</b> <b>SSMIN)</b>
       <b>DLAPLL</b> measures the linear dependence of two vectors.

       <b>Purpose:</b>

            Given two column vectors X and Y, let

                                 A = ( X Y ).

            The subroutine first computes the QR factorization of A = Q*R,
            and then computes the SVD of the 2-by-2 upper triangular matrix R.
            The smaller singular value of R is returned in SSMIN, which is used
            as the measurement of the linear dependency of the vectors X and Y.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The length of the vectors X and Y.

           <u>X</u>

                     X is DOUBLE PRECISION array,
                                    dimension (1+(N-1)*INCX)
                     On entry, X contains the N-vector X.
                     On exit, X is overwritten.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between successive elements of X. INCX &gt; 0.

           <u>Y</u>

                     Y is DOUBLE PRECISION array,
                                    dimension (1+(N-1)*INCY)
                     On entry, Y contains the N-vector Y.
                     On exit, Y is overwritten.

           <u>INCY</u>

                     INCY is INTEGER
                     The increment between successive elements of Y. INCY &gt; 0.

           <u>SSMIN</u>

                     SSMIN is DOUBLE PRECISION
                     The smallest singular value of the N-by-2 matrix A = ( X Y ).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlapmr</b> <b>(logical</b> <b>FORWRD,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b>
       <b>LDX,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>K)</b>
       <b>DLAPMR</b> rearranges rows of a matrix as specified by a permutation vector.

       <b>Purpose:</b>

            DLAPMR rearranges the rows of the M by N matrix X as specified
            by the permutation <a href="../man1/K.1.html">K</a>(1),<a href="../man2/K.2.html">K</a>(2),...,K(M) of the integers 1,...,M.
            If FORWRD = .TRUE.,  forward permutation:

                 X(K(I),*) is moved X(I,*) for I = 1,2,...,M.

            If FORWRD = .FALSE., backward permutation:

                 X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.

       <b>Parameters</b>
           <u>FORWRD</u>

                     FORWRD is LOGICAL
                     = .TRUE., forward permutation
                     = .FALSE., backward permutation

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix X. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix X. N &gt;= 0.

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (LDX,N)
                     On entry, the M by N matrix X.
                     On exit, X contains the permuted matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X, LDX &gt;= MAX(1,M).

           <u>K</u>

                     K is INTEGER array, dimension (M)
                     On entry, K contains the permutation vector. K is used as
                     internal workspace, but reset to its original value on
                     output.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlapmt</b> <b>(logical</b> <b>FORWRD,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b>
       <b>LDX,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>K)</b>
       <b>DLAPMT</b> performs a forward or backward permutation of the columns of a matrix.

       <b>Purpose:</b>

            DLAPMT rearranges the columns of the M by N matrix X as specified
            by the permutation <a href="../man1/K.1.html">K</a>(1),<a href="../man2/K.2.html">K</a>(2),...,K(N) of the integers 1,...,N.
            If FORWRD = .TRUE.,  forward permutation:

                 X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.

            If FORWRD = .FALSE., backward permutation:

                 X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.

       <b>Parameters</b>
           <u>FORWRD</u>

                     FORWRD is LOGICAL
                     = .TRUE., forward permutation
                     = .FALSE., backward permutation

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix X. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix X. N &gt;= 0.

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (LDX,N)
                     On entry, the M by N matrix X.
                     On exit, X contains the permuted matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X, LDX &gt;= MAX(1,M).

           <u>K</u>

                     K is INTEGER array, dimension (N)
                     On entry, K contains the permutation vector. K is used as
                     internal workspace, but reset to its original value on
                     output.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlaqp2</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>OFFSET,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b>
       <b>LDA,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>JPVT,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>VN1,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>VN2,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>DLAQP2</b> computes a QR factorization with column pivoting of the matrix block.

       <b>Purpose:</b>

            DLAQP2 computes a QR factorization with column pivoting of
            the block A(OFFSET+1:M,1:N).
            The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A. N &gt;= 0.

           <u>OFFSET</u>

                     OFFSET is INTEGER
                     The number of rows of the matrix A that must be pivoted
                     but no factorized. OFFSET &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.
                     On exit, the upper triangle of block A(OFFSET+1:M,1:N) is
                     the triangular factor obtained; the elements in block
                     A(OFFSET+1:M,1:N) below the diagonal, together with the
                     array TAU, represent the orthogonal matrix Q as a product of
                     elementary reflectors. Block A(1:OFFSET,1:N) has been
                     accordingly pivoted, but no factorized.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>JPVT</u>

                     JPVT is INTEGER array, dimension (N)
                     On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
                     to the front of A*P (a leading column); if JPVT(i) = 0,
                     the i-th column of A is a free column.
                     On exit, if JPVT(i) = k, then the i-th column of A*P
                     was the k-th column of A.

           <u>TAU</u>

                     TAU is DOUBLE PRECISION array, dimension (min(M,N))
                     The scalar factors of the elementary reflectors.

           <u>VN1</u>

                     VN1 is DOUBLE PRECISION array, dimension (N)
                     The vector with the partial column norms.

           <u>VN2</u>

                     VN2 is DOUBLE PRECISION array, dimension (N)
                     The vector with the exact column norms.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (N)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain X. Sun, Computer Science Dept.,
           Duke University, USA
            Partial column norm updating strategy modified on April 2011 Z. Drmac and Z. Bujanovic, Dept. of
           Mathematics, University of Zagreb, Croatia.

       <b>References:</b>
           LAPACK Working Note 176

   <b>subroutine</b> <b>dlaqps</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>OFFSET,</b> <b>integer</b> <b>NB,</b> <b>integer</b> <b>KB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>JPVT,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>VN1,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>VN2,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>AUXV,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldf,</b> <b>*</b> <b>)</b> <b>F,</b> <b>integer</b> <b>LDF)</b>
       <b>DLAQPS</b> computes a step of QR factorization with column pivoting of a real m-by-n matrix A by using BLAS
       level 3.

       <b>Purpose:</b>

            DLAQPS computes a step of QR factorization with column pivoting
            of a real M-by-N matrix A by using Blas-3.  It tries to factorize
            NB columns from A starting from the row OFFSET+1, and updates all
            of the matrix with Blas-3 xGEMM.

            In some cases, due to catastrophic cancellations, it cannot
            factorize NB columns.  Hence, the actual number of factorized
            columns is returned in KB.

            Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A. N &gt;= 0

           <u>OFFSET</u>

                     OFFSET is INTEGER
                     The number of rows of A that have been factorized in
                     previous steps.

           <u>NB</u>

                     NB is INTEGER
                     The number of columns to factorize.

           <u>KB</u>

                     KB is INTEGER
                     The number of columns actually factorized.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.
                     On exit, block A(OFFSET+1:M,1:KB) is the triangular
                     factor obtained and block A(1:OFFSET,1:N) has been
                     accordingly pivoted, but no factorized.
                     The rest of the matrix, block A(OFFSET+1:M,KB+1:N) has
                     been updated.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>JPVT</u>

                     JPVT is INTEGER array, dimension (N)
                     JPVT(I) = K &lt;==&gt; Column K of the full matrix A has been
                     permuted into position I in AP.

           <u>TAU</u>

                     TAU is DOUBLE PRECISION array, dimension (KB)
                     The scalar factors of the elementary reflectors.

           <u>VN1</u>

                     VN1 is DOUBLE PRECISION array, dimension (N)
                     The vector with the partial column norms.

           <u>VN2</u>

                     VN2 is DOUBLE PRECISION array, dimension (N)
                     The vector with the exact column norms.

           <u>AUXV</u>

                     AUXV is DOUBLE PRECISION array, dimension (NB)
                     Auxiliary vector.

           <u>F</u>

                     F is DOUBLE PRECISION array, dimension (LDF,NB)
                     Matrix F**T = L*Y**T*A.

           <u>LDF</u>

                     LDF is INTEGER
                     The leading dimension of the array F. LDF &gt;= max(1,N).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain X. Sun, Computer Science Dept.,
           Duke University, USA
            Partial column norm updating strategy modified on April 2011 Z. Drmac and Z. Bujanovic, Dept. of
           Mathematics, University of Zagreb, Croatia.

       <b>References:</b>
           LAPACK Working Note 176

   <b>subroutine</b> <b>dlaqr0</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WR,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>WI,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAQR0</b> computes the eigenvalues of a Hessenberg matrix, and optionally the matrices from the Schur
       decomposition.

       <b>Purpose:</b>

               DLAQR0 computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**T, where T is an upper quasi-triangular matrix (the
               Schur form), and Z is the orthogonal matrix of Schur vectors.

               Optionally Z may be postmultiplied into an input orthogonal
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     = .TRUE. : the full Schur form T is required;
                     = .FALSE.: only eigenvalues are required.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     = .TRUE. : the matrix of Schur vectors Z is required;
                     = .FALSE.: Schur vectors are not required.

           <u>N</u>

                     N is INTEGER
                      The order of the matrix H.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER
                      It is assumed that H is already upper triangular in rows
                      and columns 1:ILO-1 and IHI+1:N and, if ILO &gt; 1,
                      H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
                      previous call to DGEBAL, and then passed to DGEHRD when the
                      matrix output by DGEBAL is reduced to Hessenberg form.
                      Otherwise, ILO and IHI should be set to 1 and N,
                      respectively.  If N &gt; 0, then 1 &lt;= ILO &lt;= IHI &lt;= N.
                      If N = 0, then ILO = 1 and IHI = 0.

           <u>H</u>

                     H is DOUBLE PRECISION array, dimension (LDH,N)
                      On entry, the upper Hessenberg matrix H.
                      On exit, if INFO = 0 and WANTT is .TRUE., then H contains
                      the upper quasi-triangular matrix T from the Schur
                      decomposition (the Schur form); 2-by-2 diagonal blocks
                      (corresponding to complex conjugate pairs of eigenvalues)
                      are returned in standard form, with H(i,i) = H(i+1,i+1)
                      and H(i+1,i)*H(i,i+1) &lt; 0. If INFO = 0 and WANTT is
                      .FALSE., then the contents of H are unspecified on exit.
                      (The output value of H when INFO &gt; 0 is given under the
                      description of INFO below.)

                      This subroutine may explicitly set H(i,j) = 0 for i &gt; j and
                      j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.

           <u>LDH</u>

                     LDH is INTEGER
                      The leading dimension of the array H. LDH &gt;= max(1,N).

           <u>WR</u>

                     WR is DOUBLE PRECISION array, dimension (IHI)

           <u>WI</u>

                     WI is DOUBLE PRECISION array, dimension (IHI)
                      The real and imaginary parts, respectively, of the computed
                      eigenvalues of H(ILO:IHI,ILO:IHI) are stored in WR(ILO:IHI)
                      and WI(ILO:IHI). If two eigenvalues are computed as a
                      complex conjugate pair, they are stored in consecutive
                      elements of WR and WI, say the i-th and (i+1)th, with
                      WI(i) &gt; 0 and WI(i+1) &lt; 0. If WANTT is .TRUE., then
                      the eigenvalues are stored in the same order as on the
                      diagonal of the Schur form returned in H, with
                      WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
                      block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
                      WI(i+1) = -WI(i).

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                      Specify the rows of Z to which transformations must be
                      applied if WANTZ is .TRUE..
                      1 &lt;= ILOZ &lt;= ILO; IHI &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (LDZ,IHI)
                      If WANTZ is .FALSE., then Z is not referenced.
                      If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
                      replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
                      orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
                      (The output value of Z when INFO &gt; 0 is given under
                      the description of INFO below.)

           <u>LDZ</u>

                     LDZ is INTEGER
                      The leading dimension of the array Z.  if WANTZ is .TRUE.
                      then LDZ &gt;= MAX(1,IHIZ).  Otherwise, LDZ &gt;= 1.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension LWORK
                      On exit, if LWORK = -1, <a href="../man1/WORK.1.html">WORK</a>(1) returns an estimate of
                      the optimal value for LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                      The dimension of the array WORK.  LWORK &gt;= max(1,N)
                      is sufficient, but LWORK typically as large as 6*N may
                      be required for optimal performance.  A workspace query
                      to determine the optimal workspace size is recommended.

                      If LWORK = -1, then DLAQR0 does a workspace query.
                      In this case, DLAQR0 checks the input parameters and
                      estimates the optimal workspace size for the given
                      values of N, ILO and IHI.  The estimate is returned
                      in <a href="../man1/WORK.1.html">WORK</a>(1).  No error message related to LWORK is
                      issued by XERBLA.  Neither H nor Z are accessed.

           <u>INFO</u>

                     INFO is INTEGER
                        = 0:  successful exit
                        &gt; 0:  if INFO = i, DLAQR0 failed to compute all of
                           the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                           and WI contain those eigenvalues which have been
                           successfully computed.  (Failures are rare.)

                           If INFO &gt; 0 and WANT is .FALSE., then on exit,
                           the remaining unconverged eigenvalues are the eigen-
                           values of the upper Hessenberg matrix rows and
                           columns ILO through INFO of the final, output
                           value of H.

                           If INFO &gt; 0 and WANTT is .TRUE., then on exit

                      (*)  (initial value of H)*U  = U*(final value of H)

                           where U is an orthogonal matrix.  The final
                           value of H is upper Hessenberg and quasi-triangular
                           in rows and columns INFO+1 through IHI.

                           If INFO &gt; 0 and WANTZ is .TRUE., then on exit

                             (final value of Z(ILO:IHI,ILOZ:IHIZ)
                              =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U

                           where U is the orthogonal matrix in (*) (regard-
                           less of the value of WANTT.)

                           If INFO &gt; 0 and WANTZ is .FALSE., then Z is not
                           accessed.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

       <b>References:</b>

             K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
             Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
             Performance, SIAM Journal of Matrix Analysis, volume 23, pages
             929--947, 2002.

            K. Braman, R. Byers and R. Mathias, The Multi-Shift QR Algorithm Part II: Aggressive Early
           Deflation, SIAM Journal of Matrix Analysis, volume 23, pages 948--973, 2002.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlaqr1</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>double</b> <b>precision</b> <b>SR1,</b>
       <b>double</b> <b>precision</b> <b>SI1,</b> <b>double</b> <b>precision</b> <b>SR2,</b> <b>double</b> <b>precision</b> <b>SI2,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V)</b>
       <b>DLAQR1</b> sets a scalar multiple of the first column of the product of 2-by-2 or 3-by-3 matrix H and
       specified shifts.

       <b>Purpose:</b>

                 Given a 2-by-2 or 3-by-3 matrix H, DLAQR1 sets v to a
                 scalar multiple of the first column of the product

                 (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)

                 scaling to avoid overflows and most underflows. It
                 is assumed that either

                         1) sr1 = sr2 and si1 = -si2
                     or
                         2) si1 = si2 = 0.

                 This is useful for starting double implicit shift bulges
                 in the QR algorithm.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                         Order of the matrix H. N must be either 2 or 3.

           <u>H</u>

                     H is DOUBLE PRECISION array, dimension (LDH,N)
                         The 2-by-2 or 3-by-3 matrix H in (*).

           <u>LDH</u>

                     LDH is INTEGER
                         The leading dimension of H as declared in
                         the calling procedure.  LDH &gt;= N

           <u>SR1</u>

                     SR1 is DOUBLE PRECISION

           <u>SI1</u>

                     SI1 is DOUBLE PRECISION

           <u>SR2</u>

                     SR2 is DOUBLE PRECISION

           <u>SI2</u>

                     SI2 is DOUBLE PRECISION
                         The shifts in (*).

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension (N)
                         A scalar multiple of the first column of the
                         matrix K in (*).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

   <b>subroutine</b> <b>dlaqr2</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KTOP,</b> <b>integer</b> <b>KBOT,</b> <b>integer</b> <b>NW,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>integer</b> <b>NS,</b> <b>integer</b> <b>ND,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SR,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>SI,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>integer</b> <b>NH,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>integer</b> <b>NV,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldwv,</b> <b>*</b> <b>)</b> <b>WV,</b> <b>integer</b> <b>LDWV,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK)</b>
       <b>DLAQR2</b> performs the orthogonal similarity transformation of a Hessenberg matrix to detect and deflate
       fully converged eigenvalues from a trailing principal submatrix (aggressive early deflation).

       <b>Purpose:</b>

               DLAQR2 is identical to DLAQR3 except that it avoids
               recursion by calling DLAHQR instead of DLAQR4.

               Aggressive early deflation:

               This subroutine accepts as input an upper Hessenberg matrix
               H and performs an orthogonal similarity transformation
               designed to detect and deflate fully converged eigenvalues from
               a trailing principal submatrix.  On output H has been over-
               written by a new Hessenberg matrix that is a perturbation of
               an orthogonal similarity transformation of H.  It is to be
               hoped that the final version of H has many zero subdiagonal
               entries.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     If .TRUE., then the Hessenberg matrix H is fully updated
                     so that the quasi-triangular Schur factor may be
                     computed (in cooperation with the calling subroutine).
                     If .FALSE., then only enough of H is updated to preserve
                     the eigenvalues.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     If .TRUE., then the orthogonal matrix Z is updated so
                     so that the orthogonal Schur factor may be computed
                     (in cooperation with the calling subroutine).
                     If .FALSE., then Z is not referenced.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix H and (if WANTZ is .TRUE.) the
                     order of the orthogonal matrix Z.

           <u>KTOP</u>

                     KTOP is INTEGER
                     It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
                     KBOT and KTOP together determine an isolated block
                     along the diagonal of the Hessenberg matrix.

           <u>KBOT</u>

                     KBOT is INTEGER
                     It is assumed without a check that either
                     KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
                     determine an isolated block along the diagonal of the
                     Hessenberg matrix.

           <u>NW</u>

                     NW is INTEGER
                     Deflation window size.  1 &lt;= NW &lt;= (KBOT-KTOP+1).

           <u>H</u>

                     H is DOUBLE PRECISION array, dimension (LDH,N)
                     On input the initial N-by-N section of H stores the
                     Hessenberg matrix undergoing aggressive early deflation.
                     On output H has been transformed by an orthogonal
                     similarity transformation, perturbed, and the returned
                     to Hessenberg form that (it is to be hoped) has some
                     zero subdiagonal entries.

           <u>LDH</u>

                     LDH is INTEGER
                     Leading dimension of H just as declared in the calling
                     subroutine.  N &lt;= LDH

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                     Specify the rows of Z to which transformations must be
                     applied if WANTZ is .TRUE.. 1 &lt;= ILOZ &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (LDZ,N)
                     IF WANTZ is .TRUE., then on output, the orthogonal
                     similarity transformation mentioned above has been
                     accumulated into Z(ILOZ:IHIZ,ILOZ:IHIZ) from the right.
                     If WANTZ is .FALSE., then Z is unreferenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of Z just as declared in the
                     calling subroutine.  1 &lt;= LDZ.

           <u>NS</u>

                     NS is INTEGER
                     The number of unconverged (ie approximate) eigenvalues
                     returned in SR and SI that may be used as shifts by the
                     calling subroutine.

           <u>ND</u>

                     ND is INTEGER
                     The number of converged eigenvalues uncovered by this
                     subroutine.

           <u>SR</u>

                     SR is DOUBLE PRECISION array, dimension (KBOT)

           <u>SI</u>

                     SI is DOUBLE PRECISION array, dimension (KBOT)
                     On output, the real and imaginary parts of approximate
                     eigenvalues that may be used for shifts are stored in
                     SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
                     SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
                     The real and imaginary parts of converged eigenvalues
                     are stored in SR(KBOT-ND+1) through SR(KBOT) and
                     SI(KBOT-ND+1) through SI(KBOT), respectively.

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension (LDV,NW)
                     An NW-by-NW work array.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of V just as declared in the
                     calling subroutine.  NW &lt;= LDV

           <u>NH</u>

                     NH is INTEGER
                     The number of columns of T.  NH &gt;= NW.

           <u>T</u>

                     T is DOUBLE PRECISION array, dimension (LDT,NW)

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of T just as declared in the
                     calling subroutine.  NW &lt;= LDT

           <u>NV</u>

                     NV is INTEGER
                     The number of rows of work array WV available for
                     workspace.  NV &gt;= NW.

           <u>WV</u>

                     WV is DOUBLE PRECISION array, dimension (LDWV,NW)

           <u>LDWV</u>

                     LDWV is INTEGER
                     The leading dimension of W just as declared in the
                     calling subroutine.  NW &lt;= LDV

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (LWORK)
                     On exit, <a href="../man1/WORK.1.html">WORK</a>(1) is set to an estimate of the optimal value
                     of LWORK for the given values of N, NW, KTOP and KBOT.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the work array WORK.  LWORK = 2*NW
                     suffices, but greater efficiency may result from larger
                     values of LWORK.

                     If LWORK = -1, then a workspace query is assumed; DLAQR2
                     only estimates the optimal workspace size for the given
                     values of N, NW, KTOP and KBOT.  The estimate is returned
                     in <a href="../man1/WORK.1.html">WORK</a>(1).  No error message related to LWORK is issued
                     by XERBLA.  Neither H nor Z are accessed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

   <b>subroutine</b> <b>dlaqr3</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KTOP,</b> <b>integer</b> <b>KBOT,</b> <b>integer</b> <b>NW,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>integer</b> <b>NS,</b> <b>integer</b> <b>ND,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SR,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>SI,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>integer</b> <b>NH,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>integer</b> <b>NV,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldwv,</b> <b>*</b> <b>)</b> <b>WV,</b> <b>integer</b> <b>LDWV,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK)</b>
       <b>DLAQR3</b> performs the orthogonal similarity transformation of a Hessenberg matrix to detect and deflate
       fully converged eigenvalues from a trailing principal submatrix (aggressive early deflation).

       <b>Purpose:</b>

               Aggressive early deflation:

               DLAQR3 accepts as input an upper Hessenberg matrix
               H and performs an orthogonal similarity transformation
               designed to detect and deflate fully converged eigenvalues from
               a trailing principal submatrix.  On output H has been over-
               written by a new Hessenberg matrix that is a perturbation of
               an orthogonal similarity transformation of H.  It is to be
               hoped that the final version of H has many zero subdiagonal
               entries.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     If .TRUE., then the Hessenberg matrix H is fully updated
                     so that the quasi-triangular Schur factor may be
                     computed (in cooperation with the calling subroutine).
                     If .FALSE., then only enough of H is updated to preserve
                     the eigenvalues.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     If .TRUE., then the orthogonal matrix Z is updated so
                     so that the orthogonal Schur factor may be computed
                     (in cooperation with the calling subroutine).
                     If .FALSE., then Z is not referenced.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix H and (if WANTZ is .TRUE.) the
                     order of the orthogonal matrix Z.

           <u>KTOP</u>

                     KTOP is INTEGER
                     It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
                     KBOT and KTOP together determine an isolated block
                     along the diagonal of the Hessenberg matrix.

           <u>KBOT</u>

                     KBOT is INTEGER
                     It is assumed without a check that either
                     KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
                     determine an isolated block along the diagonal of the
                     Hessenberg matrix.

           <u>NW</u>

                     NW is INTEGER
                     Deflation window size.  1 &lt;= NW &lt;= (KBOT-KTOP+1).

           <u>H</u>

                     H is DOUBLE PRECISION array, dimension (LDH,N)
                     On input the initial N-by-N section of H stores the
                     Hessenberg matrix undergoing aggressive early deflation.
                     On output H has been transformed by an orthogonal
                     similarity transformation, perturbed, and the returned
                     to Hessenberg form that (it is to be hoped) has some
                     zero subdiagonal entries.

           <u>LDH</u>

                     LDH is INTEGER
                     Leading dimension of H just as declared in the calling
                     subroutine.  N &lt;= LDH

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                     Specify the rows of Z to which transformations must be
                     applied if WANTZ is .TRUE.. 1 &lt;= ILOZ &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (LDZ,N)
                     IF WANTZ is .TRUE., then on output, the orthogonal
                     similarity transformation mentioned above has been
                     accumulated into Z(ILOZ:IHIZ,ILOZ:IHIZ) from the right.
                     If WANTZ is .FALSE., then Z is unreferenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of Z just as declared in the
                     calling subroutine.  1 &lt;= LDZ.

           <u>NS</u>

                     NS is INTEGER
                     The number of unconverged (ie approximate) eigenvalues
                     returned in SR and SI that may be used as shifts by the
                     calling subroutine.

           <u>ND</u>

                     ND is INTEGER
                     The number of converged eigenvalues uncovered by this
                     subroutine.

           <u>SR</u>

                     SR is DOUBLE PRECISION array, dimension (KBOT)

           <u>SI</u>

                     SI is DOUBLE PRECISION array, dimension (KBOT)
                     On output, the real and imaginary parts of approximate
                     eigenvalues that may be used for shifts are stored in
                     SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
                     SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
                     The real and imaginary parts of converged eigenvalues
                     are stored in SR(KBOT-ND+1) through SR(KBOT) and
                     SI(KBOT-ND+1) through SI(KBOT), respectively.

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension (LDV,NW)
                     An NW-by-NW work array.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of V just as declared in the
                     calling subroutine.  NW &lt;= LDV

           <u>NH</u>

                     NH is INTEGER
                     The number of columns of T.  NH &gt;= NW.

           <u>T</u>

                     T is DOUBLE PRECISION array, dimension (LDT,NW)

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of T just as declared in the
                     calling subroutine.  NW &lt;= LDT

           <u>NV</u>

                     NV is INTEGER
                     The number of rows of work array WV available for
                     workspace.  NV &gt;= NW.

           <u>WV</u>

                     WV is DOUBLE PRECISION array, dimension (LDWV,NW)

           <u>LDWV</u>

                     LDWV is INTEGER
                     The leading dimension of W just as declared in the
                     calling subroutine.  NW &lt;= LDV

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (LWORK)
                     On exit, <a href="../man1/WORK.1.html">WORK</a>(1) is set to an estimate of the optimal value
                     of LWORK for the given values of N, NW, KTOP and KBOT.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the work array WORK.  LWORK = 2*NW
                     suffices, but greater efficiency may result from larger
                     values of LWORK.

                     If LWORK = -1, then a workspace query is assumed; DLAQR3
                     only estimates the optimal workspace size for the given
                     values of N, NW, KTOP and KBOT.  The estimate is returned
                     in <a href="../man1/WORK.1.html">WORK</a>(1).  No error message related to LWORK is issued
                     by XERBLA.  Neither H nor Z are accessed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

   <b>subroutine</b> <b>dlaqr4</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WR,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>WI,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAQR4</b> computes the eigenvalues of a Hessenberg matrix, and optionally the matrices from the Schur
       decomposition.

       <b>Purpose:</b>

               DLAQR4 implements one level of recursion for DLAQR0.
               It is a complete implementation of the small bulge multi-shift
               QR algorithm.  It may be called by DLAQR0 and, for large enough
               deflation window size, it may be called by DLAQR3.  This
               subroutine is identical to DLAQR0 except that it calls DLAQR2
               instead of DLAQR3.

               DLAQR4 computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**T, where T is an upper quasi-triangular matrix (the
               Schur form), and Z is the orthogonal matrix of Schur vectors.

               Optionally Z may be postmultiplied into an input orthogonal
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     = .TRUE. : the full Schur form T is required;
                     = .FALSE.: only eigenvalues are required.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     = .TRUE. : the matrix of Schur vectors Z is required;
                     = .FALSE.: Schur vectors are not required.

           <u>N</u>

                     N is INTEGER
                      The order of the matrix H.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER
                      It is assumed that H is already upper triangular in rows
                      and columns 1:ILO-1 and IHI+1:N and, if ILO &gt; 1,
                      H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
                      previous call to DGEBAL, and then passed to DGEHRD when the
                      matrix output by DGEBAL is reduced to Hessenberg form.
                      Otherwise, ILO and IHI should be set to 1 and N,
                      respectively.  If N &gt; 0, then 1 &lt;= ILO &lt;= IHI &lt;= N.
                      If N = 0, then ILO = 1 and IHI = 0.

           <u>H</u>

                     H is DOUBLE PRECISION array, dimension (LDH,N)
                      On entry, the upper Hessenberg matrix H.
                      On exit, if INFO = 0 and WANTT is .TRUE., then H contains
                      the upper quasi-triangular matrix T from the Schur
                      decomposition (the Schur form); 2-by-2 diagonal blocks
                      (corresponding to complex conjugate pairs of eigenvalues)
                      are returned in standard form, with H(i,i) = H(i+1,i+1)
                      and H(i+1,i)*H(i,i+1) &lt; 0. If INFO = 0 and WANTT is
                      .FALSE., then the contents of H are unspecified on exit.
                      (The output value of H when INFO &gt; 0 is given under the
                      description of INFO below.)

                      This subroutine may explicitly set H(i,j) = 0 for i &gt; j and
                      j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.

           <u>LDH</u>

                     LDH is INTEGER
                      The leading dimension of the array H. LDH &gt;= max(1,N).

           <u>WR</u>

                     WR is DOUBLE PRECISION array, dimension (IHI)

           <u>WI</u>

                     WI is DOUBLE PRECISION array, dimension (IHI)
                      The real and imaginary parts, respectively, of the computed
                      eigenvalues of H(ILO:IHI,ILO:IHI) are stored in WR(ILO:IHI)
                      and WI(ILO:IHI). If two eigenvalues are computed as a
                      complex conjugate pair, they are stored in consecutive
                      elements of WR and WI, say the i-th and (i+1)th, with
                      WI(i) &gt; 0 and WI(i+1) &lt; 0. If WANTT is .TRUE., then
                      the eigenvalues are stored in the same order as on the
                      diagonal of the Schur form returned in H, with
                      WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
                      block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
                      WI(i+1) = -WI(i).

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                      Specify the rows of Z to which transformations must be
                      applied if WANTZ is .TRUE..
                      1 &lt;= ILOZ &lt;= ILO; IHI &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (LDZ,IHI)
                      If WANTZ is .FALSE., then Z is not referenced.
                      If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
                      replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
                      orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
                      (The output value of Z when INFO &gt; 0 is given under
                      the description of INFO below.)

           <u>LDZ</u>

                     LDZ is INTEGER
                      The leading dimension of the array Z.  if WANTZ is .TRUE.
                      then LDZ &gt;= MAX(1,IHIZ).  Otherwise, LDZ &gt;= 1.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension LWORK
                      On exit, if LWORK = -1, <a href="../man1/WORK.1.html">WORK</a>(1) returns an estimate of
                      the optimal value for LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                      The dimension of the array WORK.  LWORK &gt;= max(1,N)
                      is sufficient, but LWORK typically as large as 6*N may
                      be required for optimal performance.  A workspace query
                      to determine the optimal workspace size is recommended.

                      If LWORK = -1, then DLAQR4 does a workspace query.
                      In this case, DLAQR4 checks the input parameters and
                      estimates the optimal workspace size for the given
                      values of N, ILO and IHI.  The estimate is returned
                      in <a href="../man1/WORK.1.html">WORK</a>(1).  No error message related to LWORK is
                      issued by XERBLA.  Neither H nor Z are accessed.

           <u>INFO</u>

                     INFO is INTEGER
                        = 0:  successful exit
                        &gt; 0:  if INFO = i, DLAQR4 failed to compute all of
                           the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                           and WI contain those eigenvalues which have been
                           successfully computed.  (Failures are rare.)

                           If INFO &gt; 0 and WANT is .FALSE., then on exit,
                           the remaining unconverged eigenvalues are the eigen-
                           values of the upper Hessenberg matrix rows and
                           columns ILO through INFO of the final, output
                           value of H.

                           If INFO &gt; 0 and WANTT is .TRUE., then on exit

                      (*)  (initial value of H)*U  = U*(final value of H)

                           where U is a orthogonal matrix.  The final
                           value of  H is upper Hessenberg and triangular in
                           rows and columns INFO+1 through IHI.

                           If INFO &gt; 0 and WANTZ is .TRUE., then on exit

                             (final value of Z(ILO:IHI,ILOZ:IHIZ)
                              =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U

                           where U is the orthogonal matrix in (*) (regard-
                           less of the value of WANTT.)

                           If INFO &gt; 0 and WANTZ is .FALSE., then Z is not
                           accessed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

       <b>References:</b>

             K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
             Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
             Performance, SIAM Journal of Matrix Analysis, volume 23, pages
             929--947, 2002.

            K. Braman, R. Byers and R. Mathias, The Multi-Shift QR Algorithm Part II: Aggressive Early
           Deflation, SIAM Journal of Matrix Analysis, volume 23, pages 948--973, 2002.

   <b>subroutine</b> <b>dlaqr5</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>KACC22,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KTOP,</b> <b>integer</b> <b>KBOT,</b>
       <b>integer</b> <b>NSHFTS,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SR,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SI,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b> <b>LDU,</b> <b>integer</b> <b>NV,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldwv,</b> <b>*</b> <b>)</b> <b>WV,</b> <b>integer</b> <b>LDWV,</b>
       <b>integer</b> <b>NH,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldwh,</b> <b>*</b> <b>)</b> <b>WH,</b> <b>integer</b> <b>LDWH)</b>
       <b>DLAQR5</b> performs a single small-bulge multi-shift QR sweep.

       <b>Purpose:</b>

               DLAQR5, called by DLAQR0, performs a
               single small-bulge multi-shift QR sweep.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                        WANTT = .true. if the quasi-triangular Schur factor
                        is being computed.  WANTT is set to .false. otherwise.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                        WANTZ = .true. if the orthogonal Schur factor is being
                        computed.  WANTZ is set to .false. otherwise.

           <u>KACC22</u>

                     KACC22 is INTEGER with value 0, 1, or 2.
                        Specifies the computation mode of far-from-diagonal
                        orthogonal updates.
                   = 0: DLAQR5 does not accumulate reflections and does not
                        use matrix-matrix multiply to update far-from-diagonal
                        matrix entries.
                   = 1: DLAQR5 accumulates reflections and uses matrix-matrix
                        multiply to update the far-from-diagonal matrix entries.
                   = 2: Same as KACC22 = 1. This option used to enable exploiting
                        the 2-by-2 structure during matrix multiplications, but
                        this is no longer supported.

           <u>N</u>

                     N is INTEGER
                        N is the order of the Hessenberg matrix H upon which this
                        subroutine operates.

           <u>KTOP</u>

                     KTOP is INTEGER

           <u>KBOT</u>

                     KBOT is INTEGER
                        These are the first and last rows and columns of an
                        isolated diagonal block upon which the QR sweep is to be
                        applied. It is assumed without a check that
                                  either KTOP = 1  or   H(KTOP,KTOP-1) = 0
                        and
                                  either KBOT = N  or   H(KBOT+1,KBOT) = 0.

           <u>NSHFTS</u>

                     NSHFTS is INTEGER
                        NSHFTS gives the number of simultaneous shifts.  NSHFTS
                        must be positive and even.

           <u>SR</u>

                     SR is DOUBLE PRECISION array, dimension (NSHFTS)

           <u>SI</u>

                     SI is DOUBLE PRECISION array, dimension (NSHFTS)
                        SR contains the real parts and SI contains the imaginary
                        parts of the NSHFTS shifts of origin that define the
                        multi-shift QR sweep.  On output SR and SI may be
                        reordered.

           <u>H</u>

                     H is DOUBLE PRECISION array, dimension (LDH,N)
                        On input H contains a Hessenberg matrix.  On output a
                        multi-shift QR sweep with shifts SR(J)+i*SI(J) is applied
                        to the isolated diagonal block in rows and columns KTOP
                        through KBOT.

           <u>LDH</u>

                     LDH is INTEGER
                        LDH is the leading dimension of H just as declared in the
                        calling procedure.  LDH &gt;= MAX(1,N).

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                        Specify the rows of Z to which transformations must be
                        applied if WANTZ is .TRUE.. 1 &lt;= ILOZ &lt;= IHIZ &lt;= N

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (LDZ,IHIZ)
                        If WANTZ = .TRUE., then the QR Sweep orthogonal
                        similarity transformation is accumulated into
                        Z(ILOZ:IHIZ,ILOZ:IHIZ) from the right.
                        If WANTZ = .FALSE., then Z is unreferenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                        LDA is the leading dimension of Z just as declared in
                        the calling procedure. LDZ &gt;= N.

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension (LDV,NSHFTS/2)

           <u>LDV</u>

                     LDV is INTEGER
                        LDV is the leading dimension of V as declared in the
                        calling procedure.  LDV &gt;= 3.

           <u>U</u>

                     U is DOUBLE PRECISION array, dimension (LDU,2*NSHFTS)

           <u>LDU</u>

                     LDU is INTEGER
                        LDU is the leading dimension of U just as declared in the
                        in the calling subroutine.  LDU &gt;= 2*NSHFTS.

           <u>NV</u>

                     NV is INTEGER
                        NV is the number of rows in WV agailable for workspace.
                        NV &gt;= 1.

           <u>WV</u>

                     WV is DOUBLE PRECISION array, dimension (LDWV,2*NSHFTS)

           <u>LDWV</u>

                     LDWV is INTEGER
                        LDWV is the leading dimension of WV as declared in the
                        in the calling subroutine.  LDWV &gt;= NV.

           <u>NH</u>

                     NH is INTEGER
                        NH is the number of columns in array WH available for
                        workspace. NH &gt;= 1.

           <u>WH</u>

                     WH is DOUBLE PRECISION array, dimension (LDWH,NH)

           <u>LDWH</u>

                     LDWH is INTEGER
                        Leading dimension of WH just as declared in the
                        calling procedure.  LDWH &gt;= 2*NSHFTS.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

       Lars Karlsson, Daniel Kressner, and Bruno Lang

       Thijs Steel, Department of Computer science, KU Leuven, Belgium

       <b>References:</b>
           K. Braman, R. Byers and R. Mathias, The Multi-Shift QR Algorithm Part I: Maintaining Well Focused
           Shifts, and Level 3 Performance, SIAM Journal of Matrix Analysis, volume 23, pages 929--947, 2002.

       Lars Karlsson, Daniel Kressner, and Bruno Lang, Optimally packed chains of bulges in multishift QR
       algorithms. ACM Trans. Math. Softw. 40, 2, Article 12 (February 2014).

   <b>subroutine</b> <b>dlaqsb</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b>
       <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>double</b> <b>precision</b> <b>SCOND,</b> <b>double</b> <b>precision</b> <b>AMAX,</b> <b>character</b> <b>EQUED)</b>

       <b>DLAQSB</b> scales a symmetric/Hermitian band matrix, using scaling factors computed by spbequ.

       <b>Purpose:</b>

            DLAQSB equilibrates a symmetric band matrix A using the scaling
            factors in the vector S.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix A is stored.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of super-diagonals of the matrix A if UPLO = 'U',
                     or the number of sub-diagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                     On entry, the upper or lower triangle of the symmetric band
                     matrix A, stored in the first KD+1 rows of the array.  The
                     j-th column of A is stored in the j-th column of the array AB
                     as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).

                     On exit, if INFO = 0, the triangular factor U or L from the
                     Cholesky factorization A = U**T*U or A = L*L**T of the band
                     matrix A, in the same storage format as A.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension (N)
                     The scale factors for A.

           <u>SCOND</u>

                     SCOND is DOUBLE PRECISION
                     Ratio of the smallest S(i) to the largest S(i).

           <u>AMAX</u>

                     AMAX is DOUBLE PRECISION
                     Absolute value of largest matrix entry.

           <u>EQUED</u>

                     EQUED is CHARACTER*1
                     Specifies whether or not equilibration was done.
                     = 'N':  No equilibration.
                     = 'Y':  Equilibration was done, i.e., A has been replaced by
                             diag(S) * A * diag(S).

       <b>Internal</b> <b>Parameters:</b>

             THRESH is a threshold value used to decide if scaling should be done
             based on the ratio of the scaling factors.  If SCOND &lt; THRESH,
             scaling is done.

             LARGE and SMALL are threshold values used to decide if scaling should
             be done based on the absolute size of the largest matrix element.
             If AMAX &gt; LARGE or AMAX &lt; SMALL, scaling is done.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlaqsp</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>double</b> <b>precision</b> <b>SCOND,</b> <b>double</b> <b>precision</b> <b>AMAX,</b> <b>character</b> <b>EQUED)</b>
       <b>DLAQSP</b> scales a symmetric/Hermitian matrix in packed storage, using scaling factors computed by sppequ.

       <b>Purpose:</b>

            DLAQSP equilibrates a symmetric matrix A using the scaling factors
            in the vector S.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix A is stored.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)
                     On entry, the upper or lower triangle of the symmetric matrix
                     A, packed columnwise in a linear array.  The j-th column of A
                     is stored in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

                     On exit, the equilibrated matrix:  diag(S) * A * diag(S), in
                     the same storage format as A.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension (N)
                     The scale factors for A.

           <u>SCOND</u>

                     SCOND is DOUBLE PRECISION
                     Ratio of the smallest S(i) to the largest S(i).

           <u>AMAX</u>

                     AMAX is DOUBLE PRECISION
                     Absolute value of largest matrix entry.

           <u>EQUED</u>

                     EQUED is CHARACTER*1
                     Specifies whether or not equilibration was done.
                     = 'N':  No equilibration.
                     = 'Y':  Equilibration was done, i.e., A has been replaced by
                             diag(S) * A * diag(S).

       <b>Internal</b> <b>Parameters:</b>

             THRESH is a threshold value used to decide if scaling should be done
             based on the ratio of the scaling factors.  If SCOND &lt; THRESH,
             scaling is done.

             LARGE and SMALL are threshold values used to decide if scaling should
             be done based on the absolute size of the largest matrix element.
             If AMAX &gt; LARGE or AMAX &lt; SMALL, scaling is done.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlaqtr</b> <b>(logical</b> <b>LTRAN,</b> <b>logical</b> <b>LREAL,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b>
       <b>LDT,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>B,</b> <b>double</b> <b>precision</b> <b>W,</b> <b>double</b> <b>precision</b> <b>SCALE,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAQTR</b> solves a real quasi-triangular system of equations, or a complex quasi-triangular system of
       special form, in real arithmetic.

       <b>Purpose:</b>

            DLAQTR solves the real quasi-triangular system

                         op(T)*p = scale*c,               if LREAL = .TRUE.

            or the complex quasi-triangular systems

                       op(T + iB)*(p+iq) = scale*(c+id),  if LREAL = .FALSE.

            in real arithmetic, where T is upper quasi-triangular.
            If LREAL = .FALSE., then the first diagonal block of T must be
            1 by 1, B is the specially structured matrix

                           B = [ <a href="../man1/b.1.html">b</a>(1) <a href="../man2/b.2.html">b</a>(2) ... b(n) ]
                               [       w            ]
                               [           w        ]
                               [              .     ]
                               [                 w  ]

            op(A) = A or A**T, A**T denotes the transpose of
            matrix A.

            On input, X = [ c ].  On output, X = [ p ].
                          [ d ]                  [ q ]

            This subroutine is designed for the condition number estimation
            in routine DTRSNA.

       <b>Parameters</b>
           <u>LTRAN</u>

                     LTRAN is LOGICAL
                     On entry, LTRAN specifies the option of conjugate transpose:
                        = .FALSE.,    op(T+i*B) = T+i*B,
                        = .TRUE.,     op(T+i*B) = (T+i*B)**T.

           <u>LREAL</u>

                     LREAL is LOGICAL
                     On entry, LREAL specifies the input matrix structure:
                        = .FALSE.,    the input is complex
                        = .TRUE.,     the input is real

           <u>N</u>

                     N is INTEGER
                     On entry, N specifies the order of T+i*B. N &gt;= 0.

           <u>T</u>

                     T is DOUBLE PRECISION array, dimension (LDT,N)
                     On entry, T contains a matrix in Schur canonical form.
                     If LREAL = .FALSE., then the first diagonal block of T mu
                     be 1 by 1.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the matrix T. LDT &gt;= max(1,N).

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (N)
                     On entry, B contains the elements to form the matrix
                     B as described above.
                     If LREAL = .TRUE., B is not referenced.

           <u>W</u>

                     W is DOUBLE PRECISION
                     On entry, W is the diagonal element of the matrix B.
                     If LREAL = .TRUE., W is not referenced.

           <u>SCALE</u>

                     SCALE is DOUBLE PRECISION
                     On exit, SCALE is the scale factor.

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (2*N)
                     On entry, X contains the right hand side of the system.
                     On exit, X is overwritten by the solution.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     On exit, INFO is set to
                        0: successful exit.
                          1: the some diagonal 1 by 1 block has been perturbed by
                             a small number SMIN to keep nonsingularity.
                          2: the some diagonal 2 by 2 block has been perturbed by
                             a small number in DLALN2 to keep nonsingularity.
                     NOTE: In the interests of speed, this routine does not
                           check the inputs for errors.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlar1v</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>B1,</b> <b>integer</b> <b>BN,</b> <b>double</b> <b>precision</b> <b>LAMBDA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>L,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>LD,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>LLD,</b> <b>double</b> <b>precision</b> <b>PIVMIN,</b> <b>double</b> <b>precision</b> <b>GAPTOL,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b>
       <b>logical</b> <b>WANTNC,</b> <b>integer</b> <b>NEGCNT,</b> <b>double</b> <b>precision</b> <b>ZTZ,</b> <b>double</b> <b>precision</b> <b>MINGMA,</b> <b>integer</b> <b>R,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>ISUPPZ,</b> <b>double</b> <b>precision</b> <b>NRMINV,</b> <b>double</b> <b>precision</b> <b>RESID,</b> <b>double</b> <b>precision</b> <b>RQCORR,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>DLAR1V</b> computes the (scaled) r-th column of the inverse of the submatrix in rows b1 through bn of the
       tridiagonal matrix LDLT - λI.

       <b>Purpose:</b>

            DLAR1V computes the (scaled) r-th column of the inverse of
            the sumbmatrix in rows B1 through BN of the tridiagonal matrix
            L D L**T - sigma I. When sigma is close to an eigenvalue, the
            computed vector is an accurate eigenvector. Usually, r corresponds
            to the index where the eigenvector is largest in magnitude.
            The following steps accomplish this computation :
            (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
            (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
            (c) Computation of the diagonal elements of the inverse of
                L D L**T - sigma I by combining the above transforms, and choosing
                r as the index where the diagonal of the inverse is (one of the)
                largest in magnitude.
            (d) Computation of the (scaled) r-th column of the inverse using the
                twisted factorization obtained by combining the top part of the
                the stationary and the bottom part of the progressive transform.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                      The order of the matrix L D L**T.

           <u>B1</u>

                     B1 is INTEGER
                      First index of the submatrix of L D L**T.

           <u>BN</u>

                     BN is INTEGER
                      Last index of the submatrix of L D L**T.

           <u>LAMBDA</u>

                     LAMBDA is DOUBLE PRECISION
                      The shift. In order to compute an accurate eigenvector,
                      LAMBDA should be a good approximation to an eigenvalue
                      of L D L**T.

           <u>L</u>

                     L is DOUBLE PRECISION array, dimension (N-1)
                      The (n-1) subdiagonal elements of the unit bidiagonal matrix
                      L, in elements 1 to N-1.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                      The n diagonal elements of the diagonal matrix D.

           <u>LD</u>

                     LD is DOUBLE PRECISION array, dimension (N-1)
                      The n-1 elements L(i)*D(i).

           <u>LLD</u>

                     LLD is DOUBLE PRECISION array, dimension (N-1)
                      The n-1 elements L(i)*L(i)*D(i).

           <u>PIVMIN</u>

                     PIVMIN is DOUBLE PRECISION
                      The minimum pivot in the Sturm sequence.

           <u>GAPTOL</u>

                     GAPTOL is DOUBLE PRECISION
                      Tolerance that indicates when eigenvector entries are negligible
                      w.r.t. their contribution to the residual.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (N)
                      On input, all entries of Z must be set to 0.
                      On output, Z contains the (scaled) r-th column of the
                      inverse. The scaling is such that Z(R) equals 1.

           <u>WANTNC</u>

                     WANTNC is LOGICAL
                      Specifies whether NEGCNT has to be computed.

           <u>NEGCNT</u>

                     NEGCNT is INTEGER
                      If WANTNC is .TRUE. then NEGCNT = the number of pivots &lt; pivmin
                      in the  matrix factorization L D L**T, and NEGCNT = -1 otherwise.

           <u>ZTZ</u>

                     ZTZ is DOUBLE PRECISION
                      The square of the 2-norm of Z.

           <u>MINGMA</u>

                     MINGMA is DOUBLE PRECISION
                      The reciprocal of the largest (in magnitude) diagonal
                      element of the inverse of L D L**T - sigma I.

           <u>R</u>

                     R is INTEGER
                      The twist index for the twisted factorization used to
                      compute Z.
                      On input, 0 &lt;= R &lt;= N. If R is input as 0, R is set to
                      the index where (L D L**T - sigma I)^{-1} is largest
                      in magnitude. If 1 &lt;= R &lt;= N, R is unchanged.
                      On output, R contains the twist index used to compute Z.
                      Ideally, R designates the position of the maximum entry in the
                      eigenvector.

           <u>ISUPPZ</u>

                     ISUPPZ is INTEGER array, dimension (2)
                      The support of the vector in Z, i.e., the vector Z is
                      nonzero only in elements <a href="../man1/ISUPPZ.1.html">ISUPPZ</a>(1) through ISUPPZ( 2 ).

           <u>NRMINV</u>

                     NRMINV is DOUBLE PRECISION
                      NRMINV = 1/SQRT( ZTZ )

           <u>RESID</u>

                     RESID is DOUBLE PRECISION
                      The residual of the FP vector.
                      RESID = ABS( MINGMA )/SQRT( ZTZ )

           <u>RQCORR</u>

                     RQCORR is DOUBLE PRECISION
                      The Rayleigh Quotient correction to LAMBDA.
                      RQCORR = MINGMA*TMP

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (4*N)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Beresford Parlett, University of California, Berkeley, USA
            Jim Demmel, University of California, Berkeley, USA
            Inderjit Dhillon, University of Texas, Austin, USA
            Osni Marques, LBNL/NERSC, USA
            Christof Voemel, University of California, Berkeley, USA

   <b>subroutine</b> <b>dlar2v</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Y,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>INCX,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>integer</b> <b>INCC)</b>
       <b>DLAR2V</b> applies a vector of plane rotations with real cosines and real sines from both sides to a sequence
       of 2-by-2 symmetric/Hermitian matrices.

       <b>Purpose:</b>

            DLAR2V applies a vector of real plane rotations from both sides to
            a sequence of 2-by-2 real symmetric matrices, defined by the elements
            of the vectors x, y and z. For i = 1,2,...,n

               ( x(i)  z(i) ) := (  c(i)  s(i) ) ( x(i)  z(i) ) ( c(i) -s(i) )
               ( z(i)  y(i) )    ( -s(i)  c(i) ) ( z(i)  y(i) ) ( s(i)  c(i) )

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of plane rotations to be applied.

           <u>X</u>

                     X is DOUBLE PRECISION array,
                                    dimension (1+(N-1)*INCX)
                     The vector x.

           <u>Y</u>

                     Y is DOUBLE PRECISION array,
                                    dimension (1+(N-1)*INCX)
                     The vector y.

           <u>Z</u>

                     Z is DOUBLE PRECISION array,
                                    dimension (1+(N-1)*INCX)
                     The vector z.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X, Y and Z. INCX &gt; 0.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
                     The cosines of the plane rotations.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
                     The sines of the plane rotations.

           <u>INCC</u>

                     INCC is INTEGER
                     The increment between elements of C and S. INCC &gt; 0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlarf</b> <b>(character</b> <b>SIDE,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>INCV,</b>
       <b>double</b> <b>precision</b> <b>TAU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>WORK)</b>
       <b>DLARF</b> applies an elementary reflector to a general rectangular matrix.

       <b>Purpose:</b>

            DLARF applies a real elementary reflector H to a real m by n matrix
            C, from either the left or the right. H is represented in the form

                  H = I - tau * v * v**T

            where tau is a real scalar and v is a real vector.

            If tau = 0, then H is taken to be the unit matrix.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': form  H * C
                     = 'R': form  C * H

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C.

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension
                                (1 + (M-1)*abs(INCV)) if SIDE = 'L'
                             or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
                     The vector v in the representation of H. V is not used if
                     TAU = 0.

           <u>INCV</u>

                     INCV is INTEGER
                     The increment between elements of v. INCV &lt;&gt; 0.

           <u>TAU</u>

                     TAU is DOUBLE PRECISION
                     The value tau in the representation of H.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC,N)
                     On entry, the m by n matrix C.
                     On exit, C is overwritten by the matrix H * C if SIDE = 'L',
                     or C * H if SIDE = 'R'.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension
                                    (N) if SIDE = 'L'
                                 or (M) if SIDE = 'R'

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlarfb</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIRECT,</b> <b>character</b> <b>STOREV,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b>
       <b>integer</b> <b>K,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b>
       <b>integer</b> <b>LDT,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldwork,</b> <b>*</b>
       <b>)</b> <b>WORK,</b> <b>integer</b> <b>LDWORK)</b>
       <b>DLARFB</b> applies a block reflector or its transpose to a general rectangular matrix.

       <b>Purpose:</b>

            DLARFB applies a real block reflector H or its transpose H**T to a
            real m by n matrix C, from either the left or the right.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply H or H**T from the Left
                     = 'R': apply H or H**T from the Right

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply H (No transpose)
                     = 'T': apply H**T (Transpose)

           <u>DIRECT</u>

                     DIRECT is CHARACTER*1
                     Indicates how H is formed from a product of elementary
                     reflectors
                     = 'F': H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) (Forward)
                     = 'B': H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) (Backward)

           <u>STOREV</u>

                     STOREV is CHARACTER*1
                     Indicates how the vectors which define the elementary
                     reflectors are stored:
                     = 'C': Columnwise
                     = 'R': Rowwise

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C.

           <u>K</u>

                     K is INTEGER
                     The order of the matrix T (= the number of elementary
                     reflectors whose product defines the block reflector).
                     If SIDE = 'L', M &gt;= K &gt;= 0;
                     if SIDE = 'R', N &gt;= K &gt;= 0.

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension
                                           (LDV,K) if STOREV = 'C'
                                           (LDV,M) if STOREV = 'R' and SIDE = 'L'
                                           (LDV,N) if STOREV = 'R' and SIDE = 'R'
                     The matrix V. See Further Details.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V.
                     If STOREV = 'C' and SIDE = 'L', LDV &gt;= max(1,M);
                     if STOREV = 'C' and SIDE = 'R', LDV &gt;= max(1,N);
                     if STOREV = 'R', LDV &gt;= K.

           <u>T</u>

                     T is DOUBLE PRECISION array, dimension (LDT,K)
                     The triangular k by k matrix T in the representation of the
                     block reflector.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= K.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC,N)
                     On entry, the m by n matrix C.
                     On exit, C is overwritten by H*C or H**T*C or C*H or C*H**T.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (LDWORK,K)

           <u>LDWORK</u>

                     LDWORK is INTEGER
                     The leading dimension of the array WORK.
                     If SIDE = 'L', LDWORK &gt;= max(1,N);
                     if SIDE = 'R', LDWORK &gt;= max(1,M).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The shape of the matrix V and the storage of the vectors which define
             the H(i) is best illustrated by the following example with n = 5 and
             k = 3. The elements equal to 1 are not stored; the corresponding
             array elements are modified but restored on exit. The rest of the
             array is not used.

             DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':

                          V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                              ( v1  1    )                     (     1 v2 v2 v2 )
                              ( v1 v2  1 )                     (        1 v3 v3 )
                              ( v1 v2 v3 )
                              ( v1 v2 v3 )

             DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':

                          V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                              ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                              (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                              (     1 v3 )
                              (        1 )

   <b>subroutine</b> <b>dlarfb_gett</b> <b>(character</b> <b>IDENT,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b>
       <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldb,</b>
       <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldwork,</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LDWORK)</b>
       <b>DLARFB_GETT</b>

       <b>Purpose:</b>

            DLARFB_GETT applies a real Householder block reflector H from the
            left to a real (K+M)-by-N  "triangular-pentagonal" matrix
            composed of two block matrices: an upper trapezoidal K-by-N matrix A
            stored in the array A, and a rectangular M-by-(N-K) matrix B, stored
            in the array B. The block reflector H is stored in a compact
            WY-representation, where the elementary reflectors are in the
            arrays A, B and T. See Further Details section.

       <b>Parameters</b>
           <u>IDENT</u>

                     IDENT is CHARACTER*1
                     If IDENT = not 'I', or not 'i', then V1 is unit
                        lower-triangular and stored in the left K-by-K block of
                        the input matrix A,
                     If IDENT = 'I' or 'i', then  V1 is an identity matrix and
                        not stored.
                     See Further Details section.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix B.
                     M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrices A and B.
                     N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number or rows of the matrix A.
                     K is also order of the matrix T, i.e. the number of
                     elementary reflectors whose product defines the block
                     reflector. 0 &lt;= K &lt;= N.

           <u>T</u>

                     T is DOUBLE PRECISION array, dimension (LDT,K)
                     The upper-triangular K-by-K matrix T in the representation
                     of the block reflector.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= K.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)

                     On entry:
                      a) In the K-by-N upper-trapezoidal part A: input matrix A.
                      b) In the columns below the diagonal: columns of V1
                         (ones are not stored on the diagonal).

                     On exit:
                       A is overwritten by rectangular K-by-N product H*A.

                     See Further Details section.

           <u>LDA</u>

                     LDB is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,K).

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB,N)

                     On entry:
                       a) In the M-by-(N-K) right block: input matrix B.
                       b) In the M-by-N left block: columns of V2.

                     On exit:
                       B is overwritten by rectangular M-by-N product H*B.

                     See Further Details section.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,M).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array,
                     dimension (LDWORK,max(K,N-K))

           <u>LDWORK</u>

                     LDWORK is INTEGER
                     The leading dimension of the array WORK. LDWORK&gt;=max(1,K).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>

            November 2020, Igor Kozachenko,
                           Computer Science Division,
                           University of California, Berkeley

       <b>Further</b> <b>Details:</b>

               (1) Description of the Algebraic Operation.

               The matrix A is a K-by-N matrix composed of two column block
               matrices, A1, which is K-by-K, and A2, which is K-by-(N-K):
               A = ( A1, A2 ).
               The matrix B is an M-by-N matrix composed of two column block
               matrices, B1, which is M-by-K, and B2, which is M-by-(N-K):
               B = ( B1, B2 ).

               Perform the operation:

                  ( A_out ) := H * ( A_in ) = ( I - V * T * V**T ) * ( A_in ) =
                  ( B_out )        ( B_in )                          ( B_in )
                             = ( I - ( V1 ) * T * ( V1**T, V2**T ) ) * ( A_in )
                                     ( V2 )                            ( B_in )
                On input:

               a) ( A_in )  consists of two block columns:
                  ( B_in )

                  ( A_in ) = (( A1_in ) ( A2_in )) = (( A1_in ) ( A2_in ))
                  ( B_in )   (( B1_in ) ( B2_in ))   ((     0 ) ( B2_in )),

                  where the column blocks are:

                  (  A1_in )  is a K-by-K upper-triangular matrix stored in the
                              upper triangular part of the array A(1:K,1:K).
                  (  B1_in )  is an M-by-K rectangular ZERO matrix and not stored.

                  ( A2_in )  is a K-by-(N-K) rectangular matrix stored
                             in the array A(1:K,K+1:N).
                  ( B2_in )  is an M-by-(N-K) rectangular matrix stored
                             in the array B(1:M,K+1:N).

               b) V = ( V1 )
                      ( V2 )

                  where:
                  1) if IDENT == 'I',V1 is a K-by-K identity matrix, not stored;
                  2) if IDENT != 'I',V1 is a K-by-K unit lower-triangular matrix,
                     stored in the lower-triangular part of the array
                     A(1:K,1:K) (ones are not stored),
                  and V2 is an M-by-K rectangular stored the array B(1:M,1:K),
                            (because on input B1_in is a rectangular zero
                             matrix that is not stored and the space is
                             used to store V2).

               c) T is a K-by-K upper-triangular matrix stored
                  in the array T(1:K,1:K).

               On output:

               a) ( A_out ) consists of two  block columns:
                  ( B_out )

                  ( A_out ) = (( A1_out ) ( A2_out ))
                  ( B_out )   (( B1_out ) ( B2_out )),

                  where the column blocks are:

                  ( A1_out )  is a K-by-K square matrix, or a K-by-K
                              upper-triangular matrix, if V1 is an
                              identity matrix. AiOut is stored in
                              the array A(1:K,1:K).
                  ( B1_out )  is an M-by-K rectangular matrix stored
                              in the array B(1:M,K:N).

                  ( A2_out )  is a K-by-(N-K) rectangular matrix stored
                              in the array A(1:K,K+1:N).
                  ( B2_out )  is an M-by-(N-K) rectangular matrix stored
                              in the array B(1:M,K+1:N).

               The operation above can be represented as the same operation
               on each block column:

                  ( A1_out ) := H * ( A1_in ) = ( I - V * T * V**T ) * ( A1_in )
                  ( B1_out )        (     0 )                          (     0 )

                  ( A2_out ) := H * ( A2_in ) = ( I - V * T * V**T ) * ( A2_in )
                  ( B2_out )        ( B2_in )                          ( B2_in )

               If IDENT != 'I':

                  The computation for column block 1:

                  A1_out: = A1_in - V1*T*(V1**T)*A1_in

                  B1_out: = - V2*T*(V1**T)*A1_in

                  The computation for column block 2, which exists if N &gt; K:

                  A2_out: = A2_in - V1*T*( (V1**T)*A2_in + (V2**T)*B2_in )

                  B2_out: = B2_in - V2*T*( (V1**T)*A2_in + (V2**T)*B2_in )

               If IDENT == 'I':

                  The operation for column block 1:

                  A1_out: = A1_in - V1*T**A1_in

                  B1_out: = - V2*T**A1_in

                  The computation for column block 2, which exists if N &gt; K:

                  A2_out: = A2_in - T*( A2_in + (V2**T)*B2_in )

                  B2_out: = B2_in - V2*T*( A2_in + (V2**T)*B2_in )

               (2) Description of the Algorithmic Computation.

               In the first step, we compute column block 2, i.e. A2 and B2.
               Here, we need to use the K-by-(N-K) rectangular workspace
               matrix W2 that is of the same size as the matrix A2.
               W2 is stored in the array WORK(1:K,1:(N-K)).

               In the second step, we compute column block 1, i.e. A1 and B1.
               Here, we need to use the K-by-K square workspace matrix W1
               that is of the same size as the as the matrix A1.
               W1 is stored in the array WORK(1:K,1:K).

               NOTE: Hence, in this routine, we need the workspace array WORK
               only of size WORK(1:K,1:max(K,N-K)) so it can hold both W2 from
               the first step and W1 from the second step.

               Case (A), when V1 is unit lower-triangular, i.e. IDENT != 'I',
               more computations than in the Case (B).

               if( IDENT != 'I' ) then
                if ( N &gt; K ) then
                  (First Step - column block 2)
                  <a href="../man1/col2_.1.html">col2_</a>(1) W2: = A2
                  <a href="../man2/col2_.2.html">col2_</a>(2) W2: = (V1**T) * W2 = (unit_lower_tr_of_(A1)**T) * W2
                  <a href="../man3/col2_.3.html">col2_</a>(3) W2: = W2 + (V2**T) * B2 = W2 + (B1**T) * B2
                  <a href="../man4/col2_.4.html">col2_</a>(4) W2: = T * W2
                  <a href="../man5/col2_.5.html">col2_</a>(5) B2: = B2 - V2 * W2 = B2 - B1 * W2
                  <a href="../man6/col2_.6.html">col2_</a>(6) W2: = V1 * W2 = unit_lower_tr_of_(A1) * W2
                  <a href="../man7/col2_.7.html">col2_</a>(7) A2: = A2 - W2
                else
                  (Second Step - column block 1)
                  <a href="../man1/col1_.1.html">col1_</a>(1) W1: = A1
                  <a href="../man2/col1_.2.html">col1_</a>(2) W1: = (V1**T) * W1 = (unit_lower_tr_of_(A1)**T) * W1
                  <a href="../man3/col1_.3.html">col1_</a>(3) W1: = T * W1
                  <a href="../man4/col1_.4.html">col1_</a>(4) B1: = - V2 * W1 = - B1 * W1
                  <a href="../man5/col1_.5.html">col1_</a>(5) square W1: = V1 * W1 = unit_lower_tr_of_(A1) * W1
                  <a href="../man6/col1_.6.html">col1_</a>(6) square A1: = A1 - W1
                end if
               end if

               Case (B), when V1 is an identity matrix, i.e. IDENT == 'I',
               less computations than in the Case (A)

               if( IDENT == 'I' ) then
                if ( N &gt; K ) then
                  (First Step - column block 2)
                  <a href="../man1/col2_.1.html">col2_</a>(1) W2: = A2
                  <a href="../man3/col2_.3.html">col2_</a>(3) W2: = W2 + (V2**T) * B2 = W2 + (B1**T) * B2
                  <a href="../man4/col2_.4.html">col2_</a>(4) W2: = T * W2
                  <a href="../man5/col2_.5.html">col2_</a>(5) B2: = B2 - V2 * W2 = B2 - B1 * W2
                  <a href="../man7/col2_.7.html">col2_</a>(7) A2: = A2 - W2
                else
                  (Second Step - column block 1)
                  <a href="../man1/col1_.1.html">col1_</a>(1) W1: = A1
                  <a href="../man3/col1_.3.html">col1_</a>(3) W1: = T * W1
                  <a href="../man4/col1_.4.html">col1_</a>(4) B1: = - V2 * W1 = - B1 * W1
                  <a href="../man6/col1_.6.html">col1_</a>(6) upper-triangular_of_(A1): = A1 - W1
                end if
               end if

               Combine these cases (A) and (B) together, this is the resulting
               algorithm:

               if ( N &gt; K ) then

                 (First Step - column block 2)

                 <a href="../man1/col2_.1.html">col2_</a>(1)  W2: = A2
                 if( IDENT != 'I' ) then
                   <a href="../man2/col2_.2.html">col2_</a>(2)  W2: = (V1**T) * W2
                                 = (unit_lower_tr_of_(A1)**T) * W2
                 end if
                 <a href="../man3/col2_.3.html">col2_</a>(3)  W2: = W2 + (V2**T) * B2 = W2 + (B1**T) * B2]
                 <a href="../man4/col2_.4.html">col2_</a>(4)  W2: = T * W2
                 <a href="../man5/col2_.5.html">col2_</a>(5)  B2: = B2 - V2 * W2 = B2 - B1 * W2
                 if( IDENT != 'I' ) then
                   <a href="../man6/col2_.6.html">col2_</a>(6)    W2: = V1 * W2 = unit_lower_tr_of_(A1) * W2
                 end if
                 <a href="../man7/col2_.7.html">col2_</a>(7) A2: = A2 - W2

               else

               (Second Step - column block 1)

                 <a href="../man1/col1_.1.html">col1_</a>(1) W1: = A1
                 if( IDENT != 'I' ) then
                   <a href="../man2/col1_.2.html">col1_</a>(2) W1: = (V1**T) * W1
                               = (unit_lower_tr_of_(A1)**T) * W1
                 end if
                 <a href="../man3/col1_.3.html">col1_</a>(3) W1: = T * W1
                 <a href="../man4/col1_.4.html">col1_</a>(4) B1: = - V2 * W1 = - B1 * W1
                 if( IDENT != 'I' ) then
                   <a href="../man5/col1_.5.html">col1_</a>(5) square W1: = V1 * W1 = unit_lower_tr_of_(A1) * W1
                   <a href="../man6_a/col1_.6_a.html">col1_</a>(6_a) below_diag_of_(A1): =  - below_diag_of_(W1)
                 end if
                 <a href="../man6_b/col1_.6_b.html">col1_</a>(6_b) up_tr_of_(A1): = up_tr_of_(A1) - up_tr_of_(W1)

               end if

   <b>subroutine</b> <b>dlarfg</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision</b> <b>ALPHA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b>
       <b>double</b> <b>precision</b> <b>TAU)</b>
       <b>DLARFG</b> generates an elementary reflector (Householder matrix).

       <b>Purpose:</b>

            DLARFG generates a real elementary reflector H of order n, such
            that

                  H * ( alpha ) = ( beta ),   H**T * H = I.
                      (   x   )   (   0  )

            where alpha and beta are scalars, and x is an (n-1)-element real
            vector. H is represented in the form

                  H = I - tau * ( 1 ) * ( 1 v**T ) ,
                                ( v )

            where tau is a real scalar and v is a real (n-1)-element
            vector.

            If the elements of x are all zero, then tau = 0 and H is taken to be
            the unit matrix.

            Otherwise  1 &lt;= tau &lt;= 2.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the elementary reflector.

           <u>ALPHA</u>

                     ALPHA is DOUBLE PRECISION
                     On entry, the value alpha.
                     On exit, it is overwritten with the value beta.

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension
                                    (1+(N-2)*abs(INCX))
                     On entry, the vector x.
                     On exit, it is overwritten with the vector v.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X. INCX &gt; 0.

           <u>TAU</u>

                     TAU is DOUBLE PRECISION
                     The value tau.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlarfgp</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision</b> <b>ALPHA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b>
       <b>double</b> <b>precision</b> <b>TAU)</b>
       <b>DLARFGP</b> generates an elementary reflector (Householder matrix) with non-negative beta.

       <b>Purpose:</b>

            DLARFGP generates a real elementary reflector H of order n, such
            that

                  H * ( alpha ) = ( beta ),   H**T * H = I.
                      (   x   )   (   0  )

            where alpha and beta are scalars, beta is non-negative, and x is
            an (n-1)-element real vector.  H is represented in the form

                  H = I - tau * ( 1 ) * ( 1 v**T ) ,
                                ( v )

            where tau is a real scalar and v is a real (n-1)-element
            vector.

            If the elements of x are all zero, then tau = 0 and H is taken to be
            the unit matrix.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the elementary reflector.

           <u>ALPHA</u>

                     ALPHA is DOUBLE PRECISION
                     On entry, the value alpha.
                     On exit, it is overwritten with the value beta.

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension
                                    (1+(N-2)*abs(INCX))
                     On entry, the vector x.
                     On exit, it is overwritten with the vector v.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X. INCX &gt; 0.

           <u>TAU</u>

                     TAU is DOUBLE PRECISION
                     The value tau.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlarft</b> <b>(character</b> <b>DIRECT,</b> <b>character</b> <b>STOREV,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b>
       <b>integer</b> <b>LDT)</b>
       <b>DLARFT</b> forms the triangular factor T of a block reflector H = I - vtvH

       <b>Purpose:</b>

            DLARFT forms the triangular factor T of a real block reflector H
            of order n, which is defined as a product of k elementary reflectors.

            If DIRECT = 'F', H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) and T is upper triangular;

            If DIRECT = 'B', H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) and T is lower triangular.

            If STOREV = 'C', the vector which defines the elementary reflector
            H(i) is stored in the i-th column of the array V, and

               H  =  I - V * T * V**T

            If STOREV = 'R', the vector which defines the elementary reflector
            H(i) is stored in the i-th row of the array V, and

               H  =  I - V**T * T * V

       <b>Parameters</b>
           <u>DIRECT</u>

                     DIRECT is CHARACTER*1
                     Specifies the order in which the elementary reflectors are
                     multiplied to form the block reflector:
                     = 'F': H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) (Forward)
                     = 'B': H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) (Backward)

           <u>STOREV</u>

                     STOREV is CHARACTER*1
                     Specifies how the vectors which define the elementary
                     reflectors are stored (see also Further Details):
                     = 'C': columnwise
                     = 'R': rowwise

           <u>N</u>

                     N is INTEGER
                     The order of the block reflector H. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The order of the triangular factor T (= the number of
                     elementary reflectors). K &gt;= 1.

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension
                                          (LDV,K) if STOREV = 'C'
                                          (LDV,N) if STOREV = 'R'
                     The matrix V. See further details.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V.
                     If STOREV = 'C', LDV &gt;= max(1,N); if STOREV = 'R', LDV &gt;= K.

           <u>TAU</u>

                     TAU is DOUBLE PRECISION array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i).

           <u>T</u>

                     T is DOUBLE PRECISION array, dimension (LDT,K)
                     The k by k triangular factor T of the block reflector.
                     If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
                     lower triangular. The rest of the array is not used.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= K.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The shape of the matrix V and the storage of the vectors which define
             the H(i) is best illustrated by the following example with n = 5 and
             k = 3. The elements equal to 1 are not stored.

             DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':

                          V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                              ( v1  1    )                     (     1 v2 v2 v2 )
                              ( v1 v2  1 )                     (        1 v3 v3 )
                              ( v1 v2 v3 )
                              ( v1 v2 v3 )

             DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':

                          V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                              ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                              (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                              (     1 v3 )
                              (        1 )

   <b>subroutine</b> <b>dlarfx</b> <b>(character</b> <b>SIDE,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>double</b> <b>precision</b>
       <b>TAU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>DLARFX</b> applies an elementary reflector to a general rectangular matrix, with loop unrolling when the
       reflector has order ≤ 10.

       <b>Purpose:</b>

            DLARFX applies a real elementary reflector H to a real m by n
            matrix C, from either the left or the right. H is represented in the
            form

                  H = I - tau * v * v**T

            where tau is a real scalar and v is a real vector.

            If tau = 0, then H is taken to be the unit matrix

            This version uses inline code if H has order &lt; 11.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': form  H * C
                     = 'R': form  C * H

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C.

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension (M) if SIDE = 'L'
                                                or (N) if SIDE = 'R'
                     The vector v in the representation of H.

           <u>TAU</u>

                     TAU is DOUBLE PRECISION
                     The value tau in the representation of H.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC,N)
                     On entry, the m by n matrix C.
                     On exit, C is overwritten by the matrix H * C if SIDE = 'L',
                     or C * H if SIDE = 'R'.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= (1,M).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension
                                 (N) if SIDE = 'L'
                                 or (M) if SIDE = 'R'
                     WORK is not referenced if H has order &lt; 11.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlarfy</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>INCV,</b> <b>double</b>
       <b>precision</b> <b>TAU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>WORK)</b>
       <b>DLARFY</b>

       <b>Purpose:</b>

            DLARFY applies an elementary reflector, or Householder matrix, H,
            to an n x n symmetric matrix C, from both the left and the right.

            H is represented in the form

               H = I - tau * v * v'

            where  tau  is a scalar and  v  is a vector.

            If  tau  is  zero, then  H  is taken to be the unit matrix.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix C is stored.
                     = 'U':  Upper triangle
                     = 'L':  Lower triangle

           <u>N</u>

                     N is INTEGER
                     The number of rows and columns of the matrix C.  N &gt;= 0.

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension
                             (1 + (N-1)*abs(INCV))
                     The vector v as described above.

           <u>INCV</u>

                     INCV is INTEGER
                     The increment between successive elements of v.  INCV must
                     not be zero.

           <u>TAU</u>

                     TAU is DOUBLE PRECISION
                     The value tau as described above.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC, N)
                     On entry, the matrix C.
                     On exit, C is overwritten by H * C * H'.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C.  LDC &gt;= max( 1, N ).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (N)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlargv</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>Y,</b> <b>integer</b> <b>INCY,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>INCC)</b>
       <b>DLARGV</b> generates a vector of plane rotations with real cosines and real sines.

       <b>Purpose:</b>

            DLARGV generates a vector of real plane rotations, determined by
            elements of the real vectors x and y. For i = 1,2,...,n

               (  c(i)  s(i) ) ( x(i) ) = ( a(i) )
               ( -s(i)  c(i) ) ( y(i) ) = (   0  )

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of plane rotations to be generated.

           <u>X</u>

                     X is DOUBLE PRECISION array,
                                    dimension (1+(N-1)*INCX)
                     On entry, the vector x.
                     On exit, x(i) is overwritten by a(i), for i = 1,...,n.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X. INCX &gt; 0.

           <u>Y</u>

                     Y is DOUBLE PRECISION array,
                                    dimension (1+(N-1)*INCY)
                     On entry, the vector y.
                     On exit, the sines of the plane rotations.

           <u>INCY</u>

                     INCY is INTEGER
                     The increment between elements of Y. INCY &gt; 0.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
                     The cosines of the plane rotations.

           <u>INCC</u>

                     INCC is INTEGER
                     The increment between elements of C. INCC &gt; 0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlarrv</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision</b> <b>VL,</b> <b>double</b> <b>precision</b> <b>VU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>L,</b> <b>double</b> <b>precision</b> <b>PIVMIN,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISPLIT,</b> <b>integer</b> <b>M,</b>
       <b>integer</b> <b>DOL,</b> <b>integer</b> <b>DOU,</b> <b>double</b> <b>precision</b> <b>MINRGP,</b> <b>double</b> <b>precision</b> <b>RTOL1,</b> <b>double</b> <b>precision</b> <b>RTOL2,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WERR,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>WGAP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IBLOCK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDEXW,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>GERS,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISUPPZ,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DLARRV</b> computes the eigenvectors of the tridiagonal matrix T = L D LT given L, D and the eigenvalues of L
       D LT.

       <b>Purpose:</b>

            DLARRV computes the eigenvectors of the tridiagonal matrix
            T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
            The input eigenvalues should have been computed by DLARRE.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the matrix.  N &gt;= 0.

           <u>VL</u>

                     VL is DOUBLE PRECISION
                     Lower bound of the interval that contains the desired
                     eigenvalues. VL &lt; VU. Needed to compute gaps on the left or right
                     end of the extremal eigenvalues in the desired RANGE.

           <u>VU</u>

                     VU is DOUBLE PRECISION
                     Upper bound of the interval that contains the desired
                     eigenvalues. VL &lt; VU.
                     Note: VU is currently not used by this implementation of DLARRV, VU is
                     passed to DLARRV because it could be used compute gaps on the right end
                     of the extremal eigenvalues. However, with not much initial accuracy in
                     LAMBDA and VU, the formula can lead to an overestimation of the right gap
                     and thus to inadequately early RQI 'convergence'. This is currently
                     prevented this by forcing a small right gap. And so it turns out that VU
                     is currently not used by this implementation of DLARRV.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     On entry, the N diagonal elements of the diagonal matrix D.
                     On exit, D may be overwritten.

           <u>L</u>

                     L is DOUBLE PRECISION array, dimension (N)
                     On entry, the (N-1) subdiagonal elements of the unit
                     bidiagonal matrix L are in elements 1 to N-1 of L
                     (if the matrix is not split.) At the end of each block
                     is stored the corresponding shift as given by DLARRE.
                     On exit, L is overwritten.

           <u>PIVMIN</u>

                     PIVMIN is DOUBLE PRECISION
                     The minimum pivot allowed in the Sturm sequence.

           <u>ISPLIT</u>

                     ISPLIT is INTEGER array, dimension (N)
                     The splitting points, at which T breaks up into blocks.
                     The first block consists of rows/columns 1 to
                     ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1
                     through ISPLIT( 2 ), etc.

           <u>M</u>

                     M is INTEGER
                     The total number of input eigenvalues.  0 &lt;= M &lt;= N.

           <u>DOL</u>

                     DOL is INTEGER

           <u>DOU</u>

                     DOU is INTEGER
                     If the user wants to compute only selected eigenvectors from all
                     the eigenvalues supplied, he can specify an index range DOL:DOU.
                     Or else the setting DOL=1, DOU=M should be applied.
                     Note that DOL and DOU refer to the order in which the eigenvalues
                     are stored in W.
                     If the user wants to compute only selected eigenpairs, then
                     the columns DOL-1 to DOU+1 of the eigenvector space Z contain the
                     computed eigenvectors. All other columns of Z are set to zero.

           <u>MINRGP</u>

                     MINRGP is DOUBLE PRECISION

           <u>RTOL1</u>

                     RTOL1 is DOUBLE PRECISION

           <u>RTOL2</u>

                     RTOL2 is DOUBLE PRECISION
                      Parameters for bisection.
                      An interval [LEFT,RIGHT] has converged if
                      RIGHT-LEFT &lt; MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )

           <u>W</u>

                     W is DOUBLE PRECISION array, dimension (N)
                     The first M elements of W contain the APPROXIMATE eigenvalues for
                     which eigenvectors are to be computed.  The eigenvalues
                     should be grouped by split-off block and ordered from
                     smallest to largest within the block ( The output array
                     W from DLARRE is expected here ). Furthermore, they are with
                     respect to the shift of the corresponding root representation
                     for their block. On exit, W holds the eigenvalues of the
                     UNshifted matrix.

           <u>WERR</u>

                     WERR is DOUBLE PRECISION array, dimension (N)
                     The first M elements contain the semiwidth of the uncertainty
                     interval of the corresponding eigenvalue in W

           <u>WGAP</u>

                     WGAP is DOUBLE PRECISION array, dimension (N)
                     The separation from the right neighbor eigenvalue in W.

           <u>IBLOCK</u>

                     IBLOCK is INTEGER array, dimension (N)
                     The indices of the blocks (submatrices) associated with the
                     corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue
                     W(i) belongs to the first block from the top, =2 if W(i)
                     belongs to the second block, etc.

           <u>INDEXW</u>

                     INDEXW is INTEGER array, dimension (N)
                     The indices of the eigenvalues within each block (submatrix);
                     for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the
                     i-th eigenvalue W(i) is the 10-th eigenvalue in the second block.

           <u>GERS</u>

                     GERS is DOUBLE PRECISION array, dimension (2*N)
                     The N Gerschgorin intervals (the i-th Gerschgorin interval
                     is (GERS(2*i-1), GERS(2*i)). The Gerschgorin intervals should
                     be computed from the original UNshifted matrix.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (LDZ, max(1,M) )
                     If INFO = 0, the first M columns of Z contain the
                     orthonormal eigenvectors of the matrix T
                     corresponding to the input eigenvalues, with the i-th
                     column of Z holding the eigenvector associated with W(i).
                     Note: the user must ensure that at least max(1,M) columns are
                     supplied in the array Z.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1, and if
                     JOBZ = 'V', LDZ &gt;= max(1,N).

           <u>ISUPPZ</u>

                     ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )
                     The support of the eigenvectors in Z, i.e., the indices
                     indicating the nonzero elements in Z. The I-th eigenvector
                     is nonzero only in elements ISUPPZ( 2*I-1 ) through
                     ISUPPZ( 2*I ).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (12*N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (7*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit

                     &gt; 0:  A problem occurred in DLARRV.
                     &lt; 0:  One of the called subroutines signaled an internal problem.
                           Needs inspection of the corresponding parameter IINFO
                           for further information.

                     =-1:  Problem in DLARRB when refining a child's eigenvalues.
                     =-2:  Problem in DLARRF when computing the RRR of a child.
                           When a child is inside a tight cluster, it can be difficult
                           to find an RRR. A partial remedy from the user's point of
                           view is to make the parameter MINRGP smaller and recompile.
                           However, as the orthogonality of the computed vectors is
                           proportional to 1/MINRGP, the user should be aware that
                           he might be trading in precision when he decreases MINRGP.
                     =-3:  Problem in DLARRB when refining a single eigenvalue
                           after the Rayleigh correction was rejected.
                     = 5:  The Rayleigh Quotient Iteration failed to converge to
                           full accuracy in MAXITR steps.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Beresford Parlett, University of California, Berkeley, USA
            Jim Demmel, University of California, Berkeley, USA
            Inderjit Dhillon, University of Texas, Austin, USA
            Osni Marques, LBNL/NERSC, USA
            Christof Voemel, University of California, Berkeley, USA

   <b>subroutine</b> <b>dlartv</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>Y,</b> <b>integer</b> <b>INCY,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>integer</b>
       <b>INCC)</b>
       <b>DLARTV</b> applies a vector of plane rotations with real cosines and real sines to the elements of a pair of
       vectors.

       <b>Purpose:</b>

            DLARTV applies a vector of real plane rotations to elements of the
            real vectors x and y. For i = 1,2,...,n

               ( x(i) ) := (  c(i)  s(i) ) ( x(i) )
               ( y(i) )    ( -s(i)  c(i) ) ( y(i) )

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of plane rotations to be applied.

           <u>X</u>

                     X is DOUBLE PRECISION array,
                                    dimension (1+(N-1)*INCX)
                     The vector x.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X. INCX &gt; 0.

           <u>Y</u>

                     Y is DOUBLE PRECISION array,
                                    dimension (1+(N-1)*INCY)
                     The vector y.

           <u>INCY</u>

                     INCY is INTEGER
                     The increment between elements of Y. INCY &gt; 0.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
                     The cosines of the plane rotations.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
                     The sines of the plane rotations.

           <u>INCC</u>

                     INCC is INTEGER
                     The increment between elements of C and S. INCC &gt; 0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlaswp</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer</b> <b>K1,</b> <b>integer</b> <b>K2,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>integer</b> <b>INCX)</b>
       <b>DLASWP</b> performs a series of row interchanges on a general rectangular matrix.

       <b>Purpose:</b>

            DLASWP performs a series of row interchanges on the matrix A.
            One row interchange is initiated for each of rows K1 through K2 of A.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     On entry, the matrix of column dimension N to which the row
                     interchanges will be applied.
                     On exit, the permuted matrix.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.

           <u>K1</u>

                     K1 is INTEGER
                     The first element of IPIV for which a row interchange will
                     be done.

           <u>K2</u>

                     K2 is INTEGER
                     (K2-K1+1) is the number of elements of IPIV for which a row
                     interchange will be done.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (K1+(K2-K1)*abs(INCX))
                     The vector of pivot indices. Only the elements in positions
                     K1 through K1+(K2-K1)*abs(INCX) of IPIV are accessed.
                     IPIV(K1+(K-K1)*abs(INCX)) = L implies rows K and L are to be
                     interchanged.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between successive values of IPIV. If INCX
                     is negative, the pivots are applied in reverse order.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Modified by
              R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA

   <b>subroutine</b> <b>dlat2s</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b>
       <b>dimension(</b> <b>ldsa,</b> <b>*</b> <b>)</b> <b>SA,</b> <b>integer</b> <b>LDSA,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAT2S</b> converts a double-precision triangular matrix to a single-precision triangular matrix.

       <b>Purpose:</b>

            DLAT2S converts a DOUBLE PRECISION triangular matrix, SA, to a SINGLE
            PRECISION triangular matrix, A.

            RMAX is the overflow for the SINGLE PRECISION arithmetic
            DLAS2S checks that all the entries of A are between -RMAX and
            RMAX. If not the conversion is aborted and a flag is raised.

            This is an auxiliary routine so there is no argument checking.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>N</u>

                     N is INTEGER
                     The number of rows and columns of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     On entry, the N-by-N triangular coefficient matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>SA</u>

                     SA is REAL array, dimension (LDSA,N)
                     Only the UPLO part of SA is referenced.  On exit, if INFO=0,
                     the N-by-N coefficient matrix SA; if INFO&gt;0, the content of
                     the UPLO part of SA is unspecified.

           <u>LDSA</u>

                     LDSA is INTEGER
                     The leading dimension of the array SA.  LDSA &gt;= max(1,M).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     = 1:  an entry of the matrix A is greater than the SINGLE
                           PRECISION overflow threshold, in this case, the content
                           of the UPLO part of SA in exit is unspecified.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlatbs</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>character</b> <b>NORMIN,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>double</b>
       <b>precision</b> <b>SCALE,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CNORM,</b> <b>integer</b> <b>INFO)</b>
       <b>DLATBS</b> solves a triangular banded system of equations.

       <b>Purpose:</b>

            DLATBS solves one of the triangular systems

               A *x = s*b  or  A**T*x = s*b

            with scaling to prevent overflow, where A is an upper or lower
            triangular band matrix.  Here A**T denotes the transpose of A, x and b
            are n-element vectors, and s is a scaling factor, usually less than
            or equal to 1, chosen so that the components of x will be less than
            the overflow threshold.  If the unscaled problem will not cause
            overflow, the Level 2 BLAS routine DTBSV is called.  If the matrix A
            is singular (A(j,j) = 0 for some j), then s is set to 0 and a
            non-trivial solution to A*x = 0 is returned.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the operation applied to A.
                     = 'N':  Solve A * x = s*b  (No transpose)
                     = 'T':  Solve A**T* x = s*b  (Transpose)
                     = 'C':  Solve A**T* x = s*b  (Conjugate transpose = Transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>NORMIN</u>

                     NORMIN is CHARACTER*1
                     Specifies whether CNORM has been set or not.
                     = 'Y':  CNORM contains the column norms on entry
                     = 'N':  CNORM is not set on entry.  On exit, the norms will
                             be computed and stored in CNORM.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of subdiagonals or superdiagonals in the
                     triangular matrix A.  KD &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                     The upper or lower triangular band matrix A, stored in the
                     first KD+1 rows of the array. The j-th column of A is stored
                     in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (N)
                     On entry, the right hand side b of the triangular system.
                     On exit, X is overwritten by the solution vector x.

           <u>SCALE</u>

                     SCALE is DOUBLE PRECISION
                     The scaling factor s for the triangular system
                        A * x = s*b  or  A**T* x = s*b.
                     If SCALE = 0, the matrix A is singular or badly scaled, and
                     the vector x is an exact or approximate solution to A*x = 0.

           <u>CNORM</u>

                     CNORM is DOUBLE PRECISION array, dimension (N)

                     If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
                     contains the norm of the off-diagonal part of the j-th column
                     of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
                     to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
                     must be greater than or equal to the 1-norm.

                     If NORMIN = 'N', CNORM is an output argument and CNORM(j)
                     returns the 1-norm of the offdiagonal part of the j-th column
                     of A.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             A rough bound on x is computed; if that is less than overflow, DTBSV
             is called, otherwise, specific code is used which checks for possible
             overflow or divide-by-zero at every operation.

             A columnwise scheme is used for solving A*x = b.  The basic algorithm
             if A is lower triangular is

                  x[1:n] := b[1:n]
                  for j = 1, ..., n
                       x(j) := x(j) / A(j,j)
                       x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                  end

             Define bounds on the components of x after j iterations of the loop:
                M(j) = bound on x[1:j]
                G(j) = bound on x[j+1:n]
             Initially, let <a href="../man0/M.0.html">M</a>(0) = 0 and <a href="../man0/G.0.html">G</a>(0) = max{x(i), i=1,...,n}.

             Then for iteration j+1 we have
                M(j+1) &lt;= G(j) / | A(j+1,j+1) |
                G(j+1) &lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                       &lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )

             where CNORM(j+1) is greater than or equal to the infinity-norm of
             column j+1 of A, not counting the diagonal.  Hence

                G(j) &lt;= <a href="../man0/G.0.html">G</a>(0) product ( 1 + CNORM(i) / | A(i,i) | )
                             1&lt;=i&lt;=j
             and

                |x(j)| &lt;= ( <a href="../man0/G.0.html">G</a>(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                              1&lt;=i&lt; j

             Since |x(j)| &lt;= M(j), we use the Level 2 BLAS routine DTBSV if the
             reciprocal of the largest M(j), j=1,..,n, is larger than
             max(underflow, 1/overflow).

             The bound on x(j) is also used to determine when a step in the
             columnwise method can be performed without fear of overflow.  If
             the computed bound is greater than a large constant, x is scaled to
             prevent overflow, but if the bound overflows, x is set to 0, x(j) to
             1, and scale to 0, and a non-trivial solution to A*x = 0 is found.

             Similarly, a row-wise scheme is used to solve A**T*x = b.  The basic
             algorithm for A upper triangular is

                  for j = 1, ..., n
                       x(j) := ( b(j) - A[1:j-1,j]**T * x[1:j-1] ) / A(j,j)
                  end

             We simultaneously compute two bounds
                  G(j) = bound on ( b(i) - A[1:i-1,i]**T * x[1:i-1] ), 1&lt;=i&lt;=j
                  M(j) = bound on x(i), 1&lt;=i&lt;=j

             The initial values are <a href="../man0/G.0.html">G</a>(0) = 0, <a href="../man0/M.0.html">M</a>(0) = max{b(i), i=1,..,n}, and we
             add the constraint G(j) &gt;= G(j-1) and M(j) &gt;= M(j-1) for j &gt;= 1.
             Then the bound on x(j) is

                  M(j) &lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |

                       &lt;= <a href="../man0/M.0.html">M</a>(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                 1&lt;=i&lt;=j

             and we can safely call DTBSV if 1/M(n) and 1/G(n) are both greater
             than max(underflow, 1/overflow).

   <b>subroutine</b> <b>dlatdf</b> <b>(integer</b> <b>IJOB,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RHS,</b> <b>double</b> <b>precision</b> <b>RDSUM,</b> <b>double</b> <b>precision</b> <b>RDSCAL,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>IPIV,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>JPIV)</b>
       <b>DLATDF</b> uses the LU factorization of the n-by-n matrix computed by sgetc2 and computes a contribution to
       the reciprocal Dif-estimate.

       <b>Purpose:</b>

            DLATDF uses the LU factorization of the n-by-n matrix Z computed by
            DGETC2 and computes a contribution to the reciprocal Dif-estimate
            by solving Z * x = b for x, and choosing the r.h.s. b such that
            the norm of x is as large as possible. On entry RHS = b holds the
            contribution from earlier solved sub-systems, and on return RHS = x.

            The factorization of Z returned by DGETC2 has the form Z = P*L*U*Q,
            where P and Q are permutation matrices. L is lower triangular with
            unit diagonal elements and U is upper triangular.

       <b>Parameters</b>
           <u>IJOB</u>

                     IJOB is INTEGER
                     IJOB = 2: First compute an approximative null-vector e
                         of Z using DGECON, e is normalized and solve for
                         Zx = +-e - f with the sign giving the greater value
                         of 2-norm(x). About 5 times as expensive as Default.
                     IJOB .ne. 2: Local look ahead strategy where all entries of
                         the r.h.s. b is chosen as either +1 or -1 (Default).

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix Z.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (LDZ, N)
                     On entry, the LU part of the factorization of the n-by-n
                     matrix Z computed by DGETC2:  Z = P * L * U * Q

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDA &gt;= max(1, N).

           <u>RHS</u>

                     RHS is DOUBLE PRECISION array, dimension (N)
                     On entry, RHS contains contributions from other subsystems.
                     On exit, RHS contains the solution of the subsystem with
                     entries according to the value of IJOB (see above).

           <u>RDSUM</u>

                     RDSUM is DOUBLE PRECISION
                     On entry, the sum of squares of computed contributions to
                     the Dif-estimate under computation by DTGSYL, where the
                     scaling factor RDSCAL (see below) has been factored out.
                     On exit, the corresponding sum of squares updated with the
                     contributions from the current sub-system.
                     If TRANS = 'T' RDSUM is not touched.
                     NOTE: RDSUM only makes sense when DTGSY2 is called by STGSYL.

           <u>RDSCAL</u>

                     RDSCAL is DOUBLE PRECISION
                     On entry, scaling factor used to prevent overflow in RDSUM.
                     On exit, RDSCAL is updated w.r.t. the current contributions
                     in RDSUM.
                     If TRANS = 'T', RDSCAL is not touched.
                     NOTE: RDSCAL only makes sense when DTGSY2 is called by
                           DTGSYL.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N).
                     The pivot indices; for 1 &lt;= i &lt;= N, row i of the
                     matrix has been interchanged with row IPIV(i).

           <u>JPIV</u>

                     JPIV is INTEGER array, dimension (N).
                     The pivot indices; for 1 &lt;= j &lt;= N, column j of the
                     matrix has been interchanged with column JPIV(j).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>
           This routine is a further developed implementation of algorithm BSOLVE in [1] using complete pivoting
           in the LU factorization.

       <b>Contributors:</b>
           Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea,
           Sweden.

       <b>References:</b>

             [1] Bo Kagstrom and Lars Westin,
                 Generalized Schur Methods with Condition Estimators for
                 Solving the Generalized Sylvester Equation, IEEE Transactions
                 on Automatic Control, Vol. 34, No. 7, July 1989, pp 745-751.

             [2] Peter Poromaa,
                 On Efficient and Robust Estimators for the Separation
                 between two Regular Matrix Pairs with Applications in
                 Condition Estimation. Report IMINF-95.05, Departement of
                 Computing Science, Umea University, S-901 87 Umea, Sweden, 1995.

   <b>subroutine</b> <b>dlatps</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>character</b> <b>NORMIN,</b> <b>integer</b> <b>N,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>double</b> <b>precision</b> <b>SCALE,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CNORM,</b> <b>integer</b> <b>INFO)</b>
       <b>DLATPS</b> solves a triangular system of equations with the matrix held in packed storage.

       <b>Purpose:</b>

            DLATPS solves one of the triangular systems

               A *x = s*b  or  A**T*x = s*b

            with scaling to prevent overflow, where A is an upper or lower
            triangular matrix stored in packed form.  Here A**T denotes the
            transpose of A, x and b are n-element vectors, and s is a scaling
            factor, usually less than or equal to 1, chosen so that the
            components of x will be less than the overflow threshold.  If the
            unscaled problem will not cause overflow, the Level 2 BLAS routine
            DTPSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
            then s is set to 0 and a non-trivial solution to A*x = 0 is returned.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the operation applied to A.
                     = 'N':  Solve A * x = s*b  (No transpose)
                     = 'T':  Solve A**T* x = s*b  (Transpose)
                     = 'C':  Solve A**T* x = s*b  (Conjugate transpose = Transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>NORMIN</u>

                     NORMIN is CHARACTER*1
                     Specifies whether CNORM has been set or not.
                     = 'Y':  CNORM contains the column norms on entry
                     = 'N':  CNORM is not set on entry.  On exit, the norms will
                             be computed and stored in CNORM.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)
                     The upper or lower triangular matrix A, packed columnwise in
                     a linear array.  The j-th column of A is stored in the array
                     AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (N)
                     On entry, the right hand side b of the triangular system.
                     On exit, X is overwritten by the solution vector x.

           <u>SCALE</u>

                     SCALE is DOUBLE PRECISION
                     The scaling factor s for the triangular system
                        A * x = s*b  or  A**T* x = s*b.
                     If SCALE = 0, the matrix A is singular or badly scaled, and
                     the vector x is an exact or approximate solution to A*x = 0.

           <u>CNORM</u>

                     CNORM is DOUBLE PRECISION array, dimension (N)

                     If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
                     contains the norm of the off-diagonal part of the j-th column
                     of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
                     to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
                     must be greater than or equal to the 1-norm.

                     If NORMIN = 'N', CNORM is an output argument and CNORM(j)
                     returns the 1-norm of the offdiagonal part of the j-th column
                     of A.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             A rough bound on x is computed; if that is less than overflow, DTPSV
             is called, otherwise, specific code is used which checks for possible
             overflow or divide-by-zero at every operation.

             A columnwise scheme is used for solving A*x = b.  The basic algorithm
             if A is lower triangular is

                  x[1:n] := b[1:n]
                  for j = 1, ..., n
                       x(j) := x(j) / A(j,j)
                       x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                  end

             Define bounds on the components of x after j iterations of the loop:
                M(j) = bound on x[1:j]
                G(j) = bound on x[j+1:n]
             Initially, let <a href="../man0/M.0.html">M</a>(0) = 0 and <a href="../man0/G.0.html">G</a>(0) = max{x(i), i=1,...,n}.

             Then for iteration j+1 we have
                M(j+1) &lt;= G(j) / | A(j+1,j+1) |
                G(j+1) &lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                       &lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )

             where CNORM(j+1) is greater than or equal to the infinity-norm of
             column j+1 of A, not counting the diagonal.  Hence

                G(j) &lt;= <a href="../man0/G.0.html">G</a>(0) product ( 1 + CNORM(i) / | A(i,i) | )
                             1&lt;=i&lt;=j
             and

                |x(j)| &lt;= ( <a href="../man0/G.0.html">G</a>(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                              1&lt;=i&lt; j

             Since |x(j)| &lt;= M(j), we use the Level 2 BLAS routine DTPSV if the
             reciprocal of the largest M(j), j=1,..,n, is larger than
             max(underflow, 1/overflow).

             The bound on x(j) is also used to determine when a step in the
             columnwise method can be performed without fear of overflow.  If
             the computed bound is greater than a large constant, x is scaled to
             prevent overflow, but if the bound overflows, x is set to 0, x(j) to
             1, and scale to 0, and a non-trivial solution to A*x = 0 is found.

             Similarly, a row-wise scheme is used to solve A**T*x = b.  The basic
             algorithm for A upper triangular is

                  for j = 1, ..., n
                       x(j) := ( b(j) - A[1:j-1,j]**T * x[1:j-1] ) / A(j,j)
                  end

             We simultaneously compute two bounds
                  G(j) = bound on ( b(i) - A[1:i-1,i]**T * x[1:i-1] ), 1&lt;=i&lt;=j
                  M(j) = bound on x(i), 1&lt;=i&lt;=j

             The initial values are <a href="../man0/G.0.html">G</a>(0) = 0, <a href="../man0/M.0.html">M</a>(0) = max{b(i), i=1,..,n}, and we
             add the constraint G(j) &gt;= G(j-1) and M(j) &gt;= M(j-1) for j &gt;= 1.
             Then the bound on x(j) is

                  M(j) &lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |

                       &lt;= <a href="../man0/M.0.html">M</a>(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                 1&lt;=i&lt;=j

             and we can safely call DTPSV if 1/M(n) and 1/G(n) are both greater
             than max(underflow, 1/overflow).

   <b>subroutine</b> <b>dlatrd</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b>
       <b>LDA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldw,</b> <b>*</b> <b>)</b> <b>W,</b> <b>integer</b> <b>LDW)</b>
       <b>DLATRD</b> reduces the first nb rows and columns of a symmetric/Hermitian matrix A to real tridiagonal form
       by an orthogonal similarity transformation.

       <b>Purpose:</b>

            DLATRD reduces NB rows and columns of a real symmetric matrix A to
            symmetric tridiagonal form by an orthogonal similarity
            transformation Q**T * A * Q, and returns the matrices V and W which are
            needed to apply the transformation to the unreduced part of A.

            If UPLO = 'U', DLATRD reduces the last NB rows and columns of a
            matrix, of which the upper triangle is supplied;
            if UPLO = 'L', DLATRD reduces the first NB rows and columns of a
            matrix, of which the lower triangle is supplied.

            This is an auxiliary routine called by DSYTRD.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix A is stored:
                     = 'U': Upper triangular
                     = 'L': Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.

           <u>NB</u>

                     NB is INTEGER
                     The number of rows and columns to be reduced.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     On entry, the symmetric matrix A.  If UPLO = 'U', the leading
                     n-by-n upper triangular part of A contains the upper
                     triangular part of the matrix A, and the strictly lower
                     triangular part of A is not referenced.  If UPLO = 'L', the
                     leading n-by-n lower triangular part of A contains the lower
                     triangular part of the matrix A, and the strictly upper
                     triangular part of A is not referenced.
                     On exit:
                     if UPLO = 'U', the last NB columns have been reduced to
                       tridiagonal form, with the diagonal elements overwriting
                       the diagonal elements of A; the elements above the diagonal
                       with the array TAU, represent the orthogonal matrix Q as a
                       product of elementary reflectors;
                     if UPLO = 'L', the first NB columns have been reduced to
                       tridiagonal form, with the diagonal elements overwriting
                       the diagonal elements of A; the elements below the diagonal
                       with the array TAU, represent the  orthogonal matrix Q as a
                       product of elementary reflectors.
                     See Further Details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= (1,N).

           <u>E</u>

                     E is DOUBLE PRECISION array, dimension (N-1)
                     If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
                     elements of the last NB columns of the reduced matrix;
                     if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
                     the first NB columns of the reduced matrix.

           <u>TAU</u>

                     TAU is DOUBLE PRECISION array, dimension (N-1)
                     The scalar factors of the elementary reflectors, stored in
                     TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
                     See Further Details.

           <u>W</u>

                     W is DOUBLE PRECISION array, dimension (LDW,NB)
                     The n-by-nb matrix W required to update the unreduced part
                     of A.

           <u>LDW</u>

                     LDW is INTEGER
                     The leading dimension of the array W. LDW &gt;= max(1,N).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             If UPLO = 'U', the matrix Q is represented as a product of elementary
             reflectors

                Q = H(n) H(n-1) . . . H(n-nb+1).

             Each H(i) has the form

                H(i) = I - tau * v * v**T

             where tau is a real scalar, and v is a real vector with
             v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
             and tau in TAU(i-1).

             If UPLO = 'L', the matrix Q is represented as a product of elementary
             reflectors

                Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nb).

             Each H(i) has the form

                H(i) = I - tau * v * v**T

             where tau is a real scalar, and v is a real vector with
             v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
             and tau in TAU(i).

             The elements of the vectors v together form the n-by-nb matrix V
             which is needed, with W, to apply the transformation to the unreduced
             part of the matrix, using a symmetric rank-2k update of the form:
             A := A - V*W**T - W*V**T.

             The contents of A on exit are illustrated by the following examples
             with n = 5 and nb = 2:

             if UPLO = 'U':                       if UPLO = 'L':

               (  a   a   a   v4  v5 )              (  d                  )
               (      a   a   v4  v5 )              (  1   d              )
               (          a   1   v5 )              (  v1  1   a          )
               (              d   1  )              (  v1  v2  a   a      )
               (                  d  )              (  v1  v2  a   a   a  )

             where d denotes a diagonal element of the reduced matrix, a denotes
             an element of the original matrix that is unchanged, and vi denotes
             an element of the vector defining H(i).

   <b>subroutine</b> <b>dlatrs</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>character</b> <b>NORMIN,</b> <b>integer</b> <b>N,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>double</b> <b>precision</b>
       <b>SCALE,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CNORM,</b> <b>integer</b> <b>INFO)</b>
       <b>DLATRS</b> solves a triangular system of equations with the scale factor set to prevent overflow.

       <b>Purpose:</b>

            DLATRS solves one of the triangular systems

               A *x = s*b  or  A**T *x = s*b

            with scaling to prevent overflow.  Here A is an upper or lower
            triangular matrix, A**T denotes the transpose of A, x and b are
            n-element vectors, and s is a scaling factor, usually less than
            or equal to 1, chosen so that the components of x will be less than
            the overflow threshold.  If the unscaled problem will not cause
            overflow, the Level 2 BLAS routine DTRSV is called.  If the matrix A
            is singular (A(j,j) = 0 for some j), then s is set to 0 and a
            non-trivial solution to A*x = 0 is returned.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the operation applied to A.
                     = 'N':  Solve A * x = s*b  (No transpose)
                     = 'T':  Solve A**T* x = s*b  (Transpose)
                     = 'C':  Solve A**T* x = s*b  (Conjugate transpose = Transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>NORMIN</u>

                     NORMIN is CHARACTER*1
                     Specifies whether CNORM has been set or not.
                     = 'Y':  CNORM contains the column norms on entry
                     = 'N':  CNORM is not set on entry.  On exit, the norms will
                             be computed and stored in CNORM.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     The triangular matrix A.  If UPLO = 'U', the leading n by n
                     upper triangular part of the array A contains the upper
                     triangular matrix, and the strictly lower triangular part of
                     A is not referenced.  If UPLO = 'L', the leading n by n lower
                     triangular part of the array A contains the lower triangular
                     matrix, and the strictly upper triangular part of A is not
                     referenced.  If DIAG = 'U', the diagonal elements of A are
                     also not referenced and are assumed to be 1.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max (1,N).

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (N)
                     On entry, the right hand side b of the triangular system.
                     On exit, X is overwritten by the solution vector x.

           <u>SCALE</u>

                     SCALE is DOUBLE PRECISION
                     The scaling factor s for the triangular system
                        A * x = s*b  or  A**T* x = s*b.
                     If SCALE = 0, the matrix A is singular or badly scaled, and
                     the vector x is an exact or approximate solution to A*x = 0.

           <u>CNORM</u>

                     CNORM is DOUBLE PRECISION array, dimension (N)

                     If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
                     contains the norm of the off-diagonal part of the j-th column
                     of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
                     to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
                     must be greater than or equal to the 1-norm.

                     If NORMIN = 'N', CNORM is an output argument and CNORM(j)
                     returns the 1-norm of the offdiagonal part of the j-th column
                     of A.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             A rough bound on x is computed; if that is less than overflow, DTRSV
             is called, otherwise, specific code is used which checks for possible
             overflow or divide-by-zero at every operation.

             A columnwise scheme is used for solving A*x = b.  The basic algorithm
             if A is lower triangular is

                  x[1:n] := b[1:n]
                  for j = 1, ..., n
                       x(j) := x(j) / A(j,j)
                       x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                  end

             Define bounds on the components of x after j iterations of the loop:
                M(j) = bound on x[1:j]
                G(j) = bound on x[j+1:n]
             Initially, let <a href="../man0/M.0.html">M</a>(0) = 0 and <a href="../man0/G.0.html">G</a>(0) = max{x(i), i=1,...,n}.

             Then for iteration j+1 we have
                M(j+1) &lt;= G(j) / | A(j+1,j+1) |
                G(j+1) &lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                       &lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )

             where CNORM(j+1) is greater than or equal to the infinity-norm of
             column j+1 of A, not counting the diagonal.  Hence

                G(j) &lt;= <a href="../man0/G.0.html">G</a>(0) product ( 1 + CNORM(i) / | A(i,i) | )
                             1&lt;=i&lt;=j
             and

                |x(j)| &lt;= ( <a href="../man0/G.0.html">G</a>(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                              1&lt;=i&lt; j

             Since |x(j)| &lt;= M(j), we use the Level 2 BLAS routine DTRSV if the
             reciprocal of the largest M(j), j=1,..,n, is larger than
             max(underflow, 1/overflow).

             The bound on x(j) is also used to determine when a step in the
             columnwise method can be performed without fear of overflow.  If
             the computed bound is greater than a large constant, x is scaled to
             prevent overflow, but if the bound overflows, x is set to 0, x(j) to
             1, and scale to 0, and a non-trivial solution to A*x = 0 is found.

             Similarly, a row-wise scheme is used to solve A**T*x = b.  The basic
             algorithm for A upper triangular is

                  for j = 1, ..., n
                       x(j) := ( b(j) - A[1:j-1,j]**T * x[1:j-1] ) / A(j,j)
                  end

             We simultaneously compute two bounds
                  G(j) = bound on ( b(i) - A[1:i-1,i]**T * x[1:i-1] ), 1&lt;=i&lt;=j
                  M(j) = bound on x(i), 1&lt;=i&lt;=j

             The initial values are <a href="../man0/G.0.html">G</a>(0) = 0, <a href="../man0/M.0.html">M</a>(0) = max{b(i), i=1,..,n}, and we
             add the constraint G(j) &gt;= G(j-1) and M(j) &gt;= M(j-1) for j &gt;= 1.
             Then the bound on x(j) is

                  M(j) &lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |

                       &lt;= <a href="../man0/M.0.html">M</a>(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                 1&lt;=i&lt;=j

             and we can safely call DTRSV if 1/M(n) and 1/G(n) are both greater
             than max(underflow, 1/overflow).

   <b>subroutine</b> <b>dlauu2</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer</b>
       <b>INFO)</b>
       <b>DLAUU2</b> computes the product UUH or LHL, where U and L are upper or lower triangular matrices (unblocked
       algorithm).

       <b>Purpose:</b>

            DLAUU2 computes the product U * U**T or L**T * L, where the triangular
            factor U or L is stored in the upper or lower triangular part of
            the array A.

            If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
            overwriting the factor U in A.
            If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
            overwriting the factor L in A.

            This is the unblocked form of the algorithm, calling Level 2 BLAS.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the triangular factor stored in the array A
                     is upper or lower triangular:
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the triangular factor U or L.  N &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     On entry, the triangular factor U or L.
                     On exit, if UPLO = 'U', the upper triangle of A is
                     overwritten with the upper triangle of the product U * U**T;
                     if UPLO = 'L', the lower triangle of A is overwritten with
                     the lower triangle of the product L**T * L.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlauum</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer</b>
       <b>INFO)</b>
       <b>DLAUUM</b> computes the product UUH or LHL, where U and L are upper or lower triangular matrices (blocked
       algorithm).

       <b>Purpose:</b>

            DLAUUM computes the product U * U**T or L**T * L, where the triangular
            factor U or L is stored in the upper or lower triangular part of
            the array A.

            If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
            overwriting the factor U in A.
            If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
            overwriting the factor L in A.

            This is the blocked form of the algorithm, calling Level 3 BLAS.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the triangular factor stored in the array A
                     is upper or lower triangular:
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the triangular factor U or L.  N &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     On entry, the triangular factor U or L.
                     On exit, if UPLO = 'U', the upper triangle of A is
                     overwritten with the upper triangle of the product U * U**T;
                     if UPLO = 'L', the lower triangle of A is overwritten with
                     the lower triangle of the product L**T * L.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>drscl</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision</b> <b>SA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SX,</b> <b>integer</b> <b>INCX)</b>
       <b>DRSCL</b> multiplies a vector by the reciprocal of a real scalar.

       <b>Purpose:</b>

            DRSCL multiplies an n-element real vector x by the real scalar 1/a.
            This is done without overflow or underflow as long as
            the final result x/a does not overflow or underflow.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of components of the vector x.

           <u>SA</u>

                     SA is DOUBLE PRECISION
                     The scalar a which is used to divide each component of x.
                     SA must be &gt;= 0, or the subroutine will divide by zero.

           <u>SX</u>

                     SX is DOUBLE PRECISION array, dimension
                                    (1+(N-1)*abs(INCX))
                     The n-element vector x.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between successive values of the vector SX.
                     &gt; 0:  <a href="../man1/SX.1.html">SX</a>(1) = <a href="../man1/X.1.html">X</a>(1) and SX(1+(i-1)*INCX) = x(i),     1&lt; i&lt;= n

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dtprfb</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIRECT,</b> <b>character</b> <b>STOREV,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b>
       <b>integer</b> <b>K,</b> <b>integer</b> <b>L,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldwork,</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LDWORK)</b>
       <b>DTPRFB</b> applies a real or complex 'triangular-pentagonal' blocked reflector to a real or complex matrix,
       which is composed of two blocks.

       <b>Purpose:</b>

            DTPRFB applies a real "triangular-pentagonal" block reflector H or its
            transpose H**T to a real matrix C, which is composed of two
            blocks A and B, either from the left or right.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply H or H**T from the Left
                     = 'R': apply H or H**T from the Right

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply H (No transpose)
                     = 'T': apply H**T (Transpose)

           <u>DIRECT</u>

                     DIRECT is CHARACTER*1
                     Indicates how H is formed from a product of elementary
                     reflectors
                     = 'F': H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) (Forward)
                     = 'B': H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) (Backward)

           <u>STOREV</u>

                     STOREV is CHARACTER*1
                     Indicates how the vectors which define the elementary
                     reflectors are stored:
                     = 'C': Columns
                     = 'R': Rows

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix B.
                     M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix B.
                     N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The order of the matrix T, i.e. the number of elementary
                     reflectors whose product defines the block reflector.
                     K &gt;= 0.

           <u>L</u>

                     L is INTEGER
                     The order of the trapezoidal part of V.
                     K &gt;= L &gt;= 0.  See Further Details.

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension
                                           (LDV,K) if STOREV = 'C'
                                           (LDV,M) if STOREV = 'R' and SIDE = 'L'
                                           (LDV,N) if STOREV = 'R' and SIDE = 'R'
                     The pentagonal matrix V, which contains the elementary reflectors
                     <a href="../man1/H.1.html">H</a>(1), <a href="../man2/H.2.html">H</a>(2), ..., H(K).  See Further Details.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V.
                     If STOREV = 'C' and SIDE = 'L', LDV &gt;= max(1,M);
                     if STOREV = 'C' and SIDE = 'R', LDV &gt;= max(1,N);
                     if STOREV = 'R', LDV &gt;= K.

           <u>T</u>

                     T is DOUBLE PRECISION array, dimension (LDT,K)
                     The triangular K-by-K matrix T in the representation of the
                     block reflector.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.
                     LDT &gt;= K.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension
                     (LDA,N) if SIDE = 'L' or (LDA,K) if SIDE = 'R'
                     On entry, the K-by-N or M-by-K matrix A.
                     On exit, A is overwritten by the corresponding block of
                     H*C or H**T*C or C*H or C*H**T.  See Further Details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If SIDE = 'L', LDA &gt;= max(1,K);
                     If SIDE = 'R', LDA &gt;= max(1,M).

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB,N)
                     On entry, the M-by-N matrix B.
                     On exit, B is overwritten by the corresponding block of
                     H*C or H**T*C or C*H or C*H**T.  See Further Details.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.
                     LDB &gt;= max(1,M).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension
                     (LDWORK,N) if SIDE = 'L',
                     (LDWORK,K) if SIDE = 'R'.

           <u>LDWORK</u>

                     LDWORK is INTEGER
                     The leading dimension of the array WORK.
                     If SIDE = 'L', LDWORK &gt;= K;
                     if SIDE = 'R', LDWORK &gt;= M.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The matrix C is a composite matrix formed from blocks A and B.
             The block B is of size M-by-N; if SIDE = 'R', A is of size M-by-K,
             and if SIDE = 'L', A is of size K-by-N.

             If SIDE = 'R' and DIRECT = 'F', C = [A B].

             If SIDE = 'L' and DIRECT = 'F', C = [A]
                                                 [B].

             If SIDE = 'R' and DIRECT = 'B', C = [B A].

             If SIDE = 'L' and DIRECT = 'B', C = [B]
                                                 [A].

             The pentagonal matrix V is composed of a rectangular block V1 and a
             trapezoidal block V2.  The size of the trapezoidal block is determined by
             the parameter L, where 0&lt;=L&lt;=K.  If L=K, the V2 block of V is triangular;
             if L=0, there is no trapezoidal block, thus V = V1 is rectangular.

             If DIRECT = 'F' and STOREV = 'C':  V = [V1]
                                                    [V2]
                - V2 is upper trapezoidal (first L rows of K-by-K upper triangular)

             If DIRECT = 'F' and STOREV = 'R':  V = [V1 V2]

                - V2 is lower trapezoidal (first L columns of K-by-K lower triangular)

             If DIRECT = 'B' and STOREV = 'C':  V = [V2]
                                                    [V1]
                - V2 is lower trapezoidal (last L rows of K-by-K lower triangular)

             If DIRECT = 'B' and STOREV = 'R':  V = [V2 V1]

                - V2 is upper trapezoidal (last L columns of K-by-K upper triangular)

             If STOREV = 'C' and SIDE = 'L', V is M-by-K with V2 L-by-K.

             If STOREV = 'C' and SIDE = 'R', V is N-by-K with V2 L-by-K.

             If STOREV = 'R' and SIDE = 'L', V is K-by-M with V2 K-by-L.

             If STOREV = 'R' and SIDE = 'R', V is K-by-N with V2 K-by-L.

   <b>subroutine</b> <b>slatrd</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NB,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>real,</b> <b>dimension(</b> <b>ldw,</b> <b>*</b> <b>)</b> <b>W,</b> <b>integer</b> <b>LDW)</b>
       <b>SLATRD</b> reduces the first nb rows and columns of a symmetric/Hermitian matrix A to real tridiagonal form
       by an orthogonal similarity transformation.

       <b>Purpose:</b>

            SLATRD reduces NB rows and columns of a real symmetric matrix A to
            symmetric tridiagonal form by an orthogonal similarity
            transformation Q**T * A * Q, and returns the matrices V and W which are
            needed to apply the transformation to the unreduced part of A.

            If UPLO = 'U', SLATRD reduces the last NB rows and columns of a
            matrix, of which the upper triangle is supplied;
            if UPLO = 'L', SLATRD reduces the first NB rows and columns of a
            matrix, of which the lower triangle is supplied.

            This is an auxiliary routine called by SSYTRD.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix A is stored:
                     = 'U': Upper triangular
                     = 'L': Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.

           <u>NB</u>

                     NB is INTEGER
                     The number of rows and columns to be reduced.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     On entry, the symmetric matrix A.  If UPLO = 'U', the leading
                     n-by-n upper triangular part of A contains the upper
                     triangular part of the matrix A, and the strictly lower
                     triangular part of A is not referenced.  If UPLO = 'L', the
                     leading n-by-n lower triangular part of A contains the lower
                     triangular part of the matrix A, and the strictly upper
                     triangular part of A is not referenced.
                     On exit:
                     if UPLO = 'U', the last NB columns have been reduced to
                       tridiagonal form, with the diagonal elements overwriting
                       the diagonal elements of A; the elements above the diagonal
                       with the array TAU, represent the orthogonal matrix Q as a
                       product of elementary reflectors;
                     if UPLO = 'L', the first NB columns have been reduced to
                       tridiagonal form, with the diagonal elements overwriting
                       the diagonal elements of A; the elements below the diagonal
                       with the array TAU, represent the  orthogonal matrix Q as a
                       product of elementary reflectors.
                     See Further Details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= (1,N).

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
                     elements of the last NB columns of the reduced matrix;
                     if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
                     the first NB columns of the reduced matrix.

           <u>TAU</u>

                     TAU is REAL array, dimension (N-1)
                     The scalar factors of the elementary reflectors, stored in
                     TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
                     See Further Details.

           <u>W</u>

                     W is REAL array, dimension (LDW,NB)
                     The n-by-nb matrix W required to update the unreduced part
                     of A.

           <u>LDW</u>

                     LDW is INTEGER
                     The leading dimension of the array W. LDW &gt;= max(1,N).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             If UPLO = 'U', the matrix Q is represented as a product of elementary
             reflectors

                Q = H(n) H(n-1) . . . H(n-nb+1).

             Each H(i) has the form

                H(i) = I - tau * v * v**T

             where tau is a real scalar, and v is a real vector with
             v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
             and tau in TAU(i-1).

             If UPLO = 'L', the matrix Q is represented as a product of elementary
             reflectors

                Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nb).

             Each H(i) has the form

                H(i) = I - tau * v * v**T

             where tau is a real scalar, and v is a real vector with
             v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
             and tau in TAU(i).

             The elements of the vectors v together form the n-by-nb matrix V
             which is needed, with W, to apply the transformation to the unreduced
             part of the matrix, using a symmetric rank-2k update of the form:
             A := A - V*W**T - W*V**T.

             The contents of A on exit are illustrated by the following examples
             with n = 5 and nb = 2:

             if UPLO = 'U':                       if UPLO = 'L':

               (  a   a   a   v4  v5 )              (  d                  )
               (      a   a   v4  v5 )              (  1   d              )
               (          a   1   v5 )              (  v1  1   a          )
               (              d   1  )              (  v1  v2  a   a      )
               (                  d  )              (  v1  v2  a   a   a  )

             where d denotes a diagonal element of the reduced matrix, a denotes
             an element of the original matrix that is unchanged, and vi denotes
             an element of the vector defining H(i).

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.10.0                                   Wed Jan 12 2022                         <u><a href="../man3/doubleOTHERauxiliary.3.html">doubleOTHERauxiliary</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>