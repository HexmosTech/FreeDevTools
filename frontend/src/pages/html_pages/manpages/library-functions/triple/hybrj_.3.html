<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hybrj_, hybrj1_ - find a zero of a system of nonlinear function</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/minpack-dev">minpack-dev_19961126+dfsg1-5build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       hybrj_, hybrj1_ - find a zero of a system of nonlinear function

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;minpack.h&gt;</b>

       <b>void</b> <b>hybrj1_</b> <b>(void</b> <b>(*</b><u>fcn</u><b>)(int</b> <b>*</b><u>n</u><b>,</b> <b>double</b> <b>*</b><u>x</u><b>,</b> <b>double</b> <b>*</b><u>fvec</u><b>,</b> <b>double</b> <b>*</b><u>fjac</u><b>,</b> <b>int</b> <b>*</b><u>ldfjac</u><b>,</b> <b>int</b> <b>*</b><u>iflag</u><b>),</b>
           <b>int</b> <b>*</b><u>n</u><b>,</b> <b>double</b> <b>*</b><u>x</u><b>,</b> <b>double</b> <b>*</b><u>fvec</u><b>,</b> <b>double</b> <b>*</b><u>fjac</u><b>,</b>
           <b>int</b> <b>*</b><u>ldfjac</u><b>,</b>
           <b>double</b> <b>*</b><u>tol</u><b>,</b> <b>int</b> <b>*</b><u>info</u><b>,</b> <b>double</b> <b>*</b><u>wa</u><b>,</b> <b>int</b> <b>*</b><u>lwa</u><b>);</b>

       <b>void</b> <b>hybrj_</b> <b>(void</b> <b>(*</b><u>fcn</u><b>)(int</b> <b>*</b><u>n</u><b>,</b> <b>double</b> <b>*</b><u>x</u><b>,</b> <b>double</b> <b>*</b><u>fvec</u><b>,</b> <b>double</b> <b>*</b><u>fjac</u><b>,</b> <b>int</b> <b>*</b><u>ldfjac</u><b>,</b> <b>int</b> <b>*</b><u>iflag</u><b>),</b>
           <b>int</b> <b>*</b><u>n</u><b>,</b> <b>double</b> <b>*</b><u>x</u><b>,</b> <b>double</b> <b>*</b><u>fvec</u><b>,</b> <b>double</b> <b>*</b><u>fjac</u><b>,</b>
           <b>int</b> <b>*</b><u>ldfjac</u><b>,</b>
           <b>double</b> <b>*</b><u>xtol</u><b>,</b> <b>int</b> <b>*</b><u>maxfev</u><b>,</b> <b>double</b> <b>*</b><u>diag</u><b>,</b> <b>int</b> <b>*</b><u>mode</u><b>,</b> <b>double</b> <b>*</b><u>factor</u><b>,</b> <b>int</b> <b>*</b><u>nprint</u><b>,</b> <b>int</b> <b>*</b><u>info</u><b>,</b> <b>int</b>
           <b>*</b><u>nfev</u><b>,</b>
           <b>int</b> <b>*</b><u>njev</u><b>,</b> <b>double</b> <b>*</b><u>r</u><b>,</b> <b>int</b> <b>*</b><u>lr</u><b>,</b> <b>double</b> <b>*</b><u>qtf</u><b>,</b>
           <b>double</b> <b>*</b><u>wa1</u><b>,</b> <b>double</b> <b>*</b><u>wa2</u><b>,</b> <b>double</b> <b>*</b><u>wa3</u><b>,</b> <b>double</b> <b>*</b><u>wa4</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  purpose of <b>hybrj_</b> is to find a zero of a system of <u>n</u> nonlinear functions in <u>n</u> variables by a modifi‐
       cation of the Powell hybrid method. The user must provide a subroutine which calculates the functions and
       a subroutine which calculates the Jacobian.

       <b>hybrj1_</b> serves the same function but has a simplified calling sequence.

   <b>Language</b> <b>notes</b>
       <b>hybrj_</b> and <b>hybrj1_</b> are written in FORTRAN. If calling from C, keep these points in mind:

       Name mangling.
              With <b>gfortran</b>, all the function names end in an underscore.

       Compile with <b>gfortran</b>.
              Even if your program is all C code, you should link with <b>gfortran</b> so it will pull in  the  FORTRAN
              libraries  automatically.  It's easiest just to use <b>gfortran</b> to do all the compiling.  (It handles
              C just fine.)

       Call by reference.
              All function parameters must be pointers.

       Column-major arrays.
              Suppose a function returns an array with 5 rows and 3 columns in an array <u>z</u> and in  the  call  you
              have declared a leading dimension of 7.  The FORTRAN and equivalent C references are:

                   z(1,1)         z[0]
                   z(2,1)         z[1]
                   z(5,1)         z[4]
                   z(1,2)         z[7]
                   z(1,3)         z[14]
                   z(i,j)         z[(i-1) + (j-1)*7]

   <b>Parameters</b> <b>for</b> <b>both</b> <b>functions</b>
       <u>fcn</u>  is  the name of the user-supplied subroutine which calculates the functions. In FORTRAN, <u>fcn</u> must be
       declared in an external statement in the user calling program, and should be written as follows:

       subroutine fcn(n,x,fvec,fjac,ldfjac,iflag)
       integer n,ldfjac,iflag
       double precision x(n),fvec(n),fjac(ldfjac,n)
       ----------
       if iflag = 1 calculate the functions at x and
       return this vector in fvec. do not alter fjac.
       if iflag = 2 calculate the jacobian at x and
       return this matrix in fjac. do not alter fvec.
       ---------
       return
       end

       In C, <u>fcn</u> should be written as follows:

         void fcn(int *n, double *x, double *fvec, double *fjac,
                  int *ldfjac, int *iflag)
         {
         /* if iflag = 1 calculate the functions at x and
            return this vector in fvec. do not alter fjac.
            if iflag = 2 calculate the jacobian at x and
            return this matrix in fjac. do not alter fvec. */
         }

       The value of <u>iflag</u> should not be changed by <u>fcn</u> unless the user wants to terminate execution  of  hybrj_.
       In this case set <u>iflag</u> to a negative integer.

       <u>n</u> is a positive integer input variable set to the number of functions and variables.

       <u>x</u>  is an array of length <u>n</u>. On input <u>x</u> must contain an initial estimate of the solution vector. On output
       <u>x</u> contains the final estimate of the solution vector.

       <u>fjac</u> is an output <u>n</u> by <u>n</u> array which contains the orthogonal matrix q produced by the qr factorization of
       the final approximate jacobian.

       <u>ldfjac</u> is a positive integer input variable not less than <u>n</u> which specifies the leading dimension of  the
       array <u>fjac</u>.

       <u>fvec</u> is an output array of length <u>n</u> which contains the functions evaluated at the output <u>x</u>.

   <b>Parameters</b> <b>for</b> <b>hybrj1_</b>
       <u>tol</u>  is  a  nonnegative input variable. Termination occurs when the algorithm estimates that the relative
       error between <u>x</u> and the solution is at most <u>tol</u>.

       <u>info</u> is an integer output variable. If the user has terminated execution, <u>info</u> is set to  the  (negative)
       value of <u>iflag</u>. See description of <u>fcn</u>. Otherwise, <u>info</u> is set as follows.

       <u>info</u> = 0   improper input parameters.

       <u>info</u> = 1   algorithm estimates that the relative error
                  between <u>x</u> and the solution is at most <u>tol</u>.

       <u>info</u> = 2   number of calls to fcn has reached or exceeded
                  200*(<u>n</u>+1).

       <u>info</u> = 3   <u>tol</u> is too small. No further improvement in
                  the approximate solution <u>x</u> is possible.

       <u>info</u> = 4   iteration is not making good progress.

       <u>wa</u> is a work array of length <u>lwa</u>.

       <u>lwa</u> is a positive integer input variable not less than (<u>n</u>*(3*<u>n</u>+13))/2.

   <b>Parameters</b> <b>for</b> <b>hybrj_</b>
       <u>xtol</u>  is a nonnegative input variable. Termination occurs when the relative error between two consecutive
       iterates is at most <u>xtol</u>.

       <u>maxfev</u> is a positive integer input variable. Termination occurs when the number of calls  to  <u>fcn</u>  is  at
       least <u>maxfev</u> by the end of an iteration.

       <u>diag</u>  is  an  array  of length <u>n</u>. If <u>mode</u> = 1 (see below), <u>diag</u> is internally set. If <u>mode</u> = 2, <u>diag</u> must
       contain positive entries that serve as multiplicative scale factors for the variables.

       <u>mode</u> is an integer input variable. If <u>mode</u> = 1, the variables will be scaled internally. If <u>mode</u> = 2, the
       scaling is specified by the input <u>diag</u>. Other values of mode are equivalent to <u>mode</u> = 1.

       <u>factor</u> is a positive input variable used in determining the initial step bound. This bound is set to  the
       product  of  <u>factor</u>  and the euclidean norm of diag*x if nonzero, or else to <u>factor</u> itself. In most cases
       factor should lie in the interval (.1,100.). 100. Is a generally recommended value.

       <u>nprint</u> is an integer input variable that enables controlled printing of iterates if it  is  positive.  In
       this  case,  <u>fcn</u> is called with <u>iflag</u> = 0 at the beginning of the first iteration and every nprint itera‐
       tions thereafter and immediately prior to return, with <u>x</u> and <u>fvec</u> available for printing.  If  <u>nprint</u>  is
       not positive, no special calls of <u>fcn</u> with <u>iflag</u> = 0 are made.

       <u>info</u>  is  an integer output variable. If the user has terminated execution, <u>info</u> is set to the (negative)
       value of <u>iflag</u>. See description of <u>fcn</u>. Otherwise, <u>info</u> is set as follows.

       <u>info</u> = 0   improper input parameters.

       <u>info</u> = 1   relative error between two consecutive iterates
                  is at most <u>xtol</u>.

       <u>info</u> = 2   number of calls to <u>fcn</u> has reached or exceeded
                  <u>maxfev</u>.

       <u>info</u> = 3   <u>xtol</u> is too small. No further improvement in
                  the approximate solution <u>x</u> is possible.

       <u>info</u> = 4   iteration is not making good progress, as
                  measured by the improvement from the last
                  five jacobian evaluations.

       <u>info</u> = 5   iteration is not making good progress, as
                  measured by the improvement from the last
                  ten iterations.

       <u>nfev</u> is an integer output variable set to the number of calls to <u>fcn</u>.

       <u>fjac</u> is an output <u>n</u> by <u>n</u> array which contains the orthogonal matrix <u>q</u> produced by the <u>qr</u> factorization of
       the final approximate jacobian.

       <u>ldfjac</u> is a positive integer input variable not less than <u>n</u> which specifies the leading dimension of  the
       array <u>fjac</u>.

       <u>r</u>  is  an output array of length <u>lr</u> which contains the upper triangular matrix produced by the <u>qr</u> factor‐
       ization of the final approximate Jacobian, stored rowwise.

       <u>lr</u> is a positive integer input variable not less than (<u>n</u>*(<u>n</u>+1))/2.

       <u>qtf</u> is an output array of length <u>n</u> which contains the vector (q transpose)*<u>fvec</u>.

       <u>wa1</u>, <u>wa2</u>, <u>wa3</u>, and <u>wa4</u> are work arrays of length <u>n</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/hybrd.3.html">hybrd</a></b>(3), <b><a href="../man3/hybrd1.3.html">hybrd1</a></b>(3).

</pre><h4><b>AUTHORS</b></h4><pre>
       Burton S. Garbow, Kenneth E. Hillstrom, Jorge J. More.
       This manual page was written by Jim Van Zandt &lt;<a href="mailto:jrv@debian.org">jrv@debian.org</a>&gt;, for the Debian GNU/Linux system (but  may
       be used by others).

Minpack                                           March 8, 2002                                        <u>HYBRJ</u><b><a href="../man3/_.3.html">_</a></b>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>