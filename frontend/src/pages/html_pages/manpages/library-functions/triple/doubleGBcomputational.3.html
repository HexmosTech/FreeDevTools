<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>doubleGBcomputational - double</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/liblapack-doc">liblapack-doc_3.10.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       doubleGBcomputational - double

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>dgbbrd</b> (VECT, M, N, NCC, KL, KU, AB, LDAB, D, E, Q, LDQ, PT, LDPT, C, LDC, WORK, INFO)
           <b>DGBBRD</b>
       subroutine <b>dgbcon</b> (NORM, N, KL, KU, AB, LDAB, IPIV, ANORM, RCOND, WORK, IWORK, INFO)
           <b>DGBCON</b>
       subroutine <b>dgbequ</b> (M, N, KL, KU, AB, LDAB, R, C, ROWCND, COLCND, AMAX, INFO)
           <b>DGBEQU</b>
       subroutine <b>dgbequb</b> (M, N, KL, KU, AB, LDAB, R, C, ROWCND, COLCND, AMAX, INFO)
           <b>DGBEQUB</b>
       subroutine <b>dgbrfs</b> (TRANS, N, KL, KU, NRHS, AB, LDAB, AFB, LDAFB, IPIV, B, LDB, X, LDX, FERR, BERR, WORK,
           IWORK, INFO)
           <b>DGBRFS</b>
       subroutine <b>dgbrfsx</b> (TRANS, EQUED, N, KL, KU, NRHS, AB, LDAB, AFB, LDAFB, IPIV, R, C, B, LDB, X, LDX,
           RCOND, BERR, N_ERR_BNDS, ERR_BNDS_NORM, ERR_BNDS_COMP, NPARAMS, PARAMS, WORK, IWORK, INFO)
           <b>DGBRFSX</b>
       subroutine <b>dgbtf2</b> (M, N, KL, KU, AB, LDAB, IPIV, INFO)
           <b>DGBTF2</b> computes the LU factorization of a general band matrix using the unblocked version of the
           algorithm.
       subroutine <b>dgbtrf</b> (M, N, KL, KU, AB, LDAB, IPIV, INFO)
           <b>DGBTRF</b>
       subroutine <b>dgbtrs</b> (TRANS, N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO)
           <b>DGBTRS</b>
       subroutine <b>dggbak</b> (JOB, SIDE, N, ILO, IHI, LSCALE, RSCALE, M, V, LDV, INFO)
           <b>DGGBAK</b>
       subroutine <b>dggbal</b> (JOB, N, A, LDA, B, LDB, ILO, IHI, LSCALE, RSCALE, WORK, INFO)
           <b>DGGBAL</b>
       subroutine <b>dla_gbamv</b> (TRANS, M, N, KL, KU, ALPHA, AB, LDAB, X, INCX, BETA, Y, INCY)
           <b>DLA_GBAMV</b> performs a matrix-vector operation to calculate error bounds.
       double precision function <b>dla_gbrcond</b> (TRANS, N, KL, KU, AB, LDAB, AFB, LDAFB, IPIV, CMODE, C, INFO,
           WORK, IWORK)
           <b>DLA_GBRCOND</b> estimates the Skeel condition number for a general banded matrix.
       subroutine <b>dla_gbrfsx_extended</b> (PREC_TYPE, TRANS_TYPE, N, KL, KU, NRHS, AB, LDAB, AFB, LDAFB, IPIV,
           COLEQU, C, B, LDB, Y, LDY, BERR_OUT, N_NORMS, ERR_BNDS_NORM, ERR_BNDS_COMP, RES, AYB, DY, Y_TAIL,
           RCOND, ITHRESH, RTHRESH, DZ_UB, IGNORE_CWISE, INFO)
           <b>DLA_GBRFSX_EXTENDED</b> improves the computed solution to a system of linear equations for general banded
           matrices by performing extra-precise iterative refinement and provides error bounds and backward
           error estimates for the solution.
       double precision function <b>dla_gbrpvgrw</b> (N, KL, KU, NCOLS, AB, LDAB, AFB, LDAFB)
           <b>DLA_GBRPVGRW</b> computes the reciprocal pivot growth factor norm(A)/norm(U) for a general banded matrix.
       subroutine <b>dorgbr</b> (VECT, M, N, K, A, LDA, TAU, WORK, LWORK, INFO)
           <b>DORGBR</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       This is the group of double computational functions for GB matrices

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>dgbbrd</b> <b>(character</b> <b>VECT,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NCC,</b> <b>integer</b> <b>KL,</b> <b>integer</b> <b>KU,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>ldpt,</b> <b>*</b> <b>)</b> <b>PT,</b> <b>integer</b> <b>LDPT,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DGBBRD</b>

       <b>Purpose:</b>

            DGBBRD reduces a real general m-by-n band matrix A to upper
            bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.

            The routine computes B, and optionally forms Q or P**T, or computes
            Q**T*C for a given matrix C.

       <b>Parameters</b>
           <u>VECT</u>

                     VECT is CHARACTER*1
                     Specifies whether or not the matrices Q and P**T are to be
                     formed.
                     = 'N': do not form Q or P**T;
                     = 'Q': form Q only;
                     = 'P': form P**T only;
                     = 'B': form both.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>NCC</u>

                     NCC is INTEGER
                     The number of columns of the matrix C.  NCC &gt;= 0.

           <u>KL</u>

                     KL is INTEGER
                     The number of subdiagonals of the matrix A. KL &gt;= 0.

           <u>KU</u>

                     KU is INTEGER
                     The number of superdiagonals of the matrix A. KU &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                     On entry, the m-by-n band matrix A, stored in rows 1 to
                     KL+KU+1. The j-th column of A is stored in the j-th column of
                     the array AB as follows:
                     AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl).
                     On exit, A is overwritten by values generated during the
                     reduction.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array A. LDAB &gt;= KL+KU+1.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (min(M,N))
                     The diagonal elements of the bidiagonal matrix B.

           <u>E</u>

                     E is DOUBLE PRECISION array, dimension (min(M,N)-1)
                     The superdiagonal elements of the bidiagonal matrix B.

           <u>Q</u>

                     Q is DOUBLE PRECISION array, dimension (LDQ,M)
                     If VECT = 'Q' or 'B', the m-by-m orthogonal matrix Q.
                     If VECT = 'N' or 'P', the array Q is not referenced.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= max(1,M) if VECT = 'Q' or 'B'; LDQ &gt;= 1 otherwise.

           <u>PT</u>

                     PT is DOUBLE PRECISION array, dimension (LDPT,N)
                     If VECT = 'P' or 'B', the n-by-n orthogonal matrix P'.
                     If VECT = 'N' or 'Q', the array PT is not referenced.

           <u>LDPT</u>

                     LDPT is INTEGER
                     The leading dimension of the array PT.
                     LDPT &gt;= max(1,N) if VECT = 'P' or 'B'; LDPT &gt;= 1 otherwise.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC,NCC)
                     On entry, an m-by-ncc matrix C.
                     On exit, C is overwritten by Q**T*C.
                     C is not referenced if NCC = 0.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C.
                     LDC &gt;= max(1,M) if NCC &gt; 0; LDC &gt;= 1 if NCC = 0.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (2*max(M,N))

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dgbcon</b> <b>(character</b> <b>NORM,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KL,</b> <b>integer</b> <b>KU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b>
       <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>double</b> <b>precision</b> <b>ANORM,</b> <b>double</b> <b>precision</b> <b>RCOND,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DGBCON</b>

       <b>Purpose:</b>

            DGBCON estimates the reciprocal of the condition number of a real
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by DGBTRF.

            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies whether the 1-norm condition number or the
                     infinity-norm condition number is required:
                     = '1' or 'O':  1-norm;
                     = 'I':         Infinity-norm.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KL</u>

                     KL is INTEGER
                     The number of subdiagonals within the band of A.  KL &gt;= 0.

           <u>KU</u>

                     KU is INTEGER
                     The number of superdiagonals within the band of A.  KU &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                     Details of the LU factorization of the band matrix A, as
                     computed by DGBTRF.  U is stored as an upper triangular band
                     matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
                     the multipliers used during the factorization are stored in
                     rows KL+KU+2 to 2*KL+KU+1.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
                     interchanged with row IPIV(i).

           <u>ANORM</u>

                     ANORM is DOUBLE PRECISION
                     If NORM = '1' or 'O', the 1-norm of the original matrix A.
                     If NORM = 'I', the infinity-norm of the original matrix A.

           <u>RCOND</u>

                     RCOND is DOUBLE PRECISION
                     The reciprocal of the condition number of the matrix A,
                     computed as RCOND = 1/(norm(A) * norm(inv(A))).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (3*N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dgbequ</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KL,</b> <b>integer</b> <b>KU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b>
       <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>R,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>double</b> <b>precision</b>
       <b>ROWCND,</b> <b>double</b> <b>precision</b> <b>COLCND,</b> <b>double</b> <b>precision</b> <b>AMAX,</b> <b>integer</b> <b>INFO)</b>
       <b>DGBEQU</b>

       <b>Purpose:</b>

            DGBEQU computes row and column scalings intended to equilibrate an
            M-by-N band matrix A and reduce its condition number.  R returns the
            row scale factors and C the column scale factors, chosen to try to
            make the largest element in each row and column of the matrix B with
            elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

            R(i) and C(j) are restricted to be between SMLNUM = smallest safe
            number and BIGNUM = largest safe number.  Use of these scaling
            factors is not guaranteed to reduce the condition number of A but
            works well in practice.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>KL</u>

                     KL is INTEGER
                     The number of subdiagonals within the band of A.  KL &gt;= 0.

           <u>KU</u>

                     KU is INTEGER
                     The number of superdiagonals within the band of A.  KU &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                     The band matrix A, stored in rows 1 to KL+KU+1.  The j-th
                     column of A is stored in the j-th column of the array AB as
                     follows:
                     AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl).

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KL+KU+1.

           <u>R</u>

                     R is DOUBLE PRECISION array, dimension (M)
                     If INFO = 0, or INFO &gt; M, R contains the row scale factors
                     for A.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (N)
                     If INFO = 0, C contains the column scale factors for A.

           <u>ROWCND</u>

                     ROWCND is DOUBLE PRECISION
                     If INFO = 0 or INFO &gt; M, ROWCND contains the ratio of the
                     smallest R(i) to the largest R(i).  If ROWCND &gt;= 0.1 and
                     AMAX is neither too large nor too small, it is not worth
                     scaling by R.

           <u>COLCND</u>

                     COLCND is DOUBLE PRECISION
                     If INFO = 0, COLCND contains the ratio of the smallest
                     C(i) to the largest C(i).  If COLCND &gt;= 0.1, it is not
                     worth scaling by C.

           <u>AMAX</u>

                     AMAX is DOUBLE PRECISION
                     Absolute value of largest matrix element.  If AMAX is very
                     close to overflow or very close to underflow, the matrix
                     should be scaled.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, and i is
                           &lt;= M:  the i-th row of A is exactly zero
                           &gt;  M:  the (i-M)-th column of A is exactly zero

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dgbequb</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KL,</b> <b>integer</b> <b>KU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b>
       <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>R,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>double</b> <b>precision</b>
       <b>ROWCND,</b> <b>double</b> <b>precision</b> <b>COLCND,</b> <b>double</b> <b>precision</b> <b>AMAX,</b> <b>integer</b> <b>INFO)</b>
       <b>DGBEQUB</b>

       <b>Purpose:</b>

            DGBEQUB computes row and column scalings intended to equilibrate an
            M-by-N matrix A and reduce its condition number.  R returns the row
            scale factors and C the column scale factors, chosen to try to make
            the largest element in each row and column of the matrix B with
            elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
            the radix.

            R(i) and C(j) are restricted to be a power of the radix between
            SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use
            of these scaling factors is not guaranteed to reduce the condition
            number of A but works well in practice.

            This routine differs from DGEEQU by restricting the scaling factors
            to a power of the radix.  Barring over- and underflow, scaling by
            these factors introduces no additional rounding errors.  However, the
            scaled entries' magnitudes are no longer approximately 1 but lie
            between sqrt(radix) and 1/sqrt(radix).

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>KL</u>

                     KL is INTEGER
                     The number of subdiagonals within the band of A.  KL &gt;= 0.

           <u>KU</u>

                     KU is INTEGER
                     The number of superdiagonals within the band of A.  KU &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                     On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
                     The j-th column of A is stored in the j-th column of the
                     array AB as follows:
                     AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)&lt;=i&lt;=min(N,j+kl)

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array A.  LDAB &gt;= max(1,M).

           <u>R</u>

                     R is DOUBLE PRECISION array, dimension (M)
                     If INFO = 0 or INFO &gt; M, R contains the row scale factors
                     for A.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (N)
                     If INFO = 0,  C contains the column scale factors for A.

           <u>ROWCND</u>

                     ROWCND is DOUBLE PRECISION
                     If INFO = 0 or INFO &gt; M, ROWCND contains the ratio of the
                     smallest R(i) to the largest R(i).  If ROWCND &gt;= 0.1 and
                     AMAX is neither too large nor too small, it is not worth
                     scaling by R.

           <u>COLCND</u>

                     COLCND is DOUBLE PRECISION
                     If INFO = 0, COLCND contains the ratio of the smallest
                     C(i) to the largest C(i).  If COLCND &gt;= 0.1, it is not
                     worth scaling by C.

           <u>AMAX</u>

                     AMAX is DOUBLE PRECISION
                     Absolute value of largest matrix element.  If AMAX is very
                     close to overflow or very close to underflow, the matrix
                     should be scaled.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i,  and i is
                           &lt;= M:  the i-th row of A is exactly zero
                           &gt;  M:  the (i-M)-th column of A is exactly zero

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dgbrfs</b> <b>(character</b> <b>TRANS,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KL,</b> <b>integer</b> <b>KU,</b> <b>integer</b> <b>NRHS,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldafb,</b> <b>*</b> <b>)</b> <b>AFB,</b> <b>integer</b> <b>LDAFB,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>FERR,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>BERR,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DGBRFS</b>

       <b>Purpose:</b>

            DGBRFS improves the computed solution to a system of linear
            equations when the coefficient matrix is banded, and provides
            error bounds and backward error estimates for the solution.

       <b>Parameters</b>
           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the form of the system of equations:
                     = 'N':  A * X = B     (No transpose)
                     = 'T':  A**T * X = B  (Transpose)
                     = 'C':  A**H * X = B  (Conjugate transpose = Transpose)

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KL</u>

                     KL is INTEGER
                     The number of subdiagonals within the band of A.  KL &gt;= 0.

           <u>KU</u>

                     KU is INTEGER
                     The number of superdiagonals within the band of A.  KU &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                     The original band matrix A, stored in rows 1 to KL+KU+1.
                     The j-th column of A is stored in the j-th column of the
                     array AB as follows:
                     AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(n,j+kl).

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KL+KU+1.

           <u>AFB</u>

                     AFB is DOUBLE PRECISION array, dimension (LDAFB,N)
                     Details of the LU factorization of the band matrix A, as
                     computed by DGBTRF.  U is stored as an upper triangular band
                     matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
                     the multipliers used during the factorization are stored in
                     rows KL+KU+2 to 2*KL+KU+1.

           <u>LDAFB</u>

                     LDAFB is INTEGER
                     The leading dimension of the array AFB.  LDAFB &gt;= 2*KL*KU+1.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     The pivot indices from DGBTRF; for 1&lt;=i&lt;=N, row i of the
                     matrix was interchanged with row IPIV(i).

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB,NRHS)
                     The right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (LDX,NRHS)
                     On entry, the solution matrix X, as computed by DGBTRS.
                     On exit, the improved solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>FERR</u>

                     FERR is DOUBLE PRECISION array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is DOUBLE PRECISION array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (3*N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Internal</b> <b>Parameters:</b>

             ITMAX is the maximum number of steps of iterative refinement.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dgbrfsx</b> <b>(character</b> <b>TRANS,</b> <b>character</b> <b>EQUED,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KL,</b> <b>integer</b> <b>KU,</b> <b>integer</b> <b>NRHS,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldafb,</b> <b>*</b> <b>)</b> <b>AFB,</b> <b>integer</b>
       <b>LDAFB,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>R,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>C,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldx</b> <b>,</b> <b>*</b> <b>)</b> <b>X,</b>
       <b>integer</b> <b>LDX,</b> <b>double</b> <b>precision</b> <b>RCOND,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BERR,</b> <b>integer</b> <b>N_ERR_BNDS,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>nrhs,</b> <b>*</b> <b>)</b> <b>ERR_BNDS_NORM,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>nrhs,</b> <b>*</b> <b>)</b> <b>ERR_BNDS_COMP,</b>
       <b>integer</b> <b>NPARAMS,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PARAMS,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DGBRFSX</b>

       <b>Purpose:</b>

               DGBRFSX improves the computed solution to a system of linear
               equations and provides error bounds and backward error estimates
               for the solution.  In addition to normwise error bound, the code
               provides maximum componentwise error bound if possible.  See
               comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
               error bounds.

               The original system of linear equations may have been equilibrated
               before calling this routine, as described by arguments EQUED, R
               and C below. In this case, the solution and error bounds returned
               are for the original unequilibrated system.

                Some optional parameters are bundled in the PARAMS array.  These
                settings determine how refinement is performed, but often the
                defaults are acceptable.  If the defaults are acceptable, users
                can pass NPARAMS = 0 which prevents the source code from accessing
                the PARAMS argument.

       <b>Parameters</b>
           <u>TRANS</u>

                     TRANS is CHARACTER*1
                Specifies the form of the system of equations:
                  = 'N':  A * X = B     (No transpose)
                  = 'T':  A**T * X = B  (Transpose)
                  = 'C':  A**H * X = B  (Conjugate transpose = Transpose)

           <u>EQUED</u>

                     EQUED is CHARACTER*1
                Specifies the form of equilibration that was done to A
                before calling this routine. This is needed to compute
                the solution and error bounds correctly.
                  = 'N':  No equilibration
                  = 'R':  Row equilibration, i.e., A has been premultiplied by
                          diag(R).
                  = 'C':  Column equilibration, i.e., A has been postmultiplied
                          by diag(C).
                  = 'B':  Both row and column equilibration, i.e., A has been
                          replaced by diag(R) * A * diag(C).
                          The right hand side B has been changed accordingly.

           <u>N</u>

                     N is INTEGER
                The order of the matrix A.  N &gt;= 0.

           <u>KL</u>

                     KL is INTEGER
                The number of subdiagonals within the band of A.  KL &gt;= 0.

           <u>KU</u>

                     KU is INTEGER
                The number of superdiagonals within the band of A.  KU &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                The number of right hand sides, i.e., the number of columns
                of the matrices B and X.  NRHS &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                The original band matrix A, stored in rows 1 to KL+KU+1.
                The j-th column of A is stored in the j-th column of the
                array AB as follows:
                AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(n,j+kl).

           <u>LDAB</u>

                     LDAB is INTEGER
                The leading dimension of the array AB.  LDAB &gt;= KL+KU+1.

           <u>AFB</u>

                     AFB is DOUBLE PRECISION array, dimension (LDAFB,N)
                Details of the LU factorization of the band matrix A, as
                computed by DGBTRF.  U is stored as an upper triangular band
                matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
                the multipliers used during the factorization are stored in
                rows KL+KU+2 to 2*KL+KU+1.

           <u>LDAFB</u>

                     LDAFB is INTEGER
                The leading dimension of the array AFB.  LDAFB &gt;= 2*KL*KU+1.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the
                matrix was interchanged with row IPIV(i).

           <u>R</u>

                     R is DOUBLE PRECISION array, dimension (N)
                The row scale factors for A.  If EQUED = 'R' or 'B', A is
                multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
                is not accessed.  R is an input argument if FACT = 'F';
                otherwise, R is an output argument.  If FACT = 'F' and
                EQUED = 'R' or 'B', each element of R must be positive.
                If R is output, each element of R is a power of the radix.
                If R is input, each element of R should be a power of the radix
                to ensure a reliable solution and error estimates. Scaling by
                powers of the radix does not cause rounding errors unless the
                result underflows or overflows. Rounding errors during scaling
                lead to refining with a matrix that is not equivalent to the
                input matrix, producing error estimates that may not be
                reliable.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (N)
                The column scale factors for A.  If EQUED = 'C' or 'B', A is
                multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
                is not accessed.  C is an input argument if FACT = 'F';
                otherwise, C is an output argument.  If FACT = 'F' and
                EQUED = 'C' or 'B', each element of C must be positive.
                If C is output, each element of C is a power of the radix.
                If C is input, each element of C should be a power of the radix
                to ensure a reliable solution and error estimates. Scaling by
                powers of the radix does not cause rounding errors unless the
                result underflows or overflows. Rounding errors during scaling
                lead to refining with a matrix that is not equivalent to the
                input matrix, producing error estimates that may not be
                reliable.

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB,NRHS)
                The right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (LDX,NRHS)
                On entry, the solution matrix X, as computed by DGETRS.
                On exit, the improved solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>RCOND</u>

                     RCOND is DOUBLE PRECISION
                Reciprocal scaled condition number.  This is an estimate of the
                reciprocal Skeel condition number of the matrix A after
                equilibration (if done).  If this is less than the machine
                precision (in particular, if it is zero), the matrix is singular
                to working precision.  Note that the error may still be small even
                if this number is very small and the matrix appears ill-
                conditioned.

           <u>BERR</u>

                     BERR is DOUBLE PRECISION array, dimension (NRHS)
                Componentwise relative backward error.  This is the
                componentwise relative backward error of each solution vector X(j)
                (i.e., the smallest relative change in any element of A or B that
                makes X(j) an exact solution).

           <u>N_ERR_BNDS</u>

                     N_ERR_BNDS is INTEGER
                Number of error bounds to return for each right hand side
                and each type (normwise or componentwise).  See ERR_BNDS_NORM and
                ERR_BNDS_COMP below.

           <u>ERR_BNDS_NORM</u>

                     ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)
                For each right-hand side, this array contains information about
                various error bounds and condition numbers corresponding to the
                normwise relative error, which is defined as follows:

                Normwise relative error in the ith solution vector:
                        max_j (abs(XTRUE(j,i) - X(j,i)))
                       ------------------------------
                             max_j abs(X(j,i))

                The array is indexed by the type of error information as described
                below. There currently are up to three pieces of information
                returned.

                The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
                right-hand side.

                The second index in ERR_BNDS_NORM(:,err) contains the following
                three fields:
                err = 1 "Trust/don't trust" boolean. Trust the answer if the
                         reciprocal condition number is less than the threshold
                         sqrt(n) * dlamch('Epsilon').

                err = 2 "Guaranteed" error bound: The estimated forward error,
                         almost certainly within a factor of 10 of the true error
                         so long as the next entry is greater than the threshold
                         sqrt(n) * dlamch('Epsilon'). This error bound should only
                         be trusted if the previous boolean is true.

                err = 3  Reciprocal condition number: Estimated normwise
                         reciprocal condition number.  Compared with the threshold
                         sqrt(n) * dlamch('Epsilon') to determine if the error
                         estimate is "guaranteed". These reciprocal condition
                         numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                         appropriately scaled matrix Z.
                         Let Z = S*A, where S scales each row by a power of the
                         radix so all absolute row sums of Z are approximately 1.

                See Lapack Working Note 165 for further details and extra
                cautions.

           <u>ERR_BNDS_COMP</u>

                     ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)
                For each right-hand side, this array contains information about
                various error bounds and condition numbers corresponding to the
                componentwise relative error, which is defined as follows:

                Componentwise relative error in the ith solution vector:
                               abs(XTRUE(j,i) - X(j,i))
                        max_j ----------------------
                                    abs(X(j,i))

                The array is indexed by the right-hand side i (on which the
                componentwise relative error depends), and the type of error
                information as described below. There currently are up to three
                pieces of information returned for each right-hand side. If
                componentwise accuracy is not requested (<a href="../man3/PARAMS.3.html">PARAMS</a>(3) = 0.0), then
                ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS &lt; 3, then at most
                the first (:,N_ERR_BNDS) entries are returned.

                The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
                right-hand side.

                The second index in ERR_BNDS_COMP(:,err) contains the following
                three fields:
                err = 1 "Trust/don't trust" boolean. Trust the answer if the
                         reciprocal condition number is less than the threshold
                         sqrt(n) * dlamch('Epsilon').

                err = 2 "Guaranteed" error bound: The estimated forward error,
                         almost certainly within a factor of 10 of the true error
                         so long as the next entry is greater than the threshold
                         sqrt(n) * dlamch('Epsilon'). This error bound should only
                         be trusted if the previous boolean is true.

                err = 3  Reciprocal condition number: Estimated componentwise
                         reciprocal condition number.  Compared with the threshold
                         sqrt(n) * dlamch('Epsilon') to determine if the error
                         estimate is "guaranteed". These reciprocal condition
                         numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                         appropriately scaled matrix Z.
                         Let Z = S*(A*diag(x)), where x is the solution for the
                         current right-hand side and S scales each row of
                         A*diag(x) by a power of the radix so all absolute row
                         sums of Z are approximately 1.

                See Lapack Working Note 165 for further details and extra
                cautions.

           <u>NPARAMS</u>

                     NPARAMS is INTEGER
                Specifies the number of parameters set in PARAMS.  If &lt;= 0, the
                PARAMS array is never referenced and default values are used.

           <u>PARAMS</u>

                     PARAMS is DOUBLE PRECISION array, dimension (NPARAMS)
                Specifies algorithm parameters.  If an entry is &lt; 0.0, then
                that entry will be filled with default value used for that
                parameter.  Only positions up to NPARAMS are accessed; defaults
                are used for higher-numbered parameters.

                  PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
                       refinement or not.
                    Default: 1.0D+0
                       = 0.0:  No refinement is performed, and no error bounds are
                               computed.
                       = 1.0:  Use the double-precision refinement algorithm,
                               possibly with doubled-single computations if the
                               compilation environment does not support DOUBLE
                               PRECISION.
                         (other values are reserved for future use)

                  PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
                       computations allowed for refinement.
                    Default: 10
                    Aggressive: Set to 100 to permit convergence using approximate
                                factorizations or factorizations other than LU. If
                                the factorization uses a technique other than
                                Gaussian elimination, the guarantees in
                                err_bnds_norm and err_bnds_comp may no longer be
                                trustworthy.

                  PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
                       will attempt to find a solution with small componentwise
                       relative error in the double-precision algorithm.  Positive
                       is true, 0.0 is false.
                    Default: 1.0 (attempt componentwise convergence)

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (4*N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                  = 0:  Successful exit. The solution to every right-hand side is
                    guaranteed.
                  &lt; 0:  If INFO = -i, the i-th argument had an illegal value
                  &gt; 0 and &lt;= N:  U(INFO,INFO) is exactly zero.  The factorization
                    has been completed, but the factor U is exactly singular, so
                    the solution and error bounds could not be computed. RCOND = 0
                    is returned.
                  = N+J: The solution corresponding to the Jth right-hand side is
                    not guaranteed. The solutions corresponding to other right-
                    hand sides K with K &gt; J may not be guaranteed as well, but
                    only the first such right-hand side is reported. If a small
                    componentwise error is not requested (<a href="../man3/PARAMS.3.html">PARAMS</a>(3) = 0.0) then
                    the Jth right-hand side is the first with a normwise error
                    bound that is not guaranteed (the smallest J such
                    that ERR_BNDS_NORM(J,1) = 0.0). By default (<a href="../man3/PARAMS.3.html">PARAMS</a>(3) = 1.0)
                    the Jth right-hand side is the first with either a normwise or
                    componentwise error bound that is not guaranteed (the smallest
                    J such that either ERR_BNDS_NORM(J,1) = 0.0 or
                    ERR_BNDS_COMP(J,1) = 0.0). See the definition of
                    ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information
                    about all of the right-hand sides check ERR_BNDS_NORM or
                    ERR_BNDS_COMP.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dgbtf2</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KL,</b> <b>integer</b> <b>KU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b>
       <b>integer</b> <b>LDAB,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>integer</b> <b>INFO)</b>
       <b>DGBTF2</b> computes the LU factorization of a general band matrix using the unblocked version of the
       algorithm.

       <b>Purpose:</b>

            DGBTF2 computes an LU factorization of a real m-by-n band matrix A
            using partial pivoting with row interchanges.

            This is the unblocked version of the algorithm, calling Level 2 BLAS.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>KL</u>

                     KL is INTEGER
                     The number of subdiagonals within the band of A.  KL &gt;= 0.

           <u>KU</u>

                     KU is INTEGER
                     The number of superdiagonals within the band of A.  KU &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                     On entry, the matrix A in band storage, in rows KL+1 to
                     2*KL+KU+1; rows 1 to KL of the array need not be set.
                     The j-th column of A is stored in the j-th column of the
                     array AB as follows:
                     AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)

                     On exit, details of the factorization: U is stored as an
                     upper triangular band matrix with KL+KU superdiagonals in
                     rows 1 to KL+KU+1, and the multipliers used during the
                     factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
                     See below for further details.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (min(M,N))
                     The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
                     matrix was interchanged with row IPIV(i).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                          has been completed, but the factor U is exactly
                          singular, and division by zero will occur if it is used
                          to solve a system of equations.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The band storage scheme is illustrated by the following example, when
             M = N = 6, KL = 2, KU = 1:

             On entry:                       On exit:

                 *    *    *    +    +    +       *    *    *   u14  u25  u36
                 *    *    +    +    +    +       *    *   u13  u24  u35  u46
                 *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
                a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
                a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
                a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *

             Array elements marked * are not used by the routine; elements marked
             + need not be set on entry, but are required by the routine to store
             elements of U, because of fill-in resulting from the row
             interchanges.

   <b>subroutine</b> <b>dgbtrf</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KL,</b> <b>integer</b> <b>KU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b>
       <b>integer</b> <b>LDAB,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>integer</b> <b>INFO)</b>
       <b>DGBTRF</b>

       <b>Purpose:</b>

            DGBTRF computes an LU factorization of a real m-by-n band matrix A
            using partial pivoting with row interchanges.

            This is the blocked version of the algorithm, calling Level 3 BLAS.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>KL</u>

                     KL is INTEGER
                     The number of subdiagonals within the band of A.  KL &gt;= 0.

           <u>KU</u>

                     KU is INTEGER
                     The number of superdiagonals within the band of A.  KU &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                     On entry, the matrix A in band storage, in rows KL+1 to
                     2*KL+KU+1; rows 1 to KL of the array need not be set.
                     The j-th column of A is stored in the j-th column of the
                     array AB as follows:
                     AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)

                     On exit, details of the factorization: U is stored as an
                     upper triangular band matrix with KL+KU superdiagonals in
                     rows 1 to KL+KU+1, and the multipliers used during the
                     factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
                     See below for further details.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (min(M,N))
                     The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
                     matrix was interchanged with row IPIV(i).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                          has been completed, but the factor U is exactly
                          singular, and division by zero will occur if it is used
                          to solve a system of equations.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The band storage scheme is illustrated by the following example, when
             M = N = 6, KL = 2, KU = 1:

             On entry:                       On exit:

                 *    *    *    +    +    +       *    *    *   u14  u25  u36
                 *    *    +    +    +    +       *    *   u13  u24  u35  u46
                 *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
                a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
                a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
                a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *

             Array elements marked * are not used by the routine; elements marked
             + need not be set on entry, but are required by the routine to store
             elements of U because of fill-in resulting from the row interchanges.

   <b>subroutine</b> <b>dgbtrs</b> <b>(character</b> <b>TRANS,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KL,</b> <b>integer</b> <b>KU,</b> <b>integer</b> <b>NRHS,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b>
       <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>integer</b> <b>INFO)</b>
       <b>DGBTRS</b>

       <b>Purpose:</b>

            DGBTRS solves a system of linear equations
               A * X = B  or  A**T * X = B
            with a general band matrix A using the LU factorization computed
            by DGBTRF.

       <b>Parameters</b>
           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the form of the system of equations.
                     = 'N':  A * X = B  (No transpose)
                     = 'T':  A**T* X = B  (Transpose)
                     = 'C':  A**T* X = B  (Conjugate transpose = Transpose)

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KL</u>

                     KL is INTEGER
                     The number of subdiagonals within the band of A.  KL &gt;= 0.

           <u>KU</u>

                     KU is INTEGER
                     The number of superdiagonals within the band of A.  KU &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrix B.  NRHS &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                     Details of the LU factorization of the band matrix A, as
                     computed by DGBTRF.  U is stored as an upper triangular band
                     matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
                     the multipliers used during the factorization are stored in
                     rows KL+KU+2 to 2*KL+KU+1.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
                     interchanged with row IPIV(i).

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB,NRHS)
                     On entry, the right hand side matrix B.
                     On exit, the solution matrix X.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dggbak</b> <b>(character</b> <b>JOB,</b> <b>character</b> <b>SIDE,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>LSCALE,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RSCALE,</b> <b>integer</b> <b>M,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>integer</b> <b>INFO)</b>
       <b>DGGBAK</b>

       <b>Purpose:</b>

            DGGBAK forms the right or left eigenvectors of a real generalized
            eigenvalue problem A*x = lambda*B*x, by backward transformation on
            the computed eigenvectors of the balanced pair of matrices output by
            DGGBAL.

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is CHARACTER*1
                     Specifies the type of backward transformation required:
                     = 'N':  do nothing, return immediately;
                     = 'P':  do backward transformation for permutation only;
                     = 'S':  do backward transformation for scaling only;
                     = 'B':  do backward transformations for both permutation and
                             scaling.
                     JOB must be the same as the argument JOB supplied to DGGBAL.

           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'R':  V contains right eigenvectors;
                     = 'L':  V contains left eigenvectors.

           <u>N</u>

                     N is INTEGER
                     The number of rows of the matrix V.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER
                     The integers ILO and IHI determined by DGGBAL.
                     1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.

           <u>LSCALE</u>

                     LSCALE is DOUBLE PRECISION array, dimension (N)
                     Details of the permutations and/or scaling factors applied
                     to the left side of A and B, as returned by DGGBAL.

           <u>RSCALE</u>

                     RSCALE is DOUBLE PRECISION array, dimension (N)
                     Details of the permutations and/or scaling factors applied
                     to the right side of A and B, as returned by DGGBAL.

           <u>M</u>

                     M is INTEGER
                     The number of columns of the matrix V.  M &gt;= 0.

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension (LDV,M)
                     On entry, the matrix of right or left eigenvectors to be
                     transformed, as returned by DTGEVC.
                     On exit, V is overwritten by the transformed eigenvectors.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the matrix V. LDV &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             See R.C. Ward, Balancing the generalized eigenvalue problem,
                            SIAM J. Sci. Stat. Comp. 2 (1981), 141-152.

   <b>subroutine</b> <b>dggbal</b> <b>(character</b> <b>JOB,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>LSCALE,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RSCALE,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DGGBAL</b>

       <b>Purpose:</b>

            DGGBAL balances a pair of general real matrices (A,B).  This
            involves, first, permuting A and B by similarity transformations to
            isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
            elements on the diagonal; and second, applying a diagonal similarity
            transformation to rows and columns ILO to IHI to make the rows
            and columns as close in norm as possible. Both steps are optional.

            Balancing may reduce the 1-norm of the matrices, and improve the
            accuracy of the computed eigenvalues and/or eigenvectors in the
            generalized eigenvalue problem A*x = lambda*B*x.

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is CHARACTER*1
                     Specifies the operations to be performed on A and B:
                     = 'N':  none:  simply set ILO = 1, IHI = N, LSCALE(I) = 1.0
                             and RSCALE(I) = 1.0 for i = 1,...,N.
                     = 'P':  permute only;
                     = 'S':  scale only;
                     = 'B':  both permute and scale.

           <u>N</u>

                     N is INTEGER
                     The order of the matrices A and B.  N &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     On entry, the input matrix A.
                     On exit,  A is overwritten by the balanced matrix.
                     If JOB = 'N', A is not referenced.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,N).

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB,N)
                     On entry, the input matrix B.
                     On exit,  B is overwritten by the balanced matrix.
                     If JOB = 'N', B is not referenced.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,N).

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER
                     ILO and IHI are set to integers such that on exit
                     A(i,j) = 0 and B(i,j) = 0 if i &gt; j and
                     j = 1,...,ILO-1 or i = IHI+1,...,N.
                     If JOB = 'N' or 'S', ILO = 1 and IHI = N.

           <u>LSCALE</u>

                     LSCALE is DOUBLE PRECISION array, dimension (N)
                     Details of the permutations and scaling factors applied
                     to the left side of A and B.  If P(j) is the index of the
                     row interchanged with row j, and D(j)
                     is the scaling factor applied to row j, then
                       LSCALE(j) = P(j)    for J = 1,...,ILO-1
                                 = D(j)    for J = ILO,...,IHI
                                 = P(j)    for J = IHI+1,...,N.
                     The order in which the interchanges are made is N to IHI+1,
                     then 1 to ILO-1.

           <u>RSCALE</u>

                     RSCALE is DOUBLE PRECISION array, dimension (N)
                     Details of the permutations and scaling factors applied
                     to the right side of A and B.  If P(j) is the index of the
                     column interchanged with column j, and D(j)
                     is the scaling factor applied to column j, then
                       LSCALE(j) = P(j)    for J = 1,...,ILO-1
                                 = D(j)    for J = ILO,...,IHI
                                 = P(j)    for J = IHI+1,...,N.
                     The order in which the interchanges are made is N to IHI+1,
                     then 1 to ILO-1.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (lwork)
                     lwork must be at least max(1,6*N) when JOB = 'S' or 'B', and
                     at least 1 when JOB = 'N' or 'P'.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             See R.C. WARD, Balancing the generalized eigenvalue problem,
                            SIAM J. Sci. Stat. Comp. 2 (1981), 141-152.

   <b>subroutine</b> <b>dla_gbamv</b> <b>(integer</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KL,</b> <b>integer</b> <b>KU,</b> <b>double</b> <b>precision</b> <b>ALPHA,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b>
       <b>INCX,</b> <b>double</b> <b>precision</b> <b>BETA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Y,</b> <b>integer</b> <b>INCY)</b>
       <b>DLA_GBAMV</b> performs a matrix-vector operation to calculate error bounds.

       <b>Purpose:</b>

            DLA_GBAMV  performs one of the matrix-vector operations

                    y := alpha*abs(A)*abs(x) + beta*abs(y),
               or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),

            where alpha and beta are scalars, x and y are vectors and A is an
            m by n matrix.

            This function is primarily used in calculating error bounds.
            To protect against underflow during evaluation, components in
            the resulting vector are perturbed away from zero by (N+1)
            times the underflow threshold.  To prevent unnecessarily large
            errors for block-structure embedded in general matrices,
            "symbolically" zero components are not perturbed.  A zero
            entry is considered "symbolic" if all multiplications involved
            in computing that entry have at least one zero multiplicand.

       <b>Parameters</b>
           <u>TRANS</u>

                     TRANS is INTEGER
                      On entry, TRANS specifies the operation to be performed as
                      follows:

                        BLAS_NO_TRANS      y := alpha*abs(A)*abs(x) + beta*abs(y)
                        BLAS_TRANS         y := alpha*abs(A**T)*abs(x) + beta*abs(y)
                        BLAS_CONJ_TRANS    y := alpha*abs(A**T)*abs(x) + beta*abs(y)

                      Unchanged on exit.

           <u>M</u>

                     M is INTEGER
                      On entry, M specifies the number of rows of the matrix A.
                      M must be at least zero.
                      Unchanged on exit.

           <u>N</u>

                     N is INTEGER
                      On entry, N specifies the number of columns of the matrix A.
                      N must be at least zero.
                      Unchanged on exit.

           <u>KL</u>

                     KL is INTEGER
                      The number of subdiagonals within the band of A.  KL &gt;= 0.

           <u>KU</u>

                     KU is INTEGER
                      The number of superdiagonals within the band of A.  KU &gt;= 0.

           <u>ALPHA</u>

                     ALPHA is DOUBLE PRECISION
                      On entry, ALPHA specifies the scalar alpha.
                      Unchanged on exit.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension ( LDAB, n )
                      Before entry, the leading m by n part of the array AB must
                      contain the matrix of coefficients.
                      Unchanged on exit.

           <u>LDAB</u>

                     LDAB is INTEGER
                      On entry, LDA specifies the first dimension of AB as declared
                      in the calling (sub) program. LDAB must be at least
                      max( 1, m ).
                      Unchanged on exit.

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension
                      ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
                      and at least
                      ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
                      Before entry, the incremented array X must contain the
                      vector x.
                      Unchanged on exit.

           <u>INCX</u>

                     INCX is INTEGER
                      On entry, INCX specifies the increment for the elements of
                      X. INCX must not be zero.
                      Unchanged on exit.

           <u>BETA</u>

                     BETA is DOUBLE PRECISION
                      On entry, BETA specifies the scalar beta. When BETA is
                      supplied as zero then Y need not be set on input.
                      Unchanged on exit.

           <u>Y</u>

                     Y is DOUBLE PRECISION array, dimension
                      ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
                      and at least
                      ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
                      Before entry with BETA non-zero, the incremented array Y
                      must contain the vector y. On exit, Y is overwritten by the
                      updated vector y.

           <u>INCY</u>

                     INCY is INTEGER
                      On entry, INCY specifies the increment for the elements of
                      Y. INCY must not be zero.
                      Unchanged on exit.

             Level 2 Blas routine.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>dla_gbrcond</b> <b>(character</b> <b>TRANS,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KL,</b> <b>integer</b> <b>KU,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldafb,</b> <b>*</b> <b>)</b> <b>AFB,</b> <b>integer</b> <b>LDAFB,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>integer</b> <b>CMODE,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>INFO,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK)</b>
       <b>DLA_GBRCOND</b> estimates the Skeel condition number for a general banded matrix.

       <b>Purpose:</b>

               DLA_GBRCOND Estimates the Skeel condition number of  op(A) * op2(C)
               where op2 is determined by CMODE as follows
               CMODE =  1    op2(C) = C
               CMODE =  0    op2(C) = I
               CMODE = -1    op2(C) = inv(C)
               The Skeel condition number  cond(A) = norminf( |inv(A)||A| )
               is computed by computing scaling factors R such that
               diag(R)*A*op2(C) is row equilibrated and computing the standard
               infinity-norm condition number.

       <b>Parameters</b>
           <u>TRANS</u>

                     TRANS is CHARACTER*1
                Specifies the form of the system of equations:
                  = 'N':  A * X = B     (No transpose)
                  = 'T':  A**T * X = B  (Transpose)
                  = 'C':  A**H * X = B  (Conjugate Transpose = Transpose)

           <u>N</u>

                     N is INTEGER
                The number of linear equations, i.e., the order of the
                matrix A.  N &gt;= 0.

           <u>KL</u>

                     KL is INTEGER
                The number of subdiagonals within the band of A.  KL &gt;= 0.

           <u>KU</u>

                     KU is INTEGER
                The number of superdiagonals within the band of A.  KU &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
                The j-th column of A is stored in the j-th column of the
                array AB as follows:
                AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)&lt;=i&lt;=min(N,j+kl)

           <u>LDAB</u>

                     LDAB is INTEGER
                The leading dimension of the array AB.  LDAB &gt;= KL+KU+1.

           <u>AFB</u>

                     AFB is DOUBLE PRECISION array, dimension (LDAFB,N)
                Details of the LU factorization of the band matrix A, as
                computed by DGBTRF.  U is stored as an upper triangular
                band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,
                and the multipliers used during the factorization are stored
                in rows KL+KU+2 to 2*KL+KU+1.

           <u>LDAFB</u>

                     LDAFB is INTEGER
                The leading dimension of the array AFB.  LDAFB &gt;= 2*KL+KU+1.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                The pivot indices from the factorization A = P*L*U
                as computed by DGBTRF; row i of the matrix was interchanged
                with row IPIV(i).

           <u>CMODE</u>

                     CMODE is INTEGER
                Determines op2(C) in the formula op(A) * op2(C) as follows:
                CMODE =  1    op2(C) = C
                CMODE =  0    op2(C) = I
                CMODE = -1    op2(C) = inv(C)

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (N)
                The vector C in the formula op(A) * op2(C).

           <u>INFO</u>

                     INFO is INTEGER
                  = 0:  Successful exit.
                i &gt; 0:  The ith argument is invalid.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (5*N).
                Workspace.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (N).
                Workspace.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dla_gbrfsx_extended</b> <b>(integer</b> <b>PREC_TYPE,</b> <b>integer</b> <b>TRANS_TYPE,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KL,</b> <b>integer</b> <b>KU,</b>
       <b>integer</b> <b>NRHS,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>ldafb,</b> <b>*</b> <b>)</b> <b>AFB,</b> <b>integer</b> <b>LDAFB,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>logical</b> <b>COLEQU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>C,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldy,</b> <b>*</b> <b>)</b> <b>Y,</b>
       <b>integer</b> <b>LDY,</b> <b>double</b> <b>precision,</b> <b>dimension(*)</b> <b>BERR_OUT,</b> <b>integer</b> <b>N_NORMS,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>nrhs,</b>
       <b>*</b> <b>)</b> <b>ERR_BNDS_NORM,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>nrhs,</b> <b>*</b> <b>)</b> <b>ERR_BNDS_COMP,</b> <b>double</b> <b>precision,</b> <b>dimension(*)</b>
       <b>RES,</b> <b>double</b> <b>precision,</b> <b>dimension(*)</b> <b>AYB,</b> <b>double</b> <b>precision,</b> <b>dimension(*)</b> <b>DY,</b> <b>double</b> <b>precision,</b>
       <b>dimension(*)</b> <b>Y_TAIL,</b> <b>double</b> <b>precision</b> <b>RCOND,</b> <b>integer</b> <b>ITHRESH,</b> <b>double</b> <b>precision</b> <b>RTHRESH,</b> <b>double</b> <b>precision</b>
       <b>DZ_UB,</b> <b>logical</b> <b>IGNORE_CWISE,</b> <b>integer</b> <b>INFO)</b>
       <b>DLA_GBRFSX_EXTENDED</b> improves the computed solution to a system of linear equations for general banded
       matrices by performing extra-precise iterative refinement and provides error bounds and backward error
       estimates for the solution.

       <b>Purpose:</b>

            DLA_GBRFSX_EXTENDED improves the computed solution to a system of
            linear equations by performing extra-precise iterative refinement
            and provides error bounds and backward error estimates for the solution.
            This subroutine is called by DGBRFSX to perform iterative refinement.
            In addition to normwise error bound, the code provides maximum
            componentwise error bound if possible. See comments for ERR_BNDS_NORM
            and ERR_BNDS_COMP for details of the error bounds. Note that this
            subroutine is only resonsible for setting the second fields of
            ERR_BNDS_NORM and ERR_BNDS_COMP.

       <b>Parameters</b>
           <u>PREC_TYPE</u>

                     PREC_TYPE is INTEGER
                Specifies the intermediate precision to be used in refinement.
                The value is defined by ILAPREC(P) where P is a CHARACTER and P
                     = 'S':  Single
                     = 'D':  Double
                     = 'I':  Indigenous
                     = 'X' or 'E':  Extra

           <u>TRANS_TYPE</u>

                     TRANS_TYPE is INTEGER
                Specifies the transposition operation on A.
                The value is defined by ILATRANS(T) where T is a CHARACTER and T
                     = 'N':  No transpose
                     = 'T':  Transpose
                     = 'C':  Conjugate transpose

           <u>N</u>

                     N is INTEGER
                The number of linear equations, i.e., the order of the
                matrix A.  N &gt;= 0.

           <u>KL</u>

                     KL is INTEGER
                The number of subdiagonals within the band of A.  KL &gt;= 0.

           <u>KU</u>

                     KU is INTEGER
                The number of superdiagonals within the band of A.  KU &gt;= 0

           <u>NRHS</u>

                     NRHS is INTEGER
                The number of right-hand-sides, i.e., the number of columns of the
                matrix B.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                     On entry, the N-by-N matrix AB.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDBA &gt;= max(1,N).

           <u>AFB</u>

                     AFB is DOUBLE PRECISION array, dimension (LDAFB,N)
                The factors L and U from the factorization
                A = P*L*U as computed by DGBTRF.

           <u>LDAFB</u>

                     LDAFB is INTEGER
                The leading dimension of the array AF.  LDAFB &gt;= max(1,N).

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                The pivot indices from the factorization A = P*L*U
                as computed by DGBTRF; row i of the matrix was interchanged
                with row IPIV(i).

           <u>COLEQU</u>

                     COLEQU is LOGICAL
                If .TRUE. then column equilibration was done to A before calling
                this routine. This is needed to compute the solution and error
                bounds correctly.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (N)
                The column scale factors for A. If COLEQU = .FALSE., C
                is not accessed. If C is input, each element of C should be a power
                of the radix to ensure a reliable solution and error estimates.
                Scaling by powers of the radix does not cause rounding errors unless
                the result underflows or overflows. Rounding errors during scaling
                lead to refining with a matrix that is not equivalent to the
                input matrix, producing error estimates that may not be
                reliable.

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB,NRHS)
                The right-hand-side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>Y</u>

                     Y is DOUBLE PRECISION array, dimension (LDY,NRHS)
                On entry, the solution matrix X, as computed by DGBTRS.
                On exit, the improved solution matrix Y.

           <u>LDY</u>

                     LDY is INTEGER
                The leading dimension of the array Y.  LDY &gt;= max(1,N).

           <u>BERR_OUT</u>

                     BERR_OUT is DOUBLE PRECISION array, dimension (NRHS)
                On exit, BERR_OUT(j) contains the componentwise relative backward
                error for right-hand-side j from the formula
                    max(i) ( abs(RES(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i) )
                where abs(Z) is the componentwise absolute value of the matrix
                or vector Z. This is computed by DLA_LIN_BERR.

           <u>N_NORMS</u>

                     N_NORMS is INTEGER
                Determines which error bounds to return (see ERR_BNDS_NORM
                and ERR_BNDS_COMP).
                If N_NORMS &gt;= 1 return normwise error bounds.
                If N_NORMS &gt;= 2 return componentwise error bounds.

           <u>ERR_BNDS_NORM</u>

                     ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)
                For each right-hand side, this array contains information about
                various error bounds and condition numbers corresponding to the
                normwise relative error, which is defined as follows:

                Normwise relative error in the ith solution vector:
                        max_j (abs(XTRUE(j,i) - X(j,i)))
                       ------------------------------
                             max_j abs(X(j,i))

                The array is indexed by the type of error information as described
                below. There currently are up to three pieces of information
                returned.

                The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
                right-hand side.

                The second index in ERR_BNDS_NORM(:,err) contains the following
                three fields:
                err = 1 "Trust/don't trust" boolean. Trust the answer if the
                         reciprocal condition number is less than the threshold
                         sqrt(n) * slamch('Epsilon').

                err = 2 "Guaranteed" error bound: The estimated forward error,
                         almost certainly within a factor of 10 of the true error
                         so long as the next entry is greater than the threshold
                         sqrt(n) * slamch('Epsilon'). This error bound should only
                         be trusted if the previous boolean is true.

                err = 3  Reciprocal condition number: Estimated normwise
                         reciprocal condition number.  Compared with the threshold
                         sqrt(n) * slamch('Epsilon') to determine if the error
                         estimate is "guaranteed". These reciprocal condition
                         numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                         appropriately scaled matrix Z.
                         Let Z = S*A, where S scales each row by a power of the
                         radix so all absolute row sums of Z are approximately 1.

                This subroutine is only responsible for setting the second field
                above.
                See Lapack Working Note 165 for further details and extra
                cautions.

           <u>ERR_BNDS_COMP</u>

                     ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)
                For each right-hand side, this array contains information about
                various error bounds and condition numbers corresponding to the
                componentwise relative error, which is defined as follows:

                Componentwise relative error in the ith solution vector:
                               abs(XTRUE(j,i) - X(j,i))
                        max_j ----------------------
                                    abs(X(j,i))

                The array is indexed by the right-hand side i (on which the
                componentwise relative error depends), and the type of error
                information as described below. There currently are up to three
                pieces of information returned for each right-hand side. If
                componentwise accuracy is not requested (<a href="../man3/PARAMS.3.html">PARAMS</a>(3) = 0.0), then
                ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS &lt; 3, then at most
                the first (:,N_ERR_BNDS) entries are returned.

                The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
                right-hand side.

                The second index in ERR_BNDS_COMP(:,err) contains the following
                three fields:
                err = 1 "Trust/don't trust" boolean. Trust the answer if the
                         reciprocal condition number is less than the threshold
                         sqrt(n) * slamch('Epsilon').

                err = 2 "Guaranteed" error bound: The estimated forward error,
                         almost certainly within a factor of 10 of the true error
                         so long as the next entry is greater than the threshold
                         sqrt(n) * slamch('Epsilon'). This error bound should only
                         be trusted if the previous boolean is true.

                err = 3  Reciprocal condition number: Estimated componentwise
                         reciprocal condition number.  Compared with the threshold
                         sqrt(n) * slamch('Epsilon') to determine if the error
                         estimate is "guaranteed". These reciprocal condition
                         numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
                         appropriately scaled matrix Z.
                         Let Z = S*(A*diag(x)), where x is the solution for the
                         current right-hand side and S scales each row of
                         A*diag(x) by a power of the radix so all absolute row
                         sums of Z are approximately 1.

                This subroutine is only responsible for setting the second field
                above.
                See Lapack Working Note 165 for further details and extra
                cautions.

           <u>RES</u>

                     RES is DOUBLE PRECISION array, dimension (N)
                Workspace to hold the intermediate residual.

           <u>AYB</u>

                     AYB is DOUBLE PRECISION array, dimension (N)
                Workspace. This can be the same workspace passed for Y_TAIL.

           <u>DY</u>

                     DY is DOUBLE PRECISION array, dimension (N)
                Workspace to hold the intermediate solution.

           <u>Y_TAIL</u>

                     Y_TAIL is DOUBLE PRECISION array, dimension (N)
                Workspace to hold the trailing bits of the intermediate solution.

           <u>RCOND</u>

                     RCOND is DOUBLE PRECISION
                Reciprocal scaled condition number.  This is an estimate of the
                reciprocal Skeel condition number of the matrix A after
                equilibration (if done).  If this is less than the machine
                precision (in particular, if it is zero), the matrix is singular
                to working precision.  Note that the error may still be small even
                if this number is very small and the matrix appears ill-
                conditioned.

           <u>ITHRESH</u>

                     ITHRESH is INTEGER
                The maximum number of residual computations allowed for
                refinement. The default is 10. For 'aggressive' set to 100 to
                permit convergence using approximate factorizations or
                factorizations other than LU. If the factorization uses a
                technique other than Gaussian elimination, the guarantees in
                ERR_BNDS_NORM and ERR_BNDS_COMP may no longer be trustworthy.

           <u>RTHRESH</u>

                     RTHRESH is DOUBLE PRECISION
                Determines when to stop refinement if the error estimate stops
                decreasing. Refinement will stop when the next solution no longer
                satisfies norm(dx_{i+1}) &lt; RTHRESH * norm(dx_i) where norm(Z) is
                the infinity norm of Z. RTHRESH satisfies 0 &lt; RTHRESH &lt;= 1. The
                default value is 0.5. For 'aggressive' set to 0.9 to permit
                convergence on extremely ill-conditioned matrices. See LAWN 165
                for more details.

           <u>DZ_UB</u>

                     DZ_UB is DOUBLE PRECISION
                Determines when to start considering componentwise convergence.
                Componentwise convergence is only considered after each component
                of the solution Y is stable, which we define as the relative
                change in each component being less than DZ_UB. The default value
                is 0.25, requiring the first bit to be stable. See LAWN 165 for
                more details.

           <u>IGNORE_CWISE</u>

                     IGNORE_CWISE is LOGICAL
                If .TRUE. then ignore componentwise convergence. Default value
                is .FALSE..

           <u>INFO</u>

                     INFO is INTEGER
                  = 0:  Successful exit.
                  &lt; 0:  if INFO = -i, the ith argument to DGBTRS had an illegal
                        value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>dla_gbrpvgrw</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>KL,</b> <b>integer</b> <b>KU,</b> <b>integer</b> <b>NCOLS,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldafb,</b> <b>*</b> <b>)</b> <b>AFB,</b> <b>integer</b> <b>LDAFB)</b>
       <b>DLA_GBRPVGRW</b> computes the reciprocal pivot growth factor norm(A)/norm(U) for a general banded matrix.

       <b>Purpose:</b>

            DLA_GBRPVGRW computes the reciprocal pivot growth factor
            norm(A)/norm(U). The "max absolute element" norm is used. If this is
            much less than 1, the stability of the LU factorization of the
            (equilibrated) matrix A could be poor. This also means that the
            solution X, estimated condition numbers, and error bounds could be
            unreliable.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                The number of linear equations, i.e., the order of the
                matrix A.  N &gt;= 0.

           <u>KL</u>

                     KL is INTEGER
                The number of subdiagonals within the band of A.  KL &gt;= 0.

           <u>KU</u>

                     KU is INTEGER
                The number of superdiagonals within the band of A.  KU &gt;= 0.

           <u>NCOLS</u>

                     NCOLS is INTEGER
                The number of columns of the matrix A.  NCOLS &gt;= 0.

           <u>AB</u>

                     AB is DOUBLE PRECISION array, dimension (LDAB,N)
                On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
                The j-th column of A is stored in the j-th column of the
                array AB as follows:
                AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)&lt;=i&lt;=min(N,j+kl)

           <u>LDAB</u>

                     LDAB is INTEGER
                The leading dimension of the array AB.  LDAB &gt;= KL+KU+1.

           <u>AFB</u>

                     AFB is DOUBLE PRECISION array, dimension (LDAFB,N)
                Details of the LU factorization of the band matrix A, as
                computed by DGBTRF.  U is stored as an upper triangular
                band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,
                and the multipliers used during the factorization are stored
                in rows KL+KU+2 to 2*KL+KU+1.

           <u>LDAFB</u>

                     LDAFB is INTEGER
                The leading dimension of the array AFB.  LDAFB &gt;= 2*KL+KU+1.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dorgbr</b> <b>(character</b> <b>VECT,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b>
       <b>integer</b> <b>LDA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b>
       <b>integer</b> <b>INFO)</b>
       <b>DORGBR</b>

       <b>Purpose:</b>

            DORGBR generates one of the real orthogonal matrices Q or P**T
            determined by DGEBRD when reducing a real matrix A to bidiagonal
            form: A = Q * B * P**T.  Q and P**T are defined as products of
            elementary reflectors H(i) or G(i) respectively.

            If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
            is of order M:
            if m &gt;= k, Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) and DORGBR returns the first n
            columns of Q, where m &gt;= n &gt;= k;
            if m &lt; k, Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(m-1) and DORGBR returns Q as an
            M-by-M matrix.

            If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
            is of order N:
            if k &lt; n, P**T = G(k) . . . <a href="../man2/G.2.html">G</a>(2) <a href="../man1/G.1.html">G</a>(1) and DORGBR returns the first m
            rows of P**T, where n &gt;= m &gt;= k;
            if k &gt;= n, P**T = G(n-1) . . . <a href="../man2/G.2.html">G</a>(2) <a href="../man1/G.1.html">G</a>(1) and DORGBR returns P**T as
            an N-by-N matrix.

       <b>Parameters</b>
           <u>VECT</u>

                     VECT is CHARACTER*1
                     Specifies whether the matrix Q or the matrix P**T is
                     required, as defined in the transformation applied by DGEBRD:
                     = 'Q':  generate Q;
                     = 'P':  generate P**T.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix Q or P**T to be returned.
                     M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix Q or P**T to be returned.
                     N &gt;= 0.
                     If VECT = 'Q', M &gt;= N &gt;= min(M,K);
                     if VECT = 'P', N &gt;= M &gt;= min(N,K).

           <u>K</u>

                     K is INTEGER
                     If VECT = 'Q', the number of columns in the original M-by-K
                     matrix reduced by DGEBRD.
                     If VECT = 'P', the number of rows in the original K-by-N
                     matrix reduced by DGEBRD.
                     K &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     On entry, the vectors which define the elementary reflectors,
                     as returned by DGEBRD.
                     On exit, the M-by-N matrix Q or P**T.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>TAU</u>

                     TAU is DOUBLE PRECISION array, dimension
                                           (min(M,K)) if VECT = 'Q'
                                           (min(N,K)) if VECT = 'P'
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i) or G(i), which determines Q or P**T, as
                     returned by DGEBRD in its array argument TAUQ or TAUP.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= max(1,min(M,N)).
                     For optimum performance LWORK &gt;= min(M,N)*NB, where NB
                     is the optimal blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.10.0                                   Wed Jan 12 2022                        <u><a href="../man3/doubleGBcomputational.3.html">doubleGBcomputational</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>