<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compress::Zlib - Interface to zlib compression library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libio-compress-perl">libio-compress-perl_2.213-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Compress::Zlib - Interface to zlib compression library

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Compress::Zlib ;

           ($d, $status) = deflateInit( [OPT] ) ;
           $status = $d-&gt;deflate($input, $output) ;
           $status = $d-&gt;flush([$flush_type]) ;
           $d-&gt;deflateParams(OPTS) ;
           $d-&gt;deflateTune(OPTS) ;
           $d-&gt;dict_adler() ;
           $d-&gt;crc32() ;
           $d-&gt;adler32() ;
           $d-&gt;total_in() ;
           $d-&gt;total_out() ;
           $d-&gt;msg() ;
           $d-&gt;get_Strategy();
           $d-&gt;get_Level();
           $d-&gt;get_BufSize();

           ($i, $status) = inflateInit( [OPT] ) ;
           $status = $i-&gt;inflate($input, $output [, $eof]) ;
           $status = $i-&gt;inflateSync($input) ;
           $i-&gt;dict_adler() ;
           $d-&gt;crc32() ;
           $d-&gt;adler32() ;
           $i-&gt;total_in() ;
           $i-&gt;total_out() ;
           $i-&gt;msg() ;
           $d-&gt;get_BufSize();

           $dest = compress($source) ;
           $dest = uncompress($source) ;

           $gz = gzopen($filename or filehandle, $mode) ;
           $bytesread = $gz-&gt;gzread($buffer [,$size]) ;
           $bytesread = $gz-&gt;gzreadline($line) ;
           $byteswritten = $gz-&gt;gzwrite($buffer) ;
           $status = $gz-&gt;gzflush($flush) ;
           $offset = $gz-&gt;gztell() ;
           $status = $gz-&gt;gzseek($offset, $whence) ;
           $status = $gz-&gt;gzclose() ;
           $status = $gz-&gt;gzeof() ;
           $status = $gz-&gt;gzsetparams($level, $strategy) ;
           $errstring = $gz-&gt;gzerror() ;
           $gzerrno

           $dest = Compress::Zlib::memGzip($buffer) ;
           $dest = Compress::Zlib::memGunzip($buffer) ;

           $crc = adler32($buffer [,$crc]) ;
           $crc = crc32($buffer [,$crc]) ;

           $crc = crc32_combine($crc1, $crc2, $len2);
           $adler = adler32_combine($adler1, $adler2, $len2);

           my $version = Compress::Raw::Zlib::zlib_version();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>Compress::Zlib</u> module provides a Perl interface to the <u>zlib</u> compression library (see "AUTHOR" for
       details about where to get <u>zlib</u>).

       The "Compress::Zlib" module can be split into two general areas of functionality, namely a simple
       read/write interface to <u>gzip</u> files and a low-level in-memory compression/decompression interface.

       Each of these areas will be discussed in the following sections.

   <b>Notes</b> <b>for</b> <b>users</b> <b>of</b> <b>Compress::Zlib</b> <b>version</b> <b>1</b>
       The main change in "Compress::Zlib" version 2.x is that it does not now interface directly to the zlib
       library. Instead it uses the "IO::Compress::Gzip" and "IO::Uncompress::Gunzip" modules for
       reading/writing gzip files, and the "Compress::Raw::Zlib" module for some low-level zlib access.

       The interface provided by version 2 of this module should be 100% backward compatible with version 1. If
       you find a difference in the expected behaviour please contact the author (See "AUTHOR"). See "GZIP
       INTERFACE"

       With the creation of the "IO::Compress" and "IO::Uncompress" modules no new features are planned for
       "Compress::Zlib" - the new modules do everything that "Compress::Zlib" does and then some. Development on
       "Compress::Zlib" will be limited to bug fixes only.

       If you are writing new code, your first port of call should be one of the new "IO::Compress" or
       "IO::Uncompress" modules.

</pre><h4><b>GZIP</b> <b>INTERFACE</b></h4><pre>
       A number of functions are supplied in <u>zlib</u> for reading and writing <u>gzip</u> files that conform to RFC 1952.
       This module provides an interface to most of them.

       If you have previously used "Compress::Zlib" 1.x, the following enhancements/changes have been made to
       the "gzopen" interface:

       1.   If  you  want  to  open either STDIN or STDOUT with "gzopen", you can now optionally use the special
            filename ""-"" as a synonym for "\*STDIN" and "\*STDOUT".

       2.   In "Compress::Zlib" version 1.x, "gzopen" used the zlib library to open the  underlying  file.  This
            made  things  especially tricky when a Perl filehandle was passed to "gzopen". Behind the scenes the
            numeric C file descriptor had to be extracted from the Perl filehandle and this passed to  the  zlib
            library.

            Apart  from  being non-portable to some operating systems, this made it difficult to use "gzopen" in
            situations where you wanted to extract/create a gzip data stream that is embedded in a larger  file,
            without having to resort to opening and closing the file multiple times.

            It  also  made it impossible to pass a perl filehandle that wasn't associated with a real filesystem
            file, like, say, an "IO::String".

            In "Compress::Zlib" version 2.x, the "gzopen" interface has been completely  rewritten  to  use  the
            IO::Compress::Gzip for writing gzip files and IO::Uncompress::Gunzip for reading gzip files. None of
            the limitations mentioned above apply.

       3.   Addition of "gzseek" to provide a restricted "seek" interface.

       4.   Added "gztell".

       A more complete and flexible interface for reading/writing gzip files/buffers is included with the module
       "IO-Compress-Zlib". See IO::Compress::Gzip and IO::Uncompress::Gunzip for more details.

       <b>$gz</b> <b>=</b> <b>gzopen($filename,</b> <b>$mode)</b>
       <b>$gz</b> <b>=</b> <b>gzopen($filehandle,</b> <b>$mode)</b>
            This  function opens either the <u>gzip</u> file $filename for reading or writing or attaches to the opened
            filehandle, $filehandle.  It returns an object on success and "undef" on failure.

            When writing a gzip file this interface  will  <u>always</u>  create  the  smallest  possible  gzip  header
            (exactly  10  bytes). If you want greater control over what gets stored in the gzip header (like the
            original filename or a comment) use IO::Compress::Gzip instead. Similarly if you want  to  read  the
            contents of the gzip header use IO::Uncompress::Gunzip.

            The  second  parameter,  $mode, is used to specify whether the file is opened for reading or writing
            and to optionally specify a compression level and compression strategy when writing. The  format  of
            the $mode parameter is similar to the mode parameter to the 'C' function "fopen", so "rb" is used to
            open for reading, "wb" for writing and "ab" for appending (writing at the end of the file).

            To  specify a compression level when writing, append a digit between 0 and 9 to the mode string -- 0
            means no compression and 9  means  maximum  compression.   If  no  compression  level  is  specified
            Z_DEFAULT_COMPRESSION is used.

            To specify the compression strategy when writing, append 'f' for filtered data, 'h' for Huffman only
            compression,  or  'R'  for  run-length  encoding.  If no strategy is specified Z_DEFAULT_STRATEGY is
            used.

            So, for example, "wb9" means open for  writing  with  the  maximum  compression  using  the  default
            strategy and "wb4R" means open for writing with compression level 4 and run-length encoding.

            Refer to the <u>zlib</u> documentation for the exact format of the $mode parameter.

       <b>$bytesread</b> <b>=</b> <b>$gz-&gt;gzread($buffer</b> <b>[,</b> <b>$size])</b> <b>;</b>
            Reads  $size bytes from the compressed file into $buffer. If $size is not specified, it will default
            to 4096. If the scalar $buffer is not large enough, it will be extended automatically.

            Returns the number of bytes actually read. On EOF it returns 0 and in the case of an error, -1.

       <b>$bytesread</b> <b>=</b> <b>$gz-&gt;gzreadline($line)</b> <b>;</b>
            Reads the next line from the compressed file into $line.

            Returns the number of bytes actually read. On EOF it returns 0 and in the case of an error, -1.

            It is legal to intermix calls to "gzread" and "gzreadline".

            To maintain backward compatibility with version 1.x of  this  module  "gzreadline"  ignores  the  $/
            variable - it <u>always</u> uses the string "\n" as the line delimiter.

            If  you  want  to  read  a  gzip  file  a  line  at  a  time and have it respect the $/ variable (or
            $INPUT_RECORD_SEPARATOR, or $RS when "English" is in use) see IO::Uncompress::Gunzip.

       <b>$byteswritten</b> <b>=</b> <b>$gz-&gt;gzwrite($buffer)</b> <b>;</b>
            Writes the contents of $buffer to the compressed file. Returns the number of bytes actually written,
            or 0 on error.

       <b>$status</b> <b>=</b> <b>$gz-&gt;gzflush($flush_type)</b> <b>;</b>
            Flushes all pending output into the compressed file.

            This method takes an optional parameter, $flush_type, that controls how the flushing will be carried
            out. By default the  $flush_type  used  is  "Z_FINISH".  Other  valid  values  for  $flush_type  are
            "Z_NO_FLUSH", "Z_SYNC_FLUSH", "Z_FULL_FLUSH" and "Z_BLOCK". It is strongly recommended that you only
            set the "flush_type" parameter if you fully understand the implications of what it does - overuse of
            "flush"  can  seriously  degrade the level of compression achieved. See the "zlib" documentation for
            details.

            Returns 0 on success.

       <b>$offset</b> <b>=</b> <b>$gz-&gt;gztell()</b> <b>;</b>
            Returns the uncompressed file offset.

       <b>$status</b> <b>=</b> <b>$gz-&gt;gzseek($offset,</b> <b>$whence)</b> <b>;</b>
            Provides a sub-set of the "seek" functionality, with the restriction that it is only legal  to  seek
            forward in the compressed file.  It is a fatal error to attempt to seek backward.

            When opened for writing, empty parts of the file will have NULL (0x00) bytes written to them.

            The $whence parameter should be one of SEEK_SET, SEEK_CUR or SEEK_END.

            Returns 1 on success, 0 on failure.

       <b>$gz-&gt;gzclose</b>
            Closes the compressed file. Any pending data is flushed to the file before it is closed.

            Returns 0 on success.

       <b>$gz-&gt;gzsetparams($level,</b> <b>$strategy</b>
            Change settings for the deflate stream $gz.

            The list of the valid options is shown below. Options not specified will remain unchanged.

            Note: This method is only available if you are running zlib 1.0.6 or better.

            <b>$level</b>
                 Defines   the   compression   level.   Valid   values  are  0  through  9,  "Z_NO_COMPRESSION",
                 "Z_BEST_SPEED", "Z_BEST_COMPRESSION", and "Z_DEFAULT_COMPRESSION".

            <b>$strategy</b>
                 Defines the strategy used to tune the compression. The valid values  are  "Z_DEFAULT_STRATEGY",
                 "Z_FILTERED" and "Z_HUFFMAN_ONLY".

       <b>$gz-&gt;gzerror</b>
            Returns  the  <u>zlib</u>  error  message  or number for the last operation associated with $gz. The return
            value will be the <u>zlib</u> error number when used in a numeric context and the <u>zlib</u> error  message  when
            used in a string context. The <u>zlib</u> error number constants, shown below, are available for use.

                Z_OK
                Z_STREAM_END
                Z_ERRNO
                Z_STREAM_ERROR
                Z_DATA_ERROR
                Z_MEM_ERROR
                Z_BUF_ERROR

       <b>$gzerrno</b>
            The  $gzerrno  scalar  holds  the error code associated with the most recent <u>gzip</u> routine. Note that
            unlike gzerror(), the error is <u>not</u> associated with a particular file.

            As with gzerror() it returns an error number in numeric context  and  an  error  message  in  string
            context.  Unlike  gzerror()  though,  the error message will correspond to the <u>zlib</u> message when the
            error is associated with <u>zlib</u> itself, or the UNIX error message when it is not (i.e.  <u>zlib</u>  returned
            "Z_ERRORNO").

            As there is an overlap between the error numbers used by <u>zlib</u> and UNIX, $gzerrno should only be used
            to  check  for the presence of <u>an</u> error in numeric context. Use gzerror() to check for specific <u>zlib</u>
            errors. The <u>gzcat</u> example below shows how the variable can be used safely.

   <b>Examples</b>
       Here is an example script which uses the interface. It implements a <u>gzcat</u> function.

           use strict ;
           use warnings ;

           use Compress::Zlib ;

           # use stdin if no files supplied
           @ARGV = '-' unless @ARGV ;

           foreach my $file (@ARGV) {
               my $buffer ;

               my $gz = gzopen($file, "rb")
                    or die "Cannot open $file: $gzerrno\n" ;

               print $buffer while $gz-&gt;gzread($buffer) &gt; 0 ;

               die "Error reading from $file: $gzerrno" . ($gzerrno+0) . "\n"
                   if $gzerrno != Z_STREAM_END ;

               $gz-&gt;gzclose() ;
           }

       Below is a script which makes use of "gzreadline". It implements a very simple <u>grep</u> like script.

           use strict ;
           use warnings ;

           use Compress::Zlib ;

           die "Usage: gzgrep pattern [file...]\n"
               unless @ARGV &gt;= 1;

           my $pattern = shift ;

           # use stdin if no files supplied
           @ARGV = '-' unless @ARGV ;

           foreach my $file (@ARGV) {
               my $gz = gzopen($file, "rb")
                    or die "Cannot open $file: $gzerrno\n" ;

               while ($gz-&gt;gzreadline($_) &gt; 0) {
                   print if /$pattern/ ;
               }

               die "Error reading from $file: $gzerrno\n"
                   if $gzerrno != Z_STREAM_END ;

               $gz-&gt;gzclose() ;
           }

       This script, <u>gzstream</u>, does the opposite of the <u>gzcat</u> script above. It  reads  from  standard  input  and
       writes a gzip data stream to standard output.

           use strict ;
           use warnings ;

           use Compress::Zlib ;

           binmode STDOUT;  # gzopen only sets it on the fd

           my $gz = gzopen(\*STDOUT, "wb")
                 or die "Cannot open stdout: $gzerrno\n" ;

           while (&lt;&gt;) {
               $gz-&gt;gzwrite($_)
                 or die "error writing: $gzerrno\n" ;
           }

           $gz-&gt;gzclose ;

   <b>Compress::Zlib::memGzip</b>
       This  function is used to create an in-memory gzip file with the minimum possible gzip header (exactly 10
       bytes).

           $dest = Compress::Zlib::memGzip($buffer)
               or die "Cannot compress: $gzerrno\n";

       If successful, it returns the in-memory gzip file. Otherwise it returns "undef" and the $gzerrno variable
       will store the zlib error code.

       The $buffer parameter can either be a scalar or a scalar reference.

       See IO::Compress::Gzip for an alternative way to carry out in-memory gzip compression.

   <b>Compress::Zlib::memGunzip</b>
       This function is used to uncompress an in-memory gzip file.

           $dest = Compress::Zlib::memGunzip($buffer)
               or die "Cannot uncompress: $gzerrno\n";

       If successful, it returns the uncompressed gzip file. Otherwise  it  returns  "undef"  and  the  $gzerrno
       variable will store the zlib error code.

       The $buffer parameter can either be a scalar or a scalar reference. The contents of the $buffer parameter
       are destroyed after calling this function.

       If  $buffer  consists of multiple concatenated gzip data streams only the first will be uncompressed. Use
       "gunzip" with the "MultiStream" option in the "IO::Uncompress::Gunzip" module if you need  to  deal  with
       concatenated data streams.

       See IO::Uncompress::Gunzip for an alternative way to carry out in-memory gzip uncompression.

</pre><h4><b>COMPRESS/UNCOMPRESS</b></h4><pre>
       Two  functions are provided to perform in-memory compression/uncompression of RFC 1950 data streams. They
       are called "compress" and "uncompress".

       <b>$dest</b> <b>=</b> <b>compress($source</b> <b>[,</b> <b>$level]</b> <b>)</b> <b>;</b>
            Compresses $source. If successful it returns the compressed data. Otherwise it returns <u>undef</u>.

            The source buffer, $source, can either be a scalar or a scalar reference.

            The  $level  parameter  defines  the  compression   level.   Valid   values   are   0   through   9,
            "Z_NO_COMPRESSION", "Z_BEST_SPEED", "Z_BEST_COMPRESSION", and "Z_DEFAULT_COMPRESSION".  If $level is
            not specified "Z_DEFAULT_COMPRESSION" will be used.

       <b>$dest</b> <b>=</b> <b>uncompress($source)</b> <b>;</b>
            Uncompresses $source. If successful it returns the uncompressed data. Otherwise it returns <u>undef</u>.

            The source buffer can either be a scalar or a scalar reference.

       Please note: the two functions defined above are <u>not</u> compatible with the Unix commands of the same name.

       See  IO::Deflate  and  IO::Inflate  included  with  this  distribution  for  an alternative interface for
       reading/writing RFC 1950 files/buffers.

</pre><h4><b>Deflate</b> <b>Interface</b></h4><pre>
       This section defines an interface that allows in-memory compression using the <u>deflate</u> interface  provided
       by zlib.

       Here is a definition of the interface available:

   <b>($d,</b> <b>$status)</b> <b>=</b> <b>deflateInit(</b> <b>[OPT]</b> <b>)</b>
       Initialises a deflation stream.

       It combines the features of the <u>zlib</u> functions "deflateInit", "deflateInit2" and "deflateSetDictionary".

       If  successful,  it  will  return  the  initialised  deflation stream, $d and $status of "Z_OK" in a list
       context. In scalar context it returns the deflation stream, $d, only.

       If not successful, the returned deflation stream ($d) will be <u>undef</u> and $status will hold the exact  <u>zlib</u>
       error code.

       The  function  optionally  takes a number of named options specified as "-Name=&gt;value" pairs. This allows
       individual options to be tailored without having to specify them all in the parameter list.

       For backward compatibility, it is also possible  to  pass  the  parameters  as  a  reference  to  a  hash
       containing the name=&gt;value pairs.

       The  function  takes  one  optional parameter, a reference to a hash.  The contents of the hash allow the
       deflation interface to be tailored.

       Here is a list of the valid options:

       <b>-Level</b>
            Defines the compression level. Valid values are 0  through  9,  "Z_NO_COMPRESSION",  "Z_BEST_SPEED",
            "Z_BEST_COMPRESSION", and "Z_DEFAULT_COMPRESSION".

            The default is Z_DEFAULT_COMPRESSION.

       <b>-Method</b>
            Defines the compression method. The only valid value at present (and the default) is Z_DEFLATED.

       <b>-WindowBits</b>
            To create an RFC 1950 data stream, set "WindowBits" to a positive number.

            To create an RFC 1951 data stream, set "WindowBits" to "-MAX_WBITS".

            For  a  full  definition  of  the  meaning  and  valid  values  for  "WindowBits"  refer to the <u>zlib</u>
            documentation for <u>deflateInit2</u>.

            Defaults to MAX_WBITS.

       <b>-MemLevel</b>
            For a definition of the meaning and valid values for "MemLevel" refer to the <u>zlib</u> documentation  for
            <u>deflateInit2</u>.

            Defaults to MAX_MEM_LEVEL.

       <b>-Strategy</b>
            Defines  the  strategy  used  to  tune  the  compression. The valid values are "Z_DEFAULT_STRATEGY",
            "Z_FILTERED" and "Z_HUFFMAN_ONLY".

            The default is Z_DEFAULT_STRATEGY.

       <b>-Dictionary</b>
            When a  dictionary  is  specified  <u>Compress::Zlib</u>  will  automatically  call  "deflateSetDictionary"
            directly  after  calling  "deflateInit".  The  Adler32  value  for the dictionary can be obtained by
            calling the method "$d-&gt;dict_adler()".

            The default is no dictionary.

       <b>-Bufsize</b>
            Sets the initial size for the deflation buffer. If the buffer has to be reallocated to increase  the
            size, it will grow in increments of "Bufsize".

            The default is 4096.

       Here is an example of using the "deflateInit" optional parameter list to override the default buffer size
       and compression level. All other options will take their default values.

           deflateInit( -Bufsize =&gt; 300,
                        -Level =&gt; Z_BEST_SPEED  ) ;

   <b>($out,</b> <b>$status)</b> <b>=</b> <b>$d-&gt;deflate($buffer)</b>
       Deflates  the  contents  of  $buffer.  The  buffer  can  either  be a scalar or a scalar reference.  When
       finished, $buffer will be completely processed (assuming there were no  errors).  If  the  deflation  was
       successful it returns the deflated output, $out, and a status value, $status, of "Z_OK".

       On error, $out will be <u>undef</u> and $status will contain the <u>zlib</u> error code.

       In a scalar context "deflate" will return $out only.

       As  with the <u>deflate</u> function in <u>zlib</u>, it is not necessarily the case that any output will be produced by
       this method. So don't rely on the fact that $out is empty for an error test.

   <b>($out,</b> <b>$status)</b> <b>=</b> <b>$d-&gt;flush()</b> <b>=head2</b> <b>($out,</b> <b>$status)</b> <b>=</b> <b>$d-&gt;flush($flush_type)</b>
       Typically used to finish the deflation. Any pending output will be returned via $out.  $status will  have
       a value "Z_OK" if successful.

       In a scalar context "flush" will return $out only.

       Note  that flushing can seriously degrade the compression ratio, so it should only be used to terminate a
       decompression (using "Z_FINISH") or when you want to create a <u>full</u> <u>flush</u> <u>point</u> (using "Z_FULL_FLUSH").

       By default the "flush_type" used is "Z_FINISH". Other valid values  for  "flush_type"  are  "Z_NO_FLUSH",
       "Z_PARTIAL_FLUSH",  "Z_SYNC_FLUSH"  and  "Z_FULL_FLUSH". It is strongly recommended that you only set the
       "flush_type" parameter if you fully  understand  the  implications  of  what  it  does.  See  the  "zlib"
       documentation for details.

   <b>$status</b> <b>=</b> <b>$d-&gt;deflateParams([OPT])</b>
       Change settings for the deflate stream $d.

       The list of the valid options is shown below. Options not specified will remain unchanged.

       <b>-Level</b>
            Defines  the  compression  level.  Valid values are 0 through 9, "Z_NO_COMPRESSION", "Z_BEST_SPEED",
            "Z_BEST_COMPRESSION", and "Z_DEFAULT_COMPRESSION".

       <b>-Strategy</b>
            Defines the strategy used to tune  the  compression.  The  valid  values  are  "Z_DEFAULT_STRATEGY",
            "Z_FILTERED" and "Z_HUFFMAN_ONLY".

   <b>$d-&gt;dict_adler()</b>
       Returns the adler32 value for the dictionary.

   <b>$d-&gt;msg()</b>
       Returns the last error message generated by zlib.

   <b>$d-&gt;total_in()</b>
       Returns the total number of bytes uncompressed bytes input to deflate.

   <b>$d-&gt;total_out()</b>
       Returns the total number of compressed bytes output from deflate.

   <b>Example</b>
       Here  is  a trivial example of using "deflate". It simply reads standard input, deflates it and writes it
       to standard output.

           use strict ;
           use warnings ;

           use Compress::Zlib ;

           binmode STDIN;
           binmode STDOUT;
           my $x = deflateInit()
              or die "Cannot create a deflation stream\n" ;

           my ($output, $status) ;
           while (&lt;&gt;)
           {
               ($output, $status) = $x-&gt;deflate($_) ;

               $status == Z_OK
                   or die "deflation failed\n" ;

               print $output ;
           }

           ($output, $status) = $x-&gt;flush() ;

           $status == Z_OK
               or die "deflation failed\n" ;

           print $output ;

</pre><h4><b>Inflate</b> <b>Interface</b></h4><pre>
       This section defines the interface available  that  allows  in-memory  uncompression  using  the  <u>deflate</u>
       interface provided by zlib.

       Here is a definition of the interface:

   <b>($i,</b> <b>$status)</b> <b>=</b> <b>inflateInit()</b>
       Initialises an inflation stream.

       In  a  list context it returns the inflation stream, $i, and the <u>zlib</u> status code in $status. In a scalar
       context it returns the inflation stream only.

       If successful, $i will hold the inflation stream and $status will be "Z_OK".

       If not successful, $i will be <u>undef</u> and $status will hold the <u>zlib</u> error code.

       The function optionally takes a number of named options specified as "-Name=&gt;value"  pairs.  This  allows
       individual options to be tailored without having to specify them all in the parameter list.

       For  backward  compatibility,  it  is  also  possible  to  pass  the  parameters as a reference to a hash
       containing the name=&gt;value pairs.

       The function takes one optional parameter, a reference to a hash.  The contents of  the  hash  allow  the
       deflation interface to be tailored.

       Here is a list of the valid options:

       <b>-WindowBits</b>
            To uncompress an RFC 1950 data stream, set "WindowBits" to a positive number.

            To uncompress an RFC 1951 data stream, set "WindowBits" to "-MAX_WBITS".

            For  a  full  definition  of  the  meaning  and  valid  values  for  "WindowBits"  refer to the <u>zlib</u>
            documentation for <u>inflateInit2</u>.

            Defaults to MAX_WBITS.

       <b>-Bufsize</b>
            Sets the initial size for the inflation buffer. If the buffer has to be reallocated to increase  the
            size, it will grow in increments of "Bufsize".

            Default is 4096.

       <b>-Dictionary</b>
            The default is no dictionary.

       Here is an example of using the "inflateInit" optional parameter to override the default buffer size.

           inflateInit( -Bufsize =&gt; 300 ) ;

   <b>($out,</b> <b>$status)</b> <b>=</b> <b>$i-&gt;inflate($buffer)</b>
       Inflates the complete contents of $buffer. The buffer can either be a scalar or a scalar reference.

       Returns  "Z_OK"  if successful and "Z_STREAM_END" if the end of the compressed data has been successfully
       reached.  If not successful, $out will be <u>undef</u> and $status will hold the <u>zlib</u> error code.

       The $buffer parameter is modified by "inflate". On completion it will contain what remains of  the  input
       buffer after inflation. This means that $buffer will be an empty string when the return status is "Z_OK".
       When  the  return  status  is  "Z_STREAM_END"  the $buffer parameter will contains what (if anything) was
       stored in the input buffer after the deflated data stream.

       This feature is useful when processing a file format that encapsulates a  compressed  data  stream  (e.g.
       gzip, zip).

   <b>$status</b> <b>=</b> <b>$i-&gt;inflateSync($buffer)</b>
       Scans $buffer until it reaches either a <u>full</u> <u>flush</u> <u>point</u> or the end of the buffer.

       If  a  <u>full</u>  <u>flush</u>  <u>point</u>  is found, "Z_OK" is returned and $buffer will be have all data up to the flush
       point removed. This can then be passed to the "deflate" method.

       Any other return code means that a flush point was not found. If more data  is  available,  "inflateSync"
       can be called repeatedly with more compressed data until the flush point is found.

   <b>$i-&gt;dict_adler()</b>
       Returns the adler32 value for the dictionary.

   <b>$i-&gt;msg()</b>
       Returns the last error message generated by zlib.

   <b>$i-&gt;total_in()</b>
       Returns the total number of bytes compressed bytes input to inflate.

   <b>$i-&gt;total_out()</b>
       Returns the total number of uncompressed bytes output from inflate.

   <b>Example</b>
       Here is an example of using "inflate".

           use strict ;
           use warnings ;

           use Compress::Zlib ;

           my $x = inflateInit()
              or die "Cannot create a inflation stream\n" ;

           my $input = '' ;
           binmode STDIN;
           binmode STDOUT;

           my ($output, $status) ;
           while (read(STDIN, $input, 4096))
           {
               ($output, $status) = $x-&gt;inflate(\$input) ;

               print $output
                   if $status == Z_OK or $status == Z_STREAM_END ;

               last if $status != Z_OK ;
           }

           die "inflation failed\n"
               unless $status == Z_STREAM_END ;

</pre><h4><b>CHECKSUM</b> <b>FUNCTIONS</b></h4><pre>
       Two  functions  are provided by <u>zlib</u> to calculate checksums. For the Perl interface, the order of the two
       parameters in both functions  has  been  reversed.  This  allows  both  running  checksums  and  one  off
       calculations to be done.

           $crc = adler32($buffer [,$crc]) ;
           $crc = crc32($buffer [,$crc]) ;

       The buffer parameters can either be a scalar or a scalar reference.

       If the $crc parameters is "undef", the crc value will be reset.

       If you have built this module with zlib 1.2.3 or better, two more CRC-related functions are available.

           $crc = crc32_combine($crc1, $crc2, $len2);
           $adler = adler32_combine($adler1, $adler2, $len2);

       These functions allow checksums to be merged.  Refer to the <u>zlib</u> documentation for more details.

</pre><h4><b>Misc</b></h4><pre>
   <b>my</b> <b>$version</b> <b>=</b> <b>Compress::Zlib::zlib_version();</b>
       Returns the version of the zlib library.

</pre><h4><b>CONSTANTS</b></h4><pre>
       All the <u>zlib</u> constants are automatically imported when you make use of <u>Compress::Zlib</u>.

</pre><h4><b>SUPPORT</b></h4><pre>
       General  feedback/questions/bug  reports  should  be sent to &lt;https://github.com/pmqs/IO-Compress/issues&gt;
       (preferred) or &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=IO-Compress&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       IO::Compress::Gzip,     IO::Uncompress::Gunzip,      IO::Compress::Deflate,      IO::Uncompress::Inflate,
       IO::Compress::RawDeflate,   IO::Uncompress::RawInflate,   IO::Compress::Bzip2,   IO::Uncompress::Bunzip2,
       IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz,  IO::Uncompress::UnXz,  IO::Compress::Lzip,
       IO::Uncompress::UnLzip,        IO::Compress::Lzop,       IO::Uncompress::UnLzop,       IO::Compress::Lzf,
       IO::Uncompress::UnLzf,    IO::Compress::Zstd,     IO::Uncompress::UnZstd,     IO::Uncompress::AnyInflate,
       IO::Uncompress::AnyUncompress

       IO::Compress::FAQ

       File::GlobMapper, Archive::Zip, Archive::Tar, IO::Zlib

       For     RFC     1950,     1951     and    1952    see    &lt;https://datatracker.ietf.org/doc/html/rfc1950&gt;,
       &lt;https://datatracker.ietf.org/doc/html/rfc1951&gt; and &lt;https://datatracker.ietf.org/doc/html/rfc1952&gt;

       The <u>zlib</u> compression library was written  by  Jean-loup  Gailly  "<a href="mailto:gzip@prep.ai.mit.edu">gzip@prep.ai.mit.edu</a>"  and  Mark  Adler
       "<a href="mailto:madler@alumni.caltech.edu">madler@alumni.caltech.edu</a>".

       The primary site for the <u>zlib</u> compression library is &lt;<a href="http://www.zlib.org">http://www.zlib.org</a>&gt;.

       The primary site for the <u>zlib-ng</u> compression library is &lt;https://github.com/zlib-ng/zlib-ng&gt;.

       The primary site for gzip is &lt;<a href="http://www.gzip.org">http://www.gzip.org</a>&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       This module was written by Paul Marquess, "<a href="mailto:pmqs@cpan.org">pmqs@cpan.org</a>".

</pre><h4><b>MODIFICATION</b> <b>HISTORY</b></h4><pre>
       See the Changes file.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 1995-2024 Paul Marquess. All rights reserved.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.0                                       2024-09-01                                <u>Compress::<a href="../man3pm/Zlib.3pm.html">Zlib</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>