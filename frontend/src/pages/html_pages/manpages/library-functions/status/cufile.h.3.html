<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cufile.h - cuFile C APIs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcufile-dev">libcufile-dev_1.9.1.3~12.4.1-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cufile.h - cuFile C APIs

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Data</b> <b>Structures</b>
       struct <b>CUfileDescr_t</b>
       struct <b>CUfileDrvProps</b>
       struct <b>CUfileError</b>
           cufileop status string
       struct <b>CUfileFSOps</b>
       struct <b>CUfileIOEvents</b>
       struct <b>CUfileIOParams</b>
       struct <b>cufileRDMAInfo</b>

   <b>Macros</b>
       #define <b>CU_FILE_CUDA_ERR</b>(status)   ((status).cu_err)
       #define <b>CU_FILE_RDMA_REGISTER</b>   1
       #define <b>CU_FILE_RDMA_RELAXED_ORDERING</b>   (1&lt;&lt;1)
       #define <b>CU_FILE_STREAM_FIXED_BUF_OFFSET</b>   1
       #define <b>CU_FILE_STREAM_FIXED_FILE_OFFSET</b>   2
       #define <b>CU_FILE_STREAM_FIXED_FILE_SIZE</b>   4
       #define <b>CU_FILE_STREAM_PAGE_ALIGNED_INPUTS</b>   8
       #define <b>CUFILE_ERRSTR</b>(err)   cufileop_status_error((<b>CUfileOpError</b>)abs((err)))
       #define <b>cuFileDriverClose</b>   <b>cuFileDriverClose_v2</b>
       #define <b>IS_CUDA_ERR</b>(status)   ((status).err == <b>CU_FILE_CUDA_DRIVER_ERROR</b>)
       #define <b>IS_CUFILE_ERR</b>(err)   (abs((err)) &gt; CUFILEOP_BASE_ERR)
           error macros to inspect error status of type <b>CUfileOpError</b>

   <b>Typedefs</b>
       typedef void * <b>CUfileBatchHandle_t</b>
       typedef enum <b>cufileBatchMode</b> <b>CUfileBatchMode_t</b>
       typedef struct <b>CUfileDescr_t</b> <b>CUfileDescr_t</b>
       typedef enum <b>CUfileDriverControlFlags</b> <b>CUfileDriverControlFlags_t</b>
       typedef enum <b>CUfileDriverStatusFlags</b> <b>CUfileDriverStatusFlags_t</b>
       typedef struct <b>CUfileDrvProps</b> <b>CUfileDrvProps_t</b>
       typedef struct <b>CUfileError</b> <b>CUfileError_t</b>
           cufileop status string
       typedef enum <b>CUfileFeatureFlags</b> <b>CUfileFeatureFlags_t</b>
       typedef struct <b>CUfileFSOps</b> <b>CUfileFSOps_t</b>
       typedef void * <b>CUfileHandle_t</b>
           File handle type.
       typedef struct <b>CUfileIOEvents</b> <b>CUfileIOEvents_t</b>
       typedef struct <b>CUfileIOParams</b> <b>CUfileIOParams_t</b>
       typedef enum <b>CUfileOpcode</b> <b>CUfileOpcode_t</b>
       typedef struct <b>cufileRDMAInfo</b> <b>cufileRDMAInfo_t</b>
       typedef enum <b>CUFILEStatus_enum</b> <b>CUfileStatus_t</b>
       typedef struct sockaddr <b>sockaddr_t</b>

   <b>Enumerations</b>
       enum <b>cufileBatchMode</b> { <b>CUFILE_BATCH</b> = 1 }
       enum <b>CUfileDriverControlFlags</b> { <b>CU_FILE_USE_POLL_MODE</b> = 0, <b>CU_FILE_ALLOW_COMPAT_MODE</b> = 1 }
       enum <b>CUfileDriverStatusFlags</b> { <b>CU_FILE_LUSTRE_SUPPORTED</b> = 0, <b>CU_FILE_WEKAFS_SUPPORTED</b> = 1,
           <b>CU_FILE_NFS_SUPPORTED</b> = 2, <b>CU_FILE_GPFS_SUPPORTED</b> = 3, <b>CU_FILE_NVME_SUPPORTED</b> = 4,
           <b>CU_FILE_NVMEOF_SUPPORTED</b> = 5, <b>CU_FILE_SCSI_SUPPORTED</b> = 6, <b>CU_FILE_SCALEFLUX_CSD_SUPPORTED</b> = 7,
           <b>CU_FILE_NVMESH_SUPPORTED</b> = 8, <b>CU_FILE_BEEGFS_SUPPORTED</b> = 9 }
       enum <b>CUfileFeatureFlags</b> { <b>CU_FILE_DYN_ROUTING_SUPPORTED</b> = 0, <b>CU_FILE_BATCH_IO_SUPPORTED</b> = 1,
           <b>CU_FILE_STREAMS_SUPPORTED</b> = 2, <b>CU_FILE_PARALLEL_IO_SUPPORTED</b> = 3 }
       enum <b>CUfileFileHandleType</b> { <b>CU_FILE_HANDLE_TYPE_OPAQUE_FD</b> = 1, <b>CU_FILE_HANDLE_TYPE_OPAQUE_WIN32</b> = 2,
           <b>CU_FILE_HANDLE_TYPE_USERSPACE_FS</b> = 3 }
       enum <b>CUfileOpcode</b> { <b>CUFILE_READ</b> = 0, <b>CUFILE_WRITE</b> }
       enum <b>CUFILEStatus_enum</b> { <b>CUFILE_WAITING</b> = 0x000001, <b>CUFILE_PENDING</b> = 0x000002, <b>CUFILE_INVALID</b> = 0x000004,
           <b>CUFILE_CANCELED</b> = 0x000008, <b>CUFILE_COMPLETE</b> = 0x0000010, <b>CUFILE_TIMEOUT</b> = 0x0000020, <b>CUFILE_FAILED</b> =
           0x0000040 }

   <b>Functions</b>
       <b>CUfileError_t</b> <b>cuFileBatchIOCancel</b> (<b>CUfileBatchHandle_t</b> batch_idp)
       void <b>cuFileBatchIODestroy</b> (<b>CUfileBatchHandle_t</b> batch_idp)
       <b>CUfileError_t</b> <b>cuFileBatchIOGetStatus</b> (<b>CUfileBatchHandle_t</b> batch_idp, unsigned min_nr, unsigned *nr,
           <b>CUfileIOEvents_t</b> *iocbp, struct timespec *timeout)
       <b>CUfileError_t</b> <b>cuFileBatchIOSetUp</b> (<b>CUfileBatchHandle_t</b> *batch_idp, unsigned nr)
       <b>CUfileError_t</b> <b>cuFileBatchIOSubmit</b> (<b>CUfileBatchHandle_t</b> batch_idp, unsigned nr, <b>CUfileIOParams_t</b> *iocbp,
           unsigned int flags)
       <b>CUfileError_t</b> <b>cuFileBufDeregister</b> (const void *bufPtr_base)
           deregister an already registered device or host memory from cuFile
       <b>CUfileError_t</b> <b>cuFileBufRegister</b> (const void *bufPtr_base, size_t length, int flags)
           register an existing cudaMalloced memory with cuFile to pin for GPUDirect Storage access or register
           host allocated memory with cuFile.
       <b>CUfileError_t</b> <b>cuFileDriverClose</b> (void)
       <b>CUfileError_t</b> <b>cuFileDriverClose_v2</b> (void)
           reset the cuFile library and release the nvidia-fs driver
       <b>CUfileError_t</b> <b>cuFileDriverGetProperties</b> (<b>CUfileDrvProps_t</b> *props)
           Gets the Driver session properties.
       <b>CUfileError_t</b> <b>cuFileDriverOpen</b> (void)
           Initialize the cuFile library and open the nvidia-fs driver.
       <b>CUfileError_t</b> <b>cuFileDriverSetMaxCacheSize</b> (size_t max_cache_size)
           Control parameter to set maximum GPU memory reserved per device by the library for internal
           buffering.
       <b>CUfileError_t</b> <b>cuFileDriverSetMaxDirectIOSize</b> (size_t max_direct_io_size)
           Control parameter to set max IO size(KB) used by the library to talk to nvidia-fs driver.
       <b>CUfileError_t</b> <b>cuFileDriverSetMaxPinnedMemSize</b> (size_t max_pinned_size)
           Sets maximum buffer space that is pinned in KB for use by <b>cuFileBufRegister</b>.
       <b>CUfileError_t</b> <b>cuFileDriverSetPollMode</b> (bool poll, size_t poll_threshold_size)
           Sets whether the Read/Write APIs use polling to do IO operations.
       <b>CUfileError_t</b> <b>cuFileGetVersion</b> (int *version)
       void <b>cuFileHandleDeregister</b> (<b>CUfileHandle_t</b> fh)
           releases a registered filehandle from cuFile
       <b>CUfileError_t</b> <b>cuFileHandleRegister</b> (<b>CUfileHandle_t</b> *fh, <b>CUfileDescr_t</b> *descr)
           cuFileHandleRegister is required, and performs extra checking that is memoized to provide increased
           performance on later cuFile operations.
       ssize_t <b>cuFileRead</b> (<b>CUfileHandle_t</b> fh, void *bufPtr_base, size_t size, off_t file_offset, off_t
           bufPtr_offset)
           read data from a registered file handle to a specified device or host memory
       <b>CUfileError_t</b> <b>cuFileReadAsync</b> (<b>CUfileHandle_t</b> fh, void *bufPtr_base, size_t *size_p, off_t
           *file_offset_p, off_t *bufPtr_offset_p, ssize_t *bytes_read_p, CUstream stream)
       <b>CUfileError_t</b> <b>cuFileStreamDeregister</b> (CUstream stream)
       <b>CUfileError_t</b> <b>cuFileStreamRegister</b> (CUstream stream, unsigned flags)
       long <b>cuFileUseCount</b> (void)
           returns use count of cufile drivers at that moment by the process.
       ssize_t <b>cuFileWrite</b> (<b>CUfileHandle_t</b> fh, const void *bufPtr_base, size_t size, off_t file_offset, off_t
           bufPtr_offset)
           write data from a specified device or host memory to a registered file handle
       <b>CUfileError_t</b> <b>cuFileWriteAsync</b> (<b>CUfileHandle_t</b> fh, void *bufPtr_base, size_t *size_p, off_t
           *file_offset_p, off_t *bufPtr_offset_p, ssize_t *bytes_written_p, CUstream stream)

   <b>Variables</b>
       <b>CUfileOpError</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       cuFile C APIs

       This file contains all the C APIs to perform GPUDirect Storage supported IO operations

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>CU_FILE_CUDA_ERR(status)</b>   <b>((status).cu_err)</b>
   <b>#define</b> <b>CU_FILE_RDMA_REGISTER</b>   <b>1</b>
   <b>#define</b> <b>CU_FILE_RDMA_RELAXED_ORDERING</b>   <b>(1&lt;&lt;1)</b>
   <b>#define</b> <b>CU_FILE_STREAM_FIXED_BUF_OFFSET</b>   <b>1</b>
   <b>#define</b> <b>CU_FILE_STREAM_FIXED_FILE_OFFSET</b>   <b>2</b>
   <b>#define</b> <b>CU_FILE_STREAM_FIXED_FILE_SIZE</b>   <b>4</b>
   <b>#define</b> <b>CU_FILE_STREAM_PAGE_ALIGNED_INPUTS</b>   <b>8</b>
   <b>#define</b> <b>CUFILE_ERRSTR(err)</b>   <b>cufileop_status_error((CUfileOpError)abs((err)))</b>
   <b>#define</b> <b>cuFileDriverClose</b>   <b>cuFileDriverClose_v2</b>
   <b>#define</b> <b>IS_CUDA_ERR(status)</b>   <b>((status).err</b> <b>==</b> <b>CU_FILE_CUDA_DRIVER_ERROR)</b>
   <b>#define</b> <b>IS_CUFILE_ERR(err)</b>   <b>(abs((err))</b> <b>&gt;</b> <b>CUFILEOP_BASE_ERR)</b>
       error macros to inspect error status of type <b>CUfileOpError</b>

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>void*</b> <b>CUfileBatchHandle_t</b>
   <b>typedef</b> <b>enum</b> <b>cufileBatchMode</b>  <b>CUfileBatchMode_t</b>
   <b>typedef</b> <b>struct</b> <b>CUfileDescr_t</b> <b>CUfileDescr_t</b>
   <b>typedef</b> <b>enum</b> <b>CUfileDriverControlFlags</b> <b>CUfileDriverControlFlags_t</b>
   <b>typedef</b> <b>enum</b> <b>CUfileDriverStatusFlags</b> <b>CUfileDriverStatusFlags_t</b>
   <b>typedef</b> <b>struct</b> <b>CUfileDrvProps</b> <b>CUfileDrvProps_t</b>
   <b>typedef</b> <b>struct</b> <b>CUfileError</b> <b>CUfileError_t</b>
       cufileop status string

   <b>typedef</b> <b>enum</b> <b>CUfileFeatureFlags</b> <b>CUfileFeatureFlags_t</b>
   <b>typedef</b> <b>struct</b> <b>CUfileFSOps</b> <b>CUfileFSOps_t</b>
   <b>typedef</b> <b>void*</b> <b>CUfileHandle_t</b>
       File handle type.

   <b>typedef</b> <b>struct</b> <b>CUfileIOEvents</b> <b>CUfileIOEvents_t</b>
   <b>typedef</b> <b>struct</b> <b>CUfileIOParams</b> <b>CUfileIOParams_t</b>
   <b>typedef</b> <b>enum</b> <b>CUfileOpcode</b> <b>CUfileOpcode_t</b>
   <b>typedef</b> <b>struct</b> <b>cufileRDMAInfo</b> <b>cufileRDMAInfo_t</b>
   <b>typedef</b> <b>enum</b> <b>CUFILEStatus_enum</b> <b>CUfileStatus_t</b>
   <b>typedef</b> <b>struct</b> <b>sockaddr</b> <b>sockaddr_t</b>
</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>cufileBatchMode</b>
       <b>Enumerator</b>

       <u>CUFILE_BATCH</u>

   <b>enum</b> <b>CUfileDriverControlFlags</b>
       <b>Enumerator</b>

       <u>CU_FILE_USE_POLL_MODE</u>
              use POLL mode. properties.use_poll_mode

       <u>CU_FILE_ALLOW_COMPAT_MODE</u>
              allow COMPATIBILITY mode. properties.allow_compat_mode

   <b>enum</b> <b>CUfileDriverStatusFlags</b>
       <b>Enumerator</b>

       <u>CU_FILE_LUSTRE_SUPPORTED</u>
              Support for DDN LUSTRE

       <u>CU_FILE_WEKAFS_SUPPORTED</u>
              Support for WEKAFS

       <u>CU_FILE_NFS_SUPPORTED</u>
              Support for NFS

       <u>CU_FILE_GPFS_SUPPORTED</u>

       <u>CU_FILE_NVME_SUPPORTED</u>
              &lt; Support for GPFS Support for NVMe

       <u>CU_FILE_NVMEOF_SUPPORTED</u>
              Support for NVMeOF

       <u>CU_FILE_SCSI_SUPPORTED</u>
              Support for SCSI

       <u>CU_FILE_SCALEFLUX_CSD_SUPPORTED</u>
              Support for Scaleflux CSD

       <u>CU_FILE_NVMESH_SUPPORTED</u>
              Support for NVMesh Block Dev

       <u>CU_FILE_BEEGFS_SUPPORTED</u>
              Support for BeeGFS

   <b>enum</b> <b>CUfileFeatureFlags</b>
       <b>Enumerator</b>

       <u>CU_FILE_DYN_ROUTING_SUPPORTED</u>
              Support for Dynamic routing to handle devices across the PCIe bridges

       <u>CU_FILE_BATCH_IO_SUPPORTED</u>
              Unsupported

       <u>CU_FILE_STREAMS_SUPPORTED</u>
              Unsupported

       <u>CU_FILE_PARALLEL_IO_SUPPORTED</u>
              Unsupported

   <b>enum</b> <b>CUfileFileHandleType</b>
       <b>Enumerator</b>

       <u>CU_FILE_HANDLE_TYPE_OPAQUE_FD</u>
              Linux based fd

       <u>CU_FILE_HANDLE_TYPE_OPAQUE_WIN32</u>
              Windows based handle (unsupported)

       <u>CU_FILE_HANDLE_TYPE_USERSPACE_FS</u>

   <b>enum</b> <b>CUfileOpcode</b>
       <b>Enumerator</b>

       <u>CUFILE_READ</u>

       <u>CUFILE_WRITE</u>

   <b>enum</b> <b>CUFILEStatus_enum</b>
       <b>Enumerator</b>

       <u>CUFILE_WAITING</u>

       <u>CUFILE_PENDING</u>

       <u>CUFILE_INVALID</u>

       <u>CUFILE_CANCELED</u>

       <u>CUFILE_COMPLETE</u>

       <u>CUFILE_TIMEOUT</u>

       <u>CUFILE_FAILED</u>

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>CUfileError_t</b> <b>cuFileBatchIOCancel</b> <b>(CUfileBatchHandle_t</b> <b>batch_idp)</b>
   <b>void</b> <b>cuFileBatchIODestroy</b> <b>(CUfileBatchHandle_t</b> <b>batch_idp)</b>
   <b>CUfileError_t</b>   <b>cuFileBatchIOGetStatus</b>  <b>(CUfileBatchHandle_t</b>  <b>batch_idp,</b>  <b>unsigned</b>  <b>min_nr,</b>  <b>unsigned</b>  <b>*</b>  <b>nr,</b>
       <b>CUfileIOEvents_t</b> <b>*</b> <b>iocbp,</b> <b>struct</b> <b>timespec</b> <b>*</b> <b>timeout)</b>
   <b>CUfileError_t</b> <b>cuFileBatchIOSetUp</b> <b>(CUfileBatchHandle_t</b> <b>*</b> <b>batch_idp,</b> <b>unsigned</b> <b>nr)</b>
   <b>CUfileError_t</b> <b>cuFileBatchIOSubmit</b> <b>(CUfileBatchHandle_t</b> <b>batch_idp,</b>  <b>unsigned</b>  <b>nr,</b>  <b>CUfileIOParams_t</b>  <b>*</b>  <b>iocbp,</b>
       <b>unsigned</b> <b>int</b> <b>flags)</b>
   <b>CUfileError_t</b> <b>cuFileBufDeregister</b> <b>(const</b> <b>void</b> <b>*</b> <b>bufPtr_base)</b>
       deregister an already registered device or host memory from cuFile

       <b>Parameters:</b>
           <u>bufPtr_base</u> buffer pointer to deregister

       <b>Returns:</b>
           CU_FILE_SUCCESS on success

           CU_FILE_INVALID_VALUE on invalid memory pointer or unregistered memory pointer

       <b>See</b> <b>also:</b>
           <b>cuFileBufRegister</b>

           <b>cuFileRead</b>

           <b>cuFileWrite</b>

   <b>CUfileError_t</b> <b>cuFileBufRegister</b> <b>(const</b> <b>void</b> <b>*</b> <b>bufPtr_base,</b> <b>size_t</b> <b>length,</b> <b>int</b> <b>flags)</b>
       register an existing cudaMalloced memory with cuFile to pin for GPUDirect Storage access or register host
       allocated memory with cuFile.

       <b>Parameters:</b>
           <u>bufPtr_base</u> buffer pointer allocated
           <u>length</u> size of memory region from the above specified bufPtr
           <u>flags</u> CU_FILE_RDMA_REGISTER

       <b>Returns:</b>
           CU_FILE_SUCCESS on success

           CU_FILE_NVFS_DRIVER_ERROR

           CU_FILE_INVALID_VALUE

           CU_FILE_CUDA_ERROR for unsupported memory type

           CU_FILE_MEMORY_ALREADY_REGISTERED on error

           CU_FILE_GPU_MEMORY_PINNING_FAILED if not enough pinned memory is available

       <b>Note:</b>
           This memory will be use to perform GPU direct DMA from the supported storage.

       <b>Warning:</b>
           This  API is intended for usecases where the memory is used as streaming buffer that is reused across
           multiple cuFile IO operations before calling <b>cuFileBufDeregister</b>

       <b>See</b> <b>also:</b>
           <b>cuFileBufDeregister</b>

           <b>cuFileRead</b>

           <b>cuFileWrite</b>

   <b>CUfileError_t</b> <b>cuFileDriverClose</b> <b>(void)</b>
   <b>CUfileError_t</b> <b>cuFileDriverClose_v2</b> <b>(void)</b>
       reset the cuFile library and release the nvidia-fs driver

       <b>Returns:</b>
           CU_FILE_SUCCESS on success

           CU_FILE_DRIVER_CLOSING if there are any active IO operations using <b>cuFileRead</b> or <b>cuFileWrite</b>

       <b>See</b> <b>also:</b>
           <b>cuFileDriverOpen</b>

   <b>CUfileError_t</b> <b>cuFileDriverGetProperties</b> <b>(CUfileDrvProps_t</b> <b>*</b> <b>props)</b>
       Gets the Driver session properties.

       <b>Returns:</b>
           CU_FILE_SUCCESS on success

       <b>See</b> <b>also:</b>
           <b>cuFileDriverSetPollMode</b>

           <b>cuFileDriverSetMaxDirectIOSize</b>

           <b>cuFileDriverSetMaxCacheSize</b>

           <b>cuFileDriverSetMaxPinnedMemSize</b>

   <b>CUfileError_t</b> <b>cuFileDriverOpen</b> <b>(void)</b>
       Initialize the cuFile library and open the nvidia-fs driver.

       <b>Returns:</b>
           CU_FILE_SUCCESS on success

           CU_FILE_DRIVER_NOT_INITIALIZED

           CU_FILE_DRIVER_VERSION_MISMATCH on driver version mismatch error

       <b>See</b> <b>also:</b>
           <b>cuFileDriverClose</b>

   <b>CUfileError_t</b> <b>cuFileDriverSetMaxCacheSize</b> <b>(size_t</b> <b>max_cache_size)</b>
       Control parameter to set maximum GPU memory reserved per device by the library for internal buffering.

       <b>Parameters:</b>
           <u>max_cache_size</u> The maximum GPU buffer space per device used for internal use in KB

       <b>Returns:</b>
           CU_FILE_SUCCESS on success

           CU_FILE_DRIVER_NOT_INITIALIZED if the driver is not initialized

           CU_FILE_DRIVER_VERSION_MISMATCH, CU_FILE_DRIVER_UNSUPPORTED_LIMIT on error

       <b>Warning:</b>
           This is an advanced command and should be tuned based on supported GPU memory

       <b>See</b> <b>also:</b>
           <b>cuFileDriverGetProperties</b>

   <b>CUfileError_t</b> <b>cuFileDriverSetMaxDirectIOSize</b> <b>(size_t</b> <b>max_direct_io_size)</b>
       Control parameter to set max IO size(KB) used by the library to talk to nvidia-fs driver.

       <b>Parameters:</b>
           <u>max_direct_io_size</u> maximum allowed direct io size in KB

       <b>Returns:</b>
           CU_FILE_SUCCESS on success

           CU_FILE_DRIVER_NOT_INITIALIZED if the driver is not initialized

           CU_FILE_DRIVER_VERSION_MISMATCH, CU_FILE_DRIVER_UNSUPPORTED_LIMIT on error

       <b>Warning:</b>
           This is an advanced command and should be tuned based on available system memory

       <b>See</b> <b>also:</b>
           <b>cuFileDriverGetProperties</b>

   <b>CUfileError_t</b> <b>cuFileDriverSetMaxPinnedMemSize</b> <b>(size_t</b> <b>max_pinned_size)</b>
       Sets maximum buffer space that is pinned in KB for use by <b>cuFileBufRegister</b>.

       <b>Parameters:</b>
           <u>max_pinned_size</u> maximum buffer space that is pinned in KB

       <b>Returns:</b>
           CU_FILE_SUCCESS on success

           CU_FILE_DRIVER_NOT_INITIALIZED if the driver is not initialized

           CU_FILE_DRIVER_VERSION_MISMATCH, CU_FILE_DRIVER_UNSUPPORTED_LIMIT on error

       <b>Warning:</b>
           This is an advanced command and should be tuned based on supported GPU memory

       <b>See</b> <b>also:</b>
           <b>cuFileDriverGetProperties</b>

   <b>CUfileError_t</b> <b>cuFileDriverSetPollMode</b> <b>(bool</b> <b>poll,</b> <b>size_t</b> <b>poll_threshold_size)</b>
       Sets whether the Read/Write APIs use polling to do IO operations.

       <b>Parameters:</b>
           <u>poll</u> boolean to indicate whether to use poll mode or not
           <u>poll_threshold_size</u> max IO size to use for POLLING mode in KB

       <b>Returns:</b>
           CU_FILE_SUCCESS on success

           CU_FILE_DRIVER_NOT_INITIALIZED if the driver is not initialized

           CU_FILE_DRIVER_VERSION_MISMATCH, CU_FILE_DRIVER_UNSUPPORTED_LIMIT on error

       <b>Warning:</b>
           This is an advanced command and should be tuned based on available system memory

       <b>See</b> <b>also:</b>
           <b>cuFileDriverGetProperties</b>

   <b>CUfileError_t</b> <b>cuFileGetVersion</b> <b>(int</b> <b>*</b> <b>version)</b>
       <b>Returns:</b>
           cufile library version.

       version is returned as (1000 major + 10 minor).  example, CUFILE 1.7.0 would be represented by 1070.

       <b>Note:</b>
           This is useful for applications that need to inquire the library.

       <b>Returns:</b>
           CU_FILE_SUCCESS on success

           CU_FILE_INVALID_VALUE if the input parameter is null.

           CU_FILE_DRIVER_VERSION_READ_ERROR if the version is not available.

   <b>void</b> <b>cuFileHandleDeregister</b> <b>(CUfileHandle_t</b> <b>fh)</b>
       releases a registered filehandle from cuFile

       <b>Parameters:</b>
           <u>fh</u> <b>CUfileHandle_t</b> file handle

       <b>Returns:</b>
           void

       <b>See</b> <b>also:</b>
           <b>cuFileHandleRegister</b>

   <b>CUfileError_t</b> <b>cuFileHandleRegister</b> <b>(CUfileHandle_t</b> <b>*</b> <b>fh,</b> <b>CUfileDescr_t</b> <b>*</b> <b>descr)</b>
       cuFileHandleRegister is required, and performs extra checking  that  is  memoized  to  provide  increased
       performance on later cuFile operations.

       <b>Parameters:</b>
           <u>fh</u> <b>CUfileHandle_t</b> opaque file handle for IO operations
           <u>descr</u> <b>CUfileDescr_t</b> file descriptor (OS agnostic)

       <b>Returns:</b>
           CU_FILE_SUCCESS  on  successful  completion.  fh  will be updated for use in <b>cuFileRead</b>, <b>cuFileWrite</b>,
           <b>cuFileHandleDeregister</b>

           CU_FILE_DRIVER_NOT_INITIALIZED on failure to load driver

           CU_FILE_IO_NOT_SUPPORTED - if filesystem is not supported

           CU_FILE_INVALID_VALUE if null or bad api arguments

           CU_FILE_INVALID_FILE_OPEN_FLAG if file is opened with unsupported modes like no O_DIRECT

           CU_FILE_INVALID_FILE_TYPE if filepath is not valid or is not a regular file

           CU_FILE_HANDLE_ALREADY_REGISTERED if file handle/descriptor is already registered

       <b>Description</b> cuFileHandleRegister registers the open file descriptor for use with cuFile IO operations.

       This API will ensure that the file’s descriptor is checked for GPUDirect Storage support  and  returns  a
       valid file handle on CU_FILE_SUCCESS.

       <b>Note:</b>
           the file needs to be opened in O_DIRECT mode to support GPUDirect Storage.

       <b>See</b> <b>also:</b>
           <b>cuFileRead</b>

           <b>cuFileWrite</b>

           <b>cuFileHandleDeregister</b>

   <b>ssize_t</b>   <b>cuFileRead</b>   <b>(CUfileHandle_t</b>  <b>fh,</b>  <b>void</b>  <b>*</b>  <b>bufPtr_base,</b>  <b>size_t</b>  <b>size,</b>  <b>off_t</b>  <b>file_offset,</b>  <b>off_t</b>
       <b>bufPtr_offset)</b>
       read data from a registered file handle to a specified device or host memory

       <b>Parameters:</b>
           <u>fh</u> <b>CUfileHandle_t</b> opaque file handle
           <u>bufPtr_base</u> base address of buffer in device or host memory
           <u>size</u> size bytes to read
           <u>file_offset</u> file-offset from beginning of the file
           <u>bufPtr_offset</u> offset relative to the bufPtr_base pointer to read into.

       <b>Returns:</b>
           size of bytes successfully read

           -1 on error, in which case errno is set to indicate filesystem errors.

           all other errors will return a negative integer value of <b>CUfileOpError</b> enum value.

       <b>Note:</b>
           If the  bufPtr  is  not  registered  with  <b>cuFileBufRegister</b>,  the  data  will  be  buffered  through
           preallocated pinned buffers if needed.

           This  is  useful for applications that need to perform IO to unaligned file offsets and/or size. This
           is also recommended for cases where the BAR1 memory size is smaller than the size  of  the  allocated
           memory.

       <b>See</b> <b>also:</b>
           <b>cuFileBufRegister</b>

           <b>cuFileHandleRegister</b>

           <b>cuFileWrite</b>

   <b>CUfileError_t</b> <b>cuFileReadAsync</b> <b>(CUfileHandle_t</b> <b>fh,</b> <b>void</b> <b>*</b> <b>bufPtr_base,</b> <b>size_t</b> <b>*</b> <b>size_p,</b> <b>off_t</b> <b>*</b> <b>file_offset_p,</b>
       <b>off_t</b> <b>*</b> <b>bufPtr_offset_p,</b> <b>ssize_t</b> <b>*</b> <b>bytes_read_p,</b> <b>CUstream</b> <b>stream)</b>
       <b>Parameters:</b>
           <u>fh</u> The cuFile handle for the file.
           <u>bufPtr_base</u> base address of buffer in device or host memory
           <u>size_p</u> pointer to size bytes to read

       <b>Note:</b>
           *size_p  if  the size is not known at the time of submission, then must provide the max possible size
           for I/O request.

       <b>Parameters:</b>
           <u>file_offset_p</u> pointer to file-offset from beginning of the file
           <u>bufPtr_offset_p</u> pointer to offset relative to the bufPtr_base pointer to read into.
           <u>bytes_read_p</u> pointer to the number of bytes that were successfully read.
           <u>CUstream</u> stream cuda stream for the operation.

       <b>Returns:</b>
           size of bytes successfully read in *bytes_read_p

           -1 on error, in which case errno is set to indicate filesystem errors.

           all other errors will return a negative integer value of <b>CUfileOpError</b> enum value.

       <b>Note:</b>
           If the bufPtr_base is not registered with  <b>cuFileBufRegister</b>,  the  data  will  be  buffered  through
           preallocated pinned buffers.

           This  is  useful for applications that need to perform IO to unaligned file offsets and/or size. This
           is also recommended for cases where the BAR1 memory size is smaller than the size  of  the  allocated
           memory.

           If  the  stream  is  registered with cuFileStreamRegister, the IO setup and teardown overhead will be
           reduced.

           on cuda stream errors, the user must call cuFileStreamDeregister to release  any  outstanding  cuFile
           resources for the stream.

       <b>See</b> <b>also:</b>
           <b>cuFileBufRegister</b>

           <b>cuFileHandleRegister</b>

           <b>cuFileRead</b>

           <b>cuFileStreamRegister</b>

           <b>cuFileStreamDeregister</b>

   <b>CUfileError_t</b> <b>cuFileStreamDeregister</b> <b>(CUstream</b> <b>stream)</b>
       <b>Parameters:</b>
           <u>CUstream</u> cuda stream for the operation.

       <b>Note:</b>
           deallocates resources used by previous cuFile asynchronous operations for the cuda stream

           highly  recommend  to  call  after cuda stream errors to release any outstanding cuFile resources for
           this stream

           must be called before cuStreamDestroy call for the specified stream.

           This is useful for applications that need to perform IO to unaligned file offsets and/or  size.  This
           is  also  recommended  for cases where the BAR1 memory size is smaller than the size of the allocated
           memory.

       <b>Returns:</b>
           CU_FILE_SUCCESS on success

           CU_FILE_DRIVER_NOT_INITIALIZED if the driver is not initialized

           CU_FILE_INVALID_VALUE if the stream is invalid

       <b>See</b> <b>also:</b>
           <b>cuFileReadAsync</b>

           <b>cuFileWriteAsync</b>

           <b>cuFileStreamRegister</b>

   <b>CUfileError_t</b> <b>cuFileStreamRegister</b> <b>(CUstream</b> <b>stream,</b> <b>unsigned</b> <b>flags)</b>
       <b>Parameters:</b>
           <u>CUstream</u> cuda stream for the operation.
           <u>flags</u> for the stream to improve the stream execution of IO based on input parameters.

       <b>Note:</b>
           supported FLAGS are

           CU_FILE_STREAM_FIXED_BUF_OFFSET - buffer pointer offset is set at submission time

           CU_FILE_STREAM_FIXED_FILE_OFFSET - file offset is set at submission time

           CU_FILE_STREAM_FIXED_FILE_SIZE - file size is set at submission time

           CU_FILE_STREAM_PAGE_ALIGNED_INPUTS - size, offset and buffer offset are 4k aligned

           allocates resources needed to support cuFile operations asynchronously for the cuda stream

           This is useful for applications that need to perform IO to unaligned file offsets and/or  size.  This
           is  also  recommended  for cases where the BAR1 memory size is smaller than the size of the allocated
           memory.

       <b>Returns:</b>
           CU_FILE_SUCCESS on success

           CU_FILE_DRIVER_NOT_INITIALIZED if the driver is not initialized

           CU_FILE_INVALID_VALUE if the stream is invalid

       <b>See</b> <b>also:</b>
           <b>cuFileReadAsync</b>

           <b>cuFileWriteAsync</b>

           <b>cuFileStreamDeregister</b>

   <b>long</b> <b>cuFileUseCount</b> <b>(void)</b>
       returns use count of cufile drivers at that moment by the process.

   <b>ssize_t</b> <b>cuFileWrite</b> <b>(CUfileHandle_t</b> <b>fh,</b> <b>const</b> <b>void</b> <b>*</b>  <b>bufPtr_base,</b>  <b>size_t</b>  <b>size,</b>  <b>off_t</b>  <b>file_offset,</b>  <b>off_t</b>
       <b>bufPtr_offset)</b>
       write data from a specified device or host memory to a registered file handle

       <b>Parameters:</b>
           <u>fh</u> <b>CUfileHandle_t</b> opaque file handle
           <u>bufPtr_base</u> base address of buffer in device or host memory
           <u>size</u> size bytes to write
           <u>file_offset</u> file-offset from beginning of the file
           <u>bufPtr_offset</u> offset relative to the bufPtr_base pointer to write from.

       <b>Returns:</b>
           size of bytes successfully written

           -1 on error, in which case errno is set to indicate filesystem errors.

           all other errors will return a negative integer value of <b>CUfileOpError</b> enum value.

       <b>Note:</b>
           If  the  bufPtr  is  not  registered  with  <b>cuFileBufRegister</b>,  the  data  will  be  buffered through
           preallocated pinned buffers if needed.

           This is useful for applications that need to perform IO to unaligned file offsets and/or  size.  This
           is  also  recommended  for cases where the BAR1 memory size is smaller than the size of the allocated
           memory.

       <b>See</b> <b>also:</b>
           <b>cuFileBufRegister</b>

           <b>cuFileHandleRegister</b>

           <b>cuFileRead</b>

   <b>CUfileError_t</b>  <b>cuFileWriteAsync</b>  <b>(CUfileHandle_t</b>  <b>fh,</b>  <b>void</b>  <b>*</b>  <b>bufPtr_base,</b>  <b>size_t</b>  <b>*</b>   <b>size_p,</b>   <b>off_t</b>   <b>*</b>
       <b>file_offset_p,</b> <b>off_t</b> <b>*</b> <b>bufPtr_offset_p,</b> <b>ssize_t</b> <b>*</b> <b>bytes_written_p,</b> <b>CUstream</b> <b>stream)</b>
       <b>Parameters:</b>
           <u>fh</u> The cuFile handle for the file.
           <u>bufPtr_base</u> base address of buffer in device or host memory
           <u>size_p</u> pointer to size bytes to write.

       <b>Note:</b>
           *size_p  if  the size is not known at the time of submission, then must provide the max possible size
           for I/O request.

       <b>Parameters:</b>
           <u>file_offset_p</u> pointer to file-offset from beginning of the file
           <u>bufPtr_offset_p</u> pointer to offset relative to the bufPtr_base pointer to write from.
           <u>bytes_written_p</u> pointer to the number of bytes that were successfully written.
           <u>CUstream</u> cuda stream for the operation.

       <b>Returns:</b>
           size of bytes successfully written in *bytes_written_p

           -1 on error, in which case errno is set to indicate filesystem errors.

           all other errors will return a negative integer value of <b>CUfileOpError</b> enum value.

       <b>Note:</b>
           If the bufPtr_base is not registered with  <b>cuFileBufRegister</b>,  the  data  will  be  buffered  through
           preallocated pinned buffers.

           This  is  useful for applications that need to perform IO to unaligned file offsets and/or size. This
           is also recommended for cases where the BAR1 memory size is smaller than the size  of  the  allocated
           memory.

           If  the  stream is registered with cuFileStreamRegister prior to this call, the IO setup and teardown
           overhead will be reduced.

           on cuda stream errors, the user must call cuFileStreamDeregister to release  any  outstanding  cuFile
           resources for the stream.

       <b>See</b> <b>also:</b>
           <b>cuFileBufRegister</b>

           <b>cuFileHandleRegister</b>

           <b>cuFileWrite</b>

           <b>cuFileStreamRegister</b>

           <b>cuFileStreamDeregister</b>

</pre><h4><b>Variable</b> <b>Documentation</b></h4><pre>
   <b>CUfileOpError</b>
</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for GPUDirect Storage from the source code.

GPUDirect Storage                                Wed Mar 13 2024                                     <u><a href="../man3/cufile.h.3.html">cufile.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>