<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL::Tiny - A very simple SQL-building library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsql-tiny-perl">libsql-tiny-perl_0.04-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SQL::Tiny - A very simple SQL-building library

</pre><h4><b>VERSION</b></h4><pre>
       Version 0.04

</pre><h4><b>SYNOPSIS</b></h4><pre>
           my ($sql,$binds) = sql_select( 'users', [ 'name', 'status' ], { status =&gt; [ 'Deleted', 'Inactive' ] }, { order_by =&gt; 'name' } );

           my ($sql,$binds) = sql_select( 'users', [ 'COUNT(*)' ], { status =&gt; [ 'Deleted', 'Inactive' ] }, { group_by =&gt; 'status' } );

           my ($sql,$binds) = sql_insert( 'users', { name =&gt; 'Dave', status =&gt; 'Active' } );

           my ($sql,$binds) = sql_update( 'users', { status =&gt; 'Inactive' }, { password =&gt; undef } );

           my ($sql,$binds) = sql_delete( 'users', { status =&gt; 'Inactive' } );

</pre><h4><b>DOCUMENTATION</b></h4><pre>
       A very simple SQL-building library.  It's not for all your SQL needs, only the very simple ones.

       It doesn't handle JOINs.  It doesn't handle subselects.  It's only for simple SQL.

       In my test suites, I have a lot of ad hoc SQL queries, and it drives me nuts to have so much SQL code
       lying around.  SQL::Tiny is for generating SQL code for simple cases.

       I'd far rather have:

           my ($sql,$binds) = sql_insert(
               'users',
               {
                   name      =&gt; 'Dave',
                   salary    =&gt; 50000,
                   status    =&gt; 'Active',
                   dateadded =&gt; \'SYSDATE()',
                   qty       =&gt; \[ 'ROUND(?)', 14.5 ],
               }
           );

       than hand-coding:

           my $sql   = 'INSERT INTO users (name,salary,status,dateadded,qty) VALUES (:name,:status,:salary,SYSDATE(),ROUND(:qty))';
           my $binds = {
               ':name'      =&gt; 'Dave',
               ':salary'    =&gt; 50000,
               ':status'    =&gt; 'Active',
               ':dateadded' =&gt; \'SYSDATE()',
               ':qty'       =&gt; 14.5,
           };

       or even the positional:

           my $sql   = 'INSERT INTO users (name,salary,status,dateadded,qty) VALUES (?,?,?,SYSDATE(),ROUND(?))';
           my $binds = [ 'Dave', 50000, 'Active', 14.5 ];

       The trade-off for that brevity of code is that SQL::Tiny has to make new SQL and binds from the input
       every time. You can't cache the SQL that comes back from SQL::Tiny because the placeholders could vary
       depending on what the input data is. Therefore, you don't want to use SQL::Tiny where speed is essential.

       The other trade-off is that SQL::Tiny handles only very simple code.  It won't handle JOINs of any kind.

       SQL::Tiny isn't meant for all of your SQL needs, only the simple ones that you do over and over.

</pre><h4><b>EXPORT</b></h4><pre>
       All subs can be exported, but none are by default.  ":all" exports all subs.

</pre><h4><b>SUBROUTINES/METHODS</b></h4><pre>
   <b>sql_select(</b> <b>$table,</b> <b>\@columns,</b> <b>\%where</b> <b>[,</b> <b>\%other</b> <b>]</b> <b>)</b>
       Creates simple SELECTs and binds.

       The %other can contain "group_by" and "order_by".

       Calling:

           my ($sql,$binds) = sql_select(
               'users',
               [qw( userid name )],
               { status =&gt; 'X' ],
               { order_by =&gt; 'name' },
           );

       returns:

           $sql   = 'SELECT userid,name FROM users WHERE status=? ORDER BY name';
           $binds = [ 'X' ];

   <b>sql_insert(</b> <b>$table,</b> <b>\%values</b> <b>)</b>
       Creates simple INSERTs and binds.

       Calling:

           my ($sql,$binds) = sql_insert(
               'users',
               {
                   serialno   =&gt; '12345',
                   name       =&gt; 'Dave',
                   rank       =&gt; 'Sergeant',
                   height     =&gt; undef,
                   date_added =&gt; \'SYSDATE()',
               }
           );

       returns:

           $sql   = 'INSERT INTO users (date_added,height,name,rank,serialno) VALUES (SYSDATE(),NULL,?,?,?)';
           $binds = [ 'Dave', 'Sergeant', 12345 ]

   <b>sql_update(</b> <b>$table,</b> <b>\%values,</b> <b>\%where</b> <b>)</b>
       Creates simple UPDATE calls and binds.

       Calling:

           my ($sql,$binds) = sql_update(
               'users',
               {
                   status     =&gt; 'X',
                   lockdate   =&gt; undef,
               },
               {
                   orderdate =&gt; \'SYSDATE()',
               },
           );

       returns:

           $sql   = 'UPDATE users SET lockdate=NULL, status=? WHERE orderdate=SYSDATE()'
           $binds = [ 'X' ]

   <b>sql_delete(</b> <b>$table,</b> <b>\%where</b> <b>)</b>
       Creates simple DELETE calls and binds.

       Calling:

           my ($sql,$binds) = sql_delete(
               'users',
               {
                   serialno   =&gt; 12345,
                   height     =&gt; undef,
                   date_added =&gt; \'SYSDATE()',
                   status     =&gt; [qw( X Y Z )],
               },
           );

       returns:

           $sql   = 'DELETE FROM users WHERE date_added = SYSDATE() AND height IS NULL AND serialno = ? AND status IN (?,?,?)'
           $binds = [ 12345, 'X', 'Y', 'Z' ]

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Lester, "&lt;andy at petdance.com&gt;"

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests to &lt;https://github.com/petdance/sql-tiny/issues&gt;, or email me
       directly.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc SQL::Tiny

       You can also look for information at:

       •   MetaCPAN

           &lt;https://metacpan.org/release/SQL-Tiny&gt;

       •   GitHub issue tracker

           &lt;https://github.com/petdance/sql-tiny/issues&gt;

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to the following folks for their contributions: Mohammad S Anwar, Tim Heaney.

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright 2019 Andy Lester.

       This  program  is  free  software;  you  can  redistribute it and/or modify it under the terms of the the
       Artistic License (2.0). You may obtain a copy of the full license at:

       &lt;<a href="http://www.perlfoundation.org/artistic_license_2_0">http://www.perlfoundation.org/artistic_license_2_0</a>&gt;

perl v5.36.0                                       2022-11-21                                     <u>SQL::<a href="../man3pm/Tiny.3pm.html">Tiny</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>