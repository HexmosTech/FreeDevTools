<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BerkeleyDB - Perl extension for Berkeley DB version 2, 3, 4, 5 or 6</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libberkeleydb-perl">libberkeleydb-perl_0.66-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       BerkeleyDB - Perl extension for Berkeley DB version 2, 3, 4, 5 or 6

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use BerkeleyDB;

         $env = new BerkeleyDB::Env [OPTIONS] ;

         $db  = tie %hash, 'BerkeleyDB::Hash', [OPTIONS] ;
         $db  = new BerkeleyDB::Hash [OPTIONS] ;

         $db  = tie %hash, 'BerkeleyDB::Btree', [OPTIONS] ;
         $db  = new BerkeleyDB::Btree [OPTIONS] ;

         $db  = tie @array, 'BerkeleyDB::Recno', [OPTIONS] ;
         $db  = new BerkeleyDB::Recno [OPTIONS] ;

         $db  = tie @array, 'BerkeleyDB::Queue', [OPTIONS] ;
         $db  = new BerkeleyDB::Queue [OPTIONS] ;

         $db  = new BerkeleyDB::Heap [OPTIONS] ;

         $db  = new BerkeleyDB::Unknown [OPTIONS] ;

         $status = BerkeleyDB::db_remove [OPTIONS]
         $status = BerkeleyDB::db_rename [OPTIONS]
         $status = BerkeleyDB::db_verify [OPTIONS]

         $hash{$key} = $value ;
         $value = $hash{$key} ;
         each %hash ;
         keys %hash ;
         values %hash ;

         $env = $db-&gt;Env()
         $status = $db-&gt;db_get()
         $status = $db-&gt;db_exists() ;
         $status = $db-&gt;db_put() ;
         $status = $db-&gt;db_del() ;
         $status = $db-&gt;db_sync() ;
         $status = $db-&gt;db_close() ;
         $status = $db-&gt;db_pget()
         $hash_ref = $db-&gt;db_stat() ;
         $status = $db-&gt;db_key_range();
         $type = $db-&gt;type() ;
         $status = $db-&gt;status() ;
         $boolean = $db-&gt;byteswapped() ;
         $status = $db-&gt;truncate($count) ;
         $status = $db-&gt;compact($start, $stop, $c_data, $flags, $end);
         $status = $db-&gt;get_blob_threshold($t1) ;
         $status = $db-&gt;get_blob_dir($dir) ;

         $bool = $env-&gt;cds_enabled();
         $bool = $db-&gt;cds_enabled();
         $lock = $db-&gt;cds_lock();
         $lock-&gt;cds_unlock();

         ($flag, $old_offset, $old_length) = $db-&gt;partial_set($offset, $length) ;
         ($flag, $old_offset, $old_length) = $db-&gt;partial_clear() ;

         $cursor = $db-&gt;db_cursor([$flags]) ;
         $newcursor = $cursor-&gt;c_dup([$flags]);
         $status = $cursor-&gt;c_get() ;
         $status = $cursor-&gt;c_put() ;
         $status = $cursor-&gt;c_del() ;
         $status = $cursor-&gt;c_count() ;
         $status = $cursor-&gt;c_pget() ;
         $status = $cursor-&gt;status() ;
         $status = $cursor-&gt;c_close() ;
         $stream = $cursor-&gt;db_stream() ;

         $cursor = $db-&gt;db_join() ;
         $status = $cursor-&gt;c_get() ;
         $status = $cursor-&gt;c_close() ;

         $status = $stream-&gt;size($S);
         $status = $stream-&gt;read($data, $offset, $size);
         $status = $stream-&gt;write($data, $offset);

         $status = $env-&gt;txn_checkpoint()
         $hash_ref = $env-&gt;txn_stat()
         $status = $env-&gt;set_mutexlocks()
         $status = $env-&gt;set_flags()
         $status = $env-&gt;set_timeout()
         $status = $env-&gt;lock_detect()
         $status = $env-&gt;lsn_reset()
         $status = $env-&gt;get_blob_threshold($t1) ;
         $status = $env-&gt;get_blob_dir($dir) ;

         $txn = $env-&gt;txn_begin() ;
         $db-&gt;Txn($txn);
         $txn-&gt;Txn($db1, $db2,...);
         $status = $txn-&gt;txn_prepare()
         $status = $txn-&gt;txn_commit()
         $status = $txn-&gt;txn_abort()
         $status = $txn-&gt;txn_id()
         $status = $txn-&gt;txn_discard()
         $status = $txn-&gt;set_timeout()

         $status = $env-&gt;set_lg_dir();
         $status = $env-&gt;set_lg_bsize();
         $status = $env-&gt;set_lg_max();

         $status = $env-&gt;set_data_dir() ;
         $status = $env-&gt;set_tmp_dir() ;
         $status = $env-&gt;set_verbose() ;
         $db_env_ptr = $env-&gt;DB_ENV() ;

         $BerkeleyDB::Error
         $BerkeleyDB::db_version

         # DBM Filters
         $old_filter = $db-&gt;filter_store_key  ( sub { ... } ) ;
         $old_filter = $db-&gt;filter_store_value( sub { ... } ) ;
         $old_filter = $db-&gt;filter_fetch_key  ( sub { ... } ) ;
         $old_filter = $db-&gt;filter_fetch_value( sub { ... } ) ;

         # deprecated, but supported
         $txn_mgr = $env-&gt;TxnMgr();
         $status = $txn_mgr-&gt;txn_checkpoint()
         $hash_ref = $txn_mgr-&gt;txn_stat()
         $txn = $txn_mgr-&gt;txn_begin() ;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>NOTE:</b> <b>This</b> <b>document</b> <b>is</b> <b>still</b> <b>under</b> <b>construction.</b> <b>Expect</b> <b>it</b> <b>to</b> <b>be</b> <b>incomplete</b> <b>in</b> <b>places.</b>

       This Perl module provides an interface to most of the functionality available in Berkeley DB versions 2,
       3, 5 and 6. In general it is safe to assume that the interface provided here to be identical to the
       Berkeley DB interface. The main changes have been to make the Berkeley DB API work in a Perl way. Note
       that if you are using Berkeley DB 2.x, the new features available in Berkeley DB 3.x or later are not
       available via this module.

       The reader is expected to be familiar with the Berkeley DB documentation. Where the interface provided
       here is identical to the Berkeley DB library and the... TODO

       The <b>db_appinit</b>, <b>db_cursor</b>, <b>db_open</b> and <b>db_txn</b> man pages are particularly relevant.

       The interface to Berkeley DB is implemented with a number of Perl classes.

</pre><h4><b>The</b> <b>BerkeleyDB::Env</b> <b>Class</b></h4><pre>
       The <b>BerkeleyDB::Env</b> class provides an interface to the Berkeley DB function <b>db_appinit</b> in Berkeley DB 2.x
       or <b>db_env_create</b> and <b>DBENV-&gt;open</b> in Berkeley DB 3.x (or later). Its purpose is to initialise a number of
       sub-systems that can then be used in a consistent way in all the databases you make use of in the
       environment.

       If you don't intend using transactions, locking or logging, then you shouldn't need to make use of
       <b>BerkeleyDB::Env</b>.

       Note that an environment consists of a number of files that Berkeley DB manages behind the scenes for
       you. When you first use an environment, it needs to be explicitly created. This is done by including
       "DB_CREATE" with the "Flags" parameter, described below.

   <b>Synopsis</b>
           $env = new BerkeleyDB::Env
                    [ -Home         =&gt; $path, ]
                    [ -Server       =&gt; $name, ]
                    [ -CacheSize    =&gt; $number, ]
                    [ -Config       =&gt; { name =&gt; value, name =&gt; value }, ]
                    [ -ErrFile      =&gt; filename, ]
                    [ -MsgFile      =&gt; filename, ]
                    [ -ErrPrefix    =&gt; "string", ]
                    [ -Flags        =&gt; number, ]
                    [ -SetFlags     =&gt; bitmask, ]
                    [ -LockDetect   =&gt; number, ]
                    [ -TxMax        =&gt; number, ]
                    [ -LogConfig    =&gt; number, ]
                    [ -MaxLockers   =&gt; number, ]
                    [ -MaxLocks     =&gt; number, ]
                    [ -MaxObjects   =&gt; number, ]
                    [ -SharedMemKey =&gt; number, ]
                    [ -Verbose      =&gt; boolean, ]
                    [ -BlobThreshold=&gt; $number, ]
                    [ -BlobDir      =&gt; directory, ]
                    [ -Encrypt      =&gt; { Password =&gt; "string",
                                         Flags    =&gt; number }, ]

       All the parameters to the BerkeleyDB::Env constructor are optional.

       -Home
            If  present,  this  parameter should point to an existing directory. Any files that <u>aren't</u> specified
            with an absolute path in the sub-systems that are initialised by the BerkeleyDB::Env class  will  be
            assumed to live in the <b>Home</b> directory.

            For  example,  in  the  code  fragment  below the database "fred.db" will be opened in the directory
            "/home/databases" because it was specified as a relative  path,  but  "joe.db"  will  be  opened  in
            "/other" because it was part of an absolute path.

                $env = new BerkeleyDB::Env
                         -Home         =&gt; "/home/databases"
                ...

                $db1 = new BerkeleyDB::Hash
                         -Filename =&gt; "fred.db",
                         -Env =&gt; $env
                ...

                $db2 = new BerkeleyDB::Hash
                         -Filename =&gt; "/other/joe.db",
                         -Env =&gt; $env
                ...

       -Server
            If  present,  this  parameter should be the hostname of a server that is running the Berkeley DB RPC
            server. All databases will be accessed via the RPC server.

       -Encrypt
            If present, this parameter will enable encryption of  all data before it is written to the database.
            This parameters must be given a hash reference. The format is shown below.

                -Encrypt =&gt; { -Password =&gt; "abc", Flags =&gt; DB_ENCRYPT_AES }

            Valid values for the Flags are 0 or "DB_ENCRYPT_AES".

            This option requires Berkeley DB 4.1 or better.

       -Cachesize
            If present, this parameter sets the size of the environments shared memory buffer pool.

       -TxMax
            If present, this parameter sets the number of simultaneous transactions that are  allowed.   Default
            100.  This default is definitely too low for programs using the MVCC capabilities.

       -LogConfig
            If present, this parameter is used to configure log options.

       -MaxLockers
            If present, this parameter is used to configure the maximum number of processes doing locking on the
            database.  Default 1000.

       -MaxLocks
            If  present,  this  parameter  is  used  to  configure  the maximum number of locks on the database.
            Default 1000.  This is often lower than required.

       -MaxObjects
            If present, this parameter is used to configure the maximum number of locked objects.  Default 1000.
            This is often lower than required.

       -SharedMemKey
            If present, this parameter sets the base segment ID for the shared memory region  used  by  Berkeley
            DB.

            This option requires Berkeley DB 3.1 or better.

            Use "$env-&gt;get_shm_key($id)" to find out the base segment ID used once the environment is open.

       -ThreadCount
            If  present,  this  parameter  declares  the  approximate number of threads that will be used in the
            database environment. This parameter is only necessary when the $env-&gt;failchk method will  be  used.
            It  does  not  actually  set  the  maximum  number of threads but rather is used to determine memory
            sizing.

            This option requires Berkeley DB 4.4 or better. It is only supported on Unix/Linux.

       -BlobThreshold
            Sets the size threshold that will be used to decide when data is stored as a BLOB. This option  must
            be set for a blobs to be used.

            This option requires Berkeley DB 6.0 or better.

       -BlobDir
            The directory where the BLOB objects are stored.

            If not specified blob files are stores in the environment directoy.

            This option requires Berkeley DB 6.0 or better.

       -Config
            This is a variation on the "-Home" parameter, but it allows finer control of where specific types of
            files will be stored.

            The parameter expects a reference to a hash. Valid keys are: <b>DB_DATA_DIR</b>, <b>DB_LOG_DIR</b> and <b>DB_TMP_DIR</b>

            The code below shows an example of how it can be used.

                $env = new BerkeleyDB::Env
                         -Config =&gt; { DB_DATA_DIR =&gt; "/home/databases",
                                      DB_LOG_DIR  =&gt; "/home/logs",
                                      DB_TMP_DIR  =&gt; "/home/tmp"
                                    }
                ...

       -ErrFile
            Expects  a  filename or filehandle. Any errors generated internally by Berkeley DB will be logged to
            this file. A useful debug setting is to open environments with either

                -ErrFile =&gt; *STDOUT

            or

                -ErrFile =&gt; *STDERR

       -ErrPrefix
            Allows a prefix to be added to the error messages before they are sent to <b>-ErrFile</b>.

       -Flags
            The <b>Flags</b> parameter specifies both  which  sub-systems  to  initialise,  as  well  as  a  number  of
            environment-wide options.  See the Berkeley DB documentation for more details of these options.

            Any of the following can be specified by OR'ing them:

            <b>DB_CREATE</b>

            If any of the files specified do not already exist, create them.

            <b>DB_INIT_CDB</b>

            Initialise the Concurrent Access Methods

            <b>DB_INIT_LOCK</b>

            Initialise the Locking sub-system.

            <b>DB_INIT_LOG</b>

            Initialise the Logging sub-system.

            <b>DB_INIT_MPOOL</b>

            Initialize  the  shared  memory  buffer  pool  subsystem.  This subsystem should be used whenever an
            application is using any Berkeley DB access method.

            <b>DB_INIT_TXN</b>

            Initialize the transaction subsystem. This subsystem should be used when recovery and  atomicity  of
            multiple operations are important. The DB_INIT_TXN flag implies the DB_INIT_LOG flag.

            <b>DB_MPOOL_PRIVATE</b>

            Create a private memory pool; see memp_open. Ignored unless DB_INIT_MPOOL is also specified.

            <b>DB_INIT_MPOOL</b> is also specified.

            <b>DB_NOMMAP</b>

            Do not map this database into process memory.

            <b>DB_RECOVER</b>

            Run  normal  recovery on this environment before opening it for normal use. If this flag is set, the
            DB_CREATE flag must also be set since the regions will be removed and recreated.

            The db_appinit function returns successfully if DB_RECOVER is specified and no log files  exist,  so
            it is necessary to ensure all necessary log files are present before running recovery.

            <b>DB_PRIVATE</b>

            <b>DB_RECOVER_FATAL</b>

            Run catastrophic recovery on this environment before opening it for normal use. If this flag is set,
            the DB_CREATE flag must also be set since the regions will be removed and recreated.

            The  db_appinit  function  returns  successfully  if  DB_RECOVER_FATAL is specified and no log files
            exist, so it is necessary to ensure all necessary log files are present before running recovery.

            <b>DB_THREAD</b>

            Ensure that handles returned by the Berkeley DB subsystems are useable by multiple threads within  a
            single process, i.e., that the system is free-threaded.

            <b>DB_TXN_NOSYNC</b>

            On  transaction commit, do not synchronously flush the log; see txn_open. Ignored unless DB_INIT_TXN
            is also specified.

            <b>DB_USE_ENVIRON</b>

            The Berkeley DB process' environment may be permitted to specify information to be used when  naming
            files;  see  Berkeley DB File Naming. As permitting users to specify which files are used can create
            security problems, environment information will be used in file naming for all  users  only  if  the
            DB_USE_ENVIRON flag is set.

            <b>DB_USE_ENVIRON_ROOT</b>

            The  Berkeley DB process' environment may be permitted to specify information to be used when naming
            files; see Berkeley DB File Naming. As permitting users to specify which files are used  can  create
            security  problems, if the DB_USE_ENVIRON_ROOT flag is set, environment information will be used for
            file naming only for users with a user-ID matching that of the superuser  (specifically,  users  for
            whom the <b><a href="../man2/getuid.2.html">getuid</a></b>(2) system call returns the user-ID 0).

       -SetFlags
            Calls   ENV-&gt;set_flags  with  the  supplied  bitmask.  Use  this  when  you  need  to  make  use  of
            DB_ENV-&gt;set_flags before DB_ENV-&gt;open is called.

            Only valid when Berkeley DB 3.x or better is used.

       -LockDetect
            Specifies what to do when a lock conflict occurs. The value should be one of

            <b>DB_LOCK_DEFAULT</b>

            Use the default policy as specified by db_deadlock.

            <b>DB_LOCK_OLDEST</b>

            Abort the oldest transaction.

            <b>DB_LOCK_RANDOM</b>

            Abort a random transaction involved in the deadlock.

            <b>DB_LOCK_YOUNGEST</b>

            Abort the youngest transaction.

       -Verbose
            Add extra debugging information to the messages sent to <b>-ErrFile</b>.

   <b>Methods</b>
       The environment class has the following methods:

       $env-&gt;errPrefix("string") ;
            This method is identical to the <b>-ErrPrefix</b> flag. It allows the error prefix  string  to  be  changed
            dynamically.

       $env-&gt;set_flags(bitmask, 1|0);
       $txn = $env-&gt;<b>TxnMgr()</b>
            Constructor   for  creating  a  <b>TxnMgr</b>  object.   See  "TRANSACTIONS"  for  more  details  of  using
            transactions.

            This method is deprecated. Access the transaction methods using the  <b>txn_</b>  methods  below  from  the
            environment object directly.

       $env-&gt;<b>txn_begin()</b>
            TODO

       $env-&gt;<b>txn_stat()</b>
            TODO

       $env-&gt;<b>txn_checkpoint()</b>
            TODO

       $env-&gt;<b>status()</b>
            Returns the status of the last BerkeleyDB::Env method.

       $env-&gt;<b>DB_ENV()</b>
            Returns a pointer to the underlying DB_ENV data structure that Berkeley DB uses.

       $env-&gt;get_shm_key($id)
            Writes  the  base  segment  ID for the shared memory region used by the Berkeley DB environment into
            $id. Returns 0 on success.

            This option requires Berkeley DB 4.2 or better.

            Use the "-SharedMemKey" option when opening the environmet to set the base segment ID.

       $env-&gt;<b>set_isalive()</b>
            Set the callback that determines if the thread of control, identified by the pid and tid  arguments,
            is still running.  This method should only be used in combination with $env-&gt;failchk.

            This option requires Berkeley DB 4.4 or better.

       $env-&gt;failchk($flags)
            The $env-&gt;failchk method checks for threads of control (either a true thread or a process) that have
            exited  while  manipulating  Berkeley  DB  library data structures, while holding a logical database
            lock, or with an  unresolved  transaction  (that  is,  a  transaction  that  was  never  aborted  or
            committed).

            If  $env-&gt;failchk  determines  a thread of control exited while holding database read locks, it will
            release those locks. If $env-&gt;failchk determines a thread  of  control  exited  with  an  unresolved
            transaction, the transaction will be aborted.

            Applications calling the $env-&gt;failchk method must have already called the $env-&gt;set_isalive method,
            on  the  same  DB  environment,  and  must  have  configured  their  database  environment using the
            -ThreadCount flag. The ThreadCount flag cannot be used on  an  environment  that  wasn't  previously
            initialized with it.

            This option requires Berkeley DB 4.4 or better.

       $env-&gt;stat_print
            Prints statistical information.

            If  the  "MsgFile" option is specified the output will be sent to the file. Otherwise output is sent
            to standard output.

            This option requires Berkeley DB 4.3 or better.

       $env-&gt;lock_stat_print
            Prints locking subsystem statistics.

            If the "MsgFile" option is specified the output will be sent to the file. Otherwise output  is  sent
            to standard output.

            This option requires Berkeley DB 4.3 or better.

       $env-&gt;mutex_stat_print
            Prints mutex subsystem statistics.

            If  the  "MsgFile" option is specified the output will be sent to the file. Otherwise output is sent
            to standard output.

            This option requires Berkeley DB 4.4 or better.

       $status = $env-&gt;get_blob_threshold($t1) ;
            Sets the parameter $t1 to the threshold value (in bytes) that is used to determine when a data  item
            is stored as a Blob.

       $status = $env-&gt;get_blob_dir($dir) ;
            Sets the $dir parameter to the directory where blob files are stored.

       $env-&gt;set_timeout($timeout, $flags)
       $env-&gt;<b>status()</b>
            Returns the status of the last BerkeleyDB::Env method.

   <b>Examples</b>
       TODO.

</pre><h4><b>Global</b> <b>Classes</b></h4><pre>
         $status = BerkeleyDB::db_remove [OPTIONS]
         $status = BerkeleyDB::db_rename [OPTIONS]
         $status = BerkeleyDB::db_verify [OPTIONS]

</pre><h4><b>THE</b> <b>DATABASE</b> <b>CLASSES</b></h4><pre>
       <b>BerkeleyDB</b> supports the following database formats:

       <b>BerkeleyDB::Hash</b>
            This  database  type allows arbitrary key/value pairs to be stored in data files. This is equivalent
            to the functionality provided by other hashing packages  like  DBM,  NDBM,  ODBM,  GDBM,  and  SDBM.
            Remember  though,  the files created using <b>BerkeleyDB::Hash</b> are not compatible with any of the other
            packages mentioned.

            A default hashing algorithm, which will be adequate for most applications, is built into BerkeleyDB.
            If you do need to use your own hashing algorithm it is possible to write your own in Perl  and  have
            <b>BerkeleyDB</b> use it instead.

       <b>BerkeleyDB::Btree</b>
            The Btree format allows arbitrary key/value pairs to be stored in a B+tree.

            As  with  the  <b>BerkeleyDB::Hash</b>  format,  it  is  possible to provide a user defined Perl routine to
            perform the comparison of keys. By default, though, the keys are stored in lexical order.

       <b>BerkeleyDB::Recno</b>
            TODO.

       <b>BerkeleyDB::Queue</b>
            TODO.

       <b>BerkeleyDB::Heap</b>
            TODO.

       <b>BerkeleyDB::Unknown</b>
            This isn't a database format at all. It is used when you  want  to  open  an  existing  Berkeley  DB
            database without having to know what type is it.

       Each of the database formats described above is accessed via a corresponding <b>BerkeleyDB</b> class. These will
       be described in turn in the next sections.

</pre><h4><b>BerkeleyDB::Hash</b></h4><pre>
       Equivalent  to  calling  <b>db_open</b>  with  type <b>DB_HASH</b> in Berkeley DB 2.x and calling <b>db_create</b> followed by
       <b>DB-&gt;open</b> with type <b>DB_HASH</b> in Berkeley DB 3.x or greater.

       Two forms of constructor are supported:

           $db = new BerkeleyDB::Hash
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       [ -BlobThreshold=&gt; $number, ]
                       [ -BlobDir      =&gt; directory, ]
                       # BerkeleyDB::Hash specific
                       [ -Ffactor       =&gt; number,]
                       [ -Nelem         =&gt; number,]
                       [ -Hash          =&gt; code reference,]
                       [ -DupCompare    =&gt; code reference,]

       and this

           [$db =] tie %hash, 'BerkeleyDB::Hash',
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       [ -BlobThreshold=&gt; $number, ]
                       [ -BlobDir      =&gt; directory, ]
                       # BerkeleyDB::Hash specific
                       [ -Ffactor       =&gt; number,]
                       [ -Nelem         =&gt; number,]
                       [ -Hash          =&gt; code reference,]
                       [ -DupCompare    =&gt; code reference,]

       When the "tie" interface is used, reading from and writing to the database is achieved via the tied hash.
       In this case the database operates like a Perl associative array that happens to be stored on disk.

       In addition to the high-level tied hash interface, it is possible to make use of the  underlying  methods
       provided by Berkeley DB

   <b>Options</b>
       In  addition  to  the  standard  set  of  options  (see "COMMON OPTIONS") <b>BerkeleyDB::Hash</b> supports these
       options:

       -Property
            Used to specify extra flags when opening a database. The following flags may be specified by bitwise
            OR'ing together one or more of the following values:

            <b>DB_DUP</b>

            When creating a new database, this flag enables the storing of duplicate keys in  the  database.  If
            <b>DB_DUPSORT</b>  is not specified as well, the duplicates are stored in the order they are created in the
            database.

            <b>DB_DUPSORT</b>

            Enables the sorting of duplicate keys in the database. Ignored if <b>DB_DUP</b> isn't also specified.

       -Ffactor
       -Nelem
            See the Berkeley DB documentation for details of these options.

       -Hash
            Allows you to provide a user defined hash function. If not specified, a  default  hash  function  is
            used. Here is a template for a user-defined hash function

                sub hash
                {
                    my ($data) = shift ;
                    ...
                    # return the hash value for $data
                    return $hash ;
                }

                tie %h, "BerkeleyDB::Hash",
                    -Filename =&gt; $filename,
                    -Hash     =&gt; \&amp;hash,
                    ...

            See "" for an example.

       -DupCompare
            Used in conjunction with the <b>DB_DUPOSRT</b> flag.

                sub compare
                {
                    my ($key, $key2) = @_ ;
                    ...
                    # return  0 if $key1 eq $key2
                    #        -1 if $key1 lt $key2
                    #         1 if $key1 gt $key2
                    return (-1 , 0 or 1) ;
                }

                tie %h, "BerkeleyDB::Hash",
                    -Filename   =&gt; $filename,
                    -Property   =&gt; DB_DUP|DB_DUPSORT,
                    -DupCompare =&gt; \&amp;compare,
                    ...

   <b>Methods</b>
       <b>BerkeleyDB::Hash</b> only supports the standard database methods.  See "COMMON DATABASE METHODS".

   <b>A</b> <b>Simple</b> <b>Tied</b> <b>Hash</b> <b>Example</b>
           use strict ;
           use BerkeleyDB ;
           use vars qw( %h $k $v ) ;

           my $filename = "fruit" ;
           unlink $filename ;
           tie %h, "BerkeleyDB::Hash",
                       -Filename =&gt; $filename,
                       -Flags    =&gt; DB_CREATE
               or die "Cannot open file $filename: $! $BerkeleyDB::Error\n" ;

           # Add a few key/value pairs to the file
           $h{"apple"} = "red" ;
           $h{"orange"} = "orange" ;
           $h{"banana"} = "yellow" ;
           $h{"tomato"} = "red" ;

           # Check for existence of a key
           print "Banana Exists\n\n" if $h{"banana"} ;

           # Delete a key/value pair.
           delete $h{"apple"} ;

           # print the contents of the file
           while (($k, $v) = each %h)
             { print "$k -&gt; $v\n" }

           untie %h ;

       here is the output:

           Banana Exists

           orange -&gt; orange
           tomato -&gt; red
           banana -&gt; yellow

       Note  that the like ordinary associative arrays, the order of the keys retrieved from a Hash database are
       in an apparently random order.

   <b>Another</b> <b>Simple</b> <b>Hash</b> <b>Example</b>
       Do the same as the previous example but not using tie.

           use strict ;
           use BerkeleyDB ;

           my $filename = "fruit" ;
           unlink $filename ;
           my $db = new BerkeleyDB::Hash
                       -Filename =&gt; $filename,
                       -Flags    =&gt; DB_CREATE
               or die "Cannot open file $filename: $! $BerkeleyDB::Error\n" ;

           # Add a few key/value pairs to the file
           $db-&gt;db_put("apple", "red") ;
           $db-&gt;db_put("orange", "orange") ;
           $db-&gt;db_put("banana", "yellow") ;
           $db-&gt;db_put("tomato", "red") ;

           # Check for existence of a key
           print "Banana Exists\n\n" if $db-&gt;db_get("banana", $v) == 0;

           # Delete a key/value pair.
           $db-&gt;db_del("apple") ;

           # print the contents of the file
           my ($k, $v) = ("", "") ;
           my $cursor = $db-&gt;db_cursor() ;
           while ($cursor-&gt;c_get($k, $v, DB_NEXT) == 0)
             { print "$k -&gt; $v\n" }

           undef $cursor ;
           undef $db ;

   <b>Duplicate</b> <b>keys</b>
       The code below is a variation on the examples above. This time the hash has been inverted. The  key  this
       time is colour and the value is the fruit name.  The <b>DB_DUP</b> flag has been specified to allow duplicates.

           use strict ;
           use BerkeleyDB ;

           my $filename = "fruit" ;
           unlink $filename ;
           my $db = new BerkeleyDB::Hash
                       -Filename =&gt; $filename,
                       -Flags    =&gt; DB_CREATE,
                       -Property  =&gt; DB_DUP
               or die "Cannot open file $filename: $! $BerkeleyDB::Error\n" ;

           # Add a few key/value pairs to the file
           $db-&gt;db_put("red", "apple") ;
           $db-&gt;db_put("orange", "orange") ;
           $db-&gt;db_put("green", "banana") ;
           $db-&gt;db_put("yellow", "banana") ;
           $db-&gt;db_put("red", "tomato") ;
           $db-&gt;db_put("green", "apple") ;

           # print the contents of the file
           my ($k, $v) = ("", "") ;
           my $cursor = $db-&gt;db_cursor() ;
           while ($cursor-&gt;c_get($k, $v, DB_NEXT) == 0)
             { print "$k -&gt; $v\n" }

           undef $cursor ;
           undef $db ;

       here is the output:

           orange -&gt; orange
           yellow -&gt; banana
           red -&gt; apple
           red -&gt; tomato
           green -&gt; banana
           green -&gt; apple

   <b>Sorting</b> <b>Duplicate</b> <b>Keys</b>
       In  the  previous  example,  when  there were duplicate keys, the values are sorted in the order they are
       stored in. The code below is identical to the previous example except the <b>DB_DUPSORT</b> flag is specified.

           use strict ;
           use BerkeleyDB ;

           my $filename = "fruit" ;
           unlink $filename ;
           my $db = new BerkeleyDB::Hash
                       -Filename =&gt; $filename,
                       -Flags    =&gt; DB_CREATE,
                       -Property  =&gt; DB_DUP | DB_DUPSORT
               or die "Cannot open file $filename: $! $BerkeleyDB::Error\n" ;

           # Add a few key/value pairs to the file
           $db-&gt;db_put("red", "apple") ;
           $db-&gt;db_put("orange", "orange") ;
           $db-&gt;db_put("green", "banana") ;
           $db-&gt;db_put("yellow", "banana") ;
           $db-&gt;db_put("red", "tomato") ;
           $db-&gt;db_put("green", "apple") ;

           # print the contents of the file
           my ($k, $v) = ("", "") ;
           my $cursor = $db-&gt;db_cursor() ;
           while ($cursor-&gt;c_get($k, $v, DB_NEXT) == 0)
             { print "$k -&gt; $v\n" }

           undef $cursor ;
           undef $db ;

       Notice that in the output below the duplicate values are sorted.

           orange -&gt; orange
           yellow -&gt; banana
           red -&gt; apple
           red -&gt; tomato
           green -&gt; apple
           green -&gt; banana

   <b>Custom</b> <b>Sorting</b> <b>Duplicate</b> <b>Keys</b>
       Another variation

       TODO

   <b>Changing</b> <b>the</b> <b>hash</b>
       TODO

   <b>Using</b> <b>db_stat</b>
       TODO

</pre><h4><b>BerkeleyDB::Btree</b></h4><pre>
       Equivalent to calling <b>db_open</b> with type <b>DB_BTREE</b> in Berkeley DB 2.x and  calling  <b>db_create</b>  followed  by
       <b>DB-&gt;open</b> with type <b>DB_BTREE</b> in Berkeley DB 3.x or greater.

       Two forms of constructor are supported:

           $db = new BerkeleyDB::Btree
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       [ -BlobThreshold=&gt; $number, ]
                       [ -BlobDir      =&gt; directory, ]
                       # BerkeleyDB::Btree specific
                       [ -Minkey        =&gt; number,]
                       [ -Compare       =&gt; code reference,]
                       [ -DupCompare    =&gt; code reference,]
                       [ -Prefix        =&gt; code reference,]

       and this

           [$db =] tie %hash, 'BerkeleyDB::Btree',
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       [ -BlobThreshold=&gt; $number, ]
                       [ -BlobDir      =&gt; directory, ]
                       # BerkeleyDB::Btree specific
                       [ -Minkey        =&gt; number,]
                       [ -Compare       =&gt; code reference,]
                       [ -DupCompare    =&gt; code reference,]
                       [ -Prefix        =&gt; code reference,]

   <b>Options</b>
       In  addition  to  the  standard  set  of  options (see "COMMON OPTIONS") <b>BerkeleyDB::Btree</b> supports these
       options:

       -Property
            Used to specify extra flags when opening a database. The following flags may be specified by bitwise
            OR'ing together one or more of the following values:

            <b>DB_DUP</b>

            When creating a new database, this flag enables the storing of duplicate keys in  the  database.  If
            <b>DB_DUPSORT</b>  is not specified as well, the duplicates are stored in the order they are created in the
            database.

            <b>DB_DUPSORT</b>

            Enables the sorting of duplicate keys in the database. Ignored if <b>DB_DUP</b> isn't also specified.

       Minkey
            TODO

       Compare
            Allow you to override the default sort order used in the database. See "Changing the sort order" for
            an example.

                sub compare
                {
                    my ($key, $key2) = @_ ;
                    ...
                    # return  0 if $key1 eq $key2
                    #        -1 if $key1 lt $key2
                    #         1 if $key1 gt $key2
                    return (-1 , 0 or 1) ;
                }

                tie %h, "BerkeleyDB::Hash",
                    -Filename   =&gt; $filename,
                    -Compare    =&gt; \&amp;compare,
                    ...

       Prefix
                sub prefix
                {
                    my ($key, $key2) = @_ ;
                    ...
                    # return number of bytes of $key2 which are
                    # necessary to determine that it is greater than $key1
                    return $bytes ;
                }

                tie %h, "BerkeleyDB::Hash",
                    -Filename   =&gt; $filename,
                    -Prefix     =&gt; \&amp;prefix,
                    ...
            =item DupCompare

                sub compare
                {
                    my ($key, $key2) = @_ ;
                    ...
                    # return  0 if $key1 eq $key2
                    #        -1 if $key1 lt $key2
                    #         1 if $key1 gt $key2
                    return (-1 , 0 or 1) ;
                }

                tie %h, "BerkeleyDB::Hash",
                    -Filename   =&gt; $filename,
                    -DupCompare =&gt; \&amp;compare,
                    ...

       set_bt_compress
            Enabled compression of the btree data. The callback interface is  not  supported  at  present.  Need
            Berkeley DB 4.8 or better.

   <b>Methods</b>
       <b>BerkeleyDB::Btree</b> supports the following database methods.  See also "COMMON DATABASE METHODS".

       All the methods below return 0 to indicate success.

       $status = $db-&gt;db_key_range($key, $less, $equal, $greater [, $flags])
            Given  a  key,  $key,  this  method  returns  the  proportion  of  keys less than $key in $less, the
            proportion equal to $key in $equal and the proportion greater than $key in $greater.

            The proportion is returned as a double in the range 0.0 to 1.0.

   <b>A</b> <b>Simple</b> <b>Btree</b> <b>Example</b>
       The code below is a simple example of using a btree database.

           use strict ;
           use BerkeleyDB ;

           my $filename = "tree" ;
           unlink $filename ;
           my %h ;
           tie %h, 'BerkeleyDB::Btree',
                       -Filename   =&gt; $filename,
                       -Flags      =&gt; DB_CREATE
             or die "Cannot open $filename: $! $BerkeleyDB::Error\n" ;

           # Add a key/value pair to the file
           $h{'Wall'} = 'Larry' ;
           $h{'Smith'} = 'John' ;
           $h{'mouse'} = 'mickey' ;
           $h{'duck'}  = 'donald' ;

           # Delete
           delete $h{"duck"} ;

           # Cycle through the keys printing them in order.
           # Note it is not necessary to sort the keys as
           # the btree will have kept them in order automatically.
           foreach (keys %h)
             { print "$_\n" }

           untie %h ;

       Here is the output from the code above. The keys have been sorted using  Berkeley  DB's  default  sorting
       algorithm.

           Smith
           Wall
           mouse

   <b>Changing</b> <b>the</b> <b>sort</b> <b>order</b>
       It  is possible to supply your own sorting algorithm if the one that Berkeley DB used isn't suitable. The
       code below is identical to the previous example except for the case insensitive compare function.

           use strict ;
           use BerkeleyDB ;

           my $filename = "tree" ;
           unlink $filename ;
           my %h ;
           tie %h, 'BerkeleyDB::Btree',
                       -Filename   =&gt; $filename,
                       -Flags      =&gt; DB_CREATE,
                       -Compare    =&gt; sub { lc $_[0] cmp lc $_[1] }
             or die "Cannot open $filename: $!\n" ;

           # Add a key/value pair to the file
           $h{'Wall'} = 'Larry' ;
           $h{'Smith'} = 'John' ;
           $h{'mouse'} = 'mickey' ;
           $h{'duck'}  = 'donald' ;

           # Delete
           delete $h{"duck"} ;

           # Cycle through the keys printing them in order.
           # Note it is not necessary to sort the keys as
           # the btree will have kept them in order automatically.
           foreach (keys %h)
             { print "$_\n" }

           untie %h ;

       Here is the output from the code above.

           mouse
           Smith
           Wall

       There are a few point to bear in mind if you want to change the ordering in a BTREE database:

       1.   The new compare function must be specified when you create the database.

       2.   You cannot change the ordering once the database has been  created.  Thus  you  must  use  the  same
            compare function every time you access the database.

   <b>Using</b> <b>db_stat</b>
       TODO

</pre><h4><b>BerkeleyDB::Recno</b></h4><pre>
       Equivalent  to  calling  <b>db_open</b>  with type <b>DB_RECNO</b> in Berkeley DB 2.x and calling <b>db_create</b> followed by
       <b>DB-&gt;open</b> with type <b>DB_RECNO</b> in Berkeley DB 3.x or greater.

       Two forms of constructor are supported:

           $db = new BerkeleyDB::Recno
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       # BerkeleyDB::Recno specific
                       [ -Delim           =&gt; byte,]
                       [ -Len             =&gt; number,]
                       [ -Pad             =&gt; byte,]
                       [ -Source          =&gt; filename,]

       and this

           [$db =] tie @arry, 'BerkeleyDB::Recno',
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       # BerkeleyDB::Recno specific
                       [ -Delim           =&gt; byte,]
                       [ -Len             =&gt; number,]
                       [ -Pad             =&gt; byte,]
                       [ -Source          =&gt; filename,]

   <b>A</b> <b>Recno</b> <b>Example</b>
       Here is a simple example that uses RECNO (if you are using a version of Perl earlier than  5.004_57  this
       example won't work -- see "Extra RECNO Methods" for a workaround).

           use strict ;
           use BerkeleyDB ;

           my $filename = "text" ;
           unlink $filename ;

           my @h ;
           tie @h, 'BerkeleyDB::Recno',
                       -Filename   =&gt; $filename,
                       -Flags      =&gt; DB_CREATE,
                       -Property   =&gt; DB_RENUMBER
             or die "Cannot open $filename: $!\n" ;

           # Add a few key/value pairs to the file
           $h[0] = "orange" ;
           $h[1] = "blue" ;
           $h[2] = "yellow" ;

           push @h, "green", "black" ;

           my $elements = scalar @h ;
           print "The array contains $elements entries\n" ;

           my $last = pop @h ;
           print "popped $last\n" ;

           unshift @h, "white" ;
           my $first = shift @h ;
           print "shifted $first\n" ;

           # Check for existence of a key
           print "Element 1 Exists with value $h[1]\n" if $h[1] ;

           untie @h ;

       Here is the output from the script:

           The array contains 5 entries
           popped black
           shifted white
           Element 1 Exists with value blue
           The last element is green
           The 2nd last element is yellow

</pre><h4><b>BerkeleyDB::Queue</b></h4><pre>
       Equivalent  to  calling  <b>db_create</b> followed by <b>DB-&gt;open</b> with type <b>DB_QUEUE</b> in Berkeley DB 3.x or greater.
       This database format isn't available if you use Berkeley DB 2.x.

       Two forms of constructor are supported:

           $db = new BerkeleyDB::Queue
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       # BerkeleyDB::Queue specific
                       [ -Len             =&gt; number,]
                       [ -Pad             =&gt; byte,]
                       [ -ExtentSize    =&gt; number, ]

       and this

           [$db =] tie @arry, 'BerkeleyDB::Queue',
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       # BerkeleyDB::Queue specific
                       [ -Len             =&gt; number,]
                       [ -Pad             =&gt; byte,]

</pre><h4><b>BerkeleyDB::Heap</b></h4><pre>
       Equivalent to calling <b>db_create</b> followed by <b>DB-&gt;open</b> with type <b>DB_HEAP</b> in Berkeley DB 5.2.x  or  greater.
       This database format isn't available if you use an older version of Berkeley DB.

       One form of constructor is supported:

           $db = new BerkeleyDB::Heap
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       [ -BlobThreshold=&gt; $number, ]
                       [ -BlobDir      =&gt; directory, ]
                       # BerkeleyDB::Heap specific
                       [ -HeapSize      =&gt; number, ]
                       [ -HeapSizeGb    =&gt; number, ]

</pre><h4><b>BerkeleyDB::Unknown</b></h4><pre>
       This class is used to open an existing database.

       Equivalent  to  calling <b>db_open</b> with type <b>DB_UNKNOWN</b> in Berkeley DB 2.x and calling <b>db_create</b> followed by
       <b>DB-&gt;open</b> with type <b>DB_UNKNOWN</b> in Berkeley DB 3.x or greater.

       The constructor looks like this:

           $db = new BerkeleyDB::Unknown
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],

   <b>An</b> <b>example</b>
</pre><h4><b>COMMON</b> <b>OPTIONS</b></h4><pre>
       All database access class constructors support the common set of options defined below. All are optional.

       -Filename
            The database filename. If no filename is specified, a temporary file will  be  created  and  removed
            once the program terminates.

       -Subname
            Specifies the name of the sub-database to open.  This option is only valid if you are using Berkeley
            DB 3.x or greater.

       -Flags
            Specify how the database will be opened/created. The valid flags are:

            <b>DB_CREATE</b>

            Create  any underlying files, as necessary. If the files do not already exist and the <b>DB_CREATE</b> flag
            is not specified, the call will fail.

            <b>DB_NOMMAP</b>

            Not supported by BerkeleyDB.

            <b>DB_RDONLY</b>

            Opens the database in read-only mode.

            <b>DB_THREAD</b>

            Not supported by BerkeleyDB.

            <b>DB_TRUNCATE</b>

            If the database file already exists, remove all the data before opening it.

       -Mode
            Determines the file protection when the database is created. Defaults to 0666.

       -Cachesize
       -Lorder
       -Pagesize
       -Env When working under a Berkeley DB environment, this parameter

            Defaults to no environment.

       -Encrypt
            If present, this parameter will enable encryption of  all data before it is written to the database.
            This parameters must be given a hash reference. The format is shown below.

                -Encrypt =&gt; { -Password =&gt; "abc", Flags =&gt; DB_ENCRYPT_AES }

            Valid values for the Flags are 0 or "DB_ENCRYPT_AES".

            This option requires Berkeley DB 4.1 or better.

       -Txn TODO.

</pre><h4><b>COMMON</b> <b>DATABASE</b> <b>METHODS</b></h4><pre>
       All the database interfaces support the common set of methods defined below.

       All the methods below return 0 to indicate success.

   <b>$env</b> <b>=</b> <b>$db-&gt;Env();</b>
       Returns the environment object the database is associated with or "undef" when no  environment  was  used
       when opening the database.

   <b>$status</b> <b>=</b> <b>$db-&gt;db_get($key,</b> <b>$value</b> <b>[,</b> <b>$flags])</b>
       Given  a  key  ($key) this method reads the value associated with it from the database. If it exists, the
       value read from the database is returned in the $value parameter.

       The <b>$flags</b> parameter is optional. If present, it must be set to <b>one</b> of the following values:

       <b>DB_GET_BOTH</b>
            When the <b>DB_GET_BOTH</b> flag is specified, <b>db_get</b> checks for the existence of <b>both</b> the $key <b>and</b>  $value
            in the database.

       <b>DB_SET_RECNO</b>
            TODO.

       In addition, the following value may be set by bitwise OR'ing it into the <b>$flags</b> parameter:

       <b>DB_RMW</b>
            TODO

       The variant "db_pget" allows you to query a secondary database:

               $status = $sdb-&gt;db_pget($skey, $pkey, $value);

       using the key $skey in the secondary db to lookup $pkey and $value from the primary db.

   <b>$status</b> <b>=</b> <b>$db-&gt;db_exists($key</b> <b>[,</b> <b>$flags])</b>
       This  method checks for the existence of the given key ($key), but does not read the value. If the key is
       not found, <b>db_exists</b> will return <b>DB_NOTFOUND</b>. Requires BDB 4.6 or better.

   <b>$status</b> <b>=</b> <b>$db-&gt;db_put($key,</b> <b>$value</b> <b>[,</b> <b>$flags])</b>
       Stores a key/value pair in the database.

       The <b>$flags</b> parameter is optional. If present it must be set to <b>one</b> of the following values:

       <b>DB_APPEND</b>
            This flag is only applicable when accessing a <b>BerkeleyDB::Recno</b> database.

            TODO.

       <b>DB_NOOVERWRITE</b>
            If this flag is specified and $key already exists in the database, the call to  <b>db_put</b>  will  return
            <b>DB_KEYEXIST</b>.

   <b>$status</b> <b>=</b> <b>$db-&gt;db_del($key</b> <b>[,</b> <b>$flags])</b>
       Deletes  a  key/value  pair  in  the database associated with $key.  If duplicate keys are enabled in the
       database, <b>db_del</b> will delete <b>all</b> key/value pairs with key $key.

       The <b>$flags</b> parameter is optional and is currently unused.

   <b>$status</b> <b>=</b> <b>$env-&gt;stat_print([$flags])</b>
       Prints statistical information.

       If the "MsgFile" option is specified the output will be sent to the file. Otherwise  output  is  sent  to
       standard output.

       This option requires Berkeley DB 4.3 or better.

   <b>$status</b> <b>=</b> <b>$db-&gt;db_sync()</b>
       If any parts of the database are in memory, write them to the database.

   <b>$cursor</b> <b>=</b> <b>$db-&gt;db_cursor([$flags])</b>
       Creates  a  cursor  object. This is used to access the contents of the database sequentially. See CURSORS
       for details of the methods available when working with cursors.

       The <b>$flags</b> parameter is optional. If present it must be set to <b>one</b> of the following values:

       <b>DB_RMW</b>
            TODO.

   <b>($flag,</b> <b>$old_offset,</b> <b>$old_length)</b> <b>=</b> <b>$db-&gt;partial_set($offset,</b> <b>$length)</b> <b>;</b>
       TODO

   <b>($flag,</b> <b>$old_offset,</b> <b>$old_length)</b> <b>=</b> <b>$db-&gt;partial_clear()</b> <b>;</b>
       TODO

   <b>$db-&gt;byteswapped()</b>
       TODO

   <b>$status</b> <b>=</b> <b>$db-&gt;get_blob_threshold($t1)</b> <b>;</b>
       Sets the parameter $t1 to the threshold value (in bytes) that is used to determine when a  data  item  is
       stored as a Blob.

   <b>$status</b> <b>=</b> <b>$db-&gt;get_blob_dir($dir)</b> <b>;</b>
       Sets the $dir parameter to the directory where blob files are stored.

   <b>$db-&gt;type()</b>
       Returns  the  type of the database. The possible return code are <b>DB_HASH</b> for a <b>BerkeleyDB::Hash</b> database,
       <b>DB_BTREE</b> for a <b>BerkeleyDB::Btree</b> database and <b>DB_RECNO</b> for a <b>BerkeleyDB::Recno</b> database. This  method  is
       typically used when a database has been opened with <b>BerkeleyDB::Unknown</b>.

   <b>$bool</b> <b>=</b> <b>$env-&gt;cds_enabled();</b>
       Returns true if the Berkeley DB environment $env has been opened on CDS mode.

   <b>$bool</b> <b>=</b> <b>$db-&gt;cds_enabled();</b>
       Returns true if the database $db has been opened on CDS mode.

   <b>$lock</b> <b>=</b> <b>$db-&gt;cds_lock();</b>
       Creates a CDS write lock object $lock.

       It is a fatal error to attempt to create a cds_lock if the Berkeley DB environment has not been opened in
       CDS mode.

   <b>$lock-&gt;cds_unlock();</b>
       Removes a CDS lock. The destruction of the CDS lock object automatically calls this method.

       Note  that if multiple CDS lock objects are created, the underlying write lock will not be released until
       all CDS lock objects are either explicitly unlocked with this method, or the CDS lock objects  have  been
       destroyed.

   <b>$ref</b> <b>=</b> <b>$db-&gt;db_stat()</b>
       Returns  a  reference  to an associative array containing information about the database. The keys of the
       associative  array  correspond  directly  to  the  names  of  the  fields  defined  in  the  Berkeley  DB
       documentation. For example, in the DB documentation, the field <b>bt_version</b> stores the version of the Btree
       database.  Assuming  you  called  <b>db_stat</b>  on  a Btree database the equivalent field would be accessed as
       follows:

           $version = $ref-&gt;{'bt_version'} ;

       If you are using Berkeley DB 3.x or better, this method will work will all database formats. When DB  2.x
       is used, it only works with <b>BerkeleyDB::Btree</b>.

   <b>$status</b> <b>=</b> <b>$db-&gt;status()</b>
       Returns the status of the last $db method called.

   <b>$status</b> <b>=</b> <b>$db-&gt;truncate($count)</b>
       Truncates the database and returns the number or records deleted in $count.

   <b>$status</b> <b>=</b> <b>$db-&gt;compact($start,</b> <b>$stop,</b> <b>$c_data,</b> <b>$flags,</b> <b>$end);</b>
       Compacts the database $db.

       All  the  parameters  are  optional - if only want to make use of some of them, use "undef" for those you
       don't want.  Trailing unused parameters can be omitted. For example, if you only want to use the  $c_data
       parameter to set the "compact_fillpercent", write you code like this

           my %hash;
           $hash{compact_fillpercent} = 50;
           $db-&gt;compact(undef, undef, \%hash);

       The  parameters  operate  identically  to  the  C  equivalent of this method.  The $c_data needs a bit of
       explanation - it must be a hash reference.  The values of the following keys can be  set  before  calling
       "compact" and will affect the operation of the compaction.

           compact_fillpercent

           compact_timeout

       The  following keys, along with associated values, will be created in the hash reference if the "compact"
       operation was successful.

           compact_deadlock

           compact_levels

           compact_pages_free

           compact_pages_examine

           compact_pages_truncated

       You need to be running Berkeley DB 4.4 or better if you want to make use of "compact".

   <b>$status</b> <b>=</b> <b>$db-&gt;associate($secondary,</b> <b>\&amp;key_callback)</b>
       Associate $db with the secondary DB $secondary

       New key/value pairs inserted to the database will be passed to the callback  which  must  set  its  third
       argument  to the secondary key to allow lookup. If an array reference is set multiple keys secondary keys
       will be associated with the primary database entry.

       Data may be retrieved fro the secondary database using "db_pget" to also obtain the primary key.

       Secondary databased are maintained automatically.

   <b>$status</b> <b>=</b> <b>$db-&gt;associate_foreign($secondary,</b> <b>callback,</b> <b>$flags)</b>
       Associate a foreign key database $db with the secondary DB $secondary.

       The second parameter must be a reference to a sub or "undef".

       The $flags parameter must be either "DB_FOREIGN_CASCADE", "DB_FOREIGN_ABORT" or "DB_FOREIGN_NULLIFY".

       When the flags parameter is "DB_FOREIGN_NULLIFY" the second parameter is a reference to a sub of the form

           sub foreign_cb
           {
               my $key = \$_[0];
               my $value = \$_[1];
               my $foreignkey = \$_[2];
               my $changed = \$_[3] ;

               # for ... set $$value and set $$changed to 1

               return 0;
           }

           $foreign_db-&gt;associate_foreign($secondary, \&amp;foreign_cb, DB_FOREIGN_NULLIFY);

</pre><h4><b>CURSORS</b></h4><pre>
       A cursor is used whenever you want to access the contents of a database in sequential  order.   A  cursor
       object is created with the "db_cursor"

       A cursor object has the following methods available:

   <b>$newcursor</b> <b>=</b> <b>$cursor-&gt;c_dup($flags)</b>
       Creates a duplicate of $cursor. This method needs Berkeley DB 3.0.x or better.

       The $flags parameter is optional and can take the following value:

       DB_POSITION
            When present this flag will position the new cursor at the same place as the existing cursor.

   <b>$status</b> <b>=</b> <b>$cursor-&gt;c_get($key,</b> <b>$value,</b> <b>$flags)</b>
       Reads  a  key/value  pair  from  the  database, returning the data in $key and $value. The key/value pair
       actually read is controlled by the $flags parameter, which can take <b>one</b> of the following values:

       <b>DB_FIRST</b>
            Set the cursor to point to the first key/value pair in the database. Return the  key/value  pair  in
            $key and $value.

       <b>DB_LAST</b>
            Set  the  cursor  to  point to the last key/value pair in the database. Return the key/value pair in
            $key and $value.

       <b>DB_NEXT</b>
            If the cursor is already pointing to a key/value pair, it will be incremented to point to  the  next
            key/value pair and return its contents.

            If the cursor isn't initialised, <b>DB_NEXT</b> works just like <b>DB_FIRST</b>.

            If the cursor is already positioned at the last key/value pair, <b>c_get</b> will return <b>DB_NOTFOUND</b>.

       <b>DB_NEXT_DUP</b>
            This  flag  is  only  valid  when  duplicate keys have been enabled in a database.  If the cursor is
            already pointing to a key/value pair and the key of the next key/value pair is identical, the cursor
            will be incremented to point to it and their contents returned.

       <b>DB_PREV</b>
            If the cursor is already pointing to a key/value pair, it  will  be  decremented  to  point  to  the
            previous key/value pair and return its contents.

            If the cursor isn't initialised, <b>DB_PREV</b> works just like <b>DB_LAST</b>.

            If the cursor is already positioned at the first key/value pair, <b>c_get</b> will return <b>DB_NOTFOUND</b>.

       <b>DB_CURRENT</b>
            If  the  cursor  has been set to point to a key/value pair, return their contents.  If the key/value
            pair referenced by the cursor has been deleted, <b>c_get</b> will return <b>DB_KEYEMPTY</b>.

       <b>DB_SET</b>
            Set the cursor to point to the key/value pair referenced by <b>$key</b> and return the value in <b>$value</b>.

       <b>DB_SET_RANGE</b>
            This flag is a variation on the <b>DB_SET</b> flag. As well as returning the value,  it  also  returns  the
            key,  via  <b>$key</b>.   When  used with a <b>BerkeleyDB::Btree</b> database the key matched by <b>c_get</b> will be the
            shortest key (in length) which is greater than or equal to the key supplied, via <b>$key</b>.  This  allows
            partial key searches.  See ??? for an example of how to use this flag.

       <b>DB_GET_BOTH</b>
            Another variation on <b>DB_SET</b>. This one returns both the key and the value.

       <b>DB_SET_RECNO</b>
            TODO.

       <b>DB_GET_RECNO</b>
            TODO.

       In addition, the following value may be set by bitwise OR'ing it into the <b>$flags</b> parameter:

       <b>DB_RMW</b>
            TODO.

   <b>$status</b> <b>=</b> <b>$cursor-&gt;c_put($key,</b> <b>$value,</b> <b>$flags)</b>
       Stores  the  key/value  pair  in  the  database.  The position that the data is stored in the database is
       controlled by the $flags parameter, which must take <b>one</b> of the following values:

       <b>DB_AFTER</b>
            When used with a Btree or Hash database, a duplicate of the key referenced  by  the  current  cursor
            position  will  be  created and the contents of <b>$value</b> will be associated with it - <b>$key</b> is ignored.
            The new key/value pair will be stored immediately after the current cursor position.  Obviously  the
            database has to have been opened with <b>DB_DUP</b>.

            When used with a Recno ... TODO

       <b>DB_BEFORE</b>
            When  used  with  a  Btree or Hash database, a duplicate of the key referenced by the current cursor
            position will be created and the contents of <b>$value</b> will be associated with it -  <b>$key</b>  is  ignored.
            The new key/value pair will be stored immediately before the current cursor position.  Obviously the
            database has to have been opened with <b>DB_DUP</b>.

            When used with a Recno ... TODO

       <b>DB_CURRENT</b>
            If  the  cursor has been initialised, replace the value of the key/value pair stored in the database
            with the contents of <b>$value</b>.

       <b>DB_KEYFIRST</b>
            Only valid with a Btree or Hash database. This flag is only really used when duplicates are  enabled
            in  the database and sorted duplicates haven't been specified.  In this case the key/value pair will
            be inserted as the first entry in the duplicates for the particular key.

       <b>DB_KEYLAST</b>
            Only valid with a Btree or Hash database. This flag is only really used when duplicates are  enabled
            in  the database and sorted duplicates haven't been specified.  In this case the key/value pair will
            be inserted as the last entry in the duplicates for the particular key.

   <b>$status</b> <b>=</b> <b>$cursor-&gt;c_del([$flags])</b>
       This method deletes the key/value pair associated with the current cursor position. The  cursor  position
       will  not  be  changed  by  this  operation, so any subsequent cursor operation must first initialise the
       cursor to point to a valid key/value pair.

       If the key/value  pair  associated  with  the  cursor  have  already  been  deleted,  <b>c_del</b>  will  return
       <b>DB_KEYEMPTY</b>.

       The <b>$flags</b> parameter is not used at present.

   <b>$status</b> <b>=</b> <b>$cursor-&gt;c_count($cnt</b> <b>[,</b> <b>$flags])</b>
       Stores the number of duplicates at the current cursor position in <b>$cnt</b>.

       The <b>$flags</b> parameter is not used at present. This method needs Berkeley DB 3.1 or better.

   <b>$status</b> <b>=</b> <b>$cursor-&gt;status()</b>
       Returns the status of the last cursor method as a dual type.

   <b>$status</b> <b>=</b> <b>$cursor-&gt;c_pget()</b> <b>;</b>
       See "db_pget"

   <b>$status</b> <b>=</b> <b>$cursor-&gt;c_close()</b>
       Closes the cursor <b>$cursor</b>.

   <b>$stream</b> <b>=</b> <b>$cursor-&gt;db_stream($flags);</b>
       Create  a  BerkeleyDB::DbStream  object  to  read  the blob at the current cursor location.  See Blob for
       details of the the BerkeleyDB::DbStream object.

       $flags must be one or more of the following OR'ed together

       DB_STREAM_READ DB_STREAM_WRITE DB_STREAM_SYNC_WRITE

       For full information on the flags refer to the Berkeley DB Reference Guide.

   <b>Cursor</b> <b>Examples</b>
       TODO

       Iterating from first to last, then in reverse.

       examples of each of the flags.

</pre><h4><b>JOIN</b></h4><pre>
       Join support for BerkeleyDB is in progress. Watch this space.

       TODO

</pre><h4><b>TRANSACTIONS</b></h4><pre>
       Transactions are created using the "txn_begin" method on BerkeleyDB::Env:

               my $txn = $env-&gt;txn_begin;

       If this is a nested transaction, supply the parent transaction as an argument:

               my $child_txn = $env-&gt;txn_begin($parent_txn);

       Then in order to work with the transaction, you must set it as the current transaction  on  the  database
       handles you want to work with:

               $db-&gt;Txn($txn);

       Or for multiple handles:

               $txn-&gt;Txn(@handles);

       The  current  transaction is given by BerkeleyDB each time to the various BDB operations. In the C api it
       is required explicitly as an argument to every operation.

       To commit a transaction call the "commit" method on it:

               $txn-&gt;txn_commit;

       and to roll back call abort:

               $txn-&gt;txn_abort

       After committing or aborting a child transaction you need to  set  the  active  transaction  again  using
       "Txn".

</pre><h4><b>BerkeleyDBB::DbStream</b> <b>--</b> <b>support</b> <b>for</b> <b>BLOB</b></h4><pre>
       Blob  support  is available in Berkeley DB starting with version 6.0. Refer to the section "Blob Support"
       in the Berkeley DB Programmer Reference for details of how Blob supports works.

       A Blob is access via a BerkeleyDBB::DbStream object. This is created via a cursor object.

           # Note - error handling not shown below.

           # Set the key we want
           my $k = "some key";

           # Don't want the value retrieved by the cursor,
           # so use partial_set to make sure no data is retrieved.
           my $v = '';
           $cursor-&gt;partial_set(0,0) ;
           $cursor-&gt;c_get($k, $v, DB_SET) ;
           $cursor-&gt;partial_clear() ;

           # Now create a stream to the blob
           my $stream = $cursor-&gt;db_stream(DB_STREAM_WRITE) ;

           # get the size of the blob
           $stream-&gt;size(my $s) ;

           # Read the first 1k of data from the blob
           my $data ;
           $stream-&gt;read($data, 0, 1024);

       A BerkeleyDB::DbStream object has the following methods available:

   <b>$status</b> <b>=</b> <b>$stream-&gt;size($SIZE);</b>
       Outputs the length of the Blob in the $SIZE parameter.

   <b>$status</b> <b>=</b> <b>$stream-&gt;read($data,</b> <b>$offset,</b> <b>$size);</b>
       Read from the blob. $offset is the number of bytes from the start of the blob to read from. $size if  the
       number of bytes to read.

   <b>$status</b> <b>=</b> <b>$stream-&gt;write($data,</b> <b>$offset,</b> <b>$flags);</b>
       Write $data to the blob, starting at offset $offset.

       Example

       Below  is  an  example of how to walk through a database when you don't know beforehand which entries are
       blobs and which are not.

           while (1)
           {
               my $k = '';
               my $v = '';
               $cursor-&gt;partial_set(0,0) ;
               my $status = $cursor-&gt;c_get($k, $v, DB_NEXT) ;
               $cursor-&gt;partial_clear();

               last if $status != 0 ;

               my $stream = $cursor-&gt;db_stream(DB_STREAM_WRITE);

               if (defined $stream)
               {
                   # It's a Blob
                   $stream-&gt;size(my $s) ;
               }
               else
               {
                   # Not a Blob
                   $cursor-&gt;c_get($k, $v, DB_CURRENT) ;
               }
           }

</pre><h4><b>Berkeley</b> <b>DB</b> <b>Concurrent</b> <b>Data</b> <b>Store</b> <b>(CDS)</b></h4><pre>
       The Berkeley DB <u>Concurrent</u> <u>Data</u> <u>Store</u> (CDS)  is  a  lightweight  locking  mechanism  that  is  useful  in
       scenarios where transactions are overkill.

   <b>What</b> <b>is</b> <b>CDS?</b>
       The  Berkeley  DB  CDS  interface  is  a simple lightweight locking mechanism that allows safe concurrent
       access to Berkeley DB databases. Your application can have  multiple  reader  and  write  processes,  but
       Berkeley  DB  will  arrange  it  so that only one process can have a write lock against the database at a
       time, i.e. multiple processes can read from a database concurrently, but  all  write  processes  will  be
       serialised.

   <b>Should</b> <b>I</b> <b>use</b> <b>it?</b>
       Whilst  this simple locking model is perfectly adequate for some applications, it will be too restrictive
       for others. Before deciding on using CDS mode, you need to be sure that it is suitable for  the  expected
       behaviour of your application.

       The key features of this model are

           All writes operations are serialised.

           A write operation will block until all reads have finished.

       There are a few of the attributes of your application that you need to be aware of before choosing to use
       CDS.

       Firstly,  if  you  application  needs  either recoverability or transaction support, then CDS will not be
       suitable.

       Next what is the ratio of read operation to write operations will your application have?

       If it is carrying out mostly read operations, and very few writes, then CDS may be appropriate.

       What is the expected throughput of reads/writes in your application?

       If you application does 90% writes and 10% reads, but on average you only  have  a  transaction  every  5
       seconds,  then the fact that all writes are serialised will not matter, because there will hardly ever be
       multiple writes processes blocking.

       In summary CDS mode may be appropriate for your application if it performs  mostly  reads  and  very  few
       writes  or  there  is  a  low  throughput.   Also, if you do not need to be able to roll back a series of
       database operations if an error occurs, then CDS is ok.

       If any of these is not the case you will need to use Berkeley DB transactions. That is outside the  scope
       of this document.

   <b>Locking</b> <b>Used</b>
       Berkeley  DB  implements CDS mode using two kinds of lock behind the scenes - namely read locks and write
       locks. A read lock allows multiple processes to access the database for reading at the same time. A write
       lock will only get access to the database when there are no read or write locks active.  The  write  lock
       will block until the process holding the lock releases it.

       Multiple processes with read locks can all access the database at the same time as long as no process has
       a  write lock. A process with a write lock can only access the database if there are no other active read
       or write locks.

       The majority of the time the Berkeley DB CDS mode will handle all locking without your application having
       to do anything. There are a couple of exceptions you need to be aware of though - these will be discussed
       in "Safely Updating Records" and "Implicit Cursors" below.

       A Berkeley DB Cursor (created with "$db-&gt;db_cursor") will by hold a lock on  the  database  until  it  is
       either explicitly closed or destroyed.  This means the lock has the potential to be long lived.

       By  default  Berkeley  DB  cursors create a read lock, but it is possible to create a cursor that holds a
       write lock, thus

           $cursor = $db-&gt;db_cursor(DB_WRITECURSOR);

       Whilst either a read or write cursor is active, it will block any other processes that wants to write  to
       the database.

       To  avoid blocking problems, only keep cursors open as long as they are needed. The same is true when you
       use the "cursor" method or the "cds_lock" method.

       For full information on CDS see the "Berkeley DB Concurrent  Data  Store  applications"  section  in  the
       Berkeley DB Reference Guide.

   <b>Opening</b> <b>a</b> <b>database</b> <b>for</b> <b>CDS</b>
       Here is the typical signature that is used when opening a database in CDS mode.

           use BerkeleyDB ;

           my $env = new BerkeleyDB::Env
                         -Home   =&gt; ".<a href="file:/home">/home</a>" ,
                         -Flags  =&gt; DB_CREATE| DB_INIT_CDB | DB_INIT_MPOOL
               or die "cannot open environment: $BerkeleyDB::Error\n";

           my $db  = new BerkeleyDB::Hash
                       -Filename       =&gt; 'test1.db',
                       -Flags          =&gt; DB_CREATE,
                       -Env            =&gt; $env
               or die "cannot open database: $BerkeleyDB::Error\n";

       or this, if you use the tied interface

           tie %hash, "BerkeleyDB::Hash",
                       -Filename       =&gt; 'test2.db',
                       -Flags          =&gt; DB_CREATE,
                       -Env            =&gt; $env
               or die "cannot open database: $BerkeleyDB::Error\n";

       The  first thing to note is that you <b>MUST</b> always use a Berkeley DB environment if you want to use locking
       with Berkeley DB.

       Remember, that apart from the actual database files you explicitly  create  yourself,  Berkeley  DB  will
       create  a  few  behind  the  scenes  to  handle  locking - they usually have names like "__db.001". It is
       therefore a good idea to use the "-Home" option, unless you are happy for all these files to  be  written
       in the current directory.

       Next,  remember to include the "DB_CREATE" flag when opening the environment for the first time. A common
       mistake is to forget to add this option and then wonder why the application doesn't work.

       Finally, it is vital that all processes that are going to access the database files use the same Berkeley
       DB environment.

   <b>Safely</b> <b>Updating</b> <b>a</b> <b>Record</b>
       One of the main gotchas when using CDS is if you want to update a record in a database, i.e. you want  to
       retrieve a record from a database, modify it in some way and put it back in the database.

       For  example,  say you are writing a web application and you want to keep a record of the number of times
       your site is accessed in a Berkeley DB database. So your code will have a line of code like this (assume,
       of course, that %hash has been tied to a Berkeley DB database):

           $hash{Counter} ++ ;

       That may look innocent enough, but there is a race condition lurking in there. If I rewrite the  line  of
       code using the low-level Berkeley DB API, which is what will actually be executed, the race condition may
       be more apparent:

           $db-&gt;db_get("Counter", $value);
           ++ $value ;
           $db-&gt;db_put("Counter", $value);

       Consider what happens behind the scenes when you execute the commands above.  Firstly, the existing value
       for the key "Counter" is fetched from the database using "db_get". A read lock will be used for this part
       of  the  update.   The value is then incremented, and the new value is written back to the database using
       "db_put". This time a write lock will be used.

       Here's the problem - there is nothing to stop two (or more) processes executing the read part at the same
       time. Remember multiple processes can hold a read lock on the database at the same  time.  So  both  will
       fetch  the same value, let's say 7, from the database. Both increment the value to 8 and attempt to write
       it to the database. Berkeley DB will ensure that only one of the processes gets a write lock,  while  the
       other  will  be blocked. So the process that happened to get the write lock will store the value 8 to the
       database and release the write lock. Now the other process will be unblocked, and it too will  write  the
       value 8 to the database. The result, in this example, is we have missed a hit in the counter.

       To  deal  with  this  kind  of scenario, you need to make the update atomic. A convenience method, called
       "cds_lock", is supplied with the BerkeleyDB module for this purpose. Using "cds_lock", the counter update
       code can now be rewritten thus:

           my $lk = $dbh-&gt;cds_lock() ;
           $hash{Counter} ++ ;
           $lk-&gt;cds_unlock;

       or this, where scoping is used to limit the lifetime of the lock object

           {
               my $lk = $dbh-&gt;cds_lock() ;
               $hash{Counter} ++ ;
           }

       Similarly, "cds_lock" can be used with the native Berkeley DB API

           my $lk = $dbh-&gt;cds_lock() ;
           $db-&gt;db_get("Counter", $value);
           ++ $value ;
           $db-&gt;db_put("Counter", $value);
           $lk-&gt;unlock;

       The "cds_lock" method will ensure that the current process has exclusive access to the database until the
       lock is either explicitly released, via the "$lk-&gt;cds_unlock()" or by the lock object being destroyed.

       If you are interested, all that "cds_lock" does is open a "write" cursor.   This  has  the  useful  side-
       effect  of  holding  a  write-lock  on the database until the cursor is deleted. This is how you create a
       write-cursor

           $cursor = $db-&gt;db_cursor(DB_WRITECURSOR);

       If you have instantiated multiple "cds_lock" objects for one  database  within  a  single  process,  that
       process will hold a write-lock on the database until <u>ALL</u> "cds_lock" objects have been destroyed.

       As  with  all  write-cursors,  you  should try to limit the scope of the "cds_lock" to as short a time as
       possible. Remember the complete database will be locked to other process whilst  the  write  lock  is  in
       place.

   <b>Cannot</b> <b>write</b> <b>with</b> <b>a</b> <b>read</b> <b>cursor</b> <b>while</b> <b>a</b> <b>write</b> <b>cursor</b> <b>is</b> <b>active</b>
       This  issue  is  easier  to demonstrate with an example, so consider the code below. The intention of the
       code is to increment the values of all the elements in a database by one.

           # Assume $db is a database opened in a CDS environment.

           # Create a write-lock
           my $lock = $db-&gt;db_cursor(DB_WRITECURSOR);
           # or
           # my $lock = $db-&gt;cds_lock();

           my $cursor = $db-&gt;db_cursor();

           # Now loop through the database, and increment
           # each value using c_put.
           while ($cursor-&gt;c_get($key, $value, DB_NEXT) == 0)
           {
                $cursor-&gt;c_put($key, $value+1, DB_CURRENT) == 0
                    or die "$BerkeleyDB::Error\n";
           }

       When this code is run, it will fail on the "c_put" line with this error

           Write attempted on read-only cursor

       The read cursor has automatically disallowed a write operation to prevent a deadlock.

       So the rule is -- you <b>CANNOT</b> carry out a write operation using a read-only cursor (i.e.  you  cannot  use
       "c_put" or "c_del") whilst another write-cursor is already active.

       The workaround for this issue is to just use "db_put" instead of "c_put", like this

           # Assume $db is a database opened in a CDS environment.

           # Create a write-lock
           my $lock = $db-&gt;db_cursor(DB_WRITECURSOR);
           # or
           # my $lock = $db-&gt;cds_lock();

           my $cursor = $db-&gt;db_cursor();

           # Now loop through the database, and increment
           # each value using c_put.
           while ($cursor-&gt;c_get($key, $value, DB_NEXT) == 0)
           {
                $db-&gt;db_put($key, $value+1) == 0
                    or die "$BerkeleyDB::Error\n";
           }

   <b>Implicit</b> <b>Cursors</b>
       All Berkeley DB cursors will hold either a read lock or a write lock on the database for the existence of
       the  cursor. In order to prevent blocking of other processes you need to make sure that they are not long
       lived.

       There are a number of instances where the Perl interface to Berkeley DB will create a cursor  behind  the
       scenes  without you being aware of it. Most of these are very short-lived and will not affect the running
       of your script, but there are a few notable exceptions.

       Consider this snippet of code

           while (my ($k, $v) = each %hash)
           {
               # do something
           }

       To implement the "each" functionality, a read cursor will be created behind the scenes to  allow  you  to
       iterate  through  the  tied hash, %hash. While that cursor is still active, a read lock will obviously be
       held against the database. If your application has any other writing processes,  these  will  be  blocked
       until the read cursor is closed. That won't happen until the loop terminates.

       To  avoid blocking problems, only keep cursors open as long as they are needed. The same is true when you
       use the "cursor" method or the "cds_lock" method.

       The locking behaviour of the "values" or "keys" functions, shown below, is subtly different.

           foreach my $k (keys %hash)
           {
               # do something
           }

           foreach my $v (values %hash)
           {
               # do something
           }

       Just as in the "each" function, a read cursor will be created to iterate over the  database  in  both  of
       these  cases.  Where  "keys"  and "values" differ is the place where the cursor carries out the iteration
       through the database. Whilst "each" carried out a single iteration every time it was invoked, the  "keys"
       and  "values"  functions will iterate through the entire database in one go -- the complete database will
       be read into memory before the first iteration of the loop.

       Apart from the fact that a read lock will be held for the amount of time required to iterate through  the
       database,  the  use  of  "keys"  and  "values"  is <b>not</b> recommended because it will result in the complete
       database being read into memory.

   <b>Avoiding</b> <b>Deadlock</b> <b>with</b> <b>multiple</b> <b>databases</b>
       If your CDS application uses multiple database files, and you need to write to more than one of them, you
       need to be careful you don't create a deadlock.

       For example, say you have two databases, D1 and D2, and two processes, P1 and  P2.  Assume  you  want  to
       write  a  record  to  each  database. If P1 writes the records to the databases in the order D1, D2 while
       process P2 writes the records in the order D2, D1, there is the potential for a deadlock to occur.

       This scenario can be avoided by either always acquiring the write locks in exactly the same order in your
       application code, or by using the "DB_CDB_ALLDB" flag when opening the environment. This flag will make a
       write-lock apply to all the databases in the environment.

       Add example here

</pre><h4><b>DBM</b> <b>Filters</b></h4><pre>
       A DBM Filter is a piece of code that is be used when you <u>always</u> want to make the same  transformation  to
       all   keys   and/or   values   in  a  DBM  database.  All  of  the  database  classes  (BerkeleyDB::Hash,
       BerkeleyDB::Btree and BerkeleyDB::Recno) support DBM Filters.

       An example is when you need to encode your data in UTF-8 before writing to the database and  then  decode
       the UTF-8 when reading from the database file.

       There are two ways to use a DBM Filter.

       1.   Using the low-level API defined below.

       2.   Using  the  DBM_Filter  module.  This module hides the complexity of the API defined below and comes
            with a number of "canned" filters that cover some of the common use-cases.

       Use of the DBM_Filter module is recommended.

   <b>DBM</b> <b>Filter</b> <b>Low-level</b> <b>API</b>
       There are four methods associated with DBM Filters. All work identically, and each is used to install (or
       uninstall) a single DBM Filter. Each expects a single parameter, namely a reference to a sub.   The  only
       difference between them is the place that the filter is installed.

       To summarise:

       <b>filter_store_key</b>
            If  a filter has been installed with this method, it will be invoked every time you write a key to a
            DBM database.

       <b>filter_store_value</b>
            If a filter has been installed with this method, it will be invoked every time you write a value  to
            a DBM database.

       <b>filter_fetch_key</b>
            If a filter has been installed with this method, it will be invoked every time you read a key from a
            DBM database.

       <b>filter_fetch_value</b>
            If a filter has been installed with this method, it will be invoked every time you read a value from
            a DBM database.

       You can use any combination of the methods, from none, to all four.

       All filter methods return the existing filter, if present, or "undef" in not.

       To delete a filter pass "undef" to it.

   <b>The</b> <b>Filter</b>
       When  each  filter  is  called  by Perl, a local copy of $_ will contain the key or value to be filtered.
       Filtering is achieved by modifying the contents of $_. The return code from the filter is ignored.

   <b>An</b> <b>Example</b> <b>--</b> <b>the</b> <b>NULL</b> <b>termination</b> <b>problem.</b>
       Consider the following scenario. You have a DBM database that you need to  share  with  a  third-party  C
       application.  The  C application assumes that <u>all</u> keys and values are NULL terminated. Unfortunately when
       Perl writes to DBM databases it doesn't use NULL termination, so  your  Perl  application  will  have  to
       manage NULL termination itself. When you write to the database you will have to use something like this:

           $hash{"$key\0"} = "$value\0" ;

       Similarly  the  NULL  needs  to  be  taken  into  account when you are considering the length of existing
       keys/values.

       It would be much better if you could ignore the NULL terminations issue in the main application code  and
       have  a mechanism that automatically added the terminating NULL to all keys and values whenever you write
       to the database and have them removed when you read from the database.  As  I'm  sure  you  have  already
       guessed, this is a problem that DBM Filters can fix very easily.

           use strict ;
           use BerkeleyDB ;

           my %hash ;
           my $filename = "filt.db" ;
           unlink $filename ;

           my $db = tie %hash, 'BerkeleyDB::Hash',
                       -Filename   =&gt; $filename,
                       -Flags      =&gt; DB_CREATE
             or die "Cannot open $filename: $!\n" ;

           # Install DBM Filters
           $db-&gt;filter_fetch_key  ( sub { s/\0$//    } ) ;
           $db-&gt;filter_store_key  ( sub { $_ .= "\0" } ) ;
           $db-&gt;filter_fetch_value( sub { s/\0$//    } ) ;
           $db-&gt;filter_store_value( sub { $_ .= "\0" } ) ;

           $hash{"abc"} = "def" ;
           my $a = $hash{"ABC"} ;
           # ...
           undef $db ;
           untie %hash ;

       Hopefully the contents of each of the filters should be self-explanatory. Both "fetch" filters remove the
       terminating NULL, and both "store" filters add a terminating NULL.

   <b>Another</b> <b>Example</b> <b>--</b> <b>Key</b> <b>is</b> <b>a</b> <b>C</b> <b>int.</b>
       Here  is  another  real-life example. By default, whenever Perl writes to a DBM database it always writes
       the key and value as strings. So when you use this:

           $hash{12345} = "something" ;

       the key 12345 will get stored in the DBM database as the 5 byte string "12345". If you actually want  the
       key  to  be stored in the DBM database as a C int, you will have to use "pack" when writing, and "unpack"
       when reading.

       Here is a DBM Filter that does it:

           use strict ;
           use BerkeleyDB ;
           my %hash ;
           my $filename = "filt.db" ;
           unlink $filename ;

           my $db = tie %hash, 'BerkeleyDB::Btree',
                       -Filename   =&gt; $filename,
                       -Flags      =&gt; DB_CREATE
             or die "Cannot open $filename: $!\n" ;

           $db-&gt;filter_fetch_key  ( sub { $_ = unpack("i", $_) } ) ;
           $db-&gt;filter_store_key  ( sub { $_ = pack ("i", $_) } ) ;
           $hash{123} = "def" ;
           # ...
           undef $db ;
           untie %hash ;

       This time only two filters have been used -- we only need to manipulate the contents of the  key,  so  it
       wasn't necessary to install any value filters.

</pre><h4><b>Using</b> <b>BerkeleyDB</b> <b>with</b> <b>MLDBM</b></h4><pre>
       Both  BerkeleyDB::Hash  and  BerkeleyDB::Btree can be used with the MLDBM module. The code fragment below
       shows how  to  open  associate  MLDBM  with  BerkeleyDB::Btree.  To  use  BerkeleyDB::Hash  just  replace
       BerkeleyDB::Btree with BerkeleyDB::Hash.

           use strict ;
           use BerkeleyDB ;
           use MLDBM qw(BerkeleyDB::Btree) ;
           use Data::Dumper;

           my $filename = 'testmldbm' ;
           my %o ;

           unlink $filename ;
           tie %o, 'MLDBM', -Filename =&gt; $filename,
                            -Flags    =&gt; DB_CREATE
                           or die "Cannot open database '$filename: $!\n";

       See the MLDBM documentation for information on how to use the module and for details of its limitations.

</pre><h4><b>EXAMPLES</b></h4><pre>
       TODO.

</pre><h4><b>HINTS</b> <b>&amp;</b> <b>TIPS</b></h4><pre>
   <b>Sharing</b> <b>Databases</b> <b>With</b> <b>C</b> <b>Applications</b>
       There  is  no  technical  reason  why  a  Berkeley  DB  database  cannot be shared by both a Perl and a C
       application.

       The vast majority of problems that are reported in this area boil down to the fact  that  C  strings  are
       NULL  terminated,  whilst  Perl strings are not. See "An Example -- the NULL termination problem." in the
       DBM FILTERS section for a generic way to work around this problem.

   <b>The</b> <b>untie</b> <b>Gotcha</b>
       TODO

</pre><h4><b>COMMON</b> <b>QUESTIONS</b></h4><pre>
       This section attempts to answer some of the more common questions that I get asked.

   <b>Relationship</b> <b>with</b> <b>DB_File</b>
       Before Berkeley DB 2.x was written there was only one Perl module that interfaced to  Berkeley  DB.  That
       module  is  called  <b>DB_File</b>. Although <b>DB_File</b> can be build with Berkeley DB 1.x, 2.x, 3.x or 4.x, it only
       provides an interface to the functionality available in Berkeley DB  1.x.  That  means  that  it  doesn't
       support transactions, locking or any of the other new features available in DB 2.x or better.

   <b>How</b> <b>do</b> <b>I</b> <b>store</b> <b>Perl</b> <b>data</b> <b>structures</b> <b>with</b> <b>BerkeleyDB?</b>
       See "Using BerkeleyDB with MLDBM".

</pre><h4><b>HISTORY</b></h4><pre>
       See the Changes file.

</pre><h4><b>SUPPORT</b></h4><pre>
       General  feedback/questions/bug  reports  should  be  sent to &lt;https://github.com/pmqs/BerkeleyDB/issues&gt;
       (preferred) or &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=BerkeleyDB&gt;.

</pre><h4><b>AVAILABILITY</b></h4><pre>
       The most recent version of <b>BerkeleyDB</b> can always be found on CPAN (see "CPAN" in perlmod for details), in
       the directory <u>modules/by-module/BerkeleyDB</u>.

       The          official          web          site          for          Berkeley           DB           is
       <u><a href="http://www.oracle.com/technology/products/berkeley-db/db/index.html">http://www.oracle.com/technology/products/berkeley-db/db/index.html</a></u>.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright  (c)  1997-2024  Paul  Marquess.  All  rights  reserved. This program is free software; you can
       redistribute it and/or modify it under the same terms as Perl itself.

       Although <b>BerkeleyDB</b> is covered by the Perl license, the library it makes use of, namely Berkeley  DB,  is
       not.    Berkeley    DB    has    its    own    copyright    and    its    own    license.     See    AGPL
       &lt;https://www.oracle.com/downloads/licenses/berkeleydb-oslicense.html&gt; for more details.  Please take  the
       time to read the Berkeley DB license and decide how it impacts your use of this Perl module.

</pre><h4><b>AUTHOR</b></h4><pre>
       Paul Marquess &lt;<a href="mailto:pmqs@cpan.org">pmqs@cpan.org</a>&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), DB_File, Berkeley DB.

perl v5.40.0                                       2024-10-19                                    <u><a href="../man3pm/BerkeleyDB.3pm.html">BerkeleyDB</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>