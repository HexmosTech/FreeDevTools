<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compress::Bzip2 - Interface to Bzip2 compression library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcompress-bzip2-perl">libcompress-bzip2-perl_2.28-1build7_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Compress::Bzip2 - Interface to Bzip2 compression library

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Compress::Bzip2 qw(:all :constant :utilities :gzip);

           ($bz, $status) = bzdeflateInit( [PARAMS] );
           ($out, $status) = $bz-&gt;bzdeflate($buffer) ; # compress

           ($bz, $status) = bzinflateInit( [PARAMS] );
           ($out, $status) = $bz-&gt;bzinflate($buffer);  # uncompress

           ($out, $status) = $bz-&gt;bzflush() ;
           ($out, $status) = $bz-&gt;bzclose() ;

           $dest = memBzip($source);
               alias compress
           $dest = memBunzip($source);
               alias decompress

           $bz = Compress::Bzip2-&gt;new( [PARAMS] );

           $bz = bzopen($filename or filehandle, $mode);
               alternate, with $bz created by new():
           $bz-&gt;bzopen($filename or filehandle, $mode);

           $bytesread = $bz-&gt;bzread($buffer [,$size]) ;
           $bytesread = $bz-&gt;bzreadline($line);
           $byteswritten = $bz-&gt;bzwrite($buffer [,$limit]);
           $errstring = $bz-&gt;bzerror();
           $status = $bz-&gt;bzeof();
           $status = $bz-&gt;bzflush();
           $status = $bz-&gt;bzclose() ;

           $status = $bz-&gt;bzsetparams( $param =&gt; $setting );

           $bz-&gt;total_in() ;
           $bz-&gt;total_out() ;

           $verstring = $bz-&gt;bzversion();

           $Compress::Bzip2::bzerrno

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>Compress::Bzip2</u> module provides a Perl interface to the <b>bzip2</b> compression library (see "AUTHOR" for
       details about where to get <u>Bzip2</u>). A relevant subset of the functionality provided by <u>bzip2</u> is available
       in <u>Compress::Bzip2</u>.

       All string parameters can either be a scalar or a scalar reference.

       The module can be split into two general areas of functionality, namely in-memory
       compression/decompression and read/write access to <u>bzip2</u> files. Each of these areas will be discussed
       separately below.

       <b>NOTE</b>

       <u>Compress::Bzip2</u> is just a simple <u>bzip2</u> binding, comparable to the old Compress::Zlib library. It is not
       well integrated into PerlIO, use the preferred IO::Compress::Bzip2 instead.

</pre><h4><b>FILE</b> <b>READ/WRITE</b> <b>INTERFACE</b></h4><pre>
       A number of functions are supplied in <u>bzlib</u> for reading and writing <u>bzip2</u> files. Unfortunately, most of
       them are not suitable.  So, this module provides another interface, built over top of the low level bzlib
       methods.

   <b>$bz</b> <b>=</b> <b>bzopen(filename</b> <b>or</b> <b>filehandle,</b> <b>mode)</b>
       This function returns an object which is used to access the other <u>bzip2</u> methods.

       The <b>mode</b> parameter is used to specify both whether the file is opened for reading or writing, with "r" or
       "w" respectively.

       If a reference to an open filehandle is passed in place of the filename, it better be positioned to the
       start of a compression/decompression sequence.

       WARNING: With Perl 5.6 you cannot use a filehandle because of SEGV in destruction with bzclose or an
       implicit close.

   <b>$bz</b> <b>=</b> <b>Compress::Bzip2-&gt;new(</b> <b>[PARAMS]</b> <b>)</b>
       Create a Compress::Bzip2 object.  Optionally, provide compression/decompression parameters as a keyword
       =&gt; setting list.  See <u><b>bzsetparams()</b></u> for a description of the parameters.

   <b>$bz-&gt;bzopen(filename</b> <b>or</b> <b>filehandle,</b> <b>mode)</b>
       This is bzopen, but it uses an object previously created by the new method.  Other than that, it is
       identical to the above bzopen.

   <b>$bytesread</b> <b>=</b> <b>$bz-&gt;bzread($buffer</b> <b>[,</b> <b>$size])</b> <b>;</b>
       Reads <b>$size</b> bytes from the compressed file into <b>$buffer</b>. If <b>$size</b> is not specified, it will default to
       4096. If the scalar <b>$buffer</b> is not large enough, it will be extended automatically.

       Returns the number of bytes actually read. On EOF it returns 0 and in the case of an error, -1.

   <b>$bytesread</b> <b>=</b> <b>$bz-&gt;bzreadline($line)</b> <b>;</b>
       Reads the next line from the compressed file into <b>$line</b>.

       Returns the number of bytes actually read. On EOF it returns 0 and in the case of an error, -1.

       It IS legal to intermix calls to <b>bzread</b> and <b>bzreadline</b>.

       At this time <b>bzreadline</b> ignores the variable $/ ($INPUT_RECORD_SEPARATOR or $RS when "English" is in
       use). The end of a line is denoted by the C character '\n'.

   <b>$byteswritten</b> <b>=</b> <b>$bz-&gt;bzwrite($buffer</b> <b>[,</b> <b>$limit])</b> <b>;</b>
       Writes the contents of <b>$buffer</b> to the compressed file. Returns the number of bytes actually written, or 0
       on error.

       If $limit is given and non-zero, then only that many bytes from $buffer will be written.

   <b>$status</b> <b>=</b> <b>$bz-&gt;bzflush($flush)</b> <b>;</b>
       Flushes all pending output to the compressed file.  Works identically to the <u>zlib</u> function it interfaces
       to. Note that the use of <b>bzflush</b> can degrade compression.

       Returns "BZ_OK" if <b>$flush</b> is "BZ_FINISH" and all output could be flushed. Otherwise the bzlib error code
       is returned.

       Refer to the <u>bzlib</u> documentation for the valid values of <b>$flush</b>.

   <b>$status</b> <b>=</b> <b>$bz-&gt;bzeof()</b> <b>;</b>
       Returns 1 if the end of file has been detected while reading the input file, otherwise returns 0.

   <b>$bz-&gt;bzclose</b>
       Closes the compressed file. Any pending data is flushed to the file before it is closed.

   <b>$bz-&gt;bzsetparams(</b> <b>[PARAMS]</b> <b>);</b>
       Change settings for the deflate stream $bz.

       The list of the valid options is shown below. Options not specified will remain unchanged.

       <b>-verbosity</b>
            Defines the verbosity level. Valid values are 0 through 4,

            The default is "-verbosity =&gt; 0".

       <b>-blockSize100k</b>
            For bzip object opened for stream deflation or write.

            Defines the buffering factor of compression method.  The algorithm buffers all data until the buffer
            is full, then it flushes all the data out.  Use -blockSize100k to specify the size of the buffer.

            Valid settings are 1 through 9, representing a blocking in multiples of 100k.

            Note  that  each  such  block  has an overhead of leading and trailing synchronization bytes.  bzip2
            recovery uses this information to pull useable data out of a corrupted file.

            A streaming application would probably want to set the blocking low.

       <b>-workFactor</b>
            For bzip object opened for stream deflation or write.

            The workFactor setting tells the deflation algorithm how much  work  to  invest  to  compensate  for
            repetitive data.

            workFactor may be a number from 0 to 250 inclusive.  The default setting is 30.

            See the bzip documentation for more information.

       <b>-small</b>
            For bzip object opened for stream inflation or read.

            <b>small</b> may be 0 or 1.  Set "small" to one to use a slower, less memory intensive algorithm.

   <b>$bz-&gt;bzerror</b>
       Returns  the  <u>bzlib</u>  error message or number for the last operation associated with <b>$bz</b>. The return value
       will be the <u>bzlib</u> error number when used in a numeric context and the <u>bzlib</u> error message when used in  a
       string context. The <u>bzlib</u> error number constants, shown below, are available for use.

         BZ_CONFIG_ERROR
         BZ_DATA_ERROR
         BZ_DATA_ERROR_MAGIC
         BZ_FINISH
         BZ_FINISH_OK
         BZ_FLUSH
         BZ_FLUSH_OK
         BZ_IO_ERROR
         BZ_MAX_UNUSED
         BZ_MEM_ERROR
         BZ_OK
         BZ_OUTBUFF_FULL
         BZ_PARAM_ERROR
         BZ_RUN
         BZ_RUN_OK
         BZ_SEQUENCE_ERROR
         BZ_STREAM_END
         BZ_UNEXPECTED_EOF

   <b>$bz-&gt;bzclearerr</b>
   <b>$bzerrno</b>
       The  <b>$bzerrno</b> scalar holds the error code associated with the most recent <u>bzip2</u> routine. Note that unlike
       <b>bzerror()</b>, the error is <u>not</u> associated with a particular file.

       As with <b>bzerror()</b> it returns an error number in numeric context and an error message in  string  context.
       Unlike  <b>bzerror()</b>  though,  the  error  message  will  correspond  to the <u>bzlib</u> message when the error is
       associated with <u>bzlib</u> itself, or the UNIX error message when it is not (i.e. <u>bzlib</u> returned "Z_ERRORNO").

       As there is an overlap between the error numbers used by <u>bzlib</u> and UNIX, <b>$bzerrno</b> should only be used  to
       check  for the presence of <u>an</u> error in numeric context. Use <b>bzerror()</b> to check for specific <u>bzlib</u> errors.
       The <u>bzcat</u> example below shows how the variable can be used safely.

   <b>$bz-&gt;prefix</b>
       Returns the additional 5 byte header which is prepended to the bzip2 header   starting  with  "BZh"  when
       using memBzip/compress.

</pre><h4><b>Compress::Bzip2</b> <b>Utilities</b></h4><pre>
       Options: -d -c -z -f -v -k -s -1..9

   <b>bzip2(</b> <b>[OPTS],</b> <b>filename)</b>
   <b>bunzip2(filename)</b>
   <b>bzcat(filenames...)</b>
   <b>bzlibversion()</b>
   <b>bzinflateInit(</b> <b>opts...</b> <b>)</b>
</pre><h4><b>Internal</b> <b>Utilties</b></h4><pre>
   <b>bz_seterror(errno,</b>   <b>msg)</b>   <b>=head2</b>  <b>$bz-&gt;is_read()</b>  <b>=head2</b>  <b>$bz-&gt;is_stream()</b>  <b>=head2</b>  <b>$bz-&gt;is_write()</b>  <b>=head2</b>
       <b>$bz-&gt;total_in()</b> <b>=head2</b> <b>$bz-&gt;total_out()</b> <b>=head2</b> <b>version()</b>
</pre><h4><b>Compress::Bzip2</b> <b>1.03</b> <b>COMPATIBILITY</b></h4><pre>
       While the 2.x thread forked off of 1.00, another line of development came to a head at  1.03.   The  1.03
       version worked with bzlib 1.0.2, had improvements to the error handling, single buffer inflate/deflate, a
       streaming interface to inflate/deflate, and a cpan style test suite.

   <b>$dest</b> <b>=</b> <b>compress(</b> <b>$string,</b> <b>[$level]</b> <b>)</b>
       Alias  to memBzip, this compresses string, using the optional compression level, 1 through 9, the default
       being 6.  Returns a string containing the compressed data.

       On error <u>undef</u> is returned.

   <b>$dest</b> <b>=</b> <b>decompress($string,</b> <b>[$level])</b>
       Alias to memBunzip, this decompresses the data in string, returning a string containing the  decompressed
       data.

       On error <u>undef</u> is returned.

   <b>uncompress($string,</b> <b>[$level])</b>
       Another alias to memBunzip

   <b>$stream</b> <b>=</b> <b>compress_init(</b> <b>[PARAMS]</b> <b>)</b>
       Alias  to bzdeflateInit.  In addition to the named parameters documented for bzdeflateInit, the following
       are accepted:

          -level, alias to -blockSize100k
          -buffer, to set the buffer size.

       The -buffer option is ignored.  The intermediate buffer size is not changeable.

   <b>$stream</b> <b>=</b> <b>decompress_init(</b> <b>[PARAMS]</b> <b>)</b>
       Alias to bzinflateInit.  See bzinflateInit for a description of the parameters.  The option "-buffer"  is
       accepted, but ignored.

   <b>$output</b> <b>=</b> <b>$stream-&gt;add(</b> <b>$string</b> <b>)</b>
       Add  data  to  be  compressed/decompressed.  Returns whatever output is available (possibly none, if it's
       still buffering it), or undef on error.

   <b>$output</b> <b>=</b> <b>$stream-&gt;finish(</b> <b>[$string]</b> <b>)</b>
       Finish the operation; takes an optional final data string.  Whatever is returned  completes  the  output;
       returns undef on error.

   <b>$stream-&gt;error</b>
       Like  the function, but applies to the current object only.  Note that errors in a stream object are also
       returned by the function.

   <b>$stream-&gt;input_size</b>
       Alias to total_in.  Total bytes passed to the stream.

   <b>$stream-&gt;output_size</b>
       Alias to total_out.  Total bytes received from the stream.

</pre><h4><b>GZIP</b> <b>COMPATIBILITY</b> <b>INTERFACE</b></h4><pre>
       Except for the exact state and error numbers, this package presents an  interface  very  much  like  that
       given  by  the  Compress::Zlib  package.  Mostly, if you take the method name, state or error number from
       Compress::Zlib and replace the "g" with a "b", your code should work.

       To make the interoperability even easier, all the Compress::Zlib method names have been used  as  aliases
       or cover functions for the bzip2 methods.

       Therefore, most code that uses Compress::Zlib should be able to use this package, with a one line change.

       Simply change

          $gz = Compress::Zlib::gzopen( "filename", "w" );

       to

          $gz = Compress::Bzip2::gzopen( "filename", "w" );

       Some  of  the  Compress::Zlib  aliases  don't  return anything useful, like crc32 or adler32, cause bzip2
       doesn't do that sort of thing.

    <b>$gz</b> <b>=</b> <b>gzopen(</b> <b>$filename,</b> <b>$mode</b> <b>)</b>
       Alias for bzopen.

    <b>$gz-&gt;gzread(</b> <b>$buffer,</b> <b>[</b> <b>$length</b> <b>]</b> <b>)</b>
       Alias for bzread.

    <b>$gz-&gt;gzreadline(</b> <b>$buffer</b> <b>)</b>
       Alias for bzreadline.

    <b>$gz-&gt;gzwrite(</b> <b>$buffer</b> <b>)</b>
       Alias for bzwrite.

    <b>$gz-&gt;gzflush(</b> <b>[$flushtype]</b> <b>)</b>
       Alias for bzflush, with return code translation.

    <b>$gz-&gt;gzclose(</b> <b>)</b>
       Alias for bzclose.

    <b>$gz-&gt;gzeof(</b> <b>)</b>
       Alias for bzeof.

    <b>$gz-&gt;gzerror(</b> <b>)</b>
       Alias for bzerror.

    <b>$gz-&gt;gzsetparams(</b> <b>$level,</b> <b>$strategy</b> <b>)</b>
       This is a no-op.

    <b>$d</b> <b>=</b> <b>deflateInit(</b> <b>[OPTS]</b> <b>)</b>
       Alias for bzdeflateInit, with return code translation.

       All OPTS are ignored.

    <b>$d-&gt;deflate(</b> <b>$buffer</b> <b>)</b>
       Alias for bzdeflate, with return code translation.

    <b>$d-&gt;deflateParams(</b> <b>[OPTS]</b> <b>)</b>
       This is a no-op.

    <b>$d-&gt;flush(</b> <b>[$flushtype]</b> <b>)</b>
       Cover function for bzflush or bzclose, depending on $flushtype.

       See the Compress::Zlib documentation for more information.

    <b>$d-&gt;dict_adler(</b> <b>)</b>
       This is a no-op.

    <b>$d-&gt;msg(</b> <b>)</b>
       This is a no-op.

    <b>$d</b> <b>=</b> <b>inflateInit(</b> <b>[OPTS]</b> <b>)</b>
       Alias for bzinflateInit, with return code translation.

       All OPTS are ignored.

    <b>$d-&gt;inflate(</b> <b>)</b>
       Alias for bzinflate, with return code translation.

    <b>$d-&gt;inflateSync(</b> <b>)</b>
       This is a no-op.

    <b>$d-&gt;adler32(</b> <b>$crc</b> <b>)</b>
       This is a no-op.

    <b>$d-&gt;crc32(</b> <b>$crc</b> <b>)</b>
       This is a no-op.

    <b>$buffer</b> <b>=</b> <b>memGzip(</b> <b>$buffer</b> <b>)</b>
       Alias for memBzip.

    <b>$buffer</b> <b>=</b> <b>memGunzip(</b> <b>$buffer</b> <b>)</b>
       Alias for memBunzip.

</pre><h4><b>IN-MEMORY</b> <b>COMPRESS/UNCOMPRESS</b></h4><pre>
       Two high-level functions are provided by <u>bzlib</u> to perform in-memory compression.  They  are  <b>memBzip</b>  and
       <b>memBunzip</b>. Two Perl subs are provided which provide similar functionality.

   <b>$compressed</b> <b>=</b> <b>memBzip($buffer);</b>
       Compresses <b>$buffer</b>. If successful it returns the compressed data. Otherwise it returns <u>undef</u>.

       The buffer parameter can either be a scalar or a scalar reference.

       Essentially,  an  in-memory  bzip  file  is created. It creates a minimal bzip header, which adds 5 bytes
       before the bzip2 specific BZh header.

   <b>$uncompressed</b> <b>=</b> <b>memBunzip($buffer);</b>
       Uncompresses <b>$buffer</b>. If successful it returns the uncompressed data. Otherwise it returns <u>undef</u>.

       The source buffer can either be a scalar or a scalar reference.

       The buffer parameter can either be a scalar or a scalar reference. The contents of the  buffer  parameter
       are destroyed after calling this function.

</pre><h4><b>STREAM</b> <b>DEFLATE</b> <b>(=</b> <b>COMPRESS)</b></h4><pre>
       The Perl interface will <u>always</u> consume the complete input buffer before returning. Also the output buffer
       returned will be automatically grown to fit the amount of output available.

       Here is a definition of the interface available:

   <b>($d,</b> <b>$status)</b> <b>=</b> <b>bzdeflateInit(</b> <b>[PARAMS]</b> <b>)</b>
       Initialises a deflation stream.

       If  successful,  it  will  return  the  initialised deflation stream, <b>$d</b> and <b>$status</b> of "BZ_OK" in a list
       context. In scalar context it returns the deflation stream, <b>$d</b>, only.

       If not successful, the returned deflation stream (<b>$d</b>) will be <u>undef</u> and <b>$status</b> will hold the exact <u>bzip2</u>
       error code.

       The function optionally takes a number of named options specified as "-Name=&gt;value"  pairs.  This  allows
       individual options to be tailored without having to specify them all in the parameter list.

       Here is a list of the valid options:

       <b>-verbosity</b>
            Defines the verbosity level. Valid values are 0 through 4,

            The default is "-verbosity =&gt; 0".

       <b>-blockSize100k</b>
            Defines the buffering factor of compression method.  The algorithm buffers all data until the buffer
            is full, then it flushes all the data out.  Use -blockSize100k to specify the size of the buffer.

            Valid settings are 1 through 9, representing a blocking in multiples of 100k.

            Note  that  each  such  block  has an overhead of leading and trailing synchronization bytes.  bzip2
            recovery uses this information to pull useable data out of a corrupted file.

            A streaming application would probably want to set the blocking low.

       <b>-workFactor</b>
            The workFactor setting tells the deflation algorithm how much  work  to  invest  to  compensate  for
            repetitive data.

            workFactor may be a number from 0 to 250 inclusive.  The default setting is 30.

            See the bzip documentation for more information.

       Here  is  an example of using the <b>deflateInit</b> optional parameter list to override the default buffer size
       and compression level. All other options will take their default values.

           bzdeflateInit( -blockSize100k =&gt; 1, -verbosity =&gt; 1 );

   <b>($out,</b> <b>$status)</b> <b>=</b> <b>$d-&gt;bzdeflate($buffer)</b>
       Deflates the contents of <b>$buffer</b>. The buffer can  either  be  a  scalar  or  a  scalar  reference.   When
       finished,  <b>$buffer</b>  will  be  completely  processed (assuming there were no errors). If the deflation was
       successful it returns deflated output, <b>$out</b>, and a status value, <b>$status</b>, of "Z_OK".

       On error, <b>$out</b> will be <u>undef</u> and <b>$status</b> will contain the <u>zlib</u> error code.

       In a scalar context <b>bzdeflate</b> will return <b>$out</b> only.

       As with the internal buffering of the <u>deflate</u> function in <u>bzip2</u>, it is not necessarily the case that  any
       output  will  be produced by this method. So don't rely on the fact that <b>$out</b> is empty for an error test.
       In fact, given the size of bzdeflates internal buffer, with most files it's  likely  you  won't  see  any
       output at all until flush or close.

   <b>($out,</b> <b>$status)</b> <b>=</b> <b>$d-&gt;bzflush([flush_type])</b>
       Typically  used to finish the deflation. Any pending output will be returned via <b>$out</b>.  <b>$status</b> will have
       a value "BZ_OK" if successful.

       In a scalar context <b>bzflush</b> will return <b>$out</b> only.

       Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate  a
       decompression (using "BZ_FLUSH") or when you want to create a <u>full</u> <u>flush</u> <u>point</u> (using "BZ_FINISH").

       The allowable values for "flush_type" are "BZ_FLUSH" and "BZ_FINISH".

       For  a  handle  opened  for  "w"  (bzwrite),  the  default  is "BZ_FLUSH".  For a stream, the default for
       "flush_type" is "BZ_FINISH" (which is essentially a close and reopen).

       It is strongly recommended that you only set the "flush_type"  parameter  if  you  fully  understand  the
       implications of what it does. See the "bzip2" documentation for details.

   <b>Example</b>
       Here  is  a trivial example of using <b>bzdeflate</b>. It simply reads standard input, deflates it and writes it
       to standard output.

           use strict ;
           use warnings ;

           use Compress::Bzip2 ;

           binmode STDIN;
           binmode STDOUT;
           my $x = bzdeflateInit()
              or die "Cannot create a deflation stream\n" ;

           my ($output, $status) ;
           while (&lt;&gt;)
           {
               ($output, $status) = $x-&gt;bzdeflate($_) ;

               $status == BZ_OK
                   or die "deflation failed\n" ;

               print $output ;
           }

           ($output, $status) = $x-&gt;bzclose() ;

           $status == BZ_OK
               or die "deflation failed\n" ;

           print $output ;

</pre><h4><b>STREAM</b> <b>INFLATE</b></h4><pre>
       Here is a definition of the interface:

   <b>($i,</b> <b>$status)</b> <b>=</b> <b>inflateInit()</b>
       Initialises an inflation stream.

       In a list context it returns the inflation stream, <b>$i</b>, and the <u>zlib</u> status code (<b>$status</b>).  In  a  scalar
       context it returns the inflation stream only.

       If successful, <b>$i</b> will hold the inflation stream and <b>$status</b> will be "BZ_OK".

       If not successful, <b>$i</b> will be <u>undef</u> and <b>$status</b> will hold the <u>bzlib.h</u> error code.

       The  function  optionally  takes a number of named options specified as "-Name=&gt;value" pairs. This allows
       individual options to be tailored without having to specify them all in the parameter list.

       For backward compatibility, it is also possible  to  pass  the  parameters  as  a  reference  to  a  hash
       containing the name=&gt;value pairs.

       The  function  takes  one  optional parameter, a reference to a hash.  The contents of the hash allow the
       deflation interface to be tailored.

       Here is a list of the valid options:

       <b>-small</b>
            <b>small</b> may be 0 or 1.  Set "small" to one to use a slower, less memory intensive algorithm.

       <b>-verbosity</b>
            Defines the verbosity level. Valid values are 0 through 4,

            The default is "-verbosity =&gt; 0".

       Here is an example of using the <b>bzinflateInit</b> optional parameter.

           bzinflateInit( -small =&gt; 1, -verbosity =&gt; 1 );

   <b>($out,</b> <b>$status)</b> <b>=</b> <b>$i-&gt;bzinflate($buffer)</b>
       Inflates the complete contents of <b>$buffer</b>. The buffer can either be a scalar or a scalar reference.

       Returns "BZ_OK" if successful and "BZ_STREAM_END" if the end of the compressed data has been successfully
       reached.  If not successful, <b>$out</b> will be <u>undef</u> and <b>$status</b> will hold the <u>bzlib</u> error code.

       The $buffer parameter is modified by "bzinflate". On completion it will contain what remains of the input
       buffer after inflation. This means that $buffer will be  an  empty  string  when  the  return  status  is
       "BZ_OK". When the return status is "BZ_STREAM_END" the $buffer parameter will contains what (if anything)
       was stored in the input buffer after the deflated data stream.

       This feature is useful when processing a file format that encapsulates a compressed data stream.

   <b>Example</b>
       Here is an example of using <b>bzinflate</b>.

           use strict ;
           use warnings ;

           use Compress::Bzip2;

           my $x = bzinflateInit()
              or die "Cannot create a inflation stream\n" ;

           my $input = '' ;
           binmode STDIN;
           binmode STDOUT;

           my ($output, $status) ;
           while (read(STDIN, $input, 4096))
           {
               ($output, $status) = $x-&gt;bzinflate(\$input) ;

               print $output
                   if $status == BZ_OK or $status == BZ_STREAM_END ;

               last if $status != BZ_OK ;
           }

           die "inflation failed\n"
               unless $status == BZ_STREAM_END ;

</pre><h4><b>EXAMPLES</b></h4><pre>
       Here are some example scripts of using the interface.

   <b>A</b> <b>bzcat</b> <b>function</b>
         use strict ;
         use warnings ;

         use Compress::Bzip2 ;

         die "Usage: bzcat file...\n" unless @ARGV ;

         my $file ;

         foreach $file (@ARGV) {
           my $buffer ;

           my $bz = bzopen($file, "rb")
              or die "Cannot open $file: $bzerrno\n" ;

           print $buffer while $bz-&gt;bzread($buffer) &gt; 0 ;

           die "Error reading from $file: $bzerrno" . ($bzerrno+0) . "\n"
              if $bzerrno != BZ_STREAM_END ;

           $bz-&gt;bzclose() ;
         }

   <b>A</b> <b>grep</b> <b>using</b> <b>bzreadline</b>
         use strict ;
         use warnings ;

         use Compress::Bzip2 ;

         die "Usage: bzgrep pattern file...\n" unless @ARGV &gt;= 2;

         my $pattern = shift ;

         my $file ;

         foreach $file (@ARGV) {
           my $bz = bzopen($file, "rb")
              or die "Cannot open $file: $bzerrno\n" ;

           while ($bz-&gt;bzreadline($_) &gt; 0) {
             print if /$pattern/ ;
           }

           die "Error reading from $file: $bzerrno\n"
             if $bzerrno != Z_STREAM_END ;

           $bz-&gt;bzclose() ;
         }

   <b>Streaming</b> <b>Compression</b>
       This  script,  <u>bzstream</u>,  does  the  opposite of the <u>bzcat</u> script above. It reads from standard input and
       writes a bzip file to standard output.

         use strict ;
         use warnings ;

         use Compress::Bzip2 ;

         binmode STDOUT;       # bzopen only sets it on the fd

         my $bz = bzopen(\*STDOUT, "wb")
            or die "Cannot open stdout: $bzerrno\n" ;

         while (&lt;&gt;) {
           $bz-&gt;bzwrite($_) or die "error writing: $bzerrno\n" ;
         }

         $bz-&gt;bzclose ;

</pre><h4><b>EXPORT</b></h4><pre>
       Use the tags :all, :utilities, :constants, :bzip1 and :gzip.

   <b>Export</b> <b>tag</b> <b>:all</b>
       This exports all the exportable methods.

   <b>Export</b> <b>tag</b> <b>:constants</b>
       This exports only the BZ_* constants.

   <b>Export</b> <b>tag</b> <b>:bzip1</b>
       This exports the Compress::Bzip2 1.x functions, for compatibility.

          compress
          decompress
          compress_init
          decompress_init
          version

       These are actually aliases to memBzip and memBunzip.

   <b>Export</b> <b>tag</b> <b>:utilities</b>
       This gives an interface to the bzip2 methods.

           bzopen
           bzinflateInit
           bzdeflateInit
           memBzip
           memBunzip
           bzip2
           bunzip2
           bzcat
           bzlibversion
           $bzerrno

   <b>Export</b> <b>tag</b> <b>:gzip</b>
       This gives compatibility with Compress::Zlib.

           gzopen
           gzinflateInit
           gzdeflateInit
           memGzip
           memGunzip
           $gzerrno

</pre><h4><b>Exportable</b> <b>constants</b></h4><pre>
       All the <u>bzlib</u> constants are automatically imported when you make use of <u>Compress::Bzip2</u>.

         BZ_CONFIG_ERROR
         BZ_DATA_ERROR
         BZ_DATA_ERROR_MAGIC
         BZ_FINISH
         BZ_FINISH_OK
         BZ_FLUSH
         BZ_FLUSH_OK
         BZ_IO_ERROR
         BZ_MAX_UNUSED
         BZ_MEM_ERROR
         BZ_OK
         BZ_OUTBUFF_FULL
         BZ_PARAM_ERROR
         BZ_RUN
         BZ_RUN_OK
         BZ_SEQUENCE_ERROR
         BZ_STREAM_END
         BZ_UNEXPECTED_EOF

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The documentation for zlib, bzip2 and Compress::Zlib.

</pre><h4><b>AUTHOR</b></h4><pre>
       Rob Janes, &lt;arjay at cpan.org&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2005 by Rob Janes

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself, either Perl version 5.8.3 or, at your option, any later version of Perl 5 you may have available.

</pre><h4><b>AUTHOR</b></h4><pre>
       The       <u>Compress::Bzip2</u>       module      was      originally      written      by      Gawdi      Azem
       <u><a href="mailto:azemgi@rupert.informatik.uni-stuttgart.de">azemgi@rupert.informatik.uni-stuttgart.de</a></u>.

       The first <u>Compress::Bzip2</u> module was written by Gawdi Azem <u><a href="mailto:azemgi@rupert.informatik.uni-stuttgart.de">azemgi@rupert.informatik.uni-stuttgart.de</a></u>.  It
       provided an interface to the in memory inflate and deflate routines.

       <u>Compress::Bzip2</u> was subsequently passed on to Marco Carnut <u><a href="mailto:kiko@tempest.com.br">kiko@tempest.com.br</a></u> who shepherded it  through
       to  version 1.03, a set of changes which included upgrades to handle bzlib 1.0.2, and improvements to the
       in memory inflate and deflate routines.  The streaming interface and  error  information  were  added  by
       David Robins <u><a href="mailto:dbrobins@davidrobins.net">dbrobins@davidrobins.net</a></u>.

       Version 2 of <u>Compress::Bzip2</u> is due to Rob Janes, of <a href="mailto:arjay@cpan.org">arjay@cpan.org</a>.  This release is intended to give an
       interface  close to that of Compress::Zlib.  It's development forks from 1.00, not 1.03, so the streaming
       interface is not the same as that in 1.03, although apparently compatible as  it  passes  the  1.03  test
       suite.

       Minor subsequent fixes and releases were done by Reini Urban, <a href="mailto:rurban@cpan.org">rurban@cpan.org</a>.

</pre><h4><b>MODIFICATION</b> <b>HISTORY</b></h4><pre>
       See the Changes file.

       2.00 Second public release of <u>Compress::Bzip2</u>.

perl v5.40.0                                       2024-10-20                               <u>Compress::<a href="../man3pm/Bzip2.3pm.html">Bzip2</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>