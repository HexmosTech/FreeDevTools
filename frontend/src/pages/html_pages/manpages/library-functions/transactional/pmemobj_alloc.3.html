<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pmemobj_alloc(),   pmemobj_xalloc(),   pmemobj_zalloc(),  pmemobj_realloc(),  pmemobj_zrealloc(),  pmemo‐</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpmemobj-dev">libpmemobj-dev_1.13.1-1.1ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>pmemobj_alloc</b>(),   <b>pmemobj_xalloc</b>(),   <b>pmemobj_zalloc</b>(),  <b>pmemobj_realloc</b>(),  <b>pmemobj_zrealloc</b>(),  <b>pmemo‐</b>
       <b>bj_strdup</b>(), <b>pmemobj_wcsdup</b>(), <b>pmemobj_alloc_usable_size</b>(), <b>pmemobj_defrag</b>(),  <b>POBJ_NEW</b>(),  <b>POBJ_ALLOC</b>(),
       <b>POBJ_ZNEW</b>(), <b>POBJ_ZALLOC</b>(), <b>POBJ_REALLOC</b>(), <b>POBJ_ZREALLOC</b>(), <b>POBJ_FREE</b>() - non-transactional atomic allo‐
       cations

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;libpmemobj.h&gt;

              typedef int (*pmemobj_constr)(**PMEMobjpool *pop, void *ptr, void *arg);
              int pmemobj_alloc(PMEMobjpool *pop, PMEMoid *oidp, size_t size,
                  uint64_t type_num, pmemobj_constr constructor, void *arg);
              int pmemobj_xalloc(PMEMobjpool *pop, PMEMoid *oidp, size_t size,
                  uint64_t type_num, uint64_t flags, pmemobj_constr constructor,
                  void *arg); (EXPERIMENTAL)
              int pmemobj_zalloc(PMEMobjpool *pop, PMEMoid *oidp, size_t size,
                  uint64_t type_num);
              void pmemobj_free(PMEMoid *oidp);
              int pmemobj_realloc(PMEMobjpool *pop, PMEMoid *oidp, size_t size,
                  uint64_t type_num);
              int pmemobj_zrealloc(PMEMobjpool *pop, PMEMoid *oidp, size_t size,
                  uint64_t type_num);
              int pmemobj_strdup(PMEMobjpool *pop, PMEMoid *oidp, const char *s,
                  uint64_t type_num);
              int pmemobj_wcsdup(PMEMobjpool *pop, PMEMoid *oidp, const wchar_t *s,
                  uint64_t type_num);
              size_t pmemobj_alloc_usable_size(PMEMoid oid);
              int pmemobj_defrag(PMEMobjpool *pop, PMEMoid **oidv, size_t oidcnt,
                  struct pobj_defrag_result *result);

              POBJ_NEW(PMEMobjpool *pop, TOID *oidp, TYPE, pmemobj_constr constructor,
                  void *arg)
              POBJ_ALLOC(PMEMobjpool *pop, TOID *oidp, TYPE, size_t size,
                  pmemobj_constr constructor, void *arg)
              POBJ_ZNEW(PMEMobjpool *pop, TOID *oidp, TYPE)
              POBJ_ZALLOC(PMEMobjpool *pop, TOID *oidp, TYPE, size_t size)
              POBJ_REALLOC(PMEMobjpool *pop, TOID *oidp, TYPE, size_t size)
              POBJ_ZREALLOC(PMEMobjpool *pop, TOID *oidp, TYPE, size_t size)
              POBJ_FREE(TOID *oidp)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Functions  described in this document provide the mechanism to allocate, resize and free objects from the
       persistent memory pool in a thread-safe and fail-safe manner.  All the routines are atomic  with  respect
       to other threads and any power-fail interruptions.  If any of these operations is torn by program failure
       or  system crash, on recovery they are guaranteed to be entirely completed or discarded, leaving the per‐
       sistent memory heap and internal object containers in a consistent state.

       All these functions should be used outside transactions.  If executed within an open transaction they are
       considered durable immediately after completion.  Changes made with these functions will  not  be  rolled
       back  if the transaction is aborted or interrupted.  They have no information about other changes made by
       transactional API, so if the same data is modified in a single transaction using transactional  and  then
       non-transactional API, transaction abort will likely corrupt the data.

       The allocations are always aligned to a cache-line boundary.

       The  <u>pmemobj_constr</u>  type  represents a constructor for atomic allocation from the persistent memory heap
       associated with memory pool <u>pop</u>.  <u>ptr</u> is a pointer to the allocated memory area and <u>arg</u> is a user-defined
       argument passed to the constructor.

       The <b>pmemobj_alloc</b>() function allocates a new object from the persistent memory heap associated with memo‐
       ry pool <u>pop</u>.  The <u>PMEMoid</u> of the allocated object is stored in <u>oidp</u>.  If <u>oidp</u> is NULL, then the newly al‐
       located object may be accessed only by iterating objects in the object container associated with the type
       number <u>type_num</u>, as described in <b><a href="../man3/POBJ_FOREACH.3.html">POBJ_FOREACH</a></b>(3).  If <u>oidp</u> points to a memory location from  the  <b>pmemobj</b>
       heap,  <u>oidp</u>  is  modified  atomically.  Before returning, <b>pmemobj_alloc</b>() calls the <u>constructor</u> function,
       passing the pool handle <u>pop</u>, the pointer to the newly allocated object in <u>ptr</u>, and the <u>arg</u> argument.   It
       is  guaranteed  that  the allocated object is either properly initialized, or if the allocation is inter‐
       rupted before the constructor completes, the memory space reserved for the object is reclaimed.  <u>size</u> can
       be any non-zero value; however, due to internal padding and object metadata, the actual size of the allo‐
       cation will differ from the requested size by at least 64 bytes.  For this reason, making allocations  of
       a size less than 64 bytes is extremely inefficient and discouraged.  The allocated object is added to the
       internal container associated with <u>type_num</u>.

       <b>pmemobj_xalloc</b>()  is  equivalent to <b>pmemobj_alloc</b>(), but with an additional <u>flags</u> argument that is a bit‐
       mask of the following values:

       • <b>POBJ_XALLOC_ZERO</b> - zero the allocated object (equivalent of <b>pmemobj_zalloc</b>())

       • <b>POBJ_CLASS_ID(class_id)</b> - allocate an object from the allocation class <u>class_id</u>.  The class  id  cannot
         be 0.

       • <b>POBJ_ARENA_ID(arena_id)</b>  - allocate an object from the arena specified by <u>arena_id</u>.  The arena must ex‐
         ist, otherwise, the behavior is undefined.  If <u>arena_id</u> is equal 0, then arena assigned to the  current
         thread will be used.

       The  <b>pmemobj_zalloc</b>()  function  allocates a new zeroed object from the persistent memory heap associated
       with memory pool <u>pop</u>.  The <u>PMEMoid</u> of the allocated object is stored in <u>oidp</u>.  If <u>oidp</u> is NULL, then  the
       newly  allocated object may be accessed only by iterating objects in the object container associated with
       the type number <u>type_num</u>, as described in <b><a href="../man3/POBJ_FOREACH.3.html">POBJ_FOREACH</a></b>(3).  If <u>oidp</u> points to a memory location from  the
       <b>pmemobj</b>  heap,  <u>oidp</u>  is  modified  atomically.  <u>size</u> can be any non-zero value; however, due to internal
       padding and object metadata, the actual size of the allocation will differ from the requested one  by  at
       least  64  bytes.   For this reason, making allocations of a size less than 64 bytes is extremely ineffi‐
       cient and discouraged.  The allocated object is added to the internal container associated with <u>type_num</u>.

       The <b>pmemobj_free</b>() function frees the memory space represented by <u>oidp</u>, which must have been allocated by
       a previous call to <b>pmemobj_alloc</b>(),  <b>pmemobj_xalloc</b>(),  <b>pmemobj_zalloc</b>(),  <b>pmemobj_realloc</b>(),  or  <b>pmemo‐</b>
       <b>bj_zrealloc</b>().   <b>pmemobj_free</b>()  provides  the same semantics as <b><a href="../man3/free.3.html">free</a></b>(3), but instead of operating on the
       process heap supplied by the system, it operates on the persistent memory heap.  If <u>oidp</u> is <b>OID_NULL</b>,  no
       operation is performed.  If <u>oidp</u> is NULL or if it points to the root object’s <u>OID</u>, the behavior of <b>pmemo‐</b>
       <b>bj_free</b>()  is  undefined.  <u>oidp</u> is set to <b>OID_NULL</b> after the memory is freed.  If <u>oidp</u> points to a memory
       location from the <b>pmemobj</b> heap, <u>oidp</u> is modified atomically.

       The <b>pmemobj_realloc</b>() function changes the size of the object represented by <u>oidp</u> to <u>size</u> bytes.   <b>pmemo‐</b>
       <b>bj_realloc</b>() provides similar semantics to <b><a href="../man3/realloc.3.html">realloc</a></b>(3), but operates on the persistent memory heap associ‐
       ated with memory pool <u>pop</u>.  The resized object is also added or moved to the internal container associat‐
       ed  with  type number <u>type_num</u>.  The contents will be unchanged in the range from the start of the region
       up to the minimum of the old and new sizes.  If the new size is larger than the old size, the added memo‐
       ry will <u>not</u> be initialized.  If <u>oidp</u> is <u>OID_NULL</u>, then the call is equivalent to <u>pmemobj_alloc(pop,</u> <u>size,</u>
       <u>type_num)</u>.  If <u>size</u> is equal to zero, and <u>oidp</u> is not <b>OID_NULL</b>, then the call  is  equivalent  to  <u>pmemo‐</u>
       <u>bj_free(oid)</u>.   Unless  <u>oidp</u>  is  <b>OID_NULL</b>, it must have been allocated by an earlier call to <b>pmemobj_al‐</b>
       <b>loc</b>(), <b>pmemobj_xalloc</b>(), <b>pmemobj_zalloc</b>(), <b>pmemobj_realloc</b>(), or <b>pmemobj_zrealloc</b>().  Note that  the  ob‐
       ject handle value may change as a result of reallocation.  If the object was moved, the memory space rep‐
       resented  by  <u>oid</u> is reclaimed.  If <u>oidp</u> points to a memory location from the <b>pmemobj</b> heap, <u>oidp</u> is modi‐
       fied atomically.  If <u>oidp</u> is NULL or if it points to the root object’s <u>OID</u>, the behavior of <b>pmemobj_real‐</b>
       <b>loc</b>() is undefined.

       <b>pmemobj_zrealloc</b>() is equivalent to <b>pmemobj_realloc</b>(), except that if the new size is larger than the old
       size, the added memory will be zeroed.

       The <b>pmemobj_strdup</b>() function stores a handle to a new object in <u>oidp</u> which is a duplicate of the  string
       <u>s</u>.  <b>pmemobj_strdup</b>() provides the same semantics as <b><a href="../man3/strdup.3.html">strdup</a></b>(3), but operates on the persistent memory heap
       associated  with  memory pool <u>pop</u>.  If <u>oidp</u> is NULL, then the newly allocated object may be accessed only
       by iterating objects in the object container associated  with  type  number  <u>type_num</u>,  as  described  in
       <b><a href="../man3/POBJ_FOREACH.3.html">POBJ_FOREACH</a></b>(3).  If <u>oidp</u> points to a memory location from the <b>pmemobj</b> heap, <u>oidp</u> is modified atomically.
       The allocated string object is also added to the internal container associated with type number <u>type_num</u>.
       Memory  for  the  new string is obtained with <b>pmemobj_alloc</b>(), on the given memory pool, and can be freed
       with <b>pmemobj_free</b>() on the same memory pool.

       <b>pmemobj_wcsdup</b>() is equivalent to <b>pmemobj_strdup</b>(), but operates on a  wide  character  string  (wchar_t)
       rather than a standard character string.

       The  <b>pmemobj_alloc_usable_size</b>()  function  provides the same semantics as <b><a href="../man3/malloc_usable_size.3.html">malloc_usable_size</a></b>(3), but in‐
       stead of the process heap supplied by the system, it operates on the persistent memory heap.

       The <b>POBJ_NEW</b>() macro is a wrapper around the <b>pmemobj_alloc</b>() function.  Instead of taking  a  pointer  to
       <u>PMEMoid</u>,  it takes a pointer to the typed <u>OID</u> of type name <u>TYPE</u>, and passes the size and type number from
       the typed <u>OID</u> to <b>pmemobj_alloc</b>().

       The <b>POBJ_ALLOC</b>() macro is equivalent to <b>POBJ_NEW</b>, except that instead of using the size of the typed <u>OID</u>,
       passes <u>size</u> to <b>pmemobj_alloc</b>().

       The <b>POBJ_ZNEW</b>() macro is a wrapper around the <b>pmemobj_zalloc</b>() function.  Instead of taking a pointer  to
       <u>PMEMoid</u>,  it takes a pointer to the typed <u>OID</u> of type name <u>TYPE</u>, and passes the size and type number from
       the typed <u>OID</u> to <b>pmemobj_zalloc</b>().

       The <b>POBJ_ZALLOC</b>() macro is equivalent to <b>POBJ_ZNEW</b>, except that instead of using the size  of  the  typed
       <u>OID</u>, passes <u>size</u> to <b>pmemobj_zalloc</b>().

       The <b>POBJ_REALLOC</b>() macro is a wrapper around the <b>pmemobj_realloc</b>() function.  Instead of taking a pointer
       to  <u>PMEMoid</u>,  it  takes a pointer to the typed <u>OID</u> of type name <u>TYPE</u>, and passes the type number from the
       typed <u>OID</u> to <b>pmemobj_realloc</b>().

       The <b>POBJ_ZREALLOC</b>() macro is a wrapper around the  <b>pmemobj_zrealloc</b>()  function.   Instead  of  taking  a
       pointer  to  <u>PMEMoid</u>,  it  takes a pointer to the typed <u>OID</u> of type name <u>TYPE</u>, and passes the type number
       from the typed <u>OID</u> to <b>pmemobj_zrealloc</b>().

       The <b>POBJ_FREE</b>() macro is a wrapper around the <b>pmemobj_free</b>() function which takes a pointer to the  typed
       <u>OID</u> instead of to <u>PMEMoid</u>.

       The  <b>pmemobj_defrag</b>()  function  performs  defragmentation  on  the objects provided through the array of
       pointers to PMEMoids <u>oidv</u> with size <u>oidcnt</u>.  If an object from the provided array is selected to be moved
       to a new location in the heap, it is reallocated and all provided pointers to that object are  atomically
       updated.   To maintain data structure consistency, applications should always provide all pointers for an
       object to <b>pmemobj_defrag</b> method.  This ensures that, even in the presence of failures,  all  pointers  to
       the  object  will  either point to the old or a new location.  All objects and pointers to objects should
       belong to the pool <u>pop</u> or, in case of pointers, can also  reside  in  volatile  memory.   Defragmentation
       across  pools is not supported.  Objects in the array that are <u>OID_NULL</u> are skipped over and no operation
       is performed on them.  All other objects must have been allocated by an earlier call to  <b>pmemobj_alloc</b>(),
       <b>pmemobj_xalloc</b>(),  <b>pmemobj_zalloc</b>(),  <b>pmemobj_realloc</b>(),  <b>pmemobj_zrealloc</b>(),  <b>pmemobj_strdup</b>() or <b>pmemo‐</b>
       <b>bj_wcsdup</b>().  The <u>result</u> variable is an instance of <u>struct</u> <u>pobj_defrag_result</u> and, if not  NULL,  can  be
       used to read <u>total</u>, the number of objects found that were processed, and <u>relocated</u>, the number of objects
       that  were relocated during defragmentation.  These variables are always initialized and can be non-zero,
       even if the return value of <b>pmemobj_defrag</b>() indicated a failure.  This is because the failure might have
       occurred after some objects were already processed.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>pmemobj_alloc</b>() and <b>pmemobj_xalloc</b> return 0.  If <u>oidp</u> is not NULL, the <u>PMEMoid</u> of  the  newly
       allocated  object  is stored in <u>oidp</u>.  If the allocation fails, -1 is returned and <u>errno</u> is set appropri‐
       ately.  If the constructor returns a non-zero value, the allocation is canceled, -1 is returned, and  <u>er‐</u>
       <u>rno</u>  is set to <b>ECANCELED</b>.  If <u>size</u> equals 0, or the <u>flags</u> for <b>pmemobj_xalloc</b> are invalid, -1 is returned,
       <u>errno</u> is set to <b>EINVAL</b>, and <u>oidp</u> is left untouched.

       On success, <b>pmemobj_zalloc</b>() returns 0.  If <u>oidp</u> is not NULL, the <u>PMEMoid</u> of the newly  allocated  object
       is  stored in <u>oidp</u>.  If the allocation fails, it returns -1 and sets <u>errno</u> appropriately.  If <u>size</u> equals
       0, it returns -1, sets <u>errno</u> to <b>EINVAL</b>, and leaves <u>oidp</u> untouched.

       The <b>pmemobj_free</b>() function returns no value.

       On success, <b>pmemobj_realloc</b>() and <b>pmemobj_zrealloc</b>() return 0 and update <u>oidp</u> if  necessary.   On  error,
       they return -1 and set <u>errno</u> appropriately.

       On  success, <b>pmemobj_strdup</b>() and <b>pmemobj_wcsdup</b>() return 0.  If <u>oidp</u> is not NULL, the <u>PMEMoid</u> of the du‐
       plicated string object is stored in <u>oidp</u>.  If <u>s</u> is NULL, they return -1, set <u>errno</u> to <b>EINVAL</b>,  and  leave
       <u>oidp</u> untouched.  On other errors, they return -1 and set <u>errno</u> appropriately.

       The  <b>pmemobj_alloc_usable_size</b>() function returns the number of usable bytes in the object represented by
       <u>oid</u>.  If <u>oid</u> is <b>OID_NULL</b>, it returns 0.

       On success, <b>pmemobj_defrag</b>() returns 0.  If defragmentation was unsuccessful or only partially successful
       (i.e. if it was aborted halfway through due to lack of resources), -1 is returned.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/free.3.html">free</a></b>(3), <b><a href="../man3/POBJ_FOREACH.3.html">POBJ_FOREACH</a></b>(3), <b><a href="../man3/realloc.3.html">realloc</a></b>(3), <b><a href="../man3/strdup.3.html">strdup</a></b>(3), <b><a href="../man3/wcsdup.3.html">wcsdup</a></b>(3), <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) and <b>&lt;https://pmem.io&gt;</b>
</pre>
 </div>
</div></section>
</div>
</body>
</html>