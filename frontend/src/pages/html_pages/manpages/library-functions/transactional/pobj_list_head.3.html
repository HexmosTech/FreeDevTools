<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POBJ_LIST_HEAD(),     POBJ_LIST_ENTRY(),    POBJ_LIST_FIRST(),    POBJ_LIST_LAST(),    POBJ_LIST_EMPTY(),</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpmemobj-dev">libpmemobj-dev_1.13.1-1.1ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>POBJ_LIST_HEAD</b>(),     <b>POBJ_LIST_ENTRY</b>(),    <b>POBJ_LIST_FIRST</b>(),    <b>POBJ_LIST_LAST</b>(),    <b>POBJ_LIST_EMPTY</b>(),
       <b>POBJ_LIST_NEXT</b>(), <b>POBJ_LIST_PREV</b>(),

       <b>POBJ_LIST_FOREACH</b>(), <b>POBJ_LIST_FOREACH_REVERSE</b>(),

       <b>POBJ_LIST_INSERT_HEAD</b>(),  <b>POBJ_LIST_INSERT_TAIL</b>(),  <b>POBJ_LIST_INSERT_AFTER</b>(),  <b>POBJ_LIST_INSERT_BEFORE</b>(),
       <b>POBJ_LIST_INSERT_NEW_HEAD</b>(),   <b>POBJ_LIST_INSERT_NEW_TAIL</b>(),  <b>POBJ_LIST_INSERT_NEW_AFTER</b>(),  <b>POBJ_LIST_IN‐</b>
       <b>SERT_NEW_BEFORE</b>(),

       <b>POBJ_LIST_REMOVE</b>(), <b>POBJ_LIST_REMOVE_FREE</b>(),

       <b>POBJ_LIST_MOVE_ELEMENT_HEAD</b>(),       <b>POBJ_LIST_MOVE_ELEMENT_TAIL</b>(),       <b>POBJ_LIST_MOVE_ELEMENT_AFTER</b>(),
       <b>POBJ_LIST_MOVE_ELEMENT_BEFORE</b>() - type-safe non-transactional persistent atomic lists

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;libpmemobj.h&gt;

              POBJ_LIST_HEAD(HEADNAME, TYPE)
              POBJ_LIST_ENTRY(TYPE)
              POBJ_LIST_FIRST(POBJ_LIST_HEAD *head)
              POBJ_LIST_LAST(POBJ_LIST_HEAD *head, POBJ_LIST_ENTRY FIELD)
              POBJ_LIST_EMPTY(POBJ_LIST_HEAD *head)
              POBJ_LIST_NEXT(TOID elm, POBJ_LIST_ENTRY FIELD)
              POBJ_LIST_PREV(TOID elm, POBJ_LIST_ENTRY FIELD)

              POBJ_LIST_FOREACH(TOID var, POBJ_LIST_HEAD *head, POBJ_LIST_ENTRY FIELD)
              POBJ_LIST_FOREACH_REVERSE(TOID var, POBJ_LIST_HEAD *head, POBJ_LIST_ENTRY FIELD)

              POBJ_LIST_INSERT_HEAD(PMEMobjpool *pop, POBJ_LIST_HEAD *head,
                  TOID elm, POBJ_LIST_ENTRY FIELD)
              POBJ_LIST_INSERT_TAIL(PMEMobjpool *pop, POBJ_LIST_HEAD *head,
                  TOID elm, POBJ_LIST_ENTRY FIELD)
              POBJ_LIST_INSERT_AFTER(PMEMobjpool *pop, POBJ_LIST_HEAD *head,
                  TOID listelm, TOID elm, POBJ_LIST_ENTRY FIELD)
              POBJ_LIST_INSERT_BEFORE(PMEMobjpool *pop, POBJ_LIST_HEAD *head,
                  TOID listelm, TOID elm, POBJ_LIST_ENTRY FIELD)
              POBJ_LIST_INSERT_NEW_HEAD(PMEMobjpool *pop, POBJ_LIST_HEAD *head,
                  POBJ_LIST_ENTRY FIELD, size_t size,
                  pmemobj_constr constructor, void *arg)
              POBJ_LIST_INSERT_NEW_TAIL(PMEMobjpool *pop, POBJ_LIST_HEAD *head,
                  POBJ_LIST_ENTRY FIELD, size_t size,
                  pmemobj_constr constructor, void *arg)
              POBJ_LIST_INSERT_NEW_AFTER(PMEMobjpool *pop, POBJ_LIST_HEAD *head,
                  TOID listelm, POBJ_LIST_ENTRY FIELD, size_t size,
                  pmemobj_constr constructor, void *arg)
              POBJ_LIST_INSERT_NEW_BEFORE(PMEMobjpool *pop, POBJ_LIST_HEAD *head,
                  TOID listelm, POBJ_LIST_ENTRY FIELD, size_t size,
                  pmemobj_constr constructor, void *arg)

              POBJ_LIST_REMOVE(PMEMobjpool *pop, POBJ_LIST_HEAD *head,
                  TOID elm, POBJ_LIST_ENTRY FIELD)
              POBJ_LIST_REMOVE_FREE(PMEMobjpool *pop, POBJ_LIST_HEAD *head,
                  TOID elm, POBJ_LIST_ENTRY FIELD)

              POBJ_LIST_MOVE_ELEMENT_HEAD(PMEMobjpool *pop, POBJ_LIST_HEAD *head,
                  POBJ_LIST_HEAD *head_new, TOID elm, POBJ_LIST_ENTRY FIELD,
                  POBJ_LIST_ENTRY field_new)
              POBJ_LIST_MOVE_ELEMENT_TAIL(PMEMobjpool *pop, POBJ_LIST_HEAD *head,
                  POBJ_LIST_HEAD *head_new, TOID elm, POBJ_LIST_ENTRY FIELD,
                  POBJ_LIST_ENTRY field_new)
              POBJ_LIST_MOVE_ELEMENT_AFTER(PMEMobjpool *pop, POBJ_LIST_HEAD *head,
                  POBJ_LIST_HEAD *head_new, TOID listelm, TOID elm,
                  POBJ_LIST_ENTRY FIELD, POBJ_LIST_ENTRY field_new)
              POBJ_LIST_MOVE_ELEMENT_BEFORE(PMEMobjpool *pop, POBJ_LIST_HEAD *head,
                  POBJ_LIST_HEAD *head_new, TOID listelm, TOID elm,
                  POBJ_LIST_ENTRY FIELD, POBJ_LIST_ENTRY field_new)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The following macros define and operate on a type-safe persistent atomic circular doubly linked list data
       structure  that  consist  of  a set of persistent objects of a well-known type.  Unlike the functions de‐
       scribed in the previous section, these macros provide type enforcement by requiring declaration  of  type
       of the objects stored in given list, and not allowing mixing objects of different types in a single list.

       The functionality and semantics of those macros is similar to circular queues defined in <b><a href="../man3/queue.3.html">queue</a></b>(3).

       The  majority  of  the macros must specify the handle to the memory pool <u>pop</u> and the name of the <u>field</u> in
       the user-defined structure, which must be of type <u>POBJ_LIST_ENTRY</u> and is used to connect the elements  in
       the list.

       A list is headed by a structure defined by the <b>POBJ_LIST_HEAD</b>() macro.  This structure contains an object
       handle of the first element on the list.  The elements are doubly linked so that an arbitrary element can
       be removed without a need to traverse the list.  New elements can be added to the list before or after an
       existing  element, at the head of the list, or at the end of the list.  A list may be traversed in either
       direction.  A <u>POBJ_LIST_HEAD</u> structure is declared as follows:

              #define POBJ_LIST_HEAD(HEADNAME, TYPE)
              struct HEADNAME
              {
                  TOID(TYPE) pe_first;
                  PMEMmutex lock;
              };

       In the macro definitions, <u>TYPE</u> is the name of a user-defined structure, that must contain a field of type
       <u>POBJ_LIST_ENTRY</u>.  The argument <u>HEADNAME</u> is the name of a user-defined structure that must be declared us‐
       ing the macro <u>POBJ_LIST_HEAD</u>.  See the examples below for further explanation of  how  these  macros  are
       used.

       The macro <u>POBJ_LIST_ENTRY</u> declares a structure that connects the elements in the list.

              #define POBJ_LIST_ENTRY(TYPE)
              struct
              {
                  TOID(TYPE) pe_next;
                  TOID(TYPE) pe_prev;
              };

       The  macro  <b>POBJ_LIST_FIRST</b>()  returns  the first element on the list referenced by <u>head</u>.  If the list is
       empty <b>OID_NULL</b> is returned.

       The macro <b>POBJ_LIST_LAST</b>() returns the last element on the list referenced by <u>head</u>.  If the list is empty
       <b>OID_NULL</b> is returned.

       The macro <b>POBJ_LIST_EMPTY</b>() evaluates to 1 if the list referenced by <u>head</u> is empty.  Otherwise, 0 is  re‐
       turned.

       The macro <b>POBJ_LIST_NEXT</b>() returns the element next to the element <u>elm</u>.

       The macro <b>POBJ_LIST_PREV</b>() returns the element preceding the element <u>elm</u>.

       The macro <b>POBJ_LIST_FOREACH</b>() traverses the list referenced by <u>head</u> assigning a handle to each element in
       turn to <u>var</u> variable.

       The macro <b>POBJ_LIST_FOREACH_REVERSE</b>() traverses the list referenced by <u>head</u> in reverse order, assigning a
       handle  to  each  element  in  turn to <u>var</u> variable.  The <u>field</u> argument is the name of the field of type
       <u>POBJ_LIST_ENTRY</u> in the element structure.

       The macro <b>POBJ_LIST_INSERT_HEAD</b>() inserts the element <u>elm</u> at the head of the list referenced by <u>head</u>.

       The macro <b>POBJ_LIST_INSERT_TAIL</b>() inserts the element <u>elm</u> at the end of the list referenced by <u>head</u>.

       The macro <b>POBJ_LIST_INSERT_AFTER</b>() inserts the element <u>elm</u> into the list referenced by <u>head</u> after the el‐
       ement <u>listelm</u>.  If <u>listelm</u> value is <b>TOID_NULL</b>, the object is inserted at the end of the list.

       The macro <b>POBJ_LIST_INSERT_BEFORE</b>() inserts the element <u>elm</u> into the list referenced by <u>head</u>  before  the
       element <u>listelm</u>.  If <u>listelm</u> value is <b>TOID_NULL</b>, the object is inserted at the head of the list.

       The  macro  <b>POBJ_LIST_INSERT_NEW_HEAD</b>()  atomically allocates a new object of size <u>size</u> and inserts it at
       the head of the list referenced by <u>head</u>.  The newly allocated object is also added to the internal object
       container associated with a type number which is retrieved from the typed <u>OID</u> of  the  first  element  on
       list.

       The  macro  <b>POBJ_LIST_INSERT_NEW_TAIL</b>()  atomically allocates a new object of size <u>size</u> and inserts it at
       the tail of the list referenced by <u>head</u>.  The newly allocated object is also added to the internal object
       container associated with a type number which is retrieved from the typed <u>OID</u> of  the  first  element  on
       list.

       The macro <b>POBJ_LIST_INSERT_NEW_AFTER</b>() atomically allocates a new object of size <u>size</u> and inserts it into
       the  list referenced by <u>head</u> after the element <u>listelm</u>.  If <u>listelm</u> value is <b>TOID_NULL</b>, the object is in‐
       serted at the end of the list.  The newly allocated object is also added to the internal object container
       associated with with a type number which is retrieved from the typed <u>OID</u> of the first element on list.

       The macro <b>POBJ_LIST_INSERT_NEW_BEFORE</b>() atomically allocates a new object of size <u>size</u> and inserts it in‐
       to the list referenced by <u>head</u> before the element <u>listelm</u>.  If <u>listelm</u> value is <b>TOID_NULL</b>, the object  is
       inserted  at  the head of the list.  The newly allocated object is also added to the internal object con‐
       tainer associated with with a type number which is retrieved from the typed <u>OID</u> of the first  element  on
       list.

       The macro <b>POBJ_LIST_REMOVE</b>() removes the element <u>elm</u> from the list referenced by <u>head</u>.

       The  macro <b>POBJ_LIST_REMOVE_FREE</b>() removes the element <u>elm</u> from the list referenced by <u>head</u> and frees the
       memory space represented by this element.

       The macro <b>POBJ_LIST_MOVE_ELEMENT_HEAD</b>() moves the element <u>elm</u> from the list referenced  by  <u>head</u>  to  the
       head  of  the  list  <u>head_new</u>.   The  <u>field</u>  and  <u>field_new</u> arguments are the names of the fields of type
       <u>POBJ_LIST_ENTRY</u> in the element structure that are used to connect the elements in both lists.

       The macro <b>POBJ_LIST_MOVE_ELEMENT_TAIL</b>() moves the element <u>elm</u> from the list referenced by <u>head</u> to the end
       of the list <u>head_new</u>.   The  <u>field</u>  and  <u>field_new</u>  arguments  are  the  names  of  the  fields  of  type
       <u>POBJ_LIST_ENTRY</u> in the element structure that are used to connect the elements in both lists.

       The  macro  <b>POBJ_LIST_MOVE_ELEMENT_AFTER</b>() atomically removes the element <u>elm</u> from the list referenced by
       <u>head</u> and inserts it into the list referenced by <u>head_new</u> after the element <u>listelm</u>.  If <u>listelm</u> value  is
       <u>TOID_NULL</u>,  the  object  is  inserted  at the end of the list.  The <u>field</u> and <u>field_new</u> arguments are the
       names of the fields of type <u>POBJ_LIST_ENTRY</u> in the element structure that are used to  connect  the  ele‐
       ments in both lists.

       The  macro <b>POBJ_LIST_MOVE_ELEMENT_BEFORE</b>() atomically removes the element <u>elm</u> from the list referenced by
       <u>head</u> and inserts it into the list referenced by <u>head_new</u> before the element <u>listelm</u>.  If <u>listelm</u> value is
       <b>TOID_NULL</b>, the object is inserted at the head of the list.  The <u>field</u> and  <u>field_new</u>  arguments  are  the
       names  of  the  fields of type <u>POBJ_LIST_ENTRY</u> in the element structure that are used to connect the ele‐
       ments in both lists.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/queue.3.html">queue</a></b>(3), <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) and <b>&lt;https://pmem.io&gt;</b>
</pre>
 </div>
</div></section>
</div>
</body>
</html>