<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mem_sections - Memory Sections</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/avr-libc">avr-libc_2.2.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mem_sections - Memory Sections

       Section are used to organize code and data of a program on the binary level.

       The (compiler-generated) assembly code assigns code, data and other entities like debug information to so
       called input sections. These sections serve as input to the linker, which bundles similar sections
       together to output sections like .text and .data according to rules defined in the linker description
       file.

       The final ELF binary is then used by programming tools like avrdude, simulators, debuggers and other
       programs, for example programs from the GNU Binutils family like avr-size, avr-objdump and avr-readelf.

       Sections may have extra properties like <b>section</b> <b>alignment</b>, <b>section</b> <b>flags</b>, <b>section</b> <b>type</b> and rules to
       locate them or to assign them to <b>memory</b> <b>regions</b>.

       • <b>Concepts</b>

         • <b>Named</b> <b>Sections</b>

           • <b>Section</b> <b>Flags</b>

           • <b>Section</b> <b>Type</b>

           • <b>Section</b> <b>Alignment</b>

           • <b>Subsections</b>

         • <b>Orphan</b> <b>Sections</b>

         • <b>LMA:</b> <b>Load</b> <b>Memory</b> <b>Address</b>

         • <b>VMA:</b> <b>Virtual</b> <b>Memory</b> <b>Address</b>

       • <b>The</b> <b>Linker</b> <b>Script:</b> <b>Building</b> <b>Blocks</b>

         • <b>Input</b> <b>Sections</b> <b>and</b> <b>Output</b> <b>Sections</b>

         • <b>Memory</b> <b>Regions</b>

       • <b>Output</b> <b>Sections</b> <b>of</b> <b>the</b> <b>Default</b> <b>Linker</b> <b>Script</b>

         • <b>.text</b>

         • <b>.data</b>

         • <b>.bss</b>

         • <b>.noinit</b>

         • <b>.rodata</b>

         • <b>.eeprom</b>

         • <b>.fuse,</b> <b>.lock</b> <b>and</b> <b>.signature</b>

         • <b>.note.gnu.avr.deviceinfo</b>

       • <b>Symbols</b> <b>in</b> <b>the</b> <b>Default</b> <b>Linker</b> <b>Script</b>

       • <b>Output</b> <b>Sections</b> <b>and</b> <b>Code</b> <b>Size</b>

       • <b>Using</b> <b>Sections</b>

         • <b>In</b> <b>C/C++</b> <b>Code</b>

         • <b>In</b> <b>Assembly</b> <b>Code</b>

</pre><h4><b>Concepts</b></h4><pre>
   <b>Named</b> <b>Sections</b>
       <u>Named</u>  <u>sections</u>  are sections that can be referred to by their name. The name and other properties can be
       provided with the .section directive like in

       .section name, "flags", @type

        or with the .pushsection directive, which directs the assembler to assemble the following code into  the
       named section.

       An  example  of  a  section that is not referred to by its name is the COMMON section. In order to put an
       object in that section, special directives like .comm name,size or .lcomm name,size have to be used.

       Directives like .text are basically the same like .section .text, where the assembler assumes appropriate
       section flags and type; same for directives .data and .bss.

   <b>Section</b> <b>Flags</b>
       The <u>section</u> <u>flags</u> can be specified with the .section and .pushsection directives, see <b>section</b> <b>type</b> for an
       example. Section flags of output sections can be specified in the linker description file, and the linker
       implements heuristics to determine the section flags of output sections from the  various  input  section
       that go into it.

       Flag  Meaning   a  The  section  will  be <b>a</b>llocated, i.e. it occupies space on the target hardware  w The
       section contains data that can be <b>w</b>ritten at run-time. Sections  that  only  contain  read-only  entities
       don't  have  the  w flag set  x The section contains e<b>x</b>ecutable code, though the section may also contain
       non-executable objects  M A <b>m</b>ergeable section  S A <b>s</b>tring section  G A  section  <b>g</b>roup,  like  used  with
       comdat objects

       The  last three flags are listed for completeness. They are used by the compiler, for example for header-
       only C++ modules and to ensure that multiplle instanciations of the same template in different compilaton
       units does occur at most once in the executable file.

   <b>Section</b> <b>Type</b>
       The <u>section</u> <u>type</u> can be specified with the .section and .pushsection directives, like in

       .section .text.myfunc,"ax",@progbits
       .pushsection ".data.myvar", "a", "progbits"

        On ELF level, the section type is stored in the section header like Elf32_Shdr.sh_type = SHT_PROGBITS.

       Type Meaning  @progbits The section contains data that will be loaded to the target, like objects in  the
       .text  and .data sections.  @nobits The section does not contain data that needs to be transferred to the
       target device, like data in the .bss and .noinit sections.  The  section  still  occupies  space  on  the
       target.  @note The section is a note, like for example the <b>.note.gnu.avr.deviceinfo</b> section.

   <b>Section</b> <b>Alignment</b>
       The <u>alignment</u> of a section is the maximum over the alignments of the objects in the section.

   <b>Subsections</b>
       <u>Subsections</u>  are  compartments  of  named  sections  and  are  introduced with the <b>.subsection</b> <b>directive.</b>
       <b>Subsections</b> <b>are</b> <b>located</b> <b>in</b> <b>order</b> <b>of</b> <b>increasing</b> <b>index</b> <b>in</b> <b>their</b> <b>input</b> <b>section.</b> <b>The</b> <b>default</b> <b>subsection</b> <b>after</b>
       <b>switching</b> <b>to</b> <b>a</b> <b>new</b> <b>section</b> <b>is</b> <b>subsection</b> <b>0.</b>

       <b>Note</b>
           A common misconception is that a section like .text.module.func were a  subsection  of  .text.module.
           This  is  not  the  case.  These  two  sections are independent, and there is no subset relation. The
           sections may have different flags and type, and they may be assigned to different output sections.

   <b>Orphan</b> <b>Sections</b>
       <u>Orphan</u> <u>sections</u> are sections that are not mentioned in the linker description file. When an input section
       is orphan, then the GNU linker implicitly generates an output  section  of  the  same  name.  The  linker
       implements  various  heuristics  to  determine  sections  flags,  section  type  and location of orphaned
       sections. One use of orphan sections is to <b>locate</b> <b>code</b> <b>to</b> <b>a</b> <b>fixed</b> <b>address</b>.

       Like for any other output section,  the  start  address  can  be  specified  by  means  of  linking  with
       -Wl,--section-start,<u>secname</u>=<u>address</u>

   <b>LMA:</b> <b>Load</b> <b>Memory</b> <b>Address</b>
       The  LMA of an object is the address where a loader like avrdude puts the object when the binary is being
       uploaded to the target device.

   <b>VMA:</b> <b>Virtual</b> <b>Memory</b> <b>Address</b>
       The VMA is the address of an object as used by the running program.

       VMA and LMA may be different: Suppose a small ATmega8 program with executable code that extends from byte
       address 0x0 to 0x20f, and one variable my_var in static strorage. The  default  linker  script  puts  the
       content of the .data output section after the .text output section and into the text <b>segment</b>. The startup
       code  then  copies  my_data  from  its  LMA  location beginning at 0x210 to its VMA location beginning at
       0x800060, because C/C++ requires that all data in static storage must have been initialized when main  is
       entered.

       The  internal  SRAM  of  ATmega8  starts  at  RAM  address  0x60, which is offset by 0x800000 in order to
       linearize the address space (VMA 0x60 is a flash address). The AVR program only ever uses  the  lower  16
       bits  of  VMAs  in  static  storage  so  that  the  offset  of 0x800000 is masked out. But code like 'LDI
       r24,<a href="../manmy_data/hh8.my_data.html">hh8</a>(my_data)' actually sets R24 to 0x80 and reveals that my_data is an object located in RAM.

</pre><h4><b>The</b> <b>Linker</b> <b>Script:</b> <b>Building</b> <b>Blocks</b></h4><pre>
       The linker description file is the central hub to channel functions  and  static  storage  objects  of  a
       program to the various memory spaces and address ranges of a device.

   <b>Input</b> <b>Sections</b> <b>and</b> <b>Output</b> <b>Sections</b>
       <u>Input</u>  <u>sections</u>  are  sections  that  are  inputs  to the linker. Functions and static variables but also
       additional notes and debug information are assigned to different input sections  by  means  of  <b>assembler</b>
       <b>directives</b>  like  .section  or  .text.  The  linker  takes  all these sections and assigns them to output
       sections as specified in the linker script.

       <u>Output</u> <u>sections</u> are defind in the linker description file. Contrary to  the  unlimited  number  of  input
       sections  a  program  can come up with, there is only a handfull of output sections like .text and .data,
       that roughly correspond to the memory spaces of the target device.

       One step in the final link is to <u>locate</u> the sections, that is  the  linker/locator  determines  at  which
       memory  location  to  put  the  output  sections, and how to arrange the many input sections within their
       assigned output section. <u>Locating</u> means that the linker assigns <b>Load</b> <b>Memory</b> <b>Addresses</b>  ---  addresses  as
       used  by  a  loader like avrdude --- and <b>Virtual</b> <b>Memory</b> <b>Addresses</b>, which are the addresses as used by the
       running program.

       While it is possible to directly assign LMAs and VMAs to  output  sections  in  the  linker  script,  the
       default  linker  scripts  provided by Binutils assign <u>memory</u> <u>regions</u> (aka. <u>memory</u> <u>segments</u>) to the output
       sections. This has some advantages like a linker script that is easier to maintain.  An  output  sections
       can be assigned to more than one memory region. For example, non-zero data in static storage (.data) goes
       to

       1.  the data region (VMA), because such variables occupy RAM which has to be allocated

       2.  the  text  region  (LMA),  because the initializers for such data has to be kept in some non-volatile
           memory (program ROM), so that the startup code can initialize that data so that  the  variables  have
           their expected initial values when main() is entered.

       The SECTIONS{} portion of a linker script models the input and output section, and it assignes the output
       section to the memory regions defined in the MEMORY{} part.

   <b>Memory</b> <b>Regions</b>
       The  <u>memory</u>  <u>regions</u>  defined in the default linker script model and correspond to the different kinds of
       memories of a device.

       Region Virtual
       Address1  Flags Purpose  text 02  rx <b>Executable</b> <b>code</b>, <b>vector</b> <b>table</b>, data in <b>PROGMEM</b>, __flash and  __memx,
       <b>startup</b>  <b>code</b>,  <b>linker</b>  <b>stubs</b>, initializers for .data  data 0x8000002  rw Data in static storage  rodata3
       0xa000002  r Read-only data in static storage  eeprom 0x810000 rw EEPROM  data   fuse  0x820000  rw  Fuse
       bytes   lock  0x830000 rw Lock bytes  signature 0x840000 rw Device signature  user_signatures 0x850000 rw
       User signature

       Notes

       1.  The <b>VMA</b>s for regions other than text are offset in order to linearize the non-linear  memory  address
           space of the AVR Harvard architecture. The target code only ever uses the lower 16 bits of the VMA to
           access objects in non-text regions.

       2.  The   addresses   for   regions   text,  data  and  rodata  are  actually  defined  as  symbols  like
           __TEXT_REGION_ORIGIN__,    so    that    they    can    be    adjusted    by    means     of,     say
           -Wl,--defsym,__DATA_REGION_ORIGIN__=0x800060.  Same applies for the lengths of all the regions, which
           is __<u>NAME</u>_REGION_LENGTH__ <u>for</u> <u>region</u> <u>name.</u>

       3.  The rodata region is only present in the avrxmega2_flmap and avrxmega4_flmap emulations, which is the
           case for Binutils since v2.42 for the AVR64 and AVR128 devices without -mrodata-in-ram.

</pre><h4><b>Output</b> <b>Sections</b> <b>of</b> <b>the</b> <b>Default</b> <b>Linker</b> <b>Script</b></h4><pre>
       This section describes the various <b>output</b> <b>sections</b> defined in the default linker description files.

       Output Purpose Memory Region  Section LMA VMA  <b>.text</b> <b>Executable</b> <b>code,</b> <b>data</b> <b>in</b> <b>progmem</b>  <b>text</b>  <b>text</b>   <b>.data</b>
       <b>Non-zero</b>  <b>data</b>  <b>in</b>  <b>static</b>  <b>storage</b>  <b>text</b>  <b>data</b>   <b>.bss</b> <b>Zero</b> <b>data</b> <b>in</b> <b>static</b> <b>storage</b> <b>---</b> <b>data</b>  <b>.noinit</b> <b>Non-</b>
       <b>initialized</b> <b>data</b> <b>in</b> <b>static</b> <b>storage</b> <b>---</b> <b>data</b>  <b>.rodata1</b>  <b>Read-only</b>  <b>data</b>  <b>in</b>  <b>static</b>  <b>storage</b>  <b>text</b>  <b>LMA</b>  <b>+</b>
       <b>offset3</b>    <b>.rodata2</b>   <b>Read-only</b>  <b>data</b> <b>in</b> <b>static</b> <b>storage</b> <b>0x8000</b> <b>*</b> <b>__flmap4</b>  <b>rodata</b>  <b>.eeprom</b> <b>Data</b> <b>in</b> <b>EEPROM</b>
       <b>Note5</b>  <b>eeprom</b>  <b>.fuse</b> <b>Fuse</b> <b>bytes</b> <b>fuse</b>  <b>.lock</b> <b>Lock</b> <b>bytes</b> <b>lock</b>  <b>.signature</b> <b>Signature</b> <b>bytes</b>  <b>signature</b>   <b>User</b>
       <b>signature</b> <b>bytes</b> <b>user_signatures</b>

       Notes

       1.  On avrxmega3 and avrtiny devices.

       2.  On AVR64 and AVR128 devices without -mrodata-in-ram.

       3.  With an offset __RODATA_PM_OFFSET__ of 0x4000 or 0x8000 depending on the device.

       4.  The  value  of  symbol  __flmap  defaults to the last 32 KiB block of program memory, see the GCC v14
           release notes.

       5.  The <b>LMA</b> actually equals the <b>VMA</b>, but is unused. The flash loader like avrdude knows where to put  the
           data,

   <b>The</b> <b>.text</b> <b>Output</b> <b>Section</b>
       The  .text  output  section  contains the actual machine instructions which make up the program, but also
       additional code like jump tables and lookup tables placed in program memory with the <b>PROGMEM</b> attribute.

       The .text output section contains the input sections described below. Input sections that are not used by
       the tools are omitted. A <b>*</b> <b>wildcard</b> <b>stands</b> <b>for</b> <b>any</b> <b>sequence</b> <b>of</b> <b>characters,</b> <b>including</b> <b>empty</b> <b>ones,</b> <b>that</b> <b>are</b>
       <b>valid</b> <b>in</b> <b>a</b> <b>section</b> <b>name.</b>

       <b>.vectors</b>
           The .vectors sections contains the interrupt vector table which consists of jumps to  <b>weak</b>ly  defined
           labels:  To __init for the first entry at index 0, and to __vector_<u>N</u> <u>for</u> <u>the</u> <u>entry</u> <u>at</u> <u>index</u> <u>N</u>  <u>1.</u> <u>The</u>
           <u>default</u> <u>value</u> <u>for</u> <b>__</b><u>vector_N</u> <u>is</u> <b>__</b><u>bad_interrupt,</u> <u>which</u>  <u>jumps</u>  <u>to</u>  <u>weakly</u>  <u>defined</u>  <b>__</b><u>vector_default,</u>
           <u>which</u> <u>jumps</u> <u>to</u> <b>__</b><u>vectors,</u> <u>which</u> <u>is</u> <u>the</u> <u>start</u> <u>of</u> <u>the</u> <u>.vectors</u> <u>section.</u>

       Implementing  an  interrupt  service  ruotine  (ISR) is performed with the help of the <b>ISR</b> <b>macro</b> <b>in</b> <b>C/C++</b>
       <b>code.</b>

       <b>.progmem.data</b>

       <b>.progmem.data.*</b>

       <b>.progmem.gcc.*</b>
           This section is used for read-only data declared with attribute <b>PROGMEM</b>, and  for  data  in  address-
           space __flash.

       The compiler assumes that the .progmem sectons are located in the lower 64 KiB of program memory. When it
       does  not fit in the lower 64 KiB block, then the program reads garbage except <b>pgm_read_*_far</b> is used. In
       that case however, code can be located in the <b>.progmemx</b> section which does not require to be  located  in
       the lower program memory.

       <b>.trampolines</b>
           Linker  stubs  for indirect jumps and calls on devices with more than 128 KiB of program memory. This
           section must be located in the same  128  KiB  block  like  the  interrupt  vector  table.  For  some
           background on linker stubs, see the GCC documentation on EIND.

       <b>.text</b>

       <b>.text.*</b>
           Executable code. This is where almost all of the executable code of an application will go.

       <b>.ctors</b>

       <b>.dtors</b>
           Tables  with  addresses  of  static  constructors  and  destructors, like C++ static constructors and
           functions declared with attribute constructor.

       <b>The</b> <b>.init</b><u>N</u> <u>Sections</u>
           These sections are used to hold the startup code from reset up through the start of main().

       The .init<u>N</u> <u>sections</u> <u>are</u> <u>executed</u> <u>in</u> <u>order</u> <u>from</u> <u>0</u> <u>to</u> <u>9:</u> <u>The</u> <u>code</u> <u>from</u> <u>one</u> <u>init</u> <u>section</u>  <u>falls</u>  <u>through</u>  <u>to</u>
       <u>the</u>  <u>next</u>  <u>higher</u>  <u>init</u>  <u>section.</u>  <u>This</u>  <u>is</u> <u>the</u> <u>reason</u> <u>for</u> <u>why</u> <u>code</u> <u>in</u> <u>these</u> <u>sections</u> <u>must</u> <u>be</u> <u>naked</u> <u>(more</u>
       <u>precisely,</u> <u>it</u> <u>must</u> <u>not</u> <u>contain</u> <u>return</u> <u>instructions),</u> <u>and</u> <u>why</u> <u>code</u> <u>in</u> <u>these</u> <u>sections</u> <u>must</u> <u>never</u> <u>be</u>  <u>called</u>
       <u>explicitly.</u>

       When several modules put code in the same init section, the order of execuation is not specified.

       Section  Performs  Hosted By Symbol1   .init0 <b>Weak</b>ly defines the __init label which is the jump target of
       the first vector in the interrupt vector table. When the user defines the __init() function, it  will  be
       jumped to instead. AVR-LibC2  .init1 Unused ---  .init2

       • Clears <b>__zero_reg__</b>

       • Initializes  the stack pointer to the value of weak symbol __stack, which has a default value of RAMEND
         as defined in <b>avr/io.h</b>

       • Initializes EIND to hh8(pm(__vectors)) on devices that have it

       • Initializes RAMPX, RAMPY, RAMPZ and RAMPD on devices that have all of them

       AVR-LibC  .init3 Initializes the NVMCTRLB.FLMAP bit-field on devices that have it, except when  -mrodata-
       in-ram  is  specified  AVR-LibC  __do_flmap_init   .init4 Initializes data in static storage: Initializes
       <b>.data</b> <b>and</b> <b>clears</b> <b>.bss</b> <b>libgcc</b> <b>__do_copy_data</b>
       <b>__do_clear_bss</b>  <b>.init5</b> <b>Unused</b>  <b>---</b>  <b>.init6</b>  <b>Run</b>  <b>static</b>  <b>C++</b>  <b>constructors</b>  <b>and</b>  <b>functions</b>  <b>defined</b>  <b>with</b>
       <b>__attribute__((constructor)).</b> <b>libgcc</b> <b>__do_global_ctors</b>  <b>.init7</b> <b>Unused</b> <b>---</b> <b>.init8</b> <b>Unused</b> <b>---</b>  <b>.init9</b> <b>Calls</b>
       <b>main</b> <b>and</b> <b>then</b> <b>jumps</b> <b>to</b> <b>exit</b> <b>AVR-LibC</b>

       Notes

       1.  Code  in  the  .init3,  .init4 and .init6 sections is optional; it will only be present when there is
           something to do. This will be tracked by the compiler --- or  has  to  be  tracked  by  the  assembly
           programmer --- which pulls in the code from the respective library by means of the mentioned symbols,
           e.g. by linking with -Wl,-u,__do_flmap_init or by means of

       .global __do_copy_data

        Conversely,  when  the  respective  code  is not desired for some reason, the symbol can be satisfied by
       defining it with, say, -Wl,--defsym,__do_copy_data=0 so that the code is not pulled in any more.

       2.  The code is provided by gcrt1.S.

       <b>The</b> <b>.fini</b><u>N</u> <u>Sections</u>
           Shutdown code. These sections are used to hold the exit code executed after return from main()  or  a
           call to <b>exit()</b>.

       The .fini<u>N</u> <u>sections</u> <u>are</u> <u>executed</u> <u>in</u> <u>descending</u> <u>order</u> <u>from</u> <u>9</u> <u>to</u> <u>0</u> <u>in</u> <u>a</u> <u>fallthrough</u> <u>manner.</u>

       Section  Performs  Hosted By Symbol  .fini9 Defines _exit and weakly defines the <b>exit</b> <b>label</b> <b>libgcc</b> <b>.fini8</b>
       <b>Run</b> <b>functions</b> <b>registered</b> <b>with</b> <b>atexit()</b> <b>AVR-LibC</b>  <b>.fini7</b> <b>Unused</b> <b>---</b>  <b>.fini6</b> <b>Run</b> <b>static</b> <b>C++</b> <b>destructors</b> <b>and</b>
       <b>functions</b> <b>defined</b> <b>with</b> <b>__attribute__((destructor))</b> <b>libgcc</b> <b>__do_global_dtors</b>  <b>.fini5...1</b> <b>Unused</b> <b>---</b> <b>.fini0</b>
       <b>Globally</b> <b>disables</b> <b>interrupts</b> <b>and</b> <b>enters</b> <b>an</b> <b>infinite</b> <b>loop</b> <b>to</b> <b>label</b> <b>__stop_program</b> <b>libgcc</b>  <b>It</b>  <b>is</b>  <b>unlikely</b>
       <b>that</b> <b>ordinary</b> <b>code</b> <b>uses</b> <b>the</b> <b>fini</b> <b>sections.</b> <b>When</b> <b>there</b> <b>are</b> <b>no</b> <b>static</b> <b>destructors</b> <b>and</b> <b>atexit()</b> <b>is</b> <b>not</b> <b>used,</b>
       <b>then</b> <b>the</b> <b>respective</b> <b>code</b> <b>is</b> <b>not</b> <b>pulled</b> <b>in</b> <b>form</b> <b>the</b> <b>libraries,</b> <b>and</b> <b>the</b> <b>fini</b> <b>code</b> <b>just</b> <b>consumes</b> <b>four</b> <b>bytes:</b>
       <b>a</b>  <b>CLI</b>  <b>and</b>  <b>a</b>  <b>RJMP</b> <b>to</b> <b>itself.</b> <b>Common</b> <b>use</b> <b>cases</b> <b>of</b> <b>fini</b> <b>code</b> <b>is</b> <b>when</b> <b>running</b> <b>the</b> <b>GCC</b> <b>test</b> <b>suite</b> <b>where</b> <b>it</b>
       <b>reduces</b> <b>fallout,</b> <b>and</b> <b>in</b> <b>simulators</b> <b>to</b> <b>determine</b> <b>(un)orderly</b> <b>termination</b> <b>of</b> <b>a</b> <b>simulated</b> <b>program.</b>

       <b>.progmemx.*</b>
           Read-only data in program memory without the requirement that it must reside in the lower 64 KiB. The
           compiler uses this section for data in the named address-space __memx.  Data  can  be  accessed  with
           <b>pgm_read_*_far</b> when it is not in a named address-space:

       #include &lt;avr/pgmspace.h&gt;

       const __memx int array1[] = { 1, 4, 9, 16, 25, 36 };

       PROGMEM_FAR
       const int array2[] = { 2, 3, 5, 7, 11, 13, 17 };

       int add (uint8_t id1, uint8_t id2)
       {
           uint_farptr_t p_array2 = pgm_get_far_address (array2);
           int val2 = pgm_read_int_far (p_array2 + sizeof(int) * id2);

           return val2 + array1[id1];
       }

       <b>.jumptables*</b>
           Used to place jump tables in some cases.

   <b>The</b> <b>.data</b> <b>Output</b> <b>Section</b>
       This  section  contains  data  in  static  storage  which has an initializer that is not all zeroes. This
       includes the following input sections:

       <b>.data*</b>
           Read-write data

       <b>.rodata*</b>
           Read-only data. These input sections are only included on devices that host read-only data in RAM.

       It is possible to tell the linker the SRAM address of  the  beginning  of  the  .data  section.  This  is
       accomplished by linking with

       avr-gcc ... -Tdata addr -Wl,--defsym,__DATA_REGION_START__=addr

       Note  that  addr must be <b>offset</b> by adding 0x800000 the to real SRAM address so that the linker knows that
       the address is in the SRAM memory segment. Thus, if you want the .data section to start at  0x1100,  pass
       0x801100 as the address to the linker.

       <b>Note</b>
           When  using  malloc()  in  the application (which could even happen inside library calls), <b>additional</b>
           <b>adjustments</b> are required.

   <b>The</b> <b>.bss</b> <b>Output</b> <b>Section</b>
       Data in static storage that will be zeroed by the startup code. This are data  objects  without  explicit
       initializer, and data objects with initializers that are all zeroes.

       Input sections are .bss* and COMMON. Common symbols are defined with directives .comm or .lcomm.

   <b>The</b> <b>.noinit</b> <b>Output</b> <b>Section</b>
       Data  objects in static storage that should not be initialized by the startup code. As the C/C++ standard
       requires that <u>all</u> data in static  storage  is  initialized  ---  which  includes  data  without  explicit
       initializer, which will be initialized to all zeroes --- such objects have to be put into section .noinit
       by hand:

       __attribute__ ((section (".noinit")))
       int foo;

        The  only  input  section in this output section is .noinit. Only data without initializer can be put in
       this section.

   <b>The</b> <b>.rodata</b> <b>Output</b> <b>Section</b>
       This section contains read-only data in static storage from .rodata* input sections. This output  section
       is  only  present for devices where read-only data remains in program memory, which are the devices where
       (parts of) the program memory are visible in the RAM address space. This is currently the  case  for  the
       emulations avrtiny, avrxmega3, avrxmega2_flmap and avrxmega4_flmap.

   <b>The</b> <b>.eeprom</b> <b>Output</b> <b>Section</b>
       This  is  where EEPROM variables are stored, for example variables declared with the <b>EEMEM</b> <b>attribute.</b> <b>The</b>
       <b>only</b> <b>input</b> <b>section</b> <b>(pattern)</b> <b>is</b> <b>.eeprom*.</b>

   <b>The</b> <b>.fuse,</b> <b>.lock</b> <b>and</b> <b>.signature</b> <b>Output</b> <b>Sections</b>
       These sections contain fuse bytes, lock bytes and device signature bytes,  respectively.  The  respective
       input section patterns are .fuse* .lock* and .signature*.

   <b>The</b> <b>.note.gnu.avr.deviceinfo</b> <b>Section</b>
       This  section is actually <u>not</u> <u>mentioned</u> in the default linker script, which means it is an <b>orphan</b> <b>section</b>
       and hence the respective output section is implicit.

       The startup code from AVR-LibC puts device information in that section to be picked up by  simulators  or
       tools like avr-size, avr-objdump, avr-readelf, etc,

       The  section  is  contained in the ELF file but not loaded onto the target. Source of the device specific
       information are the device header file and compiler builtin macros. The layout conforms to  the  standard
       ELF note section layout and is laid out as follows.

       #include &lt;<a href="file:/usr/include/elf.h">elf.h</a>&gt;

       typedef struct
       {
           Elf32_Word n_namesz;     /* AVR_NOTE_NAME_LEN */
           Elf32_Word n_descsz;     /* size of avr_desc */
           Elf32_Word n_type;       /* 1 - the only AVR note type */
       } Elf32_Nhdr;

       #define AVR_NOTE_NAME_LEN 4

       struct note_gnu_avr_deviceinfo
       {
           Elf32_Nhdr nhdr;
           char note_name[AVR_NOTE_NAME_LEN]; /* = "AVR\0" */

           struct
           {
               Elf32_Word flash_start;
               Elf32_Word flash_size;
               Elf32_Word sram_start;
               Elf32_Word sram_size;
               Elf32_Word eeprom_start;
               Elf32_Word eeprom_size;
               Elf32_Word offset_table_size;
               /* Offset table containing byte offsets into
                  string table that immediately follows it.
                  index 0: Device name byte offset */
               Elf32_Off offset_table[1];
               /* Standard ELF string table.
                  index 0 : NULL
                  index 1 : Device name
                  index 2 : NULL */
               char strtab[2 + strlen(__AVR_DEVICE_NAME__)];
           } avr_desc;
       };

       The contents of this section can be displayed with

       • avr-objdump -P avr-deviceinfo <u>file,</u> <u>which</u> <u>is</u> <u>supported</u> <u>since</u> <u>Binutils</u> <u>v2.43.</u>

       • avr-readelf -n <u>file,</u> <u>which</u> <u>displays</u> <u>all</u> <u>notes.</u>

</pre><h4><b>Symbols</b> <b>in</b> <b>the</b> <b>Default</b> <b>Linker</b> <b>Script</b></h4><pre>
       Most of the symbols like main are defined in the code of the application, but some symbols are defined in
       the default linker script:

       <b>__</b><u>name</u><b>_REGION_ORIGIN__</b>
           Describes  the  physical  properties  of  memory  region <u>name,</u> <u>where</u> <u>name</u> <u>is</u> <u>one</u> <u>of</u> <u>TEXT</u> <u>or</u> <u>DATA.</u> <u>The</u>
           <u>address</u> <u>is</u> <u>a</u> <u>VMA</u> <u>and</u> <u>offset</u> <u>at</u> <u>explained</u> <u>above.</u>
            <u>The</u> <u>linker</u> <u>script</u> <u>only</u> <u>supplies</u> <u>a</u> <u>default</u> <u>for</u> <u>the</u> <u>symbol</u> <u>values</u> <u>when</u> <u>they</u> <u>have</u> <u>not</u> <u>been</u>  <u>defined</u>  <u>by</u>
           <u>other</u>  <u>means,</u> <u>like</u> <u>for</u> <u>example</u> <u>in</u> <u>the</u> <u>startup</u> <u>code</u> <u>or</u> <u>by</u> <b>--defsym.</b> <b>For</b> <b>example,</b> <b>to</b> <b>let</b> <b>the</b> <b>code</b> <b>start</b>
           <b>at</b> <b>address</b> <b>0x100,</b> <b>one</b> <b>can</b> <b>link</b> <b>with</b>

       avr-gcc ... -Ttext=0x100 -Wl,--defsym,__TEXT_REGION_ORIGIN__=0x100

       <b>__</b><u>name</u><b>_REGION_LENGTH__</b>
           Describes the physical properties of memory region <u>name,</u> <u>where</u> <u>name</u> <u>is</u> <u>one</u> <u>of:</u>  <u>TEXT,</u>  <u>DATA,</u>  <u>EEPROM,</u>
           <u>LOCK,</u> <u>FUSE,</u> <u>SIGNATURE</u> <u>or</u> <u>USER_SIGNATURE.</u>
            <u>Only</u>  <u>a</u> <u>default</u> <u>is</u> <u>supplied</u> <u>when</u> <u>the</u> <u>symbol</u> <u>is</u> <u>not</u> <u>yet</u> <u>defined</u> <u>by</u> <u>other</u> <u>means.</u> <u>Most</u> <u>of</u> <u>these</u> <u>symbols</u>
           <u>are</u> <b>weakly</b> <u>defined</u> <u>in</u> <u>the</u> <u>startup</u> <u>code.</u>

       <b>__data_start</b>

       <b>__data_end</b>
           Start and (one past the) end <b>VMA</b> address of the <b>.data</b> <b>section</b> <b>in</b> <b>RAM.</b>

       <b>__data_load_start</b>

       <b>__data_load_end</b>
           Start and (one past the) end <b>LMA</b> address of the <b>.data</b> <b>section</b> <b>initializers</b> <b>located</b> <b>in</b> <b>program</b> <b>memory.</b>
           <b>Used</b> <b>together</b> <b>with</b> <b>the</b> <b>VMA</b> <b>addresses</b> <b>above</b> <b>by</b> <b>the</b> <b>startup</b> <b>code</b> <b>to</b> <b>copy</b> <b>data</b> <b>initializers</b> <b>from</b> <b>program</b>
           <b>memory</b> <b>to</b> <b>RAM.</b>

       <b>__bss_start</b>

       <b>__bss_end</b>
           Start and (one past the) end VMA address of the <b>.bss</b> <b>section.</b> <b>The</b> <b>startup</b> <b>code</b> <b>clears</b>  <b>this</b>  <b>part</b>  <b>of</b>
           <b>the</b> <b>RAM.</b>

       <b>__rodata_start</b>

       <b>__rodata_end</b>

       <b>__rodata_load_start</b>

       <b>__rodata_load_end</b>
           Start  and  (one past the) end VMA resp. LMA address of the .rodata output section. These symbols are
           only defined when .rodata is not output to  the  text  region,  which  is  the  case  for  emulations
           avrxmega2_flmap and avrxmega4_flmap.

       <b>__heap_start</b>
           One  past  the  last object located in static storage. Immediately follows the <b>.noinit</b> <b>section</b> <b>(which</b>
           <b>immediately</b> <b>follows</b> <b>.bss,</b> <b>which</b> <b>immediately</b> <b>follows</b> <b>.data).</b> <b>Used</b> <b>by</b> <b>malloc()</b> <b>and</b> <b>friends.</b>

       Code that computes a checksum over all relevant code and data in program memory has to consider:

       • The range from the beginning  of  the  .text  section  (address  0x0  in  the  default  layout)  up  to
         __data_load_start.

       • For   emulations   that   have  the  rodata  <b>memory</b>  <b>region</b>,  the  range  from  __rodata_load_start  to
         __rodata_load_end has also to be taken into account.

</pre><h4><b>Output</b> <b>Sections</b> <b>and</b> <b>Code</b> <b>Size</b></h4><pre>
       The avr-size program (part of Binutils), coming from a Unix background, doesn't  account  for  the  <b>.data</b>
       <b>initialization</b>  <b>space</b>  <b>added</b>  <b>to</b>  <b>the</b> <b>.text</b> <b>section,</b> <b>so</b> <b>in</b> <b>order</b> <b>to</b> <b>know</b> <b>how</b> <b>much</b> <b>flash</b> <b>the</b> <b>final</b> <b>program</b>
       <b>will</b> <b>consume,</b> <b>one</b> <b>needs</b> <b>to</b> <b>add</b> <b>the</b> <b>values</b> <b>for</b> <b>both,</b> <b>.text</b> <b>and</b> <b>.data</b> <b>(but</b> <b>not</b> <b>.bss),</b> <b>while</b> <b>the</b>  <b>amount</b>  <b>of</b>
       <b>pre-allocated</b> <b>SRAM</b> <b>is</b> <b>the</b> <b>sum</b> <b>of</b> <b>.data</b> <b>and</b> <b>.bss.</b>

       Memory usage and free memory can also be displayed with

       avr-objdump -P mem-usage code.elf

</pre><h4><b>Using</b> <b>Sections</b></h4><pre>
   <b>In</b> <b>C/C++</b> <b>Code</b>
       The  following example shows how to read and reset the MCUCR special function register on ATmega328. This
       SFR holds to reset source like 'watchdog reset' or 'external reset', and should be read early,  prior  to
       the  initialization  of RAM and execution of static constructors which may take some time. This means the
       code has to be placed  prior  to  <b>.init4</b>  <b>which</b>  <b>initializes</b>  <b>static</b>  <b>storage,</b>  <b>but</b>  <b>after</b>  <b>.init2</b>  <b>which</b>
       <b>initializes</b>  <b>__zero_reg__.</b> <b>As</b> <b>the</b> <b>code</b> <b>runs</b> <b>prior</b> <b>to</b> <b>the</b> <b>initialization</b> <b>of</b> <b>static</b> <b>storage,</b> <b>variable</b> <b>mcucr</b>
       <b>must</b> <b>be</b> <b>placed</b> <b>in</b> <b>section</b> <b>.noinit</b> <b>so</b> <b>that</b> <b>it</b> <b>won't</b> <b>be</b> <b>overridden</b> <b>by</b> <b>that</b> <b>part</b> <b>of</b> <b>the</b> <b>startup</b> <b>code:</b>

       #include &lt;avr/io.h&gt;

       __attribute__((section(".noinit")))
       uint8_t mcucr;

       __attribute__((used, unused, naked, section(".init3")))
       static void read_MCUCR (void)
       {
           mcucr = MCUCR;
           MCUCR = 0;
       }

       • The used attribute tells the compiler that the function is used although it is never called.

       • The unused attribute tells the compiler that it is fine that  the  function  is  unused,  and  silences
         respective diagnostics about the seemingly unused functions.

       • The  naked  attribute is required because the code is located in an init section. The function <u>must</u> <u>not</u>
         <u>have</u> <u>a</u> <u>RET</u> <u>statement</u> <u>because</u> <u>the</u> <u>function</u> <u>is</u> <u>never</u> <u>called.</u> <u>According</u> <u>to</u> <u>the</u> <u>GCC</u> <u>documentation,</u> <u>the</u> <u>only</u>
         <u>code</u> <u>supported</u> <u>in</u> <u>naked</u> <u>functions</u> <u>is</u> <u>inline</u> <u>assembly,</u> <u>but</u> <u>the</u> <u>code</u> <u>above</u> <u>is</u> <u>simple</u> <u>enough</u> <u>so</u>  <u>that</u>  <u>GCC</u>
         <u>can</u> <u>deal</u> <u>with</u> <u>it.</u>

   <b>In</b> <b>Assembly</b> <b>Code</b>
       Example:

       #include &lt;avr/io.h&gt;

       .section .init3,"ax",@progbits
           lds     r0, MCUCR

       .pushsection .noinit,"a",@nobits
       mcucr:
           .type   mcucr, @object
           .size   mcucr, 1
           .space  1
       .popsection                     ; Proceed with .init3

           sts     mcucr, r0
           sts     MCUCR, __zero_reg__ ; Initialized in .init2

       .text
           .global main
           .type   main, @function
           lds     r24,    mcucr
           clr     r25
           rjmp    putchar
           .size main, .-main

       • The  'ax'  <b>flags</b>  tells that the sections is <b>a</b>llocatable (consumes space on the target hardware) and is
         e<b>x</b>ecutable.

       • The @progbits <b>type</b> tells that the section contains  bits  that  have  to  be  uploaded  to  the  target
         hardware.

       For more detais, see the see the gas user manual on the .section directive.

AVR-LibC                                          Version 2.2.1                               <u><a href="../man3avr/mem_sections.3avr.html">mem_sections</a></u>(3avr)
</pre>
 </div>
</div></section>
</div>
</body>
</html>