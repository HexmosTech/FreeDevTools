<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::Inline::Section - Implements a section of tests</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-inline-perl">libtest-inline-perl_2.214-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::Inline::Section - Implements a section of tests

</pre><h4><b>VERSION</b></h4><pre>
       version 2.214

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class implements a single section of tests. That is, a section of POD beginning with "=begin test"
       or "=begin testing".

   <b>Types</b> <b>of</b> <b>Sections</b>
       There are two types of code sections. The first, beginning with "=begin testing ...", contains a set of
       tests and other code to be executed at any time (within a set of specifyable constraints). The second,
       labelled "=begin testing SETUP", contains code to be executed at the beginning of the test script, before
       any of the other sections are executed. This allows any needed variables or environment to be set up
       before the tests are run.  You can have more than one setup section, and they will be written to the test
       file in order of appearance.

   <b>Test</b> <b>Section</b> <b>Header</b> <b>Syntax</b>
       Some examples of the different types of test headers are as follows.

         # Normal anonymous test
         =begin testing

         ok( $foo == $bar, 'This is a test' );

         =end testing

         # A named test. Also provides the number of tests to run.
         # Any test section can specify the number of tests.
         =begin testing my_method 1

         ok( $foo-&gt;my_method, '-&gt;my_method returns true' );

         =end testing

         # A named test with pre-requisites.
         # Note that ONLY named tests can have pre-requisites
         =begin testing this after my_method foo bar other_method Other::Class

         ok( $foo-&gt;this, '-&gt;this returns true' );

         =end testing

       The first example shows a normal anonymous test. All anonymous test sections are considered low priority,
       and we be run, in order of appearance, AFTER all named tests have been run.

       Any and all arguments used after "testing" must be in the form of simple space separated words. The first
       word is considered the "name" of the test.  The intended use for these is generally to create one named
       test section for each function or method, but you can name them as you please. Test names <b>must</b> be unique,
       and <b>are</b> case sensitive.

       After the name, you can provide the word "after" and provide a list of other named tests that must be
       completed first in order to run this test. This is provided so that when errors are encounted, they are
       probably the result of this method or set of tests, and not in some other method that this one relies on.
       It makes debugging a lot easier. The word after is only a keyword when after the test name, so you can
       use a test name of after as well.  The following are both legal

         =begin testing after after that
         =begin testing this after after

       The easiest and recommended way of labeling the tests is simple to name all tests after their methods,
       and put as a pre-requisite any other methods that the method you are testing calls. Test::Inline will
       take care of writing the tests to the test script in the correct order. Please note you can NOT define
       circular relationships in the prerequisites, or an error will occur.

       If a number is provided as the last value, it will be taken to mean the number of actual tests that will
       occur during the test section. While preparing to write the test files, the processor will try to use
       these to try to determine the number of files to write. If ALL test sections to be written to a
       particular file have a test count, then the script will use the total of these as a basic for providing
       Test::More with a plan.

       If ANY test sections to be written to a file do not have a test count, the test file with use "no_plan".

       Finally, Test::Inline will try to be forgiving in it's parsing of the tests.  any missing prerequisites
       will be ignored. Also, as long as it does not break a prerequisite, all named tests will be attempted to
       be run in their order of appearance.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
         my $Section = Test::Inline::Section-&gt;new( $pod );

       The "new" constructor takes a string of POD, which must be a single section of relevant pod ( preferably
       produced by Test::Inline::ExtractHandler ), and creates a new section object for it.

       Returns a new "Test::Inline::Section" object if passed POD in the form "=begin testing ...". Returns
       "undef" on error.

   <b>parse</b>
         my $SectionList = Test::Inline::Section( @elements );

       Since version 1.50 Test::Inline has been extracting package statements so that as the sections are
       extracted, we can determine which sections belong to which packages, and separate them accordingly.

       The "parse" method takes <b>all</b> of the elements from a file, and returns all of the Sections. By doing it
       here, we can track the package context and set it in the Sections.

   <b>setup</b>
         my $run_first = $Section-&gt;setup;

       The "setup" accessor indicates that this section is a "setup" section, to be run at the beginning of the
       generated test script.

       Returns true if this is a setup section, false otherwise.

   <b>example</b>
         my $just_compile = $Section-&gt;example;

       The "example" accessor indicates that this section is an "example" section, to be compile-tested instead
       of run.

       Returns true if this is an example section, false otherwise.

   <b>context</b>
       The "context" method returns the package context of the unit test section, or false if the unit test
       section appeared out of context.

   <b>name</b>
       The "name" method returns the name of the test section, or false if the test if anonymous.

   <b>tests</b>
       The "tests" method returns the number of Test::Builder-compatible tests that will run within the test
       section. Returns "undef" if the number of tests is unknown.

   <b>begin</b>
       For use mainly in debugging, the "begin" method returns the literal string of the begin line/paragraph.

   <b>anonymous</b>
         my $is_anonymous = $Section-&gt;anonymous;

       The "anonymous" method returns true if the test section is an unnamed anonymous section, or false if it
       is a named section or a setup section.

   <b>after</b>
         my @names = $Section-&gt;after;

       The "after" method returns the list of other named tests that this test section says it should be run
       after.

       Returns a list of test name, or the null list "()" if the test does not have to run after any other named
       tests.

   <b>classes</b>
         my @classes = $Section-&gt;classes;

       The "classes" method returns the list of test classes that the test depends on, and should be run before
       the tests. These values are used to determine the set of class-level dependencies for the entire test
       file.

       Returns a list of class names, or the null list "()" if the test does not have any class-level
       dependencies.

   <b>content</b>
         my $code = $Section-&gt;content;

       The "content" method returns the actual testing code contents of the section, with the leading "=begin"
       and trailing "=end" removed.

       Returns a string containing the code, or the null string "" if the section was empty.

</pre><h4><b>SUPPORT</b></h4><pre>
       See the main SUPPORT section.

       Bugs may be submitted through the RT bug tracker &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Test-
       Inline&gt; (or <a href="mailto:bug-Test-Inline@rt.cpan.org">bug-Test-Inline@rt.cpan.org</a> &lt;<a href="mailto:bug-Test-Inline@rt.cpan.org">mailto:bug-Test-Inline@rt.cpan.org</a>&gt;).

</pre><h4><b>AUTHOR</b></h4><pre>
       Adam Kennedy &lt;<a href="mailto:adamk@cpan.org">adamk@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2003 by Adam Kennedy.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.32.0                                       2021-01-31                         <u>Test::Inline::<a href="../man3pm/Section.3pm.html">Section</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>