<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>curl_formadd - add a section to a multipart form POST</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       curl_formadd - add a section to a multipart form POST

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       CURLFORMcode curl_formadd(struct curl_httppost **firstitem,
                                 struct curl_httppost **lastitem, ...);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>This</b> <b>function</b> <b>is</b> <b>deprecated.</b> Use <u><a href="../man3/curl_mime_init.3.html">curl_mime_init</a>(3)</u> instead.

       curl_formadd()  is  used  to append sections when building a multipart form post. Append one section at a
       time until you have added all the sections you want included and then you pass the <u>firstitem</u>  pointer  as
       parameter to <u><a href="../man3/CURLOPT_HTTPPOST.3.html">CURLOPT_HTTPPOST</a>(3)</u>. <u>lastitem</u> is set after each <u><a href="../man3/curl_formadd.3.html">curl_formadd</a>(3)</u> call and on repeated invokes
       it should be left as set to allow repeated invokes to find the end of the list faster.

       After the <u>lastitem</u> pointer follow the real arguments.

       The  pointers  <u>firstitem</u> and <u>lastitem</u> should both be pointing to NULL in the first call to this function.
       All list-data is allocated by the function itself. You must call <u><a href="../man3/curl_formfree.3.html">curl_formfree</a>(3)</u> on the <u>firstitem</u>  after
       the form post has been done to free the resources.

       Using POST with HTTP 1.1 implies the use of a "Expect: 100-continue" header.  You can disable this header
       with <u><a href="../man3/CURLOPT_HTTPHEADER.3.html">CURLOPT_HTTPHEADER</a>(3)</u> as usual.

       First,  there are some basics you need to understand about multipart form posts. Each part consists of at
       least a NAME and a CONTENTS part. If the  part  is  made  for  file  upload,  there  are  also  a  stored
       CONTENT-TYPE and a FILENAME.  Below, we discuss what options you use to set these properties in the parts
       you want to add to your post.

       The  options  listed  first  are  for  making  normal  parts.  The  options  from  <u>CURLFORM_FILE</u>  through
       <u>CURLFORM_BUFFERLENGTH</u> are for file upload parts.

</pre><h4><b>OPTIONS</b></h4><pre>
       CURLFORM_COPYNAME
              followed by a string which provides the <u>name</u> of this part.  libcurl  copies  the  string  so  your
              application  does  not  need  to  keep  it  around  after  this  function call. If the name is not
              null-terminated, you must set its length with <b>CURLFORM_NAMELENGTH</b>. The  <u>name</u>  is  not  allowed  to
              contain zero-valued bytes. The copied data is freed by <u><a href="../man3/curl_formfree.3.html">curl_formfree</a>(3)</u>.

       CURLFORM_PTRNAME
              followed  by  a string which provides the <u>name</u> of this part. libcurl uses the pointer and refer to
              the data in your application, so you must make sure it remains until curl no longer needs  it.  If
              the name is not null-terminated, you must set its length with <b>CURLFORM_NAMELENGTH</b>. The <u>name</u> is not
              allowed to contain zero-valued bytes.

       CURLFORM_COPYCONTENTS
              followed  by  a pointer to the contents of this part, the actual data to send away. libcurl copies
              the provided data, so your application does not need to keep it around after this  function  call.
              If  the  data  is not null-terminated, or if you would like it to contain zero bytes, you must set
              the length of the name with <b>CURLFORM_CONTENTSLENGTH</b>. The copied data is freed by <u><a href="../man3/curl_formfree.3.html">curl_formfree</a>(3)</u>.

       CURLFORM_PTRCONTENTS
              followed by a pointer to the contents of this part, the actual data to send away. libcurl uses the
              pointer and refer to the data in your application, so you must make sure it remains until curl  no
              longer  needs  it.  If  the  data  is not null-terminated, or if you would like it to contain zero
              bytes, you must set its length with <b>CURLFORM_CONTENTSLENGTH</b>.

       CURLFORM_CONTENTLEN
              followed by a curl_off_t value giving the length of the contents. Note  that  for  <u>CURLFORM_STREAM</u>
              contents, this option is mandatory.

              If  you  pass a 0 (zero) for this option, libcurl calls strlen() on the contents to figure out the
              size. If you really want to send a zero byte content then you must make sure strlen() on the  data
              pointer returns zero.

              (Option added in 7.46.0)

       CURLFORM_CONTENTSLENGTH
              (This option is deprecated. Use <u>CURLFORM_CONTENTLEN</u> instead.)

              followed by a long giving the length of the contents. Note that for <u>CURLFORM_STREAM</u> contents, this
              option is mandatory.

              If  you  pass a 0 (zero) for this option, libcurl calls strlen() on the contents to figure out the
              size. If you really want to send a zero byte content then you must make sure strlen() on the  data
              pointer returns zero.

       CURLFORM_FILECONTENT
              followed  by  a  filename, causes that file to be read and its contents used as data in this part.
              This part does <u>not</u> automatically become a file upload part simply because its data was read from a
              file.

              The specified file needs to kept around until the associated transfer is done.

       CURLFORM_FILE
              followed by a filename, makes this part a file upload part. It sets  the  <u>filename</u>  field  to  the
              basename  of  the provided filename, it reads the contents of the file and passes them as data and
              sets the content-type if the given file match one of the internally  known  file  extensions.  For
              <b>CURLFORM_FILE</b>  the user may send one or more files in one part by providing multiple <b>CURLFORM_FILE</b>
              arguments  each  followed  by  the  filename  (and  each  <u>CURLFORM_FILE</u>  is  allowed  to  have   a
              <u>CURLFORM_CONTENTTYPE</u>).

              The  given upload file has to exist in its full in the file system already when the upload starts,
              as libcurl needs to read the correct file size beforehand.

              The specified file needs to kept around until the associated transfer is done.

       CURLFORM_CONTENTTYPE
              is used in combination with <u>CURLFORM_FILE</u>. Followed by a pointer to a string  which  provides  the
              content-type for this part, possibly instead of an internally chosen one.

       CURLFORM_FILENAME
              is  used in combination with <u>CURLFORM_FILE</u>. Followed by a pointer to a string, it tells libcurl to
              use the given string as the <u>filename</u> in the file upload part instead of the actual filename.

       CURLFORM_BUFFER
              is used for custom file upload parts without use of <u>CURLFORM_FILE</u>. It tells libcurl that the  file
              contents  are  already  present in a buffer. The parameter is a string which provides the <u>filename</u>
              field in the content header.

       CURLFORM_BUFFERPTR
              is used in combination with <u>CURLFORM_BUFFER</u>. The parameter is  a  pointer  to  the  buffer  to  be
              uploaded.  This buffer must not be freed until after <u><a href="../man3/curl_easy_cleanup.3.html">curl_easy_cleanup</a>(3)</u> is called. You must also
              use <u>CURLFORM_BUFFERLENGTH</u> to set the number of bytes in the buffer.

       CURLFORM_BUFFERLENGTH
              is used in combination with <u>CURLFORM_BUFFER</u>. The parameter is a long which gives the length of the
              buffer.

       CURLFORM_STREAM
              Tells libcurl to use the <u><a href="../man3/CURLOPT_READFUNCTION.3.html">CURLOPT_READFUNCTION</a>(3)</u> callback to get data. The parameter you  pass  to
              <u>CURLFORM_STREAM</u>  is  the pointer passed on to the read callback's fourth argument. If you want the
              part to look like a file upload one, set the <u>CURLFORM_FILENAME</u> parameter as well. Note  that  when
              using  <u>CURLFORM_STREAM</u>, <u>CURLFORM_CONTENTSLENGTH</u> must also be set with the total expected length of
              the part unless the formpost is sent chunked encoded. (Option added in libcurl 7.18.2)

       CURLFORM_ARRAY
              Another possibility to send options to curl_formadd() is the <b>CURLFORM_ARRAY</b> option, that passes  a
              struct   curl_forms  array  pointer  as  its  value.  Each  curl_forms  structure  element  has  a
              <u>CURLformoption</u> and a char pointer. The final element in the array  must  be  a  CURLFORM_END.  All
              available  options  can  be  used  in  an array, except the CURLFORM_ARRAY option itself. The last
              argument in such an array must always be <b>CURLFORM_END</b>.

       CURLFORM_CONTENTHEADER
              specifies extra headers for the form POST section. This takes a curl_slist prepared in  the  usual
              way  using  <b>curl_slist_append</b>  and  appends  the  list  of  headers to those libcurl automatically
              generates. The list must exist while the POST occurs, if you free it before the post completes you
              may experience problems.

              When  you  have  passed  the  <u>struct</u>  <u>curl_httppost</u>  pointer  to  <u><a href="../man3/curl_easy_setopt.3.html">curl_easy_setopt</a>(3)</u>  (using  the
              <u><a href="../man3/CURLOPT_HTTPPOST.3.html">CURLOPT_HTTPPOST</a>(3)</u>   option),   you   must  not  free  the  list  until  after  you  have  called
              <u><a href="../man3/curl_easy_cleanup.3.html">curl_easy_cleanup</a>(3)</u> for the curl handle.

              See example below.

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects http only

</pre><h4><b>EXAMPLE</b></h4><pre>
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt; /* for strlen */

       static const char record[]="data in a buffer";

       int main(void)
       {
         CURL *curl = curl_easy_init();
         if(curl) {
           struct curl_httppost *post = NULL;
           struct curl_httppost *last = NULL;
           char namebuffer[] = "name buffer";
           long namelength = strlen(namebuffer);
           char buffer[] = "test buffer";
           char htmlbuffer[] = "&lt;HTML&gt;test buffer&lt;/HTML&gt;";
           long htmlbufferlength = strlen(htmlbuffer);
           struct curl_forms forms[3];
           char file1[] = "my-face.jpg";
           char file2[] = "your-face.jpg";
           /* add null character into htmlbuffer, to demonstrate that
              transfers of buffers containing null characters actually work
           */
           htmlbuffer[8] = '\0';

           /* Add simple name/content section */
           curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, "name",
                        CURLFORM_COPYCONTENTS, "content", CURLFORM_END);

           /* Add simple name/content/contenttype section */
           curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, "htmlcode",
                        CURLFORM_COPYCONTENTS, "&lt;HTML&gt;&lt;/HTML&gt;",
                        CURLFORM_CONTENTTYPE, "text/html", CURLFORM_END);

           /* Add name/ptrcontent section */
           curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, "name_for_ptrcontent",
                        CURLFORM_PTRCONTENTS, buffer, CURLFORM_END);

           /* Add ptrname/ptrcontent section */
           curl_formadd(&amp;post, &amp;last, CURLFORM_PTRNAME, namebuffer,
                        CURLFORM_PTRCONTENTS, buffer, CURLFORM_NAMELENGTH,
                        namelength, CURLFORM_END);

           /* Add name/ptrcontent/contenttype section */
           curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, "html_code_with_hole",
                        CURLFORM_PTRCONTENTS, htmlbuffer,
                        CURLFORM_CONTENTSLENGTH, htmlbufferlength,
                        CURLFORM_CONTENTTYPE, "text/html", CURLFORM_END);

           /* Add simple file section */
           curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, "picture",
                        CURLFORM_FILE, "my-face.jpg", CURLFORM_END);

           /* Add file/contenttype section */
           curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, "picture",
                        CURLFORM_FILE, "my-face.jpg",
                        CURLFORM_CONTENTTYPE, "image/jpeg", CURLFORM_END);

           /* Add two file section */
           curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, "pictures",
                        CURLFORM_FILE, "my-face.jpg",
                        CURLFORM_FILE, "your-face.jpg", CURLFORM_END);

           /* Add two file section using CURLFORM_ARRAY */
           forms[0].option = CURLFORM_FILE;
           forms[0].value  = file1;
           forms[1].option = CURLFORM_FILE;
           forms[1].value  = file2;
           forms[2].option  = CURLFORM_END;

           /* Add a buffer to upload */
           curl_formadd(&amp;post, &amp;last,
                        CURLFORM_COPYNAME, "name",
                        CURLFORM_BUFFER, "data",
                        CURLFORM_BUFFERPTR, record,
                        CURLFORM_BUFFERLENGTH, sizeof(record),
                        CURLFORM_END);

           /* no option needed for the end marker */
           curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, "pictures",
                        CURLFORM_ARRAY, forms, CURLFORM_END);
           /* Add the content of a file as a normal post text value */
           curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, "filecontent",
                        CURLFORM_FILECONTENT, ".bashrc", CURLFORM_END);
           /* Set the form info */
           curl_easy_setopt(curl, CURLOPT_HTTPPOST, post);

           curl_easy_perform(curl);

           curl_easy_cleanup(curl);

           curl_formfree(post);
         }
       }

</pre><h4><b>DEPRECATED</b></h4><pre>
       Deprecated in 7.56.0. Before this release, field names were allowed to  contain  zero-valued  bytes.  The
       pseudo-filename  "-"  to  read stdin is discouraged although still supported, but data is not read before
       being actually sent: the effective data size can then not be automatically  determined,  resulting  in  a
       chunked  encoding  transfer.  Backslashes and double quotes in field and filenames are now escaped before
       transmission.

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.1

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       0 means everything was OK, non-zero means an error occurred corresponding  to  a  <u>CURL_FORMADD</u><b>_</b>  <u>constant</u>
       <u>defined</u> <u>in</u> <u>&lt;curl/curl.h&gt;*.</u>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/curl_easy_setopt.3.html">curl_easy_setopt</a></b>(3), <b><a href="../man3/curl_formfree.3.html">curl_formfree</a></b>(3), <b><a href="../man3/curl_mime_init.3.html">curl_mime_init</a></b>(3)

libcurl                                            2025-06-16                                    <u><a href="../man3/curl_formadd.3.html">curl_formadd</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>