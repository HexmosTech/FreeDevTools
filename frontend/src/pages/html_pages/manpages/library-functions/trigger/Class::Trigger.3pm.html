<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::Trigger - Mixin to add / call inheritable triggers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-trigger-perl">libclass-trigger-perl_0.15-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::Trigger - Mixin to add / call inheritable triggers

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package Foo;
         use Class::Trigger;

         sub foo {
             my $self = shift;
             $self-&gt;call_trigger('before_foo');
             # some code ...
             $self-&gt;call_trigger('middle_of_foo');
             # some code ...
             $self-&gt;call_trigger('after_foo');
         }

         package main;
         Foo-&gt;add_trigger(before_foo =&gt; \&amp;sub1);
         Foo-&gt;add_trigger(after_foo =&gt; \&amp;sub2);

         my $foo = Foo-&gt;new;
         $foo-&gt;foo;            # then sub1, sub2 called

         # triggers are inheritable
         package Bar;
         use base qw(Foo);

         Bar-&gt;add_trigger(before_foo =&gt; \&amp;sub);

         # triggers can be object based
         $foo-&gt;add_trigger(after_foo =&gt; \&amp;sub3);
         $foo-&gt;foo;            # sub3 would appply only to this object

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Class::Trigger is a mixin class to add / call triggers (or hooks) that get called at some points you
       specify.

</pre><h4><b>METHODS</b></h4><pre>
       By using this module, your class is capable of following methods.

       add_trigger
             Foo-&gt;add_trigger($triggerpoint =&gt; $sub);
             $foo-&gt;add_trigger($triggerpoint =&gt; $sub);

             Foo-&gt;add_trigger( name =&gt; $triggerpoint,
                               callback =&gt; sub {return undef},
                               abortable =&gt; 1);

             # no further triggers will be called. Undef will be returned.

           Adds  triggers  for  trigger  point. You can have any number of triggers for each point. Each coderef
           will be passed a reference to the calling object, as well as arguments passed  in  via  call_trigger.
           Return values will be captured in <u>list</u> <u>context</u>.

           If  add_trigger is called with named parameters and the "abortable" parameter is passed a true value,
           a false return value from trigger code will stop processing  of  this  trigger  point  and  return  a
           "false" value to the calling code.

           If  "add_trigger"  is  called  without  the  "abortable"  flag,  return  values  will  be captured by
           call_trigger, but failures will be ignored.

           If "add_trigger" is called as object method, whole current trigger table  will  be  copied  onto  the
           object and the new trigger added to that. (The object must be implemented as hash.)

             my $foo = Foo-&gt;new;

             # this trigger ($sub_foo) would apply only to $foo object
             $foo-&gt;add_trigger($triggerpoint =&gt; $sub_foo);
             $foo-&gt;foo;

             # And not to another $bar object
             my $bar = Foo-&gt;new;
             $bar-&gt;foo;

       call_trigger
             $foo-&gt;call_trigger($triggerpoint, @args);

           Calls  triggers  for  trigger point, which were added via "add_trigger" method. Each triggers will be
           passed a copy of the object as the first argument.  Remaining arguments passed to "call_trigger" will
           be passed on to each trigger.  Triggers are invoked in the same order they were defined.

           If there are no "abortable"  triggers  or  no  "abortable"  trigger  point  returns  a  false  value,
           "call_trigger" will return the number of triggers processed.

           If  an  "abortable"  trigger  returns  a false value, call trigger will stop execution of the trigger
           point and return undef.

       last_trigger_results
               my @results = @{ $foo-&gt;last_trigger_results };

           Returns a reference to an array of the return values of all triggers  called  for  the  last  trigger
           point. Results are ordered in the same order the triggers were run.

</pre><h4><b>TRIGGER</b> <b>POINTS</b></h4><pre>
       By  default you can make any number of trigger points, but if you want to declare names of trigger points
       explicitly, you can do it via "import".

         package Foo;
         use Class::Trigger qw(foo bar baz);

         package main;
         Foo-&gt;add_trigger(foo  =&gt; \&amp;sub1); # okay
         Foo-&gt;add_trigger(hoge =&gt; \&amp;sub2); # exception

</pre><h4><b>FAQ</b></h4><pre>
       <b>Acknowledgement:</b> Thanks to everyone at POOP mailing-list (<a href="http://poop.sourceforge.net/">http://poop.sourceforge.net/</a>).

       Q.  This module lets me add subs to be run before/after a specific subroutine is run.  Yes?

       A.  You put various <b>call_trigger()</b> method in your class.  Then your class users  can  call  <b>add_trigger()</b>
           method to add subs to be run in points just you specify (exactly where you put <b>call_trigger()</b>).

       Q.  Are  you  aware of the perl-aspects project and the Aspect module?  Very similar to Class::Trigger by
           the look of it, but its not nearly as  explicit.   Its  not  necessary  for  <b>foo()</b>  to  actually  say
           "triggers go *here*", you just add them.

       A.  Yep ;)

           But the difference with Aspect would be that Class::Trigger is so simple that it's easy to learn, and
           doesn't require 5.6 or over.

       Q.  How does this compare to Sub::Versive, or Hook::LexWrap?

       A.  Very similar. But the difference with Class::Trigger would be the explicitness of trigger points.

           In addition, you can put hooks in any point, rather than pre or post of a method.

       Q.  It looks interesting, but I just can't think of a practical example of its use...

       A.  (by Tony Bowden)

           I  originally  added  code  like  this to Class::DBI to cope with one particular case: auto-upkeep of
           full-text search indices.

           So I added functionality in Class::DBI to be able to  trigger  an  arbitrary  subroutine  every  time
           something  happened  -  then  it  was  a simple matter of setting up triggers on INSERT and UPDATE to
           reindex that row, and on DELETE to remove that index row.

           See Class::DBI::mysql::FullTextSearch and its source code to see it in action.

</pre><h4><b>AUTHORS</b></h4><pre>
       Original idea by Tony Bowden &lt;<a href="mailto:tony@kasei.com">tony@kasei.com</a>&gt; in Class::DBI.

       Code by Tatsuhiko Miyagawa &lt;<a href="mailto:miyagawa@bulknews.net">miyagawa@bulknews.net</a>&gt;.

       Jesse Vincent added a code to get return values from triggers and abortable flag.

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Class::DBI

perl v5.34.0                                       2022-06-05                                <u>Class::<a href="../man3pm/Trigger.3pm.html">Trigger</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>