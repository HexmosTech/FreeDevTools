<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Directory::Scratch - (DEPRECATED) Easy-to-use self-cleaning scratch space</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdirectory-scratch-perl">libdirectory-scratch-perl_0.18-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Directory::Scratch - (DEPRECATED) Easy-to-use self-cleaning scratch space

</pre><h4><b>VERSION</b></h4><pre>
       version 0.18

</pre><h4><b>DEPRECATION</b> <b>NOTICE</b></h4><pre>
       This module has not been maintained in quite some time, and now there are other options available, which
       are much more actively maintained. Please use Test::TempDir::Tiny instead of this module.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       When writing test suites for modules that operate on files, it's often inconvenient to correctly create a
       platform-independent temporary storage space, manipulate files inside it, then clean it up when the test
       exits.  The inconvenience usually results in tests that don't work everywhere, or worse, no tests at all.

       This module aims to eliminate that problem by making it easy to do things right.

       Example:

           use Directory::Scratch;

           my $temp = Directory::Scratch-&gt;new();
           my $dir  = $temp-&gt;mkdir('foo/bar');
           my @lines= qw(This is a file with lots of lines);
           my $file = $temp-&gt;touch('foo/bar/baz', @lines);

           my $fh = openfile($file);
           print {$fh} "Here is another line.\n";
           close $fh;

           $temp-&gt;delete('foo/bar/baz');

           undef $temp; # everything else is removed

           # Directory::Scratch objects stringify to base
           $temp-&gt;touch('foo');
           ok(-e "$temp/foo");  # /tmp/xYz837/foo should exist

</pre><h4><b>EXPORT</b></h4><pre>
       The first argument to the module is optional, but if specified, it's interpreted as the name of the OS
       whose file naming semantics you want to use with Directory::Scratch.  For example, if you choose "Unix",
       then you can provide paths to Directory::Scratch in UNIX-form ('foo/bar/baz') on any platform.  Unix is
       the default if you don't choose anything explicitly.

       If you want to use the local platform's flavor (not recommended), specify an empty import list:

           use Directory::Scratch ''; # use local path flavor

       Recognized platforms (from File::Spec):

       Mac
       UNIX
       Win32
       VMS
       OS2

       The names are case sensitive, since they simply specify which "File::Spec::" module to use when splitting
       the path.

   <b>EXAMPLE</b>
           use Directory::Scratch 'Win32';
           my $tmp = Directory::Scratch-&gt;new();
           $tmp-&gt;touch("foo\\bar\\baz"); # and so on

</pre><h4><b>METHODS</b></h4><pre>
       The  file  arguments  to  these  methods  are always relative to the temporary directory.  If you specify
       "touch('<a href="file:/etc/passwd">/etc/passwd</a>')", then a file called "/tmp/whatever/etc/passwd" will be created instead.

       This means that the program's PWD is ignored (for these methods), and that a leading "/" on the  filename
       is meaningless (and will cause portability problems).

       Finally,  whenever  a  filename  or  path  is  returned,  it is a Path::Class object rather than a string
       containing the filename.  Usually, this object will act just like the string, but to be extra-safe,  call
       "$path-&gt;stringify"  to ensure that you're really getting a string.  (Some clever modules try to determine
       whether a variable is a filename or a filehandle; these modules usually guess wrong when confronted  with
       a "Path::Class" object.)

   <b>new</b>
       Creates  a  new  temporary directory (via File::Temp and its defaults).  When the object returned by this
       method goes out of scope, the directory and its contents are removed.

           my $temp = Directory::Scratch-&gt;new;
           my $another = $temp-&gt;new(); # will be under $temp

           # some File::Temp arguments get passed through (may be less portable)
           my $temp = Directory::Scratch-&gt;new(
               DIR      =&gt; '<a href="file:/var/tmp">/var/tmp</a>',       # be specific about where your files go
               CLEANUP  =&gt; 0,                # turn off automatic cleanup
               TEMPLATE =&gt; 'ScratchDirXXXX', # specify a template for the dirname
           );

       If "DIR", "CLEANUP", or "TEMPLATE" are omitted, reasonable defaults are selected.   "CLEANUP"  is  on  by
       default, and "DIR" is set to "File::Spec-&gt;tmpdir";

   <b>child</b>
       Creates  a  new  "Directory::Scratch"  directory  inside the current "base", copying TEMPLATE and CLEANUP
       options from the current instance.  Returns a "Directory::Scratch" object.

   <b>base</b>
       Returns the full path of the temporary directory, as a Path::Class object.

   <b>platform([$platform])</b>
       Returns the name of the platform that the filenames are being interpreted as (i.e.,  "Win32"  means  that
       this module expects paths like "\foo\bar", whereas "UNIX" means it expects "/foo/bar").

       If  $platform  is  sepcified,  the  platform  is  changed  to  the passed value.  (Overrides the platform
       specified at module "use" time, for <u>this</u> <u>instance</u> only, not every "Directory::Scratch" object.)

   <b>touch($filename,</b> <b>[@lines])</b>
       Creates a file named $filename, optionally containing the elements of  @lines  separated  by  the  output
       record separator "$\".

       The Path::Class object representing the new file is returned if the operation is successful, an exception
       is thrown otherwise.

   <b>create_tree(\%tree)</b>
       Creates  a  file for every key/value pair if the hash, using the key as the filename and the value as the
       contents.  If the value is an arrayref, the array is used as the optional @lines argument to "touch".  If
       the value is a reference to "undef", then a directory is created instead of a file.

       Example:

           %tree = ( 'foo'     =&gt; 'this is foo',
                     'bar/baz' =&gt; 'this is baz inside bar',
                     'lines'   =&gt; [qw|this file contains 5 lines|],
                     'dir'     =&gt; \undef,
                   );
           $tmp-&gt;create_tree(\%tree);

       In this case, two directories are created, "dir" and "bar"; and three files  are  created,  "foo",  "baz"
       (inside "bar"), and "lines". "foo" and "baz" contain a single line, while "lines" contains 5 lines.

   <b>openfile($filename)</b>
       Opens $filename for writing and reading ("+&gt;"), and returns the filehandle.  If $filename already exists,
       it will be truncated.  It's up to you to take care of flushing/closing.

       In list context, returns both the filehandle and the filename "($fh, $path)".

   <b>mkdir($directory)</b>
       Creates  a directory (and its parents, if necessary) inside the temporary directory and returns its name.
       Any leading "/" on the directory name is ignored; all directories are created inside the "base".

       The full path of this directory is returned if the operation is successful,  otherwise  an  exception  is
       thrown.

   <b>tempfile([$path])</b>
       Returns an empty filehandle + filename in $path.  If $path is omitted, the base directory is assumed.

       See File::Temp::tempfile.

           my($fh,$name) = $scratch-&gt;tempfile;

   <b>exists($file)</b>
       Returns the file's real (system) path if $file exists, undefined otherwise.

       Example:

           my $path = $tmp-&gt;exists($file);
           if(defined $path){
              say "Looks like you have a file at $path!";
              open(my $fh, '&gt;&gt;', $path) or die $!;
              print {$fh} "add another line\n";
              close $fh or die $!;
           }
           else {
              say "No file called $file."
           }

   <b>stat($file)</b>
       Stats  $file.   In  list  context,  returns  the list returned by the "stat" builtin.  In scalar context,
       returns a "File::stat" object.

   <b>read($file)</b>
       Returns the contents of $file.  In array context, returns a list of chompped lines.  In  scalar  context,
       returns the raw octets of the file (with any trailing newline removed).

       If you wrote the file with $, set, you'll want to set $/ to $, when reading the file back in:

           local $, = '!';
           $tmp-&gt;touch('foo', qw{foo bar baz}); # writes "foo!bar!baz!" to disk
           scalar $tmp-&gt;read('foo') # returns "foo!bar!baz!"
           $tmp-&gt;read('foo') # returns ("foo!bar!baz!")
           local $/ = '!';
           $tmp-&gt;read('foo') # returns ("foo", "bar", "baz")

   <b>write($file,</b> <b>@lines)</b>
       Replaces  the contents of file with @lines.  Each line will be ended with a "\n", or $, if it is defined.
       The file will be created if necessary.

   <b>append($file,</b> <b>@lines)</b>
       Appends @lines to $file, as per "write".

   <b>randfile()</b>
       Generates a file with random string data in it.   If String::Random is available,  it  will  be  used  to
       generate the file's data.  Takes 0, 1, or 2 arguments - default size, max size, or size range.

       A max size of 0 will cause an exception to be thrown.

       Examples:

           my $file = $temp-&gt;randfile(); # size is between 1024 and 131072
           my $file = $temp-&gt;randfile( 4192 ); # size is below 4129
           my $file = $temp-&gt;randfile( 1000000, 4000000 );

   <b>link($from,</b> <b>$to)</b>
       Symlinks a file in the temporary directory to another file in the temporary directory.

       Note:  symlinks  are  not  supported on Win32.  Portable code must not use this method.  (The method will
       "croak" if it won't work.)

   <b>ls([$path])</b>
       Returns a list (in no particular order) of all files below $path.  If  $path  is  omitted,  the  root  is
       assumed.  Note that directories are not returned.

       If $path does not exist, an exception is thrown.

   <b>delete($path)</b>
       Deletes the named file or directory at $path.

       If the path is removed successfully, the method returns true.  Otherwise, an exception is thrown.

       (Note:  delete  means "unlink" for a file and "rmdir" for a directory.  "delete"-ing an unempty directory
       is an error.)

   <b>chmod($octal_permissions,</b> <b>@files)</b>
       Sets the permissions $octal_permissions on @files, returning the number of  files  successfully  changed.
       Note  that '0644' is "--w----r-T", not "-rw-r--r--".  You need to pass in "oct('0644')" or a literal 0644
       for this method to DWIM.  The method is just a passthru to  perl's  built-in  "chmod"  function,  so  see
       "perldoc -f chmod" for full details.

   <b>cleanup</b>
       Forces  an  immediate  cleanup  of the current object's directory.  See File::Path's <b>rmtree()</b>.  It is not
       safe to use the object after this method is called.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       If the "PERL_DIRECTORYSCRATCH_CLEANUP" variable is set to 0, automatic cleanup will be suppressed.

</pre><h4><b>PATCHES</b></h4><pre>
       Commentary, patches, etc. are most welcome.  If you send a patch, try patching the git version  available
       from:

       &lt;git://git.jrock.us/Directory-Scratch&gt;.

       You can check out a copy by running:

           git clone git://git.jrock.us/Directory-Scratch

       Then  you can use git to commit changes and then e-mail me a patch, or you can publish the repository and
       ask me to pull the changes.  More information about git is available from

       &lt;<a href="http://git.or.cz/">http://git.or.cz/</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        L&lt;File::Temp&gt;
        L&lt;File::Path&gt;
        L&lt;File::Spec&gt;
        L&lt;Path::Class&gt;

</pre><h4><b>BUGS</b></h4><pre>
       Please     report     any     bugs     or     feature     through     the      web      interface      at
       &lt;<a href="http://rt.cpan.org/NoAuth/ReportBug.html">http://rt.cpan.org/NoAuth/ReportBug.html</a>?Queue=Directory-Scratch&gt;.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to Al Tobey (TOBEYA) for some excellent patches, notably:

       "child"
       Random Files ("randfile")
       "tempfile"
       "openfile"

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2006 Jonathan Rockway, all rights reserved.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2022-11-20                            <u>Directory::<a href="../man3pm/Scratch.3pm.html">Scratch</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>