<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heap - Perl extensions for keeping data partially sorted</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libheap-perl">libheap-perl_0.80-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Heap - Perl extensions for keeping data partially sorted

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Heap;

         my $heap = Heap-&gt;new;
         my $elem;

         use Heap::Elem::Num(NumElem);

         foreach $i ( 1..100 ) {
             $elem = NumElem( $i );
             $heap-&gt;add( $elem );
         }

         while( defined( $elem = $heap-&gt;extract_top ) ) {
             print "Smallest is ", $elem-&gt;val, "\n";
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The Heap collection of modules provide routines that manage a heap of elements.  A heap is a partially
       sorted structure that is always able to easily extract the smallest of the elements in the structure (or
       the largest if a reversed compare routine is provided).

       If the collection of elements is changing dynamically, the heap has less overhead than keeping the
       collection fully sorted.

       The elements must be objects as described in "Heap::Elem" and all elements inserted into one heap must be
       mutually compatible - either the same class exactly or else classes that differ only in ways unrelated to
       the <b>Heap::Elem</b> interface.

</pre><h4><b>METHODS</b></h4><pre>
       $heap = <b>HeapClass::new()</b>; $heap2 = $heap1-&gt;<b>new()</b>;
           Returns  a  new heap object of the specified (sub-)class.  This is often used as a subroutine instead
           of a method, of course.

       $heap-&gt;DESTROY
           Ensures that no internal circular data references remain.  Some variants of Heap  ignore  this  (they
           have  no  such  references).   Heap  users normally need not worry about it, DESTROY is automatically
           invoked when the heap reference goes out of scope.

       $heap-&gt;add($elem)
           Add an element to the heap.

       $elem = $heap-&gt;top
           Return the top element on the heap.  It is <b>not</b> removed from the heap but will remain at the top.   It
           will be the smallest element on the heap (unless a reversed cmp function is being used, in which case
           it will be the largest).  Returns <u>undef</u> if the heap is empty.

           This  method  used  to  be called "minimum" instead of "top".  The old name is still supported but is
           deprecated.  (It was confusing to use the method "minimum" to get the maximum value on the heap  when
           a reversed cmp function was used for ordering elements.)

       $elem = $heap-&gt;extract_top
           Delete the top element from the heap and return it.  Returns <u>undef</u> if the heap was empty.

           This  method  used  to  be  called "extract_minimum" instead of "extract_top".  The old name is still
           supported but is deprecated.  (It was confusing to  use  the  method  "extract_minimum"  to  get  the
           maximum value on the heap when a reversed cmp function was used for ordering elements.)

       $heap1-&gt;absorb($heap2)
           Merge all of the elements from <u>$heap2</u> into <u>$heap1</u>.  This will leave <u>$heap2</u> empty.

       $heap1-&gt;decrease_key($elem)
           The  element  will be moved closed to the top of the heap if it is now smaller than any higher parent
           elements.  The user must have changed the value of <u>$elem</u>  before  <u>decrease_key</u>  is  called.   Only  a
           decrease is permitted.  (This is a decrease according to the <u>cmp</u> function - if it is a reversed order
           comparison,  then  you  are only permitted to increase the value of the element.  To be pedantic, you
           may only use <u>decrease_key</u> if <u>$elem-</u>cmp($elem_original) &lt;= 0&gt; if <u>$elem_original</u> were an elem with  the
           value that <u>$elem</u> had before it was <u>decreased</u>.)

       $elem = $heap-&gt;delete($elem)
           The element is removed from the heap (whether it is at the top or not).

</pre><h4><b>AUTHOR</b></h4><pre>
       John Macdonald, <a href="mailto:john@perlwolf.com">john@perlwolf.com</a>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 1998-2007, O'Reilly &amp; Associates.

       This code is distributed under the same copyright terms as perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>Heap::<a href="../man3/Elem.3.html">Elem</a></b>(3), <b>Heap::<a href="../man3/Binary.3.html">Binary</a></b>(3), <b>Heap::<a href="../man3/Binomial.3.html">Binomial</a></b>(3), <b>Heap::<a href="../man3/Fibonacci.3.html">Fibonacci</a></b>(3).

perl v5.36.0                                       2022-10-22                                          <u><a href="../man3pm/Heap.3pm.html">Heap</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>