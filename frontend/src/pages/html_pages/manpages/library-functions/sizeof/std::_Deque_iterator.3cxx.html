<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::_Deque_iterator< _Tp, _Ref, _Ptr > - A deque::iterator.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::_Deque_iterator&lt; _Tp, _Ref, _Ptr &gt; - A deque::iterator.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;deque&gt;

   <b>Public</b> <b>Types</b>
       <b>typedef</b> <b>__ptr_rebind</b>&lt; _Ptr, _Tp &gt; <b>_Elt_pointer</b>
       <b>typedef</b> <b>__ptr_rebind</b>&lt; _Ptr, _Elt_pointer &gt; <b>_Map_pointer</b>
       <b>typedef</b> <b>_Deque_iterator</b> <b>_Self</b>
       <b>typedef</b> <b>__iter</b>&lt; const _Tp &gt; <b>const_iterator</b>
       <b>typedef</b> ptrdiff_t <b>difference_type</b>
       <b>typedef</b> <b>__iter</b>&lt; _Tp &gt; <b>iterator</b>
       <b>typedef</b> <b>std::random_access_iterator_tag</b> <b>iterator_category</b>
       <b>typedef</b> _Ptr <b>pointer</b>
       <b>typedef</b> <b>_Ref</b> <b>reference</b>
       <b>typedef</b> size_t <b>size_type</b>
       <b>typedef</b> _Tp <b>value_type</b>

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>_Deque_iterator</b> (_Elt_pointer __x, _Map_pointer __y) noexcept
       <b>_Deque_iterator</b> (const <b>_Deque_iterator</b> &amp;__x) noexcept
       template&lt;<b>typename</b> _Iter , <b>typename</b>  = _Require&lt;is_same&lt;_Self, const_iterator&gt;,
           is_same&lt;_Iter, iterator&gt;&gt;&gt; <b>_Deque_iterator</b> (const _Iter &amp;__x) noexcept
       <b>iterator</b> <b>_M_const_cast</b> () const noexcept
       <b>void</b> <b>_M_set_node</b> (_Map_pointer <b>__new_node</b>) noexcept
       <b>reference</b> <b>operator*</b> () const noexcept
       <b>_Self</b> &amp; <b>operator++</b> () noexcept
       <b>_Self</b> <b>operator++</b> (int) noexcept
       <b>_Self</b> &amp; <b>operator+=</b> (difference_type __n) noexcept
       <b>_Self</b> &amp; <b>operator--</b> () noexcept
       <b>_Self</b> <b>operator--</b> (int) noexcept
       <b>_Self</b> &amp; <b>operator-=</b> (difference_type __n) noexcept
       pointer <b>operator-&gt;</b> () const noexcept
       <b>_Deque_iterator</b> &amp; <b>operator=</b> (const <b>_Deque_iterator</b> &amp;)=<b>default</b>
       <b>reference</b> <b>operator[]</b> (difference_type __n) const noexcept

   <b>Static</b> <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>static</b> size_t <b>_S_buffer_size</b> () noexcept

   <b>Public</b> <b>Attributes</b>
       _Elt_pointer <b>_M_cur</b>
       _Elt_pointer <b>_M_first</b>
       _Elt_pointer <b>_M_last</b>
       _Map_pointer <b>_M_node</b>

   <b>Friends</b>
       template&lt;<b>typename</b> <b>_RefR</b> , <b>typename</b> <b>_PtrR</b> &gt; bool <b>operator!=</b> (const <b>_Self</b> &amp;__x, const <b>_Deque_iterator</b>&lt; _Tp,
           <b>_RefR</b>, <b>_PtrR</b> &gt; &amp;__y) noexcept
       bool <b>operator!=</b> (const <b>_Self</b> &amp;__x, const <b>_Self</b> &amp;__y) noexcept
       <b>_Self</b> <b>operator+</b> (const <b>_Self</b> &amp;__x, difference_type __n) noexcept
       <b>_Self</b> <b>operator+</b> (difference_type __n, const <b>_Self</b> &amp;__x) noexcept
       template&lt;<b>typename</b> <b>_RefR</b> , <b>typename</b> <b>_PtrR</b> &gt; difference_type <b>operator-</b> (const <b>_Self</b> &amp;__x, const
           <b>_Deque_iterator</b>&lt; _Tp, <b>_RefR</b>, <b>_PtrR</b> &gt; &amp;__y) noexcept
       difference_type <b>operator-</b> (const <b>_Self</b> &amp;__x, const <b>_Self</b> &amp;__y) noexcept
       <b>_Self</b> <b>operator-</b> (const <b>_Self</b> &amp;__x, difference_type __n) noexcept
       template&lt;<b>typename</b> <b>_RefR</b> , <b>typename</b> <b>_PtrR</b> &gt; bool <b>operator&lt;</b> (const <b>_Self</b> &amp;__x, const <b>_Deque_iterator</b>&lt; _Tp,
           <b>_RefR</b>, <b>_PtrR</b> &gt; &amp;__y) noexcept
       bool <b>operator&lt;</b> (const <b>_Self</b> &amp;__x, const <b>_Self</b> &amp;__y) noexcept
       template&lt;<b>typename</b> <b>_RefR</b> , <b>typename</b> <b>_PtrR</b> &gt; bool <b>operator&lt;=</b> (const <b>_Self</b> &amp;__x, const <b>_Deque_iterator</b>&lt; _Tp,
           <b>_RefR</b>, <b>_PtrR</b> &gt; &amp;__y) noexcept
       bool <b>operator&lt;=</b> (const <b>_Self</b> &amp;__x, const <b>_Self</b> &amp;__y) noexcept
       template&lt;<b>typename</b> <b>_RefR</b> , <b>typename</b> <b>_PtrR</b> &gt; bool <b>operator==</b> (const <b>_Self</b> &amp;__x, const <b>_Deque_iterator</b>&lt; _Tp,
           <b>_RefR</b>, <b>_PtrR</b> &gt; &amp;__y) noexcept
       bool <b>operator==</b> (const <b>_Self</b> &amp;__x, const <b>_Self</b> &amp;__y) noexcept
       template&lt;<b>typename</b> <b>_RefR</b> , <b>typename</b> <b>_PtrR</b> &gt; bool <b>operator&gt;</b> (const <b>_Self</b> &amp;__x, const <b>_Deque_iterator</b>&lt; _Tp,
           <b>_RefR</b>, <b>_PtrR</b> &gt; &amp;__y) noexcept
       bool <b>operator&gt;</b> (const <b>_Self</b> &amp;__x, const <b>_Self</b> &amp;__y) noexcept
       template&lt;<b>typename</b> <b>_RefR</b> , <b>typename</b> <b>_PtrR</b> &gt; bool <b>operator&gt;=</b> (const <b>_Self</b> &amp;__x, const <b>_Deque_iterator</b>&lt; _Tp,
           <b>_RefR</b>, <b>_PtrR</b> &gt; &amp;__y) noexcept
       bool <b>operator&gt;=</b> (const <b>_Self</b> &amp;__x, const <b>_Self</b> &amp;__y) noexcept

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp,</b> <b>typename</b> <b>_Ref,</b> <b>typename</b> <b>_Ptr&gt;</b>
       struct std::_Deque_iterator&lt; _Tp, _Ref, _Ptr &gt;"A deque::iterator.

       Quite a bit of intelligence here. Much of the functionality of deque is actually passed off to this
       class. A deque holds two of these internally, marking its valid range. Access to elements is done as
       offsets of either of those two, relying on operator overloading in this class.

       All the functions are op overloads except for _M_set_node.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Ref</b> <b>,</b> <b>typename</b> <b>_Ptr</b> <b>&gt;</b> <b>void</b> <b>std::_Deque_iterator&lt;</b> <b>_Tp,</b> <b>_Ref,</b> <b>_Ptr</b>
       <b>&gt;::_M_set_node</b> <b>(_Map_pointer</b> <b>__new_node)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Prepares to traverse new_node. Sets everything except _M_cur, which should therefore be set by the caller
       immediately afterwards, based on _M_first and _M_last.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++      <u>std::_Deque_iterator&lt;</u> <b>_</b><u>Tp,</u> <b>_</b><u>Ref,</u> <b>_</b><u>Ptr</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>