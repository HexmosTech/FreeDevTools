<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libatomic-ops - Library providing user level atomic operations</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libatomic-ops-dev">libatomic-ops-dev_7.8.2-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libatomic-ops - Library providing user level atomic operations

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;atomic_ops.h&gt;</b>

       <b>cc</b> <b>...</b> <b>-latomic_ops</b>

       Note that all operations have an additional barrier option that can be set explicitly.

       <b>void</b> <b>AO_load(AO_t</b> <b>*addr)</b>
       <b>void</b> <b>AO_store(AO_t</b> <b>*addr,</b> <b>AO_t</b> <b>val)</b>

       <b>int</b> <b>AO_test_and_set</b> <b>(AO_t</b> <b>*addr)</b>

       <b>AO_t</b> <b>AO_fetch_and_add(AO_t</b> <b>*addr,</b> <b>AO_t</b> <b>incr)</b>
       <b>AO_t</b> <b>AO_fetch_and_add1(AO_t</b> <b>*addr)</b>
       <b>AO_t</b> <b>AO_fetch_and_sub1(AO_t</b> <b>*addr)</b>

       <b>void</b> <b>AO_or(AO_t</b> <b>*p,</b> <b>AO_t</b> <b>incr)</b>
       <b>int</b> <b>AO_compare_and_swap(AO_t</b> <b>*addr,</b> <b>AO_t</b> <b>old,</b> <b>AO_t</b> <b>new_val)</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>libatomic-ops</b> offers a programming interface to a comprehensive range of atomic operations at user level.

       We  define  various  atomic  operations  on  memory  in  a  machine-specific way.  Unfortunately, this is
       complicated by the fact that these may or may not be combined with various  memory  barriers.   Thus  the
       actual  operations  we  define  have  the form <b>AO_&lt;atomic-op&gt;_&lt;barrier&gt;</b> for all plausible combinations of
       &lt;atomic-op&gt; and &lt;barrier&gt;.

       The valid barrier suffixes are

       <b>_release</b>
              Earlier operations may not be delayed past it.

       <b>_acquire</b>
              Later operations may not move ahead of it.

       <b>_read</b>  Subsequent reads must follow this operation and preceding reads.

       <b>_write</b> Earlier writes precede both this operation and later writes.

       <b>_full</b>  Ordered with respect to both earlier and later memops.

       <b>_release_write</b>
              Ordered with respect to earlier writes.

       <b>_acquire_read</b>
              Ordered with repsect to later reads.

       This of course results in a mild combinatorial explosion.

       The library will find the least expensive way to implement your operations on  the  applicable  hardware.
       In  many  cases  that  will involve, for example, a stronger memory barrier, or a combination of hardware
       primitives.

       Note that atomicity guarantees are valid only if both readers and writers use AO_  operations  to  access
       the  shared value, while ordering constraints are intended to apply all memory operations.  If a location
       can potentially be accessed simultaneously from multiple threads, and one of  those  accesses  may  be  a
       write  access,  then  all such accesses to that location should be through AO_ primitives. However if AO_
       operations enforce sufficient ordering to ensure that a location x cannot be  accessed  concurrently,  or
       can only be read concurrently, then x can be accessed via ordinary references and assignments.

       All operations operate on an <b>AO_t</b> value, which is the natural word size for the architecture.

       <b>AO_load</b> and <b>AO_store</b> load and store the specified pointer address.

       <b>AO_test_and_set</b>  atomically  replaces  an address with <b>AO_TS_SET</b> and returns the prior value.  An <b>AO_TS_t</b>
       <b>location</b> <b>can</b> <b>be</b> <b>reset</b> <b>with</b> <b>the</b> <b>AO_CLEAR</b> macro, which usually uses <b>AO_store_release</b>

       <b>AO_fetch_and_add</b> takes an address and a value to add.

       <b>AO_fetch_and_add1</b> and <b>AO_fetch_and_sub1</b> are provided since they may have faster  implemenations  on  some
       hardware

       <b>AO_or</b> atomically ors an <u>AO_t</u> value into a memory location, but does not provide access to the original

       <b>AO_compare_and_swap</b>  takes  an  address,  an  old  value  and  a  new value and returns an int.  <u>non-zero</u>
       indicates the compare and swap succeeded.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/libatomic-stack.3.html">libatomic-stack</a>(3), <a href="../man3/libatomic-malloc.3.html">libatomic-malloc</a>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
       This manual page was written by Ian Wienand &lt;<a href="mailto:ianw@gelato.unsw.edu.au">ianw@gelato.unsw.edu.au</a>&gt;, based on comments  in  the  source
       code.  It was written for the Debian project (but may be used by others).

Ian Wienand                                       May 17, 2005                                  <u><a href="../man3/LIBATOMIC-OPS.3.html">LIBATOMIC-OPS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>