<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>avr_pgmspace - <avr/pgmspace.h>: Program Space Utilities</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/avr-libc">avr-libc_2.2.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       avr_pgmspace - &lt;avr/pgmspace.h&gt;: Program Space Utilities

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Macros</b>
       #define <b>PROGMEM_FAR</b>   __attribute__((__section__('.progmemx.data')))
       #define <b>PROGMEM</b>   __attribute__((__progmem__))
       #define <b>PSTR</b>(str)   ({ static const <b>PROGMEM</b> char c[] = (str); &amp;c[0]; })
       #define <b>PSTR_FAR</b>(str)   ({ static const <b>PROGMEM_FAR</b> char c[] = (str); <b>pgm_get_far_address</b>(c[0]); })
       #define <b>pgm_read_byte_near</b>(__addr)   __LPM ((<b>uint16_t</b>)(__addr))
       #define <b>pgm_read_word_near</b>(__addr)   __LPM_word ((<b>uint16_t</b>)(__addr))
       #define <b>pgm_read_dword_near</b>(__addr)       __LPM_dword ((<b>uint16_t</b>)(__addr))
       #define <b>pgm_read_qword_near</b>(__addr)   __LPM_qword ((<b>uint16_t</b>)(__addr))
       #define <b>pgm_read_float_near</b>(addr)   pgm_read_float (addr)
       #define <b>pgm_read_ptr_near</b>(__addr)       ((void*) __LPM_word ((<b>uint16_t</b>)(__addr)))
       #define <b>pgm_read_byte_far</b>(__addr)   __ELPM (__addr)
       #define <b>pgm_read_word_far</b>(__addr)   __ELPM_word (__addr)
       #define <b>pgm_read_dword_far</b>(__addr)   __ELPM_dword (__addr)
       #define <b>pgm_read_qword_far</b>(__addr)   __ELPM_qword (__addr)
       #define <b>pgm_read_ptr_far</b>(__addr)   ((void*) __ELPM_word (__addr))
       #define <b>pgm_read_byte</b>(__addr)   <b>pgm_read_byte_near</b>(__addr)
       #define <b>pgm_read_word</b>(__addr)   <b>pgm_read_word_near</b>(__addr)
       #define <b>pgm_read_dword</b>(__addr)   <b>pgm_read_dword_near</b>(__addr)
       #define <b>pgm_read_qword</b>(__addr)   <b>pgm_read_qword_near</b>(__addr)
       #define <b>pgm_read_ptr</b>(__addr)   <b>pgm_read_ptr_near</b>(__addr)
       #define <b>pgm_get_far_address</b>(var)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       #include &lt;avr/io.h&gt;
       #include &lt;avr/pgmspace.h&gt;

       The functions in this module provide interfaces for a program to access data stored in program space
       (flash memory) of the device.

       <b>Note</b>
           These functions are an attempt to provide some compatibility with header files that come with IAR C,
           to make porting applications between different compilers easier. This is not 100% compatibility
           though (GCC does not have full support for multiple address spaces yet).

           If you are working with strings which are completely based in RAM, use the standard string functions
           described in <b>&lt;string.h&gt;:</b> <b>Strings</b>.

           If possible, put your constant tables in the lower 64 KB and use <b>pgm_read_byte_near()</b> or
           <b>pgm_read_word_near()</b> instead of <b>pgm_read_byte_far()</b> or <b>pgm_read_word_far()</b> since it is more efficient
           that way, and you can still use the upper 64K for executable code. All functions that are suffixed
           with a _P <u>require</u> their arguments to be in the lower 64 KB of the flash ROM, as they do not use ELPM
           instructions. This is normally not a big concern as the linker setup arranges any program space
           constants declared using the macros from this header file so they are placed right after the
           interrupt vectors, and in front of any executable code. However, it can become a problem if there are
           too many of these constants, or for bootloaders on devices with more than 64 KB of ROM. <u>All</u> <u>these</u>
           <u>functions</u> <u>will</u> <u>not</u> <u>work</u> <u>in</u> <u>that</u> <u>situation.</u>

           For <b>Xmega</b> devices, make sure the NVM controller command register (NVM.CMD or NVM_CMD) is set to 0x00
           (NOP) before using any of these functions.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>pgm_get_far_address(var)</b>
       This macro evaluates to a <b>uint_farptr_t</b> 32-bit 'far' pointer (only 24 bits used) to data even beyond the
       64 KiB limit for the 16-bit ordinary pointer. It is similar to the '&amp;' operator, with some limitations.
       Example:

       #include &lt;avr/pgmspace.h&gt;

       // Section .progmemx.data is located after all the code sections.
       PROGMEM_FAR
       const int data[] = { 2, 3, 5, 7, 9, 11 };

       int get_data (uint8_t idx)
       {
           uint_farptr_t pdata = pgm_get_far_address (data[0]);
           return pgm_read_int_far (pdata + idx * sizeof(int));
       }

       Comments:

       • The overhead is minimal and it's mainly due to the 32-bit size operation.

       • 24 bit sizes guarantees the code compatibility for use in future devices.

       • var  has to be resolved at link-time as an existing symbol, i.e. a simple variable name, an array name,
         or an array or structure element provided the offset is known at compile-time, and var  is  located  in
         static storage, etc.

   <b>#define</b> <b>pgm_read_byte(__addr)</b>   <b>pgm_read_byte_near(__addr)</b>
       Read a byte from the program space with a 16-bit (near) nyte-address.

   <b>#define</b> <b>pgm_read_byte_far(__addr)</b>   <b>__ELPM</b> <b>(__addr)</b>
       Read a byte from the program space with a 32-bit (far) byte-address.

   <b>#define</b> <b>pgm_read_byte_near(__addr)</b>   <b>__LPM</b> <b>((uint16_t)(__addr))</b>
       Read a byte from the program space with a 16-bit (near) byte-address.

   <b>#define</b> <b>pgm_read_dword(__addr)</b>   <b>pgm_read_dword_near(__addr)</b>
       Read a double word from the program space with a 16-bit (near) byte-address.

   <b>#define</b> <b>pgm_read_dword_far(__addr)</b>   <b>__ELPM_dword</b> <b>(__addr)</b>
       Read a double word from the program space with a 32-bit (far) byte-address.

   <b>#define</b> <b>pgm_read_dword_near(__addr)</b>       <b>__LPM_dword</b> <b>((uint16_t)(__addr))</b>
       Read a double word from the program space with a 16-bit (near) byte-address.

   <b>#define</b> <b>pgm_read_float_near(addr)</b>   <b>pgm_read_float</b> <b>(addr)</b>
       Read a float from the program space with a 16-bit (near) byte-address.

   <b>#define</b> <b>pgm_read_ptr(__addr)</b>   <b>pgm_read_ptr_near(__addr)</b>
       Read a pointer from the program space with a 16-bit (near) byte-address.

   <b>#define</b> <b>pgm_read_ptr_far(__addr)</b>   <b>((void*)</b> <b>__ELPM_word</b> <b>(__addr))</b>
       Read a pointer from the program space with a 32-bit (far) byte-address.

   <b>#define</b> <b>pgm_read_ptr_near(__addr)</b>       <b>((void*)</b> <b>__LPM_word</b> <b>((uint16_t)(__addr)))</b>
       Read a pointer from the program space with a 16-bit (near) byte-address.

   <b>#define</b> <b>pgm_read_qword(__addr)</b>   <b>pgm_read_qword_near(__addr)</b>
       Read a quad-word from the program space with a 16-bit (near) byte-address.

   <b>#define</b> <b>pgm_read_qword_far(__addr)</b>   <b>__ELPM_qword</b> <b>(__addr)</b>
       Read a quad-word from the program space with a 32-bit (far) byte-address.

   <b>#define</b> <b>pgm_read_qword_near(__addr)</b>   <b>__LPM_qword</b> <b>((uint16_t)(__addr))</b>
       Read a quad-word from the program space with a 16-bit (near) byte-address.

   <b>#define</b> <b>pgm_read_word(__addr)</b>   <b>pgm_read_word_near(__addr)</b>
       Read a word from the program space with a 16-bit (near) byte-address.

   <b>#define</b> <b>pgm_read_word_far(__addr)</b>   <b>__ELPM_word</b> <b>(__addr)</b>
       Read a word from the program space with a 32-bit (far) byte-address.

   <b>#define</b> <b>pgm_read_word_near(__addr)</b>   <b>__LPM_word</b> <b>((uint16_t)(__addr))</b>
       Read a word from the program space with a 16-bit (near) byte-address.

   <b>#define</b> <b>PROGMEM</b>   <b>__attribute__((__progmem__))</b>
       Attribute to use in order to declare an object being located in flash ROM.

   <b>#define</b> <b>PROGMEM_FAR</b>   <b>__attribute__((__section__('.progmemx.data')))</b>
       Attribute  to  use  in  order  to  declare  an  object being located in far flash ROM. This is similar to
       <b>PROGMEM</b>, except that it puts the static storage object in section <b>.progmemx.data.</b> <b>In</b> <b>order</b> <b>to</b> <b>access</b>  <b>the</b>
       <b>object,</b>  <b>the</b>  <b>pgm_read_*_far</b>  <b>and</b>  <b>_PF</b>  <b>functions</b> <b>declare</b> <b>in</b> <b>this</b> <b>header</b> <b>can</b> <b>be</b> <b>used.</b> <b>In</b> <b>order</b> <b>to</b> <b>get</b> <b>its</b>
       <b>address,</b> <b>see</b> <b>pgm_get_far_address().</b>

       It only makes sense to put read-only objects in this section, though the compiler does not diagnose  when
       this is not the case.

   <b>#define</b> <b>PSTR(str)</b>   <b>({</b> <b>static</b> <b>const</b> <b>PROGMEM</b> <b>char</b> <b>c[]</b> <b>=</b> <b>(str);</b> <b>&amp;c[0];</b> <b>})</b>
       Used to declare a static pointer to a string in program space.

   <b>#define</b> <b>PSTR_FAR(str)</b>   <b>({</b> <b>static</b> <b>const</b> <b>PROGMEM_FAR</b> <b>char</b> <b>c[]</b> <b>=</b> <b>(str);</b> <b>pgm_get_far_address(c[0]);</b> <b>})</b>
       Used to define a string literal in far program space, and to return its address of type <b>uint_farptr_t</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for AVR-LibC from the source code.

AVR-LibC                                          Version 2.2.1                               <u><a href="../man3avr/avr_pgmspace.3avr.html">avr_pgmspace</a></u>(3avr)
</pre>
 </div>
</div></section>
</div>
</body>
</html>