<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::Stream - HTML output stream class, and some markup utilities</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-stream-perl">libhtml-stream-perl_1.60-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::Stream - HTML output stream class, and some markup utilities

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Here's small sample of some of the non-OO ways you can use this module:

             use HTML::Stream qw(:funcs);

             print html_tag('A', HREF=&gt;$link);
             print html_escape("&lt;&lt;Hello &amp; welcome!&gt;&gt;");

       And some of the OO ways as well:

             use HTML::Stream;
             $HTML = new HTML::Stream \*STDOUT;

             # The vanilla interface...
             $HTML-&gt;tag('A', HREF=&gt;"$href");
             $HTML-&gt;tag('IMG', SRC=&gt;"logo.gif", ALT=&gt;"LOGO");
             $HTML-&gt;text($copyright);
             $HTML-&gt;tag('_A');

             # The chocolate interface...
             $HTML -&gt; A(HREF=&gt;"$href");
             $HTML -&gt; IMG(SRC=&gt;"logo.gif", ALT=&gt;"LOGO");
             $HTML -&gt; t($caption);
             $HTML -&gt; _A;

             # The chocolate interface, with whipped cream...
             $HTML -&gt; A(HREF=&gt;"$href")
                   -&gt; IMG(SRC=&gt;"logo.gif", ALT=&gt;"LOGO")
                   -&gt; t($caption)
                   -&gt; _A;

             # The strawberry interface...
             output $HTML [A, HREF=&gt;"$href"],
                          [IMG, SRC=&gt;"logo.gif", ALT=&gt;"LOGO"],
                          $caption,
                          [_A];

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>HTML::Stream</b> module provides you with an object-oriented (and subclassable) way of outputting HTML.
       Basically, you open up an "HTML stream" on an existing filehandle, and then do all of your output to the
       HTML stream.  You can intermix HTML-stream-output and ordinary-print-output, if you like.

       There's even a small built-in subclass, <b>HTML::Stream::Latin1</b>, which can handle Latin-1 input right out of
       the box.   But all in good time...

</pre><h4><b>INTRODUCTION</b> <b>(the</b> <b>Neapolitan</b> <b>dessert</b> <b>special)</b></h4><pre>
   <b>Function</b> <b>interface</b>
       Let's start out with the simple stuff.  This module provides a collection of non-OO utility functions for
       escaping HTML text and producing HTML tags, like this:

           use HTML::Stream qw(:funcs);        # imports functions from @EXPORT_OK

           print html_tag(A, HREF=&gt;$url);
           print '&amp;copy; 1996 by', html_escape($myname), '!';
           print html_tag('/A');

       By the way: that last line could be rewritten as:

           print html_tag(_A);

       And if you need to get a parameter in your tag that doesn't have an associated value, supply the
       <u>undefined</u> value (<u>not</u> the empty string!):

           print html_tag(TD, NOWRAP=&gt;undef, ALIGN=&gt;'LEFT');

                &lt;TD NOWRAP ALIGN=LEFT&gt;

           print html_tag(IMG, SRC=&gt;'logo.gif', ALT=&gt;'');

                &lt;IMG SRC="logo.gif" ALT=""&gt;

       There are also some routines for reversing the process, like:

           $text = "This &lt;i&gt;isn't&lt;/i&gt; &amp;quot;fun&amp;quot;...";
           print html_unmarkup($text);

                This isn't &amp;quot;fun&amp;quot;...

           print html_unescape($text);

                This isn't "fun"...

       <u>Yeah,</u> <u>yeah,</u> <u>yeah</u>, I hear you cry.  <u>We've</u> <u>seen</u> <u>this</u> <u>stuff</u> <u>before.</u>  But wait!  There's more...

   <b>OO</b> <b>interface,</b> <b>vanilla</b>
       Using the function interface can be tedious... so we also provide an <b>"HTML</b> <b>output</b> <b>stream"</b> class.
       Messages to an instance of that class generally tell that stream to output some HTML.  Here's the above
       example, rewritten using HTML streams:

           use HTML::Stream;
           $HTML = new HTML::Stream \*STDOUT;

           $HTML-&gt;tag(A, HREF=&gt;$url);
           $HTML-&gt;ent('copy');
           $HTML-&gt;text(" 1996 by $myname!");
           $HTML-&gt;tag(_A);

       As you've probably guessed:

           text()   Outputs some text, which will be HTML-escaped.

           tag()    Outputs an ordinary tag, like &lt;A&gt;, possibly with parameters.
                    The parameters will all be HTML-escaped automatically.

           ent()    Outputs an HTML entity, like the &amp;copy; or &amp;lt; .
                    You mostly don't need to use it; you can often just put the
                    Latin-1 representation of the character in the text().

       You might prefer to use "t()" and "e()" instead of "text()" and "ent()": they're absolutely identical,
       and easier to type:

           $HTML -&gt; tag(A, HREF=&gt;$url);
           $HTML -&gt; e('copy');
           $HTML -&gt; t(" 1996 by $myname!");
           $HTML -&gt; tag(_A);

       Now, it wouldn't be nice to give you those "text()" and "ent()" shortcuts without giving you one for
       "tag()", would it?  Of course not...

   <b>OO</b> <b>interface,</b> <b>chocolate</b>
       The known HTML tags are even given their own <b>tag-methods,</b> compiled on demand.  The above code could be
       written even more compactly as:

           $HTML -&gt; A(HREF=&gt;$url);
           $HTML -&gt; e('copy');
           $HTML -&gt; t(" 1996 by $myname!");
           $HTML -&gt; _A;

       As you've probably guessed:

           A(HREF=&gt;$url)   ==   tag(A, HREF=&gt;$url)   ==   &lt;A HREF="/the/url"&gt;
           _A              ==   tag(_A)              ==   &lt;/A&gt;

       All of the autoloaded "tag-methods" use the tagname in <u>all-uppercase</u>.  A "_" prefix on any tag-method
       means that an end-tag is desired.  The "_" was chosen for several reasons: (1) it's short and easy to
       type, (2) it doesn't produce much visual clutter to look at, (3) "_TAG" looks a little like "/TAG"
       because of the straight line.

       •   <u>I</u> <u>know,</u> <u>I</u> <u>know...</u> <u>it</u> <u>looks</u> <u>like</u> <u>a</u> <u>private</u> <u>method.</u>  <u>You</u> <u>get</u> <u>used</u> <u>to</u> <u>it.</u>  <u>Really.</u>

       I  should  stress  that  this  module  will  only auto-create tag methods for <b>known</b> HTML tags.  So you're
       protected from typos like this (which will cause a fatal exception at run-time):

           $HTML -&gt; IMGG(SRC=&gt;$src);

       (You're not yet protected from illegal tag parameters, but it's a start, ain't it?)

       If you need to make a tag known (sorry, but this  is  currently  a  <u>global</u>  operation,  and  not  stream-
       specific), do this:

           accept_tag HTML::Stream 'MARQUEE';       # for you MSIE fans...

       <b>Note:</b>  <b>there</b>  <b>is</b>  <b>no</b>  <b>corresponding</b> <b>"reject_tag".</b>  I thought and thought about it, and could not convince
       myself that such a method would do anything more useful than cause other  people's  modules  to  suddenly
       stop working because some bozo function decided to reject the "FONT" tag.

   <b>OO</b> <b>interface,</b> <b>with</b> <b>whipped</b> <b>cream</b>
       In  the grand tradition of C++, output method chaining is supported in both the Vanilla Interface and the
       Chocolate Interface.  So you can (and probably should) write the above code as:

           $HTML -&gt; A(HREF=&gt;$url)
                 -&gt; e('copy') -&gt; t(" 1996 by $myname!")
                 -&gt; _A;

       <u>But</u> <u>wait!</u>  <u>Neapolitan</u> <u>ice</u> <u>cream</u> <u>has</u> <u>one</u> <u>more</u> <u>flavor...</u>

   <b>OO</b> <b>interface,</b> <b>strawberry</b>
       I was jealous of the compact syntax of HTML::AsSubs, but I  didn't  want  to  worry  about  clogging  the
       namespace  with  a  lot  of  functions  like  p(),  a(), etc. (especially when markup-functions like <b>tr()</b>
       conflict with existing Perl functions).  So I came up with this:

           output $HTML [A, HREF=&gt;$url], "Here's my $caption", [_A];

       Conceptually, arrayrefs are sent to "html_tag()", and strings to "html_escape()".

</pre><h4><b>ADVANCED</b> <b>TOPICS</b></h4><pre>
   <b>Auto-formatting</b> <b>and</b> <b>inserting</b> <b>newlines</b>
       <u>Auto-formatting</u> is the name I give to the Chocolate Interface feature whereby newlines (and maybe, in the
       future, other things) are inserted before or after the tags you output in order to make  your  HTML  more
       readable.  So, by default, this:

           $HTML -&gt; HTML
                 -&gt; HEAD
                 -&gt; TITLE -&gt; t("Hello!") -&gt; _TITLE
                 -&gt; _HEAD
                 -&gt; BODY(BGCOLOR=&gt;'#808080');

       Actually produces this:

           &lt;HTML&gt;&lt;HTML&gt;
           &lt;HEAD&gt;
           &lt;TITLE&gt;Hello!&lt;/TITLE&gt;
           &lt;/HEAD&gt;
           &lt;BODY BGCOLOR="#808080"&gt;

       <b>To</b> <b>turn</b> <b>off</b> <b>autoformatting</b> <b>altogether</b> on a given HTML::Stream object, use the "auto_format()" method:

           $HTML-&gt;<a href="../man0/auto_format.0.html">auto_format</a>(0);        # stop autoformatting!

       <b>To</b>  <b>change</b> <b>whether</b> <b>a</b> <b>newline</b> <b>is</b> <b>automatically</b> <b>output</b> before/after the begin/end form of a tag at a <b>global</b>
       level, use "set_tag()":

           HTML::Stream-&gt;set_tag('B', Newlines=&gt;15);   # 15 means "\n&lt;B&gt;\n \n&lt;/B&gt;\n"
           HTML::Stream-&gt;set_tag('I', Newlines=&gt;7);    # 7 means  "\n&lt;I&gt;\n \n&lt;/I&gt;  "

       <b>To</b> <b>change</b> <b>whether</b> <b>a</b> <b>newline</b> <b>is</b> <b>automatically</b> <b>output</b> before/after the begin/end form of a tag <b>for</b> <b>a</b>  <b>given</b>
       <b>stream</b> level, give the stream its own private "tag info" table, and then use "set_tag()":

           $HTML-&gt;private_tags;
           $HTML-&gt;set_tag('B', Newlines=&gt;0);     # won't affect anyone else!

       <b>To</b> <b>output</b> <b>newlines</b> <b>explicitly</b>, just use the special "nl" method in the Chocolate Interface:

           $HTML-&gt;nl;     # one newline
           $HTML-&gt;<a href="../man6/nl.6.html">nl</a>(6);  # six newlines

       I am sometimes asked, "why don't you put more newlines in automatically?"  Well, mostly because...

       •   Sometimes you'll be outputting stuff inside a "PRE" environment.

       •   Sometimes you really do want to jam things (like images, or table cell delimiters and the things they
           contain) right up against each other.

       So I've stuck to outputting newlines in places where it's most likely to be harmless.

   <b>Entities</b>
       As shown above, You can use the "ent()" (or "e()") method to output an entity:

           $HTML-&gt;t('Copyright ')-&gt;e('copy')-&gt;t(' 1996 by Me!');

       But this can be a pain, particularly for generating output with non-ASCII characters:

           $HTML -&gt; t('Copyright ')
                 -&gt; e('copy')
                 -&gt; t(' 1996 by Fran') -&gt; e('ccedil') -&gt; t('ois, Inc.!');

       Granted, Europeans can always type the 8-bit characters directly in their Perl code, and just have this:

           $HTML -&gt; t("Copyright \251 1996 by Fran\347ois, Inc.!');

       But folks without 8-bit text editors can find this kind of output cumbersome to generate.  Sooooooooo...

   <b>Auto-escaping:</b> <b>changing</b> <b>the</b> <b>way</b> <b>text</b> <b>is</b> <b>escaped</b>
       <u>Auto-escaping</u>  is  the name I give to the act of taking an "unsafe" string (one with "&gt;", "&amp;", etc.), and
       magically outputting "safe" HTML.

       The default "auto-escape" behavior of an HTML stream can be a drag if you've got a lot character entities
       that you want to output, or if you're using the Latin-1 character set,  or  some  other  input  encoding.
       Fortunately,  you can use the "auto_escape()" method to change the way a particular HTML::Stream works at
       any time.

       First, here's a couple of special invocations:

           $HTML-&gt;auto_escape('ALL');      # Default; escapes [&lt;&gt;"&amp;] and 8-bit chars.
           $HTML-&gt;auto_escape('LATIN_1');  # Like ALL, but uses Latin-1 entities
                                           #   instead of decimal equivalents.
           $HTML-&gt;auto_escape('NON_ENT');  # Like ALL, but leaves "&amp;" alone.

       You can also install your own auto-escape function (note that you might very well want to install it  for
       just a little bit only, and then de-install it):

           sub my_auto_escape {
               my $text = shift;
               HTML::Entities::encode($text);     # start with default
               $text =~ s/\(c\)/&amp;copy;/ig;        # (C) becomes copyright
               $text =~ s/\\,(c)/\&amp;$1cedil;/ig;   # \,c becomes a cedilla
               $text;
           }

           # Start using my auto-escape:
           my $old_esc = $HTML-&gt;auto_escape(\&amp;my_auto_escape);

           # Output some stuff:
           $HTML-&gt; IMG(SRC=&gt;'logo.gif', ALT=&gt;'Fran\,cois, Inc');
           output $HTML 'Copyright (C) 1996 by Fran\,cois, Inc.!';

           # Stop using my auto-escape:
           $HTML-&gt;auto_escape($old_esc);

       If  you  find yourself in a situation where you're doing this a lot, a better way is to create a <b>subclass</b>
       of HTML::Stream which  installs  your  custom  function  when  constructed.   For  an  example,  see  the
       <b>HTML::Stream::Latin1</b> subclass in this module.

   <b>Outputting</b> <b>HTML</b> <b>to</b> <b>things</b> <b>besides</b> <b>filehandles</b>
       As  of Revision 1.21, you no longer need to supply "new()" with a filehandle: <u>any</u> <u>object</u> <u>that</u> <u>responds</u> <u>to</u>
       <u>a</u> <u><b>print()</b></u> <u>method</u> <u>will</u> <u>do</u>.  Of course, this includes <b>blessed</b> FileHandles, and IO::Handles.

       If you supply a GLOB reference (like "\*STDOUT") or  a  string  (like  "Module::FH"),  HTML::Stream  will
       automatically  create  an  invisible  object for talking to that filehandle (I don't dare bless it into a
       FileHandle, since the underlying descriptor would get closed when the HTML::Stream is destroyed, and  you
       might not want that).

       You say you want to print to a string?  For kicks and giggles, try this:

           package StringHandle;
           sub new {
               my $self = '';
               bless \$self, shift;
           }
           sub print {
               my $self = shift;
               $$self .= join('', @_);
           }

           package main;
           use HTML::Stream;

           my $SH = new StringHandle;
           my $HTML = new HTML::Stream $SH;
           $HTML -&gt; H1 -&gt; t("Hello &amp; &lt;&lt;welcome&gt;&gt;!") -&gt; _H1;
           print "PRINTED STRING: ", $$SH, "\n";

   <b>Subclassing</b>
       This  is  where  you  can  make  your  application-specific  HTML-generating code <u>much</u> easier to look at.
       Consider this:

           package MY::HTML;
           @ISA = qw(HTML::Stream);

           sub Aside {
               $_[0] -&gt; FONT(SIZE=&gt;-1) -&gt; I;
           }
           sub _Aside {
               $_[0] -&gt; _I -&gt; _FONT;
           }

       Now, you can do this:

           my $HTML = new MY::HTML \*STDOUT;

           $HTML -&gt; Aside
                 -&gt; t("Don't drink the milk, it's spoiled... pass it on...")
                 -&gt; _Aside;

       If you're defining these markup-like, chocolate-interface-style functions, I recommend using  mixed  case
       with a leading capital.  You probably shouldn't use all-uppercase, since that's what this module uses for
       real HTML tags.

</pre><h4><b>PUBLIC</b> <b>INTERFACE</b></h4><pre>
   <b>Functions</b>
       html_escape TEXT
           Given  a  TEXT string, turn the text into valid HTML by escaping "unsafe" characters.  Currently, the
           "unsafe" characters are 8-bit characters plus:

               &lt;  &gt;  =  &amp;

           <b>Note:</b> provided for convenience and backwards-compatibility only.  You  may  want  to  use  the  more-
           powerful <b>HTML::Entities::encode</b> function instead.

       html_tag TAG [, PARAM=&gt;VALUE, ...]
           Return  the  text  for a given TAG, possibly with parameters.  As an efficiency hack, only the values
           are HTML-escaped currently: it is assumed that the tag and parameters will already be safe.

           For convenience and readability, you can say "_A" instead of "/A" for the first tag, if  you're  into
           barewords.

       html_unescape TEXT
           Remove  angle-tag  markup, and convert the standard ampersand-escapes ("lt", "gt", "amp", "quot", and
           "#ddd") into ASCII characters.

           <b>Note:</b> provided for convenience and backwards-compatibility only.  You  may  want  to  use  the  more-
           powerful <b>HTML::Entities::decode</b> function instead: unlike this function, it can collapse entities like
           "copy" and "ccedil" into their Latin-1 byte values.

       html_unmarkup TEXT
           Remove  angle-tag  markup from TEXT, but do not convert ampersand-escapes.  Cheesy, but theoretically
           useful if you want to, say, incorporate externally-provided HTML into a page you're  generating,  and
           are worried that the HTML might contain undesirable markup.

   <b>Vanilla</b>
       new [PRINTABLE]
           <u>Class</u> <u>method.</u>  Create a new HTML output stream.

           The  PRINTABLE  may  be  a  FileHandle,  a glob reference, or any object that responds to a "print()"
           message.  If no PRINTABLE is given, does a <b>select()</b> and uses that.

       auto_escape [NAME|SUBREF]
           <u>Instance</u> <u>method.</u>  Set the auto-escape function for this HTML stream.

           If the argument is a subroutine reference SUBREF, then that subroutine will be  used.   Declare  such
           subroutines like this:

               sub my_escape {
                   my $text = shift;     # it's passed in the first argument
                   ...
                   $text;
               }

           If  a textual NAME is given, then one of the appropriate built-in functions is used.  Possible values
           are:

           ALL Default for HTML::Stream objects.  This escapes angle brackets,  ampersands,  double-quotes,  and
               8-bit characters.  8-bit characters are escaped using decimal entity codes (like "#123").

           LATIN_1
               Like  "ALL",  but  uses  Latin-1  entity names (like "ccedil") instead of decimal entity codes to
               escape characters.  This makes the HTML more readable but it is currently not advised, as "older"
               browsers (like Netscape 2.0) do not recognize many of the ISO-8859-1 entity names (like "deg").

               <b>Warning:</b> If you specify this option, you'll find that it attempts to "require" <b>HTML::Entities</b>  at
               run  time.  That's because I didn't want to <u>force</u> you to have that module just to use the rest of
               HTML::Stream.  To pick up problems at compile time, you are advised to say:

                   use HTML::Stream;
                   use HTML::Entities;

               in your source code.

           NON_ENT
               Like "ALL", except that ampersands (&amp;) are <u>not</u> escaped.  This allows you  to  use  &amp;-entities  in
               your text strings, while having everything else safely escaped:

                   output $HTML "If A is an acute angle, then A &gt; 90&amp;deg;";

           Returns  the  previously-installed  function, in the manner of "select()".  No arguments just returns
           the currently-installed function.

       auto_format ONOFF
           <u>Instance</u> <u>method.</u>  Set the auto-formatting characteristics for this HTML stream.  Currently,  all  you
           can  do  is  supply a single defined boolean argument, which turns auto-formatting ON (1) or OFF (0).
           The self object is returned.

           Please use no other values; they are reserved for future use.

       comment COMMENT
           <u>Instance</u> <u>method.</u>  Output an HTML comment.  As of 1.29, a newline is automatically appended.

       ent ENTITY
           <u>Instance</u> <u>method.</u>  Output an HTML entity.  For example, here's how you'd output a non-breaking space:

                 $html-&gt;ent('nbsp');

           You may abbreviate this method name as "e":

                 $html-&gt;e('nbsp');

           <b>Warning:</b> this function assumes that the entity argument is legal.

       io  Return the underlying output handle for this HTML stream.  All you can depend upon is that it is some
           kind of object which responds to a <b>print()</b> message:

               $HTML-&gt;io-&gt;print("This is not auto-escaped or nuthin!");

       nl [COUNT]
           <u>Instance</u> <u>method.</u>  Output COUNT newlines.  If undefined, COUNT defaults to 1.

       tag TAGNAME [, PARAM=&gt;VALUE, ...]
           <u>Instance</u> <u>method.</u>  Output a tag.  Returns the self object, to allow method chaining.  You can say "_A"
           instead of "/A", if you're into barewords.

       text TEXT...
           <u>Instance</u> <u>method.</u>  Output some text.  You may abbreviate this method name as "t":

                 $html-&gt;t('Hi there, ', $yournamehere, '!');

           Returns the self object, to allow method chaining.

       text_nbsp TEXT...
           <u>Instance</u> <u>method.</u>  Output some text, but with all spaces output as non-breaking-space characters:

                 $html-&gt;t("To list your home directory, type: ")
                      -&gt;text_nbsp("ls -l ~yourname.")

           Returns the self object, to allow method chaining.

   <b>Strawberry</b>
       output ITEM,...,ITEM
           <u>Instance</u> <u>method.</u>  Go through the items.  If an item is an arrayref, treat it like the array  argument
           to  <b>html_tag()</b>  and  output  the result.  If an item is a text string, escape the text and output the
           result.  Like this:

                output $HTML [A, HREF=&gt;$url], "Here's my $caption!", [_A];

   <b>Chocolate</b>
       accept_tag TAG
           <u>Class</u> <u>method.</u>  Declares that the tag is to be accepted as valid HTML  (if  it  isn't  already).   For
           example, this...

                # Make sure methods MARQUEE and _MARQUEE are compiled on demand:
                HTML::Stream-&gt;accept_tag('MARQUEE');

           ...gives  the Chocolate Interface permission to create (via AUTOLOAD) definitions for the MARQUEE and
           _MARQUEE methods, so you can then say:

                $HTML -&gt; MARQUEE -&gt; t("Hi!") -&gt; _MARQUEE;

           If you want to set the default attribute of the tag as well, you can do so via the  <b>set_tag()</b>  method
           instead; it will effectively do an <b>accept_tag()</b> as well.

                # Make sure methods MARQUEE and _MARQUEE are compiled on demand,
                #   *and*, set the characteristics of that tag.
                HTML::Stream-&gt;set_tag('MARQUEE', Newlines=&gt;9);

       private_tags
           <u>Instance</u>  <u>method.</u>   Normally,  HTML  streams  use a reference to a global table of tag information to
           determine how to do such things as auto-formatting, and modifications made to that table by "set_tag"
           will affect everyone.

           However, if you want an HTML stream to have a private copy of that table to munge with, just send  it
           this message after creating it.  Like this:

               my $HTML = new HTML::Stream \*STDOUT;
               $HTML-&gt;private_tags;

           Then, you can say stuff like:

               $HTML-&gt;set_tag('PRE',   Newlines=&gt;0);
               $HTML-&gt;set_tag('BLINK', Newlines=&gt;9);

           And  it  won't  affect  anyone else's <u>auto-formatting</u> (although they will possibly be able to use the
           BLINK tag method without a fatal exception ":-(" ).

           Returns the self object.

       set_tag TAG, [TAGINFO...]
           <u>Class/instance</u> <u>method.</u>  Accept the given TAG in the Chocolate Interface, and (if  TAGINFO  is  given)
           alter its characteristics when being output.

           •   <b>If</b>  <b>invoked</b>  <b>as</b>  <b>a</b>  <b>class</b>  <b>method,</b> this alters the "master tag table", and allows a new tag to be
               supported via an autoloaded method:

                    HTML::Stream-&gt;set_tag('MARQUEE', Newlines=&gt;9);

               Once you do this, <u>all</u> HTML streams you open from then on will allow that tag to be output in  the
               chocolate interface.

           •   <b>If</b>  <b>invoked</b>  <b>as</b>  <b>an</b>  <b>instance</b> <b>method,</b> this alters the "tag table" referenced by that HTML stream,
               usually for the purpose of affecting things like the auto-formatting on that HTML stream.

               <b>Warning:</b> by default, an HTML stream just references the "master tag table"  (this  makes  "new()"
               more efficient), so <u>by</u> <u>default,</u> <u>the</u> <u>instance</u> <u>method</u> <u>will</u> <u>behave</u> <u>exactly</u> <u>like</u> <u>the</u> <u>class</u> <u>method.</u>

                    my $HTML = new HTML::Stream \*STDOUT;
                    $HTML-&gt;set_tag('BLINK', Newlines=&gt;0);  # changes it for others!

               If you want to diddle with <u>one</u> stream's auto-formatting <u>only,</u> you'll need to give that stream its
               own <u>private</u> tag table.  Like this:

                    my $HTML = new HTML::Stream \*STDOUT;
                    $HTML-&gt;private_tags;
                    $HTML-&gt;set_tag('BLINK', Newlines=&gt;0);  # doesn't affect other streams

               <b>Note:</b>  this  will still force an default entry for BLINK in the <u>master</u> tag table: otherwise, we'd
               never know that it was legal to AUTOLOAD a BLINK  method.    However,  it  will  only  alter  the
               <u>characteristics</u> of the BLINK tag (like auto-formatting) in the <u>object's</u> tag table.

           The TAGINFO, if given, is a set of key=&gt;value pairs with the following possible keys:

           Newlines
               Assumed  to  be  a  number  which encodes how newlines are to be output before/after a tag.   The
               value is the logical OR (or sum) of a set of flags:

                    0x01    newline before &lt;TAG&gt;         .&lt;TAG&gt;.     .&lt;/TAG&gt;.
                    0x02    newline after &lt;TAG&gt;          |     |     |      |
                    0x04    newline before &lt;/TAG&gt;        1     2     4      8
                    0x08    newline after &lt;/TAG&gt;

               Hence, to output BLINK environments which are preceded/followed by newlines:

                    set_tag HTML::Stream 'BLINK', Newlines=&gt;9;

           Returns the self object on success.

       tags
           <u>Class/instance</u> <u>method.</u>  Returns an unsorted list of all tags in the  class/instance  tag  table  (see
           "set_tag" for class/instance method differences).

</pre><h4><b>SUBCLASSES</b></h4><pre>
   <b>HTML::Stream::Latin1</b>
       A  small,  public  package for outputting Latin-1 markup.  Its default auto-escape function is "LATIN_1",
       which tries to output the mnemonic entity markup (e.g., "&amp;ccedil;") for ISO-8859-1 characters.

       So using HTML::Stream::Latin1 like this:

           use HTML::Stream;

           $HTML = new HTML::Stream::Latin1 \*STDOUT;
           output $HTML "\253A right angle is 90\260, \277No?\273\n";

       Prints this:

           &amp;laquo;A right angle is 90&amp;deg;, &amp;iquest;No?&amp;raquo;

       Instead of what HTML::Stream would print, which is this:

           &amp;#171;A right angle is 90&amp;#176;, &amp;#191;No?&amp;#187;

       <b>Warning:</b> a lot of Latin-1 HTML markup is not recognized by older browsers (e.g., Netscape 2.0).  Consider
       using HTML::Stream; it will output the decimal entities which currently seem to be more "portable".

       <b>Note:</b> using this class "requires" that you have HTML::Entities.

</pre><h4><b>PERFORMANCE</b></h4><pre>
       Slower than I'd like.  Both the <b>output()</b> method and the various "tag" methods seem to run about  5  times
       slower than the old just-hardcode-the-darn stuff approach.  That is, in general, this:

           ### Approach #1...
           tag  $HTML 'A', HREF=&gt;"$href";
           tag  $HTML 'IMG', SRC=&gt;"logo.gif", ALT=&gt;"LOGO";
           text $HTML $caption;
           tag  $HTML '_A';
           text $HTML $a_lot_of_text;

       And this:

           ### Approach #2...
           output $HTML [A, HREF=&gt;"$href"],
                        [IMG, SRC=&gt;"logo.gif", ALT=&gt;"LOGO"],
                        $caption,
                        [_A];
           output $HTML $a_lot_of_text;

       And this:

           ### Approach #3...
           $HTML -&gt; A(HREF=&gt;"$href")
                 -&gt; IMG(SRC=&gt;"logo.gif", ALT=&gt;"LOGO")
                 -&gt; t($caption)
                 -&gt; _A
                 -&gt; t($a_lot_of_text);

       Each run about 5x slower than this:

           ### Approach #4...
           print '&lt;A HREF="', html_escape($href), '&gt;',
                 '&lt;IMG SRC="logo.gif" ALT="LOGO"&gt;',
                 html_escape($caption),
                 '&lt;/A&gt;';
           print html_escape($a_lot_of_text);

       Of course, I'd much rather use any of first three <u>(especially</u> <u>#3)</u> if I had to get something done right in
       a hurry.  Or did you not notice the typo in approach #4?  ";-)"

       (BTW, thanks to Benchmark:: for allowing me to... er... benchmark stuff.)

</pre><h4><b>VERSION</b></h4><pre>
       $Id: Stream.pm,v 1.60 2008/08/06 dstaal Exp $

</pre><h4><b>CHANGE</b> <b>LOG</b></h4><pre>
       Version 1.60   (2008/08/06)
           Fixed up the tests some more, updated changelog.  (Which I'd forgotten about...)

       Version 1.59   (2008/06/01)
           Better tests, better Meta.yml.

       Version 1.58   (2008/05/28)
           Another attempt at cleanup, as well expanding the Meta.yml file.

       Version 1.57   (2008/05/28)
           Cleaned up the Mac-specific files that were getting created in the archive.

       Version 1.56   (2008/05/27)
           Added  the  start  of  a  testing  suite.   In  the  process,  I found an error: HTML defines the tag
           'NOFRAMES', not 'NOFRAME'.  Both are currently in the tag list, but consider 'NOFRAME' depriciated.

           The test suite requires Test::More and Test::Output.

       Version 1.55   (2003/10/28)
           New maintainer: Daniel T. Staal.  No major changes in the code, except to complete the  tag  list  to
           HTML  4.01  specifications.  (With  the  exception  of  the  'S'  tag,  which  I want to test, and is
           depreciated anyway.  Note that the DOCTYPE  is  not  actually  a  HTML  tag,  and  is  not  currently
           included.)

       Version 1.54   (2001/08/20)
           The  terms-of-use  have  been  placed  in the distribution file "COPYING".  Also, small documentation
           tweaks were made.

       Version 1.51   (2001/08/16)
           No real changes to code; just improved documentation, and  removed  HTML::Entities  and  HTML::Parser
           from .<a href="file:/etc">/etc</a> at CPAN's request.

       Version 1.47   (2000/06/10)
           No real changes to code; just improved documentation.

       Version 1.45   (1999/02/09)
           Cleanup for Perl 5.005: removed duplicate typeglob assignments.

       Version 1.44   (1998/01/14)
           Win95 install (5.004) now works.  Added SYNOPSIS to POD.

       Version 1.41   (1998/01/02)
           Removed $&amp; for efficiency.  <u>Thanks,</u> <u>Andreas!</u>

           Added  support  for  OPTION,  and  default  now puts newlines after SELECT and /SELECT.  Also altered
           "TELEM" syntax to put newline after end-tags of list element tags  (like  /OPTION,  /LI,  etc.).   In
           theory,  this  change  could  produce  undesirable  results  for  folks who embed lists inside of PRE
           environments... however, that kind of stuff was done in the days before TABLEs; also, you can  always
           turn it off if you really need to.  <u>Thanks</u> <u>to</u> <u>John</u> <u>D</u> <u>Groenveld</u> <u>for</u> <u>these</u> <u>patches.</u>

           Added  <b>text_nbsp()</b>.   <u>Thanks</u>  <u>to</u>  <u>John</u> <u>D</u> <u>Groenveld</u> <u>for</u> <u>the</u> <u>patch.</u>  This method may also be invoked as
           <b>nbsp_text()</b> as in the original patch, but that's sort  of  a  private  tip-of-the-hat  to  the  patch
           author, and the synonym may go away in the future.

       Version 1.37   (1997/02/09)
           No real change; just trying to make CPAN.pm happier.

       Version 1.32   (1997/01/12)
           <b>NEW</b> <b>TOOL</b> <b>for</b> <b>generating</b> <b>Perl</b> <b>code</b> <b>which</b> <b>uses</b> <b>HTML::Stream!</b>  Check your toolkit for <b>html2perlstream</b>.

           Added built-in support for escaping 8-bit characters.

           Added  "LATIN_1"  auto-escape,  which uses HTML::Entities to generate mnemonic entities.  This is now
           the default method for HTML::Stream::Latin1.

           Added "auto_format()," so you can now turn auto-formatting off/on.

           Added "private_tags()", so it is now possible for HTML streams to each have their own "private"  copy
           of the %Tags table, for use by "set_tag()".

           Added "set_tag()".  The tags tables may now be modified dynamically so as to change how formatting is
           done on-the-fly.  This will hopefully not compromise the efficiency of the chocolate interface (until
           now,  the formatting was compiled into the method itself), and <u>will</u> add greater flexibility for more-
           complex programs.

           Added POD documentation for all subroutines in the public interface.

       Version 1.29   (1996/12/10)
           Added terminating newline to <b>comment()</b>.  <u>Thanks</u> <u>to</u> <u>John</u> <u>D</u> <u>Groenveld</u> <u>for</u> <u>the</u> <u>suggestion</u> <u>and</u> <u>the</u> <u>patch.</u>

       Version 1.27   (1996/12/10)
           Added built-in HTML::Stream::Latin1, which does a very simple encoding of all characters above  ASCII
           127.

           Fixed  bug  in  <b>accept_tag()</b>, where 'my' variable was shadowing argument.  <u>Thanks</u> <u>to</u> <u>John</u> <u>D</u> <u>Groenveld</u>
           <u>for</u> <u>the</u> <u>bug</u> <u>report</u> <u>and</u> <u>the</u> <u>patch.</u>

       Version 1.26   (1996/09/27)
           Start of history.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This program is free software.  You may copy or redistribute it under the same terms as Perl itself.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Warmest thanks to...

           Eryq                   For writing the original version of this module.

           John Buckman           For suggesting that I write an "html2perlstream",
                                  and inspiring me to look at supporting Latin-1.
           Tony Cebzanov          For suggesting that I write an "html2perlstream"
           John D Groenveld       Bug reports, patches, and suggestions
           B. K. Oxley (binkley)  For suggesting the support of "writing to strings"
                                  which became the "printable" interface.

</pre><h4><b>AUTHOR</b></h4><pre>
       Daniel T. Staal (<u><a href="mailto:DStaal@usa.net">DStaal@usa.net</a></u>).

       Enjoy.  Yell if it breaks.

perl v5.34.0                                       2022-06-14                                  <u>HTML::<a href="../man3pm/Stream.3pm.html">Stream</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>