<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>avr_stdio - <stdio.h>: Standard IO facilities</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/avr-libc">avr-libc_2.2.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       avr_stdio - &lt;stdio.h&gt;: Standard IO facilities

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Macros</b>
       #define <b>stdin</b>   (__iob[0])
       #define <b>stdout</b>   (__iob[1])
       #define <b>stderr</b>   (__iob[2])
       #define <b>EOF</b>   (-1)
       #define <b>fdev_set_udata</b>(stream,  u)   do { (stream)-&gt;udata = u; } <a href="../man0/while.0.html">while</a>(0)
       #define <b>fdev_get_udata</b>(stream)   ((stream)-&gt;udata)
       #define <b>fdev_setup_stream</b>(stream,  put,  get,  rwflag)
       #define <b>_FDEV_SETUP_READ</b>   __SRD
       #define <b>_FDEV_SETUP_WRITE</b>   __SWR
       #define <b>_FDEV_SETUP_RW</b>   (__SRD|__SWR)
       #define <b>_FDEV_ERR</b>   (-1)
       #define <b>_FDEV_EOF</b>   (-2)
       #define <b>FDEV_SETUP_STREAM</b>(put,  get,  rwflag)
       #define <b>fdev_close</b>()
       #define <b>putc</b>(__c,  __stream)   <b>fputc</b>(__c, __stream)
       #define <b>putchar</b>(__c)   <b>fputc</b>(__c, <b>stdout</b>)
       #define <b>getc</b>(__stream)   <b>fgetc</b>(__stream)
       #define <b>getchar</b>()   <b>fgetc</b>(<b>stdin</b>)

   <b>Typedefs</b>
       typedef struct __file <b>FILE</b>

   <b>Functions</b>
       int <b>fclose</b> (<b>FILE</b> *__stream)
       int <b>vfprintf</b> (<b>FILE</b> *__stream, const char *__fmt, va_list __ap)
       int <b>vfprintf_P</b> (<b>FILE</b> *__stream, const char *__fmt, va_list __ap)
       int <b>fputc</b> (int __c, <b>FILE</b> *__stream)
       int <b>printf</b> (const char *__fmt,...)
       int <b>printf_P</b> (const char *__fmt,...)
       int <b>vprintf</b> (const char *__fmt, va_list __ap)
       int <b>sprintf</b> (char *__s, const char *__fmt,...)
       int <b>sprintf_P</b> (char *__s, const char *__fmt,...)
       int <b>snprintf</b> (char *__s, size_t __n, const char *__fmt,...)
       int <b>snprintf_P</b> (char *__s, size_t __n, const char *__fmt,...)
       int <b>vsprintf</b> (char *__s, const char *__fmt, va_list ap)
       int <b>vsprintf_P</b> (char *__s, const char *__fmt, va_list ap)
       int <b>vsnprintf</b> (char *__s, size_t __n, const char *__fmt, va_list ap)
       int <b>vsnprintf_P</b> (char *__s, size_t __n, const char *__fmt, va_list ap)
       int <b>fprintf</b> (<b>FILE</b> *__stream, const char *__fmt,...)
       int <b>fprintf_P</b> (<b>FILE</b> *__stream, const char *__fmt,...)
       int <b>fputs</b> (const char *__str, <b>FILE</b> *__stream)
       int <b>fputs_P</b> (const char *__str, <b>FILE</b> *__stream)
       int <b>puts</b> (const char *__str)
       int <b>puts_P</b> (const char *__str)
       size_t <b>fwrite</b> (const void *__ptr, size_t __size, size_t __nmemb, <b>FILE</b> *__stream)
       int <b>fgetc</b> (<b>FILE</b> *__stream)
       int <b>ungetc</b> (int __c, <b>FILE</b> *__stream)
       char * <b>fgets</b> (char *__str, int __size, <b>FILE</b> *__stream)
       char * <b>gets</b> (char *__str)
       size_t <b>fread</b> (void *__ptr, size_t __size, size_t __nmemb, <b>FILE</b> *__stream)
       void <b>clearerr</b> (<b>FILE</b> *__stream)
       int <b>feof</b> (<b>FILE</b> *__stream)
       int <b>ferror</b> (<b>FILE</b> *__stream)
       int <b>vfscanf</b> (<b>FILE</b> *__stream, const char *__fmt, va_list __ap)
       int <b>vfscanf_P</b> (<b>FILE</b> *__stream, const char *__fmt, va_list __ap)
       int <b>fscanf</b> (<b>FILE</b> *__stream, const char *__fmt,...)
       int <b>fscanf_P</b> (<b>FILE</b> *__stream, const char *__fmt,...)
       int <b>scanf</b> (const char *__fmt,...)
       int <b>scanf_P</b> (const char *__fmt,...)
       int <b>vscanf</b> (const char *__fmt, va_list __ap)
       int <b>sscanf</b> (const char *__buf, const char *__fmt,...)
       int <b>sscanf_P</b> (const char *__buf, const char *__fmt,...)
       int <b>fflush</b> (<b>FILE</b> *stream)
       <b>FILE</b> * <b>fdevopen</b> (int(*put)(char, <b>FILE</b> *), int(*get)(<b>FILE</b> *))

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

   <b>Introduction</b> <b>to</b> <b>the</b> <b>Standard</b> <b>IO</b> <b>facilities</b>
       This file declares the standard IO facilities that are implemented in AVR-LibC. Due to the nature of the
       underlying hardware, only a limited subset of standard IO is implemented. There is no actual file
       implementation available, so only device IO can be performed. Since there's no operating system, the
       application needs to provide enough details about their devices in order to make them usable by the
       standard IO facilities.

       Due to space constraints, some functionality has not been implemented at all (like some of the printf
       conversions that have been left out). Nevertheless, potential users of this implementation should be
       warned: the printf and scanf families of functions, although usually associated with presumably simple
       things like the famous 'Hello, world!' program, are actually fairly complex which causes their inclusion
       to eat up a fair amount of code space. Also, they are not fast due to the nature of interpreting the
       format string at run-time. Whenever possible, resorting to the (sometimes non-standard) predetermined
       conversion facilities that are offered by AVR-LibC will usually cost much less in terms of speed and code
       size.

   <b>Tunable</b> <b>options</b> <b>for</b> <b>code</b> <b>size</b> <b>vs.</b> <b>feature</b> <b>set</b>
       In order to allow programmers a code size vs. functionality tradeoff, the function <b>vfprintf()</b> which is
       the heart of the printf family can be selected in different flavours using linker options. See the
       documentation of <b>vfprintf()</b> for a detailed description. The same applies to <b>vfscanf()</b> and the scanf
       family of functions.

   <b>Outline</b> <b>of</b> <b>the</b> <b>chosen</b> <b>API</b>
       The standard streams stdin, stdout, and stderr are provided, but contrary to the C standard, since AVR-
       LibC has no knowledge about applicable devices, these streams are not already pre-initialized at
       application startup. Also, since there is no notion of 'file' whatsoever to AVR-LibC, there is no
       function fopen() that could be used to associate a stream to some device. (See <b>note</b> <b>1</b>.) Instead, the
       function <b>fdevopen()</b> <b>is</b> <b>provided</b> <b>to</b> <b>associate</b> <b>a</b> <b>stream</b> <b>to</b> <b>a</b> <b>device,</b> <b>where</b> <b>the</b> <b>device</b> <b>needs</b> <b>to</b> <b>provide</b> <b>a</b>
       <b>function</b> <b>to</b> <b>send</b> <b>a</b> <b>character,</b> <b>to</b> <b>receive</b> <b>a</b> <b>character,</b> <b>or</b> <b>both.</b> <b>There</b> <b>is</b> <b>no</b> <b>differentiation</b> <b>between</b> <b>'text'</b>
       <b>and</b> <b>'binary'</b> <b>streams</b> <b>inside</b> <b>AVR-LibC.</b> <b>Character</b> <b>\n</b> <b>is</b> <b>sent</b> <b>literally</b> <b>down</b> <b>to</b> <b>the</b> <b>device's</b> <b>put()</b> <b>function.</b>
       <b>If</b> <b>the</b> <b>device</b> <b>requires</b> <b>a</b> <b>carriage</b> <b>return</b> <b>(\r)</b> <b>character</b> <b>to</b> <b>be</b> <b>sent</b> <b>before</b> <b>the</b> <b>linefeed,</b> <b>its</b> <b>put()</b> <b>routine</b>
       <b>must</b> <b>implement</b> <b>this</b> <b>(see</b> <b>note</b> <b>2).</b>

       As an alternative method to <b>fdevopen()</b>, the macro <b>fdev_setup_stream()</b> might be used to setup a user-
       supplied FILE structure.

       It should be noted that the automatic conversion of a newline character into a carriage return - newline
       sequence breaks binary transfers. If binary transfers are desired, no automatic conversion should be
       performed, but instead any string that aims to issue a CR-LF sequence must use '\r\n' explicitly.

       For convenience, the first call to <b>fdevopen()</b> <b>that</b> <b>opens</b> <b>a</b> <b>stream</b> <b>for</b> <b>reading</b> <b>will</b> <b>cause</b> <b>the</b> <b>resulting</b>
       <b>stream</b> <b>to</b> <b>be</b> <b>aliased</b> <b>to</b> <b>stdin.</b> <b>Likewise,</b> <b>the</b> <b>first</b> <b>call</b> <b>to</b> <b>fdevopen()</b> <b>that</b> <b>opens</b> <b>a</b> <b>stream</b> <b>for</b> <b>writing</b>
       <b>will</b> <b>cause</b> <b>the</b> <b>resulting</b> <b>stream</b> <b>to</b> <b>be</b> <b>aliased</b> <b>to</b> <b>both,</b> <b>stdout,</b> <b>and</b> <b>stderr.</b> <b>Thus,</b> <b>if</b> <b>the</b> <b>open</b> <b>was</b> <b>done</b>
       <b>with</b> <b>both,</b> <b>read</b> <b>and</b> <b>write</b> <b>intent,</b> <b>all</b> <b>three</b> <b>standard</b> <b>streams</b> <b>will</b> <b>be</b> <b>identical.</b> <b>Note</b> <b>that</b> <b>these</b> <b>aliases</b>
       <b>are</b> <b>indistinguishable</b> <b>from</b> <b>each</b> <b>other,</b> <b>thus</b> <b>calling</b> <b>fclose()</b> <b>on</b> <b>such</b> <b>a</b> <b>stream</b> <b>will</b> <b>also</b> <b>effectively</b> <b>close</b>
       <b>all</b> <b>of</b> <b>its</b> <b>aliases</b> <b>(note</b> <b>3).</b>

       It is possible to tie additional user data to a stream, using <b>fdev_set_udata()</b>. The backend put and get
       functions can then extract this user data using <b>fdev_get_udata()</b>, and act appropriately. For example, a
       single put function could be used to talk to two different UARTs that way, or the put and get functions
       could keep internal state between calls there.

   <b>Format</b> <b>strings</b> <b>in</b> <b>flash</b> <b>ROM</b>
       All the printf and scanf family functions come in two flavours: the standard name, where the format
       string is expected to be in SRAM, as well as a version with the suffix '_P' where the format string is
       expected to reside in the flash ROM. The macro <b>PSTR</b> (explained in <b>&lt;avr/pgmspace.h&gt;:</b> <b>Program</b> <b>Space</b>
       <b>Utilities</b>) becomes very handy for declaring these format strings.

   <b>Running</b> <b>stdio</b> <b>without</b> <b>malloc()</b>
       By default, <b>fdevopen()</b> requires malloc(). As this is often not desired in the limited environment of a
       microcontroller, an alternative option is provided to run completely without malloc().

       The macro <b>fdev_setup_stream()</b> is provided to prepare a user-supplied FILE buffer for operation with
       stdio.

   <b>Example</b>
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

       static int uart_putchar(char c, FILE *stream);

       static FILE mystdout = FDEV_SETUP_STREAM(uart_putchar, NULL,
                                                _FDEV_SETUP_WRITE);

       static int
       uart_putchar(char c, FILE *stream)
       {

         if (c == '\n')
           uart_putchar('\r', stream);
         loop_until_bit_is_set(UCSRA, UDRE);
         UDR = c;
         return 0;
       }

       int
       main(void)
       {
         init_uart();
         stdout = &amp;mystdout;
         printf("Hello, world!\n");

         return 0;
       }

       This example uses the initializer form <b>FDEV_SETUP_STREAM()</b> rather than the function-like
       <b>fdev_setup_stream()</b>, so all data initialization happens during C start-up.

       If streams initialized that way are no longer needed, they can be destroyed by first calling the macro
       <b>fdev_close()</b>, and then destroying the object itself. No call to <b>fclose()</b> should be issued for these
       streams. While calling <b>fclose()</b> itself is harmless, it will cause an undefined reference to free() and
       thus cause the linker to link the malloc module into the application.

   <b>Notes</b>
       <b>Note</b> <b>1:</b>
           It  might  have  been  possible to implement a device abstraction that is compatible with fopen() but
           since this would have required to parse a string, and to take all the information needed  either  out
           of this string, or out of an additional table that would need to be provided by the application, this
           approach was not taken.

       <b>Note</b> <b>2:</b>
           This  basically  follows the Unix approach: if a device such as a terminal needs special handling, it
           is in the domain of the terminal device driver to provide this functionality. Thus, a simple function
           suitable as put() for <b>fdevopen()</b> <b>that</b> <b>talks</b> <b>to</b> <b>a</b> <b>UART</b> <b>interface</b> <b>might</b> <b>look</b> <b>like</b> <b>this:</b>

       int
       uart_putchar(char c, FILE *stream)
       {

         if (c == '\n')
           uart_putchar('\r', stream);
         loop_until_bit_is_set(UCSRA, UDRE);
         UDR = c;
         return 0;
       }

       <b>Note</b> <b>3:</b>
           This implementation has been chosen because the cost of maintaining an alias is considerably  smaller
           than the cost of maintaining full copies of each stream. Yet, providing an implementation that offers
           the  complete set of standard streams was deemed to be useful. Not only that writing <b>printf()</b> <b>instead</b>
           <b>of</b> <b>fprintf(mystream,</b> <b>...)</b> <b>saves</b> <b>typing</b> <b>work,</b> <b>but</b> <b>since</b> <b>avr-gcc</b> <b>needs</b> <b>to</b> <b>resort</b> <b>to</b> <b>pass</b> <b>all</b>  <b>arguments</b>
           <b>of</b> <b>variadic</b> <b>functions</b> <b>on</b> <b>the</b> <b>stack</b> <b>(as</b> <b>opposed</b> <b>to</b> <b>passing</b> <b>them</b> <b>in</b> <b>registers</b> <b>for</b> <b>functions</b> <b>that</b> <b>take</b> <b>a</b>
           <b>fixed</b>  <b>number</b> <b>of</b> <b>parameters),</b> <b>the</b> <b>ability</b> <b>to</b> <b>pass</b> <b>one</b> <b>parameter</b> <b>less</b> <b>by</b> <b>implying</b> <b>stdin</b> <b>or</b> <b>stdout</b> <b>will</b>
           <b>also</b> <b>save</b> <b>some</b> <b>execution</b> <b>time.</b>

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>_FDEV_EOF</b>   <b>(-2)</b>
       Return code for an end-of-file condition during device read.

       To be used in the get function of <b>fdevopen()</b>.

   <b>#define</b> <b>_FDEV_ERR</b>   <b>(-1)</b>
       Return code for an error condition during device read.

       To be used in the get function of <b>fdevopen()</b>.

   <b>#define</b> <b>_FDEV_SETUP_READ</b>   <b>__SRD</b>
       <b>fdev_setup_stream()</b> with read intent

   <b>#define</b> <b>_FDEV_SETUP_RW</b>   <b>(__SRD|__SWR)</b>
       <b>fdev_setup_stream()</b> with read/write intent

   <b>#define</b> <b>_FDEV_SETUP_WRITE</b>   <b>__SWR</b>
       <b>fdev_setup_stream()</b> with write intent

   <b>#define</b> <b>EOF</b>   <b>(-1)</b>
       EOF declares the value that is returned by various standard IO functions in case of an error.  Since  the
       AVR  platform (currently) doesn't contain an abstraction for actual files, its origin as 'end of file' is
       somewhat meaningless here.

   <b>#define</b> <b>fdev_close()</b>
       This macro frees up any library resources that might be associated with stream. It should  be  called  if
       stream is no longer needed, right before the application is going to destroy the stream object itself.

       (Currently, this macro evaluates to nothing, but this might change in future versions of the library.)

   <b>#define</b> <b>fdev_get_udata(stream)</b>   <b>((stream)-&gt;udata)</b>
       This macro retrieves a pointer to user defined data from a FILE stream object.

   <b>#define</b> <b>fdev_set_udata(stream,</b> <b>u)</b>   <b>do</b> <b>{</b> <b>(stream)-&gt;udata</b> <b>=</b> <b>u;</b> <b>}</b> <b><a href="../man0/while.0.html">while</a>(0)</b>
       This macro inserts a pointer to user defined data into a FILE stream object.

       The  user  data  can be useful for tracking state in the put and get functions supplied to the <b>fdevopen()</b>
       function.

   <b>#define</b> <b>FDEV_SETUP_STREAM(put,</b> <b>get,</b> <b>rwflag)</b>
       Initializer for a user-supplied stdio stream. This macro acts similar to <b>fdev_setup_stream()</b>, but  it  is
       to be used as the initializer of a variable of type FILE.

       The remaining arguments are to be used as explained in <b>fdev_setup_stream()</b>.

   <b>#define</b> <b>fdev_setup_stream(stream,</b> <b>put,</b> <b>get,</b> <b>rwflag)</b>
       Setup a user-supplied buffer as an stdio stream. This macro takes a user-supplied buffer stream, and sets
       it  up  as a stream that is valid for stdio operations, similar to one that has been obtained dynamically
       from <b>fdevopen()</b>. The buffer to setup must be of type <b>FILE</b>.

       The arguments put and get are identical to those that need to be passed to <b>fdevopen()</b>.

       The rwflag argument can take one of the values <b>_FDEV_SETUP_READ</b>,  <b>_FDEV_SETUP_WRITE</b>,  or  <b>_FDEV_SETUP_RW</b>,
       for read, write, or read/write intent, respectively.

       <b>Note</b>
           No  assignments to the standard streams will be performed by <b>fdev_setup_stream()</b>. If standard streams
           are to be used, these need to be assigned by the user. See also under <b>Running</b> <b>stdio</b> <b>without</b> <b>malloc()</b>.

   <b>#define</b> <b>getc(__stream)</b>   <b>fgetc(__stream)</b>
       The macro getc used to be a 'fast' macro implementation with a functionality identical  to  <b>fgetc()</b>.  For
       space constraints, in AVR-LibC, it is just an alias for fgetc.

   <b>#define</b> <b>getchar(void)</b>   <b>fgetc(stdin)</b>
       The macro getchar reads a character from stdin. Return values and error handling is identical to <b>fgetc()</b>.

   <b>#define</b> <b>putc(__c,</b> <b>__stream)</b>   <b>fputc(__c,</b> <b>__stream)</b>
       The  macro  putc  used to be a 'fast' macro implementation with a functionality identical to <b>fputc()</b>. For
       space constraints, in AVR-LibC, it is just an alias for fputc.

   <b>#define</b> <b>putchar(__c)</b>   <b>fputc(__c,</b> <b>stdout)</b>
       The macro putchar sends character c to stdout.

   <b>#define</b> <b>stderr</b>   <b>(__iob[2])</b>
       Stream destined for error output. Unless specifically assigned, identical to stdout.

       If stderr should point to another stream, the result of another <b>fdevopen()</b> <b>must</b> <b>be</b> <b>explicitly</b> <b>assigned</b> <b>to</b>
       <b>it</b> <b>without</b> <b>closing</b> <b>the</b> <b>previous</b> <b>stderr</b> <b>(since</b> <b>this</b> <b>would</b> <b>also</b> <b>close</b> <b>stdout).</b>

   <b>#define</b> <b>stdin</b>   <b>(__iob[0])</b>
       Stream that will be used as an input stream  by  the  simplified  functions  that  don't  take  a  stream
       argument.

       The first stream opened with read intent using <b>fdevopen()</b> <b>will</b> <b>be</b> <b>assigned</b> <b>to</b> <b>stdin.</b>

   <b>#define</b> <b>stdout</b>   <b>(__iob[1])</b>
       Stream  that  will  be  used  as  an  output  stream by the simplified functions that don't take a stream
       argument.

       The first stream opened with write intent using <b>fdevopen()</b> <b>will</b> <b>be</b> <b>assigned</b> <b>to</b> <b>both,</b> <b>stdin,</b> <b>and</b> <b>stderr.</b>

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>struct</b> <b>__file</b> <b>FILE</b>
       FILE is the opaque structure that is passed around between the various standard IO functions.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>clearerr</b> <b>(FILE</b> <b>*</b> <b>__stream)</b> <b>[extern]</b>
       Clear the error and end-of-file flags of stream.

   <b>int</b> <b>fclose</b> <b>(FILE</b> <b>*</b> <b>__stream)</b> <b>[extern]</b>
       This function closes stream, and disallows and further IO to and from it.

       When using <b>fdevopen()</b> to setup the stream, a call to <b>fclose()</b> is needed in order  to  free  the  internal
       resources allocated.

       If the stream has been set up using <b>fdev_setup_stream()</b> or <b>FDEV_SETUP_STREAM()</b>, use <b>fdev_close()</b> instead.

       It currently always returns 0 (for success).

   <b>FILE</b> <b>*</b> <b>fdevopen</b> <b>(int(*)(char,</b> <b>FILE</b> <b>*)</b> <b>put,</b> <b>int(*)(FILE</b> <b>*)</b> <b>get)</b>
       This function is a replacement for fopen().

       It  opens  a  stream  for  a  device  where  the actual device implementation needs to be provided by the
       application. If successful, a pointer to the structure for the opened stream is returned. Reasons  for  a
       possible  failure  currently  include  that neither the put nor the get argument have been provided, thus
       attempting to open a stream with no IO intent at all, or that insufficient dynamic memory is available to
       establish a new stream.

       If the put function pointer is provided, the stream is opened with write intent. The function  passed  as
       put  shall  take two arguments, the first a character to write to the device, and the second a pointer to
       FILE, and shall return 0 if the output was successful, and a nonzero value if the character could not  be
       sent to the device.

       If  the  get  function pointer is provided, the stream is opened with read intent. The function passed as
       get shall take a pointer to FILE as its single argument, and return one character from the device, passed
       as an int type. If an error occurs when trying to read from the device, it shall return <b>_FDEV_ERR.</b> <b>If</b>  <b>an</b>
       <b>end-of-file</b> <b>condition</b> <b>was</b> <b>reached</b> <b>while</b> <b>reading</b> <b>from</b> <b>the</b> <b>device,</b> <b>_FDEV_EOF</b> <b>shall</b> <b>be</b> <b>returned.</b>

       If both functions are provided, the stream is opened with read and write intent.

       The first stream opened with read intent is assigned to stdin, and the first one opened with write intent
       is assigned to both, stdout and stderr.

       <b>fdevopen()</b> uses <b>calloc()</b> (und thus malloc()) in order to allocate the storage for the new stream.

       <b>Note</b>
           If  the macro __STDIO_FDEVOPEN_COMPAT_12 is declared before including &lt;<b>stdio.h</b>&gt;, a function prototype
           for <b>fdevopen()</b> will be chosen that is backwards compatible with AVR-LibC version 1.2 and before. This
           is solely intented for providing a simple migration path without the need to immediately  change  all
           source code. Do not use for new code.

   <b>int</b> <b>feof</b> <b>(FILE</b> <b>*</b> <b>__stream)</b> <b>[extern]</b>
       Test the end-of-file flag of stream. This flag can only be cleared by a call to <b>clearerr()</b>.

   <b>int</b> <b>ferror</b> <b>(FILE</b> <b>*</b> <b>__stream)</b> <b>[extern]</b>
       Test the error flag of stream. This flag can only be cleared by a call to <b>clearerr()</b>.

   <b>int</b> <b>fflush</b> <b>(FILE</b> <b>*</b> <b>stream)</b> <b>[extern]</b>
       Flush stream.

       This  is  a null operation provided for source-code compatibility only, as the standard IO implementation
       currently does not perform any buffering.

   <b>int</b> <b>fgetc</b> <b>(FILE</b> <b>*</b> <b>__stream)</b> <b>[extern]</b>
       The function fgetc reads a character from stream. It returns the character, or EOF  in  case  end-of-file
       was encountered or an error occurred. The routines <b>feof()</b> or <b>ferror()</b> must be used to distinguish between
       both situations.

   <b>char</b> <b>*</b> <b>fgets</b> <b>(char</b> <b>*</b> <b>__str,</b> <b>int</b> <b>__size,</b> <b>FILE</b> <b>*</b> <b>__stream)</b> <b>[extern]</b>
       Read  at  most  size  -  1  bytes  from  stream, until a newline character was encountered, and store the
       characters in the buffer pointed to by str. Unless an error was encountered  while  reading,  the  string
       will then be terminated with a NUL character.

       If  an  error  was encountered, the function returns NULL and sets the error flag of stream, which can be
       tested using <b>ferror()</b>. Otherwise, a pointer to the string will be returned.

   <b>int</b> <b>fprintf</b> <b>(FILE</b> <b>*</b> <b>__stream,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b>  <b>...)</b> <b>[extern]</b>
       The function fprintf performs formatted output to stream. See <b>vfprintf()</b> <b>for</b> <b>details.</b>

   <b>int</b> <b>fprintf_P</b> <b>(FILE</b> <b>*</b> <b>__stream,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b>  <b>...)</b> <b>[extern]</b>
       Variant of <b>fprintf()</b> <b>that</b> <b>uses</b> <b>a</b> <b>fmt</b> <b>string</b> <b>that</b> <b>resides</b> <b>in</b> <b>program</b> <b>memory.</b>

   <b>int</b> <b>fputc</b> <b>(int</b> <b>__c,</b> <b>FILE</b> <b>*</b> <b>__stream)</b> <b>[extern]</b>
       The function fputc sends the character c (though given as type int) to stream. It returns the  character,
       or EOF in case an error occurred.

   <b>int</b> <b>fputs</b> <b>(const</b> <b>char</b> <b>*</b> <b>__str,</b> <b>FILE</b> <b>*</b> <b>__stream)</b> <b>[extern]</b>
       Write the string pointed to by str to stream stream.

       Returns 0 on success and EOF on error.

   <b>int</b> <b>fputs_P</b> <b>(const</b> <b>char</b> <b>*</b> <b>__str,</b> <b>FILE</b> <b>*</b> <b>__stream)</b> <b>[extern]</b>
       Variant of <b>fputs()</b> where str resides in program memory.

   <b>size_t</b> <b>fread</b> <b>(void</b> <b>*</b> <b>__ptr,</b> <b>size_t</b> <b>__size,</b> <b>size_t</b> <b>__nmemb,</b> <b>FILE</b> <b>*</b> <b>__stream)</b> <b>[extern]</b>
       Read nmemb objects, size bytes each, from stream, to the buffer pointed to by ptr.

       Returns the number of objects successfully read, i. e. nmemb unless an input error occured or end-of-file
       was encountered. <b>feof()</b> and <b>ferror()</b> must be used to distinguish between these two conditions.

   <b>int</b> <b>fscanf</b> <b>(FILE</b> <b>*</b> <b>__stream,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b>  <b>...)</b> <b>[extern]</b>
       The function fscanf performs formatted input, reading the input data from stream.

       See <b>vfscanf()</b> for details.

   <b>int</b> <b>fscanf_P</b> <b>(FILE</b> <b>*</b> <b>__stream,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b>  <b>...)</b> <b>[extern]</b>
       Variant of <b>fscanf()</b> using a fmt string in program memory.

   <b>size_t</b> <b>fwrite</b> <b>(const</b> <b>void</b> <b>*</b> <b>__ptr,</b> <b>size_t</b> <b>__size,</b> <b>size_t</b> <b>__nmemb,</b> <b>FILE</b> <b>*</b> <b>__stream)</b> <b>[extern]</b>
       Write nmemb objects, size bytes each, to stream. The first byte of the first object is referenced by ptr.

       Returns the number of objects successfully written, i. e. nmemb unless an output error occured.

   <b>char</b> <b>*</b> <b>gets</b> <b>(char</b> <b>*</b> <b>__str)</b> <b>[extern]</b>
       Similar  to  <b>fgets()</b>  except that it will operate on stream stdin, and the trailing newline (if any) will
       not be stored in the string. It is the caller's responsibility to provide  enough  storage  to  hold  the
       characters read.

   <b>int</b> <b>printf</b> <b>(const</b> <b>char</b> <b>*</b> <b>__fmt,</b>  <b>...)</b> <b>[extern]</b>
       The function printf performs formatted output to stream stdout. See <b>vfprintf()</b> <b>for</b> <b>details.</b>

   <b>int</b> <b>printf_P</b> <b>(const</b> <b>char</b> <b>*</b> <b>__fmt,</b>  <b>...)</b> <b>[extern]</b>
       Variant of <b>printf()</b> <b>that</b> <b>uses</b> <b>a</b> <b>fmt</b> <b>string</b> <b>that</b> <b>resides</b> <b>in</b> <b>program</b> <b>memory.</b>

   <b>int</b> <b>puts</b> <b>(const</b> <b>char</b> <b>*</b> <b>__str)</b> <b>[extern]</b>
       Write the string pointed to by str, and a trailing newline character, to stdout.

   <b>int</b> <b>puts_P</b> <b>(const</b> <b>char</b> <b>*</b> <b>__str)</b> <b>[extern]</b>
       Variant of <b>puts()</b> where str resides in program memory.

   <b>int</b> <b>scanf</b> <b>(const</b> <b>char</b> <b>*</b> <b>__fmt,</b>  <b>...)</b> <b>[extern]</b>
       The function scanf performs formatted input from stream stdin.

       See <b>vfscanf()</b> for details.

   <b>int</b> <b>scanf_P</b> <b>(const</b> <b>char</b> <b>*</b> <b>__fmt,</b>  <b>...)</b> <b>[extern]</b>
       Variant of <b>scanf()</b> where fmt resides in program memory.

   <b>int</b> <b>snprintf</b> <b>(char</b> <b>*</b> <b>__s,</b> <b>size_t</b> <b>__n,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b>  <b>...)</b> <b>[extern]</b>
       Like  <b>sprintf(),</b>  <b>but</b>  <b>instead</b> <b>of</b> <b>assuming</b> <b>s</b> <b>to</b> <b>be</b> <b>of</b> <b>infinite</b> <b>size,</b> <b>no</b> <b>more</b> <b>than</b> <b>n</b> <b>characters</b> <b>(including</b>
       <b>the</b> <b>trailing</b> <b>NUL</b> <b>character)</b> <b>will</b> <b>be</b> <b>converted</b> <b>to</b> <b>s.</b>

       Returns the number of characters that would have been written to s if there were enough space.

   <b>int</b> <b>snprintf_P</b> <b>(char</b> <b>*</b> <b>__s,</b> <b>size_t</b> <b>__n,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b>  <b>...)</b> <b>[extern]</b>
       Variant of <b>snprintf()</b> <b>that</b> <b>uses</b> <b>a</b> <b>fmt</b> <b>string</b> <b>that</b> <b>resides</b> <b>in</b> <b>program</b> <b>memory.</b>

   <b>int</b> <b>sprintf</b> <b>(char</b> <b>*</b> <b>__s,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b>  <b>...)</b> <b>[extern]</b>
       Variant of <b>printf()</b> <b>that</b> <b>sends</b> <b>the</b> <b>formatted</b> <b>characters</b> <b>to</b> <b>string</b> <b>s.</b>

   <b>int</b> <b>sprintf_P</b> <b>(char</b> <b>*</b> <b>__s,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b>  <b>...)</b> <b>[extern]</b>
       Variant of <b>sprintf()</b> <b>that</b> <b>uses</b> <b>a</b> <b>fmt</b> <b>string</b> <b>that</b> <b>resides</b> <b>in</b> <b>program</b> <b>memory.</b>

   <b>int</b> <b>sscanf</b> <b>(const</b> <b>char</b> <b>*</b> <b>__buf,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b>  <b>...)</b> <b>[extern]</b>
       The function sscanf performs formatted input, reading the input data from the buffer pointed to by buf.

       See <b>vfscanf()</b> for details.

   <b>int</b> <b>sscanf_P</b> <b>(const</b> <b>char</b> <b>*</b> <b>__buf,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b>  <b>...)</b> <b>[extern]</b>
       Variant of <b>sscanf()</b> using a fmt string in program memory.

   <b>int</b> <b>ungetc</b> <b>(int</b> <b>__c,</b> <b>FILE</b> <b>*</b> <b>__stream)</b> <b>[extern]</b>
       The <b>ungetc()</b> function pushes the character c (converted to an unsigned char) back onto the  input  stream
       pointed to by stream. The pushed-back character will be returned by a subsequent read on the stream.

       Currently, only a single character can be pushed back onto the stream.

       The  <b>ungetc()</b>  function  returns  the character pushed back after the conversion, or EOF if the operation
       fails. If the value of the argument c character equals EOF, the operation will fail and the  stream  will
       remain unchanged.

   <b>int</b> <b>vfprintf</b> <b>(FILE</b> <b>*</b> <b>__stream,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b> <b>va_list</b> <b>__ap)</b> <b>[extern]</b>
       vfprintf  is  the  central  facility of the printf family of functions. It outputs values to stream under
       control of a format string passed in fmt. The actual values to print are passed as  a  variable  argument
       list ap.

       vfprintf  returns the number of characters written to stream, or EOF in case of an error. Currently, this
       will only happen if stream has not been opened with write intent.

       The format string is composed of zero or more directives: ordinary characters (not %), which  are  copied
       unchanged  to the output stream; and conversion specifications, each of which results in fetching zero or
       more subsequent arguments. Each conversion specification is introduced by the % character. The  arguments
       must properly correspond (after type promotion) with the conversion specifier. After the %, the following
       appear in sequence:

       • Zero or more of the following flags:
         • #  The  value  should  be  converted  to an 'alternate form'. For c, d, i, s, and u conversions, this
           option has no effect. For o conversions, the precision of the number is increased to force the  first
           character  of  the  output  string  to  a  zero  (except  if a zero value is printed with an explicit
           precision of zero). For x and X conversions, a non-zero result has the string `0x'  (or  `0X'  for  X
           conversions) prepended to it.
         • 0  (zero)  Zero  padding.  For  all conversions, the converted value is padded on the left with zeros
           rather than blanks. If a precision is given with a numeric conversion (d, i, o, u, i, x, and X),  the
           0 flag is ignored.
         • -  A negative field width flag; the converted value is to be left adjusted on the field boundary. The
           converted value is padded on the right with blanks, rather than on the left with blanks or zeros. A -
           overrides a 0 if both are given.
         •
         • + A sign must always be placed before a number produced by a signed conversion. A + overrides a space
           if both are used.
       • An optional decimal digit string specifying a minimum field width. If the  converted  value  has  fewer
         characters  than  the  field  width,  it will be padded with spaces on the left (or right, if the left-
         adjustment flag has been given) to fill out the field width.
       • An optional precision, in the form of a period . followed by an optional digit  string.  If  the  digit
         string  is  omitted,  the precision is taken as zero. This gives the minimum number of digits to appear
         for d, i, o, u, x, and X conversions, or the maximum number of characters to be printed from  a  string
         for s conversions.
       • An  optional  l  or  h  length  modifier,  that specifies that the argument for the d, i, o, u, x, or X
         conversion is a 'long int' rather than int. The h is ignored, as 'short int' is equivalent to int.
       • A character that specifies the type of conversion to be applied.
       The conversion specifiers and their meanings are:
       • diouxX The int (or appropriate variant) argument is converted to signed decimal  (d  and  i),  unsigned
         octal  (o),  unsigned decimal (u), or unsigned hexadecimal (x and X) notation. The letters 'abcdef' are
         used for x conversions; the letters 'ABCDEF' are used for X conversions. The precision, if  any,  gives
         the  minimum  number  of  digits  that must appear; if the converted value requires fewer digits, it is
         padded on the left with zeros.
       • p The void * argument is taken as an unsigned integer, and converted similarly as a %#x  command  would
         do.
       • c The int argument is converted to an 'unsigned char', and the resulting character is written.
       • s  The  'char  *'  argument  is  expected  to  be a pointer to an array of character type (pointer to a
         string). Characters from the array are written up to (but not including) a terminating  NUL  character;
         if a precision is specified, no more than the number specified are written. If a precision is given, no
         null  character  need be present; if the precision is not specified, or is greater than the size of the
         array, the array must contain a terminating NUL character.
       • % A % is written. No argument is converted. The complete conversion specification is '%%'.
       • eE The double argument is rounded and converted in the format '[-]d.ddde±dd' where there is  one  digit
         before  the decimal-point character and the number of digits after it is equal to the precision; if the
         precision is missing, it is taken as 6; if the precision is zero, no decimal-point  character  appears.
         An  <u>E</u>  conversion  uses the letter 'E' (rather than 'e') to introduce the exponent. The exponent always
         contains two digits; if the value is zero, the exponent is 00.
       • fF The double argument is rounded and converted to decimal notation in the format  '[-]ddd.ddd',  where
         the  number of digits after the decimal-point character is equal to the precision specification. If the
         precision is missing, it is taken as 6; if the precision is explicitly zero, no decimal-point character
         appears. If a decimal point appears, at least one digit appears before it.
       • gG The double argument is converted in style f or e (or F  or  E  for  G  conversions).  The  precision
         specifies  the  number  of  significant digits. If the precision is missing, 6 digits are given; if the
         precision is zero, it is treated as 1. Style e is used if the exponent from its conversion is less than
         -4 or greater than or equal to the precision. Trailing zeros are removed from the  fractional  part  of
         the result; a decimal point appears only if it is followed by at least one digit.
       • S  Similar  to  the  s format, except the pointer is expected to point to a program-memory (ROM) string
         instead of a RAM string.
       In no case does a non-existent or small field width cause truncation of a numeric field; if the result of
       a conversion is wider than the field width, the field is expanded to contain the conversion result.
       Since the full implementation of all  the  mentioned  features  becomes  fairly  large,  three  different
       flavours  of  <b>vfprintf()</b>  can be selected using linker options. The default <b>vfprintf()</b> implements all the
       mentioned functionality except floating point conversions. A minimized version of <b>vfprintf()</b> is available
       that only implements the very basic integer and string conversion facilities, but only the  #  additional
       option  can  be  specified  using  conversion  flags  (these  flags  are parsed correctly from the format
       specification, but then simply ignored). This version can  be  requested  using  the  following  <b>compiler</b>
       <b>options</b>:
       -Wl,-u,vfprintf -lprintf_min
       If  the  full  functionality  including the floating point conversions is required, the following options
       should be used:
       -Wl,-u,vfprintf -lprintf_flt -lm
       <b>Limitations:</b>

           • The specified width and precision can be at most 255.
       <b>Notes:</b>

           • For floating-point conversions, if you link default or minimized version of <b>vfprintf()</b>, the  symbol
             ?  will be output and double argument will be skipped. So you output below will not be crashed. For
             default version the width field and the 'pad to left' ( symbol minus ) option  will  work  in  this
             case.
           • The  hh  length  modifier  is  ignored  (char  argument  is  promouted  to int). More exactly, this
             realization does not check the number of h symbols.
           • But the ll length modifier will to abort the output, as this realization does not operate long long
             arguments.
           • The variable width or precision field (an asterisk * symbol) is not realized and will to abort  the
             output.
   <b>int</b> <b>vfprintf_P</b> <b>(FILE</b> <b>*</b> <b>__stream,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b> <b>va_list</b> <b>__ap)</b> <b>[extern]</b>
       Variant of <b>vfprintf()</b> <b>that</b> <b>uses</b> <b>a</b> <b>fmt</b> <b>string</b> <b>that</b> <b>resides</b> <b>in</b> <b>program</b> <b>memory.</b>
   <b>int</b> <b>vfscanf</b> <b>(FILE</b> <b>*</b> <b>stream,</b> <b>const</b> <b>char</b> <b>*</b> <b>fmt,</b> <b>va_list</b> <b>ap)</b> <b>[extern]</b>
       Formatted input. This function is the heart of the <b>scanf</b> family of functions.
       Characters  are  read  from  <u>stream</u>  and  processed in a way described by <u>fmt</u>. Conversion results will be
       assigned to the parameters passed via <u>ap</u>.
       The format string <u>fmt</u> is  scanned  for  conversion  specifications.  Anything  that  doesn't  comprise  a
       conversion specification is taken as text that is matched literally against the input. White space in the
       format  string  will  match any white space in the data (including none), all other characters match only
       itself. Processing is aborted as soon as the data and format string no longer match, or there is an error
       or end-of-file condition on <u>stream</u>.
       Most conversions skip leading white space before starting the actual conversion.
       Conversions are introduced with the character <b>%</b>. Possible options can follow the <b>%</b>:
       • a * indicating that the conversion should be performed but the conversion result is to be discarded; no
         parameters will be processed from ap,
       • the character h indicating that the argument is a pointer to short int (rather than int),
       • the 2 characters hh indicating that the argument is a pointer to char (rather than int).
       • the character l indicating that the argument is a pointer to long int (rather  than  int,  for  integer
         type conversions), or a pointer to float (for floating point conversions),
       In  addition,  a  maximal  field width may be specified as a nonzero positive decimal integer, which will
       restrict the conversion to at most this many characters from  the  input  stream.  This  field  width  is
       limited  to  at  most  255  characters  which is also the default value (except for the c conversion that
       defaults to 1).
       The following conversion flags are supported:
       • % Matches a literal % character. This is not a conversion.
       • d Matches an optionally signed decimal integer; the next pointer must be a pointer to int.
       • i Matches an optionally signed integer; the next pointer must be a pointer to int. The integer is  read
         in  base  16  if it begins with <b>0x</b> or <b>0X</b>, in base 8 if it begins with <b>0</b>, and in base 10 otherwise. Only
         characters that correspond to the base are used.
       • o Matches an octal integer; the next pointer must be a pointer to unsigned int.
       • u Matches an optionally signed decimal integer; the next pointer must be a pointer to unsigned int.
       • x Matches an optionally signed hexadecimal integer; the next pointer must be a pointer to unsigned int.
       • f Matches an optionally signed floating-point number; the next pointer must be a pointer to float.
       • e, g, F, E, G Equivalent to f.
       • s Matches a sequence of non-white-space characters; the next pointer must be a pointer to char, and the
         array must be large enough to accept all the sequence and the  terminating  NUL  character.  The  input
         string stops at white space or at the maximum field width, whichever occurs first.
       • c Matches a sequence of width count characters (default 1); the next pointer must be a pointer to char,
         and  there  must be enough room for all the characters (no terminating NUL is added). The usual skip of
         leading white space is suppressed. To skip white space first, use an explicit space in the format.
       • [ Matches a nonempty sequence of characters from the specified set of  accepted  characters;  the  next
         pointer  must be a pointer to char, and there must be enough room for all the characters in the string,
         plus a terminating NUL character. The usual skip of leading white space is suppressed. The string is to
         be made up of characters in (or not in) a particular set; the set is defined by the characters  between
         the  open bracket [ character and a close bracket ] character. The set excludes those characters if the
         first character after the open bracket is a circumflex ^. To include a close bracket in the  set,  make
         it  the  first character after the open bracket or the circumflex; any other position will end the set.
         The hyphen character - is also  special;  when  placed  between  two  other  characters,  it  adds  all
         intervening  characters  to  the  set. To include a hyphen, make it the last character before the final
         close bracket. For instance, [^]0-9-] means the set of <u>everything</u> <u>except</u> <u>close</u>  <u>bracket,</u>  <u>zero</u>  <u>through</u>
         <u>nine,</u> <u>and</u> <u>hyphen</u>. The string ends with the appearance of a character not in the (or, with a circumflex,
         in)  set  or  when  the  field  width  runs  out. Note that usage of this conversion enlarges the stack
         expense.
       • p Matches a pointer value (as printed by p in <b>printf()</b>); the next pointer must be a pointer to void.
       • n Nothing is expected; instead, the number of characters consumed thus far from  the  input  is  stored
         through  the next pointer, which must be a pointer to int. This is not a conversion, although it can be
         suppressed with the * flag.
       These functions return the number of input items assigned, which can be fewer than provided for, or  even
       zero,  in  the  event  of  a  matching  failure. Zero indicates that, while there was input available, no
       conversions were assigned; typically this is due to an invalid input character,  such  as  an  alphabetic
       character  for a d conversion. The value EOF is returned if an input failure occurs before any conversion
       such as an end-of-file occurs. If an error or end-of-file occurs after conversion has begun,  the  number
       of conversions which were successfully completed is returned.
       By  default,  all the conversions described above are available except the floating-point conversions and
       the width is limited to 255 characters. The float-point conversion will  be  available  in  the  extended
       version  provided  by the library libscanf_flt.a. Also in this case the width is not limited (exactly, it
       is limited to 65535 characters). To link a program  against  the  extended  version,  use  the  following
       compiler flags in the link stage:
       -Wl,-u,vfscanf -lscanf_flt -lm
       A third version is available for environments that are tight on space. In addition to the restrictions of
       the  standard  one,  this version implements no %[ specification. This version is provided in the library
       libscanf_min.a, and can be requested using the following options in the link stage:
       -Wl,-u,vfscanf -lscanf_min -lm
   <b>int</b> <b>vfscanf_P</b> <b>(FILE</b> <b>*</b> <b>__stream,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b> <b>va_list</b> <b>__ap)</b> <b>[extern]</b>
       Variant of <b>vfscanf()</b> using a fmt string in program memory.
   <b>int</b> <b>vprintf</b> <b>(const</b> <b>char</b> <b>*</b> <b>__fmt,</b> <b>va_list</b> <b>__ap)</b> <b>[extern]</b>
       The function vprintf performs formatted output to stream stdout, taking a variable argument  list  as  in
       <b>vfprintf()</b>.
       See <b>vfprintf()</b> for details.
   <b>int</b> <b>vscanf</b> <b>(const</b> <b>char</b> <b>*</b> <b>__fmt,</b> <b>va_list</b> <b>__ap)</b> <b>[extern]</b>
       The  function  vscanf  performs  formatted input from stream stdin, taking a variable argument list as in
       <b>vfscanf()</b>.
       See <b>vfscanf()</b> for details.
   <b>int</b> <b>vsnprintf</b> <b>(char</b> <b>*</b> <b>__s,</b> <b>size_t</b> <b>__n,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b> <b>va_list</b> <b>ap)</b> <b>[extern]</b>
       Like <b>vsprintf(),</b> <b>but</b> <b>instead</b> <b>of</b> <b>assuming</b> <b>s</b> <b>to</b> <b>be</b> <b>of</b> <b>infinite</b> <b>size,</b> <b>no</b> <b>more</b> <b>than</b> <b>n</b>  <b>characters</b>  <b>(including</b>
       <b>the</b> <b>trailing</b> <b>NUL</b> <b>character)</b> <b>will</b> <b>be</b> <b>converted</b> <b>to</b> <b>s.</b>
       Returns the number of characters that would have been written to s if there were enough space.
   <b>int</b> <b>vsnprintf_P</b> <b>(char</b> <b>*</b> <b>__s,</b> <b>size_t</b> <b>__n,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b> <b>va_list</b> <b>ap)</b> <b>[extern]</b>
       Variant of <b>vsnprintf()</b> <b>that</b> <b>uses</b> <b>a</b> <b>fmt</b> <b>string</b> <b>that</b> <b>resides</b> <b>in</b> <b>program</b> <b>memory.</b>
   <b>int</b> <b>vsprintf</b> <b>(char</b> <b>*</b> <b>__s,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b> <b>va_list</b> <b>ap)</b> <b>[extern]</b>
       Like <b>sprintf()</b> <b>but</b> <b>takes</b> <b>a</b> <b>variable</b> <b>argument</b> <b>list</b> <b>for</b> <b>the</b> <b>arguments.</b>
   <b>int</b> <b>vsprintf_P</b> <b>(char</b> <b>*</b> <b>__s,</b> <b>const</b> <b>char</b> <b>*</b> <b>__fmt,</b> <b>va_list</b> <b>ap)</b> <b>[extern]</b>
       Variant of <b>vsprintf()</b> <b>that</b> <b>uses</b> <b>a</b> <b>fmt</b> <b>string</b> <b>that</b> <b>resides</b> <b>in</b> <b>program</b> <b>memory.</b>
</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for AVR-LibC from the source code.

AVR-LibC                                          Version 2.2.1                                  <u><a href="../man3avr/avr_stdio.3avr.html">avr_stdio</a></u>(3avr)
</pre>
 </div>
</div></section>
</div>
</body>
</html>