<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>List - List operations.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       List - List operations.

</pre><h4><b>Module</b></h4><pre>
       Module   List

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>List</b>
        : <b>sig</b> <b>end</b>

       List operations.

       Some  functions  are flagged as not tail-recursive.  A tail-recursive function uses constant stack space,
       while a non-tail-recursive function uses stack space proportional to the length  of  its  list  argument,
       which  can  be  a  problem  with  very  long  lists.   When the function takes several list arguments, an
       approximate formula giving stack usage (in some unspecified constant unit) is shown in parentheses.

       The above considerations can usually be ignored if your lists are not longer than about 10000 elements.

       The labeled version of this module can be used as described in the <b>StdLabels</b> module.

       <u>type</u> <b>'a</b> <u>t</u> = <b>'a</b> <b>list</b> =
        | []
        | (::) <b>of</b> <b>'a</b> <b>*</b> <b>'a</b> <b>list</b>

       An alias for the type of lists.

       <u>val</u> <u>length</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>int</b>

       Return the length (number of elements) of the given list.

       <u>val</u> <u>compare_lengths</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>int</b>

       Compare the lengths of two lists.  <b>compare_lengths</b> <b>l1</b> <b>l2</b> is equivalent to <b>compare</b> <b>(length</b> <b>l1)</b> <b>(length</b> <b>l2)</b>
       , except that the computation stops after reaching the end of the shortest list.

       <b>Since</b> 4.05

       <u>val</u> <u>compare_length_with</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b>

       Compare the length of a list to an integer.  <b>compare_length_with</b> <b>l</b> <b>len</b> is equivalent to  <b>compare</b>  <b>(length</b>
       <b>l)</b> <b>len</b> , except that the computation stops after at most <b>len</b> iterations on the list.

       <b>Since</b> 4.05

       <u>val</u> <u>is_empty</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       <b>is_empty</b> <b>l</b> is true if and only if <b>l</b> has no elements. It is equivalent to <b>compare_length_with</b> <b>l</b> <b>0</b> <b>=</b> <b>0</b> .

       <b>Since</b> 5.1

       <u>val</u> <u>cons</u> : <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>cons</b> <b>x</b> <b>xs</b> is <b>x</b> <b>::</b> <b>xs</b>

       <b>Since</b> 4.03 (4.05 in ListLabels)

       <u>val</u> <u>hd</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b>

       Return the first element of the given list.

       <b>Raises</b> <b>Failure</b> if the list is empty.

       <u>val</u> <u>tl</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Return the given list without its first element.

       <b>Raises</b> <b>Failure</b> if the list is empty.

       <u>val</u> <u>nth</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b>

       Return the <b>n</b> -th element of the given list.  The first element (head of the list) is at position 0.

       <b>Raises</b> <b>Failure</b> if the list is too short.

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is negative.

       <u>val</u> <u>nth_opt</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       Return  the  <b>n</b>  -th  element  of  the given list.  The first element (head of the list) is at position 0.
       Return <b>None</b> if the list is too short.

       <b>Since</b> 4.05

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is negative.

       <u>val</u> <u>rev</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       List reversal.

       <u>val</u> <u>init</u> : <b>int</b> <b>-&gt;</b> <b>(int</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>init</b> <b>len</b> <b>f</b> is <b>[f</b> <b>0;</b> <b>f</b> <b>1;</b> <b>...;</b> <b>f</b> <b>(len-1)]</b> , evaluated left to right.

       <b>Since</b> 4.06

       <b>Raises</b> <b>Invalid_argument</b> if <b>len</b> <b>&lt;</b> <b>0</b> .

       <u>val</u> <u>append</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>append</b> <b>l0</b> <b>l1</b> appends <b>l1</b> to <b>l0</b> .  Same function as the infix operator <b>@</b> .

       <b>Since</b> 5.1 this function is tail-recursive.

       <u>val</u> <u>rev_append</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>rev_append</b> <b>l1</b> <b>l2</b> reverses <b>l1</b> and concatenates it with <b>l2</b> .  This is equivalent to <b>(</b> <b>List.rev</b> <b>l1)</b> <b>@</b> <b>l2</b> .

       <u>val</u> <u>concat</u> : <b>'a</b> <b>list</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Concatenate a list of lists. The elements of the argument are all  concatenated  together  (in  the  same
       order) to give the result.  Not tail-recursive (length of the argument + length of the longest sub-list).

       <u>val</u> <u>flatten</u> : <b>'a</b> <b>list</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Same as <b>List.concat</b> . Not tail-recursive (length of the argument + length of the longest sub-list).

   <b>Comparison</b>
       <u>val</u> <u>equal</u> : <b>('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       <b>equal</b>  <b>eq</b>  <b>[a1;</b>  <b>...;</b>  <b>an]</b> <b>[b1;</b> <b>..;</b> <b>bm]</b> holds when the two input lists have the same length, and for each
       pair of elements <b>ai</b> , <b>bi</b> at the same position we have <b>eq</b> <b>ai</b> <b>bi</b> .

       Note: the <b>eq</b> function may be called even if the lists have different length. If you  know  your  equality
       function is costly, you may want to check <b>List.compare_lengths</b> first.

       <b>Since</b> 4.12

       <u>val</u> <u>compare</u> : <b>('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>int</b>

       <b>compare</b> <b>cmp</b> <b>[a1;</b> <b>...;</b> <b>an]</b> <b>[b1;</b> <b>...;</b> <b>bm]</b> performs a lexicographic comparison of the two input lists, using
       the same <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int</b> interface as <b>compare</b> :

       -  <b>a1</b> <b>::</b> <b>l1</b> is smaller than <b>a2</b> <b>::</b> <b>l2</b> (negative result) if <b>a1</b> is smaller than <b>a2</b> , or if they are equal (0
       result) and <b>l1</b> is smaller than <b>l2</b>

       -the empty list <b>[]</b> is strictly smaller than non-empty lists

       Note: the <b>cmp</b> function will be called even if the lists have different lengths.

       <b>Since</b> 4.12

   <b>Iterators</b>
       <u>val</u> <u>iter</u> : <b>('a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>unit</b>

       <b>iter</b> <b>f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> applies function <b>f</b> in turn to <b>[a1;</b> <b>...;</b> <b>an]</b> . It is equivalent to <b>f</b> <b>a1;</b> <b>f</b> <b>a2;</b> <b>...;</b> <b>f</b>
       <b>an</b> .

       <u>val</u> <u>iteri</u> : <b>(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>unit</b>

       Same as <b>List.iter</b> , but the function is applied to the index of the element as first  argument  (counting
       from 0), and the element itself as second argument.

       <b>Since</b> 4.00

       <u>val</u> <u>map</u> : <b>('a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b>

       <b>map</b>  <b>f</b>  <b>[a1;</b>  <b>...;</b> <b>an]</b> applies function <b>f</b> to <b>a1,</b> <b>...,</b> <b>an</b> , and builds the list <b>[f</b> <b>a1;</b> <b>...;</b> <b>f</b> <b>an]</b> with the
       results returned by <b>f</b> .

       <u>val</u> <u>mapi</u> : <b>(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b>

       Same as <b>List.map</b> , but the function is applied to the index of the element as  first  argument  (counting
       from 0), and the element itself as second argument.

       <b>Since</b> 4.00

       <u>val</u> <u>rev_map</u> : <b>('a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b>

       <b>rev_map</b> <b>f</b> <b>l</b> gives the same result as <b>List.rev</b> <b>(</b> <b>List.map</b> <b>f</b> <b>l)</b> , but is more efficient.

       <u>val</u> <u>filter_map</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b>

       <b>filter_map</b>  <b>f</b>  <b>l</b>  applies <b>f</b> to every element of <b>l</b> , filters out the <b>None</b> elements and returns the list of
       the arguments of the <b>Some</b> elements.

       <b>Since</b> 4.08

       <u>val</u> <u>concat_map</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>list)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b>

       <b>concat_map</b> <b>f</b> <b>l</b> gives the same result as <b>List.concat</b> <b>(</b> <b>List.map</b> <b>f</b> <b>l)</b> . Tail-recursive.

       <b>Since</b> 4.10

       <u>val</u> <u>fold_left_map</u> : <b>('acc</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'acc</b> <b>*</b> <b>'b)</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'acc</b> <b>*</b> <b>'b</b> <b>list</b>

       <b>fold_left_map</b> is  a combination of <b>fold_left</b> and <b>map</b> that threads an accumulator through calls to <b>f</b> .

       <b>Since</b> 4.11

       <u>val</u> <u>fold_left</u> : <b>('acc</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_left</b> <b>f</b> <b>init</b> <b>[b1;</b> <b>...;</b> <b>bn]</b> is <b>f</b> <b>(...</b> <b>(f</b> <b>(f</b> <b>init</b> <b>b1)</b> <b>b2)</b> <b>...)</b> <b>bn</b> .

       <u>val</u> <u>fold_right</u> : <b>('a</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_right</b> <b>f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> <b>init</b> is <b>f</b> <b>a1</b> <b>(f</b> <b>a2</b> <b>(...</b> <b>(f</b> <b>an</b> <b>init)</b> <b>...))</b>  . Not tail-recursive.

   <b>Iterators</b> <b>on</b> <b>two</b> <b>lists</b>
       <u>val</u> <u>iter2</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>unit</b>

       <b>iter2</b> <b>f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> <b>[b1;</b> <b>...;</b> <b>bn]</b> calls in turn <b>f</b> <b>a1</b> <b>b1;</b> <b>...;</b> <b>f</b> <b>an</b> <b>bn</b> .

       <b>Raises</b> <b>Invalid_argument</b> if the two lists are determined to have different lengths.

       <u>val</u> <u>map2</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'c)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>'c</b> <b>list</b>

       <b>map2</b> <b>f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> <b>[b1;</b> <b>...;</b> <b>bn]</b> is <b>[f</b> <b>a1</b> <b>b1;</b> <b>...;</b> <b>f</b> <b>an</b> <b>bn]</b> .

       <b>Raises</b> <b>Invalid_argument</b> if the two lists are determined to have different lengths.

       <u>val</u> <u>rev_map2</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'c)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>'c</b> <b>list</b>

       <b>rev_map2</b> <b>f</b> <b>l1</b> <b>l2</b> gives the same result as <b>List.rev</b> <b>(</b> <b>List.map2</b> <b>f</b> <b>l1</b> <b>l2)</b> , but is more efficient.

       <u>val</u> <u>fold_left2</u> : <b>('acc</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_left2</b> <b>f</b> <b>init</b> <b>[a1;</b> <b>...;</b> <b>an]</b> <b>[b1;</b> <b>...;</b> <b>bn]</b> is <b>f</b> <b>(...</b> <b>(f</b> <b>(f</b> <b>init</b> <b>a1</b> <b>b1)</b> <b>a2</b> <b>b2)</b> <b>...)</b> <b>an</b> <b>bn</b> .

       <b>Raises</b> <b>Invalid_argument</b> if the two lists are determined to have different lengths.

       <u>val</u> <u>fold_right2</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_right2</b> <b>f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> <b>[b1;</b> <b>...;</b> <b>bn]</b> <b>init</b> is <b>f</b> <b>a1</b> <b>b1</b> <b>(f</b> <b>a2</b> <b>b2</b> <b>(...</b> <b>(f</b> <b>an</b> <b>bn</b> <b>init)</b> <b>...))</b>  .

       <b>Raises</b> <b>Invalid_argument</b> if the two lists are determined to have different lengths. Not tail-recursive.

   <b>List</b> <b>scanning</b>
       <u>val</u> <u>for_all</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       <b>for_all</b> <b>f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> checks if all elements of the list satisfy the predicate <b>f</b> . That is, it  returns
       <b>(f</b> <b>a1)</b> <b>&amp;&amp;</b> <b>(f</b> <b>a2)</b> <b>&amp;&amp;</b> <b>...</b> <b>&amp;&amp;</b> <b>(f</b> <b>an)</b> for a non-empty list and <b>true</b> if the list is empty.

       <u>val</u> <u>exists</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       <b>exists</b> <b>f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> checks if at least one element of the list satisfies the predicate <b>f</b> . That is, it
       returns <b>(f</b> <b>a1)</b> <b>||</b> <b>(f</b> <b>a2)</b> <b>||</b> <b>...</b> <b>||</b> <b>(f</b> <b>an)</b> for a non-empty list and <b>false</b> if the list is empty.

       <u>val</u> <u>for_all2</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       Same as <b>List.for_all</b> , but for a two-argument predicate.

       <b>Raises</b> <b>Invalid_argument</b> if the two lists are determined to have different lengths.

       <u>val</u> <u>exists2</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       Same as <b>List.exists</b> , but for a two-argument predicate.

       <b>Raises</b> <b>Invalid_argument</b> if the two lists are determined to have different lengths.

       <u>val</u> <u>mem</u> : <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       <b>mem</b> <b>a</b> <b>set</b> is true if and only if <b>a</b> is equal to an element of <b>set</b> .

       <u>val</u> <u>memq</u> : <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       Same as <b>List.mem</b> , but uses physical equality instead of structural equality to compare list elements.

   <b>List</b> <b>searching</b>
       <u>val</u> <u>find</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b>

       <b>find</b> <b>f</b> <b>l</b> returns the first element of the list <b>l</b> that satisfies the predicate <b>f</b> .

       <b>Raises</b> <b>Not_found</b> if there is no value that satisfies <b>f</b> in the list <b>l</b> .

       <u>val</u> <u>find_opt</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       <b>find</b>  <b>f</b> <b>l</b> returns the first element of the list <b>l</b> that satisfies the predicate <b>f</b> .  Returns <b>None</b> if there
       is no value that satisfies <b>f</b> in the list <b>l</b> .

       <b>Since</b> 4.05

       <u>val</u> <u>find_index</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>int</b> <b>option</b>

       <b>find_index</b> <b>f</b> <b>xs</b> returns <b>Some</b> <b>i</b> , where <b>i</b> is the index of the first element of the list <b>xs</b> that  satisfies
       <b>f</b> <b>x</b> , if there is such an element.

       It returns <b>None</b> if there is no such element.

       <b>Since</b> 5.1

       <u>val</u> <u>find_map</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       <b>find_map</b>  <b>f</b>  <b>l</b> applies <b>f</b> to the elements of <b>l</b> in order, and returns the first result of the form <b>Some</b> <b>v</b> ,
       or <b>None</b> if none exist.

       <b>Since</b> 4.10

       <u>val</u> <u>find_mapi</u> : <b>(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       Same as <b>find_map</b> , but the predicate is applied to the index of the element as first  argument  (counting
       from 0), and the element itself as second argument.

       <b>Since</b> 5.1

       <u>val</u> <u>filter</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>filter</b>  <b>f</b>  <b>l</b>  returns  all  the  elements  of  the list <b>l</b> that satisfy the predicate <b>f</b> . The order of the
       elements in the input list is preserved.

       <u>val</u> <u>find_all</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>find_all</b> is another name for <b>List.filter</b> .

       <u>val</u> <u>filteri</u> : <b>(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Same as <b>List.filter</b> , but the predicate is applied  to  the  index  of  the  element  as  first  argument
       (counting from 0), and the element itself as second argument.

       <b>Since</b> 4.11

   <b>List</b> <b>manipulation</b>
       <u>val</u> <u>take</u> : <b>int</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>take</b> <b>n</b> <b>l</b> returns the prefix of <b>l</b> of length <b>n</b> , or a copy of <b>l</b> if <b>n</b> <b>&gt;</b> <b>length</b> <b>l</b> .

       <b>n</b> must be nonnegative.

       <b>Since</b> 5.3

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is negative.

       <u>val</u> <u>drop</u> : <b>int</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>drop</b> <b>n</b> <b>l</b> returns the suffix of <b>l</b> after <b>n</b> elements, or <b>[]</b> if <b>n</b> <b>&gt;</b> <b>length</b> <b>l</b> .

       <b>n</b> must be nonnegative.

       <b>Since</b> 5.3

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is negative.

       <u>val</u> <u>take_while</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>take_while</b> <b>p</b> <b>l</b> is the longest (possibly empty) prefix of <b>l</b> containing only elements that satisfy <b>p</b> .

       <b>Since</b> 5.3

       <u>val</u> <u>drop_while</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>drop_while</b>  <b>p</b>  <b>l</b>  is the longest (possibly empty) suffix of <b>l</b> starting at the first element that does not
       satisfy <b>p</b> .

       <b>Since</b> 5.3

       <u>val</u> <u>partition</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>*</b> <b>'a</b> <b>list</b>

       <b>partition</b> <b>f</b> <b>l</b> returns a pair of lists <b>(l1,</b> <b>l2)</b> , where <b>l1</b> is the list of  all  the  elements  of  <b>l</b>  that
       satisfy  the predicate <b>f</b> , and <b>l2</b> is the list of all the elements of <b>l</b> that do not satisfy <b>f</b> .  The order
       of the elements in the input list is preserved.

       <u>val</u> <u>partition_map</u> : <b>('a</b> <b>-&gt;</b> <b>('b,</b> <b>'c)</b> <b>Either.t)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>*</b> <b>'c</b> <b>list</b>

       <b>partition_map</b> <b>f</b> <b>l</b> returns a pair of lists <b>(l1,</b> <b>l2)</b> such that, for each element <b>x</b> of the input list <b>l</b> :

       -if <b>f</b> <b>x</b> is <b>Left</b> <b>y1</b> , then <b>y1</b> is in <b>l1</b> , and

       -if <b>f</b> <b>x</b> is <b>Right</b> <b>y2</b> , then <b>y2</b> is in <b>l2</b> .

       The output elements are included in <b>l1</b> and <b>l2</b> in the same  relative  order  as  the  corresponding  input
       elements in <b>l</b> .

       In  particular, <b>partition_map</b> <b>(fun</b> <b>x</b> <b>-&gt;</b> <b>if</b> <b>f</b> <b>x</b> <b>then</b> <b>Left</b> <b>x</b> <b>else</b> <b>Right</b> <b>x)</b> <b>l</b> is equivalent to <b>partition</b> <b>f</b> <b>l</b>
       .

       <b>Since</b> 4.12

   <b>Association</b> <b>lists</b>
       <u>val</u> <u>assoc</u> : <b>'a</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>'b</b>

       <b>assoc</b> <b>a</b> <b>l</b> returns the value associated with key <b>a</b> in the list of pairs <b>l</b> . That is, <b>assoc</b> <b>a</b> <b>[</b> <b>...;</b> <b>(a,b);</b>
       <b>...]</b> <b>=</b> <b>b</b> if <b>(a,b)</b> is the leftmost binding of <b>a</b> in list <b>l</b> .

       <b>Raises</b> <b>Not_found</b> if there is no value associated with <b>a</b> in the list <b>l</b> .

       <u>val</u> <u>assoc_opt</u> : <b>'a</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       <b>assoc_opt</b> <b>a</b> <b>l</b> returns the value associated with key <b>a</b> in the list of pairs <b>l</b> . That  is,  <b>assoc_opt</b>  <b>a</b>  <b>[</b>
       <b>...;</b>  <b>(a,b);</b> <b>...]</b> <b>=</b> <b>Some</b> <b>b</b> if <b>(a,b)</b> is the leftmost binding of <b>a</b> in list <b>l</b> .  Returns <b>None</b> if there is no
       value associated with <b>a</b> in the list <b>l</b> .

       <b>Since</b> 4.05

       <u>val</u> <u>assq</u> : <b>'a</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>'b</b>

       Same as <b>List.assoc</b> , but uses physical equality instead of structural equality to compare keys.

       <u>val</u> <u>assq_opt</u> : <b>'a</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       Same as <b>List.assoc_opt</b> , but uses physical equality instead of structural equality to compare keys.

       <b>Since</b> 4.05

       <u>val</u> <u>mem_assoc</u> : <b>'a</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       Same as <b>List.assoc</b> , but simply return <b>true</b> if a binding exists, and <b>false</b> if no bindings exist  for  the
       given key.

       <u>val</u> <u>mem_assq</u> : <b>'a</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       Same as <b>List.mem_assoc</b> , but uses physical equality instead of structural equality to compare keys.

       <u>val</u> <u>remove_assoc</u> : <b>'a</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b>

       <b>remove_assoc</b>  <b>a</b>  <b>l</b>  returns  the  list  of  pairs  <b>l</b>  without  the  first  pair with key <b>a</b> , if any.  Not
       tail-recursive.

       <u>val</u> <u>remove_assq</u> : <b>'a</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b>

       Same as <b>List.remove_assoc</b> , but uses physical equality instead of structural equality  to  compare  keys.
       Not tail-recursive.

   <b>Lists</b> <b>of</b> <b>pairs</b>
       <u>val</u> <u>split</u> : <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>*</b> <b>'b</b> <b>list</b>

       Transform  a  list  of  pairs into a pair of lists: <b>split</b> <b>[(a1,b1);</b> <b>...;</b> <b>(an,bn)]</b> is <b>([a1;</b> <b>...;</b> <b>an],</b> <b>[b1;</b>
       <b>...;</b> <b>bn])</b> .  Not tail-recursive.

       <u>val</u> <u>combine</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b>

       Transform a pair of lists into a list of pairs: <b>combine</b> <b>[a1;</b> <b>...;</b> <b>an]</b> <b>[b1;</b> <b>...;</b>  <b>bn]</b>  is  <b>[(a1,b1);</b>  <b>...;</b>
       <b>(an,bn)]</b> .

       <b>Raises</b> <b>Invalid_argument</b> if the two lists have different lengths. Not tail-recursive.

   <b>Sorting</b>
       <u>val</u> <u>sort</u> : <b>('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Sort a list in increasing order according to a comparison function. The comparison function must return 0
       if  its arguments compare as equal, a positive integer if the first is greater, and a negative integer if
       the first is smaller (see Array.sort for a complete specification). For example, <b>compare</b>  is  a  suitable
       comparison  function.   The resulting list is sorted in increasing order.  <b>List.sort</b> is guaranteed to run
       in constant heap space (in addition to the size of the result list) and logarithmic stack space.

       The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.

       <u>val</u> <u>stable_sort</u> : <b>('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Same as <b>List.sort</b> , but the sorting algorithm is guaranteed to be  stable  (i.e.  elements  that  compare
       equal are kept in their original order).

       The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.

       <u>val</u> <u>fast_sort</u> : <b>('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Same as <b>List.sort</b> or <b>List.stable_sort</b> , whichever is faster on typical input.

       <u>val</u> <u>sort_uniq</u> : <b>('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Same as <b>List.sort</b> , but also remove duplicates.

       <b>Since</b> 4.02 (4.03 in ListLabels)

       <u>val</u> <u>merge</u> : <b>('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Merge  two lists: Assuming that <b>l1</b> and <b>l2</b> are sorted according to the comparison function <b>cmp</b> , <b>merge</b> <b>cmp</b>
       <b>l1</b> <b>l2</b> will return a sorted list containing all the elements of <b>l1</b> and <b>l2</b> .  If several  elements  compare
       equal,  the elements of <b>l1</b> will be before the elements of <b>l2</b> .  Not tail-recursive (sum of the lengths of
       the arguments).

   <b>Lists</b> <b>and</b> <b>Sequences</b>
       <u>val</u> <u>to_seq</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>Seq.t</b>

       Iterate on the list.

       <b>Since</b> 4.07

       <u>val</u> <u>of_seq</u> : <b>'a</b> <b>Seq.t</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Create a list from a sequence.

       <b>Since</b> 4.07

OCamldoc                                           2025-06-12                                           <u><a href="../man3o/List.3o.html">List</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>