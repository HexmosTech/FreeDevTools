<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>List::Objects::WithUtils - List objects, kitchen sink included</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblist-objects-withutils-perl">liblist-objects-withutils-perl_2.028003-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       List::Objects::WithUtils - List objects, kitchen sink included

</pre><h4><b>SYNOPSIS</b></h4><pre>
         ## A small sample; consult the description, below, for links to
         ## extended documentation

         # Import all object constructor functions:
         #   array immarray array_of immarray_of
         #   hash immhash hash_of immhash_of
         use List::Objects::WithUtils;

         # Import all of the above plus autoboxing:
         use List::Objects::WithUtils ':all';
         # Same as above, but shorter:
         use Lowu;

         # Most methods returning lists return new objects; chaining is easy:
         array(qw/ aa Ab bb Bc bc /)
           -&gt;grep(sub { /^b/i })
           -&gt;map(sub  { uc })
           -&gt;uniq
           -&gt;all;   # ( 'BB', 'BC' )

         # Useful utilities from other list modules are available:
         my $want_idx = array(
           +{ id =&gt; '400', user =&gt; 'bob' },
           +{ id =&gt; '600', user =&gt; 'suzy' },
           +{ id =&gt; '700', user =&gt; 'fred' },
         )-&gt;first_index(sub { $_-&gt;{id} &gt; 500 });

         my $itr = array( 1 .. 7 )-&gt;<a href="../man3/natatime.3.html">natatime</a>(3);
         while ( my @nextset = $itr-&gt;() ) {
           ...
         }

         my $meshed = array(qw/ a b c d /)
           -&gt;mesh( array(1 .. 4) )
           -&gt;all;   # ( 'a', 1, 'b', 2, 'c', 3, 'd', 4 )

         my ($evens, $odds) = array( 1 .. 20 )
           -&gt;part(sub { $_[0] &amp; 1 })
           -&gt;all;

         my $sorted = array(
           +{ name =&gt; 'bob',  acct =&gt; 1 },
           +{ name =&gt; 'fred', acct =&gt; 2 },
           +{ name =&gt; 'suzy', acct =&gt; 3 },
         )-&gt;sort_by(sub { $_-&gt;{name} });

         # array() objects are mutable:
         my $mutable = array(qw/ foo bar baz /);
         $mutable-&gt;insert(1, 'quux');
         $mutable-&gt;<a href="../man2/delete.2.html">delete</a>(2);

         # ... or use immarray() immutable arrays:
         my $static = immarray( qw/ foo bar baz / );
         $static-&gt;set(0, 'quux');  # dies
         $static-&gt;[0] = 'quux';    # dies
         push @$static, 'quux';    # dies

         # Construct a hash:
         my $hash  = hash( foo =&gt; 'bar', snacks =&gt; 'cake' );

         # You can set multiple keys in one call:
         $hash-&gt;set( foobar =&gt; 'baz', pie =&gt; 'cherry' );

         # ... which is useful for merging in another (plain) hash:
         my %foo = ( pie =&gt; 'pumpkin', snacks =&gt; 'cheese' );
         $hash-&gt;set( %foo );

         # ... or another hash object:
         my $second = hash( pie =&gt; 'key lime' );
         $hash-&gt;set( $second-&gt;export );

         # Retrieve one value as a simple scalar:
         my $snacks = $hash-&gt;get('snacks');

         # ... or retrieve multiple values as an array-type object:
         my $vals = $hash-&gt;get('foo', 'foobar');

         # Take a hash slice of keys, return a new hash object
         # consisting of the retrieved key/value pairs:
         my $slice = $hash-&gt;sliced('foo', 'pie');

         # Arrays inflate to hash objects:
         my $items = array( qw/ foo bar baz/ )-&gt;map(sub { $_ =&gt; 1 })-&gt;inflate;
         if ($items-&gt;exists('foo')) {
           # ...
         }

         # Hashes inflate to simple objects with accessors:
         my $obj = $hash-&gt;inflate;
         $snacks = $obj-&gt;snacks;

         # Methods returning multiple values typically return new array-type objects:
         my @match_keys = $hash-&gt;keys-&gt;grep(sub { m/foo/ })-&gt;all;
         my @match_vals = $hash-&gt;values-&gt;grep(sub { m/bar/ })-&gt;all;

         my @sorted_pairs = hash( foo =&gt; 2, bar =&gt; 3, baz =&gt; 1)
           -&gt;kv
           -&gt;sort_by(sub { $_-&gt;[1] })
           -&gt;all;  # ( [ baz =&gt; 1 ], [ foo =&gt; 2 ], [ bar =&gt; 3 ] )

         # Perl6-inspired Junctions:
         if ( $hash-&gt;keys-&gt;any_items == qr/snacks/ ) {
           # ... hash has key(s) matching /snacks/ ...
         }
         if ( $hash-&gt;values-&gt;all_items &gt; 10 ) {
           # ... all hash values greater than 10 ...
         }

         # Type-checking arrays via Type::Tiny:
         use Types::Standard -all;
         my $int_arr = array_of Int() =&gt; 1 .. 10;

         # Type-checking hashes:
         use Types::Standard -all;
         my $int_hash = hash_of Int() =&gt; (foo =&gt; 1, bar =&gt; 2);

         # Native list types can be autoboxed:
         use List::Objects::WithUtils 'autobox';
         my $foo = [ qw/foo baz bar foo quux/ ]-&gt;uniq-&gt;sort;
         my $bar = +{ a =&gt; 1, b =&gt; 2, c =&gt; 3 }-&gt;values-&gt;sort;

         # Autoboxing is lexically scoped like normal:
         { no List::Objects::WithUtils::Autobox;
           [ 1 .. 10 ]-&gt;shuffle;  # dies
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A set of roles and classes defining an object-oriented interface to Perl hashes and arrays with useful
       utility methods, junctions, type-checking ability, and optional autoboxing. Originally derived from
       Data::Perl.

   <b>Uses</b>
       The included objects are useful as-is but are largely intended for use as data container types for
       attributes. This lends a more natural object-oriented syntax; these are particularly convenient in
       combination with delegated methods, as in this example:

         package Some::Thing;
         use List::Objects::WithUtils;
         use Moo;

         has items =&gt; (
           is      =&gt; 'ro',
           builder =&gt; sub { array },
           handles =&gt; +{
             add_items   =&gt; 'push',
             get_items   =&gt; 'all',
             items_where =&gt; 'grep',
           },
         );

         # ... later ...
         my $thing = Some::Thing-&gt;new;
         $thing-&gt;add_items(@more_items);
         # Operate on all positive items:
         for my $item ($thing-&gt;items_where(sub { $_ &gt; 0 })-&gt;all) {
           ...
         }

       List::Objects::Types provides Type::Tiny-based types &amp; coercions matching the list objects provided by
       this distribution. These integrate nicely with typed or untyped list objects:

         package Accounts;
         use List::Objects::Types -types;
         use Moo 2;

         has usergroups =&gt; (
           is        =&gt; 'ro',
           # +{ $group =&gt; [ [ $usr =&gt; $id ], ... ] }
           # Coerced to objects all the way down:
           isa       =&gt; TypedHash[ TypedArray[ArrayObj] ],
           coerce    =&gt; 1,
           builder   =&gt; sub { +{} },
         );

         # ... later ...
         my $users_in_grp = $accts-&gt;usergroups
           -&gt;get($some_group)
           -&gt;grep(sub { $_[0]-&gt;<a href="../man0/get.0.html">get</a>(0) });

   <b>Objects</b>
       <u>Arrays</u>

       <b>array</b> (List::Objects::WithUtils::Array) provides basic mutable ARRAY-type objects.  Behavior is defined
       by List::Objects::WithUtils::Role::Array; look there for documentation on available methods.

       <b>immarray</b> is imported from List::Objects::WithUtils::Array::Immutable and operates much like an <b>array</b>,
       except methods that mutate the list are not available; using immutable arrays promotes safer programming
       patterns.

       <b>array_of</b> provides Type::Tiny-compatible type-checking array objects that can coerce and check their
       values as they are added; see List::Objects::WithUtils::Array::Typed.

       <b>immarray_of</b> provides immutable type-checking arrays; see
       List::Objects::WithUtils::Array::Immutable::Typed.

       <u>Hashes</u>

       <b>hash</b> is the basic mutable HASH-type object imported from List::Objects::WithUtils::Hash; see
       List::Objects::WithUtils::Role::Hash for documentation.

       <b>immhash</b> provides immutable (restricted) hashes; see List::Objects::WithUtils::Hash::Immutable.

       <b>hash_of</b> provides Type::Tiny-compatible type-checking hash objects; see
       List::Objects::WithUtils::Hash::Typed.

       <b>immhash_of</b> provides immutable type-checking hashes; see List::Objects::WithUtils::Hash::Immutable::Typed.

   <b>Importing</b>
       A bare import list ("use List::Objects::WithUtils;") will import all of the object constructor functions
       described above; they can also be selectively imported, e.g.:

         use List::Objects::WithUtils 'array_of', 'hash_of';

       Importing <b>autobox</b> lexically enables List::Objects::WithUtils::Autobox, which provides
       List::Objects::WithUtils::Array or List::Objects::WithUtils::Hash methods for native ARRAY and HASH
       types.

       Importing <b>all</b> or <b>:all</b> will import all of the object constructors and additionally turn <b>autobox</b> on; "use
       Lowu;" is a shortcut for importing <b>all</b>.

   <b>Debugging</b>
       Most methods belonging to these objects are heavily micro-optimized -- at the cost of useful error
       handling.

       Since there are few built-in argument checks, a mistake in your code can frequently lead to slightly
       cryptic errors from the perl side:

         &gt; my $pos;  # whoops, I'm still undefined later:
         &gt; if ($arr-&gt;exists($pos)) { ... }
         Use of uninitialized value in numeric le (&lt;=) at $useless_lib_lineno

       ... in which case Devel::Confess is likely to improve your quality of life by providing a real backtrace:

         $ perl -d:Confess my_app.pl
         Use of uninitialized value in numeric le (&lt;=) at ...
           [...]::Array::exists(<a href="../man0x8441068/ARRAY.0x8441068.html">ARRAY</a>(0x8441068), undef) called at ...

   <b>Subclassing</b>
       The importer for this package is somewhat flexible; a subclass can override import to pass import tags
       and a target package by feeding this package's import() a HASH:

         # Subclass and import to target packages (see Lowu.pm f.ex):
         package My::Defaults;
         use parent 'List::Objects::WithUtils';
         sub import {
           my ($class, @params) = @_;
           $class-&gt;SUPER::import(
             +{
               import =&gt; [ 'autobox', 'array', 'hash' ],
               to     =&gt; scalar(caller)
             }
           )
         }

       Functionality is mostly defined by Roles.  For example, it's easy to create your own array class with new
       methods:

         package My::Array::Object;
         use Role::Tiny::With;
         # Act like List::Objects::WithUtils::Array:
         with 'List::Objects::WithUtils::Role::Array',
              'List::Objects::WithUtils::Role::Array::WithJunctions';

         # One way to add your own functional interface:
         use Exporter 'import';  our @EXPORT = 'my_array';
         sub my_array { __PACKAGE__-&gt;new(@_) }

         # ... add/override methods ...

       ... in which case you may want to also define your own hash subclass that overrides "array_type" to
       produce your preferred arrays:

         package My::Hash::Object;
         use Role::Tiny::With;
         with 'List::Objects::WithUtils::Role::Hash';

         use Exporter 'import';  our @EXPORT = 'my_hash';
         sub my_hash { __PACKAGE__-&gt;new(@_) }

         sub array_type { 'My::Array::Object' }

         # ... add/override methods ...

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       List::Objects::WithUtils::Role::Array for documentation on the basic set of array() methods.

       List::Objects::WithUtils::Role::Array::WithJunctions for documentation on array() junction-returning
       methods.

       List::Objects::WithUtils::Array::Immutable for more on immarray() immutable arrays.

       List::Objects::WithUtils::Array::Typed for more on array_of() type-checking arrays.

       List::Objects::WithUtils::Array::Immutable::Typed for more on immarray_of() immutable type-checking
       arrays.

       List::Objects::WithUtils::Role::Hash for documentation regarding hash() methods.

       List::Objects::WithUtils::Hash::Immutable for more on immhash() immutable hashes.

       List::Objects::WithUtils::Hash::Typed for more on hash_of() type-checking hashes.

       List::Objects::WithUtils::Hash::Immutable::Typed for more on immhash_of() immutable type-checking hashes.

       List::Objects::WithUtils::Autobox for details on autoboxing.

       The Lowu module for a convenient importer shortcut.

       List::Objects::Types for relevant Type::Tiny types.

       MoopsX::ListObjects for integration with Moops class-building sugar.

</pre><h4><b>AUTHOR</b></h4><pre>
       Jon Portnoy &lt;<a href="mailto:avenj@cobaltirc.org">avenj@cobaltirc.org</a>&gt;

       Licensed under the same terms as Perl.

       The original Array and Hash roles were derived from Data::Perl by Matthew Phillips (CPAN: MATTP), haarg,
       and others.

       Immutable array objects were originally inspired by Const::Fast by Leon Timmermans (CPAN: LEONT), but now
       use "tie".

       Junctions are adapted from Perl6::Junction by Carl Franks (CPAN: CFRANKS)

       Most of the type-checking code and other useful additions were contributed by Toby Inkster (CPAN:
       TOBYINK)

       A significant portion of this code simply wraps other widely-used modules, especially:

       List::Util

       List::UtilsBy

       Type::Tiny

       Inspiration for a few pieces comes from the "classic" (version 0.33) List::MoreUtils.

perl v5.38.2                                       2024-03-07                      <u>List::Objects::<a href="../man3pm/WithUtils.3pm.html">WithUtils</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>