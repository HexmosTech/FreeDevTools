<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lists - List processing functions.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       lists - List processing functions.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module contains functions for list processing.

       Unless  otherwise  stated,  all  functions assume that position numbering starts at 1. That is, the first
       element of a list is at position 1.

       Two terms <u>T1</u> and <u>T2</u> compare equal if <u>T1</u> <u>==</u> <u>T2</u> evaluates to <u>true</u>. They match if <u>T1</u>  <u>=:=</u>  <u>T2</u>  evaluates  to
       <u>true</u>.

       Whenever an <u>ordering</u> <u>function</u> <u>F</u> is expected as argument, it is assumed that the following properties hold
       of <u>F</u> for all x, y, and z:

         * If x <u>F</u> y and y <u>F</u> x, then x = y (<u>F</u> is antisymmetric).

         * If x <u>F</u> y and y <u>F</u> z, then x <u>F</u> z (<u>F</u> is transitive).

         * x <u>F</u> y or y <u>F</u> x (<u>F</u> is total).

       An example of a typical ordering function is less than or equal to: <u>=&lt;/2</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>all(Pred,</b> <b>List)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Pred = fun((Elem :: T) -&gt; boolean())
                 List = [T]
                 T = term()

              Returns  <u>true</u>  if <u>Pred(Elem)</u> returns <u>true</u> for all elements <u>Elem</u> in <u>List</u>, otherwise <u>false</u>. The <u>Pred</u>
              function must return a boolean.

       <b>any(Pred,</b> <b>List)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Pred = fun((Elem :: T) -&gt; boolean())
                 List = [T]
                 T = term()

              Returns <u>true</u> if <u>Pred(Elem)</u> returns <u>true</u> for at least one element <u>Elem</u> in <u>List</u>. The  <u>Pred</u>  function
              must return a boolean.

       <b>append(ListOfLists)</b> <b>-&gt;</b> <b>List1</b>

              Types:

                 ListOfLists = [List]
                 List = List1 = [T]
                 T = term()

              Returns a list in which all the sublists of <u>ListOfLists</u> have been appended.

              <u>Example:</u>

              &gt; lists:append([[1, 2, 3], [a, b], [4, 5, 6]]).
              [1,2,3,a,b,4,5,6]

       <b>append(List1,</b> <b>List2)</b> <b>-&gt;</b> <b>List3</b>

              Types:

                 List1 = List2 = List3 = [T]
                 T = term()

              Returns  a  new  list  <u>List3</u>, which is made from the elements of <u>List1</u> followed by the elements of
              <u>List2</u>.

              <u>Example:</u>

              &gt; lists:append("abc", "def").
              "abcdef"

              <u>lists:append(A,</u> <u>B)</u> is equivalent to <u>A</u> <u>++</u> <u>B</u>.

       <b>concat(Things)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Things = [Thing]
                 Thing = atom() | integer() | float() | string()

              Concatenates the text representation of the elements of <u>Things</u>. The  elements  of  <u>Things</u>  can  be
              atoms, integers, floats, or strings.

              <u>Example:</u>

              &gt; lists:concat([doc, '/', file, '.', 3]).
              "doc/file.3"

       <b>delete(Elem,</b> <b>List1)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 Elem = T
                 List1 = List2 = [T]
                 T = term()

              Returns  a  copy  of  <u>List1</u>  where the first element matching <u>Elem</u> is deleted, if there is such an
              element.

       <b>droplast(List)</b> <b>-&gt;</b> <b>InitList</b>

              Types:

                 List = [T, ...]
                 InitList = [T]
                 T = term()

              Drops the last element of a <u>List</u>. The list is to be non-empty, otherwise the function crashes with
              a <u>function_clause</u>.

       <b>dropwhile(Pred,</b> <b>List1)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 Pred = fun((Elem :: T) -&gt; boolean())
                 List1 = List2 = [T]
                 T = term()

              Drops elements <u>Elem</u> from <u>List1</u> while <u>Pred(Elem)</u> returns <u>true</u> and returns the remaining  list.  The
              <u>Pred</u> function must return a boolean.

       <b>duplicate(N,</b> <b>Elem)</b> <b>-&gt;</b> <b>List</b>

              Types:

                 N = integer() &gt;= 0
                 Elem = T
                 List = [T]
                 T = term()

              Returns a list containing <u>N</u> copies of term <u>Elem</u>.

              <u>Example:</u>

              &gt; lists:duplicate(5, xx).
              [xx,xx,xx,xx,xx]

       <b>filter(Pred,</b> <b>List1)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 Pred = fun((Elem :: T) -&gt; boolean())
                 List1 = List2 = [T]
                 T = term()

              <u>List2</u> is a list of all elements <u>Elem</u> in <u>List1</u> for which <u>Pred(Elem)</u> returns <u>true</u>. The <u>Pred</u> function
              must return a boolean.

       <b>filtermap(Fun,</b> <b>List1)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 Fun = fun((Elem) -&gt; boolean() | {true, Value})
                 List1 = [Elem]
                 List2 = [Elem | Value]
                 Elem = Value = term()

              Calls  <u>Fun(Elem)</u>  on  successive  elements  <u>Elem</u> of <u>List1</u>. <u>Fun/1</u> must return either a Boolean or a
              tuple <u>{true,</u> <u>Value}</u>. The function returns the list of elements for which <u>Fun</u> returns a new  value,
              where a value of <u>true</u> is synonymous with <u>{true,</u> <u>Elem}</u>.

              That is, <u>filtermap</u> behaves as if it had been defined as follows:

              filtermap(Fun, List1) -&gt;
                  lists:foldr(fun(Elem, Acc) -&gt;
                                     case Fun(Elem) of
                                         false -&gt; Acc;
                                         true -&gt; [Elem|Acc];
                                         {true,Value} -&gt; [Value|Acc]
                                     end
                              end, [], List1).

              <u>Example:</u>

              &gt; lists:filtermap(fun(X) -&gt; case X rem 2 of 0 -&gt; {true, X div 2}; _ -&gt; false end end, [1,2,3,4,5]).
              [1,2]

       <b>flatlength(DeepList)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 DeepList = [term() | DeepList]

              Equivalent to <u>length(flatten(DeepList))</u>, but more efficient.

       <b>flatmap(Fun,</b> <b>List1)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 Fun = fun((A) -&gt; [B])
                 List1 = [A]
                 List2 = [B]
                 A = B = term()

              Takes  a  function  from  <u>A</u>s to lists of <u>B</u>s, and a list of <u>A</u>s (<u>List1</u>) and produces a list of <u>B</u>s by
              applying the function to every element in <u>List1</u> and appending the resulting lists.

              That is, <u>flatmap</u> behaves as if it had been defined as follows:

              flatmap(Fun, List1) -&gt;
                  append(map(Fun, List1)).

              <u>Example:</u>

              &gt; lists:flatmap(fun(X)-&gt;[X,X] end, [a,b,c]).
              [a,a,b,b,c,c]

       <b>flatten(DeepList)</b> <b>-&gt;</b> <b>List</b>

              Types:

                 DeepList = [term() | DeepList]
                 List = [term()]

              Returns a flattened version of <u>DeepList</u>.

       <b>flatten(DeepList,</b> <b>Tail)</b> <b>-&gt;</b> <b>List</b>

              Types:

                 DeepList = [term() | DeepList]
                 Tail = List = [term()]

              Returns a flattened version of <u>DeepList</u> with tail <u>Tail</u> appended.

       <b>foldl(Fun,</b> <b>Acc0,</b> <b>List)</b> <b>-&gt;</b> <b>Acc1</b>

              Types:

                 Fun = fun((Elem :: T, AccIn) -&gt; AccOut)
                 Acc0 = Acc1 = AccIn = AccOut = term()
                 List = [T]
                 T = term()

              Calls <u>Fun(Elem,</u> <u>AccIn)</u> on successive elements <u>A</u> of <u>List</u>, starting with <u>AccIn</u> <u>==</u> <u>Acc0</u>.  <u>Fun/2</u>  must
              return  a  new accumulator, which is passed to the next call. The function returns the final value
              of the accumulator. <u>Acc0</u> is returned if the list is empty.

              <u>Example:</u>

              &gt; lists:foldl(fun(X, Sum) -&gt; X + Sum end, 0, [1,2,3,4,5]).
              15
              &gt; lists:foldl(fun(X, Prod) -&gt; X * Prod end, 1, [1,2,3,4,5]).
              120

       <b>foldr(Fun,</b> <b>Acc0,</b> <b>List)</b> <b>-&gt;</b> <b>Acc1</b>

              Types:

                 Fun = fun((Elem :: T, AccIn) -&gt; AccOut)
                 Acc0 = Acc1 = AccIn = AccOut = term()
                 List = [T]
                 T = term()

              Like <u>foldl/3</u>, but the list is traversed from right to left.

              <u>Example:</u>

              &gt; P = fun(A, AccIn) -&gt; io:format("~p ", [A]), AccIn end.
              #Fun&lt;erl_eval.12.2225172&gt;
              &gt; lists:foldl(P, void, [1,2,3]).
              1 2 3 void
              &gt; lists:foldr(P, void, [1,2,3]).
              3 2 1 void

              <u>foldl/3</u> is tail recursive and is usually preferred to <u>foldr/3</u>.

       <b>join(Sep,</b> <b>List1)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 Sep = T
                 List1 = List2 = [T]
                 T = term()

              Inserts <u>Sep</u> between each element in <u>List1</u>. Has no effect on the empty  list  and  on  a  singleton
              list. For example:

              &gt; lists:join(x, [a,b,c]).
              [a,x,b,x,c]
              &gt; lists:join(x, [a]).
              [a]
              &gt; lists:join(x, []).
              []

       <b>foreach(Fun,</b> <b>List)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Fun = fun((Elem :: T) -&gt; term())
                 List = [T]
                 T = term()

              Calls  <u>Fun(Elem)</u> for each element <u>Elem</u> in <u>List</u>. This function is used for its side effects and the
              evaluation order is defined to be the same as the order of the elements in the list.

       <b>keydelete(Key,</b> <b>N,</b> <b>TupleList1)</b> <b>-&gt;</b> <b>TupleList2</b>

              Types:

                 Key = term()
                 N = integer() &gt;= 1
                   1..tuple_size(Tuple)
                 TupleList1 = TupleList2 = [Tuple]
                 Tuple = tuple()

              Returns a copy of <u>TupleList1</u> where the first occurrence of a  tuple  whose  <u>N</u>th  element  compares
              equal to <u>Key</u> is deleted, if there is such a tuple.

       <b>keyfind(Key,</b> <b>N,</b> <b>TupleList)</b> <b>-&gt;</b> <b>Tuple</b> <b>|</b> <b>false</b>

              Types:

                 Key = term()
                 N = integer() &gt;= 1
                   1..tuple_size(Tuple)
                 TupleList = [Tuple]
                 Tuple = tuple()

              Searches the list of tuples <u>TupleList</u> for a tuple whose <u>N</u>th element compares equal to <u>Key</u>. Returns
              <u>Tuple</u> if such a tuple is found, otherwise <u>false</u>.

       <b>keymap(Fun,</b> <b>N,</b> <b>TupleList1)</b> <b>-&gt;</b> <b>TupleList2</b>

              Types:

                 Fun = fun((Term1 :: term()) -&gt; Term2 :: term())
                 N = integer() &gt;= 1
                   1..tuple_size(Tuple)
                 TupleList1 = TupleList2 = [Tuple]
                 Tuple = tuple()

              Returns  a  list of tuples where, for each tuple in <u>TupleList1</u>, the <u>N</u>th element <u>Term1</u> of the tuple
              has been replaced with the result of calling <u>Fun(Term1)</u>.

              <u>Examples:</u>

              &gt; Fun = fun(Atom) -&gt; atom_to_list(Atom) end.
              #Fun&lt;erl_eval.6.10732646&gt;
              2&gt; lists:keymap(Fun, 2, [{name,jane,22},{name,lizzie,20},{name,lydia,15}]).
              [{name,"jane",22},{name,"lizzie",20},{name,"lydia",15}]

       <b>keymember(Key,</b> <b>N,</b> <b>TupleList)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Key = term()
                 N = integer() &gt;= 1
                   1..tuple_size(Tuple)
                 TupleList = [Tuple]
                 Tuple = tuple()

              Returns <u>true</u> if there is a tuple in <u>TupleList</u> whose <u>N</u>th element compares equal to  <u>Key</u>,  otherwise
              <u>false</u>.

       <b>keymerge(N,</b> <b>TupleList1,</b> <b>TupleList2)</b> <b>-&gt;</b> <b>TupleList3</b>

              Types:

                 N = integer() &gt;= 1
                   1..tuple_size(Tuple)
                 TupleList1 = [T1]
                 TupleList2 = [T2]
                 TupleList3 = [T1 | T2]
                 T1 = T2 = Tuple
                 Tuple = tuple()

              Returns the sorted list formed by merging <u>TupleList1</u> and <u>TupleList2</u>. The merge is performed on the
              <u>N</u>th  element  of  each  tuple. Both <u>TupleList1</u> and <u>TupleList2</u> must be key-sorted before evaluating
              this function. When two tuples compare equal, the tuple from <u>TupleList1</u> is picked before the tuple
              from <u>TupleList2</u>.

       <b>keyreplace(Key,</b> <b>N,</b> <b>TupleList1,</b> <b>NewTuple)</b> <b>-&gt;</b> <b>TupleList2</b>

              Types:

                 Key = term()
                 N = integer() &gt;= 1
                   1..tuple_size(Tuple)
                 TupleList1 = TupleList2 = [Tuple]
                 NewTuple = Tuple
                 Tuple = tuple()

              Returns a copy of <u>TupleList1</u> where the first occurrence of a <u>T</u> tuple whose  <u>N</u>th  element  compares
              equal to <u>Key</u> is replaced with <u>NewTuple</u>, if there is such a tuple <u>T</u>.

       <b>keysearch(Key,</b> <b>N,</b> <b>TupleList)</b> <b>-&gt;</b> <b>{value,</b> <b>Tuple}</b> <b>|</b> <b>false</b>

              Types:

                 Key = term()
                 N = integer() &gt;= 1
                   1..tuple_size(Tuple)
                 TupleList = [Tuple]
                 Tuple = tuple()

              Searches the list of tuples <u>TupleList</u> for a tuple whose <u>N</u>th element compares equal to <u>Key</u>. Returns
              <u>{value,</u> <u>Tuple}</u> if such a tuple is found, otherwise <u>false</u>.

          <b>Note:</b>
              This  function  is  retained  for  backward  compatibility.  Function  <u>keyfind/3</u>  is  usually more
              convenient.

       <b>keysort(N,</b> <b>TupleList1)</b> <b>-&gt;</b> <b>TupleList2</b>

              Types:

                 N = integer() &gt;= 1
                   1..tuple_size(Tuple)
                 TupleList1 = TupleList2 = [Tuple]
                 Tuple = tuple()

              Returns a list containing the sorted elements of list <u>TupleList1</u>. Sorting is performed on the  <u>N</u>th
              element of the tuples. The sort is stable.

       <b>keystore(Key,</b> <b>N,</b> <b>TupleList1,</b> <b>NewTuple)</b> <b>-&gt;</b> <b>TupleList2</b>

              Types:

                 Key = term()
                 N = integer() &gt;= 1
                   1..tuple_size(Tuple)
                 TupleList1 = [Tuple]
                 TupleList2 = [Tuple, ...]
                 NewTuple = Tuple
                 Tuple = tuple()

              Returns  a  copy  of <u>TupleList1</u> where the first occurrence of a tuple <u>T</u> whose <u>N</u>th element compares
              equal to <u>Key</u> is replaced with <u>NewTuple</u>, if there is such a tuple <u>T</u>. If there is no such tuple <u>T</u>, a
              copy of <u>TupleList1</u> where [<u>NewTuple</u>] has been appended to the end is returned.

       <b>keytake(Key,</b> <b>N,</b> <b>TupleList1)</b> <b>-&gt;</b> <b>{value,</b> <b>Tuple,</b> <b>TupleList2}</b> <b>|</b> <b>false</b>

              Types:

                 Key = term()
                 N = integer() &gt;= 1
                   1..tuple_size(Tuple)
                 TupleList1 = TupleList2 = [tuple()]
                 Tuple = tuple()

              Searches the list of tuples <u>TupleList1</u> for a tuple  whose  <u>N</u>th  element  compares  equal  to  <u>Key</u>.
              Returns <u>{value,</u> <u>Tuple,</u> <u>TupleList2}</u> if such a tuple is found, otherwise <u>false</u>. <u>TupleList2</u> is a copy
              of <u>TupleList1</u> where the first occurrence of <u>Tuple</u> has been removed.

       <b>last(List)</b> <b>-&gt;</b> <b>Last</b>

              Types:

                 List = [T, ...]
                 Last = T
                 T = term()

              Returns the last element in <u>List</u>.

       <b>map(Fun,</b> <b>List1)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 Fun = fun((A) -&gt; B)
                 List1 = [A]
                 List2 = [B]
                 A = B = term()

              Takes  a  function  from  <u>A</u>s  to  <u>B</u>s,  and  a list of <u>A</u>s and produces a list of <u>B</u>s by applying the
              function to every element in the list. This function is used to  obtain  the  return  values.  The
              evaluation order depends on the implementation.

       <b>mapfoldl(Fun,</b> <b>Acc0,</b> <b>List1)</b> <b>-&gt;</b> <b>{List2,</b> <b>Acc1}</b>

              Types:

                 Fun = fun((A, AccIn) -&gt; {B, AccOut})
                 Acc0 = Acc1 = AccIn = AccOut = term()
                 List1 = [A]
                 List2 = [B]
                 A = B = term()

              Combines the operations of <u>map/2</u> and <u>foldl/3</u> into one pass.

              <u>Example:</u>

              Summing the elements in a list and double them at the same time:

              &gt; lists:mapfoldl(fun(X, Sum) -&gt; {2*X, X+Sum} end,
              0, [1,2,3,4,5]).
              {[2,4,6,8,10],15}

       <b>mapfoldr(Fun,</b> <b>Acc0,</b> <b>List1)</b> <b>-&gt;</b> <b>{List2,</b> <b>Acc1}</b>

              Types:

                 Fun = fun((A, AccIn) -&gt; {B, AccOut})
                 Acc0 = Acc1 = AccIn = AccOut = term()
                 List1 = [A]
                 List2 = [B]
                 A = B = term()

              Combines the operations of <u>map/2</u> and <u>foldr/3</u> into one pass.

       <b>max(List)</b> <b>-&gt;</b> <b>Max</b>

              Types:

                 List = [T, ...]
                 Max = T
                 T = term()

              Returns  the  first  element  of <u>List</u> that compares greater than or equal to all other elements of
              <u>List</u>.

       <b>member(Elem,</b> <b>List)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Elem = T
                 List = [T]
                 T = term()

              Returns <u>true</u> if <u>Elem</u> matches some element of <u>List</u>, otherwise <u>false</u>.

       <b>merge(ListOfLists)</b> <b>-&gt;</b> <b>List1</b>

              Types:

                 ListOfLists = [List]
                 List = List1 = [T]
                 T = term()

              Returns the sorted list formed by merging all the sublists of <u>ListOfLists</u>. All  sublists  must  be
              sorted  before  evaluating  this  function.  When two elements compare equal, the element from the
              sublist with the lowest position in <u>ListOfLists</u> is picked before the other element.

       <b>merge(List1,</b> <b>List2)</b> <b>-&gt;</b> <b>List3</b>

              Types:

                 List1 = [X]
                 List2 = [Y]
                 List3 = [X | Y]
                 X = Y = term()

              Returns the sorted list formed by merging <u>List1</u> and <u>List2</u>. Both <u>List1</u> and  <u>List2</u>  must  be  sorted
              before evaluating this function. When two elements compare equal, the element from <u>List1</u> is picked
              before the element from <u>List2</u>.

       <b>merge(Fun,</b> <b>List1,</b> <b>List2)</b> <b>-&gt;</b> <b>List3</b>

              Types:

                 Fun = fun((A, B) -&gt; boolean())
                 List1 = [A]
                 List2 = [B]
                 List3 = [A | B]
                 A = B = term()

              Returns  the  sorted  list  formed by merging <u>List1</u> and <u>List2</u>. Both <u>List1</u> and <u>List2</u> must be sorted
              according to the ordering function <u>Fun</u> before evaluating this function. <u>Fun(A,</u>  <u>B)</u>  is  to  return
              <u>true</u>  if  <u>A</u>  compares  less than or equal to <u>B</u> in the ordering, otherwise <u>false</u>. When two elements
              compare equal, the element from <u>List1</u> is picked before the element from <u>List2</u>.

       <b>merge3(List1,</b> <b>List2,</b> <b>List3)</b> <b>-&gt;</b> <b>List4</b>

              Types:

                 List1 = [X]
                 List2 = [Y]
                 List3 = [Z]
                 List4 = [X | Y | Z]
                 X = Y = Z = term()

              Returns the sorted list formed by merging <u>List1</u>, <u>List2</u>, and <u>List3</u>. All of <u>List1</u>, <u>List2</u>, and  <u>List3</u>
              must  be sorted before evaluating this function. When two elements compare equal, the element from
              <u>List1</u>, if there is such an element, is picked before the other element, otherwise the element from
              <u>List2</u> is picked before the element from <u>List3</u>.

       <b>min(List)</b> <b>-&gt;</b> <b>Min</b>

              Types:

                 List = [T, ...]
                 Min = T
                 T = term()

              Returns the first element of <u>List</u> that compares less than or equal to all other elements of <u>List</u>.

       <b>nth(N,</b> <b>List)</b> <b>-&gt;</b> <b>Elem</b>

              Types:

                 N = integer() &gt;= 1
                   1..length(List)
                 List = [T, ...]
                 Elem = T
                 T = term()

              Returns the <u>N</u>th element of <u>List</u>.

              <u>Example:</u>

              &gt; lists:nth(3, [a, b, c, d, e]).
              c

       <b>nthtail(N,</b> <b>List)</b> <b>-&gt;</b> <b>Tail</b>

              Types:

                 N = integer() &gt;= 0
                   0..length(List)
                 List = [T, ...]
                 Tail = [T]
                 T = term()

              Returns the <u>N</u>th tail of <u>List</u>, that is, the sublist of <u>List</u> starting at <u>N+1</u> and  continuing  up  to
              the end of the list.

              <u>Example</u>

              &gt; lists:nthtail(3, [a, b, c, d, e]).
              [d,e]
              &gt; tl(tl(tl([a, b, c, d, e]))).
              [d,e]
              &gt; lists:nthtail(0, [a, b, c, d, e]).
              [a,b,c,d,e]
              &gt; lists:nthtail(5, [a, b, c, d, e]).
              []

       <b>partition(Pred,</b> <b>List)</b> <b>-&gt;</b> <b>{Satisfying,</b> <b>NotSatisfying}</b>

              Types:

                 Pred = fun((Elem :: T) -&gt; boolean())
                 List = Satisfying = NotSatisfying = [T]
                 T = term()

              Partitions  <u>List</u>  into  two lists, where the first list contains all elements for which <u>Pred(Elem)</u>
              returns <u>true</u>, and the second list contains all elements for which <u>Pred(Elem)</u> returns <u>false</u>.

              <u>Examples:</u>

              &gt; lists:partition(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]).
              {[1,3,5,7],[2,4,6]}
              &gt; lists:partition(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]).
              {[a,b,c,d,e],[1,2,3,4]}

              For a different way to partition a list, see <u>splitwith/2</u>.

       <b>prefix(List1,</b> <b>List2)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 List1 = List2 = [T]
                 T = term()

              Returns <u>true</u> if <u>List1</u> is a prefix of <u>List2</u>, otherwise <u>false</u>.

       <b>reverse(List1)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 List1 = List2 = [T]
                 T = term()

              Returns a list with the elements in <u>List1</u> in reverse order.

       <b>reverse(List1,</b> <b>Tail)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 List1 = [T]
                 Tail = term()
                 List2 = [T]
                 T = term()

              Returns a list with the elements in <u>List1</u> in reverse order, with tail <u>Tail</u> appended.

              <u>Example:</u>

              &gt; lists:reverse([1, 2, 3, 4], [a, b, c]).
              [4,3,2,1,a,b,c]

       <b>search(Pred,</b> <b>List)</b> <b>-&gt;</b> <b>{value,</b> <b>Value}</b> <b>|</b> <b>false</b>

              Types:

                 Pred = fun((T) -&gt; boolean())
                 List = [T]
                 Value = T

              If there is a <u>Value</u> in <u>List</u> such that <u>Pred(Value)</u> returns <u>true</u>, returns  <u>{value,</u>  <u>Value}</u>  for  the
              first such <u>Value</u>, otherwise returns <u>false</u>. The <u>Pred</u> function must return a boolean.

       <b>seq(From,</b> <b>To)</b> <b>-&gt;</b> <b>Seq</b>

       <b>seq(From,</b> <b>To,</b> <b>Incr)</b> <b>-&gt;</b> <b>Seq</b>

              Types:

                 From = To = Incr = integer()
                 Seq = [integer()]

              Returns a sequence of integers that starts with <u>From</u> and contains the successive results of adding
              <u>Incr</u>  to  the  previous  element,  until <u>To</u> is reached or passed (in the latter case, <u>To</u> is not an
              element of the sequence). <u>Incr</u> defaults to 1.

              Failures:

                * If <u>To</u> <u>&lt;</u> <u>From</u> <u>-</u> <u>Incr</u> and <u>Incr</u> <u>&gt;</u> <u>0</u>.

                * If <u>To</u> <u>&gt;</u> <u>From</u> <u>-</u> <u>Incr</u> and <u>Incr</u> <u>&lt;</u> <u>0</u>.

                * If <u>Incr</u> <u>=:=</u> <u>0</u> and <u>From</u> <u>=/=</u> <u>To</u>.

              The following equalities hold for all sequences:

              length(lists:seq(From, To)) =:= To - From + 1
              length(lists:seq(From, To, Incr)) =:= (To - From + Incr) div Incr

              <u>Examples:</u>

              &gt; lists:seq(1, 10).
              [1,2,3,4,5,6,7,8,9,10]
              &gt; lists:seq(1, 20, 3).
              [1,4,7,10,13,16,19]
              &gt; lists:seq(1, 0, 1).
              []
              &gt; lists:seq(10, 6, 4).
              []
              &gt; lists:seq(1, 1, 0).
              [1]

       <b>sort(List1)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 List1 = List2 = [T]
                 T = term()

              Returns a list containing the sorted elements of <u>List1</u>.

       <b>sort(Fun,</b> <b>List1)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 Fun = fun((A :: T, B :: T) -&gt; boolean())
                 List1 = List2 = [T]
                 T = term()

              Returns a list containing the sorted elements of <u>List1</u>, according to the  ordering  function  <u>Fun</u>.
              <u>Fun(A,</u>  <u>B)</u>  is  to  return  <u>true</u>  if <u>A</u> compares less than or equal to <u>B</u> in the ordering, otherwise
              <u>false</u>.

       <b>split(N,</b> <b>List1)</b> <b>-&gt;</b> <b>{List2,</b> <b>List3}</b>

              Types:

                 N = integer() &gt;= 0
                   0..length(List1)
                 List1 = List2 = List3 = [T]
                 T = term()

              Splits <u>List1</u> into <u>List2</u> and <u>List3</u>. <u>List2</u> contains the first <u>N</u> elements  and  <u>List3</u>  the  remaining
              elements (the <u>N</u>th tail).

       <b>splitwith(Pred,</b> <b>List)</b> <b>-&gt;</b> <b>{List1,</b> <b>List2}</b>

              Types:

                 Pred = fun((T) -&gt; boolean())
                 List = List1 = List2 = [T]
                 T = term()

              Partitions  <u>List</u>  into  two  lists  according  to <u>Pred</u>. <u>splitwith/2</u> behaves as if it is defined as
              follows:

              splitwith(Pred, List) -&gt;
                  {takewhile(Pred, List), dropwhile(Pred, List)}.

              <u>Examples:</u>

              &gt; lists:splitwith(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]).
              {[1],[2,3,4,5,6,7]}
              &gt; lists:splitwith(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]).
              {[a,b],[1,c,d,2,3,4,e]}

              The <u>Pred</u> function must return a boolean. For a different way to partition a list, see <u>partition/2</u>.

       <b>sublist(List1,</b> <b>Len)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 List1 = List2 = [T]
                 Len = integer() &gt;= 0
                 T = term()

              Returns the sublist of <u>List1</u> starting at position 1 and with (maximum) <u>Len</u> elements. It is not  an
              error for <u>Len</u> to exceed the length of the list, in that case the whole list is returned.

       <b>sublist(List1,</b> <b>Start,</b> <b>Len)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 List1 = List2 = [T]
                 Start = integer() &gt;= 1
                   1..(length(List1)+1)
                 Len = integer() &gt;= 0
                 T = term()

              Returns the sublist of <u>List1</u> starting at <u>Start</u> and with (maximum) <u>Len</u> elements. It is not an error
              for <u>Start+Len</u> to exceed the length of the list.

              <u>Examples:</u>

              &gt; lists:sublist([1,2,3,4], 2, 2).
              [2,3]
              &gt; lists:sublist([1,2,3,4], 2, 5).
              [2,3,4]
              &gt; lists:sublist([1,2,3,4], 5, 2).
              []

       <b>subtract(List1,</b> <b>List2)</b> <b>-&gt;</b> <b>List3</b>

              Types:

                 List1 = List2 = List3 = [T]
                 T = term()

              Returns  a  new list <u>List3</u> that is a copy of <u>List1</u>, subjected to the following procedure: for each
              element in <u>List2</u>, its first occurrence in <u>List1</u> is deleted.

              <u>Example:</u>

              &gt; lists:subtract("123212", "212").
              "312".

              <u>lists:subtract(A,</u> <u>B)</u> is equivalent to <u>A</u> <u>--</u> <u>B</u>.

       <b>suffix(List1,</b> <b>List2)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 List1 = List2 = [T]
                 T = term()

              Returns <u>true</u> if <u>List1</u> is a suffix of <u>List2</u>, otherwise <u>false</u>.

       <b>sum(List)</b> <b>-&gt;</b> <b>number()</b>

              Types:

                 List = [number()]

              Returns the sum of the elements in <u>List</u>.

       <b>takewhile(Pred,</b> <b>List1)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 Pred = fun((Elem :: T) -&gt; boolean())
                 List1 = List2 = [T]
                 T = term()

              Takes elements <u>Elem</u> from <u>List1</u> while <u>Pred(Elem)</u> returns <u>true</u>, that is, the  function  returns  the
              longest  prefix  of  the list for which all elements satisfy the predicate. The <u>Pred</u> function must
              return a boolean.

       <b>ukeymerge(N,</b> <b>TupleList1,</b> <b>TupleList2)</b> <b>-&gt;</b> <b>TupleList3</b>

              Types:

                 N = integer() &gt;= 1
                   1..tuple_size(Tuple)
                 TupleList1 = [T1]
                 TupleList2 = [T2]
                 TupleList3 = [T1 | T2]
                 T1 = T2 = Tuple
                 Tuple = tuple()

              Returns the sorted list formed by merging <u>TupleList1</u> and <u>TupleList2</u>. The merge is performed on the
              <u>N</u>th element of each tuple. Both <u>TupleList1</u> and <u>TupleList2</u> must be  key-sorted  without  duplicates
              before  evaluating  this  function.  When  two  tuples compare equal, the tuple from <u>TupleList1</u> is
              picked and the one from <u>TupleList2</u> is deleted.

       <b>ukeysort(N,</b> <b>TupleList1)</b> <b>-&gt;</b> <b>TupleList2</b>

              Types:

                 N = integer() &gt;= 1
                   1..tuple_size(Tuple)
                 TupleList1 = TupleList2 = [Tuple]
                 Tuple = tuple()

              Returns a list containing the sorted elements of list <u>TupleList1</u> where all except the first  tuple
              of  the  tuples  comparing equal have been deleted. Sorting is performed on the <u>N</u>th element of the
              tuples.

       <b>umerge(ListOfLists)</b> <b>-&gt;</b> <b>List1</b>

              Types:

                 ListOfLists = [List]
                 List = List1 = [T]
                 T = term()

              Returns the sorted list formed by merging all the sublists of <u>ListOfLists</u>. All  sublists  must  be
              sorted and contain no duplicates before evaluating this function. When two elements compare equal,
              the  element  from  the sublist with the lowest position in <u>ListOfLists</u> is picked and the other is
              deleted.

       <b>umerge(List1,</b> <b>List2)</b> <b>-&gt;</b> <b>List3</b>

              Types:

                 List1 = [X]
                 List2 = [Y]
                 List3 = [X | Y]
                 X = Y = term()

              Returns the sorted list formed by merging <u>List1</u> and <u>List2</u>. Both <u>List1</u> and <u>List2</u> must be sorted and
              contain no duplicates before evaluating this  function.  When  two  elements  compare  equal,  the
              element from <u>List1</u> is picked and the one from <u>List2</u> is deleted.

       <b>umerge(Fun,</b> <b>List1,</b> <b>List2)</b> <b>-&gt;</b> <b>List3</b>

              Types:

                 Fun = fun((A, B) -&gt; boolean())
                 List1 = [A]
                 List2 = [B]
                 List3 = [A | B]
                 A = B = term()

              Returns  the  sorted  list  formed by merging <u>List1</u> and <u>List2</u>. Both <u>List1</u> and <u>List2</u> must be sorted
              according to the ordering function <u>Fun</u> and contain no duplicates before evaluating this  function.
              <u>Fun(A,</u>  <u>B)</u>  is  to  return  <u>true</u>  if <u>A</u> compares less than or equal to <u>B</u> in the ordering, otherwise
              <u>false</u>. When two elements compare equal, the element from <u>List1</u> is picked and the one from <u>List2</u> is
              deleted.

       <b>umerge3(List1,</b> <b>List2,</b> <b>List3)</b> <b>-&gt;</b> <b>List4</b>

              Types:

                 List1 = [X]
                 List2 = [Y]
                 List3 = [Z]
                 List4 = [X | Y | Z]
                 X = Y = Z = term()

              Returns the sorted list formed by merging <u>List1</u>, <u>List2</u>, and <u>List3</u>. All of <u>List1</u>, <u>List2</u>, and  <u>List3</u>
              must  be  sorted  and  contain  no  duplicates  before evaluating this function. When two elements
              compare equal, the element from <u>List1</u> is picked if there is such an element, otherwise the element
              from <u>List2</u> is picked, and the other is deleted.

       <b>unzip(List1)</b> <b>-&gt;</b> <b>{List2,</b> <b>List3}</b>

              Types:

                 List1 = [{A, B}]
                 List2 = [A]
                 List3 = [B]
                 A = B = term()

              "Unzips" a list of two-tuples into two lists, where the first list contains the first  element  of
              each tuple, and the second list contains the second element of each tuple.

       <b>unzip3(List1)</b> <b>-&gt;</b> <b>{List2,</b> <b>List3,</b> <b>List4}</b>

              Types:

                 List1 = [{A, B, C}]
                 List2 = [A]
                 List3 = [B]
                 List4 = [C]
                 A = B = C = term()

              "Unzips"  a list of three-tuples into three lists, where the first list contains the first element
              of each tuple, the second list contains the second element of  each  tuple,  and  the  third  list
              contains the third element of each tuple.

       <b>usort(List1)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 List1 = List2 = [T]
                 T = term()

              Returns  a  list containing the sorted elements of <u>List1</u> where all except the first element of the
              elements comparing equal have been deleted.

       <b>usort(Fun,</b> <b>List1)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 Fun = fun((T, T) -&gt; boolean())
                 List1 = List2 = [T]
                 T = term()

              Returns a list containing the sorted elements of <u>List1</u> where all except the first element  of  the
              elements comparing equal according to the ordering function <u>Fun</u> have been deleted. <u>Fun(A,</u> <u>B)</u> is to
              return <u>true</u> if <u>A</u> compares less than or equal to <u>B</u> in the ordering, otherwise <u>false</u>.

       <b>zip(List1,</b> <b>List2)</b> <b>-&gt;</b> <b>List3</b>

              Types:

                 List1 = [A]
                 List2 = [B]
                 List3 = [{A, B}]
                 A = B = term()

              "Zips"  two  lists  of  equal  length into one list of two-tuples, where the first element of each
              tuple is taken from the first list and the second element is taken from the corresponding  element
              in the second list.

       <b>zip3(List1,</b> <b>List2,</b> <b>List3)</b> <b>-&gt;</b> <b>List4</b>

              Types:

                 List1 = [A]
                 List2 = [B]
                 List3 = [C]
                 List4 = [{A, B, C}]
                 A = B = C = term()

              "Zips"  three lists of equal length into one list of three-tuples, where the first element of each
              tuple is taken from the first list, the second element is taken from the corresponding element  in
              the second list, and the third element is taken from the corresponding element in the third list.

       <b>zipwith(Combine,</b> <b>List1,</b> <b>List2)</b> <b>-&gt;</b> <b>List3</b>

              Types:

                 Combine = fun((X, Y) -&gt; T)
                 List1 = [X]
                 List2 = [Y]
                 List3 = [T]
                 X = Y = T = term()

              Combines  the  elements  of  two  lists  of equal length into one list. For each pair <u>X,</u> <u>Y</u> of list
              elements from the two lists, the element in the result list is <u>Combine(X,</u> <u>Y)</u>.

              <u>zipwith(fun(X,</u> <u>Y)</u> <u>-&gt;</u> <u>{X,Y}</u> <u>end,</u> <u>List1,</u> <u>List2)</u> is equivalent to <u>zip(List1,</u> <u>List2)</u>.

              <u>Example:</u>

              &gt; lists:zipwith(fun(X, Y) -&gt; X+Y end, [1,2,3], [4,5,6]).
              [5,7,9]

       <b>zipwith3(Combine,</b> <b>List1,</b> <b>List2,</b> <b>List3)</b> <b>-&gt;</b> <b>List4</b>

              Types:

                 Combine = fun((X, Y, Z) -&gt; T)
                 List1 = [X]
                 List2 = [Y]
                 List3 = [Z]
                 List4 = [T]
                 X = Y = Z = T = term()

              Combines the elements of three lists of equal length into one list. For each triple  <u>X,</u>  <u>Y,</u>  <u>Z</u>  of
              list elements from the three lists, the element in the result list is <u>Combine(X,</u> <u>Y,</u> <u>Z)</u>.

              <u>zipwith3(fun(X,</u>  <u>Y,</u>  <u>Z)</u>  <u>-&gt;</u>  <u>{X,Y,Z}</u> <u>end,</u> <u>List1,</u> <u>List2,</u> <u>List3)</u> is equivalent to <u>zip3(List1,</u> <u>List2,</u>
              <u>List3)</u>.

              <u>Examples:</u>

              &gt; lists:zipwith3(fun(X, Y, Z) -&gt; X+Y+Z end, [1,2,3], [4,5,6], [7,8,9]).
              [12,15,18]
              &gt; lists:zipwith3(fun(X, Y, Z) -&gt; [X,Y,Z] end, [a,b,c], [x,y,z], [1,2,3]).
              [[a,x,1],[b,y,2],[c,z,3]]

Ericsson AB                                        stdlib 3.17                                       <u><a href="../man3erl/lists.3erl.html">lists</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>