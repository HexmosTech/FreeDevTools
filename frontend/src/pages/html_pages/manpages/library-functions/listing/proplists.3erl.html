<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>proplists - Support functions for property lists.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       proplists - Support functions for property lists.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Property  lists  are ordinary lists containing entries in the form of either tuples, whose first elements
       are keys used for lookup and insertion, or atoms, which work as shorthand for tuples <u>{Atom,</u> <u>true}</u>. (Other
       terms are allowed in the lists, but are ignored by this module.) If there is more than  one  entry  in  a
       list  for  a certain key, the first occurrence normally overrides any later (irrespective of the arity of
       the tuples).

       Property lists are useful for representing inherited properties, such as options  passed  to  a  function
       where  a user can specify options overriding the default settings, object properties, annotations, and so
       on.

       Two keys are considered equal if they match (<u>=:=</u>). That is, numbers are compared literally rather than by
       value, so that, for example, <u>1</u> and <u>1.0</u> are different keys.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>property()</b> = atom() | tuple()

       <b>proplist()</b> = [property()]

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>append_values(Key,</b> <b>ListIn)</b> <b>-&gt;</b> <b>ListOut</b>

              Types:

                 Key = term()
                 ListIn = ListOut = [term()]

              Similar to <u>get_all_values/2</u>, but each value is wrapped in a list unless it  is  already  itself  a
              list. The resulting list of lists is concatenated. This is often useful for "incremental" options.

              <u>Example:</u>

              append_values(a, [{a, [1,2]}, {b, 0}, {a, 3}, {c, -1}, {a, [4]}])

              returns:

              [1,2,3,4]

       <b>compact(ListIn)</b> <b>-&gt;</b> <b>ListOut</b>

              Types:

                 ListIn = ListOut = [property()]

              Minimizes  the  representation of all entries in the list. This is equivalent to <u>[property(P)</u> <u>||</u> <u>P</u>
              <u>&lt;-</u> <u>ListIn]</u>.

              See also <u>property/1</u>, <u>unfold/1</u>.

       <b>delete(Key,</b> <b>List)</b> <b>-&gt;</b> <b>List</b>

              Types:

                 Key = term()
                 List = [term()]

              Deletes all entries associated with <u>Key</u> from <u>List</u>.

       <b>expand(Expansions,</b> <b>ListIn)</b> <b>-&gt;</b> <b>ListOut</b>

              Types:

                 Expansions = [{Property :: property(), Expansion :: [term()]}]
                 ListIn = ListOut = [term()]

              Expands particular properties to corresponding sets of properties (or other terms). For each  pair
              <u>{Property,</u>  <u>Expansion}</u>  in  <u>Expansions</u>:  if  <u>E</u>  is  the first entry in <u>ListIn</u> with the same key as
              <u>Property</u>, and <u>E</u> and <u>Property</u> have equivalent normal forms, then <u>E</u> is replaced with  the  terms  in
              <u>Expansion</u>, and any following entries with the same key are deleted from <u>ListIn</u>.

              For example, the following expressions all return <u>[fie,</u> <u>bar,</u> <u>baz,</u> <u>fum]</u>:

              expand([{foo, [bar, baz]}], [fie, foo, fum])
              expand([{{foo, true}, [bar, baz]}], [fie, foo, fum])
              expand([{{foo, false}, [bar, baz]}], [fie, {foo, false}, fum])

              However, no expansion is done in the following call because <u>{foo,</u> <u>false}</u> shadows <u>foo</u>:

              expand([{{foo, true}, [bar, baz]}], [{foo, false}, fie, foo, fum])

              Notice  that if the original property term is to be preserved in the result when expanded, it must
              be included in the expansion list. The inserted terms are not expanded recursively. If  <u>Expansions</u>
              contains more than one property with the same key, only the first occurrence is used.

              See also <u>normalize/2</u>.

       <b>from_map(Map)</b> <b>-&gt;</b> <b>List</b>

              Types:

                 Map = #{Key =&gt; Value}
                 List = [{Key, Value}]
                 Key = Value = term()

              Converts the map <u>Map</u> to a property list.

       <b>get_all_values(Key,</b> <b>List)</b> <b>-&gt;</b> <b>[term()]</b>

              Types:

                 Key = term()
                 List = [term()]

              Similar to <u>get_value/2</u>, but returns the list of values for <u>all</u> entries <u>{Key,</u> <u>Value}</u> in <u>List</u>. If no
              such entry exists, the result is the empty list.

       <b>get_bool(Key,</b> <b>List)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Key = term()
                 List = [term()]

              Returns  the  value  of  a boolean key/value option. If <u>lookup(Key,</u> <u>List)</u> would yield <u>{Key,</u> <u>true}</u>,
              this function returns <u>true</u>, otherwise <u>false</u>.

              See also <u>get_value/2</u>, <u>lookup/2</u>.

       <b>get_keys(List)</b> <b>-&gt;</b> <b>[term()]</b>

              Types:

                 List = [term()]

              Returns an unordered list of the keys used in <u>List</u>, not containing duplicates.

       <b>get_value(Key,</b> <b>List)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 Key = term()
                 List = [term()]

              Equivalent to <u>get_value(Key,</u> <u>List,</u> <u>undefined)</u>.

       <b>get_value(Key,</b> <b>List,</b> <b>Default)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 Key = term()
                 List = [term()]
                 Default = term()

              Returns the value of a simple key/value property in <u>List</u>. If <u>lookup(Key,</u> <u>List)</u> would  yield  <u>{Key,</u>
              <u>Value}</u>, this function returns the corresponding <u>Value</u>, otherwise <u>Default</u>.

              See also <u>get_all_values/2</u>, <u>get_bool/2</u>, <u>get_value/2</u>, <u>lookup/2</u>.

       <b>is_defined(Key,</b> <b>List)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Key = term()
                 List = [term()]

              Returns <u>true</u> if <u>List</u> contains at least one entry associated with <u>Key</u>, otherwise <u>false</u>.

       <b>lookup(Key,</b> <b>List)</b> <b>-&gt;</b> <b>none</b> <b>|</b> <b>tuple()</b>

              Types:

                 Key = term()
                 List = [term()]

              Returns the first entry associated with <u>Key</u> in <u>List</u>, if one exists, otherwise returns <u>none</u>. For an
              atom <u>A</u> in the list, the tuple <u>{A,</u> <u>true}</u> is the entry associated with <u>A</u>.

              See also <u>get_bool/2</u>, <u>get_value/2</u>, <u>lookup_all/2</u>.

       <b>lookup_all(Key,</b> <b>List)</b> <b>-&gt;</b> <b>[tuple()]</b>

              Types:

                 Key = term()
                 List = [term()]

              Returns  the  list of all entries associated with <u>Key</u> in <u>List</u>. If no such entry exists, the result
              is the empty list.

              See also <u>lookup/2</u>.

       <b>normalize(ListIn,</b> <b>Stages)</b> <b>-&gt;</b> <b>ListOut</b>

              Types:

                 ListIn = [term()]
                 Stages = [Operation]
                 Operation =
                     {aliases, Aliases} |
                     {negations, Negations} |
                     {expand, Expansions}
                 Aliases = Negations = [{Key, Key}]
                 Expansions = [{Property :: property(), Expansion :: [term()]}]
                 ListOut = [term()]

              Passes <u>ListIn</u> through a sequence of  substitution/expansion  stages.  For  an  <u>aliases</u>  operation,
              function <u>substitute_aliases/2</u> is applied using the specified list of aliases:

                * For  a  <u>negations</u>  operation,  <u>substitute_negations/2</u>  is applied using the specified negation
                  list.

                * For an <u>expand</u> operation, function <u>expand/2</u> is applied using the specified list of expansions.

              The final result is automatically compacted (compare <u>compact/1</u>).

              Typically you want to  substitute  negations  first,  then  aliases,  then  perform  one  or  more
              expansions  (sometimes you want to pre-expand particular entries before doing the main expansion).
              You might want to substitute negations and/or aliases repeatedly,  to  allow  such  forms  in  the
              right-hand side of aliases and expansion lists.

              See also <u>substitute_negations/2</u>.

       <b>property(PropertyIn)</b> <b>-&gt;</b> <b>PropertyOut</b>

              Types:

                 PropertyIn = PropertyOut = property()

              Creates  a normal form (minimal) representation of a property. If <u>PropertyIn</u> is <u>{Key,</u> <u>true}</u>, where
              <u>Key</u> is an atom, <u>Key</u> is returned, otherwise the whole term <u>PropertyIn</u> is returned.

              See also <u>property/2</u>.

       <b>property(Key,</b> <b>Value)</b> <b>-&gt;</b> <b>Property</b>

              Types:

                 Key = Value = term()
                 Property = atom() | {term(), term()}

              Creates a normal form (minimal) representation of a simple  key/value  property.  Returns  <u>Key</u>  if
              <u>Value</u> is <u>true</u> and <u>Key</u> is an atom, otherwise a tuple <u>{Key,</u> <u>Value}</u> is returned.

              See also <u>property/1</u>.

       <b>split(List,</b> <b>Keys)</b> <b>-&gt;</b> <b>{Lists,</b> <b>Rest}</b>

              Types:

                 List = Keys = [term()]
                 Lists = [[term()]]
                 Rest = [term()]

              Partitions  <u>List</u>  into a list of sublists and a remainder. <u>Lists</u> contains one sublist for each key
              in <u>Keys</u>, in the corresponding order. The relative  order  of  the  elements  in  each  sublist  is
              preserved  from the original <u>List</u>. <u>Rest</u> contains the elements in <u>List</u> that are not associated with
              any of the specified keys, also with their original relative order preserved.

              <u>Example:</u>

              split([{c, 2}, {e, 1}, a, {c, 3, 4}, d, {b, 5}, b], [a, b, c])

              returns:

              {[[a], [{b, 5}, b],[{c, 2}, {c, 3, 4}]], [{e, 1}, d]}

       <b>substitute_aliases(Aliases,</b> <b>ListIn)</b> <b>-&gt;</b> <b>ListOut</b>

              Types:

                 Aliases = [{Key, Key}]
                 Key = term()
                 ListIn = ListOut = [term()]

              Substitutes keys of properties. For each entry in <u>ListIn</u>, if it is associated  with  some  key  <u>K1</u>
              such that <u>{K1,</u> <u>K2}</u> occurs in <u>Aliases</u>, the key of the entry is changed to <u>K2</u>. If the same <u>K1</u> occurs
              more than once in <u>Aliases</u>, only the first occurrence is used.

              For  example,  <u>substitute_aliases([{color,</u> <u>colour}],</u> <u>L)</u> replaces all tuples <u>{color,</u> <u>...}</u> in <u>L</u> with
              <u>{colour,</u> <u>...}</u>, and all atoms <u>color</u> with <u>colour</u>.

              See also <u>normalize/2</u>, <u>substitute_negations/2</u>.

       <b>substitute_negations(Negations,</b> <b>ListIn)</b> <b>-&gt;</b> <b>ListOut</b>

              Types:

                 Negations = [{Key1, Key2}]
                 Key1 = Key2 = term()
                 ListIn = ListOut = [term()]

              Substitutes keys of boolean-valued properties and simultaneously negates their  values.  For  each
              entry  in  <u>ListIn</u>, if it is associated with some key <u>K1</u> such that <u>{K1,</u> <u>K2}</u> occurs in <u>Negations</u>: if
              the entry was <u>{K1,</u> <u>true}</u>, it is replaced with <u>{K2,</u> <u>false}</u>, otherwise with <u>K2</u>,  thus  changing  the
              name  of  the  option and simultaneously negating the value specified by <u>get_bool(Key,</u> <u>ListIn)</u>. If
              the same <u>K1</u> occurs more than once in <u>Negations</u>, only the first occurrence is used.

              For example, <u>substitute_negations([{no_foo,</u> <u>foo}],</u> <u>L)</u> replaces any atom <u>no_foo</u> or  tuple  <u>{no_foo,</u>
              <u>true}</u> in <u>L</u> with <u>{foo,</u> <u>false}</u>, and any other tuple <u>{no_foo,</u> <u>...}</u> with <u>foo</u>.

              See also <u>get_bool/2</u>, <u>normalize/2</u>, <u>substitute_aliases/2</u>.

       <b>to_map(List)</b> <b>-&gt;</b> <b>Map</b>

              Types:

                 List = [Shorthand | {Key, Value} | term()]
                 Map = #{Shorthand =&gt; true, Key =&gt; Value}
                 Shorthand = atom()
                 Key = Value = term()

              Converts the property list <u>List</u> to a map.

              Shorthand  atom values in <u>List</u> will be expanded to an association of the form <u>Atom</u> <u>=&gt;</u> <u>true</u>. Tuples
              of the form <u>{Key,</u> <u>Value}</u> in <u>List</u> will be converted to an association of the  form  <u>Key</u>  <u>=&gt;</u>  <u>Value</u>.
              Anything else will be silently ignored.

              If the same key appears in <u>List</u> multiple times, the value of the one appearing nearest to the head
              of  <u>List</u>  will  be  in  the  result  map,  that  is  the value that would be returned by a call to
              <u>get_value(Key,</u> <u>List)</u>.

              <u>Example:</u>

              to_map([a, {b, 1}, {c, 2}, {c, 3}])

              returns:

              #{a =&gt; true, b =&gt; 1, c =&gt; 2}

       <b>to_map(List,</b> <b>Stages)</b> <b>-&gt;</b> <b>Map</b>

              Types:

                 List = [term()]
                 Stages = [Operation]
                 Operation =
                     {aliases, Aliases} |
                     {negations, Negations} |
                     {expand, Expansions}
                 Aliases = Negations = [{Key, Key}]
                 Expansions = [{Property :: property(), Expansion :: [term()]}]
                 Map = #{term() =&gt; term()}

              Converts the property list <u>List</u> to a map after applying the normalizations given in <u>Stages</u>.

              See also <u>normalize/2</u>, <u>to_map/1</u>.

       <b>unfold(ListIn)</b> <b>-&gt;</b> <b>ListOut</b>

              Types:

                 ListIn = ListOut = [term()]

              Unfolds all occurrences of atoms in <u>ListIn</u> to tuples <u>{Atom,</u> <u>true}</u>.

Ericsson AB                                        stdlib 3.17                                   <u><a href="../man3erl/proplists.3erl.html">proplists</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>