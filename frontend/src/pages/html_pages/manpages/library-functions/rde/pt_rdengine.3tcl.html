<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pt::rde - Parsing Runtime Support, PARAM based</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pt::rde - Parsing Runtime Support, PARAM based

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>pt::rde</b> <b>?1.2?</b>

       package require <b>snit</b>

       package require <b>struct::stack</b> <b>1.6</b>

       package require <b>pt::ast</b> <b>1.2</b>

       <b>::pt::rde</b> <u>objectName</u>

       <u>objectName</u> <b>destroy</b>

       <u>objectName</u> <b>reset</b> <u>chan</u>

       <u>objectName</u> <b>complete</b>

       <u>objectName</u> <b>chan</b>

       <u>objectName</u> <b>line</b>

       <u>objectName</u> <b>column</b>

       <u>objectName</u> <b>current</b>

       <u>objectName</u> <b>location</b>

       <u>objectName</u> <b>locations</b>

       <u>objectName</u> <b>ok</b>

       <u>objectName</u> <b>value</b>

       <u>objectName</u> <b>error</b>

       <u>objectName</u> <b>errors</b>

       <u>objectName</u> <b>tokens</b> ?<u>from</u> ?<u>to</u>??

       <u>objectName</u> <b>symbols</b>

       <u>objectName</u> <b>known</b>

       <u>objectName</u> <b>reducible</b>

       <u>objectName</u> <b>asts</b>

       <u>objectName</u> <b>ast</b>

       <u>objectName</u> <b>position</b> <u>loc</u>

       <u>objectName</u> <b>i_input_next</b> <u>msg</u>

       <u>objectName</u> <b>i_test_alnum</b>

       <u>objectName</u> <b>i_test_alpha</b>

       <u>objectName</u> <b>i_test_ascii</b>

       <u>objectName</u> <b>i_test_char</b> <u>char</u>

       <u>objectName</u> <b>i_test_ddigit</b>

       <u>objectName</u> <b>i_test_digit</b>

       <u>objectName</u> <b>i_test_graph</b>

       <u>objectName</u> <b>i_test_lower</b>

       <u>objectName</u> <b>i_test_print</b>

       <u>objectName</u> <b>i_test_punct</b>

       <u>objectName</u> <b>i_test_range</b> <u>chars</u> <u>chare</u>

       <u>objectName</u> <b>i_test_space</b>

       <u>objectName</u> <b>i_test_upper</b>

       <u>objectName</u> <b>i_test_wordchar</b>

       <u>objectName</u> <b>i_test_xdigit</b>

       <u>objectName</u> <b>i_error_clear</b>

       <u>objectName</u> <b>i_error_push</b>

       <u>objectName</u> <b>i_error_pop_merge</b>

       <u>objectName</u> <b>i_error_nonterminal</b> <u>symbol</u>

       <u>objectName</u> <b>i_status_ok</b>

       <u>objectName</u> <b>i_status_fail</b>

       <u>objectName</u> <b>i_status_negate</b>

       <u>objectName</u> <b>i_loc_push</b>

       <u>objectName</u> <b>i_loc_pop_discard</b>

       <u>objectName</u> <b>i_loc_pop_rewind</b>

       <u>objectName</u> <b>i:ok_loc_pop_rewind</b>

       <u>objectName</u> <b>i_loc_pop_rewind/discard</b>

       <u>objectName</u> <b>i_symbol_restore</b> <u>symbol</u>

       <u>objectName</u> <b>i_symbol_save</b> <u>symbol</u>

       <u>objectName</u> <b>i_value_clear</b>

       <u>objectName</u> <b>i_value_clear/leaf</b>

       <u>objectName</u> <b>i_value_clear/reduce</b>

       <u>objectName</u> <b>i:ok_ast_value_push</b>

       <u>objectName</u> <b>i_ast_push</b>

       <u>objectName</u> <b>i_ast_pop_rewind</b>

       <u>objectName</u> <b>i:fail_ast_pop_rewind</b>

       <u>objectName</u> <b>i_ast_pop_rewind/discard</b>

       <u>objectName</u> <b>i_ast_pop_discard</b>

       <u>objectName</u> <b>i_ast_pop_discard/rewind</b>

       <u>objectName</u> <b>i:ok_continue</b>

       <u>objectName</u> <b>i:fail_continue</b>

       <u>objectName</u> <b>i:fail_return</b>

       <u>objectName</u> <b>i:ok_return</b>

       <u>objectName</u> <b>si:void_state_push</b>

       <u>objectName</u> <b>si:void2_state_push</b>

       <u>objectName</u> <b>si:value_state_push</b>

       <u>objectName</u> <b>si:void_state_merge</b>

       <u>objectName</u> <b>si:void_state_merge_ok</b>

       <u>objectName</u> <b>si:value_state_merge</b>

       <u>objectName</u> <b>si:value_notahead_start</b>

       <u>objectName</u> <b>si:void_notahead_exit</b>

       <u>objectName</u> <b>si:value_notahead_exit</b>

       <u>objectName</u> <b>si:kleene_abort</b>

       <u>objectName</u> <b>si:kleene_close</b>

       <u>objectName</u> <b>si:voidvoid_branch</b>

       <u>objectName</u> <b>si:voidvalue_branch</b>

       <u>objectName</u> <b>si:valuevoid_branch</b>

       <u>objectName</u> <b>si:valuevalue_branch</b>

       <u>objectName</u> <b>si:voidvoid_part</b>

       <u>objectName</u> <b>si:voidvalue_part</b>

       <u>objectName</u> <b>si:valuevalue_part</b>

       <u>objectName</u> <b>si:value_symbol_start</b> <u>symbol</u>

       <u>objectName</u> <b>si:value_void_symbol_start</b> <u>symbol</u>

       <u>objectName</u> <b>si:void_symbol_start</b> <u>symbol</u>

       <u>objectName</u> <b>si:void_void_symbol_start</b> <u>symbol</u>

       <u>objectName</u> <b>si:reduce_symbol_end</b> <u>symbol</u>

       <u>objectName</u> <b>si:void_leaf_symbol_end</b> <u>symbol</u>

       <u>objectName</u> <b>si:value_leaf_symbol_end</b> <u>symbol</u>

       <u>objectName</u> <b>si:value_clear_symbol_end</b> <u>symbol</u>

       <u>objectName</u> <b>si:void_clear_symbol_end</b> <u>symbol</u>

       <u>objectName</u> <b>si:next_char</b> <u>tok</u>

       <u>objectName</u> <b>si:next_range</b> <u>toks</u> <u>toke</u>

       <u>objectName</u> <b>si:next_alnum</b>

       <u>objectName</u> <b>si:next_alpha</b>

       <u>objectName</u> <b>si:next_ascii</b>

       <u>objectName</u> <b>si:next_ddigit</b>

       <u>objectName</u> <b>si:next_digit</b>

       <u>objectName</u> <b>si:next_graph</b>

       <u>objectName</u> <b>si:next_lower</b>

       <u>objectName</u> <b>si:next_print</b>

       <u>objectName</u> <b>si:next_punct</b>

       <u>objectName</u> <b>si:next_space</b>

       <u>objectName</u> <b>si:next_upper</b>

       <u>objectName</u> <b>si:next_wordchar</b>

       <u>objectName</u> <b>si:next_xdigit</b>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Are  you lost ?  Do you have trouble understanding this document ?  In that case please read the overview
       provided by the <u>Introduction</u> <u>to</u> <u>Parser</u> <u>Tools</u>. This document is the entrypoint to  the  whole  system  the
       current package is a part of.

       This  package  provides a class whose instances provide the runtime support for recursive descent parsers
       with backtracking, as is needed for the execution  of,  for  example,  parsing  expression  grammars.  It
       implements  the  <u>PackRat</u>  <u>Machine</u>  <u>Specification</u>, as such that document is <u>required</u> reading to understand
       both this manpage, and the package itself. The description below does make numerous shorthand  references
       to the PARAM's instructions and the various parts of its architectural state.

       The package resides in the Execution section of the Core Layer of Parser Tools.

       IMAGE: arch_core_transform

       Note:  This  package  not  only  has  the  standard Tcl implementation, but also an accelerator, i.e. a C
       implementation, based on Critcl.

   <b>CLASS</b> <b>API</b>
       The package exports the API described here.

       <b>::pt::rde</b> <u>objectName</u>
              The command creates a new runtime object for a recursive  descent  parser  with  backtracking  and
              returns  the  fully  qualified  name  of  the object command as its result. The API of this object
              command is described in the section <b>Object</b> <b>API</b>. It may be used to invoke various operations on the
              object.

   <b>OBJECT</b> <b>API</b>
       All objects created by this package provide the following 63 methods for the manipulation and querying of
       their state, which is, in essence the architectural state of a PARAM.

       First some general methods and the state accessors.

       <u>objectName</u> <b>destroy</b>
              This method destroys the object, releasing all claimed memory, and deleting the associated  object
              command.

       <u>objectName</u> <b>reset</b> <u>chan</u>
              This  method  resets  the state of the runtme to its defaults, preparing it for the parsing of the
              character in the channel <u>chan</u>, which becomes IN.

              Note here that the Parser Tools are based on Tcl 8.5+. In other words, the channel argument is not
              restricted to files, sockets, etc. We have the full power of <u>reflected</u> <u>channels</u> available.

              It should also be noted that the parser pulls the characters from the input  stream  as  it  needs
              them.  If a parser created by this package has to be operated in a push aka event-driven manner it
              will be necessary to go to Tcl 8.6+ and use the <b>coroutine::auto</b> to wrap it into a coroutine  where
              <b>read</b> is properly changed for push-operation.

       <u>objectName</u> <b>complete</b>
              This method completes parsing, either returning the AST made from the elements of ARS, or throwing
              an error containing the current ER.

       <u>objectName</u> <b>chan</b>
              This method returns the handle of the channel which is IN.

       <u>objectName</u> <b>line</b>
              This  method  returns  the line number for the position IN is currently at. Note that this may not
              match with the line number for CL, due to backtracking.

       <u>objectName</u> <b>column</b>
              This method returns the column for the position IN is currently at. Note that this may  not  match
              with the column for CL, due to backtracking.

       <u>objectName</u> <b>current</b>
              This method returns CC.

       <u>objectName</u> <b>location</b>
              This method returns CL.

       <u>objectName</u> <b>locations</b>
              This  method  returns  the  LS.  The  topmost  entry of the stack will be the first element of the
              returned list.

       <u>objectName</u> <b>ok</b>
              This method returns ST.

       <u>objectName</u> <b>value</b>
              This method returns SV.

       <u>objectName</u> <b>error</b>
              This method returns ER. This is either the empty string for an empty ER, or a list of 2  elements,
              the  location the error is for, and a set of messages which specify which symbols were expected at
              the location. The messages are encoded as one of the possible atomic parsing expressions  (special
              operators, terminal, range, and nonterminal operator).

       <u>objectName</u> <b>errors</b>
              This  method  returns ES. The topmost entry of the stack will be the first element of the returned
              list. Each entry is encoded as described for <b>error</b>.

       <u>objectName</u> <b>tokens</b> ?<u>from</u> ?<u>to</u>??
              This method returns the part of TC for the range of locations of IN starting at <u>from</u> and ending at
              <u>to</u>. If <u>to</u> is not specified it is taken as identical to <u>from</u>. If neither argument is specified  the
              whole of TC is returned.

              Each  token  in  the returned list is a list of three elements itself, containing the character at
              the location, and the associated line and column numbers, in this order.

       <u>objectName</u> <b>symbols</b>
              This method returns a dictionary containing NC. Keys are two-element lists containing  nonterminal
              symbol and location, in this order. The values are 4-tuples containing CL, ST, ER, and SV, in this
              order. ER is encoded as specified for the method <b>error</b>.

       <u>objectName</u> <b>known</b>
              This  method  returns  a list containing the keys of SC. They are encoded in the same manner as is
              done by method <b>symbols</b>.

       <u>objectName</u> <b>reducible</b>
              This method returns ARS. The topmost entry of the stack will be the first element of the  returned
              list

       <u>objectName</u> <b>asts</b>
              This  method  returns AS. The topmost entry of the stack will be the first element of the returned
              list

       <u>objectName</u> <b>ast</b>
              This is a convenience method returning the topmost element of ARS.

       <u>objectName</u> <b>position</b> <u>loc</u>
              This method returns the line and column numbers for the specified location of  IN,  assuming  that
              this location has already been reached during the parsing process.

       The following methods implement all PARAM instructions. They all have the prefix "i_".

       The  control  flow is mainly provided by Tcl's builtin commands, like <b>if</b>, <b>while</b>, etc., plus a few guarded
       variants of PARAM instructions and Tcl commands.. That means that  these  instruction  variants  will  do
       nothing  if  their  guard  condition  is  not fulfilled. They can be recognized by the prefix "i:ok_" and
       "i:fail_", which denote the value ST has to have for the instruction to execute.

       The instructions are listed in the same order they occur in the <u>PackRat</u> <u>Machine</u> <u>Specification</u>,  with  the
       guard variants listed after their regular implementation, if any, or in their place.

       <u>objectName</u> <b>i_input_next</b> <u>msg</u>
              This method implements the PARAM instruction <b>input_next</b>.

       <u>objectName</u> <b>i_test_alnum</b>
              This method implements the PARAM instruction <b>test_alnum</b>.

       <u>objectName</u> <b>i_test_alpha</b>
              This method implements the PARAM instruction <b>test_alpha</b>.

       <u>objectName</u> <b>i_test_ascii</b>
              This method implements the PARAM instruction <b>test_ascii</b>.

       <u>objectName</u> <b>i_test_char</b> <u>char</u>
              This method implements the PARAM instruction <b>test_char</b>.

       <u>objectName</u> <b>i_test_ddigit</b>
              This method implements the PARAM instruction <b>test_ddigit</b>.

       <u>objectName</u> <b>i_test_digit</b>
              This method implements the PARAM instruction <b>test_digit</b>.

       <u>objectName</u> <b>i_test_graph</b>
              This method implements the PARAM instruction <b>test_graph</b>.

       <u>objectName</u> <b>i_test_lower</b>
              This method implements the PARAM instruction <b>test_lower</b>.

       <u>objectName</u> <b>i_test_print</b>
              This method implements the PARAM instruction <b>test_print</b>.

       <u>objectName</u> <b>i_test_punct</b>
              This method implements the PARAM instruction <b>test_punct</b>.

       <u>objectName</u> <b>i_test_range</b> <u>chars</u> <u>chare</u>
              This method implements the PARAM instruction <b>test_range</b>.

       <u>objectName</u> <b>i_test_space</b>
              This method implements the PARAM instruction <b>test_space</b>.

       <u>objectName</u> <b>i_test_upper</b>
              This method implements the PARAM instruction <b>test_upper</b>.

       <u>objectName</u> <b>i_test_wordchar</b>
              This method implements the PARAM instruction <b>test_wordchar</b>.

       <u>objectName</u> <b>i_test_xdigit</b>
              This method implements the PARAM instruction <b>test_xdigit</b>.

       <u>objectName</u> <b>i_error_clear</b>
              This method implements the PARAM instruction <b>error_clear</b>.

       <u>objectName</u> <b>i_error_push</b>
              This method implements the PARAM instruction <b>error_push</b>.

       <u>objectName</u> <b>i_error_pop_merge</b>
              This method implements the PARAM instruction <b>error_pop_merge</b>.

       <u>objectName</u> <b>i_error_nonterminal</b> <u>symbol</u>
              This method implements the PARAM instruction <b>error_nonterminal</b>.

       <u>objectName</u> <b>i_status_ok</b>
              This method implements the PARAM instruction <b>status_ok</b>.

       <u>objectName</u> <b>i_status_fail</b>
              This method implements the PARAM instruction <b>status_fail</b>.

       <u>objectName</u> <b>i_status_negate</b>
              This method implements the PARAM instruction <b>status_negate</b>.

       <u>objectName</u> <b>i_loc_push</b>
              This method implements the PARAM instruction <b>loc_push</b>.

       <u>objectName</u> <b>i_loc_pop_discard</b>
              This method implements the PARAM instruction <b>loc_pop_discard</b>.

       <u>objectName</u> <b>i_loc_pop_rewind</b>
              This method implements the PARAM instruction <b>loc_pop_rewind</b>.

       <u>objectName</u> <b>i:ok_loc_pop_rewind</b>
              This guarded method, a variant of <b>i_loc_pop_rewind</b>, executes only for "ST == ok".

       <u>objectName</u> <b>i_loc_pop_rewind/discard</b>
              This  method  is  a  convenient  combination  of  control  flow  and  the  two  PARAM instructions
              <b>loc_pop_rewind</b> and <b>loc_pop_discard</b>. The former is executed for "ST == fail", the latter for "ST ==
              ok".

       <u>objectName</u> <b>i_symbol_restore</b> <u>symbol</u>
              This method implements the PARAM instruction <b>symbol_restore</b>.

              The boolean result of the check is returned as the result of the  method  and  can  be  used  with
              standard Tcl control flow commands.

       <u>objectName</u> <b>i_symbol_save</b> <u>symbol</u>
              This method implements the PARAM instruction <b>symbol_save</b>.

       <u>objectName</u> <b>i_value_clear</b>
              This method implements the PARAM instruction <b>value_clear</b>.

       <u>objectName</u> <b>i_value_clear/leaf</b>
              This method is a convenient combination of control flow and the two PARAM instructions <b>value_clear</b>
              and <b>value_leaf</b>. The former is executed for "ST == fail", the latter for "ST == ok".

       <u>objectName</u> <b>i_value_clear/reduce</b>
              This method is a convenient combination of control flow and the two PARAM instructions <b>value_clear</b>
              and <b>value_reduce</b>. The former is executed for "ST == fail", the latter for "ST == ok".

       <u>objectName</u> <b>i:ok_ast_value_push</b>
              This  method  implements  a  guarded  variant  of  the the PARAM instruction <b>ast_value_push</b>, which
              executes only for "ST == ok".

       <u>objectName</u> <b>i_ast_push</b>
              This method implements the PARAM instruction <b>ast_push</b>.

       <u>objectName</u> <b>i_ast_pop_rewind</b>
              This method implements the PARAM instruction <b>ast_pop_rewind</b>.

       <u>objectName</u> <b>i:fail_ast_pop_rewind</b>
              This guarded method, a variant of <b>i_ast_pop_rewind</b>, executes only for "ST == fail".

       <u>objectName</u> <b>i_ast_pop_rewind/discard</b>
              This method  is  a  convenient  combination  of  control  flow  and  the  two  PARAM  instructions
              <b>ast_pop_rewind</b> and <b>ast_pop_discard</b>. The former is executed for "ST == fail", the latter for "ST ==
              ok".

       <u>objectName</u> <b>i_ast_pop_discard</b>
              This method implements the PARAM instruction <b>ast_pop_discard</b>.

       <u>objectName</u> <b>i_ast_pop_discard/rewind</b>
              This  method  is  a  convenient  combination  of  control  flow  and  the  two  PARAM instructions
              <b>ast_pop_discard</b> and <b>ast_pop_rewind</b>. The former is executed for "ST == fail", the latter for "ST ==
              ok".

       <u>objectName</u> <b>i:ok_continue</b>
              This guarded method executes only for "ST == ok". Then it aborts  the  current  iteration  of  the
              innermost loop in the calling Tcl procedure.

       <u>objectName</u> <b>i:fail_continue</b>
              This  guarded  method  executes only for "ST == fail". Then it aborts the current iteration of the
              innermost loop in the calling Tcl procedure.

       <u>objectName</u> <b>i:fail_return</b>
              This guarded method executes only for "ST == fail". Then it aborts the calling Tcl procedure.

       <u>objectName</u> <b>i:ok_return</b>
              This guarded method executes only for "ST == ok". Then it aborts the calling Tcl procedure.

       The next set of methods are <u>super</u> <u>instructions</u>,  meaning  that  each  implements  a  longer  sequence  of
       instructions  commonly  used in parsers. The combinated instructions of the previous set, i.e. those with
       names matching the pattern "i_*/*", are actually super instructions as well, albeit with  limited  scope,
       handling  2  instructions  with their control flow. The upcoming set is much broader in scope, folding as
       much as six or more PARAM instructions into a single method call.

       In this we can see the reasoning behind their use well:

       [1]    By using less instructions the generated parsers become smaller, as the common parts are now truly
              part of the common runtime, and not explicitly written in the parser's code over and over again.

       [2]    Using less instructions additionally reduces the overhead associated with calls into the  runtime,
              i.e. the cost of method dispatch and of setting up the variable context.

       [3]    Another  effect  of  the  super  instructions  is  that  their internals can be optimized as well,
              especially regarding control flow, and stack use, as the runtime internals are accessible  to  all
              instructions folded into the sequence.

       <u>objectName</u> <b>si:void_state_push</b>
              This method combines

              i_loc_push
              i_error_clear
              i_error_push

              Parsers use it at the beginning of <u>void</u> sequences and choices with a <u>void</u> initial branch.

       <u>objectName</u> <b>si:void2_state_push</b>
              This method combines

              i_loc_push
              i_error_clear
              i_error_push

              Parsers use it at the beginning of optional and repeated expressions.

       <u>objectName</u> <b>si:value_state_push</b>
              This method combines

              i_ast_push
              i_loc_push
              i_error_clear
              i_error_push

              Parsers  use it at the beginning of sequences generating an AST and choices with an initial branch
              generating an AST.

       <u>objectName</u> <b>si:void_state_merge</b>
              This method combines

              i_error_pop_merge
              i_loc_pop_rewind/discard

              Parsers use it at the end of void sequences and choices whose last branch is void.

       <u>objectName</u> <b>si:void_state_merge_ok</b>
              This method combines

              i_error_pop_merge
              i_loc_pop_rewind/discard
              i_status_ok

              Parsers use it at the end of optional expressions

       <u>objectName</u> <b>si:value_state_merge</b>
              This method combines

              i_error_pop_merge
              i_ast_pop_rewind/discard
              i_loc_pop_rewind/discard

              Parsers use it at the end of sequences generating ASTs and choices whose last branch generates  an
              AST

       <u>objectName</u> <b>si:value_notahead_start</b>
              This method combines

              i_loc_push
              i_ast_push

              Parsers use it at the beginning of negative lookahead predicates which generate ASTs.

       <u>objectName</u> <b>si:void_notahead_exit</b>
              This method combines

              i_loc_pop_rewind
              i_status_negate

              Parsers use it at the end of void negative lookahead predicates.

       <u>objectName</u> <b>si:value_notahead_exit</b>
              This method combines

              i_ast_pop_discard/rewind
              i_loc_pop_rewind
              i_status_negate

              Parsers use it at the end of negative lookahead predicates which generate ASTs.

       <u>objectName</u> <b>si:kleene_abort</b>
              This method combines

              i_loc_pop_rewind/discard
              i:fail_return

              Parsers use it to stop a positive repetition when its first, required, expression fails.

       <u>objectName</u> <b>si:kleene_close</b>
              This method combines

              i_error_pop_merge
              i_loc_pop_rewind/discard
              i:fail_status_ok
              i:fail_return

              Parsers use it at the end of repetitions.

       <u>objectName</u> <b>si:voidvoid_branch</b>
              This method combines

              i_error_pop_merge
              i:ok_loc_pop_discard
              i:ok_return
              i_loc_rewind
              i_error_push

              Parsers use it when transiting between branches of a choice when both are void.

       <u>objectName</u> <b>si:voidvalue_branch</b>
              This method combines

              i_error_pop_merge
              i:ok_loc_pop_discard
              i:ok_return
              i_ast_push
              i_loc_rewind
              i_error_push

              Parsers  use  it when transiting between branches of a choice when the failing branch is void, and
              the next to test generates an AST.

       <u>objectName</u> <b>si:valuevoid_branch</b>
              This method combines

              i_error_pop_merge
              i_ast_pop_rewind/discard
              i:ok_loc_pop_discard
              i:ok_return
              i_loc_rewind
              i_error_push

              Parsers use it when transiting between branches of a choice when the failing branch  generates  an
              AST, and the next to test is void.

       <u>objectName</u> <b>si:valuevalue_branch</b>
              This method combines

              i_error_pop_merge
              i_ast_pop_discard
              i:ok_loc_pop_discard
              i:ok_return
              i_ast_rewind
              i_loc_rewind
              i_error_push

              Parsers use it when transiting between branches of a choice when both generate ASTs.

       <u>objectName</u> <b>si:voidvoid_part</b>
              This method combines

              i_error_pop_merge
              i:fail_loc_pop_rewind
              i:fail_return
              i_error_push

              Parsers use it when transiting between parts of a sequence and both are void.

       <u>objectName</u> <b>si:voidvalue_part</b>
              This method combines

              i_error_pop_merge
              i:fail_loc_pop_rewind
              i:fail_return
              i_ast_push
              i_error_push

              Parsers  use  it  when  transiting between parts of a sequence and the sucessfully matched part is
              void, and after it an AST is generated.

       <u>objectName</u> <b>si:valuevalue_part</b>
              This method combines

              i_error_pop_merge
              i:fail_ast_pop_rewind
              i:fail_loc_pop_rewind
              i:fail_return
              i_error_push

              Parsers use it when transiting between parts of a sequence and both parts generate ASTs.

       <u>objectName</u> <b>si:value_symbol_start</b> <u>symbol</u>
              This method combines

              if/found? i_symbol_restore $symbol
              i:found:ok_ast_value_push
              i:found_return
              i_loc_push
              i_ast_push

              Parsers use it at the beginning of a nonterminal symbol generating an AST, whose  right-hand  side
              may have generated an AST as well.

       <u>objectName</u> <b>si:value_void_symbol_start</b> <u>symbol</u>
              This method combines

              if/found? i_symbol_restore $symbol
              i:found:ok_ast_value_push
              i:found_return
              i_loc_push
              i_ast_push

              Parsers use it at the beginning of a void nonterminal symbol whose right-hand side may generate an
              AST.

       <u>objectName</u> <b>si:void_symbol_start</b> <u>symbol</u>
              This method combines

              if/found? i_symbol_restore $symbol
              i:found_return
              i_loc_push
              i_ast_push

              Parsers use it at the beginning of a nonterminal symbol generating an AST whose right-hand side is
              void.

       <u>objectName</u> <b>si:void_void_symbol_start</b> <u>symbol</u>
              This method combines

              if/found? i_symbol_restore $symbol
              i:found_return
              i_loc_push

              Parsers  use  it  at   the beginning of a void nonterminal symbol whose right-hand side is void as
              well.

       <u>objectName</u> <b>si:reduce_symbol_end</b> <u>symbol</u>
              This method combines

              i_value_clear/reduce $symbol
              i_symbol_save        $symbol
              i_error_nonterminal  $symbol
              i_ast_pop_rewind
              i_loc_pop_discard
              i:ok_ast_value_push

              Parsers use it at the end of a non-terminal symbol generating an AST using the  AST  generated  by
              the right-hand side as child.

       <u>objectName</u> <b>si:void_leaf_symbol_end</b> <u>symbol</u>
              This method combines

              i_value_clear/leaf  $symbol
              i_symbol_save       $symbol
              i_error_nonterminal $symbol
              i_loc_pop_discard
              i:ok_ast_value_push

              Parsers  use  it  at  the  end of a non-terminal symbol generating an AST whose right-hand side is
              void.

       <u>objectName</u> <b>si:value_leaf_symbol_end</b> <u>symbol</u>
              This method combines

              i_value_clear/leaf  $symbol
              i_symbol_save       $symbol
              i_error_nonterminal $symbol
              i_loc_pop_discard
              i_ast_pop_rewind
              i:ok_ast_value_push

              Parsers use it at the end of a non-terminal symbol generating an AST discarding the AST  generated
              by the right-hand side.

       <u>objectName</u> <b>si:value_clear_symbol_end</b> <u>symbol</u>
              This method combines

              i_value_clear
              i_symbol_save       $symbol
              i_error_nonterminal $symbol
              i_loc_pop_discard
              i_ast_pop_rewind

              Parsers  use  it  at  the  end  of a void non-terminal symbol, discarding the AST generated by the
              right-hand side.

       <u>objectName</u> <b>si:void_clear_symbol_end</b> <u>symbol</u>
              This method combines

              i_value_clear
              i_symbol_save       $symbol
              i_error_nonterminal $symbol
              i_loc_pop_discard

              Parsers use it at the end of a void non-terminal symbol with a void right-hand side.

       <u>objectName</u> <b>si:next_char</b> <u>tok</u>

       <u>objectName</u> <b>si:next_range</b> <u>toks</u> <u>toke</u>

       <u>objectName</u> <b>si:next_alnum</b>

       <u>objectName</u> <b>si:next_alpha</b>

       <u>objectName</u> <b>si:next_ascii</b>

       <u>objectName</u> <b>si:next_ddigit</b>

       <u>objectName</u> <b>si:next_digit</b>

       <u>objectName</u> <b>si:next_graph</b>

       <u>objectName</u> <b>si:next_lower</b>

       <u>objectName</u> <b>si:next_print</b>

       <u>objectName</u> <b>si:next_punct</b>

       <u>objectName</u> <b>si:next_space</b>

       <u>objectName</u> <b>si:next_upper</b>

       <u>objectName</u> <b>si:next_wordchar</b>

       <u>objectName</u> <b>si:next_xdigit</b>
              These methods all combine

              i_input_next $msg
              i:fail_return

              with the appropriate <b>i_test_xxx</b> instruction. Parsers use them for handling atomic expressions.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category <u>pt</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       EBNF,  LL(k),  PEG,  TDPL,  context-free  languages,  expression,  grammar,  matching,  parser,   parsing
       expression,  parsing  expression grammar, push down automaton, recursive descent, state, top-down parsing
       languages, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Parsing and Grammars

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 1.2                                         <u>pt::<a href="../man3tcl/rde.3tcl.html">rde</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>