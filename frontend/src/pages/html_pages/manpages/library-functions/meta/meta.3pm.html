<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>"meta" - meta-programming API</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmeta-perl">libmeta-perl_0.013-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       "meta" - meta-programming API

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use v5.14;
          use meta;

          my $metapkg = meta::get_package( "MyApp::Some::Package" );

          $metapkg-&gt;add_symbol(
             '&amp;a_function' =&gt; sub { say "New function was created" }
          );

          MyApp::Some::Package::a_function();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This package provides an API for metaprogramming; that is, allowing code to inspect or manipulate parts
       of its own program structure.  Parts of the perl interpreter itself can be accessed by means of
       "meta"-objects provided by this package.  Methods on these objects allow inspection of details, as well
       as creating new items or removing existing ones.

       The intention of this API is to provide a nicer replacement for existing tricks such as "no strict
       'refs'" and using globrefs, and also to be a more consistent place to add new abilities, such as more
       APIs for inspection and alteration of internal structures, metaprogramming around the new 'class'
       feature, and other such uses.

       This module should be considered <b>experimental</b>; no API stability guarantees are made at this time.
       Behaviour may be added, altered, or removed in later versions. Once a workable API shape has been found,
       it is hoped that this module will eventually become dual-life and shipped as part of Perl core, as the
       implementation for PPC 0022. See the link in the "SEE ALSO" section.

       This module attempts to find a balance between accurately representing low-level concepts within the
       current implementation of the Perl interpreter, while also providing higher-level abstractions that
       provide useful behaviour for code that uses it. One place this can be seen is the lower-level
       "list_globs" method, which directly maps to the way that GVs are stored in symbol table stashes but
       requires the user to be aware of the GV-less optimisised storage of CVs, as compared to the higher-level
       "list_symbols" method which provides an abstraction over this complication and presents the more useful
       but less accurate impression of separately named symbols that neatly map to their values.

       <u>Since</u> <u>version</u> <u>0.003_002</u> all the entry-point functions and constructors in this module will provoke
       warnings in the "meta::experimental" category. They can be silenced by

          use meta;
          no warnings 'meta::experimental';

       <u>Since</u> <u>version</u> <u>0.005</u> the various "can_..."-prefixed variant accessor methods print deprecation warnings.
       They are likely to be removed soon.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>get_package</b>
          $metapkg = meta::get_package( $pkgname );

       Returns a metapackage reference representing the given package name, creating it if it did not previously
       exist.

       An alternative to "meta::package-&gt;get" in a plain function style.

   <b>get_this_package</b>
          $metapkg = meta::get_this_package;

       <u>Since</u> <u>version</u> <u>0.002.</u>

       Returns a metapackage reference representing the package of the code that called the function.

       Useful for performing meta-programming on the contents of a module during its "BEGIN" or loading time.
       Equivalent to but more efficient than the following:

          meta::get_package(__PACKAGE__)

   <b>for_reference</b>
          $metasym = meta::for_reference( $ref );

       <u>Since</u> <u>version</u> <u>0.007.</u>

       Returns a metasymbol reference representing the glob, variable or subroutine that is pointed to by the
       given reference.

       Note that passing in a reference to a symbol table hash ("stash") does not result in a metapackage. For
       that you will have to call "get_package" or similar.

</pre><h4><b>METHODS</b> <b>ON</b> <b>"meta::package"</b></h4><pre>
   <b>get</b>
          $metapkg = meta::package-&gt;get( $pkgname );

       <u>Since</u> <u>version</u> <u>0.003_001.</u>

       Returns a metapackage reference representing the given package name, creating it if it did not previously
       exist.

       An alternative to "meta::get_package" in an object constructor style.

   <b>is_class</b>
          $bool = $metapkg-&gt;is_class;

       <u>Since</u> <u>version</u> <u>0.009.</u>

       Returns true if on a version of Perl that supports "use feature 'class'", and the package being
       represented is a real "class" created by that feature.  False for regular packages, and always false on
       earlier versions of Perl before that feature was introduced.

   <b>name</b>
          $name = $metapkg-&gt;name;

       Returns the name of the package being represented.

   <b>get_glob</b>
          $metaglob = $metapkg-&gt;get_glob( $name );

       Returns a metaglob reference representing the given symbol name within the package, if it exists. Throws
       an exception if not.

   <b>try_get_glob,</b> <b>can_glob</b>
          $metaglob = $metapkg-&gt;try_get_glob( $name );
          $metaglob = $metapkg-&gt;can_glob( $name );

       Similar to "get_glob" but returns undef if the glob does not exist.

   <b>list_globs</b>
          @metaglobs = $metapkg-&gt;list_globs;

       <u>Since</u> <u>version</u> <u>0.005.</u>

       Returns a list of all the globs in the package that may refer to symbols (i.e.  not subpackages). They
       are returned in no particular order.

       For a more convenient return value form, see also "list_symbols".

   <b>list_subpackage_globs</b>
   <b>list_all_globs</b>
          @metaglobs = $metapkg-&gt;list_subpackage_globs;
          @metaglobs = $metapkg-&gt;list_all_globs;

       <u>Since</u> <u>version</u> <u>0.005.</u>

       Returns a list of all the globs in the package that refer to subpackages, or all globs, including
       subpackages. They are returned in no particular order.

       For a more convenient return value form, see also "list_subpackages".

   <b>get_symbol</b>
          $metasym = $metapkg-&gt;get_symbol( $name );

       Returns a metasymbol reference representing the given symbol name within the package. The symbol name
       should include the leading sigil; one of the characters "*", "$", "@", "%" or "&amp;". Throws an exception if
       the symbol does not exist.

   <b>try_get_symbol,</b> <b>can_symbol</b>
          $metasym = $metapkg-&gt;try_get_symbol( $name );
          $metasym = $metapkg-&gt;can_symbol( $name );

       Similar to "get_symbol" but returns undef if the symbol does not exist.

   <b>add_symbol</b>
          $metasym = $metapkg-&gt;add_symbol( $name, $valueref );

       Creates a new symbol of the given name in the given package. The new symbol will refer to the item given
       by reference, whose type must match the sigil of the symbol name. Returns a metasymbol reference as per
       "get_symbol". If a symbol already existed of the given name then an exception is thrown.

       <u>Note</u> that this does not create a copy of a variable, but stores an alias to the referred item itself
       within the symbol table.

          $metapkg-&gt;add_symbol( '@things', \my @array );

          push @array, "more", "values";
          # these values are now visible in the @things array

       If adding a scalar, array or hash variable, the $valueref argument is optional. If not provided then a
       new, blank variable of the correct type will be created.

   <b>get_or_add_symbol</b>
          $metasym = $metapkg-&gt;get_or_add_symbol( $name, $valueref );

       <u>Since</u> <u>version</u> <u>0.003_003.</u>

       Similar to "get_symbol" but creates a new symbol if it didn't already exist as per "add_symbol".

       Note that if the symbol did already exist it is returned and $valueref will be ignored. The symbol will
       not be modified in that case to point to the value referred to instead.

   <b>remove_symbol</b>
          $metapkg-&gt;remove_symbol( $name );

       Removes a symbol of the given name from the given package. If the symbol was the last item in the glob
       then the glob too is removed from the package. If the named symbol did not previously exist then an
       exception is thrown.

       To only conditionally remove a symbol if it already exists, test for it first by using "try_get_symbol":

          $metapkg-&gt;try_get_symbol( '$variable' ) and
             $metapkg-&gt;remove_symbol( '$variable' );

   <b>list_symbols</b>
          %sub_metasyms = $metapkg-&gt;list_symbols;
          %sub_metasyms = $metapkg-&gt;list_symbols( sigils =&gt; $filter );

       <u>Since</u> <u>version</u> <u>0.006.</u>

       Returns an even-sized key/value list containing the symbols within the given package instance. Each
       symbol is returned as a pair, with its sigil-prefixed basename first, followed by a metasymbol instance
       representing it. Since the sigil-prefixed names must be unique, it is convenient to assign this list into
       a hash. The symbols are returned in no particular order.

       If the optional "sigils" named parameter is given, it should be a string of possible symbol sigils (the
       characters "$", "@", "%" or "&amp;"). In this case, only symbols whose sigil is present in this string will
       be returned.

   <b>list_subpackages</b>
          %sub_metapkgs = $metapkg-&gt;list_subpackages;

       <u>Since</u> <u>version</u> <u>0.006.</u>

       Returns an even-sized key/value list containing the immediate sub-packages of the given package instance.
       Each sub-package is returned as a pair, with its basename first (minus the "::" suffix), followed by a
       metapackage instance representing it. Since the names of each sub-package must be unique, it is
       convenient to assign this list into a hash. The sub-packages are returned in no particular order.

   <b>add_named_sub</b>
          $metasub = $metapkg-&gt;add_named_sub( $name, $code );

       <u>Since</u> <u>version</u> <u>0.008.</u>

       A convenient shortcut for adding a subroutine symbol and setting the subname of the newly-added sub.
       Equivalent to calling "add_symbol" and then "set_subname" on its result, but more efficient as it does
       not have to create a separate fake GV to store the subname in.

       Note that $name should be given as a barename, without the leading "&amp;" sigil.

</pre><h4><b>METHODS</b> <b>ON</b> <b>METASYMBOLS</b></h4><pre>
   <b>is_glob,</b> <b>is_scalar,</b> <b>...</b>
          $bool = $metasym-&gt;is_glob;
          $bool = $metasym-&gt;is_scalar;
          $bool = $metasym-&gt;is_array;
          $bool = $metasym-&gt;is_hash;
          $bool = $metasym-&gt;is_subroutine;

       Returns true if the symbol being referred to is of the given type, or false if not.

   <b>reference</b>
          $ref = $metasym-&gt;reference;

       Returns a regular Perl reference to the symbol being represented.

</pre><h4><b>METHODS</b> <b>ON</b> <b>"meta::glob"</b></h4><pre>
   <b>get</b>
          $metaglob = meta::glob-&gt;get( $globname );

       <u>Since</u> <u>version</u> <u>0.003_001.</u>

       Returns a metaglob reference representing the given symbol from the symbol table from a fully-qualified
       name, if it exists. Throws an exception if not.

   <b>try_get</b>
          $metaglob = meta::glob-&gt;try_get( $globname );

       <u>Since</u> <u>version</u> <u>0.003_003.</u>

       Similar to "get" but returns undef if the given symbol does not exist.

   <b>get_or_add</b>
          $metaglob = meta::glob-&gt;get_or_add( $globname );

       <u>Since</u> <u>version</u> <u>0.003_003.</u>

       Similar to "get" but creates the symbol if it didn't already exist.

   <b>basename</b>
          $name = $metaglob-&gt;basename;

       Returns the name of the glob <u>within</u> <u>its</u> <u>package</u>.

   <b>get_scalar,</b> <b>get_array,</b> <b>...</b>
          $metasym = $metaglob-&gt;get_scalar;
          $metasym = $metaglob-&gt;get_array;
          $metasym = $metaglob-&gt;get_hash;
          $metasym = $metaglob-&gt;get_code;

       Returns a metasymbol reference representing the symbol in the given slot of the glob, if it exists.
       Throws an exception if not.

   <b>try_get_scalar,</b> <b>try_get_array,</b> <b>...</b>
       Similar to "get_scalar", "get_array", etc... but returns undef if the given slot does not exist.

</pre><h4><b>METHODS</b> <b>ON</b> <b>METAVARIABLES</b></h4><pre>
   <b>value</b>
          $scalar = $metavar-&gt;value;
          @array  = $metavar-&gt;value;
          %hash   = $metavar-&gt;value;

          $count = scalar $metavar-&gt;value;

       Returns the current value of the variable, as if it appeared in regular Perl code.

</pre><h4><b>METHODS</b> <b>ON</b> <b>METASUBROUTINES</b></h4><pre>
   <b>is_method</b>
          $bool = $metasub-&gt;is_method;

       <u>Since</u> <u>version</u> <u>0.009.</u>

       Returns true if on a version of Perl that supports "use feature 'class'", and the subroutine being
       represented is a real "method" created by that feature.  False for regular "sub"-based subroutines, and
       always false on earlier versions of Perl before that feature was introduced.

   <b>subname</b>
          $name = $metasub-&gt;subname;

       Returns the (fully-qualified) name of the subroutine.

   <b>set_subname</b>
          $metasub = $metasub-&gt;set_subname( $name );

       <u>Since</u> <u>version</u> <u>0.007.</u>

       Sets a new name for the subroutine.

       If $name is not fully-qualified (i.e. does not contain a "::" sequence), then the package name of the
       caller is used to create the fully-qualified name to be stored.

   <b>prototype</b>
          $proto = $metasub-&gt;prototype;

       Returns the prototype of the subroutine.

   <b>set_prototype</b>
          $metasub = $metasub-&gt;set_prototype( $proto );

       <u>Since</u> <u>version</u> <u>0.007.</u>

       Sets a new prototype for the subroutine.

       Returns the $metasub instance itself to allow for easy chaining.

   <b>signature</b>
          $metasig = $metasub-&gt;signature;

       <u>Since</u> <u>version</u> <u>0.010.</u>

       If on Perl version 5.26 or above and the subroutine has a signature, returns an object reference
       representing details about the signature. This can be queried using the methods below. If the subroutine
       does not use a signature (or on Perl versions before 5.26) returns "undef".

</pre><h4><b>METHODS</b> <b>ON</b> <b>SUBROUTINE</b> <b>METASIGNATURES</b></h4><pre>
   <b>mandatory_params</b>
          $n = $metasig-&gt;mandatory_params;

       Returns the number of parameters that are mandatory (i.e. do not have a defaulting expression). This is
       the minimum number of argument values that must be passed to any call of this function and does not count
       a final slurpy parameter.

       Note that the implicit $self parameter to a "method" subroutine is included in this count. This count
       will always be at least 1 on such a method.

   <b>optional_params</b>
          $n = $metasig-&gt;optional_params;

       Returns the number of parameters that are optional (i.e. have a defaulting expression).

   <b>slurpy</b>
          $slurpy = $metasig-&gt;slurpy;

       Returns the sigil character associated with the final slurpy parameter if it exists (i.e. "%" or "@"), or
       "undef" if no slurpy parameter is defined.

   <b>min_args</b>
   <b>max_args</b>
          $n = $metasig-&gt;min_args;

          $n = $metasig-&gt;max_args;

       Returns the minimum or maximum number of argument values that can be passed to a call to this function.
       "min_args" is the same as "mandatory_params" but is offered as an alias in case the data model ever
       changes. "max_args" will be "undef" if the function uses a slurpy final parameter.

</pre><h4><b>TODO</b></h4><pre>
       •   Access to the new parts of API introduced by Perl 5.38 to deal with classes, methods, fields.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       PPC 0022 "metaprogramming" &lt;https://github.com/Perl/PPCs/blob/main/ppcs/ppc0022-metaprogramming.md&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Paul Evans &lt;<a href="mailto:leonerd@leonerd.org.uk">leonerd@leonerd.org.uk</a>&gt;

perl v5.40.1                                       2025-04-24                                          <u><a href="../man3pm/meta.3pm.html">meta</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>