<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lc_channel_detect_gaps,  lc_channel_check_seqno  -  check  for  missing  incoming  messages and send NACK</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblibrecast-dev">liblibrecast-dev_0.9.1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       lc_channel_detect_gaps,  lc_channel_check_seqno  -  check  for  missing  incoming  messages and send NACK
       messages if required

</pre><h4><b>LIBRARY</b></h4><pre>
       Librecast library (<u>liblibrecast</u>, <u>-llibrecast</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;librecast/net.h&gt;</b>

       <b>int</b> <b>lc_channel_detect_gaps(lc_channel_t</b> <b>*chan);</b>
       <b>int</b> <b>lc_channel_check_seqno(lc_channel_t</b> <b>*chan,</b> <b>lc_seq_t</b> <b>seq);</b>

       Compile and link with <u>-llibrecast</u>.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>lc_channel_detect_gaps</b>() arranges for a channel to check message sequence numbers  of  recently  received
       messages  and  to  send  NACK  messages  if it detects gaps. These NACK messages will cause the sender to
       resend the missing messages, which will then arrive as normal.  The application needs to receive messages
       using <b>lc_msg_recv</b>() or <b>lc_socket_listen</b>() which decode the incoming messages  and  extract  the  sequence
       numbers, and will then automatically detect gaps.

       <b>lc_channel_check_seqno</b>()  compares  the  sequence number passed to it with the sequence numbers of recent
       messages and sends NACKs if any are deemed missing: it is necessary to call this if an  application  uses
       its   own   message   format,   and  receives  messages  using  functions  other  than  <b>lc_msg_recv</b>()  or
       <b>lc_socket_listen</b>() because the library will not  have  the  information  necessary  to  extract  sequence
       numbers  from  messages; however the library will still take care of gap detection and NACK messages. The
       second argument must be the sequence number from the  message  as  decoded  by  the  application.  It  is
       necessary  to  call <b>lc_channel_detect_gaps</b>() before using <b>lc_channel_check_seqno</b>() otherwise the function
       will not do anything. This could be useful for example if gap detection and NACKs are optional,  and  the
       application  will  conditionally  call  <b>lc_channel_detect_gaps</b>() during initialisation, but then can just
       unconditionally call <b>lc_channel_check_seqno</b>() after decoding each incoming message.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>lc_channel_detect_gaps</b>() returns 0 on success, and -1 to indicate an error, setting the  global  variable
       <u>errno</u> to an appropriate code, most likely <b>ENOMEM</b> to indicate that there was insufficient memory to set up
       the required data structures.

       <b>lc_channel_detect_gaps</b>() returns 0 if the message is new, 1 if it is a duplicate (the sequence number has
       already  been  seen)  and  -1  to  indicate  an  error  transmitting  a NACK message, setting <u>errno</u> to an
       appropriate code.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>lc_channel_detect_gaps</b>() can fail with any of the errors the <b>malloc</b>() library function  can  produce,  as
       well as any errors produces by the <b>lc_channel_sidehash</b>() or <b>lc_socket_new</b>() functions.

       <b>lc_channel_check_seqno</b>() can fail with any of the errors the <b>lc_socket_send</b>() function can produce.

</pre><h4><b>EXAMPLE</b></h4><pre>
   <b>Program</b> <b>source</b>

       lc_ctx_t *lctx;
       lc_channel_t *chan;
       lctx = lc_ctx_new();
       chan = lc_channel_new(lctx, "channel name");
       if (lc_channel_detect_gaps(chan) == -1) {
            /* handle this error */
       }

       /* your program goes here, likely calling lc_msg_recv(chan, ...) or lc_socket_listen(...)  */

       lc_channel_free(chan);
       lc_ctx_free(lctx);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/lc_channel_nack_handler.3.html">lc_channel_nack_handler</a></b>(3), <b><a href="../man3/lc_channel_free.3.html">lc_channel_free</a></b>(3), <b><a href="../man3/lc_msg_recv.3.html">lc_msg_recv</a></b>(3), <b><a href="../man3/lc_socket_listen.3.html">lc_socket_listen</a></b>(3), <b><a href="../man3/lc_socket_send.3.html">lc_socket_send</a></b>(3)

LIBRECAST                                          2022-10-29                          <u><a href="../man3/LC_CHANNEL_DETECT_GAPS.3.html">LC_CHANNEL_DETECT_GAPS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>