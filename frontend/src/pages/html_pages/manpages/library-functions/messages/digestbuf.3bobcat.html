<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::DigestBuf - Computes Message Digests from information inserted into a std::ostream</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::DigestBuf - Computes Message Digests from information inserted into a std::ostream

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/digestbuf&gt;</b>
       Linking option: <u>-lbobcat</u> <u>-lcrypto</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>FBB::DigestBuf</b>  objects  are  <b>std::streambuf</b>  objects that can be used to initialize <u>std::ostream</u> objects
       with.

       The message digest of all information inserted into such an <u>std::ostream</u> is computed.

       All the message digests defined by the OpenSSL library that can be  selected  by  name  may  be  used  in
       combination with <u>DigestBuf</u> objects.

       The  currently  supported  message  digest algorithms are shown by the <u>openssl</u> <u>list</u> <u>-digest-commands</u>. The
       names of the digest algorithms can be used to select a digest algorithms  for  the  class’s  constructor,
       below.

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All  constructors,  members,  operators  and manipulators, mentioned in this man-page, are defined in the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       <b>std::streambuf</b>

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
       o      <b>DigestBuf(char</b> <b>const</b> <b>*digestName,</b> <b>size_t</b> <b>bufsize</b> <b>=</b> <b>1024)</b>:
              This constructor initializes the streambuf,  setting  it  up  for  the  message  digest  algorithm
              specified  with  <u>type</u>.  The  message digest algorithms specified in the <b>DESCRIPTION</b> section may be
              used here. E.g., to use the sha256 algorithm specify <u>"sha256"</u>.

              The <u>bufsize</u> argument specifies the size of the internal buffer used by <u>DigestBuf</u> to store incoming
              characters temporarily. The provided default argument should be OK in all normal cases.

       The copy and move constructors and assignment operators are not available.

</pre><h4><b>OVERLOADED</b> <b>OPERATOR</b></h4><pre>
       o      <b>std::ostream</b> <b>&amp;operator&lt;&lt;(std::ostream</b> <b>&amp;out,</b> <b>DigestBuf</b> <b>const</b> <b>&amp;digestbuf)</b>:
              The insertion operator is a free function defined in the namespace <u>FBB</u>. It inserts a hash value as
              a series of hexadecimally displayed values into the provided <u>ostream</u>. See the example below for an
              illustration.

</pre><h4><b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       All members of <b>std::streambuf</b> are available, as <b>FBB::DigestBuf</b> inherits from this class.

       o      <b>void</b> <b>eoi()</b>:
              This member finishes the computation of the  message digest  computation.  It  is  needed  as  the
              <u>DigestBuf</u>  object has no external means for deciding whether all information to compute the digest
              for has yet been received or not. The general approach to follow when computing a  message  digest
              is therefore:

                  1. create a DigestBuf object
                  2. use it to create a std::ostream object
                  3. insert information into the ostream object
                  4. call the DigestBuf object’s eoi() member or insert the
                      eoi manipulator into the ostream (see below)
                  5. obtain/process the hash value from the DigestBuf object.

       o      <b>std::string</b> <b>const</b> <b>&amp;hash()</b> <b>const</b>:
              This  member  returns  the  hash value computed by the <u>DigestBuf</u> object. Its value is only defined
              after having called <u>close()</u>. The hash value is returned in a  <u>std::string</u>  object.  This  string’s
              <u>length()</u>  member  contains  the number of characters used by the hash value, and its <u>data()</u> member
              refers to the hash value’s characters. Note that a hash value’s character value may be 0  (not  to
              be confused with <u>’0’</u>).

       o      <b>void</b> <b>reset()</b>:
              This  member  reinitializes the message digest computation. One a message digest has been computed
              for, say a stream <u>streamA</u> this member can be called after which the digest for  a  stream  <u>streamB</u>
              can be computed using the same <u>DigestBuf</u> object.

</pre><h4><b>MANIPULATOR</b></h4><pre>
       o      <b>FBB::eoi</b>:
              The  <u>eoi</u> manipulator can be inserted into the <u>ostream</u> to complete the digest. It performs the same
              actions as the <u>eoi</u> member. If inserted into a plain <u>std::ostream</u> nothing happens.

</pre><h4><b>EXAMPLE</b></h4><pre>
       #include &lt;iostream&gt;
       #include &lt;ostream&gt;
       #include &lt;bobcat/digestbuf&gt;

       using namespace std;
       using namespace FBB;

       int main(int argc, char **argv)
       try
       {
           DigestBuf digestbuf(argc == 1 ? "sha256" : argv[1]);
           ostream out(&amp;digestbuf);

           string hw("hello world\n");

           out &lt;&lt; hw &lt;&lt; eoi;
           cout &lt;&lt; "&gt;" &lt;&lt; digestbuf &lt;&lt; "&lt;" &lt;&lt; endl;

           digestbuf.reset();
           out.write(hw.c_str(), hw.length()) &lt;&lt; eoi;
           cout &lt;&lt; "&gt;" &lt;&lt; digestbuf &lt;&lt; "&lt;" &lt;&lt; endl;
       }
       catch(exception const &amp;err)
       {
           cout &lt;&lt; err.what() &lt;&lt; endl;
           return 1;
       }

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/digestbuf</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7), <b><a href="../man3bobcat/hmacbuf.3bobcat.html">hmacbuf</a></b>(3bobcat), <b>std::streambuf</b>

</pre><h4><b>BUGS</b></h4><pre>
       None reported

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>: debian package containing the static library, headers, manual pages, and  developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                            <u>FBB::<a href="../man3bobcat/DigestBuf.3bobcat.html">DigestBuf</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>