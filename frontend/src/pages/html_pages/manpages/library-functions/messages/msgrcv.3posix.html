<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       msgrcv — XSI message receive operation

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;sys/msg.h&gt;

       ssize_t msgrcv(int <u>msqid</u>, void *<u>msgp</u>, size_t <u>msgsz</u>, long <u>msgtyp</u>,
           int <u>msgflg</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>msgrcv</u>()  function  operates on XSI message queues (see the Base Definitions volume of POSIX.1‐2017,
       <u>Section</u> <u>3.226</u>, <u>Message</u> <u>Queue</u>).  It is unspecified whether this function interoperates with  the  realtime
       interprocess communication facilities defined in <u>Section</u> <u>2.8</u>, <u>Realtime</u>.

       The  <u>msgrcv</u>()  function  shall read a message from the queue associated with the message queue identifier
       specified by <u>msqid</u> and place it in the user-defined buffer pointed to by <u>msgp</u>.

       The application shall ensure that the argument <u>msgp</u> points to a user-defined buffer that contains first a
       field of type <b>long</b> specifying the type of the message, and then a data portion that holds the data  bytes
       of the message. The structure below is an example of what this user-defined buffer might look like:

           struct mymsg {
               long    mtype;     /* Message type. */
               char    mtext[1];  /* Message text. */
           }

       The structure member <u>mtype</u> is the received message's type as specified by the sending process.

       The structure member <u>mtext</u> is the text of the message.

       The  argument  <u>msgsz</u>  specifies  the  size in bytes of <u>mtext</u>.  The received message shall be truncated to
       <u>msgsz</u> bytes if it is larger than <u>msgsz</u> and (<u>msgflg</u> &amp; MSG_NOERROR) is non-zero.  The truncated part of the
       message shall be lost and no indication of the truncation shall be given to the calling process.

       If the value of <u>msgsz</u> is greater than {SSIZE_MAX}, the result is implementation-defined.

       The argument <u>msgtyp</u> specifies the type of message requested as follows:

        *  If <u>msgtyp</u> is 0, the first message on the queue shall be received.

        *  If <u>msgtyp</u> is greater than 0, the first message of type <u>msgtyp</u> shall be received.

        *  If <u>msgtyp</u> is less than 0, the first message of the lowest type that is less  than  or  equal  to  the
           absolute value of <u>msgtyp</u> shall be received.

       The  argument  <u>msgflg</u>  specifies  the  action  to be taken if a message of the desired type is not on the
       queue. These are as follows:

        *  If (<u>msgflg</u> &amp; IPC_NOWAIT) is non-zero, the calling thread shall return immediately with a return value
           of -1 and <u>errno</u> set to <b>[ENOMSG]</b>.

        *  If (<u>msgflg</u> &amp; IPC_NOWAIT) is 0, the calling thread shall suspend execution until one of the  following
           occurs:

           --  A message of the desired type is placed on the queue.

           --  The  message  queue identifier <u>msqid</u> is removed from the system; when this occurs, <u>errno</u> shall be
               set to <b>[EIDRM]</b> and -1 shall be returned.

           --  The calling thread receives a signal that is to be caught; in this case a message is not received
               and the calling thread resumes execution in the manner prescribed in <u>sigaction</u>().

       Upon successful completion, the following actions are taken with respect to the data structure associated
       with <u>msqid</u>:

        *  <b>msg_qnum</b> shall be decremented by 1.

        *  <b>msg_lrpid</b> shall be set to the process ID of the calling process.

        *  <b>msg_rtime</b> shall be set to the current time, as described in <u>Section</u> <u>2.7.1</u>, <u>IPC</u> <u>General</u> <u>Description</u>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon successful completion, <u>msgrcv</u>() shall return a value equal to the number of  bytes  actually  placed
       into  the  buffer  <u>mtext</u>.   Otherwise,  no message shall be received, <u>msgrcv</u>() shall return -1, and <u>errno</u>
       shall be set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>msgrcv</u>() function shall fail if:

       <b>E2BIG</b>  The value of <u>mtext</u> is greater than <u>msgsz</u> and (<u>msgflg</u> &amp; MSG_NOERROR) is 0.

       <b>EACCES</b> Operation permission is  denied  to  the  calling  process;  see  <u>Section</u>  <u>2.7</u>,  <u>XSI</u>  <u>Interprocess</u>
              <u>Communication</u>.

       <b>EIDRM</b>  The message queue identifier <u>msqid</u> is removed from the system.

       <b>EINTR</b>  The <u>msgrcv</u>() function was interrupted by a signal.

       <b>EINVAL</b> <u>msqid</u> is not a valid message queue identifier.

       <b>ENOMSG</b> The queue does not contain a message of the desired type and (<u>msgflg</u> &amp; IPC_NOWAIT) is non-zero.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Receiving</b> <b>a</b> <b>Message</b>
       The following example receives the first message on the queue (based on the value of the <u>msgtyp</u> argument,
       0). The queue is identified by the <u>msqid</u> argument (assuming that the value has previously been set). This
       call specifies that an error should be reported if no message is available, but not if the message is too
       large. The message size is calculated directly using the <u>sizeof</u> operator.

           #include &lt;sys/msg.h&gt;
           ...
           int result;
           int msqid;
           struct message {
               long type;
               char text[20];
           } msg;
           long msgtyp = 0;
           ...
           result = msgrcv(msqid, (void *) &amp;msg, sizeof(msg.text),
                    msgtyp, MSG_NOERROR | IPC_NOWAIT);

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       The  POSIX  Realtime  Extension  defines  alternative  interfaces  for  interprocess communication (IPC).
       Application developers who need to use IPC should design their applications so that modules using the IPC
       routines described in <u>Section</u> <u>2.7</u>, <u>XSI</u> <u>Interprocess</u> <u>Communication</u> can  be  easily  modified  to  use  the
       alternative interfaces.

</pre><h4><b>RATIONALE</b></h4><pre>
       None.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u>   <u>2.7</u>,   <u>XSI</u>   <u>Interprocess</u>  <u>Communication</u>,  <u>Section</u>  <u>2.8</u>,  <u>Realtime</u>,  <u>mq_close</u>(),  <u>mq_getattr</u>(),
       <u>mq_notify</u>(), <u>mq_open</u>(), <u>mq_receive</u>(), <u>mq_send</u>(), <u>mq_setattr</u>(), <u>mq_unlink</u>(), <u>msgctl</u>(), <u>msgget</u>(), <u>msgsnd</u>(),
       <u>sigaction</u>()

       The Base Definitions volume of POSIX.1‐2017, <u>Section</u> <u>3.226</u>, <u>Message</u> <u>Queue</u>, <b>&lt;sys_msg.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                        <u><a href="../man3POSIX/MSGRCV.3POSIX.html">MSGRCV</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>