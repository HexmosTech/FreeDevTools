<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sys - A functional interface to system messages.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sys - A functional interface to system messages.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  contains  functions  for  sending  system  messages used by programs, and messages used for
       debugging purposes.

       Functions used for implementation of processes are also expected to understand system messages,  such  as
       debug  messages and code change. These functions must be used to implement the use of system messages for
       a process; either directly, or through standard behaviors, such as <u>gen_server</u>.

       The default time-out is 5000 ms, unless otherwise specified. <u>timeout</u> defines the time  to  wait  for  the
       process  to  respond to a request. If the process does not respond, the function evaluates <u>exit({timeout,</u>
       <u>{M,</u> <u>F,</u> <u>A}})</u>.

       The functions make references to a debug structure. The debug structure is a list of <u>dbg_opt()</u>, which  is
       an  internal  data type used by function <u>handle_system_msg/6</u>. No debugging is performed if it is an empty
       list.

</pre><h4><b>SYSTEM</b> <b>MESSAGES</b></h4><pre>
       Processes that are not implemented as  one  of  the  standard  behaviors  must  still  understand  system
       messages. The following three messages must be understood:

         * Plain  system  messages.  These  are received as <u>{system,</u> <u>From,</u> <u>Msg}</u>. The content and meaning of this
           message are not interpreted by the receiving process module.  When  a  system  message  is  received,
           function <u>handle_system_msg/6</u> is called to handle the request.

         * Shutdown  messages. If the process traps exits, it must be able to handle a shutdown request from its
           parent, the supervisor. The message  <u>{'EXIT',</u>  <u>Parent,</u>  <u>Reason}</u>  from  the  parent  is  an  order  to
           terminate. The process must terminate when this message is received, normally with the same <u>Reason</u> as
           <u>Parent</u>.

         * If  the  modules  used  to  implement the process change dynamically during runtime, the process must
           understand one more message. An example is the <u>gen_event</u> processes. The message  is  <u>{_Label,</u>  <u>{From,</u>
           <u>Ref},</u>  <u>get_modules}</u>.  The  reply to this message is <u>From</u> <u>!</u> <u>{Ref,</u> <u>Modules}</u>, where <u>Modules</u> is a list of
           the currently active modules in the process.

           This message is used by the release handler to find which processes that execute  a  certain  module.
           The process can later be suspended and ordered to perform a code change for one of its modules.

</pre><h4><b>SYSTEM</b> <b>EVENTS</b></h4><pre>
       When  debugging  a  process with the functions of this module, the process generates <u>system_events</u>, which
       are then treated in the debug function. For example, <u>trace</u> formats the system events to the terminal.

       Four predefined system events are used when a process receives or sends a message. The process  can  also
       define its own system events. It is always up to the process itself to format these events.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>name()</b> =
           pid() | atom() | {global, term()} | {via, module(), term()}

       <b>system_event()</b> =
           {in, Msg :: term()} |
           {in, Msg :: term(), State :: term()} |
           {out, Msg :: term(), To :: term()} |
           {out, Msg :: term(), To :: term(), State :: term()} |
           {noreply, State :: term()} |
           {continue, Continuation :: term()} |
           {code_change, Event :: term(), State :: term()} |
           {postpone,
            Event :: term(),
            State :: term(),
            NextState :: term()} |
           {consume,
            Event :: term(),
            State :: term(),
            NextState :: term()} |
           {start_timer, Action :: term(), State :: term()} |
           {insert_timeout, Event :: term(), State :: term()} |
           {enter, State :: term()} |
           {terminate, Reason :: term(), State :: term()} |
           term()

                <u>{in,Msg}</u>:
                  Is produced by <u>gen_server</u> and <u>gen_event</u> when the message <u>Msg</u> arrives.

                <u>{in,Msg,State}</u>:
                  Is produced by <u>gen_statem</u> when the message <u>Msg</u> arrives in state <u>State</u>.

                  For <u>gen_statem</u> the <u>Msg</u> term is an <u>{EventType,EventContent}</u> tuple.

                <u>{out,Msg,To}</u>:
                  Is  produced by <u>gen_statem</u> when the reply <u>Msg</u> is sent back to <u>To</u> by returning a <u>{reply,To,Msg}</u>
                  action from the callback module.

                  <u>To</u> is of the same type as the first argument to <u>gen_statem:reply/2</u>.

                <u>{out,Msg,To,State}</u>:
                  Is produced by <u>gen_server</u> when the reply <u>Msg</u> is sent back to <u>To</u>  by  returning  a  <u>{reply,...}</u>
                  tuple from the callback module.

                  <u>To</u> is of the same type as the first argument to <u>gen_server:reply/2</u>.

                  <u>State</u> is the new server state.

                <u>{noreply,State}</u>:
                  Is produced by <u>gen_server</u> when a <u>{noreply,...}</u> tuple is returned from the callback module.

                  <u>State</u> is the new server state.

                <u>{continue,Continuation}</u>:
                  Is  produced  by <u>gen_server</u> when a <u>{continue,Continuation}</u> tuple is returned from the callback
                  module.

                <u>{code_change,Event,State}</u>:
                  Is produced by <u>gen_statem</u> when the message <u>Event</u> arrives in state <u>State</u>  as  the  first  event
                  after a code change.

                  <u>Event</u> is an <u>{EventType,EventContent}</u> tuple.

                  {postpone,Event,State,NextState}  :  Is  produced  by  <u>gen_statem</u>  when  the  message <u>Event</u> is
                  postponed in state <u>State</u>. <u>NextState</u> is the new state.

                  <u>Event</u> is an <u>{EventType,EventContent}</u> tuple.

                  {consume,Event,State,NextState} : Is produced by <u>gen_statem</u> when the message <u>Event</u> is consumed
                  in state <u>State</u>. <u>NextState</u> is the new state.

                  <u>Event</u> is an <u>{EventType,EventContent}</u> tuple.

                  {start_timer,Action,State} : Is produced by <u>gen_statem</u> when the action <u>Action</u> starts  a  timer
                  in state <u>State</u>.

                  {insert_timeout,Event,State}  :  Is  produced by <u>gen_statem</u> when a timeout zero action inserts
                  event <u>Event</u> in state <u>State</u>.

                  <u>Event</u> is an <u>{EventType,EventContent}</u> tuple.

                  {enter,State} : Is produced by <u>gen_statem</u> when the first state <u>State</u> is entered.

                  {terminate,Reason,State} : Is produced by <u>gen_statem</u> when it terminates with reason <u>Reason</u>  in
                  state <u>State</u>.

       <b>dbg_opt()</b>

              See the introduction of this manual page.

       <b>dbg_fun()</b> =
           fun((FuncState :: term(),
                Event :: system_event(),
                ProcState :: term()) -&gt;
                   done | (NewFuncState :: term()))

       <b>debug_option()</b> =
           trace | log |
           {log, N :: integer() &gt;= 1} |
           statistics |
           {log_to_file, FileName :: file:name()} |
           {install,
            {Func :: dbg_fun(), FuncState :: term()} |
            {FuncId :: term(), Func :: dbg_fun(), FuncState :: term()}}

       <b>format_fun()</b> =
           fun((Device :: io:device() | file:io_device(),
                Event :: system_event(),
                Extra :: term()) -&gt;
                   any())

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>change_code(Name,</b> <b>Module,</b> <b>OldVsn,</b> <b>Extra)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>change_code(Name,</b> <b>Module,</b> <b>OldVsn,</b> <b>Extra,</b> <b>Timeout)</b> <b>-&gt;</b>
                      ok | {error, Reason}

              Types:

                 Name = name()
                 Module = module()
                 OldVsn = undefined | term()
                 Extra = term()
                 Timeout = timeout()
                 Reason = term()

              Tells  the  process to change code. The process must be suspended to handle this message. Argument
              <u>Extra</u> is reserved for each process to use as  its  own.  Function  <u>Module:system_code_change/4</u>  is
              called. <u>OldVsn</u> is the old version of the <u>Module</u>.

       <b>get_state(Name)</b> <b>-&gt;</b> <b>State</b>

       <b>get_state(Name,</b> <b>Timeout)</b> <b>-&gt;</b> <b>State</b>

              Types:

                 Name = name()
                 Timeout = timeout()
                 State = term()

              Gets the state of the process.

          <b>Note:</b>
              These  functions  are  intended  only  to  help with debugging. They are provided for convenience,
              allowing developers to avoid having to create their own state extraction functions and also  avoid
              having  to  interactively extract the state from the return values of <u>get_status/1</u> or <u>get_status/2</u>
              while debugging.

              The value of <u>State</u> varies for different types of processes, as follows:

                * For a <u>gen_server</u> process, the returned <u>State</u> is the state of the callback module.

                * For a <u>gen_statem</u> process, <u>State</u> is the tuple <u>{CurrentState,CurrentData}</u>.

                * For a <u>gen_event</u> process, <u>State</u> is a list of tuples, where each tuple corresponds to  an  event
                  handler registered in the process and contains <u>{Module,</u> <u>Id,</u> <u>HandlerState}</u>, as follows:

                  <u>Module</u>:
                    The module name of the event handler.

                  <u>Id</u>:
                    The ID of the handler (which is <u>false</u> if it was registered without an ID).

                  <u>HandlerState</u>:
                    The state of the handler.

              If  the  callback module exports a function <u>system_get_state/1</u>, it is called in the target process
              to get its state. Its argument is the same as the  <u>Misc</u>  value  returned  by  <u>get_status/1,2</u>,  and
              function  <u>Module:system_get_state/1</u>  is  expected to extract the state of the callback module from
              it. Function <u>system_get_state/1</u> must return <u>{ok,</u> <u>State}</u>, where <u>State</u> is the state of the  callback
              module.

              If  the  callback module does not export a <u>system_get_state/1</u> function, <u>get_state/1,2</u> assumes that
              the <u>Misc</u> value is the state of the callback module and returns it directly instead.

              If the callback module's <u>system_get_state/1</u> function crashes or throws an  exception,  the  caller
              exits  with  error <u>{callback_failed,</u> <u>{Module,</u> <u>system_get_state},</u> <u>{Class,</u> <u>Reason}}</u>, where <u>Module</u> is
              the name of the callback module and <u>Class</u> and <u>Reason</u> indicate details of the exception.

              Function <u>system_get_state/1</u> is primarily  useful  for  user-defined  behaviors  and  modules  that
              implement  OTP  special  processes. The <u>gen_server</u>, <u>gen_statem</u>, and <u>gen_event</u> OTP behavior modules
              export this function, so callback modules for those behaviors need not to supply their own.

              For more information about a process, including its state, see <u>get_status/1</u> and <u>get_status/2</u>.

       <b>get_status(Name)</b> <b>-&gt;</b> <b>Status</b>

       <b>get_status(Name,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Status</b>

              Types:

                 Name = name()
                 Timeout = timeout()
                 Status =
                     {status, Pid :: pid(), {module, Module :: module()}, [SItem]}
                 SItem =
                     (PDict :: [{Key :: term(), Value :: term()}]) |
                     (SysState :: running | suspended) |
                     (Parent :: pid()) |
                     (Dbg :: [dbg_opt()]) |
                     (Misc :: term())

              Gets the status of the process.

              The value of <u>Misc</u> varies for different types of processes, for example:

                * A <u>gen_server</u> process returns the state of the callback module.

                * A <u>gen_statem</u> process returns information, such as its current state name and state data.

                * A <u>gen_event</u> process returns information about each of its registered handlers.

              Callback modules for <u>gen_server</u>, <u>gen_statem</u>, and <u>gen_event</u> can also change the value  of  <u>Misc</u>  by
              exporting  a function <u>format_status/2</u>, which contributes module-specific information. For details,
              see <u>gen_server:format_status/2</u>, <u>gen_statem:format_status/2</u>, and <u>gen_event:format_status/2</u>.

       <b>install(Name,</b> <b>FuncSpec)</b> <b>-&gt;</b> <b>ok</b>

       <b>install(Name,</b> <b>FuncSpec,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Name = name()
                 FuncSpec = {Func, FuncState} | {FuncId, Func, FuncState}
                 FuncId = term()
                 Func = dbg_fun()
                 FuncState = term()
                 Timeout = timeout()

              Enables installation of alternative debug functions. An example of such a function is a trigger, a
              function that waits for some special event and performs some action when the event  is  generated.
              For example, turning on low-level tracing.

              <u>Func</u>  is  called  whenever  a system event is generated. This function is to return <u>done</u>, or a new
              <u>Func</u> state. In the first case, the function is removed. It is also removed if the function  fails.
              If  one  debug function should be installed more times, a unique <u>FuncId</u> must be specified for each
              installation.

       <b>log(Name,</b> <b>Flag)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>[system_event()]}</b>

       <b>log(Name,</b> <b>Flag,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>[system_event()]}</b>

              Types:

                 Name = name()
                 Flag = true | {true, N :: integer() &gt;= 1} | false | get | print
                 Timeout = timeout()

              Turns the logging of system events on or off. If on, a maximum of <u>N</u> events are kept in  the  debug
              structure (default is 10).

              If <u>Flag</u> is <u>get</u>, a list of all logged events is returned.

              If <u>Flag</u> is <u>print</u>, the logged events are printed to <u>standard_io</u>.

              The  events  are formatted with a function that is defined by the process that generated the event
              (with a call to <u>handle_debug/4</u>).

       <b>log_to_file(Name,</b> <b>Flag)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>open_file}</b>

       <b>log_to_file(Name,</b> <b>Flag,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>open_file}</b>

              Types:

                 Name = name()
                 Flag = (FileName :: string()) | false
                 Timeout = timeout()

              Enables or disables the logging of all system events in text format to the file.  The  events  are
              formatted  with a function that is defined by the process that generated the event (with a call to
              <u>handle_debug/4</u>). The file is opened with encoding UTF-8.

       <b>no_debug(Name)</b> <b>-&gt;</b> <b>ok</b>

       <b>no_debug(Name,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Name = name()
                 Timeout = timeout()

              Turns off all debugging for the process. This includes functions  that  are  installed  explicitly
              with function <u>install/2,3</u>, for example, triggers.

       <b>remove(Name,</b> <b>FuncOrFuncId</b> <b>::</b> <b>Func</b> <b>|</b> <b>FuncId)</b> <b>-&gt;</b> <b>ok</b>

       <b>remove(Name,</b> <b>FuncOrFuncId</b> <b>::</b> <b>Func</b> <b>|</b> <b>FuncId,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Name = name()
                 Func = dbg_fun()
                 FuncId = term()
                 Timeout = timeout()

              Removes  an  installed  debug  function  from  the  process.  <u>Func</u>  or  <u>FuncId</u> must be the same as
              previously installed.

       <b>replace_state(Name,</b> <b>StateFun)</b> <b>-&gt;</b> <b>NewState</b>

       <b>replace_state(Name,</b> <b>StateFun,</b> <b>Timeout)</b> <b>-&gt;</b> <b>NewState</b>

              Types:

                 Name = name()
                 StateFun = fun((State :: term()) -&gt; NewState :: term())
                 Timeout = timeout()
                 NewState = term()

              Replaces the state of the process, and returns the new state.

          <b>Note:</b>
              These functions are intended only to help with debugging, and are not to  be  called  from  normal
              code.  They  are provided for convenience, allowing developers to avoid having to create their own
              custom state replacement functions.

              Function <u>StateFun</u> provides a new state for the process. Argument <u>State</u>  and  the  <u>NewState</u>  return
              value of <u>StateFun</u> vary for different types of processes as follows:

                * For  a  <u>gen_server</u>  process,  <u>State</u>  is the state of the callback module and <u>NewState</u> is a new
                  instance of that state.

                * For a <u>gen_statem</u> process, <u>State</u> is the tuple <u>{CurrentState,CurrentData}</u>,  and  <u>NewState</u>  is  a
                  similar tuple, which can contain a new current state, new state data, or both.

                * For a <u>gen_event</u> process, <u>State</u> is the tuple <u>{Module,</u> <u>Id,</u> <u>HandlerState}</u> as follows:

                  <u>Module</u>:
                    The module name of the event handler.

                  <u>Id</u>:
                    The ID of the handler (which is <u>false</u> if it was registered without an ID).

                  <u>HandlerState</u>:
                    The state of the handler.

                  <u>NewState</u>  is  a similar tuple where <u>Module</u> and <u>Id</u> are to have the same values as in <u>State</u>, but
                  the value of <u>HandlerState</u> can be different. Returning a <u>NewState</u>, whose <u>Module</u>  or  <u>Id</u>  values
                  differ  from  those of <u>State</u>, leaves the state of the event handler unchanged. For a <u>gen_event</u>
                  process, <u>StateFun</u> is called once for each event handler registered in the <u>gen_event</u> process.

              If a <u>StateFun</u> function decides not to effect any change  in  process  state,  then  regardless  of
              process type, it can return its <u>State</u> argument.

              If  a  <u>StateFun</u>  function  crashes  or  throws  an exception, the original state of the process is
              unchanged for <u>gen_server</u>, and <u>gen_statem</u> processes. For <u>gen_event</u> processes, a crashing or failing
              <u>StateFun</u> function means that only the state of the particular event handler it was working on when
              it failed or crashed is unchanged; it can still succeed in changing  the  states  of  other  event
              handlers registered in the same <u>gen_event</u> process.

              If  the  callback  module  exports  a  <u>system_replace_state/2</u> function, it is called in the target
              process to replace its state using <u>StateFun</u>. Its two arguments are <u>StateFun</u> and <u>Misc</u>,  where  <u>Misc</u>
              is  the  same  as  the <u>Misc</u> value returned by <u>get_status/1,2</u>. A <u>system_replace_state/2</u> function is
              expected to return <u>{ok,</u> <u>NewState,</u> <u>NewMisc}</u>, where <u>NewState</u>  is  the  new  state  of  the  callback
              module,  obtained  by  calling  <u>StateFun</u>,  and <u>NewMisc</u> is a possibly new value used to replace the
              original <u>Misc</u> (required as <u>Misc</u> often contains the state of the callback module within it).

              If the callback module  does  not  export  a  <u>system_replace_state/2</u>  function,  <u>replace_state/2,3</u>
              assumes  that  <u>Misc</u> is the state of the callback module, passes it to <u>StateFun</u> and uses the return
              value as both the new state and as the new value of <u>Misc</u>.

              If the callback module's function <u>system_replace_state/2</u>  crashes  or  throws  an  exception,  the
              caller  exits with error <u>{callback_failed,</u> <u>{Module,</u> <u>system_replace_state},</u> <u>{Class,</u> <u>Reason}}</u>, where
              <u>Module</u> is the name of the callback module and <u>Class</u> and <u>Reason</u> indicate details of the  exception.
              If  the callback module does not provide a <u>system_replace_state/2</u> function and <u>StateFun</u> crashes or
              throws an exception, the caller exits with error <u>{callback_failed,</u> <u>StateFun,</u> <u>{Class,</u> <u>Reason}}</u>.

              Function <u>system_replace_state/2</u> is primarily useful for user-defined behaviors  and  modules  that
              implement  OTP  special  processes. The OTP behavior modules <u>gen_server</u>, <u>gen_statem</u>, and <u>gen_event</u>
              export this function, so callback modules for those behaviors need not to supply their own.

       <b>resume(Name)</b> <b>-&gt;</b> <b>ok</b>

       <b>resume(Name,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Name = name()
                 Timeout = timeout()

              Resumes a suspended process.

       <b>statistics(Name,</b> <b>Flag)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Statistics}</b>

       <b>statistics(Name,</b> <b>Flag,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Statistics}</b>

              Types:

                 Name = name()
                 Flag = true | false | get
                 Statistics = [StatisticsTuple] | no_statistics
                 StatisticsTuple =
                     {start_time, DateTime1} |
                     {current_time, DateTime2} |
                     {reductions, integer() &gt;= 0} |
                     {messages_in, integer() &gt;= 0} |
                     {messages_out, integer() &gt;= 0}
                 DateTime1 = DateTime2 = file:date_time()
                 Timeout = timeout()

              Enables or disables the collection of statistics. If <u>Flag</u> is <u>get</u>, the  statistical  collection  is
              returned.

       <b>suspend(Name)</b> <b>-&gt;</b> <b>ok</b>

       <b>suspend(Name,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Name = name()
                 Timeout = timeout()

              Suspends  the  process.  When the process is suspended, it only responds to other system messages,
              but not other messages.

       <b>terminate(Name,</b> <b>Reason)</b> <b>-&gt;</b> <b>ok</b>

       <b>terminate(Name,</b> <b>Reason,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Name = name()
                 Reason = term()
                 Timeout = timeout()

              Orders the process to terminate with the specified <u>Reason</u>. The termination is done asynchronously,
              so it is not guaranteed that the process is terminated when the function returns.

       <b>trace(Name,</b> <b>Flag)</b> <b>-&gt;</b> <b>ok</b>

       <b>trace(Name,</b> <b>Flag,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Name = name()
                 Flag = boolean()
                 Timeout = timeout()

              Prints all system events on <u>standard_io</u>. The events are formatted with a function that is  defined
              by the process that generated the event (with a call to <u>handle_debug/4</u>).

</pre><h4><b>PROCESS</b> <b>IMPLEMENTATION</b> <b>FUNCTIONS</b></h4><pre>
       The  following functions are used when implementing a special process. This is an ordinary process, which
       does not use a standard behavior, but a process that understands the standard system messages.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>debug_options(Options</b> <b>::</b> <b>[Opt</b> <b>::</b> <b>debug_option()])</b> <b>-&gt;</b> <b>[dbg_opt()]</b>

              Can be used by a process that initiates a debug structure from a list of options.  The  values  of
              argument <u>Opt</u> are the same as for the corresponding functions.

       <b>get_debug(Item,</b> <b>Debug,</b> <b>Default)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 Item = log | statistics
                 Debug = [dbg_opt()]
                 Default = term()

          <b>Warning:</b>
              <u>get_debug/3</u> is deprecated since it returns data of an internal type only useful for debugging.

              Gets  the  data  associated  with a debug option. <u>Default</u> is returned if <u>Item</u> is not found. Can be
              used by the process to retrieve debug data for printing before it terminates.

       <b>handle_debug(Debug,</b> <b>FormFunc,</b> <b>Extra,</b> <b>Event)</b> <b>-&gt;</b> <b>[dbg_opt()]</b>

              Types:

                 Debug = [dbg_opt()]
                 FormFunc = format_fun()
                 Extra = term()
                 Event = system_event()

              This function is called by a process when it generates a system event. <u>FormFunc</u>  is  a  formatting
              function,  called  as  <u>FormFunc(Device,</u>  <u>Event,</u>  <u>Extra)</u> to print the events, which is necessary if
              tracing is activated. <u>Extra</u> is any  extra  information  that  the  process  needs  in  the  format
              function, for example, the process name.

       <b>handle_system_msg(Msg,</b> <b>From,</b> <b>Parent,</b> <b>Module,</b> <b>Debug,</b> <b>Misc)</b> <b>-&gt;</b>
                            no_return()

              Types:

                 Msg = term()
                 From = {pid(), Tag :: term()}
                 Parent = pid()
                 Module = module()
                 Debug = [dbg_opt()]
                 Misc = term()

              This  function is used by a process module to take care of system messages. The process receives a
              <u>{system,</u> <u>From,</u> <u>Msg}</u> message and passes <u>Msg</u> and <u>From</u> to this function.

              This function <u>never</u> returns. It calls either of the following functions:

                * <u>Module:system_continue(Parent,</u> <u>NDebug,</u> <u>Misc)</u>, where the process continues the execution.

                * <u>Module:system_terminate(Reason,</u> <u>Parent,</u> <u>Debug,</u> <u>Misc)</u>, if the process is to terminate.

              <u>Module</u> must export the following:

                * <u>system_continue/3</u>

                * <u>system_terminate/4</u>

                * <u>system_code_change/4</u>

                * <u>system_get_state/1</u>

                * <u>system_replace_state/2</u>

              Argument <u>Misc</u> can be used to save internal data in a process, for example, its state. It  is  sent
              to <u>Module:system_continue/3</u> or <u>Module:system_terminate/4</u>.

       <b>print_log(Debug)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Debug = [dbg_opt()]

              Prints  the  logged system events in the debug structure, using <u>FormFunc</u> as defined when the event
              was generated by a call to <u>handle_debug/4</u>.

       <b>get_log(Debug)</b> <b>-&gt;</b> <b>[system_event()]</b>

              Types:

                 Debug = [dbg_opt()]

              Returns the  logged  system  events  in  the  debug  structure,  that  is  the  last  argument  to
              <u>handle_debug/4</u>.

       <b>Module:system_code_change(Misc,</b> <b>Module,</b> <b>OldVsn,</b> <b>Extra)</b> <b>-&gt;</b> <b>{ok,</b> <b>NMisc}</b>

              Types:

                 Misc = term()
                 OldVsn = undefined | term()
                 Module = atom()
                 Extra = term()
                 NMisc = term()

              Called  from  <u>handle_system_msg/6</u> when the process is to perform a code change. The code change is
              used when the internal data structure has changed. This function converts argument <u>Misc</u> to the new
              data structure. <u>OldVsn</u> is attribute <u>vsn</u> of the old version of the <u>Module</u>. If no such attribute  is
              defined, the atom <u>undefined</u> is sent.

       <b>Module:system_continue(Parent,</b> <b>Debug,</b> <b>Misc)</b> <b>-&gt;</b> <b>none()</b>

              Types:

                 Parent = pid()
                 Debug = [dbg_opt()]
                 Misc = term()

              Called  from <u>handle_system_msg/6</u> when the process is to continue its execution (for example, after
              it has been suspended). This function never returns.

       <b>Module:system_get_state(Misc)</b> <b>-&gt;</b> <b>{ok,</b> <b>State}</b>

              Types:

                 Misc = term()
                 State = term()

              Called from <u>handle_system_msg/6</u> when the process is to return a term  that  reflects  its  current
              state. <u>State</u> is the value returned by <u>get_state/2</u>.

       <b>Module:system_replace_state(StateFun,</b> <b>Misc)</b> <b>-&gt;</b> <b>{ok,</b> <b>NState,</b> <b>NMisc}</b>

              Types:

                 StateFun = fun((State :: term()) -&gt; NState)
                 Misc = term()
                 NState = term()
                 NMisc = term()

              Called  from  <u>handle_system_msg/6</u>  when the process is to replace its current state. <u>NState</u> is the
              value returned by <u>replace_state/3</u>.

       <b>Module:system_terminate(Reason,</b> <b>Parent,</b> <b>Debug,</b> <b>Misc)</b> <b>-&gt;</b> <b>none()</b>

              Types:

                 Reason = term()
                 Parent = pid()
                 Debug = [dbg_opt()]
                 Misc = term()

              Called from <u>handle_system_msg/6</u> when the process is to terminate. For example,  this  function  is
              called when the process is suspended and its parent orders shutdown. It gives the process a chance
              to do a cleanup. This function never returns.

Ericsson AB                                        stdlib 3.17                                         <u><a href="../man3erl/sys.3erl.html">sys</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>