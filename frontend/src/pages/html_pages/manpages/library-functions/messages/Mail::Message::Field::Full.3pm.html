<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mail::Message::Field::Full - construct one smart line in a message header</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmail-message-perl">libmail-message-perl_3.017-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mail::Message::Field::Full - construct one smart line in a message header

</pre><h4><b>INHERITANCE</b></h4><pre>
        Mail::Message::Field::Full
          is a Mail::Message::Field
          is a Mail::Reporter

        Mail::Message::Field::Full is extended by
          Mail::Message::Field::Structured
          Mail::Message::Field::Unstructured

</pre><h4><b>SYNOPSIS</b></h4><pre>
        # Getting to understand the complexity of a header field ...

        my $fast = $msg-&gt;head-&gt;get('subject');
        my $full = Mail::Message::Field::Full-&gt;from($fast);

        my $full = $msg-&gt;head-&gt;get('subject')-&gt;study;  # same
        my $full = $msg-&gt;head-&gt;study('subject');       # same
        my $full = $msg-&gt;study('subject');             # same

        # ... or build a complex header field yourself

        my $f = Mail::Message::Field::Full-&gt;new('To');
        my $f = Mail::Message::Field::Full-&gt;new('Subject: hi!');
        my $f = Mail::Message::Field::Full-&gt;new(Subject =&gt; 'hi!');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is the <u>full</u> implementation of a header field: it has <u>full</u> understanding of all predefined header
       fields.  These objects will be quite slow, because header fields can be very complex.  Of course, this
       class delivers the optimal result, but for a quite large penalty in performance and memory consumption.
       Are you willing to accept?

       This class supports the common header description from RFC2822 (formerly RFC822), the extensions with
       respect to character set encodings as specified in RFC2047, and the extensions on language specification
       and long parameter wrapping from RFC2231.  If you do not need the latter two, then the
       Mail::Message::Field::Fast and Mail::Message::Field::Flex are enough for your application.

       RFC5322 (<u>https://www.rfc-editor.org/rfc/rfc5322.html</u>) describes a long list of obsolete syntax for
       structured header fields.  This mainly refers to disallowing white-spaces and folding on many
       inconvenient locations.  This matches MailBox's natural behavior.

       Extends "DESCRIPTION" in Mail::Message::Field.

</pre><h4><b>OVERLOADED</b></h4><pre>
       Extends "OVERLOADED" in Mail::Message::Field.

       overload: <b>""</b>
           Inherited, see "OVERLOADED" in Mail::Message::Field

       overload: <b>0+</b>
           Inherited, see "OVERLOADED" in Mail::Message::Field

       overload: <b>&lt;=</b>&gt;
           Inherited, see "OVERLOADED" in Mail::Message::Field

       overload: <b>bool</b>
           Inherited, see "OVERLOADED" in Mail::Message::Field

       overload: <b>cmp</b>
           Inherited, see "OVERLOADED" in Mail::Message::Field

       overload: <b>stringification</b>
           In string context, the decoded body is returned, as if <b>decodedBody()</b> would have been called.

</pre><h4><b>METHODS</b></h4><pre>
       Extends "METHODS" in Mail::Message::Field.

   <b>Constructors</b>
       Extends "Constructors" in Mail::Message::Field.

       $obj-&gt;<b>clone</b>()
           Inherited, see "Constructors" in Mail::Message::Field

       Mail::Message::Field::Full-&gt;<b>from</b>($field, %options)
           Convert  any  $field  (a  Mail::Message::Field  object) into a new Mail::Message::Field::Full object.
           This conversion is done the hard way: the string which is produced by the original object  is  parsed
           again.   Usually,  the string which is parsed is exactly the line (or lines) as found in the original
           input source, which is a good thing because Full  fields  are  much  more  careful  with  the  actual
           content.

           %options  are passed to the constructor (see <b>new()</b>).  In any case, some extensions of this Full field
           class is returned.  It depends on which field is created what kind of class we get.

           example:

            my $fast = $msg-&gt;head-&gt;get('subject');
            my $full = Mail::Message::Field::Full-&gt;from($fast);

            my $full = $msg-&gt;head-&gt;get('subject')-&gt;study;  # same
            my $full = $msg-&gt;head-&gt;study('subject');       # same
            my $full = $msg-&gt;get('subject');               # same

       Mail::Message::Field::Full-&gt;<b>new</b>($data)
           Creating a new field object the correct way is a lot of work, because there is so much freedom in the
           RFCs, but at the same time so many restrictions.  Most fields are implemented, but if you  have  your
           own field (and do no want to contribute it to MailBox), then simply call new on your own package.

           You have the choice to instantiate the object as string or in prepared parts:

           •   <b>new</b> LINE, OPTIONS

               Pass  a  LINE  as  it could be found in a file: a (possibly folded) line which is terminated by a
               new-line.

           •   <b>new</b> NAME, [BODY], OPTIONS

               A set of values which shape the line.

           The NAME is a wellformed header name (you may use <b>wellformedName()</b>) to be sure about the casing.  The
           BODY is a string, one object, or an ref-array of objects.  In case of objects, they must fit  to  the
           constructor  of  the  field:  the  types  which are accepted may differ.  The optional ATTRIBUTE list
           contains Mail::Message::Field::Attribute objects.  Finally, there are some OPTIONS.

            -Option  --Defined in     --Default
             charset                    undef
             encoding                   'q'
             force                      false
             language                   undef
             log       Mail::Reporter   'WARNINGS'
             trace     Mail::Reporter   'WARNINGS'

           charset =&gt; STRING
             The body is specified in utf8, and must become 7-bits ascii to be transmited.  Specify a charset to
             which the multi-byte utf8 is converted before it gets encoded.  See <b>encode()</b>, which does the job.

           encoding =&gt; 'q'|'Q'|'b'|'B'
             Non-ascii characters are encoded using Quoted-Printable  ('q'  or  'Q')  or  Base64  ('b'  or  'B')
             encoding.

           force =&gt; BOOLEAN
             Enforce  encoding  in  the  specified charset, even when it is not needed because the body does not
             contain any non-ascii characters.

           language =&gt; STRING
             The language used can be specified, however is rarely used my mail clients.

           log =&gt; LEVEL
           trace =&gt; LEVEL

           example:

            my $s = Mail::Message::Field::Full-&gt;new('Subject: Hello World');
            my $s = Mail::Message::Field::Full-&gt;new('Subject', 'Hello World');

            my @attrs   = (Mail::Message::Field::Attribute-&gt;new(...), ...);
            my @options = (extra =&gt; 'the color blue');
            my $t = Mail::Message::Field::Full-&gt;new(To =&gt; \@addrs, @attrs, @options);

   <b>The</b> <b>field</b>
       Extends "The field" in Mail::Message::Field.

       $obj-&gt;<b>isStructured</b>()
       Mail::Message::Field::Full-&gt;<b>isStructured</b>()
           Inherited, see "The field" in Mail::Message::Field

       $obj-&gt;<b>length</b>()
           Inherited, see "The field" in Mail::Message::Field

       $obj-&gt;<b>nrLines</b>()
           Inherited, see "The field" in Mail::Message::Field

       $obj-&gt;<b>print</b>( [$fh] )
           Inherited, see "The field" in Mail::Message::Field

       $obj-&gt;<b>size</b>()
           Inherited, see "The field" in Mail::Message::Field

       $obj-&gt;<b>string</b>( [$wrap] )
           Inherited, see "The field" in Mail::Message::Field

       $obj-&gt;<b>toDisclose</b>()
           Inherited, see "The field" in Mail::Message::Field

   <b>Access</b> <b>to</b> <b>the</b> <b>name</b>
       Extends "Access to the name" in Mail::Message::Field.

       $obj-&gt;<b>Name</b>()
           Inherited, see "Access to the name" in Mail::Message::Field

       $obj-&gt;<b>name</b>()
           Inherited, see "Access to the name" in Mail::Message::Field

       $obj-&gt;<b>wellformedName</b>( [STRING] )
           Inherited, see "Access to the name" in Mail::Message::Field

   <b>Access</b> <b>to</b> <b>the</b> <b>body</b>
       Extends "Access to the body" in Mail::Message::Field.

       $obj-&gt;<b>body</b>()
           Inherited, see "Access to the body" in Mail::Message::Field

       $obj-&gt;<b>decodedBody</b>(%options)
           Returns the unfolded body of the field, where encodings are resolved.  The returned line  will  still
           contain comments and such.  The %options are passed to the decoder, see <b>decode()</b>.

           BE WARNED: if the field is a structured field, the content may change syntax, because of encapsulated
           special  characters.   By  default,  the body is decoded as text, which results in a small difference
           within comments as well (read the RFC).

       $obj-&gt;<b>folded</b>()
           Inherited, see "Access to the body" in Mail::Message::Field

       $obj-&gt;<b>foldedBody</b>( [$body] )
           Inherited, see "Access to the body" in Mail::Message::Field

       $obj-&gt;<b>stripCFWS</b>( [STRING] )
       Mail::Message::Field::Full-&gt;<b>stripCFWS</b>( [STRING] )
           Inherited, see "Access to the body" in Mail::Message::Field

       $obj-&gt;<b>unfoldedBody</b>( [$body, [$wrap]] )
           Inherited, see "Access to the body" in Mail::Message::Field

   <b>Access</b> <b>to</b> <b>the</b> <b>content</b>
       Extends "Access to the content" in Mail::Message::Field.

       $obj-&gt;<b>addresses</b>()
           Inherited, see "Access to the content" in Mail::Message::Field

       $obj-&gt;<b>attribute</b>( $name, [$value] )
           Inherited, see "Access to the content" in Mail::Message::Field

       $obj-&gt;<b>attributes</b>()
           Inherited, see "Access to the content" in Mail::Message::Field

       $obj-&gt;<b>beautify</b>()
           For structured header fields, this removes the original encoding of the field's body (the  format  as
           it was offered to <b>parse()</b>), therefore the next request for the field will have to re-produce the read
           data clean and nice.  For unstructured bodies, this method doesn't do a thing.

       $obj-&gt;<b>comment</b>( [STRING] )
           Inherited, see "Access to the content" in Mail::Message::Field

       $obj-&gt;<b>createComment</b>(STRING, %options)
       Mail::Message::Field::Full-&gt;<b>createComment</b>(STRING, %options)
           Create  a comment to become part in a field.  Comments are automatically included within parenthesis.
           Matching pairs of parenthesis are permitted within the STRING.  When a non-matching  parenthesis  are
           used,  it is only permitted with an escape (a backslash) in front of them.  These backslashes will be
           added automatically if needed (don't worry!).  Backslashes will stay, except at  the  end,  where  it
           will be doubled.

           The %options are "charset", "language", and "encoding" as always.  The created comment is returned.

       $obj-&gt;<b>createPhrase</b>(STRING, %options)
       Mail::Message::Field::Full-&gt;<b>createPhrase</b>(STRING, %options)
           A phrase is a text which plays a well defined role.  This is the main difference with comments, which
           have do specified meaning.  Some special characters in the phrase will cause it to be surrounded with
           double quotes: do not specify them yourself.

           The %options are "charset", "language", and "encoding", as always.

       $obj-&gt;<b>study</b>()
           Inherited, see "Access to the content" in Mail::Message::Field

       $obj-&gt;<b>toDate</b>( [$time] )
       Mail::Message::Field::Full-&gt;<b>toDate</b>( [$time] )
           Inherited, see "Access to the content" in Mail::Message::Field

       $obj-&gt;<b>toInt</b>()
           Inherited, see "Access to the content" in Mail::Message::Field

   <b>Other</b> <b>methods</b>
       Extends "Other methods" in Mail::Message::Field.

       $obj-&gt;<b>dateToTimestamp</b>(STRING)
       Mail::Message::Field::Full-&gt;<b>dateToTimestamp</b>(STRING)
           Inherited, see "Other methods" in Mail::Message::Field

   <b>Internals</b>
       Extends "Internals" in Mail::Message::Field.

       $obj-&gt;<b>consume</b>( $line | &lt;$name,&lt;$body|$objects&gt;&gt; )
           Inherited, see "Internals" in Mail::Message::Field

       $obj-&gt;<b>decode</b>(STRING, %options)
       Mail::Message::Field::Full-&gt;<b>decode</b>(STRING, %options)
           Decode  field  encoded  STRING to an utf8 string.  The input STRING is part of a header field, and as
           such, may contain encoded words in "=?...?.?...?=" format defined by RFC2047.  The STRING may contain
           multiple encoded parts, maybe using different character sets.

           Be warned:  you MUST first interpret the field into parts, like phrases and comments, and then decode
           each part separately, otherwise the decoded text may interfere with your markup characters.

           Be warned: language information, which is defined in RFC2231, is ignored.

           Encodings with unknown charsets are left untouched [requires  v2.085,  otherwise  croaked].   Unknown
           characters within an charset are replaced by a '?'.

            -Option --Default
             is_text  1

           is_text =&gt; BOOLEAN
             Encoding  on  text  is slightly more complicated than encoding structured data, because it contains
             blanks.  Visible blanks have to be ignored between two encoded words in the text, but not  when  an
             encoded word follows or precedes an unencoded word.  Phrases and comments are texts.

           example:

            print Mail::Message::Field::Full-&gt;decode('=?iso-8859-1?Q?J=F8rgen?=');
               # prints   JE&lt;0slash&gt;rgen

       $obj-&gt;<b>defaultWrapLength</b>( [$length] )
           Inherited, see "Internals" in Mail::Message::Field

       $obj-&gt;<b>encode</b>(STRING, %options)
           Encode  the  (possibly utf8 encoded) STRING to a string which is acceptable to the RFC2047 definition
           of a header: only containing us-ascii characters.

            -Option  --Default
             charset   'us-ascii'
             encoding  'q'
             force     &lt;flase&gt;
             language  undef
             name      undef

           charset =&gt; STRING
             STRING is an utf8 string which has to be translated into any byte-wise character set for transport,
             because MIME-headers can only contain ascii characters.

           encoding =&gt; 'q'|'Q'|'b'|'B'
             The character encoding to be used.  With "q" or "Q", quoted-printable encoding will be used.   With
             "b " or "B ", base64 encoding will be taken.

           force =&gt; BOOLEAN
             Encode the string, even when it only contains us-ascii characters.  By default, this is off because
             it decreases readibility of the produced header fields.

           language =&gt; STRING
             RFC2231  defines how to specify language encodings in encoded words.  The STRING is a strandard iso
             language name.

           name =&gt; STRING
             [3.002] When the name of the field is given, the first encoded line will be shorter.

       $obj-&gt;<b>fold</b>( $name, $body, [$maxchars] )
       Mail::Message::Field::Full-&gt;<b>fold</b>( $name, $body, [$maxchars] )
           Inherited, see "Internals" in Mail::Message::Field

       $obj-&gt;<b>setWrapLength</b>( [$length] )
           Inherited, see "Internals" in Mail::Message::Field

       $obj-&gt;<b>stringifyData</b>(STRING|ARRAY|$objects)
           Inherited, see "Internals" in Mail::Message::Field

       $obj-&gt;<b>unfold</b>(STRING)
           Inherited, see "Internals" in Mail::Message::Field

   <b>Parsing</b>
       You probably do not want to call these parsing methods yourself: use the  standard  constructors  (<b>new()</b>)
       and it will be done for you.

       $obj-&gt;<b>consumeComment</b>(STRING)
       Mail::Message::Field::Full-&gt;<b>consumeComment</b>(STRING)
           Try  to  read  a  comment  from  the  STRING.   When  successful,  the  comment without encapsulating
           parenthesis is returned, together with the rest of the string.

       $obj-&gt;<b>consumeDotAtom</b>(STRING)
           Returns three elemens: the atom-text, the rest string, and the concatenated comments.  Both atom  and
           comments can be undef.

       $obj-&gt;<b>consumePhrase</b>(STRING)
       Mail::Message::Field::Full-&gt;<b>consumePhrase</b>(STRING)
           Take the STRING, and try to strip-off a valid phrase.  In the obsolete phrase syntax, any sequence of
           words  is  accepted  as  phrase  (as  long  as  certain special characters are not used).  RFC2822 is
           stricter: only one word or a quoted string is allowed.  As always, the obsolete syntax  is  accepted,
           and the new syntax is produced.

           This method returns two elements: the phrase (or undef) followed by the resulting string.  The phrase
           will be removed from the optional quotes.  Be warned that "" will return an empty, valid phrase.

           example:

            my ($phrase, $rest) = $field-&gt;consumePhrase( q["hi!" &lt;<a href="mailto:sales@example.com">sales@example.com</a>&gt;] );

       $obj-&gt;<b>parse</b>(STRING)
           Get  the  detailed  information  from  the STRING, and store the data found in the field object.  The
           accepted input is very field type dependent.  Unstructured fields do no parsing whatsoever.

       $obj-&gt;<b>produceBody</b>()
           Produce the text for the field, based on the information stored within the field object.

           Usually, you wish the exact same line as was found in the input source of a message.   But  when  you
           have  created  a  field yourself, it should get formatted.  You may call <b>beautify()</b> on a preformatted
           field to enforce a call to this method when the field is needed later.

   <b>Error</b> <b>handling</b>
       Extends "Error handling" in Mail::Message::Field.

       $obj-&gt;<b>AUTOLOAD</b>()
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>addReport</b>($object)
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>defaultTrace</b>( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )
       Mail::Message::Field::Full-&gt;<b>defaultTrace</b>( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>errors</b>()
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>log</b>( [$level, [$strings]] )
       Mail::Message::Field::Full-&gt;<b>log</b>( [$level, [$strings]] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>logPriority</b>($level)
       Mail::Message::Field::Full-&gt;<b>logPriority</b>($level)
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>logSettings</b>()
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>notImplemented</b>()
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>report</b>( [$level] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>reportAll</b>( [$level] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>trace</b>( [$level] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>warnings</b>()
           Inherited, see "Error handling" in Mail::Reporter

   <b>Cleanup</b>
       Extends "Cleanup" in Mail::Message::Field.

       $obj-&gt;<b>DESTROY</b>()
           Inherited, see "Cleanup" in Mail::Reporter

</pre><h4><b>DETAILS</b></h4><pre>
       Extends "DETAILS" in Mail::Message::Field.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Warning: Field content is not numerical: $content
           The numeric value of a field is requested (for instance the "Lines" or "Content-Length" fields should
           be numerical), however the data contains weird characters.

       Error: Field name too long (max $length), in '$name'
           It is not specified in the RFCs how long a field name can be,  but  at  least  it  should  be  a  few
           characters shorter than the line wrap.

       Warning: Illegal character in charset '$charset'
           The  field  is created with an utf8 string which only contains data from the specified character set.
           However, that character set can never be a valid name because it contains characters  which  are  not
           permitted.

       Warning: Illegal character in field name $name
           A  new  field  is  being created which does contain characters not permitted by the RFCs.  Using this
           field in messages may break other e-mail clients  or  transfer  agents,  and  therefore  mutulate  or
           extinguish your message.

       Warning: Illegal character in language '$lang'
           The  field  is created with data which is specified to be in a certain language, however, the name of
           the language cannot be valid: it contains characters which are not permitted by the RFCs.

       Warning: Illegal encoding '$encoding', used 'q'
           The RFCs only permit base64 ("b " or "B ") or quoted-printable ("q" or  "Q")  encoding.   Other  than
           these four options are illegal.

       Error: Package $package does not implement $method.
           Fatal  error:  the specific package (or one of its superclasses) does not implement this method where
           it should. This message means that some other related classes do implement this  method  however  the
           class  at  hand does not.  Probably you should investigate this and probably inform the author of the
           package.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This module is part of Mail-Message distribution  version  3.017,  built  on  April  18,  2025.  Website:
       <u><a href="http://perl.overmeer.net/CPAN/">http://perl.overmeer.net/CPAN/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 2001-2025 by [Mark Overmeer &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]. For other contributors see ChangeLog.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.40.1                                       2025-04-25                    <u>Mail::Message::Field::<a href="../man3pm/Full.3pm.html">Full</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>