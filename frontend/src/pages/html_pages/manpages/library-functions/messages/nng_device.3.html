<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nng_device - message forwarding device</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnng-dev">libnng-dev_1.10.1-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       nng_device - message forwarding device

</pre><h4><b>SYNOPSIS</b></h4><pre>
           #include &lt;nng/nng.h&gt;

           int nng_device(nng_socket s1, nng_socket s2);

           void nng_device_aio(nng_aio *aio, nng_socket s1, nng_socket s2);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The nng_device() and nng_device_aio() functions forward messages received from one socket <u>s1</u> to another
       socket <u>s2</u>, and vice versa.

       These functions are used to create forwarders, which can be used to create complex network topologies to
       provide for improved horizontal scalability, reliability, and isolation.

       Only raw mode sockets may be used with this function. These can be created using _raw forms of the
       various socket constructors, such as nng_req0_open_raw().

       The nng_device() function does not return until one of the sockets is closed. The nng_device_aio()
       function returns immediately, and operates completely in the background.

   <b>Reflectors</b>
       One of the sockets passed may be an unopened socket initialized with the NNG_SOCKET_INITIALIZER special
       value. If this is the case, then the other socket must be valid, and must use a protocol that is
       bidirectional and can peer with itself (such as <u>pair</u> or <u>bus</u>.) In this case the device acts as a reflector
       or loop-back device, where messages received from the valid socket are merely returned to the sender.

   <b>Forwarders</b>
       When both sockets are valid, then the result is a forwarder or proxy. In this case sockets <u>s1</u> and <u>s2</u> must
       be compatible with each other, which is to say that they should represent the opposite halves of a two
       protocol pattern, or both be the same protocol for a single protocol pattern. For example, if <u>s1</u> is a <u>pub</u>
       socket, then <u>s2</u> must be a <u>sub</u> socket. Or, if <u>s1</u> is a <u>bus</u> socket, then <u>s2</u> must also be a <u>bus</u> socket.

   <b>Operation</b>
       The nng_device() function moves messages between the provided sockets.

       When a protocol has a backtrace style header, routing information is present in the header of received
       messages, and is copied to the header of the output bound message. The underlying raw mode protocols
       supply the necessary header adjustments to add or remove routing headers as needed. This allows replies
       to be returned to requesters, and responses to be routed back to surveyors.

       The caller of these functions is required to close the sockets when the device is stopped.

       Additionally, some protocols have a maximum time-to-live to protect against forwarding loops and
       especially amplification loops. In these cases, the default limit (usually 8), ensures that messages will
       self-terminate when they have passed through too many forwarders, protecting the network from unlimited
       message amplification that can arise through misconfiguration. This is controlled via the NNG_OPT_MAXTTL
       option.

           <b>Important</b>

           Not all protocols have support for guarding against forwarding loops, and even for those that do,
           forwarding loops can be extremely detrimental to network performance.

           <b>Note</b>

           Devices (forwarders and reflectors) act in best-effort delivery mode only. If a message is received
           from one socket that cannot be accepted by the other (due to backpressure or other issues), then the
           message is discarded.

           <b>Tip</b>

           Use the request/reply pattern, which includes automatic retries by the requester, if reliable
           delivery is needed.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       This function continues running, and only returns an appropriate error when one occurs, or if one of the
       sockets is closed.

</pre><h4><b>ERRORS</b></h4><pre>
       NNG_ECLOSED
           At least one of the sockets is not open.

       NNG_ENOMEM
           Insufficient memory is available.

       NNG_EINVAL
           The sockets are not compatible, or are both invalid.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man5/nng_options.5.html">nng_options</a>(5), <a href="../man5/nng_socket.5.html">nng_socket</a>(5), <a href="../man7/nng.7.html">nng</a>(7)

                                                   2025-04-20                                      <u><a href="../man3/NNG_DEVICE.3.html">NNG_DEVICE</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>