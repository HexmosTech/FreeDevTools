<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pvm_trecv - Receive with timeout.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/pvm-dev">pvm-dev_3.4.6-3.2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pvm_trecv - Receive with timeout.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>C</b>    <b>#include</b> <b>&lt;sys/time.h&gt;</b>
            <b>int</b> <b>bufid</b> <b>=</b> <b>pvm_trecv(</b> <b>int</b> <b>tid,</b> <b>int</b> <b>msgtag,</b> <b>struct</b> <b>timeval</b> <b>*tmout</b> <b>)</b>

       <b>Fortran</b>   <b>call</b> <b>pvmftrecv(</b> <b>tid,</b> <b>msgtag,</b> <b>sec,</b> <b>usec,</b> <b>bufid</b> <b>)</b>

</pre><h4><b>PARAMETERS</b></h4><pre>
       tid     Integer to match task identifier of sending process.

       msgtag  Integer to match message tag; should be &gt;= 0.

       tmout   (or <u>sec</u> and <u>usec</u>) Time to wait before returning without a message.

       bufid   Integer  returns  the  value  of the new active receive buffer identifier.  Values less than zero
               indicate an error.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The routine <u>pvm_trecv</u> blocks the process until  a  message  with  label  <u>msgtag</u>  has  arrived  from  <u>tid</u>.
       pvm_trecv  then  places  the  message  in  a new <u>active</u> receive buffer, also clearing the current receive
       buffer.  If no matching message arrives within the specified waiting time, pvm_trecv  returns  without  a
       message.

       A  -1  in  <u>msgtag</u> or <u>tid</u> matches anything.  This allows the user the following options.  If <u>tid</u> = -1 then
       pvm_trecv will accept a message from any process which has a  matching  <u>msgtag</u>.   If  <u>msgtag</u>  =  -1  then
       pvm_trecv  will  accept  any  message that is sent from process <u>tid</u>.  If <u>tid</u> and <u>msgtag</u> are both -1, then
       pvm_trecv will accept any message from any process.

       In C, the <u>tmout</u> fields tv_sec and tv_usec specify how  long  pvm_trecv  will  wait  without  returning  a
       matching  message.  In Fortran, two separate parameters, <u>sec</u> and <u>usec</u> are passed.  With both set to zero,
       pvm_trecv behaves the same as <u>pvm_nrecv</u>, which is to probe for messages and return  immediately  even  if
       none  are  matched.  In C, passing a null pointer in <u>tmout</u> makes pvm_trecv act like <u>pvm_recv</u>, that is, it
       will wait indefinitely.  In Fortran, setting <u>sec</u> to -1 has the same effect.

       The PVM model guarantees the following about message order.  If task 1 sends message A to  task  2,  then
       task  1  sends  message B to task 2, message A will arrive at task 2 before message B.  Moreover, if both
       messages arrive before task 2 does a receive, then a wildcard receive will always return message A.

       If pvm_trecv is successful, <u>bufid</u> will be the new active receive buffer identifier.   If  no  message  is
       received, pvm_trecv returns 0.  If some error occurs then <u>bufid</u> will be &lt; 0.

       Once  pvm_trecv  returns, the data in the message can be unpacked into the user's memory using the unpack
       routines.

</pre><h4><b>EXAMPLES</b></h4><pre>
       C:
            struct timeval tmout;

            tid = pvm_parent();
            msgtag = 4 ;
            tmout.tv_sec = 60;
            tmout.tv_usec = 0;
            if ((bufid = pvm_trecv( tid, msgtag, &amp;tmout )) &gt; 0) {
                 pvm_upkint( tid_array, 10, 1 );
                 pvm_upkint( problem_size, 1, 1 );
                 pvm_upkfloat( input_array, 100, 1 );
            }

       Fortran:
            CALL PVMFTRECV( -1, 4, 60, 0, BUFID )
            IF (BUFID .EQ. 0) GO TO 666
            CALL PVMFUNPACK( INTEGER4, TIDS, 25, 1, INFO )
            CALL PVMFUNPACK( REAL8, MATRIX, 100, 100, INFO )
       666  CONTINUE

</pre><h4><b>ERRORS</b></h4><pre>
       These error conditions can be returned by <u>pvm_trecv</u>

       PvmBadParam
              giving an invalid tid value, or msgtag &lt; -1.

       PvmSysErr
              pvmd not responding.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3PVM/pvm_bufinfo.3PVM.html">pvm_bufinfo</a>(3PVM),     <a href="../man3PVM/pvm_getminfo.3PVM.html">pvm_getminfo</a>(3PVM),     <a href="../man3PVM/pvm_nrecv.3PVM.html">pvm_nrecv</a>(3PVM),     <a href="../man3PVM/pvm_recv.3PVM.html">pvm_recv</a>(3PVM),     <a href="../man3PVM/pvm_unpack.3PVM.html">pvm_unpack</a>(3PVM),
       <a href="../man3PVM/pvm_probe.3PVM.html">pvm_probe</a>(3PVM), <a href="../man3PVM/pvm_send.3PVM.html">pvm_send</a>(3PVM), <a href="../man3PVM/pvm_mcast.3PVM.html">pvm_mcast</a>(3PVM)

                                                8 February, 1994                                     <u><a href="../man3PVM/TRECV.3PVM.html">TRECV</a></u>(3PVM)
</pre>
 </div>
</div></section>
</div>
</body>
</html>