<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mojo::Message - HTTP message base class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmojolicious-perl">libmojolicious-perl_9.39+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mojo::Message - HTTP message base class

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package Mojo::Message::MyMessage;
         use Mojo::Base 'Mojo::Message';

         sub cookies              {...}
         sub extract_start_line   {...}
         sub get_start_line_chunk {...}
         sub start_line_size      {...}

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mojo::Message is an abstract base class for HTTP message containers, based on RFC 7230
       &lt;https://tools.ietf.org/html/rfc7230&gt;, RFC 7231 &lt;https://tools.ietf.org/html/rfc7231&gt; and RFC 2388
       &lt;https://tools.ietf.org/html/rfc2388&gt;, like Mojo::Message::Request and Mojo::Message::Response.

</pre><h4><b>EVENTS</b></h4><pre>
       Mojo::Message inherits all events from Mojo::EventEmitter and can emit the following new ones.

   <b>finish</b>
         $msg-&gt;on(finish =&gt; sub ($msg) {...});

       Emitted after message building or parsing is finished.

         my $before = time;
         $msg-&gt;on(finish =&gt; sub ($msg) { $msg-&gt;headers-&gt;header('X-Parser-Time' =&gt; time - $before) });

   <b>progress</b>
         $msg-&gt;on(progress =&gt; sub ($msg) {...});

       Emitted when message building or parsing makes progress.

         # Building
         $msg-&gt;on(progress =&gt; sub ($msg, $state, $offset) { say qq{Building "$state" at offset $offset} });

         # Parsing
         $msg-&gt;on(progress =&gt; sub ($msg) {
           return unless my $len = $msg-&gt;headers-&gt;content_length;
           my $size = $msg-&gt;content-&gt;progress;
           say 'Progress: ', $size == $len ? 100 : int($size / ($len / 100)), '%';
         });

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       Mojo::Message implements the following attributes.

   <b>content</b>
         my $msg = $msg-&gt;content;
         $msg    = $msg-&gt;content(Mojo::Content::Single-&gt;new);

       Message content, defaults to a Mojo::Content::Single object.

   <b>default_charset</b>
         my $charset = $msg-&gt;default_charset;
         $msg        = $msg-&gt;default_charset('UTF-8');

       Default charset used by "text" and to extract data from "application/x-www-form-urlencoded" or
       "multipart/form-data" message body, defaults to "UTF-8".

   <b>max_line_size</b>
         my $size = $msg-&gt;max_line_size;
         $msg     = $msg-&gt;<a href="../man1024/max_line_size.1024.html">max_line_size</a>(1024);

       Maximum start-line size in bytes, defaults to the value of the "MOJO_MAX_LINE_SIZE" environment variable
       or 8192 (8KiB).

   <b>max_message_size</b>
         my $size = $msg-&gt;max_message_size;
         $msg     = $msg-&gt;<a href="../man1024/max_message_size.1024.html">max_message_size</a>(1024);

       Maximum message size in bytes, defaults to the value of the "MOJO_MAX_MESSAGE_SIZE" environment variable
       or 16777216 (16MiB). Setting the value to 0 will allow messages of indefinite size.

   <b>version</b>
         my $version = $msg-&gt;version;
         $msg        = $msg-&gt;version('1.1');

       HTTP version of message, defaults to 1.1.

</pre><h4><b>METHODS</b></h4><pre>
       Mojo::Message inherits all methods from Mojo::EventEmitter and implements the following new ones.

   <b>body</b>
         my $bytes = $msg-&gt;body;
         $msg      = $msg-&gt;body('Hello!');

       Slurp or replace "content".

   <b>body_params</b>
         my $params = $msg-&gt;body_params;

       "POST" parameters extracted from "application/x-www-form-urlencoded" or "multipart/form-data" message
       body, usually a Mojo::Parameters object. Note that this method caches all data, so it should not be
       called before the entire message body has been received. Parts of the message body need to be loaded into
       memory to parse "POST" parameters, so you have to make sure it is not excessively large. There's a 16MiB
       limit for requests and a 2GiB limit for responses by default.

         # Get POST parameter names and values
         my $hash = $msg-&gt;body_params-&gt;to_hash;

   <b>body_size</b>
         my $size = $msg-&gt;body_size;

       Content size in bytes.

   <b>build_body</b>
         my $bytes = $msg-&gt;build_body;

       Render whole body with "get_body_chunk".

   <b>build_headers</b>
         my $bytes = $msg-&gt;build_headers;

       Render all headers with "get_header_chunk".

   <b>build_start_line</b>
         my $bytes = $msg-&gt;build_start_line;

       Render start-line with "get_start_line_chunk".

   <b>cookie</b>
         my $cookie = $msg-&gt;cookie('foo');

       Access message cookies, usually Mojo::Cookie::Request or Mojo::Cookie::Response objects. If there are
       multiple cookies sharing the same name, and you want to access more than just the last one, you can use
       "every_cookie". Note that this method caches all data, so it should not be called before all headers have
       been received.

         # Get cookie value
         say $msg-&gt;cookie('foo')-&gt;value;

   <b>cookies</b>
         my $cookies = $msg-&gt;cookies;

       Access message cookies. Meant to be overloaded in a subclass.

   <b>dom</b>
         my $dom        = $msg-&gt;dom;
         my $collection = $msg-&gt;dom('a[href]');

       Retrieve message body from "text" and turn it into a Mojo::DOM object, an optional selector can be used
       to call the method "find" in Mojo::DOM on it right away, which then returns a Mojo::Collection object.
       Note that this method caches all data, so it should not be called before the entire message body has been
       received. The whole message body needs to be loaded into memory to parse it, so you have to make sure it
       is not excessively large. There's a 16MiB limit for requests and a 2GiB limit for responses by default.

         # Perform "find" right away
         say $msg-&gt;dom('h1, h2, h3')-&gt;map('text')-&gt;join("\n");

         # Use everything else Mojo::DOM has to offer
         say $msg-&gt;dom-&gt;at('title')-&gt;text;
         say $msg-&gt;dom-&gt;at('body')-&gt;children-&gt;map('tag')-&gt;uniq-&gt;join("\n");

   <b>error</b>
         my $err = $msg-&gt;error;
         $msg    = $msg-&gt;error({message =&gt; 'Parser error'});

       Get or set message error, an "undef" return value indicates that there is no error.

         # Connection or parser error
         $msg-&gt;error({message =&gt; 'Connection refused'});

         # 4xx/5xx response
         $msg-&gt;error({message =&gt; 'Internal Server Error', code =&gt; 500});

   <b>every_cookie</b>
         my $cookies = $msg-&gt;every_cookie('foo');

       Similar to "cookie", but returns all message cookies sharing the same name as an array reference.

         # Get first cookie value
         say $msg-&gt;every_cookie('foo')-&gt;[0]-&gt;value;

   <b>every_upload</b>
         my $uploads = $msg-&gt;every_upload('foo');

       Similar to "upload", but returns all file uploads sharing the same name as an array reference.

         # Get content of first uploaded file
         say $msg-&gt;every_upload('foo')-&gt;[0]-&gt;asset-&gt;slurp;

   <b>extract_start_line</b>
         my $bool = $msg-&gt;extract_start_line(\$str);

       Extract start-line from string. Meant to be overloaded in a subclass.

   <b>finish</b>
         $msg = $msg-&gt;finish;

       Finish message parser/generator.

   <b>fix_headers</b>
         $msg = $msg-&gt;fix_headers;

       Make sure message has all required headers.

   <b>get_body_chunk</b>
         my $bytes = $msg-&gt;get_body_chunk($offset);

       Get a chunk of body data starting from a specific position. Note that it might not be possible to get the
       same chunk twice if content was generated dynamically.

   <b>get_header_chunk</b>
         my $bytes = $msg-&gt;get_header_chunk($offset);

       Get a chunk of header data, starting from a specific position. Note that this method finalizes the
       message.

   <b>get_start_line_chunk</b>
         my $bytes = $msg-&gt;get_start_line_chunk($offset);

       Get a chunk of start-line data starting from a specific position. Meant to be overloaded in a subclass.

   <b>header_size</b>
         my $size = $msg-&gt;header_size;

       Size of headers in bytes. Note that this method finalizes the message.

   <b>headers</b>
         my $headers = $msg-&gt;headers;

       Message headers, usually a Mojo::Headers object.

         # Longer version
         my $headers = $msg-&gt;content-&gt;headers;

   <b>is_finished</b>
         my $bool = $msg-&gt;is_finished;

       Check if message parser/generator is finished.

   <b>is_limit_exceeded</b>
         my $bool = $msg-&gt;is_limit_exceeded;

       Check if message has exceeded "max_line_size", "max_message_size", "max_buffer_size" in Mojo::Content or
       "max_line_size" in Mojo::Headers.

   <b>json</b>
         my $value = $msg-&gt;json;
         my $value = $msg-&gt;json('/foo/bar');

       Decode JSON message body directly using Mojo::JSON if possible, an "undef" return value indicates a bare
       "null" or that decoding failed. An optional JSON Pointer can be used to extract a specific value with
       Mojo::JSON::Pointer.  Note that this method caches all data, so it should not be called before the entire
       message body has been received. The whole message body needs to be loaded into memory to parse it, so you
       have to make sure it is not excessively large.  There's a 16MiB limit for requests and a 2GiB limit for
       responses by default.

         # Extract JSON values
         say $msg-&gt;json-&gt;{foo}{bar}[23];
         say $msg-&gt;json('/foo/bar/23');

   <b>parse</b>
         $msg = $msg-&gt;parse('HTTP/1.1 200 OK...');

       Parse message chunk.

   <b>save_to</b>
         $msg = $msg-&gt;save_to('/some/path/index.html');

       Save message body to a file.

   <b>start_line_size</b>
         my $size = $msg-&gt;start_line_size;

       Size of the start-line in bytes. Meant to be overloaded in a subclass.

   <b>text</b>
         my $str = $msg-&gt;text;

       Retrieve "body" and try to decode it with "charset" in Mojo::Content or "default_charset".

   <b>to_string</b>
         my $str = $msg-&gt;to_string;

       Render whole message. Note that this method finalizes the message, and that it might not be possible to
       render the same message twice if content was generated dynamically.

   <b>upload</b>
         my $upload = $msg-&gt;upload('foo');

       Access "multipart/form-data" file uploads, usually Mojo::Upload objects. If there are multiple uploads
       sharing the same name, and you want to access more than just the last one, you can use "every_upload".
       Note that this method caches all data, so it should not be called before the entire message body has been
       received.

         # Get content of uploaded file
         say $msg-&gt;upload('foo')-&gt;asset-&gt;slurp;

   <b>uploads</b>
         my $uploads = $msg-&gt;uploads;

       All "multipart/form-data" file uploads, usually Mojo::Upload objects.

         # Names of all uploads
         say $_-&gt;name for @{$msg-&gt;uploads};

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mojolicious, Mojolicious::Guides, &lt;https://mojolicious.org&gt;.

perl v5.40.0                                       2024-12-07                                 <u>Mojo::<a href="../man3pm/Message.3pm.html">Message</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>