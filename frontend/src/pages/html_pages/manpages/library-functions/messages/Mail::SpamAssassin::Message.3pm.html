<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mail::SpamAssassin::Message - decode, render, and hold an RFC-2822 message</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/spamassassin">spamassassin_4.0.1-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mail::SpamAssassin::Message - decode, render, and hold an RFC-2822 message

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module encapsulates an email message and allows access to the various MIME message parts and message
       metadata.

       The message structure, after initiating a <b>parse()</b> cycle, looks like this:

         Message object, also top-level node in Message::Node tree
            |
            +---&gt; Message::Node for other parts in MIME structure
            |       |---&gt; [ more Message::Node parts ... ]
            |       [ others ... ]
            |
            +---&gt; Message::Metadata object to hold metadata

</pre><h4><b>PUBLIC</b> <b>METHODS</b></h4><pre>
       <b>new()</b>
           Creates  a Mail::SpamAssassin::Message object.  Takes a hash reference as a parameter.  The used hash
           key/value pairs are as follows:

           "message" is either undef (which will use STDIN), a scalar - a string containing an entire message, a
           reference to such string, an array reference of the message with  one  line  per  array  element,  or
           either a file glob or an IO::File object which holds the entire contents of the message.

           Note:  The  message  is  expected  to  generally  be in RFC 2822 format, optionally including an mbox
           message separator line (the "From " line) as the first line.

           "parse_now" specifies whether or not to create the MIME tree at  object-creation  time  or  later  as
           necessary.

           The  <u>parse_now</u>  option,  by  default,  is  set to false (0).  This allows SpamAssassin to not have to
           generate the tree of Mail::SpamAssassin::Message::Node objects and their related data if the tree  is
           not  going to be used.  This is handy, for instance, when running "spamassassin -d", which only needs
           the pristine header and body which is always handled when the object is created.

           "subparse" specifies how many MIME recursion levels should be parsed.  Defaults to 20.

       <b>find_parts()</b>
           Used to search the tree for specific MIME  parts.   See  <u>Mail::SpamAssassin::Message::Node</u>  for  more
           details.

       <b>get_pristine_header()</b>
           Returns  pristine  headers of the message.  If no specific header name is given as a parameter (case-
           insensitive), then all headers will be returned as a scalar, including the blank line at the  end  of
           the headers.

           If  called  in  an  array context, an array will be returned with each specific header in a different
           element.  In a scalar context, the last specific header is returned.

           ie: If 'Subject' is specified as the header, and there are  2  Subject  headers  in  a  message,  the
           last/bottom one in the message is returned in scalar context or both are returned in array context.

           Btw,  returning  the last header field (not the first) happens to be consistent with DKIM signatures,
           which search for and cover multiple header fields bottom-up according to the 'h' tag. Let's  keep  it
           this way.

           Note: the returned header will include the ending newline and any embedded whitespace folding.

       <b>get_mbox_separator()</b>
           Returns the mbox separator found in the message, or undef if there wasn't one.

       <b>get_body()</b>
           Returns an array of the pristine message body, one line per array element.

       <b>get_pristine()</b>
           Returns a scalar of the entire pristine message.

       <b>get_pristine_body()</b>
           Returns a scalar of the pristine message body.

       <b>get_pristine_body_digest()</b>
           Returns  SHA1 hex digest of the pristine message body.  CRLF line endings are normalized to LF before
           hashing.

       <b>get_msgid()</b>
           Returns Message-ID header for the message, with &lt;&gt; and surrounding whitespace removed. Returns undef,
           if nothing found between &lt;&gt;.

       <b>generate_msgid()</b>
           Generate a calculated "Message-ID"  in  <b>sha1hex@sa_generated</b>  format,  using  To,  Date  headers  and
           pristine body as source for hashing.

       extract_message_metadata($permsgstatus)
       $str = get_metadata($hdr)
       put_metadata($hdr, $text)
       delete_metadata($hdr)
       $str = <b>get_all_metadata()</b>
       <b>finish_metadata()</b>
           Destroys  the  metadata  for this message.  Once a message has been scanned fully, the metadata is no
           longer required.   Destroying this will free up some memory.

       <b>finish()</b>
           Clean up an object so that it can be destroyed.

       <b>receive_date()</b>
           Return a time_t value with the received date of the current message, or current time if received time
           couldn't be determined.

</pre><h4><b>PARSING</b> <b>METHODS,</b> <b>NON-PUBLIC</b></h4><pre>
       These methods take a RFC2822-esque formatted message and create a tree with all of the  MIME  body  parts
       included.  Those parts will be decoded as necessary, and text/html parts will be rendered into a standard
       text format, suitable for use in SpamAssassin.

       <b>parse_body()</b>
           <b>parse_body()</b>  passes  the  body  part  that  was  passed  in  onto  the  correct  part parser, either
           <b>_parse_multipart()</b> for multipart/* parts, or <b>_parse_normal()</b> for everything else.  Multipart sections
           become the root of sub-trees, while everything else becomes a leaf in the tree.

           For multipart messages, the first call to <b>parse_body()</b> doesn't create a new sub-tree  and  just  uses
           the  parent node to contain children.  All other calls to <b>parse_body()</b> will cause a new sub-tree root
           to be created and children will exist underneath that root.  (this is just so the tree doesn't have a
           root node which points at the actual root node ...)

       <b>_parse_multipart()</b>
           Generate a root node, and for each child part call <b>parse_body()</b> to generate the tree.

       <b>_parse_normal()</b>
           Generate a leaf node and add it to the parent.

perl v5.40.1                                       2025-06-26                   <u>Mail::SpamAssassin::<a href="../man3pm/Message.3pm.html">Message</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>