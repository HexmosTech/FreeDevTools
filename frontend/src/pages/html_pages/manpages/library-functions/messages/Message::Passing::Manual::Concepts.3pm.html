<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Message::Passing::Manual::Concepts - The concepts behind the framework</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmessage-passing-perl">libmessage-passing-perl_0.117-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Message::Passing::Manual::Concepts - The concepts behind the framework

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This framework tries to be a simplifying layer over message passing, allowing you to easily make the
       networking parts of message passing become just configuration. This allows you to concentrate on the hard
       parts (i.e. your application, not the message passing).

</pre><h4><b>COMPONENTS</b> <b>AND</b> <b>CHAINS</b></h4><pre>
       There are only a few core concepts to grasp to use the framework. We'll start with the component types,
       and then move onto chains.

       There are only three types of components:

   <b>OUTPUTS</b>
       An output is simply a class with a "consume" method. This will be called with a message as its only
       parameter, like this:

           $output-&gt;consume($message);

       Outputs are expected to compose Message::Passing::Role::Output.

   <b>INPUTS</b>
       An input is simply a class with an "output_to" attribute. Your code just calls the consume method on its
       output, like this:

           $self-&gt;output_to-&gt;consume($message);

       Inputs are expected to compose Message::Passing::Role::Input which provides this attribute, and use the
       "BUILD" method from Moo to do any work needed to start listening for events.

   <b>FILTER</b>
       A filter is just a combination of an output and input. Some (or all) of the messages consumed by the
       input are sent on to the output.

       An optional Message::Passing::Role::Filter is supplied, allowing you to provide a simple filter method:

           with 'Message::Passing::Role::Filter';

           sub filter {
               my ($self, $message) = @_;
               return $message; # Or return undef to drop it
           }

       However, you can write a filter manually as:

           with qw/
               Message::Passing::Role::Input
               Message::Passing::Role::Output
           /;

           sub consume {
               my ($self, $message) = @_;
               # Do something to $message here
               $self-&gt;output_to-&gt;consume($message);
           }

       As you've hopefully guessed by now, a "chain" is just an input, outputting to zero or more filters, which
       output to an output.

</pre><h4><b>DSL</b></h4><pre>
       So, this is all pretty easy, and you already know enough to pick up some components and use them! For
       example:

           use Message::Passing::Input::FileTail;
           use Message::Passing::Output::STDOUT;

           Message::Passing::Input::FileTail-&gt;new(
               filename =&gt; $ARGV[0],
               output_to =&gt; Message::Passing::Output::STDOUT-&gt;new,
           );
           AnyEvent-&gt;condvar-&gt;recv; # Enter event loop

       There you go - you're tailing a file to screen - however you could just as easily by sending it over the
       network with ZeroMQ or any other output.

       This is, however, a bit ugly! If you're building a chain of several filters, or you have several inputs
       being multiplexed into one output, then the code gets ugly fast.

       To make it easy to build chains of processing, and your own scripts, a simple DSL is provided.  The
       example above becomes:

           use Message::Passing::DSL;

           run_message_server message_chain {
               input file =&gt; (
                   class =&gt; 'FileTail',
                   output_to =&gt; 'stdout',
               );
               output stdout =&gt; (
                   class =&gt; 'STDOUT',
               );
           };

</pre><h4><b>Event</b> <b>loop</b></h4><pre>
       AnyEvent has been mentioned, and it's expected that scripts will use a supported event loop. This implies
       that your code is asynchronous, which is generally fine - however it should be noted that doing any long
       operation (non trivial database queries) will block the entire server - meaning no events will be
       processed.

       In cases such as these, running a pool of worker processes to distribute the blocking jobs is more
       appropriate, and easy to wire up (on one or more hosts). This is documented more fully in
       Message::Passing::Manual::Workers

</pre><h4><b>ZeroMQ</b></h4><pre>
       ZeroMQ is the recommended transport for messages, and Message::Passing::Output::ZeroMQ is designed to
       work inside a traditional synchronous application. This means that you can emit messages into ZeroMQ
       without blocking your application, or having to use or run the AnyEvent event loop.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
   <b>Message::Passing::Manual::Cookbook</b>
       Recipies for achieving common tasks

</pre><h4><b>AUTHOR,</b> <b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       See Message::Passing.

perl v5.32.1                                       2021-11-09             <u>Message::Passin...anual::<a href="../man3pm/Concepts.3pm.html">Concepts</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>