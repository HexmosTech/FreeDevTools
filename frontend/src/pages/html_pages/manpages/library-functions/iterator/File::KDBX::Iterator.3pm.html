<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File::KDBX::Iterator - KDBX database iterator</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfile-kdbx-perl">libfile-kdbx-perl_0.906-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       File::KDBX::Iterator - KDBX database iterator

</pre><h4><b>VERSION</b></h4><pre>
       version 0.906

</pre><h4><b>SYNOPSIS</b></h4><pre>
           my $kdbx = File::KDBX-&gt;load('database.kdbx', 'masterpw');

           $kdbx-&gt;entries
               -&gt;where(sub { $_-&gt;title =~ /bank/i })
               -&gt;order_by('title')
               -&gt;<a href="../man5/limit.5.html">limit</a>(5)
               -&gt;each(sub {
                   say $_-&gt;title;
               });

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A buffered iterator compatible with and expanding upon Iterator::Simple, this provides an easy way to
       navigate a File::KDBX database. The documentation for <b>Iterator::Simple</b> documents functions and methods
       supported by this iterator that are not documented here, so consider that additional reading.

   <b>Buffer</b>
       This iterator is buffered, meaning it can drain from an iterator subroutine under the hood, storing items
       temporarily to be accessed later. This allows features like "peek" and "order_by" which might be useful
       in the context of KDBX databases which are normally pretty small so draining an iterator completely isn't
       cost-prohibitive in terms of memory usage.

       The way this works is that if you call an iterator without arguments, it acts like a normal iterator. If
       you call it with arguments, however, the arguments are added to the buffer. When called without
       arguments, the buffer is drained before the iterator function is. Using "unget" is equivalent to calling
       the iterator with arguments, and "next" is equivalent to calling the iterator without arguments.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
           \&amp;iterator = File::KDBX::Iterator-&gt;new(\&amp;iterator);

       Bless an iterator to augment it with buffering plus some useful utility methods.

   <b>next</b>
           $item = $iterator-&gt;next;
           # OR equivalently
           $item = $iterator-&gt;();

           $item = $iterator-&gt;next(\&amp;query);

       Get the next item or "undef" if there are no more items. If a query is passed, get the next matching
       item, discarding any unmatching items before the matching item. Example:

           my $item = $iterator-&gt;next(sub { $_-&gt;label =~ /Gym/ });

   <b>peek</b>
           $item = $iterator-&gt;peek;

       Peek at the next item. Returns "undef" if the iterator is empty. This allows you to access the next item
       without draining it from the iterator. The same item will be returned the next time "next" is called.

   <b>unget</b>
           # Replace buffer:
           $iterator-&gt;unget(\@items);
           # OR equivalently
           $iterator-&gt;(\@items);

           # Unshift onto buffer:
           $iterator-&gt;unget(@items);
           # OR equivalently
           $iterator-&gt;(@items);

       Replace the buffer (first form) or unshift one or more items to the current buffer (second form).

       See "Buffer".

   <b>each</b>
           @items = $iterator-&gt;each;

           $iterator-&gt;each(sub($item, $num, @args) { ... }, @args);

           $iterator-&gt;each($method_name, ...);

       Get or act on the rest of the items. This method has three forms:

       1.  Without arguments, "each" returns a list of the rest of the items.

       2.  Pass  a  coderef  to  be called once per item, in order. Arguments to the coderef are the item itself
           (also available as $_), its index number and then any extra arguments  that  were  passed  to  "each"
           after the coderef.

       3.  Pass a string that is the name of a method to be called on each object, in order. Any extra arguments
           passed  to  "each"  after  the method name are passed through to each method call. This form requires
           each item be an object that "can" the given method.

       <b>NOTE:</b> This method drains the iterator completely, leaving it empty. See "CAVEATS".

   <b>grep</b>
   <b>where</b>
           \&amp;iterator = $iterator-&gt;grep(\&amp;query);
           \&amp;iterator = $iterator-&gt;grep(sub($item) { ... });

       Get a new iterator draining from an existing iterator but providing only items that pass a  test  or  are
       matched by a query. In its basic form this method is very much like perl's built-in grep function, except
       for iterators.

       There are many examples of the various forms of this method at "QUERY" in File::KDBX.

   <b>map</b>
           \&amp;iterator = $iterator-&gt;map(\&amp;code);

       Get  a  new  iterator  draining from an existing iterator but providing modified items. In its basic form
       this method is very much like perl's built-in map function, except for iterators.

   <b>order_by</b>
           \&amp;iterator = $iterator-&gt;sort_by($field, %options);
           \&amp;iterator = $iterator-&gt;sort_by(\&amp;get_value, %options);

       Get a new iterator draining from an existing iterator but providing items  sorted  by  an  object  field.
       Sorting   is  done  using  Unicode::Collate  (if  available)  or  "cmp"  to  sort  alphanumerically.  The
       "\&amp;get_value" subroutine is called once for each item and should return a string value. Options:

       •   "ascending" - Order ascending if true, descending otherwise (default: true)

       •   "case" - If true, take case into account, otherwise ignore case (default: true)

       •   "collate" - If true, use <b>Unicode::Collate</b> (if available),  otherwise  use  perl  built-ins  (default:
           true)

       •   Any <b>Unicode::Collate</b> option is also supported.

       <b>NOTE:</b>  This  method  drains  the  iterator  completely  and  places the sorted items onto the buffer. See
       "CAVEATS".

   <b>sort_by</b>
       Alias for "order_by".

   <b>norder_by</b>
           \&amp;iterator = $iterator-&gt;nsort_by($field, %options);
           \&amp;iterator = $iterator-&gt;nsort_by(\&amp;get_value, %options);

       Get a new iterator draining from an existing iterator but providing items  sorted  by  an  object  field.
       Sorting  is  done numerically using "&lt;=&gt;". The "\&amp;get_value" subroutine or $field accessor is called once
       for each item and should return a numerical value. Options:

       •   "ascending" - Order ascending if true, descending otherwise (default: true)

       <b>NOTE:</b> This method drains the iterator completely and  places  the  sorted  items  onto  the  buffer.  See
       "CAVEATS".

   <b>nsort_by</b>
       Alias for "norder_by".

   <b>limit</b>
           \&amp;iterator = $iterator-&gt;limit($count);

       Get a new iterator draining from an existing iterator but providing only a limited number of items.

       "limit" is an alias for "$iterator-&gt;head($count)" in Iterator::Simple.

   <b>to_array</b>
           \@array = $iterator-&gt;to_array;

       Get the rest of the items from an iterator as an arrayref.

       <b>NOTE:</b> This method drains the iterator completely, leaving it empty. See "CAVEATS".

   <b>count</b>
           $size = $iterator-&gt;count;

       Count the rest of the items from an iterator.

       <b>NOTE:</b> This method drains the iterator completely but restores it to its pre-drained state. See "CAVEATS".

   <b>size</b>
       Alias for "count".

</pre><h4><b>CAVEATS</b></h4><pre>
       Some  methods  attempt to drain the iterator completely before returning. For obvious reasons, this won't
       work for infinite iterators because your computer doesn't have infinite memory. This  isn't  a  practical
       issue  with  <b>File::KDBX</b> lists which are always finite -- unless you do something weird like force a child
       group to be its own ancestor -- but I'm noting it here as a potential issue  if  you  use  this  iterator
       class for other things (which you probably shouldn't do).

       KDBX  databases  are  always fully-loaded into memory anyway, so there's not a significant memory cost to
       draining an iterator completely.

</pre><h4><b>BUGS</b></h4><pre>
       Please    report    any    bugs     or     feature     requests     on     the     bugtracker     website
       &lt;https://github.com/chazmcgarvey/File-KDBX/issues&gt;

       When  submitting  a  bug  or request, please include a test-file or a patch to an existing test-file that
       illustrates the bug or desired feature.

</pre><h4><b>AUTHOR</b></h4><pre>
       Charles McGarvey &lt;<a href="mailto:ccm@cpan.org">ccm@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2022 by Charles McGarvey.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.40.1                                       2025-05-04                          <u>File::KDBX::<a href="../man3pm/Iterator.3pm.html">Iterator</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>