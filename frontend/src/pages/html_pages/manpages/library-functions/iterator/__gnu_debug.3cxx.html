<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
<b>__</b><u>gnu_debug</u>(3cxx)                                                                              <b>__</b><u>gnu_debug</u>(3cxx)

</pre><h4><b>NAME</b></h4><pre>
       __gnu_debug - GNU debug classes for public use.

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Classes</b>
       class <b>_After_nth_from</b>
       struct <b>_BeforeBeginHelper</b>
       class <b>_Equal_to</b>
       class <b>_Not_equal_to</b>
       class <b>_Safe_container</b>
           Safe class dealing with some allocator dependent operations.
       class <b>_Safe_forward_list</b>
           Special iterators swap and invalidation for forward_list because of the before_begin iterator.
       class <b>_Safe_iterator</b>
           Safe iterator wrapper.
       class <b>_Safe_iterator_base</b>
           Basic functionality for a <u>safe</u> iterator.
       class <b>_Safe_local_iterator</b>
           Safe iterator wrapper.
       class <b>_Safe_local_iterator_base</b>
           Basic functionality for a <u>safe</u> iterator.
       class <b>_Safe_node_sequence</b>
           Like _Safe_sequence but with a special _M_invalidate_all implementation not invalidating past-the-end
           iterators. Used by node based sequence.
       class <b>_Safe_sequence</b>
           Base class for constructing a <u>safe</u> sequence type that tracks iterators that reference it.
       class <b>_Safe_sequence_base</b>
           Base class that supports tracking of iterators that reference a sequence.
       class <b>_Safe_unordered_container</b>
           Base class for constructing a <u>safe</u> unordered container type that tracks iterators that reference it.
       class <b>_Safe_unordered_container_base</b>
           Base class that supports tracking of local iterators that reference an unordered container.
       class <b>_Safe_vector</b>
           Base class for Debug Mode vector.
       struct <b>_Sequence_traits</b>
       class <b>basic_string</b>
           Class std::basic_string with safety/checking/debug instrumentation.

   <b>Typedefs</b>
       typedef <b>basic_string</b>&lt; char &gt; <b>string</b>
       typedef <b>basic_string</b>&lt; char16_t &gt; <b>u16string</b>
           A string of char16_t.
       typedef <b>basic_string</b>&lt; char32_t &gt; <b>u32string</b>
           A string of char32_t.
       typedef <b>basic_string</b>&lt; wchar_t &gt; <b>wstring</b>

   <b>Enumerations</b>
       enum <b>_Debug_msg_id</b> { <b>__msg_valid_range</b>, <b>__msg_insert_singular</b>, <b>__msg_insert_different</b>, <b>__msg_erase_bad</b>,
           <b>__msg_erase_different</b>, <b>__msg_subscript_oob</b>, <b>__msg_empty</b>, <b>__msg_unpartitioned</b>,
           <b>__msg_unpartitioned_pred</b>, <b>__msg_unsorted</b>, <b>__msg_unsorted_pred</b>, <b>__msg_not_heap</b>, <b>__msg_not_heap_pred</b>,
           <b>__msg_bad_bitset_write</b>, <b>__msg_bad_bitset_read</b>, <b>__msg_bad_bitset_flip</b>, <b>__msg_self_splice</b>,
           <b>__msg_splice_alloc</b>, <b>__msg_splice_bad</b>, <b>__msg_splice_other</b>, <b>__msg_splice_overlap</b>, <b>__msg_init_singular</b>,
           <b>__msg_init_copy_singular</b>, <b>__msg_init_const_singular</b>, <b>__msg_copy_singular</b>, <b>__msg_bad_deref</b>,
           <b>__msg_bad_inc</b>, <b>__msg_bad_dec</b>, <b>__msg_iter_subscript_oob</b>, <b>__msg_advance_oob</b>, <b>__msg_retreat_oob</b>,
           <b>__msg_iter_compare_bad</b>, <b>__msg_compare_different</b>, <b>__msg_iter_order_bad</b>, <b>__msg_order_different</b>,
           <b>__msg_distance_bad</b>, <b>__msg_distance_different</b>, <b>__msg_deref_istream</b>, <b>__msg_inc_istream</b>,
           <b>__msg_output_ostream</b>, <b>__msg_deref_istreambuf</b>, <b>__msg_inc_istreambuf</b>, <b>__msg_insert_after_end</b>,
           <b>__msg_erase_after_bad</b>, <b>__msg_valid_range2</b>, <b>__msg_local_iter_compare_bad</b>, <b>__msg_non_empty_range</b>,
           <b>__msg_self_move_assign</b>, <b>__msg_bucket_index_oob</b>, <b>__msg_valid_load_factor</b>, <b>__msg_equal_allocs</b>,
           <b>__msg_insert_range_from_self</b>, <b>__msg_irreflexive_ordering</b> }
       enum <b>_Distance_precision</b> { <b>__dp_none</b>, <b>__dp_equality</b>, <b>__dp_sign</b>, <b>__dp_sign_max_size</b>, <b>__dp_exact</b> }

   <b>Functions</b>
       template&lt;typename _Iterator &gt; constexpr _Iterator <b>__base</b> (_Iterator __it)
       template&lt;typename _Iterator , typename _Sequence &gt; _Iterator <b>__base</b> (const <b>_Safe_iterator</b>&lt; _Iterator,
           _Sequence, <b>std::random_access_iterator_tag</b> &gt; &amp;__it)
       template&lt;typename _Iterator &gt; constexpr auto <b>__base</b> (const <b>std::move_iterator</b>&lt; _Iterator &gt; &amp;__it) -&gt;
           decltype(std::make_move_iterator(__base(__it.base())))
       template&lt;typename _Iterator , typename _Sequence &gt; constexpr <b>std::reverse_iterator</b>&lt; _Iterator &gt; <b>__base</b>
           (const <b>std::reverse_iterator</b>&lt; <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, <b>std::random_access_iterator_tag</b> &gt;
           &gt; &amp;__it)
       template&lt;typename _InputIterator , typename _Size &gt; constexpr bool <b>__can_advance</b> (_InputIterator, _Size)
       template&lt;typename _InputIterator , typename _Diff &gt; constexpr bool <b>__can_advance</b> (_InputIterator, const
           <b>std::pair</b>&lt; _Diff, <b>_Distance_precision</b> &gt; &amp;, int)
       template&lt;typename _Iterator , typename _Sequence , typename _Category , typename _Size &gt; bool
           <b>__can_advance</b> (const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category &gt; &amp;, _Size)
       template&lt;typename _Iterator , typename _Sequence , typename _Category , typename _Diff &gt; bool
           <b>__can_advance</b> (const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category &gt; &amp;, const <b>std::pair</b>&lt; _Diff,
           <b>_Distance_precision</b> &gt; &amp;, int)
       template&lt;typename _Iterator , typename _Size &gt; constexpr bool <b>__can_advance</b> (const <b>std::move_iterator</b>&lt;
           _Iterator &gt; &amp;__it, _Size __n)
       template&lt;typename _Iterator , typename _Diff &gt; constexpr bool <b>__can_advance</b> (const <b>std::move_iterator</b>&lt;
           _Iterator &gt; &amp;__it, const <b>std::pair</b>&lt; _Diff, <b>_Distance_precision</b> &gt; &amp;__dist, int __way)
       template&lt;typename _Iterator , typename _Size &gt; constexpr bool <b>__can_advance</b> (const <b>std::reverse_iterator</b>&lt;
           _Iterator &gt; &amp;__it, _Size __n)
       template&lt;typename _Iterator , typename _Diff &gt; constexpr bool <b>__can_advance</b> (const <b>std::reverse_iterator</b>&lt;
           _Iterator &gt; &amp;__it, const <b>std::pair</b>&lt; _Diff, <b>_Distance_precision</b> &gt; &amp;__dist, int __way)
       template&lt;typename _ForwardIterator , typename _Tp &gt; constexpr bool <b>__check_partitioned_lower</b>
           (_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__value)
       template&lt;typename _ForwardIterator , typename _Tp , typename _Pred &gt; constexpr bool
           <b>__check_partitioned_lower</b> (_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__value,
           _Pred __pred)
       template&lt;typename _ForwardIterator , typename _Tp &gt; constexpr bool <b>__check_partitioned_upper</b>
           (_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__value)
       template&lt;typename _ForwardIterator , typename _Tp , typename _Pred &gt; constexpr bool
           <b>__check_partitioned_upper</b> (_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__value,
           _Pred __pred)
       template&lt;typename _Iterator &gt; constexpr bool <b>__check_singular</b> (_Iterator const &amp;)
       template&lt;typename _Tp &gt; constexpr bool <b>__check_singular</b> (_Tp *const &amp;__ptr)
       bool <b>__check_singular_aux</b> (const <b>_Safe_iterator_base</b> *__x)
       bool <b>__check_singular_aux</b> (const class <b>_Safe_iterator_base</b> *)
       bool <b>__check_singular_aux</b> (const void *)
       template&lt;typename _InputIterator &gt; constexpr bool <b>__check_sorted</b> (const _InputIterator &amp;__first, const
           _InputIterator &amp;__last)
       template&lt;typename _InputIterator , typename _Predicate &gt; constexpr bool <b>__check_sorted</b> (const
           _InputIterator &amp;__first, const _InputIterator &amp;__last, _Predicate __pred)
       template&lt;typename _ForwardIterator , typename _Predicate &gt; constexpr bool <b>__check_sorted_aux</b>
           (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, <b>std::forward_iterator_tag</b>)
       template&lt;typename _ForwardIterator &gt; constexpr bool <b>__check_sorted_aux</b> (_ForwardIterator __first,
           _ForwardIterator __last, <b>std::forward_iterator_tag</b>)
       template&lt;typename _InputIterator , typename _Predicate &gt; constexpr bool <b>__check_sorted_aux</b> (const
           _InputIterator &amp;, const _InputIterator &amp;, _Predicate, <b>std::input_iterator_tag</b>)
       template&lt;typename _InputIterator &gt; constexpr bool <b>__check_sorted_aux</b> (const _InputIterator &amp;, const
           _InputIterator &amp;, <b>std::input_iterator_tag</b>)
       template&lt;typename _InputIterator1 , typename _InputIterator2 &gt; constexpr bool <b>__check_sorted_set</b> (const
           _InputIterator1 &amp;__first, const _InputIterator1 &amp;__last, const _InputIterator2 &amp;)
       template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _Predicate &gt; constexpr bool
           <b>__check_sorted_set</b> (const _InputIterator1 &amp;__first, const _InputIterator1 &amp;__last, const
           _InputIterator2 &amp;, _Predicate __pred)
       template&lt;typename _InputIterator , typename _Predicate &gt; constexpr bool <b>__check_sorted_set_aux</b> (const
           _InputIterator &amp;, const _InputIterator &amp;, _Predicate, std::__false_type)
       template&lt;typename _InputIterator &gt; constexpr bool <b>__check_sorted_set_aux</b> (const _InputIterator &amp;, const
           _InputIterator &amp;, std::__false_type)
       template&lt;typename _InputIterator , typename _Predicate &gt; constexpr bool <b>__check_sorted_set_aux</b> (const
           _InputIterator &amp;__first, const _InputIterator &amp;__last, _Predicate __pred, std::__true_type)
       template&lt;typename _InputIterator &gt; constexpr bool <b>__check_sorted_set_aux</b> (const _InputIterator &amp;__first,
           const _InputIterator &amp;__last, std::__true_type)
       template&lt;typename _CharT , typename _Integer &gt; const _CharT * <b>__check_string</b> (const _CharT *__s, _Integer
           __n, const char *__file, unsigned int __line, const char *__function)
       template&lt;typename _CharT &gt; const _CharT * <b>__check_string</b> (const _CharT *__s, const char *__file, unsigned
           int __line, const char *__function)
       template&lt;typename _InputIterator &gt; _InputIterator <b>__check_valid_range</b> (const _InputIterator &amp;__first,
           const _InputIterator &amp;__last, const char *__file, unsigned int __line, const char *__function)
       template&lt;typename _Iterator , typename _Sequence , typename _Category , typename _InputIterator &gt; bool
           <b>__foreign_iterator</b> (const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category &gt; &amp;__it, _InputIterator
           __other, _InputIterator __other_end)
       template&lt;typename _Iterator , typename _Sequence , typename _Category , typename _Integral &gt; bool
           <b>__foreign_iterator_aux</b> (const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category &gt; &amp;, _Integral,
           _Integral, std::__true_type)
       template&lt;typename _Iterator , typename _Sequence , typename _Category , typename _InputIterator &gt; bool
           <b>__foreign_iterator_aux</b> (const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category &gt; &amp;__it, _InputIterator
           __other, _InputIterator __other_end, std::__false_type)
       template&lt;typename _Iterator , typename _Sequence , typename _Category , typename _OtherIterator ,
           typename _OtherSequence , typename _OtherCategory &gt; bool <b>__foreign_iterator_aux2</b> (const
           <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category &gt; &amp;, const <b>_Safe_iterator</b>&lt; _OtherIterator,
           _OtherSequence, _OtherCategory &gt; &amp;, const <b>_Safe_iterator</b>&lt; _OtherIterator, _OtherSequence,
           _OtherCategory &gt; &amp;)
       template&lt;typename _Iterator , typename _Sequence , typename _Category , typename _InputIterator &gt; bool
           <b>__foreign_iterator_aux2</b> (const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category &gt; &amp;__it, const
           _InputIterator &amp;__other, const _InputIterator &amp;__other_end)
       template&lt;typename _Iterator , typename _Sequence , typename _Category , typename _OtherIterator &gt; bool
           <b>__foreign_iterator_aux2</b> (const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category &gt; &amp;__it, const
           <b>_Safe_iterator</b>&lt; _OtherIterator, _Sequence, _Category &gt; &amp;__other, const <b>_Safe_iterator</b>&lt;
           _OtherIterator, _Sequence, _Category &gt; &amp;)
       template&lt;typename _Iterator , typename _Sequence , typename _Category , typename _InputIterator &gt; bool
           <b>__foreign_iterator_aux3</b> (const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category &gt; &amp;, const
           _InputIterator &amp;, const _InputIterator &amp;, std::__false_type)
       template&lt;typename _Iterator , typename _Sequence , typename _Category , typename _InputIterator &gt; bool
           <b>__foreign_iterator_aux3</b> (const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category &gt; &amp;__it, const
           _InputIterator &amp;__other, const _InputIterator &amp;__other_end, std::__true_type)
       template&lt;typename _Iterator , typename _Sequence , typename _Category &gt; bool <b>__foreign_iterator_aux4</b>
           (const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category &gt; &amp;,...)
       template&lt;typename _Iterator , typename _Sequence , typename _Category &gt; bool <b>__foreign_iterator_aux4</b>
           (const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category &gt; &amp;__it, const typename _Sequence::value_type
           *__other)
       template&lt;typename _Iterator &gt; constexpr _Distance_traits&lt; _Iterator &gt;::__type <b>__get_distance</b> (_Iterator
           __lhs, _Iterator __rhs)
       template&lt;typename _Iterator &gt; constexpr _Distance_traits&lt; _Iterator &gt;::__type <b>__get_distance</b> (_Iterator
           __lhs, _Iterator __rhs, <b>std::input_iterator_tag</b>)
       template&lt;typename _Iterator &gt; constexpr _Distance_traits&lt; _Iterator &gt;::__type <b>__get_distance</b> (_Iterator
           __lhs, _Iterator __rhs, <b>std::random_access_iterator_tag</b>)
       template&lt;typename _Iterator &gt; constexpr _Distance_traits&lt; _Iterator &gt;::__type <b>__get_distance</b> (const
           <b>std::move_iterator</b>&lt; _Iterator &gt; &amp;__first, const <b>std::move_iterator</b>&lt; _Iterator &gt; &amp;__last)
       template&lt;typename _Iterator &gt; constexpr _Distance_traits&lt; _Iterator &gt;::__type <b>__get_distance</b> (const
           <b>std::reverse_iterator</b>&lt; _Iterator &gt; &amp;__first, const <b>std::reverse_iterator</b>&lt; _Iterator &gt; &amp;__last)
       template&lt;typename _Iterator &gt; constexpr bool <b>__is_irreflexive</b> (_Iterator __it)
       template&lt;typename _Iterator , typename _Pred &gt; constexpr bool <b>__is_irreflexive_pred</b> (_Iterator __it,
           _Pred __pred)
       template&lt;typename _Iterator &gt; _Iterator <b>__unsafe</b> (_Iterator __it)
       template&lt;typename _Iterator , typename _Sequence &gt; _Iterator <b>__unsafe</b> (const <b>_Safe_iterator</b>&lt; _Iterator,
           _Sequence &gt; &amp;__it)
       template&lt;typename _Iterator , typename _Sequence &gt; _Iterator <b>__unsafe</b> (const <b>_Safe_local_iterator</b>&lt;
           _Iterator, _Sequence &gt; &amp;__it)
       template&lt;typename _Iterator &gt; constexpr auto <b>__unsafe</b> (const <b>std::move_iterator</b>&lt; _Iterator &gt; &amp;__it) -&gt;
           decltype(std::make_move_iterator(__unsafe(__it.base())))
       template&lt;typename _Iterator &gt; constexpr auto <b>__unsafe</b> (const <b>std::reverse_iterator</b>&lt; _Iterator &gt; &amp;__it) -&gt;
           decltype(std::__make_reverse_iterator(__unsafe(__it.base())))
       template&lt;typename _InputIterator &gt; constexpr bool <b>__valid_range</b> (_InputIterator __first, _InputIterator
           __last)
       template&lt;typename _InputIterator &gt; constexpr bool <b>__valid_range</b> (_InputIterator __first, _InputIterator
           __last, typename _Distance_traits&lt; _InputIterator &gt;::__type &amp;__dist)
       template&lt;typename _Iterator , typename _Sequence , typename _Category &gt; bool <b>__valid_range</b> (const
           <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category &gt; &amp;, const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence,
           _Category &gt; &amp;)
       template&lt;typename _Iterator , typename _Sequence , typename _Category &gt; bool <b>__valid_range</b> (const
           <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category &gt; &amp;, const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence,
           _Category &gt; &amp;, typename _Distance_traits&lt; _Iterator &gt;::__type &amp;)
       template&lt;typename _Iterator , typename _Sequence &gt; bool <b>__valid_range</b> (const <b>_Safe_local_iterator</b>&lt;
           _Iterator, _Sequence &gt; &amp;, const <b>_Safe_local_iterator</b>&lt; _Iterator, _Sequence &gt; &amp;)
       template&lt;typename _Iterator , typename _Sequence &gt; bool <b>__valid_range</b> (const <b>_Safe_local_iterator</b>&lt;
           _Iterator, _Sequence &gt; &amp;, const <b>_Safe_local_iterator</b>&lt; _Iterator, _Sequence &gt; &amp;, typename
           _Distance_traits&lt; _Iterator &gt;::__type &amp;)
       template&lt;typename _Iterator &gt; constexpr bool <b>__valid_range</b> (const <b>std::move_iterator</b>&lt; _Iterator &gt;
           &amp;__first, const <b>std::move_iterator</b>&lt; _Iterator &gt; &amp;__last, typename _Distance_traits&lt; _Iterator
           &gt;::__type &amp;__dist)
       template&lt;typename _Iterator &gt; constexpr bool <b>__valid_range</b> (const <b>std::reverse_iterator</b>&lt; _Iterator &gt;
           &amp;__first, const <b>std::reverse_iterator</b>&lt; _Iterator &gt; &amp;__last, typename _Distance_traits&lt; _Iterator
           &gt;::__type &amp;__dist)
       template&lt;typename _InputIterator &gt; constexpr bool <b>__valid_range_aux</b> (_InputIterator __first,
           _InputIterator __last, std::__false_type)
       template&lt;typename _InputIterator &gt; constexpr bool <b>__valid_range_aux</b> (_InputIterator __first,
           _InputIterator __last, <b>std::input_iterator_tag</b>)
       template&lt;typename _InputIterator &gt; constexpr bool <b>__valid_range_aux</b> (_InputIterator __first,
           _InputIterator __last, <b>std::random_access_iterator_tag</b>)
       template&lt;typename _InputIterator &gt; constexpr bool <b>__valid_range_aux</b> (_InputIterator __first,
           _InputIterator __last, typename _Distance_traits&lt; _InputIterator &gt;::__type &amp;__dist,
           std::__false_type)
       template&lt;typename _Integral &gt; constexpr bool <b>__valid_range_aux</b> (_Integral, _Integral, std::__true_type)
       template&lt;typename _Integral &gt; constexpr bool <b>__valid_range_aux</b> (_Integral, _Integral, typename
           _Distance_traits&lt; _Integral &gt;::__type &amp;__dist, std::__true_type)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; <b>std::basic_istream</b>&lt; _CharT, _Traits &gt;
           &amp; <b>getline</b> (<b>std::basic_istream</b>&lt; _CharT, _Traits &gt; &amp;__is, <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
           &amp;__str)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; <b>std::basic_istream</b>&lt; _CharT, _Traits &gt;
           &amp; <b>getline</b> (<b>std::basic_istream</b>&lt; _CharT, _Traits &gt; &amp;__is, <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
           &amp;__str, _CharT __delim)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator!=</b> (const _CharT *__lhs,
           const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator!=</b> (const <b>basic_string</b>&lt;
           _CharT, _Traits, _Allocator &gt; &amp;__lhs, const _CharT *__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator!=</b> (const <b>basic_string</b>&lt;
           _CharT, _Traits, _Allocator &gt; &amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
           _Allocator &gt; <b>operator+</b> (_CharT __lhs, const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
           _Allocator &gt; <b>operator+</b> (const _CharT *__lhs, const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
           &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
           _Allocator &gt; <b>operator+</b> (const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__lhs, _CharT __rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
           _Allocator &gt; <b>operator+</b> (const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__lhs, const _CharT
           *__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
           _Allocator &gt; <b>operator+</b> (const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__lhs, const <b>basic_string</b>&lt;
           _CharT, _Traits, _Allocator &gt; &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator&lt;</b> (const _CharT *__lhs,
           const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator&lt;</b> (const <b>basic_string</b>&lt;
           _CharT, _Traits, _Allocator &gt; &amp;__lhs, const _CharT *__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator&lt;</b> (const <b>basic_string</b>&lt;
           _CharT, _Traits, _Allocator &gt; &amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; <b>std::basic_ostream</b>&lt; _CharT, _Traits &gt;
           &amp; <b>operator&lt;&lt;</b> (<b>std::basic_ostream</b>&lt; _CharT, _Traits &gt; &amp;__os, const <b>basic_string</b>&lt; _CharT, _Traits,
           _Allocator &gt; &amp;__str)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator&lt;=</b> (const _CharT *__lhs,
           const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator&lt;=</b> (const <b>basic_string</b>&lt;
           _CharT, _Traits, _Allocator &gt; &amp;__lhs, const _CharT *__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator&lt;=</b> (const <b>basic_string</b>&lt;
           _CharT, _Traits, _Allocator &gt; &amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator==</b> (const _CharT *__lhs,
           const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator==</b> (const <b>basic_string</b>&lt;
           _CharT, _Traits, _Allocator &gt; &amp;__lhs, const _CharT *__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator==</b> (const <b>basic_string</b>&lt;
           _CharT, _Traits, _Allocator &gt; &amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator&gt;</b> (const _CharT *__lhs,
           const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator&gt;</b> (const <b>basic_string</b>&lt;
           _CharT, _Traits, _Allocator &gt; &amp;__lhs, const _CharT *__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator&gt;</b> (const <b>basic_string</b>&lt;
           _CharT, _Traits, _Allocator &gt; &amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator&gt;=</b> (const _CharT *__lhs,
           const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator&gt;=</b> (const <b>basic_string</b>&lt;
           _CharT, _Traits, _Allocator &gt; &amp;__lhs, const _CharT *__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; bool <b>operator&gt;=</b> (const <b>basic_string</b>&lt;
           _CharT, _Traits, _Allocator &gt; &amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__rhs)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; <b>std::basic_istream</b>&lt; _CharT, _Traits &gt;
           &amp; <b>operator&gt;&gt;</b> (<b>std::basic_istream</b>&lt; _CharT, _Traits &gt; &amp;__is, <b>basic_string</b>&lt; _CharT, _Traits, _Allocator
           &gt; &amp;__str)
       template&lt;typename _CharT , typename _Traits , typename _Allocator &gt; void <b>swap</b> (<b>basic_string</b>&lt; _CharT,
           _Traits, _Allocator &gt; &amp;__lhs, <b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt; &amp;__rhs)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       GNU debug classes for public use.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>basic_string&lt;char16_t&gt;</b> <b>__gnu_debug::u16string</b>
       A string of char16_t.

   <b>typedef</b> <b>basic_string&lt;char32_t&gt;</b> <b>__gnu_debug::u32string</b>
       A string of char32_t.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>__gnu_debug::_Distance_precision</b>
       The precision to which we can calculate the distance between two iterators.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Iterator</b> <b>&gt;</b> <b>constexpr</b> <b>_Iterator</b> <b>__gnu_debug::__base</b> <b>(_Iterator</b> <b>__it)</b> <b>[inline],</b>  <b>[constexpr]</b>

       Helper function to extract base iterator of random access safe iterator in order to reduce performance
       impact of debug mode. Limited to random access iterator because it is the only category for which it is
       possible to check for correct iterators order in the __valid_range function thanks to the &lt; operator.

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b>
       <b>&gt;::_M_before_dereferenceable()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>constexpr</b> <b>bool</b> <b>__gnu_debug::__check_singular</b> <b>(_Tp</b> <b>*const</b> <b>&amp;</b> <b>__ptr)</b> <b>[inline],</b>
       <b>[constexpr]</b>
       Non-NULL pointers are nonsingular.

   <b>bool</b> <b>__gnu_debug::__check_singular_aux</b> <b>(const</b> <b>_Safe_iterator_base</b> <b>*</b> <b>__x)</b> <b>[inline]</b>
       Iterators that derive from _Safe_iterator_base can be determined singular or non-singular.

       References <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Integer</b> <b>&gt;</b> <b>const</b> <b>_CharT</b> <b>*</b> <b>__gnu_debug::__check_string</b> <b>(const</b> <b>_CharT</b> <b>*</b>
       <b>__s,</b> <b>_Integer</b> <b>__n,</b> <b>const</b> <b>char</b> <b>*</b> <b>__file,</b> <b>unsigned</b> <b>int</b> <b>__line,</b> <b>const</b> <b>char</b> <b>*</b> <b>__function)</b> <b>[inline]</b>
       Checks that __s is non-NULL or __n == 0, and then returns __s.

   <b>template&lt;typename</b> <b>_CharT</b> <b>&gt;</b> <b>const</b> <b>_CharT</b> <b>*</b> <b>__gnu_debug::__check_string</b> <b>(const</b> <b>_CharT</b> <b>*</b> <b>__s,</b> <b>const</b> <b>char</b> <b>*</b>
       <b>__file,</b> <b>unsigned</b> <b>int</b> <b>__line,</b> <b>const</b> <b>char</b> <b>*</b> <b>__function)</b> <b>[inline]</b>
       Checks that __s is non-NULL and then returns __s.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b> <b>,</b> <b>typename</b> <b>_OtherIterator</b> <b>,</b> <b>typename</b>
       <b>_OtherSequence</b> <b>,</b> <b>typename</b> <b>_OtherCategory</b> <b>&gt;</b> <b>bool</b> <b>__gnu_debug::__foreign_iterator_aux2</b> <b>(const</b>
       <b>_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;</b> <b>&amp;,</b> <b>const</b> <b>_Safe_iterator&lt;</b> <b>_OtherIterator,</b>
       <b>_OtherSequence,</b> <b>_OtherCategory</b> <b>&gt;</b> <b>&amp;,</b> <b>const</b> <b>_Safe_iterator&lt;</b> <b>_OtherIterator,</b> <b>_OtherSequence,</b> <b>_OtherCategory</b>
       <b>&gt;</b> <b>&amp;)</b> <b>[inline]</b>
       Handle debug iterators from different types of container.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b> <b>,</b> <b>typename</b> <b>_OtherIterator</b> <b>&gt;</b> <b>bool</b>
       <b>__gnu_debug::__foreign_iterator_aux2</b> <b>(const</b> <b>_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;</b> <b>&amp;</b> <b>__it,</b>
       <b>const</b> <b>_Safe_iterator&lt;</b> <b>_OtherIterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;</b> <b>&amp;</b> <b>__other,</b> <b>const</b> <b>_Safe_iterator&lt;</b>
       <b>_OtherIterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;</b> <b>&amp;)</b> <b>[inline]</b>
       Handle debug iterators from the same type of container.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>&gt;</b> <b>constexpr</b> <b>_Distance_traits&lt;</b> <b>_Iterator</b> <b>&gt;::__type</b> <b>__gnu_debug::__get_distance</b>
       <b>(_Iterator</b> <b>__lhs,</b> <b>_Iterator</b> <b>__rhs,</b> <b>std::random_access_iterator_tag)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Determine the distance between two iterators with some known precision.

   <b>template&lt;typename</b> <b>_InputIterator</b> <b>&gt;</b> <b>constexpr</b> <b>bool</b> <b>__gnu_debug::__valid_range</b> <b>(_InputIterator</b> <b>__first,</b>
       <b>_InputIterator</b> <b>__last,</b> <b>typename</b> <b>_Distance_traits&lt;</b> <b>_InputIterator</b> <b>&gt;::__type</b> <b>&amp;</b> <b>__dist)</b> <b>[inline],</b>
       <b>[constexpr]</b>
       Don't know what these iterators are, or if they are even iterators (we may get an integral type for
       InputIterator), so see if they are integral and pass them on to the next phase otherwise.

       References <b>__valid_range_aux()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b> <b>&gt;</b> <b>bool</b> <b>__gnu_debug::__valid_range</b>
       <b>(const</b> <b>_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;</b> <b>&amp;</b> <b>__first,</b> <b>const</b> <b>_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;</b> <b>&amp;</b> <b>__last,</b> <b>typename</b> <b>_Distance_traits&lt;</b> <b>_Iterator</b> <b>&gt;::__type</b> <b>&amp;</b> <b>__dist)</b> <b>[inline]</b>
       Safe iterators know how to check if they form a valid range.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>bool</b> <b>__gnu_debug::__valid_range</b> <b>(const</b>
       <b>_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;</b> <b>&amp;</b> <b>__first,</b> <b>const</b> <b>_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;</b> <b>&amp;</b> <b>__last,</b> <b>typename</b> <b>_Distance_traits&lt;</b> <b>_Iterator</b> <b>&gt;::__type</b> <b>&amp;</b> <b>__dist_info)</b> <b>[inline]</b>
       Safe local iterators know how to check if they form a valid range.

   <b>template&lt;typename</b> <b>_InputIterator</b> <b>&gt;</b> <b>constexpr</b> <b>bool</b> <b>__gnu_debug::__valid_range_aux</b> <b>(_InputIterator</b> <b>__first,</b>
       <b>_InputIterator</b> <b>__last,</b> <b>std::__false_type)</b> <b>[inline],</b>  <b>[constexpr]</b>
       We have iterators, so figure out what kind of iterators they are to see if we can check the range ahead
       of time.

       References <b>std::__iterator_category()</b>, and <b>__valid_range_aux()</b>.

   <b>template&lt;typename</b> <b>_Integral</b> <b>&gt;</b> <b>constexpr</b> <b>bool</b> <b>__gnu_debug::__valid_range_aux</b> <b>(_Integral,</b> <b>_Integral,</b>
       <b>std::__true_type)</b> <b>[inline],</b>  <b>[constexpr]</b>
       We say that integral types for a valid range, and defer to other routines to realize what to do with
       integral types instead of iterators.

       Referenced by <b>__valid_range()</b>, and <b>__valid_range_aux()</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++                                  <b>__</b><u><a href="../man3cxx/gnu_debug.3cxx.html">gnu_debug</a></u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>