<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::move_iterator< _Iterator ></title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::move_iterator&lt; _Iterator &gt;

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;iterator&gt;

       Inherits std::__detail::__move_iter_cat&lt; _Iterator &gt;.

   <b>Public</b> <b>Types</b>
       <b>using</b> <b>difference_type</b> = iter_difference_t&lt; _Iterator &gt;
       <b>using</b> <b>iterator_concept</b> = <b>decltype</b>(_S_iter_concept())
       <b>using</b> <b>iterator_type</b> = _Iterator
       <b>using</b> <b>pointer</b> = _Iterator
       <b>using</b> <b>reference</b> = <b>iter_rvalue_reference_t</b>&lt; _Iterator &gt;
       <b>using</b> <b>value_type</b> = iter_value_t&lt; _Iterator &gt;

   <b>Public</b> <b>Member</b> <b>Functions</b>
       template&lt;<b>typename</b> _Iter &gt;
           requires __convertible&lt;_Iter&gt;constexpr <b>move_iterator</b> (const <b>move_iterator</b>&lt; _Iter &gt; &amp;__i)"
       constexpr <b>move_iterator</b> (iterator_type __i)
       constexpr iterator_type <b>base</b> () &amp;&amp;
       constexpr const iterator_type &amp; <b>base</b> () const &amp;noexcept
       constexpr <b>reference</b> <b>operator*</b> () const
       constexpr <b>move_iterator</b> <b>operator+</b> (<b>difference_type</b> __n) const
       constexpr <b>move_iterator</b> &amp; <b>operator++</b> ()
       constexpr <b>move_iterator</b> <b>operator++</b> (int)
       constexpr <b>void</b> <b>operator++</b> (int)
       constexpr <b>move_iterator</b> &amp; <b>operator+=</b> (<b>difference_type</b> __n)
       constexpr <b>move_iterator</b> <b>operator-</b> (<b>difference_type</b> __n) const
       constexpr <b>move_iterator</b> &amp; <b>operator--</b> ()
       constexpr <b>move_iterator</b> <b>operator--</b> (int)
       constexpr <b>move_iterator</b> &amp; <b>operator-=</b> (<b>difference_type</b> __n)
       constexpr pointer <b>operator-&gt;</b> () const
       template&lt;<b>typename</b> _Iter &gt;
           requires __convertible&lt;_Iter&gt; &amp;&amp; assignable_from&lt;_Iterator&amp;, const _Iter&amp;&gt;constexpr <b>move_iterator</b> &amp;
           <b>operator=</b> (const <b>move_iterator</b>&lt; _Iter &gt; &amp;__i)"
       constexpr <b>reference</b> <b>operator[]</b> (<b>difference_type</b> __n) const

   <b>Friends</b>
       constexpr <b>iter_rvalue_reference_t</b>&lt; _Iterator &gt; <b>iter_move</b> (const <b>move_iterator</b> &amp;__i)
           noexcept(noexcept(ranges::iter_move(__i._M_current)))
       template&lt;indirectly_swappable&lt; _Iterator &gt; _Iter2&gt; constexpr <b>void</b> <b>iter_swap</b> (const <b>move_iterator</b> &amp;__x,
           const <b>move_iterator</b>&lt; _Iter2 &gt; &amp;__y) noexcept(noexcept(ranges::iter_swap(__x._M_current,
           __y._M_current)))
       template&lt;sized_sentinel_for&lt; _Iterator &gt; _Sent&gt; constexpr iter_difference_t&lt; _Iterator &gt; <b>operator-</b> (const
           <b>move_iterator</b> &amp;__x, const move_sentinel&lt; _Sent &gt; &amp;__y)
       template&lt;sized_sentinel_for&lt; _Iterator &gt; _Sent&gt; constexpr iter_difference_t&lt; _Iterator &gt; <b>operator-</b> (const
           move_sentinel&lt; _Sent &gt; &amp;__x, const <b>move_iterator</b> &amp;__y)
       template&lt;sentinel_for&lt; _Iterator &gt; _Sent&gt; constexpr bool <b>operator==</b> (const <b>move_iterator</b> &amp;__x, const
           move_sentinel&lt; _Sent &gt; &amp;__y)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_Iterator&gt;</b>
       class std::move_iterator&lt; _Iterator &gt;"Class template move_iterator is an iterator adapter with the same
       behavior as the underlying iterator except that its dereference operator implicitly converts the value
       returned by the underlying iterator's dereference operator to an rvalue reference. Some generic
       algorithms can be called with move iterators to replace copying with moving.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++              <u>std::move_iterator&lt;</u> <b>_</b><u>Iterator</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>