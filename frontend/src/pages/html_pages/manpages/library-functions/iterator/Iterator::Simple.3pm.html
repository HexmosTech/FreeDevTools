<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Iterator::Simple - Simple iterator and utilities</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libiterator-simple-perl">libiterator-simple-perl_0.07-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Iterator::Simple - Simple iterator and utilities

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Iterator::Simple;

         sub foo {
           my $max = shift;
           my $i = 0;
           iterator {
             return if $i &gt; $max;
             $i++;
           }
         }

         my $iterator = <a href="../man20/foo.20.html">foo</a>(20); # yields 0,1,2, ..., 19, 20;
         $iterator = imap { $_ + 2 } $iterator; # yields 2,3,4,5, ... ,20,21,22
         $iterator = igrep { $_ % 2 } $iterator; # yields 3,5,7,9, ... ,17,19,21

         # iterable object
         $iterator = iter([qw(foo bar baz)]); # iterator from array ref
         $iterator = iter(IO::File-&gt;new($filename)); # iterator from GLOB

         # filters
         $iterator = ichain($itr1, $itr2); # chain iterators;
         $iterator = izip($itr1, $itr2); # zip iterators;
         $iterator = ienumerate $iterator; # add index;

         # general filter
         $iterator = ifilter $iterator, sub {
           return $_ if /^A/;
           return;
         }

         # how to iterate
         while(defined($_ = $iterator-&gt;())) {
           print;
         }

         while(defined($_ = $iterator-&gt;next)) {
           print;
         }

         while(&lt;iterator&gt;) {
           print;
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Iterator::Simple is yet another general-purpose iterator utilities.

       Rather simple, but powerful and fast iterator.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       Iterator::Simple doesn't export any functions by default. please import them like:

         use Iterator::Simple qw(iter list imap);

       For all functions:

         use Iterator::Simple qw(:all);

       iterator { CODE }
           Iterator  constructor.  CODE  returns  a  value  on each call, and if it is exhausted, returns undef.
           Therefore, you cannot yields undefined value as a meaning value. If you want, you could use  Iterator
           module which can do that.

           Generally, you can implement iterator as a closure like:

             use Iterator::Simple qw(iterator);

             sub fibonacci {
               my($s1, $s2, $max) = @_;

               iterator {
                 my $rv;
                 ($rv, $s1, $s2) = ($s1, $s2, $s1 + $s2);
                 return if $rv &gt; $max;
                 return $rv;
               }
             }

             my $iterator = fiboacci(1, 1, 1000);

           You can iterate it in several ways:

           • just call it

               while(defined($_ = $iterator-&gt;())) {
                 print "$_\n";
               }

           • "next" method

               while(defined($_ = $iterator-&gt;next)) {
                 print "$_\n";
               }

           • &lt;&gt; operator

               while(&lt;$iterator&gt;) {
                 print "$_\n";
               }

       is_iterator($object)
           If $object is an iterator created by Iterator::Simple, returns true.  False otherwise.

       iter($object)
           This  function  auto  detects what $object is, and automatically turns it into an iterator. Supported
           objects are:

           • Iterator made with Iterator::Simple.

           • Object that implements "__iter__" method.

           • Object that overloads '&lt;&gt;' or has "next" method.

           • Object that overloads '&amp;{}'.(as iterator function.)

           • Object that overloads '@{}'.(with "iarray()")

           • ARRAY reference. ("iarray()")

           • CODE reference. (as iterator function.)

           • GLOB reference.

           • nothing ("iter()".) (empty iterator.)

           If it fails to convert, runtime error.

       is_iterable($object)
           return true if $object can be converted with "iter($object)"

       list($object)
           This function converts $object into single array referece.

           • ARRAY reference.

           • GLOB reference.

           • Iterator made with Iterator::Simple.

           • Object that overloads '@{}' operator.

           • Object that implements '__iter__' method.

           • Object that overloads '&lt;&gt;' operator or has "next" method.

           • nothing (i.e. <b>list()</b> returns []);

           If it fails to convert, runtime error.

           Note that after "list($iterator)", that iterator is not usable any more.

       imap { CODE } $iterable
           This is the iterator version of "map". Returns  an  iterator  which  yields  the  value  from  source
           iterator modified by CODE.

       igrep { CODE } $iterable
           This  is  the  iterator  version  of  "grep".  Returns an iterator which yields the value from source
           iterator only when CODE returns true value.

       iflatten $iterable
           When $iterable yields another iterator, iterate it first.

             $subitr = iter([10, 11,12]);
             $source = iter([ 1, 2, $subitr, 4]);

             $flattened = iflatten $source;

             # yields 1, 2, 10, 11, 12, 4.

       ifilter $iterable, sub{ CODE }
           This is the combination of imap, igrep, iflatten. it supports  modify  (imap)  ,  skip  (igrep),  and
           inflate (iflatten). but it should be faster than combination of them.

           For example:

             $combination = iflatten
               imap { $_ eq 'baz' ? iter(['whoa', 'who']) : ":$_:" }
               igrep { $_ ne 'bar' }
               iter [ 'foo', 'bar', 'baz', 'fiz' ];

             $itr = iter [ 'foo', 'bar', 'baz', 'fiz' ];
             $filterd = ifilter $itr, sub {
               return if $_ eq 'bar'; #skip
               return iter(['whoa', 'who']) if $_ eq 'baz'; #inflate
               return ":$_:"; # modify
             };

           Both of them will yields ':foo:', 'whoa', 'who', ':fiz:'.

       ichain($iterable, $iterable2, ...)
           This  function  returns  an  iterator which chains one or more iterators.  Iterates each iterables in
           order as is, until each iterables are exhausted.

           Example:

             $itr1 = iter(['foo', 'bar', 'baz']);
             $itr2 = iter(['hoge', 'hage']);

             $chained = ichain($itr1, $itr2);

             # yields 'foo', 'bar', 'baz', 'hoge', 'hage'.

       ienumerate($iterable)
           This function returns an iterator yields like:

             $ary = iter(['foo', 'bar', 'baz', ... ]);

             $iter = ienumerate $ary;

             # yields [0, 'foo'], [1, 'bar'], [2, 'baz'], ...

       izip($iterable, $iterable2, ...);
           Accepts one or more iterables, returns an iterator like:

             $animals = iter(['dogs', 'cats', 'pigs']);
             $says = iter(['bowwow', 'mew', 'oink']);

             $zipped = izip($animals, $says);

             # yields ['dogs','bowwow'], ['cats','mew'], ['pigs', 'oink'].

           Note that when one of source iterables is exhausted, zipped iterator will be exhausted also.

       islice($iterable, $start, $end, $step)
           Same as islice of itertools in Python. If $end is undef or negative value, it iterates  source  until
           it is exhausted.  $step defaults to 1. 0 or negative step value is prohibited.

             $iter = iter([0,1,2,3,4,5,6,7,8,9,10,11,12]);

             $sliced = islice($iter, 3, 13, 2);

             # yields 3, 5, 7, 9, 11.

       ihead($count, $iterable)
             islice($iterable, 0, $count, 1);

       iskip($count, $iterable)
             islice($iterable, $count, undef, 1);

       iarray($arrayref);
           Turns  array  reference  into  an  iterator.  Used in "iter($arrayref)".  You do not have to use this
           function directly, because "iter($arrayref)" is sufficient.

</pre><h4><b>OO</b> <b>INTERFACE</b></h4><pre>
       Iterator used in Iterator::Simple is just a code reference blessed  in  Iterator::Simple::Iterator.  This
       class implements several method and overloads some operators.

       Itrator::Simple::Iterator-&gt;new($coderef)
           Just bless $coderef in Iterator::Simple::Iterator and returns it.

       $iterator-&gt;next
           Call underlying code.

       $iterator-&gt;__iter__
           Returns self. You don't need to use this.

       Overloaded operators.
           • Read filehandle operator '&lt;&gt;'

             Overloading '&lt;&gt;' makes this possible like:

               print while &lt;$iterator&gt;;

           • Pipe.. bit_OR? .. No, pipe!

               $iterator | $coderef1 | $coderef2;

             is equivalent to:

               $iterator-&gt;filter($coderef1)-&gt;filter($coderef2);

             is equivalent to:

               ifilter(ifilter($iterator, $coderef1), $coderef2);

       $iterator-&gt;filter($coderef)
       $iterator-&gt;<b>flatten()</b>
       $iterator-&gt;chain($another, ..)
       $iterator-&gt;zip($another, ..)
       $iterator-&gt;<b>enumerate()</b>
       $iterator-&gt;slice($start, $end, $step)
       $iterator-&gt;head($count)
       $iterator-&gt;skip($count)
           For example, $iterator-&gt;<b>flatten()</b> is equivalent to "iflatten $iterator".

</pre><h4><b>TIPS</b></h4><pre>
       All  iterator transformation function calls "iter" function on all source iterables. So you can pass just
       array reference, GLOB ref, etc.

       These examples completely do the right thing:

         imap { $_ + 2 } [1, 2, 3, ... ];
         ienumerate(\*STDIN);

         # DBIx::Class::ResultSet has 'next' method.
         ifilter $dbic_resultset, sub {CODE};

       You can implement "__iter__" method on your objects in your application.  By doing that, your object will
       be Iterator::Simple friendly :).

       Note that "__iter__" method must return an iterator.

</pre><h4><b>Why</b> <b>Not</b> <b>Iterator.pm</b></h4><pre>
       There is another iterator module in CPAN, named Iterator and Iterator::Util made by Eric J. Roode that is
       great solution.  Why yet another iterator module? The answer is *Speed*. You  use  iterator  because  you
       have  too many data to manipulate in memory, therefore iterator could be called thousands of times, speed
       is important.

       For this simple example:

         use Iterator::Util qw(iarray imap igrep);

         for(1 .. 100) {
           my $itr = igrep { $_ % 2 } imap { $_ + 2 } iarray([1 .. 1000]);
           my @result;
           while($itr-&gt;isnt_exhausted) {
             push @result, $itr-&gt;value;
           }
         }

       meanwhile:

         use Iterator::Simple qw(iarray imap igrep);

         for(1 .. 100) {
           my $itr = igrep { $_ % 2 } imap { $_ + 2 } iarray([1 .. 1000]);
           my @result;
           while(defined($_ = $itr-&gt;())) {
             push @result, $_;
           }
         }

       Iterator::Simple is about ten times faster!

       That is natural because Iterator::Simple iterator is just a code reference, while Iterator.pm iterator is
       full featured class instance.  But Iterator::Simple is sufficient for usual demands.

       One of most downside of Iterator::Simple is, you cannot yields undef value as a  meaning  value,  because
       Iterator::Simple  thinks  it  as  a  exhausted sign.  If you need to do that, you have to yield something
       which represents undef value.

       Also, Iterator::Simple cannot determine iterator is exhausted until next iteration, while Iterator.pm has
       'is(nt)_exhausted' method which is useful in some situation.

</pre><h4><b>AUTHOR</b></h4><pre>
       Rintaro Ishizaki &lt;<a href="mailto:rintaro@cpan.org">rintaro@cpan.org</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       • Iterator - Feature rich another iterator class.

       • Iterator::Util - Utilities which uses Iterator. Many of filter functions are from this module.

perl v5.36.0                                       2022-10-16                              <u>Iterator::<a href="../man3pm/Simple.3pm.html">Simple</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>