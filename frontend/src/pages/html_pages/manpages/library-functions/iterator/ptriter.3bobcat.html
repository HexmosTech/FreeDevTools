<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::PtrIter - Iterator returning pointer when dereferenced</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::PtrIter - Iterator returning pointer when dereferenced

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/ptriter&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>PtrIter</u>  class  template  implements  an  input  iterator whose <u>operator*</u> returns the address of the
       element the iterator refers to.  Consider a <u>std::unordered_map&lt;std::string,</u> <u>DataType&gt;</u>. Its  <u>begin</u>  member
       returns an iterator whose <u>operator*</u> returns a <u>std::pair&lt;std::string,</u> <u>DataType&gt;</u> <u>(const)</u> <u>&amp;</u>. This is usually
       what  you  want,  but  now  assume  we want to display the map’s content, sorted by its keys. Sorting can
       simply be performed by defining a support vector containing pointers to the elements in the map, and then
       sorting the strings the pointers point at.

       <u>PtrIter</u> is a tool that can be used to construct such a support vector, as shown in the <b>EXAMPLE</b> section.

       <u>PtrIter</u> is a class template requiring one template type parameter: <u>Iterator</u>, the iterator’s  type  (e.g.,
       <u>vector&lt;string&gt;::iterator</u>)

       <u>PtrIter</u>’s  users  don’t  have  to  specify  <u>PtrIter</u>’s  template type. The function template <u>ptrIter</u>, when
       provided with an iterator returns the matching <u>PtrIter</u> object.

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All constructors, members, operators and manipulators, mentioned in this man-page,  are  defined  in  the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       <u>std::iterator&lt;std::input_iterator_tag,</u> <u>...&gt;</u>

</pre><h4><b>FREE</b> <b>FUNCTION</b></h4><pre>
       o      <b>PtrIter&lt;Iterator&gt;</b> <b>ptrIter(Iterator</b> <b>const</b> <b>&amp;iter)</b>:
              this  function  template  returns  a  <u>PtrIter</u>  object  for  the function’s <u>Iterator</u> argument. This
              function template simplyfies the construction of a <u>PtrIter</u> as no template parameters  need  to  be
              specified (see also the <b>EXAMPLE</b> section)

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
       o      <b>PtrIter(Iterator</b> <b>const</b> <b>&amp;iter)</b>:
              The  <u>iter</u>  parameter  must  be  initialized  with  an existing input iterator, offering <u>operator*,</u>
              <u>operator++,</u> <u>operator==</u> and <u>operator!=</u>.   As  <u>PtrIter</u>  is  a  class  template,  its  template  type
              parameters must be specified when defining a <u>PtrIter</u> object. E.g.,

                  PtrIter&lt;set&lt;string&gt;::iterator&gt; PtrIter(mySet.begin());

       Copy and move constructors (and assignment operators) are available.

</pre><h4><b>OVERLOADED</b> <b>OPERATORS</b></h4><pre>
       o      <b>PtrType</b> <b>operator*()</b> <b>const</b>:
              the address of the entity the iterator refers to is returned;

       o      <b>PtrIter</b> <b>&amp;operator++()</b>:
              the iterator is (pre)incremented to the next position;

       o      <b>bool</b> <b>operator==(PtrIter</b> <b>const</b> <b>&amp;other)</b> <b>const</b>:
              <u>true</u> is returned if the two iterators are equal;

       o      <b>bool</b> <b>operator!=(PtrIter</b> <b>const</b> <b>&amp;other)</b> <b>const</b>:
              <u>true</u> is returned if the two iterators are unequal;

</pre><h4><b>USING</b> <b>DECLARATION</b></h4><pre>
       The <u>PtrIter</u> class template defines <u>PtrType</u>:

       o      <b>using</b> <b>PtrType</b> <b>=</b> <b>decltype(&amp;*Iterator())</b>:

</pre><h4><b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       All  members of <u>std::iterator&lt;std:::input_iterator_tag,</u> <u>...&gt;</u> are available, as <b>FBB::PtrIter</b> inherits from
       this class.

</pre><h4><b>EXAMPLE</b></h4><pre>
       #include &lt;algorithm&gt;
       #include &lt;unordered_map&gt;
       #include &lt;vector&gt;
       #include &lt;cstring&gt;
       #include &lt;iostream&gt;

       #include &lt;bobcat/ptriter&gt;

       using namespace std;
       using namespace FBB;

       int main()
       {
           cout &lt;&lt; "Enter lines, the first word will be the map’s key; "
                                                   "^D when done.\n";

           string key;
           string line;
           unordered_map&lt;string, string&gt; map;
           while (cin &gt;&gt; key &amp;&amp; getline(cin, line))    // fill the map
               map[key] = line;
           cout &lt;&lt; ’\n’;

                                               // initialize a support
           vector&lt;decltype(&amp;*map.begin())&gt;     // vector, using ptrIter
               support(ptrIter(map.begin()), ptrIter(map.end()));

                                               // sort ’support’
           typedef unordered_map&lt;string, string&gt;::value_type VT;
           sort(support.begin(), support.end(),
               [&amp;](VT const *p1, VT const *p2)
               {
                   return strcasecmp(p1-&gt;first.c_str(), p2-&gt;first.c_str()) &lt; 0;
               }
           );

           for(auto &amp;element: support)         // display sorted by key
               cout &lt;&lt; element-&gt;first &lt;&lt; ’ ’ &lt;&lt; element-&gt;second &lt;&lt; ’\n’;
       }

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/ptriter</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7)

</pre><h4><b>BUGS</b></h4><pre>
       None Reported.

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>: debian package containing the static library, headers, manual pages, and  developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                              <u>FBB::<a href="../man3bobcat/PtrIter.3bobcat.html">PtrIter</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>