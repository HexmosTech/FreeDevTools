<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File::Next - File-finding iterator</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfile-next-perl">libfile-next-perl_1.18-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       File::Next - File-finding iterator

</pre><h4><b>VERSION</b></h4><pre>
       Version 1.18

</pre><h4><b>SYNOPSIS</b></h4><pre>
       File::Next is a lightweight, taint-safe file-finding module.  It has no non-core prerequisites.

           use File::Next;

           my $files = File::Next::files( '<a href="file:/tmp">/tmp</a>' );

           while ( defined ( my $file = $files-&gt;() ) ) {
               # do something...
           }

</pre><h4><b>OPERATIONAL</b> <b>THEORY</b></h4><pre>
       The two major functions, <u><b>files()</b></u> and <u><b>dirs()</b></u>, return an iterator that will walk through a directory tree.
       The simplest use case is:

           use File::Next;

           my $iter = File::Next::files( '<a href="file:/tmp">/tmp</a>' );

           while ( defined ( my $file = $iter-&gt;() ) ) {
               print $file, "\n";
           }

           # Prints...
           /tmp/foo.txt
           /tmp/bar.pl
           /tmp/baz/1
           /tmp/baz/2.txt
           /tmp/baz/wango/tango/purple.txt

       Note that only files are returned by files()'s iterator.  Directories are ignored.

       In list context, the iterator returns a list containing <u>$dir</u>, <u>$file</u> and <u>$fullpath</u>, where <u>$fullpath</u> is
       what would get returned in scalar context.

       The first parameter to any of the iterator factory functions may be a hashref of options.

</pre><h4><b>ITERATORS</b></h4><pre>
       For the three iterators, the \%options are optional.

   <b>files(</b> <b>[</b> <b>\%options,</b> <b>]</b> <b>@starting_points</b> <b>)</b>
       Returns an iterator that walks directories starting with the items in <u>@starting_points</u>.  Each call to the
       iterator returns another regular file.

   <b>dirs(</b> <b>[</b> <b>\%options,</b> <b>]</b> <b>@starting_points</b> <b>)</b>
       Returns an iterator that walks directories starting with the items in <u>@starting_points</u>.  Each call to the
       iterator returns another directory.

   <b>everything(</b> <b>[</b> <b>\%options,</b> <b>]</b> <b>@starting_points</b> <b>)</b>
       Returns an iterator that walks directories starting with the items in <u>@starting_points</u>.  Each call to the
       iterator returns another file, whether it's a regular file, directory, symlink, socket, or whatever.

   <b>from_file(</b> <b>[</b> <b>\%options,</b> <b>]</b> <b>$filename</b> <b>)</b>
       Returns an iterator that iterates over each of the files specified in <u>$filename</u>.  If <u>$filename</u> is "-",
       then the files are read from STDIN.

       The files are assumed to be in the file one filename per line.  If <u>$nul_separated</u> is passed, then the
       files are assumed to be NUL-separated, as by "find -print0".

       If there are blank lines or empty filenames in the input stream, they are ignored.

       Each filename is checked to see that it is a regular file or a named pipe.  If the file does not exists
       or is a directory, then a warning is thrown to <u>warning_handler</u>, and the file is skipped.

       The following options have no effect in "from_files": <u>descend_filter</u>, <u>sort_files</u>, <u>follow_symlinks</u>.

</pre><h4><b>SUPPORT</b> <b>FUNCTIONS</b></h4><pre>
   <b>sort_standard(</b> <b>$a,</b> <b>$b</b> <b>)</b>
       A sort function for passing as a "sort_files" option:

           my $iter = File::Next::files( {
               sort_files =&gt; \&amp;File::Next::sort_standard,
           }, 't/swamp' );

       This function is the default, so the code above is identical to:

           my $iter = File::Next::files( {
               sort_files =&gt; 1,
           }, 't/swamp' );

   <b>sort_reverse(</b> <b>$a,</b> <b>$b</b> <b>)</b>
       Same as "sort_standard", but in reverse.

   <b>reslash(</b> <b>$path</b> <b>)</b>
       Takes a path with all forward slashes and rebuilds it with whatever is appropriate for the platform.  For
       example 'foo/bar/bat' will become 'foo\bar\bat' on Windows.

       This is really just a convenience function.  I'd make it private, but <u>ack</u> wants it, too.

</pre><h4><b>CONSTRUCTOR</b> <b>PARAMETERS</b></h4><pre>
   <b>file_filter</b> <b>-&gt;</b> <b>\&amp;file_filter</b>
       The file_filter lets you check to see if it's really a file you want to get back.  If the file_filter
       returns a true value, the file will be returned; if false, it will be skipped.

       The file_filter function takes no arguments but rather does its work through a collection of variables.

       •   $_ is the current filename within that directory

       •   $File::Next::dir is the current directory name

       •   $File::Next::name is the complete pathname to the file

       These are analogous to the same variables in File::Find.

           my $iter = File::Next::files( { file_filter =&gt; sub { /\.txt$/ } }, '<a href="file:/tmp">/tmp</a>' );

       By default, the <u>file_filter</u> is "sub {1}", or "all files".

       This filter has no effect if your iterator is only returning directories.

   <b>descend_filter</b> <b>=&gt;</b> <b>\&amp;descend_filter</b>
       The  descend_filter  lets  you check to see if the iterator should descend into a given directory.  Maybe
       you want to skip <u>CVS</u> and <u>.svn</u> directories.

           my $descend_filter = sub { $_ ne "CVS" &amp;&amp; $_ ne ".svn" }

       The descend_filter function takes no  arguments  but  rather  does  its  work  through  a  collection  of
       variables.

       •   $_ is the current filename of the directory

       •   $File::Next::dir is the complete directory name

       The  descend  filter  is  NOT  applied  to  any  directory  names  specified  as  <u>@starting_points</u> in the
       constructor.  For example,

           my $iter = File::Next::files( { descend_filter =&gt; sub{0} }, '<a href="file:/tmp">/tmp</a>' );

       always descends into <u><a href="file:/tmp">/tmp</a></u>, as you would expect.

       By default, the <u>descend_filter</u> is "sub {1}", or "always descend".

   <b>error_handler</b> <b>=&gt;</b> <b>\&amp;error_handler</b>
       If <u>error_handler</u> is set, then any errors will be sent through it.  If the error is OS-related  (ex.  file
       not  found,  not  permissions),  the  native error code is passed as a second argument.  By default, this
       value is "CORE::die".  This function must NOT return.

   <b>warning_handler</b> <b>=&gt;</b> <b>\&amp;warning_handler</b>
       If <u>warning_handler</u> is set, then any  errors  will  be  sent  through  it.   By  default,  this  value  is
       "CORE::warn".  Unlike the <u>error_handler</u>, this function must return.

   <b>sort_files</b> <b>=&gt;</b> <b>[</b> <b>0</b> <b>|</b> <b>1</b> <b>|</b> <b>\&amp;sort_sub]</b>
       If you want files sorted, pass in some true value, as in "sort_files =&gt; 1".

       If  you  want a special sort order, pass in a sort function like "sort_files =&gt; sub { $a-&gt;[1] cmp $b-&gt;[1]
       }".  Note that the parms passed in to the sub are arrayrefs, where $a-&gt;[0] is the directory name, $a-&gt;[1]
       is the file name and $a-&gt;[2] is the full path.  Typically you're going to be sorting on $a-&gt;[2].

   <b>follow_symlinks</b> <b>=&gt;</b> <b>[</b> <b>0</b> <b>|</b> <b>1</b> <b>]</b>
       If set to false, the iterator will ignore any files and directories that are actually symlinks.  This has
       no effect on non-Unixy systems such as Windows.  By default, this is true.

       Note that this filter does not apply to any of the <u>@starting_points</u> passed in to the constructor.

       You should not  set  "follow_symlinks  =&gt;  0"  unless  you  specifically  need  that  behavior.   Setting
       "follow_symlinks  =&gt; 0" can be a speed hit, because File::Next must check to see if the file or directory
       you're about to follow is actually a symlink.

   <b>nul_separated</b> <b>=&gt;</b> <b>[</b> <b>0</b> <b>|</b> <b>1</b> <b>]</b>
       Used by the "from_file" iterator.  Specifies that the files listed in the input file are separated by NUL
       characters, as from the "find" command with the "-print0" argument.

</pre><h4><b>PRIVATE</b> <b>FUNCTIONS</b></h4><pre>
   <b>_setup(</b> <b>$default_parms,</b> <b>@whatever_was_passed_to_files()</b> <b>)</b>
       Handles all the scut-work for setting up the parms passed in.

       Returns a hashref of operational options, combined between <u>$passed_parms</u> and <u>$defaults</u>, plus the queue.

       The queue prep stuff takes the strings in <u>@starting_points</u> and puts them in the format that queue needs.

       The @queue that gets passed around is an array, with each entry an arrayref of $dir, $file and $fullpath.

   <b>_candidate_files(</b> <b>$parms,</b> <b>$dir</b> <b>)</b>
       Pulls out the files/dirs that might be worth looking into in <u>$dir</u>.  If <u>$dir</u> is  the  empty  string,  then
       search the current directory.

       <u>$parms</u> is the hashref of parms passed into File::Next constructor.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       "File::Next::files must not be invoked as File::Next-&gt;files"
       "File::Next::dirs must not be invoked as File::Next-&gt;dirs"
       "File::Next::everything must not be invoked as File::Next-&gt;everything"

       The  interface functions do not allow for the method invocation syntax and throw errors with the messages
       above. You can work around this limitation with "can" in UNIVERSAL.

           for my $file_system_feature (qw(dirs files)) {
               my $iterator = File::Next-&gt;can($file_system_feature)-&gt;($options, $target_directory);
               while (defined(my $name = $iterator-&gt;())) {
                   # ...
               }
           }

</pre><h4><b>SPEED</b> <b>TWEAKS</b></h4><pre>
       •   Don't set "follow_symlinks =&gt; 0" unless you need it.

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Lester, "&lt;andy at petdance.com&gt;"

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests to &lt;<a href="http://github.com/petdance/file-next/issues">http://github.com/petdance/file-next/issues</a>&gt;.

       Note that File::Next does NOT use &lt;<a href="http://rt.cpan.org">http://rt.cpan.org</a>&gt; for bug tracking.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc File::Next

       You can also look for information at:

       •   File::Next's bug queue

           &lt;<a href="http://github.com/petdance/file-next/issues">http://github.com/petdance/file-next/issues</a>&gt;

       •   CPAN Ratings

           &lt;<a href="http://cpanratings.perl.org/d/File-Next">http://cpanratings.perl.org/d/File-Next</a>&gt;

       •   Search CPAN

           &lt;<a href="http://search.cpan.org/dist/File-Next">http://search.cpan.org/dist/File-Next</a>&gt;

       •   Source code repository

           &lt;<a href="http://github.com/petdance/file-next/tree/master">http://github.com/petdance/file-next/tree/master</a>&gt;

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       All file-finding in this module is adapted from Mark Jason Dominus' marvelous  <u>Higher</u>  <u>Order</u>  <u>Perl</u>,  page
       126.

       Thanks  to these fine contributors: Varadinsky, Paulo Custodio, Gerhard Poul, Brian Fraser, Todd Rinaldo,
       Bruce Woodward, Christopher J. Madsen, Bernhard Fisseni and Rob Hoelz.

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2005-2017 Andy Lester.

       This program is free software; you can redistribute it and/or modify it under the terms of  the  Artistic
       License version 2.0.

perl v5.40.1                                       2025-05-04                                          <u><a href="../man3pm/Next.3pm.html">Next</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>