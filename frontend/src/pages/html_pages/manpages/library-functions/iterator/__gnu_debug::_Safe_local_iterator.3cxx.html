<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
<b>__</b><u>gnu_debug::_Safe_loc...</u> <b>_</b><u>Iterator,</u> <b>_</b><u>Sequence</u> <u>&gt;</u>(3cxx)    <b>__</b><u>gnu_debug::_Safe_loc...</u> <b>_</b><u>Iterator,</u> <b>_</b><u>Sequence</u> <u>&gt;</u>(3cxx)

</pre><h4><b>NAME</b></h4><pre>
       __gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence &gt; - Safe iterator wrapper.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;safe_local_iterator.h&gt;

       Inherits _Iterator, and <b>__gnu_debug::_Safe_local_iterator_base</b>.

   <b>Public</b> <b>Types</b>
       typedef _Traits::difference_type <b>difference_type</b>
       typedef _Traits::iterator_category <b>iterator_category</b>
       typedef _Iterator <b>iterator_type</b>
       typedef _Traits::pointer <b>pointer</b>
       typedef _Traits::reference <b>reference</b>
       typedef _Traits::value_type <b>value_type</b>

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>_Safe_local_iterator</b> () noexcept
       <b>_Safe_local_iterator</b> (_Iterator __i, const <b>_Safe_sequence_base</b> *__cont)
           Safe iterator construction from an unsafe iterator and its sequence.
       <b>_Safe_local_iterator</b> (<b>_Safe_local_iterator</b> &amp;&amp;__x) noexcept
           Move construction.
       <b>_Safe_local_iterator</b> (const <b>_Safe_local_iterator</b> &amp;__x) noexcept
           Copy construction.
       template&lt;typename _MutableIterator &gt; <b>_Safe_local_iterator</b> (const <b>_Safe_local_iterator</b>&lt; _MutableIterator,
           typename __gnu_cxx::__enable_if&lt; _IsConstant::__value &amp;&amp;std::__are_same&lt; _MutableIterator,
           _OtherIterator &gt;::__value, _Sequence &gt;::__type &gt; &amp;__x) noexcept
           Converting constructor from a mutable iterator to a constant iterator.
       void <b>_M_attach</b> (<b>_Safe_sequence_base</b> *__seq)
       void <b>_M_attach_single</b> (<b>_Safe_sequence_base</b> *__seq)
       bool <b>_M_attached_to</b> (const <b>_Safe_sequence_base</b> *__seq) const
       bool <b>_M_can_compare</b> (const <b>_Safe_iterator_base</b> &amp;__x) const  throw ()
       bool <b>_M_dereferenceable</b> () const
           Is the iterator dereferenceable?
       _Distance_traits&lt; _Iterator &gt;::__type <b>_M_get_distance_to</b> (const <b>_Safe_local_iterator</b> &amp;__rhs) const
       __gnu_cxx::__conditional_type&lt; _IsConstant::__value, const_Sequence *, _Sequence * &gt;::__type
           <b>_M_get_sequence</b> () const
       template&lt;typename _Other &gt; bool <b>_M_in_same_bucket</b> (const <b>_Safe_local_iterator</b>&lt; _Other, _Sequence &gt;
           &amp;__other) const
           Is this iterator part of the same bucket as the other one?
       bool <b>_M_incrementable</b> () const
           Is the iterator incrementable?
       void <b>_M_invalidate</b> ()
       bool <b>_M_is_begin</b> () const
           Is this iterator equal to the sequence's begin(bucket) iterator?
       bool <b>_M_is_end</b> () const
           Is this iterator equal to the sequence's end(bucket) iterator?
       void <b>_M_reset</b> ()  throw ()
       bool <b>_M_singular</b> () const  throw ()
       void <b>_M_unlink</b> ()  throw ()
       bool <b>_M_valid_range</b> (const <b>_Safe_local_iterator</b> &amp;__rhs, <b>std::pair</b>&lt; difference_type, <b>_Distance_precision</b> &gt;
           &amp;__dist_info) const
       bool <b>_M_value_initialized</b> () const
           Is the iterator value-initialized?
       const _Iterator &amp; <b>base</b> () const noexcept
       _Iterator &amp; <b>base</b> () noexcept
           Return the underlying iterator.
       size_type <b>bucket</b> () const
           Return the bucket.
       <b>operator</b> <b>_Iterator</b> () const
           Conversion to underlying non-debug iterator to allow better interaction with non-debug containers.
       reference <b>operator*</b> () const
           Iterator dereference.
       <b>_Safe_local_iterator</b> &amp; <b>operator++</b> ()
           Iterator preincrement.
       <b>_Safe_local_iterator</b> <b>operator++</b> (int)
           Iterator postincrement.
       pointer <b>operator-&gt;</b> () const
           Iterator dereference.
       <b>_Safe_local_iterator</b> &amp; <b>operator=</b> (<b>_Safe_local_iterator</b> &amp;&amp;__x) noexcept
           Move assignment.
       <b>_Safe_local_iterator</b> &amp; <b>operator=</b> (const <b>_Safe_local_iterator</b> &amp;__x)
           Copy assignment.

   <b>Static</b> <b>Public</b> <b>Member</b> <b>Functions</b>
       static constexpr bool <b>_S_constant</b> ()
           Determine if this is a constant iterator.

   <b>Public</b> <b>Attributes</b>
       <b>_Safe_iterator_base</b> * <b>_M_next</b>
       <b>_Safe_iterator_base</b> * <b>_M_prior</b>
       <b>_Safe_sequence_base</b> * <b>_M_sequence</b>
       unsigned int <b>_M_version</b>

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       void <b>_M_attach</b> (<b>_Safe_sequence_base</b> *__seq, bool __constant)
       void <b>_M_attach_single</b> (<b>_Safe_sequence_base</b> *__seq, bool __constant)  throw ()
       void <b>_M_detach</b> ()
       void <b>_M_detach_single</b> ()  throw ()
       <b>_Safe_unordered_container_base</b> * <b>_M_get_container</b> () const noexcept
       __gnu_cxx::__mutex &amp; <b>_M_get_mutex</b> ()  throw ()

   <b>Friends</b>
       bool <b>operator!=</b> (const <b>_Self</b> &amp;__lhs, const <b>_OtherSelf</b> &amp;__rhs) noexcept
       bool <b>operator!=</b> (const <b>_Self</b> &amp;__lhs, const <b>_Self</b> &amp;__rhs) noexcept
       bool <b>operator==</b> (const <b>_Self</b> &amp;__lhs, const <b>_OtherSelf</b> &amp;__rhs) noexcept
       bool <b>operator==</b> (const <b>_Self</b> &amp;__lhs, const <b>_Self</b> &amp;__rhs) noexcept

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_Iterator,</b> <b>typename</b> <b>_Sequence&gt;</b>
       class __gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence &gt;"Safe iterator wrapper.

       The class template _Safe_local_iterator is a wrapper around an iterator that tracks the iterator's
       movement among sequences and checks that operations performed on the 'safe' iterator are legal. In
       additional to the basic iterator operations (which are validated, and then passed to the underlying
       iterator), _Safe_local_iterator has member functions for iterator invalidation, attaching/detaching the
       iterator from sequences, and querying the iterator's state.

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;::_Safe_local_iterator</b> <b>()</b> <b>[inline],</b>  <b>[noexcept]</b>
       <b>Postcondition</b>
           the iterator is singular and unattached

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;::_Safe_local_iterator</b> <b>(_Iterator</b> <b>__i,</b> <b>const</b> <b>_Safe_sequence_base</b> <b>*</b> <b>__cont)</b> <b>[inline]</b>
       Safe iterator construction from an unsafe iterator and its sequence.

       <b>Precondition</b>
           seq is not NULL

       <b>Postcondition</b>
           this is not singular

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;::_Safe_local_iterator</b> <b>(const</b> <b>_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;</b> <b>&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Copy construction.

       References <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_attach()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>, <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_value_initialized()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;::_Safe_local_iterator</b> <b>(_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Move construction.

       <b>Postcondition</b>
           __x is singular and unattached

       References <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_attach()</b>,
       <b>__gnu_debug::_Safe_local_iterator_base::_M_detach()</b>, <b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;::_M_value_initialized()</b>, and <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::base()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>template&lt;typename</b> <b>_MutableIterator</b> <b>&gt;</b>
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator</b> <b>(const</b>
       <b>_Safe_local_iterator&lt;</b> <b>_MutableIterator,</b> <b>typename</b> <b>__gnu_cxx::__enable_if&lt;</b> <b>_IsConstant::__value</b>
       <b>&amp;&amp;std::__are_same&lt;</b> <b>_MutableIterator,</b> <b>_OtherIterator</b> <b>&gt;::__value,</b> <b>_Sequence</b> <b>&gt;::__type</b> <b>&gt;</b> <b>&amp;</b> <b>__x)</b> <b>[inline],</b>
       <b>[noexcept]</b>
       Converting constructor from a mutable iterator to a constant iterator.

       References <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_attach()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>, <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_value_initialized()</b>.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>void</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::_M_attach</b> <b>(_Safe_sequence_base</b> <b>*</b> <b>__seq)</b> <b>[inline]</b>
       Attach iterator to the given sequence.

       References <b>__gnu_debug::_Safe_local_iterator_base::_M_attach()</b>, and <b>__gnu_debug::_Safe_local_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_S_constant()</b>.

       Referenced by <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>.

   <b>void</b> <b>__gnu_debug::_Safe_local_iterator_base::_M_attach</b> <b>(_Safe_sequence_base</b> <b>*</b> <b>__seq,</b> <b>bool</b> <b>__constant)</b>
       <b>[protected],</b>  <b>[inherited]</b>
       Attaches this iterator to the given container, detaching it from whatever container it was attached to
       originally. If the new container is the NULL pointer, the iterator is left unattached.

       Referenced by <b>__gnu_debug::_Safe_local_iterator_base::_Safe_local_iterator_base()</b>,
       <b>__gnu_debug::_Safe_local_iterator_base::_Safe_local_iterator_base()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_attach()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>void</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::_M_attach_single</b> <b>(_Safe_sequence_base</b> <b>*</b> <b>__seq)</b> <b>[inline]</b>
       Likewise, but not thread-safe.

       References <b>__gnu_debug::_Safe_local_iterator_base::_M_attach_single()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_S_constant()</b>.

   <b>void</b> <b>__gnu_debug::_Safe_local_iterator_base::_M_attach_single</b> <b>(_Safe_sequence_base</b> <b>*</b> <b>__seq,</b> <b>bool</b> <b>__constant)</b>
       <b>[protected],</b>  <b>[inherited]</b>
       Likewise, but not thread-safe.

       Referenced by <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_attach_single()</b>.

   <b>bool</b> <b>__gnu_debug::_Safe_iterator_base::_M_attached_to</b> <b>(const</b> <b>_Safe_sequence_base</b> <b>*</b> <b>__seq)</b> <b>const</b> <b>[inline],</b>
       <b>[inherited]</b>
       Determines if we are attached to the given sequence.

       References <b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>.

   <b>bool</b> <b>__gnu_debug::_Safe_iterator_base::_M_can_compare</b> <b>(const</b> <b>_Safe_iterator_base</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inherited]</b>
       Can we compare this iterator to the given iterator __x? Returns true if both iterators are nonsingular
       and reference the same sequence.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>bool</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::_M_dereferenceable</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Is the iterator dereferenceable?

       References <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_is_end()</b>, and
       <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>.

       Referenced by <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator*()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator-&gt;()</b>.

   <b>void</b> <b>__gnu_debug::_Safe_local_iterator_base::_M_detach</b> <b>()</b> <b>[protected],</b>  <b>[inherited]</b>
       Detach the iterator for whatever container it is attached to, if any.

       Referenced by <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>.

   <b>void</b> <b>__gnu_debug::_Safe_local_iterator_base::_M_detach_single</b> <b>()</b> <b>[protected],</b>  <b>[inherited]</b>
       Likewise, but not thread-safe.

   <b>__gnu_cxx::__mutex</b> <b>&amp;</b> <b>__gnu_debug::_Safe_iterator_base::_M_get_mutex</b> <b>()</b> <b>[protected],</b>  <b>[inherited]</b>
       For use in _Safe_iterator.

       Referenced by <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator++()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator++()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>, and <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::operator=()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>template&lt;typename</b> <b>_Other</b> <b>&gt;</b> <b>bool</b>
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_in_same_bucket</b> <b>(const</b> <b>_Safe_local_iterator&lt;</b>
       <b>_Other,</b> <b>_Sequence</b> <b>&gt;</b> <b>&amp;</b> <b>__other)</b> <b>const</b> <b>[inline]</b>
       Is this iterator part of the same bucket as the other one?

       References <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::bucket()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>bool</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::_M_incrementable</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Is the iterator incrementable?

       References <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_is_end()</b>, and
       <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>.

       Referenced by <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator++()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator++()</b>.

   <b>void</b> <b>__gnu_debug::_Safe_iterator_base::_M_invalidate</b> <b>()</b> <b>[inline],</b>  <b>[inherited]</b>
       Invalidate the iterator, making it singular.

       References <b>__gnu_debug::_Safe_iterator_base::_M_version</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>bool</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::_M_is_begin</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Is this iterator equal to the sequence's begin(bucket) iterator?

       References <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::base()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::bucket()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>bool</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::_M_is_end</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Is this iterator equal to the sequence's end(bucket) iterator?

       References <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::base()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::bucket()</b>.

       Referenced by <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_dereferenceable()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_incrementable()</b>.

   <b>void</b> <b>__gnu_debug::_Safe_iterator_base::_M_reset</b> <b>()</b> <b>[inherited]</b>
       Reset all member variables

   <b>bool</b> <b>__gnu_debug::_Safe_iterator_base::_M_singular</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Is this iterator singular?

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>,
       <b>__gnu_debug::__check_singular_aux()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b>
       <b>&gt;::_M_dereferenceable()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_dereferenceable()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_incrementable()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_incrementable()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>, and <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::operator=()</b>.

   <b>void</b> <b>__gnu_debug::_Safe_iterator_base::_M_unlink</b> <b>()</b> <b>[inline],</b>  <b>[inherited]</b>
       Unlink itself

       References <b>__gnu_debug::_Safe_iterator_base::_M_next</b>, and <b>__gnu_debug::_Safe_iterator_base::_M_prior</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>bool</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::_M_value_initialized</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Is the iterator value-initialized?

       References <b>__gnu_debug::_Safe_iterator_base::_M_version</b>, and <b>__gnu_debug::_Safe_local_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::base()</b>.

       Referenced by <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>static</b> <b>constexpr</b> <b>bool</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_S_constant</b> <b>()</b> <b>[inline],</b>  <b>[static],</b>  <b>[constexpr]</b>
       Determine if this is a constant iterator.

       Referenced by <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_attach()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_attach_single()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>_Iterator</b> <b>&amp;</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::base</b> <b>()</b> <b>[inline],</b>  <b>[noexcept]</b>
       Return the underlying iterator.

       Referenced by <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_is_begin()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_is_end()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_value_initialized()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::bucket()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator*()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;::operator++()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator-&gt;()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>size_type</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::bucket</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Return the bucket.

       References <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::base()</b>.

       Referenced by <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_in_same_bucket()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_is_begin()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_is_end()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;::operator</b> <b>_Iterator</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Conversion to underlying non-debug iterator to allow better interaction with non-debug containers.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>reference</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::operator*</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Iterator dereference.

       <b>Precondition</b>
           iterator is dereferenceable

       References <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_dereferenceable()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::base()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>_Safe_local_iterator</b> <b>&amp;</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator++</b> <b>()</b> <b>[inline]</b>
       Iterator preincrement.

       <b>Precondition</b>
           iterator is incrementable

       References <b>__gnu_debug::_Safe_iterator_base::_M_get_mutex()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_incrementable()</b>, and <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;::base()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>_Safe_local_iterator</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator++</b> <b>(int)</b> <b>[inline]</b>
       Iterator postincrement.

       <b>Precondition</b>
           iterator is incrementable

       References <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_incrementable()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>pointer</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::operator-&gt;</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Iterator dereference.

       <b>Precondition</b>
           iterator is dereferenceable

       References <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_dereferenceable()</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::base()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>_Safe_local_iterator</b> <b>&amp;</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=</b> <b>(_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline],</b>
       <b>[noexcept]</b>
       Move assignment.

       <b>Postcondition</b>
           __x is singular and unattached

       References <b>std::__addressof()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_attach()</b>,
       <b>__gnu_debug::_Safe_local_iterator_base::_M_detach()</b>, <b>__gnu_debug::_Safe_iterator_base::_M_get_mutex()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>, <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_value_initialized()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_version</b>, <b>__gnu_debug::_Safe_sequence_base::_M_version</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::base()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>&gt;</b> <b>_Safe_local_iterator</b> <b>&amp;</b> <b>__gnu_debug::_Safe_local_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=</b> <b>(const</b> <b>_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Copy assignment.

       References <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_attach()</b>,
       <b>__gnu_debug::_Safe_local_iterator_base::_M_detach()</b>, <b>__gnu_debug::_Safe_iterator_base::_M_get_mutex()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>, <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_value_initialized()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_version</b>, <b>__gnu_debug::_Safe_sequence_base::_M_version</b>, and
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::base()</b>.

</pre><h4><b>Member</b> <b>Data</b> <b>Documentation</b></h4><pre>
   <b>_Safe_iterator_base*</b> <b>__gnu_debug::_Safe_iterator_base::_M_next</b> <b>[inherited]</b>
       Pointer to the next iterator in the sequence's list of iterators. Only valid when _M_sequence != NULL.

       Referenced by <b>__gnu_debug::_Safe_sequence&lt;</b> <b>_SafeSequence</b> <b>&gt;::_M_invalidate_if()</b>,
       <b>__gnu_debug::_Safe_sequence&lt;</b> <b>_Sequence</b> <b>&gt;::_M_transfer_from_if()</b>, and
       <b>__gnu_debug::_Safe_iterator_base::_M_unlink()</b>.

   <b>_Safe_iterator_base*</b> <b>__gnu_debug::_Safe_iterator_base::_M_prior</b> <b>[inherited]</b>
       Pointer to the previous iterator in the sequence's list of iterators. Only valid when _M_sequence !=
       NULL.

       Referenced by <b>__gnu_debug::_Safe_sequence&lt;</b> <b>_SafeSequence</b> <b>&gt;::_M_invalidate_if()</b>,
       <b>__gnu_debug::_Safe_sequence&lt;</b> <b>_Sequence</b> <b>&gt;::_M_transfer_from_if()</b>, and
       <b>__gnu_debug::_Safe_iterator_base::_M_unlink()</b>.

   <b>_Safe_sequence_base*</b> <b>__gnu_debug::_Safe_iterator_base::_M_sequence</b> <b>[inherited]</b>
       The sequence this iterator references; may be NULL to indicate a singular iterator.

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_Safe_iterator_base()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;::_Safe_local_iterator()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;::_Safe_local_iterator()</b>, <b>__gnu_debug::_Safe_local_iterator_base::_Safe_local_iterator_base()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_attached_to()</b>, <b>__gnu_debug::_Safe_sequence&lt;</b> <b>_Sequence</b>
       <b>&gt;::_M_transfer_from_if()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>, and <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::operator=()</b>.

   <b>unsigned</b> <b>int</b> <b>__gnu_debug::_Safe_iterator_base::_M_version</b> <b>[inherited]</b>
       The version number of this iterator. The sentinel value 0 is used to indicate an invalidated iterator
       (i.e., one that is singular because of an operation on the container). This version number must equal the
       version number in the sequence referenced by _M_sequence for the iterator to be non-singular.

       Referenced by <b>__gnu_debug::_Safe_iterator_base::_M_invalidate()</b>, <b>__gnu_debug::_Safe_sequence&lt;</b> <b>_Sequence</b>
       <b>&gt;::_M_transfer_from_if()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b>
       <b>&gt;::_M_value_initialized()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;::_M_value_initialized()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>, and <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::operator=()</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstd<b>__</b><u>gnu_debug::_Safe_loc...</u> <b>_</b><u>Iterator,</u> <b>_</b><u>Sequence</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>