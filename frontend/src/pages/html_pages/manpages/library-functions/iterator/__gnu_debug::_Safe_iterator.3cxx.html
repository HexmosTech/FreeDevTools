<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
<b>__</b><u>gnu_debug::_Safe_iter...</u> <b>_</b><u>Sequence,</u> <b>_</b><u>Category</u> <u>&gt;</u>(3cxx)  <b>__</b><u>gnu_debug::_Safe_iter...</u> <b>_</b><u>Sequence,</u> <b>_</b><u>Category</u> <u>&gt;</u>(3cxx)

</pre><h4><b>NAME</b></h4><pre>
       __gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence, _Category &gt; - Safe iterator wrapper.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;safe_iterator.h&gt;

       Inherits _Iterator, and <b>__gnu_debug::_Safe_iterator_base</b>.

       Inherited by __gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence, std::random_access_iterator_tag &gt;.

   <b>Public</b> <b>Types</b>
       typedef <b>_Safe_iterator</b>&lt; _Iterator, _Sequence, iterator_category &gt; <b>_Self</b>
       typedef _Traits::difference_type <b>difference_type</b>
       typedef _Traits::iterator_category <b>iterator_category</b>
       using <b>iterator_concept</b> = std::__detail::__iter_concept&lt; _Iterator &gt;
       typedef _Iterator <b>iterator_type</b>
       typedef _Traits::pointer <b>pointer</b>
       typedef _Traits::reference <b>reference</b>
       typedef _Traits::value_type <b>value_type</b>

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>_Safe_iterator</b> () noexcept
       <b>_Safe_iterator</b> (_Iterator __i, const <b>_Safe_sequence_base</b> *__seq) noexcept
           Safe iterator construction from an unsafe iterator and its sequence.
       <b>_Safe_iterator</b> (<b>_Safe_iterator</b> &amp;&amp;__x) noexcept
           Move construction.
       <b>_Safe_iterator</b> (const <b>_Safe_iterator</b> &amp;__x) noexcept
           Copy construction.
       template&lt;typename _MutableIterator &gt; <b>_Safe_iterator</b> (const <b>_Safe_iterator</b>&lt; _MutableIterator, _Sequence,
           typename __gnu_cxx::__enable_if&lt; _IsConstant::__value &amp;&amp;std::__are_same&lt; _MutableIterator,
           _OtherIterator &gt;::__value, _Category &gt;::__type &gt; &amp;__x) noexcept
           Converting constructor from a mutable iterator to a constant iterator.
       void <b>_M_attach</b> (<b>_Safe_sequence_base</b> *__seq)
       void <b>_M_attach_single</b> (<b>_Safe_sequence_base</b> *__seq)
       bool <b>_M_attached_to</b> (const <b>_Safe_sequence_base</b> *__seq) const
       bool <b>_M_before_dereferenceable</b> () const
           Is the iterator before a dereferenceable one?
       template&lt;typename _Diff &gt; bool <b>_M_can_advance</b> (const <b>std::pair</b>&lt; _Diff, <b>_Distance_precision</b> &gt; &amp;__dist, int
           __way) const
       bool <b>_M_can_advance</b> (difference_type __n, bool __strict=false) const
       bool <b>_M_can_compare</b> (const <b>_Safe_iterator_base</b> &amp;__x) const  throw ()
       bool <b>_M_dereferenceable</b> () const
           Is the iterator dereferenceable?
       void <b>_M_detach_single</b> ()  throw ()
       _Distance_traits&lt; _Iterator &gt;::__type <b>_M_get_distance_from_begin</b> () const
       _Distance_traits&lt; _Iterator &gt;::__type <b>_M_get_distance_to</b> (const <b>_Safe_iterator</b> &amp;__rhs) const
       _Distance_traits&lt; _Iterator &gt;::__type <b>_M_get_distance_to_end</b> () const
       __gnu_cxx::__conditional_type&lt; _IsConstant::__value, const_Sequence *, _Sequence * &gt;::__type
           <b>_M_get_sequence</b> () const
       bool <b>_M_incrementable</b> () const
           Is the iterator incrementable?
       void <b>_M_invalidate</b> ()
       bool <b>_M_is_before_begin</b> () const
           Is this iterator equal to the sequence's before_begin() iterator if any?
       bool <b>_M_is_begin</b> () const
           Is this iterator equal to the sequence's begin() iterator?
       bool <b>_M_is_beginnest</b> () const
           Is this iterator equal to the sequence's before_begin() iterator if any or begin() otherwise?
       bool <b>_M_is_end</b> () const
           Is this iterator equal to the sequence's end() iterator?
       void <b>_M_reset</b> ()  throw ()
       bool <b>_M_singular</b> () const  throw ()
       void <b>_M_unlink</b> ()  throw ()
       bool <b>_M_valid_range</b> (const <b>_Safe_iterator</b> &amp;__rhs, <b>std::pair</b>&lt; difference_type, <b>_Distance_precision</b> &gt;
           &amp;__dist, bool __check_dereferenceable=true) const
       bool <b>_M_value_initialized</b> () const
           Is the iterator value-initialized?
       const _Iterator &amp; <b>base</b> () const noexcept
       _Iterator &amp; <b>base</b> () noexcept
           Return the underlying iterator.
       <b>operator</b> <b>_Iterator</b> () const noexcept
           Conversion to underlying non-debug iterator to allow better interaction with non-debug containers.
       reference <b>operator*</b> () const noexcept
           Iterator dereference.
       <b>_Safe_iterator</b> &amp; <b>operator++</b> () noexcept
           Iterator preincrement.
       <b>_Safe_iterator</b> <b>operator++</b> (int) noexcept
           Iterator postincrement.
       pointer <b>operator-&gt;</b> () const noexcept
           Iterator dereference.
       <b>_Safe_iterator</b> &amp; <b>operator=</b> (<b>_Safe_iterator</b> &amp;&amp;__x) noexcept
           Move assignment.
       <b>_Safe_iterator</b> &amp; <b>operator=</b> (const <b>_Safe_iterator</b> &amp;__x) noexcept
           Copy assignment.

   <b>Static</b> <b>Public</b> <b>Member</b> <b>Functions</b>
       static constexpr bool <b>_S_constant</b> ()
           Determine if this is a constant iterator.

   <b>Public</b> <b>Attributes</b>
       <b>_Safe_iterator_base</b> * <b>_M_next</b>
       <b>_Safe_iterator_base</b> * <b>_M_prior</b>
       <b>_Safe_sequence_base</b> * <b>_M_sequence</b>
       unsigned int <b>_M_version</b>

   <b>Protected</b> <b>Types</b>
       typedef std::__are_same&lt; typename _Sequence::_Base::const_iterator, _Iterator &gt; <b>_IsConstant</b>
       typedef __gnu_cxx::__conditional_type&lt; _IsConstant::__value, typename_Sequence::_Base::iterator,
           typename_Sequence::_Base::const_iterator &gt;::__type <b>_OtherIterator</b>

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       <b>_Safe_iterator</b> (const <b>_Safe_iterator</b> &amp;__x, _Unchecked) noexcept
       void <b>_M_attach</b> (<b>_Safe_sequence_base</b> *__seq, bool __constant)
       void <b>_M_attach_single</b> (<b>_Safe_sequence_base</b> *__seq, bool __constant)  throw ()
       void <b>_M_detach</b> ()
       __gnu_cxx::__mutex &amp; <b>_M_get_mutex</b> ()  throw ()

   <b>Friends</b>
       template&lt;typename _IteR &gt; bool <b>operator!=</b> (const <b>_Self</b> &amp;__lhs, const <b>_Safe_iterator</b>&lt; _IteR, _Sequence,
           iterator_category &gt; &amp;__rhs) noexcept
       bool <b>operator!=</b> (const <b>_Self</b> &amp;__lhs, const <b>_Self</b> &amp;__rhs) noexcept
       template&lt;typename _IteR &gt; bool <b>operator==</b> (const <b>_Self</b> &amp;__lhs, const <b>_Safe_iterator</b>&lt; _IteR, _Sequence,
           iterator_category &gt; &amp;__rhs) noexcept
       bool <b>operator==</b> (const <b>_Self</b> &amp;__lhs, const <b>_Self</b> &amp;__rhs) noexcept

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_Iterator,</b> <b>typename</b> <b>_Sequence,</b> <b>typename</b> <b>_Category</b> <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b>
       class __gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence, _Category &gt;"Safe iterator wrapper.

       The class template _Safe_iterator is a wrapper around an iterator that tracks the iterator's movement
       among sequences and checks that operations performed on the 'safe' iterator are legal. In additional to
       the basic iterator operations (which are validated, and then passed to the underlying iterator),
       _Safe_iterator has member functions for iterator invalidation, attaching/detaching the iterator from
       sequences, and querying the iterator's state.

       Note that _Iterator must be the first base class so that it gets initialized before the iterator is being
       attached to the container's list of iterators and it is being detached before _Iterator get destroyed.
       Otherwise it would result in a data race.

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b>
       <b>_Category</b> <b>&gt;::_Safe_iterator</b> <b>()</b> <b>[inline],</b>  <b>[noexcept]</b>
       <b>Postcondition</b>
           the iterator is singular and unattached

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b>
       <b>_Category</b> <b>&gt;::_Safe_iterator</b> <b>(_Iterator</b> <b>__i,</b> <b>const</b> <b>_Safe_sequence_base</b> <b>*</b> <b>__seq)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Safe iterator construction from an unsafe iterator and its sequence.

       <b>Precondition</b>
           seq is not NULL

       <b>Postcondition</b>
           this is not singular

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b>
       <b>_Category</b> <b>&gt;::_Safe_iterator</b> <b>(const</b> <b>_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;</b> <b>&amp;</b> <b>__x)</b> <b>[inline],</b>
       <b>[noexcept]</b>
       Copy construction.

       References <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_attach()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>, <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>, and
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_value_initialized()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b>
       <b>_Category</b> <b>&gt;::_Safe_iterator</b> <b>(_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline],</b>
       <b>[noexcept]</b>
       Move construction.

       <b>Postcondition</b>
           __x is singular and unattached

       References <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_attach()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_detach()</b>, <b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b>
       <b>_Category</b> <b>&gt;::_M_value_initialized()</b>, and <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b>
       <b>&gt;::base()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>template&lt;typename</b> <b>_MutableIterator</b> <b>&gt;</b>
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator</b> <b>(const</b> <b>_Safe_iterator&lt;</b>
       <b>_MutableIterator,</b> <b>_Sequence,</b> <b>typename</b> <b>__gnu_cxx::__enable_if&lt;</b> <b>_IsConstant::__value</b> <b>&amp;&amp;std::__are_same&lt;</b>
       <b>_MutableIterator,</b> <b>_OtherIterator</b> <b>&gt;::__value,</b> <b>_Category</b> <b>&gt;::__type</b> <b>&gt;</b> <b>&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Converting constructor from a mutable iterator to a constant iterator.

       References <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_attach()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>, <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>, and
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_value_initialized()</b>.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>void</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_attach</b> <b>(_Safe_sequence_base</b> <b>*</b> <b>__seq)</b> <b>[inline]</b>
       Attach iterator to the given sequence.

       References <b>__gnu_debug::_Safe_iterator_base::_M_attach()</b>, and <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_S_constant()</b>.

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>, and
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>.

   <b>void</b> <b>__gnu_debug::_Safe_iterator_base::_M_attach</b> <b>(_Safe_sequence_base</b> <b>*</b> <b>__seq,</b> <b>bool</b> <b>__constant)</b> <b>[protected],</b>
       <b>[inherited]</b>
       Attaches this iterator to the given sequence, detaching it from whatever sequence it was attached to
       originally. If the new sequence is the NULL pointer, the iterator is left unattached.

       Referenced by <b>__gnu_debug::_Safe_iterator_base::_Safe_iterator_base()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_Safe_iterator_base()</b>, and <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_attach()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>void</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_attach_single</b> <b>(_Safe_sequence_base</b> <b>*</b> <b>__seq)</b> <b>[inline]</b>
       Likewise, but not thread-safe.

       References <b>__gnu_debug::_Safe_iterator_base::_M_attach_single()</b>, and <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_S_constant()</b>.

   <b>void</b> <b>__gnu_debug::_Safe_iterator_base::_M_attach_single</b> <b>(_Safe_sequence_base</b> <b>*</b> <b>__seq,</b> <b>bool</b> <b>__constant)</b>
       <b>[protected],</b>  <b>[inherited]</b>
       Likewise, but not thread-safe.

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_attach_single()</b>.

   <b>bool</b> <b>__gnu_debug::_Safe_iterator_base::_M_attached_to</b> <b>(const</b> <b>_Safe_sequence_base</b> <b>*</b> <b>__seq)</b> <b>const</b> <b>[inline],</b>
       <b>[inherited]</b>
       Determines if we are attached to the given sequence.

       References <b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>bool</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_before_dereferenceable</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Is the iterator before a dereferenceable one?

       References <b>__gnu_debug::__base()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b>
       <b>&gt;::_M_incrementable()</b>, and <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::base()</b>.

   <b>bool</b> <b>__gnu_debug::_Safe_iterator_base::_M_can_compare</b> <b>(const</b> <b>_Safe_iterator_base</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inherited]</b>
       Can we compare this iterator to the given iterator __x? Returns true if both iterators are nonsingular
       and reference the same sequence.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>bool</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_dereferenceable</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Is the iterator dereferenceable?

       References <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_is_before_begin()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_is_end()</b>, and
       <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>.

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator*()</b>, and
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator-&gt;()</b>.

   <b>void</b> <b>__gnu_debug::_Safe_iterator_base::_M_detach</b> <b>()</b> <b>[protected],</b>  <b>[inherited]</b>
       Detach the iterator for whatever sequence it is attached to, if any.

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>, and
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>.

   <b>void</b> <b>__gnu_debug::_Safe_iterator_base::_M_detach_single</b> <b>()</b> <b>[inherited]</b>
       Likewise, but not thread-safe.

       Referenced by <b>__gnu_debug::_Safe_sequence&lt;</b> <b>_Sequence</b> <b>&gt;::_M_transfer_from_if()</b>.

   <b>__gnu_cxx::__mutex</b> <b>&amp;</b> <b>__gnu_debug::_Safe_iterator_base::_M_get_mutex</b> <b>()</b> <b>[protected],</b>  <b>[inherited]</b>
       For use in _Safe_iterator.

       Referenced by <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator++()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator++()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>, and <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::operator=()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>bool</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_incrementable</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Is the iterator incrementable?

       References <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_is_end()</b>, and
       <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>.

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b>
       <b>&gt;::_M_before_dereferenceable()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b>
       <b>&gt;::operator++()</b>, and <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator++()</b>.

   <b>void</b> <b>__gnu_debug::_Safe_iterator_base::_M_invalidate</b> <b>()</b> <b>[inline],</b>  <b>[inherited]</b>
       Invalidate the iterator, making it singular.

       References <b>__gnu_debug::_Safe_iterator_base::_M_version</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>bool</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_is_before_begin</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Is this iterator equal to the sequence's before_begin() iterator if any?

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_dereferenceable()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>bool</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_is_begin</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Is this iterator equal to the sequence's begin() iterator?

       References <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::base()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>bool</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_is_beginnest</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Is this iterator equal to the sequence's before_begin() iterator if any or begin() otherwise?

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>bool</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_is_end</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Is this iterator equal to the sequence's end() iterator?

       References <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::base()</b>.

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_dereferenceable()</b>, and
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_incrementable()</b>.

   <b>void</b> <b>__gnu_debug::_Safe_iterator_base::_M_reset</b> <b>()</b> <b>[inherited]</b>
       Reset all member variables

   <b>bool</b> <b>__gnu_debug::_Safe_iterator_base::_M_singular</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Is this iterator singular?

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>,
       <b>__gnu_debug::__check_singular_aux()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b>
       <b>&gt;::_M_dereferenceable()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_dereferenceable()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_incrementable()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::_M_incrementable()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>, and <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::operator=()</b>.

   <b>void</b> <b>__gnu_debug::_Safe_iterator_base::_M_unlink</b> <b>()</b> <b>[inline],</b>  <b>[inherited]</b>
       Unlink itself

       References <b>__gnu_debug::_Safe_iterator_base::_M_next</b>, and <b>__gnu_debug::_Safe_iterator_base::_M_prior</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>bool</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_value_initialized</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Is the iterator value-initialized?

       References <b>__gnu_debug::_Safe_iterator_base::_M_version</b>, and <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::base()</b>.

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>, and
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>static</b> <b>constexpr</b> <b>bool</b> <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_S_constant</b> <b>()</b> <b>[inline],</b>  <b>[static],</b>  <b>[constexpr]</b>
       Determine if this is a constant iterator.

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_attach()</b>, and
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_attach_single()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>_Iterator</b> <b>&amp;</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::base</b> <b>()</b> <b>[inline],</b>  <b>[noexcept]</b>
       Return the underlying iterator.

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_before_dereferenceable()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_is_begin()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_is_end()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_value_initialized()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator*()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b>
       <b>&gt;::operator++()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator-&gt;()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>, and
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b>
       <b>_Category</b> <b>&gt;::operator</b> <b>_Iterator</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Conversion to underlying non-debug iterator to allow better interaction with non-debug containers.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>reference</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator*</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Iterator dereference.

       <b>Precondition</b>
           iterator is dereferenceable

       References <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_dereferenceable()</b>, and
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::base()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>_Safe_iterator</b> <b>&amp;</b> <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator++</b> <b>()</b> <b>[inline],</b>  <b>[noexcept]</b>
       Iterator preincrement.

       <b>Precondition</b>
           iterator is incrementable

       References <b>__gnu_debug::_Safe_iterator_base::_M_get_mutex()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_incrementable()</b>, and <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b>
       <b>_Category</b> <b>&gt;::base()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>_Safe_iterator</b> <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator++</b> <b>(int)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Iterator postincrement.

       <b>Precondition</b>
           iterator is incrementable

       References <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_incrementable()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>pointer</b> <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator-&gt;</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Iterator dereference.

       <b>Precondition</b>
           iterator is dereferenceable

       References <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_dereferenceable()</b>, and
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::base()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>_Safe_iterator</b> <b>&amp;</b> <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=</b> <b>(_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__x)</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Move assignment.

       <b>Postcondition</b>
           __x is singular and unattached

       References <b>std::__addressof()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b>
       <b>&gt;::_M_attach()</b>, <b>__gnu_debug::_Safe_iterator_base::_M_detach()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_get_mutex()</b>, <b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b>
       <b>_Category</b> <b>&gt;::_M_value_initialized()</b>, <b>__gnu_debug::_Safe_iterator_base::_M_version</b>,
       <b>__gnu_debug::_Safe_sequence_base::_M_version</b>, and <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b>
       <b>_Category</b> <b>&gt;::base()</b>.

   <b>template&lt;typename</b> <b>_Iterator</b> <b>,</b> <b>typename</b> <b>_Sequence</b> <b>,</b> <b>typename</b> <b>_Category</b>  <b>=</b> <b>typename</b>
       <b>std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b> <b>_Safe_iterator</b> <b>&amp;</b> <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=</b> <b>(const</b> <b>_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;</b> <b>&amp;</b>
       <b>__x)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Copy assignment.

       References <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_attach()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_detach()</b>, <b>__gnu_debug::_Safe_iterator_base::_M_get_mutex()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>, <b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_M_value_initialized()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_version</b>, <b>__gnu_debug::_Safe_sequence_base::_M_version</b>, and
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::base()</b>.

</pre><h4><b>Member</b> <b>Data</b> <b>Documentation</b></h4><pre>
   <b>_Safe_iterator_base*</b> <b>__gnu_debug::_Safe_iterator_base::_M_next</b> <b>[inherited]</b>
       Pointer to the next iterator in the sequence's list of iterators. Only valid when _M_sequence != NULL.

       Referenced by <b>__gnu_debug::_Safe_sequence&lt;</b> <b>_SafeSequence</b> <b>&gt;::_M_invalidate_if()</b>,
       <b>__gnu_debug::_Safe_sequence&lt;</b> <b>_Sequence</b> <b>&gt;::_M_transfer_from_if()</b>, and
       <b>__gnu_debug::_Safe_iterator_base::_M_unlink()</b>.

   <b>_Safe_iterator_base*</b> <b>__gnu_debug::_Safe_iterator_base::_M_prior</b> <b>[inherited]</b>
       Pointer to the previous iterator in the sequence's list of iterators. Only valid when _M_sequence !=
       NULL.

       Referenced by <b>__gnu_debug::_Safe_sequence&lt;</b> <b>_SafeSequence</b> <b>&gt;::_M_invalidate_if()</b>,
       <b>__gnu_debug::_Safe_sequence&lt;</b> <b>_Sequence</b> <b>&gt;::_M_transfer_from_if()</b>, and
       <b>__gnu_debug::_Safe_iterator_base::_M_unlink()</b>.

   <b>_Safe_sequence_base*</b> <b>__gnu_debug::_Safe_iterator_base::_M_sequence</b> <b>[inherited]</b>
       The sequence this iterator references; may be NULL to indicate a singular iterator.

       Referenced by <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::_Safe_iterator()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_Safe_iterator_base()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::_Safe_local_iterator()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;::_Safe_local_iterator()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;::_Safe_local_iterator()</b>, <b>__gnu_debug::_Safe_local_iterator_base::_Safe_local_iterator_base()</b>,
       <b>__gnu_debug::_Safe_iterator_base::_M_attached_to()</b>, <b>__gnu_debug::_Safe_sequence&lt;</b> <b>_Sequence</b>
       <b>&gt;::_M_transfer_from_if()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>, and <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::operator=()</b>.

   <b>unsigned</b> <b>int</b> <b>__gnu_debug::_Safe_iterator_base::_M_version</b> <b>[inherited]</b>
       The version number of this iterator. The sentinel value 0 is used to indicate an invalidated iterator
       (i.e., one that is singular because of an operation on the container). This version number must equal the
       version number in the sequence referenced by _M_sequence for the iterator to be non-singular.

       Referenced by <b>__gnu_debug::_Safe_iterator_base::_M_invalidate()</b>, <b>__gnu_debug::_Safe_sequence&lt;</b> <b>_Sequence</b>
       <b>&gt;::_M_transfer_from_if()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b>
       <b>&gt;::_M_value_initialized()</b>, <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b>
       <b>&gt;::_M_value_initialized()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>,
       <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b> <b>_Sequence</b> <b>&gt;::operator=()</b>, <b>__gnu_debug::_Safe_iterator&lt;</b>
       <b>_Iterator,</b> <b>_Sequence,</b> <b>_Category</b> <b>&gt;::operator=()</b>, and <b>__gnu_debug::_Safe_local_iterator&lt;</b> <b>_Iterator,</b>
       <b>_Sequence</b> <b>&gt;::operator=()</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libst<b>__</b><u>gnu_debug::_Safe_iter...</u> <b>_</b><u>Sequence,</u> <b>_</b><u>Category</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>