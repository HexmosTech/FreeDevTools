<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>archive_write — functions for creating archives</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libarchive-dev">libarchive-dev_3.7.7-0ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       archive_write — functions for creating archives

</pre><h4><b>LIBRARY</b></h4><pre>
       Streaming Archive Library (libarchive, -larchive)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;archive.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  functions  provide a complete API for creating streaming archive files.  The general process is to
       first create the struct archive object, set any desired options, initialize the archive, append  entries,
       then close the archive and release all resources.

   <b>Create</b> <b>archive</b> <b>object</b>
       See <u><a href="../man3/archive_write_new.3.html">archive_write_new</a></u>(3).

       To write an archive, you must first obtain an initialized struct archive object from <b>archive_write_new</b>().

   <b>Enable</b> <b>filters</b> <b>and</b> <b>formats,</b> <b>configure</b> <b>block</b> <b>size</b> <b>and</b> <b>padding</b>
       See <u><a href="../man3/archive_write_filter.3.html">archive_write_filter</a></u>(3), <u><a href="../man3/archive_write_format.3.html">archive_write_format</a></u>(3) and <u><a href="../man3/archive_write_blocksize.3.html">archive_write_blocksize</a></u>(3).

       You  can  then  modify  this  object  for the desired operations with the various <b>archive_write_set_XXX</b>()
       functions.   In  particular,  you  will  need   to   invoke   appropriate   <b>archive_write_add_XXX</b>()   and
       <b>archive_write_set_XXX</b>() functions to enable the corresponding compression and format support.

   <b>Set</b> <b>options</b>
       See <u><a href="../man3/archive_write_set_options.3.html">archive_write_set_options</a></u>(3).

   <b>Open</b> <b>archive</b>
       See <u><a href="../man3/archive_write_open.3.html">archive_write_open</a></u>(3).

       Once  you  have  prepared  the  struct archive object, you call <b>archive_write_open</b>() to actually open the
       archive and prepare it for writing.  There are several variants of this function; the most basic  expects
       you  to  provide  pointers to several functions that can provide blocks of bytes from the archive.  There
       are convenience forms that allow you to specify a filename, file descriptor, <u>FILE</u> <u>*</u> object, or a block of
       memory from which to write the archive data.

   <b>Produce</b> <b>archive</b>
       See <u><a href="../man3/archive_write_header.3.html">archive_write_header</a></u>(3) and <u><a href="../man3/archive_write_data.3.html">archive_write_data</a></u>(3).

       Individual archive  entries  are  written  in  a  three-step  process:  You  first  initialize  a  struct
       archive_entry  structure with information about the new entry.  At a minimum, you should set the pathname
       of the entry and provide a <u>struct</u> <u>stat</u> with a valid <u>st_mode</u> field, which specifies the type of object and
       <u>st_size</u> field, which specifies the size of the data portion of the object.

   <b>Release</b> <b>resources</b>
       See <u><a href="../man3/archive_write_free.3.html">archive_write_free</a></u>(3).

       After all entries have been written, use the <b>archive_write_free</b>() function to release all resources.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following sketch illustrates basic usage of the library.  In this example, the callback functions are
       simply wrappers around the standard <u><a href="../man2/open.2.html">open</a></u>(2), <u><a href="../man2/write.2.html">write</a></u>(2), and <u><a href="../man2/close.2.html">close</a></u>(2) system calls.

             #ifdef __linux__
             #define _FILE_OFFSET_BITS 64
             #endif
             #include &lt;sys/stat.h&gt;
             #include &lt;archive.h&gt;
             #include &lt;archive_entry.h&gt;
             #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
             #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
             #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

             struct mydata {
               const char *name;
               int fd;
             };

             int
             myopen(struct archive *a, void *client_data)
             {
               struct mydata *mydata = client_data;

               mydata-&gt;fd = open(mydata-&gt;name, O_WRONLY | O_CREAT, 0644);
               if (mydata-&gt;fd &gt;= 0)
                 return (ARCHIVE_OK);
               else
                 return (ARCHIVE_FATAL);
             }

             la_ssize_t
             mywrite(struct archive *a, void *client_data, const void *buff, size_t n)
             {
               struct mydata *mydata = client_data;

               return (write(mydata-&gt;fd, buff, n));
             }

             int
             myclose(struct archive *a, void *client_data)
             {
               struct mydata *mydata = client_data;

               if (mydata-&gt;fd &gt; 0)
                 close(mydata-&gt;fd);
               return (0);
             }

             void
             write_archive(const char *outname, const char **filename)
             {
               struct mydata *mydata = malloc(sizeof(struct mydata));
               struct archive *a;
               struct archive_entry *entry;
               struct stat st;
               char buff[8192];
               int len;
               int fd;

               a = archive_write_new();
               mydata-&gt;name = outname;
               /* Set archive format and filter according to output file extension.
                * If it fails, set default format. Platform depended function.
                * See supported formats in archive_write_set_format_filter_by_ext.c */
               if (archive_write_set_format_filter_by_ext(a, outname) != ARCHIVE_OK)  {
                 archive_write_add_filter_gzip(a);
                 archive_write_set_format_ustar(a);
               }
               archive_write_open(a, mydata, myopen, mywrite, myclose);
               while (*filename) {
                 stat(*filename, &amp;st);
                 entry = archive_entry_new();
                 archive_entry_copy_stat(entry, &amp;st);
                 archive_entry_set_pathname(entry, *filename);
                 archive_write_header(a, entry);
                 if ((fd = open(*filename, O_RDONLY)) != -1) {
                   len = read(fd, buff, sizeof(buff));
                   while (len &gt; 0) {
                     archive_write_data(a, buff, len);
                     len = read(fd, buff, sizeof(buff));
                   }
                   close(fd);
                 }
                 archive_entry_free(entry);
                 filename++;
               }
               archive_write_free(a);
             }

             int main(int argc, const char **argv)
             {
               const char *outname;
               argv++;
               outname = *argv++;
               write_archive(outname, argv);
               return 0;
             }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/tar.1.html">tar</a></u>(1), <u><a href="../man3/archive_write_set_options.3.html">archive_write_set_options</a></u>(3), <u><a href="../man3/libarchive.3.html">libarchive</a></u>(3), <u><a href="../man5/cpio.5.html">cpio</a></u>(5), <u><a href="../man5/mtree.5.html">mtree</a></u>(5), <u><a href="../man5/tar.5.html">tar</a></u>(5)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>libarchive</b> library first appeared in FreeBSD 5.3.

</pre><h4><b>AUTHORS</b></h4><pre>
       The <b>libarchive</b> library was written by Tim Kientzle &lt;<a href="mailto:kientzle@acm.org">kientzle@acm.org</a>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       There are many peculiar bugs in historic tar implementations that may cause certain  programs  to  reject
       archives  written  by  this  library.   For  example,  several historic implementations calculated header
       checksums incorrectly and will thus reject valid archives; GNU tar does not fully support pax interchange
       format; some old tar implementations required specific field terminations.

       The default pax interchange format eliminates most of the historic tar limitations and provides a generic
       key/value attribute facility for vendor-defined extensions.  One oversight in POSIX  is  the  failure  to
       provide  a  standard  attribute  for  large  device  numbers.   This  library  uses “SCHILY.devminor” and
       “SCHILY.devmajor” for device numbers that exceed the range supported by  the  backwards-compatible  ustar
       header.   These  keys are compatible with Joerg Schilling's <b>star</b> archiver.  Other implementations may not
       recognize these keys and will thus be unable to correctly restore device nodes with large device  numbers
       from archives created by this library.

Debian                                          February 2, 2012                                <u><a href="../man3/ARCHIVE_WRITE.3.html">ARCHIVE_WRITE</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>