<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Archive::Ar - Interface for manipulating ar archives</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libarchive-ar-perl">libarchive-ar-perl_2.02-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Archive::Ar - Interface for manipulating ar archives

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Archive::Ar;

           my $ar = Archive::Ar-&gt;new;

           $ar-&gt;read('./foo.ar');
           $ar-&gt;extract;

           $ar-&gt;add_files('./bar.tar.gz', 'bat.pl')
           $ar-&gt;add_data('newfile.txt','Some contents');

           $ar-&gt;chmod('file1', 0644);
           $ar-&gt;chown('file1', $uid, $gid);

           $ar-&gt;remove('file1', 'file2');

           my $filehash = $ar-&gt;get_content('bar.tar.gz');
           my $data = $ar-&gt;get_data('bar.tar.gz');
           my $handle = $ar-&gt;get_handle('bar.tar.gz');

           my @files = $ar-&gt;list_files();

           my $archive = $ar-&gt;write;
           my $size = $ar-&gt;write('outbound.ar');

           $ar-&gt;error();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Archive::Ar is a pure-perl way to handle standard ar archives.

       This is useful if you have those types of archives on the system, but it is also useful because .deb
       packages for the Debian GNU/Linux distribution are ar archives. This is one building block in a future
       chain of modules to build, manipulate, extract, and test debian modules with no platform or architecture
       dependence.

       You may notice that the API to Archive::Ar is similar to Archive::Tar, and this was done intentionally to
       keep similarity between the Archive::* modules.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
         $ar = Archive::Ar-&gt;new()
         $ar = Archive::Ar-&gt;new($filename)
         $ar = Archive::Ar-&gt;new($filehandle)

       Returns a new Archive::Ar object.  Without an argument, it returns an empty object.  If passed a filename
       or an open filehandle, it will read the referenced archive into memory.  If the read fails for any
       reason, returns undef.

   <b>set_opt</b>
         $ar-&gt;set_opt($name, $val)

       Assign option $name value $val.  Possible options are:

       •   warn

           Warning  level.   Levels  are  zero  for no warnings, 1 for brief warnings, and 2 for warnings with a
           stack trace.  Default is zero.

       •   chmod

           Change the file permissions of files created when extracting.  Default is true (non-zero).

       •   same_perms

           When setting file permissions, use the values in the archive unchanged.   If  false,  removes  setuid
           bits and applies the user's umask.  Default is true for the root user, false otherwise.

       •   chown

           Change the owners of extracted files, if possible.  Default is true.

       •   type

           Archive type.  May be GNU, BSD or COMMON, or undef if no archive has been read.  Defaults to the type
           of the archive read, or undef.

       •   symbols

           Provide  a  filename for the symbol table, if present.  If set, the symbol table is treated as a file
           that can be read from or written to an archive.  It is an error if the filename provided matches  the
           name of a file in the archive.  If undefined, the symbol table is ignored.  Defaults to undef.

   <b>get_opt</b>
         $val = $ar-&gt;get_opt($name)

       Returns the value of option $name.

   <b>type</b>
         $type = $ar-&gt;type()

       Returns  the  type  of the ar archive.  The type is undefined until an archive is loaded.  If the archive
       displays characteristics of a gnu-style archive, GNU is returned.  If it looks like a bsd-style  archive,
       BSD  is  returned.   Otherwise,  COMMON  is returned.  Note that unless filenames exceed 16 characters in
       length, bsd archives look like the common format.

   <b>clear</b>
         $ar-&gt;clear()

       Clears the current in-memory archive.

   <b>read</b>
         $len = $ar-&gt;read($filename)
         $len = $ar-&gt;read($filehandle)

       This reads a new file into the object, removing any ar archive already represented in  the  object.   The
       argument  may  be  a filename, filehandle or IO::Handle object.  Returns the size of the file contents or
       undef if it fails.

   <b>read_memory</b>
         $len = $ar-&gt;read_memory($data)

       Parses the string argument as an archive,  reading  it  into  memory.   Replaces  any  previously  loaded
       archive.  Returns the number of bytes read, or undef if it fails.

   <b>contains_file</b>
         $bool = $ar-&gt;contains_file($filename)

       Returns true if the archive contains a file with $filename.  Returns undef otherwise.

   <b>extract</b>
         $ar-&gt;extract()
         $ar-&gt;extract_file($filename)

       Extracts  files  from the archive.  The first form extracts all files, the latter extracts just the named
       file.  Extracted files are assigned the permissions and modification time stored in the archive, and,  if
       possible, the user and group ownership.  Returns non-zero upon success, or undef if failure.

   <b>rename</b>
         $ar-&gt;rename($filename, $newname)

       Changes the name of a file in the in-memory archive.

   <b>chmod</b>
         $ar-&gt;chmod($filename, $mode);

       Change the mode of the member to $mode.

   <b>chown</b>
         $ar-&gt;chown($filename, $uid, $gid);
         $ar-&gt;chown($filename, $uid);

       Change  the  ownership  of the member to user id $uid and (optionally) group id $gid.  Negative id values
       are ignored.

   <b>remove</b>
         $ar-&gt;remove(@filenames)
         $ar-&gt;remove($arrayref)

       Removes files from the in-memory archive.  Returns the number of files removed.

   <b>list_files</b>
         @filenames = $ar-&gt;list_files()

       Returns a list of the names of all the files in the archive.  If called in a scalar  context,  returns  a
       reference to an array.

   <b>add_files</b>
         $ar-&gt;add_files(@filenames)
         $ar-&gt;add_files($arrayref)

       Adds files to the archive.  The arguments can be paths, but only the filenames are stored in the archive.
       Stores the uid, gid, mode, size, and modification timestamp of the file as returned by "stat()".

       Returns the number of files successfully added, or undef if failure.

   <b>add_data</b>
         $ar-&gt;add_data("filename", $data)
         $ar-&gt;add_data("filename", $data, $options)

       Adds  a  file to the in-memory archive with name $filename and content $data.  File properties can be set
       with $optional_hashref:

         $options = {
             'data' =&gt; $data,
             'uid' =&gt; $uid,    #defaults to zero
             'gid' =&gt; $gid,    #defaults to zero
             'date' =&gt; $date,  #date in epoch seconds. Defaults to now.
             'mode' =&gt; $mode,  #defaults to 0100644;
         }

       You cannot add_data over another file  however.   This  returns  the  file  length  in  bytes  if  it  is
       successful, undef otherwise.

   <b>write</b>
         $data = $ar-&gt;write()
         $len = $ar-&gt;write($filename)

       Returns  the  archive  as  a  string,  or  writes it to disk as $filename.  Returns the archive size upon
       success when writing to disk.  Returns undef if failure.

   <b>get_content</b>
         $content = $ar-&gt;get_content($filename)

       This returns a hash with the file content in it, including the data that the file would contain.  If  the
       file does not exist or no filename is given, this returns undef. On success, a hash is returned:

           $content = {
               'name' =&gt; $filename,
               'date' =&gt; $mtime,
               'uid' =&gt; $uid,
               'gid' =&gt; $gid,
               'mode' =&gt; $mode,
               'size' =&gt; $size,
               'data' =&gt; $file_contents,
           }

   <b>get_data</b>
         $data = $ar-&gt;get_data("filename")

       Returns a scalar containing the file data of the given archive member.  Upon error, returns undef.

   <b>get_handle</b>
         $handle = $ar-&gt;get_handle("filename")&gt;

       Returns a file handle to the in-memory file data of the given archive member.  Upon error, returns undef.
       This can be useful for unpacking nested archives.  Uses IO::String if it's loaded.

   <b>error</b>
         $errstr = $ar-&gt;error($trace)

       Returns the current error string, which is usually the last error reported.  If a true value is provided,
       returns the error message and stack trace.

</pre><h4><b>BUGS</b></h4><pre>
       See https://github.com/jbazik/Archive-Ar/issues/ to report and view bugs.

</pre><h4><b>SOURCE</b></h4><pre>
       The source code repository for Archive::Ar can be found at <a href="http://github.com/jbazik/Archive-Ar/">http://github.com/jbazik/Archive-Ar/</a>.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2009-2014 John Bazik &lt;<a href="mailto:jbazik@cpan.org">jbazik@cpan.org</a>&gt;.

       Copyright 2003 Jay Bonci &lt;<a href="mailto:jaybonci@cpan.org">jaybonci@cpan.org</a>&gt;.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

       See <a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a>

perl v5.36.0                                       2022-10-13                                   <u>Archive::<a href="../man3pm/Ar.3pm.html">Ar</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>