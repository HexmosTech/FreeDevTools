<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>archive_write_open,       archive_write_open2,       archive_write_open_fd,      archive_write_open_FILE,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libarchive-dev">libarchive-dev_3.7.7-0ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       archive_write_open,       archive_write_open2,       archive_write_open_fd,      archive_write_open_FILE,
       archive_write_open_filename, archive_write_open_memory — functions for creating archives

</pre><h4><b>LIBRARY</b></h4><pre>
       Streaming Archive Library (libarchive, -larchive)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;archive.h&gt;</b>

       <u>int</u>
       <b>archive_write_open</b>(<u>struct</u> <u>archive</u> <u>*</u>,             <u>void</u> <u>*client_data</u>,              <u>archive_open_callback</u> <u>*</u>,
           <u>archive_write_callback</u> <u>*</u>, <u>archive_close_callback</u> <u>*</u>);

       <u>int</u>
       <b>archive_write_open2</b>(<u>struct</u> <u>archive</u> <u>*</u>,             <u>void</u> <u>*client_data</u>,             <u>archive_open_callback</u> <u>*</u>,
           <u>archive_write_callback</u> <u>*</u>, <u>archive_close_callback</u> <u>*</u>, <u>archive_free_callback</u> <u>*</u>);

       <u>int</u>
       <b>archive_write_open_fd</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>int</u> <u>fd</u>);

       <u>int</u>
       <b>archive_write_open_FILE</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>FILE</u> <u>*file</u>);

       <u>int</u>
       <b>archive_write_open_filename</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>const</u> <u>char</u> <u>*filename</u>);

       <u>int</u>
       <b>archive_write_open_memory</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>void</u> <u>*buffer</u>, <u>size_t</u> <u>bufferSize</u>, <u>size_t</u> <u>*outUsed</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>archive_write_open</b>()
               Freeze the settings, open the archive, and prepare for writing entries.  This is the most generic
               form of this function, which accepts pointers to three callback functions which will  be  invoked
               by  the  compression  layer  to  write  the constructed archive.  This does not alter the default
               archive padding.

       <b>archive_write_open2</b>()
               Same as <b>archive_write_open</b>() with an additional fourth free callback.  This  function  should  be
               preferred to <b>archive_write_open</b>().

       <b>archive_write_open_fd</b>()
               A   convenience   form   of   <b>archive_write_open</b>()   that   accepts   a   file  descriptor.   The
               <b>archive_write_open_fd</b>() function is safe  for  use  with  tape  drives  or  other  block-oriented
               devices.

       <b>archive_write_open_FILE</b>()
               A   convenience  form  of  <b>archive_write_open</b>()  that  accepts  a  <u>FILE</u>  <u>*</u>  pointer.   Note  that
               <b>archive_write_open_FILE</b>() is not safe for writing to tape drives or other  devices  that  require
               correct blocking.

       <b>archive_write_open_file</b>()
               A deprecated synonym for <b>archive_write_open_filename</b>().

       <b>archive_write_open_filename</b>()
               A  convenience  form  of <b>archive_write_open</b>() that accepts a filename.  A NULL argument indicates
               that the output should be written to standard output; an argument of “-” will open  a  file  with
               that   name.    If   you   have   not   invoked   <b>archive_write_set_bytes_in_last_block</b>(),   then
               <b>archive_write_open_filename</b>() will adjust the last-block padding depending on the file:  it  will
               enable  padding  when  writing to standard output or to a character or block device node, it will
               disable    padding    otherwise.     You    can    override    this    by    manually    invoking
               <b>archive_write_set_bytes_in_last_block</b>()     before     calling     <b>archive_write_open2</b>().     The
               <b>archive_write_open_filename</b>() function is safe for use with tape drives or  other  block-oriented
               devices.

       <b>archive_write_open_memory</b>()
               A convenience form of <b>archive_write_open2</b>() that accepts a pointer to a block of memory that will
               receive the archive.  The final <u>size_t</u> <u>*</u> argument points to a variable that will be updated after
               each  write  to  reflect  how  much  of the buffer is currently in use.  You should be careful to
               ensure that this variable remains allocated until after the archive  is  closed.   This  function
               will disable padding unless you have specifically set the block size.
       More  information  about  the <u>struct</u> <u>archive</u> object and the overall design of the library can be found in
       the <u><a href="../man3/libarchive.3.html">libarchive</a></u>(3) overview.

       Note that the convenience forms above vary in how they block the output.  See  <u><a href="../man3/archive_write_blocksize.3.html">archive_write_blocksize</a></u>(3)
       if you need to control the block size used for writes or the end-of-file padding behavior.

</pre><h4><b>CLIENT</b> <b>CALLBACKS</b></h4><pre>
       To  use  this  library,  you  will need to define and register callback functions that will be invoked to
       write data to the resulting archive.  These functions are registered by calling <b>archive_write_open2</b>():

             <u>typedef</u> <u>int</u> <b>archive_open_callback</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>void</u> <u>*client_data</u>)

       The open callback is invoked by <b>archive_write_open</b>().  It should return <b>ARCHIVE_OK</b> if the underlying file
       or data source is successfully opened.  If the open fails, it should call <b>archive_set_error</b>() to register
       an error code and message and return <b>ARCHIVE_FATAL</b>.  Please note that if open fails, close is not  called
       and resources must be freed inside the open callback or with the free callback.

             <u>typedef</u>  <u>la_ssize_t</u> <b>archive_write_callback</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>void</u> <u>*client_data</u>, <u>const</u> <u>void</u> <u>*buffer</u>,
             <u>size_t</u> <u>length</u>)

       The write callback is invoked whenever the library needs to write raw bytes to the archive.  For  correct
       blocking,  each  call to the write callback function should translate into a single <u><a href="../man2/write.2.html">write</a></u>(2) system call.
       This is especially critical when writing archives to tape drives.  On success, the write callback  should
       return the number of bytes actually written.  On error, the callback should invoke <b>archive_set_error</b>() to
       register an error code and message and return -1.

             <u>typedef</u> <u>int</u> <b>archive_close_callback</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>void</u> <u>*client_data</u>)

       The  close  callback  is  invoked  by  archive_close when the archive processing is complete. If the open
       callback fails, the close callback is not invoked.  The callback should return <b>ARCHIVE_OK</b> on success.  On
       failure, the callback should invoke <b>archive_set_error</b>() to register an error code and message and  return
       <b>ARCHIVE_FATAL</b>.

             <u>typedef</u> <u>int</u> <b>archive_free_callback</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>void</u> <u>*client_data</u>)

       The free callback is always invoked on archive_free.  The return code of this callback is not processed.

       Note  that  if  the  client-provided write callback function returns a non-zero value, that error will be
       propagated back to the caller through whatever API function resulted in  that  call,  which  may  include
       <b>archive_write_header</b>(),    <b>archive_write_data</b>(),    <b>archive_write_close</b>(),   <b>archive_write_finish</b>(),   or
       <b>archive_write_free</b>().  The client callback can call <b>archive_set_error</b>() to provide values that  can  then
       be retrieved by <b>archive_errno</b>() and <b>archive_error_string</b>().

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       These functions return <b>ARCHIVE_OK</b> on success, or <b>ARCHIVE_FATAL</b>.

</pre><h4><b>ERRORS</b></h4><pre>
       Detailed   error   codes   and   textual   descriptions   are  available  from  the  <b>archive_errno</b>()  and
       <b>archive_error_string</b>() functions.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/tar.1.html">tar</a></u>(1), <u><a href="../man3/archive_write.3.html">archive_write</a></u>(3), <u><a href="../man3/archive_write_blocksize.3.html">archive_write_blocksize</a></u>(3),  <u><a href="../man3/archive_write_filter.3.html">archive_write_filter</a></u>(3),  <u><a href="../man3/archive_write_format.3.html">archive_write_format</a></u>(3),
       <u><a href="../man3/archive_write_new.3.html">archive_write_new</a></u>(3), <u><a href="../man3/archive_write_set_options.3.html">archive_write_set_options</a></u>(3), <u><a href="../man3/libarchive.3.html">libarchive</a></u>(3), <u><a href="../man5/cpio.5.html">cpio</a></u>(5), <u><a href="../man5/mtree.5.html">mtree</a></u>(5), <u><a href="../man5/tar.5.html">tar</a></u>(5)

Debian                                          November 12, 2020                          <u><a href="../man3/ARCHIVE_WRITE_OPEN.3.html">ARCHIVE_WRITE_OPEN</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>