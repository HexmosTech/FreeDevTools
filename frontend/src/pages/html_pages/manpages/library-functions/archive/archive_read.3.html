<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>archive_read — functions for reading streaming archives</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libarchive-dev">libarchive-dev_3.7.7-0ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       archive_read — functions for reading streaming archives

</pre><h4><b>LIBRARY</b></h4><pre>
       Streaming Archive Library (libarchive, -larchive)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;archive.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  functions  provide a complete API for reading streaming archives.  The general process is to first
       create the struct archive object, set options, initialize the reader, iterate over  the  archive  headers
       and associated data, then close the archive and release all resources.

   <b>Create</b> <b>archive</b> <b>object</b>
       See <u><a href="../man3/archive_read_new.3.html">archive_read_new</a></u>(3).

       To read an archive, you must first obtain an initialized struct archive object from <b>archive_read_new</b>().

   <b>Enable</b> <b>filters</b> <b>and</b> <b>formats</b>
       See <u><a href="../man3/archive_read_filter.3.html">archive_read_filter</a></u>(3) and <u><a href="../man3/archive_read_format.3.html">archive_read_format</a></u>(3).

       You  can  then  modify this object for the desired operations with the various <b>archive_read_set_XXX</b>() and
       <b>archive_read_support_XXX</b>()  functions.   In   particular,   you   will   need   to   invoke   appropriate
       <b>archive_read_support_XXX</b>()  functions  to  enable the corresponding compression and format support.  Note
       that these latter functions perform two distinct operations: they cause the corresponding support code to
       be linked into your program, and they  enable  the  corresponding  auto-detect  code.   Unless  you  have
       specific   constraints,   you   will  generally  want  to  invoke  <b>archive_read_support_filter_all</b>()  and
       <b>archive_read_support_format_all</b>() to enable auto-detect for all formats and compression  types  currently
       supported by the library.

   <b>Set</b> <b>options</b>
       See <u><a href="../man3/archive_read_set_options.3.html">archive_read_set_options</a></u>(3).

   <b>Open</b> <b>archive</b>
       See <u><a href="../man3/archive_read_open.3.html">archive_read_open</a></u>(3).

       Once  you  have  prepared  the  struct  archive object, you call <b>archive_read_open</b>() to actually open the
       archive and prepare it for reading.  There are several variants of this function; the most basic  expects
       you  to  provide  pointers to several functions that can provide blocks of bytes from the archive.  There
       are convenience forms that allow you to specify a filename, file descriptor, <u>FILE</u> <u>*</u> object, or a block of
       memory from which to read the archive data.  Note that the core library makes no  assumptions  about  the
       size  of the blocks read; callback functions are free to read whatever block size is most appropriate for
       the medium.

   <b>Consume</b> <b>archive</b>
       See <u><a href="../man3/archive_read_header.3.html">archive_read_header</a></u>(3), <u><a href="../man3/archive_read_data.3.html">archive_read_data</a></u>(3) and <u><a href="../man3/archive_read_extract.3.html">archive_read_extract</a></u>(3).

       Each archive entry consists of a header followed by a certain amount of data.  You can  obtain  the  next
       header with <b>archive_read_next_header</b>(), which returns a pointer to an struct archive_entry structure with
       information  about  the current archive element.  If the entry is a regular file, then the header will be
       followed by the file data.  You can use <b>archive_read_data</b>() (which works much  like  the  <u><a href="../man2/read.2.html">read</a></u>(2)  system
       call)  to  read  this  data from the archive, or <b>archive_read_data_block</b>() which provides a slightly more
       efficient interface.  You may prefer to use the higher-level <b>archive_read_data_skip</b>(),  which  reads  and
       discards the data for this entry, <b>archive_read_data_into_fd</b>(), which copies the data to the provided file
       descriptor,  or  <b>archive_read_extract</b>(), which recreates the specified entry on disk and copies data from
       the archive.  In particular, note that <b>archive_read_extract</b>() uses  the  struct  archive_entry  structure
       that  you  provide  it,  which may differ from the entry just read from the archive.  In particular, many
       applications will want to override the pathname, file permissions, or ownership.

   <b>Release</b> <b>resources</b>
       See <u><a href="../man3/archive_read_free.3.html">archive_read_free</a></u>(3).

       Once you have finished reading data from the archive, you should call <b>archive_read_close</b>() to  close  the
       archive,  then  call  <b>archive_read_free</b>() to release all resources, including all memory allocated by the
       library.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following illustrates basic usage of the library.  In this example, the callback functions are simply
       wrappers around the standard <u><a href="../man2/open.2.html">open</a></u>(2), <u><a href="../man2/read.2.html">read</a></u>(2), and <u><a href="../man2/close.2.html">close</a></u>(2) system calls.

             void
             list_archive(const char *name)
             {
               struct mydata *mydata;
               struct archive *a;
               struct archive_entry *entry;

               mydata = malloc(sizeof(struct mydata));
               a = archive_read_new();
               mydata-&gt;name = name;
               archive_read_support_filter_all(a);
               archive_read_support_format_all(a);
               archive_read_open(a, mydata, myopen, myread, myclose);
               while (archive_read_next_header(a, &amp;entry) == ARCHIVE_OK) {
                 printf("%s\n",archive_entry_pathname(entry));
                 archive_read_data_skip(a);
               }
               archive_read_free(a);
               <a href="../manmydata/free.mydata.html">free</a>(mydata);
             }

             la_ssize_t
             myread(struct archive *a, void *client_data, const void **buff)
             {
               struct mydata *mydata = client_data;

               *buff = mydata-&gt;buff;
               return (read(mydata-&gt;fd, mydata-&gt;buff, 10240));
             }

             int
             myopen(struct archive *a, void *client_data)
             {
               struct mydata *mydata = client_data;

               mydata-&gt;fd = open(mydata-&gt;name, O_RDONLY);
               return (mydata-&gt;fd &gt;= 0 ? ARCHIVE_OK : ARCHIVE_FATAL);
             }

             int
             myclose(struct archive *a, void *client_data)
             {
               struct mydata *mydata = client_data;

               if (mydata-&gt;fd &gt; 0)
                 close(mydata-&gt;fd);
               return (ARCHIVE_OK);
             }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/tar.1.html">tar</a></u>(1), <u><a href="../man3/archive_read_data.3.html">archive_read_data</a></u>(3),  <u><a href="../man3/archive_read_extract.3.html">archive_read_extract</a></u>(3),  <u><a href="../man3/archive_read_filter.3.html">archive_read_filter</a></u>(3),  <u><a href="../man3/archive_read_format.3.html">archive_read_format</a></u>(3),
       <u><a href="../man3/archive_read_header.3.html">archive_read_header</a></u>(3),     <u><a href="../man3/archive_read_new.3.html">archive_read_new</a></u>(3),    <u><a href="../man3/archive_read_open.3.html">archive_read_open</a></u>(3),    <u><a href="../man3/archive_read_set_options.3.html">archive_read_set_options</a></u>(3),
       <u><a href="../man3/archive_util.3.html">archive_util</a></u>(3), <u><a href="../man3/libarchive.3.html">libarchive</a></u>(3), <u><a href="../man5/tar.5.html">tar</a></u>(5)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>libarchive</b> library first appeared in FreeBSD 5.3.

</pre><h4><b>AUTHORS</b></h4><pre>
       The <b>libarchive</b> library was written by Tim Kientzle &lt;<a href="mailto:kientzle@acm.org">kientzle@acm.org</a>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       Many traditional archiver programs treat  empty  files  as  valid  empty  archives.   For  example,  many
       implementations  of  <u><a href="../man1/tar.1.html">tar</a></u>(1) allow you to append entries to an empty file.  Of course, it is impossible to
       determine the format of an empty file by inspecting the contents, so this library treats empty  files  as
       having a special “empty” format.

Debian                                          February 2, 2012                                 <u><a href="../man3/ARCHIVE_READ.3.html">ARCHIVE_READ</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>