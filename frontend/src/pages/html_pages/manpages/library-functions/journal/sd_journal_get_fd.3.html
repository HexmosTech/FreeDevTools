<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sd_journal_get_fd, sd_journal_get_events, sd_journal_get_timeout, sd_journal_process, sd_journal_wait,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsystemd-dev">libsystemd-dev_257.7-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sd_journal_get_fd, sd_journal_get_events, sd_journal_get_timeout, sd_journal_process, sd_journal_wait,
       sd_journal_reliable_fd, SD_JOURNAL_NOP, SD_JOURNAL_APPEND, SD_JOURNAL_INVALIDATE - Journal change
       notification interface

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;systemd/sd-journal.h&gt;</b>

       <b>int</b> <b>sd_journal_get_fd(sd_journal</b> <b>*</b><u>j</u><b>);</b>

       <b>int</b> <b>sd_journal_get_events(sd_journal</b> <b>*</b><u>j</u><b>);</b>

       <b>int</b> <b>sd_journal_get_timeout(sd_journal</b> <b>*</b><u>j</u><b>,</b> <b>uint64_t</b> <b>*</b><u>timeout_usec</u><b>);</b>

       <b>int</b> <b>sd_journal_process(sd_journal</b> <b>*</b><u>j</u><b>);</b>

       <b>int</b> <b>sd_journal_wait(sd_journal</b> <b>*</b><u>j</u><b>,</b> <b>uint64_t</b> <u>timeout_usec</u><b>);</b>

       <b>int</b> <b>sd_journal_reliable_fd(sd_journal</b> <b>*</b><u>j</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>sd_journal_get_fd()</b> returns a file descriptor that may be asynchronously polled in an external event loop
       and is signaled as soon as the journal changes, because new entries or files were added, rotation took
       place, or files have been deleted, and similar. The file descriptor is suitable for usage in <b><a href="../man2/poll.2.html">poll</a></b>(2). Use
       <b>sd_journal_get_events()</b> for an events mask to watch for. The call takes one argument: the journal context
       object. Note that not all file systems are capable of generating the necessary events for wakeups from
       this file descriptor for changes to be noticed immediately. In particular network files systems do not
       generate suitable file change events in all cases. Cases like this can be detected with
       <b>sd_journal_reliable_fd()</b>, below.  <b>sd_journal_get_timeout()</b> will ensure in these cases that wake-ups
       happen frequently enough for changes to be noticed, although with a certain latency.

       <b>sd_journal_get_events()</b> will return the <b>poll()</b> mask to wait for. This function will return a combination
       of <b>POLLIN</b> and <b>POLLOUT</b> and similar to fill into the ".events" field of <u>struct</u> <u>pollfd</u>.

       <b>sd_journal_get_timeout()</b> will return a timeout value for usage in <b>poll()</b>. This returns a value in
       microseconds since the epoch of <b>CLOCK_MONOTONIC</b> for timing out <b>poll()</b> in <u>timeout_usec</u>. See
       <b><a href="../man2/clock_gettime.2.html">clock_gettime</a></b>(2) for details about <b>CLOCK_MONOTONIC</b>. If there is no timeout to wait for, this will fill in
       <b>(uint64_t)</b> <b>-1</b> instead. Note that <b>poll()</b> takes a relative timeout in milliseconds rather than an absolute
       timeout in microseconds. To convert the absolute 'us' timeout into relative 'ms', use code like the
       following:

           uint64_t t;
           int msec;
           sd_journal_get_timeout(m, &amp;t);
           if (t == (uint64_t) -1)
             msec = -1;
           else {
             struct timespec ts;
             uint64_t n;
             clock_gettime(CLOCK_MONOTONIC, &amp;ts);
             n = (uint64_t) ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
             msec = t &gt; n ? (int) ((t - n + 999) / 1000) : 0;
           }

       The code above does not do any error checking for brevity's sake. The calculated <u>msec</u> integer can be
       passed directly as <b>poll()</b>'s timeout parameter.

       After each <b>poll()</b> wake-up <b>sd_journal_process()</b> needs to be called to process events. This call will also
       indicate what kind of change has been detected (see below; note that spurious wake-ups are possible).

       A synchronous alternative for using <b>sd_journal_get_fd()</b>, <b>sd_journal_get_events()</b>,
       <b>sd_journal_get_timeout()</b> and <b>sd_journal_process()</b> is <b>sd_journal_wait()</b>. It will synchronously wait until
       the journal gets changed. The maximum time this call sleeps may be controlled with the <u>timeout_usec</u>
       parameter. Pass <b>(uint64_t)</b> <b>-1</b> to wait indefinitely. Internally this call simply combines
       <b>sd_journal_get_fd()</b>, <b>sd_journal_get_events()</b>, <b>sd_journal_get_timeout()</b>, <b>poll()</b> and <b>sd_journal_process()</b>
       into one.

       <b>sd_journal_reliable_fd()</b> may be used to check whether the wake-up events from the file descriptor
       returned by <b>sd_journal_get_fd()</b> are known to be quickly triggered. On certain file systems where file
       change events from the OS are not available (such as NFS) changes need to be polled for repeatedly, and
       hence are detected only with a considerable latency. This call will return a positive value if the
       journal changes are detected quickly and zero when they need to be polled for. Note that there is usually
       no need to invoke this function directly as <b>sd_journal_get_timeout()</b> will request appropriate timeouts
       anyway.

       Note that all of the above change notification interfaces do not report changes instantly. Latencies are
       introduced for multiple reasons: as mentioned certain storage backends require time-based polling, in
       other cases wake-ups are optimized by coalescing events, and the OS introduces additional IO/CPU
       scheduling latencies.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>sd_journal_get_fd()</b> returns a valid file descriptor on success or a negative errno-style error code.

       <b>sd_journal_get_events()</b> returns a combination of <b>POLLIN</b>, <b>POLLOUT</b> and suchlike on success or a negative
       errno-style error code.

       <b>sd_journal_reliable_fd()</b> returns a positive integer if the file descriptor returned by
       <b>sd_journal_get_fd()</b> will generate wake-ups immediately for all journal changes. Returns 0 if there might
       be a latency involved.

       <b>sd_journal_process()</b> and <b>sd_journal_wait()</b> return a negative errno-style error code, or one of
       <b>SD_JOURNAL_NOP</b>, <b>SD_JOURNAL_APPEND</b> or <b>SD_JOURNAL_INVALIDATE</b> on success:

       •   If <b>SD_JOURNAL_NOP</b> is returned, the journal did not change since the last invocation.

       •   If <b>SD_JOURNAL_APPEND</b> is returned, new entries have been appended to the end of the journal. In this
           case, it is sufficient to simply continue reading at the previous end location of the journal, to
           read the newly added entries.

       •   If <b>SD_JOURNAL_INVALIDATE</b>, journal files were added to or removed from the set of journal files
           watched (e.g. due to rotation or vacuuming), and thus entries might have appeared or disappeared at
           arbitrary places in the log stream, possibly before or after the previous end of the log stream. If
           <b>SD_JOURNAL_INVALIDATE</b> is returned, live-view UIs that want to reflect on screen the precise state of
           the log data on disk should probably refresh their entire display (relative to the cursor of the log
           entry on the top of the screen). Programs only interested in a strictly sequential stream of log data
           may treat <b>SD_JOURNAL_INVALIDATE</b> the same way as <b>SD_JOURNAL_APPEND</b>, thus ignoring any changes to the
           log view earlier than the old end of the log stream.

</pre><h4><b>SIGNAL</b> <b>SAFETY</b></h4><pre>
       In general, <b>sd_journal_get_fd()</b>, <b>sd_journal_get_events()</b>, and <b>sd_journal_get_timeout()</b> are <u>not</u> "async
       signal safe" in the meaning of <b><a href="../man7/signal-safety.7.html">signal-safety</a></b>(7). Nevertheless, only the first call to any of those three
       functions performs unsafe operations, so subsequent calls <u>are</u> safe.

       <b>sd_journal_process()</b> and <b>sd_journal_wait()</b> are not safe.  <b>sd_journal_reliable_fd()</b> is safe.

</pre><h4><b>NOTES</b></h4><pre>
       All functions listed here are thread-agnostic and only a single specific thread may operate on a given
       object during its entire lifetime. It is safe to allocate multiple independent objects and use each from
       a specific thread in parallel. However, it is not safe to allocate such an object in one thread, and
       operate or free it from any other, even if locking is used to ensure these threads do not operate on it
       at the very same time.

       Functions described here are available as a shared library, which can be compiled against and linked to
       with the <b>libsystemd</b> <b><a href="../man1/pkg-config.1.html">pkg-config</a></b>(1) file.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Iterating through the journal, in a live view tracking all changes:

           /* SPDX-License-Identifier: MIT-0 */

           #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;systemd/sd-journal.h&gt;

           int main(int argc, char *argv[]) {
             int r;
             sd_journal *j;

             r = sd_journal_open(&amp;j, SD_JOURNAL_LOCAL_ONLY);
             if (r &lt; 0) {
               fprintf(stderr, "Failed to open journal: %s\n", strerror(-r));
               return 1;
             }

             for (;;)  {
               const void *d;
               size_t l;
               r = sd_journal_next(j);
               if (r &lt; 0) {
                 fprintf(stderr, "Failed to iterate to next entry: %s\n", strerror(-r));
                 break;
               }
               if (r == 0) {
                 /* Reached the end, let's wait for changes, and try again */
                 r = sd_journal_wait(j, (uint64_t) -1);
                 if (r &lt; 0) {
                   fprintf(stderr, "Failed to wait for changes: %s\n", strerror(-r));
                   break;
                 }
                 continue;
               }
               r = sd_journal_get_data(j, "MESSAGE", &amp;d, &amp;l);
               if (r &lt; 0) {
                 fprintf(stderr, "Failed to read message field: %s\n", strerror(-r));
                 continue;
               }
               printf("%.*s\n", (int) l, (const char*) d);
             }

             sd_journal_close(j);
             return 0;
           }

       Waiting with <b>poll()</b> (this example lacks all error checking for the sake of simplicity):

           /* SPDX-License-Identifier: MIT-0 */

           #define _GNU_SOURCE 1
           #include &lt;<a href="file:/usr/include/poll.h">poll.h</a>&gt;
           #include &lt;<a href="file:/usr/include/time.h">time.h</a>&gt;
           #include &lt;systemd/sd-journal.h&gt;

           int wait_for_changes(sd_journal *j) {
             uint64_t t;
             int msec;
             struct pollfd pollfd;

             sd_journal_get_timeout(j, &amp;t);
             if (t == (uint64_t) -1)
               msec = -1;
             else {
               struct timespec ts;
               uint64_t n;
               clock_gettime(CLOCK_MONOTONIC, &amp;ts);
               n = (uint64_t) ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
               msec = t &gt; n ? (int) ((t - n + 999) / 1000) : 0;
             }

             pollfd.fd = sd_journal_get_fd(j);
             pollfd.events = sd_journal_get_events(j);
             poll(&amp;pollfd, 1, msec);
             return sd_journal_process(j);
           }

</pre><h4><b>HISTORY</b></h4><pre>
       <b>sd_journal_get_fd()</b>, <b>sd_journal_process()</b>, and <b>sd_journal_wait()</b> were added in version 187.

       <b>sd_journal_reliable_fd()</b> was added in version 196.

       <b>sd_journal_get_events()</b> and <b>sd_journal_get_timeout()</b> were added in version 201.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/systemd.1.html">systemd</a></b>(1), <b><a href="../man3/sd-journal.3.html">sd-journal</a></b>(3), <b><a href="../man3/sd_journal_open.3.html">sd_journal_open</a></b>(3), <b><a href="../man3/sd_journal_next.3.html">sd_journal_next</a></b>(3), <b><a href="../man2/poll.2.html">poll</a></b>(2), <b><a href="../man2/clock_gettime.2.html">clock_gettime</a></b>(2)

systemd 257.7                                                                               <u><a href="../man3/SD_JOURNAL_GET_FD.3.html">SD_JOURNAL_GET_FD</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>