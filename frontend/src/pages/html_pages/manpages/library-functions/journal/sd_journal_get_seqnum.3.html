<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sd_journal_get_seqnum - Read sequence number from the current journal entry</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsystemd-dev">libsystemd-dev_257.7-1ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sd_journal_get_seqnum - Read sequence number from the current journal entry

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;systemd/sd-journal.h&gt;</b>

       <b>int</b> <b>sd_journal_get_seqnum(sd_journal</b> <b>*</b><u>j</u><b>,</b> <b>uint64_t</b> <b>*</b><u>ret_seqnum</u><b>,</b> <b>sd_id128_t</b> <b>*</b><u>ret_seqnum_id</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>sd_journal_get_seqnum()</b> returns the sequence number of the current journal entry. It takes three
       arguments: the journal context object, a pointer to a 64-bit unsigned integer to store the sequence
       number in, and a buffer to return the 128-bit sequence number ID in.

       When writing journal entries to disk each <b>systemd-journald</b> instance will number them sequentially,
       starting from 1 for the first entry written after subsystem initialization. Each such series of sequence
       numbers is associated with a 128-bit sequence number ID which is initialized randomly, once at
       <b>systemd-journal</b> initialization. Thus, while multiple instances of <b>systemd-journald</b> will assign the same
       sequence numbers to their written journal entries, they will have a distinct sequence number IDs. The
       sequence number is assigned at the moment of writing the entry to disk. If log entries are rewritten (for
       example because the volatile logs from <a href="file:/run/log/">/run/log/</a> are flushed to <a href="file:/var/log/">/var/log/</a> via
       systemd-journald-flush.service) they will get new sequence numbers assigned.

       Sequence numbers may be used to order entries (entries associated with the same sequence number ID and
       lower sequence numbers should be ordered chronologically before those with higher sequence numbers), and
       to detect lost entries. Note that journal service instances typically write to multiple journal files in
       parallel (for example because <u>SplitMode=</u> is used), in which case each journal file will only contain a
       subset of the sequence numbers. To recover the full stream of journal entries the files must be combined
       ("interleaved"), a process that primarily relies on the sequence numbers. When journal files are rotated
       (due to size or time limits), the series of sequence numbers is continued in the replacement files. All
       journal files generated from the same journal instance will carry the same sequence number ID.

       As the sequence numbers are assigned at the moment of writing the journal entries to disk they do not
       exist if storage is disabled via <u>SplitMode=</u>.

       The <u>ret_seqnum</u> and <u>ret_seqnum_id</u> parameters may be specified as <b>NULL</b> in which case the relevant data is
       not returned (but the call will otherwise succeed).

       Note that these functions will not work before <b><a href="../man3/sd_journal_next.3.html">sd_journal_next</a></b>(3) (or related call) has been called at
       least once, in order to position the read pointer at a valid entry.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>sd_journal_get_seqnum()</b> returns 0 on success or a negative errno-style error code..

</pre><h4><b>NOTES</b></h4><pre>
       All functions listed here are thread-agnostic and only a single specific thread may operate on a given
       object during its entire lifetime. It is safe to allocate multiple independent objects and use each from
       a specific thread in parallel. However, it is not safe to allocate such an object in one thread, and
       operate or free it from any other, even if locking is used to ensure these threads do not operate on it
       at the very same time.

       Functions described here are available as a shared library, which can be compiled against and linked to
       with the <b>libsystemd</b> <b><a href="../man1/pkg-config.1.html">pkg-config</a></b>(1) file.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>sd_journal_get_seqnum()</b> was added in version 254.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/systemd.1.html">systemd</a></b>(1), <b><a href="../man3/sd-journal.3.html">sd-journal</a></b>(3), <b><a href="../man3/sd_journal_open.3.html">sd_journal_open</a></b>(3), <b><a href="../man3/sd_journal_next.3.html">sd_journal_next</a></b>(3), <b><a href="../man3/sd_journal_get_data.3.html">sd_journal_get_data</a></b>(3),
       <b><a href="../man3/sd_journal_get_monotonic_usec.3.html">sd_journal_get_monotonic_usec</a></b>(3)

systemd 257.7                                                                           <u><a href="../man3/SD_JOURNAL_GET_SEQNUM.3.html">SD_JOURNAL_GET_SEQNUM</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>