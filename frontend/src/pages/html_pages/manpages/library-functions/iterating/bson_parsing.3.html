<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bson_parsing - Parsing and Iterating BSON Documents</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libbson-doc">libbson-doc_1.21.0-1build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       bson_parsing - Parsing and Iterating BSON Documents

</pre><h4><b>PARSING</b></h4><pre>
       BSON  documents are lazily parsed as necessary. To begin parsing a BSON document, use one of the provided
       Libbson functions to create a new <b>bson_t</b> from existing data such as <b>bson_new_from_data()</b>. This will  make
       a copy of the data so that additional mutations may occur to the BSON document.

       <b>TIP:</b>
          If  you  only  want  to  parse  a  BSON  document  and  have  no  need  to  mutate  it,  you  may  use
          <b>bson_init_static()</b> to avoid making a copy of the data.

          bson_t *b;

          b = bson_new_from_data (my_data, my_data_len);
          if (!b) {
             fprintf (stderr, "The specified length embedded in &lt;my_data&gt; did not match "
                              "&lt;my_data_len&gt;\n");
             return;
          }

          bson_destroy (b);

       Only two checks are performed when creating a new <b>bson_t</b> from an existing  buffer.  First,  the  document
       must  begin  with  the buffer length, matching what was expected by the caller. Second, the document must
       end with the expected trailing <b>\0</b> byte.

       To parse the document further we use a <b>bson_iter_t</b> to iterate the elements  within  the  document.  Let's
       print all of the field names in the document.

          bson_t *b;
          bson_iter_t iter;

          if ((b = bson_new_from_data (my_data, my_data_len))) {
             if (bson_iter_init (&amp;iter, b)) {
                while (bson_iter_next (&amp;iter)) {
                   printf ("Found element key: \"%s\"\n", bson_iter_key (&amp;iter));
                }
             }
             bson_destroy (b);
          }

       Converting  a  document  to  JSON  uses  a <b>bson_iter_t</b> and <b>bson_visitor_t</b> to iterate all fields of a BSON
       document recursively and generate a UTF-8 encoded JSON string.

          bson_t *b;
          char *json;

          if ((b = bson_new_from_data (my_data, my_data_len))) {
             if ((json = bson_as_canonical_extended_json (b, NULL))) {
                printf ("%s\n", json);
                bson_free (json);
             }
             bson_destroy (b);
          }

</pre><h4><b>RECURSING</b> <b>INTO</b> <b>SUB-DOCUMENTS</b></h4><pre>
       Libbson provides convenient sub-iterators to dive down into a sub-document  or  sub-array.  Below  is  an
       example that will dive into a sub-document named "foo" and print it's field names.

          bson_iter_t iter;
          bson_iter_t child;
          char *json;

          if (bson_iter_init_find (&amp;iter, doc, "foo") &amp;&amp;
              BSON_ITER_HOLDS_DOCUMENT (&amp;iter) &amp;&amp; bson_iter_recurse (&amp;iter, &amp;child)) {
             while (bson_iter_next (&amp;child)) {
                printf ("Found sub-key of \"foo\" named \"%s\"\n",
                        bson_iter_key (&amp;child));
             }
          }

</pre><h4><b>FINDING</b> <b>FIELDS</b> <b>USING</b> <b>DOT</b> <b>NOTATION</b></h4><pre>
       Using  the  <b>bson_iter_recurse()</b>  function exemplified above, <b>bson_iter_find_descendant()</b> can find a field
       for you using the MongoDB style path notation such as "foo.bar.0.baz".

       Let's create a document like <b>{"foo":</b> <b>{"bar":</b> <b>[{"baz:</b> <b>1}]}}</b> and locate the <b>"baz"</b> field.

          bson_t *b;
          bson_iter_t iter;
          bson_iter_t baz;

          b =
             BCON_NEW ("foo", "{", "bar", "[", "{", "baz", BCON_INT32 (1), "}", "]", "}");

          if (bson_iter_init (&amp;iter, b) &amp;&amp;
              bson_iter_find_descendant (&amp;iter, "foo.bar.0.baz", &amp;baz) &amp;&amp;
              BSON_ITER_HOLDS_INT32 (&amp;baz)) {
             printf ("baz = %d\n", bson_iter_int32 (&amp;baz));
          }

          bson_destroy (b);

</pre><h4><b>VALIDATING</b> <b>A</b> <b>BSON</b> <b>DOCUMENT</b></h4><pre>
       If all you want to do is validate that a BSON document is valid, you can use <b>bson_validate()</b>.

          size_t err_offset;

          if (!bson_validate (doc, BSON_VALIDATE_NONE, &amp;err_offset)) {
             fprintf (stderr,
                      "The document failed to validate at offset: %u\n",
                      (unsigned) err_offset);
          }

       See the <b>bson_validate()</b> documentation for more information and examples.

</pre><h4><b>AUTHOR</b></h4><pre>
       MongoDB, Inc

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2017-present, MongoDB, Inc

1.21.0                                            Feb 09, 2022                                   <u><a href="../man3/BSON_PARSING.3.html">BSON_PARSING</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>