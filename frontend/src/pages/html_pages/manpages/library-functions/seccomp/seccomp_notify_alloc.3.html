<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>seccomp_notify_alloc,      seccomp_notify_free,      seccomp_notify_receive,      seccomp_notify_respond,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libseccomp-dev">libseccomp-dev_2.6.0-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       seccomp_notify_alloc,      seccomp_notify_free,      seccomp_notify_receive,      seccomp_notify_respond,
       seccomp_notify_id_valid, seccomp_notify_fd - Manage seccomp notifications

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;seccomp.h&gt;</b>

       <b>int</b> <b>seccomp_notify_alloc(struct</b> <b>seccomp_notif</b> <b>**</b><u>req</u><b>,</b> <b>struct</b> <b>seccomp_notif_resp</b> <b>**</b><u>resp</u><b>)</b>
       <b>void</b> <b>seccomp_notify_free(struct</b> <b>seccomp_notif</b> <b>*</b><u>req</u><b>,</b> <b>struct</b> <b>seccomp_notif_resp</b> <b>*</b><u>resp</u><b>)</b>
       <b>int</b> <b>seccomp_notify_receive(int</b> <u>fd</u><b>,</b> <b>struct</b> <b>seccomp_notif</b> <b>*</b><u>req</u><b>)</b>
       <b>int</b> <b>seccomp_notify_respond(int</b> <u>fd</u><b>,</b> <b>struct</b> <b>seccomp_notif_resp</b> <b>*</b><u>resp</u><b>)</b>
       <b>int</b> <b>seccomp_notify_id_valid(int</b> <u>fd</u><b>,</b> <b>uint64_t</b> <u>id</u><b>)</b>
       <b>int</b> <b>seccomp_notify_fd(const</b> <b>scmp_filter_ctx</b> <u>ctx</u><b>)</b>

       Link with <u>-lseccomp</u>.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>seccomp_notify_alloc</b>() function dynamically allocates enough memory for a  seccomp  notification  and
       response.  Note  that  one  should  always  use  these functions and not depend on the structure sizes in
       headers, since the size can vary depending on the kernel version. This function takes  care  to  ask  the
       kernel   how   big   each   structure   should  be,  and  allocates  the  right  amount  of  memory.  The
       <b>seccomp_notify_free</b>() function frees memory allocated by <b>seccomp_notify_alloc</b>().

       The <b>seccomp_notify_receive</b>() function receives a notification from a seccomp  notify  fd  (obtained  from
       <b>seccomp_notify_fd</b>()).

       The  <b>seccomp_notify_respond</b>() function sends a response to a particular notification. The id field should
       be the same as the id from the request, so that the kernel knows which request this response  corresponds
       to.

       The  <b>seccomp_notify_id_valid</b>()  function  checks  to  see  if  the syscall from a particular notification
       request is still valid, i.e. if the task is still alive. See NOTES below for details on race conditions.

       The <b>seccomp_notify_fd</b>() returns the notification fd of a filter after it has been loaded.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The <b>seccomp_notify_fd</b>() returns the notification fd of the loaded filter, -1 if a notification fd has not
       yet been created, and -EINVAL if the filter context is invalid.

       The <b>seccomp_notify_id_valid</b>() returns 0 if the id is valid, and -ENOENT if it is not.

       The <b>seccomp_notify_alloc</b>(), <b>seccomp_notify_receive</b>(), and <b>seccomp_notify_respond</b>() functions return  zero
       on success,  or one of the following error codes on failure:

       <b>-ECANCELED</b>
              There  was  a  system  failure  beyond  the control of the library, check the <u>errno</u> value for more
              information.

       <b>-EFAULT</b>
              Internal libseccomp failure.

       <b>-ENOMEM</b>
              The library was unable to allocate enough memory.

       <b>-EOPNOTSUPP</b>
              The library doesn't support the particular operation.

</pre><h4><b>NOTES</b></h4><pre>
       Care should be taken to avoid two different time of check/time of use errors.  First, after  opening  any
       resources  relevant  to the pid for a notification (e.g.  /proc/pid/mem for reading tracee memory to make
       policy decisions), applications should call <b>seccomp_notify_id_valid</b>() to make sure that the resources the
       application has opened correspond to the right pid, i.e. that the pid didn't die  and  a  different  task
       take its place.

       Second,  the  classic  time  of  check/time  of  use  issue  with  seccomp memory should also be avoided:
       applications should copy any memory they wish to use to make decisions  from  the  tracee  into  its  own
       address  space before applying any policy decisions, since a multi-threaded tracee may edit the memory at
       any time, including after it's used to make a policy decision.

       A complete example of how to avoid these two races is available  in  the  Linux  Kernel  source  tree  at
       <b>/samples/seccomp/user-trap.c.</b>

</pre><h4><b>AUTHOR</b></h4><pre>
       Tycho Andersen &lt;<a href="mailto:tycho@tycho.ws">tycho@tycho.ws</a>&gt;

<a href="mailto:tycho@tycho.ws">tycho@tycho.ws</a>                                     30 May 2020                           <u><a href="../man3/seccomp_notify_alloc.3.html">seccomp_notify_alloc</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>