<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>seccomp_rule_add, seccomp_rule_add_exact - Add a seccomp filter rule</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libseccomp-dev">libseccomp-dev_2.6.0-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       seccomp_rule_add, seccomp_rule_add_exact - Add a seccomp filter rule

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;seccomp.h&gt;</b>

       <b>typedef</b> <b>void</b> <b>*</b> <b>scmp_filter_ctx;</b>

       <b>int</b> <b>SCMP_SYS(</b><u>syscall_name</u><b>);</b>

       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_CMP(unsigned</b> <b>int</b> <u>arg</u><b>,</b>
                                    <b>enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A0(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A1(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A2(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A3(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A4(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A5(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>

       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_CMP64(unsigned</b> <b>int</b> <u>arg</u><b>,</b>
                                    <b>enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A0_64(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A1_64(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A2_64(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A3_64(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A4_64(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A5_64(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>

       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_CMP32(unsigned</b> <b>int</b> <u>arg</u><b>,</b>
                                    <b>enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A0_32(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A1_32(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A2_32(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A3_32(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A4_32(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>
       <b>struct</b> <b>scmp_arg_cmp</b> <b>SCMP_A5_32(enum</b> <b>scmp_compare</b> <u>op</u><b>,</b> <u>...</u><b>);</b>

       <b>int</b> <b>seccomp_rule_add(scmp_filter_ctx</b> <u>ctx</u><b>,</b> <b>uint32_t</b> <u>action</u><b>,</b>
                            <b>int</b> <u>syscall</u><b>,</b> <b>unsigned</b> <b>int</b> <u>arg_cnt</u><b>,</b> <u>...</u><b>);</b>
       <b>int</b> <b>seccomp_rule_add_exact(scmp_filter_ctx</b> <u>ctx</u><b>,</b> <b>uint32_t</b> <u>action</u><b>,</b>
                                  <b>int</b> <u>syscall</u><b>,</b> <b>unsigned</b> <b>int</b> <u>arg_cnt</u><b>,</b> <u>...</u><b>);</b>

       <b>int</b> <b>seccomp_rule_add_array(scmp_filter_ctx</b> <u>ctx</u><b>,</b>
                                  <b>uint32_t</b> <u>action</u><b>,</b> <b>int</b> <u>syscall</u><b>,</b>
                                  <b>unsigned</b> <b>int</b> <u>arg_cnt</u><b>,</b>
                                  <b>const</b> <b>struct</b> <b>scmp_arg_cmp</b> <b>*</b><u>arg_array</u><b>);</b>
       <b>int</b> <b>seccomp_rule_add_exact_array(scmp_filter_ctx</b> <u>ctx</u><b>,</b>
                                        <b>uint32_t</b> <u>action</u><b>,</b> <b>int</b> <u>syscall</u><b>,</b>
                                        <b>unsigned</b> <b>int</b> <u>arg_cnt</u><b>,</b>
                                        <b>const</b> <b>struct</b> <b>scmp_arg_cmp</b> <b>*</b><u>arg_array</u><b>);</b>

       Link with <u>-lseccomp</u>.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The        <b>seccomp_rule_add</b>(),        <b>seccomp_rule_add_array</b>(),       <b>seccomp_rule_add_exact</b>(),       and
       <b>seccomp_rule_add_exact_array</b>() functions all add a new filter rule to the current  seccomp  filter.   The
       <b>seccomp_rule_add</b>()  and  <b>seccomp_rule_add_array</b>()  functions will make a "best effort" to add the rule as
       specified, but may alter the rule slightly due to architecture  specifics  (e.g.  internal  rewriting  of
       multiplexed  syscalls,  like  socket  and  ipc  functions  on  x86).   The  <b>seccomp_rule_add_exact</b>()  and
       <b>seccomp_rule_add_exact_array</b>() functions will attempt to add the rule exactly  as  specified  so  it  may
       behave  differently  on  different  architectures.   While  it does not guarantee a exact filter ruleset,
       <b>seccomp_rule_add</b>() and  <b>seccomp_rule_add_array</b>()  do  guarantee  the  same  behavior  regardless  of  the
       architecture.

       The  newly added filter rule does not take effect until the entire filter is loaded into the kernel using
       <b><a href="../man3/seccomp_load.3.html">seccomp_load</a></b>(3).  When adding rules to a filter, it is important to consider  the  impact  of  previously
       loaded filters; see the <b><a href="../man3/seccomp_load.3.html">seccomp_load</a></b>(3) documentation for more information.

       All  of  the  filter rules supplied by the calling application are combined into a union, with additional
       logic to eliminate redundant syscall filters.  For example, if a rule  is  added  which  allows  a  given
       syscall  with  a  specific set of argument values and later a rule is added which allows the same syscall
       regardless the argument values then the first, more specific rule, is effectively dropped from the filter
       by the second more generic rule.

       The  <b>SCMP_CMP</b>(),  <b>SCMP_CMP64</b>(),  <b>SCMP_A{0-5}</b>(),  and  <b>SCMP_A{0-5}_64</b>()  macros  generate  a  scmp_arg_cmp
       structure  for  use with the above functions. The <b>SCMP_CMP</b>() and <b>SCMP_CMP64</b>() macros allows the caller to
       specify an arbitrary argument along with the comparison operator, 64-bit mask, and  64-bit  datum  values
       where the <b>SCMP_A{0-5}</b>() and <b>SCMP_A{0-5}_64</b>() macros are specific to a certain argument.

       The <b>SCMP_CMP32</b>() and <b>SCMP_A{0-5}_32</b>() macros are similar to the variants above, but they take 32-bit mask
       and 32-bit datum values.

       It  is  recommended that whenever possible developers avoid using the <b>SCMP_CMP</b>() and <b>SCMP_A{0-5}</b>() macros
       and use the variants which are explicitly 32 or 64-bit.  This should help eliminate problems caused by an
       unwanted sign extension of negative datum values.

       If syscall argument comparisons are included in the filter rule, all of the comparisons must be true  for
       the rule to match.

       When  adding  syscall  argument  comparisons  to  the filter it is important to remember that while it is
       possible to have multiple comparisons in a single rule, you can only compare  each  argument  once  in  a
       single  rule.   In  other  words,  you can not have multiple comparisons of the 3rd syscall argument in a
       single rule.

       In a filter containing multiple architectures, it is an error to add a filter rule  for  a  syscall  that
       does not exist in all of the filter's architectures.

       While  it  is  possible  to specify the <u>syscall</u> value directly using the standard <b>__NR_syscall</b> values, in
       order to ensure proper operation across multiple architectures  it  is  highly  recommended  to  use  the
       <b>SCMP_SYS</b>()  macro  instead.   See  the  EXAMPLES  section  below.   It is also important to remember that
       regardless of the architectures present in the filter, the syscall  numbers  used  in  filter  rules  are
       interpreted in the context of the native architecture.

       Starting  with  Linux  v4.8,  there  may  be  a need to create a rule with a syscall value of -1 to allow
       tracing programs to skip a syscall invocation; in order to create a rule with a -1 syscall  value  it  is
       necessary   to   first  set  the  <b>SCMP_FLTATR_API_TSKIP</b>  attribute.   See  <b><a href="../man3/seccomp_attr_set.3.html">seccomp_attr_set</a></b>(3)  for  more
       information.

       The filter context <u>ctx</u> is the value returned by the call to <b><a href="../man3/seccomp_init.3.html">seccomp_init</a></b>(3).

       Valid <u>action</u> values are as follows:

       <b>SCMP_ACT_KILL</b>
              The thread will be killed by the kernel when it calls a syscall that matches the filter rule.

       <b>SCMP_ACT_KILL_PROCESS</b>
              The process will be killed by the kernel when it calls a syscall that matches the filter rule.

       <b>SCMP_ACT_TRAP</b>
              The thread will throw a SIGSYS signal when it calls a syscall that matches the filter rule.

       <b>SCMP_ACT_ERRNO(uint16_t</b> <b>errno)</b>
              The thread will receive a return value of <u>errno</u> when it calls a syscall that  matches  the  filter
              rule.

       <b>SCMP_ACT_TRACE(uint16_t</b> <b>msg_num)</b>
              If  the  thread is being traced and the tracing process specified the <b>PTRACE_O_TRACESECCOMP</b> option
              in the call to <b><a href="../man2/ptrace.2.html">ptrace</a></b>(2), the tracing process will be notified, via <b>PTRACE_EVENT_SECCOMP</b> , and the
              value provided in <u>msg_num</u> can be retrieved using the <b>PTRACE_GETEVENTMSG</b> option.

       <b>SCMP_ACT_LOG</b>
              The seccomp filter will have no effect on the thread calling the syscall if it matches the  filter
              rule but the syscall will be logged.

       <b>SCMP_ACT_ALLOW</b>
              The  seccomp filter will have no effect on the thread calling the syscall if it matches the filter
              rule.

       <b>SCMP_ACT_NOTIFY</b>
              A monitoring process will be notified when a process running the seccomp filter  calls  a  syscall
              that  matches the filter rule.  The process that invokes the syscall waits in the kernel until the
              monitoring process has responded via <b>seccomp_notify_respond</b> <b>(3)</b> .

              When a filter utilizing <b>SCMP_ACT_NOTIFY</b>  is  loaded  into  the  kernel,  the  kernel  generates  a
              notification  fd  that  must  be  used  to  communicate  between  the  monitoring  process and the
              process(es) being filtered.  See <b>seccomp_notify_fd</b> <b>(3)</b> for more information.

       Valid comparison <u>op</u> values are as follows:

       <b>SCMP_CMP_NE</b>
              Matches when the argument value is not equal to the datum value, example:

              SCMP_CMP( <u>arg</u> , SCMP_CMP_NE , <u>datum</u> )

       <b>SCMP_CMP_LT</b>
              Matches when the argument value is less than the datum value, example:

              SCMP_CMP( <u>arg</u> , SCMP_CMP_LT , <u>datum</u> )

       <b>SCMP_CMP_LE</b>
              Matches when the argument value is less than or equal to the datum value, example:

              SCMP_CMP( <u>arg</u> , SCMP_CMP_LE , <u>datum</u> )

       <b>SCMP_CMP_EQ</b>
              Matches when the argument value is equal to the datum value, example:

              SCMP_CMP( <u>arg</u> , SCMP_CMP_EQ , <u>datum</u> )

       <b>SCMP_CMP_GE</b>
              Matches when the argument value is greater than or equal to the datum value, example:

              SCMP_CMP( <u>arg</u> , SCMP_CMP_GE , <u>datum</u> )

       <b>SCMP_CMP_GT</b>
              Matches when the argument value is greater than the datum value, example:

              SCMP_CMP( <u>arg</u> , SCMP_CMP_GT , <u>datum</u> )

       <b>SCMP_CMP_MASKED_EQ</b>
              Matches when the masked argument value is equal to the masked datum value, example:

              SCMP_CMP( <u>arg</u> , SCMP_CMP_MASKED_EQ , <u>mask</u> , <u>datum</u> )

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The <b>SCMP_SYS</b>() macro returns a value suitable for use as the <u>syscall</u>  value  in  the  <b>seccomp_rule_add*</b>()
       functions.   In  a  similar manner, the <b>SCMP_CMP</b>() and <b>SCMP_A*</b>() macros return values suitable for use as
       argument comparisons in the <b>seccomp_rule_add</b>() and <b>seccomp_rule_add_exact</b>() functions.

       The       <b>seccomp_rule_add</b>(),       <b>seccomp_rule_add_array</b>(),        <b>seccomp_rule_add_exact</b>(),        and
       <b>seccomp_rule_add_exact_array</b>()  functions  return  zero on success or one of the following error codes on
       failure:

       <b>-EDOM</b>  Architecture specific failure.

       <b>-EEXIST</b>
              The rule already exists.

       <b>-EACCES</b>
              The rule conflicts with the filter (for example, the rule <u>action</u> equals the default action of  the
              filter).

       <b>-EFAULT</b>
              Internal libseccomp failure.

       <b>-EINVAL</b>
              Invalid input, either the context or architecture token is invalid.

       <b>-ENOMEM</b>
              The library was unable to allocate enough memory.

       <b>-EOPNOTSUPP</b>
              The library doesn't support the particular operation.

</pre><h4><b>EXAMPLES</b></h4><pre>
       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;seccomp.h&gt;
       #include &lt;sys/stat.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;stddef.h&gt;

       #define BUF_SIZE    256

       int main(int argc, char *argv[])
       {
            int rc = -1;
            scmp_filter_ctx ctx;
            struct scmp_arg_cmp arg_cmp[] = { SCMP_A0(SCMP_CMP_EQ, 2) };
            int fd;
            unsigned char buf[BUF_SIZE];

            ctx = seccomp_init(SCMP_ACT_KILL);
            if (ctx == NULL)
                 goto out;

            /* ... */

            fd = open("file.txt", 0);

            /* ... */

            rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(close), 0);
            if (rc &lt; 0)
                 goto out;

            rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);
            if (rc &lt; 0)
                 goto out;

            rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
            if (rc &lt; 0)
                 goto out;

            rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 3,
                            SCMP_A0(SCMP_CMP_EQ, fd),
                            SCMP_A1(SCMP_CMP_EQ, (scmp_datum_t)buf),
                            SCMP_A2(SCMP_CMP_LE, BUF_SIZE));
            if (rc &lt; 0)
                 goto out;

            rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 1,
                            SCMP_CMP(0, SCMP_CMP_EQ, fd));
            if (rc &lt; 0)
                 goto out;

            rc = seccomp_rule_add_array(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 1,
                                  arg_cmp);
            if (rc &lt; 0)
                 goto out;

            rc = seccomp_load(ctx);
            if (rc &lt; 0)
                 goto out;

            /* ... */

       out:
            seccomp_release(ctx);
            return -rc;
       }

</pre><h4><b>NOTES</b></h4><pre>
       While  the  seccomp filter can be generated independent of the kernel, kernel support is required to load
       and enforce the seccomp filter generated by libseccomp.

       The libseccomp project site, with more information and the  source  code  repository,  can  be  found  at
       https://github.com/seccomp/libseccomp.   This tool, as well as the libseccomp library, is currently under
       development, please report any bugs at the project site or directly to the author.

</pre><h4><b>BUGS</b></h4><pre>
       The runtime behavior of seccomp filters is dependent upon the kernel version, the processor architecture,
       and other libraries including libc.  This could affect the return code of a seccomp filter.

       <b>*</b>      PowerPC glibc will not return a negative number when  the  <b>getpid()</b>  syscall  is  invoked.   If  a
              seccomp filter has been created where <b>getpid()</b> will return a negative number from the kernel, then
              PowerPC glibc will return the absolute value of the errno.  In this case, it is very difficult for
              an application to distinguish between the errno and a valid pid.

</pre><h4><b>AUTHOR</b></h4><pre>
       Paul Moore &lt;<a href="mailto:paul@paul-moore.com">paul@paul-moore.com</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/seccomp_syscall_resolve_name_rewrite.3.html">seccomp_syscall_resolve_name_rewrite</a></b>(3),           <b><a href="../man3/seccomp_syscall_priority.3.html">seccomp_syscall_priority</a></b>(3),          <b><a href="../man3/seccomp_load.3.html">seccomp_load</a></b>(3),
       <b><a href="../man3/seccomp_attr_set.3.html">seccomp_attr_set</a></b>(3)

<a href="mailto:paul@paul-moore.com">paul@paul-moore.com</a>                                30 May 2020                               <u><a href="../man3/seccomp_rule_add.3.html">seccomp_rule_add</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>