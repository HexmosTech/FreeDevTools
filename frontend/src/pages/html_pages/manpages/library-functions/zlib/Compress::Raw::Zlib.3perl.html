<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compress::Raw::Zlib - Low-Level Interface to zlib or zlib-ng compression library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Compress::Raw::Zlib - Low-Level Interface to zlib or zlib-ng compression library

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Compress::Raw::Zlib ;

           ($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) ;
           $status = $d-&gt;deflate($input, $output) ;
           $status = $d-&gt;flush($output [, $flush_type]) ;
           $d-&gt;deflateReset() ;
           $d-&gt;deflateParams(OPTS) ;
           $d-&gt;deflateTune(OPTS) ;
           $d-&gt;dict_adler() ;
           $d-&gt;crc32() ;
           $d-&gt;adler32() ;
           $d-&gt;total_in() ;
           $d-&gt;total_out() ;
           $d-&gt;msg() ;
           $d-&gt;get_Strategy();
           $d-&gt;get_Level();
           $d-&gt;get_BufSize();

           ($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) ;
           $status = $i-&gt;inflate($input, $output [, $eof]) ;
           $status = $i-&gt;inflateSync($input) ;
           $i-&gt;inflateReset() ;
           $i-&gt;dict_adler() ;
           $d-&gt;crc32() ;
           $d-&gt;adler32() ;
           $i-&gt;total_in() ;
           $i-&gt;total_out() ;
           $i-&gt;msg() ;
           $d-&gt;get_BufSize();

           $crc = adler32($buffer [,$crc]) ;
           $crc = crc32($buffer [,$crc]) ;

           $crc = crc32_combine($crc1, $crc2, $len2);
           $adler = adler32_combine($adler1, $adler2, $len2);

           my $version = Compress::Raw::Zlib::zlib_version();
           my $flags = Compress::Raw::Zlib::zlibCompileFlags();

           is_zlib_native();
           is_zlibng_native();
           is_zlibng_compat();
           is_zlibng();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>Compress::Raw::Zlib</u> module provides a Perl interface to the <u>zlib</u> or <u>zlib-ng</u> compression libraries
       (see "SEE ALSO" for details about where to get <u>zlib</u> or <u>zlib-ng</u>).

       In the text below all references to <u>zlib</u> are also applicable to <u>zlib-ng</u> unless otherwise stated.

</pre><h4><b>Compress::Raw::Zlib::Deflate</b></h4><pre>
       This section defines an interface that allows in-memory compression using the <u>deflate</u> interface provided
       by zlib.

       Here is a definition of the interface available:

   <b>($d,</b> <b>$status)</b> <b>=</b> <b>new</b> <b>Compress::Raw::Zlib::Deflate(</b> <b>[OPT]</b> <b>)</b>
       Initialises a deflation object.

       If you are familiar with the <u>zlib</u> library, it combines the features of the <u>zlib</u> functions "deflateInit",
       "deflateInit2" and "deflateSetDictionary".

       If successful, it will return the initialised deflation object, $d and a $status of "Z_OK" in a list
       context. In scalar context it returns the deflation object, $d, only.

       If not successful, the returned deflation object, $d, will be <u>undef</u> and $status will hold the a <u>zlib</u>
       error code.

       The function optionally takes a number of named options specified as "Name =&gt; value" pairs. This allows
       individual options to be tailored without having to specify them all in the parameter list.

       For backward compatibility, it is also possible to pass the parameters as a reference to a hash
       containing the name=&gt;value pairs.

       Below is a list of the valid options:

       <b>-Level</b>
            Defines  the  compression  level.  Valid values are 0 through 9, "Z_NO_COMPRESSION", "Z_BEST_SPEED",
            "Z_BEST_COMPRESSION", and "Z_DEFAULT_COMPRESSION".

            The default is "Z_DEFAULT_COMPRESSION".

       <b>-Method</b>
            Defines the compression method. The only valid value at present (and the default) is "Z_DEFLATED".

       <b>-WindowBits</b>
            To compress an RFC 1950 data stream, set "WindowBits" to a positive number between 8 and 15.

            To compress an RFC 1951 data stream, set "WindowBits" to "-MAX_WBITS".

            To compress an RFC 1952 data stream (i.e. gzip), set "WindowBits" to "WANT_GZIP".

            For a definition of the meaning and valid values for "WindowBits" refer to  the  <u>zlib</u>  documentation
            for <u>deflateInit2</u>.

            Defaults to "MAX_WBITS".

       <b>-MemLevel</b>
            For  a definition of the meaning and valid values for "MemLevel" refer to the <u>zlib</u> documentation for
            <u>deflateInit2</u>.

            Defaults to MAX_MEM_LEVEL.

       <b>-Strategy</b>
            Defines the strategy used to tune  the  compression.  The  valid  values  are  "Z_DEFAULT_STRATEGY",
            "Z_FILTERED", "Z_RLE", "Z_FIXED" and "Z_HUFFMAN_ONLY".

            The default is "Z_DEFAULT_STRATEGY".

       <b>-Dictionary</b>
            When  a  dictionary  is specified <u>Compress::Raw::Zlib</u> will automatically call "deflateSetDictionary"
            directly after calling "deflateInit". The Adler32 value  for  the  dictionary  can  be  obtained  by
            calling the method "$d-&gt;dict_adler()".

            The default is no dictionary.

       <b>-Bufsize</b>
            Sets  the  initial  size for the output buffer used by the "$d-&gt;deflate" and "$d-&gt;flush" methods. If
            the buffer has to be reallocated to increase the size, it will grow in increments of "Bufsize".

            The default buffer size is 4096.

       <b>-AppendOutput</b>
            This option controls how data is written to the output buffer by the "$d-&gt;deflate"  and  "$d-&gt;flush"
            methods.

            If  the  "AppendOutput"  option  is  set  to  false,  the  output  buffers  in the "$d-&gt;deflate" and
            "$d-&gt;flush"  methods will be truncated before uncompressed data is written to them.

            If the option is set to true, uncompressed data will  be  appended  to  the  output  buffer  in  the
            "$d-&gt;deflate" and "$d-&gt;flush" methods.

            This option defaults to false.

       <b>-CRC32</b>
            If  set  to  true, a crc32 checksum of the uncompressed data will be calculated. Use the "$d-&gt;crc32"
            method to retrieve this value.

            This option defaults to false.

       <b>-ADLER32</b>
            If set to true,  an  adler32  checksum  of  the  uncompressed  data  will  be  calculated.  Use  the
            "$d-&gt;adler32" method to retrieve this value.

            This option defaults to false.

       Here  is  an  example of using the "Compress::Raw::Zlib::Deflate" optional parameter list to override the
       default buffer size and compression level. All other options will take their default values.

           my $d = new Compress::Raw::Zlib::Deflate ( -Bufsize =&gt; 300,
                                                      -Level   =&gt; Z_BEST_SPEED ) ;

   <b>$status</b> <b>=</b> <b>$d-&gt;deflate($input,</b> <b>$output)</b>
       Deflates the contents of $input and writes the compressed data to $output.

       The $input and $output parameters can be either scalars or scalar references.

       When finished, $input will be completely processed (assuming there were no errors). If the deflation  was
       successful it writes the deflated data to $output and returns a status value of "Z_OK".

       On error, it returns a <u>zlib</u> error code.

       If  the  "AppendOutput"  option  is set to true in the constructor for the $d object, the compressed data
       will be appended to $output. If it is false, $output will be truncated  before  any  compressed  data  is
       written to it.

       <b>Note</b>:  This  method  will not necessarily write compressed data to $output every time it is called. So do
       not assume that there has been an error if the contents of  $output  is  empty  on  returning  from  this
       method. As long as the return code from the method is "Z_OK", the deflate has succeeded.

   <b>$status</b> <b>=</b> <b>$d-&gt;flush($output</b> <b>[,</b> <b>$flush_type])</b>
       Typically used to finish the deflation. Any pending output will be written to $output.

       Returns "Z_OK" if successful.

       Note  that flushing can seriously degrade the compression ratio, so it should only be used to terminate a
       decompression (using "Z_FINISH") or when you want to create a <u>full</u> <u>flush</u> <u>point</u> (using "Z_FULL_FLUSH").

       By default the "flush_type" used is "Z_FINISH". Other valid values  for  "flush_type"  are  "Z_NO_FLUSH",
       "Z_PARTIAL_FLUSH",  "Z_SYNC_FLUSH"  and  "Z_FULL_FLUSH". It is strongly recommended that you only set the
       "flush_type" parameter if you fully  understand  the  implications  of  what  it  does.  See  the  "zlib"
       documentation for details.

       If  the  "AppendOutput"  option  is set to true in the constructor for the $d object, the compressed data
       will be appended to $output. If it is false, $output will be truncated  before  any  compressed  data  is
       written to it.

   <b>$status</b> <b>=</b> <b>$d-&gt;deflateReset()</b>
       This  method  will  reset  the deflation object $d. It can be used when you are compressing multiple data
       streams and want to use the same object to compress each of  them.  It  should  only  be  used  once  the
       previous  data  stream  has  been flushed successfully, i.e. a call to "$d-&gt;flush(Z_FINISH)" has returned
       "Z_OK".

       Returns "Z_OK" if successful.

   <b>$status</b> <b>=</b> <b>$d-&gt;deflateParams([OPT])</b>
       Change settings for the deflate object $d.

       The list of the valid options is shown below. Options not specified will remain unchanged.

       <b>-Level</b>
            Defines the compression level. Valid values are 0  through  9,  "Z_NO_COMPRESSION",  "Z_BEST_SPEED",
            "Z_BEST_COMPRESSION", and "Z_DEFAULT_COMPRESSION".

       <b>-Strategy</b>
            Defines  the  strategy  used  to  tune  the  compression. The valid values are "Z_DEFAULT_STRATEGY",
            "Z_FILTERED" and "Z_HUFFMAN_ONLY".

       <b>-BufSize</b>
            Sets the initial size for the output buffer used by the "$d-&gt;deflate" and  "$d-&gt;flush"  methods.  If
            the buffer has to be reallocated to increase the size, it will grow in increments of "Bufsize".

   <b>$status</b> <b>=</b> <b>$d-&gt;deflateTune($good_length,</b> <b>$max_lazy,</b> <b>$nice_length,</b> <b>$max_chain)</b>
       Tune  the  internal  settings for the deflate object $d. This option is only available if you are running
       zlib 1.2.2.3 or better.

       Refer to the documentation in zlib.h for instructions on how to fly "deflateTune".

   <b>$d-&gt;dict_adler()</b>
       Returns the adler32 value for the dictionary.

   <b>$d-&gt;crc32()</b>
       Returns the crc32 value for the uncompressed data to date.

       If the "CRC32" option is not enabled in the constructor for this object, this method will  always  return
       0;

   <b>$d-&gt;adler32()</b>
       Returns the adler32 value for the uncompressed data to date.

   <b>$d-&gt;msg()</b>
       Returns the last error message generated by zlib.

   <b>$d-&gt;total_in()</b>
       Returns the total number of bytes uncompressed bytes input to deflate.

   <b>$d-&gt;total_out()</b>
       Returns the total number of compressed bytes output from deflate.

   <b>$d-&gt;get_Strategy()</b>
       Returns  the  deflation  strategy currently used. Valid values are "Z_DEFAULT_STRATEGY", "Z_FILTERED" and
       "Z_HUFFMAN_ONLY".

   <b>$d-&gt;get_Level()</b>
       Returns the compression level being used.

   <b>$d-&gt;get_BufSize()</b>
       Returns the buffer size used to carry out the compression.

   <b>Example</b>
       Here is a trivial example of using "deflate". It simply reads standard input, deflates it and  writes  it
       to standard output.

           use strict ;
           use warnings ;

           use Compress::Raw::Zlib ;

           binmode STDIN;
           binmode STDOUT;
           my $x = new Compress::Raw::Zlib::Deflate
              or die "Cannot create a deflation stream\n" ;

           my ($output, $status) ;
           while (&lt;&gt;)
           {
               $status = $x-&gt;deflate($_, $output) ;

               $status == Z_OK
                   or die "deflation failed\n" ;

               print $output ;
           }

           $status = $x-&gt;flush($output) ;

           $status == Z_OK
               or die "deflation failed\n" ;

           print $output ;

</pre><h4><b>Compress::Raw::Zlib::Inflate</b></h4><pre>
       This  section  defines  an  interface  that  allows  in-memory  uncompression using the <u>inflate</u> interface
       provided by zlib.

       Here is a definition of the interface:

    <b>($i,</b> <b>$status)</b> <b>=</b> <b>new</b> <b>Compress::Raw::Zlib::Inflate(</b> <b>[OPT]</b> <b>)</b>
       Initialises an inflation object.

       In a list context it returns the inflation object, $i, and the <u>zlib</u> status code ($status).  In  a  scalar
       context it returns the inflation object only.

       If successful, $i will hold the inflation object and $status will be "Z_OK".

       If not successful, $i will be <u>undef</u> and $status will hold the <u>zlib</u> error code.

       The  function optionally takes a number of named options specified as "-Name =&gt; value" pairs. This allows
       individual options to be tailored without having to specify them all in the parameter list.

       For backward compatibility, it is also possible  to  pass  the  parameters  as  a  reference  to  a  hash
       containing the "name=&gt;value" pairs.

       Here is a list of the valid options:

       <b>-WindowBits</b>
            To uncompress an RFC 1950 data stream, set "WindowBits" to a positive number between 8 and 15.

            To uncompress an RFC 1951 data stream, set "WindowBits" to "-MAX_WBITS".

            To uncompress an RFC 1952 data stream (i.e. gzip), set "WindowBits" to "WANT_GZIP".

            To  auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e.  gzip), set "WindowBits" to
            "WANT_GZIP_OR_ZLIB".

            For a full definition  of  the  meaning  and  valid  values  for  "WindowBits"  refer  to  the  <u>zlib</u>
            documentation for <u>inflateInit2</u>.

            Defaults to "MAX_WBITS".

       <b>-Bufsize</b>
            Sets  the  initial size for the output buffer used by the "$i-&gt;inflate" method. If the output buffer
            in this method has to be reallocated to increase the size, it will grow in increments of "Bufsize".

            Default is 4096.

       <b>-Dictionary</b>
            The default is no dictionary.

       <b>-AppendOutput</b>
            This option controls how data is written to the output buffer by the "$i-&gt;inflate" method.

            If the option is set to false, the output buffer in  the  "$i-&gt;inflate"  method  will  be  truncated
            before uncompressed data is written to it.

            If  the  option  is  set  to  true,  uncompressed  data will be appended to the output buffer by the
            "$i-&gt;inflate" method.

            This option defaults to false.

       <b>-CRC32</b>
            If set to true, a crc32 checksum of the uncompressed data will be calculated.  Use  the  "$i-&gt;crc32"
            method to retrieve this value.

            This option defaults to false.

       <b>-ADLER32</b>
            If  set  to  true,  an  adler32  checksum  of  the  uncompressed  data  will  be calculated. Use the
            "$i-&gt;adler32" method to retrieve this value.

            This option defaults to false.

       <b>-ConsumeInput</b>
            If set to true, this option will remove compressed data from the input buffer of  the  "$i-&gt;inflate"
            method as the inflate progresses.

            This  option  can  be  useful  when  you  are processing compressed data that is embedded in another
            file/buffer. In this case the data that immediately follows the compressed stream will  be  left  in
            the input buffer.

            This option defaults to true.

       <b>-LimitOutput</b>
            The  "LimitOutput"  option  changes  the  behavior of the "$i-&gt;inflate" method so that the amount of
            memory used by the output buffer can be limited.

            When "LimitOutput" is used the size of the output buffer used  will  either  be  the  value  of  the
            "Bufsize"  option  or  the  amount  of  memory  already  allocated  to $output, whichever is larger.
            Predicting the output size available is tricky, so don't rely on  getting  an  exact  output  buffer
            size.

            When  "LimitOutout"  is not specified "$i-&gt;inflate" will use as much memory as it takes to write all
            the uncompressed data it creates by uncompressing the input buffer.

            If "LimitOutput" is enabled, the "ConsumeInput" option will also be enabled.

            This option defaults to false.

            See "The LimitOutput option" for a discussion on why "LimitOutput" is needed and how to use it.

       Here is an example of using an optional parameter to override the default buffer size.

           my ($i, $status) = new Compress::Raw::Zlib::Inflate( -Bufsize =&gt; 300 ) ;

    <b>$status</b> <b>=</b> <b>$i-&gt;inflate($input,</b> <b>$output</b> <b>[,$eof])</b>
       Inflates the complete contents of $input and writes the uncompressed data  to  $output.  The  $input  and
       $output parameters can either be scalars or scalar references.

       Returns  "Z_OK"  if successful and "Z_STREAM_END" if the end of the compressed data has been successfully
       reached.

       If not successful $status will hold the <u>zlib</u> error code.

       If the "ConsumeInput" option has been set to  true  when  the  "Compress::Raw::Zlib::Inflate"  object  is
       created, the $input parameter is modified by "inflate". On completion it will contain what remains of the
       input  buffer  after  inflation. In practice, this means that when the return status is "Z_OK" the $input
       parameter will contain an empty string, and when the return status is "Z_STREAM_END" the $input parameter
       will contains what (if anything) was stored in the input buffer after the deflated data stream.

       This feature is useful when processing a file format that encapsulates a  compressed  data  stream  (e.g.
       gzip, zip) and there is useful data immediately after the deflation stream.

       If  the  "AppendOutput"  option  is set to true in the constructor for this object, the uncompressed data
       will be appended to $output. If it is false, $output will be truncated before any  uncompressed  data  is
       written to it.

       The $eof parameter needs a bit of explanation.

       Prior  to  version  1.2.0,  zlib  assumed that there was at least one trailing byte immediately after the
       compressed data stream when it was carrying out decompression. This normally isn't a problem because  the
       majority  of  zlib  applications  guarantee  that  there  will be data directly after the compressed data
       stream.  For example, both gzip (RFC 1950) and zip both define trailing data that follows the  compressed
       data stream.

       The $eof parameter only needs to be used if <b>all</b> of the following conditions apply

       1.   You  are  either  using a copy of zlib that is older than version 1.2.0 or you want your application
            code to be able to run with as many different versions of zlib as possible.

       2.   You have set the "WindowBits" parameter to "-MAX_WBITS" in the constructor for this object, i.e. you
            are uncompressing a raw deflated data stream (RFC 1951).

       3.   There is no data immediately after the compressed data stream.

       If <b>all</b> of these are the case, then you need to set the $eof parameter to true on the final call (and only
       the final call) to "$i-&gt;inflate".

       If you have built this module with zlib &gt;= 1.2.0, the $eof parameter is ignored. You can still set it  if
       you want, but it won't be used behind the scenes.

   <b>$status</b> <b>=</b> <b>$i-&gt;inflateSync($input)</b>
       This  method  can be used to attempt to recover good data from a compressed data stream that is partially
       corrupt.  It scans $input until it reaches either a <u>full</u> <u>flush</u> <u>point</u> or the end of the buffer.

       If a <u>full</u> <u>flush</u> <u>point</u> is found, "Z_OK" is returned and $input will be have all data up to the flush point
       removed. This data can then be passed to the "$i-&gt;inflate" method to be uncompressed.

       Any other return code means that a flush point was not found. If more data  is  available,  "inflateSync"
       can be called repeatedly with more compressed data until the flush point is found.

       Note  <u>full</u>  <u>flush</u> <u>points</u> are not present by default in compressed data streams. They must have been added
       explicitly when the data stream was created by calling "Compress::Deflate::flush"  with "Z_FULL_FLUSH".

   <b>$status</b> <b>=</b> <b>$i-&gt;inflateReset()</b>
       This method will reset the inflation object $i. It can be used when you are uncompressing  multiple  data
       streams and want to use the same object to uncompress each of them.

       Returns "Z_OK" if successful.

   <b>$i-&gt;dict_adler()</b>
       Returns the adler32 value for the dictionary.

   <b>$i-&gt;crc32()</b>
       Returns the crc32 value for the uncompressed data to date.

       If  the  "CRC32" option is not enabled in the constructor for this object, this method will always return
       0;

   <b>$i-&gt;adler32()</b>
       Returns the adler32 value for the uncompressed data to date.

       If the "ADLER32" option is not enabled in the constructor for this object, this method will always return
       0;

   <b>$i-&gt;msg()</b>
       Returns the last error message generated by zlib.

   <b>$i-&gt;total_in()</b>
       Returns the total number of bytes compressed bytes input to inflate.

   <b>$i-&gt;total_out()</b>
       Returns the total number of uncompressed bytes output from inflate.

   <b>$d-&gt;get_BufSize()</b>
       Returns the buffer size used to carry out the decompression.

   <b>Examples</b>
       Here is an example of using "inflate".

           use strict ;
           use warnings ;

           use Compress::Raw::Zlib;

           my $x = new Compress::Raw::Zlib::Inflate()
              or die "Cannot create a inflation stream\n" ;

           my $input = '' ;
           binmode STDIN;
           binmode STDOUT;

           my ($output, $status) ;
           while (read(STDIN, $input, 4096))
           {
               $status = $x-&gt;inflate($input, $output) ;

               print $output ;

               last if $status != Z_OK ;
           }

           die "inflation failed\n"
               unless $status == Z_STREAM_END ;

       The next example show how to use the "LimitOutput" option. Notice the use of two  nested  loops  in  this
       case.  The  outer  loop  reads the data from the input source - STDIN and the inner loop repeatedly calls
       "inflate" until $input is exhausted, we get an error, or the end of the  stream  is  reached.  One  point
       worth  remembering  is  by  using the "LimitOutput" option you also get "ConsumeInput" set as well - this
       makes the code below much simpler.

           use strict ;
           use warnings ;

           use Compress::Raw::Zlib;

           my $x = new Compress::Raw::Zlib::Inflate(LimitOutput =&gt; 1)
              or die "Cannot create a inflation stream\n" ;

           my $input = '' ;
           binmode STDIN;
           binmode STDOUT;

           my ($output, $status) ;

         OUTER:
           while (read(STDIN, $input, 4096))
           {
               do
               {
                   $status = $x-&gt;inflate($input, $output) ;

                   print $output ;

                   last OUTER
                       unless $status == Z_OK || $status == Z_BUF_ERROR ;
               }
               while length $input;
           }

           die "inflation failed\n"
               unless $status == Z_STREAM_END ;

</pre><h4><b>CHECKSUM</b> <b>FUNCTIONS</b></h4><pre>
       Two functions are provided by <u>zlib</u> to calculate checksums. For the Perl interface, the order of  the  two
       parameters  in  both  functions  has  been  reversed.  This  allows  both  running  checksums and one off
       calculations to be done.

           $crc = adler32($buffer [,$crc]) ;
           $crc = crc32($buffer [,$crc]) ;

       The buffer parameters can either be a scalar or a scalar reference.

       If the $crc parameters is "undef", the crc value will be reset.

       If you have built this module with zlib 1.2.3 or better, two more CRC-related functions are available.

           $crc = crc32_combine($crc1, $crc2, $len2);
           $adler = adler32_combine($adler1, $adler2, $len2);

       These functions allow checksums to be merged.  Refer to the <u>zlib</u> documentation for more details.

</pre><h4><b>Misc</b></h4><pre>
   <b>my</b> <b>$version</b> <b>=</b> <b>Compress::Raw::Zlib::zlib_version();</b>
       Returns the version of the <u>zlib</u> library if this module has been built with the  <u>zlib</u>  library.   If  this
       module  has  been  built  with <u>zlib-ng</u> in native mode, this function will return a empty string.  If this
       module has been built with <u>zlib-ng</u> in compat mode, this function will return the Izlib&gt; API  verion  that
       <u>zlib-ng</u> is supporting.

   <b>my</b> <b>$version</b> <b>=</b> <b>Compress::Raw::Zlib::zlibng_version();</b>
       Returns  the  version  of the zlib-ng library if this module has been built with the <u>zlib-ng</u> library.  If
       this module has been built with <u>zlib</u>, this function will return a empty string.

   <b>my</b> <b>$flags</b> <b>=</b> <b>Compress::Raw::Zlib::zlibCompileFlags();</b>
       Returns the flags indicating compile-time options that were used to build the zlib  or  zlib-ng  library.
       See the zlib documentation for a description of the flags returned by "zlibCompileFlags".

       Note that when the zlib sources are built along with this module the "sprintf" flags (bits 24, 25 and 26)
       should be ignored.

       If you are using zlib 1.2.0 or older, "zlibCompileFlags" will return 0.

   <b>is_zlib_native();</b> <b>=head2</b> <b>is_zlibng_native();</b> <b>=head2</b> <b>is_zlibng_compat();</b> <b>=head2</b> <b>is_zlibng();</b>
       These function can use used to check if "Compress::Raw::Zlib" was been built with <u>zlib</u> or <u>zlib-ng</u>.

       The  function  "is_zlib_native"  returns true if "Compress::Raw::Zlib" was built with <u>zlib</u>.  The function
       "is_zlibng" returns true if "Compress::Raw::Zlib" was built with <u>zlib-ng</u>.

       The <u>zlib-ng</u> library has an option to build with a zlib-compataible API.  The c&lt;is_zlibng_compat&gt; function
       retuens true if zlib-ng has ben built with this API.

       Finally, "is_zlibng_native" returns true if <u>zlib-ng</u> was built with its native API.

</pre><h4><b>The</b> <b>LimitOutput</b> <b>option.</b></h4><pre>
       By default "$i-&gt;inflate($input, $output)" will uncompress <u>all</u>  data  in  $input  and  write  <u>all</u>  of  the
       uncompressed  data  it  has generated to $output. This makes the interface to "inflate" much simpler - if
       the method has uncompressed $input successfully <u>all</u> compressed data in $input will have been dealt  with.
       So  if you are reading from an input source and uncompressing as you go the code will look something like
       this

           use strict ;
           use warnings ;

           use Compress::Raw::Zlib;

           my $x = new Compress::Raw::Zlib::Inflate()
              or die "Cannot create a inflation stream\n" ;

           my $input = '' ;

           my ($output, $status) ;
           while (read(STDIN, $input, 4096))
           {
               $status = $x-&gt;inflate($input, $output) ;

               print $output ;

               last if $status != Z_OK ;
           }

           die "inflation failed\n"
               unless $status == Z_STREAM_END ;

       The points to note are

       •    The main processing loop in the code handles reading of compressed data from STDIN.

       •    The status code returned from "inflate" will only trigger termination of the main processing loop if
            it isn't "Z_OK". When "LimitOutput" has not been used the "Z_OK" status means that the  end  of  the
            compressed data stream has been reached or there has been an error in uncompression.

       •    After  the  call  to "inflate" <u>all</u> of the uncompressed data in $input will have been processed. This
            means the subsequent call to "read" can overwrite it's contents without any problem.

       For most use-cases the behavior  described  above  is  acceptable  (this  module  and  it's  predecessor,
       "Compress::Zlib",  have used it for over 10 years without an issue), but in a few very specific use-cases
       the amount of memory required for $output can prohibitively large. For example, if  the  compressed  data
       stream  contains  the same pattern repeated thousands of times, a relatively small compressed data stream
       can uncompress into hundreds of megabytes.  Remember "inflate" will keep allocating memory until <u>all</u>  the
       uncompressed data has been written to the output buffer - the size of $output is unbounded.

       The "LimitOutput" option is designed to help with this use-case.

       The  main  difference in your code when using "LimitOutput" is having to deal with cases where the $input
       parameter still contains some uncompressed data that "inflate" hasn't  processed  yet.  The  status  code
       returned from "inflate" will be "Z_OK" if uncompression took place and "Z_BUF_ERROR" if the output buffer
       is full.

       Below is typical code that shows how to use "LimitOutput".

           use strict ;
           use warnings ;

           use Compress::Raw::Zlib;

           my $x = new Compress::Raw::Zlib::Inflate(LimitOutput =&gt; 1)
              or die "Cannot create a inflation stream\n" ;

           my $input = '' ;
           binmode STDIN;
           binmode STDOUT;

           my ($output, $status) ;

         OUTER:
           while (read(STDIN, $input, 4096))
           {
               do
               {
                   $status = $x-&gt;inflate($input, $output) ;

                   print $output ;

                   last OUTER
                       unless $status == Z_OK || $status == Z_BUF_ERROR ;
               }
               while length $input;
           }

           die "inflation failed\n"
               unless $status == Z_STREAM_END ;

       Points to note this time:

       •    There  are  now  two  nested  loops in the code: the outer loop for reading the compressed data from
            STDIN, as before; and the inner loop to carry out the uncompression.

       •    There are two exit points from the inner uncompression loop.

            Firstly when "inflate" has returned a status other than "Z_OK" or "Z_BUF_ERROR".   This  means  that
            either  the end of the compressed data stream has been reached ("Z_STREAM_END") or there is an error
            in the compressed data. In either of these cases there is no point in continuing  with  reading  the
            compressed data, so both loops are terminated.

            The  second  exit  point tests if there is any data left in the input buffer, $input - remember that
            the "ConsumeInput" option is automatically enabled when  "LimitOutput"  is  used.   When  the  input
            buffer has been exhausted, the outer loop can run again and overwrite a now empty $input.

</pre><h4><b>ACCESSING</b> <b>ZIP</b> <b>FILES</b></h4><pre>
       Although  it  is  possible (with some effort on your part) to use this module to access .zip files, there
       are other perl modules available that will do all the  hard  work  for  you.  Check  out  "Archive::Zip",
       "Archive::Zip::SimpleZip", "IO::Compress::Zip" and "IO::Uncompress::Unzip".

</pre><h4><b>FAQ</b></h4><pre>
   <b>Compatibility</b> <b>with</b> <b>Unix</b> <b>compress/uncompress.</b>
       This module is not compatible with Unix "compress".

       If you have the "uncompress" program available, you can use this to read compressed files

           open F, "uncompress -c $filename |";
           while (&lt;F&gt;)
           {
               ...

       Alternatively, if you have the "gunzip" program available, you can use this to read compressed files

           open F, "gunzip -c $filename |";
           while (&lt;F&gt;)
           {
               ...

       and this to write compress files, if you have the "compress" program available

           open F, "| compress -c $filename ";
           print F "data";
           ...
           close F ;

   <b>Accessing</b> <b>.tar.Z</b> <b>files</b>
       See previous FAQ item.

       If the "Archive::Tar" module is installed and either the "uncompress" or "gunzip" programs are available,
       you can use one of these workarounds to read ".tar.Z" files.

       Firstly with "uncompress"

           use strict;
           use warnings;
           use Archive::Tar;

           open F, "uncompress -c $filename |";
           my $tar = Archive::Tar-&gt;new(*F);
           ...

       and this with "gunzip"

           use strict;
           use warnings;
           use Archive::Tar;

           open F, "gunzip -c $filename |";
           my $tar = Archive::Tar-&gt;new(*F);
           ...

       Similarly, if the "compress" program is available, you can use this to write a ".tar.Z" file

           use strict;
           use warnings;
           use Archive::Tar;
           use IO::File;

           my $fh = new IO::File "| compress -c &gt;$filename";
           my $tar = Archive::Tar-&gt;new();
           ...
           $tar-&gt;write($fh);
           $fh-&gt;close ;

   <b>Zlib</b> <b>Library</b> <b>Version</b> <b>Support</b>
       By  default  "Compress::Raw::Zlib"  will  build with a private copy of version 1.2.5 of the zlib library.
       (See the <u>README</u> file for details of how to override this behaviour)

       If you decide to use a different version of the zlib library, you need  to  be  aware  of  the  following
       issues

       •    First off, you must have zlib 1.0.5 or better.

       •    You   need   to   have  zlib  1.2.1  or  better  if  you  want  to  use  the  "-Merge"  option  with
            "IO::Compress::Gzip", "IO::Compress::Deflate" and "IO::Compress::RawDeflate".

</pre><h4><b>CONSTANTS</b></h4><pre>
       All the <u>zlib</u> constants are automatically imported when you make use of <u>Compress::Raw::Zlib</u>.

</pre><h4><b>SUPPORT</b></h4><pre>
       General         feedback/questions/bug         reports         should         be         sent          to
       &lt;https://github.com/pmqs/Compress-Raw-Zlib/issues&gt;                     (preferred)                     or
       &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Compress-Raw-Zlib&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Compress::Zlib,        IO::Compress::Gzip,         IO::Uncompress::Gunzip,         IO::Compress::Deflate,
       IO::Uncompress::Inflate,   IO::Compress::RawDeflate,   IO::Uncompress::RawInflate,   IO::Compress::Bzip2,
       IO::Uncompress::Bunzip2,       IO::Compress::Lzma,       IO::Uncompress::UnLzma,        IO::Compress::Xz,
       IO::Uncompress::UnXz,        IO::Compress::Lzip,        IO::Uncompress::UnLzip,       IO::Compress::Lzop,
       IO::Uncompress::UnLzop,       IO::Compress::Lzf,        IO::Uncompress::UnLzf,        IO::Compress::Zstd,
       IO::Uncompress::UnZstd, IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress

       IO::Compress::FAQ

       File::GlobMapper, Archive::Zip, Archive::Tar, IO::Zlib

       For     RFC     1950,     1951     and    1952    see    &lt;https://datatracker.ietf.org/doc/html/rfc1950&gt;,
       &lt;https://datatracker.ietf.org/doc/html/rfc1951&gt; and &lt;https://datatracker.ietf.org/doc/html/rfc1952&gt;

       The <u>zlib</u> compression library was written  by  Jean-loup  Gailly  "<a href="mailto:gzip@prep.ai.mit.edu">gzip@prep.ai.mit.edu</a>"  and  Mark  Adler
       "<a href="mailto:madler@alumni.caltech.edu">madler@alumni.caltech.edu</a>".

       The primary site for the <u>zlib</u> compression library is &lt;<a href="http://www.zlib.org">http://www.zlib.org</a>&gt;.

       The primary site for the <u>zlib-ng</u> compression library is &lt;https://github.com/zlib-ng/zlib-ng&gt;.

       The primary site for gzip is &lt;<a href="http://www.gzip.org">http://www.gzip.org</a>&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       This module was written by Paul Marquess, "<a href="mailto:pmqs@cpan.org">pmqs@cpan.org</a>".

</pre><h4><b>MODIFICATION</b> <b>HISTORY</b></h4><pre>
       See the Changes file.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 2005-2024 Paul Marquess. All rights reserved.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.1                                       2025-07-27                         <u>Compress::Raw::<a href="../man3perl/Zlib.3perl.html">Zlib</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>