<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zlib - zlib compression interface.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       zlib - zlib compression interface.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  provides  an API for the zlib library (www.zlib.net). It is used to compress and decompress
       data. The data format is described by RFC 1950, RFC 1951, and RFC 1952.

       A typical (compress) usage is as follows:

       Z = zlib:open(),
       ok = zlib:deflateInit(Z,default),

       Compress = fun(end_of_data, _Cont) -&gt; [];
                     (Data, Cont) -&gt;
                        [zlib:deflate(Z, Data)|Cont(Read(),Cont)]
                  end,
       Compressed = Compress(Read(),Compress),
       Last = zlib:deflate(Z, [], finish),
       ok = zlib:deflateEnd(Z),
       zlib:close(Z),
       list_to_binary([Compressed|Last])

       In all functions errors, <u>{'EXIT',{Reason,Backtrace}}</u>, can be thrown, where <u>Reason</u> describes the error.

       Typical <u>Reason</u>s:

         <u>badarg</u>:
           Bad argument.

         <u>not_initialized</u>:
           The stream hasn't been initialized, eg. if <u>inflateInit/1</u> wasn't called prior to a call to <u>inflate/2</u>.

         <u>not_on_controlling_process</u>:
           The stream was used by a process that doesn't control it. Use <u>set_controlling_process/2</u> if  you  need
           to transfer a stream to a different process.

         <u>data_error</u>:
           The data contains errors.

         <u>stream_error</u>:
           Inconsistent stream state.

         <u>{need_dictionary,Adler32}</u>:
           See <u>inflate/2</u>.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>zstream()</b> = reference()

              A zlib stream, see <u>open/0</u>.

       <b>zlevel()</b> =
           none | default | best_compression | best_speed | 0..9

       <b>zflush()</b> = none | sync | full | finish

       <b>zmemlevel()</b> = 1..9

       <b>zmethod()</b> = deflated

       <b>zstrategy()</b> = default | filtered | huffman_only | rle

       <b>zwindowbits()</b> = -15..-8 | 8..47

              Normally in the range <u>-15..-8</u> <u>|</u> <u>8..15</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>adler32(Z,</b> <b>Data)</b> <b>-&gt;</b> <b>CheckSum</b>

              Types:

                 Z = zstream()
                 Data = iodata()
                 CheckSum = integer() &gt;= 0

              Calculates the Adler-32 checksum for <u>Data</u>.

          <b>Warning:</b>
              This function is deprecated and will be removed in a future release. Use <u>erlang:adler32/1</u> instead.

       <b>adler32(Z,</b> <b>PrevAdler,</b> <b>Data)</b> <b>-&gt;</b> <b>CheckSum</b>

              Types:

                 Z = zstream()
                 PrevAdler = integer() &gt;= 0
                 Data = iodata()
                 CheckSum = integer() &gt;= 0

              Updates  a  running  Adler-32  checksum for <u>Data</u>. If <u>Data</u> is the empty binary or the empty iolist,
              this function returns the required initial value for the checksum.

              Example:

              Crc = lists:foldl(fun(Data,Crc0) -&gt;
                                    zlib:adler32(Z, Crc0, Data),
                                end, zlib:adler32(Z,&lt;&lt; &gt;&gt;), Datas)

          <b>Warning:</b>
              This function is deprecated and will be removed in a future release. Use <u>erlang:adler32/2</u> instead.

       <b>adler32_combine(Z,</b> <b>Adler1,</b> <b>Adler2,</b> <b>Size2)</b> <b>-&gt;</b> <b>Adler</b>

              Types:

                 Z = zstream()
                 Adler = Adler1 = Adler2 = Size2 = integer() &gt;= 0

              Combines two Adler-32 checksums into one. For two binaries or iolists, <u>Data1</u> and <u>Data2</u> with  sizes
              of <u>Size1</u> and <u>Size2</u>, with Adler-32 checksums <u>Adler1</u> and <u>Adler2</u>.

              This  function  returns  the  <u>Adler</u>  checksum of <u>[Data1,Data2]</u>, requiring only <u>Adler1</u>, <u>Adler2</u>, and
              <u>Size2</u>.

          <b>Warning:</b>
              This function is deprecated and will be removed in a future release. Use  <u>erlang:adler32_combine/3</u>
              instead.

       <b>close(Z)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Z = zstream()

              Closes the stream referenced by <u>Z</u>.

       <b>compress(Data)</b> <b>-&gt;</b> <b>Compressed</b>

              Types:

                 Data = iodata()
                 Compressed = binary()

              Compresses data with zlib headers and checksum.

       <b>crc32(Z)</b> <b>-&gt;</b> <b>CRC</b>

              Types:

                 Z = zstream()
                 CRC = integer() &gt;= 0

              Gets the current calculated CRC checksum.

          <b>Warning:</b>
              This  function  is  deprecated  and will be removed in a future release. Use <u>erlang:crc32/1</u> on the
              uncompressed data instead.

       <b>crc32(Z,</b> <b>Data)</b> <b>-&gt;</b> <b>CRC</b>

              Types:

                 Z = zstream()
                 Data = iodata()
                 CRC = integer() &gt;= 0

              Calculates the CRC checksum for <u>Data</u>.

          <b>Warning:</b>
              This function is deprecated and will be removed in a future release. Use <u>erlang:crc32/1</u> instead.

       <b>crc32(Z,</b> <b>PrevCRC,</b> <b>Data)</b> <b>-&gt;</b> <b>CRC</b>

              Types:

                 Z = zstream()
                 PrevCRC = integer() &gt;= 0
                 Data = iodata()
                 CRC = integer() &gt;= 0

              Updates a running CRC checksum for <u>Data</u>. If <u>Data</u> is the empty binary or  the  empty  iolist,  this
              function returns the required initial value for the CRC.

              Example:

              Crc = lists:foldl(fun(Data,Crc0) -&gt;
                                    zlib:crc32(Z, Crc0, Data),
                                end, zlib:crc32(Z,&lt;&lt; &gt;&gt;), Datas)

          <b>Warning:</b>
              This function is deprecated and will be removed in a future release. Use <u>erlang:crc32/2</u> instead.

       <b>crc32_combine(Z,</b> <b>CRC1,</b> <b>CRC2,</b> <b>Size2)</b> <b>-&gt;</b> <b>CRC</b>

              Types:

                 Z = zstream()
                 CRC = CRC1 = CRC2 = Size2 = integer() &gt;= 0

              Combines  two  CRC  checksums into one. For two binaries or iolists, <u>Data1</u> and <u>Data2</u> with sizes of
              <u>Size1</u> and <u>Size2</u>, with CRC checksums <u>CRC1</u> and <u>CRC2</u>.

              This function returns the <u>CRC</u> checksum of <u>[Data1,Data2]</u>, requiring only <u>CRC1</u>, <u>CRC2</u>, and <u>Size2</u>.

          <b>Warning:</b>
              This function is deprecated and will be removed in a future  release.  Use  <u>erlang:crc32_combine/3</u>
              instead.

       <b>deflate(Z,</b> <b>Data)</b> <b>-&gt;</b> <b>Compressed</b>

              Types:

                 Z = zstream()
                 Data = iodata()
                 Compressed = iolist()

              Same as <u>deflate(Z,</u> <u>Data,</u> <u>none)</u>.

       <b>deflate(Z,</b> <b>Data,</b> <b>Flush)</b> <b>-&gt;</b> <b>Compressed</b>

              Types:

                 Z = zstream()
                 Data = iodata()
                 Flush = zflush()
                 Compressed = iolist()

              Compresses  as  much  data  as  possible,  and  stops  when the input buffer becomes empty. It can
              introduce some output latency (reading input without producing any output) except when  forced  to
              flush.

              If  <u>Flush</u>  is  set  to  <u>sync</u>, all pending output is flushed to the output buffer and the output is
              aligned on a byte boundary, so that the decompressor can get all  input  data  available  so  far.
              Flushing  can  degrade  compression  for  some  compression  algorithms;  thus,  use  it only when
              necessary.

              If <u>Flush</u> is set to <u>full</u>, all output is flushed as with <u>sync</u>, and the compression state is reset so
              that decompression can restart from this point if previous compressed data has been damaged or  if
              random access is desired. Using <u>full</u> too often can seriously degrade the compression.

              If  <u>Flush</u>  is  set to <u>finish</u>, pending input is processed, pending output is flushed, and <u>deflate/3</u>
              returns. Afterwards the only possible operations on the stream are <u>deflateReset/1</u> or <u>deflateEnd/1</u>.

              <u>Flush</u> can be set to <u>finish</u> immediately after <u>deflateInit</u> if all compression is to be done  in  one
              step.

              Example:

              zlib:deflateInit(Z),
              B1 = zlib:deflate(Z,Data),
              B2 = zlib:deflate(Z,&lt;&lt; &gt;&gt;,finish),
              zlib:deflateEnd(Z),
              list_to_binary([B1,B2])

       <b>deflateEnd(Z)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Z = zstream()

              Ends  the  deflate session and cleans all data used. Notice that this function throws a <u>data_error</u>
              exception if the last call to <u>deflate/3</u> was not called with <u>Flush</u> set to <u>finish</u>.

       <b>deflateInit(Z)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Z = zstream()

              Same as <u>zlib:deflateInit(Z,</u> <u>default)</u>.

       <b>deflateInit(Z,</b> <b>Level)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Z = zstream()
                 Level = zlevel()

              Initializes a zlib stream for compression.

              <u>Level</u> decides the compression level to be used:

                * <u>default</u> gives default compromise between speed and compression

                * <u>none</u> (0) gives no compression

                * <u>best_speed</u> (1) gives best speed

                * <u>best_compression</u> (9) gives best compression

       <b>deflateInit(Z,</b> <b>Level,</b> <b>Method,</b> <b>WindowBits,</b> <b>MemLevel,</b> <b>Strategy)</b> <b>-&gt;</b>
                      ok

              Types:

                 Z = zstream()
                 Level = zlevel()
                 Method = zmethod()
                 WindowBits = zwindowbits()
                 MemLevel = zmemlevel()
                 Strategy = zstrategy()

              Initiates a zlib stream for compression.

                <u>Level</u>:
                  Compression level to use:

                  * <u>default</u> gives default compromise between speed and compression

                  * <u>none</u> (0) gives no compression

                  * <u>best_speed</u> (1) gives best speed

                  * <u>best_compression</u> (9) gives best compression

                <u>Method</u>:
                  Compression method to use, currently the only supported method is <u>deflated</u>.

                <u>WindowBits</u>:
                  The base two logarithm of the window size (the size of the history buffer). It is to be in the
                  range 8 through 15. Larger values result in better compression at the expense of memory usage.
                  Defaults to 15 if <u>deflateInit/2</u> is used. A  negative  <u>WindowBits</u>  value  suppresses  the  zlib
                  header  (and  checksum)  from  the stream. Notice that the zlib source mentions this only as a
                  undocumented feature.

            <b>Warning:</b>
                Due to a known bug in the underlying zlib library, <u>WindowBits</u> values 8 and -8  do  not  work  as
                expected.  In  zlib versions before 1.2.9 values 8 and -8 are automatically changed to 9 and -9.
                <u>From</u> <u>zlib</u> <u>version</u> <u>1.2.9</u> <u>value</u> <u>-8</u> <u>is</u> <u>rejected</u> causing <u>zlib:deflateInit/6</u>  to  fail  (8  is  still
                changed  to  9).  It  also seem possible that future versions of zlib may fix this bug and start
                accepting 8 and -8 as is.

                Conclusion: Avoid values 8 and -8 unless you know your zlib version supports them.

                <u>MemLevel</u>:
                  Specifies how much memory is to be allocated for the internal  compression  state:  <u>MemLevel</u>=1
                  uses  minimum memory but is slow and reduces compression ratio; <u>MemLevel</u>=9 uses maximum memory
                  for optimal speed. Defaults to 8.

                <u>Strategy</u>:
                  Tunes the compression algorithm. Use the following values:

                  * <u>default</u> for normal data

                  * <u>filtered</u> for data produced by a filter (or predictor)

                  * <u>huffman_only</u> to force Huffman encoding only (no string match)

                  * <u>rle</u> to limit match distances to one (run-length encoding)

                  Filtered data consists mostly of small values with a somewhat  random  distribution.  In  this
                  case, the compression algorithm is tuned to compress them better. The effect of <u>filtered</u> is to
                  force  more  Huffman  coding  and  less  string  matching; it is somewhat intermediate between
                  <u>default</u> and <u>huffman_only</u>. <u>rle</u> is designed to be almost as  fast  as  <u>huffman_only</u>,  but  gives
                  better compression for PNG image data.

                  <u>Strategy</u>  affects only the compression ratio, but not the correctness of the compressed output
                  even if it is not set appropriately.

       <b>deflateParams(Z,</b> <b>Level,</b> <b>Strategy)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Z = zstream()
                 Level = zlevel()
                 Strategy = zstrategy()

              Dynamically updates the compression level and compression strategy. The  interpretation  of  <u>Level</u>
              and  <u>Strategy</u>  is as in <u>deflateInit/6</u>. This can be used to switch between compression and straight
              copy of the input data, or to switch to a different kind  of  input  data  requiring  a  different
              strategy.  If  the compression level is changed, the input available so far is compressed with the
              old level (and can be flushed); the new level takes effect only at the next call of <u>deflate/3</u>.

              Before the call of <u>deflateParams</u>, the stream state must be set as for a call of <u>deflate/3</u>, as  the
              currently available input may have to be compressed and flushed.

       <b>deflateReset(Z)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Z = zstream()

              Equivalent to <u>deflateEnd/1</u> followed by <u>deflateInit/1,2,6</u>, but does not free and reallocate all the
              internal compression state. The stream keeps the same compression level and any other attributes.

       <b>deflateSetDictionary(Z,</b> <b>Dictionary)</b> <b>-&gt;</b> <b>Adler32</b>

              Types:

                 Z = zstream()
                 Dictionary = iodata()
                 Adler32 = integer() &gt;= 0

              Initializes  the  compression  dictionary  from  the specified byte sequence without producing any
              compressed output.

              This function must be called immediately after <u>deflateInit/1,2,6</u>  or  <u>deflateReset/1</u>,  before  any
              call of <u>deflate/3</u>.

              The compressor and decompressor must use the same dictionary (see <u>inflateSetDictionary/2</u>).

              The Adler checksum of the dictionary is returned.

       <b>getBufSize(Z)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Z = zstream()

              Gets the size of the intermediate buffer.

          <b>Warning:</b>
              This function is deprecated and will be removed in a future release.

       <b>gunzip(Data)</b> <b>-&gt;</b> <b>Decompressed</b>

              Types:

                 Data = iodata()
                 Decompressed = binary()

              Uncompresses data with gz headers and checksum.

       <b>gzip(Data)</b> <b>-&gt;</b> <b>Compressed</b>

              Types:

                 Data = iodata()
                 Compressed = binary()

              Compresses data with gz headers and checksum.

       <b>inflate(Z,</b> <b>Data)</b> <b>-&gt;</b> <b>Decompressed</b>

              Types:

                 Z = zstream()
                 Data = iodata()
                 Decompressed = iolist()

              Equivalent to <u>inflate(Z,</u> <u>Data,</u> <u>[])</u>

       <b>inflate(Z,</b> <b>Data,</b> <b>Options)</b> <b>-&gt;</b> <b>Decompressed</b>

              Types:

                 Z = zstream()
                 Data = iodata()
                 Options = [{exception_on_need_dict, boolean()}]
                 Decompressed =
                     iolist() |
                     {need_dictionary,
                      Adler32 :: integer() &gt;= 0,
                      Output :: iolist()}

              Decompresses as much data as possible. It can introduce some output latency (reading input without
              producing any output).

              Currently  the  only available option is <u>{exception_on_need_dict,boolean()}</u> which controls whether
              the function should throw an exception when a preset dictionary  is  required  for  decompression.
              When  set  to  false, a <u>need_dictionary</u> tuple will be returned instead. See <u>inflateSetDictionary/2</u>
              for details.

          <b>Warning:</b>
              This option defaults to <u>true</u> for backwards compatibility but we intend  to  remove  the  exception
              behavior  in  a  future release. New code that needs to handle dictionaries manually should always
              specify <u>{exception_on_need_dict,false}</u>.

       <b>inflateChunk(Z)</b> <b>-&gt;</b> <b>Decompressed</b> <b>|</b> <b>{more,</b> <b>Decompressed}</b>

              Types:

                 Z = zstream()
                 Decompressed = iolist()

          <b>Warning:</b>
              This function is deprecated and will be removed in a future release. Use <u>safeInflate/2</u> instead.

              Reads the next chunk of uncompressed data, initialized by <u>inflateChunk/2</u>.

              This function is to be repeatedly called, while it returns <u>{more,</u> <u>Decompressed}</u>.

       <b>inflateChunk(Z,</b> <b>Data)</b> <b>-&gt;</b> <b>Decompressed</b> <b>|</b> <b>{more,</b> <b>Decompressed}</b>

              Types:

                 Z = zstream()
                 Data = iodata()
                 Decompressed = iolist()

          <b>Warning:</b>
              This function is deprecated and will be removed in a future release. Use <u>safeInflate/2</u> instead.

              Like <u>inflate/2</u>, but decompresses no more data than will  fit  in  the  buffer  configured  through
              <u>setBufSize/2</u>.  Is is useful when decompressing a stream with a high compression ratio, such that a
              small amount of compressed input can expand up to 1000 times.

              This  function  returns  <u>{more,</u>  <u>Decompressed}</u>,  when  there  is  more   output   available,   and
              <u>inflateChunk/1</u> is to be used to read it.

              This function can introduce some output latency (reading input without producing any output).

              An  exception  will  be  thrown  if a preset dictionary is required for further decompression. See
              <u>inflateSetDictionary/2</u> for details.

              Example:

              walk(Compressed, Handler) -&gt;
                  Z = zlib:open(),
                  zlib:inflateInit(Z),
                  % Limit single uncompressed chunk size to 512kb
                  zlib:setBufSize(Z, 512 * 1024),
                  loop(Z, Handler, zlib:inflateChunk(Z, Compressed)),
                  zlib:inflateEnd(Z),
                  zlib:close(Z).

              loop(Z, Handler, {more, Uncompressed}) -&gt;
                  Handler(Uncompressed),
                  loop(Z, Handler, zlib:inflateChunk(Z));
              loop(Z, Handler, Uncompressed) -&gt;
                  Handler(Uncompressed).

       <b>inflateEnd(Z)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Z = zstream()

              Ends the inflate session and cleans all data used. Notice that this function throws  a  <u>data_error</u>
              exception if no end of stream was found (meaning that not all data has been uncompressed).

       <b>inflateGetDictionary(Z)</b> <b>-&gt;</b> <b>Dictionary</b>

              Types:

                 Z = zstream()
                 Dictionary = binary()

              Returns  the decompression dictionary currently in use by the stream. This function must be called
              between <u>inflateInit/1,2</u> and <u>inflateEnd</u>.

              Only supported if ERTS was compiled with zlib &gt;= 1.2.8.

       <b>inflateInit(Z)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Z = zstream()

              Initializes a zlib stream for decompression.

       <b>inflateInit(Z,</b> <b>WindowBits)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Z = zstream()
                 WindowBits = zwindowbits()

              Initializes a decompression session on zlib stream.

              <u>WindowBits</u> is the base two logarithm of the maximum window size (the size of the history  buffer).
              It is to be in the range 8 through 15. Default to 15 if <u>inflateInit/1</u> is used.

              If  a  compressed  stream  with  a  larger window size is specified as input, <u>inflate/2</u> throws the
              <u>data_error</u> exception.

              A negative <u>WindowBits</u> value makes zlib ignore the zlib header  (and  checksum)  from  the  stream.
              Notice that the zlib source mentions this only as a undocumented feature.

       <b>inflateReset(Z)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Z = zstream()

              Equivalent  to  <u>inflateEnd/1</u>  followed  by <u>inflateInit/1</u>, but does not free and reallocate all the
              internal decompression state. The stream  will  keep  attributes  that  could  have  been  set  by
              <u>inflateInit/1,2</u>.

       <b>inflateSetDictionary(Z,</b> <b>Dictionary)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Z = zstream()
                 Dictionary = iodata()

              Initializes  the  decompression  dictionary  from  the  specified uncompressed byte sequence. This
              function must be called as a response  to  an  inflate  operation  (eg.  <u>safeInflate/2</u>)  returning
              <u>{need_dictionary,Adler,Output}</u>   or   in   the   case   of   deprecated   functions,  throwing  an
              <u>{'EXIT',{{need_dictionary,Adler},_StackTrace}}</u> exception.

              The dictionary chosen by the compressor can be determined from the Adler value returned or  thrown
              by  the call to the inflate function. The compressor and decompressor must use the same dictionary
              (See <u>deflateSetDictionary/2</u>).

              After setting the dictionary the inflate operation should be retried without new input.

              Example:

              deprecated_unpack(Z, Compressed, Dict) -&gt;
                   case catch zlib:inflate(Z, Compressed) of
                        {'EXIT',{{need_dictionary,_DictID},_}} -&gt;
                               ok = zlib:inflateSetDictionary(Z, Dict),
                               Uncompressed = zlib:inflate(Z, []);
                        Uncompressed -&gt;
                               Uncompressed
                   end.

              new_unpack(Z, Compressed, Dict) -&gt;
                  case zlib:inflate(Z, Compressed, [{exception_on_need_dict, false}]) of
                      {need_dictionary, _DictId, Output} -&gt;
                          ok = zlib:inflateSetDictionary(Z, Dict),
                          [Output | zlib:inflate(Z, [])];
                      Uncompressed -&gt;
                          Uncompressed
                  end.

       <b>open()</b> <b>-&gt;</b> <b>zstream()</b>

              Opens a zlib stream.

       <b>safeInflate(Z,</b> <b>Data)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Z = zstream()
                 Data = iodata()
                 Result =
                     {continue, Output :: iolist()} |
                     {finished, Output :: iolist()} |
                     {need_dictionary,
                      Adler32 :: integer() &gt;= 0,
                      Output :: iolist()}

              Like <u>inflate/2</u>, but returns once it has expanded beyond a small implementation-defined  threshold.
              It's useful when decompressing untrusted input which could have been maliciously crafted to expand
              until the system runs out of memory.

              This  function  returns  <u>{continue</u>  <u>|</u>  <u>finished,</u>  <u>Output}</u>,  where  Output  is  the  data  that was
              decompressed in this call. New input can be queued up on each call if desired,  and  the  function
              will return <u>{finished,</u> <u>Output}</u> once all queued data has been decompressed.

              This function can introduce some output latency (reading input without producing any output).

              If   a  preset  dictionary  is  required  for  further  decompression,  this  function  returns  a
              <u>need_dictionary</u> tuple. See <u>inflateSetDictionary/2</u>) for details.

              Example:

              walk(Compressed, Handler) -&gt;
                  Z = zlib:open(),
                  zlib:inflateInit(Z),
                  loop(Z, Handler, zlib:safeInflate(Z, Compressed)),
                  zlib:inflateEnd(Z),
                  zlib:close(Z).

              loop(Z, Handler, {continue, Output}) -&gt;
                  Handler(Output),
                  loop(Z, Handler, zlib:safeInflate(Z, []));
              loop(Z, Handler, {finished, Output}) -&gt;
                  Handler(Output).

       <b>setBufSize(Z,</b> <b>Size)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Z = zstream()
                 Size = integer() &gt;= 0

              Sets the intermediate buffer size.

          <b>Warning:</b>
              This function is deprecated and will be removed in a future release.

       <b>set_controlling_process(Z,</b> <b>Pid)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Z = zstream()
                 Pid = pid()

              Changes the controlling process of <u>Z</u> to <u>Pid</u>, which must be a local process.

       <b>uncompress(Data)</b> <b>-&gt;</b> <b>Decompressed</b>

              Types:

                 Data = iodata()
                 Decompressed = binary()

              Uncompresses data with zlib headers and checksum.

       <b>unzip(Data)</b> <b>-&gt;</b> <b>Decompressed</b>

              Types:

                 Data = iodata()
                 Decompressed = binary()

              Uncompresses data without zlib headers and checksum.

       <b>zip(Data)</b> <b>-&gt;</b> <b>Compressed</b>

              Types:

                 Data = iodata()
                 Compressed = binary()

              Compresses data without zlib headers and checksum.

Ericsson AB                                        erts 12.2.1                                        <u><a href="../man3erl/zlib.3erl.html">zlib</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>