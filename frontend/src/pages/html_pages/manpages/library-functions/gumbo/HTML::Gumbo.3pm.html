<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::Gumbo - HTML5 parser based on gumbo C library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-gumbo-perl">libhtml-gumbo-perl_0.18-5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::Gumbo - HTML5 parser based on gumbo C library

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use HTML::Gumbo;
           say HTML::Gumbo-&gt;new-&gt;parse('&lt;div&gt;&lt;/div&gt;');

           say HTML::Gumbo-&gt;new-&gt;parse('&lt;h1&gt;Hello&lt;/h1&gt;', format =&gt; 'tree')-&gt;as_HTML;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Gumbo &lt;https://github.com/google/gumbo-parser&gt; is an implementation of the HTML5 parsing algorithm
       &lt;<a href="http://www.w3.org/TR/html5/syntax.html">http://www.w3.org/TR/html5/syntax.html</a>&gt; implemented as a pure C99 library with no outside dependencies.

       Goals and features of the C library:

       •   Fully conformant with the HTML5 spec.

       •   Robust and resilient to bad input.

       •   Simple API that can be easily wrapped by other languages. (This is one of such wrappers.)

       •   Support  for  source  locations  and  pointers  back  to  the  original  text.   (Not exposed by this
           implementation at the moment.)

       •   Relatively lightweight, with no outside dependencies.

       •   Passes all html5lib-0.95 tests.

       •   Tested on over 2.5 billion pages from Google's index.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
           my $parser = HTML::Gumbo-&gt;new;

       No options at the moment.

   <b>parse</b>
           my $res = $parser-&gt;parse(
               "&lt;h1&gt;hello world!&lt;/h1&gt;",
               format =&gt; 'tree',
               input_is =&gt; 'string',
           );

       Takes html string and pairs of named arguments:

       format
           Output format, default is string. See "SUPPORTED OUTPUT FORMATS".

       fragment_namespace
           Enables fragments parsing algorithm. Pass  either  'HTML',  'SVG'  or  'MATHML'  to  enable  and  set
           namespace.  Without  this  input  is  parsed as html document, so html, head, title and body tags are
           added if absent.

           <b>Note</b> that fragment_enclosing_tag is set to '&lt;body&gt;' and can not be changed at the moment.  Feel  free
           to send patches implementing this part.

           See "SUPPORTED OUTPUT FORMATS" for additional details.

           <b>Note</b>  that  SVG and MATHML parsing is not tested, feel free to file bug reports with tests in case it
           doesn't work.

       input_is
           Whether html is perl 'string', 'octets' or 'utf8' (octets known to be utf8). See "CHARACTER  ENCODING
           OF THE INPUT".

       encoding, encoding_content_type, encoding_tentative
           See "CHARACTER ENCODING OF THE INPUT".

       ... Some formatters may have additional arguments, see "SUPPORTED OUTPUT FORMATS"

       Return value depends on the picked format.

</pre><h4><b>SUPPORTED</b> <b>OUTPUT</b> <b>FORMATS</b></h4><pre>
   <b>string</b>
       HTML is parsed and re-built from the tree, so tags are balanced (except void elements).

       No additional arguments specific for this format.

           $html = HTML::Gumbo-&gt;new-&gt;parse( $html );

   <b>callback</b>
       HTML::Parser  like  interface.  Pass a sub as "callback" argument to "parse" method and it will be called
       for every node in the document:

           HTML::Gumbo-&gt;new-&gt;parse( $html, format =&gt; 'callback', callback =&gt; sub {
               my ($event) = shift;
               if ( $event eq 'document start' ) {
                   my ($doctype) = @_;
               }
               elsif ( $event eq 'document end' ) {
               }
               elsif ( $event eq 'start' ) {
                   my ($tag, $attrs) = @_;
               }
               elsif ( $event eq 'end' ) {
                   my ($tag) = @_;
               }
               elsif ( $event eq /^(text|space|cdata|comment)$/ ) {
                   my ($text) = @_;
               }
               else {
                   die "Unknown event";
               }
           } );

       Note that 'end' events are not generated for void elements  &lt;<a href="http://www.w3.org/TR/html5/syntax.html">http://www.w3.org/TR/html5/syntax.html</a>#void-
       elements&gt;, for example "hr", "br" and "img".

       No additional arguments except mentioned "callback".

       Fragment  parsing  still  generates  'document  start'  and  'document  end'  events what can be handy to
       initialize your parsing callback.

   <b>tree</b>
       Alpha stage.

       Produces tree based on HTML::Elements, like HTML::TreeBuilder.

       There is major difference from HTML::TreeBuilder, this method produces top level element  with  tag  name
       'document' which may have doctype, comments and html tags as children.

       Fragments  parsing  still  produces  top  level 'document' element as fragment can be a list of tags, for
       example: '&lt;p&gt;hello&lt;/p&gt;&lt;p&gt;world&lt;/p'.

       Yes, it's not ready to use as drop in replacement of tree builder. Patches are wellcome as  I  don't  use
       this  formatter  at the moment. Note that it's hard to get rid of top level element because of situations
       described above.  So not bad idea is to write HTML::Gumbo::Document class  that  is  either  subclass  of
       HTML::Element or implements a small subset of methods of HTML::Element.

</pre><h4><b>CHARACTER</b> <b>ENCODING</b> <b>OF</b> <b>THE</b> <b>INPUT</b></h4><pre>
       The C parser works only with UTF-8, so you have several options to make sure input is UTF-8. First of all
       define "input_is" argument:

       string
           Input is Perl string, for example obtained from "decoded_content" in HTTP::Response.  Default value.

               $gumbo-&gt;parse( decode_utf8($octets) );

       octets
           Input     are     octets.     Partial     implementation     of     encoding    sniffing    algorithm
           &lt;<a href="http://www.w3.org/TR/html5/syntax.html">http://www.w3.org/TR/html5/syntax.html</a>#encoding-sniffing-algorithm&gt; is used. First thing wins:

           "encoding" argument
               Use it to hardcode a specific encoding.

                   $gumbo-&gt;parse( $octets, input_is =&gt; 'octets', encoding =&gt; 'latin-1' );

           BOM UTF-8/UTF-16 BOMs are checked.

           "encoding_content_type" argument
               Encdoning from rransport layer, charset in content-type header.

                   $gumbo-&gt;parse( $octets, input_is =&gt; 'octets', encoding_content_type =&gt; 'latin-1' );

           Prescan
               Not implemented, follow issue 58 &lt;https://github.com/google/gumbo-parser/issues/58&gt;.

               HTML5 defines prescan algorithm &lt;<a href="http://www.w3.org/TR/html5/syntax.html">http://www.w3.org/TR/html5/syntax.html</a>#prescan-a-byte-stream-to-
               determine-its-encoding&gt; that extracts encoding from meta tags in the head.

               It would be cool to get it in the C library, but I will accept a patch that impements it in  pure
               perl.

           "encoding_tentative" argument
               The  likely  encoding  for  this  page,  e.g.  based on the encoding of the page when it was last
               visited.

                   $gumbo-&gt;parse( $octets, input_is =&gt; 'octets', encoding_tentative =&gt; 'latin-1' );

           nested browsing context
               Not implemented. Fragment parsing with or without context is not implemented. Parser also has  no
               origin information, so it wouldn't be implemented.

           autodetection
               Not implemented.

               Can be implemented using Encode::Detect::Detector. Patches are welcome.

           otherwise
               It <b>dies</b>.

       "utf8"
           Use  utf8  as input_is when you're sure input is UTF-8, but octets.  No pre-processing at all. Should
           only be used on trusted input or when it's preprocessed already.

</pre><h4><b>AUTHOR</b></h4><pre>
       Ruslan Zakirov &lt;<a href="mailto:ruz@bestpractical.com">ruz@bestpractical.com</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       Under the same terms as perl itself.

perl v5.40.1                                       2025-05-17                                   <u>HTML::<a href="../man3pm/Gumbo.3pm.html">Gumbo</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>