<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_InitHashTable,        Tcl_InitCustomHashTable,       Tcl_InitObjHashTable,       Tcl_DeleteHashTable,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_InitHashTable,        Tcl_InitCustomHashTable,       Tcl_InitObjHashTable,       Tcl_DeleteHashTable,
       Tcl_CreateHashEntry,   Tcl_DeleteHashEntry,   Tcl_FindHashEntry,   Tcl_GetHashValue,    Tcl_SetHashValue,
       Tcl_GetHashKey, Tcl_FirstHashEntry, Tcl_NextHashEntry, Tcl_HashStats - procedures to manage hash tables

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       <b>Tcl_InitHashTable</b>(<u>tablePtr,</u> <u>keyType</u>)

       <b>Tcl_InitCustomHashTable</b>(<u>tablePtr,</u> <u>keyType,</u> <u>typePtr</u>)

       <b>Tcl_InitObjHashTable</b>(<u>tablePtr</u>)

       <b>Tcl_DeleteHashTable</b>(<u>tablePtr</u>)

       Tcl_HashEntry *
       <b>Tcl_CreateHashEntry</b>(<u>tablePtr,</u> <u>key,</u> <u>newPtr</u>)

       <b>Tcl_DeleteHashEntry</b>(<u>entryPtr</u>)

       Tcl_HashEntry *
       <b>Tcl_FindHashEntry</b>(<u>tablePtr,</u> <u>key</u>)

       void *
       <b>Tcl_GetHashValue</b>(<u>entryPtr</u>)

       <b>Tcl_SetHashValue</b>(<u>entryPtr,</u> <u>value</u>)

       void *
       <b>Tcl_GetHashKey</b>(<u>tablePtr,</u> <u>entryPtr</u>)

       Tcl_HashEntry *
       <b>Tcl_FirstHashEntry</b>(<u>tablePtr,</u> <u>searchPtr</u>)

       Tcl_HashEntry *
       <b>Tcl_NextHashEntry</b>(<u>searchPtr</u>)

       char *
       <b>Tcl_HashStats</b>(<u>tablePtr</u>)

</pre><h4><b>ARGUMENTS</b></h4><pre>
       Tcl_HashTable <u>*tablePtr</u> (in)                   Address  of  hash  table structure (for all procedures but
                                                      <b>Tcl_InitHashTable</b>, this  must  have  been  initialized  by
                                                      previous call to <b>Tcl_InitHashTable</b>).

       int <u>keyType</u> (in)                               Kind  of  keys  to use for new hash table.  Must be either
                                                      <b>TCL_STRING_KEYS</b>, <b>TCL_ONE_WORD_KEYS</b>,  <b>TCL_CUSTOM_TYPE_KEYS</b>,
                                                      <b>TCL_CUSTOM_PTR_KEYS</b>, or an integer value greater than 1.

       Tcl_HashKeyType <u>*typePtr</u> (in)                  Address  of  structure  which  defines the behavior of the
                                                      hash table.

       const void <u>*key</u> (in)                           Key to use for probe into table.  Exact  form  depends  on
                                                      <u>keyType</u> used to create table.

       int <u>*newPtr</u> (out)                              The word at <u>*newPtr</u> is set to 1 if a new entry was created
                                                      and 0 if there was already an entry for <u>key</u>.

       Tcl_HashEntry <u>*entryPtr</u> (in)                   Pointer to hash table entry.

       void <u>*value</u> (in)                               New value to assign to hash table entry.

       Tcl_HashSearch <u>*searchPtr</u> (in)                 Pointer  to  record  to  use  to keep track of progress in
                                                      enumerating all the entries in a hash table.
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A hash table consists of zero or more entries, each consisting of a key and a value.  Given the  key  for
       an  entry,  the  hashing routines can very quickly locate the entry, and hence its value. There may be at
       most one entry in a hash table with a particular key, but many entries may have the same value.  Keys can
       take one of four  forms:  strings,  one-word  values,  integer  arrays,  or  custom  keys  defined  by  a
       Tcl_HashKeyType  structure  (See section <b>THE</b> <b>TCL_HASHKEYTYPE</b> <b>STRUCTURE</b> below). All of the keys in a given
       table have the same form, which is specified when the table is initialized.

       The value of a hash table entry can be anything that fits in the  same  space  as  a  “char  *”  pointer.
       Values  for hash table entries are managed entirely by clients, not by the hash module itself.  Typically
       each entry's value is a pointer to a data structure managed by client code.

       Hash tables grow gracefully as the number of entries increases, so that there are always less than  three
       entries  per hash bucket, on average. This allows for fast lookups regardless of the number of entries in
       a table.

       The  core  provides  three  functions  for  the  initialization  of   hash   tables,   Tcl_InitHashTable,
       Tcl_InitObjHashTable and Tcl_InitCustomHashTable.

       <b>Tcl_InitHashTable</b>  initializes  a structure that describes a new hash table.  The space for the structure
       is provided by the caller, not by the hash module.  The value of <u>keyType</u> indicates  what  kinds  of  keys
       will  be  used  for  all entries in the table. All of the key types described later are allowed, with the
       exception of <b>TCL_CUSTOM_TYPE_KEYS</b> and <b>TCL_CUSTOM_PTR_KEYS</b>.

       <b>Tcl_InitObjHashTable</b> is a wrapper around <b>Tcl_InitCustomHashTable</b> and initializes a hash table whose  keys
       are Tcl_Obj *.

       <b>Tcl_InitCustomHashTable</b>  initializes  a  structure  that  describes  a  new hash table. The space for the
       structure is provided by the caller, not by the hash module.  The value of <u>keyType</u> indicates  what  kinds
       of keys will be used for all entries in the table.  <u>KeyType</u> must have one of the following values:

       <b>TCL_STRING_KEYS</b>          Keys are null-terminated strings.  They are passed to hashing routines using the
                                address of the first character of the string.

       <b>TCL_ONE_WORD_KEYS</b>        Keys  are single-word values;  they are passed to hashing routines and stored in
                                hash table entries as “char *” values.  The pointer value is the key;   it  need
                                not (and usually does not) actually point to a string.

       <b>TCL_CUSTOM_TYPE_KEYS</b>     Keys  are of arbitrary type, and are stored in the entry. Hashing and comparison
                                is determined by <u>typePtr</u>. The Tcl_HashKeyType  structure  is  described  in  the
                                section <b>THE</b> <b>TCL_HASHKEYTYPE</b> <b>STRUCTURE</b> below.

       <b>TCL_CUSTOM_PTR_KEYS</b>      Keys are pointers to an arbitrary type, and are stored in the entry. Hashing and
                                comparison  is determined by <u>typePtr</u>. The Tcl_HashKeyType structure is described
                                in the section <b>THE</b> <b>TCL_HASHKEYTYPE</b> <b>STRUCTURE</b> below.

       <u>other</u>                    If <u>keyType</u> is not one of the above, then it must be  an  integer  value  greater
                                than  1.   In  this  case the keys will be arrays of “int” values, where <u>keyType</u>
                                gives the number of ints in each key.  This allows  structures  to  be  used  as
                                keys.   All  keys  must  have the same size.  Array keys are passed into hashing
                                functions using the address of the first int in the array.

       <b>Tcl_DeleteHashTable</b> deletes all of the entries in a hash table and frees up the  memory  associated  with
       the  table's  bucket  array  and  entries.   It  does  not free the actual table structure (pointed to by
       <u>tablePtr</u>), since that memory is assumed to be managed by the client.  <b>Tcl_DeleteHashTable</b> also  does  not
       free  or  otherwise  manipulate  the  values  of  the  hash  table entries.  If the entry values point to
       dynamically-allocated memory, then it is the client's responsibility  to  free  these  structures  before
       deleting the table.

       <b>Tcl_CreateHashEntry</b>  locates  the  entry  corresponding  to a particular key, creating a new entry in the
       table if there was not already one with the given key.  If an entry already existed with  the  given  key
       then <u>*newPtr</u> is set to zero.  If a new entry was created, then <u>*newPtr</u> is set to a non-zero value and the
       value  of  the  new entry will be set to zero.  The return value from <b>Tcl_CreateHashEntry</b> is a pointer to
       the entry, which may be used to retrieve and modify the entry's value or to delete  the  entry  from  the
       table.

       <b>Tcl_DeleteHashEntry</b>  will  remove  an  existing entry from a table.  The memory associated with the entry
       itself will be freed, but the client is responsible for any cleanup associated with  the  entry's  value,
       such as freeing a structure that it points to.

       <b>Tcl_FindHashEntry</b> is similar to <b>Tcl_CreateHashEntry</b> except that it does not create a new entry if the key
       doesn't exist; instead, it returns NULL as result.

       <b>Tcl_GetHashValue</b> and <b>Tcl_SetHashValue</b> are used to read and write an entry's value, respectively.

       <b>Tcl_GetHashKey</b>  returns the key for a given hash table entry, either as a pointer to a string, a one-word
       (“char *”) key, or as a pointer to the first word of an array of integers, depending on the <u>keyType</u>  used
       to  create  a hash table.  In all cases <b>Tcl_GetHashKey</b> returns a result with type “char *”.  When the key
       is a string or array, the result of <b>Tcl_GetHashKey</b> points  to  information  in  the  table  entry;   this
       information will remain valid until the entry is deleted or its table is deleted.

       <b>Tcl_FirstHashEntry</b>  and  <b>Tcl_NextHashEntry</b>  may  be  used  to scan all of the entries in a hash table.  A
       structure of type “Tcl_HashSearch”, provided by the client, is used to keep track of progress through the
       table.  <b>Tcl_FirstHashEntry</b> initializes the search record and returns the first entry  in  the  table  (or
       NULL  if  the  table  is empty).  Each subsequent call to <b>Tcl_NextHashEntry</b> returns the next entry in the
       table or NULL if the end of the table has been reached.  A call to <b>Tcl_FirstHashEntry</b> followed  by  calls
       to  <b>Tcl_NextHashEntry</b>  will  return each of the entries in the table exactly once, in an arbitrary order.
       It is inadvisable to modify the structure of the table, e.g.  by creating or deleting entries, while  the
       search  is  in  progress,  with  the  exception  of  deleting the entry returned by <b>Tcl_FirstHashEntry</b> or
       <b>Tcl_NextHashEntry</b>.

       <b>Tcl_HashStats</b> returns a dynamically-allocated string with overall information about a hash table, such as
       the number of entries it contains, the number of buckets in its hash array, and the  utilization  of  the
       buckets.  It is the caller's responsibility to free the result string by passing it to <b>Tcl_Free</b>.

       The  header  file  <b>tcl.h</b>  defines  the  actual  data  structures  used to implement hash tables.  This is
       necessary so that clients can allocate Tcl_HashTable structures and so that macros can be  used  to  read
       and  write  the values of entries.  However, users of the hashing routines should never refer directly to
       any of the fields of any of the hash-related data structures; use the procedures and macros defined here.

</pre><h4><b>THE</b> <b>TCL_HASHKEYTYPE</b> <b>STRUCTURE</b></h4><pre>
       Extension  writers  can  define  new  hash  key  types  by  defining  four  procedures,  initializing   a
       <b>Tcl_HashKeyType</b>  structure to describe the type, and calling <b>Tcl_InitCustomHashTable</b>. The <b>Tcl_HashKeyType</b>
       structure is defined as follows:

              typedef struct {
                  int <u>version</u>;
                  int <u>flags</u>;
                  Tcl_HashKeyProc *<u>hashKeyProc</u>;
                  Tcl_CompareHashKeysProc *<u>compareKeysProc</u>;
                  Tcl_AllocHashEntryProc *<u>allocEntryProc</u>;
                  Tcl_FreeHashEntryProc *<u>freeEntryProc</u>;
              } <b>Tcl_HashKeyType</b>;

       The <u>version</u> member is the version of the table. If this structure is extended in future then the  version
       can be used to distinguish between different structures. It should be set to <b>TCL_HASH_KEY_TYPE_VERSION</b>.

       The <u>flags</u> member is 0 or one or more of the following values OR'ed together:

       <b>TCL_HASH_KEY_RANDOMIZE_HASH</b>
                                There  are some things, pointers for example which do not hash well because they
                                do not use the lower bits. If this flag is set then the hash table will  attempt
                                to  rectify  this by randomizing the bits and then using the upper N bits as the
                                index into the table.

       <b>TCL_HASH_KEY_SYSTEM_HASH</b> This flag forces Tcl to use the memory allocation  procedures  provided  by  the
                                operating system when allocating and freeing memory used to store the hash table
                                data structures, and not any of Tcl's own customized memory allocation routines.
                                This  is  important  if  the hash table is to be used in the implementation of a
                                custom set of allocation routines, or something that a custom set of  allocation
                                routines might depend on, in order to avoid any circular dependency.

       The <u>hashKeyProc</u> member contains the address of a function called to calculate a hash value for the key.

              typedef TCL_HASH_TYPE <b>Tcl_HashKeyProc</b>(
                      Tcl_HashTable *<u>tablePtr</u>,
                      void *<u>keyPtr</u>);

       If this is NULL then <u>keyPtr</u> is used and <b>TCL_HASH_KEY_RANDOMIZE_HASH</b> is assumed.

       The <u>compareKeysProc</u> member contains the address of a function called to compare two keys.

              typedef int <b>Tcl_CompareHashKeysProc</b>(
                      void *<u>keyPtr</u>,
                      Tcl_HashEntry *<u>hPtr</u>);

       If this is NULL then the <u>keyPtr</u> pointers are compared. If the keys do not match then the function returns
       0, otherwise it returns 1.

       The  <u>allocEntryProc</u>  member  contains the address of a function called to allocate space for an entry and
       initialize the key and clientData.

              typedef Tcl_HashEntry *<b>Tcl_AllocHashEntryProc</b>(
                      Tcl_HashTable *<u>tablePtr</u>,
                      void *<u>keyPtr</u>);

       If this is NULL then <b>Tcl_Alloc</b> is used to allocate enough space for a Tcl_HashEntry, the key  pointer  is
       assigned  to  key.oneWordValue  and  the  clientData  is set to NULL. String keys and array keys use this
       function to allocate enough space for the entry and the key in one block, rather than  doing  it  in  two
       blocks.  This saves space for a pointer to the key from the entry and another memory allocation. Tcl_Obj*
       keys use this function to allocate enough space for an entry and increment the  reference  count  on  the
       value.

       The <u>freeEntryProc</u> member contains the address of a function called to free space for an entry.

              typedef void <b>Tcl_FreeHashEntryProc</b>(
                      Tcl_HashEntry *<u>hPtr</u>);

       If  this  is NULL then <b>Tcl_Free</b> is used to free the space for the entry.  Tcl_Obj* keys use this function
       to decrement the reference count on the value.

</pre><h4><b>REFERENCE</b> <b>COUNT</b> <b>MANAGEMENT</b></h4><pre>
       When a hash  table  is  created  with  <b>Tcl_InitCustomHashTable</b>,  the  <b>Tcl_CreateHashEntry</b>  function  will
       increment  the reference count of its <u>key</u> argument when it creates a key (but not if there is an existing
       matching key). The reference count of the key will be decremented when the corresponding  hash  entry  is
       deleted,  whether  with <b>Tcl_DeleteHashEntry</b> or with <b>Tcl_DeleteHashTable</b>. The <b>Tcl_GetHashKey</b> function will
       return the key without further modifying its reference count.

       Custom hash tables that use a Tcl_Obj* as key will generally  need  to  do  something  similar  in  their
       <u>allocEntryProc</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/Dict.3tcl.html">Dict</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       hash table, key, lookup, search, value

Tcl                                                                                               <u><a href="../man3tcl/Tcl_Hash.3tcl.html">Tcl_Hash</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>