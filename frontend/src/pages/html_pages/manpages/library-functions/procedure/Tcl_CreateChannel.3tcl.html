<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_CreateChannel,        Tcl_GetChannelInstanceData,       Tcl_GetChannelType,       Tcl_GetChannelName,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_CreateChannel,        Tcl_GetChannelInstanceData,       Tcl_GetChannelType,       Tcl_GetChannelName,
       Tcl_GetChannelHandle,     Tcl_GetChannelMode,     Tcl_GetChannelBufferSize,     Tcl_SetChannelBufferSize,
       Tcl_NotifyChannel,  Tcl_BadChannelOption,  Tcl_ChannelName, Tcl_ChannelVersion, Tcl_ChannelBlockModeProc,
       Tcl_ChannelClose2Proc,     Tcl_ChannelInputProc,     Tcl_ChannelOutputProc,      Tcl_ChannelWideSeekProc,
       Tcl_ChannelTruncateProc,    Tcl_ChannelSetOptionProc,   Tcl_ChannelGetOptionProc,   Tcl_ChannelWatchProc,
       Tcl_ChannelGetHandleProc,  Tcl_ChannelFlushProc,   Tcl_ChannelHandlerProc,   Tcl_ChannelThreadActionProc,
       Tcl_IsChannelShared,  Tcl_IsChannelRegistered,  Tcl_CutChannel, Tcl_SpliceChannel, Tcl_IsChannelExisting,
       Tcl_ClearChannelHandlers,  Tcl_GetChannelThread,  Tcl_ChannelBuffered  -  procedures  for  creating   and
       manipulating channels

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       Tcl_Channel
       <b>Tcl_CreateChannel</b>(<u>typePtr,</u> <u>channelName,</u> <u>instanceData,</u> <u>mask</u>)

       void *
       <b>Tcl_GetChannelInstanceData</b>(<u>channel</u>)

       const Tcl_ChannelType *
       <b>Tcl_GetChannelType</b>(<u>channel</u>)

       const char *
       <b>Tcl_GetChannelName</b>(<u>channel</u>)

       int
       <b>Tcl_GetChannelHandle</b>(<u>channel,</u> <u>direction,</u> <u>handlePtr</u>)

       Tcl_ThreadId
       <b>Tcl_GetChannelThread</b>(<u>channel</u>)

       int
       <b>Tcl_GetChannelMode</b>(<u>channel</u>)

       int                                                                                                       2
       <b>Tcl_RemoveChannelMode</b>(<u>interp,</u> <u>channel,</u> <u>mode</u>)                                                              2

       int
       <b>Tcl_GetChannelBufferSize</b>(<u>channel</u>)

       <b>Tcl_SetChannelBufferSize</b>(<u>channel,</u> <u>size</u>)

       <b>Tcl_NotifyChannel</b>(<u>channel,</u> <u>mask</u>)

       int
       <b>Tcl_BadChannelOption</b>(<u>interp,</u> <u>optionName,</u> <u>optionList</u>)

       int
       <b>Tcl_IsChannelShared</b>(<u>channel</u>)

       int
       <b>Tcl_IsChannelRegistered</b>(<u>interp,</u> <u>channel</u>)

       int
       <b>Tcl_IsChannelExisting</b>(<u>channelName</u>)

       <b>Tcl_CutChannel</b>(<u>channel</u>)

       <b>Tcl_SpliceChannel</b>(<u>channel</u>)

       <b>Tcl_ClearChannelHandlers</b>(<u>channel</u>)

       int
       <b>Tcl_ChannelBuffered</b>(<u>channel</u>)

       const char *
       <b>Tcl_ChannelName</b>(<u>typePtr</u>)

       Tcl_ChannelTypeVersion
       <b>Tcl_ChannelVersion</b>(<u>typePtr</u>)

       Tcl_DriverBlockModeProc *
       <b>Tcl_ChannelBlockModeProc</b>(<u>typePtr</u>)

       Tcl_DriverClose2Proc *
       <b>Tcl_ChannelClose2Proc</b>(<u>typePtr</u>)

       Tcl_DriverInputProc *
       <b>Tcl_ChannelInputProc</b>(<u>typePtr</u>)

       Tcl_DriverOutputProc *
       <b>Tcl_ChannelOutputProc</b>(<u>typePtr</u>)

       Tcl_DriverWideSeekProc *
       <b>Tcl_ChannelWideSeekProc</b>(<u>typePtr</u>)

       Tcl_DriverThreadActionProc *
       <b>Tcl_ChannelThreadActionProc</b>(<u>typePtr</u>)

       Tcl_DriverTruncateProc *
       <b>Tcl_ChannelTruncateProc</b>(<u>typePtr</u>)

       Tcl_DriverSetOptionProc *
       <b>Tcl_ChannelSetOptionProc</b>(<u>typePtr</u>)

       Tcl_DriverGetOptionProc *
       <b>Tcl_ChannelGetOptionProc</b>(<u>typePtr</u>)

       Tcl_DriverWatchProc *
       <b>Tcl_ChannelWatchProc</b>(<u>typePtr</u>)

       Tcl_DriverGetHandleProc *
       <b>Tcl_ChannelGetHandleProc</b>(<u>typePtr</u>)

       Tcl_DriverFlushProc *
       <b>Tcl_ChannelFlushProc</b>(<u>typePtr</u>)

       Tcl_DriverHandlerProc *
       <b>Tcl_ChannelHandlerProc</b>(<u>typePtr</u>)

</pre><h4><b>ARGUMENTS</b></h4><pre>
       const Tcl_ChannelType <u>*typePtr</u> (in)              Points  to  a  structure  containing  the  addresses  of
                                                        procedures that can be called to perform I/O  and  other
                                                        functions on the channel.

       const char <u>*channelName</u> (in)                     The  name of this channel, such as <b>file3</b>; must not be in
                                                        use by any other channel. Can be NULL, in which case the
                                                        channel is  created  without  a  name.  If  the  created
                                                        channel  is  assigned  to  one  of the standard channels
                                                        (<b>stdin</b>, <b>stdout</b> or <b>stderr</b>),  the  assigned  channel  name
                                                        will be the name of the standard channel.

       void <u>*instanceData</u> (in)                          Arbitrary  one-word  value  to  be  associated with this
                                                        channel.  This value is passed to procedures in  <u>typePtr</u>
                                                        when they are invoked.

       int <u>mask</u> (in)                                    OR-ed  combination  of  <b>TCL_READABLE</b> and <b>TCL_WRITABLE</b> to
                                                        indicate whether a channel is readable and writable.

       Tcl_Channel <u>channel</u> (in)                         The channel to operate on.

       int <u>direction</u> (in)                               <b>TCL_READABLE</b>  means  the   input   handle   is   wanted;
                                                        <b>TCL_WRITABLE</b> means the output handle is wanted.

       void <u>**handlePtr</u> (out)                           Points  to  the  location  where the desired OS-specific
                                                        handle should be stored.

       Tcl_Size <u>size</u> (in)                               The size, in bytes,  of  buffers  to  allocate  in  this
                                                        channel.

       int <u>mask</u> (in)                                    An  OR-ed  combination of <b>TCL_READABLE</b>, <b>TCL_WRITABLE</b> and
                                                        <b>TCL_EXCEPTION</b> that indicates events that  have  occurred
                                                        on this channel.

       Tcl_Interp <u>*interp</u> (in)                          Current interpreter. (can be NULL)

       const char <u>*optionName</u> (in)                      Name of the invalid option.

       const char <u>*optionList</u> (in)                      Specific  options  list  (space separated words, without
                                                        “-”) to append to the  standard  generic  options  list.
                                                        Can be NULL for generic options error message only.
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Tcl  uses  a  two-layered  channel  architecture.  It  provides a generic upper layer to enable C and Tcl
       programs to perform input and output using the same APIs for a variety of files,  devices,  sockets  etc.
       The generic C APIs are described in the manual entry for <b>Tcl_OpenFileChannel</b>.

       The  lower  layer  provides  type-specific  channel  drivers  for  each  type of device supported on each
       platform.  This manual entry describes the C APIs used to communicate between the generic layer  and  the
       type-specific  channel drivers.  It also explains how new types of channels can be added by providing new
       channel drivers.

       Channel drivers consist of a number of components: First, each channel driver provides a  <b>Tcl_ChannelType</b>
       structure  containing pointers to functions implementing the various operations used by the generic layer
       to communicate with the channel driver. The <b>Tcl_ChannelType</b> structure and the functions referenced by  it
       are described in the section <b>TCL_CHANNELTYPE</b>, below.

       Second,  channel  drivers  usually provide a Tcl command to create instances of that type of channel. For
       example, the Tcl <b>open</b> command creates channels that use the file and command channel drivers, and the Tcl
       <b>socket</b> command creates channels that use TCP sockets for network communication.

       Third, a channel driver optionally provides a C function to open channel  instances  of  that  type.  For
       example,  <b>Tcl_OpenFileChannel</b>  opens  a  channel that uses the file channel driver, and <b>Tcl_OpenTcpClient</b>
       opens  a  channel  that  uses  the  TCP  network  protocol.   These  creation  functions  typically   use
       <b>Tcl_CreateChannel</b> internally to open the channel.

       To add a new type of channel you must implement a C API or a Tcl command that opens a channel by invoking
       <b>Tcl_CreateChannel</b>.   When  your  driver  calls <b>Tcl_CreateChannel</b> it passes in a <b>Tcl_ChannelType</b> structure
       describing the driver's I/O procedures.  The generic layer will then invoke the functions  referenced  in
       that structure to perform operations on the channel.

       <b>Tcl_CreateChannel</b>  opens  a new channel and associates the supplied <u>typePtr</u> and <u>instanceData</u> with it. The
       channel is opened in the mode indicated by <u>mask</u>.  For a discussion of channel drivers,  their  operations
       and the <b>Tcl_ChannelType</b> structure, see the section <b>TCL_CHANNELTYPE</b>, below.

       <b>Tcl_CreateChannel</b>  interacts  with  the  code managing the standard channels. Once a standard channel was
       initialized either through a call to <b>Tcl_GetStdChannel</b>  or  a  call  to  <b>Tcl_SetStdChannel</b>  closing  this
       standard  channel  will cause the next call to <b>Tcl_CreateChannel</b> to make the new channel the new standard
       channel too. See <b>Tcl_StandardChannels</b> for a general treatise about standard channels and the behavior  of
       the Tcl library with regard to them.

       <b>Tcl_GetChannelInstanceData</b>  returns the instance data associated with the channel in <u>channel</u>. This is the
       same as the <u>instanceData</u> argument in the call to <b>Tcl_CreateChannel</b> that created this channel.

       <b>Tcl_GetChannelType</b> returns a pointer to the <b>Tcl_ChannelType</b> structure used by the channel in the  <u>channel</u>
       argument.  This  is  the  same as the <u>typePtr</u> argument in the call to <b>Tcl_CreateChannel</b> that created this
       channel.

       <b>Tcl_GetChannelName</b> returns a string containing the name associated with  the  channel,  or  NULL  if  the
       <u>channelName</u> argument to <b>Tcl_CreateChannel</b> was NULL.

       <b>Tcl_GetChannelHandle</b> places the OS-specific device handle associated with <u>channel</u> for the given <u>direction</u>
       in  the location specified by <u>handlePtr</u> and returns <b>TCL_OK</b>.  If the channel does not have a device handle
       for the specified direction, then <b>TCL_ERROR</b> is returned instead.  Different channel drivers  will  return
       different  types of handle.  Refer to the manual entries for each driver to determine what type of handle
       is returned.

       <b>Tcl_GetChannelThread</b> returns the id of the thread currently managing the specified <u>channel</u>.  This  allows
       channel drivers to send their file events to the correct event queue even for a multi-threaded core.

       <b>Tcl_GetChannelMode</b>  returns an OR-ed combination of <b>TCL_READABLE</b> and <b>TCL_WRITABLE</b>, indicating whether the
       channel is open for input and output.

       <b>Tcl_RemoveChannelMode</b> removes an access privilege from the channel, either <b>TCL_READABLE</b> or  <b>TCL_WRITABLE</b>, 2
       and  returns  a  regular Tcl result code, <b>TCL_OK</b>, or <b>TCL_ERROR</b>. The function throws an error if either an 2
       invalid mode is specified or the result of the removal would be an inaccessible channel. In that case  an 2
       error message is left in the interp argument, if not NULL.

       <b>Tcl_GetChannelBufferSize</b>  returns  the  size,  in bytes, of buffers allocated to store input or output in
       <u>channel</u>. If the value was not set by a previous call to <b>Tcl_SetChannelBufferSize</b>, described  below,  then
       the default value of 4096 is returned.

       <b>Tcl_SetChannelBufferSize</b>  sets  the  size,  in  bytes,  of  buffers  that will be allocated in subsequent
       operations on the channel to store input or output. The <u>size</u> argument  should  be  between  one  and  one
       million,  allowing  buffers  of  one  byte  to  one  million  bytes.  If  <u>size</u>  is  outside  this  range,
       <b>Tcl_SetChannelBufferSize</b> sets the buffer size to 4096.

       <b>Tcl_NotifyChannel</b> is called by a channel driver  to  indicate  to  the  generic  layer  that  the  events
       specified  by  <u>mask</u>  have  occurred  on  the  channel.  Channel drivers are responsible for invoking this
       function whenever the channel handlers need to be called for the channel (or other pending tasks  like  a
       write flush should be performed).  See <b>WATCHPROC</b> below for more details.

       <b>Tcl_BadChannelOption</b> is called from driver specific <u>setOptionProc</u> or <u>getOptionProc</u> to generate a complete
       error message.

       <b>Tcl_ChannelBuffered</b>  returns the number of bytes of input currently buffered in the internal buffer (push
       back area) of the channel itself. It does not report about the data in the overall buffers for the  stack
       of channels the supplied channel is part of.

       <b>Tcl_IsChannelShared</b>  checks  the  refcount  of  the specified <u>channel</u> and returns whether the <u>channel</u> was
       shared among multiple interpreters (result == 1) or not (result == 0).

       <b>Tcl_IsChannelRegistered</b> checks whether the specified <u>channel</u>  is  registered  in  the  given  <u>interp</u>reter
       (result == 1) or not (result == 0).

       <b>Tcl_IsChannelExisting</b>   checks   whether  a  channel  with  the  specified  name  is  registered  in  the
       (thread)-global list of all channels (result == 1) or not (result == 0).

       <b>Tcl_CutChannel</b> removes the specified <u>channel</u> from the (thread)global list of all channels (of the current
       thread).  Application to a channel still registered in some interpreter is not  allowed.   Also  notifies
       the driver if <b>Tcl_DriverThreadActionProc</b> is defined for it.

       <b>Tcl_SpliceChannel</b>  adds  the specified <u>channel</u> to the (thread)global list of all channels (of the current
       thread).  Application to a channel registered in some interpreter is  not  allowed.   Also  notifies  the
       driver if <b>Tcl_DriverThreadActionProc</b> is defined for it.

       <b>Tcl_ClearChannelHandlers</b>  removes  all  channel  handlers and event scripts associated with the specified
       <u>channel</u>, thus shutting down all event processing for this channel.

</pre><h4><b>TCL_CHANNELTYPE</b></h4><pre>
       A channel driver provides a <b>Tcl_ChannelType</b> structure that contains pointers to functions that  implement
       the  various  operations  on a channel; these operations are invoked as needed by the generic layer.  The
       structure was versioned starting in Tcl 8.3.2/8.4 to correct a problem with stacked channel drivers.  See
       the <b>OLD</b> <b>CHANNEL</b> <b>TYPES</b> section below for details about the old structure.

       The <b>Tcl_ChannelType</b> structure contains the following fields:

              typedef struct {
                      const char *<u>typeName</u>;
                      Tcl_ChannelTypeVersion <u>version</u>;
                      void *<u>closeProc</u>; /* Not used any more*/
                      Tcl_DriverInputProc *<u>inputProc</u>;
                      Tcl_DriverOutputProc *<u>outputProc</u>;
                      void *<u>seekProc</u>; /* Not used any more */
                      Tcl_DriverSetOptionProc *<u>setOptionProc</u>;
                      Tcl_DriverGetOptionProc *<u>getOptionProc</u>;
                      Tcl_DriverWatchProc *<u>watchProc</u>;
                      Tcl_DriverGetHandleProc *<u>getHandleProc</u>;
                      Tcl_DriverClose2Proc *<u>close2Proc</u>;
                      Tcl_DriverBlockModeProc *<u>blockModeProc</u>;
                      Tcl_DriverFlushProc *<u>flushProc</u>;
                      Tcl_DriverHandlerProc *<u>handlerProc</u>;
                      Tcl_DriverWideSeekProc *<u>wideSeekProc</u>;
                      Tcl_DriverThreadActionProc *<u>threadActionProc</u>;
                      Tcl_DriverTruncateProc *<u>truncateProc</u>;
              } <b>Tcl_ChannelType</b>;

       It is not necessary to provide implementations for all channel operations.  Those which are not necessary
       may be set to NULL in the struct: <u>blockModeProc</u>, <u>seekProc</u>, <u>setOptionProc</u>,  <u>getOptionProc</u>,  <u>getHandleProc</u>,
       and  <u>close2Proc</u>,  in  addition  to  <u>flushProc</u>,  <u>handlerProc</u>,  <u>threadActionProc</u>,  and <u>truncateProc</u>.  Other
       functions that cannot be implemented in a meaningful way should return <b>EINVAL</b> when  called,  to  indicate
       that the operations they represent are not available. Also note that <u>wideSeekProc</u> can be NULL if <u>seekProc</u>
       is.

       The  user should only use the above structure for <b>Tcl_ChannelType</b> instantiation.  When referencing fields
       in  a  <b>Tcl_ChannelType</b>  structure,  the  following  functions  should  be  used  to  obtain  the  values:
       <b>Tcl_ChannelName</b>,        <b>Tcl_ChannelVersion</b>,        <b>Tcl_ChannelBlockModeProc</b>,       <b>Tcl_ChannelClose2Proc</b>,
       <b>Tcl_ChannelInputProc</b>,   <b>Tcl_ChannelOutputProc</b>,   <b>Tcl_ChannelWideSeekProc</b>,    <b>Tcl_ChannelThreadActionProc</b>,
       <b>Tcl_ChannelTruncateProc</b>,    <b>Tcl_ChannelSetOptionProc</b>,   <b>Tcl_ChannelGetOptionProc</b>,   <b>Tcl_ChannelWatchProc</b>,
       <b>Tcl_ChannelGetHandleProc</b>, <b>Tcl_ChannelFlushProc</b>, or <b>Tcl_ChannelHandlerProc</b>.

       The change to the structures was made in such a way that standard channel types  are  binary  compatible.
       However,  channel  types that use stacked channels (i.e. TLS, Trf) have new versions to correspond to the
       above change since the previous code for stacked channels had problems.

   <b>TYPENAME</b>
       The <u>typeName</u> field contains a null-terminated string that identifies the type of the  device  implemented
       by this driver, e.g.  <b>file</b> or <b>socket</b>.

       This value can be retrieved with <b>Tcl_ChannelName</b>, which returns a pointer to the string.

   <b>VERSION</b>
       The  <u>version</u>  field should be set to the version of the structure that you require. <b>TCL_CHANNEL_VERSION_5</b>
       is the minimum supported.

       This value can be retrieved with <b>Tcl_ChannelVersion</b>.

   <b>BLOCKMODEPROC</b>
       The <u>blockModeProc</u> field contains the address of a function called by the generic layer  to  set  blocking
       and nonblocking mode on the device.  <u>BlockModeProc</u> should match the following prototype:

              typedef int <b>Tcl_DriverBlockModeProc</b>(
                      void *<u>instanceData</u>,
                      int <u>mode</u>);

       The <u>instanceData</u> is the same as the value passed to <b>Tcl_CreateChannel</b> when this channel was created.  The
       <u>mode</u>  argument  is  either  <b>TCL_MODE_BLOCKING</b>  or <b>TCL_MODE_NONBLOCKING</b> to set the device into blocking or
       nonblocking mode. The function should return zero if the operation was successful,  or  a  nonzero  POSIX
       error code if the operation failed.

       If  the  operation  is  successful,  the function can modify the supplied <u>instanceData</u> to record that the
       channel entered blocking or nonblocking mode and to implement the blocking or nonblocking behavior.   For
       some  device  types, the blocking and nonblocking behavior can be implemented by the underlying operating
       system; for other device types, the behavior must be emulated in the channel driver.

       This value can be retrieved with <b>Tcl_ChannelBlockModeProc</b>, which returns a pointer to the function.

       A channel driver <b>not</b> supplying a <u>blockModeProc</u> has to be very, very careful. It has to tell  the  generic
       layer exactly which blocking mode is acceptable to it, and should this also document for the user so that
       the blocking mode of the channel is not changed to an unacceptable value. Any confusion here may lead the
       interpreter into a (spurious and difficult to find) deadlock.

   <b>CLOSE2PROC</b>
       The  <u>close2Proc</u>  field contains the address of a function called by the generic layer to clean up driver-
       related information when the channel is closed. <u>Close2Proc</u> must match the following prototype:

              typedef int <b>Tcl_DriverClose2Proc</b>(
                      void *<u>instanceData</u>,
                      Tcl_Interp *<u>interp</u>,
                      int <u>flags</u>);

       If <u>flags</u> is 0, the <u>instanceData</u> argument is the same as the value provided to <b>Tcl_CreateChannel</b> when  the
       channel  was  created.  The function should release any storage maintained by the channel driver for this
       channel, and close the input and output devices encapsulated by this channel. All queued output will have
       been flushed to the device before this function is called, and  no  further  driver  operations  will  be
       invoked on this instance after calling the <u>closeProc</u>. If the close operation is successful, the procedure
       should  return  zero;  otherwise  it  should  return a nonzero POSIX error code. In addition, if an error
       occurs and <u>interp</u> is not NULL, the procedure should store an error message in the interpreter's result.

       Alternatively, channels that support closing the read and write sides independently may accept other flag
       values than 0.  Then <u>close2Proc</u> will be called with <u>flags</u> set to an OR'ed combination  of  <b>TCL_CLOSE_READ</b>
       or  <b>TCL_CLOSE_WRITE</b>  to  indicate that the driver should close the read and/or write side of the channel.
       The channel driver may be invoked to perform additional operations on the  channel  after  <u>close2Proc</u>  is
       called  to  close  one or both sides of the channel.  In all cases, the <u>close2Proc</u> function should return
       zero if the close operation was successful; otherwise it should return a nonzero POSIX  error  code.   In
       addition,  if  an error occurs and <u>interp</u> is not NULL, the procedure should store an error message in the
       interpreter's result.

       The <u>close2Proc</u> value can be  retrieved  with  <b>Tcl_ChannelClose2Proc</b>,  which  returns  a  pointer  to  the
       function.

   <b>INPUTPROC</b>
       The  <u>inputProc</u> field contains the address of a function called by the generic layer to read data from the
       file or device and store it in an internal buffer. <u>InputProc</u> must match the following prototype:

              typedef int <b>Tcl_DriverInputProc</b>(
                      void *<u>instanceData</u>,
                      char *<u>buf</u>,
                      int <u>bufSize</u>,
                      int *<u>errorCodePtr</u>);

       <u>InstanceData</u> is the same as the value passed to <b>Tcl_CreateChannel</b> when the channel was created.  The  <u>buf</u>
       argument  points  to  an array of bytes in which to store input from the device, and the <u>bufSize</u> argument
       indicates how many bytes are available at <u>buf</u>.

       The <u>errorCodePtr</u> argument points to an integer variable provided  by  the  generic  layer.  If  an  error
       occurs,  the  function  should  set  the  variable  to  a POSIX error code that identifies the error that
       occurred.

       The function should read data from the input device encapsulated by the channel and store it at <u>buf</u>.   On
       success,  the  function  should return a nonnegative integer indicating how many bytes were read from the
       input device and stored at <u>buf</u>. On error, the function should return -1. If an error  occurs  after  some
       data has been read from the device, that data is lost.

       If  <u>inputProc</u>  can determine that the input device has some data available but less than requested by the
       <u>bufSize</u> argument, the function should only attempt to read as  much  data  as  is  available  and  return
       without  blocking. If the input device has no data available whatsoever and the channel is in nonblocking
       mode, the function should return an <b>EAGAIN</b> error. If the input device has no  data  available  whatsoever
       and  the  channel  is in blocking mode, the function should block for the shortest possible time until at
       least one byte of data can be read from the device; then, it should return as much data as  it  can  read
       without blocking.

       This value can be retrieved with <b>Tcl_ChannelInputProc</b>, which returns a pointer to the function.

   <b>OUTPUTPROC</b>
       The <u>outputProc</u> field contains the address of a function called by the generic layer to transfer data from
       an internal buffer to the output device.  <u>OutputProc</u> must match the following prototype:

              typedef int <b>Tcl_DriverOutputProc</b>(
                      void *<u>instanceData</u>,
                      const char *<u>buf</u>,
                      int <u>toWrite</u>,
                      int *<u>errorCodePtr</u>);

       <u>InstanceData</u>  is  the same as the value passed to <b>Tcl_CreateChannel</b> when the channel was created. The <u>buf</u>
       argument contains an array of bytes to be written to the device, and the <u>toWrite</u> argument  indicates  how
       many bytes are to be written from the <u>buf</u> argument.

       The  <u>errorCodePtr</u>  argument  points  to  an  integer  variable provided by the generic layer. If an error
       occurs, the function should set this variable to a POSIX error code that identifies the error.

       The function should write the data at <u>buf</u> to the output device encapsulated by the channel.  On  success,
       the  function  should  return  a nonnegative integer indicating how many bytes were written to the output
       device.  The return value is normally the same as <u>toWrite</u>, but may be less in some cases such as  if  the
       output  operation  is interrupted by a signal. If an error occurs the function should return -1.  In case
       of error, some data may have been written to the device.

       If the channel is nonblocking and the output device is unable to absorb any data whatsoever, the function
       should return -1 with an <b>EAGAIN</b> error without writing any data.

       This value can be retrieved with <b>Tcl_ChannelOutputProc</b>, which returns a pointer to the function.

   <b>WIDESEEKPROC</b>
       The <u>wideSeekProc</u> field contains the address of a function called by the generic layer to move the  access
       point  at  which  subsequent  input  or  output  operations  will be applied. <u>WideSeekProc</u> must match the
       following prototype:

              typedef long long <b>Tcl_DriverWideSeekProc</b>(
                      void *<u>instanceData</u>,
                      long long <u>offset</u>,
                      int <u>seekMode</u>,
                      int *<u>errorCodePtr</u>);

       The <u>instanceData</u> argument is the same as the value given  to  <b>Tcl_CreateChannel</b>  when  this  channel  was
       created.   <u>Offset</u>  and  <u>seekMode</u>  have  the  same meaning as for the <b>Tcl_Seek</b> procedure (described in the
       manual entry for <b>Tcl_OpenFileChannel</b>).

       The <u>errorCodePtr</u> argument points to an integer variable provided by the generic layer for returning <b>errno</b>
       values from the function.  The function should set this variable to  a  POSIX  error  code  if  an  error
       occurs.  The function should store an <b>EINVAL</b> error code if the channel type does not implement seeking.

       The  return  value  is  the  new  access point or -1 in case of error. If an error occurred, the function
       should not move the access point.

       The <u>wideSseekProc</u> value can be retrieved with <b>Tcl_ChannelWideSeekProc</b>, which returns  a  pointer  to  the
       function.

   <b>SETOPTIONPROC</b>
       The  <u>setOptionProc</u>  field contains the address of a function called by the generic layer to set a channel
       type specific option on a channel.  <u>setOptionProc</u> must match the following prototype:

              typedef int <b>Tcl_DriverSetOptionProc</b>(
                      void *<u>instanceData</u>,
                      Tcl_Interp *<u>interp</u>,
                      const char *<u>optionName</u>,
                      const char *<u>newValue</u>);

       <u>optionName</u> is the name of an option to set, and <u>newValue</u> is the new value for that option, as  a  string.
       The  <u>instanceData</u>  is the same as the value given to <b>Tcl_CreateChannel</b> when this channel was created. The
       function should do whatever channel type specific action is required to implement the new  value  of  the
       option.

       Some  options  are  handled  by  the  generic  code  and  this function is never called to set them, e.g.
       <b>-blockmode</b>. Other options are specific to each channel  type  and  the  <u>setOptionProc</u>  procedure  of  the
       channel  driver  will  get called to implement them. The <u>setOptionProc</u> field can be NULL, which indicates
       that this channel type supports no type specific options.

       If the option value is successfully modified to the new value, the function returns  <b>TCL_OK</b>.   It  should
       call  <b>Tcl_BadChannelOption</b> which itself returns <b>TCL_ERROR</b> if the <u>optionName</u> is unrecognized.  If <u>newValue</u>
       specifies a value for the option that is not supported or if a system call  error  occurs,  the  function
       should  leave  an  error  message in the result of <u>interp</u> if <u>interp</u> is not NULL. The function should also
       call <b>Tcl_SetErrno</b> to store an appropriate POSIX error code.

       This value can be retrieved with <b>Tcl_ChannelSetOptionProc</b>, which returns a pointer to the function.

   <b>GETOPTIONPROC</b>
       The <u>getOptionProc</u> field contains the address of a function called by the generic layer to get  the  value
       of a channel type specific option on a channel. <u>getOptionProc</u> must match the following prototype:

              typedef int <b>Tcl_DriverGetOptionProc</b>(
                      void *<u>instanceData</u>,
                      Tcl_Interp *<u>interp</u>,
                      const char *<u>optionName</u>,
                      Tcl_DString *<u>optionValue</u>);

       <u>OptionName</u>  is  the  name of an option supported by this type of channel. If the option name is not NULL,
       the function stores its current value, as a string, in the Tcl dynamic string <u>optionValue</u>.  If <u>optionName</u>
       is NULL, the function stores in <u>optionValue</u> an alternating  list  of  all  supported  options  and  their
       current  values.   On  success,  the  function returns <b>TCL_OK</b>.  It should call <b>Tcl_BadChannelOption</b> which
       itself returns <b>TCL_ERROR</b> if the <u>optionName</u> is unrecognized. If a system call error occurs,  the  function
       should  leave  an  error  message in the result of <u>interp</u> if <u>interp</u> is not NULL. The function should also
       call <b>Tcl_SetErrno</b> to store an appropriate POSIX error code.

       Some options are handled by the generic code and this function is never called to retrieve  their  value,
       e.g.  <b>-blockmode</b>.  Other options are specific to each channel type and the <u>getOptionProc</u> procedure of the
       channel driver will get called to implement them. The <u>getOptionProc</u> field can be  NULL,  which  indicates
       that this channel type supports no type specific options.

       This value can be retrieved with <b>Tcl_ChannelGetOptionProc</b>, which returns a pointer to the function.

   <b>WATCHPROC</b>
       The  <u>watchProc</u>  field  contains  the  address of a function called by the generic layer to initialize the
       event notification mechanism to notice events of interest on this channel.  <u>WatchProc</u>  should  match  the
       following prototype:

              typedef void <b>Tcl_DriverWatchProc</b>(
                      void *<u>instanceData</u>,
                      int <u>mask</u>);

       The  <u>instanceData</u> is the same as the value passed to <b>Tcl_CreateChannel</b> when this channel was created. The
       <u>mask</u> argument is an OR-ed combination of  <b>TCL_READABLE</b>,  <b>TCL_WRITABLE</b>  and  <b>TCL_EXCEPTION</b>;  it  indicates
       events the caller is interested in noticing on this channel.

       The  function  should  initialize  device type specific mechanisms to notice when an event of interest is
       present on the channel.  When one or more of the designated events occurs on  the  channel,  the  channel
       driver  is  responsible  for  calling <b>Tcl_NotifyChannel</b> to inform the generic channel module.  The driver
       should  take  care  not  to  starve  other  channel  drivers  or  sources  of   callbacks   by   invoking
       Tcl_NotifyChannel  too  frequently.   Fairness  can  be insured by using the Tcl event queue to allow the
       channel event to be scheduled in sequence with other events.  See the description of  <b>Tcl_QueueEvent</b>  for
       details on how to queue an event.

       This value can be retrieved with <b>Tcl_ChannelWatchProc</b>, which returns a pointer to the function.

   <b>GETHANDLEPROC</b>
       The  <u>getHandleProc</u>  field  contains  the  address of a function called by the generic layer to retrieve a
       device-specific handle from the channel.  <u>GetHandleProc</u> should match the following prototype:

              typedef int <b>Tcl_DriverGetHandleProc</b>(
                      void *<u>instanceData</u>,
                      int <u>direction</u>,
                      void **<u>handlePtr</u>);

       <u>InstanceData</u> is the same as the value passed to <b>Tcl_CreateChannel</b> when  this  channel  was  created.  The
       <u>direction</u>  argument  is  either  <b>TCL_READABLE</b>  to  retrieve the handle used for input, or <b>TCL_WRITABLE</b> to
       retrieve the handle used for output.

       If the channel implementation has device-specific handles, the function should retrieve  the  appropriate
       handle associated with the channel, according the <u>direction</u> argument.  The handle should be stored in the
       location  referred  to  by  <u>handlePtr</u>, and <b>TCL_OK</b> should be returned.  If the channel is not open for the
       specified direction, or if the channel implementation does not use device handles,  the  function  should
       return <b>TCL_ERROR</b>.

       This value can be retrieved with <b>Tcl_ChannelGetHandleProc</b>, which returns a pointer to the function.

   <b>FLUSHPROC</b>
       The  <u>flushProc</u>  field  is currently reserved for future use.  It should be set to NULL.  <u>FlushProc</u> should
       match the following prototype:

              typedef int <b>Tcl_DriverFlushProc</b>(
                      void *<u>instanceData</u>);

       This value can be retrieved with <b>Tcl_ChannelFlushProc</b>, which returns a pointer to the function.

   <b>HANDLERPROC</b>
       The <u>handlerProc</u> field contains the address of a function called  by  the  generic  layer  to  notify  the
       channel  that  an  event  occurred.   It  should  be  defined for stacked channel drivers that wish to be
       notified of events that occur  on  the  underlying  (stacked)  channel.   <u>HandlerProc</u>  should  match  the
       following prototype:

              typedef int <b>Tcl_DriverHandlerProc</b>(
                      void *<u>instanceData</u>,
                      int <u>interestMask</u>);

       <u>InstanceData</u>  is  the  same  as the value passed to <b>Tcl_CreateChannel</b> when this channel was created.  The
       <u>interestMask</u> is an OR-ed combination of <b>TCL_READABLE</b> or <b>TCL_WRITABLE</b>; it indicates  what  type  of  event
       occurred on this channel.

       This value can be retrieved with <b>Tcl_ChannelHandlerProc</b>, which returns a pointer to the function.

   <b>THREADACTIONPROC</b>
       The  <u>threadActionProc</u>  field  contains  the  address  of  the function called by the generic layer when a
       channel is created, closed, or going to move to a different thread, i.e. whenever thread-specific  driver
       state might have to initialized or updated. It can be NULL.  The action <u>TCL_CHANNEL_THREAD_REMOVE</u> is used
       to notify the driver that it should update or remove any thread-specific data it might be maintaining for
       the channel.

       The action <u>TCL_CHANNEL_THREAD_INSERT</u> is used to notify the driver that it should update or initialize any
       thread-specific   data  it  might  be  maintaining  using  the  calling  thread  as  the  associate.  See
       <b>Tcl_CutChannel</b> and <b>Tcl_SpliceChannel</b> for more detail.

              typedef void <b>Tcl_DriverThreadActionProc</b>(
                      void *<u>instanceData</u>,
                      int <u>action</u>);

       <u>InstanceData</u> is the same as the value passed to <b>Tcl_CreateChannel</b> when this channel was created.

       These values can be retrieved with <b>Tcl_ChannelThreadActionProc</b>, which returns a pointer to the function.

   <b>TRUNCATEPROC</b>
       The <u>truncateProc</u> field contains the address of the function called by the generic layer when a channel is
       truncated to some length. It can be NULL.

              typedef int <b>Tcl_DriverTruncateProc</b>(
                      void *<u>instanceData</u>,
                      long long <u>length</u>);

       <u>InstanceData</u> is the same as the value passed to <b>Tcl_CreateChannel</b> when  this  channel  was  created,  and
       <u>length</u>  is the new length of the underlying file, which should not be negative. The result should be 0 on
       success or an errno code (suitable for use with <b>Tcl_SetErrno</b>) on failure.

       These values can be retrieved with <b>Tcl_ChannelTruncateProc</b>, which returns a pointer to the function.

</pre><h4><b>TCL_BADCHANNELOPTION</b></h4><pre>
       This procedure generates a “bad option” error message in  an  (optional)  interpreter.   It  is  used  by
       channel  drivers  when  an invalid Set/Get option is requested. Its purpose is to concatenate the generic
       options list to the specific ones and factorize the generic options error message string.

       It always returns <b>TCL_ERROR</b>

       An error message is generated in <u>interp</u>'s result value to indicate that a command was invoked with a  bad
       option.  The message has the form
                  bad option "blah": should be one of
                  &lt;...generic options...&gt;+&lt;...specific options...&gt;
       so you get for instance:
                  bad option "-blah": should be one of -blocking,
                  -buffering, -buffersize, -eofchar, -translation,
                  -peername, or -sockname
       when called with <u>optionList</u> equal to “peername sockname”

       “blah”  is  the <u>optionName</u> argument and “&lt;specific options&gt;” is a space separated list of specific option
       words.  The function takes good care of inserting minus signs before each option, commas  after,  and  an
       “or” before the last option.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/Tcl_Close.3tcl.html">Tcl_Close</a>(3tcl),        <a href="../man3tcl/Tcl_OpenFileChannel.3tcl.html">Tcl_OpenFileChannel</a>(3tcl),        <a href="../man3tcl/Tcl_SetErrno.3tcl.html">Tcl_SetErrno</a>(3tcl),       <a href="../man3tcl/Tcl_QueueEvent.3tcl.html">Tcl_QueueEvent</a>(3tcl),
       <a href="../man3tcl/Tcl_StackChannel.3tcl.html">Tcl_StackChannel</a>(3tcl), <a href="../man3tcl/Tcl_GetStdChannel.3tcl.html">Tcl_GetStdChannel</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       blocking, channel driver, channel registration, channel type, nonblocking

Tcl                                                    8.4                               <u><a href="../man3tcl/Tcl_CreateChannel.3tcl.html">Tcl_CreateChannel</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>