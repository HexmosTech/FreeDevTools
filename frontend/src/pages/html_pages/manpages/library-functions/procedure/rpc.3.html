<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rpc - library routines for remote procedure calls</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rpc - library routines for remote procedure calls

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b> <b>AND</b> <b>DESCRIPTION</b></h4><pre>
       These routines allow C programs to make procedure calls on other machines across the network.  First, the
       client  calls  a  procedure  to send a data packet to the server.  Upon receipt of the packet, the server
       calls a dispatch routine to perform the requested service, and then sends back  a  reply.   Finally,  the
       procedure call returns to the client.

       To take use of these routines, include the header file <u>&lt;rpc/rpc.h&gt;</u>.

       The prototypes below make use of the following types:

           <b>typedef</b> <b>int</b> <u>bool_t</u><b>;</b>

           <b>typedef</b> <b>bool_t</b> <b>(*</b><u>xdrproc_t</u><b>)(XDR</b> <b>*,</b> <b>void</b> <b>*,</b> <b>...);</b>

           <b>typedef</b> <b>bool_t</b> <b>(*</b><u>resultproc_t</u><b>)(caddr_t</b> <u>resp</u><b>,</b>
                                          <b>struct</b> <b>sockaddr_in</b> <b>*</b><u>raddr</u><b>);</b>

       See the header files for the declarations of the <u>AUTH</u>, <u>CLIENT</u>, <u>SVCXPRT</u>, and <u>XDR</u> types.

       <b>void</b> <b>auth_destroy(AUTH</b> <b>*</b><u>auth</u><b>);</b>

              A  macro  that  destroys the authentication information associated with <u>auth</u>.  Destruction usually
              involves deallocation of private data structures.  The use of  <u>auth</u>  is  undefined  after  calling
              <b>auth_destroy</b>().

       <b>AUTH</b> <b>*authnone_create(void);</b>

              Create  and  return  an RPC authentication handle that passes nonusable authentication information
              with each remote procedure call.  This is the default authentication used by RPC.

       <b>AUTH</b> <b>*authunix_create(char</b> <b>*</b><u>host</u><b>,</b> <b>uid_t</b> <u>uid</u><b>,</b> <b>gid_t</b> <u>gid</u><b>,</b>
                             <b>int</b> <u>len</u><b>,</b> <b>gid_t</b> <u>aup_gids</u><b>[.</b><u>len</u><b>]);</b>

              Create and return an RPC authentication handle  that  contains  authentication  information.   The
              parameter  <u>host</u> is the name of the machine on which the information was created; <u>uid</u> is the user's
              user ID; <u>gid</u> is the user's current group ID; <u>len</u> and <u>aup_gids</u> refer to a counted array  of  groups
              to which the user belongs.  It is easy to impersonate a user.

       <b>AUTH</b> <b>*authunix_create_default(void);</b>

              Calls <b>authunix_create</b>() with the appropriate parameters.

       <b>int</b> <b>callrpc(char</b> <b>*</b><u>host</u><b>,</b> <b>unsigned</b> <b>long</b> <u>prognum</u><b>,</b>
                   <b>unsigned</b> <b>long</b> <u>versnum</u><b>,</b> <b>unsigned</b> <b>long</b> <u>procnum</u><b>,</b>
                   <b>xdrproc_t</b> <u>inproc</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>in</u><b>,</b>
                   <b>xdrproc_t</b> <u>outproc</u><b>,</b> <b>char</b> <b>*</b><u>out</u><b>);</b>

              Call the remote procedure associated with <u>prognum</u>, <u>versnum</u>, and <u>procnum</u> on the machine, <u>host</u>.  The
              parameter  <u>in</u>  is  the  address of the procedure's argument(s), and <u>out</u> is the address of where to
              place the result(s); <u>inproc</u> is used to encode the procedure's parameters, and <u>outproc</u> is  used  to
              decode  the  procedure's  results.  This routine returns zero if it succeeds, or the value of <b>enum</b>
              <b>clnt_stat</b> cast to an integer if it fails.  The routine  <b>clnt_perrno</b>()  is  handy  for  translating
              failure statuses into messages.

              Warning:   calling   remote  procedures  with  this  routine  uses  UDP/IP  as  a  transport;  see
              <b>clntudp_create</b>() for restrictions.  You do not have control of timeouts  or  authentication  using
              this routine.

       <b>enum</b> <b>clnt_stat</b> <b>clnt_broadcast(unsigned</b> <b>long</b> <u>prognum</u><b>,</b>
                            <b>unsigned</b> <b>long</b> <u>versnum</u><b>,</b> <b>unsigned</b> <b>long</b> <u>procnum</u><b>,</b>
                            <b>xdrproc_t</b> <u>inproc</u><b>,</b> <b>char</b> <b>*</b><u>in</u><b>,</b>
                            <b>xdrproc_t</b> <u>outproc</u><b>,</b> <b>char</b> <b>*</b><u>out</u><b>,</b>
                            <b>resultproc_t</b> <u>eachresult</u><b>);</b>

              Like  <b>callrpc</b>(),  except  the  call  message is broadcast to all locally connected broadcast nets.
              Each time it receives a response, this routine calls <b>eachresult</b>(), whose form is:

                  <b>eachresult(char</b> <b>*</b><u>out</u><b>,</b> <b>struct</b> <b>sockaddr_in</b> <b>*</b><u>addr</u><b>);</b>

              where <u>out</u> is the same as <u>out</u> passed to <b>clnt_broadcast</b>(), except that the remote procedure's output
              is decoded there; <u>addr</u>  points  to  the  address  of  the  machine  that  sent  the  results.   If
              <b>eachresult</b>()  returns  zero,  <b>clnt_broadcast</b>()  waits  for more replies; otherwise it returns with
              appropriate status.

              Warning: broadcast sockets are limited in size to the maximum transfer unit of the data link.  For
              ethernet, this value is 1500 bytes.

       <b>enum</b> <b>clnt_stat</b> <b>clnt_call(CLIENT</b> <b>*</b><u>clnt</u><b>,</b> <b>unsigned</b> <b>long</b> <u>procnum</u><b>,</b>
                           <b>xdrproc_t</b> <u>inproc</u><b>,</b> <b>char</b> <b>*</b><u>in</u><b>,</b>
                           <b>xdrproc_t</b> <u>outproc</u><b>,</b> <b>char</b> <b>*</b><u>out</u><b>,</b>
                           <b>struct</b> <b>timeval</b> <u>tout</u><b>);</b>

              A macro that calls the remote procedure <u>procnum</u> associated with the client handle, <u>clnt</u>, which  is
              obtained  with  an  RPC  client  creation  routine such as <b>clnt_create</b>().  The parameter <u>in</u> is the
              address of the procedure's argument(s), and <u>out</u> is the address of where to  place  the  result(s);
              <u>inproc</u> is used to encode the procedure's parameters, and <u>outproc</u> is used to decode the procedure's
              results; <u>tout</u> is the time allowed for results to come back.

       <b>clnt_destroy(CLIENT</b> <b>*</b><u>clnt</u><b>);</b>

              A  macro  that  destroys  the  client's  RPC handle.  Destruction usually involves deallocation of
              private data  structures,  including  <u>clnt</u>  itself.   Use  of  <u>clnt</u>  is  undefined  after  calling
              <b>clnt_destroy</b>().   If  the  RPC  library  opened  the  associated  socket,  it  will close it also.
              Otherwise, the socket remains open.

       <b>CLIENT</b> <b>*clnt_create(const</b> <b>char</b> <b>*</b><u>host</u><b>,</b> <b>unsigned</b> <b>long</b> <u>prog</u><b>,</b>
                           <b>unsigned</b> <b>long</b> <u>vers</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>proto</u><b>);</b>

              Generic client creation routine.  <u>host</u> identifies the name of the remote host where the server  is
              located.  <u>proto</u> indicates which kind of transport protocol to use.  The currently supported values
              for  this  field  are  “udp”  and  “tcp”.   Default  timeouts  are  set, but can be modified using
              <b>clnt_control</b>().

              Warning: using UDP has its shortcomings.  Since UDP-based RPC messages  can  hold  only  up  to  8
              Kbytes  of encoded data, this transport cannot be used for procedures that take large arguments or
              return huge results.

       <b>bool_t</b> <b>clnt_control(CLIENT</b> <b>*</b><u>cl</u><b>,</b> <b>int</b> <u>req</u><b>,</b> <b>char</b> <b>*</b><u>info</u><b>);</b>

              A macro used to change or retrieve various information about a client object.  <u>req</u>  indicates  the
              type  of operation, and <u>info</u> is a pointer to the information.  For both UDP and TCP, the supported
              values of <u>req</u> and their argument types and what they do are:

                  <b>CLSET_TIMEOUT</b>  <u>struct</u> <u>timeval</u> // set total timeout
                  <b>CLGET_TIMEOUT</b>  <u>struct</u> <u>timeval</u> // get total timeout

              Note: if you set the timeout using <b>clnt_control</b>(), the timeout  parameter  passed  to  <b>clnt_call</b>()
              will be ignored in all future calls.

                  <b>CLGET_SERVER_ADDR</b>  <u>struct</u> <u>sockaddr_in</u>
                                  // get server's address

              The following operations are valid for UDP only:

                  <b>CLSET_RETRY_TIMEOUT</b>  <u>struct</u> <u>timeval</u> // set the retry timeout
                  <b>CLGET_RETRY_TIMEOUT</b>  <u>struct</u> <u>timeval</u> // get the retry timeout

              The  retry  timeout is the time that "UDP RPC" waits for the server to reply before retransmitting
              the request.

       <b>clnt_freeres(CLIENT</b> <b>*</b> <u>clnt</u><b>,</b> <b>xdrproc_t</b> <u>outproc</u><b>,</b> <b>char</b> <b>*</b><u>out</u><b>);</b>

              A macro that frees any data allocated by the RPC/XDR system when it decoded the results of an  RPC
              call.   The parameter <u>out</u> is the address of the results, and <u>outproc</u> is the XDR routine describing
              the results.  This routine returns one if the results were successfully freed, and zero otherwise.

       <b>void</b> <b>clnt_geterr(CLIENT</b> <b>*</b><u>clnt</u><b>,</b> <b>struct</b> <b>rpc_err</b> <b>*</b><u>errp</u><b>);</b>

              A macro that copies the error structure out of the client handle to the structure at address <u>errp</u>.

       <b>void</b> <b>clnt_pcreateerror(const</b> <b>char</b> <b>*</b><u>s</u><b>);</b>

              Print a message to standard error indicating why a client RPC handle could not  be  created.   The
              message  is  prepended  with  string  <u>s</u> and a colon.  Used when a <b>clnt_create</b>(), <b>clntraw_create</b>(),
              <b>clnttcp_create</b>(), or <b>clntudp_create</b>() call fails.

       <b>void</b> <b>clnt_perrno(enum</b> <b>clnt_stat</b> <u>stat</u><b>);</b>

              Print a message to standard error corresponding to the condition indicated by  <u>stat</u>.   Used  after
              <b>callrpc</b>().

       <b>clnt_perror(CLIENT</b> <b>*</b><u>clnt</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>s</u><b>);</b>

              Print a message to standard error indicating why an RPC call failed; <u>clnt</u> is the handle used to do
              the call.  The message is prepended with string <u>s</u> and a colon.  Used after <b>clnt_call</b>().

       <b>char</b> <b>*clnt_spcreateerror(const</b> <b>char</b> <b>*</b><u>s</u><b>);</b>

              Like  <b>clnt_pcreateerror</b>(),  except  that  it  returns a string instead of printing to the standard
              error.

              Bugs: returns pointer to static data that is overwritten on each call.

       <b>char</b> <b>*clnt_sperrno(enum</b> <b>clnt_stat</b> <u>stat</u><b>);</b>

              Take the same arguments as <b>clnt_perrno</b>(), but instead of sending a message to the  standard  error
              indicating  why  an RPC call failed, return a pointer to a string which contains the message.  The
              string ends with a NEWLINE.

              <b>clnt_sperrno</b>() is used instead of <b>clnt_perrno</b>() if the program does not have a standard error  (as
              a  program  running  as  a  server  quite likely does not), or if the programmer does not want the
              message to be output with <b><a href="../man3/printf.3.html">printf</a></b>(3), or if a message  format  different  than  that  supported  by
              <b>clnt_perrno</b>() is to be used.  Note: unlike <b>clnt_sperror</b>() and <b>clnt_spcreateerror</b>(), <b>clnt_sperrno</b>()
              returns pointer to static data, but the result will not get overwritten on each call.

       <b>char</b> <b>*clnt_sperror(CLIENT</b> <b>*</b><u>rpch</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>s</u><b>);</b>

              Like  <b>clnt_perror</b>(),  except that (like <b>clnt_sperrno</b>()) it returns a string instead of printing to
              standard error.

              Bugs: returns pointer to static data that is overwritten on each call.

       <b>CLIENT</b> <b>*clntraw_create(unsigned</b> <b>long</b> <u>prognum</u><b>,</b> <b>unsigned</b> <b>long</b> <u>versnum</u><b>);</b>

              This routine creates a toy RPC client for  the  remote  program  <u>prognum</u>,  version  <u>versnum</u>.   The
              transport  used  to pass messages to the service is actually a buffer within the process's address
              space, so the corresponding RPC server should live in the same address space; see <b>svcraw_create</b>().
              This allows simulation of RPC and acquisition of RPC overheads, such as round trip times,  without
              any kernel interference.  This routine returns NULL if it fails.

       <b>CLIENT</b> <b>*clnttcp_create(struct</b> <b>sockaddr_in</b> <b>*</b><u>addr</u><b>,</b>
                       <b>unsigned</b> <b>long</b> <u>prognum</u><b>,</b> <b>unsigned</b> <b>long</b> <u>versnum</u><b>,</b>
                       <b>int</b> <b>*</b><u>sockp</u><b>,</b> <b>unsigned</b> <b>int</b> <u>sendsz</u><b>,</b> <b>unsigned</b> <b>int</b> <u>recvsz</u><b>);</b>

              This  routine  creates  an  RPC client for the remote program <u>prognum</u>, version <u>versnum</u>; the client
              uses TCP/IP as a transport.  The  remote  program  is  located  at  Internet  address  <u>*addr</u>.   If
              <u>addr-&gt;sin_port</u>  is zero, then it is set to the actual port that the remote program is listening on
              (the remote <b>portmap</b> service is consulted for this information).  The parameter <u>sockp</u> is a  socket;
              if  it is <b>RPC_ANYSOCK</b>, then this routine opens a new one and sets <u>sockp</u>.  Since TCP-based RPC uses
              buffered I/O, the user may specify the size of the send and receive buffers  with  the  parameters
              <u>sendsz</u>  and  <u>recvsz</u>;  values  of  zero  choose suitable defaults.  This routine returns NULL if it
              fails.

       <b>CLIENT</b> <b>*clntudp_create(struct</b> <b>sockaddr_in</b> <b>*</b><u>addr</u><b>,</b>
                       <b>unsigned</b> <b>long</b> <u>prognum</u><b>,</b> <b>unsigned</b> <b>long</b> <u>versnum</u><b>,</b>
                       <b>struct</b> <b>timeval</b> <u>wait</u><b>,</b> <b>int</b> <b>*</b><u>sockp</u><b>);</b>

              This routine creates an RPC client for the remote program <u>prognum</u>,  version  <u>versnum</u>;  the  client
              uses  use  UDP/IP  as  a  transport.   The remote program is located at Internet address <u>addr</u>.  If
              <u>addr-&gt;sin_port</u> is zero, then it is set to actual port that the remote program is listening on (the
              remote <b>portmap</b> service is consulted for this information).  The parameter <u>sockp</u> is a socket; if it
              is <b>RPC_ANYSOCK</b>, then this routine opens a new one and sets <u>sockp</u>.  The UDP transport  resends  the
              call  message  in intervals of <u>wait</u> time until a response is received or until the call times out.
              The total time for the call to time out is specified by <b>clnt_call</b>().

              Warning: since UDP-based RPC messages can hold only up to 8 Kbytes of encoded data, this transport
              cannot be used for procedures that take large arguments or return huge results.

       <b>CLIENT</b> <b>*clntudp_bufcreate(struct</b> <b>sockaddr_in</b> <b>*</b><u>addr</u><b>,</b>
                   <b>unsigned</b> <b>long</b> <u>prognum</u><b>,</b> <b>unsigned</b> <b>long</b> <u>versnum</u><b>,</b>
                   <b>struct</b> <b>timeval</b> <u>wait</u><b>,</b> <b>int</b> <b>*</b><u>sockp</u><b>,</b>
                   <b>unsigned</b> <b>int</b> <u>sendsize</u><b>,</b> <b>unsigned</b> <b>int</b> <u>recosize</u><b>);</b>

              This routine creates an RPC client for the remote program <u>prognum</u>, on <u>versnum</u>; the client uses use
              UDP/IP as a transport.  The remote program is located at Internet address <u>addr</u>.  If <u>addr-&gt;sin_port</u>
              is zero, then it is set to actual port that the remote program is listening on (the remote <b>portmap</b>
              service is consulted  for  this  information).   The  parameter  <u>sockp</u>  is  a  socket;  if  it  is
              <b>RPC_ANYSOCK</b>, then this routine opens a new one and sets <u>sockp</u>.  The UDP transport resends the call
              message  in  intervals of <u>wait</u> time until a response is received or until the call times out.  The
              total time for the call to time out is specified by <b>clnt_call</b>().

              This allows the user to specify the maximum packet size for sending and  receiving  UDP-based  RPC
              messages.

       <b>void</b> <b>get_myaddress(struct</b> <b>sockaddr_in</b> <b>*</b><u>addr</u><b>);</b>

              Stuff  the machine's IP address into <u>*addr</u>, without consulting the library routines that deal with
              <u><a href="file:/etc/hosts">/etc/hosts</a></u>.  The port number is always set to <b>htons(PMAPPORT)</b>.

       <b>struct</b> <b>pmaplist</b> <b>*pmap_getmaps(struct</b> <b>sockaddr_in</b> <b>*</b><u>addr</u><b>);</b>

              A user interface to the <b>portmap</b> service, which returns a list of the current  RPC  program-to-port
              mappings  on  the  host  located  at IP address <u>*addr</u>.  This routine can return NULL.  The command
              <u>rpcinfo</u> <u>-p</u> uses this routine.

       <b>unsigned</b> <b>short</b> <b>pmap_getport(struct</b> <b>sockaddr_in</b> <b>*</b><u>addr</u><b>,</b>
                           <b>unsigned</b> <b>long</b> <u>prognum</u><b>,</b> <b>unsigned</b> <b>long</b> <u>versnum</u><b>,</b>
                           <b>unsigned</b> <b>int</b> <u>protocol</u><b>);</b>

              A user interface to the <b>portmap</b> service, which returns the port number on which  waits  a  service
              that  supports  program  number  <u>prognum</u>,  version  <u>versnum</u>,  and  speaks  the  transport protocol
              associated with <u>protocol</u>.  The value of <u>protocol</u> is most likely  <b>IPPROTO_UDP</b>  or  <b>IPPROTO_TCP</b>.   A
              return  value  of  zero  means  that  the  mapping does not exist or that the RPC system failed to
              contact the remote <b>portmap</b> service.   In  the  latter  case,  the  global  variable  <u>rpc_createerr</u>
              contains the RPC status.

       <b>enum</b> <b>clnt_stat</b> <b>pmap_rmtcall(struct</b> <b>sockaddr_in</b> <b>*</b><u>addr</u><b>,</b>
                           <b>unsigned</b> <b>long</b> <u>prognum</u><b>,</b> <b>unsigned</b> <b>long</b> <u>versnum</u><b>,</b>
                           <b>unsigned</b> <b>long</b> <u>procnum</u><b>,</b>
                           <b>xdrproc_t</b> <u>inproc</u><b>,</b> <b>char</b> <b>*</b><u>in</u><b>,</b>
                           <b>xdrproc_t</b> <u>outproc</u><b>,</b> <b>char</b> <b>*</b><u>out</u><b>,</b>
                           <b>struct</b> <b>timeval</b> <u>tout</u><b>,</b> <b>unsigned</b> <b>long</b> <b>*</b><u>portp</u><b>);</b>

              A  user  interface to the <b>portmap</b> service, which instructs <b>portmap</b> on the host at IP address <u>*addr</u>
              to make an RPC call on your behalf to a procedure on that host.   The  parameter  <u>*portp</u>  will  be
              modified  to  the  program's  port  number  if  the  procedure succeeds.  The definitions of other
              parameters are discussed in <b>callrpc</b>() and <b>clnt_call</b>().  This procedure should be used for a “ping”
              and nothing else.  See also <b>clnt_broadcast</b>().

       <b>bool_t</b> <b>pmap_set(unsigned</b> <b>long</b> <u>prognum</u><b>,</b> <b>unsigned</b> <b>long</b> <u>versnum</u><b>,</b>
                       <b>int</b> <u>protocol</u><b>,</b> <b>unsigned</b> <b>short</b> <u>port</u><b>);</b>

              A user interface  to  the  <b>portmap</b>  service,  which  establishes  a  mapping  between  the  triple
              [<u>prognum</u>,<u>versnum</u>,<u>protocol</u>]  and  <u>port</u>  on the machine's <b>portmap</b> service.  The value of <u>protocol</u> is
              most likely <b>IPPROTO_UDP</b> or <b>IPPROTO_TCP</b>.  This routine returns one if it succeeds, zero  otherwise.
              Automatically done by <b>svc_register</b>().

       <b>bool_t</b> <b>pmap_unset(unsigned</b> <b>long</b> <u>prognum</u><b>,</b> <b>unsigned</b> <b>long</b> <u>versnum</u><b>);</b>

              A  user  interface  to  the  <b>portmap</b>  service,  which  destroys  all  mapping  between  the triple
              [<u>prognum</u>,<u>versnum</u>,<u>*</u>] and <b>ports</b> on the machine's <b>portmap</b> service.  This routine returns  one  if  it
              succeeds, zero otherwise.

       <b>int</b> <b>registerrpc(unsigned</b> <b>long</b> <u>prognum</u><b>,</b> <b>unsigned</b> <b>long</b> <u>versnum</u><b>,</b>
                       <b>unsigned</b> <b>long</b> <u>procnum</u><b>,</b> <b>char</b> <b>*(*</b><u>procname</u><b>)(char</b> <b>*),</b>
                       <b>xdrproc_t</b> <u>inproc</u><b>,</b> <b>xdrproc_t</b> <u>outproc</u><b>);</b>

              Register  procedure  <u>procname</u>  with  the  RPC  service  package.  If a request arrives for program
              <u>prognum</u>, version <u>versnum</u>, and procedure  <u>procnum</u>,  <u>procname</u>  is  called  with  a  pointer  to  its
              parameter(s);  <u>procname</u>  should return a pointer to its static result(s); <u>inproc</u> is used to decode
              the parameters while <u>outproc</u> is used to encode the results.  This  routine  returns  zero  if  the
              registration succeeded, -1 otherwise.

              Warning:  remote  procedures  registered in this form are accessed using the UDP/IP transport; see
              <b>svcudp_create</b>() for restrictions.

       <b>struct</b> <b>rpc_createerr</b> <u>rpc_createerr</u><b>;</b>

              A global variable whose value is set by any RPC client creation routine  that  does  not  succeed.
              Use the routine <b>clnt_pcreateerror</b>() to print the reason why.

       <b>void</b> <b>svc_destroy(SVCXPRT</b> <b>*</b><u>xprt</u><b>);</b>

              A  macro  that  destroys  the  RPC  service  transport handle, <u>xprt</u>.  Destruction usually involves
              deallocation of private data structures, including <u>xprt</u> itself.  Use of <u>xprt</u>  is  undefined  after
              calling this routine.

       <b>fd_set</b> <u>svc_fdset</u><b>;</b>

              A  global variable reflecting the RPC service side's read file descriptor bit mask; it is suitable
              as a parameter to the <b><a href="../man2/select.2.html">select</a></b>(2) system call.  This is of interest only if  a  service  implementor
              does  their  own  asynchronous  event  processing, instead of calling <b>svc_run</b>().  This variable is
              read-only  (do  not  pass  its  address  to  <b><a href="../man2/select.2.html">select</a></b>(2)!),  yet  it  may  change  after  calls   to
              <b>svc_getreqset</b>() or any creation routines.

       <b>int</b> <u>svc_fds</u><b>;</b>

              Similar  to  <b>svc_fdset</b>,  but  limited  to  32  file  descriptors.   This interface is obsoleted by
              <b>svc_fdset</b>.

       <b>svc_freeargs(SVCXPRT</b> <b>*</b><u>xprt</u><b>,</b> <b>xdrproc_t</b> <u>inproc</u><b>,</b> <b>char</b> <b>*</b><u>in</u><b>);</b>

              A macro that frees any data allocated by the RPC/XDR system when it decoded  the  arguments  to  a
              service  procedure  using  <b>svc_getargs</b>().  This routine returns 1 if the results were successfully
              freed, and zero otherwise.

       <b>svc_getargs(SVCXPRT</b> <b>*</b><u>xprt</u><b>,</b> <b>xdrproc_t</b> <u>inproc</u><b>,</b> <b>char</b> <b>*</b><u>in</u><b>);</b>

              A macro that decodes the arguments of an RPC request associated with  the  RPC  service  transport
              handle,  <u>xprt</u>.   The parameter <u>in</u> is the address where the arguments will be placed; <u>inproc</u> is the
              XDR routine used to decode the arguments.  This routine returns one if decoding succeeds, and zero
              otherwise.

       <b>struct</b> <b>sockaddr_in</b> <b>*svc_getcaller(SVCXPRT</b> <b>*</b><u>xprt</u><b>);</b>

              The approved way of getting the network address of the caller of a procedure associated  with  the
              RPC service transport handle, <u>xprt</u>.

       <b>void</b> <b>svc_getreqset(fd_set</b> <b>*</b><u>rdfds</u><b>);</b>

              This  routine  is  of  interest only if a service implementor does not call <b>svc_run</b>(), but instead
              implements custom asynchronous event processing.  It is called when the <b><a href="../man2/select.2.html">select</a></b>(2) system call  has
              determined that an RPC request has arrived on some RPC socket(s); <u>rdfds</u> is the resultant read file
              descriptor bit mask.  The routine returns when all sockets associated with the value of <u>rdfds</u> have
              been serviced.

       <b>void</b> <b>svc_getreq(int</b> <u>rdfds</u><b>);</b>

              Similar  to  <b>svc_getreqset</b>(),  but limited to 32 file descriptors.  This interface is obsoleted by
              <b>svc_getreqset</b>().

       <b>bool_t</b> <b>svc_register(SVCXPRT</b> <b>*</b><u>xprt</u><b>,</b> <b>unsigned</b> <b>long</b> <u>prognum</u><b>,</b>
                           <b>unsigned</b> <b>long</b> <u>versnum</u><b>,</b>
                           <b>void</b> <b>(*</b><u>dispatch</u><b>)(struct</b> <b>svc_req</b> <b>*,</b> <b>SVCXPRT</b> <b>*),</b>
                           <b>unsigned</b> <b>long</b> <u>protocol</u><b>);</b>

              Associates <u>prognum</u> and <u>versnum</u> with the service dispatch  procedure,  <u>dispatch</u>.   If  <u>protocol</u>  is
              zero,  the  service  is  not  registered with the <b>portmap</b> service.  If <u>protocol</u> is nonzero, then a
              mapping of the triple [<u>prognum</u>,<u>versnum</u>,<u>protocol</u>] to <u>xprt-&gt;xp_port</u> is established  with  the  local
              <b>portmap</b>  service (generally <u>protocol</u> is zero, <b>IPPROTO_UDP</b> or <b>IPPROTO_TCP</b>).  The procedure <u>dispatch</u>
              has the following form:

                  dispatch(struct svc_req *request, SVCXPRT *xprt);

              The <b>svc_register</b>() routine returns one if it succeeds, and zero otherwise.

       <b>void</b> <b>svc_run(void);</b>

              This routine never returns.  It waits for RPC  requests  to  arrive,  and  calls  the  appropriate
              service  procedure  using  <b>svc_getreq</b>() when one arrives.  This procedure is usually waiting for a
              <b><a href="../man2/select.2.html">select</a></b>(2) system call to return.

       <b>bool_t</b> <b>svc_sendreply(SVCXPRT</b> <b>*</b><u>xprt</u><b>,</b> <b>xdrproc_t</b> <u>outproc</u><b>,</b> <b>char</b> <b>*</b><u>out</u><b>);</b>

              Called by an RPC service's dispatch routine to send the results of a remote procedure  call.   The
              parameter  <u>xprt</u>  is the request's associated transport handle; <u>outproc</u> is the XDR routine which is
              used to encode the results; and <u>out</u> is the address of the results.  This routine returns one if it
              succeeds, zero otherwise.

       <b>void</b> <b>svc_unregister(unsigned</b> <b>long</b> <u>prognum</u><b>,</b> <b>unsigned</b> <b>long</b> <u>versnum</u><b>);</b>

              Remove all mapping of the double  [<u>prognum</u>,<u>versnum</u>]  to  dispatch  routines,  and  of  the  triple
              [<u>prognum</u>,<u>versnum</u>,<u>*</u>] to port number.

       <b>void</b> <b>svcerr_auth(SVCXPRT</b> <b>*</b><u>xprt</u><b>,</b> <b>enum</b> <b>auth_stat</b> <u>why</u><b>);</b>

              Called  by  a  service  dispatch routine that refuses to perform a remote procedure call due to an
              authentication error.

       <b>void</b> <b>svcerr_decode(SVCXPRT</b> <b>*</b><u>xprt</u><b>);</b>

              Called by a service dispatch routine that cannot successfully decode  its  parameters.   See  also
              <b>svc_getargs</b>().

       <b>void</b> <b>svcerr_noproc(SVCXPRT</b> <b>*</b><u>xprt</u><b>);</b>

              Called  by a service dispatch routine that does not implement the procedure number that the caller
              requests.

       <b>void</b> <b>svcerr_noprog(SVCXPRT</b> <b>*</b><u>xprt</u><b>);</b>

              Called when the desired program is not registered with  the  RPC  package.   Service  implementors
              usually do not need this routine.

       <b>void</b> <b>svcerr_progvers(SVCXPRT</b> <b>*</b><u>xprt</u><b>,</b> <b>unsigned</b> <b>long</b> <u>low_vers</u><b>,</b>
                            <b>unsigned</b> <b>long</b> <u>high_vers</u><b>);</b>

              Called  when  the  desired  version  of a program is not registered with the RPC package.  Service
              implementors usually do not need this routine.

       <b>void</b> <b>svcerr_systemerr(SVCXPRT</b> <b>*</b><u>xprt</u><b>);</b>

              Called by a service dispatch routine when it detects a system error not covered by any  particular
              protocol.  For example, if a service can no longer allocate storage, it may call this routine.

       <b>void</b> <b>svcerr_weakauth(SVCXPRT</b> <b>*</b><u>xprt</u><b>);</b>

              Called  by  a  service  dispatch  routine  that  refuses to perform a remote procedure call due to
              insufficient authentication parameters.  The routine calls <b>svcerr_auth(xprt,</b> <b>AUTH_TOOWEAK)</b>.

       <b>SVCXPRT</b> <b>*svcfd_create(int</b> <u>fd</u><b>,</b> <b>unsigned</b> <b>int</b> <u>sendsize</u><b>,</b>
                             <b>unsigned</b> <b>int</b> <u>recvsize</u><b>);</b>

              Create a service on top of any open  file  descriptor.   Typically,  this  file  descriptor  is  a
              connected  socket for a stream protocol such as TCP.  <u>sendsize</u> and <u>recvsize</u> indicate sizes for the
              send and receive buffers.  If they are zero, a reasonable default is chosen.

       <b>SVCXPRT</b> <b>*svcraw_create(void);</b>

              This routine creates a toy RPC service transport, to which it returns a pointer.  The transport is
              really a buffer within the process's address space, so the corresponding RPC client should live in
              the same address  space;  see  <b>clntraw_create</b>().   This  routine  allows  simulation  of  RPC  and
              acquisition  of  RPC  overheads (such as round trip times), without any kernel interference.  This
              routine returns NULL if it fails.

       <b>SVCXPRT</b> <b>*svctcp_create(int</b> <u>sock</u><b>,</b> <b>unsigned</b> <b>int</b> <u>send_buf_size</u><b>,</b>
                              <b>unsigned</b> <b>int</b> <u>recv_buf_size</u><b>);</b>

              This routine creates a TCP/IP-based RPC service transport, to which it  returns  a  pointer.   The
              transport is associated with the socket <u>sock</u>, which may be <b>RPC_ANYSOCK</b>, in which case a new socket
              is  created.   If  the  socket  is not bound to a local TCP port, then this routine binds it to an
              arbitrary port.   Upon  completion,  <u>xprt-&gt;xp_sock</u>  is  the  transport's  socket  descriptor,  and
              <u>xprt-&gt;xp_port</u>  is the transport's port number.  This routine returns NULL if it fails.  Since TCP-
              based RPC uses buffered I/O, users may specify the size of buffers; values of zero choose suitable
              defaults.

       <b>SVCXPRT</b> <b>*svcudp_bufcreate(int</b> <u>sock</u><b>,</b> <b>unsigned</b> <b>int</b> <u>sendsize</u><b>,</b>
                                 <b>unsigned</b> <b>int</b> <u>recosize</u><b>);</b>

              This routine creates a UDP/IP-based RPC service transport, to which it  returns  a  pointer.   The
              transport is associated with the socket <u>sock</u>, which may be <b>RPC_ANYSOCK</b>, in which case a new socket
              is  created.   If  the  socket  is not bound to a local UDP port, then this routine binds it to an
              arbitrary port.   Upon  completion,  <u>xprt-&gt;xp_sock</u>  is  the  transport's  socket  descriptor,  and
              <u>xprt-&gt;xp_port</u> is the transport's port number.  This routine returns NULL if it fails.

              This  allows  the  user to specify the maximum packet size for sending and receiving UDP-based RPC
              messages.

       <b>SVCXPRT</b> <b>*svcudp_create(int</b> <u>sock</u><b>);</b>

              This call is equivalent to <u>svcudp_bufcreate(sock,SZ,SZ)</u> for some default size <u>SZ</u>.

       <b>bool_t</b> <b>xdr_accepted_reply(XDR</b> <b>*</b><u>xdrs</u><b>,</b> <b>struct</b> <b>accepted_reply</b> <b>*</b><u>ar</u><b>);</b>

              Used for encoding RPC reply messages.  This routine is useful for users who wish to generate  RPC-
              style messages without using the RPC package.

       <b>bool_t</b> <b>xdr_authunix_parms(XDR</b> <b>*</b><u>xdrs</u><b>,</b> <b>struct</b> <b>authunix_parms</b> <b>*</b><u>aupp</u><b>);</b>

              Used for describing UNIX credentials.  This routine is useful for users who wish to generate these
              credentials without using the RPC authentication package.

       <b>void</b> <b>xdr_callhdr(XDR</b> <b>*</b><u>xdrs</u><b>,</b> <b>struct</b> <b>rpc_msg</b> <b>*</b><u>chdr</u><b>);</b>

              Used  for  describing  RPC  call  header  messages.   This routine is useful for users who wish to
              generate RPC-style messages without using the RPC package.

       <b>bool_t</b> <b>xdr_callmsg(XDR</b> <b>*</b><u>xdrs</u><b>,</b> <b>struct</b> <b>rpc_msg</b> <b>*</b><u>cmsg</u><b>);</b>

              Used for describing RPC call messages.  This routine is useful for users who wish to generate RPC-
              style messages without using the RPC package.

       <b>bool_t</b> <b>xdr_opaque_auth(XDR</b> <b>*</b><u>xdrs</u><b>,</b> <b>struct</b> <b>opaque_auth</b> <b>*</b><u>ap</u><b>);</b>

              Used for describing RPC authentication information messages.  This routine is useful for users who
              wish to generate RPC-style messages without using the RPC package.

       <b>bool_t</b> <b>xdr_pmap(XDR</b> <b>*</b><u>xdrs</u><b>,</b> <b>struct</b> <b>pmap</b> <b>*</b><u>regs</u><b>);</b>

              Used for describing parameters to various <b>portmap</b> procedures, externally.  This routine is  useful
              for users who wish to generate these parameters without using the <b>pmap</b> interface.

       <b>bool_t</b> <b>xdr_pmaplist(XDR</b> <b>*</b><u>xdrs</u><b>,</b> <b>struct</b> <b>pmaplist</b> <b>**</b><u>rp</u><b>);</b>

              Used  for  describing  a  list of port mappings, externally.  This routine is useful for users who
              wish to generate these parameters without using the <b>pmap</b> interface.

       <b>bool_t</b> <b>xdr_rejected_reply(XDR</b> <b>*</b><u>xdrs</u><b>,</b> <b>struct</b> <b>rejected_reply</b> <b>*</b><u>rr</u><b>);</b>

              Used for describing RPC reply messages.  This routine is useful for users  who  wish  to  generate
              RPC-style messages without using the RPC package.

       <b>bool_t</b> <b>xdr_replymsg(XDR</b> <b>*</b><u>xdrs</u><b>,</b> <b>struct</b> <b>rpc_msg</b> <b>*</b><u>rmsg</u><b>);</b>

              Used for describing RPC reply messages.  This routine is useful for users who wish to generate RPC
              style messages without using the RPC package.

       <b>void</b> <b>xprt_register(SVCXPRT</b> <b>*</b><u>xprt</u><b>);</b>

              After  RPC  service  transport  handles  are created, they should register themselves with the RPC
              service package.  This routine modifies the global variable <u>svc_fds</u>.  Service implementors usually
              do not need this routine.

       <b>void</b> <b>xprt_unregister(SVCXPRT</b> <b>*</b><u>xprt</u><b>);</b>

              Before an RPC service transport handle is destroyed, it should  unregister  itself  with  the  RPC
              service package.  This routine modifies the global variable <u>svc_fds</u>.  Service implementors usually
              do not need this routine.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       For an explanation of the terms used in this section, see <b><a href="../man7/attributes.7.html">attributes</a></b>(7).
       ┌─────────────────────────────────────────────────────────────────────────────┬───────────────┬─────────┐
       │ <b>Interface</b>                                                                   │ <b>Attribute</b>     │ <b>Value</b>   │
       ├─────────────────────────────────────────────────────────────────────────────┼───────────────┼─────────┤
       │ <b>auth_destroy</b>(), <b>authnone_create</b>(), <b>authunix_create</b>(),                       │ Thread safety │ MT-Safe │
       │ <b>authunix_create_default</b>(), <b>callrpc</b>(), <b>clnt_broadcast</b>(), <b>clnt_call</b>(),        │               │         │
       │ <b>clnt_destroy</b>(), <b>clnt_create</b>(), <b>clnt_control</b>(), <b>clnt_freeres</b>(),              │               │         │
       │ <b>clnt_geterr</b>(), <b>clnt_pcreateerror</b>(), <b>clnt_perrno</b>(), <b>clnt_perror</b>(),           │               │         │
       │ <b>clnt_spcreateerror</b>(), <b>clnt_sperrno</b>(), <b>clnt_sperror</b>(), <b>clntraw_create</b>(),     │               │         │
       │ <b>clnttcp_create</b>(), <b>clntudp_create</b>(), <b>clntudp_bufcreate</b>(), <b>get_myaddress</b>(),   │               │         │
       │ <b>pmap_getmaps</b>(), <b>pmap_getport</b>(), <b>pmap_rmtcall</b>(), <b>pmap_set</b>(), <b>pmap_unset</b>(),   │               │         │
       │ <b>registerrpc</b>(), <b>svc_destroy</b>(), <b>svc_freeargs</b>(), <b>svc_getargs</b>(),                │               │         │
       │ <b>svc_getcaller</b>(), <b>svc_getreqset</b>(), <b>svc_getreq</b>(), <b>svc_register</b>(), <b>svc_run</b>(),  │               │         │
       │ <b>svc_sendreply</b>(), <b>svc_unregister</b>(), <b>svcerr_auth</b>(), <b>svcerr_decode</b>(),          │               │         │
       │ <b>svcerr_noproc</b>(), <b>svcerr_noprog</b>(), <b>svcerr_progvers</b>(), <b>svcerr_systemerr</b>(),    │               │         │
       │ <b>svcerr_weakauth</b>(), <b>svcfd_create</b>(), <b>svcraw_create</b>(), <b>svctcp_create</b>(),        │               │         │
       │ <b>svcudp_bufcreate</b>(), <b>svcudp_create</b>(), <b>xdr_accepted_reply</b>(),                  │               │         │
       │ <b>xdr_authunix_parms</b>(), <b>xdr_callhdr</b>(), <b>xdr_callmsg</b>(), <b>xdr_opaque_auth</b>(),      │               │         │
       │ <b>xdr_pmap</b>(), <b>xdr_pmaplist</b>(), <b>xdr_rejected_reply</b>(), <b>xdr_replymsg</b>(),           │               │         │
       │ <b>xprt_register</b>(), <b>xprt_unregister</b>()                                          │               │         │
       └─────────────────────────────────────────────────────────────────────────────┴───────────────┴─────────┘

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/xdr.3.html">xdr</a></b>(3)

       The following manuals:
              Remote Procedure Calls: Protocol Specification
              Remote Procedure Call Programming Guide
              rpcgen Programming Guide

       <u>RPC:</u> <u>Remote</u> <u>Procedure</u> <u>Call</u> <u>Protocol</u> <u>Specification</u>, RFC 1050, Sun Microsystems, Inc., USC-ISI.

Linux man-pages 6.9.1                              2024-05-02                                             <u><a href="../man3/rpc.3.html">rpc</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>