<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UR::DataSource - manage the the relationship between objects and a specific storage system</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libur-perl">libur-perl_0.470+ds-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       UR::DataSource - manage the the relationship between objects and a specific storage system

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package MyApp::DataSource::DB;

         class MyApp::DataSource::DB {
             is =&gt; ['UR::DataSource::Oracle','UR::Singleton'],
         };
         sub server { 'main_db_server' }
         sub login  { 'db_user' }
         sub auth   { 'db_passwd' }
         sub owner  { 'db_owner' }
         1;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Data source instances represent a logical source of data to the application.  Most of them are likely to
       be some kind of relational database, but not all are.  UR::DataSource is an abstract base class inherited
       by other data sources.

       In normal use, your data sources will probably inherit from an abstract data source class such as
       UR::DataSource::Oracle or UR::DataSource::File, as well as UR::Singleton.  This makes it easy to link
       classes to this data source, since the class name will be the same as its ID, and the module autoloader
       will instantiate it automatically.

</pre><h4><b>INHERITANCE</b></h4><pre>
       UR::Object

</pre><h4><b>Methods</b></h4><pre>
       User applications will seldom interact with data sources directly.

       autogenerate_new_object_id_for_class_name_and_rule
             my $id = $datasource-&gt;autogenerate_new_object_id_for_class_name_and_rule($class,$boolexpr);

           UR::Object::Type  calls this when the application calls <b>create()</b> on a class to create a new instance,
           but does not specify a value for the ID property.  The default  implementation  throws  an  exception
           with  "die", but UR::DataSource::RDBMS is able to query a sequence in the database to generate unique
           IDs.  A developer implementing a new data source will need to override  this  method  and  provide  a
           sensible implementation.

       next_dummy_autogenerated_id
             my $int = $datasource-&gt;next_dummy_autogenerated_id()

           In  a  testing  situation,  is  often  preferable  to  avoid  using  the  database's  sequence for ID
           autogeneration but still make ID values that are unique.  UR::DataSource::RDBMS calls this method  if
           the  "use_dummy_autogenerated_ids"  (see  below)  flag is true.  The IDs generated by this method are
           unique during the life of the process.  In addition, objects with dummy-generated IDs will  never  be
           saved to a real data source during <b>UR::Context::commit()</b>.

       use_dummy_autogenerated_ids
             $bool = $datasource-&gt;use_dummy_autogenerated_ids();
             $datasource-&gt;use_dummy_autogenerated_ids($bool);

           Get  or  set  a  flag controlling how object IDs are autogenerated.  Data source child classes should
           look     at     the     value     of     this     flag     inside     their     implementation     of
           "autogenerate_new_object_id_for_class_name_and_rule".       If     true,     they     should     call
           "next_dummy_autogenerated_id" and return that value instead of attempting to generate an ID on  their
           own.  This flag is also tied to the UR_USE_DUMMY_AUTOGENERATED_IDS environment variable.

       resolve_data_sources_for_rule
             $possibly_other_data_source = $data_source-&gt;resolve_data_sources_for_rule($boolexpr);

           When  UR::Context is determining which data source to use to process a <b>get()</b> request, it looks at the
           class metadata for its data source, and then calls "resolve_data_sources_for_rule" to give that  data
           source a chance to defer to another data source.

       create_iterator_closure_for_rule_template_and_values
             $subref = $datasource-&gt;create_iterator_closure_for_rule_template_and_values(
                                        $boolexpr_tmpl,
                                        @values
                                    );

           A front-end for the more widely used "create_iterator_closure_for_rule"

       create_iterator_closure_for_rule
             $subref = $datasource-&gt;create_iterator_closure_for_rule($boolexpr);

           This is the main entry point UR::Context uses to get data from its underlying data sources.  There is
           no  default implementation; each subclass implementing specific data source types must supply its own
           code.

           The method must accept a UR::BoolExpr $boolexpr (rule), and return a subref.  Each time the subref is
           called it must return one arrayref of data satisfying the rule, and undef when there is no more  data
           to return.

       _sync_database
             $bool = $datasource-&gt;_sync_database(changed_objects =&gt; $listref);

           Called  by  UR::Context <b>commit()</b>.  $listref will contain all the changed objects that should be saved
           to that data source.  The default implementation prints a warning message and  returns  true  without
           saving  anything.  UR::DataSource::RDBMS has a functioning <b>_sync_database()</b> capable of generating SQL
           to update, insert and delete rows from the database's tables.

           The data source should return true if all the changes were successfully made,  false  if  there  were
           problems.

       commit
             $bool = $datasource-&gt;commit()

           Called  by  UR::Context <b>commit()</b>.  After all data sources return true from <b>_sync_database()</b>, "commit"
           must make those changes permanent.  For RDBMS-type data sources, this commits the transaction.

           Return true if the commit is successful, false otherwise.

       rollback
             $bool = $datasource-&gt;rollback()

           Called by "commit" in UR::Context if any data sources has problems during _sync_database  or  commit.
           It  is  also  called  by  "rollback" in UR::Context.  Data sources should reverse any changes applied
           during a prior "_sync_database" that has not been made permanent by "commit".

       get_default_handle
             $scalar = $datasource-&gt;get_default_handle();

           Should return the "handle" associated with any underlying logical data.  For an  RDBMS  data  source,
           this is the DBI database handle.  For a file-based data source, this is the &lt;IO::File&gt; file handle.

       create_from_inline_class_data
             $datasource = $data_source_class_name-&gt;create_from_inline_class_data(
                                                        $class_data_hashref,
                                                        $datasource_data_hashref
                                                    );

           Called  by  the class initializer when a class definition contains an in-line data source definition.
           See "Inline Data Sources" in UR::Object::Type::Initializer.

       _ignore_table
             $bool = $datasource-&gt;_ignore_table($table_name);

           Used to indicate whether the "ur update classes" command should create a class for the named table or
           not.  If <b>_ignore_table()</b> returns true, then it will not create a class.

</pre><h4><b>Internal</b> <b>API</b> <b>Methods</b></h4><pre>
       _get_class_data_for_loading
       _generate_class_data_for_loading
             $hashref = $datasource-&gt;_resolve_query_plan($class_meta);

           These  two  methods  are  called  by  UR::Context  as   part   of   the   object   loading   process.
           "_generate_class_data_for_loading"  collects  information  about  a  class  and its metadata, such as
           property names, subclassing information and tables connected to  the  class,  and  stores  that  data
           inside the class's metadata object.

           "_get_class_data_for_loading" is the main entry point; it calls "_generate_class_data_for_loading" if
           the data has not been generated and cached yet, and caches the data in the class metadata object.

       _resolve_query_plan
       _generate_template_data_for_loading
             $hashref = $datasource-&gt;_resolve_query_plan($boolexpr_tmpl);

           These   two   methods   are   called   by   UR::Context  as  part  of  the  object  loading  process.
           "_generate_template_data_for_loading"   collects   information   from   the    UR::BoolExpr::Template
           $boolexpr_tmpl  (rule  template)  and  returns a hashref used later by the data source.  This hashref
           includes hints about what classes will be involved in loading the resulting data, how  those  classes
           are  joined  together  and  how  columns  in the underlying query against the data source will map to
           properties of the class.

           "_resolve_query_plan" is the main entry point; it calls "_generate_template_data_for_loading" if  the
           data has not been generated and cached yet, and caches the data in the rule template object.

       _generate_loading_templates_arrayref
             my $listref = $datasource-&gt;_generate_loading_templates_arrayref($listref);

           Called by <b>_generate_template_data_for_loading()</b>.  The input is a listref of listrefs about properties
           involved in a query.  The second-level data is sets of quads:

           1. The class object for this property
           2. The property metadata object
           3. The database table name the data will come from
           4 The "object number", starting with 0.  This is used in inheritance or delegation where a table join
           will be required.

           It  returns  a listref of hashrefs, one hashref for every class involved in the request; usually just
           1, but can be more than one if inheritance or delegation is involved.  The data includes  information
           about  the  class's properties, ID properties, and which columns of the result set the values will be
           found.

</pre><h4><b>MetaDB</b></h4><pre>
       Each Namespace created through "ur define namespace" will have a data  source  called  the  MetaDB.   For
       example,  the  MyApp  namespace's  MetaDB is called MyApp::DataSource::Meta.  The MetaDB is used to store
       information about the schemas of other data sources in  the  database.   UR  itself  has  a  MetaDB  with
       information about the MetaDB's schema, called UR::DataSource::Meta.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       UR::DataSource::RDBMS
           The   base   class   for   relational   database   Data   Sources,  such  as  UR::DataSource::Oracle,
           UR::DataSoure::Pg, UR::DataSource::MySQL and UR::DataSource::SQLite

       UR::DataSource::File,
           The base class for comma/tab delimited files

       UR::DataSource::FileMux
           The base class for file multiplexor data sources.

       UR::Context, UR::DataSource::Meta

perl v5.38.2                                       2024-06-15                                <u>UR::<a href="../man3pm/DataSource.3pm.html">DataSource</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>