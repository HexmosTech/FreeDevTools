<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Function_Qualifiers - Qualifiers for kernel functions.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/opencl-1.2-man-doc">opencl-1.2-man-doc_1.0~svn33624-5.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Function_Qualifiers - Qualifiers for kernel functions.

       __kernel kernel

       __attribute__((vec_type_hint(&lt;type<u>n</u>&gt;)))
       __attribute__((work_group_size_hint(<u>X</u>, <u>Y</u>, <u>Z</u>)))
       __attribute__((reqd_work_group_size(<u>X</u>, <u>Y</u>, <u>Z</u>)))

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>__kernel</b> (or <b>kernel</b>) qualifier declares a function to be a kernel that can be executed by an
       application on an OpenCL device(s). The following rules apply to functions that are declared with this
       qualifier:

       •   It can be executed on the device only

       •   It can be called by the host

       •   It is just a regular function call if a <b>__kernel</b> function is called by another kernel function.

       Kernel functions with variables declared inside the function with the <b><a href="../man3clc/local.3clc.html">local</a></b>(3clc) or <b><a href="../man3clc/local.3clc.html">local</a></b>(3clc)
       qualifier can be called by the host using appropriate APIs such as <b><a href="../man3clc/clEnqueueNDRangeKernel.3clc.html">clEnqueueNDRangeKernel</a></b>(3clc), and
       <b><a href="../man3clc/clEnqueueTask.3clc.html">clEnqueueTask</a></b>(3clc).

       The behavior of calling kernel functions with variables declared inside the function with the <b><a href="../man3clc/local.3clc.html">local</a></b>(3clc)
       or <b><a href="../man3clc/local.3clc.html">local</a></b>(3clc) qualifier from other kernel functions is implementation-defined.

       The <b>__kernel</b> and <b>kernel</b> names are reserved for use as functions qualifiers and shall not be used
       otherwise.  Optional Attribute Qualifiers.PP The <b>__kernel</b> qualifier can be used with the keyword
       <b><a href="../man3clc/attribute.3clc.html">attribute</a></b>(3clc) to declare additional information about the kernel function as described below.

       The optional __attribute__((vec_type_hint(&lt;type&gt;))) is a hint to the compiler and is intended to be a
       representation of the computational <u>width</u> of the <b>__kernel</b>, and should serve as the basis for calculating
       processor bandwidth utilization when the compiler is looking to autovectorize the code. In the
       __attribute__((vec_type_hint(&lt;type&gt;))) qualifier &lt;type&gt; is one of the built-in vector types or the
       constituent scalar element types. If vec_type_hint (&lt;type&gt;) is not specified, the kernel is assumed to
       have the __attribute__((vec_type_hint(int))) qualifier.

       Implicit in autovectorization is the assumption that any libraries called from the <b>__kernel</b> must be
       recompilable at run time to handle cases where the compiler decides to merge or separate workitems. This
       probably means that such libraries can never be hard coded binaries or that hard coded binaries must be
       accompanied either by source or some retargetable intermediate representation. This may be a code
       security question for some.

       For example, where the developer specified a width of <b>float4</b>, the compiler should assume that the
       computation usually uses up 4 lanes of a float vector, and would decide to merge work-items or possibly
       even separate one work-item into many threads to better match the hardware capabilities. A conforming
       implementation is not required to autovectorize code, but shall support the hint. A compiler may
       autovectorize, even if no hint is provided. If an implementation merges <b>N</b> work-items into one thread, it
       is responsible for correctly handling cases where the number of global or local work-items in any
       dimension modulo <b>N</b> is not zero.

       If for example, a <b>__kernel</b> function is declared with __attribute__(( vec_type_hint (float4))) (meaning
       that most operations in the <b>__kernel</b> are explicitly vectorized using <b>float4</b>) and the kernel is running
       using Intel® Advanced Vector Instructions (Intel® AVX) which implements a 8-float-wide vector unit, the
       autovectorizer might choose to merge two work-items to one thread, running a second work-item in the high
       half of the 256-bit AVX register.

       As another example, a Power4 machine has two scalar double precision floating-point units with an 6-cycle
       deep pipe. An autovectorizer for the Power4 machine might choose to interleave six kernels declared with
       the __attribute__(( vec_type_hint (double2))) qualifier into one hardware thread, to ensure that there is
       always 12-way parallelism available to saturate the FPUs. It might also choose to merge 4 or 8 work-items
       (or some other number) if it concludes that these are better choices, due to resource utilization
       concerns or some preference for divisibility by 2.

       The optional __attribute__((work_group_size_hint(<u>X</u>, <u>Y</u>, <u>Z</u>))) is a hint to the compiler and is intended to
       specify the work-group size that may be used i.e. value most likely to be specified by the
       <u>local_work_size</u> argument to <b><a href="../man3clc/clEnqueueNDRangeKernel.3clc.html">clEnqueueNDRangeKernel</a></b>(3clc). For example the
       __attribute__((work_group_size_hint(1, 1, 1))) is a hint to the compiler that the kernel will most likely
       be executed with a work-group size of 1.

       The optional __attribute__((reqd_work_group_size(<u>X</u>, <u>Y</u>, <u>Z</u>))) is the work-group size that must be used as
       the <u>local_work_size</u> argument to <b><a href="../man3clc/clEnqueueNDRangeKernel.3clc.html">clEnqueueNDRangeKernel</a></b>(3clc). This allows the compiler to optimize the
       generated code appropriately for this kernel. The optional __attribute__((reqd_work_group_size(<u>X</u>, <u>Y</u>,
       <u>Z</u>))), if specified, must be (1, 1, 1) if the kernel is executed via <b><a href="../man3clc/clEnqueueTask.3clc.html">clEnqueueTask</a></b>(3clc).

       If <u>Z</u> is one, the <u>work_dim</u> argument to <b><a href="../man3clc/clEnqueueNDRangeKernel.3clc.html">clEnqueueNDRangeKernel</a></b>(3clc) can be 2 or 3. If <u>Y</u> and <u>Z</u> are one, the
       <u>work_dim</u> argument to <b><a href="../man3clc/clEnqueueNDRangeKernel.3clc.html">clEnqueueNDRangeKernel</a></b>(3clc) can be 1, 2 or 3.

</pre><h4><b>NOTES</b></h4><pre>
       Kernel functions with variables declared inside the function with the <b><a href="../man3clc/local.3clc.html">local</a></b>(3clc) or <b><a href="../man3clc/local.3clc.html">local</a></b>(3clc)
       qualifier can be called by the host using appropriate APIs such as <b><a href="../man3clc/clEnqueueNDRangeKernel.3clc.html">clEnqueueNDRangeKernel</a></b>(3clc), and
       <b><a href="../man3clc/clEnqueueTask.3clc.html">clEnqueueTask</a></b>(3clc).

       The behavior of calling kernel functions with variables declared inside the function with the <b><a href="../man3clc/local.3clc.html">local</a></b>(3clc)
       and <b><a href="../man3clc/local.3clc.html">local</a></b>(3clc) qualifier from other kernel functions is implementation-defined.

       The <b>__kernel</b> and <b>kernel</b> names are reserved for use as functions qualifiers and shall not be used
       otherwise.

   <b>Example</b>
       // autovectorize assuming float4 as the // basic
       computation width __kernel
       __attribute__((vec_type_hint(float4))) void foo(
       __global float4 *p ) { ....

       // autovectorize assuming double as the // basic
       computation width __kernel
       __attribute__((vec_type_hint(double))) void foo(
       __global float4 *p ){ ....

       // autovectorize assuming int (default) // as the basic
       computation width __kernel void foo( __global float4 *p
       ){ ....

</pre><h4><b>SPECIFICATION</b></h4><pre>
       <b>OpenCL</b> <b>Specification</b>[1]

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3clc/attribute.3clc.html">attribute</a></b>(3clc), <b><a href="../man3clc/clEnqueueNDRangeKernel.3clc.html">clEnqueueNDRangeKernel</a></b>(3clc), <b><a href="../man3clc/clEnqueueTask.3clc.html">clEnqueueTask</a></b>(3clc)

</pre><h4><b>AUTHORS</b></h4><pre>
       <b>The</b> <b>Khronos</b> <b>Group</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2007-2011 The Khronos Group Inc.
       Permission is hereby granted, free of charge, to any person obtaining a copy of this software and/or
       associated documentation files (the "Materials"), to deal in the Materials without restriction, including
       without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Materials, and to permit persons to whom the Materials are furnished to do so, subject to
       the condition that this copyright notice and permission notice shall be included in all copies or
       substantial portions of the Materials.

</pre><h4><b>NOTES</b></h4><pre>
        1. OpenCL Specification
           page 227, section 6.7 - Function Qualifiers

The Khronos Group                                  11/18/2024                          <u>FUNCTION</u> <u><a href="../man3clc/QUALIFIERS.3clc.html">QUALIFIERS</a></u>(3clc)
</pre>
 </div>
</div></section>
</div>
</body>
</html>