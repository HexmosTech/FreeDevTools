<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLIST_CLASS_ENTRY,  SLIST_CLASS_HEAD, SLIST_CONCAT, SLIST_EMPTY, SLIST_ENTRY, SLIST_FIRST, SLIST_FOREACH,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbsd-dev">libbsd-dev_0.12.2-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SLIST_CLASS_ENTRY,  SLIST_CLASS_HEAD, SLIST_CONCAT, SLIST_EMPTY, SLIST_ENTRY, SLIST_FIRST, SLIST_FOREACH,
       SLIST_FOREACH_FROM,  SLIST_FOREACH_FROM_SAFE,  SLIST_FOREACH_SAFE,  SLIST_HEAD,   SLIST_HEAD_INITIALIZER,
       SLIST_INIT,   SLIST_INSERT_AFTER,   SLIST_INSERT_HEAD,   SLIST_NEXT,   SLIST_REMOVE,  SLIST_REMOVE_AFTER,
       SLIST_REMOVE_HEAD,  SLIST_SWAP,  STAILQ_CLASS_ENTRY,  STAILQ_CLASS_HEAD,   STAILQ_CONCAT,   STAILQ_EMPTY,
       STAILQ_ENTRY,     STAILQ_FIRST,     STAILQ_FOREACH,     STAILQ_FOREACH_FROM,    STAILQ_FOREACH_FROM_SAFE,
       STAILQ_FOREACH_SAFE,    STAILQ_HEAD,    STAILQ_HEAD_INITIALIZER,    STAILQ_INIT,     STAILQ_INSERT_AFTER,
       STAILQ_INSERT_HEAD,  STAILQ_INSERT_TAIL,  STAILQ_LAST,  STAILQ_NEXT,  STAILQ_REMOVE, STAILQ_REMOVE_AFTER,
       STAILQ_REMOVE_HEAD, STAILQ_SWAP, LIST_CLASS_ENTRY, LIST_CLASS_HEAD, LIST_CONCAT, LIST_EMPTY,  LIST_ENTRY,
       LIST_FIRST,   LIST_FOREACH,   LIST_FOREACH_FROM,  LIST_FOREACH_FROM_SAFE,  LIST_FOREACH_SAFE,  LIST_HEAD,
       LIST_HEAD_INITIALIZER, LIST_INIT,  LIST_INSERT_AFTER,  LIST_INSERT_BEFORE,  LIST_INSERT_HEAD,  LIST_NEXT,
       LIST_PREV,   LIST_REMOVE,  LIST_SWAP,  TAILQ_CLASS_ENTRY,  TAILQ_CLASS_HEAD,  TAILQ_CONCAT,  TAILQ_EMPTY,
       TAILQ_ENTRY,      TAILQ_FIRST,      TAILQ_FOREACH,      TAILQ_FOREACH_FROM,      TAILQ_FOREACH_FROM_SAFE,
       TAILQ_FOREACH_REVERSE,            TAILQ_FOREACH_REVERSE_FROM,            TAILQ_FOREACH_REVERSE_FROM_SAFE,
       TAILQ_FOREACH_REVERSE_SAFE,   TAILQ_FOREACH_SAFE,   TAILQ_HEAD,    TAILQ_HEAD_INITIALIZER,    TAILQ_INIT,
       TAILQ_INSERT_AFTER,  TAILQ_INSERT_BEFORE,  TAILQ_INSERT_HEAD,  TAILQ_INSERT_TAIL, TAILQ_LAST, TAILQ_NEXT,
       TAILQ_PREV, TAILQ_REMOVE, TAILQ_SWAP â€” implementations of singly-linked lists, singly-linked tail queues,
       lists and tail queues

</pre><h4><b>LIBRARY</b></h4><pre>
       Utility functions from BSD systems (libbsd, -lbsd)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/queue.h&gt;</b>
       (See <u><a href="../man7/libbsd.7.html">libbsd</a></u>(7) for include usage.)

       <b>SLIST_CLASS_ENTRY</b>(<u>CLASSTYPE</u>);

       <b>SLIST_CLASS_HEAD</b>(<u>HEADNAME</u>, <u>CLASSTYPE</u>);

       <b>SLIST_CONCAT</b>(<u>SLIST_HEAD</u> <u>*head1</u>, <u>SLIST_HEAD</u> <u>*head2</u>, <u>TYPE</u>, <u>SLIST_ENTRY</u> <u>NAME</u>);

       <b>SLIST_EMPTY</b>(<u>SLIST_HEAD</u> <u>*head</u>);

       <b>SLIST_ENTRY</b>(<u>TYPE</u>);

       <b>SLIST_FIRST</b>(<u>SLIST_HEAD</u> <u>*head</u>);

       <b>SLIST_FOREACH</b>(<u>TYPE</u> <u>*var</u>, <u>SLIST_HEAD</u> <u>*head</u>, <u>SLIST_ENTRY</u> <u>NAME</u>);

       <b>SLIST_FOREACH_FROM</b>(<u>TYPE</u> <u>*var</u>, <u>SLIST_HEAD</u> <u>*head</u>, <u>SLIST_ENTRY</u> <u>NAME</u>);

       <b>SLIST_FOREACH_FROM_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>SLIST_HEAD</u> <u>*head</u>, <u>SLIST_ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp_var</u>);

       <b>SLIST_FOREACH_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>SLIST_HEAD</u> <u>*head</u>, <u>SLIST_ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp_var</u>);

       <b>SLIST_HEAD</b>(<u>HEADNAME</u>, <u>TYPE</u>);

       <b>SLIST_HEAD_INITIALIZER</b>(<u>SLIST_HEAD</u> <u>head</u>);

       <b>SLIST_INIT</b>(<u>SLIST_HEAD</u> <u>*head</u>);

       <b>SLIST_INSERT_AFTER</b>(<u>TYPE</u> <u>*listelm</u>, <u>TYPE</u> <u>*elm</u>, <u>SLIST_ENTRY</u> <u>NAME</u>);

       <b>SLIST_INSERT_HEAD</b>(<u>SLIST_HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>SLIST_ENTRY</u> <u>NAME</u>);

       <b>SLIST_NEXT</b>(<u>TYPE</u> <u>*elm</u>, <u>SLIST_ENTRY</u> <u>NAME</u>);

       <b>SLIST_REMOVE</b>(<u>SLIST_HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>TYPE</u>, <u>SLIST_ENTRY</u> <u>NAME</u>);

       <b>SLIST_REMOVE_AFTER</b>(<u>TYPE</u> <u>*elm</u>, <u>SLIST_ENTRY</u> <u>NAME</u>);

       <b>SLIST_REMOVE_HEAD</b>(<u>SLIST_HEAD</u> <u>*head</u>, <u>SLIST_ENTRY</u> <u>NAME</u>);

       <b>SLIST_SWAP</b>(<u>SLIST_HEAD</u> <u>*head1</u>, <u>SLIST_HEAD</u> <u>*head2</u>, <u>TYPE</u>);

       <b>STAILQ_CLASS_ENTRY</b>(<u>CLASSTYPE</u>);

       <b>STAILQ_CLASS_HEAD</b>(<u>HEADNAME</u>, <u>CLASSTYPE</u>);

       <b>STAILQ_CONCAT</b>(<u>STAILQ_HEAD</u> <u>*head1</u>, <u>STAILQ_HEAD</u> <u>*head2</u>);

       <b>STAILQ_EMPTY</b>(<u>STAILQ_HEAD</u> <u>*head</u>);

       <b>STAILQ_ENTRY</b>(<u>TYPE</u>);

       <b>STAILQ_FIRST</b>(<u>STAILQ_HEAD</u> <u>*head</u>);

       <b>STAILQ_FOREACH</b>(<u>TYPE</u> <u>*var</u>, <u>STAILQ_HEAD</u> <u>*head</u>, <u>STAILQ_ENTRY</u> <u>NAME</u>);

       <b>STAILQ_FOREACH_FROM</b>(<u>TYPE</u> <u>*var</u>, <u>STAILQ_HEAD</u> <u>*head</u>, <u>STAILQ_ENTRY</u> <u>NAME</u>);

       <b>STAILQ_FOREACH_FROM_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>STAILQ_HEAD</u> <u>*head</u>, <u>STAILQ_ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp_var</u>);

       <b>STAILQ_FOREACH_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>STAILQ_HEAD</u> <u>*head</u>, <u>STAILQ_ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp_var</u>);

       <b>STAILQ_HEAD</b>(<u>HEADNAME</u>, <u>TYPE</u>);

       <b>STAILQ_HEAD_INITIALIZER</b>(<u>STAILQ_HEAD</u> <u>head</u>);

       <b>STAILQ_INIT</b>(<u>STAILQ_HEAD</u> <u>*head</u>);

       <b>STAILQ_INSERT_AFTER</b>(<u>STAILQ_HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*listelm</u>, <u>TYPE</u> <u>*elm</u>, <u>STAILQ_ENTRY</u> <u>NAME</u>);

       <b>STAILQ_INSERT_HEAD</b>(<u>STAILQ_HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>STAILQ_ENTRY</u> <u>NAME</u>);

       <b>STAILQ_INSERT_TAIL</b>(<u>STAILQ_HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>STAILQ_ENTRY</u> <u>NAME</u>);

       <b>STAILQ_LAST</b>(<u>STAILQ_HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>STAILQ_ENTRY</u> <u>NAME</u>);

       <b>STAILQ_NEXT</b>(<u>TYPE</u> <u>*elm</u>, <u>STAILQ_ENTRY</u> <u>NAME</u>);

       <b>STAILQ_REMOVE</b>(<u>STAILQ_HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>TYPE</u>, <u>STAILQ_ENTRY</u> <u>NAME</u>);

       <b>STAILQ_REMOVE_AFTER</b>(<u>STAILQ_HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>STAILQ_ENTRY</u> <u>NAME</u>);

       <b>STAILQ_REMOVE_HEAD</b>(<u>STAILQ_HEAD</u> <u>*head</u>, <u>STAILQ_ENTRY</u> <u>NAME</u>);

       <b>STAILQ_SWAP</b>(<u>STAILQ_HEAD</u> <u>*head1</u>, <u>STAILQ_HEAD</u> <u>*head2</u>, <u>TYPE</u>);

       <b>LIST_CLASS_ENTRY</b>(<u>CLASSTYPE</u>);

       <b>LIST_CLASS_HEAD</b>(<u>HEADNAME</u>, <u>CLASSTYPE</u>);

       <b>LIST_CONCAT</b>(<u>LIST_HEAD</u> <u>*head1</u>, <u>LIST_HEAD</u> <u>*head2</u>, <u>TYPE</u>, <u>LIST_ENTRY</u> <u>NAME</u>);

       <b>LIST_EMPTY</b>(<u>LIST_HEAD</u> <u>*head</u>);

       <b>LIST_ENTRY</b>(<u>TYPE</u>);

       <b>LIST_FIRST</b>(<u>LIST_HEAD</u> <u>*head</u>);

       <b>LIST_FOREACH</b>(<u>TYPE</u> <u>*var</u>, <u>LIST_HEAD</u> <u>*head</u>, <u>LIST_ENTRY</u> <u>NAME</u>);

       <b>LIST_FOREACH_FROM</b>(<u>TYPE</u> <u>*var</u>, <u>LIST_HEAD</u> <u>*head</u>, <u>LIST_ENTRY</u> <u>NAME</u>);

       <b>LIST_FOREACH_FROM_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>LIST_HEAD</u> <u>*head</u>, <u>LIST_ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp_var</u>);

       <b>LIST_FOREACH_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>LIST_HEAD</u> <u>*head</u>, <u>LIST_ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp_var</u>);

       <b>LIST_HEAD</b>(<u>HEADNAME</u>, <u>TYPE</u>);

       <b>LIST_HEAD_INITIALIZER</b>(<u>LIST_HEAD</u> <u>head</u>);

       <b>LIST_INIT</b>(<u>LIST_HEAD</u> <u>*head</u>);

       <b>LIST_INSERT_AFTER</b>(<u>TYPE</u> <u>*listelm</u>, <u>TYPE</u> <u>*elm</u>, <u>LIST_ENTRY</u> <u>NAME</u>);

       <b>LIST_INSERT_BEFORE</b>(<u>TYPE</u> <u>*listelm</u>, <u>TYPE</u> <u>*elm</u>, <u>LIST_ENTRY</u> <u>NAME</u>);

       <b>LIST_INSERT_HEAD</b>(<u>LIST_HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>LIST_ENTRY</u> <u>NAME</u>);

       <b>LIST_NEXT</b>(<u>TYPE</u> <u>*elm</u>, <u>LIST_ENTRY</u> <u>NAME</u>);

       <b>LIST_PREV</b>(<u>TYPE</u> <u>*elm</u>, <u>LIST_HEAD</u> <u>*head</u>, <u>TYPE</u>, <u>LIST_ENTRY</u> <u>NAME</u>);

       <b>LIST_REMOVE</b>(<u>TYPE</u> <u>*elm</u>, <u>LIST_ENTRY</u> <u>NAME</u>);

       <b>LIST_SWAP</b>(<u>LIST_HEAD</u> <u>*head1</u>, <u>LIST_HEAD</u> <u>*head2</u>, <u>TYPE</u>, <u>LIST_ENTRY</u> <u>NAME</u>);

       <b>TAILQ_CLASS_ENTRY</b>(<u>CLASSTYPE</u>);

       <b>TAILQ_CLASS_HEAD</b>(<u>HEADNAME</u>, <u>CLASSTYPE</u>);

       <b>TAILQ_CONCAT</b>(<u>TAILQ_HEAD</u> <u>*head1</u>, <u>TAILQ_HEAD</u> <u>*head2</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>);

       <b>TAILQ_EMPTY</b>(<u>TAILQ_HEAD</u> <u>*head</u>);

       <b>TAILQ_ENTRY</b>(<u>TYPE</u>);

       <b>TAILQ_FIRST</b>(<u>TAILQ_HEAD</u> <u>*head</u>);

       <b>TAILQ_FOREACH</b>(<u>TYPE</u> <u>*var</u>, <u>TAILQ_HEAD</u> <u>*head</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>);

       <b>TAILQ_FOREACH_FROM</b>(<u>TYPE</u> <u>*var</u>, <u>TAILQ_HEAD</u> <u>*head</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>);

       <b>TAILQ_FOREACH_FROM_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>TAILQ_HEAD</u> <u>*head</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp_var</u>);

       <b>TAILQ_FOREACH_REVERSE</b>(<u>TYPE</u> <u>*var</u>, <u>TAILQ_HEAD</u> <u>*head</u>, <u>HEADNAME</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>);

       <b>TAILQ_FOREACH_REVERSE_FROM</b>(<u>TYPE</u> <u>*var</u>, <u>TAILQ_HEAD</u> <u>*head</u>, <u>HEADNAME</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>);

       <b>TAILQ_FOREACH_REVERSE_FROM_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>TAILQ_HEAD</u> <u>*head</u>, <u>HEADNAME</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp_var</u>);

       <b>TAILQ_FOREACH_REVERSE_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>TAILQ_HEAD</u> <u>*head</u>, <u>HEADNAME</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp_var</u>);

       <b>TAILQ_FOREACH_SAFE</b>(<u>TYPE</u> <u>*var</u>, <u>TAILQ_HEAD</u> <u>*head</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>, <u>TYPE</u> <u>*temp_var</u>);

       <b>TAILQ_HEAD</b>(<u>HEADNAME</u>, <u>TYPE</u>);

       <b>TAILQ_HEAD_INITIALIZER</b>(<u>TAILQ_HEAD</u> <u>head</u>);

       <b>TAILQ_INIT</b>(<u>TAILQ_HEAD</u> <u>*head</u>);

       <b>TAILQ_INSERT_AFTER</b>(<u>TAILQ_HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*listelm</u>, <u>TYPE</u> <u>*elm</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>);

       <b>TAILQ_INSERT_BEFORE</b>(<u>TYPE</u> <u>*listelm</u>, <u>TYPE</u> <u>*elm</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>);

       <b>TAILQ_INSERT_HEAD</b>(<u>TAILQ_HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>);

       <b>TAILQ_INSERT_TAIL</b>(<u>TAILQ_HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>);

       <b>TAILQ_LAST</b>(<u>TAILQ_HEAD</u> <u>*head</u>, <u>HEADNAME</u>);

       <b>TAILQ_NEXT</b>(<u>TYPE</u> <u>*elm</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>);

       <b>TAILQ_PREV</b>(<u>TYPE</u> <u>*elm</u>, <u>HEADNAME</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>);

       <b>TAILQ_REMOVE</b>(<u>TAILQ_HEAD</u> <u>*head</u>, <u>TYPE</u> <u>*elm</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>);

       <b>TAILQ_SWAP</b>(<u>TAILQ_HEAD</u> <u>*head1</u>, <u>TAILQ_HEAD</u> <u>*head2</u>, <u>TYPE</u>, <u>TAILQ_ENTRY</u> <u>NAME</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These macros define and operate on four types of data structures which can be used  in  both  C  and  C++
       source code:
             1.   Lists
             2.   Singly-linked lists
             3.   Singly-linked tail queues
             4.   Tail queues
       All four structures support the following functionality:
             1.   Insertion of a new entry at the head of the list.
             2.   Insertion of a new entry after any element in the list.
             3.   <a href="../man1/O.1.html">O</a>(1) removal of an entry from the head of the list.
             4.   Forward traversal through the list.
             5.   Swapping the contents of two lists.

       Singly-linked  lists  are  the  simplest  of  the  four  data  structures  and  support  only  the  above
       functionality.  Singly-linked lists are ideal  for  applications  with  large  datasets  and  few  or  no
       removals, or for implementing a LIFO queue.  Singly-linked lists add the following functionality:
             1.   O(n) removal of any entry in the list.
             2.   O(n) concatenation of two lists.

       Singly-linked tail queues add the following functionality:
             1.   Entries can be added at the end of a list.
             2.   O(n) removal of any entry in the list.
             3.   They may be concatenated.
       However:
             1.   All list insertions must specify the head of the list.
             2.   Each head entry requires two pointers rather than one.
             3.   Code size is about 15% greater and operations run about 20% slower than singly-linked lists.

       Singly-linked  tail  queues are ideal for applications with large datasets and few or no removals, or for
       implementing a FIFO queue.

       All doubly linked types of data structures (lists and tail queues) additionally allow:
             1.   Insertion of a new entry before any element in the list.
             2.   <a href="../man1/O.1.html">O</a>(1) removal of any entry in the list.
       However:
             1.   Each element requires two pointers rather than one.
             2.   Code size and execution time of operations (except for removal) is about  twice  that  of  the
                  singly-linked data-structures.

       Linked lists are the simplest of the doubly linked data structures.  They add the following functionality
       over the above:
             1.   O(n) concatenation of two lists.
             2.   They may be traversed backwards.
       However:
             1.   To  traverse  backwards, an entry to begin the traversal and the list in which it is contained
                  must be specified.

       Tail queues add the following functionality:
             1.   Entries can be added at the end of a list.
             2.   They may be traversed backwards, from tail to head.
             3.   They may be concatenated.
       However:
             1.   All list insertions and removals must specify the head of the list.
             2.   Each head entry requires two pointers rather than one.
             3.   Code size is about 15% greater and operations run about 20% slower than singly-linked lists.

       In the macro definitions, <u>TYPE</u> is the name of a user defined structure.  The  structure  must  contain  a
       field  called  <u>NAME</u> which is of type <b>SLIST_ENTRY</b>, <b>STAILQ_ENTRY</b>, <b>LIST_ENTRY</b>, or <b>TAILQ_ENTRY</b>.  In the macro
       definitions, <u>CLASSTYPE</u> is the name of a user defined class.  The class must contain a field  called  <u>NAME</u>
       which  is  of  type  <b>SLIST_CLASS_ENTRY</b>,  <b>STAILQ_CLASS_ENTRY</b>, <b>LIST_CLASS_ENTRY</b>, or <b>TAILQ_CLASS_ENTRY</b>.  The
       argument <u>HEADNAME</u> is the name of a user  defined  structure  that  must  be  declared  using  the  macros
       <b>SLIST_HEAD</b>,  <b>SLIST_CLASS_HEAD</b>, <b>STAILQ_HEAD</b>, <b>STAILQ_CLASS_HEAD</b>, <b>LIST_HEAD</b>, <b>LIST_CLASS_HEAD</b>, <b>TAILQ_HEAD</b>, or
       <b>TAILQ_CLASS_HEAD</b>.  See the examples below for further explanation of how these macros are used.

</pre><h4><b>SINGLY-LINKED</b> <b>LISTS</b></h4><pre>
       A singly-linked list is headed by a structure defined by the <b>SLIST_HEAD</b> macro.  This structure contains a
       single pointer to the first element on the list.  The elements are singly linked for  minimum  space  and
       pointer manipulation overhead at the expense of O(n) removal for arbitrary elements.  New elements can be
       added  to  the  list  after  an  existing element or at the head of the list.  An <u>SLIST_HEAD</u> structure is
       declared as follows:

             SLIST_HEAD(HEADNAME, TYPE) head;

       where <u>HEADNAME</u> is the name of the structure to be defined, and <u>TYPE</u> is the type of  the  elements  to  be
       linked into the list.  A pointer to the head of the list can later be declared as:

             struct HEADNAME *headp;

       (The names <b>head</b> and <b>headp</b> are user selectable.)

       The macro <b>SLIST_HEAD_INITIALIZER</b> evaluates to an initializer for the list <u>head</u>.

       The  macro  <b>SLIST_CONCAT</b>  concatenates  the  list headed by <u>head2</u> onto the end of the one headed by <u>head1</u>
       removing all entries from the former.  Use of this macro should be avoided as it traverses  the  entirety
       of  the <u>head1</u> list.  A singly-linked tail queue should be used if this macro is needed in high-usage code
       paths or to operate on long lists.

       The macro <b>SLIST_EMPTY</b> evaluates to true if there are no elements in the list.

       The macro <b>SLIST_ENTRY</b> declares a structure that connects the elements in the list.

       The macro <b>SLIST_FIRST</b> returns the first element in the list or NULL if the list is empty.

       The macro <b>SLIST_FOREACH</b> traverses the list referenced by <u>head</u> in the forward  direction,  assigning  each
       element in turn to <u>var</u>.

       The macro <b>SLIST_FOREACH_FROM</b> behaves identically to <b>SLIST_FOREACH</b> when <u>var</u> is NULL, else it treats <u>var</u> as
       a  previously  found  SLIST  element and begins the loop at <u>var</u> instead of the first element in the SLIST
       referenced by <u>head</u>.

       The macro <b>SLIST_FOREACH_SAFE</b> traverses the list referenced by <u>head</u> in the  forward  direction,  assigning
       each  element in turn to <u>var</u>.  However, unlike <b>SLIST_FOREACH</b>() here it is permitted to both remove <u>var</u> as
       well as free it from within the loop safely without interfering with the traversal.

       The macro <b>SLIST_FOREACH_FROM_SAFE</b> behaves identically to <b>SLIST_FOREACH_SAFE</b> when <u>var</u>  is  NULL,  else  it
       treats <u>var</u> as a previously found SLIST element and begins the loop at <u>var</u> instead of the first element in
       the SLIST referenced by <u>head</u>.

       The macro <b>SLIST_INIT</b> initializes the list referenced by <u>head</u>.

       The macro <b>SLIST_INSERT_HEAD</b> inserts the new element <u>elm</u> at the head of the list.

       The macro <b>SLIST_INSERT_AFTER</b> inserts the new element <u>elm</u> after the element <u>listelm</u>.

       The macro <b>SLIST_NEXT</b> returns the next element in the list.

       The  macro  <b>SLIST_REMOVE_AFTER</b>  removes  the  element after <u>elm</u> from the list.  Unlike <u>SLIST_REMOVE</u>, this
       macro does not traverse the entire list.

       The macro <b>SLIST_REMOVE_HEAD</b> removes the element <u>elm</u> from the head of the list.  For  optimum  efficiency,
       elements  being removed from the head of the list should explicitly use this macro instead of the generic
       <u>SLIST_REMOVE</u> macro.

       The macro <b>SLIST_REMOVE</b> removes the element <u>elm</u> from the list.  Use of this macro should be avoided as  it
       traverses  the  entire  list.   A doubly-linked list should be used if this macro is needed in high-usage
       code paths or to operate on long lists.

       The macro <b>SLIST_SWAP</b> swaps the contents of <u>head1</u> and <u>head2</u>.

</pre><h4><b>SINGLY-LINKED</b> <b>LIST</b> <b>EXAMPLE</b></h4><pre>
       SLIST_HEAD(slisthead, entry) head =
           SLIST_HEAD_INITIALIZER(head);
       struct slisthead *headp;                /* Singly-linked List head. */
       struct entry {
               ...
               SLIST_ENTRY(entry) entries;     /* Singly-linked List. */
               ...
       } *n1, *n2, *n3, *np;

       SLIST_INIT(&amp;head);                      /* Initialize the list. */

       n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
       SLIST_INSERT_HEAD(&amp;head, n1, entries);

       n2 = malloc(sizeof(struct entry));      /* Insert after. */
       SLIST_INSERT_AFTER(n1, n2, entries);

       SLIST_REMOVE(&amp;head, n2, entry, entries);/* Deletion. */
       free(n2);

       n3 = SLIST_FIRST(&amp;head);
       SLIST_REMOVE_HEAD(&amp;head, entries);      /* Deletion from the head. */
       free(n3);
                                               /* Forward traversal. */
       SLIST_FOREACH(np, &amp;head, entries)
               np-&gt; ...
                                               /* Safe forward traversal. */
       SLIST_FOREACH_SAFE(np, &amp;head, entries, np_temp) {
               np-&gt;do_stuff();
               ...
               SLIST_REMOVE(&amp;head, np, entry, entries);
               free(np);
       }

       while (!SLIST_EMPTY(&amp;head)) {           /* List Deletion. */
               n1 = SLIST_FIRST(&amp;head);
               SLIST_REMOVE_HEAD(&amp;head, entries);
               free(n1);
       }

</pre><h4><b>SINGLY-LINKED</b> <b>TAIL</b> <b>QUEUES</b></h4><pre>
       A singly-linked tail queue is headed by a structure defined by the  <b>STAILQ_HEAD</b>  macro.   This  structure
       contains a pair of pointers, one to the first element in the tail queue and the other to the last element
       in the tail queue.  The elements are singly linked for minimum space and pointer manipulation overhead at
       the expense of O(n) removal for arbitrary elements.  New elements can be added to the tail queue after an
       existing  element,  at  the  head  of  the  tail  queue,  or at the end of the tail queue.  A <u>STAILQ_HEAD</u>
       structure is declared as follows:

             STAILQ_HEAD(HEADNAME, TYPE) head;

       where <b>HEADNAME</b> is the name of the structure to be defined, and <b>TYPE</b> is the type of  the  elements  to  be
       linked into the tail queue.  A pointer to the head of the tail queue can later be declared as:

             struct HEADNAME *headp;

       (The names <b>head</b> and <b>headp</b> are user selectable.)

       The macro <b>STAILQ_HEAD_INITIALIZER</b> evaluates to an initializer for the tail queue <u>head</u>.

       The  macro  <b>STAILQ_CONCAT</b>  concatenates  the tail queue headed by <u>head2</u> onto the end of the one headed by
       <u>head1</u> removing all entries from the former.

       The macro <b>STAILQ_EMPTY</b> evaluates to true if there are no items on the tail queue.

       The macro <b>STAILQ_ENTRY</b> declares a structure that connects the elements in the tail queue.

       The macro <b>STAILQ_FIRST</b> returns the first item on the tail queue or NULL if the tail queue is empty.

       The macro <b>STAILQ_FOREACH</b> traverses the tail queue referenced by <u>head</u> in the forward direction,  assigning
       each element in turn to <u>var</u>.

       The  macro <b>STAILQ_FOREACH_FROM</b> behaves identically to <b>STAILQ_FOREACH</b> when <u>var</u> is NULL, else it treats <u>var</u>
       as a previously found STAILQ element and begins the loop at <u>var</u> instead  of  the  first  element  in  the
       STAILQ referenced by <u>head</u>.

       The  macro  <b>STAILQ_FOREACH_SAFE</b>  traverses  the  tail  queue referenced by <u>head</u> in the forward direction,
       assigning each element in turn to <u>var</u>.  However, unlike <b>STAILQ_FOREACH</b>() here it  is  permitted  to  both
       remove <u>var</u> as well as free it from within the loop safely without interfering with the traversal.

       The  macro  <b>STAILQ_FOREACH_FROM_SAFE</b> behaves identically to <b>STAILQ_FOREACH_SAFE</b> when <u>var</u> is NULL, else it
       treats <u>var</u> as a previously found STAILQ element and begins the loop at <u>var</u> instead of the  first  element
       in the STAILQ referenced by <u>head</u>.

       The macro <b>STAILQ_INIT</b> initializes the tail queue referenced by <u>head</u>.

       The macro <b>STAILQ_INSERT_HEAD</b> inserts the new element <u>elm</u> at the head of the tail queue.

       The macro <b>STAILQ_INSERT_TAIL</b> inserts the new element <u>elm</u> at the end of the tail queue.

       The macro <b>STAILQ_INSERT_AFTER</b> inserts the new element <u>elm</u> after the element <u>listelm</u>.

       The  macro  <b>STAILQ_LAST</b>  returns  the last item on the tail queue.  If the tail queue is empty the return
       value is NULL.

       The macro <b>STAILQ_NEXT</b> returns the next item on the tail queue, or NULL this item is the last.

       The macro <b>STAILQ_REMOVE_AFTER</b> removes the element after <u>elm</u> from the tail queue.   Unlike  <u>STAILQ_REMOVE</u>,
       this macro does not traverse the entire tail queue.

       The  macro <b>STAILQ_REMOVE_HEAD</b> removes the element at the head of the tail queue.  For optimum efficiency,
       elements being removed from the head of the tail queue should use this macro explicitly rather  than  the
       generic <u>STAILQ_REMOVE</u> macro.

       The macro <b>STAILQ_REMOVE</b> removes the element <u>elm</u> from the tail queue.  Use of this macro should be avoided
       as  it  traverses  the entire list.  A doubly-linked tail queue should be used if this macro is needed in
       high-usage code paths or to operate on long tail queues.

       The macro <b>STAILQ_SWAP</b> swaps the contents of <u>head1</u> and <u>head2</u>.

</pre><h4><b>SINGLY-LINKED</b> <b>TAIL</b> <b>QUEUE</b> <b>EXAMPLE</b></h4><pre>
       STAILQ_HEAD(stailhead, entry) head =
           STAILQ_HEAD_INITIALIZER(head);
       struct stailhead *headp;                /* Singly-linked tail queue head. */
       struct entry {
               ...
               STAILQ_ENTRY(entry) entries;    /* Tail queue. */
               ...
       } *n1, *n2, *n3, *np;

       STAILQ_INIT(&amp;head);                     /* Initialize the queue. */

       n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
       STAILQ_INSERT_HEAD(&amp;head, n1, entries);

       n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */
       STAILQ_INSERT_TAIL(&amp;head, n1, entries);

       n2 = malloc(sizeof(struct entry));      /* Insert after. */
       STAILQ_INSERT_AFTER(&amp;head, n1, n2, entries);
                                               /* Deletion. */
       STAILQ_REMOVE(&amp;head, n2, entry, entries);
       free(n2);
                                               /* Deletion from the head. */
       n3 = STAILQ_FIRST(&amp;head);
       STAILQ_REMOVE_HEAD(&amp;head, entries);
       free(n3);
                                               /* Forward traversal. */
       STAILQ_FOREACH(np, &amp;head, entries)
               np-&gt; ...
                                               /* Safe forward traversal. */
       STAILQ_FOREACH_SAFE(np, &amp;head, entries, np_temp) {
               np-&gt;do_stuff();
               ...
               STAILQ_REMOVE(&amp;head, np, entry, entries);
               free(np);
       }
                                               /* TailQ Deletion. */
       while (!STAILQ_EMPTY(&amp;head)) {
               n1 = STAILQ_FIRST(&amp;head);
               STAILQ_REMOVE_HEAD(&amp;head, entries);
               free(n1);
       }
                                               /* Faster TailQ Deletion. */
       n1 = STAILQ_FIRST(&amp;head);
       while (n1 != NULL) {
               n2 = STAILQ_NEXT(n1, entries);
               free(n1);
               n1 = n2;
       }
       STAILQ_INIT(&amp;head);

</pre><h4><b>LISTS</b></h4><pre>
       A list is headed by a structure defined by the <b>LIST_HEAD</b> macro.  This structure contains a single pointer
       to the first element on the list.  The elements are doubly linked so that an  arbitrary  element  can  be
       removed  without  traversing  the list.  New elements can be added to the list after an existing element,
       before an existing element, or at the head of the list.  A <u>LIST_HEAD</u> structure is declared as follows:

             LIST_HEAD(HEADNAME, TYPE) head;

       where <u>HEADNAME</u> is the name of the structure to be defined, and <u>TYPE</u> is the type of  the  elements  to  be
       linked into the list.  A pointer to the head of the list can later be declared as:

             struct HEADNAME *headp;

       (The names <b>head</b> and <b>headp</b> are user selectable.)

       The macro <b>LIST_HEAD_INITIALIZER</b> evaluates to an initializer for the list <u>head</u>.

       The  macro  <b>LIST_CONCAT</b>  concatenates  the  list  headed by <u>head2</u> onto the end of the one headed by <u>head1</u>
       removing all entries from the former.  Use of this macro should be avoided as it traverses  the  entirety
       of  the  <u>head1</u>  list.  A tail queue should be used if this macro is needed in high-usage code paths or to
       operate on long lists.

       The macro <b>LIST_EMPTY</b> evaluates to true if there are no elements in the list.

       The macro <b>LIST_ENTRY</b> declares a structure that connects the elements in the list.

       The macro <b>LIST_FIRST</b> returns the first element in the list or NULL if the list is empty.

       The macro <b>LIST_FOREACH</b> traverses the list referenced by <u>head</u> in the  forward  direction,  assigning  each
       element in turn to <u>var</u>.

       The macro <b>LIST_FOREACH_FROM</b> behaves identically to <b>LIST_FOREACH</b> when <u>var</u> is NULL, else it treats <u>var</u> as a
       previously  found  LIST  element  and  begins  the  loop  at <u>var</u> instead of the first element in the LIST
       referenced by <u>head</u>.

       The macro <b>LIST_FOREACH_SAFE</b> traverses the list referenced by <u>head</u> in  the  forward  direction,  assigning
       each  element  in turn to <u>var</u>.  However, unlike <b>LIST_FOREACH</b>() here it is permitted to both remove <u>var</u> as
       well as free it from within the loop safely without interfering with the traversal.

       The macro <b>LIST_FOREACH_FROM_SAFE</b> behaves identically to <b>LIST_FOREACH_SAFE</b>  when  <u>var</u>  is  NULL,  else  it
       treats  <u>var</u> as a previously found LIST element and begins the loop at <u>var</u> instead of the first element in
       the LIST referenced by <u>head</u>.

       The macro <b>LIST_INIT</b> initializes the list referenced by <u>head</u>.

       The macro <b>LIST_INSERT_HEAD</b> inserts the new element <u>elm</u> at the head of the list.

       The macro <b>LIST_INSERT_AFTER</b> inserts the new element <u>elm</u> after the element <u>listelm</u>.

       The macro <b>LIST_INSERT_BEFORE</b> inserts the new element <u>elm</u> before the element <u>listelm</u>.

       The macro <b>LIST_NEXT</b> returns the next element in the list, or NULL if this is the last.

       The macro <b>LIST_PREV</b> returns the previous element in the list, or NULL if this is the  first.   List  <u>head</u>
       must contain element <u>elm</u>.

       The macro <b>LIST_REMOVE</b> removes the element <u>elm</u> from the list.

       The macro <b>LIST_SWAP</b> swaps the contents of <u>head1</u> and <u>head2</u>.

</pre><h4><b>LIST</b> <b>EXAMPLE</b></h4><pre>
       LIST_HEAD(listhead, entry) head =
           LIST_HEAD_INITIALIZER(head);
       struct listhead *headp;                 /* List head. */
       struct entry {
               ...
               LIST_ENTRY(entry) entries;      /* List. */
               ...
       } *n1, *n2, *n3, *np, *np_temp;

       LIST_INIT(&amp;head);                       /* Initialize the list. */

       n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
       LIST_INSERT_HEAD(&amp;head, n1, entries);

       n2 = malloc(sizeof(struct entry));      /* Insert after. */
       LIST_INSERT_AFTER(n1, n2, entries);

       n3 = malloc(sizeof(struct entry));      /* Insert before. */
       LIST_INSERT_BEFORE(n2, n3, entries);

       LIST_REMOVE(n2, entries);               /* Deletion. */
       free(n2);
                                               /* Forward traversal. */
       LIST_FOREACH(np, &amp;head, entries)
               np-&gt; ...

                                               /* Safe forward traversal. */
       LIST_FOREACH_SAFE(np, &amp;head, entries, np_temp) {
               np-&gt;do_stuff();
               ...
               LIST_REMOVE(np, entries);
               free(np);
       }

       while (!LIST_EMPTY(&amp;head)) {            /* List Deletion. */
               n1 = LIST_FIRST(&amp;head);
               LIST_REMOVE(n1, entries);
               free(n1);
       }

       n1 = LIST_FIRST(&amp;head);                 /* Faster List Deletion. */
       while (n1 != NULL) {
               n2 = LIST_NEXT(n1, entries);
               free(n1);
               n1 = n2;
       }
       LIST_INIT(&amp;head);

</pre><h4><b>TAIL</b> <b>QUEUES</b></h4><pre>
       A tail queue is headed by a structure defined by the <b>TAILQ_HEAD</b> macro.  This structure contains a pair of
       pointers, one to the first element in the tail queue and the other to the last element in the tail queue.
       The  elements  are  doubly linked so that an arbitrary element can be removed without traversing the tail
       queue.  New elements can be added to the tail  queue  after  an  existing  element,  before  an  existing
       element,  at  the  head  of  the  tail queue, or at the end of the tail queue.  A <u>TAILQ_HEAD</u> structure is
       declared as follows:

             TAILQ_HEAD(HEADNAME, TYPE) head;

       where <b>HEADNAME</b> is the name of the structure to be defined, and <b>TYPE</b> is the type of  the  elements  to  be
       linked into the tail queue.  A pointer to the head of the tail queue can later be declared as:

             struct HEADNAME *headp;

       (The names <b>head</b> and <b>headp</b> are user selectable.)

       The macro <b>TAILQ_HEAD_INITIALIZER</b> evaluates to an initializer for the tail queue <u>head</u>.

       The  macro  <b>TAILQ_CONCAT</b>  concatenates  the  tail queue headed by <u>head2</u> onto the end of the one headed by
       <u>head1</u> removing all entries from the former.

       The macro <b>TAILQ_EMPTY</b> evaluates to true if there are no items on the tail queue.

       The macro <b>TAILQ_ENTRY</b> declares a structure that connects the elements in the tail queue.

       The macro <b>TAILQ_FIRST</b> returns the first item on the tail queue or NULL if the tail queue is empty.

       The macro <b>TAILQ_FOREACH</b> traverses the tail queue referenced by <u>head</u> in the forward  direction,  assigning
       each  element  in  turn  to  <u>var</u>.  <u>var</u> is set to NULL if the loop completes normally, or if there were no
       elements.

       The macro <b>TAILQ_FOREACH_FROM</b> behaves identically to <b>TAILQ_FOREACH</b> when <u>var</u> is NULL, else it treats <u>var</u> as
       a previously found TAILQ element and begins the loop at <u>var</u> instead of the first  element  in  the  TAILQ
       referenced by <u>head</u>.

       The  macro  <b>TAILQ_FOREACH_REVERSE</b>  traverses  the tail queue referenced by <u>head</u> in the reverse direction,
       assigning each element in turn to <u>var</u>.

       The macro <b>TAILQ_FOREACH_REVERSE_FROM</b> behaves identically to <b>TAILQ_FOREACH_REVERSE</b> when <u>var</u> is NULL,  else
       it  treats <u>var</u> as a previously found TAILQ element and begins the reverse loop at <u>var</u> instead of the last
       element in the TAILQ referenced by <u>head</u>.

       The macros <b>TAILQ_FOREACH_SAFE</b> and <b>TAILQ_FOREACH_REVERSE_SAFE</b> traverse the list referenced by <u>head</u> in  the
       forward  or reverse direction respectively, assigning each element in turn to <u>var</u>.  However, unlike their
       unsafe counterparts, <b>TAILQ_FOREACH</b> and <b>TAILQ_FOREACH_REVERSE</b> make it possible to both remove <u>var</u> as  well
       as free it from within the loop safely without interfering with the traversal.

       The  macro  <b>TAILQ_FOREACH_FROM_SAFE</b>  behaves  identically to <b>TAILQ_FOREACH_SAFE</b> when <u>var</u> is NULL, else it
       treats <u>var</u> as a previously found TAILQ element and begins the loop at <u>var</u> instead of the first element in
       the TAILQ referenced by <u>head</u>.

       The macro <b>TAILQ_FOREACH_REVERSE_FROM_SAFE</b> behaves identically to <b>TAILQ_FOREACH_REVERSE_SAFE</b> when  <u>var</u>  is
       NULL,  else  it treats <u>var</u> as a previously found TAILQ element and begins the reverse loop at <u>var</u> instead
       of the last element in the TAILQ referenced by <u>head</u>.

       The macro <b>TAILQ_INIT</b> initializes the tail queue referenced by <u>head</u>.

       The macro <b>TAILQ_INSERT_HEAD</b> inserts the new element <u>elm</u> at the head of the tail queue.

       The macro <b>TAILQ_INSERT_TAIL</b> inserts the new element <u>elm</u> at the end of the tail queue.

       The macro <b>TAILQ_INSERT_AFTER</b> inserts the new element <u>elm</u> after the element <u>listelm</u>.

       The macro <b>TAILQ_INSERT_BEFORE</b> inserts the new element <u>elm</u> before the element <u>listelm</u>.

       The macro <b>TAILQ_LAST</b> returns the last item on the tail queue.  If the tail  queue  is  empty  the  return
       value is NULL.

       The macro <b>TAILQ_NEXT</b> returns the next item on the tail queue, or NULL if this item is the last.

       The macro <b>TAILQ_PREV</b> returns the previous item on the tail queue, or NULL if this item is the first.

       The macro <b>TAILQ_REMOVE</b> removes the element <u>elm</u> from the tail queue.

       The macro <b>TAILQ_SWAP</b> swaps the contents of <u>head1</u> and <u>head2</u>.

</pre><h4><b>TAIL</b> <b>QUEUE</b> <b>EXAMPLE</b></h4><pre>
       TAILQ_HEAD(tailhead, entry) head =
           TAILQ_HEAD_INITIALIZER(head);
       struct tailhead *headp;                 /* Tail queue head. */
       struct entry {
               ...
               TAILQ_ENTRY(entry) entries;     /* Tail queue. */
               ...
       } *n1, *n2, *n3, *np;

       TAILQ_INIT(&amp;head);                      /* Initialize the queue. */

       n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
       TAILQ_INSERT_HEAD(&amp;head, n1, entries);

       n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */
       TAILQ_INSERT_TAIL(&amp;head, n1, entries);

       n2 = malloc(sizeof(struct entry));      /* Insert after. */
       TAILQ_INSERT_AFTER(&amp;head, n1, n2, entries);

       n3 = malloc(sizeof(struct entry));      /* Insert before. */
       TAILQ_INSERT_BEFORE(n2, n3, entries);

       TAILQ_REMOVE(&amp;head, n2, entries);       /* Deletion. */
       free(n2);
                                               /* Forward traversal. */
       TAILQ_FOREACH(np, &amp;head, entries)
               np-&gt; ...
                                               /* Safe forward traversal. */
       TAILQ_FOREACH_SAFE(np, &amp;head, entries, np_temp) {
               np-&gt;do_stuff();
               ...
               TAILQ_REMOVE(&amp;head, np, entries);
               free(np);
       }
                                               /* Reverse traversal. */
       TAILQ_FOREACH_REVERSE(np, &amp;head, tailhead, entries)
               np-&gt; ...
                                               /* TailQ Deletion. */
       while (!TAILQ_EMPTY(&amp;head)) {
               n1 = TAILQ_FIRST(&amp;head);
               TAILQ_REMOVE(&amp;head, n1, entries);
               free(n1);
       }
                                               /* Faster TailQ Deletion. */
       n1 = TAILQ_FIRST(&amp;head);
       while (n1 != NULL) {
               n2 = TAILQ_NEXT(n1, entries);
               free(n1);
               n1 = n2;
       }
       TAILQ_INIT(&amp;head);

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       When  debugging  <b><a href="../man3/queue.3.html">queue</a>(3)</b>,  it can be useful to trace queue changes.  To enable tracing, define the macro
       <u>QUEUE_MACRO_DEBUG_TRACE</u> at compile time.

       It can also be useful to trash pointers that have been  unlinked  from  a  queue,  to  detect  use  after
       removal.   To  enable  pointer  trashing,  define the macro <u>QUEUE_MACRO_DEBUG_TRASH</u> at compile time.  The
       macro <b>QMD_IS_TRASHED</b>(<u>void</u> <u>*ptr</u>) returns true if <u>ptr</u>  has  been  trashed  by  the  <u>QUEUE_MACRO_DEBUG_TRASH</u>
       option.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3bsd/tree.3bsd.html">tree</a></u>(3bsd)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>queue</b> functions first appeared in 4.4BSD.

Debian                                          September 8, 2016                                    <u><a href="../man3bsd/queue.3bsd.html">queue</a></u>(3bsd)
</pre>
 </div>
</div></section>
</div>
</body>
</html>