<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Queue - First-in first-out queues.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Queue - First-in first-out queues.

</pre><h4><b>Module</b></h4><pre>
       Module   Queue

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Queue</b>
        : <b>sig</b> <b>end</b>

       First-in first-out queues.

       This module implements queues (FIFOs), with in-place modification.  See <b>Queue.examples</b> below.

       <b>Alert</b> <b>unsynchronized_access.</b>  Unsynchronized accesses to queues are a programming error.

       Unsynchronized accesses

       Unsynchronized  accesses  to  a  queue  may lead to an invalid queue state.  Thus, concurrent accesses to
       queues must be synchronized (for instance with a <b>Mutex.t</b> ).

       <u>type</u> <b>!'a</b> <u>t</u>

       The type of queues containing elements of type <b>'a</b> .

       <u>exception</u> <u>Empty</u>

       Raised when <b>Queue.take</b> or <b>Queue.peek</b> is applied to an empty queue.

       <u>val</u> <u>create</u> : <b>unit</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       Return a new queue, initially empty.

       <u>val</u> <u>add</u> : <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>add</b> <b>x</b> <b>q</b> adds the element <b>x</b> at the end of the queue <b>q</b> .

       <u>val</u> <u>push</u> : <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>push</b> is a synonym for <b>add</b> .

       <u>val</u> <u>take</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b>

       <b>take</b> <b>q</b> removes and returns the first element in queue <b>q</b> , or raises <b>Queue.Empty</b> if the queue is empty.

       <u>val</u> <u>take_opt</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       <b>take_opt</b> <b>q</b> removes and returns the first element in queue <b>q</b> , or returns <b>None</b> if the queue is empty.

       <b>Since</b> 4.08

       <u>val</u> <u>pop</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b>

       <b>pop</b> is a synonym for <b>take</b> .

       <u>val</u> <u>peek</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b>

       <b>peek</b> <b>q</b> returns the first element in queue <b>q</b> , without removing it from the queue, or  raises  <b>Queue.Empty</b>
       if the queue is empty.

       <u>val</u> <u>peek_opt</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       <b>peek_opt</b>  <b>q</b> returns the first element in queue <b>q</b> , without removing it from the queue, or returns <b>None</b> if
       the queue is empty.

       <b>Since</b> 4.08

       <u>val</u> <u>top</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b>

       <b>top</b> is a synonym for <b>peek</b> .

       <u>val</u> <u>drop</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>drop</b> <b>q</b> removes the first element in queue <b>q</b> , or raises <b>Queue.Empty</b> if the queue is empty.

       <b>Since</b> 5.3

       <u>val</u> <u>clear</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       Discard all elements from a queue.

       <u>val</u> <u>copy</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       Return a copy of the given queue.

       <u>val</u> <u>is_empty</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       Return <b>true</b> if the given queue is empty, <b>false</b> otherwise.

       <u>val</u> <u>length</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b>

       Return the number of elements in a queue.

       <u>val</u> <u>iter</u> : <b>('a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>iter</b> <b>f</b> <b>q</b> applies <b>f</b> in turn to all elements of <b>q</b> , from the least recently entered to  the  most  recently
       entered.  The queue itself is unchanged.

       <u>val</u> <u>fold</u> : <b>('acc</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold</b>  <b>f</b> <b>accu</b> <b>q</b> is equivalent to <b>List.fold_left</b> <b>f</b> <b>accu</b> <b>l</b> , where <b>l</b> is the list of <b>q</b> 's elements. The queue
       remains unchanged.

       <u>val</u> <u>transfer</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>transfer</b> <b>q1</b> <b>q2</b> adds all of <b>q1</b> 's elements at the end of the queue <b>q2</b> , then clears <b>q1</b> . It is  equivalent
       to the sequence <b>iter</b> <b>(fun</b> <b>x</b> <b>-&gt;</b> <b>add</b> <b>x</b> <b>q2)</b> <b>q1;</b> <b>clear</b> <b>q1</b> , but runs in constant time.

   <b>Iterators</b>
       <u>val</u> <u>to_seq</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>Seq.t</b>

       Iterate  on  the  queue,  in front-to-back order.  The behavior is not specified if the queue is modified
       during the iteration.

       <b>Since</b> 4.07

       <u>val</u> <u>add_seq</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>Seq.t</b> <b>-&gt;</b> <b>unit</b>

       Add the elements from a sequence to the end of the queue.

       <b>Since</b> 4.07

       <u>val</u> <u>of_seq</u> : <b>'a</b> <b>Seq.t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       Create a queue from a sequence.

       <b>Since</b> 4.07

   <b>Examples</b>
   <b>Basic</b> <b>Example</b>
       A basic example:
           <b>#</b> <b>let</b> <b>q</b> <b>=</b> <b>Queue.create</b> <b>()</b>
           <b>val</b> <b>q</b> <b>:</b> <b>'_weak1</b> <b>Queue.t</b> <b>=</b> <b>&lt;abstr&gt;</b>

           <b>#</b> <b>Queue.push</b> <b>1</b> <b>q;</b> <b>Queue.push</b> <b>2</b> <b>q;</b> <b>Queue.push</b> <b>3</b> <b>q</b>
           <b>-</b> <b>:</b> <b>unit</b> <b>=</b> <b>()</b>

           <b>#</b> <b>Queue.length</b> <b>q</b>
           <b>-</b> <b>:</b> <b>int</b> <b>=</b> <b>3</b>

           <b>#</b> <b>Queue.pop</b> <b>q</b>
           <b>-</b> <b>:</b> <b>int</b> <b>=</b> <b>1</b>

           <b>#</b> <b>Queue.pop</b> <b>q</b>
           <b>-</b> <b>:</b> <b>int</b> <b>=</b> <b>2</b>

           <b>#</b> <b>Queue.pop</b> <b>q</b>
           <b>-</b> <b>:</b> <b>int</b> <b>=</b> <b>3</b>

           <b>#</b> <b>Queue.pop</b> <b>q</b>
           <b>Exception:</b> <b>Stdlib.Queue.Empty.</b>

   <b>Search</b> <b>Through</b> <b>a</b> <b>Graph</b>
       For a more elaborate example, a classic algorithmic use of queues is to implement  a  BFS  (breadth-first
       search) through a graph.

            <b>type</b> <b>graph</b> <b>=</b> <b>{</b>
              <b>edges:</b> <b>(int,</b> <b>int</b> <b>list)</b> <b>Hashtbl.t</b>
            <b>}</b>

           <b>(*</b> <b>Search</b> <b>in</b> <b>graph</b> <b>[g]</b> <b>using</b> <b>BFS,</b> <b>starting</b> <b>from</b> <b>node</b> <b>[start].</b>
              <b>It</b> <b>returns</b> <b>the</b> <b>first</b> <b>node</b> <b>that</b> <b>satisfies</b> <b>[p],</b> <b>or</b> <b>[None]</b> <b>if</b>
              <b>no</b> <b>node</b> <b>reachable</b> <b>from</b> <b>[start]</b> <b>satisfies</b> <b>[p].</b>
           <b>*)</b>
           <b>let</b> <b>search_for</b> <b>~(g:graph)</b> <b>~(start:int)</b> <b>(p:int</b> <b>-&gt;</b> <b>bool)</b> <b>:</b> <b>int</b> <b>option</b> <b>=</b>
             <b>let</b> <b>to_explore</b> <b>=</b> <b>Queue.create()</b> <b>in</b>
             <b>let</b> <b>explored</b> <b>=</b> <b>Hashtbl.create</b> <b>16</b> <b>in</b>

             <b>Queue.push</b> <b>start</b> <b>to_explore;</b>
             <b>let</b> <b>rec</b> <b>loop</b> <b>()</b> <b>=</b>
               <b>if</b> <b>Queue.is_empty</b> <b>to_explore</b> <b>then</b> <b>None</b>
               <b>else</b>
                 <b>(*</b> <b>node</b> <b>to</b> <b>explore</b> <b>*)</b>
                 <b>let</b> <b>node</b> <b>=</b> <b>Queue.pop</b> <b>to_explore</b> <b>in</b>
                 <b>explore_node</b> <b>node</b>

             <b>and</b> <b>explore_node</b> <b>node</b> <b>=</b>
               <b>if</b> <b>not</b> <b>(Hashtbl.mem</b> <b>explored</b> <b>node)</b> <b>then</b> <b>(</b>
                 <b>if</b> <b>p</b> <b>node</b> <b>then</b> <b>Some</b> <b>node</b> <b>(*</b> <b>found</b> <b>*)</b>
                 <b>else</b> <b>(</b>
                   <b>Hashtbl.add</b> <b>explored</b> <b>node</b> <b>();</b>
                   <b>let</b> <b>children</b> <b>=</b>
                     <b>Hashtbl.find_opt</b> <b>g.edges</b> <b>node</b>
                     <b>|&gt;</b> <b>Option.value</b> <b>~default:[]</b>
                   <b>in</b>
                   <b>List.iter</b> <b>(fun</b> <b>child</b> <b>-&gt;</b> <b>Queue.push</b> <b>child</b> <b>to_explore)</b> <b>children;</b>
                   <b>loop()</b>
                 <b>)</b>
               <b>)</b> <b>else</b> <b>loop()</b>
             <b>in</b>
             <b>loop()</b>

           <b>(*</b> <b>a</b> <b>sample</b> <b>graph</b> <b>*)</b>
           <b>let</b> <b>my_graph:</b> <b>graph</b> <b>=</b>
             <b>let</b> <b>edges</b> <b>=</b>
               <b>List.to_seq</b> <b>[</b>
                 <b>1,</b> <b>[2;3];</b>
                 <b>2,</b> <b>[10;</b> <b>11];</b>
                 <b>3,</b> <b>[4;5];</b>
                 <b>5,</b> <b>[100];</b>
                 <b>11,</b> <b>[0;</b> <b>20];</b>
               <b>]</b>
               <b>|&gt;</b> <b>Hashtbl.of_seq</b>
             <b>in</b> <b>{edges}</b>

           <b>#</b> <b>search_for</b> <b>~g:my_graph</b> <b>~start:1</b> <b>(fun</b> <b>x</b> <b>-&gt;</b> <b>x</b> <b>=</b> <b>30)</b>
           <b>-</b> <b>:</b> <b>int</b> <b>option</b> <b>=</b> <b>None</b>

           <b>#</b> <b>search_for</b> <b>~g:my_graph</b> <b>~start:1</b> <b>(fun</b> <b>x</b> <b>-&gt;</b> <b>x</b> <b>&gt;=</b> <b>15)</b>
           <b>-</b> <b>:</b> <b>int</b> <b>option</b> <b>=</b> <b>Some</b> <b>20</b>

           <b>#</b> <b>search_for</b> <b>~g:my_graph</b> <b>~start:1</b> <b>(fun</b> <b>x</b> <b>-&gt;</b> <b>x</b> <b>&gt;=</b> <b>50)</b>
           <b>-</b> <b>:</b> <b>int</b> <b>option</b> <b>=</b> <b>Some</b> <b>100</b>

OCamldoc                                           2025-06-12                                          <u><a href="../man3o/Queue.3o.html">Queue</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>