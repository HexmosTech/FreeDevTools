<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>queue - Abstract data type for FIFO queues.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       queue - Abstract data type for FIFO queues.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides (double-ended) FIFO queues in an efficient manner.

       All  functions  fail  with reason <u>badarg</u> if arguments are of wrong type, for example, queue arguments are
       not queues, indexes are not integers, and list arguments are not lists.  Improper  lists  cause  internal
       crashes. An index out of range for a queue also causes a failure with reason <u>badarg</u>.

       Some functions, where noted, fail with reason <u>empty</u> for an empty queue.

       The  data  representing  a queue as used by this module is to be regarded as opaque by other modules. Any
       code assuming knowledge of the format is running on thin ice.

       All operations  have  an  amortized  <a href="../man1/O.1.html">O</a>(1)  running  time,  except  <u>all/2</u>,  <u>any/2</u>,  <u>delete/2</u>,  <u>delete_r/2</u>,
       <u>delete_with/2</u>, <u>delete_with_r/2</u>, <u>filter/2</u>, <u>filtermap/2</u>, <u>fold/3</u>, <u>join/2</u>, <u>len/1</u>, <u>member/2</u>, <u>split/2</u> that have
       O(n).  To  minimize  the  size of a queue minimizing the amount of garbage built by queue operations, the
       queues do not contain explicit length information, and that is why <u>len/1</u> is O(n). If  better  performance
       for this particular operation is essential, it is easy for the caller to keep track of the length.

       Queues  are  double-ended.  The  mental  picture of a queue is a line of people (items) waiting for their
       turn. The queue front is the end with the item that has waited the longest. The queue rear is the end  an
       item  enters  when  it starts to wait. If instead using the mental picture of a list, the front is called
       head and the rear is called tail.

       Entering at the front and exiting at the rear are reverse operations on the queue.

       This module has three sets of interface functions: the  "Original  API",  the  "Extended  API",  and  the
       "Okasaki API".

       The  "Original  API"  and the "Extended API" both use the mental picture of a waiting line of items. Both
       have reverse operations suffixed "_r".

       The "Original API" item removal functions return compound terms  with  both  the  removed  item  and  the
       resulting  queue. The "Extended API" contains alternative functions that build less garbage and functions
       for just inspecting the queue ends. Also the "Okasaki API" functions build less garbage.

       The "Okasaki API" is inspired by "Purely Functional Data Structures" by Chris Okasaki. It regards  queues
       as  lists.  This  API  is by many regarded as strange and avoidable. For example, many reverse operations
       have lexically reversed names, some with more readable but perhaps less understandable aliases.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>queue(Item)</b>

              As returned by <u>new/0</u>.

       <b>queue()</b> = queue(term())

</pre><h4><b>ORIGINAL</b> <b>API</b></h4><pre>
</pre><h4><b>EXPORTS</b></h4><pre>
       <b>all(Pred,</b> <b>Q</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Pred = fun((Item) -&gt; boolean())

              Returns <u>true</u> if <u>Pred(Item)</u> returns <u>true</u> for all items <u>Item</u> in <u>Q</u>, otherwise <u>false</u>.

       <b>any(Pred,</b> <b>Q</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Pred = fun((Item) -&gt; boolean())

              Returns <u>true</u> if <u>Pred(Item)</u> returns <u>true</u> for at least one item <u>Item</u> in <u>Q</u>, otherwise <u>false</u>.

       <b>delete(Item,</b> <b>Q1)</b> <b>-&gt;</b> <b>Q2</b>

              Types:

                 Item = T
                 Q1 = Q2 = queue(T)
                 T = term()

              Returns a copy of <u>Q1</u> where the first item matching <u>Item</u> is deleted, if there is such an item.

       <b>delete_r(Item,</b> <b>Q1)</b> <b>-&gt;</b> <b>Q2</b>

              Types:

                 Item = T
                 Q1 = Q2 = queue(T)
                 T = term()

              Returns a copy of <u>Q1</u> where the last item matching <u>Item</u> is deleted, if there is such an item.

       <b>delete_with(Pred,</b> <b>Q1)</b> <b>-&gt;</b> <b>Q2</b>

              Types:

                 Pred = fun((Item) -&gt; boolean())
                 Q1 = Q2 = queue(Item)
                 Item = term()

              Returns a copy of <u>Q1</u> where the first item for which <u>Pred</u> returns <u>true</u> is deleted, if there is such
              an item.

       <b>delete_with_r(Pred,</b> <b>Q1)</b> <b>-&gt;</b> <b>Q2</b>

              Types:

                 Pred = fun((Item) -&gt; boolean())
                 Q1 = Q2 = queue(Item)
                 Item = term()

              Returns a copy of <u>Q1</u> where the last item for which <u>Pred</u> returns <u>true</u> is deleted, if there is  such
              an item.

       <b>filter(Fun,</b> <b>Q1</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Q2</b> <b>::</b> <b>queue(Item)</b>

              Types:

                 Fun = fun((Item) -&gt; boolean() | [Item])

              Returns a queue <u>Q2</u> that is the result of calling <u>Fun(Item)</u> on all items in <u>Q1</u>.

              If  <u>Fun(Item)</u>  returns  <u>true</u>, <u>Item</u> is copied to the result queue. If it returns <u>false</u>, <u>Item</u> is not
              copied. If it returns a list, the list elements are inserted instead of <u>Item</u> in the result queue.

              So, <u>Fun(Item)</u> returning <u>[Item]</u> is thereby semantically  equivalent  to  returning  <u>true</u>,  just  as
              returning  <u>[]</u>  is  semantically  equivalent  to  returning <u>false</u>. But returning a list builds more
              garbage than returning an atom.

       <b>filtermap(Fun,</b> <b>Q1)</b> <b>-&gt;</b> <b>Q2</b>

              Types:

                 Fun = fun((Item) -&gt; boolean() | {true, Value})
                 Q1 = queue(Item)
                 Q2 = queue(Item | Value)
                 Item = Value = term()

              Returns a queue <u>Q2</u> that is the result of calling <u>Fun(Item)</u> on all items in <u>Q1</u>.

              If <u>Fun(Item)</u> returns <u>true</u>, <u>Item</u> is copied to the result queue. If it returns <u>false</u>,  <u>Item</u>  is  not
              copied. If it returns <u>{true,</u> <u>NewItem}</u>, the queue element at this position is replaced with <u>NewItem</u>
              in the result queue.

       <b>fold(Fun,</b> <b>Acc0,</b> <b>Q</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Acc1</b>

              Types:

                 Fun = fun((Item, AccIn) -&gt; AccOut)
                 Acc0 = Acc1 = AccIn = AccOut = term()

              Calls  <u>Fun(Item,</u>  <u>AccIn)</u> on successive items <u>Item</u> of <u>Queue</u>, starting with <u>AccIn</u> <u>==</u> <u>Acc0</u>. The queue
              is traversed in queue order, that is, from front to rear. <u>Fun/2</u> must  return  a  new  accumulator,
              which is passed to the next call. The function returns the final value of the accumulator. <u>Acc0</u> is
              returned if the queue is empty.

              <u>Example:</u>

              &gt; queue:fold(fun(X, Sum) -&gt; X + Sum end, 0, queue:from_list([1,2,3,4,5])).
              15
              &gt; queue:fold(fun(X, Prod) -&gt; X * Prod end, 1, queue:from_list([1,2,3,4,5])).
              120

       <b>from_list(L</b> <b>::</b> <b>[Item])</b> <b>-&gt;</b> <b>queue(Item)</b>

              Returns a queue containing the items in <u>L</u> in the same order; the head item of the list becomes the
              front item of the queue.

       <b>in(Item,</b> <b>Q1</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Q2</b> <b>::</b> <b>queue(Item)</b>

              Inserts <u>Item</u> at the rear of queue <u>Q1</u>. Returns the resulting queue <u>Q2</u>.

       <b>in_r(Item,</b> <b>Q1</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Q2</b> <b>::</b> <b>queue(Item)</b>

              Inserts <u>Item</u> at the front of queue <u>Q1</u>. Returns the resulting queue <u>Q2</u>.

       <b>is_empty(Q</b> <b>::</b> <b>queue())</b> <b>-&gt;</b> <b>boolean()</b>

              Tests if <u>Q</u> is empty and returns <u>true</u> if so, otherwise <u>false</u>.

       <b>is_queue(Term</b> <b>::</b> <b>term())</b> <b>-&gt;</b> <b>boolean()</b>

              Tests if <u>Term</u> is a queue and returns <u>true</u> if so, otherwise <u>false</u>.

       <b>join(Q1</b> <b>::</b> <b>queue(Item),</b> <b>Q2</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Q3</b> <b>::</b> <b>queue(Item)</b>

              Returns a queue <u>Q3</u> that is the result of joining <u>Q1</u> and <u>Q2</u> with <u>Q1</u> in front of <u>Q2</u>.

       <b>len(Q</b> <b>::</b> <b>queue())</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Calculates and returns the length of queue <u>Q</u>.

       <b>member(Item,</b> <b>Q</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Item</u> matches some element in <u>Q</u>, otherwise <u>false</u>.

       <b>new()</b> <b>-&gt;</b> <b>queue()</b>

              Returns an empty queue.

       <b>out(Q1</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b>
              {{value, Item}, Q2 :: queue(Item)} |
              {empty, Q1 :: queue(Item)}

              Removes  the  item  at the front of queue <u>Q1</u>. Returns tuple <u>{{value,</u> <u>Item},</u> <u>Q2}</u>, where <u>Item</u> is the
              item removed and <u>Q2</u> is the resulting queue. If <u>Q1</u> is empty, tuple <u>{empty,</u> <u>Q1}</u> is returned.

       <b>out_r(Q1</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b>
                {{value, Item}, Q2 :: queue(Item)} |
                {empty, Q1 :: queue(Item)}

              Removes the item at the rear of queue <u>Q1</u>. Returns tuple <u>{{value,</u> <u>Item},</u> <u>Q2}</u>,  where  <u>Item</u>  is  the
              item removed and <u>Q2</u> is the new queue. If <u>Q1</u> is empty, tuple <u>{empty,</u> <u>Q1}</u> is returned.

       <b>reverse(Q1</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Q2</b> <b>::</b> <b>queue(Item)</b>

              Returns a queue <u>Q2</u> containing the items of <u>Q1</u> in the reverse order.

       <b>split(N</b> <b>::</b> <b>integer()</b> <b>&gt;=</b> <b>0,</b> <b>Q1</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b>
                {Q2 :: queue(Item), Q3 :: queue(Item)}

              Splits <u>Q1</u> in two. The <u>N</u> front items are put in <u>Q2</u> and the rest in <u>Q3</u>.

       <b>to_list(Q</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>[Item]</b>

              Returns  a  list  of the items in the queue in the same order; the front item of the queue becomes
              the head of the list.

</pre><h4><b>EXTENDED</b> <b>API</b></h4><pre>
</pre><h4><b>EXPORTS</b></h4><pre>
       <b>drop(Q1</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Q2</b> <b>::</b> <b>queue(Item)</b>

              Returns a queue <u>Q2</u> that is the result of removing the front item from <u>Q1</u>.

              Fails with reason <u>empty</u> if <u>Q1</u> is empty.

       <b>drop_r(Q1</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Q2</b> <b>::</b> <b>queue(Item)</b>

              Returns a queue <u>Q2</u> that is the result of removing the rear item from <u>Q1</u>.

              Fails with reason <u>empty</u> if <u>Q1</u> is empty.

       <b>get(Q</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Item</b>

              Returns <u>Item</u> at the front of queue <u>Q</u>.

              Fails with reason <u>empty</u> if <u>Q</u> is empty.

       <b>get_r(Q</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Item</b>

              Returns <u>Item</u> at the rear of queue <u>Q</u>.

              Fails with reason <u>empty</u> if <u>Q</u> is empty.

       <b>peek(Q</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>empty</b> <b>|</b> <b>{value,</b> <b>Item}</b>

              Returns tuple <u>{value,</u> <u>Item}</u>, where <u>Item</u> is the front item of <u>Q</u>, or <u>empty</u> if <u>Q</u> is empty.

       <b>peek_r(Q</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>empty</b> <b>|</b> <b>{value,</b> <b>Item}</b>

              Returns tuple <u>{value,</u> <u>Item}</u>, where <u>Item</u> is the rear item of <u>Q</u>, or <u>empty</u> if <u>Q</u> is empty.

</pre><h4><b>OKASAKI</b> <b>API</b></h4><pre>
</pre><h4><b>EXPORTS</b></h4><pre>
       <b>cons(Item,</b> <b>Q1</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Q2</b> <b>::</b> <b>queue(Item)</b>

              Inserts <u>Item</u> at the head of queue <u>Q1</u>. Returns the new queue <u>Q2</u>.

       <b>daeh(Q</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Item</b>

              Returns the tail item of queue <u>Q</u>.

              Fails with reason <u>empty</u> if <u>Q</u> is empty.

       <b>head(Q</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Item</b>

              Returns <u>Item</u> from the head of queue <u>Q</u>.

              Fails with reason <u>empty</u> if <u>Q</u> is empty.

       <b>init(Q1</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Q2</b> <b>::</b> <b>queue(Item)</b>

              Returns a queue <u>Q2</u> that is the result of removing the tail item from <u>Q1</u>.

              Fails with reason <u>empty</u> if <u>Q1</u> is empty.

       <b>lait(Q1</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Q2</b> <b>::</b> <b>queue(Item)</b>

              Returns a queue <u>Q2</u> that is the result of removing the tail item from <u>Q1</u>.

              Fails with reason <u>empty</u> if <u>Q1</u> is empty.

              The name <u>lait/1</u> is a misspelling - do not use it anymore.

       <b>last(Q</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Item</b>

              Returns the tail item of queue <u>Q</u>.

              Fails with reason <u>empty</u> if <u>Q</u> is empty.

       <b>liat(Q1</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Q2</b> <b>::</b> <b>queue(Item)</b>

              Returns a queue <u>Q2</u> that is the result of removing the tail item from <u>Q1</u>.

              Fails with reason <u>empty</u> if <u>Q1</u> is empty.

       <b>snoc(Q1</b> <b>::</b> <b>queue(Item),</b> <b>Item)</b> <b>-&gt;</b> <b>Q2</b> <b>::</b> <b>queue(Item)</b>

              Inserts <u>Item</u> as the tail item of queue <u>Q1</u>. Returns the new queue <u>Q2</u>.

       <b>tail(Q1</b> <b>::</b> <b>queue(Item))</b> <b>-&gt;</b> <b>Q2</b> <b>::</b> <b>queue(Item)</b>

              Returns a queue <u>Q2</u> that is the result of removing the head item from <u>Q1</u>.

              Fails with reason <u>empty</u> if <u>Q1</u> is empty.

Ericsson AB                                        stdlib 3.17                                       <u><a href="../man3erl/queue.3erl.html">queue</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>