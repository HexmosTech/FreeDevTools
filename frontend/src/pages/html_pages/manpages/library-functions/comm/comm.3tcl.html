<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>comm - A remote communication facility for Tcl (8.5 and later)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       comm - A remote communication facility for Tcl (8.5 and later)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>comm</b> <b>?4.7.3?</b>

       <b>::comm::comm</b> <b>send</b> ?-async? ?-command <u>callback</u>? <u>id</u> <u>cmd</u> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <b>::comm::comm</b> <b>self</b>

       <b>::comm::comm</b> <b>interps</b>

       <b>::comm::comm</b> <b>connect</b> ?<u>id</u>?

       <b>::comm::comm</b> <b>new</b> <u>chan</u> ?<u>name</u> <u>value</u> <u>...</u>?

       <b>::comm::comm</b> <b>channels</b>

       <b>::comm::comm</b> <b>config</b>

       <b>::comm::comm</b> <b>config</b> <u>name</u>

       <b>::comm::comm</b> <b>config</b> ?<u>name</u> <u>value</u> <u>...</u>?

       <b>::comm::comm</b> <b>shutdown</b> <u>id</u>

       <b>::comm::comm</b> <b>abort</b>

       <b>::comm::comm</b> <b>destroy</b>

       <b>::comm::comm</b> <b>hook</b> <u>event</u> ?<b>+</b>? ?<u>script</u>?

       <b>::comm::comm</b> <b>remoteid</b>

       <b>::comm::comm_send</b>

       <b>::comm::comm</b> <b>return_async</b>

       <b>$future</b> <b>return</b> ?<b>-code</b> <u>code</u>? ?<u>value</u>?

       <b>$future</b> <b>configure</b> ?<b>-command</b> ?<u>cmdprefix</u>??

       <b>$future</b> <b>cget</b> <b>-command</b>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>comm</b> command provides an inter-interpreter remote execution facility much like Tk's <b><a href="../man3tk/send.3tk.html">send</a>(3tk)</b>, except
       that  it  uses sockets rather than the X server for the communication path.  As a result, <b>comm</b> works with
       multiple interpreters, works on Windows and Macintosh systems,  and  provides  control  over  the  remote
       execution path.

       These commands work just like <b>send</b> and <b>winfo</b> <b>interps</b> :

                  ::comm::comm send ?-async? id cmd ?arg arg ...?
                  ::comm::comm interps

       This is all that is really needed to know in order to use <b>comm</b>

   <b>COMMANDS</b>
       The package initializes <b>::comm::comm</b> as the default <u>chan</u>.

       <b>comm</b> names communication endpoints with an <u>id</u> unique to each machine.  Before sending commands, the <u>id</u> of
       another  interpreter  is  needed.   Unlike  Tk's  send,  <b>comm</b> doesn't implicitly know the <u>id</u>'s of all the
       interpreters on the system.  The following four methods make up the basic <b>comm</b> interface.

       <b>::comm::comm</b> <b>send</b> ?-async? ?-command <u>callback</u>? <u>id</u> <u>cmd</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
              This invokes the given command in the interpreter named by <u>id</u>.  The command waits for  the  result
              and remote errors are returned unless the <b>-async</b> or <b>-command</b> option is given.  If <b>-async</b> is given,
              send  returns  immediately  and  there is no further notification of result.  If <b>-command</b> is used,
              <u>callback</u> specifies a command to invoke when the result is received.  These  options  are  mutually
              exclusive.  The callback will receive arguments in the form <u>-option</u> <u>value</u>, suitable for <b>array</b> <b>set</b>.
              The  options are: <u>-id</u>, the comm id of the interpreter that received the command; <u>-serial</u>, a unique
              serial for each command sent to a particular comm  interpreter;  <u>-chan</u>,  the  comm  channel  name;
              <u>-code</u>,  the  result  code  of  the  command;  <u>-errorcode</u>,  the  errorcode, if any, of the command;
              <u>-errorinfo</u>, the errorinfo, if any, of the command; and <u>-result</u>, the return value of  the  command.
              If  connection  is lost before a reply is received, the callback will be invoked with a connection
              lost message with -code equal to -1.  When <b>-command</b> is used, the command returns the unique serial
              for the command.

       <b>::comm::comm</b> <b>self</b>
              Returns the <u>id</u> for this channel.

       <b>::comm::comm</b> <b>interps</b>
              Returns a list of all the remote <u>id</u>'s to which this channel  is  connected.   <b>comm</b>  learns  a  new
              remote  <u>id</u>  when  a command is first issued it, or when a remote <u>id</u> first issues a command to this
              comm channel.  <b>::comm::comm</b> <b>ids</b> is an alias for this method.

       <b>::comm::comm</b> <b>connect</b> ?<u>id</u>?
              Whereas <b>::comm::comm</b> <b>send</b> will automatically connect to the given <u>id</u>, this forces a connection  to
              a  remote  <u>id</u>  without  sending  a command.  After this, the remote <u>id</u> will appear in <b>::comm::comm</b>
              <b>interps</b>.

   <b>EVAL</b> <b>SEMANTICS</b>
       The evaluation semantics of <b>::comm::comm</b> <b>send</b> are intended to match Tk's <b>send</b> <u>exactly</u>.  This  means  that
       <b>comm</b> evaluates arguments on the remote side.

       If  you  find  that <b>::comm::comm</b> <b>send</b> doesn't work for a particular command, try the same thing with Tk's
       send and see if the result is different.  If there is a problem, please report it.  For  instance,  there
       was  had  one  report  that  this  command produced an error.  Note that the equivalent <b>send</b> command also
       produces the same error.

                  % ::comm::comm send id llength {a b c}
                  wrong # args: should be "llength list"
                  % send name llength {a b c}
                  wrong # args: should be "llength list"

       The <b>eval</b> hook (described below) can be used to change from <b>send</b>'s double eval semantics  to  single  eval
       semantics.

   <b>MULTIPLE</b> <b>CHANNELS</b>
       More than one <b>comm</b> channel (or <u>listener</u>) can be created in each Tcl interpreter.  This allows flexibility
       to  create full and restricted channels.  For instance, <u>hook</u> scripts are specific to the channel they are
       defined against.

       <b>::comm::comm</b> <b>new</b> <u>chan</u> ?<u>name</u> <u>value</u> <u>...</u>?
              This creates a new channel and Tcl command with the given channel name.  This new command controls
              the new channel and takes all the same arguments as <b>::comm::comm</b>.   Any  remaining  arguments  are
              passed to the <b>config</b> method.  The fully qualified channel name is returned.

       <b>::comm::comm</b> <b>channels</b>
              This lists all the channels allocated in this Tcl interpreter.

       The default configuration parameters for a new channel are:

                  "-port 0 -local 1 -listen 0 -silent 0"

       The default channel <b>::comm::comm</b> is created with:

                  "::comm::comm new ::comm::comm -port 0 -local 1 -listen 1 -silent 0"

   <b>CHANNEL</b> <b>CONFIGURATION</b>
       The  <b>config</b>  method  acts  similar  to  <b>fconfigure</b>  in  that  it  sets or queries configuration variables
       associated with a channel.

       <b>::comm::comm</b> <b>config</b>

       <b>::comm::comm</b> <b>config</b> <u>name</u>

       <b>::comm::comm</b> <b>config</b> ?<u>name</u> <u>value</u> <u>...</u>?
              When given no arguments, <b>config</b> returns a list of all variables and their value With one argument,
              <b>config</b> returns the value of just that argument.  With an  even  number  of  arguments,  the  given
              variables are set to the given values.

       These configuration variables can be changed (descriptions of them are elsewhere in this manual page):

       <b>-listen</b> ?<u>0|1</u>?

       <b>-local</b>  ?<u>0|1</u>?

       <b>-port</b>   ?<u>port</u>?

       <b>-silent</b> ?<u>0|1</u>?

       <b>-socketcmd</b> ?<u>commandname</u>?

       <b>-interp</b> ?<u>interpreter</u>?

       <b>-events</b> ?<u>eventlist</u>?

       These configuration variables are read only:

       <b>-chan</b>    <u>chan</u>

       <b>-serial</b>  <u>n</u>

       <b>-socket</b>  sock<u>In</u>

       When <b>config</b> changes the parameters of an existing channel (with the exception of <b>-interp</b> and <b>-events</b>), it
       closes  and  reopens  the  listening  socket.  An automatically assigned channel <u>id</u> will change when this
       happens.  Recycling the socket is done by invoking <b>::comm::comm</b> <b>abort</b>, which causes all active  sends  to
       terminate.

   <b>ID/PORT</b> <b>ASSIGNMENTS</b>
       <b>comm</b>  uses  a  TCP  port  for endpoint <u>id</u>.  The <b>interps</b> (or <b>ids</b>) method merely lists all the TCP ports to
       which the channel is connected.  By default, each channel's <u>id</u> is  randomly  assigned  by  the  operating
       system  (but  usually  starts at a low value around 1024 and increases each time a new socket is opened).
       This behavior is accomplished by giving the <b>-port</b> config option a value of 0.   Alternately,  a  specific
       TCP port number may be provided for a given channel.  As a special case, comm contains code to allocate a
       a  high-numbered  TCP  port  (&gt;10000)  by  using  <b>-port</b>  <b>{}</b>.   Note  that  a channel won't be created and
       initialized unless the specific port can be allocated.

       As a special case, if the channel is configured with <b>-listen</b> <b>0</b>, then  it  will  not  create  a  listening
       socket  and  will  use  an  id  of  <b>0</b>  for  itself.  Such a channel is only good for outgoing connections
       (although once a connection is established, it can carry send traffic in both  directions).   As  another
       special case, if the channel is configured with <b>-silent</b> <b>0</b>, then the listening side will ignore connection
       attempts where the protocol negotiation phase failed, instead of throwing an error.

   <b>EXECUTION</b> <b>ENVIRONMENT</b>
       A  communication  channel in its default configuration will use the current interpreter for the execution
       of all received scripts, and of the event scripts associated with the various hooks.

       This insecure setup can be changed by the user via the two options <b>-interp</b>, and <b>-events</b>.

       When <b>-interp</b> is set all received scripts are executed in the slave interpreter specified as the value  of
       the  option. This interpreter is expected to exist before configuration. I.e. it is the responsibility of
       the user to create it. However afterward the communication channel takes ownership of  this  interpreter,
       and  will  destroy  it  when  the  communication  channel is destroyed.  Note that reconfiguration of the
       communication channel to either a different interpreter or the empty string will  release  the  ownership
       <u>without</u>  destroying  the  previously  configured interpreter.  The empty string has a special meaning, it
       restores the default behaviour of executing received scripts in the current interpreter.

       <u>Also</u> <u>of</u> <u>note</u> is that replies and callbacks (a special form of  reply)  are  <u>not</u>  considered  as  received
       scripts.  They  are trusted, part of the internal machinery of comm, and therefore always executed in the
       current interpreter.

       Even if an interpreter has been configured as the execution environment for received  scripts  the  event
       scripts  associated  with the various hooks will by default still be executed in the current interpreter.
       To change this use the option <b>-events</b> to declare a list of the events whose scripts should be executed in
       the declared interpreter as well. The contents of this option are ignored if the communication channel is
       configured to execute received scripts in the current interpreter.

   <b>REMOTE</b> <b>INTERPRETERS</b>
       By default, each channel is restricted to accepting connections from  the  local  system.   This  can  be
       overridden  by using the <b>-local</b> <b>0</b> configuration option For such channels, the <u>id</u> parameter takes the form
       <u>{</u> <u>id</u> <u>host</u> <u>}</u>.

       <u>WARNING</u>: The <u>host</u> must always be specified in the same form (e.g., as either  a  fully  qualified  domain
       name, plain hostname or an IP address).

   <b>CLOSING</b> <b>CONNECTIONS</b>
       These methods give control over closing connections:

       <b>::comm::comm</b> <b>shutdown</b> <u>id</u>
              This  closes  the  connection  to  <u>id</u>,  aborting  all outstanding commands in progress.  Note that
              nothing prevents the connection from being immediately reopened by another  incoming  or  outgoing
              command.

       <b>::comm::comm</b> <b>abort</b>
              This invokes shutdown on all open connections in this comm channel.

       <b>::comm::comm</b> <b>destroy</b>
              This  aborts all connections and then destroys the this comm channel itself, including closing the
              listening socket.  Special code allows the default <b>::comm::comm</b> channel to be closed such that the
              <b>::comm::comm</b> command it is not destroyed.  Doing so closes the listening socket,  preventing  both
              incoming and outgoing commands on the channel.  This sequence reinitializes the default channel:

                  "::comm::comm destroy; ::comm::comm new ::comm::comm"

       When  a  remote  connection  is  lost  (because the remote exited or called <b>shutdown</b>), <b>comm</b> can invoke an
       application callback.  This can be used to cleanup or restart an ancillary process,  for  instance.   See
       the <u>lost</u> callback below.

   <b>CALLBACKS</b>
       This is a mechanism for setting hooks for particular events:

       <b>::comm::comm</b> <b>hook</b> <u>event</u> ?<b>+</b>? ?<u>script</u>?
              This  uses a syntax similar to Tk's <b>bind</b> command.  Prefixing <u>script</u> with a <b>+</b> causes the new script
              to be appended.  Without this, a new <u>script</u> replaces any existing script.  When invoked without  a
              script, no change is made.  In all cases, the new hook script is returned by the command.

              When  an  <u>event</u>  occurs,  the  <u>script</u> associated with it is evaluated with the listed variables in
              scope and available.  The return code (<u>not</u> the return value) of the script is commonly used decide
              how to further process after the hook.

              Common variables include:

              <b>chan</b>   the name of the comm channel (and command)

              <b>id</b>     the id of the remote in question

              <b>fid</b>    the file id for the socket of the connection

       These are the defined <u>events</u>:

       <b>connecting</b>
              Variables: <b>chan</b>, <b>id</b>

              This hook is invoked before making a connection to the remote named in <u>id</u>.  An error  return  (via
              <b>error</b>) will abort the connection attempt with the error.  Example:

                  % ::comm::comm hook connecting {
                      if {[string match {*[02468]} $id]} {
                          error "Can't connect to even ids"
                      }
                  }
                  % ::comm::comm send 10000 puts ok
                  Connect to remote failed: Can't connect to even ids
                  %

       <b>connected</b>
              Variables: <b>chan</b>, <b>fid</b>, <b>id</b>, <b>host</b>, and <b>port</b>.

              This  hook  is  invoked  immediately  after  making  a remote connection to <u>id</u>, allowing arbitrary
              authentication over the socket named by <u>fid</u>.   An  error  return  (via  <b>error</b>  )  will  close  the
              connection  with the error.  <u>host</u> and <u>port</u> are merely extracted from the <u>id</u>; changing any of these
              will have no effect on the connection, however.  It is also possible  to  substitute  and  replace
              <u>fid</u>.

       <b>incoming</b>
              Variables: <b>chan</b>, <b>fid</b>, <b>addr</b>, and <b>remport</b>.

              Hook  invoked when receiving an incoming connection, allowing arbitrary authentication over socket
              named by <u>fid</u>.  An error return (via <b>error</b>) will close the connection with the  error.   Note  that
              the peer is named by <u>remport</u> and <u>addr</u> but that the remote <u>id</u> is still unknown.  Example:

                  ::comm::comm hook incoming {
                      if {[string match 127.0.0.1 $addr]} {
                          error "I don't talk to myself"
                      }
                  }

       <b>eval</b>   Variables: <b>chan</b>, <b>id</b>, <b>cmd</b>, and <b>buffer</b>.

              This  hook  is  invoked after collecting a complete script from a remote but <u>before</u> evaluating it.
              This allows complete control over the processing of incoming commands.  <u>cmd</u> contains  either  <b>send</b>
              or <b>async</b>.  <u>buffer</u> holds the script to evaluate.  At the time the hook is called, <u>$chan</u> <u>remoteid</u> is
              identical in value to <u>id</u>.

              By  changing  <u>buffer</u>,  the hook can change the script to be evaluated.  The hook can short circuit
              evaluation and cause a value to be immediately returned by using <b>return</b> <u>result</u> (or, from within  a
              procedure,  <b>return</b> <b>-code</b> <b>return</b> <u>result</u>).  An error return (via <b>error</b>) will return an error result,
              as is if the script caused the error.  Any other return will evaluate  the  script  in  <u>buffer</u>  as
              normal.   For  compatibility  with  3.2,  <b>break</b> and <b>return</b> <b>-code</b> <b>break</b> <u>result</u> is supported, acting
              similarly to <b>return</b> <b>{}</b> and <b>return</b> <b>-code</b> <b>return</b> <u>result</u>.

              Examples:

              [1]    augmenting a command

                         % ::comm::comm send [::comm::comm self] pid
                         5013
                         % ::comm::comm hook eval {puts "going to execute $buffer"}
                         % ::comm::comm send [::comm::comm self] pid
                         going to execute pid
                         5013

              [2]    short circuiting a command

                         % ::comm::comm hook eval {puts "would have executed $buffer"; return 0}
                         % ::comm::comm send [::comm::comm self] pid
                         would have executed pid
                         0

              [3]    Replacing double eval semantics

                         % ::comm::comm send [::comm::comm self] llength {a b c}
                         wrong # args: should be "llength list"
                         % ::comm::comm hook eval {return [uplevel #0 $buffer]}
                         return [uplevel #0 $buffer]
                         % ::comm::comm send [::comm::comm self] llength {a b c}
                         3

              [4]    Using a slave interpreter

                         % interp create foo
                         % ::comm::comm hook eval {return [foo eval $buffer]}
                         % ::comm::comm send [::comm::comm self] set myvar 123
                         123
                         % set myvar
                         can't read "myvar": no such variable
                         % foo eval set myvar
                         123

              [5]    Using a slave interpreter (double eval)

                         % ::comm::comm hook eval {return [eval foo eval $buffer]}

              [6]    Subverting the script to execute

                         % ::comm::comm hook eval {
                             switch -- $buffer {
                                 a {return A-OK}
                                 b {return B-OK}
                                 default {error "$buffer is a no-no"}
                             }
                         }
                         % ::comm::comm send [::comm::comm self] pid
                         pid is a no-no
                         % ::comm::comm send [::comm::comm self] a
                         A-OK

       <b>reply</b>  Variables: <b>chan</b>, <b>id</b>, <b>buffer</b>, <b>ret</b>, and <b>return()</b>.

              This hook is invoked after collecting a complete reply script from a remote but <u>before</u>  evaluating
              it.   This  allows  complete  control  over the processing of replies to sent commands.  The reply
              <u>buffer</u> is in one of the following forms

              •      return result

              •      return -code code result

              •      return -code code -errorinfo info -errorcode ecode msg

       For safety reasons, this is decomposed.  The return result is in <u>ret</u>, and the return switches are in  the
       return array:

              •      <u>return(-code)</u>

              •      <u>return(-errorinfo)</u>

              •      <u>return(-errorcode)</u>

       Any  of  these  may  be  the  empty  string.  Modifying these four variables can change the return value,
       whereas modifying <u>buffer</u> has no effect.

       <b>callback</b>
              Variables: <b>chan</b>, <b>id</b>, <b>buffer</b>, <b>ret</b>, and <b>return()</b>.

              Similar to <u>reply</u>, but used for callbacks.

       <b>lost</b>   Variables: <b>chan</b>, <b>id</b>, and <b>reason</b>.

              This hook is invoked when the connection to <b>id</b>  is  lost.   Return  value  (or  thrown  error)  is
              ignored.  <u>reason</u> is an explanatory string indicating why the connection was lost.  Example:

                  ::comm::comm hook lost {
                      global myvar
                      if {$myvar(id) == $id} {
                          myfunc
                          return
                      }
                  }

   <b>UNSUPPORTED</b>
       These interfaces may change or go away in subsequence releases.

       <b>::comm::comm</b> <b>remoteid</b>
              Returns  the  <u>id</u>  of the sender of the last remote command executed on this channel.  If used by a
              proc being invoked remotely, it must be  called  before  any  events  are  processed.   Otherwise,
              another command may get invoked and change the value.

       <b>::comm::comm_send</b>
              Invoking  this  procedure  will  substitute  the  Tk  <b>send</b>  and  <b>winfo</b> <b>interps</b> commands with these
              equivalents that use <b>::comm::comm</b>.

                  proc send {args} {
                      eval ::comm::comm send $args
                  }
                  rename winfo tk_winfo
                  proc winfo {cmd args} {
                      if {![string match in* $cmd]} {
                          return [eval [list tk_winfo $cmd] $args]
                      }
                      return [::comm::comm interps]
                  }

   <b>SECURITY</b>
       Starting with version 4.6 of the package an option <b>-socketcmd</b> is supported, allowing the user of  a  comm
       channel  to specify which command to use when opening a socket. Anything which is API-compatible with the
       builtin <b>::socket</b> (the default) can be used.

       The envisioned main use is the specification of the <b>tls::socket</b> command, see package <b>tls</b>, to  secure  the
       communication.

                # Load and initialize tls
                package require tls
                tls::init  -cafile /path/to/ca/cert -keyfile ...

                # Create secured comm channel
                ::comm::comm new SECURE -socketcmd tls::socket -listen 1
                ...

       The  sections  <b>Execution</b>  <b>Environment</b>  and  <b>Callbacks</b>  are  also  relevant to the security of the system,
       providing means to restrict the execution to a specific environment, perform  additional  authentication,
       and the like.

   <b>BLOCKING</b> <b>SEMANTICS</b>
       There  is  one  outstanding  difference  between  <b>comm</b>  and  <b>send</b>.  When blocking in a synchronous remote
       command, <b>send</b> uses an internal C hook (Tk_RestrictEvents) to the event  loop  to  look  ahead  for  send-
       related  events  and  only process those without processing any other events.  In contrast, <b>comm</b> uses the
       <b>vwait</b> command as a semaphore to indicate the return message  has  arrived.   The  difference  is  that  a
       synchronous  <b>send</b>  will block the application and prevent all events (including window related ones) from
       being processed, while a synchronous <b>::comm::comm</b> <b>send</b> will block the application but still  allow  other
       events to get processed.  In particular, <b>after</b> <b>idle</b> handlers will fire immediately when comm blocks.

       What can be done about this?  First, note that this behavior will come from any code using <b>vwait</b> to block
       and  wait  for  an  event to occur.  At the cost of multiple channel support, <b>comm</b> could be changed to do
       blocking I/O on the socket, giving send-like blocking semantics.  However, multiple channel support is  a
       very  useful feature of comm that it is deemed too important to lose.  The remaining approaches involve a
       new loadable module written in C (which is somewhat against the philosophy of <b>comm</b>) One way would  be  to
       create  a modified version of the <b>vwait</b> command that allow the event flags passed to Tcl_DoOneEvent to be
       specified.  For <b>comm</b>, just the TCL_FILE_EVENTS would be processed.  Another way would be to  implement  a
       mechanism  like  Tk_RestrictEvents,  but  apply it to the Tcl event loop (since <b>comm</b> doesn't require Tk).
       One of these approaches will be available in a future <b>comm</b> release as an optional component.

   <b>ASYNCHRONOUS</b> <b>RESULT</b> <b>GENERATION</b>
       By default the result returned by a remotely invoked command is the result sent back to the invoker. This
       means that the result is generated synchronously, and the server handling the call  is  blocked  for  the
       duration of the command.

       While  this  is  tolerable  as long as only short-running commands are invoked on the server long-running
       commands, like database queries make this a problem. One command can prevent the processing  requests  of
       all other clients for an arbitrary period of time.

       Before  version  4.5  of  comm the only solution was to rewrite the server command to use the Tcl builtin
       command <b>vwait</b>, or one of its relatives like <b>tkwait</b>, to open a new event  loop  which  processes  requests
       while  the long-running operation is executed. This however has its own perils, as this makes it possible
       to both overflow the Tcl stack with a large number of event loop, and to have a newer requests block  the
       return of older ones, as the eventloop have to be unwound in the order of their creation.

       The proper solution is to have the invoked command indicate to <b>comm</b> that it cannot or will not deliver an
       immediate,  synchronous  result,  but  will  do so later. At that point the framework can put sending the
       actual result on hold and continue processing requests using the main event loop. No blocking, no nesting
       of event loops. At some future date the long running operation delivers  the  result  to  comm,  via  the
       future object, which is then forwarded to the invoker as usual.

       The  necessary support for this solution has been added to comm since version 4.5, in the form of the new
       method <b>return_async</b>.

       <b>::comm::comm</b> <b>return_async</b>
              This command is used by a remotely invoked script to notify the comm channel which invoked it that
              the result to send back to the invoker is not generated synchronously.  If  this  command  is  not
              called the default/standard behaviour of comm is to send the synchronously generated result of the
              script itself to the invoker.

              The  result  of <b>return_async</b> is an object. This object, called a <u>future</u> is where the result of the
              script has to be delivered to when it becomes ready. When  that  happens  it  will  take  all  the
              necessary  actions  to  deliver  the result to the invoker of the script, and then destroy itself.
              Should comm have lost the connection to the invoker while the result is being computed the  future
              will  not  try to deliver the result it got, but just destroy itself. The future can be configured
              with a command to call when the invoker is lost. This enables the user to implement an early abort
              of the long-running operation, should this be supported by it.

              An example:

              # Procedure invoked by remote clients to run database operations.
              proc select {sql} {
                  # Signal the async generation of the result

                  set future [::comm::comm return_async]

                  # Generate an async db operation and tell it where to deliver the result.

                  set query [db query -command [list $future return] $sql]

                  # Tell the database system which query to cancel if the connection
                  # goes away while it is running.

                  $future configure -command [list db cancel $query]

                  # Note: The above will work without problem only if the async
                  # query will nover run its completion callback immediately, but
                  # only from the eventloop. Because otherwise the future we wish to
                  # configure may already be gone. If that is possible use 'catch'
                  # to prevent the error from propagating.
                  return
              }

       The API of a future object is:

              <b>$future</b> <b>return</b> ?<b>-code</b> <u>code</u>? ?<u>value</u>?
                     Use this method to tell the future that long-running operation has completed. Arguments are
                     an optional return value (defaults to the empty string), and the Tcl return code  (defaults
                     to OK).

                     The  future will deliver this information to invoker, if the connection was not lost in the
                     meantime, and then destroy itself. If the connection  was  lost  it  will  do  nothing  but
                     destroy itself.

              <b>$future</b> <b>configure</b> ?<b>-command</b> ?<u>cmdprefix</u>??

              <b>$future</b> <b>cget</b> <b>-command</b>
                     These  methods  allow the user to retrieve and set a command to be called if the connection
                     the future belongs to has been lost.

   <b>COMPATIBILITY</b>
       <b>comm</b> exports itself as a package.  The package version number is in the form <u>major</u>  <u>.</u>  <u>minor</u>,  where  the
       major  version  will  only change when a non-compatible change happens to the API or protocol.  Minor bug
       fixes and changes will only affect the minor version.  To load <b>comm</b> this command is usually used:

                  package require comm 3

       Note that requiring no version (or a specific version) can also be done.

       The revision history of <b>comm</b> includes these releases:

       4.6.3  Fixed ticket [ced0d60fc9]. Added proper detection of eof on a socket, properly closing it.

       4.6.2  Fixed bugs 2972571 and 3066872, the first a misdetection of quoted brace after  double  backslash,
              the other a blocking gets making for an obvious (hinsight) DoS attack on comm channels.

       4.6.1  Changed  the  implementation of <b>comm::commCollect</b> to emulate lindex's pre-Tcl 8 behaviour, i.e. it
              was given the ability to parse out the first word of a list, even if the whole  buffer  is  not  a
              well-formed  list.  Without this change the first word could only be extracted if the whole buffer
              was a well-formed list (ever since Tcl 8), and in a ver-high-load situation, i.e. a server sending
              lots and/or large commands very fast, this may never happen, eventually crashing the receiver when
              it runs out of memory. With the change the receiver is always able to process the first word  when
              it becomes well-formed, regardless of the structure of the remainder of the buffer.

       4.6    Added the option <b>-socketcmd</b> enabling users to override how a socket is opened. The envisioned main
              use is the specification of the <b>tls::socket</b> command, see package <b>tls</b>, to secure the communication.

       4.5.7  Changed handling of ports already in use to provide a proper error message.

       4.5.6  Bugfix in the replacement for <b>vwait</b>, made robust against of variable names containing spaces.

       4.5.5  Bugfix in the handling of hooks, typo in variable name.

       4.5.4  Bugfix  in  the  handling  of the result received by the <b>send</b> method. Replaced an <u>after</u> <u>idle</u> <u>unset</u>
              <u>result</u> with an immediate <b>unset</b>, with the information saved to a local variable.

              The <b>after</b> <b>idle</b> can spill into a forked child process if there is no event loop between  its  setup
              and  the  fork.  This  may bork the child if the next event loop is the <b>vwait</b> of <b>comm</b>'s <b>send</b> a few
              lines above the <b>after</b> <b>idle</b>, and the child used the same serial number for  its  next  request.  In
              that  case  the  parent's <b>after</b> <b>idle</b> <b>unset</b> will delete the very array element the child is waiting
              for, unlocking the <b>vwait</b>, causing it to access  a  now  missing  array  element,  instead  of  the
              expected result.

       4.5.3  Bugfixes in the wrappers for the builtin <b>update</b> and <b>vwait</b> commands.

       4.5.2  Bugfix in the wrapper for the builtin <b>update</b> command.

       4.5.1  Bugfixes  in the handling of -interp for regular scripts. The handling of the buffer was wrong for
              scripts which are a single statement as list. Fixed missing argument to new command <b>commSendReply</b>,
              introduced by version 4.5. Affected debugging.

       4.5    New server-side feature. The command invoked on the server can now switch comm from  the  standard
              synchronous  return  of  its result to an asynchronous (defered) return. Due to the use of snit to
              implement the <u>future</u> objects used by this feature from this version on comm requires at least  Tcl
              8.3 to run. Please read the section <b>Asynchronous</b> <b>Result</b> <b>Generation</b> for more details.

       4.4.1  Bugfix in the execution of hooks.

       4.4    Bugfixes in the handling of -interp for regular and hook scripts. Bugfixes in channel cleanup.

       4.3.1  Introduced  -interp  and  -events  to  enable easy use of a slave interp for execution of received
              scripts, and of event scripts.

       4.3    Bugfixes, and introduces -silent to allow the user to force the server/listening side to  silently
              ignore connection attempts where the protocol negotiation failed.

       4.2    Bugfixes,  and  most  important,  switched  to utf-8 as default encoding for full i18n without any
              problems.

       4.1    Rewrite  of  internal  code  to  remove  old  pseudo-object  model.   Addition  of  send  -command
              asynchronous callback option.

       4.0    Per request by John LoVerso. Improved handling of error for async invoked commands.

       3.7    Moved into tcllib and placed in a proper namespace.

       3.6    A  bug  in  the  looking  up  of  the  remoteid for a executed command could be triggered when the
              connection was closed while several asynchronous sends were queued to be executed.

       3.5    Internal change to how reply messages from a <b>send</b> are handled.  Reply  messages  are  now  decoded
              into  the  <u>value</u>  to  pass to <b>return</b>; a new return statement is then cons'd up to with this value.
              Previously, the return code was passed in from the remote as a command  to  evaluate.   Since  the
              wire  protocol  has not changed, this is still the case.  Instead, the reply handling code decodes
              the <b>reply</b> message.

       3.4    Added more source commentary, as well as documenting config variables in this man page.  Fixed bug
              were loss of connection would give error about a variable named <b>pending</b> rather  than  the  message
              about the lost connection.  <b>comm</b> <b>ids</b> is now an alias for <b>comm</b> <b>interps</b> (previously, it an alias for
              <b>comm</b>  <b>chans</b>).   Since  the method invocation change of 3.0, break and other exceptional conditions
              were not being returned correctly from <b>comm</b> <b>send</b>.  This has been fixed by removing the extra level
              of indirection into the internal procedure <b>commSend</b>.  Also  added  propagation  of  the  <u>errorCode</u>
              variable.  This means that these commands return exactly as they would with <b>send</b>:

                  comm send id break
                  catch {comm send id break}
                  comm send id expr 1 / 0

       Added  a  new hook for reply messages.  Reworked method invocation to avoid the use of comm:* procedures;
       this also cut the invocation time down by 40%.  Documented <b>comm</b> <b>config</b> (as this manual page still  listed
       the defunct <b>comm</b> <b>init</b>!)

       3.3    Some  minor  bugs  were  corrected  and the documentation was cleaned up.  Added some examples for
              hooks.  The return semantics of the <b>eval</b> hook were changed.

       3.2    A new wire protocol, version 3, was added.  This is backwards compatible with version 2  but  adds
              an  exchange  of supported protocol versions to allow protocol negotiation in the future.  Several
              bugs with the hook implementation were fixed.  A new section of the man page on blocking semantics
              was added.

       3.1    All the documented hooks were implemented.  <b>commLostHook</b> was removed.   A  bug  in  <b>comm</b>  <b>new</b>  was
              fixed.

       3.0    This  is  a  new  version  of <b>comm</b> with several major changes.  There is a new way of creating the
              methods available under the <b>comm</b> command.  The <b>comm</b> <b>init</b> method has been retired and  is  replaced
              by  <b>comm</b>  <b>configure</b> which allows access to many of the well-defined internal variables.  This also
              generalizes the options available to <b>comm</b> <b>new</b>.  Finally, there is now a protocol version exchanged
              when a  connection  is  established.   This  will  allow  for  future  on-wire  protocol  changes.
              Currently, the protocol version is set to 2.

       2.3    <b>comm</b>  <b>ids</b>  was renamed to <b>comm</b> <b>channels</b>.  General support for <b>comm</b> <b>hook</b> was fully implemented, but
              only the <u>lost</u> hook exists, and it was changed to follow the general hook  API.   <b>commLostHook</b>  was
              unsupported (replaced by <b>comm</b> <b>hook</b> <b>lost</b>) and <b>commLost</b> was removed.

       2.2    The <u>died</u> hook was renamed <u>lost</u>, to be accessed by <b>commLostHook</b> and an early implementation of <b>comm</b>
              <b>lost</b> <b>hook</b>.  As such, <b>commDied</b> is now <b>commLost</b>.

       2.1    Unsupported method <b>comm</b> <b>remoteid</b> was added.

       2.0    <b>comm</b>  has  been  rewritten  from  scratch  (but  is  fully  compatible  with Comm 1.0, without the
              requirement to use obTcl).

</pre><h4><b>TLS</b> <b>SECURITY</b> <b>CONSIDERATIONS</b></h4><pre>
       This package uses the <b>TLS</b> package to handle the security for <b>https</b> urls and other socket connections.

       Policy decisions like the set of protocols to support and what ciphers to use are not the  responsibility
       of  <b>TLS</b>,  nor  of  this  package  itself  however.   Such  decisions  are the responsibility of whichever
       application is using the package, and are likely influenced by the set of servers  the  application  will
       talk to as well.

       For        example,        in        light        of        the        recent        <u>POODLE</u>        <u>attack</u>
       [<a href="http://googleonlinesecurity.blogspot.co.uk/2014/10/this-poodle-bites-exploiting-ssl-30.html">http://googleonlinesecurity.blogspot.co.uk/2014/10/this-poodle-bites-exploiting-ssl-30.html</a>]  discovered
       by  Google  many  servers  will  disable  support  for  the  SSLv3  protocol.   To handle this change the
       applications using <b>TLS</b> must be patched, and not this package, nor <b>TLS</b> itself.  Such a  patch  may  be  as
       simple as generally activating <b>tls1</b> support, as shown in the example below.

                  package require tls
                  tls::init -tls1 1 ;# forcibly activate support for the TLS1 protocol

                  ... your own application code ...

</pre><h4><b>AUTHOR</b></h4><pre>
       John LoVerso, <a href="mailto:John@LoVerso.Southborough.MA.US">John@LoVerso.Southborough.MA.US</a>

       <u><a href="http://www.opengroup.org/~loverso/tcl-tk/">http://www.opengroup.org/~loverso/tcl-tk/</a>#comm</u>

</pre><h4><b>LICENSE</b></h4><pre>
       Please      see      the      file      <u>comm.LICENSE</u>     that     accompanied     this     source,     or
       <u><a href="http://www.opengroup.org/www/dist_client/caubweb/COPYRIGHT.free.html">http://www.opengroup.org/www/dist_client/caubweb/COPYRIGHT.free.html</a></u>.

       This license for <b>comm</b>, new as of version 3.2, allows it to be used for free, without any licensing fee or
       royalty.

</pre><h4><b>BUGS</b></h4><pre>
       •      If there is a failure initializing a channel created  with  <b>::comm::comm</b>  <b>new</b>,  then  the  channel
              should be destroyed.  Currently, it is left in an inconsistent state.

       •      There should be a way to force a channel to quiesce when changing the configuration.

       The  following  items  can  be  implemented  with the existing hooks and are listed here as a reminder to
       provide a sample hook in a future version.

       •      Allow easier use of a slave interp for actual command execution (especially when operating in "not
              local" mode).

       •      Add host list (xhost-like) or "magic cookie" (xauth-like) authentication to initial handshake.

       The following are outstanding todo items.

       •      Add an interp discovery and name-&gt;port mapping.  This is likely to  be  in  a  separate,  optional
              nameserver.  (See also the related work, below.)

       •      Fix the <u>{id</u> <u>host}</u> form so as not to be dependent upon canonical hostnames.  This requires fixes to
              Tcl to resolve hostnames!

       This man page is bigger than the source file.

</pre><h4><b>ON</b> <b>USING</b> <b>OLD</b> <b>VERSIONS</b> <b>OF</b> <b>TCL</b></h4><pre>
       Tcl7.5  under  Windows  contains  a  bug  that causes the interpreter to hang when EOF is reached on non-
       blocking sockets.  This can be triggered with a command such as this:

                  "comm send $other exit"

       Always make sure the channel is quiescent before closing/exiting or use at least Tcl7.6 under Windows.

       Tcl7.6 on the Mac contains several bugs.  It is recommended you use at least Tcl7.6p2.

       Tcl8.0 on UNIX contains a socket bug that can  crash  Tcl.   It  is  recommended  you  use  Tcl8.0p1  (or
       Tcl7.6p2).

</pre><h4><b>RELATED</b> <b>WORK</b></h4><pre>
       Tcl-DP  provides  an  RPC-based  remote  execution  interface,  but  is  a  compiled  Tcl extension.  See
       <u><a href="http://www.cs.cornell.edu/Info/Projects/zeno/Projects/Tcl-DP.html">http://www.cs.cornell.edu/Info/Projects/zeno/Projects/Tcl-DP.html</a></u>.

       Michael Doyle &lt;<a href="mailto:miked@eolas.com">miked@eolas.com</a>&gt; has code that implements the Tcl-DP  RPC  interface  using  standard  Tcl
       sockets,       much      like      <b>comm</b>.       The      DpTcl      package      is      available      at
       <u><a href="http://chiselapp.com/user/gwlester/repository/DpTcl">http://chiselapp.com/user/gwlester/repository/DpTcl</a></u>.

       Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt; uses <b>comm</b> and has built a  simple  nameserver  as
       part of his Pool library.  See <u><a href="http://www.purl.org/net/akupries/soft/pool/index.htm">http://www.purl.org/net/akupries/soft/pool/index.htm</a></u>.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category <u>comm</u> of the <u>Tcllib</u> <u>Trackers</u>  [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].   Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tk/send.3tk.html">send</a>(3tk)

</pre><h4><b>KEYWORDS</b></h4><pre>
       comm,  communication,  ipc,  message,  remote communication, remote execution, rpc, secure, send, socket,
       ssl, tls

</pre><h4><b>CATEGORY</b></h4><pre>
       Programming tools

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 1995-1998 The Open Group. All Rights Reserved.
       Copyright (c) 2003-2004 ActiveState Corporation.
       Copyright (c) 2006-2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                4.7.3                                           <u><a href="../man3tcl/comm.3tcl.html">comm</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>