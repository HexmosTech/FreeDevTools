<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>erl_tar - Unix 'tar' utility for reading and writing tar archives.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       erl_tar - Unix 'tar' utility for reading and writing tar archives.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  archives and extract files to and from a tar file. This module supports reading most common
       tar formats, namely v7, STAR, USTAR, and PAX, as well as some of GNU tar's extensions to the USTAR format
       (sparse files most notably). It produces tar archives in USTAR format, unless the  files  being  archived
       require PAX format due to restrictions in USTAR (such as unicode metadata, filename length, and more). As
       such,  <u>erl_tar</u>  supports  tar  archives  produced by most all modern tar utilities, and produces tarballs
       which should be similarly portable.

       By convention, the name of a tar file is to end in "<u>.tar</u>". To abide to the convention, add "<u>.tar</u>" to  the
       name.

       Tar files can be created in one operation using function <u>create/2</u> or <u>create/3</u>.

       Alternatively, for more control, use functions <u>open/2</u>, <u>add/3,4</u>, and <u>close/1</u>.

       To extract all files from a tar file, use function <u>extract/1</u>. To extract only some files or to be able to
       specify some more options, use function <u>extract/2</u>.

       To return a list of the files in a tar file, use function <u>table/1</u> or <u>table/2</u>. To print a list of files to
       the Erlang shell, use function <u>t/1</u> or <u>tt/1</u>.

       To  convert  an  error  term returned from one of the functions above to a readable message, use function
       <u>format_error/1</u>.

</pre><h4><b>UNICODE</b> <b>SUPPORT</b></h4><pre>
       If <u>file:native_name_encoding/0</u> returns <u>utf8</u>, path names are encoded in UTF-8 when creating tar files, and
       path names are assumed to be encoded in UTF-8 when extracting tar files.

       If <u>file:native_name_encoding/0</u> returns <u>latin1</u>, no translation of path names is done.

       Unicode metadata stored in PAX headers is preserved

</pre><h4><b>OTHER</b> <b>STORAGE</b> <b>MEDIA</b></h4><pre>
       The <u>ftp</u> module normally accesses the tar file on disk using the <u>file</u> module. When other needs arise,  you
       can  define  your own low-level Erlang functions to perform the writing and reading on the storage media;
       use function <u>init/3</u>.

       An example of this is the SFTP support in <u>ssh_sftp:open_tar/3</u>. This function opens a tar file on a remote
       machine using an SFTP channel.

</pre><h4><b>LIMITATIONS</b></h4><pre>
         * If you must remain compatible with the USTAR tar format, you must ensure file paths being stored  are
           less  than  255  bytes  in total, with a maximum filename component length of 100 bytes. USTAR uses a
           header field (prefix) in addition to the name field, and splits file paths longer than 100 bytes into
           two parts. This split is done on a directory boundary, and is done in such a way to make the best use
           of the space available in those two fields, but in practice this will often mean that you  have  less
           than  255  bytes  for  a  path. <u>erl_tar</u> will automatically upgrade the format to PAX to handle longer
           filenames, so this is only an issue if you need to extract the archive with an  older  implementation
           of  <u>erl_tar</u>  or  <u>tar</u>  which  does not support PAX. In this case, the PAX headers will be extracted as
           regular files, and you will need to apply them manually.

         * Like the above,  if  you  must  remain  USTAR  compatible,  you  must  also  ensure  than  paths  for
           symbolic/hard links are no more than 100 bytes, otherwise PAX headers will be used.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>name_in_archive()</b> = string()

       <b>open_type()</b> =
           file:filename_all() |
           {binary, binary()} |
           {file, file:io_device()}

       <b>tar_descriptor()</b>

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>add(TarDescriptor,</b> <b>AddType,</b> <b>Options)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

       <b>add(TarDescriptor,</b> <b>Filename,</b> <b>NameInArchive,</b> <b>Options)</b> <b>-&gt;</b>
              ok | {error, term()}

              Types:

                 TarDescriptor = tar_descriptor()
                 Filename = file:filename_all()
                 NameInArchive = name_in_archive()
                 Options = [add_opt()]
                 <b>add_type()</b> =
                     name_in_archive() | {name_in_archive(), file:filename_all()}
                 <b>add_opt()</b> =
                     dereference | verbose |
                     {chunks, integer() &gt;= 1} |
                     {atime, integer() &gt;= 0} |
                     {mtime, integer() &gt;= 0} |
                     {ctime, integer() &gt;= 0} |
                     {uid, integer() &gt;= 0} |
                     {gid, integer() &gt;= 0}

              Adds a file to a tar file that has been opened for writing by <u>open/1</u>.

              <u>NameInArchive</u>  is the name under which the file becomes stored in the tar file. The file gets this
              name when it is extracted from the tar file.

              Options:

                <u>dereference</u>:
                  By default, symbolic links are stored as symbolic links in  the  tar  file.  To  override  the
                  default  and  store  the  file  that the symbolic link points to into the tar file, use option
                  <u>dereference</u>.

                <u>verbose</u>:
                  Prints an informational message about the added file.

                <u>{chunks,ChunkSize}</u>:
                  Reads data in parts from the file. This is intended  for  memory-limited  machines  that,  for
                  example, builds a tar file on a remote machine over SFTP, see <u>ssh_sftp:open_tar/3</u>.

                <u>{atime,non_neg_integer()}</u>:
                  Sets the last time, as  POSIX time, when the file was read. See also <u>file:read_file_info/1</u>.

                <u>{mtime,non_neg_integer()}</u>:
                  Sets the last time, as  POSIX time, when the file was written. See also <u>file:read_file_info/1</u>.

                <u>{ctime,non_neg_integer()}</u>:
                  Sets the time, as  POSIX time, when the file was created. See also <u>file:read_file_info/1</u>.

                <u>{uid,non_neg_integer()}</u>:
                  Sets the file owner. <u>file:read_file_info/1</u>.

                <u>{gid,non_neg_integer()}</u>:
                  Sets the group that the file owner belongs to. <u>file:read_file_info/1</u>.

       <b>close(TarDescriptor</b> <b>::</b> <b>tar_descriptor())</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Closes a tar file opened by <u>open/2</u>.

       <b>create(Name</b> <b>::</b> <b>file:filename_all(),</b> <b>FileList</b> <b>::</b> <b>filelist())</b> <b>-&gt;</b>
                 ok | {error, {string(), term()}}

              Types:

                 <b>filelist()</b> =
                     [file:filename() | {name_in_archive(), file:filename_all()}]

              Creates a tar file and archives the files whose names are specified in <u>FileList</u> into it. The files
              can either be read from disk or be specified as binaries.

       <b>create(Name</b> <b>::</b> <b>file:filename_all(),</b>
              FileList :: filelist(),
              Options :: [create_opt()]) -&gt;
                 ok | {error, term()} | {error, {string(), term()}}

              Types:

                 <b>filelist()</b> =
                     [file:filename() | {name_in_archive(), file:filename_all()}]
                 <b>create_opt()</b> = compressed | cooked | dereference | verbose

              Creates a tar file and archives the files whose names are specified in <u>FileList</u> into it. The files
              can either be read from disk or be specified as binaries.

              The options in <u>OptionList</u> modify the defaults as follows:

                <u>compressed</u>:
                  The entire tar file is compressed, as if it has been run through the <u>gzip</u> program. To abide to
                  the  convention  that  a  compressed  tar  file  is  to  end  in  "<u>.tar.gz</u>" or "<u>.tgz</u>", add the
                  appropriate extension.

                <u>cooked</u>:
                  By default, function <u>open/2</u> opens the tar file in <u>raw</u> mode, which is faster but does not allow
                  a remote (Erlang) file server to be used. Adding <u>cooked</u> to the mode list overrides the default
                  and opens the tar file without option <u>raw</u>.

                <u>dereference</u>:
                  By default, symbolic links are stored as symbolic links in  the  tar  file.  To  override  the
                  default  and  store  the  file  that the symbolic link points to into the tar file, use option
                  <u>dereference</u>.

                <u>verbose</u>:
                  Prints an informational message about each added file.

       <b>extract(Open</b> <b>::</b> <b>open_type())</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Extracts all files from a tar archive.

              If argument <u>Name</u> is specified as <u>{binary,Binary}</u>, the contents of the binary is assumed  to  be  a
              tar archive.

              If  argument  <u>Name</u>  is specified as <u>{file,Fd}</u>, <u>Fd</u> is assumed to be a file descriptor returned from
              function <u>file:open/2</u>.

              Otherwise, <u>Name</u> is to be a filename.

          <b>Note:</b>
              Leading slashes in tar member names will be removed before writing the  file.  That  is,  absolute
              paths  will  be  turned  into  relative  paths. There will be an info message written to the error
              logger when paths are changed in this way.

          <b>Warning:</b>
              The <u>compressed</u> and <u>cooked</u> flags are invalid when passing a file  descriptor  with  <u>{file,Fd}</u>.  The
              file is assumed to have been opened with the appropriate flags.

       <b>extract(Open</b> <b>::</b> <b>open_type(),</b> <b>Opts</b> <b>::</b> <b>[extract_opt()])</b> <b>-&gt;</b>
                  {ok, [{string(), binary()}]} | {error, term()} | ok

              Types:

                 <b>extract_opt()</b> =
                     {cwd, string()} |
                     {files, [name_in_archive()]} |
                     compressed | cooked | memory | keep_old_files | verbose

              Extracts files from a tar archive.

              If  argument  <u>Name</u>  is specified as <u>{binary,Binary}</u>, the contents of the binary is assumed to be a
              tar archive.

              If argument <u>Name</u> is specified as <u>{file,Fd}</u>, <u>Fd</u> is assumed to be a file  descriptor  returned  from
              function <u>file:open/2</u>.

              Otherwise, <u>Name</u> is to be a filename.

              The following options modify the defaults for the extraction as follows:

                <u>{cwd,Cwd}</u>:
                  Files  with relative filenames are by default extracted to the current working directory. With
                  this option, files are instead extracted into directory <u>Cwd</u>.

                <u>{files,FileList}</u>:
                  By default, all files are extracted from the tar file. With this option, only those files  are
                  extracted whose names are included in <u>FileList</u>.

                <u>compressed</u>:
                  With  this  option,  the  file  is  uncompressed  while  extracting.  If  the  tar file is not
                  compressed, this option is ignored.

                <u>cooked</u>:
                  By default, function <u>open/2</u> function opens the tar file in <u>raw</u> mode, which is faster but  does
                  not  allow  a remote (Erlang) file server to be used. Adding <u>cooked</u> to the mode list overrides
                  the default and opens the tar file without option <u>raw</u>.

                <u>memory</u>:
                  Instead of extracting to a directory, this option  gives  the  result  as  a  list  of  tuples
                  <u>{Filename,</u>  <u>Binary}</u>,  where <u>Binary</u> is a binary containing the extracted data of the file named
                  <u>Filename</u> in the tar file.

                <u>keep_old_files</u>:
                  By default, all existing files with the same name as files in the tar  file  are  overwritten.
                  With this option, existing files are not overwriten.

                <u>verbose</u>:
                  Prints an informational message for each extracted file.

          <b>Warning:</b>
              The  <u>compressed</u>  and  <u>cooked</u>  flags are invalid when passing a file descriptor with <u>{file,Fd}</u>. The
              file is assumed to have been opened with the appropriate flags.

       <b>format_error(Atom</b> <b>::</b> <b>term())</b> <b>-&gt;</b> <b>string()</b>

              Converts an error reason term to a human-readable error message string.

       <b>init(UserData</b> <b>::</b> <b>user_data(),</b>
            AccessMode :: write | read,
            Fun :: file_op()) -&gt;
               {ok, tar_descriptor()} | {error, badarg}

              Types:

                 <b>user_data()</b> = term()
                 <b>file_op()</b> =
                     fun((write | close | read2 | position,
                          {user_data(), iodata()} |
                          user_data() |
                          {user_data(), integer() &gt;= 0} |
                          {user_data(), integer() &gt;= 0}) -&gt;
                             ok | eof |
                             {ok, string() | binary()} |
                             {ok, integer() &gt;= 0} |
                             {error, term()})

              The <u>Fun</u> is the definition of what to do when the different storage operations functions are to  be
              called from the higher tar handling functions (such as <u>add/3</u>, <u>add/4</u>, and <u>close/1</u>).

              The <u>Fun</u> is called when the tar function wants to do a low-level operation, like writing a block to
              a  file.  The  <u>Fun</u> is called as <u>Fun(Op,</u> <u>{UserData,Parameters...})</u>, where <u>Op</u> is the operation name,
              <u>UserData</u> is the term passed as the first argument to <u>init/1</u> and <u>Parameters...</u> are the  data  added
              by the tar function to be passed down to the storage handling function.

              Parameter <u>UserData</u> is typically the result of opening a low-level structure like a file descriptor
              or an SFTP channel id. The different <u>Fun</u> clauses operate on that very term.

              The following are the fun clauses parameter lists:

                <u>(write,</u> <u>{UserData,DataToWrite})</u>:
                  Writes term <u>DataToWrite</u> using <u>UserData</u>.

                <u>(close,</u> <u>UserData)</u>:
                  Closes the access.

                <u>(read2,</u> <u>{UserData,Size})</u>:
                  Reads  using <u>UserData</u> but only <u>Size</u> bytes. Notice that there is only an arity-2 read function,
                  not an arity-1 function.

                <u>(position,{UserData,Position})</u>:
                  Sets the position of <u>UserData</u> as defined for files in <u>file:position/2</u>

              <u>Example:</u>

              The following is a complete <u>Fun</u> parameter for reading and writing on files using the <u>file</u> module:

              ExampleFun =
                 fun(write, {Fd,Data}) -&gt;  file:write(Fd, Data);
                    (position, {Fd,Pos}) -&gt; file:position(Fd, Pos);
                    (read2, {Fd,Size}) -&gt; file:read(Fd, Size);
                    (close, Fd) -&gt; file:close(Fd)
                 end

              Here <u>Fd</u> was specified to function <u>init/3</u> as:

              {ok,Fd} = file:open(Name, ...).
              {ok,TarDesc} = erl_tar:init(Fd, [write], ExampleFun),

              <u>TarDesc</u> is then used:

              erl_tar:add(TarDesc, SomeValueIwantToAdd, FileNameInTarFile),
              ...,
              erl_tar:close(TarDesc)

              When  the  <u>erl_tar</u>  core  wants  to,  for  example,  write  a  piece  of  <u>Data</u>,  it   would   call
              <u>ExampleFun(write,</u> <u>{UserData,Data})</u>.

          <b>Note:</b>
              This  example  with  the  <u>file</u> module operations is not necessary to use directly, as that is what
              function <u>open/2</u> in principle does.

          <b>Warning:</b>
              The <u>TarDescriptor</u> term is not a file descriptor. You are advised  not  to  rely  on  the  specific
              contents of this term, as it can change in future Erlang/OTP releases when more features are added
              to this module.

       <b>open(Open</b> <b>::</b> <b>open_type(),</b> <b>Mode</b> <b>::</b> <b>[write</b> <b>|</b> <b>compressed</b> <b>|</b> <b>cooked])</b> <b>-&gt;</b>
               {ok, tar_descriptor()} | {error, term()}

              Creates a tar file for writing (any existing file with the same name is truncated).

              By  convention, the name of a tar file is to end in "<u>.tar</u>". To abide to the convention, add "<u>.tar</u>"
              to the name.

              Except for the <u>write</u> atom, the following atoms can be added to <u>OpenModeList</u>:

                <u>compressed</u>:
                  The entire tar file is compressed, as if it has been run through the <u>gzip</u> program. To abide to
                  the convention that a compressed  tar  file  is  to  end  in  "<u>.tar.gz</u>"  or  "<u>.tgz</u>",  add  the
                  appropriate extension.

                <u>cooked</u>:
                  By  default,  the  tar file is opened in <u>raw</u> mode, which is faster but does not allow a remote
                  (Erlang) file server to be used. Adding <u>cooked</u> to the mode  list  overrides  the  default  and
                  opens the tar file without option <u>raw</u>.

              To  add  one file at the time into an opened tar file, use function <u>add/3,4</u>. When you are finished
              adding files, use function <u>close/1</u> to close the tar file.

          <b>Warning:</b>
              The <u>compressed</u> and <u>cooked</u> flags are invalid when passing a file  descriptor  with  <u>{file,Fd}</u>.  The
              file must already be opened with the appropriate flags.

          <b>Warning:</b>
              The  <u>TarDescriptor</u>  term  is  not  a  file descriptor. You are advised not to rely on the specific
              contents of this term, as it can change in future Erlang/OTP releases when more features are added
              to this module.

       <b>table(Open</b> <b>::</b> <b>open_type())</b> <b>-&gt;</b>
                {ok, [name_in_archive()]} | {error, term()}

       <b>table(Open</b> <b>::</b> <b>open_type(),</b>
             Opts :: [compressed | verbose | cooked]) -&gt;
                {ok, [name_in_archive() | tar_entry()]} | {error, term()}

              Types:

                 <b>tar_entry()</b> =
                     {Name :: name_in_archive(),
                      Type :: typeflag(),
                      Size :: integer() &gt;= 0,
                      MTime :: tar_time(),
                      Mode :: mode(),
                      Uid :: uid(),
                      Gid :: gid()}
                 <b>tar_time()</b> = integer() &gt;= 0
                 <b>typeflag()</b> =
                     regular | link | symlink | char | block | directory | fifo |
                     reserved | unknown
                 <b>mode()</b> = integer() &gt;= 0
                 <b>uid()</b> = integer() &gt;= 0
                 <b>gid()</b> = integer() &gt;= 0

              Retrieves the names of all files in the tar file <u>Name</u>.

       <b>t(Name</b> <b>::</b> <b>file:filename())</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Prints the names of all files in the tar file <u>Name</u> to the Erlang shell (similar to "<u>tar</u> <u>t</u>").

       <b>tt(Name</b> <b>::</b> <b>open_type())</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Prints names and information about all files in the tar file <u>Name</u> to the Erlang shell (similar  to
              "<u>tar</u> <u>tv</u>").

Ericsson AB                                        stdlib 3.17                                     <u><a href="../man3erl/erl_tar.3erl.html">erl_tar</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>