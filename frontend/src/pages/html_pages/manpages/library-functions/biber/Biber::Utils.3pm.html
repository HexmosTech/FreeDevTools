<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Biber::Utils - Various utility subs used in Biber</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/biber">biber_2.20-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Biber::Utils - Various utility subs used in Biber

</pre><h4><b>EXPORT</b></h4><pre>
       All functions are exported by default.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>glob_data_file</b>
         Expands a data file glob to a list of filenames

   <b>slurp_switchr</b>
         Use different read encoding/slurp interfaces for Windows due to its
         horrible legacy codepage system

   <b>slurp_switchw</b>
         Use different write encoding/slurp interfaces for Windows due to its
         horrible legacy codepage system

   <b>locate_data_file</b>
         Searches for a data file by

         The exact path if the filename is absolute
         In the input_directory, if defined
         In the output_directory, if defined
         Relative to the current directory
         In the same directory as the control file
         Using kpsewhich, if available

         Check existence of NFC/NFD file variants and return correct one.
         Account for windows file encodings

   <b>check_empty</b>
           Wrapper around empty check to deal with Win32 Unicode filenames

   <b>check_exists</b>
           Wrapper around exists check to deal with Win32 Unicode filenames

   <b>biber_warn</b>
           Wrapper around various warnings bits and pieces.
           Add warning to the list of .bbl warnings and the master list of warnings

   <b>biber_error</b>
           Wrapper around error logging
           Forces an exit.

   <b>makenamesid</b>
       Given a Biber::Names object, return an underscore normalised concatenation of all of the full name
       strings.

   <b>makenameid</b>
       Given a Biber::Name object, return an underscore normalised concatenation of the full name strings.

   <b>latex_recode_output</b>
         Tries to convert UTF-8 to TeX macros in passed string

   <b>strip_noinit</b>
         Removes elements which are not to be considered during initials generation
         in names

   <b>strip_nosort</b>
         Removes elements which are not to be used in sorting a name from a string

   <b>strip_nonamestring</b>
         Removes elements which are not to be used in certain name-related operations like:

         * fullhash generation
         * uniquename generation

        from a name

   <b>normalise_string_label</b>
       Remove some things from a string for label generation. Don't strip \p{Dash} as this is needed to process
       compound names or label generation.

   <b>normalise_string_sort</b>
       Removes LaTeX macros, and all punctuation, symbols, separators as well as leading and trailing whitespace
       for sorting strings.  Control chars don't need to be stripped as they are completely ignorable in DUCET

   <b>normalise_string_bblxml</b>
       Some string normalisation for bblxml output

   <b>normalise_string</b>
       Removes LaTeX macros, and all punctuation, symbols, separators and control characters, as well as leading
       and trailing whitespace for sorting strings.  Only decodes LaTeX character macros into Unicode if output
       is UTF-8

   <b>normalise_string_common</b>
         Common bit for normalisation

   <b>normalise_string_hash</b>
         Normalise strings used for hashes. We collapse LaTeX macros into a vestige
         so that hashes are unique between things like:

         Smith
         {\v S}mith

         we replace macros like this to preserve their vestiges:

         \v S -&gt; v:
         \" -&gt; 34:

   <b>normalise_string_underscore</b>
         Like normalise_string, but also substitutes ~ and whitespace with underscore.

   <b>escape_label</b>
         Escapes a few special character which might be used in labels

   <b>unescape_label</b>
         Unscapes a few special character which might be used in label but which need
         sorting without escapes

   <b>reduce_array</b>
       reduce_array(\@a, \@b) returns all elements in @a that are not in @b

   <b>remove_outer</b>
           Remove surrounding curly brackets:
               '{string}' -&gt; 'string'
           but not
               '{string} {string}' -&gt; 'string} {string'

           Return (boolean if stripped, string)

   <b>has_outer</b>
           Return (boolean if surrounded in braces

   <b>add_outer</b>
           Add surrounding curly brackets:
               'string' -&gt; '{string}'

   <b>ucinit</b>
           upper case of initial letters in a string

   <b>is_undef</b>
           Checks for undefness of arbitrary things, including
           composite method chain calls which don't reliably work
           with defined() (see perldoc for defined())
           This works because we are just testing the value passed
           to this sub. So, for example, this is randomly unreliable
           even if the resulting value of the arg to defined() is "undef":

           defined($thing-&gt;method($arg)-&gt;method)

           whereas:

           is_undef($thing-&gt;method($arg)-&gt;method)

           works since we only test the return value of all the methods
           with defined()

   <b>is_def</b>
           Checks for definedness in the same way as is_undef()

   <b>is_undef_or_null</b>
           Checks for undef or nullness (see is_undef() above)

   <b>is_def_and_notnull</b>
           Checks for def and unnullness (see is_undef() above)

   <b>is_def_and_null</b>
           Checks for def and nullness (see is_undef() above)

   <b>is_null</b>
           Checks for nullness

   <b>is_notnull</b>
           Checks for notnullness

   <b>is_notnull_scalar</b>
           Checks for notnullness of a scalar

   <b>is_notnull_array</b>
           Checks for notnullness of an array (passed by ref)

   <b>is_notnull_hash</b>
           Checks for notnullness of an hash (passed by ref)

   <b>is_notnull_object</b>
           Checks for notnullness of an object (passed by ref)

   <b>stringify_hash</b>
           Turns a hash into a string of keys and values

   <b>normalise_utf8</b>
         Normalise any UTF-8 encoding string immediately to exactly what we want
         We want the strict perl utf8 "UTF-8"

   <b>inits</b>
          We turn the initials into an array so we can be flexible with them later
          The tie here is used only so we know what to split on. We don't want to make
          any typesetting decisions in Biber, like what to use to join initials so on
          output to the .bbl, we only use BibLaTeX macros.

   <b>join_name</b>
         Replace all join typsetting elements in a name part (space, ties) with BibLaTeX macros
         so that typesetting decisions are made in BibLaTeX, not hard-coded in Biber

   <b>filter_entry_options</b>
           Process any per_entry option transformations which are necessary on output

   <b>imatch</b>
           Do an interpolating (neg)match using a match RE and a string passed in as variables
           Using /g on matches so that $1,$2 etc. can be populated from repeated matches of
           same capture group as well as different groups

   <b>ireplace</b>
           Do an interpolating match/replace using a match RE, replacement RE
           and string passed in as variables

   <b>validate_biber_xml</b>
         Validate a biber/biblatex XML metadata file against an RNG XML schema

   <b>map_boolean</b>
           Convert booleans between strings and numbers. Because standard XML "boolean"
           datatype considers "true" and "1" the same etc.

   <b>process_entry_options</b>
           Set per-entry options

   <b>merge_entry_options</b>
           Merge entry options, dealing with conflicts

   <b>expand_option_input</b>
           Expand options such as meta-options coming from biblatex

   <b>parse_date_range</b>
         Parse of ISO8601 date range

   <b>parse_date_unspecified</b>
         Parse of ISO8601-2:2016 4.3 unspecified format into date range
         Returns range plus specification of granularity of unspecified

   <b>parse_date_start</b>
         Convenience wrapper

   <b>parse_date_end</b>
         Convenience wrapper

   <b>parse_date</b>
         Parse of iso8601-2 dates

   <b>date_monthday</b>
         Force month/day to ISO8601-2:2016 format with leading zero

   <b>biber_decode_utf8</b>
           Perform NFD form conversion as well as UTF-8 conversion. Used to normalize
           bibtex input as the T::B interface doesn't allow a neat whole file slurping.

   <b>out</b>
         Output to target. Outputs NFC UTF-8 if output is UTF-8

   <b>process_comment</b>
         Fix up some problems with comments after being processed by btparse

   <b>locale2bcp47</b>
         Map babel/polyglossia language options to a sensible CLDR (bcp47) locale default
         Return input string if there is no mapping

   <b>bcp472locale</b>
         Map CLDR (bcp47) locale to a babel/polyglossia locale
         Return input string if there is no mapping

   <b>rangelen</b>
         Calculate the length of a range field
         Range fields are an array ref of two-element array refs [range_start, range_end]
         range_end can be be empty for open-ended range or undef
         Deals with Unicode and ASCII roman numerals via the magic of Unicode NFKD form

         m-n -&gt; [m, n]
         m   -&gt; [m, undef]
         m-  -&gt; [m, '']
         -n  -&gt; ['', n]
         -   -&gt; ['', undef]

   <b>match_indices</b>
         Return array ref of array refs of matches and start indices of matches
         for provided array of compiled regexps into string

   <b>parse_range</b>
         Parses a range of values into a two-value array ref.
         Ranges with no starting value default to "1"
         Ranges can be open-ended and it's up to surrounding code to interpret this
         Ranges can be single figures which is shorthand for 1-x

   <b>strip_annotation</b>
         Removes annotation marker from a field name

   <b>parse_range_alt</b>
         Parses a range of values into a two-value array ref.
         Either start or end can be undef and it's up to surrounding code to interpret this

   <b>maploopreplace</b>
         Replace loop markers with values.

   <b>get_transliterator</b>
         Get a ref to a transliterator for the given from/to
         We are abstracting this in this way because it is not clear what the future
         of the transliteration library is. We want to be able to switch.

   <b>call_transliterator</b>
         Run a transliterator on passed text. Hides call semantics of transliterator
         so we can switch engine in the future.

</pre><h4><b>AUTHOR</b></h4><pre>
       Philip Kime "&lt;philip at kime.org.uk&gt;"

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests on our Github tracker at
       &lt;https://github.com/plk/biber/issues&gt;.

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2012-2024 Philip Kime, all rights reserved.

       This module is free software.  You can redistribute it and/or modify it under the terms of the Artistic
       License 2.0.

       This program is distributed in the hope that it will be useful, but without any warranty; without even
       the implied warranty of merchantability or fitness for a particular purpose.

perl v5.38.2                                       2024-05-26                                  <u>Biber::<a href="../man3pm/Utils.3pm.html">Utils</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>