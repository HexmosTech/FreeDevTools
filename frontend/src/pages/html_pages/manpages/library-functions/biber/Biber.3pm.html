<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Biber - main module for biber, a bibtex replacement for users of biblatex</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/biber">biber_2.20-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Biber - main module for biber, a bibtex replacement for users of biblatex

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Biber;
           my $biber = Biber-&gt;new();
           $biber-&gt;parse_ctrlfile("example.bcf");
           $biber-&gt;prepare;

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
           Initialize the Biber object, optionally passing named options as arguments.

   <b>display_end</b>
          Output summary of warnings/errors/misc before exit

   <b>biber_tempdir</b>
           Returns a File::Temp directory object for use in various things

   <b>biber_tempdir_name</b>
           Returns the directory name of the File::Temp directory object

   <b>sections</b>
           my $sections= $biber-&gt;sections

           Returns a Biber::Sections object describing the bibliography sections

   <b>add_sections</b>
           Adds a Biber::Sections object. Used externally from, e.g. biber

   <b>datalists</b>
           my $datalists = $biber-&gt;datalists

           Returns a Biber::DataLists object describing the bibliography sorting lists

   <b>langtags</b>
           Returns a Biber::LangTags object containing a parser for BCP47 tags

   <b>set_output_obj</b>
           Sets the object used to output final results
           Must be a subclass of Biber::Output::base

   <b>get_preamble</b>
           Returns the current preamble as an array ref

   <b>get_output_obj</b>
           Returns the object used to output final results

   <b>set_current_section</b>
           Sets the current section number that we are working on to a section number

   <b>get_current_section</b>
           Gets the current section number that we are working on

   <b>tool_mode_setup</b>
         Fakes parts of the control file for tool mode

   <b>parse_ctrlfile</b>
           This method reads the control file
           generated by biblatex to work out the various biblatex options.
           See Constants.pm for defaults and example of the data structure being built here.

   <b>process_setup</b>
          Place to put misc pre-processing things needed later

   <b>process_setup_tool</b>
          Place to put misc pre-processing things needed later for tool mode

   <b>resolve_alias_refs</b>
         Resolve aliases in xref/crossref/xdata which take keys as values to their real keys

         We use set_datafield as we are overriding the alias in the datasource

   <b>process_citekey_aliases</b>
        Remove citekey aliases from citekeys as they don't point to real
        entries.

   <b>instantiate_dynamic</b>
           This instantiates any dynamic entries so that they are available
           for processing later on. This has to be done before most all other
           processing so that when we call $section-&gt;bibentry($key), as we
           do many times in the code, we don't die because there is a key but
           no Entry object.

   <b>resolve_xdata</b>
           Resolve xdata

   <b>cite_setmembers</b>
           Promotes set member to cited status

   <b>preprocess_sets</b>
           $biber-&gt;preprocess_sets

           This records the set information for use later

   <b>calculate_interentry</b>
           $biber-&gt;calculate_interentry

           Ensures that crossrefs/xrefs that are directly cited or cross-referenced
           at least mincrossrefs/minxrefs times are included in the bibliography.

   <b>process_interentry</b>
           $biber-&gt;process_interentry

           Ensures proper inheritance of data from cross-references.

   <b>validate_datamodel</b>
         Validate bib data according to a datamodel
         Note that we are validating the internal Biber::Entries
         after they have been created from the datasources so this is
         datasource neutral, as it should be. It is here to enforce
         adherence to what biblatex expects.

   <b>process_namedis</b>
           Generate name strings and disambiguation schema. Has to be in the context
           of a data list (reference context) because uniquenametemplate can be specified
           per-list/context

   <b>postprocess_sets</b>
         Adds required per-entry options etc. to sets

   <b>process_entries_static</b>
         Processing of entries which is not list-specific and which can therefore
         insert data directly into entries

   <b>process_entries_pre</b>
           Main processing operations, to generate metadata and entry information
           This method is automatically called by C&lt;prepare&gt;.
           Runs prior to uniqueness processing

   <b>process_entries_post</b>
           More processing operations, to generate things which require uniqueness
           information like namehash
           Runs after uniqueness processing

   <b>process_entries_final</b>
           Final processing operations which depend on all previous processing

   <b>process_uniqueprimaryauthor</b>
           Track seen primary author base names for generation of uniqueprimaryauthor

   <b>process_workuniqueness</b>
           Track seen work combination for generation of singletitle, uniquetitle, uniquebaretitle and
           uniquework

   <b>process_extradate</b>
           Track labelname/labeltitle+date parts combination for generation of extradate

   <b>process_extraname</b>
           Track labelname only for generation of extraname

   <b>process_extratitle</b>
           Track labelname/labeltitle combination for generation of extratitle

   <b>process_extratitleyear</b>
           Track labeltitle/labelyear combination for generation of extratitleyear

   <b>process_sets</b>
           Postprocess set entries

           Checks for common set errors and enforces "dataonly" options for set members.
           It's not necessary to set skipbib, skipbiblist in the OPTIONS field for
           the set members as these are automatically set by biblatex due to the \inset

   <b>process_nocite</b>
           Generate nocite information

   <b>process_labelname</b>
           Generate labelname information.

   <b>process_labeldate</b>
           Generate labeldate information, including times

   <b>process_labeltitle</b>
         Generate labeltitle

         Note that this is not conditionalised on the biblatex "labeltitle"
         as labeltitle should always be output since all standard styles need it.
         Only extratitle is conditionalised on the biblatex "labeltitle" option.

   <b>process_fullhash</b>
           Generate fullhash

   <b>process_namehash</b>
           Generate namehash

   <b>process_pername_hashes</b>
           Generate per_name_hashes

   <b>process_visible_names</b>
           Generate the visible name information.
           This is used in various places and it is useful to have it generated in one place.

   <b>process_labelalpha</b>
           Generate the labelalpha and also the variant for sorting

   <b>process_extraalpha</b>
           Generate the extraalpha information

   <b>process_presort</b>
           Put presort fields for an entry into the main Biber bltx state
           so that it is all available in the same place since this can be
           set per-type and globally too.

   <b>process_lists</b>
           Process a bibliography list

   <b>check_list_filter</b>
           Run an entry through a list filter. Returns a boolean.

   <b>generate_sortdataschema</b>
           Generate sort data schema for Sort::Key from sort spec like this:

         spec   =&gt; [
                     [undef, { presort =&gt; {} }],
                     [{ final =&gt; 1 }, { sortkey =&gt; {} }],
                     [
                       {'sort_direction'  =&gt; 'descending'},
                       { sortname =&gt; {} },
                       { author =&gt; {} },
                       { editor =&gt; {} },
                       { translator =&gt; {} },
                       { sorttitle =&gt; {} },
                       { title =&gt; {} },
                     ],
                     [undef, { sortyear =&gt; {} }, { year =&gt; {} }],
                     [undef, { sorttitle =&gt; {} }, { title =&gt; {} }],
                     [undef, { volume =&gt; {} }, { "0000" =&gt; {} }],
                   ],

   <b>generate_sortinfo</b>
           Generate information for sorting

   <b>uniqueness</b>
           Generate the uniqueness information needed when creating .bbl

   <b>create_uniquename_info</b>
           Gather the uniquename information as we look through the names

           What is happening in here is the following: We are registering the
           number of occurrences of each name, name+init and fullname within a
           specific context. For example, the context is "global" with uniquename
           &lt; mininit and "name list" for uniquename=mininit or minfull. The keys
           we store to count this are the most specific information for the
           context, so, for uniquename &lt; mininit, this is the full name and for
           uniquename=mininit or minfull, this is the complete list of full names.
           These keys have values in a hash which are ignored. They serve only to
           accumulate repeated occurrences with the context and we don't care
           about this and so the values are a useful sinkhole for such repetition.

           For example, if we find in the global context a base name "Smith" in two different entries
           under the same form "Alan Smith", the data structure will look like:

           {Smith}-&gt;{global}-&gt;{Alan Smith} = 2

           We don't care about the value as this means that there are 2 "Alan Smith"s in the global
           context which need disambiguating identically anyway. So, we just count the keys for the
           base name "Smith" in the global context to see how ambiguous the base name itself is. This
           would be "1" and so "Alan Smith" would get uniquename=false because it's unambiguous as just
           "Smith".

           The same goes for "minimal" list context disambiguation for uniquename=mininit or minfull.
           For example, if we had the base name "Smith" to disambiguate in two entries with labelname
           "John Smith and Alan Jones", the data structure would look like:

           {Smith}-&gt;{Smith+Jones}-&gt;{John Smith+Alan Jones} = 2

           Again, counting the keys of the context for the base name gives us "1" which means we
           have uniquename=false for "John Smith" in both entries because it's the same list. This also
           works for repeated names in the same list "John Smith and Bert Smith". Disambiguating
           "Smith" in this:

           {Smith}-&gt;{Smith+Smith}-&gt;{John Smith+Bert Smith} = 2

           So both "John Smith" and "Bert Smith" in this entry get
           uniquename=false (of course, as long as there are no other "X Smith and
           Y Smith" entries where X != "John" or Y != "Bert").

           The values from biblatex.sty:

           false   = 0
           init    = 1
           true    = 2
           full    = 2
           allinit = 3
           allfull = 4
           mininit = 5
           minfull = 6

   <b>generate_uniquename</b>
          Generate the per-name uniquename values using the information
          harvested by create_uniquename_info()

   <b>create_uniquelist_info</b>
           Gather the uniquelist information as we look through the names

   <b>generate_uniquelist</b>
          Generate the per-namelist uniquelist values using the information
          harvested by create_uniquelist_info()

   <b>generate_contextdata</b>
           Generate information for data which may changes per datalist

   <b>generate_singletitle</b>
           Generate the singletitle field, if requested. The information for generating
           this is gathered in process_workuniqueness()

   <b>generate_uniquetitle</b>
           Generate the uniquetitle field, if requested. The information for generating
           this is gathered in process_workuniqueness()

   <b>generate_uniquebaretitle</b>
           Generate the uniquebaretitle field, if requested. The information for generating
           this is gathered in process_workuniqueness()

   <b>generate_uniquework</b>
           Generate the uniquework field, if requested. The information for generating
           this is gathered in process_workuniqueness()

   <b>generate_uniquepa</b>
           Generate the uniqueprimaryauthor field, if requested. The information for generating
           this is gathered in create_uniquename_info()

   <b>sort_list</b>
           Sort a list using information in entries according to a certain sorting template.
           Use a flag to skip info messages on first pass

   <b>preprocess_options</b>
          Preprocessing for options. Used primarily to perform process-intensive
          operations which can be done once instead of inside dense loops later.

   <b>prepare</b>
           Do the main work.
           Process and sort all entries before writing the output.

   <b>prepare_tool</b>
           Do the main work for tool mode

   <b>fetch_data</b>
           Fetch citekey and dependents data from section datasources
           Expects to find datasource packages named:

           Biber::Input::&lt;type&gt;::&lt;datatype&gt;

           and one defined subroutine called:

           Biber::Input::&lt;type&gt;::&lt;datatype&gt;::extract_entries

           which takes args:

           1: Biber object
           2: Datasource name
           3: Reference to an array of cite keys to look for

           and returns an array of the cite keys it did not find in the datasource

   <b>get_dependents</b>
         Get dependents of the entries for a given list of citekeys. Is called recursively
         until there are no more dependents to look for.

   <b>remove_undef_dependent</b>
           Remove undefined dependent keys from an entry using a map of
           dependent keys to entries

   <b>_parse_sort</b>
          Convenience sub to parse a .bcf sorting section and return nice
          sorting object

   <b>_filedump</b> <b>and</b> <b>_stringdump</b>
           Dump the biber object with Data::Dump for debugging

</pre><h4><b>AUTHORS</b></h4><pre>
       Philip Kime "&lt;philip at kime.org.uk&gt;"

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests on our Github tracker at
       &lt;https://github.com/plk/biber/issues&gt;.

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2009-2012 François Charette and Philip Kime, all rights reserved.  Copyright 2012-2024 Philip
       Kime, all rights reserved.

       This module is free software.  You can redistribute it and/or modify it under the terms of the Artistic
       License 2.0.

       This program is distributed in the hope that it will be useful, but without any warranty; without even
       the implied warranty of merchantability or fitness for a particular purpose.

perl v5.38.2                                       2024-05-26                                         <u><a href="../man3pm/Biber.3pm.html">Biber</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>