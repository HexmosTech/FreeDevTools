<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mojolicious::Guides::Routing - Routing requests</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmojolicious-perl">libmojolicious-perl_9.39+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mojolicious::Guides::Routing - Routing requests

</pre><h4><b>OVERVIEW</b></h4><pre>
       This document contains a simple and fun introduction to the Mojolicious router and its underlying
       concepts.

</pre><h4><b>CONCEPTS</b></h4><pre>
       Essentials every Mojolicious developer should know.

   <b>Dispatcher</b>
       The foundation of every web framework is a tiny black box connecting incoming requests with code
       generating the appropriate response.

         GET /user/show/1 -&gt; $c-&gt;render(text =&gt; 'Daniel');

       This black box is usually called a dispatcher. There are many implementations using different strategies
       to establish these connections, but pretty much all are based around mapping the path part of the request
       URL to some kind of response generator.

         /user/show/2 -&gt; $c-&gt;render(text =&gt; 'Isabell');
         /user/show/3 -&gt; $c-&gt;render(text =&gt; 'Sara');
         /user/show/4 -&gt; $c-&gt;render(text =&gt; 'Stefan');
         /user/show/5 -&gt; $c-&gt;render(text =&gt; 'Fynn');

       While it is very well possible to make all these connections static, it is also rather inefficient.
       That's why regular expressions are commonly used to make the dispatch process more dynamic.

         qr!/user/show/(\d+)! -&gt; $c-&gt;render(text =&gt; $users{$1});

       Modern dispatchers have pretty much everything HTTP has to offer at their disposal and can use many more
       variables than just the request path, such as request method and headers like "Host", "User-Agent" and
       "Accept".

         GET /user/show/23 HTTP/1.1
         Host: mojolicious.org
         User-Agent: Mojolicious (Perl)
         Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

   <b>Routes</b>
       While regular expressions are quite powerful they also tend to be unpleasant to look at and are generally
       overkill for ordinary path matching.

         qr!/user/admin/(\d+)! -&gt; $c-&gt;render(text =&gt; $users{$1});

       This is where routes come into play, they have been designed from the ground up to represent paths with
       placeholders.

         /user/admin/:id -&gt; $c-&gt;render(text =&gt; $users{$id});

       The only difference between a static path and the route above is the ":id" placeholder. One or more
       placeholders can be anywhere in the route.

         /user/:role/:id

       A fundamental concept of the Mojolicious router is that extracted placeholder values are turned into a
       hash.

         /user/admin/23 -&gt; /user/:role/:id -&gt; {role =&gt; 'admin', id =&gt; 23}

       This hash is basically the center of every Mojolicious application, you will learn more about this later
       on.  Internally, routes get compiled to regular expressions, so you can get the best of both worlds with
       a little bit of experience.

         /user/admin/:id -&gt; qr/(?-xism:^\/user\/admin\/([^\<a href="file:/.">/.</a>]+))/

       A trailing slash in the path is always optional.

         /user/admin/23/ -&gt; /user/:role/:id -&gt; {role =&gt; 'admin', id =&gt; 23}

   <b>Reversibility</b>
       One more huge advantage routes have over regular expressions is that they are easily reversible,
       extracted placeholders can be turned back into a path at any time.

         /sebastian -&gt; /:name -&gt; {name =&gt; 'sebastian'}
         {name =&gt; 'sebastian'} -&gt; /:name -&gt; /sebastian

       Every placeholder has a name, even if it's just an empty string.

   <b>Standard</b> <b>placeholders</b>
       Standard placeholders are the simplest form of placeholders, they use a colon prefix and match all
       characters except "/" and ".", similar to the regular expression "([^<a href="file:/.">/.</a>]+)".

         /hello              -&gt; /:name/hello -&gt; undef
         /sebastian/23/hello -&gt; /:name/hello -&gt; undef
         /sebastian.23/hello -&gt; /:name/hello -&gt; undef
         /sebastian/hello    -&gt; /:name/hello -&gt; {name =&gt; 'sebastian'}
         /sebastian23/hello  -&gt; /:name/hello -&gt; {name =&gt; 'sebastian23'}
         /sebastian 23/hello -&gt; /:name/hello -&gt; {name =&gt; 'sebastian 23'}

       All placeholders can be surrounded by "&lt;" and "&gt;" to separate them from the surrounding text.

         /hello             -&gt; /&lt;:name&gt;hello -&gt; undef
         /sebastian/23hello -&gt; /&lt;:name&gt;hello -&gt; undef
         /sebastian.23hello -&gt; /&lt;:name&gt;hello -&gt; undef
         /sebastianhello    -&gt; /&lt;:name&gt;hello -&gt; {name =&gt; 'sebastian'}
         /sebastian23hello  -&gt; /&lt;:name&gt;hello -&gt; {name =&gt; 'sebastian23'}
         /sebastian 23hello -&gt; /&lt;:name&gt;hello -&gt; {name =&gt; 'sebastian 23'}

       The colon prefix is optional for standard placeholders that are surrounded by "&lt;" and "&gt;".

         /i♥mojolicious -&gt; /&lt;one&gt;♥&lt;two&gt; -&gt; {one =&gt; 'i', two =&gt; 'mojolicious'}

   <b>Relaxed</b> <b>placeholders</b>
       Relaxed placeholders are just like standard placeholders, but use a hash prefix and match all characters
       except "/", similar to the regular expression "([^/]+)".

         /hello              -&gt; /#name/hello -&gt; undef
         /sebastian/23/hello -&gt; /#name/hello -&gt; undef
         /sebastian.23/hello -&gt; /#name/hello -&gt; {name =&gt; 'sebastian.23'}
         /sebastian/hello    -&gt; /#name/hello -&gt; {name =&gt; 'sebastian'}
         /sebastian23/hello  -&gt; /#name/hello -&gt; {name =&gt; 'sebastian23'}
         /sebastian 23/hello -&gt; /#name/hello -&gt; {name =&gt; 'sebastian 23'}

       They can be especially useful for manually matching file names with extensions, rather than using format
       detection.

         /music/song.mp3 -&gt; /music/#filename -&gt; {filename =&gt; 'song.mp3'}

   <b>Wildcard</b> <b>placeholders</b>
       Wildcard placeholders are just like the two types of placeholders above, but use an asterisk prefix and
       match absolutely everything, including "/" and ".", similar to the regular expression "(.+)".

         /hello              -&gt; /*name/hello -&gt; undef
         /sebastian/23/hello -&gt; /*name/hello -&gt; {name =&gt; 'sebastian/23'}
         /sebastian.23/hello -&gt; /*name/hello -&gt; {name =&gt; 'sebastian.23'}
         /sebastian/hello    -&gt; /*name/hello -&gt; {name =&gt; 'sebastian'}
         /sebastian23/hello  -&gt; /*name/hello -&gt; {name =&gt; 'sebastian23'}
         /sebastian 23/hello -&gt; /*name/hello -&gt; {name =&gt; 'sebastian 23'}

       They can be useful for manually matching entire file paths.

         /music/rock/song.mp3 -&gt; /music/*filepath -&gt; {filepath =&gt; 'rock/song.mp3'}

</pre><h4><b>BASICS</b></h4><pre>
       Most commonly used features every Mojolicious developer should know about.

   <b>Minimal</b> <b>route</b>
       The attribute "routes" in Mojolicious contains a router you can use to generate route structures.

         # Application
         package MyApp;
         use Mojo::Base 'Mojolicious', -signatures;

         sub startup ($self) {
           # Router
           my $r = $self-&gt;routes;

           # Route
           $r-&gt;get('/welcome')-&gt;to(controller =&gt; 'foo', action =&gt; 'welcome');
         }

         1;

       The minimal route above will load and instantiate the class "MyApp::Controller::Foo" and call its
       "welcome" method.  Routes are usually configured in the "startup" method of the application class, but
       the router can be accessed from everywhere (even at runtime).

         # Controller
         package MyApp::Controller::Foo;
         use Mojo::Base 'Mojolicious::Controller', -signatures;

         # Action
         sub welcome ($self) {
           # Render response
           $self-&gt;render(text =&gt; 'Hello there.');
         }

         1;

       All routes match in the same order in which they were defined, and matching stops as soon as a suitable
       route has been found. So you can improve the routing performance by declaring your most frequently
       accessed routes first. A routing cache will also be used automatically to handle sudden traffic spikes
       more gracefully.

   <b>Routing</b> <b>destination</b>
       After you start a new route with methods like "get" in Mojolicious::Routes::Route, you can also give it a
       destination in the form of a hash using the chained method "to" in Mojolicious::Routes::Route.

         # /welcome -&gt; {controller =&gt; 'foo', action =&gt; 'welcome'}
         $r-&gt;get('/welcome')-&gt;to(controller =&gt; 'foo', action =&gt; 'welcome');

       Now if the route matches an incoming request it will use the content of this hash to try and find
       appropriate code to generate a response.

   <b>HTTP</b> <b>methods</b>
       There are already shortcuts for the most common HTTP request methods like "post" in
       Mojolicious::Routes::Route, and for more control "any" in Mojolicious::Routes::Route accepts an optional
       array reference with arbitrary request methods as first argument.

         # PUT /hello  -&gt; undef
         # GET /hello  -&gt; {controller =&gt; 'foo', action =&gt; 'hello'}
         $r-&gt;get('/hello')-&gt;to(controller =&gt; 'foo', action =&gt; 'hello');

         # PUT /hello -&gt; {controller =&gt; 'foo', action =&gt; 'hello'}
         $r-&gt;put('/hello')-&gt;to(controller =&gt; 'foo', action =&gt; 'hello');

         # POST /hello -&gt; {controller =&gt; 'foo', action =&gt; 'hello'}
         $r-&gt;post('/hello')-&gt;to(controller =&gt; 'foo', action =&gt; 'hello');

         # GET|POST /bye  -&gt; {controller =&gt; 'foo', action =&gt; 'bye'}
         $r-&gt;any(['GET', 'POST'] =&gt; '/bye')-&gt;to(controller =&gt; 'foo', action =&gt; 'bye');

         # * /whatever -&gt; {controller =&gt; 'foo', action =&gt; 'whatever'}
         $r-&gt;any('/whatever')-&gt;to(controller =&gt; 'foo', action =&gt; 'whatever');

       There is one small exception, "HEAD" requests are considered equal to "GET", but content will not be sent
       with the response even if it is present.

         # GET /test  -&gt; {controller =&gt; 'bar', action =&gt; 'test'}
         # HEAD /test -&gt; {controller =&gt; 'bar', action =&gt; 'test'}
         $r-&gt;get('/test')-&gt;to(controller =&gt; 'bar', action =&gt; 'test');

       You can also use the "_method" query parameter to override the request method. This can be very useful
       when submitting forms with browsers that only support "GET" and "POST".

         # PUT  /stuff             -&gt; {controller =&gt; 'baz', action =&gt; 'stuff'}
         # POST /stuff?_method=PUT -&gt; {controller =&gt; 'baz', action =&gt; 'stuff'}
         $r-&gt;put('/stuff')-&gt;to(controller =&gt; 'baz', action =&gt; 'stuff');

   <b>IRIs</b>
       IRIs are handled transparently, that means paths are guaranteed to be unescaped and decoded from bytes to
       characters.

         # GET /☃ (Unicode snowman) -&gt; {controller =&gt; 'foo', action =&gt; 'snowman'}
         $r-&gt;get('/☃')-&gt;to(controller =&gt; 'foo', action =&gt; 'snowman');

   <b>Stash</b>
       The generated hash of a matching route is actually the center of the whole Mojolicious request cycle. We
       call it the stash, and it persists until a response has been generated.

         # /bye -&gt; {controller =&gt; 'foo', action =&gt; 'bye', mymessage =&gt; 'Bye'}
         $r-&gt;get('/bye')-&gt;to(controller =&gt; 'foo', action =&gt; 'bye', mymessage =&gt; 'Bye');

       There are a few stash values with special meaning, such as "controller" and "action", but you can
       generally fill it with whatever data you need to generate a response. Once dispatched the whole stash
       content can be changed at any time.

         sub bye ($self) {

           # Get message from stash
           my $msg = $self-&gt;stash('mymessage');

           # Change message in stash
           $self-&gt;stash(mymessage =&gt; 'Welcome');
         }

       You can use "defaults" in Mojolicious to set default stash values that will be available everywhere in
       the application.

         $app-&gt;defaults(mymessage =&gt; 'Howdy');

       For a full list of reserved stash values see "stash" in Mojolicious::Controller.

   <b>Nested</b> <b>routes</b>
       It is also possible to build tree structures from routes to remove repetitive code. A route with children
       can't match on its own though, only the actual endpoints of these nested routes can.

         # /foo     -&gt; undef
         # /foo/bar -&gt; {controller =&gt; 'foo', action =&gt; 'bar'}
         my $foo = $r-&gt;any('/foo')-&gt;to(controller =&gt; 'foo');
         $foo-&gt;get('/bar')-&gt;to(action =&gt; 'bar');

       The stash is simply inherited from route to route and newer values override old ones.

         # /cats      -&gt; {controller =&gt; 'cats', action =&gt; 'index'}
         # /cats/nyan -&gt; {controller =&gt; 'cats', action =&gt; 'nyan'}
         # /cats/lol  -&gt; {controller =&gt; 'cats', action =&gt; 'default'}
         my $cats = $r-&gt;any('/cats')-&gt;to(controller =&gt; 'cats', action =&gt; 'default');
         $cats-&gt;get('/')-&gt;to(action =&gt; 'index');
         $cats-&gt;get('/nyan')-&gt;to(action =&gt; 'nyan');
         $cats-&gt;get('/lol');

       With a few common prefixes you can also greatly improve the routing performance of applications with many
       routes, because children are only tried if the prefix matched first.

   <b>Special</b> <b>stash</b> <b>values</b>
       When the dispatcher sees "controller" and "action" values in the stash it will always try to turn them
       into a class and method to dispatch to. The "controller" value gets converted from "snake_case" to
       "CamelCase" using "camelize" in Mojo::Util and appended to one or more namespaces, defaulting to a
       controller namespace based on the application class ("MyApp::Controller"), as well as the bare
       application class ("MyApp"), and these namespaces are searched in that order. The action value is not
       changed at all, so both values are case-sensitive.

         # Application
         package MyApp;
         use Mojo::Base 'Mojolicious', -signatures;

         sub startup ($self) {
           # /bye -&gt; MyApp::Controller::Foo-&gt;bye
           $self-&gt;routes-&gt;get('/bye')-&gt;to(controller =&gt; 'foo', action =&gt; 'bye');
         }

         1;

         # Controller
         package MyApp::Controller::Foo;
         use Mojo::Base 'Mojolicious::Controller', -signatures;

         # Action
         sub bye ($self) {
           # Render response
           $self-&gt;render(text =&gt; 'Good bye.');
         }

         1;

       Controller classes are perfect for organizing code in larger projects. There are more dispatch
       strategies, but because controllers are the most commonly used ones they also got a special shortcut in
       the form of "controller#action".

         # /bye -&gt; {controller =&gt; 'foo', action =&gt; 'bye', mymessage =&gt; 'Bye'}
         $r-&gt;get('/bye')-&gt;to('foo#bye', mymessage =&gt; 'Bye');

       During camelization "-" characters get replaced with "::", this allows multi-level "controller"
       hierarchies.

         # / -&gt; MyApp::Controller::Foo::Bar-&gt;hi
         $r-&gt;get('/')-&gt;to('foo-bar#hi');

       You can also just specify the "controller" in CamelCase form instead of snake_case.

         # / -&gt; MyApp::Controller::Foo::Bar-&gt;hi
         $r-&gt;get('/')-&gt;to('Foo::Bar#hi');

       For security reasons the dispatcher will always check if the "controller" is actually a subclass of
       Mojolicious::Controller or Mojo before dispatching to it.

   <b>Namespaces</b>
       You can use the "namespace" stash value to change the namespace of a whole route with all its children.

         # /bye -&gt; MyApp::MyController::Foo::Bar-&gt;bye
         $r-&gt;get('/bye')-&gt;to(namespace =&gt; 'MyApp::MyController', controller =&gt; 'Foo::Bar', action =&gt; 'bye');

       The "controller" is always converted from "snake_case" to "CamelCase" with "camelize" in Mojo::Util, and
       then appended to this "namespace".

         # /bye -&gt; MyApp::MyController::Foo::Bar-&gt;bye
         $r-&gt;get('/bye')-&gt;to('foo-bar#bye', namespace =&gt; 'MyApp::MyController');

         # /hey -&gt; MyApp::MyController::Foo::Bar-&gt;hey
         $r-&gt;get('/hey')-&gt;to('Foo::Bar#hey', namespace =&gt; 'MyApp::MyController');

       You can also change the default namespaces for all routes in the application with the router attribute
       "namespaces" in Mojolicious::Routes, which usually defaults to a namespace based on the application class
       ("MyApp::Controller"), as well as the bare application class ("MyApp").

         $r-&gt;namespaces(['MyApp::MyController']);

   <b>Route</b> <b>to</b> <b>callback</b>
       The "cb" stash value, which won't be inherited by nested routes, can be used to bypass controllers and
       execute a callback instead.

         $r-&gt;get('/bye')-&gt;to(cb =&gt; sub ($c) {
           $c-&gt;render(text =&gt; 'Good bye.');
         });

       But just like in Mojolicious::Lite you can also pass the callback directly, which usually looks much
       better.

         $r-&gt;get('/bye' =&gt; sub ($c) {
           $c-&gt;render(text =&gt; 'Good bye.');
         });

   <b>Named</b> <b>routes</b>
       Naming your routes will allow backreferencing in many methods and helpers throughout the whole framework,
       most of which internally rely on "url_for" in Mojolicious::Controller for this.

         # /foo/marcus -&gt; {controller =&gt; 'foo', action =&gt; 'bar', user =&gt; 'marcus'}
         $r-&gt;get('/foo/:user')-&gt;to('foo#bar')-&gt;name('baz');

         # Generate URL "/foo/marcus" for route "baz" (in previous request context)
         my $url = $c-&gt;url_for('baz');

         # Generate URL "/foo/jan" for route "baz"
         my $url = $c-&gt;url_for('baz', user =&gt; 'jan');

         # Generate URL "<a href="http://127.0.0.1">http://127.0.0.1</a>:3000/foo/jan" for route "baz"
         my $url = $c-&gt;url_for('baz', user =&gt; 'jan')-&gt;to_abs;

       You can assign a name with "name" in Mojolicious::Routes::Route, or let the router generate one
       automatically, which would be equal to the route itself without non-word characters, custom names have a
       higher precedence though.

         # /foo/bar ("foobar")
         $r-&gt;get('/foo/bar')-&gt;to('test#stuff');

         # Generate URL "/foo/bar"
         my $url = $c-&gt;url_for('foobar');

       To refer to the current route you can use the reserved name "current" or no name at all.

         # Generate URL for current route
         my $url = $c-&gt;url_for('current');
         my $url = $c-&gt;url_for;

       To check or get the name of the current route you can use the helper "current_route" in
       Mojolicious::Plugin::DefaultHelpers.

         # Name for current route
         my $name = $c-&gt;current_route;

         # Check route name in code shared by multiple routes
         $c-&gt;stash(button =&gt; 'green') if $c-&gt;current_route('login');

   <b>Optional</b> <b>placeholders</b>
       Extracted placeholder values will simply redefine older stash values if they already exist.

         # /bye -&gt; {controller =&gt; 'foo', action =&gt; 'bar', mymessage =&gt; 'bye'}
         # /hey -&gt; {controller =&gt; 'foo', action =&gt; 'bar', mymessage =&gt; 'hey'}
         $r-&gt;get('/:mymessage')-&gt;to('foo#bar', mymessage =&gt; 'hi');

       One more interesting effect, a placeholder automatically becomes optional if there is already a stash
       value of the same name present, this works similar to the regular expression "([^<a href="file:/.">/.</a>]+)?".

         # / -&gt; {controller =&gt; 'foo', action =&gt; 'bar', mymessage =&gt; 'hi'}
         $r-&gt;get('/:mymessage')-&gt;to('foo#bar', mymessage =&gt; 'hi');

         # /test/123     -&gt; {controller =&gt; 'foo', action =&gt; 'bar', mymessage =&gt; 'hi'}
         # /test/bye/123 -&gt; {controller =&gt; 'foo', action =&gt; 'bar', mymessage =&gt; 'bye'}
         $r-&gt;get('/test/:mymessage/123')-&gt;to('foo#bar', mymessage =&gt; 'hi');

       And if two optional placeholders are only separated by a slash, that slash can become optional as well.

   <b>Restrictive</b> <b>placeholders</b>
       A very easy way to make placeholders more restrictive are alternatives, you just make a list of possible
       values, which then work similar to the regular expression "(bender|leela)".

         # /fry    -&gt; undef
         # /bender -&gt; {controller =&gt; 'foo', action =&gt; 'bar', name =&gt; 'bender'}
         # /leela  -&gt; {controller =&gt; 'foo', action =&gt; 'bar', name =&gt; 'leela'}
         $r-&gt;get('/:name' =&gt; [name =&gt; ['bender', 'leela']])-&gt;to('foo#bar');

       You can also adjust the regular expressions behind placeholders directly, just make sure not to use "^"
       and "$" or capturing groups "(...)", because placeholders become part of a larger regular expression
       internally, non-capturing groups "(?:...)" are fine though.

         # /23   -&gt; {controller =&gt; 'foo', action =&gt; 'bar', number =&gt; 23}
         # /test -&gt; undef
         $r-&gt;get('/:number' =&gt; [number =&gt; qr/\d+/])-&gt;to('foo#bar');

         # /23   -&gt; undef
         # /test -&gt; {controller =&gt; 'foo', action =&gt; 'bar', name =&gt; 'test'}
         $r-&gt;get('/:name' =&gt; [name =&gt; qr/[a-zA-Z]+/])-&gt;to('foo#bar');

       This way you get easily readable routes and the raw power of regular expressions.

   <b>Placeholder</b> <b>types</b>
       And if you have multiple routes using restrictive placeholders you can also turn them into placeholder
       types with "add_type" in Mojolicious::Routes.

         # A type with alternatives
         $r-&gt;add_type(futurama_name =&gt; ['bender', 'leela']);

         # /fry    -&gt; undef
         # /bender -&gt; {controller =&gt; 'foo', action =&gt; 'bar', name =&gt; 'bender'}
         # /leela  -&gt; {controller =&gt; 'foo', action =&gt; 'bar', name =&gt; 'leela'}
         $r-&gt;get('/&lt;name:futurama_name&gt;')-&gt;to('foo#bar');

       Placeholder types work just like restrictive placeholders, they are just reusable with the
       "&lt;placeholder:type&gt;" notation.

         # A type adjusting the regular expression
         $r-&gt;add_type(upper =&gt; qr/[A-Z]+/);

         # /user/ROOT -&gt; {controller =&gt; 'users', action =&gt; 'show', name =&gt; 'ROOT'}
         # /user/root -&gt; undef
         # /user/23   -&gt; undef
         $r-&gt;get('/user/&lt;name:upper&gt;')-&gt;to('users#show');

       Some types like "num" are used so commonly that they are available by default.

         # /article/12   -&gt; {controller =&gt; 'article', action =&gt; 'show', id =&gt; 12}
         # /article/test -&gt; undef
         $r-&gt;get('/article/&lt;id:num&gt;')-&gt;to('articles#show');

       For a full list of available placeholder types see also "TYPES" in Mojolicious::Routes.

   <b>Introspection</b>
       The command Mojolicious::Command::routes can be used from the command line to list all available routes
       together with names and underlying regular expressions.

         $ ./myapp.pl routes -v
         /foo/:name  ....  POST  fooname  ^/foo/([^<a href="file:/.">/.</a>]+)/?(?:\.([^/]+))?$
         /bar        ..U.  *     bar      ^/bar
           +/baz     ...W  GET   baz      ^/baz/?(?:\.([^/]+))?$
         /yada       ....  *     yada     ^/yada/?(?:\.([^/]+))?$

   <b>Under</b>
       To share code with multiple nested routes you can use "under" in Mojolicious::Routes::Route, because
       unlike normal nested routes, the routes generated with it have their own intermediate destination and
       result in additional dispatch cycles when they match.

         # /foo     -&gt; undef
         # /foo/bar -&gt; {controller =&gt; 'foo', action =&gt; 'baz'}
         #             {controller =&gt; 'foo', action =&gt; 'bar'}
         my $foo = $r-&gt;under('/foo')-&gt;to('foo#baz');
         $foo-&gt;get('/bar')-&gt;to('#bar');

       The actual action code for this destination needs to return a true value or the dispatch chain will be
       broken, this can be a very powerful tool for authentication.

         # /blackjack -&gt; {cb =&gt; sub {...}}
         #               {controller =&gt; 'hideout', action =&gt; 'blackjack'}
         my $auth = $r-&gt;under('/' =&gt; sub ($c) {

           # Authenticated
           return 1 if $c-&gt;req-&gt;headers-&gt;header('X-Bender');

           # Not authenticated
           $c-&gt;render(text =&gt; "You're not Bender.", status =&gt; 401);
           return undef;
         });
         $auth-&gt;get('/blackjack')-&gt;to('hideout#blackjack');

       Broken dispatch chains can be continued by calling "continue" in Mojolicious::Controller, this allows for
       example, non-blocking operations to finish before reaching the next dispatch cycle.

         my $maybe = $r-&gt;under('/maybe' =&gt; sub ($c) {

           # Wait 3 seconds and then give visitors a 50% chance to continue
           Mojo::IOLoop-&gt;timer(3 =&gt; sub {

             # Loser
             return $c-&gt;render(text =&gt; 'No luck.') unless int rand 2;

             # Winner
             $c-&gt;continue;
           });

           return undef;
         });
         $maybe-&gt;get('/')-&gt;to('maybe#winner');

       Every destination is just a snapshot of the stash at the time the route matched, and only the "format"
       value is shared by all of them. For a little more power you can introspect the preceding and succeeding
       destinations with "match" in Mojolicious::Controller.

         # Action of the fourth dispatch cycle
         my $action = $c-&gt;match-&gt;stack-&gt;[3]{action};

   <b>Formats</b>
       File extensions like ".html" and ".txt" at the end of a route can be detected and stored in the stash
       value "format".  Use a restrictive placeholder to declare the possible values.

         # /foo.txt -&gt; undef
         # /foo.rss -&gt; {controller =&gt; 'foo', action =&gt; 'bar', format =&gt; 'rss'}
         # /foo.xml -&gt; {controller =&gt; 'foo', action =&gt; 'bar', format =&gt; 'xml'}
         $r-&gt;get('/foo' =&gt; [format =&gt; ['rss', 'xml']])-&gt;to('foo#bar');

       This for example, allows multiple templates in different formats to share the same action code. And just
       like with placeholders you can use a default value to make the format optional.

         # /foo      -&gt; {controller =&gt; 'foo', action =&gt; 'bar'}
         # /foo.html -&gt; {controller =&gt; 'foo', action =&gt; 'bar', format =&gt; 'html'}
         # /foo.txt  -&gt; {controller =&gt; 'foo', action =&gt; 'bar', format =&gt; 'txt'}
         $r-&gt;get('/foo' =&gt; [format =&gt; ['html', 'txt']])-&gt;to('foo#bar', format =&gt; undef);

       Formats can be inherited by nested routes.

         # /foo      -&gt; {controller =&gt; 'foo', action =&gt; 'one', format =&gt; undef}
         # /foo.html -&gt; {controller =&gt; 'foo', action =&gt; 'one', format =&gt; 'html'}
         # /foo.json -&gt; {controller =&gt; 'foo', action =&gt; 'one', format =&gt; 'json'}
         # /bar      -&gt; {controller =&gt; 'bar', action =&gt; 'two', format =&gt; undef}
         # /bar.html -&gt; {controller =&gt; 'bar', action =&gt; 'two', format =&gt; 'html'}
         # /bar.json -&gt; {controller =&gt; 'bar', action =&gt; 'two', format =&gt; 'json'}
         my $with_format = $r-&gt;any('/' =&gt; [format =&gt; ['html', 'json']])-&gt;to(format =&gt; undef);
         $with_format-&gt;get('/foo')-&gt;to('foo#one');
         $with_format-&gt;get('/bar')-&gt;to('bar#two');

       A "format" value can also be passed to "url_for" in Mojolicious::Controller.

         # /foo/23.txt -&gt; {controller =&gt; 'foo', action =&gt; 'bar', id =&gt; 23, format =&gt; 'txt'}
         $r-&gt;get('/foo/:id')-&gt;to('foo#bar')-&gt;name('baz');

         # Generate URL "/foo/24.txt" for route "baz"
         my $url = $c-&gt;url_for('baz', id =&gt; 24, format =&gt; 'txt');

   <b>WebSockets</b>
       With the method "websocket" in Mojolicious::Routes::Route you can restrict access to WebSocket
       handshakes, which are normal "GET" requests with some additional information.

         # /echo (WebSocket handshake)
         $r-&gt;websocket('/echo')-&gt;to('foo#echo');

         # Controller
         package MyApp::Controller::Foo;
         use Mojo::Base 'Mojolicious::Controller', -signatures;

         # Action
         sub echo ($self) {
           $self-&gt;on(message =&gt; sub ($self, $msg) {
             $self-&gt;send("echo: $msg");
           });
         }

         1;

       The connection gets established when you respond to the WebSocket handshake request with a 101 response
       status, which happens automatically if you subscribe to an event with "on" in Mojolicious::Controller or
       send a message with "send" in Mojolicious::Controller right away.

         GET /echo HTTP/1.1
         Host: mojolicious.org
         User-Agent: Mojolicious (Perl)
         Connection: Upgrade
         Upgrade: websocket
         Sec-WebSocket-Key: IDM3ODE4NDk2MjA1OTcxOQ==
         Sec-WebSocket-Version: 13

         HTTP/1.1 101 Switching Protocols
         Server: Mojolicious (Perl)
         Date: Tue, 03 Feb 2015 17:08:24 GMT
         Connection: Upgrade
         Upgrade: websocket
         Sec-WebSocket-Accept: SWsp5N2iNxPbHlcOTIw8ERvyVPY=

   <b>Catch-all</b> <b>route</b>
       Since routes match in the order in which they were defined, you can catch all requests that did not match
       in your last route with an optional wildcard placeholder.

         # * /*
         $r-&gt;any('/*whatever' =&gt; {whatever =&gt; ''} =&gt; sub ($c) {
           my $whatever = $c-&gt;param('whatever');
           $c-&gt;render(text =&gt; "/$whatever did not match.", status =&gt; 404);
         });

   <b>Conditions</b>
       Conditions such as "headers", "agent" and "host" from Mojolicious::Plugin::HeaderCondition can be applied
       to any route with the method "requires" in Mojolicious::Routes::Route, and allow even more powerful route
       constructs.

         # / (Origin: <a href="http://perl.org">http://perl.org</a>)
         $r-&gt;get('/')-&gt;requires(headers =&gt; {Origin =&gt; qr/perl\.org/})-&gt;to('foo#bar');

         # / (Firefox)
         $r-&gt;get('/')-&gt;requires(agent =&gt; qr/Firefox/)-&gt;to('browser-test#firefox');

         # / (Internet Explorer)
         $r-&gt;get('/')-&gt;requires(agent =&gt; qr/Internet Explorer/)-&gt;to('browser-test#ie');

         # <a href="http://docs.mojolicious.org/Mojolicious">http://docs.mojolicious.org/Mojolicious</a>
         $r-&gt;get('/')-&gt;requires(host =&gt; 'docs.mojolicious.org')-&gt;to('perldoc#index');

       Just be aware that conditions are too complex for the routing cache, which normally speeds up recurring
       requests, and can therefore reduce performance.

   <b>Hooks</b>
       Hooks operate outside the routing system and allow you to extend the framework itself by sharing code
       with all requests indiscriminately through "hook" in Mojolicious, which makes them a very powerful tool
       especially for plugins.

         # Application
         package MyApp;
         use Mojo::Base 'Mojolicious', -signatures;

         sub startup ($self) {

           # Check all requests for a "/test" prefix
           $self-&gt;hook(before_dispatch =&gt; sub ($c) {
             $c-&gt;render(text =&gt; 'This request did not reach the router.') if $c-&gt;req-&gt;url-&gt;path-&gt;contains('/test');
           });

           # These will not be reached if the hook above renders a response
           my $r = $self-&gt;routes;
           $r-&gt;get('/welcome')-&gt;to('foo#welcome');
           $r-&gt;post('/bye')-&gt;to('foo#bye');
         }

         1;

       Post-processing the response to add or remove headers is a very common use.

         # Make sure static files are cached
         $app-&gt;hook(after_static =&gt; sub ($c) {
           $c-&gt;res-&gt;headers-&gt;cache_control('max-age=3600, must-revalidate');
         });

         # Remove a default header
         $app-&gt;hook(after_dispatch =&gt; sub ($c) {
           $c-&gt;res-&gt;headers-&gt;remove('Server');
         });

       Same for pre-processing the request.

         # Choose template variant based on request headers
         $app-&gt;hook(before_dispatch =&gt; sub ($c) {
           return unless my $agent = $c-&gt;req-&gt;headers-&gt;user_agent;
           $c-&gt;stash(variant =&gt; 'ie') if $agent =~ /Internet Explorer/;
         });

       Or more advanced extensions to add monitoring to your application.

         # Forward exceptions to a web service
         $app-&gt;hook(after_dispatch =&gt; sub ($c) {
           return unless my $e = $c-&gt;stash('exception');
           $c-&gt;ua-&gt;post('https://example.com/bugs' =&gt; form =&gt; {exception =&gt; $e});
         });

       You can even extend much of the core functionality.

         # Make controller object available to actions as $_
         $app-&gt;hook(around_action =&gt; sub ($next, $c, $action, $last) {
           local $_ = $c;
           return $next-&gt;();
         });

         # Pass route name as argument to actions
         $app-&gt;hook(around_action =&gt; sub ($next, $c, $action, $last) {
           return $c-&gt;$action($c-&gt;current_route);
         });

       For a full list of available hooks see "HOOKS" in Mojolicious.

</pre><h4><b>ADVANCED</b></h4><pre>
       Less commonly used and more powerful features.

   <b>Shortcuts</b>
       To make route generation more expressive, you can also add your own shortcuts with "add_shortcut" in
       Mojolicious::Routes.

         # Simple "resource" shortcut
         $r-&gt;add_shortcut(resource =&gt; sub ($r, $name) {

           # Prefix for resource
           my $resource = $r-&gt;any("/$name")-&gt;to("$name#");

           # Render a list of resources
           $resource-&gt;get('/')-&gt;to('#index')-&gt;name($name);

           # Render a form to create a new resource (submitted to "store")
           $resource-&gt;get('/create')-&gt;to('#create')-&gt;name("create_$name");

           # Store newly created resource (submitted by "create")
           $resource-&gt;post-&gt;to('#store')-&gt;name("store_$name");

           # Render a specific resource
           $resource-&gt;get('/:id')-&gt;to('#show')-&gt;name("show_$name");

           # Render a form to edit a resource (submitted to "update")
           $resource-&gt;get('/:id/edit')-&gt;to('#edit')-&gt;name("edit_$name");

           # Store updated resource (submitted by "edit")
           $resource-&gt;put('/:id')-&gt;to('#update')-&gt;name("update_$name");

           # Remove a resource
           $resource-&gt;delete('/:id')-&gt;to('#remove')-&gt;name("remove_$name");

           return $resource;
         });

         # GET /users         -&gt; {controller =&gt; 'users', action =&gt; 'index'}
         # GET /users/create  -&gt; {controller =&gt; 'users', action =&gt; 'create'}
         # POST /users        -&gt; {controller =&gt; 'users', action =&gt; 'store'}
         # GET /users/23      -&gt; {controller =&gt; 'users', action =&gt; 'show', id =&gt; 23}
         # GET /users/23/edit -&gt; {controller =&gt; 'users', action =&gt; 'edit', id =&gt; 23}
         # PUT /users/23      -&gt; {controller =&gt; 'users', action =&gt; 'update', id =&gt; 23}
         # DELETE /users/23   -&gt; {controller =&gt; 'users', action =&gt; 'remove', id =&gt; 23}
         $r-&gt;resource('users');

   <b>Rearranging</b> <b>routes</b>
       From application startup until the first request has arrived, all routes can still be moved around or
       even removed with methods like "add_child" in Mojolicious::Routes::Route and "remove" in
       Mojolicious::Routes::Route.

         # GET /example/show -&gt; {controller =&gt; 'example', action =&gt; 'show'}
         my $show = $r-&gt;get('/show')-&gt;to('example#show');
         $r-&gt;any('/example')-&gt;add_child($show);

         # Nothing
         $r-&gt;get('/secrets/show')-&gt;to('secrets#show')-&gt;name('show_secrets');
         $r-&gt;find('show_secrets')-&gt;remove;

       Especially for rearranging routes created by plugins this can be very useful, to find routes by their
       name you can use "find" in Mojolicious::Routes::Route.

         # GET /example/test -&gt; {controller =&gt; 'example', action =&gt; 'test'}
         $r-&gt;get('/something/else')-&gt;to('something#else')-&gt;name('test');
         my $test = $r-&gt;find('test');
         $test-&gt;pattern-&gt;parse('/example/test');
         $test-&gt;pattern-&gt;defaults({controller =&gt; 'example', action =&gt; 'test'});

       Even the route pattern and destination can still be changed with "parse" in Mojolicious::Routes::Pattern
       and "defaults" in Mojolicious::Routes::Pattern.

   <b>Adding</b> <b>conditions</b>
       You can also add your own conditions with the method "add_condition" in Mojolicious::Routes. All
       conditions are basically router plugins that run every time a new request arrives, and which need to
       return a true value for the route to match.

         # A condition that randomly allows a route to match
         $r-&gt;add_condition(random =&gt; sub ($route, $c, $captures, $num) {

           # Loser
           return undef if int rand $num;

           # Winner
           return 1;
         });

         # /maybe (25% chance)
         $r-&gt;get('/maybe')-&gt;requires(random =&gt; 4)-&gt;to('foo#bar');

       Use whatever request information you need.

         # A condition to check query parameters (useful for mock web services)
         $r-&gt;add_condition(query =&gt; sub ($route, $c, $captures, $hash) {

           for my $key (keys %$hash) {
             my $param = $c-&gt;req-&gt;url-&gt;query-&gt;param($key);
             return undef unless defined $param &amp;&amp; $param eq $hash-&gt;{$key};
           }

           return 1;
         });

         # /hello?to=world&amp;test=1
         $r-&gt;get('/hello')-&gt;requires(query =&gt; {test =&gt; 1, to =&gt; 'world'})-&gt;to('foo#bar');

   <b>Condition</b> <b>plugins</b>
       You can also package your conditions as reusable plugins.

         # Plugin
         package Mojolicious::Plugin::WerewolfCondition;
         use Mojo::Base 'Mojolicious::Plugin', -signatures;

         use Astro::MoonPhase;

         sub register ($self, $app, $conf) {

           # Add "werewolf" condition
           $app-&gt;routes-&gt;add_condition(werewolf =&gt; sub ($route, $c, $captures, $days) {

             # Keep the werewolves out!
             return undef if abs(14 - (phase(time))[2]) &gt; ($days / 2);

             # It's ok, no werewolf
             return 1;
           });
         }

         1;

       Now just load the plugin and you are ready to use the condition in all your applications.

         # Application
         package MyApp;
         use Mojo::Base 'Mojolicious', -signatures;

         sub startup ($self) {

           # Plugin
           $self-&gt;plugin('WerewolfCondition');

           # /hideout (keep them out for 4 days after full moon)
           $self-&gt;routes-&gt;get('/hideout')-&gt;requires(werewolf =&gt; 4)-&gt;to(controller =&gt; 'foo', action =&gt; 'bar');
         }

         1;

   <b>Mount</b> <b>applications</b>
       The easiest way to embed one application into another is Mojolicious::Plugin::Mount, which allows you to
       mount whole self-contained applications under a domain and/or prefix.

         use Mojolicious::Lite -signatures;

         # Whole application mounted under "/prefix"
         plugin Mount =&gt; {'/prefix' =&gt; '/home/sri/myapp/script/myapp'};

         # Mount application with subdomain
         plugin Mount =&gt; {'test.example.com' =&gt; '/home/sri/myapp2.pl'};

         # Normal route
         get '/' =&gt; sub ($c) {
           $c-&gt;render(text =&gt; 'Hello World!');
         };

         app-&gt;start;

   <b>Embed</b> <b>applications</b>
       For a little more power you can also embed applications by using them instead of a controller. This
       allows for example, the use of the Mojolicious::Lite domain specific language in normal Mojolicious
       controllers.

         # Controller
         package MyApp::Controller::Bar;
         use Mojolicious::Lite -signatures;

         # /hello
         get '/hello' =&gt; sub ($c) {
           my $name = $c-&gt;param('name');
           $c-&gt;render(text =&gt; "Hello $name.");
         };

         1;

       With the attribute "partial" in Mojolicious::Routes::Route, you can allow the route to partially match
       and use only the remaining path in the embedded application, the base path will be passed along in the
       "path" stash value.

         # /foo/*
         $r-&gt;any('/foo')-&gt;<a href="../man1/partial.1.html">partial</a>(1)-&gt;to('bar#', name =&gt; 'Mojo');

       A minimal embeddable application is nothing more than a subclass of Mojolicious, containing a "handler"
       method accepting Mojolicious::Controller objects.

         package MyApp::Controller::Bar;
         use Mojo::Base 'Mojolicious', -signatures;

         sub handler ($self, $c) {
           $c-&gt;res-&gt;<a href="../man200/code.200.html">code</a>(200);
           my $name = $c-&gt;param('name');
           $c-&gt;res-&gt;body("Hello $name.");
         }

         1;

       The host application will only share very little information with the embedded application through the
       stash. So you cannot currently use route placeholders in routes leading to embedded applications, since
       that would cause problems with "url_for" in Mojolicious::Controller.

   <b>Application</b> <b>plugins</b>
       You can even package applications as self-contained reusable plugins.

         # Plugin
         package Mojolicious::Plugin::MyEmbeddedApp;
         use Mojo::Base 'Mojolicious::Plugin', -signatures;

         sub register ($self, $app, $conf) {

           # Automatically add route
           $app-&gt;routes-&gt;any('/foo')-&gt;<a href="../man1/partial.1.html">partial</a>(1)-&gt;to(app =&gt; EmbeddedApp::app());
         }

         package EmbeddedApp;
         use Mojolicious::Lite;

         get '/bar' =&gt; 'bar';

         1;
         __DATA__
         @@ bar.html.ep
         Hello World!

       The "app" stash value, which won't be inherited by nested routes, can be used for already instantiated
       applications.  Now just load the plugin and you're done.

         # Application
         package MyApp;
         use Mojo::Base 'Mojolicious', -signatures;

         sub startup ($self) {

           # Plugin
           $self-&gt;plugin('MyEmbeddedApp');
         }

         1;

</pre><h4><b>MORE</b></h4><pre>
       You can continue with Mojolicious::Guides now or take a look at the Mojolicious wiki
       &lt;https://github.com/mojolicious/mojo/wiki&gt;, which contains a lot more documentation and examples by many
       different authors.

</pre><h4><b>SUPPORT</b></h4><pre>
       If you have any questions the documentation might not yet answer, don't hesitate to ask in the Forum
       &lt;https://forum.mojolicious.org&gt;, or on IRC &lt;https://web.libera.chat/#mojo&gt;.

perl v5.40.0                                       2024-12-07                  <u>Mojolicious::Guides::<a href="../man3pm/Routing.3pm.html">Routing</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>