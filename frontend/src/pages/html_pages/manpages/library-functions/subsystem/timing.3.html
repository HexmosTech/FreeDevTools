<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>benchmp,  benchmp_getstate,  benchmp_interval,  start,  stop, get_n, set_n, gettime, settime, get_enough,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/lmbench">lmbench_3.0-a9+debian.1-9_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       benchmp,  benchmp_getstate,  benchmp_interval,  start,  stop, get_n, set_n, gettime, settime, get_enough,
       t_overhead, l_overhead - the lmbench timing subsystem

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b>

       <b>typedef</b> <b>u_long</b> <b>iter_t;</b>

       <b>typedef</b> <b>(*bench_f)(iter_t</b> <b>iterations,</b> <b>void*</b> <b>cookie);</b>

       <b>typedef</b> <b>(*support_f)(iter_t</b> <b>iterations,</b> <b>void*</b> <b>cookie);</b>

       <b>void</b> <b>benchmp(support_f</b> <b>initialize,</b> <b>bench_f</b> <b>benchmark,</b> <b>support_f</b> <b>cleanup,</b> <b>int</b> <b>enough,</b>  <b>int</b>  <b>parallel,</b>  <b>int</b>
       <b>warmup,</b> <b>int</b> <b>repetitions,</b> <b>void*</b> <b>cookie);</b>

       <b>void*</b> <b>benchmp_getstate();</b>

       <b>iter_t</b> <b>benchmp_interval(void*</b> <b>state);</b>

       <b>void</b> <b>start(struct</b> <b>timeval</b> <b>*begin);</b>

       <b>uint64</b>    <b>stop(struct</b> <b>timeval</b> <b>*begin,</b> <b>struct</b> <b>timeval</b> <b>*end);</b>

       <b>uint64</b>    <b>get_n();</b>

       <b>void</b> <b>set_n(uint64</b> <b>n);</b>

       <b>uint64</b>    <b>gettime();</b>

       <b>void</b> <b>settime(uint64</b> <b>u);</b>

       <b>uint64</b>    <b>get_enough(uint64</b> <b>enough);</b>

       <b>uint64</b>    <b>t_overhead();</b>

       <b>double</b>    <b>l_overhead();</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  single  most  important  element of a good benchmarking system is the quality and reliability of its
       measurement system.  <u>lmbench</u>'s timing subsystem  manages  the  experimental  timing  process  to  produce
       accurate  results  in  the  least  possible time.  <u>lmbench</u> includes methods for measuring and eliminating
       several factors that influence  the accuracy of timing measurements, such as the resolution of the system
       clock.

       <u>lmbench</u> gets accurate  results  by  considering  clock  resolution,  auto-sizing  the  duration  of  each
       benchmark, and conducting multiple experiments.

       <b>void</b> <b>benchmp(initialize,</b> <b>benchmark,</b> <b>cleanup,</b> <b>enough,</b> <b>parallel,</b> <b>warmup,</b> <b>repetitions,</b> <b>cookie)</b>
              measures  the  performance of <u>benchmark</u> repeatedly and reports the median result.  <u>benchmp</u> creates
              <u>parallel</u> sub-processes which run <u>benchmark</u> in  parallel.   This  allows  lmbench  to  measure  the
              system's  ability to scale as the number of client processes increases.  Each sub-process executes
              <u>initialize</u> before starting the benchmarking cycle.  It will call <u>benchmark</u> several times in  order
              to  collect  <u>repetitions</u> results.  After all the benchmark results have been collected, <u>cleanup</u> is
              called to cleanup any resources which may have been allocated by <u>initialize</u> or <u>benchmark</u> <u>.</u>  <u>cookie</u>
              is a void pointer to a hunk of memory that can be used to store any parameters or  state  that  is
              needed by the benchmark.

       <b>void</b> <b>benchmp_getstate()</b>
              returns  a  void pointer to the lmbench-internal state used during benchmarking.  The state is not
              to be used or accessed directly by clients, but rather would be passed into <u>benchmp_interval.</u>

       <b>iter_t</b> <b>benchmp_interval(void*</b> <b>state)</b>
              returns the number of times the benchmark should execute its benchmark  loop  during  this  timing
              interval.   This  is used only for weird benchmarks which cannot implement the benchmark body in a
              function which can return, such as the page fault handler.  Please see <u>lat_sig.c</u> for sample usage.

       <b>void</b> <b>start(struct</b> <b>timeval</b> <b>*begin)</b>
              starts a timing interval.  If <u>begin</u> is non-null, save the start time in <u>begin</u> <u>.</u>

       <b>uint64</b> <b>stop(struct</b> <b>timeval</b> <b>*begin,</b> <b>struct</b> <b>timeval</b> <b>*end)</b>
              stops a timing interval, returning the number of elapsed micro-seconds.

       <b>uint64</b> <b>get_n()</b>
              returns the number of times <u>loop_body</u> was executed during the timing interval.

       <b>void</b> <b>set_n(uint64</b> <b>n)</b>
              sets the number of times <u>loop_body</u> was executed during the timing interval.

       <b>uint64</b> <b>gettime()</b>
              returns the number of micro-seconds in the timing interval.

       <b>void</b> <b>settime(uint64</b> <b>u)</b>
              sets the number of micro-seconds in the timing interval.

       <b>uint64</b> <b>get_enough(uint64</b> <b>enough)</b>
              return the time in micro-seconds needed to accurately measure a timing interval.

       <b>uint64</b> <b>t_overhead()</b>
              return the time in micro-seconds needed to measure time.

       <b>double</b> <b>l_overhead()</b>
              return the time in micro-seconds needed to do a simple loop.

</pre><h4><b>VARIABLES</b></h4><pre>
       There are three environment variables that can be used to modify the <u>lmbench</u>  timing  subsystem:  ENOUGH,
       TIMING_O,  and LOOP_O.  The environment variables can be used to directly set the results of <b>get_enough</b> <b>,</b>
       <b>t_overhead</b> <b>,</b> and <b>l_overhead</b> <b>.</b>  When running a large number of benchmarks, or repeating the same benchmark
       many times, this can save time by eliminating the necessity of recalculating these values for each run.

</pre><h4><b>FUTURES</b></h4><pre>
       Development of <u>lmbench</u> is continuing.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man8/lmbench.8.html">lmbench</a>(8), <a href="../man3/lmbench.3.html">lmbench</a>(3), <a href="../man3/reporting.3.html">reporting</a>(3), <a href="../man3/results.3.html">results</a>(3).

</pre><h4><b>AUTHOR</b></h4><pre>
       Carl Staelin and Larry McVoy

       Comments, suggestions, and bug reports are always welcome.

(c)1998 Larry McVoy                                  $Date:$                                   <u>lmbench</u> <u><a href="../man3/timing.3.html">timing</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>