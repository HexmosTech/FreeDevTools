<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>seq_trace - Sequential tracing of information transfers.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       seq_trace - Sequential tracing of information transfers.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Sequential  tracing  makes  it  possible  to trace information flows between processes resulting from one
       initial transfer of information. Sequential tracing is independent of the  ordinary  tracing  in  Erlang,
       which  is controlled by the <u>erlang:trace/3</u> BIF. For more information about what sequential tracing is and
       how it can be used, see section Sequential Tracing.

       <u>seq_trace</u> provides functions that control all aspects of sequential  tracing.  There  are  functions  for
       activation, deactivation, inspection, and for collection of the trace output.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>token()</b> = {integer(), boolean(), term(), term(), term()}

              An opaque term (a tuple) representing a trace token.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>set_token(Token)</b> <b>-&gt;</b> <b>PreviousToken</b> <b>|</b> <b>ok</b>

              Types:

                 Token = PreviousToken = [] | token()

              Sets  the  trace  token for the calling process to <u>Token</u>. If <u>Token</u> <u>==</u> <u>[]</u> then tracing is disabled,
              otherwise <u>Token</u> should be an Erlang term returned from <u>get_token/0</u> or <u>set_token/1</u>. <u>set_token/1</u> can
              be used to temporarily exclude message passing from the trace by setting the trace token to  empty
              like this:

              OldToken = seq_trace:set_token([]), % set to empty and save
                                                  % old value
              % do something that should not be part of the trace
              io:format("Exclude the signalling caused by this~n"),
              seq_trace:set_token(OldToken), % activate the trace token again
              ...

              Returns the previous value of the trace token.

       <b>set_token(Component,</b> <b>Val)</b> <b>-&gt;</b> <b>OldVal</b>

              Types:

                 Component = component()
                 Val = OldVal = value()
                 <b>component()</b> = label | serial | flag()
                 <b>flag()</b> =
                     send | 'receive' | print | timestamp | monotonic_timestamp |
                     strict_monotonic_timestamp
                 <b>value()</b> =
                     (Label :: term()) |
                     {Previous :: integer() &gt;= 0, Current :: integer() &gt;= 0} |
                     (Bool :: boolean())

              Sets  the  individual  <u>Component</u>  of  the  trace  token  to <u>Val</u>. Returns the previous value of the
              component.

                <u>set_token(label,</u> <u>Label)</u>:
                  The <u>label</u> component is a term which identifies all events belonging  to  the  same  sequential
                  trace.  If  several  sequential traces can be active simultaneously, <u>label</u> is used to identify
                  the separate traces. Default is 0.

            <b>Warning:</b>
                Labels were restricted to small signed integers (28 bits) prior to OTP 21. The trace token  will
                be silenty dropped if it crosses over to a node that does not support the label.

                <u>set_token(serial,</u> <u>SerialValue)</u>:
                  <u>SerialValue</u>  <u>=</u>  <u>{Previous,</u>  <u>Current}</u>. The <u>serial</u> component contains counters which enables the
                  traced messages to be sorted, should never be set explicitly by the user as these counters are
                  updated automatically. Default is <u>{0,</u> <u>0}</u>.

                <u>set_token(send,</u> <u>Bool)</u>:
                  A trace token flag (<u>true</u> <u>|</u> <u>false</u>)  which  enables/disables  tracing  on  information  sending.
                  Default is <u>false</u>.

                <u>set_token('receive',</u> <u>Bool)</u>:
                  A  trace  token  flag  (<u>true</u> <u>|</u> <u>false</u>) which enables/disables tracing on information reception.
                  Default is <u>false</u>.

                <u>set_token(print,</u> <u>Bool)</u>:
                  A trace token flag (<u>true</u>  <u>|</u>  <u>false</u>)  which  enables/disables  tracing  on  explicit  calls  to
                  <u>seq_trace:print/1</u>. Default is <u>false</u>.

                <u>set_token(timestamp,</u> <u>Bool)</u>:
                  A  trace token flag (<u>true</u> <u>|</u> <u>false</u>) which enables/disables a timestamp to be generated for each
                  traced event. Default is <u>false</u>.

                <u>set_token(strict_monotonic_timestamp,</u> <u>Bool)</u>:
                  A trace token flag (<u>true</u> <u>|</u> <u>false</u>) which enables/disables a strict monotonic  timestamp  to  be
                  generated for each traced event. Default is <u>false</u>. Timestamps will consist of Erlang monotonic
                  time  and  a monotonically increasing integer. The time-stamp has the same format and value as
                  produced by <u>{erlang:monotonic_time(nanosecond),</u> <u>erlang:unique_integer([monotonic])}</u>.

                <u>set_token(monotonic_timestamp,</u> <u>Bool)</u>:
                  A trace token flag (<u>true</u> <u>|</u> <u>false</u>) which enables/disables a strict monotonic  timestamp  to  be
                  generated  for each traced event. Default is <u>false</u>. Timestamps will use Erlang monotonic time.
                  The time-stamp has the same format and value as produced by <u>erlang:monotonic_time(nanosecond)</u>.

              If multiple timestamp flags are passed, <u>timestamp</u> has precedence  over  <u>strict_monotonic_timestamp</u>
              which  in  turn has precedence over <u>monotonic_timestamp</u>. All timestamp flags are remembered, so if
              two are passed and the one with highest precedence later is disabled the  other  one  will  become
              active.

       <b>get_token()</b> <b>-&gt;</b> <b>[]</b> <b>|</b> <b>token()</b>

              Returns  the  value  of  the trace token for the calling process. If <u>[]</u> is returned, it means that
              tracing is not active. Any other value returned is the value of an active trace token.  The  value
              returned can be used as input to the <u>set_token/1</u> function.

       <b>get_token(Component)</b> <b>-&gt;</b> <b>{Component,</b> <b>Val}</b>

              Types:

                 Component = component()
                 Val = value()
                 <b>component()</b> = label | serial | flag()
                 <b>flag()</b> =
                     send | 'receive' | print | timestamp | monotonic_timestamp |
                     strict_monotonic_timestamp
                 <b>value()</b> =
                     (Label :: term()) |
                     {Previous :: integer() &gt;= 0, Current :: integer() &gt;= 0} |
                     (Bool :: boolean())

              Returns  the  value of the trace token component <u>Component</u>. See set_token/2 for possible values of
              <u>Component</u> and <u>Val</u>.

       <b>print(TraceInfo)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 TraceInfo = term()

              Puts the Erlang term <u>TraceInfo</u> into the sequential trace output if the calling  process  currently
              is executing within a sequential trace and the <u>print</u> flag of the trace token is set.

       <b>print(Label,</b> <b>TraceInfo)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Label = integer()
                 TraceInfo = term()

              Same  as  <u>print/1</u> with the additional condition that <u>TraceInfo</u> is output only if <u>Label</u> is equal to
              the label component of the trace token.

       <b>reset_trace()</b> <b>-&gt;</b> <b>true</b>

              Sets the trace token to empty for all processes on the local node. The process  internal  counters
              used  to create the serial of the trace token is set to 0. The trace token is set to empty for all
              messages in message queues. Together this will effectively stop all ongoing sequential tracing  in
              the local node.

       <b>set_system_tracer(Tracer)</b> <b>-&gt;</b> <b>OldTracer</b>

              Types:

                 Tracer = OldTracer = tracer()
                 <b>tracer()</b> =
                     (Pid :: pid()) |
                     port() |
                     (TracerModule :: {module(), term()}) |
                     false

              Sets  the  system tracer. The system tracer can be either a process, port or tracer module denoted
              by <u>Tracer</u>. Returns the previous value (which can be <u>false</u> if no system tracer is active).

              Failure: <u>{badarg,</u> <u>Info}}</u> if <u>Pid</u> is not an existing local pid.

       <b>get_system_tracer()</b> <b>-&gt;</b> <b>Tracer</b>

              Types:

                 Tracer = tracer()
                 <b>tracer()</b> =
                     (Pid :: pid()) |
                     port() |
                     (TracerModule :: {module(), term()}) |
                     false

              Returns the pid, port identifier or tracer module of the current system  tracer  or  <u>false</u>  if  no
              system tracer is activated.

</pre><h4><b>TRACE</b> <b>MESSAGES</b> <b>SENT</b> <b>TO</b> <b>THE</b> <b>SYSTEM</b> <b>TRACER</b></h4><pre>
       The  format of the messages is one of the following, depending on if flag <u>timestamp</u> of the trace token is
       set to <u>true</u> or <u>false</u>:

       {seq_trace, Label, SeqTraceInfo, TimeStamp}

       or

       {seq_trace, Label, SeqTraceInfo}

       Where:

       Label = int()
       TimeStamp = {Seconds, Milliseconds, Microseconds}
         Seconds = Milliseconds = Microseconds = int()

       <u>SeqTraceInfo</u> can have the following formats:

         <u>{send,</u> <u>Serial,</u> <u>From,</u> <u>To,</u> <u>Message}</u>:
           Used when a process <u>From</u> with its trace token flag <u>send</u> set to <u>true</u> has sent information. <u>To</u> may be a
           process identifier, a registered name on a node represented as <u>{NameAtom,</u> <u>NodeAtom}</u>, or a  node  name
           represented  as  an  atom.  <u>From</u>  may  be a process identifier or a node name represented as an atom.
           <u>Message</u> contains the information passed along in this information transfer. If the transfer  is  done
           via message passing, it is the actual message.

         <u>{'receive',</u> <u>Serial,</u> <u>From,</u> <u>To,</u> <u>Message}</u>:
           Used  when  a process <u>To</u> receives information with a trace token that has flag <u>'receive'</u> set to <u>true</u>.
           <u>To</u> may be a process identifier, or a node name  represented  as  an  atom.  <u>From</u>  may  be  a  process
           identifier  or  a  node name represented as an atom. <u>Message</u> contains the information passed along in
           this information transfer. If the transfer is done via message passing, it is the actual message.

         <u>{print,</u> <u>Serial,</u> <u>From,</u> <b>_</b><u>,</u> <u>Info}</u>:
           Used when a process <u>From</u> has called <u>seq_trace:print(Label,</u> <u>TraceInfo)</u> and has a trace token with flag
           <u>print</u> set to <u>true</u>, and <u>label</u> set to <u>Label</u>.

       <u>Serial</u> is a tuple <u>{PreviousSerial,</u> <u>ThisSerial}</u>, where:

         * Integer <u>PreviousSerial</u> denotes the serial counter  passed  in  the  last  received  information  that
           carried  a  trace token. If the process is the first in a new sequential trace, <u>PreviousSerial</u> is set
           to the value of the process internal "trace clock".

         * Integer <u>ThisSerial</u> is the serial counter that a process sets on outgoing messages. It is based on the
           process internal "trace clock", which is incremented by one before it is attached to the trace  token
           in the message.

</pre><h4><b>SEQUENTIAL</b> <b>TRACING</b></h4><pre>
       Sequential  tracing  is  a  way  to  trace a sequence of information transfers between different local or
       remote processes, where the sequence is initiated by a single transfer. The typical information  transfer
       is  an ordinary Erlang message passed between two processes, but information is transferred also in other
       ways. In short, it works as follows:

       Each process has a <u>trace</u> <u>token</u>, which can be empty or not empty. When not empty, the trace token  can  be
       seen  as  the tuple <u>{Label,</u> <u>Flags,</u> <u>Serial,</u> <u>From}</u>. The trace token is passed invisibly when information is
       passed between processes. In most cases the information is passed in ordinary messages between processes,
       but information is also passed between processes by other means. For example, by spawning a new  process.
       An  information  transfer  between  two  processes  is  represented  by  a send event and a receive event
       regardless of how it is passed.

       To start a sequential trace, the user must explicitly set the trace token in the process that  will  send
       the first information in a sequence.

       The  trace  token  of a process is set each time the process receives information. This is typically when
       the process matches a message in a receive statement,  according  to  the  trace  token  carried  by  the
       received message, empty or not.

       On  each Erlang node, a process can be set as the <u>system</u> <u>tracer</u>. This process will receive trace messages
       each time information with a trace token is sent or received (if the trace token flag <u>send</u>  or  <u>'receive'</u>
       is set). The system tracer can then print each trace event, write it to a file, or whatever suitable.

   <b>Note:</b>
       The  system tracer only receives those trace events that occur locally within the Erlang node. To get the
       whole picture of a sequential trace, involving processes on many Erlang nodes, the output from the system
       tracer on each involved node must be merged (offline).

       The following sections describe sequential tracing and its most fundamental concepts.

</pre><h4><b>DIFFERENT</b> <b>INFORMATION</b> <b>TRANSFERS</b></h4><pre>
       Information flows between processes in a lot of different ways. Not all  flows  of  information  will  be
       covered  by  sequential  tracing.  One  example  is information passed via ETS tables. Below is a list of
       information paths that are covered by sequential tracing:

         <b>Message</b> <b>Passing:</b>
           All ordinary messages passed between Erlang processes.

         <b>Exit</b> <b>signals:</b>
           An exit signal is represented as an <u>{'EXIT',</u> <u>Pid,</u> <u>Reason}</u> tuple.

         <b>Process</b> <b>Spawn:</b>
           A process spawn is represented as multiple information transfers. At least one spawn request and  one
           spawn  reply.  The actual amount of information transfers depends on what type of spawn it is and may
           also change in future implementations. Note that this is more or less an internal protocol  that  you
           are  peeking  at.  The spawn request will be represented as a tuple with the first element containing
           the atom <u>spawn_request</u>, but this is more or less all that you can depend on.

   <b>Note:</b>
       If you do ordinary <u>send</u> or <u>receive</u> trace on the system, you will only see ordinary message  passing,  not
       the other information transfers listed above.

   <b>Note:</b>
       When a send event and corresponding receive event do not both correspond to ordinary Erlang messages, the
       <u>Message</u>  part  of the trace messages may not be identical. This since all information not necessarily are
       available when generating the trace messages.

</pre><h4><b>TRACE</b> <b>TOKEN</b></h4><pre>
       Each process has a current trace token which is "invisibly" passed from the parent process on creation of
       the process.

       The current token of a process is set in one of the following two ways:

         * Explicitly by the process itself, through a call to <u>seq_trace:set_token/1,2</u>

         * When information is received. This is typically when a received message is matched out in  a  receive
           expression, but also when information is received in other ways.

       In  both cases, the current token is set. In particular, if the token of a received message is empty, the
       current token of the process is set to empty.

       A trace token contains a label and a set of flags.  Both  the  label  and  the  flags  are  set  in  both
       alternatives above.

</pre><h4><b>SERIAL</b></h4><pre>
       The  trace  token  contains a component called <u>serial</u>. It consists of two integers, <u>Previous</u> and <u>Current</u>.
       The purpose is to uniquely identify each traced event within a trace sequence, as well as  to  order  the
       messages chronologically and in the different branches, if any.

       The algorithm for updating <u>Serial</u> can be described as follows:

       Let  each  process  have two counters, <u>prev_cnt</u> and <u>curr_cnt</u>, both are set to <u>0</u> when a process is created
       outside of a trace sequence. The counters are updated at the following occasions:

         * <u>When</u> <u>the</u> <u>process</u> <u>is</u> <u>about</u> <u>to</u> <u>pass</u> <u>along</u> <u>information</u> <u>to</u> <u>another</u> <u>process</u> <u>and</u> <u>the</u>  <u>trace</u>  <u>token</u>  <u>is</u>  <u>not</u>
           <u>empty.</u>  This  typically  occurs  when sending a message, but also, for example, when spawning another
           process.

           Let the serial of the trace token be <u>tprev</u> and <u>tcurr</u>.

         curr_cnt := curr_cnt + 1
         tprev := prev_cnt
         tcurr := curr_cnt

           The trace token with <u>tprev</u> and <u>tcurr</u> is then passed along with the information passed  to  the  other
           process.

         * <u>When</u>  <u>the</u> <u>process</u> <u>calls</u> <u>seq_trace:print(Label,</u> <u>Info)</u>, <u>Label</u> <u>matches</u> <u>the</u> <u>label</u> <u>part</u> <u>of</u> <u>the</u> <u>trace</u> <u>token</u>
           <u>and</u> <u>the</u> <u>trace</u> <u>token</u> <u>print</u> <u>flag</u> <u>is</u> <u>true</u>.

           The algorithm is the same as for send above.

         * <u>When</u> <u>information</u> <u>is</u> <u>received</u> <u>that</u> <u>also</u> <u>contains</u> <u>a</u> <u>non-empty</u> <u>trace</u> <u>token.</u> <u>For</u> <u>example,</u> <u>when</u> <u>a</u>  <u>message</u>
           <u>is</u> <u>matched</u> <u>out</u> <u>in</u> <u>a</u> <u>receive</u> <u>expression,</u> <u>or</u> <u>when</u> <u>a</u> <u>new</u> <u>process</u> <u>is</u> <u>spawned.</u>

           The process trace token is set to the trace token from the message.

           Let the serial of the trace token be <u>tprev</u> and <u>tcurr</u>.

         if (curr_cnt &lt; tcurr )
            curr_cnt := tcurr
         prev_cnt := tcurr

       <u>curr_cnt</u> of a process is incremented each time the process is involved in a sequential trace. The counter
       can reach its limit (27 bits) if a process is very long-lived and is involved in much sequential tracing.
       If  the  counter  overflows,  the  serial for ordering of the trace events cannot be used. To prevent the
       counter from overflowing in the middle of a sequential trace,  function  <u>seq_trace:reset_trace/0</u>  can  be
       called  to  reset  <u>prev_cnt</u> and <u>curr_cnt</u> of all processes in the Erlang node. This function also sets all
       trace tokens in processes and their message queues to  empty,  and  thus  stops  all  ongoing  sequential
       tracing.

</pre><h4><b>PERFORMANCE</b> <b>CONSIDERATIONS</b></h4><pre>
       The  performance degradation for a system that is enabled for sequential tracing is negligible as long as
       no tracing is activated. When tracing is activated, there is an extra cost for each traced  message,  but
       all other messages are unaffected.

</pre><h4><b>PORTS</b></h4><pre>
       Sequential tracing is not performed across ports.

       If  the  user  for some reason wants to pass the trace token to a port, this must be done manually in the
       code of the port controlling process. The port  controlling  processes  have  to  check  the  appropriate
       sequential  trace  settings (as obtained from <u>seq_trace:get_token/1</u>) and include trace information in the
       message data sent to their respective ports.

       Similarly, for messages  received  from  a  port,  a  port  controller  has  to  retrieve  trace-specific
       information, and set appropriate sequential trace flags through calls to <u>seq_trace:set_token/2</u>.

</pre><h4><b>DISTRIBUTION</b></h4><pre>
       Sequential  tracing  between  nodes  is  performed  transparently.  This  applies  to  C-nodes built with
       <u>Erl_Interface</u> too. A C-node built with <u>Erl_Interface</u> only maintains one trace token, which means that the
       C-node appears as one process from the sequential tracing point of view.

</pre><h4><b>EXAMPLE</b> <b>OF</b> <b>USE</b></h4><pre>
       This example gives a rough idea of how the new primitives  can  be  used  and  what  kind  of  output  it
       produces.

       Assume that you have an initiating process with <u>Pid</u> <u>==</u> <u>&lt;0.30.0&gt;</u> like this:

       -module(seqex).
       -compile(export_all).

       loop(Port) -&gt;
           receive
               {Port,Message} -&gt;
                   seq_trace:set_token(label,17),
                   seq_trace:set_token('receive',true),
                   seq_trace:set_token(print,true),
                   seq_trace:print(17,"**** Trace Started ****"),
                   call_server ! {self(),the_message};
               {ack,Ack} -&gt;
                   ok
           end,
           loop(Port).

       And a registered process <u>call_server</u> with <u>Pid</u> <u>==</u> <u>&lt;0.31.0&gt;</u> like this:

       loop() -&gt;
           receive
               {PortController,Message} -&gt;
                   Ack = {received, Message},
                   seq_trace:print(17,"We are here now"),
                   PortController ! {ack,Ack}
           end,
           loop().

       A possible output from the system's <u>sequential_tracer</u> can be like this:

       17:&lt;0.30.0&gt; Info {0,1} WITH
       "**** Trace Started ****"
       17:&lt;0.31.0&gt; Received {0,2} FROM &lt;0.30.0&gt; WITH
       {&lt;0.30.0&gt;,the_message}
       17:&lt;0.31.0&gt; Info {2,3} WITH
       "We are here now"
       17:&lt;0.30.0&gt; Received {2,4} FROM &lt;0.31.0&gt; WITH
       {ack,{received,the_message}}

       The implementation of a system tracer process that produces this printout can look like this:

       tracer() -&gt;
           receive
               {seq_trace,Label,TraceInfo} -&gt;
                  print_trace(Label,TraceInfo,false);
               {seq_trace,Label,TraceInfo,Ts} -&gt;
                  print_trace(Label,TraceInfo,Ts);
               _Other -&gt; ignore
           end,
           tracer().

       print_trace(Label,TraceInfo,false) -&gt;
           io:format("~p:",[Label]),
           print_trace(TraceInfo);
       print_trace(Label,TraceInfo,Ts) -&gt;
           io:format("~p ~p:",[Label,Ts]),
           print_trace(TraceInfo).

       print_trace({print,Serial,From,_,Info}) -&gt;
           io:format("~p Info ~p WITH~n~p~n", [From,Serial,Info]);
       print_trace({'receive',Serial,From,To,Message}) -&gt;
           io:format("~p Received ~p FROM ~p WITH~n~p~n",
                     [To,Serial,From,Message]);
       print_trace({send,Serial,From,To,Message}) -&gt;
           io:format("~p Sent ~p TO ~p WITH~n~p~n",
                     [From,Serial,To,Message]).

       The code that creates a process that runs this tracer function and sets that process as the system tracer
       can look like this:

       start() -&gt;
           Pid = spawn(?MODULE,tracer,[]),
           seq_trace:set_system_tracer(Pid), % set Pid as the system tracer
           ok.

       With a function like <u>test/0</u>, the whole example can be started:

       test() -&gt;
           P = spawn(?MODULE, loop, [port]),
           register(call_server, spawn(?MODULE, loop, [])),
           start(),
           P ! {port,message}.

Ericsson AB                                        kernel 8.2                                    <u><a href="../man3erl/seq_trace.3erl.html">seq_trace</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>