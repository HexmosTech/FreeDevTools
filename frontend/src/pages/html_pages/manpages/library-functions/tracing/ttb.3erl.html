<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ttb - A base for building trace tools for distributed systems.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ttb - A base for building trace tools for distributed systems.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The Trace Tool Builder, <u>ttb</u>, is a base for building trace tools for distributed systems.

       When using <u>ttb</u>, do not use module <u>dbg</u> in application Runtime_Tools in parallel.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>start_trace(Nodes,</b> <b>Patterns,</b> <b>FlagSpec,</b> <b>Opts)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Result = see p/2
                 Nodes = see tracer/2
                 Patterns = [tuple()]
                 FlagSpec = {Procs, Flags}
                 Proc = see p/2
                 Flags = see p/2
                 Opts = see tracer/2

              This  function is a shortcut allowing to start a trace with one command. Each tuple in <u>Patterns</u> is
              converted to a list, which in turn is passed to <u>ttb:tpl/2,3,4</u>.

              The call:

              &gt; ttb:start_trace([Node, OtherNode], [{mod, foo, []}, {mod, bar, 2}], {all, call}, [{file, File}, {handler,{fun myhandler/4, S}}]).

              is equivalent to:

              &gt; ttb:start_trace([Node, OtherNode], [{file, File}, {handler,{fun myhandler/4, S}}]), ttb:tpl(mod, foo, []), ttb:tpl(mod, bar, 2, []), ttb:p(all, call).

       <b>tracer()</b> <b>-&gt;</b> <b>Result</b>

              Equivalent to <u>tracer(node())</u>.

       <b>tracer(Shortcut)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Shortcut = shell | dbg

              Handy shortcuts for common tracing settings.

              <u>shell</u> is equivalent to <u>tracer(node(),[{file,</u> <u>{local,</u> <u>"ttb"}},</u> <u>shell])</u>.

              <u>dbg</u> is equivalent to <u>tracer(node(),[{shell,</u> <u>only}])</u>.

       <b>tracer(Nodes)</b> <b>-&gt;</b> <b>Result</b>

              Equivalent to <u>tracer(Nodes,[])</u>.

       <b>tracer(Nodes,Opts)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Result = {ok, ActivatedNodes} | {error,Reason}
                 Nodes = atom() | [atom()] | all | existing | new
                 Opts = Opt | [Opt]
                 Opt = {file,Client} | {handler, FormatHandler} | {process_info,PI} | shell | {shell, ShellSpec}
                 | {timer, TimerSpec} | {overload_check, {MSec, Module, Function}} | {flush, MSec}  |  resume  |
                 {resume, FetchTimeout} | {queue_size, QueueSize}
                 TimerSpec = MSec | {MSec, StopOpts}
                 MSec = FetchTimeout = integer()
                 Module = Function = atom()
                 StopOpts = see stop/2
                 Client = File | {local, File}
                 File = Filename | Wrap
                 Filename = string()
                 Wrap = {wrap,Filename} | {wrap,Filename,Size,Count}
                 FormatHandler = See format/2
                 PI = true | false
                 ShellSpec = true | false | only
                 QueueSize = non_neg_integer()

              Starts  a  file  trace  port  on  all  specified nodes and points the system tracer for sequential
              tracing to the same port.

              <u>Options:</u>

                <u>Filename</u>:
                  The specified <u>Filename</u> is prefixed with the node name. Default <u>Filename</u> is <u>ttb</u>.

                <u>File={wrap,Filename,Size,Count}</u>:
                  Can be used if the size of the trace logs must be limited. Default  values  are  <u>Size=128*1024</u>
                  and <u>Count=8</u>.

                <u>Client</u>:
                  When  tracing  diskless  nodes, <u>ttb</u> must be started from an external "trace control node" with
                  disk access, and <u>Client</u> must be <u>{local,</u> <u>File}</u>. All trace information is then sent to the trace
                  control node where it is written to file.

                <u>queue_size</u>:
                  When tracing to shell or <u>{local,File}</u>, an ip trace driver is used  internally.  The  ip  trace
                  driver has a queue of maximum <u>QueueSize</u> messages waiting to be delivered. If the driver cannot
                  deliver  messages  as fast as they are produced, the queue size might be exceeded and messages
                  are dropped. This parameter is optional, and is only useful if many  <u>{drop,N}</u>  trace  messages
                  are received by the trace handler. It has no meaning if shell or <u>{local,File}</u> is not used. See
                  dbg:trace_port/2 for more information about the ip trace driver.

                <u>process_info</u>:
                  Indicates  if  process  information  is to be collected. If <u>PI</u> <u>=</u> <u>true</u> (which is default), each
                  process identifier <u>Pid</u> is replaced by a tuple <u>{Pid,ProcessInfo,Node}</u>, where <u>ProcessInfo</u> is the
                  registered process name, its globally registered name, or its initial function.  To  turn  off
                  this functionality, set <u>PI</u> <u>=</u> <u>false</u>.

                <u>{shell,</u> <u>ShellSpec}</u>:
                  Indicates  that  trace  messages  are to be printed on the console as they are received by the
                  tracing process. This implies trace client <u>{local,</u> <u>File}</u>. If <u>ShellSpec</u>  is  <u>only</u>  (instead  of
                  <u>true</u>), no trace logs are stored.

                <u>shell</u>:
                  Shortcut for <u>{shell,</u> <u>true}</u>.

                <u>timer</u>:
                  Indicates  that the trace is to be automatically stopped after <u>MSec</u> milliseconds. <u>StopOpts</u> are
                  passed to command <u>ttb:stop/2</u>  if  specified  (default  is  <u>[]</u>).  Notice  that  the  timing  is
                  approximate,  as  delays related to network communication are always present. The timer starts
                  after <u>ttb:p/2</u> is issued, so you can set up your trace patterns before.

                <u>overload_check</u>:
                  Allows to enable overload  checking  on  the  nodes  under  trace.  <u>Module:Function(check)</u>  is
                  performed  each  <u>MSec</u>  millisecond.  If  the  check returns <u>true</u>, the tracing is disabled on a
                  specified node.

                  <u>Module:Function</u> must be able to handle at least three atoms: <u>init</u>, <u>check</u>, and <u>stop</u>.  <u>init</u>  and
                  <u>stop</u> allows you to initialize and clean up the check environment.

                  When  a  node  gets  overloaded,  it  is not possible to issue <u>ttb:p/2</u> or any command from the
                  <u>ttb:tp/2,3,4</u> family,  as  it  would  lead  to  inconsistent  tracing  state  (different  trace
                  specifications on different nodes).

                <u>flush</u>:
                  Periodically  flushes  all file trace port clients (see <u>dbg:flush_trace_port/1</u>). When enabled,
                  the buffers are freed each <u>MSec</u> millisecond. This option is not allowed  with  <u>{file,</u>  <u>{local,</u>
                  <u>File}}</u> tracing.

                <u>{resume,</u> <u>FetchTimeout}</u>:
                  Enables the autoresume feature. When enabled, remote nodes try to reconnect to the controlling
                  node  if  they are restarted. The feature requires application Runtime_Tools to be started (so
                  it has to be present in the <u>.boot</u> scripts if the traced nodes run with  embedded  Erlang).  If
                  this  is  not  possible,  resume  can be performed manually by starting <u>Runtime_Tools</u> remotely
                  using <u>rpc:call/4</u>.

                  <u>ttb</u> tries to fetch all logs from a reconnecting node before  reinitializing  the  trace.  This
                  must finish within <u>FetchTimeout</u> milliseconds or is aborted.

                  By default, autostart information is stored in a file named <u>ttb_autostart.bin</u> on each node. If
                  this  is  not  desired  (for  example,  on diskless nodes), a custom module handling autostart
                  information  storage  and  retrieval  can  be  provided  by  specifying  environment  variable
                  <u>ttb_autostart_module</u>  for  the  application  Runtime_Tools.  The  module  must  respond to the
                  following API:

                  <u>write_config(Data)</u> <u>-&gt;</u> <u>ok</u>:
                    Stores the provided data for further retrieval. It is important to  realize  that  the  data
                    storage used must not be affected by the node crash.

                  <u>read_config()</u> <u>-&gt;</u> <u>{ok,</u> <u>Data}</u> <u>|</u> <u>{error,</u> <u>Error}</u>:
                    Retrieves configuration stored with <u>write_config(Data)</u>.

                  <u>delete_config()</u> <u>-&gt;</u> <u>ok</u>:
                    Deletes  configuration  stored  with  <u>write_config(Data)</u>.  Notice  that  after this call any
                    subsequent calls to <u>read_config</u> must return <u>{error,</u> <u>Error}</u>.

                  <u>resume</u> implies the default <u>FetchTimeout</u>, which is 10 seconds

       <b>p(Item,Flags)</b> <b>-&gt;</b> <b>Return</b>

              Types:

                 Return = {ok,[{Item,MatchDesc}]}
                 Items = Item | [Item]
                 Item = pid() | port() | RegName | {global,GlobalRegName} | all | processes | ports | existing |
                 existing_processes | existing_ports | new | new_processes | new_ports
                 RegName = atom()
                 GlobalRegName = term()
                 Flags = Flag | [Flag]

              Sets the specified trace flags on the specified processes  or  ports.  Flag  <u>timestamp</u>  is  always
              turned on.

              See  the  Reference Manual for module <u>dbg</u> for the possible trace flags. Parameter <u>MatchDesc</u> is the
              same as returned from <u>dbg:p/2</u>.

              Processes can be specified as registered names, globally registered names, or process identifiers.
              Ports can be specified as registered names or port identifiers. If a registered name is specified,
              the flags are set on processes/ports with this name on all active nodes.

              Issuing this command starts the timer for this trace if option <u>timer</u> is specified with <u>tracer/2</u>.

       <b>tp(Module</b> <b>[,</b> <b>Function</b> <b>[,</b> <b>Arity]],</b> <b>MatchSpec)</b>
       <b>tp({Module,</b> <b>Function</b> <b>,</b> <b>Arity},</b> <b>MatchSpec)</b>
       <b>tpl(Module</b> <b>[,</b> <b>Function</b> <b>[,</b> <b>Arity]],</b> <b>MatchSpec)</b>
       <b>tpl({Module,</b> <b>Function</b> <b>,</b> <b>Arity},</b> <b>MatchSpec)</b>
       <b>ctp()</b>
       <b>ctp(Module</b> <b>[,</b> <b>Function</b> <b>[,</b> <b>Arity]])</b>
       <b>ctp({Module,</b> <b>Function,</b> <b>Arity})</b>
       <b>ctpl()</b>
       <b>ctpl(Module</b> <b>[,</b> <b>Function</b> <b>[,</b> <b>Arity]])</b>
       <b>ctpl({Module,</b> <b>Function,</b> <b>Arity})</b>
       <b>ctpg()</b>
       <b>ctpg(Module</b> <b>[,</b> <b>Function</b> <b>[,</b> <b>Arity]])</b>
       <b>ctpg({Module,</b> <b>Function,</b> <b>Arity})</b>
       <b>tpe(Event,MatchSpec)</b>
       <b>ctpe(Event)</b>

              These functions are to be used with trace flag <u>call</u>, <u>send</u>, and <u>'receive'</u> for setting and  clearing
              trace patterns.

              When  trace  flag  <u>call</u>  is set on a process, function calls are traced on that process if a trace
              pattern is set for the called function.

              The <u>send</u> and <u>'receive'</u> flags enable tracing of all messages sent and received by the process/port.
              Trace patterns set with <u>tpe</u> may limit traced messages based on the message  content,  the  sender,
              and/or the receiver.

              Trace  patterns  specify how to trace a function or a message by using match specifications. Match
              specifications are described in the <u>ERTS</u> <u>User's</u> <u>Guide</u>.

              These functions are equivalent to the corresponding functions in module dbg,  but  all  calls  are
              stored  in  the  history. The history buffer makes it easy to create configuration files; the same
              trace environment can be set up many times, for example, to compare two test runs. It also reduces
              the amount of typing when using <u>ttb</u> from the Erlang shell.

                <u>tp</u>:
                  Sets trace patterns on global function calls.

                <u>tpl</u>:
                  Sets trace patterns on local and global function calls.

                <u>tpe</u>:
                  Sets trace patterns on messages.

                <u>ctp</u>:
                  Clears trace patterns on local and global function calls.

                <u>ctpl</u>:
                  Clears trace patterns on local function calls.

                <u>ctpg</u>:
                  Clears trace patterns on global function calls.

                <u>ctpe</u>:
                  Clears trace patterns on messages.

              With  <u>tp</u>  and  <u>tpl</u>,  one  of  the  match  specification  shortcuts  can  be  used  (for   example,
              <u>ttb:tp(foo_module,</u> <u>caller)</u>).

              The shortcuts are as follows:

                * <u>return</u> - for <u>[{'_',[],[{return_trace}]}]</u> (report the return value from a traced function)

                * <u>caller</u> - for <u>[{'_',[],[{message,{caller}}]}]</u> (report the calling function)

                * <u>{codestr,</u>   <u>Str}</u>  -  for  <u>dbg:fun2ms/1</u>  arguments  passed  as  strings  (example:  <u>"fun(_)</u>  <u>-&gt;</u>
                  <u>return_trace()</u> <u>end"</u>)

       <b>list_history()</b> <b>-&gt;</b> <b>History</b>

              Types:

                 History = [{N,Func,Args}]

              All calls to <u>ttb</u> is stored in the history. This  function  returns  the  current  content  of  the
              history.  Any  entry  can  be reexecuted with <u>run_history/1</u> or stored in a configuration file with
              <u>write_config/2,3</u>.

       <b>run_history(N)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 N = integer() | [integer()]

              Executes  the  specified  entry  or  entries  from  the  history  list.  To  list   history,   use
              <u>list_history/0</u>.

       <b>write_config(ConfigFile,Config)</b>

              Equivalent to <u>write_config(ConfigFile,Config,[])</u>.

       <b>write_config(ConfigFile,Config,Opts)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,Reason}</b>

              Types:

                 ConfigFile = string()
                 Config = all | [integer()] | [{Mod,Func,Args}]
                 Mod = atom()
                 Func = atom()
                 Args = [term()]
                 Opts = Opt | [Opt]
                 Opt = append

              Creates  or extends a configuration file, which can be used for restoring a specific configuration
              later.

              The contents of the configuration file can  either  be  fetched  from  the  history  or  specified
              directly as a list of <u>{Mod,Func,Args}</u>.

              If  the  complete history is to be stored in the configuration file, <u>Config</u> must be <u>all</u>. If only a
              selected number of entries from the history are to be stored, <u>Config</u> must be a  list  of  integers
              pointing out the entries to be stored.

              If  <u>Opts</u> is not specified or if it is <u>[]</u>, <u>ConfigFile</u> is deleted and a new file is created. If <u>Opts</u>
              <u>=</u> <u>[append]</u>, <u>ConfigFile</u> is not deleted. The new information is appended at the end of the file.

       <b>run_config(ConfigFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,Reason}</b>

              Types:

                 ConfigFile = string()

              Executes all entries in the specified configuration file. Notice that  the  history  of  the  last
              trace is always available in file <u>ttb_last_config</u>.

       <b>run_config(ConfigFile,NumList)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,Reason}</b>

              Types:

                 ConfigFile = string()
                 NumList = [integer()]

              Executes  selected  entries  from  the specified configuration file. <u>NumList</u> is a list of integers
              pointing out the entries to be executed.

              To list the contents of a configuration file, use <u>list_config/1</u>.

              Notice that the history of the last trace is always available in file <u>ttb_last_config</u>.

       <b>list_config(ConfigFile)</b> <b>-&gt;</b> <b>Config</b> <b>|</b> <b>{error,Reason}</b>

              Types:

                 ConfigFile = string()
                 Config = [{N,Func,Args}]

              Lists all entries in the specified configuration file.

       <b>write_trace_info(Key,Info)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Key = term()
                 Info = Data | fun() -&gt; Data
                 Data = term()

              File <u>.ti</u> contains <u>{Key,ValueList}</u> tuples. This function adds <u>Data</u> to the <u>ValueList</u> associated with
              <u>Key</u>. All information written with this function is included in the call to the format handler.

       <b>seq_trigger_ms()</b> <b>-&gt;</b> <b>MatchSpec</b>

              Equivalent to <u>seq_trigger_ms(all)</u>.

       <b>seq_trigger_ms(Flags)</b> <b>-&gt;</b> <b>MatchSpec</b>

              Types:

                 MatchSpec = match_spec()
                 Flags = all | SeqTraceFlag | [SeqTraceFlag]
                 SeqTraceFlag = atom()

              A match specification can turn on or  off  sequential  tracing.  This  function  returns  a  match
              specification, which turns on sequential tracing with the specified <u>Flags</u>.

              This  match  specification  can be specified as the last argument to <u>tp</u> or <u>tpl</u>. The activated <u>Item</u>
              then becomes a <u>trigger</u> for sequential tracing. This means that if the item is called on a  process
              with trace flag <u>call</u> set, the process is "contaminated" with token <u>seq_trace</u>.

              If <u>Flags</u> <u>=</u> <u>all</u>, all possible flags are set.

              The possible values for <u>SeqTraceFlag</u> are available in <u>seq_trace</u>.

              For  a description of the <u>match_spec()</u> syntax, see section <u>Match</u> <u>Specifications</u> <u>in</u> <u>Erlang</u> in ERTS,
              which explains the general match specification "language".

          <b>Note:</b>
              The <u>system</u> <u>tracer</u> for sequential tracing is automatically initiated by <u>ttb</u> when a  trace  port  is
              started with <u>ttb:tracer/0,1,2</u>.

              An example of how to use function <u>seq_trigger_ms/0,1</u> follows:

              (tiger@durin)5&gt; ttb:tracer().
              {ok,[tiger@durin]}
              (tiger@durin)6&gt; ttb:p(all,call).
              {ok,{[all],[call]}}
              (tiger@durin)7&gt; ttb:tp(mod,func,ttb:seq_trigger_ms()).
              {ok,[{matched,1},{saved,1}]}
              (tiger@durin)8&gt;

              Whenever <u>mod:func(...)</u> is called after this, token <u>seq_trace</u> is set on the executing process.

       <b>stop()</b>

              Equivalent to <u>stop([])</u>.

       <b>stop(Opts)</b> <b>-&gt;</b> <b>stopped</b> <b>|</b> <b>{stopped,</b> <b>Dir}</b>

              Types:

                 Opts = Opt | [Opt]
                 Opt = nofetch | {fetch_dir, Dir} | format | {format, FormatOpts} | return_fetch_dir
                 Dir = string()
                 FormatOpts = see format/2

              Stops  tracing  on  all nodes. Logs and trace information files are sent to the trace control node
              and stored in a directory named <u>ttb_upload_FileName-Timestamp</u>, where <u>Filename</u> is the one  provided
              with  <u>{file,</u> <u>File}</u> during trace setup and <u>Timestamp</u> is of the form <u>yyyymmdd-hhmmss</u>. Even logs from
              nodes on the same machine as the trace control node are moved to this directory. The history  list
              is  saved  to  a  file  named <u>ttb_last_config</u> for further reference (as it is no longer accessible
              through history and configuration management functions, like <u>ttb:list_history/0</u>).

              <u>Options:</u>

                <u>nofetch</u>:
                  Indicates that trace logs are not to be collected after tracing is stopped.

                <u>{fetch,</u> <u>Dir}</u>:
                  Allows specification of the directory to fetch the data to. If the directory  already  exists,
                  an error is thrown.

                <u>format</u>:
                  Indicates  the  trace  logs  to  be  formatted after tracing is stopped. All logs in the fetch
                  directory are merged.

                <u>return_fetch_dir</u>:
                  Indicates the return value to be <u>{stopped,</u> <u>Dir}</u> and not just <u>stopped</u>. This implies <u>fetch</u>.

       <b>get_et_handler()</b>

              Returns the <u>et</u> handler, which can be used with <u>format/2</u> or <u>tracer/2</u>.

              Example: <u>ttb:format(Dir,</u> <u>[{handler,</u> <u>ttb:get_et_handler()}])</u>.

       <b>format(File)</b>

              Equivalent to <u>format(File,[])</u>.

       <b>format(File,Options)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 File = string() | [string()]
                   This can be the name of a binary log, a list of  such  logs,  or  the  name  of  a  directory
                   containing one or more binary logs.
                 Options = Opt | [Opt]
                 Opt = {out,Out} | {handler,FormatHandler} | disable_sort
                 Out = standard_io | string()
                 FormatHandler = {Function, InitialState}
                 Function = fun(Fd,Trace,TraceInfo,State) -&gt; State
                 Fd = standard_io | FileDescriptor
                   File descriptor of the destination file <u>Out</u>.
                 Trace = tuple()
                   The trace message. For details, see the Reference Manual for module <u>erlang</u>.
                 TraceInfo = [{Key,ValueList}]
                   Includes  the  keys  <u>flags</u>, <u>client</u>, and <u>node</u>. If <u>handler</u> is specified as option to the tracer
                   function,  this  is  also   included.   Also,   all   information   written   with   function
                   <u>write_trace_info/2</u> is included.

              Reads  the specified binary trace log(s). The logs are processed in the order of their time stamps
              as long as option <u>disable_sort</u> is not specified.

              If <u>FormatHandler</u> <u>=</u> <u>{Function,InitialState}</u>, <u>Function</u> is called for each trace message.

              If <u>FormatHandler</u> <u>=</u> <u>get_et_handler()</u>, <u>et_viewer</u> in application ET is used for presenting the  trace
              log  graphically.  <u>ttb</u> provides a few different filters that can be selected from menu <u>Filters</u> <u>and</u>
              <u>scaling</u> in the <u>et_viewer</u>.

              If <u>FormatHandler</u> is not specified, a default handler is used presenting each trace  message  as  a
              text line.

              The state returned from each call of <u>Function</u> is passed to the next call, even if the next call is
              to format a message from another log file.

              If <u>Out</u> is specified, <u>FormatHandler</u> gets the file descriptor to <u>Out</u> as the first parameter.

              <u>Out</u> is ignored if the <u>et</u> format handler is used.

              Wrap  logs  can  be  formatted one by one or all at once. To format one of the wrap logs in a set,
              specify the exact file name. To format the whole set of wrap logs, specify the name with <u>*</u> instead
              of the wrap count. For examples, see the <u>User's</u> <u>Guide</u>.

Ericsson AB                                      observer 2.10.1                                       <u><a href="../man3erl/ttb.3erl.html">ttb</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>