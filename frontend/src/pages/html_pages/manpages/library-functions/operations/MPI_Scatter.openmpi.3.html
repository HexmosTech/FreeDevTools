<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Syntax</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openmpi-doc">openmpi-doc_5.0.7-1build1_all</a> <br><br><pre>
</pre><h4><b>SYNTAX</b></h4><pre>
   <b>C</b> <b>Syntax</b>
          #include &lt;mpi.h&gt;

          int MPI_Scatter(const void *sendbuf, int sendcount, MPI_Datatype sendtype,
               void *recvbuf, int recvcount, MPI_Datatype recvtype, int root,
               MPI_Comm comm)

          int MPI_Iscatter(const void *sendbuf, int sendcount, MPI_Datatype sendtype,
               void *recvbuf, int recvcount, MPI_Datatype recvtype, int root,
               MPI_Comm comm, MPI_Request *request)

          int MPI_Scatter_init(const void *sendbuf, int sendcount, MPI_Datatype sendtype,
               void *recvbuf, int recvcount, MPI_Datatype recvtype, int root,
               MPI_Comm comm, MPI_Info info, MPI_Request *request)

   <b>Fortran</b> <b>Syntax</b>
          USE MPI
          ! or the older form: INCLUDE 'mpif.h'
          MPI_SCATTER(SENDBUF, SENDCOUNT, SENDTYPE, RECVBUF, RECVCOUNT,
                       RECVTYPE, ROOT, COMM, IERROR)
               &lt;type&gt;  SENDBUF(*), RECVBUF(*)
               INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT, RECVTYPE, ROOT
               INTEGER COMM, IERROR

          MPI_ISCATTER(SENDBUF, SENDCOUNT, SENDTYPE, RECVBUF, RECVCOUNT,
                       RECVTYPE, ROOT, COMM, REQUEST, IERROR)
               &lt;type&gt;  SENDBUF(*), RECVBUF(*)
               INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT, RECVTYPE, ROOT
               INTEGER COMM, REQUEST, IERROR

          MPI_SCATTER_INIT(SENDBUF, SENDCOUNT, SENDTYPE, RECVBUF, RECVCOUNT,
                       RECVTYPE, ROOT, COMM, INFO, REQUEST, IERROR)
               &lt;type&gt;  SENDBUF(*), RECVBUF(*)
               INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT, RECVTYPE, ROOT
               INTEGER COMM, INFO, REQUEST, IERROR

   <b>Fortran</b> <b>2008</b> <b>Syntax</b>
          USE mpi_f08
          MPI_Scatter(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype,
                       root, comm, ierror)
               TYPE(*), DIMENSION(..), INTENT(IN) :: sendbuf
               TYPE(*), DIMENSION(..) :: recvbuf
               INTEGER, INTENT(IN) :: sendcount, recvcount, root
               TYPE(MPI_Datatype), INTENT(IN) :: sendtype, recvtype
               TYPE(MPI_Comm), INTENT(IN) :: comm
               INTEGER, OPTIONAL, INTENT(OUT) :: ierror

          MPI_Iscatter(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype,
                       root, comm, request, ierror)
               TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: sendbuf
               TYPE(*), DIMENSION(..), ASYNCHRONOUS :: recvbuf
               INTEGER, INTENT(IN) :: sendcount, recvcount, root
               TYPE(MPI_Datatype), INTENT(IN) :: sendtype, recvtype
               TYPE(MPI_Comm), INTENT(IN) :: comm
               TYPE(MPI_Request), INTENT(OUT) :: request
               INTEGER, OPTIONAL, INTENT(OUT) :: ierror

          MPI_Scatter_init(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype,
                       root, comm, info, request, ierror)
               TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: sendbuf
               TYPE(*), DIMENSION(..), ASYNCHRONOUS :: recvbuf
               INTEGER, INTENT(IN) :: sendcount, recvcount, root
               TYPE(MPI_Datatype), INTENT(IN) :: sendtype, recvtype
               TYPE(MPI_Comm), INTENT(IN) :: comm
               TYPE(MPI_Info), INTENT(IN) :: info
               TYPE(MPI_Request), INTENT(OUT) :: request
               INTEGER, OPTIONAL, INTENT(OUT) :: ierror

</pre><h4><b>INPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>sendbuf</b>: Address of send buffer (choice, significant only at root).

       • <b>sendcount</b>: Number of elements sent to each process (integer, significant only at root).

       • <b>sendtype</b>: Datatype of send buffer elements (handle, significant only at root).

       • <b>recvcount</b>: Number of elements in receive buffer (integer).

       • <b>recvtype</b>: Datatype of receive buffer elements (handle).

       • <b>root</b>: Rank of sending process (integer).

       • <b>comm</b>: Communicator (handle).

       • <b>info</b>: Info (handle, persistent).

</pre><h4><b>OUTPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>recvbuf</b>: Address of receive buffer (choice).

       • <b>request</b>: Request (handle, non-blocking only).

       • <b>ierror</b>: Fortran only: Error status (integer).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>MPI_Scatter</u> is the inverse operation to <u>MPI_Gather</u>.

       The outcome is as if the root executed n send operations,

          MPI_Send(sendbuf + i * sendcount * extent(sendtype), sendcount,
                   sendtype, i, ...);

       and each process executed a receive,

          MPI_Recv(recvbuf, recvcount, recvtype, i, ...).;

       An  alternative  description  is  that  the  root  sends  a message with <b>MPI_Send(sendbuf,</b> <b>sendcount</b> <b>*</b> <b>n,</b>
       <b>sendtype,</b> <b>...)</b>. This message is split into <u>n</u> equal segments, the ith segment is sent to the  ith  process
       in the group, and each process receives this message as above.

       The send buffer is ignored for all nonroot processes.

       The  type  signature  associated with <u>sendcount</u>, <u>sendtype</u> at the root must be equal to the type signature
       associated with <u>recvcount</u>, <u>recvtype</u> at all processes (however, the type maps  may  be  different).   This
       implies  that the amount of data sent must be equal to the amount of data received, pairwise between each
       process and the root. Distinct type maps between sender and receiver are still allowed.

       All arguments to the function are significant on process <u>root</u>, while on other processes,  only  arguments
       <u>recvbuf</u>, <u>recvcount</u>, <u>recvtype</u>, <u>root</u>, <u>comm</u> are significant. The arguments <u>root</u> and <u>comm</u> must have identical
       values on all processes.

       The  specification  of  counts  and  types should not cause any location on the root to be read more than
       once.

       <b>Rationale:</b> Though not needed, the last restriction is imposed so as to achieve symmetry with  <u>MPI_Gather</u>,
       where the corresponding restriction (a multiple-write restriction) is necessary.

       <b>Example:</b>  The  reverse  of Example 1 in the <u>MPI_Gather</u> manpage. Scatter sets of 100 ints from the root to
       each process in the group.

          MPI_Comm comm;
          int gsize,*sendbuf;
          int root, rbuf[100];
          ...
          MPI_Comm_size(comm, &amp;gsize);
          sendbuf = (int *)malloc(gsize*100*sizeof(int));
          ...
          MPI_Scatter(sendbuf, 100, MPI_INT, rbuf, 100,
                      MPI_INT, root, comm);

</pre><h4><b>USE</b> <b>OF</b> <b>IN-PLACE</b> <b>OPTION</b></h4><pre>
       When the communicator is an intracommunicator, you can perform a scatter operation in-place  (the  output
       buffer  is  used  as  the  input  buffer). Use the variable MPI_IN_PLACE as the value of the root process
       <u>recvbuf</u>. In this case, <u>recvcount</u> and <u>recvtype</u> are ignored, and the root process sends no data to itself.

       Note that MPI_IN_PLACE is a special kind of value; it has the same restrictions on its use as MPI_BOTTOM.

       Because the in-place option converts the receive buffer into a send-and-receive buffer, a Fortran binding
       that includes INTENT must mark these as INOUT, not OUT.

</pre><h4><b>WHEN</b> <b>COMMUNICATOR</b> <b>IS</b> <b>AN</b> <b>INTER-COMMUNICATOR</b></h4><pre>
       When the communicator is an inter-communicator, the root process in the first group  sends  data  to  all
       processes  in  the  second group. The first group defines the root process. That process uses MPI_ROOT as
       the value of its <u>root</u> argument. The remaining processes use <b>MPI_PROC_NULL</b> as  the  value  of  their  <u>root</u>
       argument.  All  processes in the second group use the rank of that root process in the first group as the
       value of their <u>root</u> argument. The receive buffer argument of the root process in the first group must  be
       consistent with the receive buffer argument of the processes in the second group.

</pre><h4><b>ERRORS</b></h4><pre>
       Almost  all  MPI  routines  return  an  error  value; C routines as the return result of the function and
       Fortran routines in the last argument.

       Before the error value is returned, the current MPI  error  handler  associated  with  the  communication
       object  (e.g.,  communicator, window, file) is called.  If no communication object is associated with the
       MPI call, then the call is considered attached to MPI_COMM_SELF and will call the  associated  MPI  error
       handler.   When   MPI_COMM_SELF   is   not  initialized  (i.e.,  before  <u>MPI_Init</u>/<u>MPI_Init_thread</u>,  after
       <u>MPI_Finalize</u>, or when using the Sessions Model exclusively) the error raises the initial  error  handler.
       The  initial  error handler can be changed by calling <u>MPI_Comm_set_errhandler</u> on MPI_COMM_SELF when using
       the World model, or the mpi_initial_errhandler CLI argument to mpiexec or info  key  to  <u>MPI_Comm_spawn</u>/‐
       <u>MPI_Comm_spawn_multiple</u>.   If no other appropriate error handler has been set, then the MPI_ERRORS_RETURN
       error handler is called for MPI I/O functions and the MPI_ERRORS_ABORT error handler is  called  for  all
       other MPI functions.

       Open MPI includes three predefined error handlers that can be used:

       • <b>MPI_ERRORS_ARE_FATAL</b> Causes the program to abort all connected MPI processes.

       • <b>MPI_ERRORS_ABORT</b> An error handler that can be invoked on a communicator, window, file, or session. When
         called  on  a  communicator,  it  acts  as if <u>MPI_Abort</u> was called on that communicator. If called on a
         window or file, acts as if <u>MPI_Abort</u> was called on a communicator containing the group of processes  in
         the corresponding window or file. If called on a session, aborts only the local process.

       • <b>MPI_ERRORS_RETURN</b> Returns an error code to the application.

       MPI applications can also implement their own error handlers by calling:

       • <u>MPI_Comm_create_errhandler</u> then <u>MPI_Comm_set_errhandler</u>

       • <u>MPI_File_create_errhandler</u> then <u>MPI_File_set_errhandler</u>

       • <u>MPI_Session_create_errhandler</u> then <u>MPI_Session_set_errhandler</u> or at <u>MPI_Session_init</u>

       • <u>MPI_Win_create_errhandler</u> then <u>MPI_Win_set_errhandler</u>

       Note that MPI does not guarantee that an MPI program can continue past an error.

       See the <u>MPI</u> <u>man</u> <u>page</u> for a full list of <u>MPI</u> <u>error</u> <u>codes</u>.

       See the Error Handling section of the MPI-3.1 standard for more information.

       <b>SEE</b> <b>ALSO:</b>

          • <u>MPI_Scatterv</u>

          • <u>MPI_Gather</u>

          • <u>MPI_Gatherv</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2003-2025, The Open MPI Community

                                                  Jun 07, 2025                                    <u><a href="../man3/MPI_SCATTER.3.html">MPI_SCATTER</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>