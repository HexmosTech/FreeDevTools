<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSL_CTX_set_max_send_fragment, SSL_set_max_send_fragment, SSL_CTX_set_split_send_fragment,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SSL_CTX_set_max_send_fragment, SSL_set_max_send_fragment, SSL_CTX_set_split_send_fragment,
       SSL_set_split_send_fragment, SSL_CTX_set_max_pipelines, SSL_set_max_pipelines,
       SSL_CTX_set_default_read_buffer_len, SSL_set_default_read_buffer_len,
       SSL_CTX_set_tlsext_max_fragment_length, SSL_set_tlsext_max_fragment_length,
       SSL_SESSION_get_max_fragment_length - Control fragment size settings and pipelining operations

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/ssl.h&gt;

        long SSL_CTX_set_max_send_fragment(SSL_CTX *ctx, long);
        long SSL_set_max_send_fragment(SSL *ssl, long m);

        long SSL_CTX_set_max_pipelines(SSL_CTX *ctx, long m);
        long SSL_set_max_pipelines(SSL_CTX *ssl, long m);

        long SSL_CTX_set_split_send_fragment(SSL_CTX *ctx, long m);
        long SSL_set_split_send_fragment(SSL *ssl, long m);

        void SSL_CTX_set_default_read_buffer_len(SSL_CTX *ctx, size_t len);
        void SSL_set_default_read_buffer_len(SSL *s, size_t len);

        int SSL_CTX_set_tlsext_max_fragment_length(SSL_CTX *ctx, uint8_t mode);
        int SSL_set_tlsext_max_fragment_length(SSL *ssl, uint8_t mode);
        uint8_t SSL_SESSION_get_max_fragment_length(const SSL_SESSION *session);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Some engines are able to process multiple simultaneous crypto operations. This capability could be
       utilised to parallelise the processing of a single connection. For example a single write can be split
       into multiple records and each one encrypted independently and in parallel. Note: this will only work in
       TLS1.1+. There is no support in SSLv3, TLSv1.0 or DTLS (any version). This capability is known as
       "pipelining" within OpenSSL.

       In order to benefit from the pipelining capability. You need to have an engine that provides ciphers that
       support this. The OpenSSL "dasync" engine provides AES128-SHA based ciphers that have this capability.
       However, these are for development and test purposes only.

       <b>SSL_CTX_set_max_send_fragment()</b> and <b>SSL_set_max_send_fragment()</b> set the <b>max_send_fragment</b> parameter for
       SSL_CTX and SSL objects respectively. This value restricts the amount of plaintext bytes that will be
       sent in any one SSL/TLS record. By default its value is SSL3_RT_MAX_PLAIN_LENGTH (16384). These functions
       will only accept a value in the range 512 - SSL3_RT_MAX_PLAIN_LENGTH.

       <b>SSL_CTX_set_max_pipelines()</b> and <b>SSL_set_max_pipelines()</b> set the maximum number of pipelines that will be
       used at any one time. This value applies to both "read" pipelining and "write" pipelining. By default
       only one pipeline will be used (i.e. normal non-parallel operation). The number of pipelines set must be
       in the range 1 - SSL_MAX_PIPELINES (32). Setting this to a value &gt; 1 will also automatically turn on
       "read_ahead" (see <b><a href="../man3/SSL_CTX_set_read_ahead.3.html">SSL_CTX_set_read_ahead</a></b>(3)). This is explained further below. OpenSSL will only ever use
       more than one pipeline if a cipher suite is negotiated that uses a pipeline capable cipher provided by an
       engine.

       Pipelining operates slightly differently for reading encrypted data compared to writing encrypted data.
       <b>SSL_CTX_set_split_send_fragment()</b> and <b>SSL_set_split_send_fragment()</b> define how data is split up into
       pipelines when writing encrypted data. The number of pipelines used will be determined by the amount of
       data provided to the <b>SSL_write_ex()</b> or <b>SSL_write()</b> call divided by <b>split_send_fragment</b>.

       For example if <b>split_send_fragment</b> is set to 2000 and <b>max_pipelines</b> is 4 then:

       SSL_write/SSL_write_ex called with 0-2000 bytes == 1 pipeline used

       SSL_write/SSL_write_ex called with 2001-4000 bytes == 2 pipelines used

       SSL_write/SSL_write_ex called with 4001-6000 bytes == 3 pipelines used

       SSL_write/SSL_write_ex called with 6001+ bytes == 4 pipelines used

       <b>split_send_fragment</b> must always be less than or equal to <b>max_send_fragment</b>. By default it is set to be
       equal to <b>max_send_fragment</b>.  This will mean that the same number of records will always be created as
       would have been created in the non-parallel case, although the data will be apportioned differently. In
       the parallel case data will be spread equally between the pipelines.

       Read pipelining is controlled in a slightly different way than with write pipelining. While reading we
       are constrained by the number of records that the peer (and the network) can provide to us in one go. The
       more records we can get in one go the more opportunity we have to parallelise the processing. As noted
       above when setting <b>max_pipelines</b> to a value greater than one, <b>read_ahead</b> is automatically set. The
       <b>read_ahead</b> parameter causes OpenSSL to attempt to read as much data into the read buffer as the network
       can provide and will fit into the buffer. Without this set data is read into the read buffer one record
       at a time. The more data that can be read, the more opportunity there is for parallelising the processing
       at the cost of increased memory overhead per connection. Setting <b>read_ahead</b> can impact the behaviour of
       the <b>SSL_pending()</b> function (see <b><a href="../man3/SSL_pending.3.html">SSL_pending</a></b>(3)). In addition the default size of the internal read buffer
       is multiplied by the number of pipelines available to ensure that we can read multiple records in one go.
       This can therefore have a significant impact on memory usage.

       The <b>SSL_CTX_set_default_read_buffer_len()</b> and <b>SSL_set_default_read_buffer_len()</b> functions control the
       size of the read buffer that will be used. The <b>len</b> parameter sets the size of the buffer. The value will
       only be used if it is greater than the default that would have been used anyway. The normal default value
       depends on a number of factors but it will be at least SSL3_RT_MAX_PLAIN_LENGTH +
       SSL3_RT_MAX_ENCRYPTED_OVERHEAD (16704) bytes.

       <b>SSL_CTX_set_tlsext_max_fragment_length()</b> sets the default maximum fragment length negotiation mode via
       value <b>mode</b> to <b>ctx</b>.  This setting affects only SSL instances created after this function is called.  It
       affects the client-side as only its side may initiate this extension use.

       <b>SSL_set_tlsext_max_fragment_length()</b> sets the maximum fragment length negotiation mode via value <b>mode</b> to
       <b>ssl</b>.  This setting will be used during a handshake when extensions are exchanged between client and
       server.  So it only affects SSL sessions created after this function is called.  It affects the client-
       side as only its side may initiate this extension use.

       <b>SSL_SESSION_get_max_fragment_length()</b> gets the maximum fragment length negotiated in <b>session</b>.

       These functions cannot be used with QUIC SSL objects.  <b>SSL_set_max_send_fragment()</b>,
       <b>SSL_set_max_pipelines()</b>, <b>SSL_set_split_send_fragment()</b>, <b>SSL_set_default_read_buffer_len()</b> and
       <b>SSL_set_tlsext_max_fragment_length()</b> fail if called on a QUIC SSL object.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       All non-void functions return 1 on success and 0 on failure.

</pre><h4><b>NOTES</b></h4><pre>
       The Maximum Fragment Length extension support is optional on the server side.  If the server does not
       support this extension then <b>SSL_SESSION_get_max_fragment_length()</b> will return:
       TLSEXT_max_fragment_length_DISABLED.

       The following modes are available:

       TLSEXT_max_fragment_length_DISABLED
           Disables Maximum Fragment Length Negotiation (default).

       TLSEXT_max_fragment_length_512
           Sets Maximum Fragment Length to 512 bytes.

       TLSEXT_max_fragment_length_1024
           Sets Maximum Fragment Length to 1024.

       TLSEXT_max_fragment_length_2048
           Sets Maximum Fragment Length to 2048.

       TLSEXT_max_fragment_length_4096
           Sets Maximum Fragment Length to 4096.

       With    the   exception   of   <b>SSL_CTX_set_default_read_buffer_len()</b>   <b>SSL_set_default_read_buffer_len()</b>,
       <b>SSL_CTX_set_tlsext_max_fragment_length()</b>,            <b>SSL_set_tlsext_max_fragment_length()</b>             and
       <b>SSL_SESSION_get_max_fragment_length()</b> all these functions are implemented using macros.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/ssl.7.html">ssl</a></b>(7), <b><a href="../man3/SSL_CTX_set_read_ahead.3.html">SSL_CTX_set_read_ahead</a></b>(3), <b><a href="../man3/SSL_pending.3.html">SSL_pending</a></b>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       The      <b>SSL_CTX_set_max_pipelines()</b>,     <b>SSL_set_max_pipelines()</b>,     <b>SSL_CTX_set_split_send_fragment()</b>,
       <b>SSL_set_split_send_fragment()</b>,                 <b>SSL_CTX_set_default_read_buffer_len()</b>                  and
       <b>SSL_set_default_read_buffer_len()</b> functions were added in OpenSSL 1.1.0.

       The        <b>SSL_CTX_set_tlsext_max_fragment_length()</b>,       <b>SSL_set_tlsext_max_fragment_length()</b>       and
       <b>SSL_SESSION_get_max_fragment_length()</b> functions were added in OpenSSL 1.1.1.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2016-2023 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file  except  in  compliance
       with  the  License.   You  can  obtain  a  copy  in  the  file  LICENSE  in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04              <u><a href="../man3SSL/SSL_CTX_SET_SPLIT_SEND_FRAGMENT.3SSL.html">SSL_CTX_SET_SPLIT_SEND_FRAGMENT</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>