<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Term::Query - Table-driven query routine.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libterm-query-perl">libterm-query-perl_2.0-11_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Term::Query - Table-driven query routine.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       "use <b>Term::Query</b>"
                        "qw( <b>query</b> <b>query_table</b> <b>query_table_set_defaults</b> <b>query_table_process</b> );"

       "$result = <b>query</b> $<u>prompt</u>, $<u>flags</u>, [ $<u>optional_args</u> ];"

       "$<u>ok</u> = <b>query_table</b> \@<u>array</u>;"

       "<b>query_table_set_defaults</b> \@<u>array</u>;"

       "$<u>ok</u> = <b>query_table_process</b> \@<u>array</u>, \&amp;flagsub, \&amp;querysub;"

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>query</b>
       The  <b>query</b> subroutine fulfills the need for a generalized question-response subroutine, with programmatic
       defaulting, validation, condition and error checking.

       Given <u>$prompt</u> and <u>$flags</u>, and possibly additional arguments, depending upon  the  characters  in  <u>$flags</u>,
       <b>query</b>  issues  a prompt to STDOUT and solicits input from STDIN.  The input is validated against a set of
       test criteria as configured by the characters in <u>$flags</u>; if any of the tests fail, an  error  message  is
       noted, and the query is reattempted.

       When  STDIN is not a tty (not interactive), prompts are not issued, and errors cause a return rather than
       attempting to obtain more input.  This non-interactive behaviour can be disabled by setting the  variable
       $Foce_Interactive as below:

           $Term::Query::Force_Interactive = 1;

       When  $Force_Interactive is a non-null, non-zero value, <b>query</b> will issue prompts, error messages, and ask
       for additional input even when the input is not interactive.

   <b>query_table</b>
       The <b>query_table</b> subroutine performs multiple queries, by invoking  <b>query</b>,  setting  associated  variables
       with  the  results  of  each  query.   Prompts, flags, and other arguments for each query are given in an
       array, called a <u>query</u> <u>table</u>, which is passed to the <b>query_table</b> subroutine by reference.

   <b>query_table_set_defaults</b>
       The <b>query_table_set_defaults</b> subroutine causes any variables named in the given <u>query</u> <u>table</u> array  to  be
       assigned their corresponding default values, if any.  This is a non-interactive subroutine.

   <b>query_table_process</b>
       A general interface to processing a <u>query</u> <u>table</u> is available with the <b>query_table_process</b> subroutine.  It
       accepts  a <u>query</u> <u>table</u> array, and two subroutine references, a <u>&amp;flagsub</u> and a <u>&amp;querysub</u>.  The <u>&amp;flagsub</u> is
       invoked on each each <u>flag</u> character given in the <u>$flags</u> argument of the <u>query</u>  <u>table</u>  (see  below).   The
       <u>&amp;querysub</u> is invoked for each query in the <u>query</u> <u>table</u>.

       The  <b>query_table</b>  and  <b>query_table_set_defaults</b> subroutines both use <b>query_table_process</b> to perform their
       functions.

   <u><b>Query</b></u> <u><b>Table</b></u>
       The  format  of  the  <u>query</u>  <u>table</u>   array   passed   to   <b>query_table</b>,   <b>query_table_set_defaults</b>,   and
       <b>query_table_process</b> subroutines is:

        @array = ( $prompt1, $flags1, [ $arglist1, ... ],
                   $prompt2, $flags2, [ $arglist2, ... ],
                   ...
                   $promptN, $flagsN, [ $arglistN, ... ] );

       In  English, there are three items per query: a <u>prompt</u> string, a <u>flags</u> string, and an array of arguments.
       Note that the syntax used above uses "[ ... ]" to denote a Perl 5 anonymous array, not an optional set of
       arguments.  Of course, if there are no arguments for a  particular  query,  the  corresponding  anonymous
       array can be the null string or zero.

       The query table design is such that a query table can be created with a set of variables, their defaults,
       value  constraints,  and help strings, and it can be used to both initialize the variables' values and to
       interactively set their new values.  The <b>query_table_set_defaults</b> subroutine performs the  former,  while
       <b>query_table</b> does the latter.

   <b>Flag</b> <b>Characters</b>
       With  typical  usage,  given  <u>$prompt</u>  and <u>$flags</u>, <b>query</b> prints <u>$prompt</u> and then waits for input from the
       user.  The handling of the response depends upon the flag characters given in the <u>$flags</u> string.

       The flag characters indicate the type of input, how to process it, acceptable values,  etc.   Some  flags
       simply  indicate  the  type  or  processing of the input, and do not require additional arguments.  Other
       flags require that subsequent arguments to the <b>query</b> subroutine be given.  The arguments must be given in
       the same order as their corresponding flag characters.

       The ordering of the flags in the <u>$flags</u> argument is important -- it determines the ordering of the tests.
       For example, if both the <b>a</b> and <b>m</b> flags are given as "am", then this indicates that  an  <u>after</u>  subroutine
       call should be performed first, followed by a regular expression <u>match</u> test.

       All tests are applied in the order given in the <u>$flags</u> until a particular test fails.  When a test fails,
       an error message is generated and the input is reattempted, except in the case of the <b>I</b> flag.

   <b>Flag</b> <b>Characters</b> <b>Without</b> <b>Arguments</b>
       <b>i</b>    The input must be an integer.

       <b>n</b>    The input must be a number, real or integer.

       <b>Y</b>    The input is a "yes" or "no", with a default answer of "yes".

       <b>N</b>    The input is a "yes" or "no", with a default answer of "no".

       <b>r</b>    Some  input  is  <u>required</u>;  an  empty response will be refused.  This option is only meaningful when
            there is no default input (see the <b>d</b> flag character below).

       <b>s</b>    Strip and squeeze the input.  Leading and trailing blanks are eliminated, and embedded whitespace is
            "squeezed" to single blank characters.  This flag is implied by the <b>k</b> and <b>K</b> flags.

       <b>H</b>    Do not treat input of <b>?</b> as a request for help.  This disables  automatic  help,  unless  implemented
            with the <u>after</u> (<b>a</b> flag) subroutine.

   <b>Flag</b> <b>Characters</b> <b>With</b> <b>Arguments</b>
       The following flag characters indicate the presence of an argument to <b>query</b>.  The arguments must occur in
       the  same order as their corresponding flag characters.  For example, if both the <b>V</b> and <b>h</b> flags are given
       as "Vh", then the first argument must be the variable name, and the next the help string, in that order.

       <b>a</b> <u>\&amp;after</u>
            The next argument is the <u>after</u> subroutine, to be invoked after the input has been  solicited.   This
            feature  provides for an "open ended" input validation, completely at the control of the user of the
            Query module.    The <u>after</u> subroutine is invoked in this manner:

              &amp;$after( \$input );

            If the <u>after</u> sub returns an "undef", then query processing stops with an  immediate  "undef"  return
            value.

            If  the <u>after</u> sub returns a null or zero value, then the input is rejected and resolicted.  No error
            messages are displayed except the "Please try again." message.

            Since the <u>after</u> sub has the reference to the <u>$input</u> variable, it is free  to  change  the  value  of
            input indirectly; ie:

              $$input = $some_new_value;

       <b>b</b> <u>\&amp;before</u>
            The  next  argument is the <u>before</u> subroutine, to be invoked before any input is attempted.    If the
            <u>before</u> sub returns a non-null, non-zero value, the current query will be attempted.  If  a  null  or
            zero value is returned, the current query will be abandoned, with a null return.

            This  feature,  used in a <u>query</u> <u>table</u>, allows for selective queries to be programmed by using <u>before</u>
            subs on the optional queries.  For example,  using  the  following  anonymous  sub  as  the  <b>b</b>  flag
            argument:

              sub { $&gt; == 0; }

            will cause the corresponding query to only be issued for the "root" user.

            The ordering of the <b>b</b> flag in the <u>$flags</u> argument is unimportant, since, by definition, this test is
            always performed before attempting any input.

       <b>d</b> <u>$default</u>
            The  next  argument is the <u>default</u> input.  This string is used instead of an empty response from the
            user.  The default value can be a scalar value, a reference to a scalar value, or a reference  to  a
            subroutine,  which  will  be  invoked  for its result only if a default value is needed (no input is
            given).

       <b>h</b> <u>$help_string</u>
            The next argument is the <u>help</u> <u>string</u>, which is printed in response to an input of "<b>?</b>".  In order  to
            enter a <b>?</b> as actual text, it must be prefixed with a backslash: "\".

       <b>k</b> <u>\@array</u>
            The  next  argument  is a reference to an array of allowable keywords.  The input is matched against
            the array elements in a case-insensitive manner, with unambiguous abbreviations allowed.  This  flag
            implies the <b>s</b> flag.

            The matching can be made case-sensitive by setting the following variable prior to the invocation of
            <b>query</b>:

              $Query::Case_sensitive = 1;

            By default, this variable is null.

       <b>K</b> <u>\@array</u>
            The  next  argument is a reference to an array of disallowed keywords In this case, for the input to
            be unacceptable, it must match exactly, case-insensitive, one of  the  array  elements.   This  flag
            implies the <b>s</b> flag.

            The  <b>k</b> option is useful for soliciting new, unique keywords to a growing list.  Adding new fields to
            a database, for example.

            The matching can be made case-sensitive by setting the $Query::Case_sensitive variable (see above).

       <b>l</b> <u>$maxlen</u>
            The next argument specifies the maximum length of the input.

       <b>m</b> <u>$regular_expression</u>
            The next argument specifies a regular expression pattern against which the input will be matched.

       <b>I</b> <u>$reference</u>
            The next argument is the input: either a simple scalar value, or a <u>reference</u> to a value, such  as  a
            "SCALAR" variable reference (eg: "\$somevar"), or a "CODE" reference (eg: "sub {..}").  In any case,
            the resulting value is used as input instead of reading from STDIN.

            If  the  input  returned  by the reference does not match other constraints, additional input is not
            attempted.  An error message is noted, and an "undef" return is taken.

            This option is handy for applications which have already acquired the input, and  wish  to  use  the
            validation features of "query".

            It  is  also  useful  to embed a query definition in a <u>query</u> <u>table</u> which does not actually perform a
            query, but instead does a variable assignment dynamically, using the <b>I</b> reference value.

       <b>J</b> <u>$reference</u>
            The next argument is the input <u>reference</u>, as with the <b>I</b> flag, except that if the input fails any  of
            the  constraints,  additional  input is solicited from the input.  In other words, the <b>J</b> flag sets a
            <u>one-time</u> only input reference.  Think of it as <u>jumping</u> into the query loop with an initial input.

       <b>V</b> <u>variable_name_or_ref</u>
            The next argument is the variable name or reference to receive the validated  input  as  its  value.
            This option, and its corresponding variable name, would normally be present on all entries used with
            <b>query_table</b> in order to retain to the values resulting from each query.

            The  value  can either be a string representing the variable name, or a reference to a variable, eg:
            "\$some_var".

   <b>Details</b>
       The query processing proceeds basically in the same order as defined by the  <u>flags</u>  argument,  with  some
       exceptions.  For example, the <u>before</u> subroutine is always performed prior to input.

       There  are  implicit  precedences in the ordering of some of the <u>flag</u> tests.  Generally, flags have their
       corresponding tests performed in the same order as the given flags.  Some flag  tests,  however,  require
       that  other flags' tests be performed beforehand in order to be effective.  For example, when given the <b>k</b>
       flag and an <b>s</b> flag, stripping the input would only be effective if the  strip  were  done  on  the  input
       before testing the input against the keyword table.  In other words, the <b>s</b> flag has precedence over the <b>k</b>
       flag.  If the user supplies the <u>flags</u> string as "ks", the effective ordering would still be "sk".

       The table below indicates the precedences of the flag tests:

         Given Flag       Flags With Higher Precedence
         ==========       ================================
         i (int)          s (strip), d (default), h (help)
         k (key)          s (strip), d (default), h (help)
         K (nonkey)       s (strip), d (default), h (help)
         l (maxlen)                  d (default), h (help)
         m (match)                   d (default), h (help)
         n (numeric)      s (strip), d (default), h (help)
         N (no)           s (strip), d (default), h (help)
         r (required)                d (default), h (help)
         s (strip)                   d (default), h (help)
         Y (yes)          s (strip), d (default), h (help)

       Except  for  the implied precedence indicated in the table above, the ordering of the flag tests proceeds
       in the same order as given in the <u>flags</u> argument.

       Excepting the precedences above, query processing proceeds generally as described below.

       •    If the <b>b</b> flag was given, the "before" subroutine is invoked as  a  "pre-input"  test.   If  the  sub
            returns a 0, empty string, or undef, the query is abandoned.  Otherwise, processing continues.

       •    If  the  <b>I</b>  or  <b>J</b>  flags  were given, then input is obtained, without prompting, from the associated
            reference.  If the reference type is "CODE", then it is invoked and the resulting  return  value  is
            used  as the input.  Otherwise the reference is evaluated in a scalar context and used as the input.
            The <b>J</b> flag test is only done once, on the first entry into the input loop.

       •    In the absence either the <b>I</b> or <b>J</b> flags, "query" will issue the given prompt and  obtain  input  from
            STDIN.  If an EOF occurs, an "undef" value will result.

       •    The  input  is  examined  for "null" input (that is, the empty string), and processing quits in this
            case.  Since most input is obtained from STDIN, a null input indicates an end-of-file (EOF).  If the
            input is not null, a terminating newline is removed, and  the  input  testing  continues.   At  this
            point, an empty input string does not indicate an EOF.

       •    If  the  <b>s</b>,  <b>k</b>,  or <b>K</b> flags were given, the input is trimmed of leading and trailing blanks, and all
            whitespace is "squeezed" to single blanks.

       •    If the input is an empty response, and there is a <u>default</u> input (<b>d</b> flag), use it instead.

       •    Unless the <b>H</b> flag is given, if the input is the character "<b>?</b>"  with nothing else,  then  print  some
            helpful information.  If the user had supplied a <u>help</u> <u>string</u>, it is printed, otherwise the message:

            You are being asked "<u>$prompt</u>"

            is  displayed.   Also,  some  information  about  the expected response, according to any given flag
            characters, is displayed.   Finally,  the  user  is  returned  to  the  prompt,  and  given  another
            opportunity to enter a response.

       •    If input is <u>required</u> (indicated by the <b>r</b> flag), and if the input is empty, produce an error message,
            and query again.

       •    If there was a <b>a</b> flag, the corresponding <u>after</u> subroutine is invoked with the input reference as its
            argument.   If  the  subroutine returns a non-null, non-zero value, the input succeeds, otherwise it
            fails.  It is up to the <u>after</u> subroutine to display any appropriate error messages.

       •    If the query was flagged <b>Y</b> or <b>N</b>, match the input against the pattern:

                /^(y(es?)?|no?)$/i

            If the match fails, print an error message, and query again.  When the match succeeds,  replace  the
            input with the complete word "yes" or "no";

       •    If  an  integer  response is required (<b>i</b> flagged), check for integer input.  If not, print an error,
            and query again.  A successful integer input is returned.

       •    If a numeric response is required (<b>n</b> flagged), check for proper numeric  input  (either  integer  or
            real format).  Errors produce a warning, and another query.

       •    If  the query was given a <u>keyword</u> table (flagged with <b>k</b>), the input is matched against the allowable
            keyword list.  If an exact match is found, the keyword is returned as the input.  Failing  an  exact
            match,  an abbreviation search is performed against the keywords.  If a single match is found, it is
            returned as the input.  If no match is found, an error message is produced, and the user is returned
            to the query to try again.  Otherwise, the input was ambiguous, an error noted showing the  matches,
            and the user is queried again.

            The   matching   is   case-insensitive   or   not,   according   to   the   value  of  the  variable
            $Query::Case_sensitive, which is nil, by default.  The variable may be set by the user to change the
            matching from case-insensitive to case-sensitive.

       •    If the query was given an unacceptable keyword list (flagged with <b>K</b>), the input is compared  against
            the  unacceptable keywords.  If it matches any keywords exactly, an error is noted, and the query is
            performed again.

            The matching is case-insensitive by default.  Set the variable $Query::Case_sensitive to a non-null,
            non-zero value to make the keyword matching case-sensitive.

       •    If the query was <b>m</b> flagged with a Perl regular expression pattern, then the input is matched against
            the pattern.  Failures are noted with an error message, and the query reattempted.

       •    If the query was <b>l</b> flagged with a maximum input length, the length of the input is  checked  against
            the maximum.  A length violation is noted with an error message and the user is queried again.

       •    If  the  query  has  a  variable defined with the <b>V</b> flag, the variable is assigned the input string.
            This is always done last, after and only if all tests are successful.

            If the variable is a string name and not qualified with a package name (ie:   $foo::variable),  then
            the variable is qualified at the level outside of the Query.pm module.

       •    Finally, having passed whatever conditions were flagged, the input is returned to the user.

</pre><h4><b>EXAMPLE</b></h4><pre>
       The following are typical usage samples:

       •    To perform a simple "yes" or "no" query, with "no" as the default answer:

             $ans = &amp;query("Do you wish to quit? (yn)",'N');

       •    An equivalent alternative is:

                query "Do you wish to quit? (yn)", 'NV', \$ans;

       •    To perform the same query, with some supplied helpful information:

             $ans = &amp;query("Do you wish to quit? (yn)",'Nh',&lt;&lt;'EOF');
             You are being asked if you wish to quit.  If you answer "yes",
             then all changes will be lost.  An answer of "no", will allow
             you to return to continue making changes.
             EOF

       •    To solicit an integer input:

             $mode = &amp;query("Please enter the file mode:",'idh','644',&lt;&lt;'EOF');
             Please enter the 3 digit numeric file mode; if you are unsure
             of how the file mode is used, please see the man page for "chmod".
             EOF

       •    To solicit one of several keywords:

             @keys = split(' ','SGI DEC IBM Sun HP Apple');
             $vendor = &amp;query('Please enter a vendor:','rkd',\@keys,'SGI');

       •    To solicit a new, unique keyword to be used as a database field name, with a regexp pattern to check
            it against:

             @fields = split(' ','Index Vendor Title'); # existing fields
             $newfield = &amp;query('New field name:','rKm',\@fields,'^\w+$');

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       <b>COLUMNS</b>
            This  variable  is  used  to  control  the  width of output when listing the keyword arrays.  If not
            defined, 80 is used by default.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       <b>Carp.pm</b>
            Used to produce usage error messages.

       <b>Array::PrintCols::print_cols</b>
            Used to produce displays of the keyword arrays.

</pre><h4><b>FILES</b></h4><pre>
       None.

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) 1995  Alan K. Stebbens &lt;<a href="mailto:aks@hub.ucsb.edu">aks@hub.ucsb.edu</a>&gt;

       This program is free software; you can redistribute it and/or modify  it  under  the  terms  of  the  GNU
       General  Public License as published by the Free Software Foundation; either version 2 of the License, or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful, but WITHOUT ANY  WARRANTY;  without  even
       the  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
       License for more details.

       You should have received a copy of the GNU General Public License along with this program; if not,  write
       to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
        Input is required.
            Issued when an empty response is given, and there is no default input.

        Please answer with 'yes' or 'no', or enter '?' for help.
            Issued for <b>Y</b> or <b>N</b> flagged queries, and the input is not reconizeable.

        Please enter an integer number.
            Printed when non-integer input is given for <b>i</b> flagged queries.

        Please enter a number, real or integer.
            Printed when non-numeric input is given for <b>n</b> flagged queries.

        The input '<u>$input</u>' is ambiguous; it matches the following:
            Issued  in  response  to  <b>k</b>  flagged  queries  with input which matches more than one of the allowed
            keywords.

        The input '<u>$input</u>' fails to match any of the allowed keywords:
            Printed when input to a <b>k</b> flagged query does not match any of the keywords.

        The input '%s' matches a disallowed keyword '%s'.
            Printed when the input matches one of the unacceptable keywords given on a <b>K</b> flagged query.

        '%s' fails to match '%s'
            This results from input failing to match the regular expression given on a <b>m</b> flagged query.

        Input is %d characters too long; cannot exceed %d characters.
            The length of the input exceeded the maximum length given with the <b>l</b> flag argument.

        Please try again, or enter '?' for help.
        query: The k flag needs an array reference.
            The next argument in the argument list to <b>query</b> wasn't an array reference.

        query: The K flag needs an array reference.
            The next argument in the argumentlist to <b>query</b> wasn't an array reference.

</pre><h4><b>BUGS</b></h4><pre>
perl v5.34.0                                       2022-06-17                                         <u><a href="../man3pm/Query.3pm.html">Query</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>