<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web::Query - Yet another scraping library like jQuery</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libweb-query-perl">libweb-query-perl_1.01-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Web::Query - Yet another scraping library like jQuery

</pre><h4><b>VERSION</b></h4><pre>
       version 1.01

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Web::Query;

           wq('<a href="http://www.w3.org/TR/html401/">http://www.w3.org/TR/html401/</a>')
               -&gt;find('div.head dt')
               -&gt;each(sub {
                   my $i = shift;
                   printf("%d %s\n", $i+1, $_-&gt;text);
               });

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Web::Query is a yet another scraping framework, have a jQuery like interface.

       Yes, I know Ingy's pQuery. But it's just alpha quality. It doesn't work.  Web::Query built at top of the
       CPAN modules, HTML::TreeBuilder::XPath, LWP::UserAgent, and HTML::Selector::XPath.

       So, this module uses HTML::Selector::XPath and only supports the CSS 3 selector supported by that module.
       Web::Query doesn't support jQuery's extended queries(yet?). If a selector is passed as a scalar ref,
       it'll be taken as a straight XPath expression.

           $wq( '&lt;div&gt;&lt;p&gt;hello&lt;/p&gt;&lt;p&gt;there&lt;/p&gt;&lt;/div&gt;' )-&gt;find( 'p' );       # css selector
           $wq( '&lt;div&gt;&lt;p&gt;hello&lt;/p&gt;&lt;p&gt;there&lt;/p&gt;&lt;/div&gt;' )-&gt;find( \'/div/p' ); # xpath selector

       <b>THIS</b> <b>LIBRARY</b> <b>IS</b> <b>UNDER</b> <b>DEVELOPMENT.</b> <b>ANY</b> <b>API</b> <b>MAY</b> <b>CHANGE</b> <b>WITHOUT</b> <b>NOTICE</b>.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       wq($stuff)
           This is a shortcut for "Web::Query-&gt;new($stuff)". This function is exported by default.

</pre><h4><b>METHODS</b></h4><pre>
   <b>CONSTRUCTORS</b>
       my $q = Web::Query-&gt;new($stuff, \%options )
           Create new instance of Web::Query. You can make the instance from URL(http, https, file scheme), HTML
           in string, URL in string, URI object, "undef", and either one HTML::Element object or an array ref of
           them.

               # all valid creators
               $q = Web::Query-&gt;new( '<a href="http://techblog.babyl.ca">http://techblog.babyl.ca</a>' );
               $q = Web::Query-&gt;new( '&lt;p&gt;foo&lt;/p&gt;' );
               $q = Web::Query-&gt;new( undef );

           This method throw the exception on unknown $stuff.

           This method returns undefined value on non-successful response with URL.

           Currently, the only two valid options are <u>indent</u>, which will be used as the indentation string if the
           object  is  printed,  and  <u>no_space_compacting</u>,  which  will  prevent  the  compaction  of whitespace
           characters in text blocks.

       my $q = Web::Query-&gt;new_from_element($element: HTML::Element)
           Create new instance of Web::Query from instance of HTML::Element.

       "my $q = Web::Query-&gt;new_from_html($html: Str)"
           Create new instance of Web::Query from HTML.

       my $q = Web::Query-&gt;new_from_url($url: Str)
           Create new instance of Web::Query from URL.

           If the response is not success(It means /^20[0-9]$/), this method returns undefined value.

           You can get a last result of response, use the $Web::Query::RESPONSE.

           Here is a best practical code:

               my $url = '<a href="http://example.com/">http://example.com/</a>';
               my $q = Web::Query-&gt;new_from_url($url)
                   or die "Cannot get a resource from $url: " . Web::Query-&gt;last_response()-&gt;status_line;

       my $q = Web::Query-&gt;new_from_file($file_name: Str)
           Create new instance of Web::Query from file name.

   <b>TRAVERSING</b>
       <u>add</u>

       Returns a new object augmented with the new element(s).

       add($html)
           An HTML fragment to add to the set of matched elements.

       add(@elements)
           One or more @elements to add to the set of matched elements.

           @elements that already are part of the set are not added a second time.

               my $group = $wq-&gt;find('#foo');         # collection has 1 element
               $group = $group-&gt;add( '#bar', $wq );   # 2 elements
               $group-&gt;add( '#foo', $wq );            # still 2 elements

       add($wq)
           An existing Web::Query object to add to the set of matched elements.

       add($selector, $context)
           $selector is a string representing a selector expression to find additional elements to  add  to  the
           set of matched elements.

           $context is the point in the document at which the selector should begin matching

       <u>contents</u>

       Get  the  immediate  children  of each element in the set of matched elements, including text and comment
       nodes.

       <u>each</u>

       Visit each nodes. $i is a counter value, 0 origin. $elem is iteration item.  $_ is localized by $elem.

           $q-&gt;each(sub { my ($i, $elem) = @_; ... })

       <u>end</u>

       Back to the before context like jQuery.

       <u>filter</u>

       Reduce the elements to those that pass the function's test.

           $q-&gt;filter(sub { my ($i, $elem) = @_; ... })

       <u>find</u>

       Get the descendants of each element in the current set of matched elements, filtered by a selector.

           my $q2 = $q-&gt;find($selector); # $selector is a CSS3 selector.

       <b>NOTE</b> If you want to match the element itself, use "filter".

       <b>INCOMPATIBLE</b> <b>CHANGE</b> From v0.14 to v0.19 (inclusive) <b>find()</b> also matched the element itself, which is  not
       jQuery compatible.  You can achieve that result using filter(), add() and find():

           my $wq = wq('&lt;div class="foo"&gt;&lt;p class="foo"&gt;bar&lt;/p&gt;&lt;/div&gt;'); # needed because we don't have a global document like jQuery does
           print $wq-&gt;filter('.foo')-&gt;add($wq-&gt;find('.foo'))-&gt;as_html; # &lt;div class="foo"&gt;&lt;p class="foo"&gt;bar&lt;/p&gt;&lt;/div&gt;&lt;p class="foo"&gt;bar&lt;/p&gt;

       <u>first</u>

       Return the first matching element.

       This method constructs a new Web::Query object from the first matching element.

       <u>last</u>

       Return the last matching element.

       This method constructs a new Web::Query object from the last matching element.

       <u>match($selector)</u>

       Returns a boolean indicating if the elements match the $selector.

       In scalar context returns only the boolean for the first element.

       For the reverse of not(), see filter().

       <u>not($selector)</u>

       Returns all the elements not matching the $selector.

           # $do_for_love will be every thing, except #that
           my $do_for_love = $wq-&gt;find('thing')-&gt;not('#that');

       <u>and_back</u>

       Add the previous set of elements to the current one.

           # get the h1 plus everything until the next h1
           $wq-&gt;find('h1')-&gt;next_until('h1')-&gt;and_back;

       <u>map</u>

       Creates a new array with the results of calling a provided function on every element.

           $q-&gt;map(sub { my ($i, $elem) = @_; ... })

       <u>parent</u>

       Get the parent of each element in the current set of matched elements.

       <u>prev</u>

       Get the previous node of each element in the current set of matched elements.

           my $prev = $q-&gt;prev;

       <u>next</u>

       Get the next node of each element in the current set of matched elements.

          my $next = $q-&gt;next;

       <u>next_until(</u> <u>$selector</u> <u>)</u>

       Get all subsequent siblings, up to (but not including) the next node matched $selector.

   <b>MANIPULATION</b>
       <u>add_class</u>

       Adds the specified class(es) to each of the set of matched elements.

           # add class 'foo' to &lt;p&gt; elements
           wq('&lt;div&gt;&lt;p&gt;foo&lt;/p&gt;&lt;p&gt;bar&lt;/p&gt;&lt;/div&gt;')-&gt;find('p')-&gt;add_class('foo');

       <u>toggle_class(</u> <u>@classes</u> <u>)</u>

       Toggles  the  given class or classes on each of the element. I.e., if the element had the class, it'll be
       removed, and if it hadn't, it'll be added.

       Classes are toggled once, no matter how many times they appear in the argument list.

           $q-&gt;toggle_class( 'foo', 'foo', 'bar' );

           # equivalent to

           $q-&gt;toggle_class('foo')-&gt;toggle_class('bar');

           # and not

           $q-&gt;toggle_class('foo')-&gt;toggle_class('foo')-&gt;toggle_class('bar');

       <u>after</u>

       Insert content, specified by the parameter, after each element in the set of matched elements.

           wq('&lt;div&gt;&lt;p&gt;foo&lt;/p&gt;&lt;/div&gt;')-&gt;find('p')
                                      -&gt;after('&lt;b&gt;bar&lt;/b&gt;')
                                      -&gt;end
                                      -&gt;as_html; # &lt;div&gt;&lt;p&gt;foo&lt;/p&gt;&lt;b&gt;bar&lt;/b&gt;&lt;/div&gt;

       The content can be anything accepted by "new".

       <u>append</u>

       Insert content, specified by the parameter, to the end of each element in the set of matched elements.

           wq('&lt;div&gt;&lt;/div&gt;')-&gt;append('&lt;p&gt;foo&lt;/p&gt;')-&gt;as_html; # &lt;div&gt;&lt;p&gt;foo&lt;/p&gt;&lt;/div&gt;

       The content can be anything accepted by "new".

       <u>as_html</u>

       Returns the string representations of either the first or all elements, depending if called  in  list  or
       scalar context.

       If  given  an  argument  "join", the string representations of the elements will be concatenated with the
       given string.

           wq( '&lt;div&gt;&lt;p&gt;foo&lt;/p&gt;&lt;p&gt;bar&lt;/p&gt;&lt;/div&gt;' )
               -&gt;find('p')
               -&gt;as_html( join =&gt; '!' );
           # &lt;p&gt;foo&lt;/p&gt;!&lt;p&gt;bar&lt;/p&gt;

       <u>"</u> <u>attr</u> <u>"</u>

       Get/set attribute values.

       In getter mode, it'll return either the values of the attribute for all elements of the set, or only  the
       first one depending of the calling context.

           my @values = $q-&gt;attr('style');      # style of all elements
           my $first_value = $q-&gt;attr('style'); # style of first element

       In setter mode, it'll set attributes value for all elements, and return back the original object for easy
       chaining.

           $q-&gt;attr( 'alt' =&gt; 'a picture' )-&gt;find( ... );

           # can pass more than 1 element too
           $q-&gt;attr( alt =&gt; 'a picture', src =&gt; 'file:///...' );

       The value passed for an attribute can be a code ref. In that case, the code will be called with $_ set to
       the current attribute value.  If the code modifies $_, the attribute will be updated with the new value.

           $q-&gt;attr( alt =&gt; sub { $_ ||= 'A picture' } );

       <u>"</u> <u>id</u> <u>"</u>

       Get/set the elements's id attribute.

       In getter mode, it behaves just like attr().

       In setter mode, it behaves like attr(), but with the following exceptions.

       If  the  attribute  value is a scalar, it'll be only assigned to the first element of the set (as ids are
       supposed to be unique), and the returned object will only contain that first element.

           my $first_element = $q-&gt;id('the_one');

       It's possible to set the ids of all the elements by passing a sub to id(). The  sub  is  given  the  same
       arguments as for each(), and its return value is taken to be the new id of the elements.

           $q-&gt;id( sub { my $i = shift;  'foo_' . $i } );

       <u>"</u> <u>name</u> <u>"</u>

       Get/set the elements's 'name' attribute.

           my $name = $q-&gt;name;  # equivalent to $q-&gt;attr( 'name' );

           $q-&gt;name( 'foo' );    # equivalent to $q-&gt;attr( name =&gt; 'foo' );

       <u>"</u> <u>data</u> <u>"</u>

       Get/set the elements's 'data-*name*' attributes.

           my $data = $q-&gt;data('foo');  # equivalent to $q-&gt;attr( 'data-foo' );

           $q-&gt;data( 'foo' =&gt; 'bar' );  # equivalent to $q-&gt;attr( 'data-foo' =&gt; 'bar' );

       <u>tagname</u>

       Get/Set the tag name of elements.

           my $name = $q-&gt;tagname;

           $q-&gt;tagname($new_name);

       <u>before</u>

       Insert content, specified by the parameter, before each element in the set of matched elements.

           wq('&lt;div&gt;&lt;p&gt;foo&lt;/p&gt;&lt;/div&gt;')-&gt;find('p')
                                      -&gt;before('&lt;b&gt;bar&lt;/b&gt;')
                                      -&gt;end
                                      -&gt;as_html; # &lt;div&gt;&lt;b&gt;bar&lt;/b&gt;&lt;p&gt;foo&lt;/p&gt;&lt;/div&gt;

       The content can be anything accepted by "new".

       <u>clone</u>

       Create a deep copy of the set of matched elements.

       <u>detach</u>

       Remove the set of matched elements from the DOM.

       <u>has_class</u>

       Determine whether any of the matched elements are assigned the given class.

       <u>"</u> <u>html</u> <u>"</u>

       Get/Set the innerHTML.

           my @html = $q-&gt;html();

           my $html = $q-&gt;html(); # 1st matching element only

           $q-&gt;html('&lt;p&gt;foo&lt;/p&gt;');

       <u>insert_before</u>

       Insert every element in the set of matched elements before the target.

       <u>insert_after</u>

       Insert every element in the set of matched elements after the target.

       <u>"</u> <u>prepend</u> <u>"</u>

       Insert  content,  specified  by  the  parameter,  to  the beginning of each element in the set of matched
       elements.

       <u>remove</u>

       Delete the elements associated with the object from the DOM.

           # remove all &lt;blink&gt; tags from the document
           $q-&gt;find('blink')-&gt;remove;

       <u>remove_class</u>

       Remove a single class, multiple classes, or all classes from each element in the set of matched elements.

       <u>replace_with</u>

       Replace the elements of the object with the provided replacement.  The replacement can  be  a  string,  a
       "Web::Query"  object  or an anonymous function. The anonymous function is passed the index of the current
       node and the node itself (with is also localized as $_).

           my $q = wq( '&lt;p&gt;&lt;b&gt;Abra&lt;/b&gt;&lt;i&gt;cada&lt;/i&gt;&lt;u&gt;bra&lt;/u&gt;&lt;/p&gt;' );

           $q-&gt;find('b')-&gt;replace_with('&lt;a&gt;Ocus&lt;/a&gt;);
               # &lt;p&gt;&lt;a&gt;Ocus&lt;/a&gt;&lt;i&gt;cada&lt;/i&gt;&lt;u&gt;bra&lt;/u&gt;&lt;/p&gt;

           $q-&gt;find('u')-&gt;replace_with($q-&gt;find('b'));
               # &lt;p&gt;&lt;i&gt;cada&lt;/i&gt;&lt;b&gt;Abra&lt;/b&gt;&lt;/p&gt;

           $q-&gt;find('i')-&gt;replace_with(sub{
               my $name = $_-&gt;text;
               return "&lt;$name&gt;&lt;/$name&gt;";
           });
               # &lt;p&gt;&lt;b&gt;Abra&lt;/b&gt;&lt;cada&gt;&lt;/cada&gt;&lt;u&gt;bra&lt;/u&gt;&lt;/p&gt;

       <u>size</u>

       Return the number of elements in the Web::Query object.

           wq('&lt;div&gt;&lt;p&gt;foo&lt;/p&gt;&lt;p&gt;bar&lt;/p&gt;&lt;/div&gt;')-&gt;find('p')-&gt;size; # 2

       <u>text</u>

       Get/Set the text.

           my @text = $q-&gt;text();

           my $text = $q-&gt;text(); # 1st matching element only

           $q-&gt;text('text');

       If called in a scalar context, only return the string representation of the first element

   <b>OTHERS</b>
       Web::Query-&gt;<b>last_response()</b>
           Returns last HTTP response status that generated by new_from_url().

</pre><h4><b>HOW</b> <b>DO</b> <b>I</b> <b>CUSTOMIZE</b> <b>USER</b> <b>AGENT?</b></h4><pre>
       You can specify your own instance of LWP::UserAgent.

           $Web::Query::UserAgent = LWP::UserAgent-&gt;new( agent =&gt; 'Mozilla/5.0' );

</pre><h4><b>FAQ</b> <b>AND</b> <b>TROUBLESHOOTING</b></h4><pre>
   <b>How</b> <b>to</b> <b>find</b> <b>XML</b> <b>processing</b> <b>instructions</b> <b>in</b> <b>a</b> <b>document?</b>
       It's possible with Web::Query::LibXML and by using an xpath expression with find():

           # find &lt;?xml-stylesheet ... ?&gt;
           $q-&gt;find(\"//processing-instruction('xml-stylesheet')");

       However, note that the support for processing instructions in HTML::TreeBuilder::LibXML::Node is sketchy,
       so there are methods like attr() that won't work.

   <b>Can't</b> <b>get</b> <b>the</b> <b>content</b> <b>of</b> <b>script</b> <b>elements</b>
       The &lt;script&gt; tag is treated differently by HTML::TreeBuilder, the parser used by Web::Query. To  retrieve
       the  content, you can use either the method html() (with the caveat that the content will be escaped), or
       use Web::Query::LibXML, which parse the 'script' element differently.

           my $node = "&lt;script&gt;var x = '&lt;p&gt;foo&lt;/p&gt;';&lt;/script&gt;";

           say Web::Query::wq( $node )-&gt;text;
               # nothing is printed!

           say Web::Query::wq( $node )-&gt;html;
               # var x = &amp;#39;&amp;lt;p&amp;gt;foo&amp;lt;/p&amp;gt;&amp;#39;;

           say Web::Query::LibXML::wq( $node )-&gt;text;
               # var x = '&lt;p&gt;foo&lt;/p&gt;';

           say Web::Query::LibXML::wq( $node )-&gt;html;
               # var x = '&amp;lt;p&amp;gt;foo&amp;lt;/p&amp;gt;';

</pre><h4><b>INCOMPATIBLE</b> <b>CHANGES</b></h4><pre>
       0.10
           <b>new_from_url()</b> is no longer throws exception on bad response from HTTP server.

</pre><h4><b>AUTHOR</b></h4><pre>
       Tokuhiro Matsuno &lt;tokuhirom AAJKLFJEF@ GMAIL COM&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       pQuery
       XML::LibXML::jQuery

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright (C) Tokuhiro Matsuno

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

</pre><h4><b>BUGS</b></h4><pre>
       Please     report     any     bugs     or     feature     requests     on    the    bugtracker    website
       &lt;https://github.com/tokuhirom/Web-Query/issues&gt;

       When submitting a bug or request, please include a test-file or a patch to  an  existing  test-file  that
       illustrates the bug or desired feature.

perl v5.38.2                                       2024-01-20                                    <u>Web::<a href="../man3pm/Query.3pm.html">Query</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>