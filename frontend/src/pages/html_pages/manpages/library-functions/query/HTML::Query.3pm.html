<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::Query - jQuery-like selection queries for HTML::Element</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-query-perl">libhtml-query-perl_0.09-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::Query - jQuery-like selection queries for HTML::Element

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Creating an "HTML::Query" object using the <b>Query()</b> constructor subroutine:

           use HTML::Query 'Query';

           # using named parameters
           $q = Query( text  =&gt; $text  );          # HTML text
           $q = Query( file  =&gt; $file  );          # HTML file
           $q = Query( tree  =&gt; $tree  );          # HTML::Element object
           $q = Query( query =&gt; $query );          # HTML::Query object
           $q = Query(
               text  =&gt; $text1,                    # or any combination
               text  =&gt; $text2,                    # of the above
               file  =&gt; $file1,
               file  =&gt; $file2,
               tree  =&gt; $tree,
               query =&gt; $query,
           );

           # passing elements as positional arguments
           $q = Query( $tree );                    # HTML::Element object(s)
           $q = Query( $tree1, $tree2, $tree3, ... );

           # or from one or more existing queries
           $q = Query( $query1 );                  # HTML::Query object(s)
           $q = Query( $query1, $query2, $query3, ... );

           # or a mixture
           $q = Query( $tree1, $query1, $tree2, $query2 );

           # the final argument (in all cases) can be a selector
           my $spec = 'ul.menu li a';              # &lt;ul class="menu"&gt;..&lt;li&gt;..&lt;a&gt;

           $q = Query( $tree, $spec );
           $q = Query( $query, $spec );
           $q = Query( $tree1, $tree2, $query1, $query2, $spec );
           $q = Query( text  =&gt; $text,  $spec );
           $q = Query( file  =&gt; $file,  $spec );
           $q = Query( tree  =&gt; $tree,  $spec );
           $q = Query( query =&gt; $query, $spec );
           $q = Query(
               text =&gt; $text,
               file =&gt; $file,
               # ...etc...
               $spec
           );

       Or using the OO <b>new()</b> constructor method (which the <b>Query()</b> subroutine maps onto):

           use HTML::Query;

           $q = HTML::Query-&gt;new(
               # accepts the same arguments as Query()
           )

       Or by monkey-patching a <b>query()</b> method into HTML::Element.

           use HTML::Query 'query';                # note lower case 'q'
           use HTML::TreeBuilder;

           # build a tree
           my $tree = HTML::TreeBuilder-&gt;new;
           $tree-&gt;parse_file($filename);

           # call the query() method on any element
           my $query = $tree-&gt;query($spec);

       Once you have a query, you can start selecting elements:

           @r = $q-&gt;query('a')-&gt;get_elements();            # all &lt;a&gt;...&lt;/a&gt; elements
           @r = $q-&gt;query('a#menu')-&gt;get_elements();       # all &lt;a&gt; with "menu" id
           @r = $q-&gt;query('#menu')-&gt;get_elements();        # all elements with "menu" id
           @r = $q-&gt;query('a.menu')-&gt;get_elements();       # all &lt;a&gt; with "menu" class
           @r = $q-&gt;query('.menu')-&gt;get_elements();        # all elements with "menu" class
           @r = $q-&gt;query('a[href]')-&gt;get_elements();      # all &lt;a&gt; with 'href' attr
           @r = $q-&gt;query('a[href=foo]')-&gt;get_elements();  # all &lt;a&gt; with 'href="foo"' attr

           # you can specify elements within elements...
           @r = $q-&gt;query('ul.menu li a')-&gt;get_elements(); # &lt;ul class="menu"&gt;...&lt;li&gt;...&lt;a&gt;

           # and use commas to delimit multiple path specs for different elements
           @r = $q-&gt;query('table tr td a, form input[type=submit]')-&gt;get_elements();

           # query() in scalar context returns a new query
           $r = $q-&gt;query('table')-&gt;get_elements();;       # find all tables
           $s = $r-&gt;query('tr')-&gt;get_elements();           # find all rows in all those tables
           $t = $s-&gt;query('td')-&gt;get_elements();           # and all cells in those rows...

       Inspecting query elements:

           # get number of elements in query
           my $size  = $q-&gt;size

           # get first/last element in query
           my $first = $q-&gt;first;
           my $last  = $q-&gt;last;

           # convert query to list or list ref of HTML::Element objects
           my $list = $q-&gt;list;            # list ref in scalar context
           my @list = $q-&gt;list;            # list in list context

       All other methods are mapped onto the HTML::Element objects in the query:

           print $query-&gt;as_trimmed_text;  # print trimmed text for each element
           print $query-&gt;as_HTML;          # print each element as HTML
           $query-&gt;delete;                 # call delete() on each element

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The "HTML::Query" module is an add-on for the HTML::Tree module set. It provides a simple way to select
       one or more elements from a tree using a query syntax inspired by jQuery. This selector syntax will be
       reassuringly familiar to anyone who has ever written a CSS selector.

       "HTML::Query" is not an attempt to provide a complete (or even near-complete) implementation of jQuery in
       Perl (see Ingy's pQuery module for a more ambitious attempt at that). Rather, it borrows some of the
       tried and tested selector syntax from jQuery (and CSS) that can easily be mapped onto the "look_down()"
       method provided by the HTML::Element module.

   <b>Creating</b> <b>a</b> <b>Query</b>
       The easiest way to create a query is using the exportable <b>Query()</b> subroutine.

           use HTML::Query 'Query';        # note capital 'Q'

       It accepts a "text" or "file" named parameter and will create an "HTML::Query" object from the HTML
       source text or file, respectively.

           my $query = Query( text =&gt; $text );
           my $query = Query( file =&gt; $file );

       This delegates to HTML::TreeBuilder to parse the HTML into a tree of HTML::Element objects.  The root
       element returned is then wrapped in an "HTML::Query" object.

       If you already have one or more HTML::Element objects that you want to query then you can pass them to
       the <b>Query()</b> subroutine as arguments. For example, you can explicitly use HTML::TreeBuilder to parse an
       HTML document into a tree:

           use HTML::TreeBuilder;
           my $tree = HTML::TreeBuilder-&gt;new;
           $tree-&gt;parse_file($filename);

       And then create an "HTML::Query" object for the tree either using an explicit "tree" named parameter:

           my $query = Query( tree =&gt; $tree );

       Or implicitly using positional arguments.

           my $query = Query( $tree );

       If you want to query across multiple elements, then pass each one as a positional argument.

           my $query = Query( $tree1, $tree2, $tree3 );

       You can also create a new query from one or more existing queries,

           my $query = Query( query =&gt; $query );   # named parameter
           my $query = Query( $query1, $query2 );  # positional arguments.

       You can mix and match these different parameters and positional arguments to create a query across
       several different sources.

           $q = Query(
               text  =&gt; $text1,
               text  =&gt; $text2,
               file  =&gt; $file1,
               file  =&gt; $file2,
               tree  =&gt; $tree,
               query =&gt; $query,
           );

       The <b>Query()</b> subroutine is a simple wrapper around the <b>new()</b> constructor method. You can instantiate your
       objects manually if you prefer.  The <b>new()</b> method accepts the same arguments as for the <b>Query()</b>
       subroutine (in fact, the <b>Query()</b> subroutine simply forwards all arguments to the <b>new()</b> method).

           use HTML::Query;

           my $query = HTML::Query-&gt;new(
               # same argument format as for Query()
           );

       A final way to use "HTML::Query" is to have it add a <b>query()</b> method to HTML::Element.  The "query" import
       hook (all lower case) can be specified to make this so.

           use HTML::Query 'query';                # note lower case 'q'
           use HTML::TreeBuilder;

           my $tree = HTML::TreeBuilder-&gt;new;
           $tree-&gt;parse_file($filename);

           # now all HTML::Elements have a query() method
           my @items = $tree-&gt;query('ul li')-&gt;get_elements();  # find all list items

       This approach, often referred to as <u>monkey-patching</u>, should be used carefully and sparingly. It involves
       a violation of HTML::Element's namespace that could have unpredictable results with a future version of
       the module (e.g. one which defines its own "query()" method that does something different). Treat it as
       something that is great to get a quick job done right now, but probably not something to be used in
       production code without careful consideration of the implications.

   <b>Selecting</b> <b>Elements</b>
       Having created an "HTML::Query" object by one of the methods outlined above, you can now fetch descendant
       elements in the tree using a simple query syntax.  For example, to fetch all the "&lt;a&gt;" elements in the
       tree, you can write:

           @links = $query-&gt;query('a')-&gt;get_elements();

       Or, if you want the elements that have a specific "class" attribute defined with a value of, say "menu",
       you can write:

           @links = $query-&gt;query('a.menu')-&gt;get_elements();

       More generally, you can look for the existence of any attribute and optionally provide a specific value
       for it.

           @links = $query-&gt;query('a[href]')-&gt;get_elements();            # any href attribute
           @links = $query-&gt;query('a[href=index.html]')-&gt;get_elements(); # specific value

       You can also find an element (or elements) by specifying an id.

           @links = $query-&gt;query('#menu')-&gt;get_elements();         # any element with id="menu"
           @links = $query-&gt;query('ul#menu')-&gt;get_elements();       # ul element with id="menu"

       You can provide multiple selection criteria to find elements within elements within elements, and so on.
       For example, to find all links in a menu, you can write:

           # matches: &lt;ul class="menu"&gt; &lt;li&gt; &lt;a&gt;
           @links = $query-&gt;query('ul.menu li a')-&gt;get_elements();

       You can separate different criteria using commas.  For example, to fetch all table rows and "span"
       elements with a "foo" class:

           @elems = $query-&gt;('table tr, span.foo')-&gt;get_elements();

   <b>Query</b> <b>Results</b>
       When called in list context, as shown in the examples above, the <b>query()</b> method returns a list of
       HTML::Element objects matching the search criteria. In scalar context, the <b>query()</b> method returns a new
       "HTML::Query" object containing the HTML::Element objects found. You can then call the <b>query()</b> method
       against that object to further refine the query. The <b>query()</b> method applies the selection to all elements
       stored in the query.

           my $tables = $query-&gt;query('table');             # query for tables
           my $rows   = $tables-&gt;query('tr');               # requery for all rows in those tables
           my $cells  = $rows-&gt;query('td')-&gt;get_elements(); # return back all the cells in those rows

   <b>Inspection</b> <b>Methods</b>
       The <b>size()</b> method returns the number of elements in the query. The <b>first()</b> and <b>last()</b> methods return the
       first and last items in the query, respectively.

           if ($query-&gt;size) {
               print "from ", $query-&gt;first-&gt;as_trimmed_text, " to ", $query-&gt;last-&gt;as_trimmed_text;
           }

       If you want to extract the HTML::Element objects from the query you can call the <b>list()</b> method. This
       returns a list of HTML::Element objects in list context, or a reference to a list in scalar context.

           @elems = $query-&gt;list;
           $elems = $query-&gt;list;

   <b>Element</b> <b>Methods</b>
       Any other methods are automatically applied to each element in the list. For example, to call the
       "as_trimmed_text()" method on all the HTML::Element objects in the query, you can write:

           print $query-&gt;as_trimmed_text;

       In list context, this method returns a list of the return values from calling the method on each element.
       In scalar context it returns a reference to a list of return values.

           @text_blocks = $query-&gt;as_trimmed_text;
           $text_blocks = $query-&gt;as_trimmed_text;

       See HTML::Element for further information on the methods it provides.

</pre><h4><b>QUERY</b> <b>SYNTAX</b></h4><pre>
   <b>Basic</b> <b>Selectors</b>
       <u>element</u>

       Matches all elements of a particular type.

           @elems = $query-&gt;query('table')-&gt;get_elements();     # &lt;table&gt;

       <u>#id</u>

       Matches all elements with a specific id attribute.

           @elems = $query-&gt;query('#menu')-&gt;get_elements()     # &lt;ANY id="menu"&gt;

       This can be combined with an element type:

           @elems = $query-&gt;query('ul#menu')-&gt;get_elements();  # &lt;ul id="menu"&gt;

       <u>.class</u>

       Matches all elements with a specific class attribute.

           @elems = $query-&gt;query('.info')-&gt;get_elements();     # &lt;ANY class="info"&gt;

       This can be combined with an element type and/or element id:

           @elems = $query-&gt;query('p.info')-&gt;get_elements();     # &lt;p class="info"&gt;
           @elems = $query-&gt;query('p#foo.info')-&gt;get_elements(); # &lt;p id="foo" class="info"&gt;
           @elems = $query-&gt;query('#foo.info')-&gt;get_elements();  # &lt;ANY id="foo" class="info"&gt;

       The selectors listed above can be combined in a whitespace delimited sequence to select down through a
       hierarchy of elements.  Consider the following table:

           &lt;table class="search"&gt;
             &lt;tr class="result"&gt;
               &lt;td class="value"&gt;WE WANT THIS ELEMENT&lt;/td&gt;
             &lt;/tr&gt;
             &lt;tr class="result"&gt;
               &lt;td class="value"&gt;AND THIS ONE&lt;/td&gt;
             &lt;/tr&gt;
             ...etc..
           &lt;/table&gt;

       To locate the cells that we're interested in, we can write:

           @elems = $query-&gt;query('table.search tr.result td.value')-&gt;get_elements();

   <b>Attribute</b> <b>Selectors</b>
       W3C CSS 2 specification defines new constructs through which to select based on specific attributes
       within elements. See the following link for the spec:
       &lt;<a href="http://www.w3.org/TR/css3-selectors/">http://www.w3.org/TR/css3-selectors/</a>#attribute-selectors&gt;

       <u>[attr]</u>

       Matches elements that have the specified attribute, including any where the attribute has no value.

           @elems = $query-&gt;query('[href]')-&gt;get_elements();        # &lt;ANY href="..."&gt;

       This can be combined with any of the above selectors.  For example:

           @elems = $query-&gt;query('a[href]')-&gt;get_elements();       # &lt;a href="..."&gt;
           @elems = $query-&gt;query('a.menu[href]')-&gt;get_elements();  # &lt;a class="menu" href="..."&gt;

       You can specify multiple attribute selectors.  Only those elements that match <u>all</u> of them will be
       selected.

           @elems = $query-&gt;query('a[href][rel]')-&gt;get_elements();  # &lt;a href="..." rel="..."&gt;

       <u>[attr=value]</u>

       Matches elements that have an attribute set to a specific value.  The value can be quoted in either
       single or double quotes, or left unquoted.

           @elems = $query-&gt;query('[href=index.html]')-&gt;get_elements();
           @elems = $query-&gt;query('[href="index.html"]')-&gt;get_elements();
           @elems = $query-&gt;query("[href='index.html']")-&gt;get_elements();

       You can specify multiple attribute selectors.  Only those elements that match <u>all</u> of them will be
       selected.

           @elems = $query-&gt;query('a[href=index.html][rel=home]')-&gt;get_elements();

       <u>[attr|=value]</u>

       Matches any element X whose foo attribute has a hyphen-separated list of values beginning (from the left)
       with bar. The value can be quoted in either single or double quotes, or left unquoted.

           @elems = $query-&gt;query('[lang|=en]')-&gt;get_elements();
           @elems = $query-&gt;query('p[class|="example"]')-&gt;get_elements();
           @elems = $query-&gt;query("img[alt|='fig']")-&gt;get_elements();

       You can specify multiple attribute selectors.  Only those elements that match <u>all</u> of them will be
       selected.

           @elems = $query-&gt;query('p[class|="external"][lang|="en"]')-&gt;get_elements();

       <u>[attr~=value]</u>

       Matches any element X whose foo attribute value is a list of space-separated values, one of which is
       exactly equal to bar. The value can be quoted in either single or double quotes, or left unquoted.

           @elems = $query-&gt;query('[lang~=en]')-&gt;get_elements();
           @elems = $query-&gt;query('p[class~="example"]')-&gt;get_elements();
           @elems = $query-&gt;query("img[alt~='fig']")-&gt;get_elements();

       You can specify multiple attribute selectors.  Only those elements that match <u>all</u> of them will be
       selected.

           @elems = $query-&gt;query('p[class~="external"][lang~="en"]')-&gt;get_elements();

       KNOWN BUG: you can't have a "]" character in the attribute value because it confuses the query parser.
       Fixing this is TODO.

   <b>Universal</b> <b>Selector</b>
       W3C CSS 2 specification defines a new construct through which to select any element within the document
       below a given hierarchy.

       <a href="http://www.w3.org/TR/css3-selectors/">http://www.w3.org/TR/css3-selectors/</a>#universal-selector

         @elems = $query-&gt;query('*')-&gt;get_elements();

   <b>Combinator</b> <b>Selectors</b>
       W3C CSS 2 specification defines new constructs through which to select based on hierarchy with the DOM.
       See the following link for the spec: &lt;<a href="http://www.w3.org/TR/css3-selectors/">http://www.w3.org/TR/css3-selectors/</a>#combinators&gt;

       <u>Immediate</u> <u>Descendents</u> <u>(children)</u>

       When you combine selectors with whitespace elements are selected if they are descended from the parent in
       some way. But if you just want to select the children (and not the grandchildren, great-grandchildren,
       etc) then you can combine the selectors with the "&gt;" character.

        @elems = $query-&gt;query('a &gt; img')-&gt;get_elements();

       <u>Non-Immediate</u> <u>Descendents</u>

       If you just want any descendents that aren't children then you can combine selectors with the "*"
       character.

        @elems = $query-&gt;query('div * a')-&gt;get_elements();

       <u>Immediate</u> <u>Siblings</u>

       If you want to use a sibling relationship then you can can join selectors with the "+" character.

        @elems = $query-&gt;query('img + span')-&gt;get_elements();

   <b>Pseudo-classes</b>
       W3C CSS 2 and CSS 3 specifications define new concepts of pseudo-classes to permit formatting based on
       information that lies outside the document tree.  See the following link for the most recent spec:
       &lt;<a href="http://www.w3.org/TR/css3-selectors/">http://www.w3.org/TR/css3-selectors/</a>#pseudo-classes&gt;

       HTML::Query currently has limited support for CSS 2, and no support for CSS 3.

       Patches are *highly* encouraged to help add support here.

       <u>-child</u> <u>pseudo-classes</u>

       If you want to return child elements within a certain position then -child pseudo-classes (:first-child,
       :last-child) are what you're looking for.

        @elems = $query-&gt;query('table td:first-child')-&gt;get_elements;

       <u>Link</u> <u>pseudo-classes:</u> <u>:link</u> <u>and</u> <u>:visited</u>

       Unsupported.

       The :link pseudo-class is to be implemented, currently unsupported.

       It is not possible to locate :visited outside of a browser context due to it's dynamic nature.

       <u>Dynamic</u> <u>pseudo-classes</u>

       Unsupported.

       It is not possible to locate these classes(:hover, :active, :focus) outside of a browser context due to
       their dynamic nature.

       <u>Language</u> <u>pseudo-class</u>

       Unsupported.

       Functionality for the :lang pseudo-class is largely replicated by using an attribute selector for lang
       combined with a universal selector query.

       If this is insufficient I'd love to see a patch adding support for it.

       <u>Other</u> <u>pseudo-classes</u>

       W3C CSS 3 added a number of new behaviors that need support. At this time there is no support for them,
       but we should work on adding support.

       Patches are very welcome.

   <b>Pseudo-elements</b>
       W3C CSS 2 and CSS 3 specification defines new concepts of pseudo-elements to permit formatting based on
       information that lies outside the document tree.  See the following link for the most recent spec:
       &lt;<a href="http://www.w3.org/TR/css3-selectors/">http://www.w3.org/TR/css3-selectors/</a>#pseudo-elements&gt;

       At this time there is no support for pseudo-elements, but we are working on adding support.

       Patches are very welcome.

   <b>Combining</b> <b>Selectors</b>
       You can combine basic and hierarchical selectors into a single query by separating each part with a
       comma.  The query will select all matching elements for each of the comma-delimited selectors.  For
       example, to find all "a", "b" and "i" elements in a tree:

           @elems = $query-&gt;query('a, b, i')-&gt;get_elements();

       Each of these selectors can be arbitrarily complex.

           @elems = $query-&gt;query(
               'table.search[width=100%] tr.result[valign=top] td.value,
                form.search input[type=submit],
                a[href=index.html]'
           )-&gt;get_elements();

</pre><h4><b>EXPORT</b> <b>HOOKS</b></h4><pre>
   <b>Query</b>
       The "Query()" constructor subroutine (note the capital letter) can be exported as a convenient way to
       create "HTML::Query" objects. It simply forwards all arguments to the <b>new()</b> constructor method.

           use HTML::Query 'Query';

           my $query = Query( file =&gt; $file, 'ul.menu li a' );

   <b>query</b>
       The "query()" export hook can be called to monkey-patch a <b>query()</b> method into the HTML::Element module.

       This is considered questionable behaviour in polite society which regards it as a violation of the inner
       sanctity of the HTML::Element.

       But if you're the kind of person that doesn't mind a bit of occasional namespace abuse for the sake of
       getting the job done, then go right ahead.  Just don't blame me if it all blows up later.

           use HTML::Query 'query';                # note lower case 'q'
           use HTML::TreeBuilder;

           # build a tree
           my $tree = HTML::TreeBuilder-&gt;new;
           $tree-&gt;parse_file($filename);

           # call the query() method on any element
           my $query = $tree-&gt;query('ul li a');

</pre><h4><b>METHODS</b></h4><pre>
       The "HTML::Query" object is a subclass of Badger::Base and inherits all of its method.

   <b>new(@elements,$selector)</b>
       This constructor method is used to create a new "HTML::Query" object. It expects a list of any number
       (including zero) of HTML::Element or "HTML::Query" objects.

           # single HTML::Element object
           my $query = HTML::Query-&gt;new($elem);

           # multiple element object
           my $query = HTML::Query-&gt;new($elem1, $elem2, $elem3, ...);

           # copy elements from an existing query
           my $query = HTML::Query-&gt;new($another_query);

           # copy elements from several queries
           my $query = HTML::Query-&gt;new($query1, $query2, $query3);

           # or a mixture
           my $query = HTML::Query-&gt;new($elem1, $query1, $elem2, $query3);

       You can also use named parameters to specify an alternate source for a element.

           $query = HTML::Query-&gt;new( file =&gt; $file );
           $query = HTML::Query-&gt;new( text =&gt; $text );

       In this case, the HTML::TreeBuilder module is used to parse the source file or text into a tree of
       HTML::Element objects.

       For the sake of completeness, you can also specify element trees and queries using named parameters:

           $query = HTML::Query-&gt;new( tree  =&gt; $tree );
           $query = HTML::Query-&gt;new( query =&gt; $query );

       You can freely mix and match elements, queries and named sources.  The query will be constructed as an
       aggregate across them all.

           $q = HTML::Query-&gt;new(
               text  =&gt; $text1,
               text  =&gt; $text2,
               file  =&gt; $file1,
               file  =&gt; $file2,
               tree  =&gt; $tree,
               query =&gt; $query1,
           );

       The final, optional argument can be a selector specification.  This is immediately passed to the <b>query()</b>
       method which will return a new query with only those elements selected.

           my $spec = 'ul.menu li a';              # &lt;ul class="menu"&gt;..&lt;li&gt;..&lt;a&gt;

           my $query = HTML::Query-&gt;new( $tree, $spec );
           my $query = HTML::Query-&gt;new( text =&gt; $text, $spec );
           my $query = HTML::Query-&gt;new(
               text =&gt; $text,
               file =&gt; $file,
               $spec
           );

       The list of arguments can also be passed by reference to a list.

           my $query = HTML::Query-&gt;new(\@args);

   <b>query($spec)</b>
       This method locates the descendant elements identified by the $spec argument for each element in the
       query. It then internally stores the results for requerying or return. See <b>get_elements()</b>.

           my $query = HTML::Query-&gt;new(\@args);
           my $results = $query-&gt;query($spec);

       See "QUERY SYNTAX" for the permitted syntax of the $spec argument.

   <b>get_elements()</b>
       This method returns the stored results from a query. In list context it returns a list of matching
       HTML::Element objects. In scalar context it returns a reference to the results array.

           my $query = HTML::Query-&gt;new(\@args);
           my $results = $query-&gt;query($spec);

           my @elements  = $results-&gt;query($spec)-&gt;get_elements();
           my $elements  = $results-&gt;query($spec)-&gt;get_elements();

   <b>get_specificity()</b>
       Calculate the specificity for any given passed selector, a critical factor in determining how best to
       apply the cascade

       A selector's specificity is calculated as follows:

       * count the number of ID attributes in the selector (= a) * count the number of other attributes and
       pseudo-classes in the selector (= b) * count the number of element names in the selector (= c) * ignore
       pseudo-elements.

       The specificity is based only on the form of the selector. In particular, a selector of the form
       "[id=p33]" is counted as an attribute selector (a=0, b=0, c=1, d=0), even if the id attribute is defined
       as an "ID" in the source document's DTD.

       See the following spec for additional details: &lt;<a href="http://www.w3.org/TR/CSS21/cascade.html">http://www.w3.org/TR/CSS21/cascade.html</a>#specificity&gt;

   <b>size()</b>
       Returns the number of elements in the query.

   <b>first()</b>
       Returns the first element in the query.

           my $elem = $query-&gt;first;

       If the query is empty then an exception will be thrown. If you would rather have an undefined value
       returned then you can use the "try" method inherited from Badger::Base. This effectively wraps the call
       to "first()" in an "eval" block to catch any exceptions thrown.

           my $elem = $query-&gt;try('first') || warn "no first element\n";

   <b>last()</b>
       Similar to <b>first()</b>, but returning the last element in the query.

           my $elem = $query-&gt;last;

   <b>list()</b>
       Returns a list of the HTML::Element object in the query in list context, or a reference to a list in
       scalar context.

           my @elems = $query-&gt;list;
           my $elems = $query-&gt;list;

   <b>AUTOLOAD</b>
       The "AUTOLOAD" method maps any other method calls to the HTML::Element objects in the list. When called
       in list context it returns a list of the values returned from calling the method on each element. In
       scalar context it returns a reference to a list of return values.

           my @text_blocks = $query-&gt;as_trimmed_text;
           my $text_blocks = $query-&gt;as_trimmed_text;

</pre><h4><b>KNOWN</b> <b>BUGS</b></h4><pre>
   <b>Attribute</b> <b>Values</b>
       It is not possible to use "]" in an attribute value.  This is due to a limitation in the parser which
       will be fixed RSN.

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Wardley &lt;<a href="http://wardley.org">http://wardley.org</a>&gt;

</pre><h4><b>MAINTAINER</b></h4><pre>
       Kevin Kamel &lt;<a href="mailto:kamelkev@mailermailer.com">kamelkev@mailermailer.com</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       Vivek Khera &lt;<a href="mailto:vivek@khera.org">vivek@khera.org</a>&gt; Michael Peters &lt;<a href="mailto:wonko@cpan.org">wonko@cpan.org</a>&gt; David Gray &lt;<a href="mailto:cpan@doesntsuck.com">cpan@doesntsuck.com</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2010 Andy Wardley.  All Rights Reserved.

       This module is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       HTML::Tree, HTML::Element, HTML::TreeBuilder, pQuery, &lt;<a href="http://jQuery.com/">http://jQuery.com/</a>&gt;

perl v5.36.0                                       2023-08-02                                   <u>HTML::<a href="../man3pm/Query.3pm.html">Query</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>