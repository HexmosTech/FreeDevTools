<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::ParseWords - parse text into an array of tokens or array of arrays</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::ParseWords - parse text into an array of tokens or array of arrays

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Text::ParseWords;
         @lists = nested_quotewords($delim, $keep, @lines);
         @words = quotewords($delim, $keep, @lines);
         @words = shellwords(@lines);
         @words = parse_line($delim, $keep, $line);
         @words = old_shellwords(@lines); # DEPRECATED!

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The nested_quotewords() and quotewords() functions accept a delimiter (which can be a regular expression)
       and a list of lines and then breaks those lines up into a list of words ignoring delimiters that appear
       inside quotes.  quotewords() returns all of the tokens in a single long list, while nested_quotewords()
       returns a list of token lists corresponding to the elements of @lines.  parse_line() does tokenizing on a
       single string.  The *quotewords() functions simply call parse_line(), so if you're only splitting one
       line you can call parse_line() directly and save a function call.

       The $keep controls what happens with delimters and special characters:

       true
           If  true,  then  the tokens are split on the specified delimiter, but all other characters (including
           quotes and backslashes) are kept in the tokens.

       false
           If $keep is false then the *quotewords() functions remove all quotes and  backslashes  that  are  not
           themselves  backslash-escaped or inside of single quotes (i.e., quotewords() tries to interpret these
           characters just like the Bourne shell).  NB: these semantics are  significantly  different  from  the
           original version of this module shipped with Perl 5.000 through 5.004.

       "delimiters"
           As  an  additional  feature,  $keep  may  be  the  keyword "delimiters" which causes the functions to
           preserve the delimiters in each string as tokens in the token lists, in addition to preserving  quote
           and backslash characters.

       shellwords() is written as a special case of quotewords(), and it does token parsing with whitespace as a
       delimiter-- similar to most Unix shells.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The sample program:

         use Text::ParseWords;
         @words = quotewords('\s+', 0, q{this   is "a test" of\ quotewords \"for you});
         $i = 0;
         foreach (@words) {
             print "$i: &lt;$_&gt;\n";
             $i++;
         }

       produces:

         0: &lt;this&gt;
         1: &lt;is&gt;
         2: &lt;a test&gt;
         3: &lt;of quotewords&gt;
         4: &lt;"for&gt;
         5: &lt;you&gt;

       demonstrating:

       0   a simple word

       1   multiple spaces are skipped because of our $delim

       2   use of quotes to include a space in a word

       3   use of a backslash to include a space in a word

       4   use of a backslash to remove the special meaning of a double-quote

       5   another simple word (note the lack of effect of the backslashed double-quote)

       Replacing  "quotewords('\s+', 0, q{this   is...})" with "shellwords(q{this   is...})" is a simpler way to
       accomplish the same thing.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Text::CSV - for parsing CSV files

</pre><h4><b>AUTHORS</b></h4><pre>
       The original author is unknown, but presumably this evolved from "shellwords.pl" in Perl 4.

       Much  of  the  code  for  parse_line()  (including  the  primary  regexp)  came   from   Joerk   Behrends
       &lt;<a href="mailto:jbehrends@multimediaproduzenten.de">jbehrends@multimediaproduzenten.de</a>&gt;.

       Examples section and other documentation provided by John Heidemann &lt;<a href="mailto:johnh@ISI.EDU">johnh@ISI.EDU</a>&gt;.

       Hal  Pomeranz  &lt;<a href="mailto:pomeranz@netcom.com">pomeranz@netcom.com</a>&gt;  maintained  this  from  1994  through  1999, and did the first CPAN
       release.

       Alexandr Ciornii &lt;alexchornyATgmail.com&gt; maintained this from 2008 to 2015.

       Many other people have contributed, with special thanks due to Michael  Schwern  &lt;<a href="mailto:schwern@envirolink.org">schwern@envirolink.org</a>&gt;
       and Jeff Friedl &lt;<a href="mailto:jfriedl@yahoo-inc.com">jfriedl@yahoo-inc.com</a>&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This library is free software; you may redistribute and/or modify it under the same terms as Perl itself.

perl v5.40.1                                       2025-07-27                            <u>Text::<a href="../man3perl/ParseWords.3perl.html">ParseWords</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>