<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP::Proxy::BodyFilter::lines - A filter that outputs only complete lines</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhttp-proxy-perl">libhttp-proxy-perl_0.304-5build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTTP::Proxy::BodyFilter::lines - A filter that outputs only complete lines

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use HTTP::Proxy::BodyFilter::lines;
           use MyFilter;    # this filter only works on complete lines

           my $filter = MyFilter-&gt;new();

           # stack both filters so that they'll handle text/* responses
           $proxy-&gt;push_filter(
               mime     =&gt; 'text/*',
               response =&gt; HTTP::Proxy::BodyFilter::lines-&gt;new,
               response =&gt; $filter
           );

           # I want my lines to end with '!'
           # This is equivalent to $/ = '!' in a normal Perl program
           my $lines = HTTP::Proxy::BodyFilter::lines-&gt;new('!');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The HTTP::Proxy::BodyFilter::lines filter makes sure that the next filter in the filter chain will only
       receive complete lines. The "chunks" of data received by the following filters with either end with "\n"
       or will be the last piece of data for the current HTTP message body.

       You can change the idea the filter has of what is a line by passing to its constructor the string it
       should understand as line ending. "\n" is the default value.

           my $filter = HTTP::Proxy::BodyFilter::lines-&gt;new( $sep );

       This is similar to modifying $/ in a Perl program. In fact, this filter has a behaviour so similar to
       modifying $/ that it also knows about "paragraph mode" and "record mode".

       Note that the "slurp" mode is not supported. Please use HTTP::Proxy::BodyFilter::complete to enable the
       generic store and forward filter mechanism.

</pre><h4><b>METHODS</b></h4><pre>
       This filter defines the following methods, which are automatically called:

       <b>init()</b>
           Initialise the filter with the EOL information.

       <b>filter()</b>
           Keeps unfinished lines for later.

       <b>will_modify()</b>
           This method returns a <u>false</u> value, thus indicating to the system that it will not modify data passing
           through.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       HTTP::Proxy, HTTP::Proxy::BodyFilter.

</pre><h4><b>AUTHOR</b></h4><pre>
       Philippe "BooK" Bruhat, &lt;<a href="mailto:book@cpan.org">book@cpan.org</a>&gt;.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2003-2015, Philippe Bruhat.

</pre><h4><b>LICENSE</b></h4><pre>
       This module is free software; you can redistribute it or modify it under the same terms as Perl itself.

perl v5.40.1                                       2025-02-18                <u>HTTP::Proxy::BodyFilter::<a href="../man3pm/lines.3pm.html">lines</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>