<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File::Data - interface to file data</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfile-data-perl">libfile-data-perl_1.20-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       File::Data - interface to file data

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Wraps all the accessing of a file into a convenient set of calls for reading and writing data, including
       a simple regex interface.

       Note that the file needs to exist prior to using this module!

       See <b>new()</b>

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use strict;

           use File::Data;

           my $o_dat = File::Data-&gt;new('./t/example');

           $o_dat-&gt;write("complete file contents\n");

           $o_dat-&gt;prepend("first line\n"); # line 0

           $o_dat-&gt;append("original second (last) line\n");

           $o_dat-&gt;insert(2, "new second line\n"); # inc. zero!

           $o_dat-&gt;replace('line', 'LINE');

           print $o_dat-&gt;READ;

           Or, perhaps more seriously :-}

               my $o_sgm = File::Data-&gt;new('./sgmlfile');

               print "new SGML data: ".$o_sgm-&gt;REPLACE(
                   '\&lt;\s*((?i)tag)\s*\&gt;\s*((?s).*)\s*\&lt;\s*((?i)\s*\/\s*tag)\s*\&gt;',
                   qq|&lt;tag&gt;key="val"&lt;/tag&gt;|,
               ) if $o_sgm;

           See METHODS and EXAMPLES.

</pre><h4><b>IMPORTANT</b></h4><pre>
       lowercase method calls return the object itself, so you can chain calls.

           my $o_obj = $o_dat-&gt;read; # ! &lt;= object !

       UPPERCASE method calls return the data relevant to the operation.

           my @data  = $o_dat-&gt;READ; # ! &lt;= data   !

       While this may occasionally be frustrating, using the <b>principle</b> <b>of</b> <b>least</b> <b>surprise</b>, it is at least
       consistent.

       See do

</pre><h4><b>EXPLANATION</b></h4><pre>
           The idea is to standardise accessing of files for repetitive and straight forward tasks, and remove
           the repeated and therefore error prone file access I have seen in many sites, where varying, (with
           equivalently varying success), methods are used to achieve essentially the same result - a simple
           search and replace and/or a regex match.

           Approaches to opening and working with files vary so much, where one person may wish to know if a
           file exists, another wishes to know whether the target is a file, or if it is readable, or writable
           and so on.  Sometimes, in production code even (horror), file's are opened without any checks of
           whether the open was successful.  Then there's a loop through each line to find the first or many
           patterns to read and/or replace.  With a failure, normally the only message is 'permission denied',
           is that read or write access, does the file even exist? etc.

           This module attempts to provide a plain/generic interface to accessing a file's data.  This will not
           suit every situation, but I have included some examples which will hopefully demonstrate that it may
           be used in situations where people would normally go through varying and inconsistent, (and therefore
           error-prone),  procedures - to get at the same data.

           Theoretically you can mix and match your read and writes so long as you don't open read-only.

               my $o_dat  = File::Data-&gt;new($file);

               my $i_snrd = $o_dat-&gt;append($append)-&gt;REPLACE($search, $replace);

               print $o_dat-&gt;READ;

           If you want to apply the same regex, or insert/prepend/replacement/whatever mechanism, to many
           different files, then the neatest solution may be to do something like the following:

               foreach my $file ( @list_of_file_names ) {
                   my $o_dat  = File::Data-&gt;new($file);

                   my $i_snrd = $o_dat-&gt;append($append)-&gt;REPLACE($search, $replace);

                   print $o_dat-&gt;READ;
               }

           One last thing - I'm sure this could be made more efficient, and I'd be receptive to any suggestions
           to that effect. Note though that the intention has been to create a simple and consistent interface,
           rather than a complicated one.

</pre><h4><b>METHODS</b></h4><pre>
       new Create a new File::Data object (default read-write).

               my $o_rw = File::Data-&gt;new($filename); # read-write

               my $o_ro = File::Data-&gt;new($filename, 'ro'); # read-only

           Each file should have it's own discrete object.

           Note  that  if you open a file read-only and then attempt to write to it, that will be regarded as an
           error, even if you change the permissions in the meantime.

           Further: The file <b>must</b> exist before successful use of  this  method  is  possible.   This  is  <b>not</b>  a
           replacement for modules which create and delete files, this is purely designed as an interface to the
           <b>data</b> of existing files.  A <b>create</b> function is a future possibility.

           Look in EXAMPLES for a more complete explanation of possible arguments to the <b>new()</b> method

       read
           Read all data from file

               $o_dat = $o_dat-&gt;read; # !

               my @data = $o_dat-&gt;READ;

       _internal
           read

               does this...

       write
           Write data to file

               my $o_dat = $o_dat-&gt;WRITE; # !

               my @written = $o_dat-&gt;write;

       prepend
           Prepend to file

               my $o_dat = $o_dat-&gt;prepen(\@lines); # !

               my @prepended = $o_dat-&gt;prepend(\@lines);

       insert
           Insert data at line number, starting from '0'

               my $o_dat = $o_dat-&gt;insert($i_lineno, \@lines); # !

               my @inserted = $o_dat-&gt;INSERT($i_lineno, \@lines);

       append
           Append to file

               my $o_dat = $o_dat-&gt;append(\@lines); # !

               my @appended = $o_dat-&gt;APPEND(\@lines);

       search
           Retrieve data out of a file, simple list of all matches found are returned.

           Note - you must use capturing parentheses for this to work!

               my $o_dat = $o_dat-&gt;search('^(.*\@.*)$'); # !

               my @addrs = $o_dat-&gt;SEARCH('^(.*\@.*)$');

               my @names = $o_dat-&gt;SEARCH('^(?:[^:]:){4}([^:]+):');

       replace
           Replace data in a 'search and replace' manner, returns the final data.

               my $o_dat = $o_dat-&gt;replace($search, $replace); # !

               my @data = $o_dat-&gt;REPLACE($search, $replace);

               my @data = $o_dat-&gt;REPLACE(
                   q|\&lt;a href=(['"])([^$1]+)?$1| =&gt; q|'my.sales.com'|,
               );

           This  is <b>simple</b>, in that you can do almost anything in the <b>search</b> side, but the <b>replace</b> side is a bit
           more restricted, as we can't effect the replacement modifiers on the fly.

           If you really need this, perhaps <b>(?{})</b> can help?

       xreturn
           Returns the product of the given (or last) <b>do()</b>, undef on failure.

               my $o_dat = $o_dat-&gt;prepend($A)-&gt;append($b)-&gt;return('prepend'); # !

               my @prepended = $o_dat-&gt;prepend($A)-&gt;append($b)-&gt;RETURN('prepend');

               my @appended  = $o_dat-&gt;prepend($A)-&gt;append($b)-&gt;RETURN; # like read()

       create
           placeholder - unsupported

       delete
           placeholder - unsupported

       close
           Close the file

               my $i_closed = $o_dat-&gt;close; # 1|0

       info
           placeholder - unsupported

</pre><h4><b>VARIABLES</b></h4><pre>
       Various variables may be set affecting the behaviour of the module.

       $File::Data::DEBUG
           Set to 0 (default) or 1 for debugging information to be printed on STDOUT.

               $File::Data::DEBUG = 1;

           Alternatively  set to a regex of any of the prime methods to debug them individually.

               $File::Data::DEBUG = '(ap|pre)pend';

       $File::Data::FATAL
           Will die if there is any failure in accessing the file, or reading the data.

           Default = 0 (don't die - just warn);

               $File::Data::FATAL = 1;    # die

       $File::Data::REFERENCE
           Will return a reference, not a list, useful with large files.

           Default is 0, ie; methods normally returns a list.  There may be an argument  to  make  returns  work
           with references by default, feedback will decide.

               $File::Data::REFERENCE = 1;

               my $a_ref = $o_dat-&gt;search('.*');

               print "The log: \n".@{ $a_ref };

       $File::Data::SILENT
           Set to something other than zero if you don't want error messages ?-\

               $File::Data::SILENT = 0; # per line

       $File::Data::STRING
           Where  regex's are used, default behaviour is to treate the entire file as a single scalar string, so
           that, for example, <b>(?ms:...)</b> matches are effective.

           Unset if you don't want this behaviour.

               $File::Data::STRING = 0; # per line

       $File::Data::PERMISSIONS
           File will be opened read-write (<b>insert()</b> compatible) unless this variable is set explicitly or  given
           via  <b>new()</b>.  In either case, unless it is one of our valid permission <b>keys</b> declared below, it will be
           passed on to <b>FileHandle</b> and otherwise not modified.  We don't support  fancy  permission  sets,  just
           read or write.

           Read-only permissions may be explicitly set using one of these <b>keys</b>:

               $File::Data::PERMISSIONS = 'ro'; # or readonly or &lt;

           Or, equivalently, for read-write (default):

               $File::Data::PERMISSIONS = 'rw'; # or readwrite or +&lt;

           Note that it makes no sense to have an 'append only' command (&gt;&gt;), we'd have to disable all of write,
           search and replace, and insert, etc. in that case - just use the <b>append()</b> method only.

           This is a KISS-compatible module remember?

       # ================================================================

</pre><h4><b>SPECIAL</b></h4><pre>
       ...

       AUTOLOAD
           Any  unrecognised function will be passed to the FileHandle object for final consideration, behaviour
           is then effectively 'o_dat ISA FileHandle'.

               $o_dat-&gt;truncate;

</pre><h4><b>EXAMPLES</b></h4><pre>
       Typical construction examples:

           my $o_rw = File::Data-&gt;new($filename, 'rw');

           my $o_ro = File::Data-&gt;new($filename, 'ro');

       complete
               my $o_dat = File::Data-&gt;new('./jabber');

               $o_dat-&gt;write("  Bewxre the Jabberwock my son,\n");

               $o_dat-&gt;prepend("The Jxbberwock by Lewis Cxrroll:\n");

               $o_dat-&gt;append("  the claws thxt snxtch,\n  ...\n");

               $o_dat-&gt;insert(2, "  the jaws which bite.\n");

               $o_dat-&gt;replace('x', 'a');

               print $o_dat-&gt;SEARCH('The.+\n')-&gt;REPLACE("The.+\n", '')-&gt;return('search');

               print $o_dat-&gt;READ;

       error
           Failure is indicated by an error routine being called, this will  print  out  any  error  to  STDERR,
           unless warnings are declared fatal, in which case we croak.  You can register your own error handlers
           for  any  method mentioned in the METHOD section of this document, in addition is a special <b>init</b> call
           for initial file opening and general setting up.

           Create a read-write object with a callback for all errors:

               my $o_rw = File::Data-&gt;new($filename, 'ro', {
                   'error'        =&gt; \&amp;myerror,
               });

           Create a read-only object with a separate object handler for each error type:

               my $o_rw = File::Data-&gt;new($filename, 'rw', {
                   'error'        =&gt; $o_generic-&gt;error_handler,
                   'insert'    =&gt; $o_handler-&gt;insert_error,
                   'open'        =&gt; $o_open_handler,
                   'read'        =&gt; \&amp;carp,
                   'write'        =&gt; \&amp;write_error,
               });

       commandline
           From the command line:

               C&lt;perl -MFile::Data -e "File::Data-&gt;new('./test.txt')-&gt;write('some stuff')"&gt;

           And (very non-obfuscated)

             C&lt;
             perl -MFile::Data -e "@x=sort qw(perl another hacker just);
               print map {split(\"\n\", ucfirst(\$_).\" \")}\
               File::Data-&gt;new(\"./t/japh\")-&gt;\
                 write(shift(@x).\"\n\")-&gt;    \
                 append(shift(@x).\"\n\")-&gt;   \
                 prepend(shift(@x).\"\n\")-&gt;  \
                 insert(2, shift(@x).\"\n\")-&gt;\
               READ;"
             &gt;

           If you still have problems, mail me the output of

               make test TEST_VERBOSE=1

       do  Simple wrapper for method calls, returning the content.

               my @inserted = $o_dat-&gt;do('insert', @this);

               my @appended = $o_dat-&gt;do('append', @this);

           An addendum to this method, and to make life generally easier, is that you can also call any  of  the
           above methods in uppercase, to call via <b>do()</b> eg;

               my @data = $o_dat-&gt;WRITE($this)-&gt;APPEND-&gt;($that)-&gt;read;

           First argument is the method to call, followed by the arguments that method expects.

               perl -MFile::Data -e "print File::Data-&gt;new($file)-&gt;INSERT(3,
               \"third line\n\")-&gt;READ";

           If you want to get at the output of a particular called method see <b>return()</b>

</pre><h4><b>AUTHOR</b></h4><pre>
       Richard Foley &lt;<a href="mailto:File.Data@rfi.net">File.Data@rfi.net</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2016 by Richard Foley

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.38.2                                       2024-03-05                                    <u>File::<a href="../man3pm/Data.3pm.html">Data</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>