<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Config::Model::models::Systemd::Section::ServiceUnit - Configuration class Systemd::Section::ServiceUnit</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libconfig-model-systemd-perl">libconfig-model-systemd-perl_0.257.2-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Config::Model::models::Systemd::Section::ServiceUnit - Configuration class Systemd::Section::ServiceUnit

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Configuration classes used by Config::Model

</pre><h4><b>Elements</b></h4><pre>
   <b>Description</b>
       A short human readable title of the unit. This may be used by systemd (and other UIs) as a user-visible
       label for the unit, so this string should identify the unit rather than describe it, despite the name.
       This string also shouldn't just repeat the unit name. "Apache2 Web Server" is a good example. Bad
       examples are "high-performance lightweight HTTP server" (too generic) or "Apache2" (meaningless for
       people who do not know Apache, duplicates the unit name). systemd may use this string as a noun in status
       messages ("Starting description...", "Started description.", "Reached target description.", "Failed to
       start description."), so it should be capitalized, and should not be a full sentence, or a phrase with a
       continuous verb. Bad examples include "exiting the container" or "updating the database once per day.".
       <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>Documentation</b>
       A space-separated list of URIs referencing documentation for this unit or its configuration. Accepted are
       only URIs of the types "http://", "https://", "file:", "info:", "man:". For more information about the
       syntax of these URIs, see <b><a href="../man7/uri.7.html">uri</a></b>(7).  The URIs should be listed in order of relevance, starting with the
       most relevant. It is a good idea to first reference documentation that explains what the unit's purpose
       is, followed by how it is configured, followed by any other related documentation. This option may be
       specified more than once, in which case the specified list of URIs is merged. If the empty string is
       assigned to this option, the list is reset and all prior assignments will have no effect.  <u>Optional.</u> <u>Type</u>
       <u>list</u> <u>of</u> <u>uniline.</u>

   <b>Wants</b>
       Configures (weak) requirement dependencies on other units. This option may be specified more than once or
       multiple space-separated units may be specified in one option in which case dependencies for all listed
       names will be created. Dependencies of this type may also be configured outside of the unit configuration
       file by adding a symlink to a ".wants/" directory accompanying the unit file. For details, see above.

       Units listed in this option will be started if the configuring unit is. However, if the listed units fail
       to start or cannot be added to the transaction, this has no impact on the validity of the transaction as
       a whole, and this unit will still be started. This is the recommended way to hook the start-up of one
       unit to the start-up of another unit.

       Note that requirement dependencies do not influence the order in which services are started or stopped.
       This has to be configured independently with the "After" or "Before" options. If unit "foo.service" pulls
       in unit "bar.service" as configured with "Wants" and no ordering is configured with "After" or "Before",
       then both units will be started simultaneously and without any delay between them if "foo.service" is
       activated.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>Requires</b>
       Similar to "Wants", but declares a stronger requirement dependency. Dependencies of this type may also be
       configured by adding a symlink to a ".requires/" directory accompanying the unit file.

       If this unit gets activated, the units listed will be activated as well. If one of the other units fails
       to activate, and an ordering dependency "After" on the failing unit is set, this unit will not be
       started. Besides, with or without specifying "After", this unit will be stopped (or restarted) if one of
       the other units is explicitly stopped (or restarted).

       Often, it is a better choice to use "Wants" instead of "Requires" in order to achieve a system that is
       more robust when dealing with failing services.

       Note that this dependency type does not imply that the other unit always has to be in active state when
       this unit is running. Specifically: failing condition checks (such as "ConditionPathExists",
       "ConditionPathIsSymbolicLink", … — see below) do not cause the start job of a unit with a "Requires"
       dependency on it to fail. Also, some unit types may deactivate on their own (for example, a service
       process may decide to exit cleanly, or a device may be unplugged by the user), which is not propagated to
       units having a "Requires" dependency. Use the "BindsTo" dependency type together with "After" to ensure
       that a unit may never be in active state without a specific other unit also in active state (see below).
       <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>Requisite</b>
       Similar to "Requires". However, if the units listed here are not started already, they will not be
       started and the starting of this unit will fail immediately. "Requisite" does not imply an ordering
       dependency, even if both units are started in the same transaction. Hence this setting should usually be
       combined with "After", to ensure this unit is not started before the other unit.

       When "Requisite=b.service" is used on "a.service", this dependency will show as "RequisiteOf=a.service"
       in property listing of "b.service". "RequisiteOf" dependency cannot be specified directly.  <u>Optional.</u>
       <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>BindsTo</b>
       Configures requirement dependencies, very similar in style to "Requires". However, this dependency type
       is stronger: in addition to the effect of "Requires" it declares that if the unit bound to is stopped,
       this unit will be stopped too. This means a unit bound to another unit that suddenly enters inactive
       state will be stopped too.  Units can suddenly, unexpectedly enter inactive state for different reasons:
       the main process of a service unit might terminate on its own choice, the backing device of a device unit
       might be unplugged or the mount point of a mount unit might be unmounted without involvement of the
       system and service manager.

       When used in conjunction with "After" on the same unit the behaviour of "BindsTo" is even stronger. In
       this case, the unit bound to strictly has to be in active state for this unit to also be in active state.
       This not only means a unit bound to another unit that suddenly enters inactive state, but also one that
       is bound to another unit that gets skipped due to an unmet condition check (such as
       "ConditionPathExists", "ConditionPathIsSymbolicLink", … — see below) will be stopped, should it be
       running. Hence, in many cases it is best to combine "BindsTo" with "After".

       When "BindsTo=b.service" is used on "a.service", this dependency will show as "BoundBy=a.service" in
       property listing of "b.service". "BoundBy" dependency cannot be specified directly.  <u>Optional.</u> <u>Type</u> <u>list</u>
       <u>of</u> <u>uniline.</u>

   <b>PartOf</b>
       Configures dependencies similar to "Requires", but limited to stopping and restarting of units. When
       systemd stops or restarts the units listed here, the action is propagated to this unit. Note that this is
       a one-way dependency — changes to this unit do not affect the listed units.

       When "PartOf=b.service" is used on "a.service", this dependency will show as "ConsistsOf=a.service" in
       property listing of "b.service". "ConsistsOf" dependency cannot be specified directly.  <u>Optional.</u> <u>Type</u>
       <u>list</u> <u>of</u> <u>uniline.</u>

   <b>Upholds</b>
       Configures dependencies similar to "Wants", but as long as this unit is up, all units listed in "Upholds"
       are started whenever found to be inactive or failed, and no job is queued for them. While a "Wants"
       dependency on another unit has a one-time effect when this units started, a "Upholds" dependency on it
       has a continuous effect, constantly restarting the unit if necessary. This is an alternative to the
       "Restart" setting of service units, to ensure they are kept running whatever happens. The restart happens
       without delay, and usual per-unit rate-limit applies.

       When "Upholds=b.service" is used on "a.service", this dependency will show as "UpheldBy=a.service" in the
       property listing of "b.service".  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>Conflicts</b>
       A space-separated list of unit names. Configures negative requirement dependencies. If a unit has a
       "Conflicts" setting on another unit, starting the former will stop the latter and vice versa.

       Note that this setting does not imply an ordering dependency, similarly to the "Wants" and "Requires"
       dependencies described above. This means that to ensure that the conflicting unit is stopped before the
       other unit is started, an "After" or "Before" dependency must be declared. It doesn't matter which of the
       two ordering dependencies is used, because stop jobs are always ordered before start jobs, see the
       discussion in "Before"/"After" below.

       If unit A that conflicts with unit B is scheduled to be started at the same time as B, the transaction
       will either fail (in case both are required parts of the transaction) or be modified to be fixed (in case
       one or both jobs are not a required part of the transaction). In the latter case, the job that is not
       required will be removed, or in case both are not required, the unit that conflicts will be started and
       the unit that is conflicted is stopped.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>Before</b>
       These two settings expect a space-separated list of unit names. They may be specified more than once, in
       which case dependencies for all listed names are created.

       Those two settings configure ordering dependencies between units. If unit "foo.service" contains the
       setting "Before=bar.service" and both units are being started, "bar.service"'s start-up is delayed until
       "foo.service" has finished starting up. "After" is the inverse of "Before", i.e. while "Before" ensures
       that the configured unit is started before the listed unit begins starting up, "After" ensures the
       opposite, that the listed unit is fully started up before the configured unit is started.

       When two units with an ordering dependency between them are shut down, the inverse of the start-up order
       is applied. I.e. if a unit is configured with "After" on another unit, the former is stopped before the
       latter if both are shut down. Given two units with any ordering dependency between them, if one unit is
       shut down and the other is started up, the shutdown is ordered before the start-up. It doesn't matter if
       the ordering dependency is "After" or "Before", in this case. It also doesn't matter which of the two is
       shut down, as long as one is shut down and the other is started up; the shutdown is ordered before the
       start-up in all cases. If two units have no ordering dependencies between them, they are shut down or
       started up simultaneously, and no ordering takes place. It depends on the unit type when precisely a unit
       has finished starting up. Most importantly, for service units start-up is considered completed for the
       purpose of "Before"/"After" when all its configured start-up commands have been invoked and they either
       failed or reported start-up success. Note that this includes "ExecStartPost" (or "ExecStopPost" for the
       shutdown case).

       Note that those settings are independent of and orthogonal to the requirement dependencies as configured
       by "Requires", "Wants", "Requisite", or "BindsTo". It is a common pattern to include a unit name in both
       the "After" and "Wants" options, in which case the unit listed will be started before the unit that is
       configured with these options.

       Note that "Before" dependencies on device units have no effect and are not supported.  Devices generally
       become available as a result of an external hotplug event, and systemd creates the corresponding device
       unit without delay.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>After</b>
       These two settings expect a space-separated list of unit names. They may be specified more than once, in
       which case dependencies for all listed names are created.

       Those two settings configure ordering dependencies between units. If unit "foo.service" contains the
       setting "Before=bar.service" and both units are being started, "bar.service"'s start-up is delayed until
       "foo.service" has finished starting up. "After" is the inverse of "Before", i.e. while "Before" ensures
       that the configured unit is started before the listed unit begins starting up, "After" ensures the
       opposite, that the listed unit is fully started up before the configured unit is started.

       When two units with an ordering dependency between them are shut down, the inverse of the start-up order
       is applied. I.e. if a unit is configured with "After" on another unit, the former is stopped before the
       latter if both are shut down. Given two units with any ordering dependency between them, if one unit is
       shut down and the other is started up, the shutdown is ordered before the start-up. It doesn't matter if
       the ordering dependency is "After" or "Before", in this case. It also doesn't matter which of the two is
       shut down, as long as one is shut down and the other is started up; the shutdown is ordered before the
       start-up in all cases. If two units have no ordering dependencies between them, they are shut down or
       started up simultaneously, and no ordering takes place. It depends on the unit type when precisely a unit
       has finished starting up. Most importantly, for service units start-up is considered completed for the
       purpose of "Before"/"After" when all its configured start-up commands have been invoked and they either
       failed or reported start-up success. Note that this includes "ExecStartPost" (or "ExecStopPost" for the
       shutdown case).

       Note that those settings are independent of and orthogonal to the requirement dependencies as configured
       by "Requires", "Wants", "Requisite", or "BindsTo". It is a common pattern to include a unit name in both
       the "After" and "Wants" options, in which case the unit listed will be started before the unit that is
       configured with these options.

       Note that "Before" dependencies on device units have no effect and are not supported.  Devices generally
       become available as a result of an external hotplug event, and systemd creates the corresponding device
       unit without delay.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>OnFailure</b>
       A space-separated list of one or more units that are activated when this unit enters the "failed" state.
       <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>OnSuccess</b>
       A space-separated list of one or more units that are activated when this unit enters the "inactive"
       state.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>PropagatesReloadTo</b>
       A space-separated list of one or more units to which reload requests from this unit shall be propagated
       to, or units from which reload requests shall be propagated to this unit, respectively. Issuing a reload
       request on a unit will automatically also enqueue reload requests on all units that are linked to it
       using these two settings.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>ReloadPropagatedFrom</b>
       A space-separated list of one or more units to which reload requests from this unit shall be propagated
       to, or units from which reload requests shall be propagated to this unit, respectively. Issuing a reload
       request on a unit will automatically also enqueue reload requests on all units that are linked to it
       using these two settings.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>PropagatesStopTo</b>
       A space-separated list of one or more units to which stop requests from this unit shall be propagated to,
       or units from which stop requests shall be propagated to this unit, respectively. Issuing a stop request
       on a unit will automatically also enqueue stop requests on all units that are linked to it using these
       two settings.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>StopPropagatedFrom</b>
       A space-separated list of one or more units to which stop requests from this unit shall be propagated to,
       or units from which stop requests shall be propagated to this unit, respectively. Issuing a stop request
       on a unit will automatically also enqueue stop requests on all units that are linked to it using these
       two settings.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>JoinsNamespaceOf</b>
       For units that start processes (such as service units), lists one or more other units whose network
       and/or temporary file namespace to join. If this is specified on a unit (say, "a.service" has
       "JoinsNamespaceOf=b.service"), then the inverse dependency ("JoinsNamespaceOf=a.service" for b.service)
       is implied. This only applies to unit types which support the "PrivateNetwork", "NetworkNamespacePath",
       "PrivateIPC", "IPCNamespacePath", and "PrivateTmp" directives (see <b><a href="../man5/systemd.exec.5.html">systemd.exec</a></b>(5) for details). If a
       unit that has this setting set is started, its processes will see the same "<a href="file:/tmp/">/tmp/</a>", "<a href="file:/var/tmp/">/var/tmp/</a>", IPC
       namespace and network namespace as one listed unit that is started. If multiple listed units are already
       started and these do not share their namespace, then it is not defined which namespace is joined. Note
       that this setting only has an effect if "PrivateNetwork"/"NetworkNamespacePath",
       "PrivateIPC"/"IPCNamespacePath" and/or "PrivateTmp" is enabled for both the unit that joins the namespace
       and the unit whose namespace is joined.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>RequiresMountsFor</b>
       Takes a space-separated list of absolute paths. Automatically adds dependencies of type "Requires" and
       "After" for all mount units required to access the specified path.

       Mount points marked with "noauto" are not mounted automatically through "local-fs.target", but are still
       honored for the purposes of this option, i.e. they will be pulled in by this unit.  <u>Optional.</u> <u>Type</u>
       <u>uniline.</u>

   <b>WantsMountsFor</b>
       Same as "RequiresMountsFor", but adds dependencies of type "Wants" instead of "Requires".  <u>Optional.</u> <u>Type</u>
       <u>uniline.</u>

   <b>OnSuccessJobMode</b>
       Takes a value of "fail", "replace", "replace-irreversibly", "isolate", "flush", "ignore-dependencies" or
       "ignore-requirements". Defaults to "replace". Specifies how the units listed in "OnSuccess"/"OnFailure"
       will be enqueued. See <b><a href="../man1/systemctl.1.html">systemctl</a></b>(1)'s "--job-mode=" option for details on the possible values. If this is
       set to "isolate", only a single unit may be listed in "OnSuccess"/"OnFailure".  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>OnFailureJobMode</b>
       Takes a value of "fail", "replace", "replace-irreversibly", "isolate", "flush", "ignore-dependencies" or
       "ignore-requirements". Defaults to "replace". Specifies how the units listed in "OnSuccess"/"OnFailure"
       will be enqueued. See <b><a href="../man1/systemctl.1.html">systemctl</a></b>(1)'s "--job-mode=" option for details on the possible values. If this is
       set to "isolate", only a single unit may be listed in "OnSuccess"/"OnFailure".  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

       Note: OnFailureJobMode is migrated with '$unit' and with:

       •   $unit =&gt; "- OnFailureIsolate"

   <b>IgnoreOnIsolate</b>
       Takes  a boolean argument. If "true", this unit will not be stopped when isolating another unit. Defaults
       to "false" for service, target, socket, timer, and path units, and "true" for slice, scope, device, swap,
       mount, and automount units.  <u>Optional.</u> <u>Type</u> <u>boolean.</u>

   <b>StopWhenUnneeded</b>
       Takes a boolean argument. If "true", this unit will be stopped when it is no longer used. Note  that,  in
       order  to  minimize  the  work  to  be  executed,  systemd will not stop units by default unless they are
       conflicting with other units, or the user explicitly requested their shut down. If this option is set,  a
       unit  will  be  automatically  cleaned  up  if  no  other  active  unit requires it. Defaults to "false".
       <u>Optional.</u> <u>Type</u> <u>boolean.</u>

   <b>RefuseManualStart</b>
       Takes a boolean argument. If "true", this unit can only be activated or deactivated indirectly.  In  this
       case,  explicit  start-up  or  termination  requested  by the user is denied, however if it is started or
       stopped as a dependency of another unit, start-up or termination will succeed. This is  mostly  a  safety
       feature  to  ensure  that  the  user  does  not  accidentally  activate units that are not intended to be
       activated explicitly, and not accidentally deactivate units that are  not  intended  to  be  deactivated.
       These options default to "false".  <u>Optional.</u> <u>Type</u> <u>boolean.</u>

   <b>RefuseManualStop</b>
       Takes  a  boolean argument. If "true", this unit can only be activated or deactivated indirectly. In this
       case, explicit start-up or termination requested by the user is denied,  however  if  it  is  started  or
       stopped  as  a  dependency of another unit, start-up or termination will succeed. This is mostly a safety
       feature to ensure that the user does not  accidentally  activate  units  that  are  not  intended  to  be
       activated  explicitly,  and  not  accidentally  deactivate units that are not intended to be deactivated.
       These options default to "false".  <u>Optional.</u> <u>Type</u> <u>boolean.</u>

   <b>AllowIsolate</b>
       Takes a boolean argument. If "true", this unit may be used with the systemctl isolate command. Otherwise,
       this will be refused. It probably is a good idea to leave this disabled  except  for  target  units  that
       shall  be  used  similar to runlevels in SysV init systems, just as a precaution to avoid unusable system
       states. This option defaults to "false".  <u>Optional.</u> <u>Type</u> <u>boolean.</u>

   <b>DefaultDependencies</b>
       Takes a boolean argument. If "yes", (the default), a few default dependencies will implicitly be  created
       for  the  unit.  The actual dependencies created depend on the unit type. For example, for service units,
       these dependencies ensure that the service is started only after basic system initialization is completed
       and is properly terminated on system shutdown. See the respective man pages for details. Generally,  only
       services  involved  with  early  boot  or  late  shutdown  should  set  this option to "no". It is highly
       recommended to leave this option enabled for the majority of common units. If set to  "no",  this  option
       does not disable all implicit dependencies, just non-essential ones.  <u>Optional.</u> <u>Type</u> <u>boolean.</u>

   <b>SurviveFinalKillSignal</b>
       Takes  a  boolean argument. Defaults to "no". If "yes", processes belonging to this unit will not be sent
       the final "SIGTERM" and "SIGKILL" signals during the final phase of the system  shutdown  process.   This
       functionality  replaces the older mechanism that allowed a program to set "argv[0][0] = '@'" as described
       at systemd and Storage Daemons for the Root File System &lt;https://systemd.io/ROOT_STORAGE_DAEMONS&gt;,  which
       however continues to be supported.  <u>Optional.</u> <u>Type</u> <u>boolean.</u>

   <b>CollectMode</b>
       Tweaks the "garbage collection" algorithm for this unit. Takes one of "inactive" or "inactive-or-failed".
       If  set to "inactive" the unit will be unloaded if it is in the "inactive" state and is not referenced by
       clients, jobs or other units — however it is not unloaded if it is in the  "failed"  state.  In  "failed"
       mode,  failed  units  are not unloaded until the user invoked systemctl reset-failed on them to reset the
       "failed" state, or  an  equivalent  command.  This  behaviour  is  altered  if  this  option  is  set  to
       "inactive-or-failed": in this case the unit is unloaded even if the unit is in a "failed" state, and thus
       an  explicitly  resetting  of  the  "failed"  state is not necessary. Note that if this mode is used unit
       results (such as exit codes, exit signals, consumed resources, …) are flushed out immediately  after  the
       unit  completed,  except  for what is stored in the logging subsystem. Defaults to "inactive".  <u>Optional.</u>
       <u>Type</u> <u>enum.</u> <u>choice:</u> <u>'inactive',</u> <u>'inactive-or-failed'.</u>

   <b>FailureActionExitStatus</b>
       Controls the exit status to propagate back to an invoking container manager (in case of a system service)
       or service manager (in case of a user manager) when the "FailureAction"/"SuccessAction" are set to "exit"
       or "exit-force" and the action is triggered. By default the exit  status  of  the  main  process  of  the
       triggering  unit (if this applies) is propagated. Takes a value in the range 0…255 or the empty string to
       request default behaviour.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>SuccessActionExitStatus</b>
       Controls the exit status to propagate back to an invoking container manager (in case of a system service)
       or service manager (in case of a user manager) when the "FailureAction"/"SuccessAction" are set to "exit"
       or "exit-force" and the action is triggered. By default the exit  status  of  the  main  process  of  the
       triggering  unit (if this applies) is propagated. Takes a value in the range 0…255 or the empty string to
       request default behaviour.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>JobTimeoutSec</b>
       "JobTimeoutSec" specifies a timeout for the whole job  that  starts  running  when  the  job  is  queued.
       "JobRunningTimeoutSec"  specifies  a timeout that starts running when the queued job is actually started.
       If either limit is reached, the job will be cancelled, the unit however will not  change  state  or  even
       enter the "failed" mode.

       Both  settings  take  a time span with the default unit of seconds, but other units may be specified, see
       <b><a href="../man7/systemd.time.7.html">systemd.time</a></b>(7).  The default is "infinity" (job  timeouts  disabled),  except  for  device  units  where
       "JobRunningTimeoutSec" defaults to "DefaultDeviceTimeoutSec".

       Note:  these  timeouts are independent from any unit-specific timeouts (for example, the timeout set with
       "TimeoutStartSec" in service units). The job timeout has no effect on the unit itself. Or in other words:
       unit-specific timeouts are useful to abort unit state changes, and revert them. The job timeout set  with
       this option however is useful to abort only the job waiting for the unit state to change.  <u>Optional.</u> <u>Type</u>
       <u>uniline.</u>

   <b>JobRunningTimeoutSec</b>
       "JobTimeoutSec"  specifies  a  timeout  for  the  whole  job  that starts running when the job is queued.
       "JobRunningTimeoutSec" specifies a timeout that starts running when the queued job is  actually  started.
       If  either  limit  is  reached, the job will be cancelled, the unit however will not change state or even
       enter the "failed" mode.

       Both settings take a time span with the default unit of seconds, but other units may  be  specified,  see
       <b><a href="../man7/systemd.time.7.html">systemd.time</a></b>(7).   The  default  is  "infinity"  (job  timeouts  disabled), except for device units where
       "JobRunningTimeoutSec" defaults to "DefaultDeviceTimeoutSec".

       Note: these timeouts are independent from any unit-specific timeouts (for example, the timeout  set  with
       "TimeoutStartSec" in service units). The job timeout has no effect on the unit itself. Or in other words:
       unit-specific  timeouts are useful to abort unit state changes, and revert them. The job timeout set with
       this option however is useful to abort only the job waiting for the unit state to change.  <u>Optional.</u> <u>Type</u>
       <u>uniline.</u>

   <b>JobTimeoutAction</b>
       "JobTimeoutAction" optionally configures an additional action to  take  when  the  timeout  is  hit,  see
       description   of   "JobTimeoutSec"  and  "JobRunningTimeoutSec"  above.  It  takes  the  same  values  as
       "FailureAction"/"SuccessAction". Defaults to "none".

       "JobTimeoutRebootArgument" configures an optional reboot string to pass to  the  <b><a href="../man2/reboot.2.html">reboot</a></b>(2)  system  call.
       <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>JobTimeoutRebootArgument</b>
       "JobTimeoutAction"  optionally  configures  an  additional  action  to  take when the timeout is hit, see
       description  of  "JobTimeoutSec"  and  "JobRunningTimeoutSec"  above.  It  takes  the  same   values   as
       "FailureAction"/"SuccessAction". Defaults to "none".

       "JobTimeoutRebootArgument"  configures  an  optional  reboot string to pass to the <b><a href="../man2/reboot.2.html">reboot</a></b>(2) system call.
       <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>StartLimitAction</b>
       Configure an additional action to take if the rate  limit  configured  with  "StartLimitIntervalSec"  and
       "StartLimitBurst"  is  hit.  Takes  the  same  values as the "FailureAction"/"SuccessAction" settings. If
       "none" is set, hitting the rate limit will trigger no action except that the start will not be permitted.
       Defaults  to  "none".   <u>Optional.</u>  <u>Type</u>  <u>enum.</u>  <u>choice:</u>  <u>'exit',</u>  <u>'exit-force',</u>   <u>'halt',</u>   <u>'halt-force',</u>
       <u>'halt-immediate',</u>  <u>'kexec',</u>  <u>'kexec-force',</u>  <u>'none',</u>  <u>'poweroff',</u> <u>'poweroff-force',</u> <u>'poweroff-immediate',</u>
       <u>'reboot',</u> <u>'reboot-force',</u> <u>'reboot-immediate',</u> <u>'soft-reboot',</u> <u>'soft-reboot-force'.</u>

   <b>SourcePath</b>
       A path to a configuration file  this  unit  has  been  generated  from.  This  is  primarily  useful  for
       implementation  of  generator tools that convert configuration from an external configuration file format
       into native unit files. This functionality should not be used in normal units.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>ConditionArchitecture</b>
       Check whether the system is running on a specific architecture. Takes  one  of  "x86",  "x86-64",  "ppc",
       "ppc-le", "ppc64", "ppc64-le", "ia64", "parisc", "parisc64", "s390", "s390x", "sparc", "sparc64", "mips",
       "mips-le",  "mips64",  "mips64-le",  "alpha", "arm", "arm-be", "arm64", "arm64-be", "sh", "sh64", "m68k",
       "tilegx", "cris", "arc", "arc-be", or "native".

       Use <b><a href="../man1/systemd-analyze.1.html">systemd-analyze</a></b>(1) for the complete list of known architectures.

       The architecture is determined from  the  information  returned  by  <b><a href="../man2/uname.2.html">uname</a></b>(2)  and  is  thus  subject  to
       <b><a href="../man2/personality.2.html">personality</a></b>(2).  Note that a "Personality" setting in the same unit file has no effect on this condition.
       A  special architecture name "native" is mapped to the architecture the system manager itself is compiled
       for. The test may be negated by prepending an exclamation mark.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>enum.</u>

   <b>ConditionFirmware</b>
       Check whether the system's firmware is of a certain type. The following values are  possible:   <u>Optional.</u>
       <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionVirtualization</b>
       Check  whether  the  system  is executed in a virtualized environment and optionally test whether it is a
       specific implementation. Takes either boolean value  to  check  if  being  executed  in  any  virtualized
       environment, or one of "vm" and "container" to test against a generic type of virtualization solution, or
       one of "qemu", "kvm", "amazon", "zvm", "vmware", "microsoft", "oracle", "powervm", "xen", "bochs", "uml",
       "bhyve",  "qnx",  "apple",  "sre",  "openvz", "lxc", "lxc-libvirt", "systemd-nspawn", "docker", "podman",
       "rkt", "wsl", "proot", "pouch", "acrn" to test against a specific implementation, or  "private-users"  to
       check  whether  we  are  running in a user namespace. See <b><a href="../man1/systemd-detect-virt.1.html">systemd-detect-virt</a></b>(1) for a full list of known
       virtualization technologies and their identifiers. If multiple virtualization  technologies  are  nested,
       only  the  innermost is considered. The test may be negated by prepending an exclamation mark.  <u>Optional.</u>
       <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionHost</b>
       "ConditionHost" may be used to match against the hostname or machine ID of the host. This either takes  a
       hostname  string  (optionally with shell style globs) which is tested against the locally set hostname as
       returned by <b><a href="../man2/gethostname.2.html">gethostname</a></b>(2), or a machine ID formatted as string (see <b><a href="../man5/machine-id.5.html">machine-id</a></b>(5)).   The  test  may  be
       negated by prepending an exclamation mark.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionKernelCommandLine</b>
       "ConditionKernelCommandLine"  may  be  used to check whether a specific kernel command line option is set
       (or if prefixed with the exclamation mark — unset). The argument must either be  a  single  word,  or  an
       assignment (i.e. two words, separated by "="). In the former case the kernel command line is searched for
       the word appearing as is, or as left hand side of an assignment. In the latter case, the exact assignment
       is  looked  for  with  right  and  left  hand  side  matching.  This  operates on the kernel command line
       communicated to userspace via "<a href="file:/proc/cmdline">/proc/cmdline</a>", except when the service manager is invoked as payload of a
       container manager, in which case the command line of PID 1  is  used  instead  (i.e.  "<a href="file:/proc/1/cmdline">/proc/1/cmdline</a>").
       <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionKernelVersion</b>
       "ConditionKernelVersion"  may  be  used  to  check  whether  the kernel version (as reported by uname -r)
       matches a certain expression, or if prefixed with the exclamation mark, does not match. The argument must
       be a list of (potentially quoted) expressions. Each expression starts with one of "=" or "!=" for  string
       comparisons,  "&lt;",  "&lt;=",  "==",  "&lt;&gt;", "&gt;=", "&gt;" for version comparisons, or $=, "!$=" for a shell-style
       glob match. If no operator is specified, $= is implied.

       Note that using the kernel version string is an unreliable way to determine which features are  supported
       by  a  kernel,  because of the widespread practice of backporting drivers, features, and fixes from newer
       upstream kernels into  older  versions  provided  by  distributions.  Hence,  this  check  is  inherently
       unportable and should not be used for units which may be used on different distributions.  <u>Optional.</u> <u>Type</u>
       <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionCredential</b>
       "ConditionCredential" may be used to check whether a credential by the specified name was passed into the
       service  manager.  See  System and Service Credentials &lt;https://systemd.io/CREDENTIALS&gt; for details about
       credentials. If used in services for the system service  manager  this  may  be  used  to  conditionalize
       services based on system credentials passed in. If used in services for the per-user service manager this
       may  be  used  to  conditionalize  services  based on credentials passed into the "unit@.service" service
       instance belonging to the user. The argument must be a valid credential name.   <u>Optional.</u>  <u>Type</u>  <u>list</u>  <u>of</u>
       <u>uniline.</u>

   <b>ConditionEnvironment</b>
       "ConditionEnvironment"  may  be  used  to  check  whether  a  specific environment variable is set (or if
       prefixed with the exclamation mark — unset) in the service manager's environment block.  The argument may
       be a single word, to check if the variable with this name is defined in  the  environment  block,  or  an
       assignment  ("name=value"),  to  check  if  the  variable with this exact value is defined. Note that the
       environment block of the service  manager  itself  is  checked,  i.e.  not  any  variables  defined  with
       "Environment"  or  "EnvironmentFile",  as  described  above. This is particularly useful when the service
       manager runs inside a containerized environment or as per-user service manager, in  order  to  check  for
       variables passed in by the enclosing container manager or PAM.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionSecurity</b>
       "ConditionSecurity"  may be used to check whether the given security technology is enabled on the system.
       Currently, the following values are recognized:

       The test may be negated by prepending an exclamation mark.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionCapability</b>
       Check whether the given capability exists in the capability bounding set of  the  service  manager  (i.e.
       this  does  not  check  whether  capability is actually available in the permitted or effective sets, see
       <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7) for details). Pass a capability name such  as  "CAP_MKNOD",  possibly  prefixed  with  an
       exclamation mark to negate the check.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionACPower</b>
       Check whether the system has AC power, or is exclusively battery powered at the time of activation of the
       unit.  This  takes  a boolean argument. If set to "true", the condition will hold only if at least one AC
       connector of the system is connected to a power source, or if no AC connectors are known. Conversely,  if
       set  to  "false",  the  condition  will  hold only if there is at least one AC connector known and all AC
       connectors are disconnected from a power source.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionNeedsUpdate</b>
       Takes one of "<a href="file:/var/">/var/</a>" or "<a href="file:/etc/">/etc/</a>" as argument, possibly prefixed with a "!" (to invert the condition). This
       condition may be used to conditionalize units on whether  the  specified  directory  requires  an  update
       because  "<a href="file:/usr/">/usr/</a>"'s  modification time is newer than the stamp file ".updated" in the specified directory.
       This is useful to implement offline updates of the vendor operating  system  resources  in  "<a href="file:/usr/">/usr/</a>"  that
       require  updating  of  "<a href="file:/etc/">/etc/</a>"  or "<a href="file:/var/">/var/</a>" on the next following boot. Units making use of this condition
       should order themselves before <b><a href="../man8/systemd-update-done.service.8.html">systemd-update-done.service</a></b>(8), to make sure they  run  before  the  stamp
       file's modification time gets reset indicating a completed update.

       If  the  "systemd.condition_needs_update="  option  is  specified  on  the  kernel command line (taking a
       boolean), it will override  the  result  of  this  condition  check,  taking  precedence  over  any  file
       modification  time  checks. If the kernel command line option is used, "systemd-update-done.service" will
       not have immediate effect on any following "ConditionNeedsUpdate" checks, until the  system  is  rebooted
       where the kernel command line option is not specified anymore.

       Note  that to make this scheme effective, the timestamp of "<a href="file:/usr/">/usr/</a>" should be explicitly updated after its
       contents are modified. The kernel will automatically update modification timestamp on  a  directory  only
       when  immediate  children  of  a  directory  are  modified;  an  modification  of  nested  files will not
       automatically result in mtime of "<a href="file:/usr/">/usr/</a>" being updated.

       Also note that if the update method includes a call to execute appropriate post-update steps  itself,  it
       should  not  touch the timestamp of "<a href="file:/usr/">/usr/</a>". In a typical distribution packaging scheme, packages will do
       any required update steps as part of the installation or upgrade, to make  package  contents  immediately
       usable. "ConditionNeedsUpdate" should be used with other update mechanisms where such an immediate update
       does not happen.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>enum.</u>

   <b>ConditionFirstBoot</b>
       Takes  a  boolean  argument.  This condition may be used to conditionalize units on whether the system is
       booting up for the first time. This roughly means that "<a href="file:/etc/">/etc/</a>" was unpopulated when  the  system  started
       booting  (for  details,  see "First Boot Semantics" in <b><a href="../man5/machine-id.5.html">machine-id</a></b>(5)).  First Boot is considered finished
       (this condition will evaluate as false) after the manager has finished the startup phase.

       This condition may be used to populate "<a href="file:/etc/">/etc/</a>" on the first boot after  factory  reset,  or  when  a  new
       system instance boots up for the first time.

       Note  that  the  service  manager  itself  will perform setup steps during First Boot: it will initialize
       <b><a href="../man5/machine-id.5.html">machine-id</a></b>(5) and preset all units,  enabling  or  disabling  them  according  to  the  <b><a href="../man5/systemd.preset.5.html">systemd.preset</a></b>(5)
       settings. Additional setup may be performed via units with "ConditionFirstBoot=yes".

       For    robustness,    units    with    "ConditionFirstBoot=yes"    should    order    themselves   before
       "first-boot-complete.target" and pull in this passive target with "Wants". This ensures that in a case of
       an aborted first boot, these units will be re-run during the next system startup.

       If the "systemd.condition_first_boot=" option is specified on the kernel command line (taking a boolean),
       it will override the result of this condition check, taking precedence over  "<a href="file:/etc/machine-id">/etc/machine-id</a>"  existence
       checks.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>boolean.</u>

   <b>ConditionPathExists</b>
       Check for the existence of a file. If the specified absolute path name does not exist, the condition will
       fail.  If  the  absolute  path  name passed to "ConditionPathExists" is prefixed with an exclamation mark
       ("!"), the test is negated, and the unit is only started if the path does not exist.  <u>Optional.</u> <u>Type</u> <u>list</u>
       <u>of</u> <u>uniline.</u>

   <b>ConditionPathExistsGlob</b>
       "ConditionPathExistsGlob" is similar to "ConditionPathExists", but checks for the existence of  at  least
       one file or directory matching the specified globbing pattern.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionPathIsDirectory</b>
       "ConditionPathIsDirectory"  is  similar  to "ConditionPathExists" but verifies that a certain path exists
       and is a directory.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionPathIsSymbolicLink</b>
       "ConditionPathIsSymbolicLink" is similar to "ConditionPathExists" but verifies that a certain path exists
       and is a symbolic link.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionPathIsMountPoint</b>
       "ConditionPathIsMountPoint" is similar to "ConditionPathExists" but verifies that a certain  path  exists
       and is a mount point.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionPathIsReadWrite</b>
       "ConditionPathIsReadWrite"  is  similar  to  "ConditionPathExists"  but verifies that the underlying file
       system is readable and writable (i.e. not mounted read-only).  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionPathIsEncrypted</b>
       "ConditionPathIsEncrypted" is similar to "ConditionPathExists" but  verifies  that  the  underlying  file
       system's  backing block device is encrypted using dm-crypt/LUKS. Note that this check does not cover ext4
       per-directory encryption, and only detects block  level  encryption.  Moreover,  if  the  specified  path
       resides  on a file system on top of a loopback block device, only encryption above the loopback device is
       detected. It is not detected whether the file system backing the  loopback  block  device  is  encrypted.
       <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionDirectoryNotEmpty</b>
       "ConditionDirectoryNotEmpty"  is similar to "ConditionPathExists" but verifies that a certain path exists
       and is a non-empty directory.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionFileNotEmpty</b>
       "ConditionFileNotEmpty" is similar to "ConditionPathExists" but verifies that a certain path  exists  and
       refers to a regular file with a non-zero size.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionFileIsExecutable</b>
       "ConditionFileIsExecutable"  is similar to "ConditionPathExists" but verifies that a certain path exists,
       is a regular file, and marked executable.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionUser</b>
       "ConditionUser" takes a numeric "UID", a UNIX user name, or the special value @system. This condition may
       be used to check whether the service manager is running as the given user. The special value @system  can
       be  used  to  check  if the user id is within the system user range. This option is not useful for system
       services, as the system manager exclusively runs as the root user, and thus the test result is  constant.
       <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionGroup</b>
       "ConditionGroup"  is similar to "ConditionUser" but verifies that the service manager's real or effective
       group, or any of its auxiliary groups, match the specified group or GID. This setting  does  not  support
       the special value @system.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionControlGroupController</b>
       Check  whether  given  cgroup controllers (e.g. "cpu") are available for use on the system or whether the
       legacy v1 cgroup or the modern v2 cgroup hierarchy is used.

       Multiple controllers may be passed with a space separating them; in this case  the  condition  will  only
       pass  if  all listed controllers are available for use. Controllers unknown to systemd are ignored. Valid
       controllers are "cpu", "io", "memory", and  "pids".  Even  if  available  in  the  kernel,  a  particular
       controller   may   not   be   available   if   it   was   disabled   on  the  kernel  command  line  with
       "cgroup_disable=controller".

       Alternatively, two special strings "v1" and "v2" may be specified (without any  controller  names).  "v2"
       will  pass  if  the unified v2 cgroup hierarchy is used, and "v1" will pass if the legacy v1 hierarchy or
       the hybrid hierarchy are used.  Note  that  legacy  or  hybrid  hierarchies  have  been  deprecated.  See
       <b><a href="../man1/systemd.1.html">systemd</a></b>(1) for more information.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionMemory</b>
       Verify that the specified amount of system memory is available to the current system. Takes a memory size
       in  bytes  as argument, optionally prefixed with a comparison operator "&lt;", "&lt;=", "=" (or "=="), "!=" (or
       "&lt;&gt;"), "&gt;=", "&gt;". On bare-metal systems compares the amount of physical memory in  the  system  with  the
       specified  size,  adhering  to  the  specified  comparison operator. In containers compares the amount of
       memory assigned to the container instead.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionCPUs</b>
       Verify that the specified number of CPUs is available to the current system. Takes a number  of  CPUs  as
       argument,  optionally prefixed with a comparison operator "&lt;", "&lt;=", "=" (or "=="), "!=" (or "&lt;&gt;"), "&gt;=",
       "&gt;". Compares the number of CPUs in the CPU affinity mask configured of the service manager  itself  with
       the  specified  number,  adhering to the specified comparison operator. On physical systems the number of
       CPUs in the affinity mask of the service manager usually matches the number  of  physical  CPUs,  but  in
       special  and  virtual  environments  might differ. In particular, in containers the affinity mask usually
       matches the number of CPUs assigned to the container and not the physically  available  ones.   <u>Optional.</u>
       <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionCPUFeature</b>
       Verify  that  a  given  CPU  feature  is  available via the "CPUID" instruction. This condition only does
       something on i386 and x86-64 processors. On other processors it is assumed that the CPU does not  support
       the given feature. It checks the leaves 1, 7, 0x80000001, and 0x80000007. Valid values are: "fpu", "vme",
       "de",  "pse",  "tsc",  "msr",  "pae",  "mce",  "cx8", "apic", "sep", "mtrr", "pge", "mca", "cmov", "pat",
       "pse36", "clflush", "mmx", "fxsr", "sse", "sse2", "ht",  "pni",  "pclmul",  "monitor",  "ssse3",  "fma3",
       "cx16",  "sse4_1",  "sse4_2",  "movbe",  "popcnt",  "aes",  "xsave",  "osxsave", "avx", "f16c", "rdrand",
       "bmi1",  "avx2",  "bmi2",  "rdseed",  "adx",  "sha_ni",  "syscall",  "rdtscp",  "lm",  "lahf_lm",  "abm",
       "constant_tsc".  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionOSRelease</b>
       Verify that a specific "key=value" pair is set in the host's <b><a href="../man5/os-release.5.html">os-release</a></b>(5).

       Other  than  exact  string matching (with "=" and "!="), relative comparisons are supported for versioned
       parameters (e.g. "VERSION_ID";  with  "&lt;",  "&lt;=",  "==",  "&lt;&gt;",  "&gt;=",  "&gt;"),  and  shell-style  wildcard
       comparisons ("*", "?", "[]") are supported with the $= (match) and "!$=" (non-match).

       If the given key is not found in the file, the match is done against an empty value.  <u>Optional.</u> <u>Type</u> <u>list</u>
       <u>of</u> <u>uniline.</u>

   <b>ConditionMemoryPressure</b>
       Verify  that  the  overall  system  (memory,  CPU or IO) pressure is below or equal to a threshold.  This
       setting takes a threshold value as argument. It can be specified as a simple percentage  value,  suffixed
       with "%", in which case the pressure will be measured as an average over the last five minutes before the
       attempt  to start the unit is performed.  Alternatively, the average timespan can also be specified using
       "/" as a separator, for example: "10%/1min". The supported timespans match what the kernel provides,  and
       are  limited to "10sec", "1min" and "5min". The "full" PSI will be checked first, and if not found "some"
       will  be  checked.  For  more  details,  see  the  documentation  on  PSI  (Pressure  Stall  Information)
       &lt;https://docs.kernel.org/accounting/psi.html&gt;.

       Optionally,  the  threshold  value  can  be prefixed with the slice unit under which the pressure will be
       checked, followed by a ":". If the slice unit is not specified,  the  overall  system  pressure  will  be
       measured, instead of a particular cgroup's.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionCPUPressure</b>
       Verify  that  the  overall  system  (memory,  CPU or IO) pressure is below or equal to a threshold.  This
       setting takes a threshold value as argument. It can be specified as a simple percentage  value,  suffixed
       with "%", in which case the pressure will be measured as an average over the last five minutes before the
       attempt  to start the unit is performed.  Alternatively, the average timespan can also be specified using
       "/" as a separator, for example: "10%/1min". The supported timespans match what the kernel provides,  and
       are  limited to "10sec", "1min" and "5min". The "full" PSI will be checked first, and if not found "some"
       will  be  checked.  For  more  details,  see  the  documentation  on  PSI  (Pressure  Stall  Information)
       &lt;https://docs.kernel.org/accounting/psi.html&gt;.

       Optionally,  the  threshold  value  can  be prefixed with the slice unit under which the pressure will be
       checked, followed by a ":". If the slice unit is not specified,  the  overall  system  pressure  will  be
       measured, instead of a particular cgroup's.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>ConditionIOPressure</b>
       Verify  that  the  overall  system  (memory,  CPU or IO) pressure is below or equal to a threshold.  This
       setting takes a threshold value as argument. It can be specified as a simple percentage  value,  suffixed
       with "%", in which case the pressure will be measured as an average over the last five minutes before the
       attempt  to start the unit is performed.  Alternatively, the average timespan can also be specified using
       "/" as a separator, for example: "10%/1min". The supported timespans match what the kernel provides,  and
       are  limited to "10sec", "1min" and "5min". The "full" PSI will be checked first, and if not found "some"
       will  be  checked.  For  more  details,  see  the  documentation  on  PSI  (Pressure  Stall  Information)
       &lt;https://docs.kernel.org/accounting/psi.html&gt;.

       Optionally,  the  threshold  value  can  be prefixed with the slice unit under which the pressure will be
       checked, followed by a ":". If the slice unit is not specified,  the  overall  system  pressure  will  be
       measured, instead of a particular cgroup's.  <u>Optional.</u> <u>Type</u> <u>list</u> <u>of</u> <u>uniline.</u>

   <b>AssertArchitecture</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertVirtualization</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertHost</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertKernelCommandLine</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertKernelVersion</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertCredential</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertEnvironment</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertSecurity</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertCapability</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertACPower</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertNeedsUpdate</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertFirstBoot</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertPathExists</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertPathExistsGlob</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertPathIsDirectory</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertPathIsSymbolicLink</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertPathIsMountPoint</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertPathIsReadWrite</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertPathIsEncrypted</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertDirectoryNotEmpty</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertFileNotEmpty</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertFileIsExecutable</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertUser</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertGroup</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertControlGroupController</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertMemory</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertCPUs</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertCPUFeature</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertOSRelease</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertMemoryPressure</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertCPUPressure</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any  assertion  setting  that  is not met results in failure of the start job (which means this is logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in fact result in any state change of the unit), it affects only the job queued  for  it.  Use  assertion
       expressions  for  units  that  cannot  operate  when  specific requirements are not met, and when this is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>AssertIOPressure</b>
       Similar to the "ConditionArchitecture", "ConditionVirtualization", …, condition settings described above,
       these settings add assertion checks to the start-up of the unit. However, unlike the conditions settings,
       any assertion setting that is not met results in failure of the start job (which  means  this  is  logged
       loudly). Note that hitting a configured assertion does not cause the unit to enter the "failed" state (or
       in  fact  result  in  any state change of the unit), it affects only the job queued for it. Use assertion
       expressions for units that cannot operate when specific requirements  are  not  met,  and  when  this  is
       something the administrator or user should look into.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>StartLimitInterval</b>
       <b>Deprecated</b>  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>OnFailureIsolate</b>
       <b>Deprecated</b>  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

   <b>FailureAction</b>
       Configure  the action to take when the unit stops and enters a failed state or inactive state.  Takes one
       of    "none",    "reboot",    "reboot-force",    "reboot-immediate",    "poweroff",     "poweroff-force",
       "poweroff-immediate",  "exit",  "exit-force", "soft-reboot", "soft-reboot-force", "kexec", "kexec-force",
       "halt", "halt-force" and "halt-immediate". In system mode, all options are allowed. In  user  mode,  only
       "none", "exit", and "exit-force" are allowed. Both options default to "none".

       If  "none"  is  set,  no action will be triggered. "reboot" causes a reboot following the normal shutdown
       procedure (i.e. equivalent to systemctl reboot).   "reboot-force"  causes  a  forced  reboot  which  will
       terminate  all  processes  forcibly  but should cause no dirty file systems on reboot (i.e. equivalent to
       systemctl reboot -f) and "reboot-immediate" causes immediate execution  of  the  <b><a href="../man2/reboot.2.html">reboot</a></b>(2)  system  call,
       which  might  result  in  data  loss  (i.e.  equivalent to systemctl reboot -ff).  Similarly, "poweroff",
       "poweroff-force", "poweroff-immediate", "kexec", "kexec-force", "halt", "halt-force" and "halt-immediate"
       have the effect of powering down the system, executing kexec, and halting the  system  respectively  with
       similar  semantics.  "exit"  causes  the  manager  to  exit  following the normal shutdown procedure, and
       "exit-force" causes it terminate without shutting down services. When "exit" or "exit-force" is  used  by
       default  the  exit  status of the main process of the unit (if this applies) is returned from the service
       manager. However, this may be overridden  with  "FailureActionExitStatus"/"SuccessActionExitStatus",  see
       below.   "soft-reboot" will trigger a userspace reboot operation.  "soft-reboot-force" does that too, but
       does not  go  through  the  shutdown  transaction  beforehand.   <u>Optional.</u>  <u>Type</u>  <u>enum.</u>  <u>choice:</u>  <u>'exit',</u>
       <u>'exit-force',</u>   <u>'halt',</u>  <u>'halt-force',</u>  <u>'halt-immediate',</u>  <u>'kexec',</u>  <u>'kexec-force',</u>  <u>'none',</u>  <u>'poweroff',</u>
       <u>'poweroff-force',</u>  <u>'poweroff-immediate',</u>  <u>'reboot',</u>  <u>'reboot-force',</u>  <u>'reboot-immediate',</u>  <u>'soft-reboot',</u>
       <u>'soft-reboot-force'.</u>

       Note: FailureAction is migrated with '$service' and with:

       •   $service =&gt; "- - Service FailureAction"

   <b>SuccessAction</b>
       Configure  the action to take when the unit stops and enters a failed state or inactive state.  Takes one
       of    "none",    "reboot",    "reboot-force",    "reboot-immediate",    "poweroff",     "poweroff-force",
       "poweroff-immediate",  "exit",  "exit-force", "soft-reboot", "soft-reboot-force", "kexec", "kexec-force",
       "halt", "halt-force" and "halt-immediate". In system mode, all options are allowed. In  user  mode,  only
       "none", "exit", and "exit-force" are allowed. Both options default to "none".

       If  "none"  is  set,  no action will be triggered. "reboot" causes a reboot following the normal shutdown
       procedure (i.e. equivalent to systemctl reboot).   "reboot-force"  causes  a  forced  reboot  which  will
       terminate  all  processes  forcibly  but should cause no dirty file systems on reboot (i.e. equivalent to
       systemctl reboot -f) and "reboot-immediate" causes immediate execution  of  the  <b><a href="../man2/reboot.2.html">reboot</a></b>(2)  system  call,
       which  might  result  in  data  loss  (i.e.  equivalent to systemctl reboot -ff).  Similarly, "poweroff",
       "poweroff-force", "poweroff-immediate", "kexec", "kexec-force", "halt", "halt-force" and "halt-immediate"
       have the effect of powering down the system, executing kexec, and halting the  system  respectively  with
       similar  semantics.  "exit"  causes  the  manager  to  exit  following the normal shutdown procedure, and
       "exit-force" causes it terminate without shutting down services. When "exit" or "exit-force" is  used  by
       default  the  exit  status of the main process of the unit (if this applies) is returned from the service
       manager. However, this may be overridden  with  "FailureActionExitStatus"/"SuccessActionExitStatus",  see
       below.   "soft-reboot" will trigger a userspace reboot operation.  "soft-reboot-force" does that too, but
       does not  go  through  the  shutdown  transaction  beforehand.   <u>Optional.</u>  <u>Type</u>  <u>enum.</u>  <u>choice:</u>  <u>'exit',</u>
       <u>'exit-force',</u>   <u>'halt',</u>  <u>'halt-force',</u>  <u>'halt-immediate',</u>  <u>'kexec',</u>  <u>'kexec-force',</u>  <u>'none',</u>  <u>'poweroff',</u>
       <u>'poweroff-force',</u>  <u>'poweroff-immediate',</u>  <u>'reboot',</u>  <u>'reboot-force',</u>  <u>'reboot-immediate',</u>  <u>'soft-reboot',</u>
       <u>'soft-reboot-force'.</u>

       Note: SuccessAction is migrated with '$service' and with:

       •   $service =&gt; "- - Service SuccessAction"

   <b>StartLimitBurst</b>
       Configure unit start rate limiting. Units which are started more than burst times within an interval time
       span  are not permitted to start any more. Use "StartLimitIntervalSec" to configure the checking interval
       and "StartLimitBurst" to configure how many starts per interval are allowed.

       interval is a time span with the default  unit  of  seconds,  but  other  units  may  be  specified,  see
       <b><a href="../man7/systemd.time.7.html">systemd.time</a></b>(7).   The  special value "infinity" can be used to limit the total number of start attempts,
       even if they happen at large time  intervals.   Defaults  to  "DefaultStartLimitIntervalSec"  in  manager
       configuration  file,  and  may  be  set  to 0 to disable any kind of rate limiting. burst is a number and
       defaults to "DefaultStartLimitBurst" in manager configuration file.

       These configuration options are particularly useful in conjunction with  the  service  setting  "Restart"
       (see  <b><a href="../man5/systemd.service.5.html">systemd.service</a></b>(5));  however, they apply to all kinds of starts (including manual), not just those
       triggered by the "Restart" logic.

       Note that units which are configured for "Restart", and which reach the start limit are not attempted  to
       be  restarted anymore; however, they may still be restarted manually or from a timer or socket at a later
       point, after the interval has passed.  From  that  point  on,  the  restart  logic  is  activated  again.
       systemctl  reset-failed  will cause the restart rate counter for a service to be flushed, which is useful
       if the administrator wants to manually start a unit and the  start  limit  interferes  with  that.  Rate-
       limiting  is  enforced  after  any  unit  condition  checks are executed, and hence unit activations with
       failing conditions do not count towards the rate limit.

       When a unit is unloaded due to the garbage collection logic (see  above)  its  rate  limit  counters  are
       flushed  out  too.  This  means  that  configuring  start rate limiting for a unit that is not referenced
       continuously has no effect.

       This setting does not apply to slice, target, device, and scope units, since they are  unit  types  whose
       activation may either never fail, or may succeed only a single time.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

       Note: StartLimitBurst is migrated with '$service' and with:

       •   $service =&gt; "- - Service StartLimitBurst"

   <b>StartLimitIntervalSec</b>
       Configure unit start rate limiting. Units which are started more than burst times within an interval time
       span  are not permitted to start any more. Use "StartLimitIntervalSec" to configure the checking interval
       and "StartLimitBurst" to configure how many starts per interval are allowed.

       interval is a time span with the default  unit  of  seconds,  but  other  units  may  be  specified,  see
       <b><a href="../man7/systemd.time.7.html">systemd.time</a></b>(7).   The  special value "infinity" can be used to limit the total number of start attempts,
       even if they happen at large time  intervals.   Defaults  to  "DefaultStartLimitIntervalSec"  in  manager
       configuration  file,  and  may  be  set  to 0 to disable any kind of rate limiting. burst is a number and
       defaults to "DefaultStartLimitBurst" in manager configuration file.

       These configuration options are particularly useful in conjunction with  the  service  setting  "Restart"
       (see  <b><a href="../man5/systemd.service.5.html">systemd.service</a></b>(5));  however, they apply to all kinds of starts (including manual), not just those
       triggered by the "Restart" logic.

       Note that units which are configured for "Restart", and which reach the start limit are not attempted  to
       be  restarted anymore; however, they may still be restarted manually or from a timer or socket at a later
       point, after the interval has passed.  From  that  point  on,  the  restart  logic  is  activated  again.
       systemctl  reset-failed  will cause the restart rate counter for a service to be flushed, which is useful
       if the administrator wants to manually start a unit and the  start  limit  interferes  with  that.  Rate-
       limiting  is  enforced  after  any  unit  condition  checks are executed, and hence unit activations with
       failing conditions do not count towards the rate limit.

       When a unit is unloaded due to the garbage collection logic (see  above)  its  rate  limit  counters  are
       flushed  out  too.  This  means  that  configuring  start rate limiting for a unit that is not referenced
       continuously has no effect.

       This setting does not apply to slice, target, device, and scope units, since they are  unit  types  whose
       activation may either never fail, or may succeed only a single time.  <u>Optional.</u> <u>Type</u> <u>uniline.</u>

       Note: StartLimitIntervalSec is migrated with '"$unit || $service"' and with:

       •   $service =&gt; "- - Service StartLimitInterval"

       •   $unit =&gt; "- StartLimitInterval"

   <b>RebootArgument</b>
       Configure the optional argument for the <b><a href="../man2/reboot.2.html">reboot</a></b>(2) system call if "StartLimitAction" or "FailureAction" is
       a  reboot action. This works just like the optional argument to systemctl reboot command.  <u>Optional.</u> <u>Type</u>
       <u>uniline.</u>

       Note: RebootArgument is migrated with '$service' and with:

       •   $service =&gt; "- - Service RebootArgument"

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   cme

perl v5.40.1                                       2025-04-26             <u>Config::Model::...on::<a href="../man3pm/ServiceUnit.3pm.html">ServiceUnit</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>