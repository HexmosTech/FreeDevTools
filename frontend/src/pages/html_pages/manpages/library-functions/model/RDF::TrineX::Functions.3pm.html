<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RDF::TrineX::Functions - some shortcut functions for RDF::Trine's object-oriented interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librdf-trinex-functions-perl">librdf-trinex-functions-perl_0.005-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       RDF::TrineX::Functions - some shortcut functions for RDF::Trine's object-oriented interface

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use RDF::TrineX::Functions -all;

         my $model = model();
         parse('/tmp/mydata.rdf', into =&gt; $model);

         $model-&gt;add_statement(statement(
             iri('<a href="http://example.com/">http://example.com/</a>'),
             iri('<a href="http://purl.org/dc/terms/title">http://purl.org/dc/terms/title</a>'),
             "An Example",
         ));

         print RDF::Trine::Serializer
             -&gt; new('Turtle')
             -&gt; serialize_model_to_string($model);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a replacement for the venerable RDF::TrineShortcuts. Not a drop-in replacement. It has fewer
       features, fewer dependencies, less hackishness, less magic and fewer places it can go wrong.

       It uses Sub::Exporter, which allows exported functions to be renamed easily:

         use RDF::TrineX::Functions
           parse =&gt; { -as =&gt; 'parse_rdf' };

   <b>Functions</b>
       "iri", "literal", "blank", "variable"
           As per the similarly named functions exported by RDF::Trine itself.

           These  are  wrapped  with  a  very tiny bit of DWIMmery. A blessed URI object passed to "iri" will be
           handled properly; a blessed URI object passed to "literal" will default the datatype  to  xsd:anyURI.
           A  string  starting with "_:" passed to either "iri" or "blank" will correctly create a blank node. A
           string starting with "?" passed to either "blank" or "variable" will correctly create a variable.  If
           any of them are passed an existing RDF::Trine::Node, it will be passed through untouched.

           Other than that, no magic.

       "curie"
           Like "iri" but passes strings through RDF::NS::Trine.

       statement(@nodes)
           As per the similarly named function exported by RDF::Trine itself.

           Again,  a  tiny  bit  of DWIMmery: blessed URI objects are passed through "iri" and unblessed scalars
           (i.e. strings) are assumed to be literals.

       "store"
           As per the similarly named function exported by RDF::Trine itself.

       "model"
           Returns a new RDF::Trine::Model. May be passed a store as a parameter.

       "parse($source, %options)"
           Parses the source and returns an RDF::Trine::Model. The source may be:

           •   a URI

               A string URI, blessed URI object or  RDF::Trine::Node::Resource,  which  will  be  retrieved  and
               parsed.

           •   a file

               A  filehandle,  Path::Class::File,  IO::All,  IO::Handle  object, or the name of an existing file
               (i.e. a scalar string). The file will be read and parsed.

               Except in the case of Path::Class::File, IO::All and  strings,  you  need  to  tell  the  "parse"
               function what parser to use, and what base URI to use.

           •   a string

               You need to tell the "parse" function what parser to use, and what base URI to use.

           •   a model or store

               An existing model or store, which will just be returned as-is.

           •   undef

               Returns an empty model.

           The  "parser"  option  can  be used to provide a blessed RDF::Trine::Parser object to use; the "type"
           option can be used instead to provide a media type hint. The "base" option provides the base URI. The
           "model" option can be used to tell this  function  to  parse  into  an  existing  model  rather  than
           returning a new one. The "graph" option may be used to provide a graph URI.

           "into"  is  an  alias for "model"; "type", "using" and "as" are aliases for "parser"; "context" is an
           alias for "graph".

           Examples:

             my $model = parse('/tmp/data.ttl', as =&gt; 'Turtle');

             my $data   = iri('<a href="http://example.com/data.nt">http://example.com/data.nt</a>');
             my $parser = RDF::Trine::Parser::NTriples-&gt;new;
             my $model  = model();

             parse($data, using =&gt; $parser, into =&gt; $model);

       "serialize($data, %options)"
           Serializes the data (which can be an RDF::Trine::Model or an RDF::Trine::Iterator) and returns it  as
           a string.

           The  "serializer"  option  can be used to provide a blessed RDF::Trine::Serializer object to use; the
           "type" option can be used instead to provide a type hint. The "output" option can be used to  provide
           a filehandle, IO::All, Path::Class::File or file name to write to instead of returning the results as
           a string.

           "to" and "file" are aliases for "output"; "type", "using" and "as" are aliases for "serializer".

           Examples:

             print serialize($model, as =&gt; 'Turtle');

             my $file = Path::Class::File-&gt;new('/tmp/data.nt');
             serialize($iterator, to =&gt; $file, as =&gt; 'NTriples');

   <b>Array</b> <b>References</b>
       In  addition to the above interface, each function supports being called with a single arrayref argument.
       In those cases, the arrayref is dereferenced into an array, and treated as a list of arguments. That  is,
       the following are equivalent:

         foo($bar, $baz);
         foo([$bar, $baz]);

       This is handy if you're writing a module of your own and wish to accept some RDF data:

         sub my_method {
           my ($self, $rdf, $foo) = @_;
           $rdf = parse($rdf);

           ....
         }

       Your method can now be called like this:

         $object-&gt;my_method($model, 'foo');

         $object-&gt;my_method($url, 'foo');

         $object-&gt;my_method(
             [ $filehandle, as =&gt; 'Turtle', base =&gt; $uri ],
             'foo',
         );

   <b>Export</b>
       By default, nothing is exported. You need to request things:

         use RDF::TrineX::Functions qw&lt; iri literal blank statement model &gt;;

       Thanks to Sub::Exporter, you can rename functions:

         use RDF::TrineX::Functions
           qw&lt; literal statement model &gt;,
           blank =&gt; { -as =&gt; 'bnode' },
           iri   =&gt; { -as =&gt; 'resource' };

       If you want to export everything, you can do:

         use RDF::TrineX::Functions -all;

       To export just the functions which generate RDF::Trine::Node objects:

         use RDF::TrineX::Functions -nodes;

       Or maybe even:

         use RDF::TrineX::Functions -nodes =&gt; { -suffix =&gt; '_node' };

       If you want to export something roughly compatible with the old RDF::TrineShortcuts, then there's:

         use RDF::TrineX::Functions -shortcuts;

       When exporting the "serialize" function you may set a default format:

         use RDF::TrineX::Functions
             serialize =&gt; { -type =&gt; 'NTriples' };

       This will be used when "serialize" is called with no explicit type given.

   <b>Pseudo-OO</b> <b>interface</b>
       "new"
           This acts as a constructor, returning a new RDF::TrineX::Functions object.

       All the normal functions can be called as methods:

        my $R = RDF::TrineX::Functions-&gt;new;
        my $model = $R-&gt;model;

       There's  no  real  advantage  to  using  this  module  as  an object, but it can help you avoid namespace
       pollution.

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs to &lt;<a href="http://rt.cpan.org/Dist/Display.html">http://rt.cpan.org/Dist/Display.html</a>?Queue=RDF-TrineX-Functions&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       RDF::Trine, RDF::QueryX::Lazy, RDF::NS.

</pre><h4><b>AUTHOR</b></h4><pre>
       Toby Inkster &lt;<a href="mailto:tobyink@cpan.org">tobyink@cpan.org</a>&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2012 by Toby Inkster.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTIES</b></h4><pre>
       THIS  PACKAGE  IS  PROVIDED  "AS  IS"  AND  WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
       LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

perl v5.38.2                                       2024-03-07                        <u>RDF::TrineX::<a href="../man3pm/Functions.3pm.html">Functions</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>