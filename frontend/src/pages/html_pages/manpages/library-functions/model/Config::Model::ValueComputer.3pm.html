<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Config::Model::ValueComputer - Provides configuration value computation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libconfig-model-perl">libconfig-model-perl_2.155-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Config::Model::ValueComputer - Provides configuration value computation

</pre><h4><b>VERSION</b></h4><pre>
       version 2.155

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Config::Model;

        # define configuration tree object
        my $model = Config::Model-&gt;new;
        $model -&gt;create_config_class (
           name =&gt; "MyClass",

           element =&gt; [
              [qw/av bv/] =&gt; {
                  type =&gt; 'leaf',
                  value_type =&gt; 'integer',
              },
              compute_int =&gt; {
                      type =&gt; 'leaf',
                      value_type =&gt; 'integer',
                      compute    =&gt; {
                          formula   =&gt; '$a + $b',
                          variables =&gt; { a =&gt; '- av', b =&gt; '- bv'}
                      },
              },
           ],
        );

        my $inst = $model-&gt;instance(root_class_name =&gt; 'MyClass' );

        my $root = $inst-&gt;config_root ;

        # put data
        $root-&gt;load( steps =&gt; 'av=33 bv=9' );

        print "Computed value is ",$root-&gt;grab_value('compute_int'),"\n";
        # Computed value is 42

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class provides a way to compute a configuration value. This computation uses a formula and some
       other configuration values from the configuration tree.

       The computed value can be overridden, in other words, the computed value can be used as a default value.

</pre><h4><b>Computed</b> <b>value</b> <b>declaration</b></h4><pre>
       A computed value must be declared in a 'leaf' element. The leaf element must have a "compute" argument
       pointing to a hash ref.

       This array ref contains:

       •   A string formula that use variables and replace function.

       •   A  set  of  variable  and  their  relative location in the tree (using the notation explained in grab
           method

       •   An optional set of replace rules.

       •   An optional parameter to force a Perl eval of a string.

       <b>Note</b>: A variable must point to a valid  location  in  the  configuration  tree.  Even  when  &amp;index()  or
       "$replace{}"  is  used.  After  substitution  of these functions, the string is used as a path (See grab)
       starting from the computed value. Hence the path must begin with "!" to go back to root node, or  "-"  to
       go up a level.

   <b>Compute</b> <b>formula</b>
       The  first  element  of  the "compute" array ref must be a string that contains the computation algorithm
       (i.e. a formula for arithmetic computation for integer values or a string template for string values).

       This string or formula should contain variables (like $foo or $bar). Note that these  variables  are  not
       interpolated by Perl.

       For instance:

         'My cat has $nb legs'
         '$m * $c**2'

       This string or formula may also contain:

       •   The index value of the current object : &amp;index or &amp;index().

       •   The  index value of a parent object: &amp;index(-). Ancestor index value can be retrieved with &amp;index(-2)
           or &amp;index(-3) or "&amp;index(- -)" or "&amp;index(- - -)"

       •   The element name of the current object: &amp;element or &amp;element().

       •   The element name of a parent object: &amp;element(-). Likewise, ancestor element name  can  be  retrieved
           with &amp;element(-2) or &amp;element(-3).

       •   The full location (path) of the current object: &amp;location or &amp;location().

       For instance, you could have this template string:

          'my element is &amp;element, my index is &amp;index' .
           'upper element is &amp;element(-), upper index is &amp;index(-)',

       If  you  need  to  perform  more  complex  operations  than  substitution,  like  extraction with regular
       expressions, you can force an eval done by Perl with "use_eval =&gt; 1". In this case,  the  result  of  the
       eval is used as the computed value.

       For instance:

         # extract host from url
         compute =&gt; {
             formula =&gt; '$old =~ m!http://[\w\.]+(?::\d+)?(<a href="file:/.">/.</a>*)!; $1 ;',
             variables =&gt; { old =&gt; '- url' } ,
                 use_eval =&gt; 1 ,
         },

         # capitalize
         compute =&gt; {
             formula =&gt; 'uc($old)',
                 variables =&gt; { old =&gt; '- small_caps' } ,
                 use_eval =&gt; 1
         }

   <b>Compute</b> <b>variables</b>
       Compute  variables  are  a  set  of  "key =&gt; value" pairs that define the variables used in the specified
       formula. The key is a variable name used in the string that represents the formula. The value is a string
       that is used to get the correct Value object.

       In this numeric example, "result" default value is "av + bv":

        element =&gt; [
           av =&gt; {
               type =&gt; 'leaf',
               value_type =&gt; 'integer'
           },
           bv =&gt; {
               type =&gt; 'leaf',
               value_type =&gt; 'integer'
           },
           result =&gt; {
               type =&gt; 'leaf',
               value_type =&gt; 'integer',
               compute =&gt; {
                   formula =&gt; '$a + $b' ,
                   variables =&gt; { a =&gt; '- av', b =&gt; '- bv' },
               }
           }
        ]

       In this string example, the default value of the "Comp" element is actually a string made of  ""macro  is
       "" and the value of the ""macro"" element of the object located 2 nodes above:

        comp =&gt; {
           type =&gt; 'leaf',
           value_type =&gt; 'string',
           compute =&gt; {
               formula =&gt; '"macro is $m"' ,
               variables =&gt; { m =&gt; '- - macro' }
           }
        }

   <b>Compute</b> <b>replace</b>
       Sometime,  using  the value of a tree leaf is not enough and you need to substitute a replacement for any
       value you can get. This replacement can be done using a hash like notation within the formula  using  the
       %replace hash.

       For instance, if you want to display a summary of a config, you can do :

        compute_with_replace =&gt; {
            formula =&gt; '$replace{$who} is the $replace{$what} of $replace{$country}',
            variables =&gt; {
                who   =&gt; '! who' ,
                what  =&gt; '! what' ,
                country =&gt; '- country',
            },
            replace =&gt; {
                chief =&gt; 'president',
                America =&gt; 'USA'
            }
        }

   <b>Complex</b> <b>formula</b>
       &amp;index, &amp;element, and replace can be combined. But the argument of &amp;element or &amp;index can only be a value
       object  specification  (I.e.  something  like  '"-  - foo"'), it cannot be a value replacement of another
       &amp;element or &amp;index.

       I.e. &amp;element($foo) is ok, but "&amp;element(&amp;index($foo))" is not allowed.

   <b>computed</b> <b>variable</b>
       Compute variables can themselves be computed :

        compute =&gt; {
           formula =&gt; 'get_element is $replace{$s}, indirect value is \'$v\'',
           variables =&gt; {
               s =&gt; '! $where',
               where =&gt; '! where_is_element',
               v =&gt; '! $replace{$s}',
           }
           replace =&gt; {
               m_value_element =&gt; 'm_value',
               compute_element =&gt; 'compute'
           }
        }

       Be sure not to specify a loop when doing recursive computation.

       The function &amp;index &amp;element and &amp;location are also allowed.

   <b>compute</b> <b>override</b>
       In some case, a computed value must be interpreted as a default value  and  the  user  must  be  able  to
       override  this computed default value.  In this case, you must use "allow_override =&gt; 1" with the compute
       parameter:

        computed_value_with_override =&gt; {
           type =&gt; 'leaf',
           value_type =&gt; 'string',
           compute =&gt; {
               formula =&gt; '"macro is $m"' ,
               variables =&gt; { m =&gt; '- - macro' } ,
               allow_override =&gt; 1,
           }
        }

       This computed default value is written to the configuration file.

       This default value may be already known by the application so the computed value should <b>not</b> be written to
       the configuration file. The computed value is interesting because it cab be shown to the  user.  In  this
       case, use the "use_as_upstream_default" parameter:

        compute_known_upstream =&gt; {
           type =&gt; 'leaf',
           value_type =&gt; 'string',
           compute =&gt; {
               formula =&gt; '"macro is $m"' ,
               variables =&gt; { m =&gt; '- - macro' } ,
               use_as_upstream_default =&gt; 1,
           }
        }

       "use_as_upstream_default" implies "allow_override".

   <b>Undefined</b> <b>variables</b>
       You  may  need  to  compute  value  where  one  of  the variables (i.e. other configuration parameter) is
       undefined. By default, any formula yields an undefined value if one variable is undefined.

       You may change this behavior with "undef_is" parameter. With this parameter, you can specify a "fallback"
       value that is used in your formula instead of an undefined variable.

       The most useful fallback values are:

        undef_is =&gt; "''", # for string values
        undef_is =&gt; 0   , # for integers, boolean values

       Example:

        Source =&gt; {
           type =&gt; 'leaf',
           value_type   =&gt; 'string',
           mandatory    =&gt; 1,
           migrate_from =&gt; {
               use_eval  =&gt; 1,
               formula   =&gt; '$old || $older ;',
               undef_is =&gt; "''",
               variables =&gt; {
                   older =&gt; '- Original-Source-Location',
                   old   =&gt; '- Upstream-Source'
               }
           },
        },
        [qw/Upstream-Source Original-Source-Location/] =&gt; {
           value_type =&gt; 'string',
           status     =&gt; 'deprecated',
           type       =&gt; 'leaf'
        }

</pre><h4><b>Examples</b></h4><pre>
   <b>String</b> <b>substitution</b>
        [qw/sav sbv/] =&gt; {
            type       =&gt; 'leaf',
            value_type =&gt; 'string',
          },
        compute_string =&gt; {
            type       =&gt; 'leaf',
            value_type =&gt; 'string',
            compute    =&gt; {
                formula   =&gt; 'meet $a and $b',
                variables =&gt; { '- sav', b =&gt; '- sbv' }
            },
        },

   <b>Computation</b> <b>with</b> <b>on-the-fly</b> <b>replacement</b>
        compute_with_replace =&gt; {
            type       =&gt; 'leaf',
            value_type =&gt; 'string',
            compute    =&gt; {
                formula =&gt;
                  '$replace{$who} is the $replace{$what} of $replace{$country}',
                variables =&gt; {
                    who     =&gt; '! who',
                    what    =&gt; '! what',
                    country =&gt; '- country',
                },
                replace =&gt; {
                    chief   =&gt; 'president',
                    America =&gt; 'USA'
                },
            },
          },

   <b>Extract</b> <b>data</b> <b>from</b> <b>a</b> <b>value</b> <b>using</b> <b>a</b> <b>Perl</b> <b>regexp</b>
       Extract the host name from an URL:

        url =&gt; {
            type       =&gt; 'leaf',
            value_type =&gt; 'uniline'
        },
        extract_host_from_url =&gt; {
            type       =&gt; 'leaf',
            value_type =&gt; 'uniline',
            compute    =&gt; {
                formula   =&gt; '$old =~ m!http://([\w\.]+)!; $1 ;',
                variables =&gt; { old =&gt; '- url' },
                use_eval  =&gt; 1,
            },
        },

   <b>copy</b> <b>hash</b> <b>example</b>
       Copying a hash may not be useful, but the using &amp;index() in a variable can be. Here's  an  example  where
       the hashes contain leaves.

       The model is set up so that the content of "copy_from" is copied into "copy_to" hash:

               copy_from =&gt; {
                   'type' =&gt; 'hash',
                   'index_type' =&gt; 'string',
                   'cargo' =&gt; {
                       'config_class_name' =&gt; 'From',
                       'type' =&gt; 'node'
                   },
               },
               copy_to =&gt; {
                   'type' =&gt; 'hash',
                   'index_type' =&gt; 'string',
                   'cargo' =&gt; {
                       'type' =&gt; 'leaf',
                       'value_type' =&gt; 'uniline',
                       'compute' =&gt; {
                           'formula' =&gt; '$copied',
                           'variables' =&gt; {
                               'copied' =&gt; '- copy_from:&amp;index()'
                           }
                       },
                   },
               },

       Hash  copy is also possible when the hash contains node. Here's an example where the data to be copied is
       stored within a node. The main class has 2 hash elements:

               copy_from =&gt; {
                   'type' =&gt; 'hash',
                   'index_type' =&gt; 'string',
                   'cargo' =&gt; {
                       'config_class_name' =&gt; 'From',
                       'type' =&gt; 'node'
                   },
               },
               copy_to =&gt; {
                   'type' =&gt; 'hash',
                   'index_type' =&gt; 'string',
                   'cargo' =&gt; {
                       'config_class_name' =&gt; 'To',
                       'type' =&gt; 'node'
                   },
               },

       The Class to copy from is quite short:

           'name' =&gt; 'From',
           'element' =&gt; [
               name =&gt;  {
                   'type' =&gt; 'leaf',
                   'value_type' =&gt; 'uniline',
               }
           ]

       Here the class to copy to:

           'name' =&gt; 'To',
           'element' =&gt; [
               name =&gt;  {
                   'type' =&gt; 'leaf',
                   'value_type' =&gt; 'uniline',
                   'compute' =&gt; {
                       'formula' =&gt; '$copied',
                       'variables' =&gt; {
                           'copied' =&gt; '! copy_from:&amp;index(-) name'
                       }
                   },
               }
           ]

</pre><h4><b>AUTHOR</b></h4><pre>
       Dominique Dumont, (ddumont at cpan dot org)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Config::Model, Config::Model::Instance, Config::Model::Value

</pre><h4><b>AUTHOR</b></h4><pre>
       Dominique Dumont

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2005-2022 by Dominique Dumont.

       This is free software, licensed under:

         The GNU Lesser General Public License, Version 2.1, February 1999

perl v5.40.0                                       2024-11-30                  <u>Config::Model::<a href="../man3pm/ValueComputer.3pm.html">ValueComputer</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>