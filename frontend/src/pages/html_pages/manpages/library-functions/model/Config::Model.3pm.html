<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Config::Model - a framework to validate, migrate and edit configuration files</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libconfig-model-perl">libconfig-model-perl_2.155-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Config::Model - a framework to validate, migrate and edit configuration files

</pre><h4><b>VERSION</b></h4><pre>
       version 2.155

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Perl</b> <b>program</b> <b>to</b> <b>use</b> <b>an</b> <b>existing</b> <b>model</b>
        use Config::Model qw(cme);
        # load, modify and save popcon configuration file
        cme('popcon')-&gt;modify("PARTICIPATE=yes");

   <b>Command</b> <b>line</b> <b>to</b> <b>use</b> <b>an</b> <b>existing</b> <b>model</b>
        # with App::Cme
        cme modify popcon 'PARTICIPATE=yes'

   <b>Perl</b> <b>program</b> <b>with</b> <b>a</b> <b>custom</b> <b>model</b>
        use Config::Model;

        # create new Model object
        my $model = Config::Model-&gt;new() ; # Config::Model object

        # create config model. A more complex model should be stored in a
        # file in lib/Config/Model/models. Then, run cme as explained below
        $model -&gt;create_config_class (
          name =&gt; "MiniModel",
          element =&gt; [ [qw/foo bar baz/ ] =&gt; { type =&gt; 'leaf', value_type =&gt; 'uniline' }, ],
          rw_config =&gt; { backend =&gt; 'IniFile', auto_create =&gt; 1,
                         config_dir =&gt; '.', file =&gt; 'mini.ini',
                       }
        ) ;

        # create instance (Config::Model::Instance object)
        my $instance = $model-&gt;instance (root_class_name =&gt; 'MiniModel');

        # get configuration tree root
        my $cfg_root = $instance -&gt; config_root ; # C::M:Node object

        # load some dummy data
        $cfg_root -&gt; load("bar=BARV foo=FOOV baz=BAZV") ;

        # write new ini file
        $instance -&gt; write_back;

        # now look for new mini.ini file un current directory

   <b>Create</b> <b>a</b> <b>new</b> <b>model</b> <b>file</b> <b>and</b> <b>use</b> <b>it</b>
        $ mkdir -p lib/Config/Model/models/
        $ echo "[ { name =&gt; 'MiniModel', \
                    element =&gt; [ [qw/foo bar baz/ ] =&gt; { type =&gt; 'leaf', value_type =&gt; 'uniline' }, ], \
                    rw_config =&gt; { backend =&gt; 'IniFile', auto_create =&gt; 1, \
                                   config_dir =&gt; '.', file =&gt; 'mini.ini', \
                                 } \
                  } \
                ] ; " &gt; lib/Config/Model/models/MiniModel.pl
        # require App::Cme
        $ cme modify -try MiniModel -dev bar=BARV foo=FOOV baz=BAZV
        $ cat mini.ini

       Note that model creation is easier running "cme meta edit" with App::Cme and Config::Model::Itself.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Config::Model enables a project developer to provide an interactive configuration editor (graphical,
       curses based or plain terminal) to users.

       To provide these tools, Config::Model needs:

       •   A  description  of  the  structure and constraints of the project's configuration (fear not, a GUI is
           available with App::Cme)

       •   A module to read and write configuration data (aka a backend class).

       With the elements above, Config::Model generates interactive configuration editors (with integrated  help
       and  data  validation).   These  editors  can be graphical (with Config::Model::TkUI), curses based (with
       Config::Model::CursesUI) or based on ReadLine.

       Smaller models targeted for configuration upgrades can also be created:

       •   only upgrade and migration specifications are required

       •   unknown parameters can be accepted

       A command line is provided to perform configuration upgrade with a single command.

   <b>How</b> <b>does</b> <b>this</b> <b>work</b> <b>?</b>
       Using this project, a typical configuration editor/validator/upgrader is made of 3 parts :

         GUI &lt;--------&gt; |---------------|
         CursesUI &lt;---&gt; | |---------|   |
                        | | Model   |   |
         ShellUI &lt;----&gt; | |---------|   |&lt;-----read-backend------- |-------------|
                        |               |----write-backend-------&gt; | config file |
         FuseUI &lt;-----&gt; | Config::Model |                          |-------------|
                        |---------------|

       1.  A reader and  writer  that  parse  the  configuration  file  and  transform  its  data  into  a  tree
           representation  within  Config::Model. The values contained in this configuration tree can be written
           back in the configuration file(s).

       2.  A validation engine which is in charge of validating  the  content  and  structure  of  configuration
           stored  in  the  configuration  tree.  This  validation  engine  follows the structure and constraint
           declared in a configuration model. This model is a kind of schema for the configuration tree.

       3.  A user interface to modify the content  of  the  configuration  tree.  A  modification  is  validated
           immediately by the validation engine.

       The important part is the configuration model used by the validation engine. This model can be created or
       modified with a graphical editor (Config::Model::Iself).

</pre><h4><b>Question</b> <b>you</b> <b>may</b> <b>ask</b> <b>yourself</b></h4><pre>
   <b>Don't</b> <b>we</b> <b>already</b> <b>have</b> <b>some</b> <b>configuration</b> <b>validation</b> <b>tools</b> <b>?</b>
       You're  probably thinking of tools like webmin. Yes, these tools exist and work fine, but they have their
       set of drawbacks.

       Usually, the validation of configuration data is done with a script which  performs  semantic  validation
       and  often  ends  up  being  quite complex (e.g. 2500 lines for Debian's xserver-xorg.config script which
       handles "xorg.conf" file).

       In most cases, the configuration model is expressed in instructions  (whatever  programming  language  is
       used) and interspersed with a lot of processing to handle the actual configuration data.

   <b>What's</b> <b>the</b> <b>advantage</b> <b>of</b> <b>this</b> <b>project</b> <b>?</b>
       Config::Model  projects  provide  a  way  to  get  a  validation  engine where the configuration model is
       completely separated from the actual processing instructions.

       A  configuration  model  can  be  created  and  modified  with  the  graphical   interface   provide   by
       Config::Model::Itself.  The model is saved in a declarative form (currently, a Perl data structure). Such
       a model is easier to maintain than a lot of code.

       The model specifies:

       •   The structure of the configuration data (which can be queried by generic user interfaces)

       •   The properties of each element (boundaries check, integer or string, enum like  type,  default  value
           ...)

       •   The targeted audience (beginner, advanced, master)

       •   The on-line help

       So, in the end:

       •   Maintenance and evolution of the configuration content is easier

       •   User sees a *common* interface for *all* programs using this project.

       •   Upgrade of configuration data is easier and sanity check is performed during the upgrade.

       •   Audit of configuration is possible to check what was modified by the user compared to default values

   <b>What</b> <b>about</b> <b>the</b> <b>user</b> <b>interface</b> <b>?</b>
       Config::Model interface can be:

       •   a shell-like interface (plain or based on Term::ReadLine).

       •   Graphical with Config::Model::TkUI (Perl/Tk interface).

       •   based on curses with Config::Model::CursesUI. This interface can be handy if your X server is down.

       •   Through a virtual file system where every configuration parameter is mapped to a file.  (Linux only)

       All these interfaces are generated from the configuration model.

       And  configuration model can be created or modified with a graphical user interface (with "cme meta edit"
       once Config::Model::Itself is installed)

   <b>What</b> <b>about</b> <b>configuration</b> <b>data</b> <b>storage</b> <b>?</b>
       Since the syntax of configuration files vary wildly form one application to another, people who  want  to
       use this framework may have to provide a dedicated parser/writer.

       To  help  with this task, this project provides writer/parsers for common format: INI style file and perl
       file. With the additional Config::Model::Backend::Augeas, Augeas library can be used to  read  and  write
       some configuration files. See <a href="http://augeas.net">http://augeas.net</a> for more details.

   <b>Is</b> <b>there</b> <b>an</b> <b>example</b> <b>of</b> <b>a</b> <b>configuration</b> <b>model</b> <b>?</b>
       The  "example"  directory  contains  a  configuration  model  example for "<a href="file:/etc/fstab">/etc/fstab</a>" file. This example
       includes a small program that use this model to show some ways to extract configuration information.

</pre><h4><b>Mailing</b> <b>lists</b></h4><pre>
       For more question, please send a mail to:

        config-model-users at lists.sourceforge.net

</pre><h4><b>Suggested</b> <b>reads</b> <b>to</b> <b>start</b></h4><pre>
   <b>Beginners</b>
       •   Config::Model::Manual::ModelCreationIntroduction

       •   Config::Model::Cookbook::CreateModelFromDoc

   <b>Advanced</b>
       •   Config::Model::models::Itself::Class: This doc and its siblings describes all parameters available to
           create a model. These are the parameters available in the GUI launched by "cme meta edit" command.

       •   Config::Model::Manual::ModelCreationAdvanced

   <b>Masters</b>
       use the source, Luke

</pre><h4><b>STOP</b></h4><pre>
       The documentation below is quite detailed and is more a reference doc regarding "Config::Model" class.

       For an introduction to model creation, please check: Config::Model::Manual::ModelCreationIntroduction

</pre><h4><b>Storage</b> <b>backend,</b> <b>configuration</b> <b>reader</b> <b>and</b> <b>writer</b></h4><pre>
       See Config::Model::BackendMgr for details

</pre><h4><b>Validation</b> <b>engine</b></h4><pre>
       "Config::Model" provides a way to get a validation engine from a set of  rules.  This  set  of  rules  is
       called the configuration model.

</pre><h4><b>User</b> <b>interface</b></h4><pre>
       The  user  interface  uses some parts of the API to set and get configuration values. More importantly, a
       generic user interface needs to analyze the configuration model  to  be  able  to  generate  at  run-time
       relevant configuration screens.

       A  command  line  interface  is  provided  in  this  module.  Curses  and  Tk  interfaces are provided by
       Config::Model::CursesUI and Config::Model::TkUI.

</pre><h4><b>Constructor</b></h4><pre>
        my $model = Config::Model -&gt; new ;

       creates an object to host your model.

   <b>Constructor</b> <b>parameters</b>
       log_level
           Specify minimal log level. Default is "WARN". Can be "INFO", "DEBUG" or "TRACE" to get more logs. Can
           also be "ERROR" to get less traces.

           This parameter is used to override the log level specified in log configuration file.

</pre><h4><b>Configuration</b> <b>Model</b></h4><pre>
       To validate a configuration tree, we must create a configuration model that defines all the properties of
       the validation engine you want to create.

       The configuration model is expressed in a declarative form (i.e. a Perl data structure  which  should  be
       easier to maintain than a lot of code)

       Each configuration class may contain a set of:

       •   node elements that refer to another configuration class

       •   value elements that contain actual configuration data

       •   list or hash elements that also contain several node or value elements

       The structure of your configuration tree is shaped by the a set of configuration classes that are used in
       node elements,

       The  structure  of  the  configuration data must be based on a tree structure. This structure has several
       advantages:

       •   Unique path to get to a node or a leaf.

       •   Simpler exploration and query

       •   Simple hierarchy. Deletion of configuration items is simpler to grasp: when you cut a branch, all the
           leaves attached to that branch go down.

       But using a tree has also some drawbacks:

       •   A complex configuration cannot be mapped on a tree.  Some more relation between nodes and leaves must
           be added.

       •   A configuration may actually be  structured  as  a  graph  instead  as  a  tree  (for  instance,  any
           configuration  that  maps  a  service to a resource). The graph relation must be decomposed in a tree
           with special <u>reference</u> relations that complete the tree to form a graph.  See  "Value  Reference"  in
           Config::Model::Value

       Note:  a  configuration  tree  is  a  tree  of  objects.  The model is declared with classes. The classes
       themselves have relations that closely match the relation of the object of the  configuration  tree.  But
       the  class need not to be declared in a tree structure (always better to reuse classes). But they must be
       declared  as  a  DAG  (directed  acyclic  graph).   See  also  Directed  acyclic   graph   on   Wikipedia
       &lt;<a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">http://en.wikipedia.org/wiki/Directed_acyclic_graph</a>"&gt;More on DAGs&gt;

       Each configuration class declaration specifies:

       •   The "name" of the class (mandatory)

       •   A "class_description" used in user interfaces (optional)

       •   Optional include specification to avoid duplicate declaration of elements.

       •   The class elements

       Each element specifies:

       •   Most importantly, the type of the element (mostly "leaf", or "node")

       •   The properties of each element (boundaries, check, integer or string, enum like type ...)

       •   The default values of parameters (if any)

       •   Whether the parameter is mandatory

       •   Targeted  audience  (beginner,  advance,  master),  i.e.  the level of expertise required to tinker a
           parameter (to hide expert parameters from newbie eyes)

       •   On-line help (for each parameter or value of parameter)

       See Config::Model::Node for details on how to declare a configuration class.

       Example:

        $ cat lib/Config/Model/models/Xorg.pl
        [
          {
            name =&gt; 'Xorg',
            class_description =&gt; 'Top level Xorg configuration.',
            include =&gt; [ 'Xorg::ConfigDir'],
            element =&gt; [
                        Files =&gt; {
                                  type =&gt; 'node',
                                  description =&gt; 'File pathnames',
                                  config_class_name =&gt; 'Xorg::Files'
                                 },
                        # snip
                       ]
          },
          {
            name =&gt; 'Xorg::DRI',
            element =&gt; [
                        Mode =&gt; {
                                 type =&gt; 'leaf',
                                 value_type =&gt; 'uniline',
                                 description =&gt; 'DRI mode, usually set to 0666'
                                }
                       ]
          }
        ];

</pre><h4><b>Configuration</b> <b>instance</b> <b>methods</b></h4><pre>
       A configuration instance is created from a model and is the starting point of a configuration tree.

   <b>instance</b>
       An instance must be created with a model name (using the root class name)  or  an  application  name  (as
       shown by "cme "list"" command).

       For example:

        my $model = Config::Model-&gt;new() ;
        $model-&gt;instance( application =&gt; 'approx');

       Or:

        my $model = Config::Model-&gt;new() ;
        # note that the model class is slightly different compared to
        # application name
        $model-&gt;instance( root_class_name =&gt; 'Approx');

       A custom configuration class can also be used with "root_class_name" parameter:

        my $model = Config::Model-&gt;new() ;
        # create_config_class is described below
        $model -&gt;create_config_class (
          name =&gt; "SomeRootClass",
          element =&gt; [ ...  ]
        ) ;

        # instance name is 'default'
        my $inst = $model-&gt;instance (root_class_name =&gt; 'SomeRootClass');

       You can create several separated instances from a model using "name" option:

        # instance name is 'default'
        my $inst = $model-&gt;instance (
          root_class_name =&gt; 'SomeRootClass',
          name            =&gt; 'test1'
        );

       Usually, model files are loaded automatically using a path matching "root_class_name" (e.g. configuration
       class  "Foo::Bar" is stored in "Foo/Bar.pl". You can choose to specify the file containing the model with
       "model_file" parameter. This is mostly useful for tests.

       The "instance" method can also retrieve an instance that has already been created:

        my $inst = $model-&gt;instance( name =&gt; 'test1' );

   <b>get_instance</b>
       Retrieve an existing instance using its name.

        my $inst = $model-&gt;get_instance('test1' );

   <b>has_instance</b>
       Check if an instance name already exists

         my $maybe = $model-&gt;has_instance('test1');

   <b>cme</b>
       This method is syntactic sugar for short program. It creates a new "Config::Model" object and  returns  a
       new instance.

       "cme" arguments are passed to "instance" method, except "force-load".

       Like  cme  command,  "cme"  functions  accepts  "force-load"  parameters. When this argument is true, the
       instance is created with "&lt;check =" 'no'&gt;&gt;. Hence bad values are stored in "cme" and  must  be  corrected
       before saving back the data.

</pre><h4><b>Configuration</b> <b>class</b></h4><pre>
       A configuration class is made of series of elements which are detailed in Config::Model::Node.

       Whatever its type (node, leaf,... ), each element of a node has several other properties:

       level
           Level is "important", "normal" or "hidden".

           The  level  is  used  to  set  how  configuration  data  is  presented  to the user in browsing mode.
           "Important" elements are shown to the user no matter what. "hidden" elements are well, hidden.  Their
           purpose is explained with the <u>warp</u> notion.

       status
           Status is "obsolete", "deprecated" or "standard" (default).

           Using a deprecated element raises a warning. Using an obsolete element raises an exception.

       description
           Description of the element. This description is used while generating user interfaces.

       summary
           Summary  of  the element. This description is used while generating a user interfaces and may be used
           in comments when writing the configuration file.

       class_description
           Description of the configuration class. This description is used while generating user interfaces.

       generated_by
           Mention with a descriptive string if this class was  generated  by  a  program.   This  parameter  is
           currently reserved for Config::Model::Itself model editor.

       include
           Include element description from another class.

             include =&gt; 'AnotherClass' ,

           or

             include =&gt; [qw/ClassOne ClassTwo/]

           In  a  configuration class, the order of the element is important. For instance if "foo" is warped by
           "bar", you must declare "bar" element before "foo".

           When including another class, you may wish to insert the included elements after a  specific  element
           of your including class:

             # say AnotherClass contains element xyz
             include =&gt; 'AnotherClass' ,
             include_after =&gt; "foo" ,
             element =&gt; [ bar =&gt; ... , foo =&gt; ... , baz =&gt; ... ]

           Now the element of your class are:

             ( bar , foo , xyz , baz )

           Note that include may not clobber an existing element.

       include_backend
           Include read/write specification from another class.

             include_backend =&gt; 'AnotherClass' ,

           or

             include_backend =&gt; [qw/ClassOne ClassTwo/]

       Note that include may not clobber an existing read/write specification.

   <b>create_config_class</b>
       This  method  creates  configuration  classes.  The  parameters  are described above and are forwarded to
       Config::Model::Node constructor. See "Configuration class declaration" in  Config::Model::Node  for  more
       details on configuration class parameters.

       Example:

         my $model = Config::Model -&gt; new ;

         $model-&gt;create_config_class
         (
          config_class_name =&gt; 'SomeRootClass',
          description       =&gt; [ X =&gt; 'X-ray' ],
          level             =&gt; [ 'tree_macro' =&gt; 'important' ] ,
          class_description =&gt; "SomeRootClass description",
          element           =&gt; [ ... ]
         ) ;

       For  convenience,  "level"  and  "description"  parameters  can  also  be  declared  within  the  element
       declaration:

         $model-&gt;create_config_class
         (
          config_class_name =&gt; 'SomeRootClass',
          class_description =&gt; "SomeRootClass description",
          'element'
          =&gt; [
               tree_macro =&gt; { level =&gt; 'important'},
               X          =&gt; { description =&gt; 'X-ray', } ,
             ]
         ) ;

</pre><h4><b>Load</b> <b>predeclared</b> <b>model</b></h4><pre>
       You can also load predeclared model.

   <b>load(</b> <b>&lt;model_name&gt;</b> <b>)</b>
       This method opens the model directory and execute a ".pl" file containing the model declaration,

       This perl file must return an array ref to declare models. E.g.:

        [
         [
          name =&gt; 'Class_1',
          element =&gt; [ ... ]
         ],
         [
          name =&gt; 'Class_2',
          element =&gt; [ ... ]
         ]
        ];

       do not put "1;" at the end or "load" will not work

       When a model name contain a "::" (e.g "Foo::Bar"), "load" looks for a file named "Foo/Bar.pl".

       This method also searches in "Foo/Bar.d" directory for additional model information.  Model snippet found
       there are loaded with augment_config_class.

       Returns a list containing the names of the loaded classes. For instance, if "Foo/Bar.pl" contains a model
       for "Foo::Bar" and "Foo::Bar2", "load" returns "( 'Foo::Bar' , 'Foo::Bar2' )".

   <b>augment_config_class</b> <b>(name</b> <b>=&gt;</b> <b>'...',</b> <b>class_data</b> <b>)</b>
       Enhance  the  feature  of  a  configuration  class.   This   method   uses   the   same   parameters   as
       "create_config_class".  See  "Model  Plugin"  in  Config::Model::Manual::ModelCreationAdvanced  for  more
       details on creating model plugins.

</pre><h4><b>Model</b> <b>query</b></h4><pre>
   <b>model</b>
       Returns a hash containing the model declaration of the passed model name. Do not modify  the  content  of
       the returned data structure.

        my $cloned = $model-&gt;model('Foo');

   <b>get_model_clone</b>
       Like  "model",  returns  a hash containing the model declaration of the passed model name, this time in a
       deep clone of the data structure.

        my $cloned = $model-&gt;get_model_clone('Foo');

   <b>generate_doc</b> <b>(</b> <b>top_class_name</b> <b>,</b> <b>directory</b> <b>,</b> <b>[</b> <b>\%done</b> <b>]</b> <b>)</b>
       Generate POD document for configuration class top_class_name and all classes used by top_class_name,  and
       write them in specified directory.

       "\%done"  is an optional reference to a hash used to avoid writing twice the same documentation when this
       method is called several times.

   <b>get_element_model(</b> <b>config_class_name</b> <b>,</b> <b>element)</b>
       Return a hash containing the model declaration for the specified class and element.

   <b>get_element_name(</b> <b>class</b> <b>=&gt;</b> <b>Foo</b> <b>)</b>
       Get all names of the elements of class "Foo".

   <b>get_element_property</b>
       Returns the property of an element from the model.

       Parameters are:

       class
       element
       property

   <b>list_class_element</b>
       Returns a string listing all the class and elements. Useful for debugging your configuration model.

</pre><h4><b>Error</b> <b>handling</b></h4><pre>
       Errors are handled with an exception mechanism.

       When a strongly typed Value object gets an authorized value, it raises an exception. If this exception is
       not caught, the programs exits.

       See Config::Model::Exception for details on the various exception classes provided with "Config::Model".

</pre><h4><b>Logging</b></h4><pre>
       See "Logging" in cme

   <b>initialize_log4perl</b>
       This method can be called  to  load  Log::Log4perl  configuration  from  "<a href="file:~/.log4config-model">~/.log4config-model</a>",  or  from
       "/etc/log4config-model.conf"  files  or  from  default  configuration &lt;https://github.com/dod38fr/config-
       model/blob/master/lib/Config/Model/log4perl.conf&gt;.

       Accepts "verbose" parameter with a list of log classes that are added to the log4perl configuration  read
       above.

       For instance, with "verbose =&gt; 'Loader'", log4perl is initialised with

        log4perl.logger.Verbose.Loader = INFO, PlainMsgOnScreen

       Likewise, with "verbose =&gt; [ 'Loader', 'Foo' ]", log4perl is initialised with:

        log4perl.logger.Verbose.Loader = INFO, PlainMsgOnScreen
        log4perl.logger.Verbose.Foo    = INFO, PlainMsgOnScreen

       Currently, this module supports only "Loader" as verbose parameters.

</pre><h4><b>BUGS</b></h4><pre>
       Given  Murphy's law, the author is fairly confident that you will find bugs or miss some features. Please
       report them to https://github.com/dod38fr/config-model/issues The  author  will  be  notified,  and  then
       you'll automatically be notified of progress on your bug.

</pre><h4><b>FEEDBACK</b></h4><pre>
       Feedback  from  users  are  highly  desired. If you find this module useful, please share your use cases,
       success stories with the author or with the config-model- users mailing list.

</pre><h4><b>PROJECT</b> <b>FOUNDER</b></h4><pre>
       Dominique Dumont, "<a href="mailto:ddumont@cpan.org">ddumont@cpan.org</a>"

</pre><h4><b>CREDITS</b></h4><pre>
       Contributors to this project are listed in alphabetical order:

         Harley Pig

         Ilya Arosov

         Jose Luis Perez Diez

         Krzysztof Tyszecki

         Mathieu Arnold

         Mohammad S Anwar

         Topi Miettinen

       Many thanks for your help

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Config::Model::Instance,

       &lt;https://github.com/dod38fr/config-model/wiki&gt;

       &lt;https://github.com/dod38fr/config-model/wiki/Creating-models&gt;

   <b>Model</b> <b>elements</b>
       The arrow shows inheritance between classes

       •   Config::Model::Node &lt;- Config::Model::AnyThing

       •   Config::Model::HashId &lt;- Config::Model::AnyId &lt;- Config::Model::AnyThing

       •   Config::Model::ListId &lt;- Config::Model::AnyId &lt;- Config::Model::AnyThing

       •   Config::Model::Value &lt;- Config::Model::AnyThing

       •   Config::Model::CheckList &lt;- Config::Model::AnyThing

       •   Config::Model::WarpedNode &lt;- Config::Model::AnyThing

   <b>command</b> <b>line</b>
       cme.

   <b>Read</b> <b>and</b> <b>write</b> <b>backends</b>
       •   Config::Model::Backend::Fstab &lt;- Config::Model::Backend::Any

       •   Config::Model::Backend::IniFile &lt;- Config::Model::Backend::Any

       •   Config::Model::Backend::PlainFile &lt;- Config::Model::Backend::Any

       •   Config::Model::Backend::ShellVar &lt;- Config::Model::Backend::Any

   <b>Model</b> <b>utilities</b>
       •   Config::Model::Annotation

       •   Config::Model::BackendMgr: Used by "Config::Model::Node" object

       •   Config::Model::Describe

       •   Config::Model::Dumper

       •   Config::Model::DumpAsData

       •   Config::Model::IdElementReference

       •   Config::Model::Iterator

       •   Config::Model::Loader

       •   Config::Model::ObjTreeScanner

       •   Config::Model::Report

       •   Config::Model::Searcher: Search element in configuration model.

       •   Config::Model::SimpleUI

       •   Config::Model::TreeSearcher: Search string or regexp in configuration tree.

       •   Config::Model::TermUI

       •   Config::Model::Iterator

       •   Config::Model::ValueComputer

       •   Config::Model::Warper

   <b>Test</b> <b>framework</b>
       •   Config::Model::Tester

</pre><h4><b>AUTHOR</b></h4><pre>
       Dominique Dumont

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2005-2022 by Dominique Dumont.

       This is free software, licensed under:

         The GNU Lesser General Public License, Version 2.1, February 1999

</pre><h4><b>SUPPORT</b></h4><pre>
   <b>Websites</b>
       The following websites have more information about this module, and may be of help to you. As always,  in
       addition to those websites please use your favorite search engine to discover more resources.

       •   CPANTS

           The CPANTS is a website that analyzes the Kwalitee ( code metrics ) of a distribution.

           &lt;<a href="http://cpants.cpanauthors.org/dist/Config-Model">http://cpants.cpanauthors.org/dist/Config-Model</a>&gt;

       •   CPAN Testers

           The  CPAN  Testers  is  a  network  of  smoke  testers  who  run  automated  tests  on  uploaded CPAN
           distributions.

           &lt;<a href="http://www.cpantesters.org/distro/C/Config-Model">http://www.cpantesters.org/distro/C/Config-Model</a>&gt;

       •   CPAN Testers Matrix

           The CPAN Testers Matrix is a website that provides a visual  overview  of  the  test  results  for  a
           distribution on various Perls/platforms.

           &lt;<a href="http://matrix.cpantesters.org/">http://matrix.cpantesters.org/</a>?dist=Config-Model&gt;

       •   CPAN Testers Dependencies

           The CPAN Testers Dependencies is a website that shows a chart of the test results of all dependencies
           for a distribution.

           &lt;<a href="http://deps.cpantesters.org/">http://deps.cpantesters.org/</a>?module=Config::Model&gt;

   <b>Bugs</b> <b>/</b> <b>Feature</b> <b>Requests</b>
       Please  report  any  bugs  or  feature  requests  by  email  to "ddumont at cpan.org", or through the web
       interface at &lt;https://github.com/dod38fr/config-model/issues&gt;. You will be automatically notified of  any
       progress on the request by the system.

   <b>Source</b> <b>Code</b>
       The  code  is open to the world, and available for you to hack on. Please feel free to browse it and play
       with it, or whatever. If you want to contribute patches, please send me a diff or prod me  to  pull  from
       your repository :)

       &lt;<a href="http://github.com/dod38fr/config-model">http://github.com/dod38fr/config-model</a>&gt;

         git clone git://github.com/dod38fr/config-model.git

perl v5.40.0                                       2024-11-30                                 <u>Config::<a href="../man3pm/Model.3pm.html">Model</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>