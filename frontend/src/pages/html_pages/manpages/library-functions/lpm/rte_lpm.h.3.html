<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rte_lpm.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dpdk-doc">dpdk-doc_24.11.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rte_lpm.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
       #include &lt;stdalign.h&gt;
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;rte_branch_prediction.h&gt;
       #include &lt;rte_byteorder.h&gt;
       #include &lt;rte_common.h&gt;
       #include &lt;rte_vect.h&gt;
       #include &lt;rte_rcu_qsbr.h&gt;
       #include 'rte_lpm_scalar.h'

   <b>Data</b> <b>Structures</b>
       struct <b>rte_lpm_config</b>
       struct <b>rte_lpm_rcu_config</b>

   <b>Macros</b>
       #define <b>RTE_LPM_NAMESIZE</b>   32
       #define <b>RTE_LPM_MAX_DEPTH</b>   32
       #define <b>RTE_LPM_LOOKUP_SUCCESS</b>   0x01000000
       #define <b>rte_lpm_lookup_bulk</b>(lpm,  ips,  next_hops,  n)           rte_lpm_lookup_bulk_func(lpm, ips,
           next_hops, n)

   <b>Enumerations</b>
       enum <b>rte_lpm_qsbr_mode</b> { <b>RTE_LPM_QSBR_MODE_DQ</b> = 0, <b>RTE_LPM_QSBR_MODE_SYNC</b> }

   <b>Functions</b>
       struct rte_lpm * <b>rte_lpm_create</b> (const char *name, int socket_id, const struct <b>rte_lpm_config</b> *config)
       struct rte_lpm * <b>rte_lpm_find_existing</b> (const char *name)
       void <b>rte_lpm_free</b> (struct rte_lpm *lpm)
       int <b>rte_lpm_rcu_qsbr_add</b> (struct rte_lpm *lpm, struct <b>rte_lpm_rcu_config</b> *cfg)
       int <b>rte_lpm_add</b> (struct rte_lpm *lpm, uint32_t ip, uint8_t depth, uint32_t next_hop)
       int <b>rte_lpm_is_rule_present</b> (struct rte_lpm *lpm, uint32_t ip, uint8_t depth, uint32_t *next_hop)
       int <b>rte_lpm_delete</b> (struct rte_lpm *lpm, uint32_t ip, uint8_t depth)
       void <b>rte_lpm_delete_all</b> (struct rte_lpm *lpm)
       static int <b>rte_lpm_lookup</b> (const struct rte_lpm *lpm, uint32_t ip, uint32_t *next_hop)
       static void <b>rte_lpm_lookupx4</b> (const struct rte_lpm *lpm, xmm_t ip, uint32_t hop[4], uint32_t defv)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       RTE Longest Prefix Match (LPM)

       Definition in file <b>rte_lpm.h</b>.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>RTE_LPM_NAMESIZE</b>   <b>32</b>
       Max number of characters in LPM name.

       Definition at line <b>29</b> of file <b>rte_lpm.h</b>.

   <b>#define</b> <b>RTE_LPM_MAX_DEPTH</b>   <b>32</b>
       Maximum depth value possible for IPv4 LPM.

       Definition at line <b>32</b> of file <b>rte_lpm.h</b>.

   <b>#define</b> <b>RTE_LPM_LOOKUP_SUCCESS</b>   <b>0x01000000</b>
       Bitmask used to indicate successful lookup

       Definition at line <b>63</b> of file <b>rte_lpm.h</b>.

   <b>#define</b> <b>rte_lpm_lookup_bulk(lpm,</b> <b>ips,</b> <b>next_hops,</b> <b>n)</b>         <b>rte_lpm_lookup_bulk_func(lpm,</b> <b>ips,</b> <b>next_hops,</b> <b>n)</b>
       Lookup multiple IP addresses in an LPM table. This may be implemented as a macro, so the address of the
       function should not be used.

       <b>Parameters</b>
           <u>lpm</u> LPM object handle
           <u>ips</u> Array of IPs to be looked up in the LPM table
           <u>next_hops</u> Next hop of the most specific rule found for IP (valid on lookup hit only). This is an
           array of two byte values. The most significant byte in each value says whether the lookup was
           successful (bitmask RTE_LPM_LOOKUP_SUCCESS is set). The least significant byte is the actual next
           hop.
           <u>n</u> Number of elements in ips (and next_hops) array to lookup. This should be a compile time constant,
           and divisible by 8 for best performance.

       <b>Returns</b>
           -EINVAL for incorrect arguments, otherwise 0

       Definition at line <b>332</b> of file <b>rte_lpm.h</b>.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>rte_lpm_qsbr_mode</b>
       RCU reclamation modes

       <b>Enumerator</b>

       <u>RTE_LPM_QSBR_MODE_DQ</u>
              Create defer queue for reclaim.

       <u>RTE_LPM_QSBR_MODE_SYNC</u>
              Use blocking mode reclaim. No defer queue created.

       Definition at line <b>69</b> of file <b>rte_lpm.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>struct</b> <b>rte_lpm</b> <b>*</b> <b>rte_lpm_create</b> <b>(const</b> <b>char</b> <b>*</b> <b>name,</b> <b>int</b> <b>socket_id,</b> <b>const</b> <b>struct</b> <b>rte_lpm_config</b> <b>*</b> <b>config)</b>
       Create an LPM object.

       <b>Parameters</b>
           <u>name</u> LPM object name
           <u>socket_id</u> NUMA socket ID for LPM table memory allocation
           <u>config</u> Structure containing the configuration

       <b>Returns</b>
           Handle to LPM object on success, NULL otherwise with rte_errno set to an appropriate values. Possible
           rte_errno values include:

           • E_RTE_NO_CONFIG - function could not get pointer to rte_config structure

           • E_RTE_SECONDARY - function was called from a secondary process instance

           • EINVAL - invalid parameter passed to function

           • ENOSPC - the maximum number of memzones has already been allocated

           • EEXIST - a memzone with the same name already exists

           • ENOMEM - no appropriate memory area found in which to create memzone

   <b>struct</b> <b>rte_lpm</b> <b>*</b> <b>rte_lpm_find_existing</b> <b>(const</b> <b>char</b> <b>*</b> <b>name)</b>
       Find an existing LPM object and return a pointer to it.

       <b>Parameters</b>
           <u>name</u> Name of the lpm object as passed to <b>rte_lpm_create()</b>

       <b>Returns</b>
           Pointer  to  lpm  object  or  NULL  if  object  not  found with rte_errno set appropriately. Possible
           rte_errno values include:

           • ENOENT - required entry not available to return.

   <b>void</b> <b>rte_lpm_free</b> <b>(struct</b> <b>rte_lpm</b> <b>*</b> <b>lpm)</b>
       Free an LPM object.

       <b>Parameters</b>
           <u>lpm</u> LPM object handle If lpm is NULL, no operation is performed.

   <b>int</b> <b>rte_lpm_rcu_qsbr_add</b> <b>(struct</b> <b>rte_lpm</b> <b>*</b> <b>lpm,</b> <b>struct</b> <b>rte_lpm_rcu_config</b> <b>*</b> <b>cfg)</b>
       Associate RCU QSBR variable with an LPM object.

       <b>Parameters</b>
           <u>lpm</u> the lpm object to add RCU QSBR
           <u>cfg</u> RCU QSBR configuration

       <b>Returns</b>
           On success - 0 On error - 1 with error code set in rte_errno. Possible rte_errno codes are:

           • EINVAL - invalid pointer

           • EEXIST - already added QSBR

           • ENOMEM - memory allocation failure

   <b>int</b> <b>rte_lpm_add</b> <b>(struct</b> <b>rte_lpm</b> <b>*</b> <b>lpm,</b> <b>uint32_t</b> <b>ip,</b> <b>uint8_t</b> <b>depth,</b> <b>uint32_t</b> <b>next_hop)</b>
       Add a rule to the LPM table.

       <b>Parameters</b>
           <u>lpm</u> LPM object handle
           <u>ip</u> IP of the rule to be added to the LPM table
           <u>depth</u> Depth of the rule to be added to the LPM table
           <u>next_hop</u> Next hop of the rule to be added to the LPM table

       <b>Returns</b>
           0 on success, negative value otherwise

   <b>int</b> <b>rte_lpm_is_rule_present</b> <b>(struct</b> <b>rte_lpm</b> <b>*</b> <b>lpm,</b> <b>uint32_t</b> <b>ip,</b> <b>uint8_t</b> <b>depth,</b> <b>uint32_t</b> <b>*</b> <b>next_hop)</b>
       Check if a rule is present in the LPM table, and provide its next hop if it is.

       <b>Parameters</b>
           <u>lpm</u> LPM object handle
           <u>ip</u> IP of the rule to be searched
           <u>depth</u> Depth of the rule to searched
           <u>next_hop</u> Next hop of the rule (valid only if it is found)

       <b>Returns</b>
           1 if the rule exists, 0 if it does not, a negative value on failure

   <b>int</b> <b>rte_lpm_delete</b> <b>(struct</b> <b>rte_lpm</b> <b>*</b> <b>lpm,</b> <b>uint32_t</b> <b>ip,</b> <b>uint8_t</b> <b>depth)</b>
       Delete a rule from the LPM table.

       <b>Parameters</b>
           <u>lpm</u> LPM object handle
           <u>ip</u> IP of the rule to be deleted from the LPM table
           <u>depth</u> Depth of the rule to be deleted from the LPM table

       <b>Returns</b>
           0 on success, negative value otherwise

   <b>void</b> <b>rte_lpm_delete_all</b> <b>(struct</b> <b>rte_lpm</b> <b>*</b> <b>lpm)</b>
       Delete all rules from the LPM table.

       <b>Parameters</b>
           <u>lpm</u> LPM object handle

   <b>static</b> <b>int</b> <b>rte_lpm_lookup</b> <b>(const</b> <b>struct</b> <b>rte_lpm</b> <b>*</b> <b>lpm,</b> <b>uint32_t</b> <b>ip,</b> <b>uint32_t</b> <b>*</b> <b>next_hop)</b> <b>[inline],</b>  <b>[static]</b>
       Lookup an IP into the LPM table.

       <b>Parameters</b>
           <u>lpm</u> LPM object handle
           <u>ip</u> IP to be looked up in the LPM table
           <u>next_hop</u> Next hop of the most specific rule found for IP (valid on lookup hit only)

       <b>Returns</b>
           -EINVAL for incorrect arguments, -ENOENT on lookup miss, 0 on lookup hit

       Definition at line <b>279</b> of file <b>rte_lpm.h</b>.

   <b>static</b> <b>void</b> <b>rte_lpm_lookupx4</b> <b>(const</b> <b>struct</b> <b>rte_lpm</b> <b>*</b> <b>lpm,</b> <b>xmm_t</b> <b>ip,</b> <b>uint32_t</b> <b>hop[4],</b> <b>uint32_t</b> <b>defv)</b> <b>[inline],</b>
       <b>[static]</b>
       Lookup four IP addresses in an LPM table.

       <b>Parameters</b>
           <u>lpm</u> LPM object handle
           <u>ip</u> Four IPs to be looked up in the LPM table
           <u>hop</u> Next hop of the most specific rule found for IP (valid on lookup hit only). This is an 4 elements
           array of two byte values. If the lookup was successful for the given IP, then least significant  byte
           of  the  corresponding  element  is the actual next hop and the most significant byte is zero. If the
           lookup for the given  IP  failed,  then  corresponding  element  would  contain  default  value,  see
           description of then next parameter.
           <u>defv</u> Default value to populate into corresponding element of hop[] array, if lookup would fail.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for DPDK from the source code.

DPDK                                             Version 24.11.2                                    <u><a href="../man3/rte_lpm.h.3.html">rte_lpm.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>