<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libcurl-share - how to use the share interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libcurl-share - how to use the share interface

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  is an overview on how to use the libcurl share interface in your C programs. There are specific man
       pages for each function mentioned in here.

       All functions in the share interface are prefixed with curl_share.

</pre><h4><b>OBJECTIVES</b></h4><pre>
       The share interface was added to enable sharing of data between curl handles.

</pre><h4><b>ONE</b> <b>SET</b> <b>OF</b> <b>DATA</b> <b>-</b> <b>MANY</b> <b>TRANSFERS</b></h4><pre>
       You can have multiple easy handles share data between them. Have them update  and  use  the  <b>same</b>  cookie
       database,  DNS  cache,  TLS  session  cache and/or connection cache. This way, each single transfer takes
       advantage from data updates made by the other transfer(s).

</pre><h4><b>SHARE</b> <b>OBJECT</b></h4><pre>
       You create a shared object with <u><a href="../man3/curl_share_init.3.html">curl_share_init</a>(3)</u>. It returns a handle for a newly created one.

       You tell the shared object what data you want it to share by using <u><a href="../man3/curl_share_setopt.3.html">curl_share_setopt</a>(3)</u>.

       Since you can use this share from multiple threads, and libcurl has no internal  thread  synchronization,
       you  must provide mutex callbacks if you are using this multi-threaded. You set lock and unlock functions
       with <u><a href="../man3/curl_share_setopt.3.html">curl_share_setopt</a>(3)</u> too.

       Then,  you  make  an  easy  handle  to  use  this  share,  you  set  the  <u><a href="../man3/CURLOPT_SHARE.3.html">CURLOPT_SHARE</a>(3)</u>  option   with
       <u><a href="../man3/curl_easy_setopt.3.html">curl_easy_setopt</a>(3)</u>,  and  pass  in  share handle. You can make any number of easy handles share the same
       share handle.

       To make an easy handle stop using that particular share, you set <u><a href="../man3/CURLOPT_SHARE.3.html">CURLOPT_SHARE</a>(3)</u> to NULL for  that  easy
       handle. To make a handle stop sharing a particular data, you can <u><a href="../man3/CURLSHOPT_UNSHARE.3.html">CURLSHOPT_UNSHARE</a>(3)</u> it.

       When  you  are  done  using  the  share,  make  sure  that  no  easy  handle  is still using it, and call
       <u><a href="../man3/curl_share_cleanup.3.html">curl_share_cleanup</a>(3)</u> on the handle.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/curl_share_cleanup.3.html">curl_share_cleanup</a></b>(3),  <b><a href="../man3/curl_share_init.3.html">curl_share_init</a></b>(3),  <b><a href="../man3/curl_share_setopt.3.html">curl_share_setopt</a></b>(3),  <b><a href="../man3/libcurl-easy.3.html">libcurl-easy</a></b>(3),   <b><a href="../man3/libcurl-errors.3.html">libcurl-errors</a></b>(3),
       <b><a href="../man3/libcurl-multi.3.html">libcurl-multi</a></b>(3)

libcurl                                            2025-06-16                                   <u><a href="../man3/libcurl-share.3.html">libcurl-share</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>