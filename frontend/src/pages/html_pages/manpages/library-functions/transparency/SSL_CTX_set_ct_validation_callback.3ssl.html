<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ssl_ct_validation_cb, SSL_enable_ct, SSL_CTX_enable_ct, SSL_disable_ct, SSL_CTX_disable_ct,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ssl_ct_validation_cb, SSL_enable_ct, SSL_CTX_enable_ct, SSL_disable_ct, SSL_CTX_disable_ct,
       SSL_set_ct_validation_callback, SSL_CTX_set_ct_validation_callback, SSL_ct_is_enabled,
       SSL_CTX_ct_is_enabled - control Certificate Transparency policy

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/ssl.h&gt;

        typedef int (*ssl_ct_validation_cb)(const CT_POLICY_EVAL_CTX *ctx,
                                           const STACK_OF(SCT) *scts, void *arg);

        int SSL_enable_ct(SSL *s, int validation_mode);
        int SSL_CTX_enable_ct(SSL_CTX *ctx, int validation_mode);
        int SSL_set_ct_validation_callback(SSL *s, ssl_ct_validation_cb callback,
                                           void *arg);
        int SSL_CTX_set_ct_validation_callback(SSL_CTX *ctx,
                                               ssl_ct_validation_cb callback,
                                               void *arg);
        void SSL_disable_ct(SSL *s);
        void SSL_CTX_disable_ct(SSL_CTX *ctx);
        int SSL_ct_is_enabled(const SSL *s);
        int SSL_CTX_ct_is_enabled(const SSL_CTX *ctx);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>SSL_enable_ct()</b> and <b>SSL_CTX_enable_ct()</b> enable the processing of signed certificate timestamps (SCTs)
       either for a given SSL connection or for all connections that share the given SSL context, respectively.
       This is accomplished by setting a built-in CT validation callback.  The behaviour of the callback is
       determined by the <b>validation_mode</b> argument, which can be either of <b>SSL_CT_VALIDATION_PERMISSIVE</b> or
       <b>SSL_CT_VALIDATION_STRICT</b> as described below.

       If <b>validation_mode</b> is equal to <b>SSL_CT_VALIDATION_STRICT</b>, then in a full TLS handshake with the
       verification mode set to <b>SSL_VERIFY_PEER</b>, if the peer presents no valid SCTs the handshake will be
       aborted.  If the verification mode is <b>SSL_VERIFY_NONE</b>, the handshake will continue despite lack of valid
       SCTs.  However, in that case if the verification status before the built-in callback was <b>X509_V_OK</b> it
       will be set to <b>X509_V_ERR_NO_VALID_SCTS</b> after the callback.  Applications can call
       <b><a href="../man3/SSL_get_verify_result.3.html">SSL_get_verify_result</a></b>(3) to check the status at handshake completion, even after session resumption since
       the verification status is part of the saved session state.  See <b><a href="../man3/SSL_set_verify.3.html">SSL_set_verify</a></b>(3),
       &lt;<b><a href="../man3/SSL_get_verify_result.3.html">SSL_get_verify_result</a></b>(3)&gt;, <b><a href="../man3/SSL_session_reused.3.html">SSL_session_reused</a></b>(3).

       If <b>validation_mode</b> is equal to <b>SSL_CT_VALIDATION_PERMISSIVE</b>, then the handshake continues, and the
       verification status is not modified, regardless of the validation status of any SCTs.  The application
       can still inspect the validation status of the SCTs at handshake completion.  Note that with session
       resumption there will not be any SCTs presented during the handshake.  Therefore, in applications that
       delay SCT policy enforcement until after handshake completion, such delayed SCT checks should only be
       performed when the session is not resumed.

       <b>SSL_set_ct_validation_callback()</b> and <b>SSL_CTX_set_ct_validation_callback()</b> register a custom callback that
       may implement a different policy than either of the above.  This callback can examine the peer's SCTs and
       determine whether they are sufficient to allow the connection to continue.  The TLS handshake is aborted
       if the verification mode is not <b>SSL_VERIFY_NONE</b> and the callback returns a non-positive result.

       An arbitrary callback data argument, <b>arg</b>, can be passed in when setting the callback.  This will be
       passed to the callback whenever it is invoked.  Ownership of this context remains with the caller.

       If no callback is set, SCTs will not be requested and Certificate Transparency validation will not occur.

       No callback will be invoked when the peer presents no certificate, e.g. by employing an anonymous (aNULL)
       cipher suite.  In that case the handshake continues as it would had no callback been requested.
       Callbacks are also not invoked when the peer certificate chain is invalid or validated via <b><a href="../man2/DANE-TA.2.html">DANE-TA</a></b>(2) or
       <b><a href="../man3/DANE-EE.3.html">DANE-EE</a></b>(3) TLSA records which use a private X.509 PKI, or no X.509 PKI at all, respectively.  Clients
       that require SCTs are expected to not have enabled any aNULL ciphers nor to have specified server
       verification via <b><a href="../man2/DANE-TA.2.html">DANE-TA</a></b>(2) or <b><a href="../man3/DANE-EE.3.html">DANE-EE</a></b>(3) TLSA records.

       <b>SSL_disable_ct()</b> and <b>SSL_CTX_disable_ct()</b> turn off CT processing, whether enabled via the built-in or the
       custom callbacks, by setting a NULL callback.  These may be implemented as macros.

       <b>SSL_ct_is_enabled()</b> and <b>SSL_CTX_ct_is_enabled()</b> return 1 if CT processing is enabled via either
       <b>SSL_enable_ct()</b> or a non-null custom callback, and 0 otherwise.

</pre><h4><b>NOTES</b></h4><pre>
       When SCT processing is enabled, OCSP stapling will be enabled. This is because one possible source of
       SCTs is the OCSP response from a server.

       The time returned by <b>SSL_SESSION_get_time_ex()</b> will be used to evaluate whether any presented SCTs have
       timestamps that are in the future (and therefore invalid).

</pre><h4><b>RESTRICTIONS</b></h4><pre>
       Certificate Transparency validation cannot be enabled and so a callback cannot be set if a custom client
       extension handler has been registered to handle SCT extensions
       (<b>TLSEXT_TYPE_signed_certificate_timestamp</b>).

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>SSL_enable_ct()</b>, <b>SSL_CTX_enable_ct()</b>, <b>SSL_CTX_set_ct_validation_callback()</b> and
       <b>SSL_set_ct_validation_callback()</b> return 1 if the <b>callback</b> is successfully set.  They return 0 if an error
       occurs, e.g. a custom client extension handler has been setup to handle SCTs.

       <b>SSL_disable_ct()</b> and <b>SSL_CTX_disable_ct()</b> do not return a result.

       <b>SSL_CTX_ct_is_enabled()</b> and <b>SSL_ct_is_enabled()</b> return a 1 if a non-null CT validation callback is set,
       or 0 if no callback (or equivalently a NULL callback) is set.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/ssl.7.html">ssl</a></b>(7), &lt;<b><a href="../man3/SSL_get_verify_result.3.html">SSL_get_verify_result</a></b>(3)&gt;, <b><a href="../man3/SSL_session_reused.3.html">SSL_session_reused</a></b>(3), <b><a href="../man3/SSL_set_verify.3.html">SSL_set_verify</a></b>(3), <b><a href="../man3/SSL_CTX_set_verify.3.html">SSL_CTX_set_verify</a></b>(3),
       <b><a href="../man3/SSL_SESSION_get_time.3.html">SSL_SESSION_get_time</a></b>(3)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2016-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04           <u><a href="../man3SSL/SSL_CTX_SET_CT_VALIDATION_CALLBACK.3SSL.html">SSL_CTX_SET_CT_VALIDATION_CALLBACK</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>