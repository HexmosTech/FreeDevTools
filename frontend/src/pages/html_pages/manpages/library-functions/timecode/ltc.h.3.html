<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ltc.h - libltc - en+decode linear timecode</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libltc-doc">libltc-doc_1.3.2-1build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ltc.h - libltc - en+decode linear timecode

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/endian.h">endian.h</a>&gt;
       #include &lt;stddef.h&gt;

   <b>Data</b> <b>Structures</b>
       struct <b>LTCFrame</b>
       struct <b>LTCFrameExt</b>
       struct <b>SMPTETimecode</b>

   <b>Macros</b>
       #define <b>DEPRECATED_EXPORT</b>
       #define <b>LTC_FRAME_BIT_COUNT</b>   80

   <b>Typedefs</b>
       typedef unsigned char <b>ltcsnd_sample_t</b>
       typedef long long int <b>ltc_off_t</b>
       typedef struct <b>LTCFrame</b> <b>LTCFrame</b>
       typedef struct <b>LTCFrameExt</b> <b>LTCFrameExt</b>
       typedef struct <b>SMPTETimecode</b> <b>SMPTETimecode</b>
       typedef struct <b>LTCDecoder</b> <b>LTCDecoder</b>
       typedef struct <b>LTCEncoder</b> <b>LTCEncoder</b>

   <b>Enumerations</b>
       enum <b>LTC_TV_STANDARD</b> { <b>LTC_TV_525_60</b>, <b>LTC_TV_625_50</b>, <b>LTC_TV_1125_60</b>, <b>LTC_TV_FILM_24</b> }
       enum <b>LTC_BG_FLAGS</b> { <b>LTC_USE_DATE</b> = 1, <b>LTC_TC_CLOCK</b> = 2, <b>LTC_BGF_DONT_TOUCH</b> = 4, <b>LTC_NO_PARITY</b> = 8 }

   <b>Functions</b>
       void <b>ltc_frame_to_time</b> (<b>SMPTETimecode</b> *stime, <b>LTCFrame</b> *frame, int flags)
       void <b>ltc_time_to_frame</b> (<b>LTCFrame</b> *frame, <b>SMPTETimecode</b> *stime, enum <b>LTC_TV_STANDARD</b> standard, int flags)
       void <b>ltc_frame_reset</b> (<b>LTCFrame</b> *frame)
       int <b>ltc_frame_increment</b> (<b>LTCFrame</b> *frame, int fps, enum <b>LTC_TV_STANDARD</b> standard, int flags)
       int <b>ltc_frame_decrement</b> (<b>LTCFrame</b> *frame, int fps, enum <b>LTC_TV_STANDARD</b> standard, int flags)
       <b>LTCDecoder</b> * <b>ltc_decoder_create</b> (int apv, int queue_size)
       int <b>ltc_decoder_free</b> (<b>LTCDecoder</b> *d)
       void <b>ltc_decoder_write</b> (<b>LTCDecoder</b> *d, <b>ltcsnd_sample_t</b> *buf, size_t size, <b>ltc_off_t</b> posinfo)
       void <b>ltc_decoder_write_double</b> (<b>LTCDecoder</b> *d, double *buf, size_t size, <b>ltc_off_t</b> posinfo)
       void <b>ltc_decoder_write_float</b> (<b>LTCDecoder</b> *d, float *buf, size_t size, <b>ltc_off_t</b> posinfo)
       void <b>ltc_decoder_write_s16</b> (<b>LTCDecoder</b> *d, short *buf, size_t size, <b>ltc_off_t</b> posinfo)
       void <b>ltc_decoder_write_u16</b> (<b>LTCDecoder</b> *d, unsigned short *buf, size_t size, <b>ltc_off_t</b> posinfo)
       int <b>ltc_decoder_read</b> (<b>LTCDecoder</b> *d, <b>LTCFrameExt</b> *frame)
       void <b>ltc_decoder_queue_flush</b> (<b>LTCDecoder</b> *d)
       int <b>ltc_decoder_queue_length</b> (<b>LTCDecoder</b> *d)
       <b>LTCEncoder</b> * <b>ltc_encoder_create</b> (double sample_rate, double fps, enum <b>LTC_TV_STANDARD</b> standard, int
           flags)
       void <b>ltc_encoder_free</b> (<b>LTCEncoder</b> *e)
       void <b>ltc_encoder_set_timecode</b> (<b>LTCEncoder</b> *e, <b>SMPTETimecode</b> *t)
       void <b>ltc_encoder_get_timecode</b> (<b>LTCEncoder</b> *e, <b>SMPTETimecode</b> *t)
       void <b>ltc_encoder_set_user_bits</b> (<b>LTCEncoder</b> *e, unsigned long data)
       unsigned long <b>ltc_frame_get_user_bits</b> (<b>LTCFrame</b> *f)
       int <b>ltc_encoder_inc_timecode</b> (<b>LTCEncoder</b> *e)
       int <b>ltc_encoder_dec_timecode</b> (<b>LTCEncoder</b> *e)
       void <b>ltc_encoder_set_frame</b> (<b>LTCEncoder</b> *e, <b>LTCFrame</b> *f)
       void <b>ltc_encoder_get_frame</b> (<b>LTCEncoder</b> *e, <b>LTCFrame</b> *f)
       int <b>ltc_encoder_get_buffer</b> (<b>LTCEncoder</b> *e, <b>ltcsnd_sample_t</b> *buf) <b>DEPRECATED_EXPORT</b>
       int <b>ltc_encoder_copy_buffer</b> (<b>LTCEncoder</b> *e, <b>ltcsnd_sample_t</b> *buf)
       <b>ltcsnd_sample_t</b> * <b>ltc_encoder_get_bufptr</b> (<b>LTCEncoder</b> *e, int *size, int flush) <b>DEPRECATED_EXPORT</b>
       int <b>ltc_encoder_get_bufferptr</b> (<b>LTCEncoder</b> *e, <b>ltcsnd_sample_t</b> **buf, int flush)
       void <b>ltc_encoder_buffer_flush</b> (<b>LTCEncoder</b> *e)
       size_t <b>ltc_encoder_get_buffersize</b> (<b>LTCEncoder</b> *e)
       int <b>ltc_encoder_reinit</b> (<b>LTCEncoder</b> *e, double sample_rate, double fps, enum <b>LTC_TV_STANDARD</b> standard, int
           flags)
       void <b>ltc_encoder_reset</b> (<b>LTCEncoder</b> *e)
       int <b>ltc_encoder_set_bufsize</b> (<b>LTCEncoder</b> *e, double sample_rate, double fps) <b>DEPRECATED_EXPORT</b>
       int <b>ltc_encoder_set_buffersize</b> (<b>LTCEncoder</b> *e, double sample_rate, double fps)
       double <b>ltc_encoder_get_volume</b> (<b>LTCEncoder</b> *e)
       int <b>ltc_encoder_set_volume</b> (<b>LTCEncoder</b> *e, double dBFS)
       double <b>ltc_encoder_get_filter</b> (<b>LTCEncoder</b> *e)
       void <b>ltc_encoder_set_filter</b> (<b>LTCEncoder</b> *e, double rise_time)
       int <b>ltc_encoder_encode_byte</b> (<b>LTCEncoder</b> *e, int byte, double speed)
       int <b>ltc_encoder_end_encode</b> (<b>LTCEncoder</b> *e)
       void <b>ltc_encoder_encode_frame</b> (<b>LTCEncoder</b> *e)
       void <b>ltc_encoder_encode_reversed_frame</b> (<b>LTCEncoder</b> *e)
       void <b>ltc_frame_set_parity</b> (<b>LTCFrame</b> *frame, enum <b>LTC_TV_STANDARD</b> standard)
       int <b>ltc_frame_parse_bcg_flags</b> (<b>LTCFrame</b> *frame, enum <b>LTC_TV_STANDARD</b> standard)
       <b>ltc_off_t</b> <b>ltc_frame_alignment</b> (double samples_per_frame, enum <b>LTC_TV_STANDARD</b> standard)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       libltc - en+decode linear timecode

       Linear (or Longitudinal) Timecode (LTC) is an encoding of timecode data as a Manchester-Biphase encoded
       audio signal. The audio signal is commonly recorded on a VTR track or other storage media.

       libltc facilitates decoding and encoding of LTC from/to timecode, including SMPTE date support.

       <b>Author</b>
           Robin Gareus <a href="mailto:robin@gareus.org">robin@gareus.org</a>

       <b>Copyright</b>

       Copyright (C) 2006-2022 Robin Gareus <a href="mailto:robin@gareus.org">robin@gareus.org</a>

       Copyright (C) 2008-2009 Jan Weiß <a href="mailto:jan@geheimwerk.de">jan@geheimwerk.de</a>

       Inspired by SMPTE Decoder - Maarten de Boer <a href="mailto:mdeboer@iua.upf.es">mdeboer@iua.upf.es</a>

       This program is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser
       General Public License as published by the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
       the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
       Public License for more details.

       You should have received a copy of the GNU Lesser General Public License along with this library. If not,
       see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.

</pre><h4><b>Data</b> <b>Structure</b> <b>Documentation</b></h4><pre>
</pre><h4><b>struct</b> <b>LTCFrame</b></h4><pre>
       Raw 80 bit LTC frame

       The datastream for each video frame of Longitudinal Timecode consists of eighty bit-periods.

       At a frame-rate of 30 fps, the bit-rate corresponds to 30 [fps] * 80 [bits/f] = 2400 bits per second. The
       frequency for a stream of zeros would be 1.2 kHz and for a stream of ones it would be 2.4 kHz.  With all
       commonly used video-frame-rates and audio-sample-rates, LTC timecode can be recorded easily into a audio-
       track.

       In each frame, 26 of the eighty bits carry the SMPTE time in binary coded decimal (BCD).

       These Bits are FRAME-UNITS, FRAME-TENS, SECS-UNITS, SECS-TENS, MINS-UNITS, MINS-TENS, HOURS-UNITS and
       HOURS-TENS. The BCD digits are loaded 'least significant bit first' (libltc takes care of the
       architecture specific alignment).

       32 bits are assigned as eight groups of four USER-BITS (also sometimes called the 'Binary Groups'). This
       capacity is generally used to carry extra info such as reel number and/or date. The User Bits may be
       allocated howsoever one wishes as long as both Binary Group Flag Bits are cleared.

       The function <b>ltc_frame_to_time</b> can interpret the user-bits as SMPTE Date+Timezone according to SMPTE
       309M-1999. similarly <b>ltc_time_to_frame</b> will do the reverse.

       The last 16 Bits make up the SYNC WORD. These bits indicate the frame boundary, the tape direction, and
       the bit-rate of the sync tone. The values of these Bits are fixed as 0011 1111 1111 1101

       The Bi-Phase Mark Phase Correction Bit (Bit 27 or 59) may be set or cleared so that that every 80-bit
       word contains an even number of zeroes. This means that the phase of the pulse train in every Sync Word
       will be the same.

       Bit 10 indicates drop-frame timecode. The Colour Frame Flag col.frm is Bit 11; if the timecode
       intentionally synchronized to a colour TV field sequence, this bit is set.

       Bit 58 is not required for the BCD count for HOURS-TENS (which has a maximum value of two) and has not
       been given any other special purpose so remains unassigned. This Bit has been RESERVED for future
       assignment.

       The Binary Group Flag Bits (bits 43 and 59) are two bits indicate the format of the User Bits data. SMPTE
       12M-1999 defines the previously reserved bit 58 to signals that the time is locked to wall-clock within a
       tolerance of ± 0.5 seconds.

       SMPTE 12M-1999 also changes the numbering schema of the BGF. (BGF1 was renamed to BGF2 and bit 58 becomes
       BGFB1)

       To further complicate matters, the BGFB assignment as well as the biphase_mark_phase_correction (aka
       parity) bit depends on the timecode-format used.

                25 fps   24, 30 fps
        BGF0      27        43
        BGF1      58        58
        BGF2      43        59
        Parity    59        27

       The variable naming chosen for the <b>LTCFrame</b> struct is based on the 24,30 fps standard.

       The Binary Group Flag Bits should be used only as shown in the truth table below. The Unassigned entries
       in the table should not be used, as they may be allocated specific meanings in the future.

                                                       BGF0      BGF1    BGF2
             user-bits                     timecode    Bit 43   Bit 58  Bit 59 (30fps, 24 fps)
                                          |        |   Bit 27   Bit 58  Bit 43 (25fps)
        No User Bits format specified     |   ?    |     0       0        0
        Eight-bit character set (1)       |   ?    |     1       0        0
        Date and Timezone set             |   ?    |     0       0        1
        Page/Line multiplex (2)           |   ?    |     1       0        1
        Character set not specified       |  clk   |     0       1        0
        Reserved                          |   ?    |     1       1        0
        Date and Timezone set             |  clk   |     0       1        1
        Page/Line multiplex (2)           |  clk   |     1       1        1

       (1) ISO/IEC 646 or ISO/IEC 2022 character set. If the seven-bit ISO codes are being used, they shall be
       converted to eight-bit codes by setting the eighth bit to zero. 4 ISO codes can be encoded, user7 and
       user8 are to be used for the first code with LSB 7 and MSB in 8. the remaining ISO codes are to be
       distributed in the same manner to user5/6 user3/4 and user1/2 accordingly.

       (2) The Page/Line indicates ANSI/SMPTE-262M is used for the user-bits. It is multiplex system that can be
       used to encode large amounts of data in the binary groups through the use of time multiplexing.

       libltc does not use any of the BGF - except for the Parity bit which can be calculated and set with
       <b>ltc_frame_set_parity</b>. Setting and interpreting the BGF is left to the application using libltc. However
       libltc provides functionality to parse or set date and timezoe according to SMPTE 309M-1999.

       further information: <a href="http://www.philrees.co.uk/articles/timecode.htm">http://www.philrees.co.uk/articles/timecode.htm</a> and <a href="http://www.barney">http://www.barney</a>-
       wol.net/time/timecode.html

       <b>Data</b> <b>Fields:</b>
           unsigned int <u>binary_group_flag_bit0:1</u> indicate user-data char encoding, see table above - bit 43

           unsigned int <u>binary_group_flag_bit1:1</u> indicate timecode is local time wall-clock, see table above -
           bit 58

           unsigned int <u>binary_group_flag_bit2:1</u> indicate user-data char encoding (or parity with 25fps), see
           table above - bit 59

           unsigned int <u>biphase_mark_phase_correction:1</u> see note on Bit 27 in description and
           <b>ltc_frame_set_parity</b> .

           unsigned int <u>col_frame:1</u> colour-frame: timecode intentionally synchronized to a colour TV field
           sequence

           unsigned int <u>dfbit:1</u> indicated drop-frame timecode

           unsigned int <u>frame_tens:2</u> SMPTE framenumber BCD tens 0..3.

           unsigned int <u>frame_units:4</u> SMPTE framenumber BCD unit 0..9.

           unsigned int <u>hours_tens:2</u> SMPTE hours BCD tens 0..2.

           unsigned int <u>hours_units:4</u> SMPTE hours BCD unit 0..9.

           unsigned int <u>mins_tens:3</u> SMPTE minutes BCD tens 0..6.

           unsigned int <u>mins_units:4</u> SMPTE minutes BCD unit 0..9.

           unsigned int <u>secs_tens:3</u> SMPTE seconds BCD tens 0..6.

           unsigned int <u>secs_units:4</u> SMPTE seconds BCD unit 0..9.

           unsigned int <u>sync_word:16</u>

           unsigned int <u>user1:4</u>

           unsigned int <u>user2:4</u>

           unsigned int <u>user3:4</u>

           unsigned int <u>user4:4</u>

           unsigned int <u>user5:4</u>

           unsigned int <u>user6:4</u>

           unsigned int <u>user7:4</u>

           unsigned int <u>user8:4</u>

</pre><h4><b>struct</b> <b>LTCFrameExt</b></h4><pre>
       Extended LTC frame - includes audio-sample position offsets, volume, etc

       Note: For TV systems, the sample in the LTC audio data stream where the LTC Frame starts is not
       necessarily at the same time as the video-frame which is described by the LTC Frame.

       <b>off_start</b> denotes the time of the first transition of bit 0 in the LTC frame.

       For 525/60 Television systems, the first transition shall occur at the beginning of line 5 of the frame
       with which it is associated. The tolerance is ± 1.5 lines.

       For 625/50 systems, the first transition shall occur at the beginning of line 2 ± 1.5 lines of the frame
       with which it is associated.

       Only for 1125/60 systems, the first transition occurs exactly at the vertical sync timing reference of
       the frame. ± 1 line.

       <b>Examples</b>
           <b>ltcdecode.c</b>.

       <b>Data</b> <b>Fields:</b>
           float <u>biphase_tics[</u><b>LTC_FRAME_BIT_COUNT</b><u>]</u> <b>detailed</b> <b>timing</b> <b>info:</b> <b>phase</b> <b>of</b> <b>the</b> <b>LTC</b> <b>signal;</b> <b>the</b> <b>time</b>
           <b>between</b> <b>each</b> <b>bit</b> <b>in</b> <b>the</b> <b>LTC-frame</b> <b>in</b> <b>audio-frames.</b> <b>Summing</b> <b>all</b> <b>80</b> <b>values</b> <b>in</b> <b>the</b> <b>array</b> <b>will</b> <b>yield</b>
           <b>audio-frames/LTC-frame</b> <b>=</b> <b>(off_end</b> <b>-</b> <b>off_start</b> <b>+</b> <b>1).</b>

           <b>LTCFrame</b> <u>ltc</u> the actual LTC frame. see <b>LTCFrame</b>

           <b>ltc_off_t</b> <u>off_end</u> the sample in the stream corresponding to the end of the LTC frame.

           <b>ltc_off_t</b> <u>off_start</u> the approximate sample in the stream corresponding to the start of the LTC frame.

           int <u>reverse</u> if non-zero, a reverse played LTC frame was detected. Since the frame was reversed, it
           started at off_end and finishes as off_start (off_end &gt; off_start). (Note: in reverse playback the
           (reversed) sync-word of the next/previous frame is detected, this offset is corrected).

           <b>ltcsnd_sample_t</b> <u>sample_max</u> the maximum input sample signal for this frame (0..255)

           <b>ltcsnd_sample_t</b> <u>sample_min</u> the minimum input sample signal for this frame (0..255)

           double <u>volume</u> the volume of the input signal in dbFS

</pre><h4><b>struct</b> <b>SMPTETimecode</b></h4><pre>
       Human readable time representation, decimal values.

       <b>Examples</b>
           <b>example_encode.c</b>, <b>ltcdecode.c</b>, and <b>ltcencode.c</b>.

       <b>Data</b> <b>Fields:</b>
           unsigned char <u>days</u> day of month 1..31

           unsigned char <u>frame</u> sub-second frame 0..(FPS - 1)

           unsigned char <u>hours</u> hour 0..23

           unsigned char <u>mins</u> minute 0..60

           unsigned char <u>months</u> valid months are 1..12

           unsigned char <u>secs</u> second 0..60

           char <u>timezone[6]</u> the timezone 6bytes: '+HHMM' textual representation

           unsigned char <u>years</u> LTC-date uses 2-digit year 00.99.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>DEPRECATED_EXPORT</b>
   <b>#define</b> <b>LTC_FRAME_BIT_COUNT</b>   <b>80</b>
</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>long</b> <b>long</b> <b>int</b> <b>ltc_off_t</b>
       sample-count offset - 64bit wide

   <b>typedef</b> <b>struct</b> <b>LTCDecoder</b> <b>LTCDecoder</b>
       Opaque structure see: <b>ltc_decoder_create</b>, <b>ltc_decoder_free</b>

   <b>typedef</b> <b>struct</b> <b>LTCEncoder</b> <b>LTCEncoder</b>
       Opaque structure see: <b>ltc_encoder_create</b>, <b>ltc_encoder_free</b>

   <b>typedef</b> <b>struct</b> <b>LTCFrame</b> <b>LTCFrame</b>
       see <b>LTCFrame</b>

   <b>typedef</b> <b>struct</b> <b>LTCFrameExt</b> <b>LTCFrameExt</b>
       see <b>LTCFrameExt</b>

   <b>typedef</b> <b>unsigned</b> <b>char</b> <b>ltcsnd_sample_t</b>
       default audio sample type: 8bit unsigned (mono)

   <b>typedef</b> <b>struct</b> <b>SMPTETimecode</b> <b>SMPTETimecode</b>
       see <b>SMPTETimecode</b>

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>LTC_BG_FLAGS</b>
       encoder and LTCframe &lt;&gt; timecode operation flags

       <b>Enumerator</b>

       <u>LTC_USE_DATE</u>
              <b>LTCFrame</b>  &lt;&gt;  <b>SMPTETimecode</b>  converter and <b>LTCFrame</b> increment/decrement use date, also set BGF2 to
              '1' when encoder is initialized or re-initialized (unless LTC_BGF_DONT_TOUCH is given)

       <u>LTC_TC_CLOCK</u>
              the Timecode is wall-clock aka freerun. This also sets BGF1 (unless LTC_BGF_DONT_TOUCH is given)

       <u>LTC_BGF_DONT_TOUCH</u>
              encoder init or re-init does not touch the BGF bits (initial values after initialization is zero)

       <u>LTC_NO_PARITY</u>
              parity bit is left untouched when setting or in/decrementing the encoder frame-number

   <b>enum</b> <b>LTC_TV_STANDARD</b>
       the standard defines the assignment of the binary-group-flag bits basically only 25fps is different,  but
       other standards defined in the SMPTE spec have been included for completeness.

       <b>Enumerator</b>

       <u>LTC_TV_525_60</u>
              30fps

       <u>LTC_TV_625_50</u>
              25fps

       <u>LTC_TV_1125_60</u>
              30fps

       <u>LTC_TV_FILM_24</u>
              24fps

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>LTCDecoder*</b> <b>ltc_decoder_create</b> <b>(int</b> <b>apv,</b> <b>int</b> <b>queue_size)</b>
       Create a new LTC decoder.

       <b>Parameters</b>
           <u>apv</u>  audio-frames  per  video  frame.  This  is  just used for initial settings, the speed is tracked
           dynamically. setting this in the right ballpark is needed to properly decode the first LTC frame in a
           sequence.
           <u>queue_size</u> length of the internal queue to store decoded frames to SMPTEDecoderWrite.

       <b>Returns</b>
           decoder handle or NULL if out-of-memory

       <b>Examples</b>
           <b>ltcdecode.c</b>.

   <b>int</b> <b>ltc_decoder_free</b> <b>(LTCDecoder</b> <b>*</b> <b>d)</b>
       Release memory of decoder.

       <b>Parameters</b>
           <u>d</u> decoder handle

       <b>Examples</b>
           <b>ltcdecode.c</b>.

   <b>void</b> <b>ltc_decoder_queue_flush</b> <b>(LTCDecoder</b> <b>*</b> <b>d)</b>
       Remove all LTC frames from the internal queue.

       <b>Parameters</b>
           <u>d</u> decoder handle

   <b>int</b> <b>ltc_decoder_queue_length</b> <b>(LTCDecoder</b> <b>*</b> <b>d)</b>
       Count number of LTC frames currently in the queue.

       <b>Parameters</b>
           <u>d</u> decoder handle

       <b>Returns</b>
           number of queued frames

   <b>int</b> <b>ltc_decoder_read</b> <b>(LTCDecoder</b> <b>*</b> <b>d,</b> <b>LTCFrameExt</b> <b>*</b> <b>frame)</b>
       Decoded LTC frames are placed in a queue. This function retrieves a frame from the queue, and  stores  it
       at LTCFrameExt*

       <b>Parameters</b>
           <u>d</u> decoder handle
           <u>frame</u> the decoded LTC frame is copied there

       <b>Returns</b>
           1 on success or 0 when no frames queued.

       <b>Examples</b>
           <b>ltcdecode.c</b>.

   <b>void</b> <b>ltc_decoder_write</b> <b>(LTCDecoder</b> <b>*</b> <b>d,</b> <b>ltcsnd_sample_t</b> <b>*</b> <b>buf,</b> <b>size_t</b> <b>size,</b> <b>ltc_off_t</b> <b>posinfo)</b>
       Feed the LTC decoder with new audio samples.

       Parse  raw audio for LTC timestamps. Once a complete LTC frame has been decoded it is pushed into a queue
       (<b>ltc_decoder_read</b>)

       <b>Parameters</b>
           <u>d</u> decoder handle
           <u>buf</u> pointer to ltcsnd_sample_t - unsigned 8 bit mono audio data
           <u>size</u> size number of samples to parse
           <u>posinfo</u> (optional, recommended) sample-offset in the audio-stream. It is added to <b>off_start</b>,  <b>off_end</b>
           in <b>LTCFrameExt</b> and should be monotonic (ie incremented by size for every call to ltc_decoder_write)

       <b>Examples</b>
           <b>ltcdecode.c</b>.

   <b>void</b> <b>ltc_decoder_write_double</b> <b>(LTCDecoder</b> <b>*</b> <b>d,</b> <b>double</b> <b>*</b> <b>buf,</b> <b>size_t</b> <b>size,</b> <b>ltc_off_t</b> <b>posinfo)</b>
       Wrapper  around  <b>ltc_decoder_write</b>  that  accepts  64-bit  floating point audio samples. Note: internally
       libltc uses 8 bit only.

       <b>Parameters</b>
           <u>d</u> decoder handle
           <u>buf</u> pointer to audio sample data
           <u>size</u> number of samples to parse
           <u>posinfo</u> (optional, recommended) sample-offset in the audio-stream.

   <b>void</b> <b>ltc_decoder_write_float</b> <b>(LTCDecoder</b> <b>*</b> <b>d,</b> <b>float</b> <b>*</b> <b>buf,</b> <b>size_t</b> <b>size,</b> <b>ltc_off_t</b> <b>posinfo)</b>
       Wrapper around <b>ltc_decoder_write</b> that accepts 32-bit  floating  point  audio  samples.  Note:  internally
       libltc uses 8 bit only.

       <b>Parameters</b>
           <u>d</u> decoder handle
           <u>buf</u> pointer to audio sample data
           <u>size</u> number of samples to parse
           <u>posinfo</u> (optional, recommended) sample-offset in the audio-stream.

   <b>void</b> <b>ltc_decoder_write_s16</b> <b>(LTCDecoder</b> <b>*</b> <b>d,</b> <b>short</b> <b>*</b> <b>buf,</b> <b>size_t</b> <b>size,</b> <b>ltc_off_t</b> <b>posinfo)</b>
       Wrapper around <b>ltc_decoder_write</b> that accepts signed 16 bit audio samples. Note: internally libltc uses 8
       bit only.

       <b>Parameters</b>
           <u>d</u> decoder handle
           <u>buf</u> pointer to audio sample data
           <u>size</u> number of samples to parse
           <u>posinfo</u> (optional, recommended) sample-offset in the audio-stream.

   <b>void</b> <b>ltc_decoder_write_u16</b> <b>(LTCDecoder</b> <b>*</b> <b>d,</b> <b>unsigned</b> <b>short</b> <b>*</b> <b>buf,</b> <b>size_t</b> <b>size,</b> <b>ltc_off_t</b> <b>posinfo)</b>
       Wrapper around <b>ltc_decoder_write</b> that accepts unsigned 16 bit audio samples. Note: internally libltc uses
       8 bit only.

       <b>Parameters</b>
           <u>d</u> decoder handle
           <u>buf</u> pointer to audio sample data
           <u>size</u> number of samples to parse
           <u>posinfo</u> (optional, recommended) sample-offset in the audio-stream.

   <b>void</b> <b>ltc_encoder_buffer_flush</b> <b>(LTCEncoder</b> <b>*</b> <b>e)</b>
       reset the write-pointer of the encoder-buffer

       <b>Parameters</b>
           <u>e</u> encoder handle

   <b>int</b> <b>ltc_encoder_copy_buffer</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>ltcsnd_sample_t</b> <b>*</b> <b>buf)</b>
       Copy the accumulated encoded audio to the given sample-buffer and flush the internal buffer.

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>buf</u>  place  to  store  the audio-samples, needs to be large enough to hold <b>ltc_encoder_get_buffersize</b>
           bytes

       <b>Returns</b>
           the number of bytes written to the memory area pointed to by buf.

       <b>Examples</b>
           <b>example_encode.c</b>.

   <b>LTCEncoder*</b> <b>ltc_encoder_create</b> <b>(double</b> <b>sample_rate,</b> <b>double</b> <b>fps,</b> <b>enum</b> <b>LTC_TV_STANDARD</b> <b>standard,</b> <b>int</b> <b>flags)</b>
       Allocate and initialize LTC audio encoder.

       calls <b>ltc_encoder_reinit</b> internally see, see notes there.

       <b>Parameters</b>
           <u>sample_rate</u> audio sample rate (eg. 48000)
           <u>fps</u> video-frames per second (e.g. 25.0)
           <u>standard</u> the TV standard to use for Binary Group Flag bit position
           <u>flags</u> binary combination of <b>LTC_BG_FLAGS</b>

       <b>Examples</b>
           <b>example_encode.c</b>, and <b>ltcencode.c</b>.

   <b>int</b> <b>ltc_encoder_dec_timecode</b> <b>(LTCEncoder</b> <b>*</b> <b>e)</b>
       Move the encoder to the  previous  timecode  frame.  This  is  useful  for  encoding  reverse  LTC.  uses
       <b>ltc_frame_decrement()</b> internally.

   <b>int</b> <b>ltc_encoder_encode_byte</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>int</b> <b>byte,</b> <b>double</b> <b>speed)</b>
       Generate LTC audio for given byte of the LTC-frame and place it into the internal buffer.

       see <b>ltc_encoder_copy_buffer</b> and <b>ltc_encoder_get_bufferptr</b>

       LTC  has  10  bytes  per  frame:  0  &lt;= bytecnt &lt; 10 use SMPTESetTime(..) to set the current frame before
       Encoding. see tests/encoder.c for an example.

       The default output signal is @ -3dBFS (38..218 at 8 bit unsigned). see also <b>ltc_encoder_set_volume</b>

       if speed is &lt; 0, the bits are encoded in reverse. slowdown &gt;  10.0  requires  custom  buffer  sizes;  see
       <b>ltc_encoder_set_buffersize</b>

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>byte</u> byte of the LTC-frame to encode 0..9
           <u>speed</u> vari-speed, &lt; 1.0 faster, &gt; 1.0 slower ; must be != 0

       <b>Returns</b>
           0 on success, -1 if byte is invalid or buffer overflow (speed &gt; 10.0)

       <b>Examples</b>
           <b>example_encode.c</b>.

   <b>void</b> <b>ltc_encoder_encode_frame</b> <b>(LTCEncoder</b> <b>*</b> <b>e)</b>
       Encode  a  full  LTC frame at fixed speed. This is equivalent to calling <b>ltc_encoder_encode_byte</b> 10 times
       for bytes 0..9 with speed 1.0.

       Note: The internal buffer must be empty before calling this function. Otherwise it may overflow. This  is
       usually the case if it is read with <b>ltc_encoder_copy_buffer</b> after calling this function.

       The default internal buffersize is exactly one full LTC frame at speed 1.0.

       <b>Parameters</b>
           <u>e</u> encoder handle

       <b>Examples</b>
           <b>example_encode.c</b>, and <b>ltcencode.c</b>.

   <b>void</b> <b>ltc_encoder_encode_reversed_frame</b> <b>(LTCEncoder</b> <b>*</b> <b>e)</b>
       Encode a full LTC frame at fixed speed -1. This is equivalent to calling <b>ltc_encoder_encode_byte</b> 10 times
       for bytes 9..0, rolling in reverse at speed 1.

       Note:  The internal buffer must be empty before calling this function. Otherwise it may overflow. This is
       usually the case if it is read with <b>ltc_encoder_copy_buffer</b> after calling this function.

       <b>Parameters</b>
           <u>e</u> encoder handle

   <b>int</b> <b>ltc_encoder_end_encode</b> <b>(LTCEncoder</b> <b>*</b> <b>e)</b>
       Terminate encoding and add final transition

       Refer to the image at <b>LTCFrame</b>. In this example, the encoded data starts and ends with a rising edge. The
       transition at the start of tne next frame marks the end of the previous frame. This transition is encoded
       at the beginning of a frame. However if there is no additional frame to be encoded, a  final  terminating
       transition has to be added.

       Since  LTC  is  usually  sent  as  continuous  stream, this is of no concern. However for a fixed, finite
       duration to be encoded, this method adds a terminating transition to the buffer.

       After this one must either call <b>ltc_encoder_reset()</b> or <b>ltc_encoder_free</b>.

       <b>Parameters</b>
           <u>e</u> encoder handle

       <b>Returns</b>
           0 on success, -1 if byte is invalid or buffer overflow (speed &gt; 10.0)

   <b>void</b> <b>ltc_encoder_free</b> <b>(LTCEncoder</b> <b>*</b> <b>e)</b>
       Release memory of the encoder.

       <b>Parameters</b>
           <u>e</u> encoder handle

       <b>Examples</b>
           <b>example_encode.c</b>, and <b>ltcencode.c</b>.

   <b>int</b> <b>ltc_encoder_get_buffer</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>ltcsnd_sample_t</b> <b>*</b> <b>buf)</b>
       Copy the accumulated encoded audio to the given sample-buffer and flush the internal buffer.

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>buf</u> place to store the audio-samples, needs to be large  enough  to  hold  <b>ltc_encoder_get_buffersize</b>
           bytes

       <b>Returns</b>
           the number of bytes written to the memory area pointed to by buf.

       <b>Deprecated</b>
           please use <b>ltc_encoder_copy_buffer()</b> instead

   <b>int</b> <b>ltc_encoder_get_bufferptr</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>ltcsnd_sample_t</b> <b>**</b> <b>buf,</b> <b>int</b> <b>flush)</b>
       Retrieve a pointer to the accumulated encoded audio-data.

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>buf</u> if set, the pointer to encoder-buffer
           <u>flush</u> call <b>ltc_encoder_buffer_flush</b> - reset the buffer write-pointer

       <b>Returns</b>
           the number of valid bytes in the buffer

       <b>Examples</b>
           <b>example_encode.c</b>, and <b>ltcencode.c</b>.

   <b>size_t</b> <b>ltc_encoder_get_buffersize</b> <b>(LTCEncoder</b> <b>*</b> <b>e)</b>
       Query  the  length of the internal buffer. It is allocated to hold audio-frames for exactly one LTC frame
       for the given sample-rate and frame-rate. ie. (1 + sample-rate / fps) bytes

       Note  this  returns  the   total   size   of   the   buffer,   not   the   used/free   part.   See   also
       <b>ltc_encoder_get_bufferptr</b>

       <b>Parameters</b>
           <u>e</u> encoder handle

       <b>Returns</b>
           size of the allocated internal buffer.

       <b>Examples</b>
           <b>example_encode.c</b>.

   <b>ltcsnd_sample_t*</b> <b>ltc_encoder_get_bufptr</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>int</b> <b>*</b> <b>size,</b> <b>int</b> <b>flush)</b>
       Retrieve a pointer to the accumulated encoded audio-data.

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>size</u> if set, the number of valid bytes in the buffer is stored there
           <u>flush</u> call <b>ltc_encoder_buffer_flush</b> - reset the buffer write-pointer

       <b>Returns</b>
           pointer to encoder-buffer

       <b>Deprecated</b>
           please use <b>ltc_encoder_get_bufferptr()</b> instead

   <b>double</b> <b>ltc_encoder_get_filter</b> <b>(LTCEncoder</b> <b>*</b> <b>e)</b>
       Get encoder signal rise-time / signal filtering

       <b>Parameters</b>
           <u>e</u> encoder handle

       <b>Returns</b>
           the signal rise-time in us (10^(-6) sec)

   <b>void</b> <b>ltc_encoder_get_frame</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>LTCFrame</b> <b>*</b> <b>f)</b>
       Low-level access to the encoder internal <b>LTCFrame</b> data

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>f</u> return LTC frame data

   <b>void</b> <b>ltc_encoder_get_timecode</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>SMPTETimecode</b> <b>*</b> <b>t)</b>
       Query the current encoder timecode.

       Note:  the  decoder stores its internal state in an LTC-frame, this function converts that LTC-Frame into
       <b>SMPTETimecode</b> on demand. see also <b>ltc_encoder_get_frame</b>.

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>t</u> is set to current timecode

   <b>double</b> <b>ltc_encoder_get_volume</b> <b>(LTCEncoder</b> <b>*</b> <b>e)</b>
       Query the volume of the generated LTC signal

       <b>Parameters</b>
           <u>e</u> encoder handle

       <b>Returns</b>
           the volume in dB full-scale (&lt;= 0.0)

   <b>int</b> <b>ltc_encoder_inc_timecode</b> <b>(LTCEncoder</b> <b>*</b> <b>e)</b>
       Move the encoder to the next timecode frame. uses <b>ltc_frame_increment()</b> internally.

       <b>Examples</b>
           <b>example_encode.c</b>, and <b>ltcencode.c</b>.

   <b>int</b> <b>ltc_encoder_reinit</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>double</b> <b>sample_rate,</b> <b>double</b> <b>fps,</b> <b>enum</b>  <b>LTC_TV_STANDARD</b>  <b>standard,</b>  <b>int</b>
       <b>flags)</b>
       Change  the  encoder  settings without re-allocating any library internal data structure (realtime safe).
       changing the fps and or sample-rate implies a buffer flush, and biphase state reset.

       This  call  will  fail  if  the  internal  buffer  is  too  small  to  hold  one  full  LTC  frame.   Use
       <b>ltc_encoder_set_buffersize</b> to prepare an internal buffer large enough to accommodate all sample_rate, fps
       combinations that you would like to re-init to.

       The  LTC  frame  payload  data  is not modified by this call, however, the flag-bits of the LTC-Frame are
       updated: If fps equals to 29.97 or 30000.0/1001.0, the <b>LTCFrame</b>'s 'dfbit' bit is set  to  1  to  indicate
       drop-frame timecode.

       Unless the LTC_BGF_DONT_TOUCH flag is set the BGF1 is set or cleared depending on LTC_TC_CLOCK and BGF0,2
       according  to LTC_USE_DATE and the given standard. col_frame is cleared and the parity recomputed (unless
       LTC_NO_PARITY is given).

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>sample_rate</u> audio sample rate (eg. 48000)
           <u>fps</u> video-frames per second (e.g. 25.0)
           <u>standard</u> the TV standard to use for Binary Group Flag bit position
           <u>flags</u> binary combination of <b>LTC_BG_FLAGS</b>

       <b>Examples</b>
           <b>ltcencode.c</b>.

   <b>void</b> <b>ltc_encoder_reset</b> <b>(LTCEncoder</b> <b>*</b> <b>e)</b>
       reset ecoder state. flushes buffer, reset biphase state

       <b>Parameters</b>
           <u>e</u> encoder handle

   <b>int</b> <b>ltc_encoder_set_buffersize</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>double</b> <b>sample_rate,</b> <b>double</b> <b>fps)</b>
       Configure a custom size for the internal buffer.

       This is needed if you are planning to call <b>ltc_encoder_reinit()</b> or if you want to keep more than one  LTC
       frame's worth of data in the library's internal buffer.

       The  buffer-size  is  (1 + sample_rate / fps) bytes. resizing the internal buffer will flush all existing
       data in it - alike <b>ltc_encoder_buffer_flush</b>.

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>sample_rate</u> audio sample rate (eg. 48000)
           <u>fps</u> video-frames per second (e.g. 25.0)

       <b>Returns</b>
           0 on success, -1 if allocation fails (which makes the  encoder  unusable,  call  <b>ltc_encoder_free</b>  or
           realloc the buffer)

       <b>Examples</b>
           <b>ltcencode.c</b>.

   <b>int</b> <b>ltc_encoder_set_bufsize</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>double</b> <b>sample_rate,</b> <b>double</b> <b>fps)</b>
       Configure a custom size for the internal buffer.

       This  is needed if you are planning to call <b>ltc_encoder_reinit()</b> or if you want to keep more than one LTC
       frame's worth of data in the library's internal buffer.

       The buffer-size is (1 + sample_rate / fps) bytes. resizing the internal buffer will  flush  all  existing
       data in it - alike <b>ltc_encoder_buffer_flush</b>.

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>sample_rate</u> audio sample rate (eg. 48000)
           <u>fps</u> video-frames per second (e.g. 25.0)

       <b>Returns</b>
           0  on  success,  -1  if  allocation fails (which makes the encoder unusable, call <b>ltc_encoder_free</b> or
           realloc the buffer)

       <b>Deprecated</b>
           please use <b>ltc_encoder_set_buffersize()</b> instead

   <b>void</b> <b>ltc_encoder_set_filter</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>double</b> <b>rise_time)</b>
       Set encoder signal rise-time / signal filtering

       LTC signal should have a rise time of 40us +/- 10 us. by default the encoder  honors  this  and  low-pass
       filters the output depending on the sample-rate.

       If you want a perfect square wave, set 'rise_time' to 0.

       Note  <b>ltc_encoder_reinit</b>  resets  the  filter-time-constant to use the default 40us for the given sample-
       rate, overriding any value previously set with <b>ltc_encoder_set_filter</b>

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>rise_time</u> the signal rise-time in us (10^(-6) sec), set to 0 for perfect square wave, default 40.0

       <b>Examples</b>
           <b>ltcencode.c</b>.

   <b>void</b> <b>ltc_encoder_set_frame</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>LTCFrame</b> <b>*</b> <b>f)</b>
       Low-level access to the internal <b>LTCFrame</b> data.

       Note: be careful to about f-&gt;dfbit, the encoder sets this [only] upon initialization.

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>f</u> LTC frame data to use

   <b>void</b> <b>ltc_encoder_set_timecode</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>SMPTETimecode</b> <b>*</b> <b>t)</b>
       Set the encoder LTC-frame to the  given  <b>SMPTETimecode</b>.  The  next  call  to  <b>ltc_encoder_encode_byte</b>  or
       <b>ltc_encoder_encode_frame</b> will encode this time to LTC audio-samples.

       Internally  this  call  uses <b>ltc_time_to_frame</b> because the LTCEncoder operates on LTCframes only. see als
       <b>ltc_encoder_set_frame</b>

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>t</u> timecode to set.

       <b>Examples</b>
           <b>example_encode.c</b>, and <b>ltcencode.c</b>.

   <b>void</b> <b>ltc_encoder_set_user_bits</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>unsigned</b> <b>long</b> <b>data)</b>
       Set the user-bits of the frame to the given data.

       The data should be a 32-bits unsigned integer. It is written LSB first continiously int  the  eight  user
       fields.

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>data</u> the data to write

   <b>int</b> <b>ltc_encoder_set_volume</b> <b>(LTCEncoder</b> <b>*</b> <b>e,</b> <b>double</b> <b>dBFS)</b>
       Set the volume of the generated LTC signal

       typically  LTC  is  sent  at  0dBu ; in EBU callibrated systems that corresponds to -18dBFS. - by default
       libltc creates -3dBFS

       since libltc generated 8bit audio-data, the minimum dBFS is about -42dB which corresponds to 1 bit.

       0dB corresponds to a signal range of 127 1..255 with 128 at the center.

       <b>Parameters</b>
           <u>e</u> encoder handle
           <u>dBFS</u> the volume in dB full-scale (&lt;= 0.0)

       <b>Returns</b>
           0 on success, -1 if the value was out of range

       <b>Examples</b>
           <b>ltcencode.c</b>.

   <b>ltc_off_t</b> <b>ltc_frame_alignment</b> <b>(double</b> <b>samples_per_frame,</b> <b>enum</b> <b>LTC_TV_STANDARD</b> <b>standard)</b>
       <b>LTCFrame</b> sample alignment offset.

       There is a relative offset of the LTC-Frame start and  the  TV-frame.  The  first  bit  of  a  LTC  frame
       corresponds  to  a  specific  line  in  the  actual  video  frame.  When decoding this offset needs to be
       subtracted from the LTC-frame's audio-sample-time to match the TV-frame's start position.

       For film frames or HDV the offset is zero.

       <b>Parameters</b>
           <u>samples_per_frame</u> audio-samples per timecode-frame (eg. 1920 = 48000/25)
           <u>standard</u> the TV standard

       <b>Returns</b>
           offset in samples

   <b>int</b> <b>ltc_frame_decrement</b> <b>(LTCFrame</b> <b>*</b> <b>frame,</b> <b>int</b> <b>fps,</b> <b>enum</b> <b>LTC_TV_STANDARD</b> <b>standard,</b> <b>int</b> <b>flags)</b>
       Decrement the timecode by one Frame (1/framerate seconds) and set the Frame's parity bit accordingly (see
       <b>ltc_frame_set_parity</b>)

       <b>Parameters</b>
           <u>frame</u> the LTC-timecode to decrement
           <u>fps</u> integer framerate (for drop-frame-timecode set frame-&gt;dfbit and round-up the fps).
           <u>standard</u> the TV standard to use for parity bit assignment if set to 1 the 25fps standard  is  enabled
           and  LTC  Frame  bit  59 instead of 27 is used for the parity. It only has only has effect flag bit 4
           (LTC_NO_PARITY) is cleared.
           <u>flags</u> binary combination of <b>LTC_BG_FLAGS</b> - here only LTC_USE_DATE and LTC_NO_PARITY are relevant.  if
           the  bit 0 is set (1) interpret user-data as date and decrement date if timecode wraps at 24h. (Note:
           leap-years are taken into account, but since the year is two-digit  only,  the  100,400yr  rules  are
           ignored.  '00' is assumed to be year 2000 which was a leap year.) bit 3 (8) indicates that the parity
           bit should not be touched

       <b>Returns</b>
           1 if timecode was wrapped around at 23:59:59:ff, 0 otherwise

   <b>unsigned</b> <b>long</b> <b>ltc_frame_get_user_bits</b> <b>(LTCFrame</b> <b>*</b> <b>f)</b>
       Get the 32-bits unsigned integer from the user-data bits. The data should be written  LSB  first  in  the
       frame

       <b>Parameters</b>
           <u>f</u> LTC frame data to parse

   <b>int</b> <b>ltc_frame_increment</b> <b>(LTCFrame</b> <b>*</b> <b>frame,</b> <b>int</b> <b>fps,</b> <b>enum</b> <b>LTC_TV_STANDARD</b> <b>standard,</b> <b>int</b> <b>flags)</b>
       Increment the timecode by one Frame (1/framerate seconds) and set the Frame's parity bit accordingly (see
       <b>ltc_frame_set_parity</b>)

       <b>Parameters</b>
           <u>frame</u> the LTC-timecode to increment
           <u>fps</u> integer framerate (for drop-frame-timecode set frame-&gt;dfbit and round-up the fps).
           <u>standard</u>  the  TV standard to use for parity bit assignment if set to 1 the 25fps standard is enabled
           and LTC Frame bit 59 instead of 27 is used for the parity. It only has only has  effect  flag  bit  4
           (LTC_NO_PARITY) is cleared.
           <u>flags</u>  binary combination of <b>LTC_BG_FLAGS</b> - here only LTC_USE_DATE and LTC_NO_PARITY are relevant. If
           the bit 0 (1) is set (1) interpret user-data as date and increment date if timecode wraps after  24h.
           (Note:  leap-years  are taken into account, but since the year is two-digit only, the 100,400yr rules
           are ignored. '00' is assumed to be year 2000 which was a leap year.)

       <b>Returns</b>
           1 if timecode was wrapped around after 23:59:59:ff, 0 otherwise

   <b>int</b> <b>ltc_frame_parse_bcg_flags</b> <b>(LTCFrame</b> <b>*</b> <b>frame,</b> <b>enum</b> <b>LTC_TV_STANDARD</b> <b>standard)</b>
       Parse Binary Coded Group Flags into standard independent format: bit 0 (1) - BGF 0, bit 1 (2)  -  BGF  1,
       bit 2 (4) - BGF 2

       <b>Parameters</b>
           <u>frame</u> LTC frame data analyze
           <u>standard</u> the TV standard to use -- see <b>LTCFrame</b> for BGF assignment

       <b>Returns</b>
           LTC Binary Group Flags

   <b>void</b> <b>ltc_frame_reset</b> <b>(LTCFrame</b> <b>*</b> <b>frame)</b>
       Reset  all  values of a LTC FRAME to zero, except for the sync-word (0x3FFD) at the end. The sync word is
       set according to architecture (big/little endian). Also set  the  Frame's  parity  bit  accordingly  (see
       <b>ltc_frame_set_parity</b>)

       <b>Parameters</b>
           <u>frame</u> the <b>LTCFrame</b> to reset

   <b>void</b> <b>ltc_frame_set_parity</b> <b>(LTCFrame</b> <b>*</b> <b>frame,</b> <b>enum</b> <b>LTC_TV_STANDARD</b> <b>standard)</b>
       Set the parity of the LTC frame.

       Bi-Phase  Mark Phase Correction bit (bit 27 - or 59) may be set or cleared so that that every 80-bit word
       contains an even number of zeroes. This means that the phase in every Sync Word will be the same.

       This is merely cosmetic; the motivation to keep the polarity of the waveform constant is to make  finding
       the Sync Word visibly (on a scope) easier.

       There is usually no need to call this function directly. The encoder utility functions <b>ltc_time_to_frame</b>,
       <b>ltc_frame_increment</b> and <b>ltc_frame_decrement</b> include a call to it.

       <b>Parameters</b>
           <u>frame</u> the LTC to analyze and set or clear the biphase_mark_phase_correction bit.
           <u>standard</u>  If  1  (aka  LTC_TV_625_50) , the 25fps mode (bit 59 - aka binary_group_flag_bit2) is used,
           otherwise the 30fps, 24fps mode (bit 27 -- biphase_mark_phase_correction) is set or cleared.

   <b>void</b> <b>ltc_frame_to_time</b> <b>(SMPTETimecode</b> <b>*</b> <b>stime,</b> <b>LTCFrame</b> <b>*</b> <b>frame,</b> <b>int</b> <b>flags)</b>
       Convert binary <b>LTCFrame</b> into <b>SMPTETimecode</b> struct

       <b>Parameters</b>
           <u>stime</u> output
           <u>frame</u> input
           <u>flags</u> binary combination of <b>LTC_BG_FLAGS</b> - here only LTC_USE_DATE is  relevant.  if  LTC_USE_DATE  is
           set,  the  user-fields  in <b>LTCFrame</b> will be parsed into the date variable of <b>SMPTETimecode</b>. otherwise
           the date information in the <b>SMPTETimecode</b> is set to zero.

       <b>Examples</b>
           <b>ltcdecode.c</b>.

   <b>void</b> <b>ltc_time_to_frame</b> <b>(LTCFrame</b> <b>*</b> <b>frame,</b> <b>SMPTETimecode</b> <b>*</b> <b>stime,</b> <b>enum</b> <b>LTC_TV_STANDARD</b> <b>standard,</b> <b>int</b> <b>flags)</b>
       Translate <b>SMPTETimecode</b> struct into its binary LTC representation and set  the  LTC  frame's  parity  bit
       accordingly (see <b>ltc_frame_set_parity</b>)

       <b>Parameters</b>
           <u>frame</u> output - the frame to be set
           <u>stime</u> input - timecode input
           <u>standard</u> the TV standard to use for parity bit assignment
           <u>flags</u>  binary combination of <b>LTC_BG_FLAGS</b> - here only LTC_USE_DATE and LTC_NO_PARITY are relevant. if
           LTC_USE_DATE is given, user-fields in <b>LTCFrame</b> will be set from the date in <b>SMPTETimecode</b>,  otherwise
           the  user-bits are not modified. All non-timecode fields remain untouched - except for the parity bit
           unless LTC_NO_PARITY is given.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libltc from the source code.

Version 1.3.2                                    Sun Sep 4 2022                                         <u><a href="../man3/ltc.h.3.html">ltc.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>