<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Dumper::Compact - Vertically compact width-limited data formatter</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-dumper-compact-perl">libdata-dumper-compact-perl_0.006000-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Dumper::Compact - Vertically compact width-limited data formatter

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Basic usage as a function:

         use Data::Dumper::Compact 'ddc';

         warn ddc($some_data_structure);

         warn ddc($some_data_structure, \%options);

       Slightly more clever usage as a function:

         use Data::Dumper::Compact ddc =&gt; \%default_options;

         warn ddc($some_data_structure);

         warn ddc($some_data_structure, \%extra_options);

       OO usage:

         use Data::Dumper::Compact;

         warn Data::Dumper::Compact-&gt;dump($data, \%options);

         my $ddc = Data::Dumper::Compact-&gt;new(\%options);

         warn $ddc-&gt;dump($data);

         warn $ddc-&gt;dump($data, \%extra_options);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Data::Dumper::Compact, henceforth referred to as DDC, was born because I was annoyed at valuable wasted
       whitespace paging through both Data::Dumper and Data::Dump based logs - Data::Dump attempts to format
       horizontally first, but then if it fails, immediately switches to formatting fully vertically, rather
       than trying to e.g. format a six element arrayref three per line.

       So here's a few of the specifics (noting that all examples unless otherwise specified are dumped with
       default options):

   <b>Arrays</b> <b>and</b> <b>Strings</b>
       Given arrays consisting of reasonably long strings, DDC does its best to produce a sane representation
       within its "max_width":

         [
           1, 2, [
             'longstringislonglongstringislonglongstringislong',
             'longstringislonglongstringislong', 'longstringislong',
             'longstringislonglongstringislonglongstringislong', 'longstringislong',
             'longstringislonglongstringislong', 'longstringislong',
             'longstringislonglongstringislong',
             'longstringislonglongstringislonglongstringislong',
             'longstringislonglongstringislong', 'longstringislonglongstringislong',
             'longstringislonglongstringislonglongstringislong', 'longstringislong',
             'longstringislong', 'longstringislonglongstringislonglongstringislong',
             'longstringislong', 'longstringislong', 'longstringislong',
             'longstringislonglongstringislong',
             'longstringislonglongstringislonglongstringislong', 'a', 'b', 'c',
             'longstringislonglongstringislonglongstringislonglongstringislong',
             'longstringislonglongstringislonglongstringislonglongstringislong',
             'longstringislonglongstringislonglongstringislonglongstringislong',
           ], 3,
         ]

   <b>Keys</b> <b>and</b> <b>Hashrefs</b>
       When faced with a "-foo" style value, it gets a "=&gt;" even in an array, and hash values that we can are
       single-line formatted:

         [
           'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', [
             'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',
             'cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc',
           ],
           -blah =&gt; { baz =&gt; 'quux', foo =&gt; 'bar' },
         ]

   <b>The</b> <b>String</b> <b>Thing</b>
       Strings are single quoted when DDC is absolutely sure that's safe, and double quoted otherwise:

         [ { -foo =&gt; {
               bar =&gt;
                 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
               baz =&gt; "bbbbbbbbbbbbbbbbbbbb\nbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
         } } ]

   <b>Lonely</b> <b>hash</b> <b>key</b>
       When a single hash key can't be formatted in a oneline form within the length, DDC will try spilling it
       to its own line:

         {
           -xxxxxxxxxxxxx =&gt; 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
         }

       If even that isn't enough, it formats it below and indented:

         { -xxxxxxxxxxxxx =&gt;
             'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
         }

   <b>Strings</b> <b>and</b> <b>the</b> <b>dot</b> <b>operator</b>
       If a string simply won't fit, DDC splits it and indents it using ".":

         [ 'xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyx'
           .'yxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxy'
           .'xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyx'
           .'yxyxyxyxyxyxyxyxyxyxyxyxyxyxyxy'
         ]

   <b>Unknown</b> <b>unknowns</b>
       Anything DDC doesn't understand is passed through its "dumper" option, though since Data::Dumper (at the
       time of writing) forgets to pass through its indentation level to B::Concise, we slightly tweak that
       behaviour on the way in for the default "dumper". But the end result looks like:

         { foo =&gt; { bar =&gt; sub {
               use warnings;
               use strict 'refs';
               my($x, $y) = @_;
               return $x * $y;
         } } }

   <b>Bless</b> <b>you</b>
       When encountering an object, if it's a blessed array or hashref, DDC will attempt to format that too:

         [ bless( {
             x =&gt; 3,
             y =&gt; [ 'foo', 'bar', 'baz', 'quux', 'fleem', 'blather', 'obrien' ],
             z =&gt; 'lololololololololololololololol',
         }, "OhGods::Lol" ) ]

   <b>All</b> <b>together</b> <b>now</b>
       The full set of behaviours allows compact (and, we hope, readable) versions of complex data structures.
       To provide one of the examples that expired this module - here is the formatting under standard options
       for a moderately complex SQL::Abstract update statement:

         {
           _ =&gt; [
             'tree_table', -join =&gt; {
               as =&gt; 'tree',
               on =&gt; { 'tree.id' =&gt; 'tree_with_path.id' },
               to =&gt; { -select =&gt; {
                   from =&gt; 'tree_with_path',
                   select =&gt; '*',
                   with_recursive =&gt; [
                     [ 'tree_with_path', 'id', 'parent_id', 'path' ], { -select =&gt; {
                         _ =&gt; [
                           'id', 'parent_id', { -as =&gt;
                               [
                                 { -cast =&gt; { -as =&gt; [ 'id', 'char', 255 ] } },
                                 'path',
                               ]
                           },
                         ],
                         from =&gt; 'tree_table',
                         union_all =&gt; { -select =&gt; {
                             _ =&gt; [
                               't.id', 't.parent_id', { -as =&gt; [
                                   { -concat =&gt; [ 'r.path', \"'/'", 't.id' ] },
                                   'path',
                               ] },
                             ],
                             from =&gt; [
                               'tree_table', -as =&gt; 't', -join =&gt; {
                                 as =&gt; 'r',
                                 on =&gt; { 't.parent_id' =&gt; 'r.id' },
                                 to =&gt; 'tree_with_path',
                               },
                             ],
                         } },
                         where =&gt; { parent_id =&gt; undef },
                     } },
                   ],
               } },
             },
           ],
           set =&gt; { path =&gt; { -ident =&gt; [ 'tree', 'path' ] } },
         }

       And the version (generated by setting "max_width" to 40) that runs out of space and thereby forces the
       "spill vertically" logic to kick in while still attemping to be at least somewhat compact:

         {
           _ =&gt; [
             'tree_table',
             '-join',
             {
               as =&gt; 'tree',
               on =&gt; {
                 'tree.id' =&gt; 'tree_with_path.id',
               },
               to =&gt; {
                 -select =&gt; {
                   from =&gt; 'tree_with_path',
                   select =&gt; '*',
                   with_recursive =&gt; [
                     [
                       'tree_with_path',
                       'id',
                       'parent_id',
                       'path',
                     ],
                     {
                       -select =&gt; {
                         _ =&gt; [
                           'id',
                           'parent_id',
                           {
                             -as =&gt; [
                               {
                                 -cast =&gt; {
                                   -as =&gt; [
                                     'id',
                                     'char',
                                     255,
                                   ],
                                 },
                               },
                               'path',
                             ],
                           },
                         ],
                         from =&gt; 'tree_table',
                         union_all =&gt; {
                           -select =&gt; {
                             _ =&gt; [
                               't.id',
                               't.parent_id',
                               {
                                 -as =&gt; [
                                   {
                                     -concat =&gt; [
                                       'r.path',
                                       \"'/'",
                                       't.id',
                                     ],
                                   },
                                   'path',
                                 ],
                               },
                             ],
                             from =&gt; [
                               'tree_table',
                               '-as',
                               't',
                               '-join',
                               {
                                 as =&gt; 'r',
                                 on =&gt; {
                                   't.parent_id' =&gt; 'r.id',
                                 },
                                 to =&gt; 'tree_with_path',
                               },
                             ],
                           },
                         },
                         where =&gt; {
                           parent_id =&gt; undef,
                         },
                       },
                     },
                   ],
                 },
               },
             },
           ],
           set =&gt; {
             path =&gt; {
               -ident =&gt; [
                 'tree',
                 'path',
               ],
             },
           },
         }

   <b>Summary</b>
       Hopefully it's clear what the goal is, and what we've done to achieve it.

       While the system is already somewhat configurable, further options are almost certainly implementable,
       although if you really want such an option then we expect you to turn up with documentation and test
       cases for it so we just have to write the code.

</pre><h4><b>OPTIONS</b></h4><pre>
   <b>max_width</b>
       Represents the width that DDC will attempt to keep as the maximum (if something overflows it in spite of
       our best efforts, DDC will fall back to a more vertically sprawling format to at least overflow as little
       as feasible).

       Default: 78

   <b>indent_by</b>
       The string to indent by. To set e.g. 4 space indent, pass "' 'x4".

       Default: '  ' (two spaces).

   <b>indent_width</b>
       How many characters one indent should be considered to be. Generally you only need to manually set this
       if your "indent_by" is "\t".

       Default: "length($self-&gt;indent_by)"

   <b>transforms</b>
       Set of transforms to apply on every "dump" operation. See "transform" for more information.

       Default: "[]"

   <b>dumper</b>
       The dumper function to be used for dumping things DDC doesn't understand, such as coderefs, regexprefs,
       etc.

       Defaults to the same options as Data::Dumper::Concise (which is, itself, only a Data::Dumper
       configuration albeit it comes with Devel::Dwarn which is rather more interesting) - although on top of
       that we add a little bit of extra cleverness to make B::Deparse use the correct indentation, since for
       some reason Data::Dumper doesn't (at the time of writing) do that.

       If you supply it yourself, it needs to be a single argument coderef - you could for example use
       "\&amp;Data::Dumper::Dumper" though that would almost certainly be pointless.

</pre><h4><b>EXPORTS</b></h4><pre>
   <b>ddc</b>
         use Data::Dumper::Compact 'ddc';
         use Data::Dumper::Compact 'ddc' =&gt; \%options;

       If the first argument to "use"/"import()" is 'ddc', a subroutine "ddc()" is installed in the calling
       package which behaves like calling "dump".

       If the second argument is a hashref, it becomes the options passed to "new".

       This feature is effectively sugar over "dump_cb", in that:

         Data::Dumper::Compact-&gt;import(ddc =&gt; \%options)

       is equivalent to:

         *ddc = Data::Dumper::Compact-&gt;new(\%options)-&gt;dump_cb;

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
         my $ddc = Data::Dumper::Compact-&gt;new;
         my $ddc = Data::Dumper::Compact-&gt;new(%options);
         my $ddc = Data::Dumper::Compact-&gt;new(\%options);

       Constructor. Takes a hash or hashref of "OPTIONS"

   <b>dump</b>
         my $formatted = Data::Dumper::Compact-&gt;dump($data, \%options?);

         my $formatted = $ddc-&gt;dump($data, \%merge_options?);

       This is the method you're going to want to call most of the time, and ties together the rest of the
       functionality into a single data-structure-to-string bundle. With just a data argument, it's equivalent
       to:

         $ddc-&gt;format( $ddc-&gt;transform( $ddc-&gt;transforms, $ddc-&gt;expand($data) );

       In class method form, options provided are passed to "new"; in instance method form, options if provided
       are merged into $ddc just for this invocation.

   <b>dump_cb</b>
         my $cb = $ddc-&gt;dump_cb;

       Returns a subroutine reference that's a curried call to "dump":

         $cb-&gt;($data, \%extra_options); # equivalent to $ddc-&gt;dump(...)

       Mostly useful for if you want to create a custom "ddc()" like thing:

         use Data::Dumper::Compact;
         BEGIN { *Dumper = Data::Dumper::Compact-&gt;new-&gt;dump_cb }

   <b>expand</b>
         my $exp = $ddc-&gt;expand($data);

       Expands a data structure to DDC tagged data. The result is, recursively,

         [ $type, $payload ]

       where if $type is one of "string", "key", or "thing", the payload is a simple string ("thing" meaning
       something unknown and therefore delegated to "dumper"). If the type is an array:

         [ array =&gt; \@values ]

       and if the type is a hash:

         [ hash =&gt; [ \@keys, \%value_map ] ]

       where the keys provide an order for formatting, and the value map is a hashref of keys to expanded
       values.

       A plain string becomes a "string", unless it fits the "-foo" style pattern that autoquotes, in which case
       it becomes a "key".

   <b>add_transform</b>
         $ddc-&gt;add_transform(sub { ... });
         $ddc-&gt;add_transform({ hash =&gt; sub { ... }, _ =&gt; sub { ... });

       Appends a transform to "$ddc-&gt;transforms", see "transform" for behaviour.

       Returns $ddc to enable chaining.

   <b>transform</b>
         my $tf_exp = $ddc-&gt;transform($tfspec, $exp);

       Takes a transform specification and expanded tagged data and returns the transformed expanded expression.
       A transform spec is an arrayref containing transforms, where each transform is applied in order, so the
       last transform added via "add_transform" will be the last one to transform the data (each transform will
       consist of a datastructure representing which parts of the $exp tree it should be called for, plus
       subroutines representing the relevant transforms).

       Transform subroutines are called as a method on the $ddc with the arguments of "$type, $payload, $path"
       where $path is an arrayref of the keys/values of the containing hashes and arrays, aggregated as DDC
       descends through the $exp tree.

       Each transform is expected to return either nothing, to indicate it doesn't wish to modify the result, or
       a replacement expanded data structure. The simplest form of transform is a subref, which gets called for
       everything.

       So, to add ' IN MICE' to every string that's part of an array under a hash key called study_results,
       i.e.:

         my $data = { study_results =&gt; [
             'Sense Of Touch Is Formed In the Brain Before Birth'.
             "We can't currently cure MS but a single cell could change that",
         ] };

         my $tf_exp = $ddc-&gt;transform([ sub {
           my ($self, $type, $payload, $path) = @_;
           return unless $type eq 'string' and ($path-&gt;[-2]||'') eq 'study_results';
           return [ $type, $payload.' IN MICE' ];
         } ], $ddc-&gt;expand($data));

       will return:

         [ hash =&gt; [
           [ 'study_results' ],
           { study_results =&gt; [ array =&gt; [
             [ string =&gt; 'Sense Of Touch Is Formed In the Brain Before Birth IN MICE' ],
             [ string =&gt; "We can't currently cure MS but a single cell could change that IN MICE", ],
           ] ] }
         ] ]

       If a hashref is found, then the values are expected to be transforms, and DDC will use
       "$hashref-&gt;{$type}||$hashref-&gt;{_}" as the transform, or skip if neither is present. So the previous
       example could be written as:

         $ddc-&gt;transform([ { string =&gt; sub {
           my ($self, $type, $payload, $path) = @_;
           return unless ($path-&gt;[-2]||'') eq 'study_results';
           return [ $type, $payload.' IN MICE' ];
         } } ], $ddc-&gt;expand($data));

       If the value of the spec entry itself <u>or</u> the relevant hash value is an arrayref, it is assumed to contain
       a spec for trailing path entries, with the last element being the transform subroutine. A path entry
       match can be an exact scalar (tested via "eq" since it works fine for both strings and integer array
       indices), regexp, "undef" to indicate "any value is fine here", or a subroutine which will be called with
       the path entry as both $_[0] and $_. So the example we've been using could <b>also</b> be written as:

         $ddc-&gt;transform([ { string =&gt; [
           'study_results', undef,
           sub { [ string =&gt; $_[2].' IN MICE' ] }
         ] } ], $ddc-&gt;expand($data));

       or

         $ddc-&gt;transform([ { string =&gt; [
           qr/^study_results$/, sub { 1 },
           sub { [ string =&gt; $_[2].' IN MICE' ] }
         ] } ], $ddc-&gt;expand($data));

       Note that while the $tfspec is not passed to transform subroutines, for the duration of the "transform"
       call the "transforms" option is localised to the provided routine, so

         sub {
           my ($self, $type, $payload, $path) = @_;
           my $tfspec = $self-&gt;transforms;
           ...
         }

       will return the top level $tfspec passed to the transform call.

       Thanks to &lt;<a href="http://twitter.com/justsaysinmice">http://twitter.com/justsaysinmice</a>&gt; for the inspiration.

   <b>format</b>
         my $formatted = $ddc-&gt;format($exp);

       Takes expanded tagged data and renders it to a formatted string, suitable for printing or warning or etc.

       Accepts the following type tags: "array", "list",  "hash", "key", "string", "thing". Arrays and hashes
       are formatted as compactly as possible within the constraint of "max_width", but if overflow occurs then
       DDC falls back to spilling everything vertically, so newlines are used for most spacing and therefore it
       doesn't exceed the max width any more than strictly necessary.

       Strings are formatted as single quote if obvious, and double quote if not.

       Keys are treated as strings when present as hash values, but when an element of array values, are
       formatted ask "the_key =&gt;" where possible.

       Lists are formatted as single line "qw()" expressions if possible, or "( ... )" if not.

       Arrays and hashes are formatted in the manner to which one would hope readers are accustomed, except more
       compact.

</pre><h4><b>ALGORITHM</b></h4><pre>
       The following is a description of the current algorithm of DDC. We reserve the right to change it for the
       better.

       If you didn't already read the overview examples in "WHY" do that first.

       Vertical mode means DDC has given up on fitting within the desired width and is now just trying to not
       use <u>too</u> much vertical space.

       Oneline mode is DDC testing to see if a single line rendering of something will fit within the available
       space. Things will often be rendered more than once since DDC is optimising for compact readable output
       rather than raw straight line performance.

   <b>Top</b> <b>level</b> <b>formatting</b>
       If something is formatted and the remaining width is zero or negative, DDC accepts default on "max_width"
       and bails out to a fully vertical approach so it overflows the desired width no more than necessary.

   <b>Array</b> <b>formatting</b>
       If already in vertical mode, formats one array element per line, appended with ",":

         [
           1,
           2,
           3
         ]

       If in possible oneline mode, formats all but the last element according to the "Array element" rules, the
       last element according to normal formatting, and joins them with ' ' in the hopes this is narrow enough.
       Return this if oneline is forced or it fits:

         [ 1, 2, 3 ]

       If there's only a single internal member, tries to use the "Single entry formatting" strategy to cuddle
       it.

         [ [
           &lt;something inside&gt;
         ] ]

       Otherwise, attempts to bundle things as best possible: Each element is formatted according to the "Array
       element" rules, and multiple results are concatenated together onto a single line where that still
       remains within the available width.

         [
           'foo', 'bar', 'baz',
           'red', 'white', 'blue',
         ]

   <b>Array</b> <b>element</b>
       Elements are normally formatted as "$formatted.','" except if an element is of type "key" in which cases
       it becomes "$key =&gt;".

         "whatever the smeg",
         smeg_off =&gt;

   <b>List</b> <b>formatting</b>
       The type "list" is synthetic and only introduced by transforms.

       It is formatted identically to an arrayref except with "( )" instead of "[ ]", with the exception that if
       it consists of only plain strings and will fit onto a single line, it formats as a "qw(x y x)" style
       list.

         qw(foo bar baz)
         (
           'foo',
           'bar',
           'baz',
         )

   <b>Single</b> <b>entry</b> <b>formatting</b>
       Where possible, a single entry will be cuddled such that the opening delimiters are both on the first
       line, and the closing delimiters both on the final line, to reduce the vertical space consumption of
       nested single entry array and/or hashrefs.

         to =&gt; { -select =&gt; {
             ...
         } }

         [ 'SRV:8FB66F32' ], [ [
             '/opt/voice-srvc-native/bin/async-srvc-att-gateway-poller', 33,
             'NERV::Voice::SRV::Native::AsyncSRVATTGatewayPoller::main',
         ] ],

   <b>Hash</b> <b>formatting</b>
       If already in vertical mode, key/value pairs are formatted separated by newlines, with no attention paid
       to key length.

         {
           foo =&gt; ...,
           bar =&gt; ...,
         }

       If potentially in oneline mode, key/value pairs are formatted separated by ', ' and the value is returned
       if forced or if remaining width allows the oneline rendering.

         { foo =&gt; ..., bar =&gt; ... }

       Otherwise, all key/value pairs are formatted as "key =&gt; value" where possible, but if the first line of
       the value is too long, the value is moved to the next line and indented.

         key =&gt; 'shortvalue'
         key =&gt;
           'overlylongvalue'

       If there's only a single such key/value pair, tries to use the "Single entry formatting" strategy to
       cuddle it.

         { zathrus =&gt; {
             listened_to =&gt; 0,
         } }

       Otherwise returns key/value pairs indented and separated by newlines

         {
           foo =&gt; ...,
           bar =&gt; ...,
         }

   <b>String</b> <b>formatting</b>
       Uses single quotes if sure that's safe, double quotes otherwise.

         'foo bar baz quux'
         "could have been '' but nicer to not screw up\n the indents with a newline"

       Attempts to format a string within the available width, using multiple lines and the "." concatenation
       operator if necessary,.

         'this would be an'
         .'annoyingly long'
         .'string'

       The target width is set to 20 in vertical mode to try and not be too ugly.

   <b>Object</b> <b>formatting</b>
       Objects are tested to see if their underlying reference is an array or hash.  If so, it's formatted with
       'bless( ' prepended and ', $class)' appended. This so far appears to interact nicely with everything
       else.

</pre><h4><b>AUTHOR</b></h4><pre>
       mst - Matt S Trout (cpan:MSTROUT) &lt;<a href="mailto:mst@shadowcat.co.uk">mst@shadowcat.co.uk</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       None so far.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2019 the Data::Dumper::Compact "AUTHOR" and "CONTRIBUTORS" as listed above.

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software and may be distributed under the same terms as perl itself. See
       &lt;https://dev.perl.org/licenses/&gt;.

perl v5.36.0                                       2022-10-04                         <u>Data::Dumper::<a href="../man3pm/Compact.3pm.html">Compact</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>