<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ck_rwcohort — generalized interface for reader-writer locks using cohort locks</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libck-dev">libck-dev_0.7.2-5ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ck_rwcohort — generalized interface for reader-writer locks using cohort locks

</pre><h4><b>LIBRARY</b></h4><pre>
       Concurrency Kit (libck, -lck)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;ck_rwcohort.h&gt;</b>
       In  each  of  the  following  macros,  "STRATEGY" should be replaced with either "NEUTRAL", "RP", or "WP"
       depending on which locking strategy the user prefers.  RP and WP represent reader preference  and  writer
       preference, respectively, while NEUTRAL represents a strategy neutral to reads vs. writes.

       <b>CK_RWCOHORT_STRATEGY_PROTOTYPE</b>(<u>COHORT_NAME</u> <u>cohort_name</u>);

       <b>CK_RWCOHORT_STRATEGY_NAME</b>(<u>COHORT_NAME</u> <u>cohort_name</u>);

       <b>CK_RWCOHORT_STRATEGY_INSTANCE</b>(<u>COHORT_NAME</u> <u>cohort_name</u>);

       <b>CK_RWCOHORT_STRATEGY_INIT</b>(<u>COHORT_NAME</u> <u>cohort_name</u>, <u>RWCOHORT</u> <u>lock</u>, <u>unsigned</u> <u>int</u> <u>wait_limit</u>);
       Note: the wait_limit argument should be omitted for locks using the neutral strategy

       <b>CK_RWCOHORT_STRATEGY_READ_LOCK</b>(<u>COHORT_NAME</u>     <u>cohort_name</u>,     <u>RWCOHORT</u>     <u>lock</u>,     <u>COHORT</u>     <u>cohort</u>,
           <u>void</u> <u>*global_context</u>, <u>void</u> <u>*local_context</u>);

       <b>CK_RWCOHORT_STRATEGY_READ_UNLOCK</b>(<u>COHORT_NAME</u>    <u>cohort_name</u>,    <u>RWCOHORT</u>     <u>lock</u>,     <u>COHORT</u>     <u>cohort</u>,
           <u>void</u> <u>*global_context</u>, <u>void</u> <u>*local_context</u>);

       <b>CK_RWCOHORT_STRATEGY_WRITE_LOCK</b>(<u>COHORT_NAME</u>     <u>cohort_name</u>,     <u>RWCOHORT</u>     <u>lock</u>,     <u>COHORT</u>    <u>cohort</u>,
           <u>void</u> <u>*global_context</u>, <u>void</u> <u>*local_context</u>);

       <b>CK_RWCOHORT_STRATEGY_WRITE_UNLOCK</b>(<u>COHORT_NAME</u>    <u>cohort_name</u>,    <u>RWCOHORT</u>    <u>lock</u>,     <u>COHORT</u>     <u>cohort</u>,
           <u>void</u> <u>*global_context</u>, <u>void</u> <u>*local_context</u>);

       Arguments    of    type    RWCOHORT    must    be    pointers    to    structs    defined    using    the
       <u><a href="../man3/CK_RWCOHORT_STRATEGY_PROTOTYPE.3.html">CK_RWCOHORT_STRATEGY_PROTOTYPE</a></u>(3) macro with the same strategy and cohort name as the current call.

       Arguments of type COHORT must be pointers to structs defined using the <u><a href="../man3/CK_COHORT_PROTOTYPE.3.html">CK_COHORT_PROTOTYPE</a></u>(3) macro.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       ck_rwcohort.h provides an interface for defining reader-writer locks that use cohort locks internally  to
       increase performance on NUMA architectures.  See <u><a href="../man3/ck_cohort.3.html">ck_cohort</a></u>(3) for more information about cohort locks.

       Before  using  a  reader-writer  cohort  lock,  the  user  must  define  a  cohort  type using either the
       <u><a href="../man3/CK_COHORT_PROTOTYPE.3.html">CK_COHORT_PROTOTYPE</a></u>(3) or the <u><a href="../man3/CK_COHORT_TRYLOCK_PROTOTYPE.3.html">CK_COHORT_TRYLOCK_PROTOTYPE</a></u>(3) macros, and define a reader-writer lock type
       using the <u><a href="../man3/CK_RWCOHORT_PROTOTYPE.3.html">CK_RWCOHORT_PROTOTYPE</a></u>(3) macro.

</pre><h4><b>EXAMPLE</b></h4><pre>
             #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
             #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;

             #include &lt;ck_pr.h&gt;
             #include &lt;ck_cohort.h&gt;
             #include &lt;ck_rwcohort.h&gt;
             #include &lt;ck_spinlock.h&gt;

             /* Create cohort methods with signatures that match the required signature */

             static void
             ck_spinlock_lock_with_context(ck_spinlock_t *lock, void *context)
             {
                     (void)context;
                     ck_spinlock_lock(lock);
                     return;
             }

             static void
             ck_spinlock_unlock_with_context(ck_spinlock_t *lock, void *context)
             {
                     (void)context;
                     ck_spinlock_unlock(lock);
                     return;
             }

             static bool
             ck_spinlock_locked_with_context(ck_spinlock_t *lock, void *context)
             {
                     (void)context;
                     return ck_spinlock_locked(lock);
             }

             /*
              * define a cohort type named "test_cohort" that will use
              * the above methods for both its global and local locks
              */
             CK_COHORT_PROTOTYPE(test_cohort,
                     ck_spinlock_lock_with_context, ck_spinlock_unlock_with_context, ck_spinlock_locked_with_context,
                     ck_spinlock_lock_with_context, ck_spinlock_unlock_with_context, ck_spinlock_locked_with_context)

             /* define a reader-writer type using the same cohort type */
             CK_RWCOHORT_WP_PROTOTYPE(test_cohort)

             static ck_spinlock_t global_lock = CK_SPINLOCK_INITIALIZER;
             static CK_COHORT_INSTANCE(test_cohort) *cohorts;
             static CK_RWCOHORT_WP_INSTANCE(test_cohort) rw_cohort = CK_RWCOHORT_WP_INITIALIZER;
             static unsigned int ready;

             static void *
             function(void *context)
             {
                     CK_COHORT_INSTANCE(test_cohort) *cohort = context;

                     while (ck_pr_load_uint(&amp;ready) == 0);

                     while (ck_pr_load_uint(&amp;ready) &gt; 0) {
                             /*
                              * acquire the cohort lock before performing critical section.
                              * note that we pass NULL for both the global and local context
                              * arguments because neither the lock nor unlock functions
                              * will use them.
                              */
                             CK_COHORT_LOCK(test_cohort, cohort, NULL, NULL);

                             /* perform critical section */

                             /* relinquish cohort lock */
                             CK_COHORT_UNLOCK(test_cohort, cohort, NULL, NULL);
                     }

                     return NULL;
             }

             int
             main(void)
             {
                     unsigned int nthr = 4;
                     unsigned int n_cohorts = 2;
                     unsigned int i;

                     /* allocate 2 cohorts of the defined type */
                     CK_COHORT_INSTANCE(test_cohort) *cohorts =
                         calloc(n_cohorts, sizeof(CK_COHORT_INSTANCE(test_cohort)));

                     /* create local locks to use with each cohort */
                     ck_spinlock_t *local_locks =
                             calloc(n_cohorts, sizeof(ck_spinlock_t));

                     pthread_t *threads =
                             calloc(nthr, sizeof(pthread_t));

                     /* initialize each of the cohorts before using them */
                     for (i = 0 ; i &lt; n_cohorts ; ++i) {
                             CK_COHORT_INIT(test_cohort, cohorts + i, &amp;global_lock, local_locks + i,
                                     CK_COHORT_DEFAULT_LOCAL_PASS_LIMIT);
                     }

                     /* start each thread and assign cohorts equally */
                     for (i = 0 ; i &lt; nthr ; ++i) {
                             pthread_create(threads + i, NULL, function, cohorts + (i % n_cohorts));
                     }

                     ck_pr_store_uint(&amp;ready, 1);
                     <a href="../man10/sleep.10.html">sleep</a>(10);
                     ck_pr_store_uint(&amp;ready, 0);

                     for (i = 0 ; i &lt; nthr ; ++i) {
                             pthread_join(threads[i], NULL);
                     }

                     return 0;
             }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/CK_COHORT_PROTOTYPE.3.html">CK_COHORT_PROTOTYPE</a></u>(3), <u><a href="../man3/CK_COHORT_TRYLOCK_PROTOTYPE.3.html">CK_COHORT_TRYLOCK_PROTOTYPE</a></u>(3), <u><a href="../man3/CK_COHORT_INSTANCE.3.html">CK_COHORT_INSTANCE</a></u>(3),  <u><a href="../man3/CK_COHORT_INITIALIZER.3.html">CK_COHORT_INITIALIZER</a></u>(3),
       <u><a href="../man3/CK_COHORT_INIT.3.html">CK_COHORT_INIT</a></u>(3), <u><a href="../man3/CK_COHORT_LOCK.3.html">CK_COHORT_LOCK</a></u>(3), <u><a href="../man3/CK_COHORT_UNLOCK.3.html">CK_COHORT_UNLOCK</a></u>(3), <u><a href="../man3/CK_COHORT_LOCKED.3.html">CK_COHORT_LOCKED</a></u>(3), <u><a href="../man3/CK_COHORT_TRYLOCK.3.html">CK_COHORT_TRYLOCK</a></u>(3),

       Additional information available at <a href="http://concurrencykit.org/">http://concurrencykit.org/</a>

                                                 April 23, 2013.                                  <u><a href="../man3/ck_rwcohort.3.html">ck_rwcohort</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>