<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Judy - C library functions for creating and accessing dynamic arrays</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libjudy-dev">libjudy-dev_1.0.5-5.1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Judy - C library functions for creating and accessing dynamic arrays

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>Judy1</b>  - maps an <b>Index</b> (word) to a <b>bit</b>
       <b>JudyL</b>  - maps an <b>Index</b> (word) to a <b>Value</b> (word/pointer)
       <b>JudySL</b> - maps an <b>Index</b> (null terminated string) to a <b>Value</b>
       <b>JudyHS</b> - maps an <b>Index</b> (array-of-bytes) of <b>Length</b> to a <b>Value</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  Judy  family  of  functions  supports fully dynamic arrays.  These arrays may be indexed by a 32- or
       64-bit word (depending on processor word size), a  null  terminated  string  or  an  array-of-bytes  plus
       length.  A dynamic array (sparsely populated) can also be thought of as a <u>mapping</u> <u>function</u> or <u>associative</u>
       <u>memory</u>.

       A  <b>Word_t</b>  is  a  <u>typedef</u> <u>unsigned</u> <u>long</u> <u>int</u>  in <b>Judy.h</b> and must be the same size as <u>sizeof(void</u> <u>*)</u> I.E. a
       pointer.

       <b>Judy1</b> functions: <b>Index</b> is a <b>Word_t</b> and <b>Value</b> is just a <b>bit</b> or simply a flag  that  <b>Index</b>  is  present  or
       missing from the array.  This can be thought of as a huge bitmap.

       <b>JudyL</b>  functions:  <b>Index</b> is a <b>Word_t</b> and <b>Value</b> is a <b>Word_t</b>.  This makes <b>JudyL</b> a pure word-to-word/pointer
       mapper.  <b>JudySL</b> and <b>JudyHL</b> are based on this property of <b>JudyL</b>.

       <b>JudySL</b> functions: <b>Index</b> is a null-terminated string and <b>Value</b> is a <b>Word_t</b>.

       <b>JudyHS</b> functions:  <b>Index</b> is an array-of-bytes of length:  <b>Length</b>.  <b>Value</b> is a <b>Word_t</b>.  This new  addition
       (May  2004) to Judy is a hybird using the best features of hashing and Judy methods.  The author believes
       <b>JudyHS</b> is a good replacement for a hashing method when resizing the hash table is done during  population
       growth.   A  correctly  tuned  hash method with a <b>static</b> hash table size and population is unbeatable for
       speed.  However, <b>JudyHS</b> will perform better than a hashing method with  smaller  and  larger  populations
       than  the optimum hash table size.  <b>JudyHS</b> does not have a degenerate performance case where knowledge of
       the hash algorithm can be exploited.  (I.E.  JudyHS does not use a linked list to handle hash collisions,
       it uses a tree of <b>JudyL</b> arrays and a virtual hash table size of 4 billion).

       Judy arrays are both <b>speed-</b> -efficient<b>,</b> <b>with</b> <b>no</b> <b>tuning</b> <b>or</b> <b>configuration</b> <b>required,</b> <b>across</b> <b>a</b> <b>wide</b> <b>range</b>  <b>of</b>
       <b>index</b>  <b>set</b>  <b>types</b> <b>(sequential,</b> <b>periodic,</b> <b>clustered,</b> <b>random).</b>  <b>Judy's</b> <b>speed</b> <b>and</b> <b>memory</b> <b>usage</b> <b>are</b> <b>typically</b>
       <b>better</b> <b>than</b> <b>other</b> <b>data</b> <b>storage</b> <b>models</b> <b>such</b> <b>as</b> <b>skiplists,</b> <b>linked</b> <b>lists,</b> <b>binary,</b> <b>ternary,</b> <b>b-trees,</b> <b>or</b>  <b>even</b>
       <b>hashing,</b> <b>and</b> <b>improves</b> <b>with</b> <b>very</b> <b>large</b> <b>data</b> <b>sets.</b>

       A  Judy array is created merely by defining a null pointer and then storing (inserting) the first element
       into the array under that pointer.  The memory used by  a  Judy  array  is  nearly  proportional  to  the
       population (number of elements).

       Judy  has two Application Program Interfaces (APIs):  a C macro interface, and a function call interface.
       Because the macro forms are sometimes faster and  have  a  simpler  error  handling  interface  than  the
       equivalent functions, they are the preferred way of using the Judy functions.

       Since  an  initial  (empty)  Judy  array is represented by a null pointer, it is possible to construct an
       array of Judy arrays.  In other words, a Judy array's <b>Values</b> (except Judy1) can be pointers to other Judy
       arrays.  This makes it very simple to construct an array with an arbitrary number of dimensions or  <b>Index</b>
       sizes.  (JudySL and JudyHS are implemented using JudyL this way).

</pre><h4><b>A</b> <b>10</b> <b>MINUTE</b> <b>TECHNICAL</b> <b>DESCRIPTION</b></h4><pre>
       may be found at <u><a href="http://judy.sourceforge.net/downloads/10minutes.htm">http://judy.sourceforge.net/downloads/10minutes.htm</a></u>

</pre><h4><b>A</b> <b>3</b> <b>HOUR</b> <b>TECHNICAL</b> <b>DESCRIPTION</b> <b>(out</b> <b>of</b> <b>date</b> <b>and</b> <b>a</b> <b>bit</b> <b>corny)</b></h4><pre>
       may be found at <u><a href="http://judy.sourceforge.net/application/shop_interm.pdf">http://judy.sourceforge.net/application/shop_interm.pdf</a></u>

</pre><h4><b>DOWNLOADS</b></h4><pre>
       Judy source downloads are available at <u><a href="http://sourceforge.net/projects/judy">http://sourceforge.net/projects/judy</a></u>
       Binarys may be built and installed in a minute or two after downloading

       For versions including more platforms and/or new features see: <u><a href="http://judy.sourceforge.net/downloads/">http://judy.sourceforge.net/downloads/</a></u>

</pre><h4><b>AUTHOR</b></h4><pre>
       Judy  was  invented  by  Doug  Baskins  (dougbaskins  .AT, yahoo.com) and implemented by Hewlett-Packard.
       (Note:  Judy is named for the inventor's sister, after discarding many proposed names.)

</pre><h4><b>FILES</b></h4><pre>
       Locations of interest include:
       <u><a href="http://sourceforge.net/projects/judy">http://sourceforge.net/projects/judy</a></u> -- project downloads
       <u>file:/usr/share/doc/Judy/</u> -- for HTML version of man pages.
       /usr/share/doc/Judy/demo/ -- demonstration program source files.
       The author attempted to write interesting application notes using advanced features of Judy.  They may be
       found at <u>"<a href="http://judy.sourceforge.net/application/">http://judy.sourceforge.net/application/</a></u> (Some may be out of date).

</pre><h4><b>ERRORS</b></h4><pre>
       A lot of thought (and time) went into making error handling in Judy simple, while maintaining flexibility
       and capability.  Error handling is a very boring subject even to write about.  So read this short section
       and use the recommended second method.  It generates the fastest code, uses the least  amount  of  memory
       and  requires  you to write extra code only for insert/deletes functions.  Also it is compatible with the
       other two methods.  This method is for production code that may want to handle <u>malloc()</u> fails differently
       than the Judy default.  If the Judy default method of handling <u>malloc()</u> fails are OK, then use the  first
       method.

       There are <u>two</u> <u>(2)</u> categories of Judy error returns, (or for any dynamic ADT):

       1) User programming errors (bugs) such as memory corruption or invalid pointers.
       2) Out-of-memory (<u>malloc()</u> failure) with <b>I</b>nsert (<b>S</b>et) or <b>D</b>elete (<b>U</b>nset) when modifying a Judy array.  Not
       all  calls  to  insert  and  delete call <u>malloc()</u>, so they may succeed even when a call to <u>malloc()</u> would
       fail.

       There are roughly <u>three</u> <u>(3)</u> methods of handling errors when using the macros:

</pre><h4><b>1)</b> <b>Default</b> <b>Error</b> <b>Handling</b> <b>Method</b></h4><pre>
       The default is to print error messages to <b>stderr</b>, for example:

       File 'YourCfile.c', line 1234: JudyLIns(), JU_ERRNO_* == 2, ID == 321
       This indicates that an error occurred in the <b>JudyLIns()</b> function at line 321.  Line 1234 is the  line  in
       'YourCfile.c' where the <b>JLI()</b> call failed.  JU_ERRNO_* == 2 is equal to JU_ERRNO_NOMEM (as defined in the
       <b>Judy.h</b> file).  The ID number indicates the source line number in the function where the error originated.
       Your  program  then  terminates  with an <u><a href="../man1/exit.1.html">exit</a>(1);</u>.  By default, both categories of Judy error returns are
       printed this way.  (The 'ID == 321' is for die hards that want more detail or for debugging Judy itself.)

</pre><h4><b>2)</b> <b>Disable</b> <b>Macro</b> <b>Error</b> <b>Handling</b></h4><pre>
       When your program is "bug free", the only errors returned should be  <u>malloc()</u>  failures.   Therefore  all
       error  returns  can  be treated as a <u>malloc()</u> failure.  By using the below <b>#define</b>, all error testing and
       printing is turned off.  Additional code needs to be added to the code that can have  <u>malloc()</u>  failures.
       Judy was designed to leave the same data in the array before the call if a <u>malloc()</u> fail occurs.  (During
       testing  of Judy, we found very few <u>malloc()</u>/OS's that were bug free after a <u>malloc()</u> failure.  Sometimes
       it took weeks to discover because most systems go into a paging frenzy before running out of memory).

       #define JUDYERROR_NOTEST 1
       (in your program code), or

       cc -DJUDYERROR_NOTEST <u>sourcefile</u> -lJudy
       (on your command line).

       // This is an example of how to program using method two (2).

       JLI(PValue, PLArray, Index);
       if (PValue == PJERR) goto out_of_memory_handling;
       &amp;.&amp;.&amp;.

       JLD(RC_int, PLArray, Index);
       if (RC_int == JERR) goto out_of_memory_handling;
       &amp;.&amp;.&amp;.

       J1S(RC_int, P1Array, Index);
       if (RC_int == JERR) goto out_of_memory_handling;
       &amp;.&amp;.&amp;.

       J1U(RC_int, P1Array, Index);
       if (RC_int == JERR) goto out_of_memory_handling;
       &amp;.&amp;.&amp;.

       Note:  Without 'JUDYERROR_NOTEST' defined, the 'goto out_of_memory_handling' will never be  executed  and
       will  be  optimized  out  by  the  compiler.   The  default method will be used -- Macro will print error
       information if an error occurs as explained above.

       With 'JUDYERROR_NOTEST' defined, the 'goto out_of_memory_handling' will be executed when an error  occurs
       -- which should only happen when <u>malloc()</u> fails.

</pre><h4><b>3)</b> <b>User-Specified</b> <b>JUDYERROR()</b> <b>Macro</b> <b>Method</b></h4><pre>
       The  <b>JUDYERROR()</b> macro (in <b>Judy.h</b>) provides flexibility for handling error returns as needed to suit your
       program while still using the Judy array macros instead of function  calls.   You  can  use  a  different
       <b>JUDYERROR()</b> macro to suit your needs.  The following example is a possible alternative to the default. It
       is  used  to  distinguish  between the two types of errors (described above), and explicitly test for the
       remaining JU_ERRNO_NOMEM errors possible in your program.

       // This is an example of Judy macro API to continue when out of memory
       // and print and <a href="../man1/exit.1.html">exit</a>(1) when any other error occurs.

       #ifndef JUDYERROR_NOTEST
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;  // needed for fprintf()

       // This is the macro that the Judy macro APIs use for return codes of -1:

       #define JUDYERROR(CallerFile, CallerLine, JudyFunc, JudyErrno, JudyErrID) \
       {                                                                         \
           if ((JudyErrno) != JU_ERRNO_NOMEM) /* ! a malloc() failure */         \
           {                                                                     \
               (void) fprintf(stderr, "File '%s', line %d: %s(), "               \
                   "JU_ERRNO_* == %d, ID == %d\n",                               \
                   CallerFile, CallerLine,                                       \
                   JudyFunc, JudyErrno, JudyErrID);                              \
               <a href="../man1/exit.1.html">exit</a>(1);                                                          \
           }                                                                     \
       }
       #endif // JUDYERROR_NOTEST not defined
       This error handling macro must be included before the <b>#include</b> <b>&lt;Judy.h&gt;</b> statement in your program.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/Judy1.3.html">Judy1</a>(3)</b>, <b><a href="../man3/JudyL.3.html">JudyL</a>(3)</b>, <b><a href="../man3/JudySL.3.html">JudySL</a>(3)</b>, <b><a href="../man3/JudyHS.3.html">JudyHS</a>(3)</b>

                                                                                                         <u><a href="../man3/Judy.3.html">Judy</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>