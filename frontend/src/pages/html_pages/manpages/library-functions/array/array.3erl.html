<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>array - Functional, extendible arrays.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       array - Functional, extendible arrays.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Functional, extendible arrays. Arrays can have fixed size, or can grow automatically as needed. A default
       value is used for entries that have not been explicitly set.

       Arrays  uses  <u>zero</u>-based  indexing. This is a deliberate design choice and differs from other Erlang data
       structures, for example, tuples.

       Unless specified by the user when the array is created, the default value is the atom <u>undefined</u>. There is
       no difference between an unset entry and an entry that has been explicitly set to the same value  as  the
       default  one  (compare  <u>reset/2</u>). If you need to differentiate between unset and set entries, ensure that
       the default value cannot be confused with the values of set entries.

       The array never shrinks automatically. If an index <u>I</u> has been used to  set  an  entry  successfully,  all
       indices  in  the  range  [0,<u>I</u>]  stay  accessible  unless  the array size is explicitly changed by calling
       <u>resize/2</u>.

       <u>Examples:</u>

       Create a fixed-size array with entries 0-9 set to <u>undefined</u>:

       A0 = array:<a href="../man10/new.10.html">new</a>(10).
       10 = array:size(A0).

       Create an extendible array and set entry 17 to <u>true</u>, causing the array to grow automatically:

       A1 = array:set(17, true, array:new()).
       18 = array:size(A1).

       Read back a stored value:

       true = array:get(17, A1).

       Accessing an unset entry returns default value:

       undefined = array:get(3, A1)

       Accessing an entry beyond the last set entry also returns the default value, if the array does  not  have
       fixed size:

       undefined = array:get(18, A1).

       "Sparse" functions ignore default-valued entries:

       A2 = array:set(4, false, A1).
       [{4, false}, {17, true}] = array:sparse_to_orddict(A2).

       An extendible array can be made fixed-size later:

       A3 = array:fix(A2).

       A fixed-size array does not grow automatically and does not allow accesses beyond the last set entry:

       {'EXIT',{badarg,_}} = (catch array:set(18, true, A3)).
       {'EXIT',{badarg,_}} = (catch array:get(18, A3)).

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>array(Type)</b>

              A  functional,  extendible  array.  The  representation is not documented and is subject to change
              without notice. Notice that arrays cannot be directly compared for equality.

       <b>array()</b> = array(term())

       <b>array_indx()</b> = integer() &gt;= 0

       <b>array_opts()</b> = array_opt() | [array_opt()]

       <b>array_opt()</b> =
           {fixed, boolean()} |
           fixed |
           {default, Type :: term()} |
           {size, N :: integer() &gt;= 0} |
           (N :: integer() &gt;= 0)

       <b>indx_pairs(Type)</b> = [indx_pair(Type)]

       <b>indx_pair(Type)</b> = {Index :: array_indx(), Type}

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>default(Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b> <b>Value</b> <b>::</b> <b>Type</b>

              Gets the value used for uninitialized entries.

              See also <u>new/2</u>.

       <b>fix(Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b> <b>array(Type)</b>

              Fixes the array size. This prevents it from growing automatically upon insertion.

              See also <u>set/3</u> and <u>relax/1</u>.

       <b>foldl(Function,</b> <b>InitialAcc</b> <b>::</b> <b>A,</b> <b>Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b> <b>B</b>

              Types:

                 Function =
                     fun((Index :: array_indx(), Value :: Type, Acc :: A) -&gt; B)

              Folds the array elements using the specified function and initial accumulator value. The  elements
              are visited in order from the lowest index to the highest. If <u>Function</u> is not a function, the call
              fails with reason <u>badarg</u>.

              See also <u>foldr/3</u>, <u>map/2</u>, <u>sparse_foldl/3</u>.

       <b>foldr(Function,</b> <b>InitialAcc</b> <b>::</b> <b>A,</b> <b>Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b> <b>B</b>

              Types:

                 Function =
                     fun((Index :: array_indx(), Value :: Type, Acc :: A) -&gt; B)

              Folds the array elements right-to-left using the specified function and initial accumulator value.
              The  elements  are  visited  in  order  from the highest index to the lowest. If <u>Function</u> is not a
              function, the call fails with reason <u>badarg</u>.

              See also <u>foldl/3</u>, <u>map/2</u>.

       <b>from_list(List</b> <b>::</b> <b>[Value</b> <b>::</b> <b>Type])</b> <b>-&gt;</b> <b>array(Type)</b>

              Equivalent to <u>from_list(List,</u> <u>undefined)</u>.

       <b>from_list(List</b> <b>::</b> <b>[Value</b> <b>::</b> <b>Type],</b> <b>Default</b> <b>::</b> <b>term())</b> <b>-&gt;</b>
                    array(Type)

              Converts a list to an extendible array. <u>Default</u> is used as the value for uninitialized entries  of
              the array. If <u>List</u> is not a proper list, the call fails with reason <u>badarg</u>.

              See also <u>new/2</u>, <u>to_list/1</u>.

       <b>from_orddict(Orddict</b> <b>::</b> <b>indx_pairs(Value</b> <b>::</b> <b>Type))</b> <b>-&gt;</b> <b>array(Type)</b>

              Equivalent to <u>from_orddict(Orddict,</u> <u>undefined)</u>.

       <b>from_orddict(Orddict</b> <b>::</b> <b>indx_pairs(Value</b> <b>::</b> <b>Type),</b>
                    Default :: Type) -&gt;
                       array(Type)

              Converts  an  ordered list of pairs <u>{Index,</u> <u>Value}</u> to a corresponding extendible array. <u>Default</u> is
              used as the value for uninitialized entries of the array. If <u>Orddict</u> is not a proper, ordered list
              of pairs whose first elements are non-negative integers, the call fails with reason <u>badarg</u>.

              See also <u>new/2</u>, <u>to_orddict/1</u>.

       <b>get(I</b> <b>::</b> <b>array_indx(),</b> <b>Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b> <b>Value</b> <b>::</b> <b>Type</b>

              Gets the value of entry <u>I</u>. If <u>I</u> is not a non-negative integer, or if the array has fixed size  and
              <u>I</u> is larger than the maximum index, the call fails with reason <u>badarg</u>.

              If  the  array  does  not  have  fixed  size,  the  default  value  for  any  index <u>I</u> greater than
              <u>size(Array)-1</u> is returned.

              See also <u>set/3</u>.

       <b>is_array(X</b> <b>::</b> <b>term())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>X</u> is an array, otherwise <u>false</u>. Notice that the check is only shallow, as there is
              no guarantee that <u>X</u> is a well-formed array representation even if this function returns <u>true</u>.

       <b>is_fix(Array</b> <b>::</b> <b>array())</b> <b>-&gt;</b> <b>boolean()</b>

              Checks if the array has fixed size. Returns <u>true</u> if the array is fixed, otherwise <u>false</u>.

              See also <u>fix/1</u>.

       <b>map(Function,</b> <b>Array</b> <b>::</b> <b>array(Type1))</b> <b>-&gt;</b> <b>array(Type2)</b>

              Types:

                 Function = fun((Index :: array_indx(), Type1) -&gt; Type2)

              Maps the specified function onto each array element. The elements are visited in  order  from  the
              lowest index to the highest. If <u>Function</u> is not a function, the call fails with reason <u>badarg</u>.

              See also <u>foldl/3</u>, <u>foldr/3</u>, <u>sparse_map/2</u>.

       <b>new()</b> <b>-&gt;</b> <b>array()</b>

              Creates a new, extendible array with initial size zero.

              See also <u>new/1</u>, <u>new/2</u>.

       <b>new(Options</b> <b>::</b> <b>array_opts())</b> <b>-&gt;</b> <b>array()</b>

              Creates a new array according to the specified otions. By default, the array is extendible and has
              initial size zero. Array indices start at <u>0</u>.

              <u>Options</u> is a single term or a list of terms, selected from the following:

                <u>N::integer()</u> <u>&gt;=</u> <u>0</u> or <u>{size,</u> <u>N::integer()</u> <u>&gt;=</u> <u>0}</u>:
                  Specifies  the initial array size; this also implies <u>{fixed,</u> <u>true}</u>. If <u>N</u> is not a non-negative
                  integer, the call fails with reason <u>badarg</u>.

                <u>fixed</u> or <u>{fixed,</u> <u>true}</u>:
                  Creates a fixed-size array. See also <u>fix/1</u>.

                <u>{fixed,</u> <u>false}</u>:
                  Creates an extendible (non-fixed-size) array.

                <u>{default,</u> <u>Value}</u>:
                  Sets the default value for the array to <u>Value</u>.

              Options are processed in the order they occur in the list, that  is,  later  options  have  higher
              precedence.

              The  default  value  is used as the value of uninitialized entries, and cannot be changed once the
              array has been created.

              <u>Examples:</u>

              array:<a href="../man100/new.100.html">new</a>(100)

              creates a fixed-size array of size 100.

              array:new({default,0})

              creates an empty, extendible array whose default value is <u>0</u>.

              array:new([{size,10},{fixed,false},{default,-1}])

              creates an extendible array with initial size 10 whose default value is <u>-1</u>.

              See also <u>fix/1</u>, <u>from_list/2</u>, <u>get/2</u>, <u>new/0</u>, <u>new/2</u>, <u>set/3</u>.

       <b>new(Size</b> <b>::</b> <b>integer()</b> <b>&gt;=</b> <b>0,</b> <b>Options</b> <b>::</b> <b>array_opts())</b> <b>-&gt;</b> <b>array()</b>

              Creates a new array according to the specified size and options. If <u>Size</u>  is  not  a  non-negative
              integer,  the call fails with reason <u>badarg</u>. By default, the array has fixed size. Notice that any
              size specifications in <u>Options</u> override parameter <u>Size</u>.

              If <u>Options</u> is a list, this is equivalent  to  <u>new([{size,</u>  <u>Size}</u>  <u>|</u>  <u>Options])</u>,  otherwise  it  is
              equivalent  to  <u>new([{size,</u>  <u>Size}</u>  <u>|</u>  <u>[Options]])</u>.  However, using this function directly is more
              efficient.

              <u>Example:</u>

              array:new(100, {default,0})

              creates a fixed-size array of size 100, whose default value is <u>0</u>.

              See also <u>new/1</u>.

       <b>relax(Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b> <b>array(Type)</b>

              Makes the array resizable. (Reverses the effects of <u>fix/1</u>.)

              See also <u>fix/1</u>.

       <b>reset(I</b> <b>::</b> <b>array_indx(),</b> <b>Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b> <b>array(Type)</b>

              Resets entry <u>I</u> to the default value for the array. If the value of entry <u>I</u> is the  default  value,
              the  array  is  returned  unchanged.  Reset  never  changes  the array size. Shrinking can be done
              explicitly by calling <u>resize/2</u>.

              If <u>I</u> is not a non-negative integer, or if the array has fixed  size  and  <u>I</u>  is  larger  than  the
              maximum index, the call fails with reason <u>badarg</u>; compare <u>set/3</u>

              See also <u>new/2</u>, <u>set/3</u>.

       <b>resize(Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b> <b>array(Type)</b>

              Changes  the  array size to that reported by <u>sparse_size/1</u>. If the specified array has fixed size,
              also the resulting array has fixed size.

              See also <u>resize/2</u>, <u>sparse_size/1</u>.

       <b>resize(Size</b> <b>::</b> <b>integer()</b> <b>&gt;=</b> <b>0,</b> <b>Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b>
                 array(Type)

              Change the array size. If <u>Size</u> is not a non-negative integer, the call fails with  reason  <u>badarg</u>.
              If the specified array has fixed size, also the resulting array has fixed size.

       <b>set(I</b> <b>::</b> <b>array_indx(),</b> <b>Value</b> <b>::</b> <b>Type,</b> <b>Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b>
              array(Type)

              Sets  entry <u>I</u> of the array to <u>Value</u>. If <u>I</u> is not a non-negative integer, or if the array has fixed
              size and <u>I</u> is larger than the maximum index, the call fails with reason <u>badarg</u>.

              If the array does not have fixed size, and <u>I</u> is greater than <u>size(Array)-1</u>,  the  array  grows  to
              size <u>I+1</u>.

              See also <u>get/2</u>, <u>reset/2</u>.

       <b>size(Array</b> <b>::</b> <b>array())</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Gets the number of entries in the array. Entries are numbered from <u>0</u> to <u>size(Array)-1</u>. Hence, this
              is also the index of the first entry that is guaranteed to not have been previously set.

              See also <u>set/3</u>, <u>sparse_size/1</u>.

       <b>sparse_foldl(Function,</b> <b>InitialAcc</b> <b>::</b> <b>A,</b> <b>Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b> <b>B</b>

              Types:

                 Function =
                     fun((Index :: array_indx(), Value :: Type, Acc :: A) -&gt; B)

              Folds  the  array  elements  using  the specified function and initial accumulator value, skipping
              default-valued entries. The elements are visited in order from the lowest index to the highest. If
              <u>Function</u> is not a function, the call fails with reason <u>badarg</u>.

              See also <u>foldl/3</u>, <u>sparse_foldr/3</u>.

       <b>sparse_foldr(Function,</b> <b>InitialAcc</b> <b>::</b> <b>A,</b> <b>Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b> <b>B</b>

              Types:

                 Function =
                     fun((Index :: array_indx(), Value :: Type, Acc :: A) -&gt; B)

              Folds the array elements right-to-left using the specified function and initial accumulator value,
              skipping default-valued entries. The elements are visited in order from the highest index  to  the
              lowest. If <u>Function</u> is not a function, the call fails with reason <u>badarg</u>.

              See also <u>foldr/3</u>, <u>sparse_foldl/3</u>.

       <b>sparse_map(Function,</b> <b>Array</b> <b>::</b> <b>array(Type1))</b> <b>-&gt;</b> <b>array(Type2)</b>

              Types:

                 Function = fun((Index :: array_indx(), Type1) -&gt; Type2)

              Maps the specified function onto each array element, skipping default-valued entries. The elements
              are visited in order from the lowest index to the highest. If <u>Function</u> is not a function, the call
              fails with reason <u>badarg</u>.

              See also <u>map/2</u>.

       <b>sparse_size(Array</b> <b>::</b> <b>array())</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Gets  the  number  of  entries  in  the array up until the last non-default-valued entry. That is,
              returns <u>I+1</u> if <u>I</u> is the last non-default-valued entry in the array,  or  zero  if  no  such  entry
              exists.

              See also <u>resize/1</u>, <u>size/1</u>.

       <b>sparse_to_list(Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b> <b>[Value</b> <b>::</b> <b>Type]</b>

              Converts the array to a list, skipping default-valued entries.

              See also <u>to_list/1</u>.

       <b>sparse_to_orddict(Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b>
                            indx_pairs(Value :: Type)

              Converts the array to an ordered list of pairs <u>{Index,</u> <u>Value}</u>, skipping default-valued entries.

              See also <u>to_orddict/1</u>.

       <b>to_list(Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b> <b>[Value</b> <b>::</b> <b>Type]</b>

              Converts the array to a list.

              See also <u>from_list/2</u>, <u>sparse_to_list/1</u>.

       <b>to_orddict(Array</b> <b>::</b> <b>array(Type))</b> <b>-&gt;</b> <b>indx_pairs(Value</b> <b>::</b> <b>Type)</b>

              Converts the array to an ordered list of pairs <u>{Index,</u> <u>Value}</u>.

              See also <u>from_orddict/2</u>, <u>sparse_to_orddict/1</u>.

Ericsson AB                                        stdlib 3.17                                       <u><a href="../man3erl/array.3erl.html">array</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>