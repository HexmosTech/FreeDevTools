<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Font::TTF::Segarr - Segmented array</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfont-ttf-perl">libfont-ttf-perl_1.06-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Font::TTF::Segarr - Segmented array

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Holds data either directly or indirectly as a series of arrays. This class looks after the set of arrays
       and masks the individual sub-arrays, thus saving a class, we hope.

</pre><h4><b>INSTANCE</b> <b>VARIABLES</b></h4><pre>
       All instance variables do not start with a space.

       The segmented array is simply an array of segments

       Each segment is a more complex affair:

       START
           In terms of the array, the address for the 0th element in this segment.

       LEN Number of elements in this segment

       VAL The array which contains the elements

</pre><h4><b>METHODS</b></h4><pre>
   <b>Font::TTF::Segarr-&gt;new($size)</b>
       Creates a new segmented array with a given data size

   <b>$s-&gt;fastadd_segment($start,</b> <b>$is_sparse,</b> <b>@dat)</b>
       Creates a new segment and adds it to the array assuming no overlap between the new segment and any others
       in  the  array.  $is_sparse  indicates  whether the passed in array contains "undef"s or not. If false no
       checking is done (which is faster, but riskier). If equal to 2 then 0 is considered undef as well.

       Returns the number of segments inserted.

   <b>$s-&gt;add_segment($start,</b> <b>$overwrite,</b> <b>@dat)</b>
       Creates a new segment and adds it to the array allowing for possible overlaps between the new segment and
       the existing ones. In the case of overlaps, elements from the new segment are deleted  unless  $overwrite
       is set in which case the elements already there are over-written.

       This  method  also  checks  the  data coming in to see if it is sparse (i.e. contains undef values). Gaps
       cause new segments to be created or not to over-write existing values.

   <b>$s-&gt;tidy</b>
       Merges any immediately adjacent segments

   <b>$s-&gt;at($addr,</b> <b>[$len])</b>
       Looks up the data held at the given address by locating the appropriate segment etc. If  $len  &gt;  1  then
       returns an array of values, spaces being filled with undef.

   <b>$s-&gt;remove($addr,</b> <b>[$len])</b>
       Removes  the  item  or items from addr returning them as an array or the first value in a scalar context.
       This is very like "at", including padding with undef, but it deletes stuff as it goes.

   <b>$s-&gt;copy</b>
       Deep copies this array

   <b>$s-&gt;copy_seg($seg)</b>
       Creates a deep copy of a segment

</pre><h4><b>BUGS</b></h4><pre>
       No known bugs.

</pre><h4><b>AUTHOR</b></h4><pre>
       Martin Hosken &lt;<a href="http://scripts.sil.org/FontUtils">http://scripts.sil.org/FontUtils</a>&gt;.

</pre><h4><b>LICENSING</b></h4><pre>
       Copyright (c) 1998-2016, SIL International (<a href="http://www.sil.org">http://www.sil.org</a>)

       This module is released under the terms of the Artistic License 2.0.  For details, see the full  text  of
       the license in the file LICENSE.

perl v5.34.0                                       2022-06-14                             <u>Font::TTF::<a href="../man3pm/Segarr.3pm.html">Segarr</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>