<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::MakeMethods::Standard::Array - Methods for Array objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-makemethods-perl">libclass-makemethods-perl_1.01-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::MakeMethods::Standard::Array - Methods for Array objects

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package MyObject;
         use Class::MakeMethods::Standard::Array (
           new =&gt; 'new',
           scalar =&gt; [ 'foo', 'bar' ],
           array =&gt; 'my_list',
           hash =&gt; 'my_index',
         );
         ...

         my $obj = MyObject-&gt;new( foo =&gt; 'Foozle' );
         print $obj-&gt;foo();

         $obj-&gt;bar('Barbados');
         print $obj-&gt;bar();

         $obj-&gt;my_list(0 =&gt; 'Foozle', 1 =&gt; 'Bang!');
         print $obj-&gt;<a href="../man1/my_list.1.html">my_list</a>(1);

         $obj-&gt;my_index('broccoli' =&gt; 'Blah!', 'foo' =&gt; 'Fiddle');
         print $obj-&gt;my_index('foo');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The Standard::Array suclass of MakeMethods provides a basic constructor and accessors for blessed-array
       object instances.

   <b>Calling</b> <b>Conventions</b>
       When you "use" this package, the method names you provide as arguments cause subroutines to be generated
       and installed in your module.

       See "Calling Conventions" in Class::MakeMethods::Standard for more information.

   <b>Declaration</b> <b>Syntax</b>
       To declare methods, pass in pairs of a method-type name followed by one or more method names.

       Valid method-type names for this package are listed in "METHOD GENERATOR TYPES".

       See "Declaration Syntax" in Class::MakeMethods::Standard and "Parameter Syntax" in
       Class::MakeMethods::Standard for more information.

   <b>Positional</b> <b>Accessors</b> <b>and</b> <b>%FIELDS</b>
       Each accessor method is assigned the next available array index at which to store its value.

       The mapping between method names and array positions is stored in a hash named %FIELDS in the declaring
       package. When a package declares its first positional accessor, its %FIELDS are initialized by searching
       its inheritance tree.

       <b>Warning</b>: Subclassing packages that use positional accessors is somewhat fragile, since you may end up
       with two distinct methods assigned to the same position. Specific cases to avoid are:

       •   If you inherit from more than one class with positional accessors, the positions used by the two sets
           of methods will overlap.

       •   If  your  superclass  adds  additional  positional  accessors after you declare your first, they will
           overlap yours.

</pre><h4><b>METHOD</b> <b>GENERATOR</b> <b>TYPES</b></h4><pre>
   <b>new</b> <b>-</b> <b>Constructor</b>
       For each method name passed, returns a subroutine with the following characteristics:

       •   Has a reference to a sample item to copy. This defaults to a reference to an empty array, but you may
           override this with the "'defaults' =" <u>array_ref</u>&gt; method parameter.

       •   If called as a class method, makes a new array containing values from the sample item, and blesses it
           into that class.

       •   If called on an array-based instance, makes a copy of it and blesses the copy into the same class  as
           the original instance.

       •   If  passed  a  list  of  method-value  pairs, calls each named method with the associated value as an
           argument.

       •   Returns the new instance.

       Sample declaration and usage:

         package MyObject;
         use Class::MakeMethods::Standard::Array (
           new =&gt; 'new',
         );
         ...

         # Bare constructor
         my $empty = MyObject-&gt;new();

         # Constructor with initial sequence of method calls
         my $obj = MyObject-&gt;new( foo =&gt; 'Foozle', bar =&gt; 'Barbados' );

         # Copy with overriding sequence of method calls
         my $copy = $obj-&gt;new( bar =&gt; 'Bob' );

   <b>scalar</b> <b>-</b> <b>Instance</b> <b>Accessor</b>
       For each method name passed, uses a closure to generate a subroutine with the following characteristics:

       •   Must be called on an array-based instance.

       •   Determines the array position associated with the method name, and uses that as an  index  into  each
           instance  to  access  the related value. This defaults to the next available slot in %FIELDS, but you
           may override this with the "'array_index' =" <u>number</u>&gt; method parameter, or by pre-filling the contents
           of %FIELDS.

       •   If called without any arguments returns the current value (or undef).

       •   If called with an argument, stores that as the value, and returns it,

       Sample declaration and usage:

         package MyObject;
         use Class::MakeMethods::Standard::Array (
           scalar =&gt; 'foo',
         );
         ...

         # Store value
         $obj-&gt;foo('Foozle');

         # Retrieve value
         print $obj-&gt;foo;

   <b>array</b> <b>-</b> <b>Instance</b> <b>Ref</b> <b>Accessor</b>
       For each method name passed, uses a closure to generate a subroutine with the following characteristics:

       •   Must be called on an array-based instance.

       •   Determines the array position associated with the method name, and uses that as an  index  into  each
           instance  to  access  the related value. This defaults to the next available slot in %FIELDS, but you
           may override this with the "'array_index' =" <u>number</u>&gt; method parameter, or by pre-filling the contents
           of %FIELDS.

       •   The value for each instance will be a reference to an array (or undef).

       •   If called without any arguments, returns the current array-ref value (or undef).

       •   If called with a single non-ref argument, uses that  argument  as  an  index  to  retrieve  from  the
           referenced array, and returns that value (or undef).

       •   If called with a single array ref argument, uses that list to return a slice of the referenced array.

       •   If  called  with  a list of argument pairs, each with a non-ref index and an associated value, stores
           the value at the given index in  the  referenced  array.  If  the  instance's  value  was  previously
           undefined,  a  new array is autovivified. The current value in each position will be overwritten, and
           later arguments with the same index will override earlier ones. Returns the current array-ref value.

       •   If called with a list of argument pairs, each with the first item being a reference to an array of up
           to two numbers, loops over each pair and uses those numbers to splice the value array.

           The first controlling number is the position at which the splice will begin. Zero will  start  before
           the first item in the list. Negative numbers count backwards from the end of the array.

           The second number is the number of items to be removed from the list. If it is omitted, or undefined,
           or zero, no items are removed. If it is a positive integer, that many items will be returned.

           If  both  numbers  are  omitted,  or  are both undefined, they default to containing the entire value
           array.

           If the second argument is undef, no values will be inserted; if it is a non-reference value, that one
           value will be inserted; if it is an array-ref, its values will be copied.

           The method returns the items that removed from the array, if any.

       Sample declaration and usage:

         package MyObject;
         use Class::MakeMethods::Standard::Array (
           array =&gt; 'bar',
         );
         ...

         # Clear and set contents of list
         print $obj-&gt;bar([ 'Spume', 'Frost' ] );

         # Set values by position
         $obj-&gt;bar(0 =&gt; 'Foozle', 1 =&gt; 'Bang!');

         # Positions may be overwritten, and in any order
         $obj-&gt;bar(2 =&gt; 'And Mash', 1 =&gt; 'Blah!');

         # Retrieve value by position
         print $obj-&gt;<a href="../man1/bar.1.html">bar</a>(1);

         # Direct access to referenced array
         print scalar @{ $obj-&gt;bar() };

       There are also calling conventions for slice and splice operations:

         # Retrieve slice of values by position
         print join(', ', $obj-&gt;bar( undef, [0, 2] ) );

         # Insert an item at position in the array
         $obj-&gt;bar([3], 'Potatoes' );

         # Remove 1 item from position 3 in the array
         $obj-&gt;bar([3, 1], undef );

         # Set a new value at position 2, and return the old value
         print $obj-&gt;bar([2, 1], 'Froth' );

   <b>hash</b> <b>-</b> <b>Instance</b> <b>Ref</b> <b>Accessor</b>
       For each method name passed, uses a closure to generate a subroutine with the following characteristics:

       •   Must be called on an array-based instance.

       •   Determines the array position associated with the method name, and uses that as an  index  into  each
           instance  to  access  the related value. This defaults to the next available slot in %FIELDS, but you
           may override this with the "'array_index' =" <u>number</u>&gt; method parameter, or by pre-filling the contents
           of %FIELDS.

       •   The value for each instance will be a reference to a hash (or undef).

       •   If called without any arguments, returns the contents  of  the  hash  in  list  context,  or  a  hash
           reference in scalar context (or undef).

       •   If called with one argument, uses that argument as an index to retrieve from the referenced hash, and
           returns that value (or undef). If the single argument is an array ref, then a slice of the referenced
           hash is returned.

       •   If  called  with  a  list  of key-value pairs, stores the value under the given key in the referenced
           hash. If the instance's value was previously undefined, a new hash is autovivified. The current value
           under each key will be overwritten, and later arguments with the same key will override earlier ones.
           Returns the contents of the hash in list context, or a hash reference in scalar context.

       Sample declaration and usage:

         package MyObject;
         use Class::MakeMethods::Standard::Array (
           hash =&gt; 'baz',
         );
         ...

         # Set values by key
         $obj-&gt;baz('foo' =&gt; 'Foozle', 'bar' =&gt; 'Bang!');

         # Values may be overwritten, and in any order
         $obj-&gt;baz('broccoli' =&gt; 'Blah!', 'foo' =&gt; 'Fiddle');

         # Retrieve value by key
         print $obj-&gt;baz('foo');

         # Retrieve slice of values by position
         print join(', ', $obj-&gt;baz( ['foo', 'bar'] ) );

         # Direct access to referenced hash
         print keys %{ $obj-&gt;baz() };

         # Reset the hash contents to empty
         @{ $obj-&gt;baz() } = ();

   <b>object</b> <b>-</b> <b>Instance</b> <b>Ref</b> <b>Accessor</b>
       For each method name passed, uses a closure to generate a subroutine with the following characteristics:

       •   Must be called on an array-based instance.

       •   Determines the array position associated with the method name, and uses that as an  index  into  each
           instance  to  access  the related value. This defaults to the next available slot in %FIELDS, but you
           may override this with the "'array_index' =" <u>number</u>&gt; method parameter, or by pre-filling the contents
           of %FIELDS.

       •   The value for each instance will be a reference to an object (or undef).

       •   If called without any arguments returns the current value.

       •   If called with an argument, stores that as the value, and returns it,

       Sample declaration and usage:

         package MyObject;
         use Class::MakeMethods::Standard::Hash (
           object =&gt; 'foo',
         );
         ...

         # Store value
         $obj-&gt;foo( Foozle-&gt;new() );

         # Retrieve value
         print $obj-&gt;foo;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See Class::MakeMethods for general information about this distribution.

       See Class::MakeMethods::Standard for more about this family of subclasses.

       See Class::MakeMethods::Standard::Hash for equivalent functionality based  on  blessed  hashes.  If  your
       module  will  be  extensively  subclassed,  consider switching to Standard::Hash to avoid the subclassing
       concerns described above.

perl v5.36.0                                       2022-10-13                  <u>MakeMethods::Standard::<a href="../man3pm/Array.3pm.html">Array</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>