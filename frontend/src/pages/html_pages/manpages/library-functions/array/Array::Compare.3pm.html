<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Array::Compare - Perl extension for comparing arrays.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libarray-compare-perl">libarray-compare-perl_3.0.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Array::Compare - Perl extension for comparing arrays.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Array::Compare;

         my $comp1 = Array::Compare-&gt;new;
         $comp-&gt;Sep('|');
         $comp-&gt;Skip({3 =&gt; 1, 4 =&gt; 1});
         $comp-&gt;<a href="../man0/WhiteSpace.0.html">WhiteSpace</a>(0);
         $comp-&gt;<a href="../man1/Case.1.html">Case</a>(1);

         my $comp2 = Array::Compare-&gt;new(Sep =&gt; '|',
                                         WhiteSpace =&gt; 0,
                                         Case =&gt; 1,
                                         Skip =&gt; {3 =&gt; 1, 4 =&gt; 1});

         my @arr1 = 0 .. 10;
         my @arr2 = 0 .. 10;

         $comp1-&gt;compare(\@arr1, \@arr2);
         $comp2-&gt;compare(\@arr1, \@arr2);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       If you have two arrays and you want to know if they are the same or different, then Array::Compare will
       be useful to you.

       All comparisons are carried out via a comparator object. In the simplest usage, you can create and use a
       comparator object like this:

         my @arr1 = 0 .. 10;
         my @arr2 = 0 .. 10;

         my $comp = Array::Compare-&gt;new;

         if ($comp-&gt;compare(\@arr1, \@arr2)) {
           print "Arrays are the same\n";
         } else {
           print "Arrays are different\n";
         }

       Notice that you pass references to the two arrays to the comparison method.

       Internally the comparator compares the two arrays by using "join" to turn both arrays into strings and
       comparing the strings using "eq". In the joined strings, the elements of the original arrays are
       separated with the "^G" character. This can cause problems if your array data contains "^G" characters as
       it is possible that two different arrays can be converted to the same string.

       To avoid this, it is possible to override the default separator character, either by passing an
       alternative to the "new" function

         my $comp = Array::Compare-&gt;new(Sep =&gt; '|');

       or by changing the separator for an existing comparator object

         $comp-&gt;Sep('|');

       In general you should choose a separator character that won't appear in your data.

       You can also control whether or not whitespace within the elements of the arrays should be considered
       significant when making the comparison.  The default is that all whitespace is significant. The
       alternative is for all consecutive white space characters to be converted to a single space for the
       purposes of the comparison. Again, this can be turned on when creating a comparator object:

         my $comp = Array::Compare-&gt;new(WhiteSpace =&gt; 0);

       or by altering an existing object:

         $comp-&gt;<a href="../man0/WhiteSpace.0.html">WhiteSpace</a>(0);

       You can also control whether or not the case of the data is significant in the comparison. The default is
       that the case of data is taken into account. This can be changed in the standard ways when creating a new
       comparator object:

         my $comp = Array::Compare-&gt;new(Case =&gt; 0);

       or by altering an existing object:

         $comp-&gt;<a href="../man0/Case.0.html">Case</a>(0);

       In addition to the simple comparison described above (which returns true if the arrays are the same and
       false if they're different) there is also a full comparison which returns a list containing the indexes
       of elements which differ between the two arrays. If the arrays are the same it returns an empty list. In
       scalar context the full comparison returns the length of this list (i.e. the number of elements that
       differ). You can access the full comparison in two ways. Firstly, there is a "DefFull" attribute. If this
       is "true" then a full comparison is carried out whenever the "compare" method is called.

         my $comp = Array::Compare-&gt;new(DefFull =&gt; 1);
         $comp-&gt;compare(\@arr1, \@arr2); # Full comparison

         $comp-&gt;<a href="../man0/DefFull.0.html">DefFull</a>(0);
         $comp-&gt;compare(\@arr1, \@arr2); # Simple comparison

         $comp-&gt;<a href="../man1/DefFull.1.html">DefFull</a>(1);
         $comp-&gt;compare(\@arr1, \@arr2); # Full comparison again

       Secondly, you can access the full comparison method directly

         $comp-&gt;full_compare(\@arr1, \@arr2);

       For symmetry, there is also a direct method to use to call the simple comparison.

         $comp-&gt;simple_compare(\@arr1, \@arr2);

       The final complication is the ability to skip elements in the comparison.  If you know that two arrays
       will always differ in a particular element but want to compare the arrays <u>ignoring</u> this element, you can
       do it with Array::Compare without taking array slices. To do this, a comparator object has an optional
       attribute called "Skip" which is a reference to a hash. The keys in this hash are the indexes of the
       array elements and the values should be any true value for elements that should be skipped.

       For example, if you want to compare two arrays, ignoring the values in elements two and four, you can do
       something like this:

         my %skip = (2 =&gt; 1, 4 =&gt; 1);
         my @a = (0, 1, 2, 3, 4, 5);
         my @b = (0, 1, X, 3, X, 5);

         my $comp = Array::Compare-&gt;new(Skip =&gt; \%skip);

         $comp-&gt;compare(\@a, \@b);

       This should return <u>true</u>, as we are explicitly ignoring the columns which differ.

       Of course, having created a comparator object with no skip hash, it is possible to add one later:

         $comp-&gt;Skip({1 =&gt; 1, 2 =&gt; 1});

       or:

         my %skip = (1 =&gt; 1, 2 =&gt; 2);
         $comp-&gt;Skip(\%skip);

       To reset the comparator so that no longer skips elements, call <b>NoSkip()</b>.

         $comp-&gt;NoSkip();

       You can also check to see if one array is a permutation of another, i.e.  they contain the same elements
       but in a different order.

         if ($comp-&gt;perm(\@a, \@b) {
           print "Arrays are perms\n";
         } else {
           print "Nope. Arrays are completely different\n";
         }

       In this case the values of "WhiteSpace" and "Case" are still used, but "Skip" is ignored for, hopefully,
       obvious reasons.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b> <b>[</b> <b>%OPTIONS</b> <b>]</b>
       Constructs a new comparison object.

       Takes an optional hash containing various options that control how comparisons are carried out. Any
       omitted options take useful defaults.

       Sep This  is  the value that is used to separate fields when the array is joined into a string. It should
           be a value which doesn't appear in your data.  Default is '^G'.

       WhiteSpace
           Flag that indicates whether or not whitespace is significant in the  comparison.  If  this  value  is
           false  then  all multiple whitespace characters are changed into a single space before the comparison
           takes place. Default is 1 (whitespace is significant).

       Case
           Flag that indicates whther or not the case of the data  should  be  significant  in  the  comparison.
           Default is 1 (case is significant).

       Skip
           a  reference  to  a  hash  which  contains  the  numbers of any columns that should be skipped in the
           comparison. Default is an empty hash (all columns are significant).

       NoSkip
           Reset skipped column details. It assigns {} to the attribute "Skip".

       DefFull
           Flag which indicates whether the default comparison is simple (just returns true if  the  arrays  are
           the  same  or  false  if they're not) or full (returns an array containing the indexes of the columns
           that differ). Default is 0 (simple comparison).

   <b>compare_len</b> <b>\@ARR1,</b> <b>\@ARR2</b>
       Very simple comparison. Just checks the lengths of the arrays are the same.

   <b>different_len</b> <b>\@ARR1,</b> <b>\@ARR2</b>
       Passed two arrays and returns true if they are of different lengths.

       This is just the inverse of "compare_len" (which is badly named).

   <b>compare</b> <b>\@ARR1,</b> <b>\@ARR2</b>
       Compare the values in two arrays and return a data indicating whether the arrays are the same. The  exact
       return  values differ depending on the comparison method used. See the descriptions of simple_compare and
       full_compare for details.

       Uses the value of DefFull to determine which comparison routine to use.

   <b>simple_compare</b> <b>\@ARR1,</b> <b>\@ARR2</b>
       Compare the values in two arrays and return a flag indicating whether or not the arrays are the same.

       Returns true if the arrays are the same or false if they differ.

       Uses the values of 'Sep', 'WhiteSpace' and 'Skip' to influence the comparison.

   <b>full_compare</b> <b>\@ARR1,</b> <b>\@ARR2</b>
       Do a full comparison between two arrays.

       Checks each individual column. In scalar context returns the number of columns that differ (zero  if  the
       arrays  are  the  same). In list context returns a list containing the indexes of the columns that differ
       (an empty list if the arrays are the same).

       Uses the values of 'Sep' and 'WhiteSpace' to influence the comparison.

       <b>Note:</b> If the two arrays are of different lengths then  this  method  just  returns  the  indexes  of  the
       elements  that  appear  in  one  array but not the other (i.e. the indexes from the longer array that are
       beyond the end of the shorter array). This might be a little counter-intuitive.

   <b>perm</b> <b>\@ARR1,</b> <b>\@ARR2</b>
       Check to see if one array is a permutation of the other (i.e. contains the same set of elements, but in a
       different order).

       We do this by sorting the arrays and passing references to the assorted versions to simple_compare. There
       are also some small changes to simple_compare as it should ignore the Skip hash if  we  are  called  from
       perm.

</pre><h4><b>AUTHOR</b></h4><pre>
       Dave Cross &lt;<a href="mailto:dave@mag-sol.com">dave@mag-sol.com</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1).

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2000-2005, Magnum Solutions Ltd.  All Rights Reserved.

       This  script  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.32.0                                       2020-12-22                                <u>Array::<a href="../man3pm/Compare.3pm.html">Compare</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>