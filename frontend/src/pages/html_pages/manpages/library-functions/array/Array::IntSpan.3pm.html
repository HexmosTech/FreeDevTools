<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Array::IntSpan - Handles arrays of scalars or objects using integer ranges</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libarray-intspan-perl">libarray-intspan-perl_2.004-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Array::IntSpan - Handles arrays of scalars or objects using integer ranges

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Array::IntSpan;

         my $foo = Array::IntSpan-&gt;new([0, 59, 'F'], [60, 69, 'D'], [80, 89, 'B']);

         print "A score of 84% results in a ".$foo-&gt;<a href="../man84/lookup.84.html">lookup</a>(84).".\n";
         unless (defined($foo-&gt;<a href="../man70/lookup.70.html">lookup</a>(70))) {
           print "The grade for the score 70% is currently undefined.\n";
         }

         $foo-&gt;set_range(70, 79, 'C');
         print "A score of 75% now results in a ".$foo-&gt;<a href="../man75/lookup.75.html">lookup</a>(75).".\n";

         $foo-&gt;set_range(0, 59, undef);
         unless (defined($foo-&gt;<a href="../man40/lookup.40.html">lookup</a>(40))) {
           print "The grade for the score 40% is now undefined.\n";
         }

         $foo-&gt;set_range(87, 89, 'B+');
         $foo-&gt;set_range(85, 100, 'A');
         $foo-&gt;set_range(100, 1_000_000, 'A+');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Array::IntSpan" brings the speed advantages of "Set::IntSpan" (written by Steven McDougall) to arrays.
       Uses include manipulating grades, routing tables, or any other situation where you have mutually
       exclusive ranges of integers that map to given values.

       The new version of "Array::IntSpan" is also able to consolidate the ranges by comparing the adjacent
       values of the range. If 2 adjacent values are identical, the 2 adjacent ranges are merged.

</pre><h4><b>Ranges</b> <b>of</b> <b>objects</b></h4><pre>
       "Array::IntSpan" can also handle objects instead of scalar values.

       But for the consolidation to work, the payload class must overload the "", "eq" and "==" operators to
       perform the consolidation comparisons.

       When a get_range method is called to a range of objects, it will return a new range of object
       referencess. These object references points to the objects stored in the original range. In other words
       the objects contained in the returned range are <b>not</b> copied.

       Thus if the user calls a methods on the objects contained in the returned range, the method is actually
       invoked on the objects stored in the original range.

       When a get_range method is called on a range of objects, several things may happen:

       •   The  get_range  spans  empty  slots. By default the returned range will skip the empty slots. But the
           user may provide a callback to create new objects (for instance). See details below.

       •   The get_range splits existing ranges. By default, the split  range  will  contains  the  same  object
           reference.  The  user  may  provide  callback to perform the object copy so that the split range will
           contains different objects. See details below.

</pre><h4><b>Ranges</b> <b>specified</b> <b>with</b> <b>integer</b> <b>fields</b></h4><pre>
       •   "Array::IntSpan::IP" is also provided with the distribution.  It lets you use IP addresses in any  of
           three  forms  (dotted  decimal, network string, and integer) for the indices into the array.  See the
           POD for that module for more information. See Array::IntSpan::IP for details.

       •   "Array::IntSpan::Fields" is also provided with the distribution. It  let  you  specify  an  arbitrary
           specification  to  handle  ranges  with  strings  made  of several integer separared by dots (like IP
           addresses of ANSI SS7 point codes). See Array::IntSpan::Fields for details.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b> <b>(...)</b>
       The "new" method takes an optional  list  of  array  elements.   The  elements  should  be  in  the  form
       "[start_index,  end_index, value]".  They should be in sorted order and there should be no overlaps.  The
       internal method "_check_structure" will be called to verify the data is correct.  If you  wish  to  avoid
       the performance penalties of checking the structure, you can use "Data::Dumper" to dump an object and use
       that code to reconstitute it.

   <b>clear</b>
       Clear the range.

   <b>set_range</b> <b>(start,</b> <b>end,</b> <b>value</b> <b>[,</b> <b>code</b> <b>ref]</b> <b>)</b>
       This method takes three parameters - the "start_index", the "end_index", and the "value".  If you wish to
       erase  a  range,  specify  "undef"  for  the "value".  It properly deals with overlapping ranges and will
       replace existing data as appropriate.  If the new range lies after the last existing  range,  the  method
       will execute in <a href="../man1/O.1.html">O</a>(1) time.  If the new range lies within the existing ranges, the method executes in O(n)
       time,  where  n  is  the  number  of ranges. It does not consolidate contiguous ranges that have the same
       "value".

       If you have a large number of inserts to do, it would be beneficial to sort them first.  Sorting  is  O(n
       lg(n)),  and since appending is <a href="../man1/O.1.html">O</a>(1), that will be considerably faster than the O(n^2) time for inserting
       n unsorted elements.

       The method returns 0 if there were no overlapping ranges and 1 if there were.

       The optional code ref is called back when an existing range is split. For instance if the original  range
       is "[0,10,$foo_obj]" and set_range is called with "[5,7,$bar_obj']", the callback will be called twice:

        $callback-&gt;(0, 4,$foo_obj)
        $callback-&gt;(8,10,$foo_obj)

       It  will  be  the  callback responsibility to make sure that the range "0-4" and "7-10" holds 2 <u>different</u>
       objects.

   <b>set(</b> <b>index,</b>  <b>value</b> <b>[,</b> <b>code</b> <b>ref]</b> <b>)</b>
       Set a single value. This may split an existing range. Actually calls:

        set_range( index, index, value [, code ref] )

   <b>set_range_as_string</b> <b>(</b> <b>index,</b>  <b>string</b> <b>[,</b> <b>code</b> <b>ref]</b> <b>)</b>
       Set one one several ranges specified with a string. Ranges are separated by "-".  Several ranges  can  be
       specified with commas.

       Example:

         set_range_as_string( '1-10,13, 14-20', 'foo')

       White space are ignored.

   <b>get_range</b> <b>(start,</b> <b>end</b> <b>[,</b> <b>filler</b> <b>|</b> <b>undef</b> <b>,</b> <b>copy_cb</b> <b>[,</b> <b>set_cb]])</b>
       This method returns a range (actually an Array::IntSpan object) from "start" to "end".

       If  "start"  and  "end"  span empty slot in the original range, get_range will skip the empty slots. If a
       "filler" value is provided, get_range will fill the slots with it.

        original range    : [2-4,X],[7-9,Y],[12-14,Z]
        get_range(3,8)    : [3-4,X],[7-8,Y]
        get_range(2,10,f) : [3-4,X],[5-6,f],[7-8,Y]

       If the "filler" parameter is a CODE reference, the filler value will be the one returned by the sub  ref.
       The  sub ref is invoked with "(start,end)", i.e. the range of the empty span to fill ("get_range(5,6)" in
       the example above). When handling object, the sub ref can invoke an object constructor.

       If "start" or "end" split an original range in 2, the default behavior is to copy the value or object ref
       contained in the original range:

        original range     : [1-4,X]
        split range        : [1-1,X],[2-2,X],[3-4,X]
        <a href="../man2/get_range.2.html">get_range</a>(2)       : [2-2,X]

       If the original range contains object, this may lead to disapointing results. In the example below the  2
       ranges contains references ("obj_a") that points to the same object:

        original range     : [1-4,obj_a]
        split range        : [1-1,obj_a],[2-2,obj_a],[3-4,obj_a]
        <a href="../man2/get_range.2.html">get_range</a>(2)       : [2-2,obj_a]

       Which  means  that  invoking  a method on the object returned by <a href="../man2/get_range.2.html">get_range</a>(2) will also be invoked on the
       range 1-4 of the original range which may not be what you want.

       If "get_range" is invoked with a copy parameter (actually a code reference), the result of  this  routine
       will be stored in the split range <u>outside</u> of the get_range:

        original range     : [1-4,X]
        <a href="../man2/get_range.2.html">get_range</a>(2)       : [2-2,X]
        split range        : [1-1,copy_of_X],[2-2,X],[3-4,copy_of_X]

       When dealing with object, the sub ref should provide a copy of the object:

        original range     : [1-4,obj_a]
        <a href="../man2/get_range.2.html">get_range</a>(2)       : [2-2,obj_a]
        split range        : [1-1,obj_a1],[2-2,obj_a],[3-4,obj_a2]

       Note  that  the  "obj_a"  contained  in the "split range" and the "obj_a" contained in the returned range
       point to the <u>same</u> <u>object</u>.

       The sub ref is invoked with "(start,end,obj_a)" and is expected to return a copy of "obj_a" that will  be
       stored in the split ranges. In the example above, 2 different copies are made: "obj_a1" and "obj_a2".

       Last,  a 3rd callback may be defined by the user: the "set_cb". This callback will be used when the range
       start or end that holds an object changes. In the example above, the "set_cb" will be called this way:

        $obj_a-&gt;&amp;$set_cb(2,2) ;

       As a matter of fact, the 3 callback can be used in the same call. In the example  below,  "get_range"  is
       invoked with 3 subs refs: "\&amp;f,\&amp;cp,\&amp;set":

        original range     : [1-4,obj_a],[7-9,obj_b]
        get_range(3-8,...) : [3-4,obj_a],[5-6,obj_fill],[7-8,obj_b]
        split range        : [1-2,obj_a1], [3-4,obj_a],[5-6,obj_fill],
                             [7-8,obj_b],[9-9,obj_b1]

       To obtain this, get_range will perform the following calls:

        $obj_fill = &amp;f ;
        $obj_a1 = &amp;cp(5,6,obj_a);
        &amp;set(3,4,$obj_a) ;
        $obj_b = &amp;cp(9,9,obj_b) ;
        &amp;set(7-8,obj_b) ;

   <b>get_range_list</b>
       In scalar context, returns a list of range in a string like: ""1-5,7,9-11"".

       In list context retunrs a list of list, E.g. " ( [1,5], [7,7], 9,11])".

   <b>lookup(</b> <b>index</b> <b>)</b>
       This  method  takes  as a single parameter the "index" to look up.  If there is an appropriate range, the
       method will return the associated value.  Otherwise, it returns "undef".

   <b>get_element(</b> <b>element_number</b> <b>)</b>
       Returns an array containing the Nth range element:

        ( start, end, value )

   <b>consolidate(</b> <b>[</b> <b>bottom,</b> <b>top</b> <b>,</b> <b>[</b> <b>set_cb</b> <b>]]</b> <b>)</b>
       This function scans the range from the range index "bottom" to "top" and compare the values held  by  the
       adjacent ranges. If the values are identical, the adjacent ranges are merged.

       The  comparison  is  made  with  the  "=="  operator.  Objects stored in the range <b>must</b> overload the "=="
       operator. If not, the comparison is made with the standard stringification of an  object  and  the  merge
       never happens.

       If provided, the "set_cb" is invoked on the contained object after 2 ranges are merged.

       For instance, if "$obj_a" eq "$obj_b":

        original range is            : [1-4,obj_a],[5-9,obj_b]
        consolidate(0,1,\&amp;set) yields: [1-9,obj_a]

       And "consolidate" performs this call:

        $set-&gt;(1,9,obj_a) ;

       Consolidate the whole range when called without parameters.

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Mohammad S Anwar &lt;<a href="mailto:mohammad.anwar@yahoo.com">mohammad.anwar@yahoo.com</a>&gt;

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Toby Everett, <a href="mailto:teverett@alascom.att.com">teverett@alascom.att.com</a>

       •   Dominique Dumont, <a href="mailto:ddumont@cpan.org">ddumont@cpan.org</a>

       Copyright  (c)  2000  Toby  Everett.   Copyright  (c)  2003-2004,2014,2020  Dominique Dumont.  All rights
       reserved.  This program is free software.

       This     module     is      distributed      under      the      Artistic      2.0      License.      See
       https://www.perlfoundation.org/artistic-license-20.html

perl v5.34.0                                       2022-05-27                                <u>Array::<a href="../man3pm/IntSpan.3pm.html">IntSpan</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>