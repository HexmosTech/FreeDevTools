<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tie::Array::Sorted - An array which is kept sorted</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtie-array-sorted-perl">libtie-array-sorted-perl_1.41-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tie::Array::Sorted - An array which is kept sorted

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use Tie::Array::Sorted;

               tie @a, "Tie::Array::Sorted", sub { $_[0] &lt;=&gt; $_[1] };

               push @a, 10, 4, 7, 3, 4;
               print "@a"; # "3 4 4 7 10"

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This presents an ordinary array, but is kept sorted. All pushes and unshifts cause the elements in
       question to be inserted in the appropriate location to maintain order.

       Direct stores ("$a[10] = "wibble"") effectively splice out the original value and insert the new element.
       It's not clear why you'd want to use direct stores like that, but this module does the right thing if you
       do.

       If you don't like the ordinary lexical comparator, you can provide your own; it should compare the two
       elements it is given. For instance, a numeric comparator would look like this:

               tie @a, "Tie::Array::Sorted", sub { $_[0] &lt;=&gt; $_[1] }

       Whereas to compare a list of files by their sizes, you'd so something like:

               tie @a, "Tie::Array::Sorted", sub { -s $_[0] &lt;=&gt; -s $_[1] }

</pre><h4><b>LAZY</b> <b>SORTING</b></h4><pre>
       If you do more stores than fetches, you may find Tie::Array::Sorted::Lazy more efficient.

</pre><h4><b>AUTHOR</b></h4><pre>
       Original author: Simon Cozens

       Current maintainer: Tony Bowden

</pre><h4><b>BUGS</b> <b>and</b> <b>QUERIES</b></h4><pre>
       Please direct all correspondence regarding this module to:      <a href="mailto:bug-Tie-Array-Sorted@rt.cpan.org">bug-Tie-Array-Sorted@rt.cpan.org</a>

       This module was originall written as part of the Plucene project.  However, as Plucene no longer uses
       this, it is effectively unmaintained.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
         Copyright (C) 2003-2006 Simon Cozens and Tony Bowden.

         This program is free software; you can redistribute it and/or modify it under
         the terms of the GNU General Public License; either version 2 of the License,
         or (at your option) any later version.

         This program is distributed in the hope that it will be useful, but WITHOUT
         ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
         FOR A PARTICULAR PURPOSE.

perl v5.36.0                                       2022-10-15                            <u>Tie::Array::<a href="../man3pm/Sorted.3pm.html">Sorted</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>