<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sub::HandlesVia::HandlerLibrary::Array - library of array-related methods</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsub-handlesvia-perl">libsub-handlesvia-perl_0.050002-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Sub::HandlesVia::HandlerLibrary::Array - library of array-related methods

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package My::Class {
           use Moo;
           use Sub::HandlesVia;
           use Types::Standard 'ArrayRef';
           has attr =&gt; (
             is =&gt; 'rwp',
             isa =&gt; ArrayRef,
             handles_via =&gt; 'Array',
             handles =&gt; {
               'my_accessor' =&gt; 'accessor',
               'my_all' =&gt; 'all',
               'my_all_true' =&gt; 'all_true',
               'my_any' =&gt; 'any',
               'my_apply' =&gt; 'apply',
               'my_clear' =&gt; 'clear',
               'my_count' =&gt; 'count',
               'my_delete' =&gt; 'delete',
               'my_elements' =&gt; 'elements',
               'my_first' =&gt; 'first',
               'my_first_index' =&gt; 'first_index',
               'my_flatten' =&gt; 'flatten',
               'my_flatten_deep' =&gt; 'flatten_deep',
               'my_for_each' =&gt; 'for_each',
               'my_for_each_pair' =&gt; 'for_each_pair',
               'my_get' =&gt; 'get',
               'my_grep' =&gt; 'grep',
               'my_head' =&gt; 'head',
               'my_insert' =&gt; 'insert',
               'my_is_empty' =&gt; 'is_empty',
               'my_join' =&gt; 'join',
               'my_map' =&gt; 'map',
               'my_max' =&gt; 'max',
               'my_maxstr' =&gt; 'maxstr',
               'my_min' =&gt; 'min',
               'my_minstr' =&gt; 'minstr',
               'my_natatime' =&gt; 'natatime',
               'my_not_all_true' =&gt; 'not_all_true',
               'my_pairfirst' =&gt; 'pairfirst',
               'my_pairgrep' =&gt; 'pairgrep',
               'my_pairkeys' =&gt; 'pairkeys',
               'my_pairmap' =&gt; 'pairmap',
               'my_pairs' =&gt; 'pairs',
               'my_pairvalues' =&gt; 'pairvalues',
               'my_pick_random' =&gt; 'pick_random',
               'my_pop' =&gt; 'pop',
               'my_print' =&gt; 'print',
               'my_product' =&gt; 'product',
               'my_push' =&gt; 'push',
               'my_reduce' =&gt; 'reduce',
               'my_reductions' =&gt; 'reductions',
               'my_reset' =&gt; 'reset',
               'my_reverse' =&gt; 'reverse',
               'my_sample' =&gt; 'sample',
               'my_set' =&gt; 'set',
               'my_shallow_clone' =&gt; 'shallow_clone',
               'my_shift' =&gt; 'shift',
               'my_shuffle' =&gt; 'shuffle',
               'my_shuffle_in_place' =&gt; 'shuffle_in_place',
               'my_sort' =&gt; 'sort',
               'my_sort_in_place' =&gt; 'sort_in_place',
               'my_splice' =&gt; 'splice',
               'my_sum' =&gt; 'sum',
               'my_tail' =&gt; 'tail',
               'my_uniq' =&gt; 'uniq',
               'my_uniq_in_place' =&gt; 'uniq_in_place',
               'my_uniqnum' =&gt; 'uniqnum',
               'my_uniqnum_in_place' =&gt; 'uniqnum_in_place',
               'my_uniqstr' =&gt; 'uniqstr',
               'my_uniqstr_in_place' =&gt; 'uniqstr_in_place',
               'my_unshift' =&gt; 'unshift',
             },
           );
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a library of methods for Sub::HandlesVia.

</pre><h4><b>DELEGATABLE</b> <b>METHODS</b></h4><pre>
   <b>"accessor(</b> <b>$index,</b> <b>$value?</b> <b>)"</b>
       Arguments: <b>Int</b>, <b>Optional[Any]</b>.

       Acts like "get" if given just an index, or "set" if given an index and value.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar', 'baz' ] );
         $object-&gt;my_accessor( 1, 'quux' );
         say Dumper( $object-&gt;attr ); ## ==&gt; [ 'foo', 'quux', 'baz' ]
         say $object-&gt;my_accessor( 2 ); ## ==&gt; 'baz'

   <b>all()</b>
       All elements in the array, in list context.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar' ] );
         my @list = $object-&gt;my_all;
         say Dumper( \@list ); ## ==&gt; [ 'foo', 'bar' ]

   <b>all_true(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Like List::Util::all().

   <b>any(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Like List::Util::any().

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar', 'baz' ] );
         my $truth  = $object-&gt;my_any( sub { /a/ } );
         say $truth; ## ==&gt; true

   <b>apply(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Executes the coderef (which should modify $_) against each element of the array; returns the resulting
       array in list context.

   <b>clear()</b>
       Empties the array.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo' ] );
         $object-&gt;my_clear;
         say Dumper( $object-&gt;attr ); ## ==&gt; []

   <b>count()</b>
       The number of elements in the referenced array.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar' ] );
         say $object-&gt;my_count; ## ==&gt; 2

   <b>delete(</b> <b>$index</b> <b>)</b>
       Arguments: <b>Int</b>.

       Removes the indexed element from the array and returns it. Elements after it will be "moved up".

   <b>elements()</b>
       All elements in the array, in list context. (Essentially the same as "all".)

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar' ] );
         my @list = $object-&gt;my_elements;
         say Dumper( \@list ); ## ==&gt; [ 'foo', 'bar' ]

   <b>first(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Like List::Util::first().

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar', 'baz' ] );
         my $found  = $object-&gt;my_first( sub { /a/ } );
         say $found; ## ==&gt; 'bar'

   <b>first_index(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Like List::MoreUtils::first_index().

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar', 'baz' ] );
         my $found  = $object-&gt;my_first_index( sub { /z$/ } );
         say $found; ## ==&gt; 2

   <b>flatten()</b>
       All elements in the array, in list context. (Essentially the same as "all".)

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar' ] );
         my @list = $object-&gt;my_flatten;
         say Dumper( \@list ); ## ==&gt; [ 'foo', 'bar' ]

   <b>flatten_deep(</b> <b>$depth?</b> <b>)</b>
       Arguments: <b>Optional[Int]</b>.

       Flattens the arrayref into a list, including any nested arrayrefs. (Has the potential to loop
       infinitely.)

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', [ 'bar', [ 'baz' ] ] ] );
         say Dumper( [ $object-&gt;my_flatten_deep ] ); ## ==&gt; [ 'foo', 'bar', 'baz' ]

         my $object2 = My::Class-&gt;new( attr =&gt; [ 'foo', [ 'bar', [ 'baz' ] ] ] );
         say Dumper( [ $object-&gt;<a href="../man1/my_flatten_deep.1.html">my_flatten_deep</a>(1) ] ); ## ==&gt; [ 'foo', 'bar', [ 'baz' ] ]

   <b>for_each(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Chainable method which executes the coderef on each element of the array. The coderef will be passed two
       values: the element and its index.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar', 'baz' ] );
         $object-&gt;my_for_each( sub { say "Item $_[1] is $_[0]." } );

   <b>for_each_pair(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Chainable method which executes the coderef on each pair of elements in the array. The coderef will be
       passed the two elements.

   <b>get(</b> <b>$index</b> <b>)</b>
       Arguments: <b>Int</b>.

       Returns a single element from the array by index.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar', 'baz' ] );
         say $object-&gt;my_get(  0 ); ## ==&gt; 'foo'
         say $object-&gt;my_get(  1 ); ## ==&gt; 'bar'
         say $object-&gt;my_get( -1 ); ## ==&gt; 'baz'

   <b>grep(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Like "grep" from perlfunc.

   <b>head(</b> <b>$count</b> <b>)</b>
       Arguments: <b>Int</b>.

       Returns the first $count elements of the array in list context.

   <b>"insert(</b> <b>$index,</b> <b>$value</b> <b>)"</b>
       Arguments: <b>Int</b>, <b>Any</b>.

       Inserts a value into the array with the given index. Elements after it will be "moved down".

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar', 'baz' ] );
         $object-&gt;my_insert( 1, 'quux' );
         say Dumper( $object-&gt;attr ); ## ==&gt; [ 'foo', 'quux', 'bar', 'baz' ]

   <b>is_empty()</b>
       Boolean indicating if the referenced array is empty.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar' ] );
         say $object-&gt;my_is_empty; ## ==&gt; false
         $object-&gt;_set_attr( [] );
         say $object-&gt;my_is_empty; ## ==&gt; true

   <b>join(</b> <b>$with?</b> <b>)</b>
       Arguments: <b>Optional[Str]</b>.

       Returns a string joining all the elements in the array; if $with is omitted, defaults to a comma.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar', 'baz' ] );
         say $object-&gt;my_join;        ## ==&gt; 'foo,bar,baz'
         say $object-&gt;my_join( '|' ); ## ==&gt; 'foo|bar|baz'

   <b>map(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Like "map" from perlfunc.

   <b>max()</b>
       Like List::Util::max().

   <b>maxstr()</b>
       Like List::Util::maxstr().

   <b>min()</b>
       Like List::Util::min().

   <b>minstr()</b>
       Like List::Util::minstr().

   <b>"natatime(</b> <b>$n,</b> <b>$callback?</b> <b>)"</b>
       Arguments: <b>Int</b>, <b>Optional[CodeRef]</b>.

       Given just a number, returns an iterator which reads that many elements from the array at a time. If also
       given a callback, calls the callback repeatedly with those values.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar', 'baz' ] );
         my $iter   = $object-&gt;my_natatime( 2 );
         say Dumper( [ $iter-&gt;() ] ); ## ==&gt; [ 'foo', 'bar' ]
         say Dumper( [ $iter-&gt;() ] ); ## ==&gt; [ 'baz' ]

   <b>not_all_true(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Like List::Util::notall().

   <b>pairfirst(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Like List::Util::pairfirst().

   <b>pairgrep(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Like List::Util::pairgrep().

   <b>pairkeys()</b>
       Like List::Util::pairkeys().

   <b>pairmap(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Like List::Util::pairmap().

   <b>pairs()</b>
       Like List::Util::pairs().

   <b>pairvalues()</b>
       Like List::Util::pairvalues().

   <b>pick_random(</b> <b>$count</b> <b>)</b>
       Arguments: <b>Optional[Int]</b>.

       If no $count is given, returns one element of the array at random. If $count is given, creates a new
       array with that many random elements from the original array (or fewer if the original array is not long
       enough) and returns that as an arrayref or list depending on context

   <b>pop()</b>
       Removes the last element from the array and returns it.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar', 'baz' ] );
         say $object-&gt;my_pop; ## ==&gt; 'baz'
         say $object-&gt;my_pop; ## ==&gt; 'bar'
         say Dumper( $object-&gt;attr ); ## ==&gt; [ 'foo' ]

   <b>"print(</b> <b>$fh?,</b> <b>$with?</b> <b>)"</b>
       Arguments: <b>Optional[FileHandle]</b>, <b>Optional[Str]</b>.

       Prints a string joining all the elements in the array; if $fh is omitted, defaults to STDOUT; if $with is
       omitted, defaults to a comma.

   <b>product()</b>
       Like List::Util::product().

   <b>push(</b> <b>@values</b> <b>)</b>
       Adds elements to the end of the array.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo' ] );
         $object-&gt;my_push( 'bar', 'baz' );
         say Dumper( $object-&gt;attr ); ## ==&gt; [ 'foo', 'bar', 'baz' ]

   <b>reduce(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Like List::Util::reduce().

   <b>reductions(</b> <b>$coderef</b> <b>)</b>
       Arguments: <b>CodeRef</b>.

       Like List::Util::reductions().

   <b>reset()</b>
       Resets the attribute to its default value, or an empty arrayref if it has no default.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar', 'baz' ] );
         $object-&gt;my_reset;
         say Dumper( $object-&gt;attr ); ## ==&gt; []

   <b>reverse()</b>
       Returns the reversed array in list context.

   <b>sample(</b> <b>$count</b> <b>)</b>
       Arguments: <b>Int</b>.

       Like List::Util::sample().

   <b>"set(</b> <b>$index,</b> <b>$value</b> <b>)"</b>
       Arguments: <b>Int</b>, <b>Any</b>.

       Sets the element with the given index to the supplied value.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar', 'baz' ] );
         $object-&gt;my_set( 1, 'quux' );
         say Dumper( $object-&gt;attr ); ## ==&gt; [ 'foo', 'quux', 'baz' ]

   <b>shallow_clone()</b>
       Creates a new arrayref with the same elements as the original.

   <b>shift()</b>
       Removes an element from the start of the array and returns it.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo', 'bar', 'baz' ] );
         say $object-&gt;my_shift; ## ==&gt; 'foo'
         say $object-&gt;my_shift; ## ==&gt; 'bar'
         say Dumper( $object-&gt;attr ); ## ==&gt; [ 'baz' ]

   <b>shuffle()</b>
       Returns the array in a random order; can be called in list context or scalar context and will return an
       arrayref in the latter case.

   <b>shuffle_in_place()</b>
       Rearranges the array in a random order, and changes the attribute to point to the new order.

   <b>sort(</b> <b>$coderef?</b> <b>)</b>
       Arguments: <b>Optional[CodeRef]</b>.

       Like "sort" from perlfunc.

   <b>sort_in_place(</b> <b>$coderef?</b> <b>)</b>
       Arguments: <b>Optional[CodeRef]</b>.

       Like "sort" from perlfunc, but changes the attribute to point to the newly sorted array.

   <b>"splice(</b> <b>$index,</b> <b>$length,</b> <b>@values</b> <b>)"</b>
       Like "splice" from perlfunc.

   <b>sum()</b>
       Like List::Util::sum0().

   <b>tail(</b> <b>$count</b> <b>)</b>
       Arguments: <b>Int</b>.

       Returns the last $count elements of the array in list context.

   <b>uniq()</b>
       Returns the array filtered to remove duplicates; can be called in list context or scalar context and will
       return an arrayref in the latter case.

   <b>uniq_in_place()</b>
       Filters the array to remove duplicates, and changes the attribute to point to the filtered array.

   <b>uniqnum()</b>
       Returns the array filtered to remove duplicates numerically; can be called in list context or scalar
       context and will return an arrayref in the latter case.

   <b>uniqnum_in_place()</b>
       Filters the array to remove duplicates numerically, and changes the attribute to point to the filtered
       array.

   <b>uniqstr()</b>
       Returns the array filtered to remove duplicates stringwise; can be called in list context or scalar
       context and will return an arrayref in the latter case.

   <b>uniqstr_in_place()</b>
       Filters the array to remove duplicates stringwise, and changes the attribute to point to the filtered
       array.

   <b>unshift(</b> <b>@values</b> <b>)</b>
       Adds an element to the start of the array.

         my $object = My::Class-&gt;new( attr =&gt; [ 'foo' ] );
         $object-&gt;my_unshift( 'bar', 'baz' );
         say Dumper( $object-&gt;attr ); ## ==&gt; [ 'bar', 'baz', 'foo' ]

</pre><h4><b>SHORTCUT</b> <b>CONSTANTS</b></h4><pre>
       This module provides some shortcut constants for indicating a list of delegations.

         package My::Class {
           use Moo;
           use Sub::HandlesVia;
           use Sub::HandlesVia::HandlerLibrary::Array qw( HandleQueue );

           has things =&gt; (
             is          =&gt; 'ro',
             handles_via =&gt; 'Array',
             handles     =&gt; HandleQueue,
             default     =&gt; sub { [] },
           );
         }

       These shortcuts can be combined using the " | " operator.

           has things =&gt; (
             is          =&gt; 'ro',
             handles_via =&gt; 'Array',
             handles     =&gt; HandleQueue | HandleStack,
             default     =&gt; sub { [] },
           );

   <b>"HandleQueue"</b>
       Creates delegations named like "things_is_empty", "things_size", "things_enqueue", "things_dequeue", and
       "things_peek".

   <b>"HandleStack"</b>
       Creates delegations named like "things_is_empty", "things_size", "things_push", "things_pop", and
       "things_peek".

</pre><h4><b>EXTENDED</b> <b>EXAMPLES</b></h4><pre>
   <b>Using</b> <b>for_each</b>
         use strict;
         use warnings;

         package My::Plugin {
           use Moo::Role;
           sub initialize {}
           sub finalize {}
         }

         package My::Processor {
           use Moo;
           use Sub::HandlesVia;
           use Types::Standard qw( ArrayRef ConsumerOf );

           has plugins =&gt; (
             is =&gt; 'ro',
             isa =&gt; ArrayRef[ ConsumerOf['My::Plugin'] ],
             handles_via =&gt; 'Array',
             handles =&gt; {
               add_plugin =&gt; 'push',
               plugin_do =&gt; 'for_each',
             },
             default =&gt; sub { [] },
           );

           sub _do_stuff {
             return;
           }

           sub run_process {
             my ( $self, @args ) = @_;
             $self-&gt;plugin_do( sub {
               my $plugin = shift;
               $plugin-&gt;initialize( $self, @args );
             } );
             $self-&gt;_do_stuff( @args );
             $self-&gt;plugin_do( sub {
               my $plugin = shift;
               $plugin-&gt;finalize( $self, @args );
             } );
           }
         }

         my $p = My::Processor-&gt;new();

         package My::Plugin::Noisy {
           use Moo; with 'My::Plugin';
           sub initialize {
             my ( $self, $processor, @args ) = @_;
             say "initialize @args"; ## ==&gt; 'initialize 1 2 3'
           }
           sub finalize {
             my ( $self, $processor, @args ) = @_;
             say "finalize @args"; ## ==&gt; 'finalize 1 2 3'
           }
         }

         $p-&gt;add_plugin( My::Plugin::Noisy-&gt;new );

         $p-&gt;run_process( 1, 2, 3 );

   <b>Job</b> <b>queue</b> <b>using</b> <b>push</b> <b>and</b> <b>shift</b>
         use strict;
         use warnings;
         use Try::Tiny;

         package My::JobQueue {
           use Moo;
           use Sub::HandlesVia;
           use Types::Standard qw( Bool ArrayRef CodeRef HasMethods is_Object );
           use Try::Tiny;

           has auto_requeue =&gt; (
             is =&gt; 'ro',
             isa =&gt; Bool,
             default =&gt; 0,
           );

           has jobs =&gt; (
             is =&gt; 'ro',
             isa =&gt; ArrayRef[ CodeRef | HasMethods['run'] ],
             handles_via =&gt; 'Array',
             handles =&gt; {
               add_job =&gt; 'push',
               _get_job =&gt; 'shift',
               is_empty =&gt; 'is_empty',
             },
             default =&gt; sub { [] },
           );

           sub _handle_failed_job {
             my ( $self, $job ) = @_;
             $self-&gt;add_job( $job ) if $self-&gt;auto_requeue;
           }

           sub run_jobs {
             my $self = shift;
             while ( not $self-&gt;is_empty ) {
               my $job = $self-&gt;_get_job;
               try {
                 is_Object($job) ? $job-&gt;run() : $job-&gt;();
               }
               catch {
                 $self-&gt;_handle_failed_job( $job );
               };
             }
           }
         }

         my $q = My::JobQueue-&gt;new();

         my $str = '';
         $q-&gt;add_job( sub { $str .= 'A' } );
         $q-&gt;add_job( sub { $str .= 'B' } );
         $q-&gt;add_job( sub { $str .= 'C' } );

         $q-&gt;run_jobs;

         say $str; ## ==&gt; 'ABC'

         # Attempt to push invalid value on the queue
         #
         try {
           $q-&gt;add_job( "jobs cannot be strings" );
         }
         catch {
           say $q-&gt;is_empty;  ## ==&gt; true
         };

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs to &lt;https://github.com/tobyink/p5-sub-handlesvia/issues&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Sub::HandlesVia.

</pre><h4><b>AUTHOR</b></h4><pre>
       Toby Inkster &lt;<a href="mailto:tobyink@cpan.org">tobyink@cpan.org</a>&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2020, 2022 by Toby Inkster.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTIES</b></h4><pre>
       THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
       LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

perl v5.40.1                                       2025-04-01             <u>Sub::HandlesVia...rLibrary::<a href="../man3pm/Array.3pm.html">Array</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>