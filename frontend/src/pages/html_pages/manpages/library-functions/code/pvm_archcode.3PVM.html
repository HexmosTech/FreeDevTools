<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pvm_archcode - Returns the data representation code for a PVM architecture name.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/pvm-dev">pvm-dev_3.4.6-3.2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pvm_archcode - Returns the data representation code for a PVM architecture name.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>C</b>    <b>int</b> <b>cod</b> <b>=</b> <b>pvm_archcode(</b> <b>char</b> <b>*arch</b> <b>)</b>

       <b>Fortran</b>   <b>call</b> <b>pvmfarchcode(</b> <b>arch,</b> <b>cod</b> <b>)</b>

</pre><h4><b>PARAMETERS</b></h4><pre>
       arch    Character string containing the architecture name.

       cod     Integer returning architecture code.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  routine  <u>pvm_archcode</u>  returns  an integer given an architecture name.  The code returned identifies
       machines with compatible binary data formats.  For example, SUN4 and RS6K have the same code, while ALPHA
       has a different one (because a few datatypes have different sizes).  This lets you know when you can  get
       away  with  using  <u>PvmDataRaw</u>  instead  of  <u>PvmDataDefault</u> encoding to pass messages between tasks on two
       machines.

       Naturally, you shouldn't assume the values returned by pvm_archcode are etched in stone; the numbers have
       no intrinsic meaning except that if two  different  arch  names  map  to  the  same  value  then  they're
       compatible.

       This routine is actually obsolete in the sense that the architecture codes returned are already available
       in  the  <u>hi_dsig</u>  field  of  the  pvmhostinfo  structure  returned by pvm_config(), as shown in the below
       example.  The routine is maintained for backwards compatibility only.

</pre><h4><b>EXAMPLES</b></h4><pre>
       C:
            struct pvmhostinfo *hip;
            int i;

            pvm_config((int *)0, (int *)0, &amp;hip);
            i = pvm_archcode(hip[0].hi_arch);

            /* or you could just do:  i = hip[0].hi_dsig;  */

       Fortran:
            CALL PVMFARCHCODE( 'RS6K', k )

</pre><h4><b>ERRORS</b></h4><pre>
       On success, <u>pvm_archcode</u> returns a positive integer data signature.

       The following error conditions can be returned as well:

       PvmBadParam
              giving an invalid architecture name.

       PvmNotFound
              there is no host with the given architecture name in the current virtual machine configuration.

       PvmSysErr
              pvmd not responding.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3PVM/pvm_config.3PVM.html">pvm_config</a>(3PVM), <a href="../man3PVM/pvm_initsend.3PVM.html">pvm_initsend</a>(3PVM), <a href="../man3PVM/pvm_notify.3PVM.html">pvm_notify</a>(3PVM), <a href="../man3PVM/pvm_tasks.3PVM.html">pvm_tasks</a>(3PVM), <a href="../man3PVM/pvm_tidtohost.3PVM.html">pvm_tidtohost</a>(3PVM)

                                                 15 March, 1994                                   <u><a href="../man3PVM/ARCHCODE.3PVM.html">ARCHCODE</a></u>(3PVM)
</pre>
 </div>
</div></section>
</div>
</body>
</html>