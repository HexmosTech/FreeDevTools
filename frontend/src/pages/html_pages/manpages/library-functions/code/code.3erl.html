<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>code - Erlang code server.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       code - Erlang code server.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  contains  the interface to the Erlang <u>code</u> <u>server</u>, which deals with the loading of compiled
       code into a running Erlang runtime system.

       The runtime system can be started in <u>interactive</u> or <u>embedded</u> mode. Which one is decided by  the  command-
       line flag <u>-mode</u>:

       % erl -mode interactive

       The modes are as follows:

         * In  interactive mode, which is default, only some code is loaded during system startup, basically the
           modules needed by the runtime system. Other code is dynamically loaded when first referenced. When  a
           call  to  a  function  in  a  certain  module  is made, and the module is not loaded, the code server
           searches for and tries to load the module.

         * In embedded mode, modules are not auto loaded. Trying to use  a  module  that  has  not  been  loaded
           results  in  an  error.  This  mode  is  recommended when the boot script loads all modules, as it is
           typically done in OTP releases. (Code can still be loaded  later  by  explicitly  ordering  the  code
           server to do so).

       To  prevent  accidentally  reloading  of modules affecting the Erlang runtime system, directories <u>kernel</u>,
       <u>stdlib</u>, and <u>compiler</u> are considered <u>sticky</u>. This means that the system issues a warning and  rejects  the
       request  if a user tries to reload a module residing in any of them. The feature can be disabled by using
       command-line flag <u>-nostick</u>.

</pre><h4><b>CODE</b> <b>PATH</b></h4><pre>
       In interactive mode, the code server maintains a search path, usually called the <u>code</u> <u>path</u>, consisting of
       a list of directories, which it searches sequentially when trying to load a module.

       Initially, the code path consists of the current working directory and all Erlang object code directories
       under library directory <u>$OTPROOT/lib</u>,  where  <u>$OTPROOT</u>  is  the  installation  directory  of  Erlang/OTP,
       <u>code:root_dir()</u>.  Directories  can  be  named  <u>Name[-Vsn]</u>  and  the  code server, by default, chooses the
       directory with the highest version number among those having the same <u>Name</u>. Suffix <u>-Vsn</u> is  optional.  If
       an <u>ebin</u> directory exists under <u>Name[-Vsn]</u>, this directory is added to the code path.

       Environment  variable  <u>ERL_LIBS</u>  (defined  in  the  operating  system) can be used to define more library
       directories to be handled in the same way as the standard OTP library directory described  above,  except
       that directories without an <u>ebin</u> directory are ignored.

       All  application  directories  found  in  the  additional  directories  appear  before  the  standard OTP
       applications, except for the Kernel and STDLIB applications,  which  are  placed  before  any  additional
       applications. In other words, modules found in any of the additional library directories override modules
       with the same name in OTP, except for modules in Kernel and STDLIB.

       Environment  variable  <u>ERL_LIBS</u>  (if  defined) is to contain a colon-separated (for Unix-like systems) or
       semicolon-separated (for Windows) list of additional libraries.

       <u>Example:</u>

       On a Unix-like system, <u>ERL_LIBS</u> can be set to the following

       /usr/local/jungerl:/home/some_user/my_erlang_lib

       On Windows, use semi-colon as separator.

</pre><h4><b>LOADING</b> <b>OF</b> <b>CODE</b> <b>FROM</b> <b>ARCHIVE</b> <b>FILES</b></h4><pre>
   <b>Warning:</b>
       The support for loading code from archive files is experimental. The purpose of releasing it before it is
       ready is to obtain early feedback. The file format, semantics, interfaces, and so on, can be changed in a
       future release. The function <u>lib_dir/2</u> and flag <u>-code_path_choice</u> are also experimental.

       The Erlang archives are <u>ZIP</u> files with extension <u>.ez</u>. Erlang archives can also  be  enclosed  in  <u>escript</u>
       files whose file extension is arbitrary.

       Erlang archive files can contain entire Erlang applications or parts of applications. The structure in an
       archive  file  is  the same as the directory structure for an application. If you, for example, create an
       archive of <u>mnesia-4.4.7</u>, the archive file must be  named  <u>mnesia-4.4.7.ez</u>  and  it  must  contain  a  top
       directory  named <u>mnesia-4.4.7</u>. If the version part of the name is omitted, it must also be omitted in the
       archive. That is, a <u>mnesia.ez</u> archive must contain a <u>mnesia</u> top directory.

       An archive file for an application can, for example, be created like this:

       zip:create("mnesia-4.4.7.ez",
            ["mnesia-4.4.7"],
            [{cwd, code:lib_dir()},
             {compress, all},
             {uncompress,[".beam",".app"]}]).

       Any file in the archive can be compressed, but to speed up the access of frequently read files, it can be
       a good idea to store <u>beam</u> and <u>app</u> files uncompressed in the archive.

       Normally the top directory of an application is  located  in  library  directory  <u>$OTPROOT/lib</u>  or  in  a
       directory  referred  to  by  environment  variable  <u>ERL_LIBS</u>.  At  startup, when the initial code path is
       computed, the code server also looks for archive files  in  these  directories  and  possibly  adds  <u>ebin</u>
       directories in archives to the code path. The code path then contains paths to directories that look like
       <u>$OTPROOT/lib/mnesia.ez/mnesia/ebin</u> or <u>$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin</u>.

       The code server uses module <u>erl_prim_loader</u> in ERTS (possibly through <u>erl_boot_server</u>) to read code files
       from  archives.  However, the functions in <u>erl_prim_loader</u> can also be used by other applications to read
       files      from      archives.      For      example,      the       call       <u>erl_prim_loader:list_dir(</u>
       <u>"/otp/root/lib/mnesia-4.4.7.ez/mnesia-4.4.7/examples/bench)"</u>  would  list  the  contents  of  a directory
       inside an archive. See <u><a href="../man3erl/erl_prim_loader.3erl.html">erl_prim_loader</a>(3erl)</u>.

       An application archive file and a regular application directory can coexist. This can be useful  when  it
       is  needed to have parts of the application as regular files. A typical case is the <u>priv</u> directory, which
       must reside as a regular directory to link in drivers dynamically and  start  port  programs.  For  other
       applications  that  do  not  need  this, directory <u>priv</u> can reside in the archive and the files under the
       directory <u>priv</u> can be read through <u>erl_prim_loader</u>.

       When a directory is added to the code path and when the entire code path  is  (re)set,  the  code  server
       decides which subdirectories in an application that are to be read from the archive and which that are to
       be read as regular files. If directories are added or removed afterwards, the file access can fail if the
       code  path  is  not  updated  (possibly  to  the same path as before, to trigger the directory resolution
       update).

       For each directory on the second level in the application archive (<u>ebin</u>, <u>priv</u>, <u>src</u>, and so on), the  code
       server  first  chooses  the  regular  directory  if  it  exists  and  second  from  the archive. Function
       <u>code:lib_dir/2</u> returns the path to the subdirectory. For example,  <u>code:lib_dir(megaco,ebin)</u>  can  return
       <u>/otp/root/lib/megaco-3.9.1.1.ez/megaco-3.9.1.1/ebin</u>    while    <u>code:lib_dir(megaco,priv)</u>    can   return
       <u>/otp/root/lib/megaco-3.9.1.1/priv</u>.

       When an <u>escript</u> file contains an archive, there are no restrictions on the name of  the  <u>escript</u>  and  no
       restrictions  on  how many applications that can be stored in the embedded archive. Single Beam files can
       also reside on the top level in the archive. At startup, the top directory in the  embedded  archive  and
       all  (second  level)  <u>ebin</u>  directories  in  the  embedded  archive  are  added  to  the  code  path. See
       <u>erts:<a href="../man1/escript.1.html">escript</a>(1)</u>.

       When the choice of directories in the code path is <u>strict</u>, the directory that ends up in the code path is
       exactly the stated one. This means that if, for example, the directory <u>$OTPROOT/lib/mnesia-4.4.7/ebin</u>  is
       explicitly    added    to    the    code   path,   the   code   server   does   not   load   files   from
       <u>$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin</u>.

       This behavior can be controlled through command-line flag <u>-code_path_choice</u> <u>Choice</u>. If the flag is set to
       <u>relaxed</u>, the code server instead chooses a suitable directory depending on the actual file structure.  If
       a  regular  application <u>ebin</u> directory exists, it is chosen. Otherwise, the directory <u>ebin</u> in the archive
       is chosen if it exists. If neither of them exists, the original directory is chosen.

       Command-line flag <u>-code_path_choice</u> <u>Choice</u> also affects how module <u>init</u> interprets the <u>boot</u>  <u>script</u>.  The
       interpretation of the explicit code paths in the <u>boot</u> <u>script</u> can be <u>strict</u> or <u>relaxed</u>. It is particularly
       useful  to  set  the flag to <u>relaxed</u> when elaborating with code loading from archives without editing the
       <u>boot</u> <u>script</u>. The default is <u>relaxed</u>. See <u>erts:<a href="../man3erl/init.3erl.html">init</a>(3erl)</u>.

</pre><h4><b>CURRENT</b> <b>AND</b> <b>OLD</b> <b>CODE</b></h4><pre>
       The code for a module can exist in two variants in a system: <u>current</u> <u>code</u> and <u>old</u> <u>code</u>. When a module  is
       loaded  into the system for the first time, the module code becomes 'current' and the global <u>export</u> <u>table</u>
       is updated with references to all functions exported from the module.

       If then a new instance of the module is loaded (for example, because of error correction),  the  code  of
       the  previous  instance  becomes  'old',  and  all  export entries referring to the previous instance are
       removed. After that, the new instance is loaded as for the first time, and becomes 'current'.

       Both old and current code for a module are valid, and can even be evaluated concurrently. The  difference
       is  that  exported  functions  in  old  code  are  unavailable. Hence, a global call cannot be made to an
       exported function in old code, but old code can still be evaluated because of processes lingering in it.

       If a third instance of the module is loaded, the code server  removes  (purges)  the  old  code  and  any
       processes  lingering  in  it are terminated. Then the third instance becomes 'current' and the previously
       current code becomes 'old'.

       For more information about old and current code, and how to make a process switch  from  old  to  current
       code, see section Compilation and Code Loading in the Erlang Reference Manual.

</pre><h4><b>ARGUMENT</b> <b>TYPES</b> <b>AND</b> <b>INVALID</b> <b>ARGUMENTS</b></h4><pre>
       Module  and  application  names  are  atoms,  while  file  and  directory names are strings. For backward
       compatibility reasons, some functions accept both strings and atoms, but a future release  will  probably
       only allow the arguments that are documented.

       Functions  in  this  module  generally  fail  with an exception if they are passed an incorrect type (for
       example, an integer or a tuple where an atom is expected). An error tuple is  returned  if  the  argument
       type  is  correct, but there are some other errors (for example, a non-existing directory is specified to
       <u>set_path/1</u>).

</pre><h4><b>ERROR</b> <b>REASONS</b> <b>FOR</b> <b>CODE-LOADING</b> <b>FUNCTIONS</b></h4><pre>
       Functions that load code (such as <u>load_file/1</u>) will return <u>{error,Reason}</u> if the  load  operation  fails.
       Here follows a description of the common reasons.

         <u>badfile</u>:
           The  object  code  has  an incorrect format or the module name in the object code is not the expected
           module name.

         <u>nofile</u>:
           No file with object code was found.

         <u>not_purged</u>:
           The object code could not be loaded because an old version of the code already existed.

         <u>on_load_failure</u>:
           The module has an -on_load function that failed when it was called.

         <u>sticky_directory</u>:
           The object code resides in a sticky directory.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>load_ret()</b> =
           {error, What :: load_error_rsn()} |
           {module, Module :: module()}

       <b>load_error_rsn()</b> =
           badfile | nofile | not_purged | on_load_failure |
           sticky_directory

       <b>module_status()</b> = not_loaded | loaded | modified | removed

       <b>prepared_code()</b>

              An opaque term holding prepared code.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>set_path(Path)</b> <b>-&gt;</b> <b>true</b> <b>|</b> <b>{error,</b> <b>What}</b>

              Types:

                 Path = [Dir :: file:filename()]
                 What = bad_directory

              Sets the code path to the list of directories <u>Path</u>.

              Returns:

                <u>true</u>:
                  If successful

                <u>{error,</u> <u>bad_directory}</u>:
                  If any <u>Dir</u> is not a directory name

       <b>get_path()</b> <b>-&gt;</b> <b>Path</b>

              Types:

                 Path = [Dir :: file:filename()]

              Returns the code path.

       <b>add_path(Dir)</b> <b>-&gt;</b> <b>add_path_ret()</b>

       <b>add_pathz(Dir)</b> <b>-&gt;</b> <b>add_path_ret()</b>

              Types:

                 Dir = file:filename()
                 <b>add_path_ret()</b> = true | {error, bad_directory}

              Adds <u>Dir</u> to the code path. The directory is added as the last directory in the new  path.  If  <u>Dir</u>
              already exists in the path, it is not added.

              Returns <u>true</u> if successful, or <u>{error,</u> <u>bad_directory}</u> if <u>Dir</u> is not the name of a directory.

       <b>add_patha(Dir)</b> <b>-&gt;</b> <b>add_path_ret()</b>

              Types:

                 Dir = file:filename()
                 <b>add_path_ret()</b> = true | {error, bad_directory}

              Adds  <u>Dir</u> to the beginning of the code path. If <u>Dir</u> exists, it is removed from the old position in
              the code path.

              Returns <u>true</u> if successful, or <u>{error,</u> <u>bad_directory}</u> if <u>Dir</u> is not the name of a directory.

       <b>add_paths(Dirs)</b> <b>-&gt;</b> <b>ok</b>

       <b>add_pathsz(Dirs)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Dirs = [Dir :: file:filename()]

              Adds the directories in <u>Dirs</u> to the end of the code path. If a <u>Dir</u> exists, it is not added.

              Always returns <u>ok</u>, regardless of the validity of each individual <u>Dir</u>.

       <b>add_pathsa(Dirs)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Dirs = [Dir :: file:filename()]

              Traverses <u>Dirs</u> and adds each <u>Dir</u> to the beginning of the code path. This means that the  order  of
              <u>Dirs</u>  is  reversed  in the resulting code path. For example, if you add <u>[Dir1,Dir2]</u>, the resulting
              path will be <u>[Dir2,Dir1|OldCodePath]</u>.

              If a <u>Dir</u> already exists in the code path, it is removed from the old position.

              Always returns <u>ok</u>, regardless of the validity of each individual <u>Dir</u>.

       <b>del_path(NameOrDir)</b> <b>-&gt;</b> <b>boolean()</b> <b>|</b> <b>{error,</b> <b>What}</b>

              Types:

                 NameOrDir = Name | Dir
                 Name = atom()
                 Dir = file:filename()
                 What = bad_name

              Deletes a directory from the code path. The argument can be  an  atom  <u>Name</u>,  in  which  case  the
              directory  with  the  name <u>.../Name[-Vsn][/ebin]</u> is deleted from the code path. Also, the complete
              directory name <u>Dir</u> can be specified as argument.

              Returns:

                <u>true</u>:
                  If successful

                <u>false</u>:
                  If the directory is not found

                <u>{error,</u> <u>bad_name}</u>:
                  If the argument is invalid

       <b>replace_path(Name,</b> <b>Dir)</b> <b>-&gt;</b> <b>true</b> <b>|</b> <b>{error,</b> <b>What}</b>

              Types:

                 Name = atom()
                 Dir = file:filename()
                 What = bad_directory | bad_name | {badarg, term()}

              Replaces an old occurrence of a directory named <u>.../Name[-Vsn][/ebin]</u> in the code path, with  <u>Dir</u>.
              If  <u>Name</u>  does  not  exist, it adds the new directory <u>Dir</u> last in the code path. The new directory
              must also be named <u>.../Name[-Vsn][/ebin]</u>. This function is to be used if  a  new  version  of  the
              directory (library) is added to a running system.

              Returns:

                <u>true</u>:
                  If successful

                <u>{error,</u> <u>bad_name}</u>:
                  If <u>Name</u> is not found

                <u>{error,</u> <u>bad_directory}</u>:
                  If <u>Dir</u> does not exist

                <u>{error,</u> <u>{badarg,</u> <u>[Name,</u> <u>Dir]}}</u>:
                  If <u>Name</u> or <u>Dir</u> is invalid

       <b>load_file(Module)</b> <b>-&gt;</b> <b>load_ret()</b>

              Types:

                 Module = module()
                 <b>load_ret()</b> =
                     {error, What :: load_error_rsn()} |
                     {module, Module :: module()}

              Tries  to  load  the  Erlang module <u>Module</u>, using the code path. It looks for the object code file
              with an extension corresponding to the Erlang machine used, for example, <u>Module.beam</u>. The  loading
              fails if the module name found in the object code differs from the name <u>Module</u>. <u>load_binary/3</u> must
              be used to load object code with a module name that is different from the file name.

              Returns <u>{module,</u> <u>Module}</u> if successful, or <u>{error,</u> <u>Reason}</u> if loading fails. See Error Reasons for
              Code-Loading Functions for a description of the possible error reasons.

       <b>load_abs(Filename)</b> <b>-&gt;</b> <b>load_ret()</b>

              Types:

                 Filename = file:filename()
                 <b>load_ret()</b> =
                     {error, What :: load_error_rsn()} |
                     {module, Module :: module()}
                 <b>loaded_filename()</b> =
                     (Filename :: file:filename()) | loaded_ret_atoms()
                 <b>loaded_ret_atoms()</b> = cover_compiled | preloaded

              Same  as <u>load_file(Module)</u>, but <u>Filename</u> is an absolute or relative filename. The code path is not
              searched. It returns a value in the same way as <u>load_file/1</u>. Notice that <u>Filename</u> must not contain
              the extension (for example, <u>.beam</u>) because <u>load_abs/1</u> adds the correct extension.

       <b>ensure_loaded(Module)</b> <b>-&gt;</b> <b>{module,</b> <b>Module}</b> <b>|</b> <b>{error,</b> <b>What}</b>

              Types:

                 Module = module()
                 What = embedded | badfile | nofile | on_load_failure

              Tries to load a module in the same way as  <u>load_file/1</u>,  unless  the  module  is  already  loaded.
              However,  in  embedded  mode  it  does  not  load a module that is not already loaded, but returns
              <u>{error,</u> <u>embedded}</u> instead. See Error Reasons for Code-Loading Functions for a description of other
              possible error reasons.

       <b>load_binary(Module,</b> <b>Filename,</b> <b>Binary)</b> <b>-&gt;</b>
                      {module, Module} | {error, What}

              Types:

                 Module = module()
                 Filename = loaded_filename()
                 Binary = binary()
                 What = badarg | load_error_rsn()
                 <b>loaded_filename()</b> =
                     (Filename :: file:filename()) | loaded_ret_atoms()
                 <b>loaded_ret_atoms()</b> = cover_compiled | preloaded

              This function can be used to load object code on remote Erlang nodes. Argument <u>Binary</u> must contain
              object code for <u>Module</u>. <u>Filename</u> is only used by the code server to keep a record  of  from  which
              file the object code for <u>Module</u> comes. Thus, <u>Filename</u> is not opened and read by the code server.

              Returns <u>{module,</u> <u>Module}</u> if successful, or <u>{error,</u> <u>Reason}</u> if loading fails. See Error Reasons for
              Code-Loading Functions for a description of the possible error reasons.

       <b>atomic_load(Modules)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>[{Module,</b> <b>What}]}</b>

              Types:

                 Modules = [Module | {Module, Filename, Binary}]
                 Module = module()
                 Filename = file:filename()
                 Binary = binary()
                 What =
                     badfile | nofile | on_load_not_allowed | duplicated |
                     not_purged | sticky_directory | pending_on_load

              Tries  to  load  all  of  the  modules  in the list <u>Modules</u> atomically. That means that either all
              modules are loaded at the same time, or none of the modules are loaded if there is a problem  with
              any of the modules.

              Loading can fail for one the following reasons:

                <u>badfile</u>:
                  The  object  code  has  an  incorrect  format or the module name in the object code is not the
                  expected module name.

                <u>nofile</u>:
                  No file with object code exists.

                <u>on_load_not_allowed</u>:
                  A module contains an -on_load function.

                <u>duplicated</u>:
                  A module is included more than once in <u>Modules</u>.

                <u>not_purged</u>:
                  The object code cannot be loaded because an old version of the code already exists.

                <u>sticky_directory</u>:
                  The object code resides in a sticky directory.

                <u>pending_on_load</u>:
                  A previously loaded module contains an <u>-on_load</u> function that never finished.

              If it is important to minimize the time that an application is inactive while changing  code,  use
              prepare_loading/1 and finish_loading/1 instead of <u>atomic_load/1</u>. Here is an example:

              {ok,Prepared} = code:prepare_loading(Modules),
              %% Put the application into an inactive state or do any
              %% other preparation needed before changing the code.
              ok = code:finish_loading(Prepared),
              %% Resume the application.

       <b>prepare_loading(Modules)</b> <b>-&gt;</b>
                          {ok, Prepared} | {error, [{Module, What}]}

              Types:

                 Modules = [Module | {Module, Filename, Binary}]
                 Module = module()
                 Filename = file:filename()
                 Binary = binary()
                 Prepared = prepared_code()
                 What = badfile | nofile | on_load_not_allowed | duplicated

              Prepares   to   load   the   modules   in   the  list  <u>Modules</u>.  Finish  the  loading  by  calling
              finish_loading(Prepared).

              This function can fail with one of the following error reasons:

                <u>badfile</u>:
                  The object code has an incorrect format or the module name in  the  object  code  is  not  the
                  expected module name.

                <u>nofile</u>:
                  No file with object code exists.

                <u>on_load_not_allowed</u>:
                  A module contains an -on_load function.

                <u>duplicated</u>:
                  A module is included more than once in <u>Modules</u>.

       <b>finish_loading(Prepared)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>[{Module,</b> <b>What}]}</b>

              Types:

                 Prepared = prepared_code()
                 Module = module()
                 What = not_purged | sticky_directory | pending_on_load

              Tries  to  load  code for all modules that have been previously prepared by prepare_loading/1. The
              loading occurs atomically, meaning that either all modules are loaded at the same time, or none of
              the modules are loaded.

              This function can fail with one of the following error reasons:

                <u>not_purged</u>:
                  The object code cannot be loaded because an old version of the code already exists.

                <u>sticky_directory</u>:
                  The object code resides in a sticky directory.

                <u>pending_on_load</u>:
                  A previously loaded module contains an <u>-on_load</u> function that never finished.

       <b>ensure_modules_loaded(Modules</b> <b>::</b> <b>[Module])</b> <b>-&gt;</b>
                                ok | {error, [{Module, What}]}

              Types:

                 Module = module()
                 What = badfile | nofile | on_load_failure

              Tries to load any modules not already loaded in the list <u>Modules</u> in the same way as load_file/1.

              Returns <u>ok</u> if successful, or <u>{error,[{Module,Reason}]}</u> if loading of some modules fails. See Error
              Reasons for Code-Loading Functions for a description of other possible error reasons.

       <b>delete(Module)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Module = module()

              Removes the current code for <u>Module</u>, that is, the current code for <u>Module</u> is made old. This  means
              that  processes can continue to execute the code in the module, but no external function calls can
              be made to it.

              Returns <u>true</u> if successful, or <u>false</u> if there is old code for <u>Module</u> that must be purged first, or
              if <u>Module</u> is not a (loaded) module.

       <b>purge(Module)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Module = module()

              Purges the code for <u>Module</u>, that is, removes code marked as old. If some processes still linger in
              the old code, these processes are killed before the code is removed.

          <b>Note:</b>
              As of ERTS version 9.0, a process is only considered to be lingering in the code if it has  direct
              references  to  the  code.  For more information see documentation of <u>erlang:check_process_code/3</u>,
              which is used in order to determine this.

              Returns <u>true</u> if successful and any process is needed to be killed, otherwise <u>false</u>.

       <b>soft_purge(Module)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Module = module()

              Purges the code for <u>Module</u>, that is, removes code marked as old, but only if no  processes  linger
              in it.

          <b>Note:</b>
              As  of ERTS version 9.0, a process is only considered to be lingering in the code if it has direct
              references to the code. For more information  see  documentation  of  <u>erlang:check_process_code/3</u>,
              which is used in order to determine this.

              Returns <u>false</u> if the module cannot be purged because of processes lingering in old code, otherwise
              <u>true</u>.

       <b>is_loaded(Module)</b> <b>-&gt;</b> <b>{file,</b> <b>Loaded}</b> <b>|</b> <b>false</b>

              Types:

                 Module = module()
                 Loaded = loaded_filename()
                 <b>loaded_filename()</b> =
                     (Filename :: file:filename()) | loaded_ret_atoms()
                   <u>Filename</u> is an absolute filename.
                 <b>loaded_ret_atoms()</b> = cover_compiled | preloaded

              Checks if <u>Module</u> is loaded. If it is, <u>{file,</u> <u>Loaded}</u> is returned, otherwise <u>false</u>.

              Normally,  <u>Loaded</u> is the absolute filename <u>Filename</u> from which the code is obtained. If the module
              is  preloaded  (see  <u><a href="../man5/script.5.html">script</a>(5)</u>),  <u>Loaded==preloaded</u>.  If  the  module   is   Cover-compiled   (see
              <u><a href="../man3erl/cover.3erl.html">cover</a>(3erl)</u>), <u>Loaded==cover_compiled</u>.

       <b>all_available()</b> <b>-&gt;</b> <b>[{Module,</b> <b>Filename,</b> <b>Loaded}]</b>

              Types:

                 Module = string()
                 Filename = loaded_filename()
                 Loaded = boolean()
                 <b>loaded_filename()</b> =
                     (Filename :: file:filename()) | loaded_ret_atoms()
                   <u>Filename</u> is an absolute filename.
                 <b>loaded_ret_atoms()</b> = cover_compiled | preloaded

              Returns  a  list  of  tuples  <u>{Module,</u>  <u>Filename,</u>  <u>Loaded}</u>  for all available modules. A module is
              considered to be available if it either is loaded or  would  be  loaded  if  called.  <u>Filename</u>  is
              normally the absolute filename, as described for <u>is_loaded/1</u>.

       <b>all_loaded()</b> <b>-&gt;</b> <b>[{Module,</b> <b>Loaded}]</b>

              Types:

                 Module = module()
                 Loaded = loaded_filename()
                 <b>loaded_filename()</b> =
                     (Filename :: file:filename()) | loaded_ret_atoms()
                   <u>Filename</u> is an absolute filename.
                 <b>loaded_ret_atoms()</b> = cover_compiled | preloaded

              Returns  a list of tuples <u>{Module,</u> <u>Loaded}</u> for all loaded modules. <u>Loaded</u> is normally the absolute
              filename, as described for <u>is_loaded/1</u>.

       <b>which(Module)</b> <b>-&gt;</b> <b>Which</b>

              Types:

                 Module = module()
                 Which = loaded_filename() | non_existing
                 <b>loaded_filename()</b> =
                     (Filename :: file:filename()) | loaded_ret_atoms()
                 <b>loaded_ret_atoms()</b> = cover_compiled | preloaded

              If the module is not loaded, this function searches the code path for the  first  file  containing
              object code for <u>Module</u> and returns the absolute filename.

              If the module is loaded, it returns the name of the file containing the loaded object code.

              If the module is preloaded, <u>preloaded</u> is returned.

              If the module is Cover-compiled, <u>cover_compiled</u> is returned.

              If the module cannot be found, <u>non_existing</u> is returned.

       <b>get_object_code(Module)</b> <b>-&gt;</b> <b>{Module,</b> <b>Binary,</b> <b>Filename}</b> <b>|</b> <b>error</b>

              Types:

                 Module = module()
                 Binary = binary()
                 Filename = file:filename()

              Searches the code path for the object code of module <u>Module</u>. Returns <u>{Module,</u> <u>Binary,</u> <u>Filename}</u> if
              successful,  otherwise  <u>error</u>.  <u>Binary</u> is a binary data object, which contains the object code for
              the module. This can be useful if code is to be loaded on a remote node in a  distributed  system.
              For example, loading module <u>Module</u> on a node <u>Node</u> is done as follows:

              ...
              {_Module, Binary, Filename} = code:get_object_code(Module),
              rpc:call(Node, code, load_binary, [Module, Filename, Binary]),
              ...

       <b>get_doc(Mod)</b> <b>-&gt;</b> <b>{ok,</b> <b>Res}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Mod = module()
                 Res = #docs_v1{}
                 Reason = non_existing | missing | file:posix()

              Searches  the  code  path  for  EEP-48  style  documentation  and  returns  it if available. If no
              documentation can be found the function tries to generate documentation from the debug information
              in the module. If no debug information is available, this function will return <u>{error,missing}</u>.

              For more information about the  documentation  chunk  see  Documentation  Storage  and  Format  in
              Kernel's User's Guide.

       <b>root_dir()</b> <b>-&gt;</b> <b>file:filename()</b>

              Returns the root directory of Erlang/OTP, which is the directory where it is installed.

              <u>Example:</u>

              &gt; code:root_dir().
              "/usr/local/otp"

       <b>lib_dir()</b> <b>-&gt;</b> <b>file:filename()</b>

              Returns the library directory, <u>$OTPROOT/lib</u>, where <u>$OTPROOT</u> is the root directory of Erlang/OTP.

              <u>Example:</u>

              &gt; code:lib_dir().
              "/usr/local/otp/lib"

       <b>lib_dir(Name)</b> <b>-&gt;</b> <b>file:filename()</b> <b>|</b> <b>{error,</b> <b>bad_name}</b>

              Types:

                 Name = atom()

              Returns  the  path for the "library directory", the top directory, for an application <u>Name</u> located
              under <u>$OTPROOT/lib</u> or on a directory referred to with environment variable <u>ERL_LIBS</u>.

              If a regular directory called <u>Name</u> or <u>Name-Vsn</u> exists in the code path with an <u>ebin</u>  subdirectory,
              the path to this directory is returned (not the <u>ebin</u> directory).

              If the directory refers to a directory in an archive, the archive name is stripped away before the
              path  is  returned. For example, if directory <u>/usr/local/otp/lib/mnesia-4.2.2.ez/mnesia-4.2.2/ebin</u>
              is in the path, <u>/usr/local/otp/lib/mnesia-4.2.2/ebin</u> is returned.  This  means  that  the  library
              directory  for  an application is the same, regardless if the application resides in an archive or
              not.

              <u>Example:</u>

              &gt; code:<a href="../manmnesia/lib_dir.mnesia.html">lib_dir</a>(mnesia).
              "/usr/local/otp/lib/mnesia-4.2.2"

              Returns <u>{error,</u> <u>bad_name}</u> if <u>Name</u> is not the name of an application under  <u>$OTPROOT/lib</u>  or  on  a
              directory  referred  to through environment variable <u>ERL_LIBS</u>. Fails with an exception if <u>Name</u> has
              the wrong type.

          <b>Warning:</b>
              For backward compatibility, <u>Name</u> is also allowed to be a string. That will probably  change  in  a
              future release.

       <b>lib_dir(Name,</b> <b>SubDir)</b> <b>-&gt;</b> <b>file:filename()</b> <b>|</b> <b>{error,</b> <b>bad_name}</b>

              Types:

                 Name = SubDir = atom()

              Returns  the  path  to a subdirectory directly under the top directory of an application. Normally
              the subdirectories reside under the top directory for the application, but  when  applications  at
              least  partly  resides  in  an archive, the situation is different. Some of the subdirectories can
              reside as regular directories while other reside in an archive file. It  is  not  checked  whether
              this directory exists.

              <u>Example:</u>

              &gt; code:lib_dir(megaco, priv).
              "/usr/local/otp/lib/megaco-3.9.1.1/priv"

              Fails with an exception if <u>Name</u> or <u>SubDir</u> has the wrong type.

       <b>compiler_dir()</b> <b>-&gt;</b> <b>file:filename()</b>

              Returns the compiler library directory. Equivalent to <u>code:lib_dir(compiler)</u>.

       <b>priv_dir(Name)</b> <b>-&gt;</b> <b>file:filename()</b> <b>|</b> <b>{error,</b> <b>bad_name}</b>

              Types:

                 Name = atom()

              Returns the path to the <u>priv</u> directory in an application. Equivalent to <u>code:lib_dir(Name,</u> <u>priv)</u>.

          <b>Warning:</b>
              For  backward  compatibility,  <u>Name</u> is also allowed to be a string. That will probably change in a
              future release.

       <b>objfile_extension()</b> <b>-&gt;</b> <b>nonempty_string()</b>

              Returns the object code file extension corresponding to the Erlang machine used, namely <u>.beam</u>.

       <b>stick_dir(Dir)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>error</b>

              Types:

                 Dir = file:filename()

              Marks <u>Dir</u> as sticky.

              Returns <u>ok</u> if successful, otherwise <u>error</u>.

       <b>unstick_dir(Dir)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>error</b>

              Types:

                 Dir = file:filename()

              Unsticks a directory that is marked as sticky.

              Returns <u>ok</u> if successful, otherwise <u>error</u>.

       <b>is_sticky(Module)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Module = module()

              Returns <u>true</u> if <u>Module</u> is the name of a module that has been loaded from a  sticky  directory  (in
              other words: an attempt to reload the module will fail), or <u>false</u> if <u>Module</u> is not a loaded module
              or is not sticky.

       <b>where_is_file(Filename)</b> <b>-&gt;</b> <b>non_existing</b> <b>|</b> <b>Absname</b>

              Types:

                 Filename = Absname = file:filename()

              Searches  the  code  path  for  <u>Filename</u>,  a  file  of  arbitrary type. If found, the full name is
              returned. <u>non_existing</u> is returned if the file cannot be found. The function can  be  useful,  for
              example, to locate application resource files.

       <b>clash()</b> <b>-&gt;</b> <b>ok</b>

              Searches  all  directories  in  the  code  path for module names with identical names and writes a
              report to <u>stdout</u>.

       <b>module_status()</b> <b>-&gt;</b> <b>[{module(),</b> <b>module_status()}]</b>

              Types:

                 <b>module_status()</b> = not_loaded | loaded | modified | removed

              See <u>module_status/1</u> and <u>all_loaded/0</u> for details.

       <b>module_status(Module</b> <b>::</b> <b>module()</b> <b>|</b> <b>[module()])</b> <b>-&gt;</b>
                        module_status() | [{module(), module_status()}]

              Types:

                 <b>module_status()</b> = not_loaded | loaded | modified | removed

              The status of a module can be one of:

                <u>not_loaded</u>:
                  If <u>Module</u> is not currently loaded.

                <u>loaded</u>:
                  If <u>Module</u> is loaded and the object file exists and contains the same code.

                <u>removed</u>:
                  If <u>Module</u> is loaded but no corresponding object file can be found in the code path.

                <u>modified</u>:
                  If <u>Module</u> is loaded but the object file contains code with a different MD5 checksum.

              Preloaded modules are always reported as <u>loaded</u>, without inspecting the contents  on  disk.  Cover
              compiled  modules  will  always  be  reported  as <u>modified</u> if an object file exists, or as <u>removed</u>
              otherwise. Modules whose load path is an empty string (which is the convention for  auto-generated
              code) will only be reported as <u>loaded</u> or <u>not_loaded</u>.

              See also <u>modified_modules/0</u>.

       <b>modified_modules()</b> <b>-&gt;</b> <b>[module()]</b>

              Returns  the  list of all currently loaded modules for which <u>module_status/1</u> returns <u>modified</u>. See
              also <u>all_loaded/0</u>.

       <b>is_module_native(Module)</b> <b>-&gt;</b> <b>true</b> <b>|</b> <b>false</b> <b>|</b> <b>undefined</b>

              Types:

                 Module = module()

              Returns <u>false</u> if the given <u>Module</u> is loaded, and <u>undefined</u> if it is not.

          <b>Warning:</b>
              This function is deprecated and will be removed in a future release.

       <b>get_mode()</b> <b>-&gt;</b> <b>embedded</b> <b>|</b> <b>interactive</b>

              Returns an atom describing the mode of the code server: <u>interactive</u> or <u>embedded</u>.

              This information is useful when an external entity (for example, an IDE) provides additional  code
              for  a running node. If the code server is in interactive mode, it only has to add the path to the
              code. If the code server is in embedded mode, the code must be loaded with <u>load_binary/3</u>.

Ericsson AB                                        kernel 8.2                                         <u><a href="../man3erl/code.3erl.html">code</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>