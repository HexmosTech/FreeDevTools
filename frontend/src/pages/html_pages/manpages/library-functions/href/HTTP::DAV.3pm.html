<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP::DAV - A WebDAV client library for Perl5</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhttp-dav-perl">libhttp-dav-perl_0.50-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTTP::DAV - A WebDAV client library for Perl5

</pre><h4><b>SYNOPSIS</b></h4><pre>
          # DAV script that connects to a webserver, safely makes
          # a new directory and uploads all html files in
          # the <a href="file:/tmp">/tmp</a> directory.

          use HTTP::DAV;

          $d = HTTP::DAV-&gt;new();
          $url = "<a href="http://host.org">http://host.org</a>:8080/dav/";

          $d-&gt;credentials(
             -user  =&gt; "pcollins",
             -pass  =&gt; "mypass",
             -url   =&gt; $url,
             -realm =&gt; "DAV Realm"
          );

          $d-&gt;open( -url =&gt; $url )
             or die("Couldn't open $url: " .$d-&gt;message . "\n");

          # Make a null lock on newdir
          $d-&gt;lock( -url =&gt; "$url/newdir", -timeout =&gt; "10m" )
             or die "Won't put unless I can lock for 10 minutes\n";

          # Make a new directory
          $d-&gt;mkcol( -url =&gt; "$url/newdir" )
             or die "Couldn't make newdir at $url\n";

          # Upload multiple files to newdir.
          if ( $d-&gt;put( -local =&gt; "<a href="file:/tmp/">/tmp/</a>*.html", -url =&gt; $url ) ) {
             print "successfully uploaded multiple files to $url\n";
          } else {
             print "put failed: " . $d-&gt;message . "\n";
          }

          $d-&gt;unlock( -url =&gt; $url );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       HTTP::DAV is a Perl API for interacting with and modifying content on webservers using the WebDAV
       protocol. Now you can LOCK, DELETE and PUT files and much more on a DAV-enabled webserver.

       HTTP::DAV is part of the PerlDAV project hosted at <a href="http://www.webdav.org/perldav/">http://www.webdav.org/perldav/</a> and has the following
       features:

       •   Full RFC2518 method support. OPTIONS, TRACE, GET, HEAD, DELETE, PUT, COPY, MOVE, PROPFIND, PROPPATCH,
           LOCK, UNLOCK.

       •   A fully object-oriented API.

       •   Recursive GET and PUT for site backups and other scripted transfers.

       •   Transparent lock handling when performing LOCK/COPY/UNLOCK sequences.

       •   http and https support (https requires the Crypt::SSLeay library). See INSTALLATION.

       •   Basic AND Digest authentication support (Digest auth requires the MD5 library). See INSTALLATION.

       •   "dave",  a  fully-functional  ftp-style  interface written on top of the HTTP::DAV API and bundled by
           default with the HTTP::DAV library. (If you've already installed HTTP::DAV, then dave will also  have
           been  installed (probably into <a href="file:/usr/local/bin">/usr/local/bin</a>). You can see it's man page by typing "perldoc dave" or
           going to <a href="http://www.webdav.org/perldav/dave/">http://www.webdav.org/perldav/dave/</a>.

       •   It is built on top of the popular LWP (Library for WWW access in Perl).  This  means  that  HTTP::DAV
           inherits  proxy  support,  redirect  handling,  basic  (and digest) authorization and many other HTTP
           operations. See "LWP" for more information.

       •   Popular server support. HTTP::DAV has been tested  against  the  following  servers:  mod_dav,  IIS5,
           Xythos  webfile  server and mydocsonline. The library is growing an impressive interoperability suite
           which also serves as useful "sample scripts". See "make test" and t/*.

       "HTTP::DAV" essentially has two API's, one which is accessed through this module directly (HTTP::DAV) and
       is a simple abstraction to the rest of the HTTP::DAV::* Classes. The  other  interface  consists  of  the
       HTTP::DAV::*  classes  which  if  required  allow  you  to  get  "down  and dirty" with your DAV and HTTP
       interactions.

       The methods provided in "HTTP::DAV" should do most of what you want. If, however, you need  more  control
       over  the  client's  operations  or  need  more  info  about the server's responses then you will need to
       understand  the  rest  of  the  HTTP::DAV::*  interfaces.  A  good   place   to   start   is   with   the
       "HTTP::DAV::Resource" and "HTTP::DAV::Response" documentation.

</pre><h4><b>METHODS</b></h4><pre>
   <b>METHOD</b> <b>CALLING:</b> <b>Named</b> <b>vs</b> <b>Unnamed</b> <b>parameters</b>
       You can pass parameters to "HTTP::DAV" methods in one of two ways: named or unnamed.

       Named  parameters  provides  for  a  simpler/easier  to  use  interface.  A  named interface affords more
       readability and allows the developer to ignore a specific order on the parameters. (named parameters  are
       also case insensitive)

       Each  argument  name  is preceded by a dash.  Neither case nor order matters in the argument list.  -url,
       -Url, and -URL are all acceptable.  In fact, only the first argument needs to begin with a  dash.   If  a
       dash is present in the first argument, "HTTP::DAV" assumes dashes for the subsequent ones.

       Each  method can also be called with unnamed parameters which often makes sense for methods with only one
       parameter. But the developer will need to ensure that the parameters are passed in the correct order  (as
       listed in the docs).

        Doc:     method( -url=&gt;$url, [-depth=&gt;$depth] )
        Named:   $d-&gt;method( -url=&gt;$url, -depth=&gt;$d ); # VALID
        Named:   $d-&gt;method( -Depth=&gt;$d, -Url=&gt;$url ); # VALID
        Named:   $d-&gt;method( Depth=&gt;$d,  Url=&gt;$url );  # INVALID (needs -)
        Named:   $d-&gt;method( -Arg2=&gt;$val2 ); # INVALID, ARG1 is not optional
        Unnamed: $d-&gt;method( $val1 );        # VALID
        Unnamed: $d-&gt;method( $val2,$val1 );  # INVALID, ARG1 must come first.

       IMPORTANT  POINT!!!!  If  you  specify  a  named parameter first but then forget for the second and third
       parameters, you WILL get weird things happen. E.g. this is bad:

        $d-&gt;method( -url=&gt;$url, $arg2, $arg3 ); # BAD BAD BAD

   <b>THINGS</b> <b>YOU</b> <b>NEED</b> <b>TO</b> <b>KNOW</b>
       In all of the methods specified in "PUBLIC METHODS"  there  are  some  common  concepts  you'll  need  to
       understand:

       •   URLs represent an absolute or relative URI.

             -url=&gt;"host.org/dav_dir/"  # Absolute
             -url=&gt;"/dav_dir/"          # Relative
             -url=&gt;"file.txt"           # Relative

           You can only use a relative URL if you have already "open"ed an absolute URL.

           The   HTTP::DAV   module   now   consistently   uses   the  named  parameter:  URL.  The  lower-level
           HTTP::DAV::Resource interface inconsistently interchanges URL and URI. I'm working to  resolve  this,
           in  the  meantime, you'll just need to remember to use the right one by checking the documentation if
           you need to mix up your use of both interfaces.

       •   GLOBS

           Some methods accept wildcards in the URL. A wildcard can be used to indicate that the command  should
           perform the command on all Resources that match the wildcard. These wildcards are called GLOBS.

           The glob may contain the characters "*", "?" and the set operator "[...]" where ... contains multiple
           characters  ([1t2])  or  a  range such ([1-5]). For the curious, the glob is converted to a regex and
           then matched: "*" to ".*", "?" to ".", and the [] is left untouched.

           It is important to note that globs only operate at the leaf-level. For instance  "/my_dir/*/file.txt"
           is not a valid glob.

           If a glob matches no URL's the command will fail (which normally means returns 0).

           Globs are useful in conjunction with CALLBACKS to provide feedback as each operation completes.

           See the documentation for each method to determine whether it supports globbing.

           Globs are useful for interactive style applications (see the source code for "dave" as an example).

           Example globs:

              $dav1-&gt;delete(-url=&gt;"/my_dir/file[1-3]");     # Matches file1, file2, file3
              $dav1-&gt;delete(-url=&gt;"/my_dir/file[1-3]*.txt");# Matches file1*.txt,file2*.txt,file3*.txt
              $dav1-&gt;delete(-url=&gt;"/my_dir/*/file.txt");    # Invalid. Can only match at leaf-level

       •   CALLBACKS

           Callbacks  are used by some methods (primarily get and put) to give the caller some insight as to how
           the operation is progressing. A callback allows you to define a subroutine as defined below and  pass
           a reference (\&amp;ref) to the method.

           The  rationale  behind  the  callback  is that a recursive get/put or an operation against many files
           (using a "glob") can actually take a long time to complete.

           Example callback:

              $d-&gt;get( -url=&gt;$url, -to=&gt;$to, -callback=&gt;\&amp;mycallback );

           Your callback function MUST accept arguments as follows:
              sub cat_callback {
                 my($status,$mesg,$url,$so_far,$length,$data) = @_;
                 ...
              }

           The "status" argument specifies whether the operation  has  succeeded  (1),  failed  (0),  or  is  in
           progress (-1).

           The  "mesg"  argument  is  a  status  message.  The status message could contain any string and often
           contains useful error messages or success messages.

           The "url" the remote URL.

           The "so_far", "length" - these parameters indicate how many bytes have been downloaded and  how  many
           we should expect. This is useful for doing "56% to go" style-gauges.

           The  "data" parameter - is the actual data transferred. The "cat" command uses this to print the data
           to the screen. This value will be empty for "put".

           See the source code of "dave" for a useful sample of how to setup a callback.

           Note that these arguments are NOT named parameters.

           All error messages set during a "multi-operation" request (for instance a recursive get/put) are also
           retrievable via the errors() function once the operation has completed. See "ERROR HANDLING" for more
           information.

   <b>PUBLIC</b> <b>METHODS</b>
       <b>new(USERAGENT)</b>
       <b>new(USERAGENT,</b> <b>HEADERS)</b>
           Creates a new "HTTP::DAV" client

            $d = HTTP::DAV-&gt;new();

           The  "-useragent"  parameter  allows  you  to  pass  your  own  <b>user</b>  <b>agent</b>  <b>object</b>  and  expects  an
           "HTTP::DAV::UserAgent"  object.  See the "dave" program for an advanced example of a custom UserAgent
           that interactively prompts the user for their username and password.

           The "-headers" parameter allows you to specify a list of headers to be sent along with all  requests.
           This can be either a hashref like:

             { "X-My-Header" =&gt; "value", ... }

           or a HTTP::Headers object.

       <b>credentials(USER,PASS,[URL],[REALM])</b>
           sets authorization credentials for a "URL" and/or "REALM".

           When  the client hits a protected resource it will check these credentials to see if either the "URL"
           or "REALM" match the authorization response.

           Either "URL" or "REALM" must be provided.

           returns no value

           Example:

            $d-&gt;credentials( -url=&gt;'myhost.org:8080/test/',
                             -user=&gt;'pcollins',
                             -pass=&gt;'mypass');

       <b>DebugLevel($val)</b>
           sets the debug level to $val. 0=off 3=noisy.

           $val default is 0.

           returns no value.

           When the value is greater than 1, the "HTTP::DAV::Comms" module will log all of  the  client&lt;=&gt;server
           interactions into /tmp/perldav_debug.txt.

   <b>DAV</b> <b>OPERATIONS</b>
       For  all  of the following operations, URL can be absolute (<a href="http://host.org/dav/">http://host.org/dav/</a>) or relative (../dir2/).
       The only operation that requires an absolute URL is open.

       <b>copy(URL,DEST,[OVERWRITE],[DEPTH])</b>
           copies one remote resource to another

           "-url"
               is the remote resource you'd like to copy. Mandatory

           "-dest"
               is the remote target for the copy command. Mandatory

           "-overwrite"
               optionally indicates whether the server should fail if the target exists. Valid  values  are  "T"
               and "F" (1 and 0 are synonymous). Default is T.

           "-depth"
               optionally indicates whether the server should do a recursive copy or not. Valid values are 0 and
               (1 or "infinity"). Default is "infinity" (1).

           The return value is always 1 or 0 indicating success or failure.

           Requires a working resource to be set before being called. See "open".

           Note:  if  either  'URL' or 'DEST' are locked by this dav client, then the lock headers will be taken
           care of automatically. If the either of the two URL's are locked by someone else, the  server  should
           reject the request.

           <b>copy</b> <b>examples:</b>

             $d-&gt;open(-url=&gt;"host.org/dav_dir/");

           Recursively copy dir1/ to dir2/

             $d-&gt;copy(-url=&gt;"dir1/", -dest=&gt;"dir2/");

           Non-recursively and non-forcefully copy dir1/ to dir2/

             $d-&gt;copy(-url=&gt;"dir1/", -dest=&gt;"dir2/",-overwrite=&gt;0,-depth=&gt;0);

           Create a copy of dir1/file.txt as dir2/file.txt

             $d-&gt;cwd(-url=&gt;"dir1/");
             $d-&gt;copy("file.txt","../dir2");

           Create a copy of file.txt as dir2/new_file.txt

             $d-&gt;copy("file.txt","/dav_dir/dir2/new_file.txt")

       <b>cwd(URL)</b>
           changes the remote working directory.

           This  is  synonymous  to open except that the URL can be relative and may contain a "glob" (the first
           match in a glob will be used).

             $d-&gt;open("host.org/dav_dir/dir1/");
             $d-&gt;cwd("../dir2");
             $d-&gt;cwd(-url=&gt;"../dir1");

           The return value is always 1 or 0 indicating success or failure.

           Requires a working resource to be set before being called. See "open".

           You can not cwd to files, only collections (directories).

       <b>delete(URL)</b>
           deletes a remote resource.

             $d-&gt;open("host.org/dav_dir/");
             $d-&gt;delete("index.html");
             $d-&gt;delete("./dir1");
             $d-&gt;delete(-url=&gt;"/dav_dir/dir2/file*",-callback=&gt;\&amp;mycallback);

       "-url"
           is the remote resource(s) you'd like to delete. It can be a file, directory or "glob".

       "-callback"
       is a reference to a callback function which will be called everytime a file is deleted. This is mainly
       useful when used in conjunction with GLOBS deletes. See callbacks
           The return value is always 1 or 0 indicating success or failure.

           Requires a working resource to be set before being called. See "open".

           This command will recursively delete directories. BE  CAREFUL  of  uninitialised  file  variables  in
           situation like this: $d-&gt;delete("$dir/$file"). This will trash your $dir if $file is not set.

       <b>get(URL,[TO],[CALLBACK])</b>
           downloads the file or directory at "URL" to the local location indicated by "TO".

           "-url"
               is the remote resource you'd like to get. It can be a file or directory or a "glob".

           "-to"
               is where you'd like to put the remote resource. The -to parameter can be:

                - a B&lt;filename&gt; indicating where to save the contents.

                - a B&lt;FileHandle reference&gt;.

                - a reference to a B&lt;scalar object&gt; into which the contents will be saved.

               If the "-url" matches multiple files (via a glob or a directory download), then the "get" routine
               will return an error if you try to use a FileHandle reference or a scalar reference.

           "-callback"
               is  a  reference  to  a  callback  function  which  will  be called everytime a file is completed
               downloading. The idea of the callback function is that some recursive get's can take a very  long
               time  and the user may require some visual feedback. See CALLBACKS for an examples and how to use
               a callback.

           The return value of get is always 1 or 0 indicating whether the entire get sequence was a success  or
           if  there was ANY failures. For instance, in a recursive get, if the server couldn't open 1 of the 10
           remote files, for whatever reason, then the return value will be 0. This is so that you can have your
           script call the errors() routine to handle error conditions.

           Previous versions of HTTP::DAV allowed the return value to be the file contents if no  -to  attribute
           was supplied. This functionality is deprecated.

           Requires a working resource to be set before being called. See "open".

           <b>get</b> <b>examples:</b>

             $d-&gt;open("host.org/dav_dir/");

           Recursively get remote my_dir/ to .

             $d-&gt;get("my_dir/",".");

           Recursively  get  remote my_dir/ to /tmp/my_dir/ calling &amp;mycallback($success,$mesg) everytime a file
           operation is completed.

             $d-&gt;get("my_dir","<a href="file:/tmp">/tmp</a>",\&amp;mycallback);

           Get remote my_dir/index.html to /tmp/index.html

             $d-&gt;get(-url=&gt;"/dav_dir/my_dir/index.html",-to=&gt;"<a href="file:/tmp">/tmp</a>");

           Get remote index.html to /tmp/index1.html

             $d-&gt;get("index.html","/tmp/index1.html");

           Get remote index.html to a filehandle

             my $fh = new FileHandle;
             $fh-&gt;open("&gt;/tmp/index1.html");
             $d-&gt;get("index.html",\$fh);

           Get remote index.html as a scalar (into the string $file_contents):

             my $file_contents;
             $d-&gt;get("index.html",\$file_contents);

           Get all of the files matching the globs file1* and file2*:

             $d-&gt;get("file[12]*","<a href="file:/tmp">/tmp</a>");

           Get all of the files matching the glob file?.html:

             $d-&gt;get("file?.html","<a href="file:/tmp">/tmp</a>"); # downloads file1.html and file2.html but not file3.html or file1.txt

           Invalid glob:

             $d-&gt;get("/dav_dir/*/index.html","<a href="file:/tmp">/tmp</a>"); # Can not glob like this.

       <b>lock([URL],[OWNER],[DEPTH],[TIMEOUT],[SCOPE],[TYPE])</b>
           locks a resource. If URL is not  specified,  it  will  lock  the  current  working  resource  (opened
           resource).

              $d-&gt;lock( -url     =&gt; "index.html",
                        -owner   =&gt; "Patrick Collins",
                        -depth   =&gt; "infinity",
                        -scope   =&gt; "exclusive",
                        -type    =&gt; "write",
                        -timeout =&gt; "10h" )

           See "HTTP::DAV::Resource" <b>lock()</b> for details of the above parameters.

           The return value is always 1 or 0 indicating success or failure.

           Requires a working resource to be set before being called. See "open".

           When  you  lock a resource, the lock is held against the current HTTP::DAV object. In fact, the locks
           are held in a "HTTP::DAV::ResourceList" object. You can operate against all of  the  locks  that  you
           have created as follows:

             ## Print and unlock all locks that we own.
             my $rl_obj = $d-&gt;get_lockedresourcelist();
             foreach $resource ( $rl_obj-&gt;get_resources() ) {
                 @locks = $resource-&gt;get_locks(-owned=&gt;1);
                 foreach $lock ( @locks ) {
                   print $resource-&gt;get_uri . "\n";
                   print $lock-&gt;as_string . "\n";
                 }
                 ## Unlock them?
                 $resource-&gt;unlock;
             }

           Typically, a simple $d-&gt;unlock($uri) will suffice.

           <b>lock</b> <b>example</b>

             $d-&gt;lock($uri, -timeout=&gt;"1d");
             ...
             $d-&gt;put("/tmp/index.html",$uri);
             $d-&gt;unlock($uri);

       <b>mkcol(URL)</b>
           make a remote collection (directory)

           The return value is always 1 or 0 indicating success or failure.

           Requires a working resource to be set before being called. See "open".

             $d-&gt;open("host.org/dav_dir/");
             $d-&gt;mkcol("new_dir");                  # Should succeed
             $d-&gt;mkcol("/dav_dir/new_dir");         # Should succeed
             $d-&gt;mkcol("/dav_dir/new_dir/xxx/yyy"); # Should fail

       <b>move(URL,DEST,[OVERWRITE],[DEPTH])</b>
           moves one remote resource to another

           "-url"
               is the remote resource you'd like to move. Mandatory

           "-dest"
               is the remote target for the move command. Mandatory

           "-overwrite"
               optionally  indicates  whether  the server should fail if the target exists. Valid values are "T"
               and "F" (1 and 0 are synonymous). Default is T.

           Requires a working resource to be set before being called. See "open".

           The return value is always 1 or 0 indicating success or failure.

           Note: if either 'URL' or 'DEST' are locked by this dav client, then the lock headers  will  be  taken
           care  of  automatically.  If  either  of  the two URL's are locked by someone else, the server should
           reject the request.

           <b>move</b> <b>examples:</b>

             $d-&gt;open(-url=&gt;"host.org/dav_dir/");

           move dir1/ to dir2/

             $d-&gt;move(-url=&gt;"dir1/", -dest=&gt;"dir2/");

           non-forcefully move dir1/ to dir2/

             $d-&gt;move(-url=&gt;"dir1/", -dest=&gt;"dir2/",-overwrite=&gt;0);

           Move dir1/file.txt to dir2/file.txt

             $d-&gt;cwd(-url=&gt;"dir1/");
             $d-&gt;move("file.txt","../dir2");

           move file.txt to dir2/new_file.txt

             $d-&gt;move("file.txt","/dav_dir/dir2/new_file.txt")

       <b>open(URL)</b>
           opens the directory (collection resource) at URL.

           open will perform a propfind against URL. If the server does not understand the request then the open
           will fail.

           Similarly, if the server indicates that the resource at URL is NOT a  collection,  the  open  command
           will fail.

       <b>options([URL])</b>
           Performs an OPTIONS request against the URL or the working resource if URL is not supplied.

           Requires a working resource to be set before being called. See "open".

           The  return  value is a string of comma separated OPTIONS that the server states are legal for URL or
           undef otherwise.

           A fully compliant DAV server may offer as many methods as: OPTIONS, TRACE, GET,  HEAD,  DELETE,  PUT,
           COPY, MOVE, PROPFIND, PROPPATCH, LOCK, UNLOCK

           Note: IIS5 does not support PROPPATCH or LOCK on collections.

           Example:

            $options = $d-&gt;options($url);
            print $options . "\n";
            if ($options=~ /\bPROPPATCH\b/) {
               print "OK to proppatch\n";
            }

           Or, put more simply:

            if ( $d-&gt;options($url) =~ /\bPROPPATCH\b/ ) {
               print "OK to proppatch\n";
            }

       <b>propfind([URL],[DEPTH])</b>
           Perform a propfind against URL at DEPTH depth.

           "-depth" can be used to specify how deep the propfind goes. "0" is collection only. "1" is collection
           and it's immediate members (This is the default value). "infinity" is the entire directory tree. Note
           that most DAV compliant servers deny "infinity" depth propfinds for security reasons.

           Requires a working resource to be set before being called. See "open".

           The return value is an "HTTP::DAV::Resource" object on success or 0 on failure.

           The Resource object can be used for interrogating properties or performing other operations.

            ## Print collection or content length
            if ( $r=$d-&gt;propfind( -url=&gt;"/my_dir", -depth=&gt;1) ) {
               if ( $r-&gt;is_collection ) {
                  print "Collection\n"
                  print $r-&gt;get_resourcelist-&gt;as_string . "\n"
               } else {
                  print $r-&gt;get_property("getcontentlength") ."\n";
               }
            }

           Please  note  that  although  you may set a different namespace for a property of a resource during a
           set_prop, HTTP::DAV currently ignores all XML namespaces so you will get clashes  if  two  properties
           have  the same name but in different namespaces. Currently this is unavoidable but I'm working on the
           solution.

       <b>proppatch([URL],[NAMESPACE],PROPNAME,PROPVALUE,ACTION,[NSABBR])</b>
           If "-action" equals "set" then we set a property named "-propname" to "-propvalue" in  the  namespace
           "-namespace" for "-url".

           If "-action" equals "remove" then we unset a property named "-propname" in the namespace "-namespace"
           for "-url".

           If no action is supplied then the default action is "set".

           The return value is an "HTTP::DAV::Resource" object on success or 0 on failure.

           The Resource object can be used for interrogating properties or performing other operations.

           To  explicitly  set  a  namespace  in which to set the propname then you can use the "-namespace" and
           "-nsabbr" (namespace abbreviation) parameters. But you're welcome to play around with DAV namespaces.

           Requires a working resource to be set before being called. See "open".

           It is recommended that you use "set_prop" and "unset_prop" instead of proppatch for readability.

           "set_prop"     simply      calls      "proppatch(-action="set)&gt;      and      "unset_prop"      calls
           "proppatch(-action=""remove")&gt;

           See "set_prop" and "unset_prop" for examples.

       <b>put(LOCAL,[URL],[CALLBACK],[HEADERS])</b>
           uploads the files or directories at "-local" to the remote destination at "-url".

           "-local" points to a file, directory or series of files or directories (indicated by a glob).

           If  the  filename  contains  any  of the characters `*',  `?' or  `['  it is a candidate for filename
           substitution,  also   known   as   ``globbing''.    This  word   is   then  regarded  as  a   pattern
           (``glob-pattern''),  and replaced with an alphabetically sorted list  of  file  names which match the
           pattern.

           One can upload/put a string by passing a reference to a scalar in the -local parameter.  See  example
           below.

           put requires a working resource to be set before being called. See "open".

           The return value is always 1 or 0 indicating success or failure.

           See <b>get()</b> for a description of what the optional callback parameter does.

           You  can  also  pass a "-headers" argument. That allows one to specify custom HTTP headers. It can be
           either a hashref with header names and values, or a HTTP::Headers object.

           <b>put</b> <b>examples:</b>

           Put a string to the server:

             my $myfile = "This is the contents of a file to be uploaded\n";
             $d-&gt;put(-local=&gt;\$myfile,-url=&gt;"<a href="http://www.host.org/dav_dir/file.txt">http://www.host.org/dav_dir/file.txt</a>");

           Put a local file to the server:

             $d-&gt;put(-local=&gt;"/tmp/index.html",-url=&gt;"<a href="http://www.host.org/dav_dir/">http://www.host.org/dav_dir/</a>");

           Put a series of local files to the server:

             In these examples, <a href="file:/tmp">/tmp</a> contains file1.html, file1, file2.html,
             file2.txt, file3.html, file2/

             $d-&gt;put(-local=&gt;"/tmp/file[12]*",-url=&gt;"<a href="http://www.host.org/dav_dir/">http://www.host.org/dav_dir/</a>");

             uploads file1.html, file1, file2.html, file2.txt and the directory file2/ to dav_dir/.

       <b>set_prop([URL],[NAMESPACE],PROPNAME,PROPVALUE)</b>
           Sets a property named "-propname" to "-propvalue" in the namespace "-namespace" for "-url".

           Requires a working resource to be set before being called. See "open".

           The return value is an "HTTP::DAV::Resource" object on success or 0 on failure.

           The Resource object can be used for interrogating properties or performing other operations.

           Example:

            if ( $r = $d-&gt;set_prop(-url=&gt;$url,
                         -namespace=&gt;"dave",
                         -propname=&gt;"author",
                         -propvalue=&gt;"Patrick Collins"
                        ) ) {
               print "Author property set\n";
            } else {
               print "set_prop failed:" . $d-&gt;message . "\n";
            }

           See the note in propfind about namespace support in HTTP::DAV. They're settable, but not readable.

       <b>steal([URL])</b>
           forcefully steals any locks held against URL.

           steal will perform a propfind against URL and then, any locks that are found will be unlocked one  by
           one regardless of whether we own them or not.

           Requires a working resource to be set before being called. See "open".

           The  return  value  is  always  1 or 0 indicating success or failure. If multiple locks are found and
           unlocking one of them fails then the operation will be aborted.

            if ($d-&gt;steal()) {
               print "Steal succeeded\n";
            } else {
               print "Steal failed: ". $d-&gt;message() . "\n";
            }

       <b>unlock([URL])</b>
           unlocks any of our locks on URL.

           Requires a working resource to be set before being called. See "open".

           The return value is always 1 or 0 indicating success or failure.

            if ($d-&gt;unlock()) {
               print "Unlock succeeded\n";
            } else {
               print "Unlock failed: ". $d-&gt;message() . "\n";
            }

       <b>unset_prop([URL],[NAMESPACE],PROPNAME)</b>
           Unsets a property named "-propname" in the namespace "-namespace" for  "-url".   Requires  a  working
           resource to be set before being called. See "open".

           The return value is an "HTTP::DAV::Resource" object on success or 0 on failure.

           The Resource object can be used for interrogating properties or performing other operations.

           Example:

            if ( $r = $d-&gt;unset_prop(-url=&gt;$url,
                         -namespace=&gt;"dave",
                         -propname=&gt;"author",
                        ) ) {
               print "Author property was unset\n";
            } else {
               print "set_prop failed:" . $d-&gt;message . "\n";
            }

           See the note in propfind about namespace support in HTTP::DAV. They're settable, but not readable.

   <b>ACCESSOR</b> <b>METHODS</b>
       <b>get_user_agent</b>
           Returns the clients' working "HTTP::DAV::UserAgent" object.

           You  may want to interact with the "HTTP::DAV::UserAgent" object to modify request headers or provide
           advanced authentication procedures. See dave for an advanced authentication procedure.

       <b>get_last_request</b>
           Takes no arguments and returns the clients' last outgoing "HTTP::Request" object.

           You would only use this to inspect a request that has already occurred.

           If you would like to modify the "HTTP::Request" BEFORE the HTTP request takes place (for instance  to
           add  another  header),  you  will  need  to get the "HTTP::DAV::UserAgent" using "get_user_agent" and
           interact with that.

       <b>get_workingresource</b>
           Returns the currently "opened" or "working" resource ("HTTP::DAV::Resource").

           The working resource is changed whenever you open a url or use the cwd command.

           e.g.
             $r = $d-&gt;get_workingresource
             print "pwd: " . $r-&gt;get_uri . "\n";

       <b>get_workingurl</b>
           Returns the currently "opened" or "working" "URL".

           The working resource is changed whenever you open a url or use the cwd command.

             print "pwd: " . $d-&gt;get_workingurl . "\n";

       <b>get_lockedresourcelist</b>
           Returns an "HTTP::DAV::ResourceList" object that represents all of the locks we've created using THIS
           dav client.

             print "pwd: " . $d-&gt;get_workingurl . "\n";

       <b>get_absolute_uri(REL_URI,[BASE_URI])</b>
           This is a useful utility function which joins "BASE_URI" and "REL_URI" and returns a new URI.

           If "BASE_URI" is not supplied then the current working resource (as indicated by  get_workingurl)  is
           used.  If  "BASE_URI"  is  not  set  and  there  is no current working resource the "REL_URI" will be
           returned.

           For instance:
            $d-&gt;open("<a href="http://host.org/webdav/dir1/">http://host.org/webdav/dir1/</a>");

            # Returns "<a href="http://host.org/webdav/dir2/">http://host.org/webdav/dir2/</a>"
            $d-&gt;get_absolute_uri(-rel_uri=&gt;"../dir2");

            # Returns "<a href="http://x.org/dav/dir2/file.txt">http://x.org/dav/dir2/file.txt</a>"
            $d-&gt;get_absolute_uri(-rel_uri  =&gt;"dir2/file.txt",
                                 -&gt;base_uri=&gt;"<a href="http://x.org/dav/">http://x.org/dav/</a>");

           Note that it subtly takes care of trailing slashes.

   <b>ERROR</b> <b>HANDLING</b> <b>METHODS</b>
       <b>message</b>
           "message" gets the last success or error message.

           The return value is always a scalar (string) and will change everytime a  dav  operation  is  invoked
           (lock, cwd, put, etc).

           See also "errors" for operations which contain multiple error messages.

       <b>errors</b>
           Returns an @array of error messages that had been set during a multi-request operation.

           Some  of "HTTP::DAV"'s operations perform multiple request to the server. At the time of writing only
           put and get are considered multi-request since they  can  operate  recursively  requiring  many  HTTP
           requests.

           In these situations you should check the errors array if to determine if any of the requests failed.

           The "errors" function is used for multi-request operations and not to be confused with a multi-status
           server  response.  A  multi-status  server  response  is when the server responds with multiple error
           messages for a SINGLE request. To deal with multi-status responses, see "HTTP::DAV::Response".

            # Recursive put
            if (!$d-&gt;put( "/tmp/my_dir", $url ) ) {
               # Get the overall message
               print $d-&gt;message;
               # Get the individual messages
               foreach $err ( $d-&gt;errors ) { print "  Error:$err\n" }
            }

       <b>is_success</b>
           Returns the status of the last DAV operation performed through the HTTP::DAV interface.

           This value will always be the same as the value returned from an HTTP::DAV::method. For instance:

             # This will always evaluate to true
             ($d-&gt;lock($url) eq $d-&gt;is_success) ?

           You may want to use the is_success method if you didn't capture the return value immediately. But  in
           most circumstances you're better off just evaluating as follows:
             if($d-&gt;lock($url)) { ... }

       <b>get_last_response</b>
           Takes no arguments and returns the last seen "HTTP::DAV::Response" object.

           You  may  want  to use this if you have just called a propfind and need the individual error messages
           returned in a MultiStatus.

           If you find that you're using <b>get_last_response()</b> method a lot, you may be better off using the  more
           advanced "HTTP::DAV" interface and interacting with the HTTP::DAV::* interfaces directly as discussed
           in  the  intro.  For instance, if you find that you're always wanting a detailed understanding of the
           server's  response   headers   or   messages,   then   you're   probably   better   off   using   the
           "HTTP::DAV::Resource" methods and interpreting the "HTTP::DAV::Response" directly.

           To  perform  detailed  analysis  of the server's response (if for instance you got back a multistatus
           response) you can call get_last_response() which will return to you the most recent  response  object
           (always  the result of the last operation, PUT, PROPFIND, etc). With the returned HTTP::DAV::Response
           object you can handle multi-status responses.

           For example:

              # Print all of the messages in a multistatus response
              if (! $d-&gt;unlock($url) ) {
                 $response = $d-&gt;get_last_response();
                 if ($response-&gt;is_multistatus() ) {
                   foreach $num ( 0 .. $response-&gt;response_count() ) {
                      ($err_code,$mesg,$url,$desc) =
                         $response-&gt;response_bynum($num);
                      print "$mesg ($err_code) for $url\n";
                   }
                 }
              }

   <b>ADVANCED</b> <b>METHODS</b>
       <b>new_resource</b>
           Creates a new resource object with which  to  play.   This  is  the  preferred  way  of  creating  an
           "HTTP::DAV::Resource"  object  if  required.  Why? Because each Resource object needs to sit within a
           global HTTP::DAV client.  Also, because  the  new_resource  routine  checks  the  "HTTP::DAV"  locked
           resource list before creating a new object.

               $dav-&gt;new_resource( -uri =&gt; "http://..." );

       <b>set_workingresource(URL)</b>
           Sets the current working resource to URL.

           You shouldn't need this method. Call open or cwd to set the working resource.

           You CAN call set_workingresource() but you will need to perform a "propfind" immediately following it
           to ensure that the working resource is valid.

</pre><h4><b>INSTALLATION,</b> <b>TODO,</b> <b>MAILING</b> <b>LISTS</b> <b>and</b> <b>REVISION</b> <b>HISTORY</b></h4><pre>
       [OUTDATED]

       Please  see the primary HTTP::DAV webpage at (<a href="http://www.webdav.org/perldav/http-dav/">http://www.webdav.org/perldav/http-dav/</a>) or the README file
       in this library.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       You'll want to also read:

       "HTTP::DAV::Response"
       "HTTP::DAV::Resource"
       "dave"

       and maybe if you're more inquisitive:

       "LWP::UserAgent"
       "HTTP::Request"
       "HTTP::DAV::Comms"
       "HTTP::DAV::Lock"
       "HTTP::DAV::ResourceList"
       "HTTP::DAV::Utils"

</pre><h4><b>AUTHOR</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       This module is Copyright (C) 2001-2008 by

           Patrick Collins
           G03 Gloucester Place, Kensington
           Sydney, Australia

           Email: <a href="mailto:pcollins@cpan.org">pcollins@cpan.org</a>
           Phone: +61 2 9663 4916

       All rights reserved.

       Current co-maintainer of the module is Cosimo Streppone for Opera Software ASA, <a href="mailto:opera@cpan.org">opera@cpan.org</a>.

       You may distribute this module under the terms of either the GNU General Public License or  the  Artistic
       License, as specified in the Perl README file.

perl v5.40.0                                       2024-10-28                                     <u>HTTP::<a href="../man3pm/DAV.3pm.html">DAV</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>