<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGI::Ajax - a perl-specific system for writing Asynchronous web applications</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcgi-ajax-perl">libcgi-ajax-perl_0.707-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CGI::Ajax - a perl-specific system for writing Asynchronous web applications

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use strict;
         use CGI;      # or any other CGI:: form handler/decoder
         use CGI::Ajax;

         my $cgi = new CGI;
         my $pjx = new CGI::Ajax( 'exported_func' =&gt; \&amp;perl_func );
         print $pjx-&gt;build_html( $cgi, \&amp;Show_HTML);

         sub perl_func {
           my $input = shift;
           # do something with $input
           my $output = $input . " was the input!";
           return( $output );
         }

         sub Show_HTML {
           my $html = &lt;&lt;EOHTML;
           &lt;HTML&gt;
           &lt;BODY&gt;
             Enter something:
               &lt;input type="text" name="val1" id="val1"
                onkeyup="exported_func( ['val1'], ['resultdiv'] );"&gt;
             &lt;br&gt;
             &lt;div id="resultdiv"&gt;&lt;/div&gt;
           &lt;/BODY&gt;
           &lt;/HTML&gt;
         EOHTML
           return $html;
         }

       When you use CGI::Ajax within Applications that send their own header information, you can skip the
       header:

         my $pjx = new CGI::Ajax(
           'exported_func' =&gt; \&amp;perl_func,
           'skip_header'   =&gt; 1,
         );
         $pjx-&gt;<a href="../man1/skip_header.1.html">skip_header</a>(1);

         print $pjx-&gt;build_html( $cgi, \&amp;Show_HTML);

       <u>There</u> <u>are</u> <u>several</u> <u>fully-functional</u> <u>examples</u> <u>in</u> <u>the</u> <u>'scripts/'</u> <u>directory</u> <u>of</u> <u>the</u> <u>distribution.</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       CGI::Ajax is an object-oriented module that provides a unique mechanism for using perl code
       asynchronously from javascript- enhanced HTML pages.  CGI::Ajax unburdens the user from having to write
       extensive javascript, except for associating an exported method with a document-defined event (such as
       onClick, onKeyUp, etc).  CGI::Ajax also mixes well with HTML containing more complex javascript.

       CGI::Ajax supports methods that return single results or multiple results to the web page, and supports
       returning values to multiple DIV elements on the HTML page.

       Using CGI::Ajax, the URL for the HTTP GET/POST request is automatically generated based on HTML layout
       and events, and the page is then dynamically updated with the output from the perl function.
       Additionally, CGI::Ajax supports mapping URL's to a CGI::Ajax function name, so you can separate your
       code processing over multiple scripts.

       Other than using the Class::Accessor module to generate CGI::Ajax' accessor methods, CGI::Ajax is
       completely self-contained - it does not require you to install a larger package or a full Content
       Management System, etc.

       We have added <u>support</u> for other CGI handler/decoder modules, like CGI::Simple or CGI::Minimal, but we
       can't test these since we run mod_perl2 only here.  CGI::Ajax checks to see if a <b>header()</b> method is
       available to the CGI object, and then uses it.  If <b>method()</b> isn't available, it creates it's own minimal
       header.

       A primary goal of CGI::Ajax is to keep the module streamlined and maximally flexible.  We are trying to
       keep the generated javascript code to a minimum, but still provide users with a variety of methods for
       deploying CGI::Ajax. And VERY little user javascript.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The CGI::Ajax module allows a Perl subroutine to be called asynchronously, when triggered from a
       javascript event on the HTML page.  To do this, the subroutine must be <u>registered</u>, usually done during:

         my $pjx = new CGI::Ajax( 'JSFUNC' =&gt; \&amp;PERLFUNC );

       This maps a perl subroutine (PERLFUNC) to an automatically generated Javascript function (JSFUNC).  Next
       you setup a trigger this function when an event occurs (e.g. "onClick"):

         onClick="JSFUNC(['source1','source2'], ['dest1','dest2']);"

       where 'source1', 'dest1', 'source2', 'dest2' are the DIV ids of HTML elements in your page...

         &lt;input type=text id=source1&gt;
         &lt;input type=text id=source2&gt;
         &lt;div id=dest1&gt;&lt;/div&gt;
         &lt;div id=dest2&gt;&lt;/div&gt;

       CGI::Ajax sends the values from source1 and source2 to your Perl subroutine and returns the results to
       dest1 and dest2.

   <b>4</b> <b>Usage</b> <b>Methods</b>
       1 Standard CGI::Ajax example
           Start  by  defining  a  perl  subroutine that you want available from javascript.  In this case we'll
           define a subrouting that determines whether or not an input is odd, even, or not a number (NaN):

             use strict;
             use CGI::Ajax;
             use CGI;

             sub evenodd_func {
               my $input = shift;

               # see if input is defined
               if ( not defined $input ) {
                 return("input not defined or NaN");
               }

               # see if value is a number (*thanks Randall!*)
               if ( $input !~ /\A\d+\z/ ) {
                 return("input is NaN");
               }

               # got a number, so mod by 2
               $input % 2 == 0 ? return("EVEN") : return("ODD");
             }

           Alternatively, we could have used coderefs to associate an exported name...

             my $evenodd_func = sub {
               # exactly the same as in the above subroutine
             };

           Next we define a function to generate the web page - this can be done many different  ways,  and  can
           also  be defined as an anonymous sub.  The only requirement is that the sub send back the html of the
           page.  You can do this via a string containing the html, or from a coderef that returns the html,  or
           from a function (as shown here)...

             sub Show_HTML {
               my $html = &lt;&lt;EOT;
             &lt;HTML&gt;
             &lt;HEAD&gt;&lt;title&gt;CGI::Ajax Example&lt;/title&gt;
             &lt;/HEAD&gt;
             &lt;BODY&gt;
               Enter a number:&amp;nbsp;
               &lt;input type="text" name="somename" id="val1" size="6"
                  OnKeyUp="evenodd( ['val1'], ['resultdiv'] );"&gt;
               &lt;br&gt;
               &lt;hr&gt;
               &lt;div id="resultdiv"&gt;
               &lt;/div&gt;
             &lt;/BODY&gt;
             &lt;/HTML&gt;
           EOT
               return $html;
             }

           The  exported  Perl  subrouting  is  triggered  using  the  "OnKeyUp" event handler of the input HTML
           element.  The subroutine takes one value from the form, the input element <b>'val1'</b>, and returns the the
           result to an HTML div element with an id of <b>'resultdiv'</b>.  Sending in the input id in an array  format
           is required to support multiple inputs, and similarly, to output multiple the results, you can use an
           array for the output divs, but this isn't mandatory - as will be explained in the <b>Advanced</b> usage.

           Now  create  a  CGI object and a CGI::Ajax object, associating a reference to our subroutine with the
           name we want available to javascript.

             my $cgi = new CGI();
             my $pjx = new CGI::Ajax( 'evenodd' =&gt; \&amp;evenodd_func );

           And if we used a coderef, it would look like this...

             my $pjx = new CGI::Ajax( 'evenodd' =&gt; $evenodd_func );

           Now we're ready to print the output page; we send in the cgi object and the HTML-generating function.

             print $pjx-&gt;build_html($cgi,\&amp;Show_HTML);

           CGI::Ajax has support for passing in extra HTML header information to the CGI object.   This  can  be
           accomplished by adding a third argument to the <b>build_html()</b> call.  The argument needs to be a hashref
           containing Key=&gt;value pairs that CGI objects understand:

             print $pjx-&gt;build_html($cgi,\&amp;Show_HTML,
               {-charset=&gt;'UTF-8, -expires=&gt;'-1d'});

           See CGI for more <b>header()</b> method options.  (CGI.pm, not the Perl6 CGI)

           That's it for the CGI::Ajax standard method.  Let's look at something more advanced.

       2 Advanced CGI::Ajax example
           Let's  say  we  wanted  to  have  a  perl  subroutine process multiple values from the HTML page, and
           similarly return multiple values back to distinct divs on the page.  This is easy to do, and requires
           no changes to the perl code - you just create it as you would any perl  subroutine  that  works  with
           multiple  input  values  and  returns  multiple  values.  The significant change happens in the event
           handler javascript in the HTML...

             onClick="exported_func(['input1','input2'],['result1','result2']);"

           Here  we  associate  our  javascript  function  ("exported_func")   with   two   HTML   element   ids
           ('input1','input2'),   and   also   send   in   two   HTML  element  ids  to  place  the  results  in
           ('result1','result2').

       3 Sending Perl Subroutine Output to a Javascript function
           Occassionally, you might want to have a custom javascript function process the  returned  information
           from  your Perl subroutine.  This is possible, and the only requierment is that you change your event
           handler code...

             onClick="exported_func(['input1'],[js_process_func]);"

           In this scenario, "js_process_func" is a javascript function you write to  take  the  returned  value
           from  your Perl subroutine and process the results.  <u>Note</u> <u>that</u> <u>a</u> <u>javascript</u> <u>function</u> <u>is</u> <u>not</u> <u>quoted</u> <u>--</u>
           <u>if</u> <u>it</u> <u>were,</u> <u>then</u> <u>CGI::Ajax</u> <u>would</u> <u>look</u> <u>for</u> <u>a</u> <u>HTML</u> <u>element</u> <u>with</u> <u>that</u> <u>id.</u>  Beware that with this  usage,
           <b>you</b>  <b>are</b>  <b>responsible</b> <b>for</b> <b>distributing</b> <b>the</b> <b>results</b> <b>to</b> <b>the</b> <b>appropriate</b> <b>place</b> <b>on</b> <b>the</b> <b>HTML</b> <b>page</b>.  If the
           exported Perl subroutine returns, e.g. 2 values, then "js_process_func" would  need  to  process  the
           input by working through an array, or using the javascript Function "arguments" object.

             function js_process_func() {
               var input1 = arguments[0]
               var input2 = arguments[1];
               // do something and return results, or set HTML divs using
               // innerHTML
               document.getElementById('outputdiv').innerHTML = input1;
             }

       4 URL/Outside Script CGI::Ajax example
           There  are  times when you may want a different script to return content to your page.  This could be
           because you have an existing script already written to perform a particular  task,  or  you  want  to
           distribute  a  part  of your application to another script.  This can be accomplished in CGI::Ajax by
           using a URL in place of a locally-defined Perl subroutine.  In this usage, you alter you creation  of
           the CGI::Ajax object to link an exported javascript function name to a local URL instead of a coderef
           or a subroutine.

             my $url = 'scripts/other_script.pl';
             my $pjx = new CGI::Ajax( 'external' =&gt; $url );

           This will work as before in terms of how it is called from you event handler:

             onClick="external(['input1','input2'],['resultdiv']);"

           The other_script.pl will get the values via a CGI object and accessing the 'args' key.  The values of
           the <b>'args'</b> key will be an array of everything that was sent into the script.

             my @input = $cgi-&gt;params('args');
             $input[0]; # contains first argument
             $input[1]; # contains second argument, etc...

           This  is  good, but what if you need to send in arguments to the other script which are directly from
           the calling Perl script, i.e. you want a calling Perl script's variable to be  sent,  not  the  value
           from an HTML element on the page?  This is possible using the following syntax:

             onClick="exported_func(['args__$input1','args__$input2'],
                                    ['resultdiv']);"

           Similary,  if  the external script required a constant as input (e.g.  "script.pl?args=42", you would
           use this syntax:

             onClick="exported_func(['args__42'],['resultdiv']);"

           In both of the above examples, the result  from  the  external  script  would  get  placed  into  the
           <u>resultdiv</u> element on our (the calling script's) page.

           If you are sending more than one argument from an external perl script back to a javascript function,
           you  will  need  to  split  the  string (AJAX applications communicate in strings only) on something.
           Internally, we use '__pjx__', and this string is checked for.  If found, CGI::Ajax will automatically
           split it.  However, if you don't want to use '__pjx__', you can do it yourself:

           For example, from your Perl script, you would...

                   return("A|B"); # join with "|"

           and then in the javascript function you would have something like...

                   process_func() {
                           var arr = arguments[0].split("|");
                           // arr[0] eq 'A'
                           // arr[1] eq 'B'
                   }

           In order to rename parameters, in case the outside script needs specifically-named parameters and not
           CGI::Ajax' <u>'args'</u> default parameter name, change your event handler associated  with  an  HTML  event
           like this

             onClick="exported_func(['myname__$input1','myparam__$input2'],
                                    ['resultdiv']);"

           The URL generated would look like this...

           "script.pl?myname=input1&amp;myparam=input2"

           You would then retrieve the input in the outside script with this...

             my $p1 = $cgi-&gt;params('myname');
             my $p1 = $cgi-&gt;params('myparam');

           Finally,  what  if  we  need  to  get a value from our HTML page and we want to send that value to an
           outside script but the outside script requires a named parameter  different  from  <u>'args'</u>?   You  can
           accomplish this with CGI::Ajax using the <b>getVal()</b> javascript method (which returns an array, thus the
           "getVal()[0]" notation):

             onClick="exported_func(['myparam__' + getVal('div_id')[0]],
                                    ['resultdiv']);"

           This  will get the value of our HTML element with and <u>id</u> of <u>div_id</u>, and submit it to the url attached
           to <u>myparam</u><b>__</b>.  So if our exported handler referred to a URI called <u>script/scr.pl</u>, and the element  on
           our  HTML  page  called  <u>div_id</u>  contained  the  number  '42',  then  the  URL  would  look like this
           "script/scr.pl?myparam=42".  The result from this outside URL would get placed  back  into  our  HTML
           page  in  the  element  <u>resultdiv</u>.   See  the  example script that comes with the distribution called
           <u>pjx_url.pl</u> and its associated outside script <u>convert_degrees.pl</u> for a working example.

           <b>N.B.</b> These examples show the use of outside scripts which are other perl scripts - <u>but</u>  <u>you</u>  <u>are</u>  <u>not</u>
           <u>limited</u>  <u>to</u>  <u>Perl</u>!  The outside script could just as easily have been PHP or any other CGI script, as
           long as the return from the other script is just the result, and not addition HTML  code  (like  FORM
           elements, etc).

   <b>GET</b> <b>versus</b> <b>POST</b>
       Note that all the examples so far have used the following syntax:

         onClick="exported_func(['input1'],['result1']);"

       There  is  an  optional  third  argument  to  a CGI::Ajax exported function that allows change the submit
       method.  The above event could also have been coded like this...

         onClick="exported_func(['input1'],['result1'], 'GET');"

       By default, CGI::Ajax sends a <u>'GET'</u> request.  If you need it, for example your URL  is  getting  way  too
       long, you can easily switch to a <u>'POST'</u> request with this syntax...

         onClick="exported_func(['input1'],['result1'], 'POST');"

       <u>('POST'</u> <u>and</u> <u>'post'</u> <u>are</u> <u>supported)</u>

   <b>Page</b> <b>Caching</b>
       We  have  implemented  a method to prevent page cacheing from undermining the AJAX methods in a page.  If
       you send in an input argument to a CGI::Ajax-exported function called 'NO_CACHE', the a special parameter
       will get attached to the end or your url with a random number in it.  This will prevent  a  browser  from
       caching your request.

         onClick="exported_func(['input1','NO_CACHE'],['result1']);"

       The  extra param is called pjxrand, and won't interfere with the order of processing for the rest of your
       parameters.

       Also see the <b>CACHE()</b> method of changing the default cache behavior.

</pre><h4><b>METHODS</b></h4><pre>
       <b>build_html()</b>
               Purpose: Associates a cgi obj ($cgi) with pjx object, inserts
                        javascript into &lt;HEAD&gt;&lt;/HEAD&gt; element and constructs
                        the page, or part of the page.  AJAX applications
                        are designed to update only the section of the
                        page that needs it - the whole page doesn't have
                        to be redrawn.  L&lt;CGI::Ajax&gt; applications use the
                        build_html() method to take care of this: if the CGI
                        parameter C&lt;fname&gt; exists, then the return from the
                        L&lt;CGI::Ajax&gt;-exported function is sent to the page.
                        Otherwise, the entire page is sent, since without
                        an C&lt;fname&gt; param, this has to be the first time
                        the page is being built.

             Arguments: The CGI object, and either a coderef, or a string
                        containing html.  Optionally, you can send in a third
                        parameter containing information that will get passed
                        directly to the CGI object header() call.
               Returns: html or updated html (including the header)
             Called By: originating cgi script

       <b>show_javascript()</b>
               Purpose: builds the text of all the javascript that needs to be
                        inserted into the calling scripts html &lt;head&gt; section
             Arguments:
               Returns: javascript text
             Called By: originating web script
                  Note: This method is also overridden so when you just print
                        a CGI::Ajax object it will output all the javascript needed
                        for the web page.

       <b>register()</b>
               Purpose: adds a function name and a code ref to the global coderef
                        hash, after the original object was created
             Arguments: function name, code reference
               Returns: none
             Called By: originating web script

       <b>fname()</b>
               Purpose: Overrides the default parameter name used for
                        passing an exported function name. Default value
                        is "fname".

             Arguments: fname("new_name"); # sets the new parameter name
                        The overriden fname should be consistent throughout
                        the entire application. Otherwise results are unpredicted.

               Returns: With no parameters fname() returns the current fname name

       <b>JSDEBUG()</b>
               Purpose: Show the AJAX URL that is being generated, and stop
                        compression of the generated javascript, both of which can aid
                        during debugging.  If set to 1, then the core js will get
                        compressed, but the user-defined functions will not be
                        compressed.  If set to 2 (or anything greater than 1 or 0),
                        then none of the javascript will get compressed.

             Arguments: <a href="../man0/JSDEBUG.0.html">JSDEBUG</a>(0); # turn javascript debugging off
                        <a href="../man1/JSDEBUG.1.html">JSDEBUG</a>(1); # turn javascript debugging on, some javascript compression
                        <a href="../man2/JSDEBUG.2.html">JSDEBUG</a>(2); # turn javascript debugging on, no javascript compresstion
               Returns: prints a link to the url that is being generated automatically by
                        the Ajax object. this is VERY useful for seeing what
                        CGI::Ajax is doing. Following the link, will show a page
                        with the output that the page is generating.

             Called By: $pjx-&gt;<a href="../man1/JSDEBUG.1.html">JSDEBUG</a>(1) # where $pjx is a CGI::Ajax object;

       <b>DEBUG()</b>
               Purpose: Show debugging information in web server logs
             Arguments: <a href="../man0/DEBUG.0.html">DEBUG</a>(0); # turn debugging off (default)
                        <a href="../man1/DEBUG.1.html">DEBUG</a>(1); # turn debugging on
               Returns: prints debugging information to the web server logs using
                        STDERR
             Called By: $pjx-&gt;<a href="../man1/DEBUG.1.html">DEBUG</a>(1) # where $pjx is a CGI::Ajax object;

       <b>CACHE()</b>
               Purpose: Alter the default result caching behavior.
             Arguments: <a href="../man0/CACHE.0.html">CACHE</a>(0); # effectively the same as having NO_CACHE passed in every call
               Returns: A change in the behavior of build_html such that the javascript
                        produced will always act as if the NO_CACHE argument is passed,
                        regardless of its presence.
             Called By: $pjx-&gt;<a href="../man0/CACHE.0.html">CACHE</a>(0) # where $pjx is a CGI::Ajax object;

</pre><h4><b>BUGS</b></h4><pre>
       Follow any bugs at our homepage....

         <a href="http://www.perljax.us">http://www.perljax.us</a>

</pre><h4><b>SUPPORT</b></h4><pre>
       Check out the news/discussion/bugs lists at our homepage:

         <a href="http://www.perljax.us">http://www.perljax.us</a>

</pre><h4><b>AUTHORS</b></h4><pre>
         Brian C. Thomas     Brent Pedersen
         CPAN ID: BCT
         <a href="mailto:bct.x42@gmail.com">bct.x42@gmail.com</a>   <a href="mailto:bpederse@gmail.com">bpederse@gmail.com</a>

         significant contribution by:
             Peter Gordon &lt;<a href="mailto:peter@pg-consultants.com">peter@pg-consultants.com</a>&gt; # CGI::Application + scripts
             Kyraha  <a href="http://michael.kyraha.com/">http://michael.kyraha.com/</a>      # getVal(), multiple forms
             Jan Franczak &lt;<a href="mailto:jan.franczak@gmail.com">jan.franczak@gmail.com</a>&gt;   # CACHE support
             Shibi NS                                # use -&gt;isa instead of -&gt;can

         others:
             RENEEB &lt;RENEEB [...] cpan.org&gt;
             stefan.scherer
             RBS
             Andrew

</pre><h4><b>A</b> <b>NOTE</b> <b>ABOUT</b> <b>THE</b> <b>MODULE</b> <b>NAME</b></h4><pre>
       This module was initiated using the name "Perljax", but then registered with CPAN  under  the  WWW  group
       "CGI::",  and  so  became  "CGI::Perljax".   Upon further deliberation, we decided to change it's name to
       CGI::Ajax.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

       The full text of the license can be found in the LICENSE file included with this module.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Data::Javascript CGI Class::Accessor

perl v5.34.0                                       2022-06-09                                     <u>CGI::<a href="../man3pm/Ajax.3pm.html">Ajax</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>