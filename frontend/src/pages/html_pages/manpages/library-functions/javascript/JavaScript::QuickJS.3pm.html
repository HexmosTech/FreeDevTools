<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript::QuickJS - Run JavaScript via QuickJS <https://bellard.org/quickjs> in Perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libjavascript-quickjs-perl">libjavascript-quickjs-perl_0.21-2build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       JavaScript::QuickJS - Run JavaScript via QuickJS &lt;https://bellard.org/quickjs&gt; in Perl

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Quick and dirty …

           my $val = JavaScript::QuickJS-&gt;new()-&gt;eval( q&lt;
               let foo = "bar";
               [ "The", "last", "value", "is", "returned." ];
           &gt; );

       … or load ES6 modules:

           my $js = JavaScript::QuickJS-&gt;new()-&gt;helpers();

           $js-&gt;eval_module( q/
               import * as coolStuff from 'cool/stuff';

               for (const [key, value] of Object.entries(coolStuff)) {
                   console.log(key, value);
               }
           / );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This library embeds Fabrice Bellard’s QuickJS &lt;https://bellard.org/quickjs&gt; engine into a Perl XS module.
       You can thus run JavaScript (ES2020 &lt;https://tc39.github.io/ecma262/&gt; specification) directly in your
       Perl programs.

       This distribution includes all needed C code; unlike with most XS modules that interface with C
       libraries, you don’t need QuickJS pre-installed on your system.

</pre><h4><b>METHODS</b></h4><pre>
   <b>$obj</b> <b>=</b> <u><b>CLASS</b></u><b>-&gt;new(</b> <b>%CONFIG_OPTS</b> <b>)</b>
       Instantiates <u>CLASS</u>. %CONFIG_OPTS have the same effect as in configure() below.

   <b>$obj</b> <b>=</b> <u><b>OBJ</b></u><b>-&gt;configure(</b> <b>%OPTS</b> <b>)</b>
       Tunes the QuickJS interpreter. Returns <u>OBJ</u>.

       %OPTS are any of:

       •   "max_stack_size"

       •   "memory_limit"

       •   "gc_threshold"

       For more information on these, see QuickJS itself.

   <b>$obj</b> <b>=</b> <u><b>OBJ</b></u><b>-&gt;set_globals(</b> <b>NAME1</b> <b>=&gt;</b> <b>VALUE1,</b> <b>..</b> <b>)</b>
       Sets 1 or more globals in <u>OBJ</u>. See below for details on type conversions from Perl to JavaScript.

       Returns <u>OBJ</u>.

   <b>$obj</b> <b>=</b> <u><b>OBJ</b></u><b>-&gt;helpers()</b>
       Defines QuickJS’s “helpers”, e.g., "console.log".

       Returns <u>OBJ</u>.

   <b>$obj</b> <b>=</b> <u><b>OBJ</b></u><b>-&gt;std()</b>
       Enables  QuickJS’s  "std" module and creates a global of the same name that’s usable from both script and
       module modes.

       This resembles "qjs"’s "--std" flag except that it <u>only</u> enables "std", not "os".

       Returns <u>OBJ</u>.

   <b>$obj</b> <b>=</b> <u><b>OBJ</b></u><b>-&gt;os()</b>
       Like std() but enables QuickJS’s "os" module instead of "std".

   <b>$VALUE</b> <b>=</b> <u><b>OBJ</b></u><b>-&gt;eval(</b> <b>$JS_CODE</b> <b>)</b>
       Like running "qjs -e '...'". Returns $JS_CODE’s last value; see below for  details  on  type  conversions
       from JavaScript to Perl.

       Untrapped exceptions in JavaScript will be rethrown as Perl exceptions.

       $JS_CODE is a <u>character</u> string.

   <b>$promise</b> <b>=</b> <u><b>OBJ</b></u><b>-&gt;eval_module(</b> <b>$JS_CODE</b> <b>)</b>
       Runs $JS_CODE as a module, which enables ES6 module syntax.  Note that no values can be returned directly
       in this mode of execution.

       Returns a promise that resolves once the module is loaded.

   <b>$obj</b> <b>=</b> <u><b>OBJ</b></u><b>-&gt;await()</b>
       Blocks until all of <u>OBJ</u>’s pending work (if any) is complete.

       For  example,  if  you  eval()  some  code  that creates a promise, call this to wait for that promise to
       complete.

       Returns <u>OBJ</u>.

   <b>$obj</b> <b>=</b> <u><b>OBJ</b></u><b>-&gt;set_module_base(</b> <b>$PATH</b> <b>)</b>
       Sets a base path (a byte string) for ES6 module imports.

       Returns <u>OBJ</u>.

   <b>$obj</b> <b>=</b> <u><b>OBJ</b></u><b>-&gt;unset_module_base()</b>
       Restores QuickJS’s default directory for ES6 module imports (as  of  this  writing,  it’s  the  process’s
       current directory).

       Returns <u>OBJ</u>.

</pre><h4><b>TYPE</b> <b>CONVERSION:</b> <b>JAVASCRIPT</b> <b>→</b> <b>PERL</b></h4><pre>
       This module converts returned values from JavaScript thus:

       •   JS string primitives become <u>character</u> strings in Perl.

       •   JS number &amp; boolean primitives become corresponding Perl values.

       •   JS null &amp; undefined become Perl undef.

       •   JS objects …

           •   Arrays become Perl array references.

           •   “Plain” objects become Perl hash references.

           •   Function,    RegExp,    and    Date    objects    become    Perl   JavaScript::QuickJS::Function,
               JavaScript::QuickJS::RegExp, and JavaScript::QuickJS::Date objects, respectively.

           •   Behaviour is <b>UNDEFINED</b> for other object types.

</pre><h4><b>TYPE</b> <b>CONVERSION:</b> <b>PERL</b> <b>→</b> <b>JAVASCRIPT</b></h4><pre>
       Generally speaking, it’s the inverse of JS → Perl:

       •   Perl strings, numbers, &amp; booleans become corresponding JavaScript primitives.

           <b>IMPORTANT:</b> Perl versions before 5.36 don’t reliably distinguish “numeric strings” from “numbers”.  If
           your  perl  predates  5.36,  typecast  accordingly  to  prevent  your  Perl  “number” from becoming a
           JavaScript string. (Even in 5.36 and later it’s still a good idea.)

       •   Perl undef becomes JS null.

       •   Unblessed array &amp; hash references become JavaScript arrays and “plain” objects.

       •   Types::Serialiser booleans become JavaScript booleans.

       •   Perl code references become JavaScript functions.

       •   Perl  JavaScript::QuickJS::Function,   JavaScript::QuickJS::RegExp,   and   JavaScript::QuickJS::Date
           objects become their original JavaScript objects.

       •   Anything else triggers an exception.

</pre><h4><b>MEMORY</b> <b>HANDLING</b> <b>NOTES</b></h4><pre>
       If  any  instance  of a class of this distribution is <b>DESTROY()</b>ed at Perl’s global destruction, we assume
       that this is a memory leak, and a warning is thrown. To prevent  this,  avoid  circular  references,  and
       clean up all global instances.

       Callbacks  make  that  tricky.  When  you  give  a  JavaScript function to Perl, that Perl object holds a
       reference to the QuickJS context. Only once that object is DESTROY()ed do we release that QuickJS context
       reference.

       Consider the following:

           my $return;

           $js-&gt;set_globals(  __return =&gt; sub { $return = shift; () } );

           $js-&gt;eval('__return( a =&gt; a )');

       This sets $return to be a JavaScript::QuickJS::Function instance. That object holds a reference  to  $js.
       $js  also stores "__return()", which is a Perl code reference that closes around $return. Thus, we have a
       reference cycle: $return refers to $js, and $js refers to $return. Those two values will thus  leak,  and
       you’ll see a warning about it at Perl’s global destruction time.

       To break the reference cycle, just do:

           undef $return;

       … once you’re done with that variable.

       You <u>might</u> have thought you could instead do:

           $js-&gt;set_globals( __return =&gt; undef )

       …  but that doesn’t work because $js holds a reference to all Perl code references it <b>ever</b> receives. This
       is because QuickJS, unlike Perl, doesn’t expose object destructors (DESTROY() in  Perl),  so  there’s  no
       good way to release that reference to the code reference.

</pre><h4><b>CHARACTER</b> <b>ENCODING</b> <b>NOTES</b></h4><pre>
       QuickJS (like all JS engines) assumes its strings are text. Since Perl can’t distinguish text from bytes,
       though,  it’s  possible  to convert Perl byte strings to JavaScript strings. It often yields a reasonable
       result, but not always.

       One place where this falls over, though, is ES6 modules. QuickJS, when it loads an  ES6  module,  decodes
       that  module’s  string literals to characters.  Thus, if you pass in byte strings from Perl, QuickJS will
       treat your Perl byte strings’ code points as character code points,  and  when  you  combine  those  code
       points with those from your ES6 module you may get mangled output.

       Another  place  that  may  create trouble is if your argument to eval() or eval_module() (above) contains
       JSON. Perl’s popular JSON encoders output byte strings  by  default,  but  as  noted  above,  eval()  and
       eval_module()  need  <u>character</u>  strings.  So  either configure your JSON encoder to output characters, or
       decode JSON bytes to characters before calling eval()/eval_module().

       For best results, <u>always</u> interact with QuickJS via <u>character</u> strings, and double-check that you’re  doing
       it that way consistently.

</pre><h4><b>NUMERIC</b> <b>PRECISION</b></h4><pre>
       Note the following if you expect to deal with “large” numbers:

       •   JavaScript’s       numeric-precision       limits      apply.      (cf.       Number.MAX_SAFE_INTEGER
           &lt;https://developer.mozilla.org/en-
           US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER&gt;.)

       •   Perl’s stringification of numbers may be <u>less</u> precise than JavaScript’s storage of those numbers,  or
           even than Perl’s own storage.  For example, in Perl 5.34 "print 1000000000000001.0" prints 1e+15.

           To  counteract  this  loss  of  precision,  add  0  to  Perl’s  numeric  scalars  (e.g.,  "print  0 +
           1000000000000001.0"); this will encourage Perl to store numbers  as  integers  when  possible,  which
           fixes this precision problem.

       •   Long-double and quad-math perls may lose precision when converting numbers to/from JavaScript. To see
           if this affects your perl—which, if you’re unsure, it probably doesn’t—run "perl -V", and see if that
           perl’s compile-time options mention long doubles or quad math.

</pre><h4><b>OS</b> <b>SUPPORT</b></h4><pre>
       QuickJS supports Linux, macOS, and Windows natively, so these work without issue.

       FreeBSD,  OpenBSD, &amp; Cygwin work after a few patches that we apply when building this library. (Hopefully
       these will eventually merge into QuickJS.)

</pre><h4><b>LIBATOMIC</b></h4><pre>
       QuickJS uses C11 atomics. Most platforms implement that functionality  in  hardware,  but  others  (e.g.,
       arm32) don’t. To fill that void, we need to link to libatomic.

       This library’s build logic detects whether libatomic is necessary and will only link to it if needed. If,
       for  some  reason,  you  need  manual  control  over that linking, set "JS_QUICKJS_LINK_LIBATOMIC" in the
       environment to 1 or a falsy value.

       If you don’t know what any of that means, you can probably ignore it.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Other JavaScript modules on CPAN include:

       •   JavaScript::Duktape::XS  and  JavaScript::Duktape  make  the  Duktape  &lt;https://duktape.org&gt;  library
           available  to  Perl.  They’re  similar to this library, but Duktape itself (as of this writing) lacks
           support for several JavaScript constructs that QuickJS supports. (It’s also slower.)

       •   JavaScript::V8 and JavaScript::V8::XS expose Google’s V8 &lt;https://v8.dev&gt; library  to  Perl.  Neither
           seems to support current V8 versions.

       •   JE is a pure-Perl (!) JavaScript engine.

       •   JavaScript  and  JavaScript::Lite expose Mozilla’s SpiderMonkey &lt;https://spidermonkey.dev/&gt; engine to
           Perl.

</pre><h4><b>LICENSE</b> <b>&amp;</b> <b>COPYRIGHT</b></h4><pre>
       This library is copyright 2023 Gasper Software Consulting.

       This library is licensed under the same terms as Perl itself.  See perlartistic.

       QuickJS is copyright  Fabrice  Bellard  and  Charlie  Gordon.  It  is  released  under  the  MIT  license
       &lt;https://opensource.org/licenses/MIT&gt;.

perl v5.40.0                                       2024-10-20                           <u>JavaScript::<a href="../man3pm/QuickJS.3pm.html">QuickJS</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>