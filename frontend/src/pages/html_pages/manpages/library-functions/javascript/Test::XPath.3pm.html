<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::XPath - Test XML and HTML content and structure with XPath expressions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-xpath-perl">libtest-xpath-perl_0.20-1_all</a> <br><br><pre>
</pre><h4><b>Name</b></h4><pre>
       Test::XPath - Test XML and HTML content and structure with XPath expressions

</pre><h4><b>Synopsis</b></h4><pre>
         use Test::More tests =&gt; 5;
         use Test::XPath;

         my $xml = &lt;&lt;'XML';
         &lt;html&gt;
           &lt;head&gt;
             &lt;title&gt;Hello&lt;/title&gt;
             &lt;style type="text/css" src="foo.css"&gt;&lt;/style&gt;
             &lt;style type="text/css" src="bar.css"&gt;&lt;/style&gt;
           &lt;/head&gt;
           &lt;body&gt;
             &lt;h1&gt;Welcome to my lair.&lt;/h1&gt;
           &lt;/body&gt;
         &lt;/html&gt;
         XML

         my $tx = Test::XPath-&gt;new( xml =&gt; $xml );

         $tx-&gt;ok( '/html/head', 'There should be a head' );
         $tx-&gt;is( '/html/head/title', 'Hello', 'The title should be correct' );

         # Recursing into a document:
         my @css = qw(foo.css bar.css);
         $tx-&gt;ok( '/html/head/style[@type="text/css"]', sub {
             my $css = shift @css;
             shift-&gt;is( './@src', $css, "Style src should be $css");
         }, 'Should have style' );

         # Better yet, use PerlX::MethodCallWithBlock:
         use PerlX::MethodCallWithBlock;
         my @css = qw(foo.css bar.css);
         use PerlX::MethodCallWithBlock;
         $tx-&gt;ok( '/html/head/style[@type="text/css"]', 'Should have style' ) {
             my $css = shift @css;
             shift-&gt;is( './@src', $css, "Style src should be $css");
         };

         # Or use CSS Selectors:
         $tx = Test::XPath-&gt;new( xml =&gt; $xml, filter =&gt; 'css_selector' );
         $tx-&gt;ok( '&gt; html &gt; head', 'There should be a head' );

</pre><h4><b>Description</b></h4><pre>
       Use the power of XPath expressions to validate the structure of your XML and HTML documents.

   <b>About</b> <b>XPath</b>
       XPath is a powerful query language for XML documents. Test::XPath relies on the libxml2 implementation
       provided by XML::LibXML. libxml2 -- pretty much the canonical library for XML processing -- provides an
       efficient and complete implementation of the XPath spec.

       XPath works by selecting nodes in an XML document. Nodes, in general, correspond to the elements (a.k.a.
       tags) defined in the XML, text within those elements, attribute values, and comments. The expressions for
       making such selections use a URI-like syntax, the basics of which are:

       $nodename
           Selects all child nodes with the name.

       "/" Selects the root node.

       "//"
           Selects  nodes  from  the  current node that match the selection, regardless of where they are in the
           node hierarchy.

       "." Selects the current node.

       ".."
           Selects the parent of the current node.

       "@" Selects attributes.

       And some examples:

       "head"
           Selects all of the child nodes of the "head" element.

       "/html"
           Selects the root "html" element.

       "body/p"
           Selects all "p" elements that are children of the "body" element.

       "//p"
           Selects all "p" elements no matter where they are in the document.

       "body//p"
           Selects all "p" elements that are descendants of the "body" element,  no  matter  where  they  appear
           under the "body" element.

       "//@lang"
           Selects all attributes named "lang".

       There are also useful predicates to select certain nodes. Some examples:

       "body//p[1]"
           Select the first paragraph under the body element.

       "body//p[last()]"
           Select the last paragraph under the body element.

       "//script[@src]"
           Select all "script" nodes that have a "src" attribute.

       "//script[@src='foo.js']"
           Select all "script" nodes that have a "src" attribute set to "foo.js".

       "//img[@height &gt; 400]"
           Select all "img" nodes with a height attribute greater than 400.

       "head/*"
           Select all child nodes below the "head" node.

       "p[@*]"
           Select all "p" nodes that have any attribute.

       "count(//p)"
           Select a count of all "p" nodes in the document.

       "contains(//title, "Welcome")"
           Select true if the title node contains the string "Welcome", and false if it does not.

       There are a bunch of core functions in XPath. In addition to the ("last()" and "count()") examples above,
       there  are  functions for node sets, booleans, numbers, and strings. See the XPath 1.0 W3C Recommendation
       &lt;<a href="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</a>&gt;, for thorough (and quite readable) documentation of XPath support, including
       syntax and  the  core  functions.  The  W3Schools  tutorial  &lt;<a href="http://www.w3schools.com/Xpath/default.asp">http://www.w3schools.com/Xpath/default.asp</a>&gt;
       provides a nice overview of XPath.

   <b>Testing</b> <b>HTML</b>
       If  you  want  to  use  XPath  to test the content and structure of an HTML document, be sure to pass the
       "is_html" option to "new()", like so:

         my $tx = Test::XPath-&gt;new( xml =&gt; $html, is_html =&gt; 1 );

       Test::XPath will then use XML::LibXML's HTML parser to parse the document, rather than  its  XML  parser.
       The  upshot  is that you won't have to worry about namespace prefixes, and XML::LibXML won't try to fetch
       any DTD specified in the DOCTYPE section of your HTML.

</pre><h4><b>Class</b> <b>Interface</b></h4><pre>
   <b>Constructor</b>
       <u>"new"</u>

         my $tx = Test::XPath-&gt;new( xml =&gt; $xml );

       Creates and returns an XML::XPath object. This object can be used to run XPath tests on the XML passed to
       it. The supported parameters are:

       "xml"
             xml =&gt; '&lt;foo&gt;&lt;bar&gt;hey&lt;/bar&gt;&lt;/foo&gt;',

           The XML to be parsed and tested. Required unless the "file" or "doc" option is passed.

       "file"
             file =&gt; 'rss.xml',

           Name of a file containing the XML to be parsed and tested. Required unless the "xml" or "doc"  option
           is passed.

       "doc"
             doc =&gt; XML::LibXML-&gt;new-&gt;parse_file($xml_file),

           An XML::LibXML document object. Required unless the "xml" or "file" option is passed.

       "is_html"
             is_html =&gt; 1,

           If  the  XML  you're  testing  is actually HTML, pass this option a true value and XML::LibXML's HTML
           parser will be used instead of the XML parser. This is especially useful if your HTML has  a  DOCTYPE
           declaration or an XML namespace (xmlns attribute) and you don't want the parser grabbing the DTD over
           the Internet and you don't want to mess with a namespace prefix in your XPath expressions.

       "xmlns"
             xmlns =&gt; {
                 x =&gt; '<a href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</a>',
                 a =&gt; '<a href="http://www.w3.org/2007/app">http://www.w3.org/2007/app</a>',
             },

           Set  up  prefixes  for  XML  namespaces.  Required  if your XML uses namespaces and you want to write
           reasonable XPath expressions.

       "options"
             options =&gt; { recover_silently =&gt; 1, no_network =&gt; 1 },

           Optional  hash  reference  of  XML::LibXML::Parser  options,   such   as   "validation",   "recover",
           "suppress_errors", and "no_network". These can be useful for tweaking the behavior of the parser.

       "filter"
             filter =&gt; 'css_selector',
             filter =&gt; sub { my $xpath = shift; },

           Pass  a  filter  name  or  a code reference for Test::XPath to use to filter XPath expressions before
           passing them on to XML::LibXML. The code reference argument allows you to transform XPath expressions
           if, for example, you use a custom XPath syntax that's more concise than XPath.

           There is currently only one built-in filter, "css_selector". So if you pass

             filter =&gt; 'css_selector',

           Then any paths passed to "ok()", "is()", etc., will be  passed  through  HTML::Selector::XPath.  This
           allows you to use CSS selector syntax, which can be more compact for simple expressions. For example,
           this CSS selector:

               $tx-&gt;is('div#content div.article h1', '...')

           Is equivalent to this XPath expression:

               $tx-&gt;is('//div[@id="content"]//div[@class="article"]//h1', '...')

</pre><h4><b>Instance</b> <b>Interface</b></h4><pre>
   <b>Assertions</b>
       <u>"ok"</u>

         $tx-&gt;ok( $xpath, $description )
         $tx-&gt;ok( $xpath, $coderef, $description )

       Test  that  an  XPath  expression  evaluated  against the XML document returns a true value. If the XPath
       expression finds no nodes, the result will be false.  If it finds a value, the value must be a true value
       (in the Perl sense).

         $tx-&gt;ok( '//foo/bar', 'Should have bar element under foo element' );
         $tx-&gt;ok( 'contains(//title, "Welcome")', 'Title should "Welcome"' );

       You can also run recursive tests against your document by passing a code reference as the second argument
       to "ok()". Once the initial selection has been completed, each selected node  will  be  assigned  to  the
       "node"  attribute  and  the XML::XPath object passed to the code reference. For example, if you wanted to
       test for the presence of "story" elements in your document, and to test that each  such  element  had  an
       incremented "id" attribute, you'd do something like this:

         my $i = 0;
         $tx-&gt;ok( '//assets/story', sub {
             shift-&gt;is('./@id', ++$i, "ID should be $i in story $i");
         }, 'Should have story elements' );

       Even better, use PerlX::MethodCallWithBlock to pass a block to the method instead of a code reference:

         use PerlX::MethodCallWithBlock;
         my $i = 0;
         $tx-&gt;ok( '//assets/story', 'Should have story elements' ) {
             shift-&gt;is('./@id', ++$i, "ID should be $i in story $i");
         };

       For  convenience,  the  XML::XPath object is also assigned to $_ for the duration of the call to the code
       reference. Either way, you can call "ok()" and pass  code  references  anywhere  in  the  hierarchy.  For
       example,  to  ensure  that  an  Atom feed has entries and that each entry has a title, a link, and a very
       specific author element with name, uri, and email subnodes, you can do this:

         $tx-&gt;ok( '/feed/entry', sub {
             $_-&gt;ok( './title', 'Should have a title' );
             $_-&gt;ok( './author', sub {
                 $_-&gt;is( './name',  'Mark Pilgrim',        'Mark should be author' );
                 $_-&gt;is( './uri',   '<a href="http://example.org/">http://example.org/</a>', 'URI should be correct' );
                 $_-&gt;is( './email', '<a href="mailto:f8dy@example.com">f8dy@example.com</a>',    'Email should be right' );
             }, 'Should have author elements' );
         }, 'Should have entry elments' );

       <u>"not_ok"</u>

         $tx-&gt;not_ok( $xpath, $description )

       The reverse of the non-recursive "ok()", the test succeeds if the XPath expression matches no part of the
       document.

         $tx-&gt;not_ok( '//foo/bar[@id=0]', 'Should have no bar elements with Id 0' );

       <u>"is"</u>

       <u>"isnt"</u>

         $tx-&gt;is( $xpath, $want, $description );
         $tx-&gt;isnt( $xpath, $dont_want, $description );

       "is()" and "isnt()" compare the value returned by evaluation of the XPath expression against the document
       to a value using "eq" and "ne", respectively.

         $tx-&gt;is( '/html/head/title', 'Welcome', 'Title should be welcoming' );
         $tx-&gt;isnt( '/html/head/link/@type', 'hello', 'Link type should not' );

       As with "Test::More::ok()", a failing test will yield a useful diagnostic message, something like:

         #   Failed test 'Title should be welcoming'
         #   at t/foo.t line 47.
         #          got: 'Bienvenidos'
         #     expected: 'Hello'

       <u>"like"</u>

       <u>"unlike"</u>

         $tx-&gt;like( $xpath, qr/want/, $description );
         $tx-&gt;unlike( $xpath, qr/dont_want/, $description );

       Similar to "is()" and "isnt()", but these methods match  the  value  returned  by  the  XPath  expression
       against a regular expression.

         $tx-&gt;like( '/html/head/title', qr/^Foobar Inc.: .+/, 'Title context' );
         $tx-&gt;unlike( '/html/head/title', qr/Error/, 'Should be no error in title' );

       As with "Test::More::like()", a failing test will yield a useful diagnostic message, something like:

         #   Failed test 'Title should, like, welcome'
         #   at t/foo.t line 62.
         #                   'Bye'
         #     doesn't match '(?-xism:^Howdy$)'

       <u>"cmp_ok"</u>

         $tx-&gt;cmp_ok( $xpath, $op, $want, $description );

       Like  "Test::More::cmp_ok()", this method allows you to compare the value returned by an XPath expression
       to a value using any binary Perl operator.

         $tx-&gt;cmp_ok( '/html/head/title', 'eq', 'Welcome' );
         $tx-&gt;cmp_ok( '//story[1]/@id', '==', 1 );

       As with "Test::More::cmp_ok()", a failing test will yield a useful diagnostic message, something like:

         #   Failed test
         #   at t/foo.t line 104.
         #     '0'
         #         &amp;&amp;
         #     '1'

   <b>Accessors</b>
       <u>"node"</u>

         my $node = $tx-&gt;node;

       Returns the current context node. This will usually be the node for the entire document, but in recursive
       tests run in code references passed to "ok()", the node will be one of the nodes selected for the test.

       <u>"xpc"</u>

       Returns the XML::LibXML::XPathContext used to execute the XPath expressions. It can be useful  to  access
       this object in order to create new XPath functions to use in your tests. For example, say that you wanted
       to define a "grep()" XPath function that returns true for a node value that matches a regular expression.
       You can define one like so:

         $tx-&gt;xpc-&gt;registerFunction( grep =&gt; sub {
             my ($nodelist, $regex) =  @_;
             my $result = XML::LibXML::NodeList-&gt;new;
             for my $node ($nodelist-&gt;get_nodelist) {
                 $result-&gt;push($node) if $node-&gt;textContent =~ $regex;
             }
             return $result;
         } );

       You  can then use "grep()" like any other XPath function to select only those nodes with content matching
       a regular expression. This example makes sure that there are "email" nodes under "author" nodes that  end
       in "@example.com" or "example.org":

         $tx-&gt;ok(
             'grep(//author/email, "@example[.](?:com|org)$")',
             'Should have example email'
         );

   <b>Utilities</b>
       <u>"find_value"</u>

         my $val = $tx-&gt;find_value($xpath);

       Returns  the  value  returned  by evaluation of the XPath expression against the document relative to the
       current node. This is the method used internally to fetch the value  to  be  compared  by  "is",  "isnt",
       "like", "unlike", and "cmp_ok". A simple example:

         my $val = $tx-&gt;find_value('/html/head/title');

</pre><h4><b>See</b> <b>Also</b></h4><pre>
       •   XML Path Language (XPath) Version 1.0 W3C Recommendation &lt;<a href="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</a>&gt;.

       •   W3Schools XPath Tutorial &lt;https://www.w3schools.com/xml/xpath_intro.asp&gt;.

       •   XML::LibXML::XPathContext - The XML::LibXML XPath evaluation library.

       •   Test::XML::XPath  -  Another library for testing XPath assertions using a functional interface. Ships
           with Test::XML.

       •   Test::HTML::Content - Another module that that offers "xpath_ok()" and "no_xpath()" test functions.

</pre><h4><b>Support</b></h4><pre>
       This module is stored in an open GitHub repository &lt;<a href="http://github.com/manwar/test-xpath/tree/">http://github.com/manwar/test-xpath/tree/</a>&gt;. Feel free
       to fork and contribute!

       Please file bug reports via GitHub Issues  &lt;<a href="http://github.com/manwar/test-xpath/issues/">http://github.com/manwar/test-xpath/issues/</a>&gt;  or  by  sending
       mail to <a href="mailto:bug-Test-XPath@rt.cpan.org">bug-Test-XPath@rt.cpan.org</a> &lt;<a href="mailto:bug-Test-XPath@rt.cpan.org">mailto:bug-Test-XPath@rt.cpan.org</a>&gt;.

</pre><h4><b>Author</b></h4><pre>
       David E. Wheeler &lt;<a href="mailto:david@kineticode.com">david@kineticode.com</a>&gt;

       Currently maintained by Mohammad S Anwar &lt;<a href="mailto:mohammad.anwar@yahoo.com">mohammad.anwar@yahoo.com</a>&gt;

</pre><h4><b>Copyright</b> <b>and</b> <b>License</b></h4><pre>
       Copyright (c) 2009-2010 David E. Wheeler. Some Rights Reserved.

       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.34.0                                       2022-08-19                                   <u>Test::<a href="../man3pm/XPath.3pm.html">XPath</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>