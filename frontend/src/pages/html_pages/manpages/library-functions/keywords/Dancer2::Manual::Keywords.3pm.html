<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dancer2::Manual::Keywords - Dancer2 DSL Keywords</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdancer2-perl">libdancer2-perl_1.1.2+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Dancer2::Manual::Keywords - Dancer2 DSL Keywords

</pre><h4><b>VERSION</b></h4><pre>
       version 1.1.2

</pre><h4><b>DSL</b> <b>KEYWORDS</b></h4><pre>
       Dancer2 provides you with a DSL (Domain-Specific Language) which makes implementing your web application
       trivial.

       For example, take the following example:

           use Dancer2;

           get '/hello/:name' =&gt; sub {
               my $name = route_parameters-&gt;get('name');
           };
           true;

       "get" and "route_parameters" are keywords provided by Dancer2.

       This document lists all keywords provided by Dancer2. It does not cover additional keywords which may be
       provided by loaded plugins; see the documentation for plugins you use to see which additional keywords
       they make available to you.

   <b>any</b>
       Defines a route for multiple HTTP methods at once:

           any ['get', 'post'] =&gt; '/myaction' =&gt; sub {
               # code
           };

       Or even, a route handler that would match any HTTP methods:

           any '/myaction' =&gt; sub {
               # code
           };

   <b>app</b>
       Returns an instance of the app. App is a Dancer2::Core::App.

   <b>body_parameters</b>
       Returns a Hash::MultiValue object from the body parameters.

           post '/' =&gt; sub {
               my $last_name = body_parameters-&gt;get('name');
               my @all_names = body_parameters-&gt;get_all('name');
           };

   <b>captures</b>
       Returns a reference to a copy of "%+", if there are named captures in the route's regular expression.

           get qr{
               / (?&lt;object&gt; user   | ticket | comment )
               / (?&lt;action&gt; delete | find )
               / (?&lt;id&gt; \d+ )
               /?$
           }x
           , sub {
               my $value_for = captures;
               "i don't want to $value_for-&gt;{action} " .
                   "the $value_for-&gt;{object} $value_for-&gt;{id} !"
           };

   <b>cookie</b>
       Accesses a cookie value (or sets it). Note that this method will eventually be preferred over
       "set_cookie".

           cookie lang =&gt; "fr-FR";              # set a cookie and return its value
           cookie lang =&gt; "fr-FR", expires =&gt; "2 hours";   # extra cookie info
           cookie "lang"                        # return a cookie value

       If your cookie value is a key/value URI string, like

           token=ABC&amp;user=foo

       "cookie" will only return the first part ("token=ABC") if called in scalar context. Use list context to
       fetch them all:

           my @values = cookie "name";

   <b>cookies</b>
       Accesses cookies values, it returns a hashref of Dancer2::Core::Cookie objects:

           get '/some_action' =&gt; sub {
               my $cookie = cookies-&gt;{name};
               return $cookie-&gt;value;
           };

       In case you have stored something other than a scalar in your cookie:

           get '/some_action' =&gt; sub {
               my $cookie = cookies-&gt;{oauth};
               my %values = $cookie-&gt;value;
               return ($values{token}, $values{token_secret});
           };

   <b>config</b>
       Accesses the configuration of the application:

           get '/appname' =&gt; sub {
               return "This is " . config-&gt;{appname};
           };

   <b>content</b>
       Sets the content for the response. This <b>only</b> works within a delayed response.

       This will crash:

           get '/' =&gt; sub {
               # THIS WILL CRASH
               content 'Hello, world!';
           };

       But this will work just fine:

           get '/' =&gt; sub {
               delayed {
                   content 'Hello, world!';
                   ...
               };
           };

   <b>content_type</b>
       Sets the <b>content-type</b> rendered, for the current route handler:

           get '/cat/:txtfile' =&gt; sub {
               content_type 'text/plain';

               # here we can dump the contents of route_parameters-&gt;get('txtfile')
           };

       You can use abbreviations for content types. For instance:

           get '/svg/:id' =&gt; sub {
               content_type 'svg';

               # here we can dump the image with id route_parameters-&gt;get('id')
           };

       Note that if you want to change the default content-type for every route, it is easier to change the
       "content_type" setting instead.

   <b>context</b>
       Deprecated. Use "app" instead.

   <b>dance</b>
       Alias for the "start" keyword. "to_app" is preferable.

   <b>dancer_app</b>
       Returns the app object. See "app".

   <b>dancer_version</b>
       Returns the version of Dancer. If you need the major version, do something like:

           int(dancer_version);

       or (better), call "dancer_major_version".

   <b>dancer_major_version</b>
       Returns the major version of Dancer.

   <b>debug</b>
       Logs a message of debug level:

           debug "This is a debug message";

       See Dancer2::Core::Role::Logger for details on how to configure where log messages go.

   <b>decode_json</b> <b>($string)</b>
       Deserializes a JSON structure from an UTF-8 binary string.

   <b>del</b>
       Defines a route for HTTP <b>DELETE</b> requests to the given URL:

           del '/resource' =&gt; sub { ... };

       You can also provide the route with a name:

           del 'rec' =&gt; '/resource' =&gt; sub { ... };

       See "uri_for_route" on how this can be used.

   <b>delayed</b>
       Stream a response asynchronously. For more information, please see "Delayed responses (Async/Streaming)"
       in Dancer2::Manual, or this article &lt;https://advent.perldancer.org/2020/22&gt; in the 2020 Dancer Advent
       Calendar.

   <b>dirname</b>
       Returns the dirname of the path given:

           my $dir = dirname($some_path);

   <b>done</b>
       Close the streaming connection. Can only be called within a streaming response callback.

   <b>dsl</b>
       Allows access to the DSL within your plugin/application. Is an instance of Dancer2::Core::DSL.

   <b>encode_json</b> <b>($structure)</b>
       Serializes a structure to a UTF-8 binary JSON string.

       Calling this function will <b>not</b> trigger the serialization's hooks.

   <b>engine</b>
       Given a namespace, returns the current engine object

           my $template_engine = engine 'template';
           my $html = $template_engine-&gt;apply_renderer(...);
           $template_engine-&gt;apply_layout($html);

   <b>error</b>
       Logs a message of error level:

           error "This is an error message";

       See Dancer2::Core::Role::Logger for details on how to configure where log messages go.

   <b>false</b>
       Constant that returns a false value (0).

   <b>flush</b>
       Flush headers when streaming a response. Necessary when "content" is called multiple times.

   <b>forward</b>
       Runs an "internal redirect" of the current route to another route. More formally; when "forward" is
       executed, the current dispatch of the route is aborted, the request is modified (altering query params or
       request method), and the modified request following a new route is dispatched again. Any remaining code
       (route and hooks) from the current dispatch will never be run and the modified route's dispatch will
       execute hooks for the new route normally.

       It effectively lets you chain routes together in a clean manner.

           get '/demo/articles/:article_id' =&gt; sub {

               # you'll have to implement this next sub yourself :)
               change_the_main_database_to_demo();

               forward "/articles/" . route_parameters-&gt;get('article_id');
           };

       In the above example, the users that reach <u>/demo/articles/30</u> will actually reach <u>/articles/30</u> but we've
       changed the database to demo before.

       This is pretty cool because it lets us retain our paths and offer a demo database by merely going to
       <u>/demo/...</u>.

       You'll notice that in the example we didn't indicate whether it was <b>GET</b> or <b>POST</b>. That is because
       "forward" chains the same type of route the user reached. If it was a <b>GET</b>, it will remain a <b>GET</b> (but if
       you do need to change the method, you can do so; read on below for details.)

       Also notice that "forward" only redirects to a new route. It does not redirect the requests involving
       static files. This is because static files are handled before Dancer2 tries to match the request to a
       route - static files take higher precedence.

       This means that you will not be able to "forward" to a static file. If you wish to do so, you have two
       options: either redirect (asking the browser to make another request, but to a file path instead) or use
       "send_file" to provide a file.

       <b>WARNING:</b> Any code after a "forward" is ignored, until the end of the route. It's not necessary to use
       "return" with "forward" anymore.

           get '/foo/:article_id' =&gt; sub {
               if ($condition) {
                   forward "/articles/" . route_parameters-&gt;get('article_id');
                   # The following code WILL NOT BE executed
                   do_stuff();
               }

               more_stuff();
           };

       Note that "forward" doesn't parse GET arguments. So, you can't use something like:

           forward '<a href="file:/home">/home</a>?authorized=1';

       But "forward" supports an optional hashref with parameters to be added to the actual parameters:

           forward '<a href="file:/home">/home</a>', { authorized =&gt; 1 };

       Finally, you can add some more options to the "forward" method, in a third argument, also as a hashref.
       That option is currently only used to change the method of your request. Use with caution.

           forward '<a href="file:/home">/home</a>', { auth =&gt; 1 }, { method =&gt; 'POST' };

   <b>from_dumper</b> <b>($structure)</b>
       Deserializes a Data::Dumper structure.

   <b>from_json</b> <b>($string,</b> <b>\%options)</b>
       Deserializes a JSON structure from a string. You should probably use "decode_json" which expects a UTF-8
       encoded binary string and handles decoding it for you.

   <b>from_yaml</b> <b>($structure)</b>
       Deserializes a YAML structure.

   <b>get</b>
       Defines a route for HTTP <b>GET</b> requests to the given path:

           get '/' =&gt; sub {
               return "Hello world";
           }

       Note that a route to match <b>HEAD</b> requests is automatically created as well.

       You can also provide the route with a name:

           get 'index' =&gt; '/' =&gt; sub {
               return "Hello world";
           }

       See "uri_for_route" on how this can be used.

   <b>halt</b>
       Sets a response object with the content given.

       When used as a return value from a hook, this breaks the execution flow and renders the response
       immediately:

           hook before =&gt; sub {
               if ($some_condition) {
                   halt("Unauthorized");

                   # this code is not executed
                   do_stuff();
               }
           };

           get '/' =&gt; sub {
               "hello there";
           };

       <b>WARNING:</b> Issuing a halt immediately exits the current route, and performs the halt. Thus, any code after
       a halt is ignored, until the end of the route.  Hence, it's not necessary anymore to use "return" with
       halt.

   <b>header</b>
       Deprecated. Use "response_header" instead.

   <b>headers</b>
       Deprecated. Use "response_headers" instead.

   <b>hook</b>
       Adds a hook at some position. For example :

         hook before_serializer =&gt; sub {
           my $content = shift;
           ...
         };

       There can be multiple hooks assigned to a given position, and each will be executed in order.

       See "HOOKS" in Dancer2::Manual for a list of available hooks.

   <b>info</b>
       Logs a message of "info" level:

           info "This is an info message";

       See Dancer2::Core::Role::Logger for details on how to configure where log messages go.

   <b>log</b>
       Logs messages at the specified level. For example:

           log( debug =&gt; "This is a debug message." );

   <b>mime</b>
       Shortcut to access the instance object of Dancer2::Core::MIME. You should read the Dancer2::Core::MIME
       documentation for full details, but the most commonly-used methods are summarized below:

           # set a new mime type
           mime-&gt;add_type( foo =&gt; 'text/foo' );

           # set a mime type alias
           mime-&gt;add_alias( f =&gt; 'foo' );

           # get mime type for an alias
           my $m = mime-&gt;for_name( 'f' );

           # get mime type for a file (based on extension)
           my $m = mime-&gt;for_file( "foo.bar" );

           # get current defined default mime type
           my $d = mime-&gt;default;

           # set the default mime type using config.yml
           # or using the set keyword
           set default_mime_type =&gt; 'text/plain';

   <b>options</b>
       Defines a route for HTTP <b>OPTIONS</b> requests to the given URL:

           options '/resource' =&gt; sub { ... };

   <b>param</b>
       <u>This</u> <u>method</u> <u>should</u> <u>be</u> <u>called</u> <u>from</u> <u>a</u> <u>route</u> <u>handler</u>.  This method is an accessor to the parameters hash
       table.

          post '/login' =&gt; sub {
              my $username = param "user";
              my $password = param "pass";
              # ...
          };

       We now recommend using one of the specific keywords for parameters ("route_parameters",
       "query_parameters", and "body_parameters") instead of "params" or "param".

   <b>params</b>
       <u>This</u> <u>method</u> <u>should</u> <u>be</u> <u>called</u> <u>from</u> <u>a</u> <u>route</u> <u>handler</u>.  It's an alias for the Dancer2::Core::Request params
       accessor. It returns a hash (in list context) or a hash reference (in scalar context) to all defined
       parameters. Check "param" below to access quickly to a single parameter value.

           post '/login' =&gt; sub {
               # get all parameters as a single hash
               my %all_parameters = params;

               // request all parmameters from a specific source: body, query, route
               my %body_parameters  = params('body');
               my %route_parameters = params('route');
               my %query_parameters = params('query');

               # any $source that is not body, query, or route generates an exception
               params('fake_source'); // Unknown source params "fake_source"
           };

       We now recommend using one of the specific keywords for parameters ("route_parameters",
       "query_parameters", and "body_parameters") instead of "params" or "param".

   <b>pass</b>
       <u>This</u> <u>method</u> <u>should</u> <u>be</u> <u>called</u> <u>from</u> <u>a</u> <u>route</u> <u>handler</u>.  Tells Dancer2 to pass the processing of the request
       to the next matching route.

       <b>WARNING:</b> Issuing a pass immediately exits the current route, and performs the pass. Thus, any code after
       a pass is ignored, until the end of the route. Hence, it's not necessary anymore to use "return" with
       pass.

           get '/some/route' =&gt; sub {
               if (...) {
                   # we want to let the next matching route handler process this one
                   pass(...);

                   # this code will be ignored
                   do_stuff();
               }
           };

       <b>WARNING:</b> You cannot set the content before passing and have it remain, even if you use the "content"
       keyword or set it directly in the response object.

   <b>patch</b>
       Defines a route for HTTP <b>PATCH</b> requests to the given URL:

           patch '/resource' =&gt; sub { ... };

       ("PATCH" is a relatively new and not-yet-common HTTP verb, which is intended to work as a "partial-PUT",
       transferring just the changes; please see RFC5789 &lt;<a href="http://tools.ietf.org/html/rfc5789">http://tools.ietf.org/html/rfc5789</a>&gt; for further
       details.)

       You can also provide the route with a name:

           patch 'rec' =&gt; '/resource' =&gt; sub { ... };

       See "uri_for_route" on how this can be used.

   <b>path</b>
       Concatenates multiple paths together, without worrying about the underlying operating system:

           my $path = path(dirname($0), 'lib', 'File.pm');

       It also normalizes (cleans) the path aesthetically. It does not verify whether the path exists, though.

   <b>post</b>
       Defines a route for HTTP <b>POST</b> requests to the given URL:

           post '/' =&gt; sub {
               return "Hello world";
           }

       You can also provide the route with a name:

           post 'index' =&gt; '/' =&gt; sub {
               return "Hello world";
           }

       See "uri_for_route" on how this can be used.

   <b>prefix</b>
       Defines a prefix for each route handler, like this:

           prefix '<a href="file:/home">/home</a>';

       From here, any route handler is defined to <a href="file:/home/">/home/</a>*:

           get '/page1' =&gt; sub {}; # will match '/home/page1'

       You can unset the prefix value:

           prefix undef;
           get '/page1' =&gt; sub {}; # will match /page1

       For a safer alternative you can use lexical prefix like this:

           prefix '<a href="file:/home">/home</a>' =&gt; sub {
               ## Prefix is set to '<a href="file:/home">/home</a>' here

               get ...;
               get ...;
           };
           ## prefix reset to the previous version here

       This makes it possible to nest prefixes:

          prefix '<a href="file:/home">/home</a>' =&gt; sub {
              ## some routes

             prefix '/private' =&gt; sub {
                ## here we are under /home/private...

                ## some more routes
             };
             ## back to <a href="file:/home">/home</a>
          };
          ## back to the root

       <b>Notice:</b> Once you have a prefix set, do not add a caret to the regex:

           prefix '/foo';
           get qr{^/bar} =&gt; sub { ... } # BAD BAD BAD
           get qr{/bar}  =&gt; sub { ... } # Good!

   <b>prepare_app</b>
       You can introduce code you want to run when your app is loaded, similar to the "prepare_app" in
       Plack::Middleware.

           prepare_app {
               my $app = shift;

               ... # do your thing
           };

       You should not close over the App instance, since you receive it as a first argument. If you close over
       it, you <b>will</b> have a memory leak.

           my $app = app();

           prepare_app {
               do_something_with_app($app); # MEMORY LEAK
           };

   <b>psgi_app</b>
       Provides the same functionality as "to_app" but uses the deprecated Dispatcher engine. You should use
       "to_app" instead.

   <b>push_header</b>
       Deprecated. Use "push_response_header" instead.

   <b>push_response_header</b>
       Do the same as "response_header", but allow for multiple headers with the same name.

           get '/send/header', sub {
               push_response_header 'x-my-header' =&gt; '1';
               push_response_header 'x-my-header' =&gt; '2';
               # will result in two headers "x-my-header" in the response
           }

   <b>put</b>
       Defines a route for HTTP <b>PUT</b> requests to the given URL:

           put '/resource' =&gt; sub { ... };

       You can also provide the route with a name:

           put 'rec' =&gt; '/resource' =&gt; sub { ... };

       See "uri_for_route" on how this can be used.

   <b>query_parameters</b>
       Returns a Hash::MultiValue object from the request parameters.

           /?foo=hello
           get '/' =&gt; sub {
               my $name = query_parameters-&gt;get('foo');
           };

           /?name=Alice&amp;name=Bob
           get '/' =&gt; sub {
               my @names = query_parameters-&gt;get_all('name');
           };

   <b>redirect</b>
       Generates a HTTP redirect (302). You can either redirect to a complete different site or within the
       application:

           get '/twitter', sub {
               redirect '<a href="http://twitter.com/me">http://twitter.com/me</a>';
               # Any code after the redirect will not be executed.
           };

       <b>WARNING:</b> Issuing a "redirect" immediately exits the current route.  Thus, any code after a "redirect" is
       ignored, until the end of the route.  Hence, it's not necessary anymore to use "return" with "redirect".

       You can also force Dancer to return a specific 300-ish HTTP response code:

           get '/old/:resource', sub {
               redirect '/new/' . route_parameters-&gt;get('resource'), 301;
           };

   <b>request</b>
       Returns a Dancer2::Core::Request object representing the current request.

       See the Dancer2::Core::Request documentation for the methods you can call, for example:

           request-&gt;referer;         # value of the HTTP referer header
           request-&gt;remote_address;  # user's IP address
           request-&gt;user_agent;      # User-Agent header value

   <b>request_data</b>
       Returns the request's body in data form (in case a serializer is set, it will be in deserialized).

       This allows us to distinguish between "body_parameters", a representation of request parameters
       (Hash::MultiValue) and other forms of content.

   <b>request_header</b>
       Returns request header(s).

           get '/get/headers' =&gt; sub {
               my $xfoo = request_header 'X-Foo';
               ...
           };

   <b>response</b>
       Returns the current response object, which is of type Dancer2::Core::Route::REQUEST.

   <b>response_header</b>
       Adds a custom header to response:

           get '/send/header', sub {
               response_header 'x-my-header' =&gt; 'shazam!';
           }

       Note that it will overwrite the old value of the header, if any. To avoid that, see
       "push_response_header".

   <b>response_headers</b>
       Adds custom headers to response:

           get '/send/headers', sub {
               response_headers 'X-Foo' =&gt; 'bar', 'X-Bar' =&gt; 'foo';
           }

   <b>route_parameters</b>
       Returns a Hash::MultiValue object from the route parameters.

           # /hello
           get '/:foo' =&gt; sub {
               my $foo = route_parameters-&gt;get('foo');
           };

   <b>runner</b>
       Returns the runner singleton. Type is Dancer2::Core::Runner.

   <b>send_as</b>
       Allows the current route handler to return specific content types to the client using either a specified
       serializer or as html.

       Any Dancer2 serializer may be used. The specified serializer class will be loaded if required, or an
       error generated if the class can not be found.  Serializer configuration may be added to your apps
       "engines" configuration.

       If "html" is specified, the content will be returned assuming it is HTML with appropriate "Content-Type"
       headers and encoded using the apps configured "charset" (or UTF-8).

           set serializer =&gt; 'YAML';
           set template   =&gt; 'TemplateToolkit';

           # returns html (not YAML)
           get '/' =&gt; sub { send_as html =&gt; template 'welcome.tt' };

           # return json (not YAML)
           get '/json' =&gt; sub {
               send_as JSON =&gt; [ some =&gt; { data =&gt; 'structure' } ];
           };

       "send_as" uses "send_file" to return the content immediately. You may pass any option "send_file"
       supports as an extra option. For example:

           # return json with a custom content_type header
           get '/json' =&gt; sub {
               send_as JSON =&gt; [ some =&gt; { data =&gt; 'structure' } ],
                       { content_type =&gt; 'application/json; charset=UTF-8' },
           };

       <b>WARNING:</b> Issuing a send_as immediately exits the current route, and performs the "send_as". Thus, any
       code after a "send_as" is ignored, until the end of the route. Hence, it's not necessary to use "return"
       with "send_as".

           get '/some/route' =&gt; sub {
               if (...) {
                   send_as JSON =&gt; $some_data;

                   # this code will be ignored
                   do_stuff();
               }
           };

   <b>send_error</b>
       Returns a HTTP error. By default the HTTP code returned is 500:

           get '/photo/:id' =&gt; sub {
               if (...) {
                   send_error("Not allowed", 403);
               } else {
                  # return content
               }
           }

       <b>WARNING:</b> Issuing a send_error immediately exits the current route, and performs the "send_error". Thus,
       any code after a "send_error" is ignored, until the end of the route. Hence, it's not necessary anymore
       to use "return" with "send_error".

           get '/some/route' =&gt; sub {
               if (...) {
                   # Something bad happened, stop immediately!
                   send_error(..);

                   # this code will be ignored
                   do_stuff();
               }
           };

   <b>send_file</b>
       Lets the current route handler send a file to the client. Note that the path of the file must be relative
       to the <b>public</b> directory unless you use the "system_path" option (see below).

           get '/download/:file' =&gt; sub {
               return send_file(route_parameters-&gt;get('file'));
           }

       <b>WARNING:</b> Issuing a "send_file" immediately exits the current route, and performs the "send_file". Thus,
       any code after a "send_file" is ignored, until the end of the route. Hence, it's not necessary anymore to
       use "return" with "send_file".

           get '/some/route' =&gt; sub {
               if (...) {
                   # OK, send her what she wants...
                   send_file(...);

                   # this code will be ignored
                   do_stuff();
               }
           };

       "send_file" will use PSGI streaming if the server supports it (most, if not all, do). You can explicitly
       disable streaming by passing "streaming =&gt; 0" as an option to "send_file".

           get '/download/:file' =&gt; sub {
               send_file( route_parameters-&gt;get('file'), streaming =&gt; 0 );
           }

       The content-type will be set depending on the current MIME types definition (see "mime" if you want to
       define your own).

       If your filename does not have an extension, you are passing in a filehandle, or you need to force a
       specific mime type, you can pass it to "send_file" as follows:

           send_file(route_parameters-&gt;get('file'), content_type =&gt; 'image/png');
           send_file($fh, content_type =&gt; 'image/png');

       Also, you can use your aliases or file extension names on "content_type", like this:

           send_file(route_parameters-&gt;get('file'), content_type =&gt; 'png');

       The encoding of the file or filehandle may be specified by passing both the "content_type" and "charset"
       options. For example:

           send_file($fh, content_type =&gt; 'text/csv', charset =&gt; 'utf-8' );

       For files outside your <b>public</b> folder, you can use the "system_path" switch. Just bear in mind that its
       use needs caution as it can be dangerous.

          send_file('<a href="file:/etc/passwd">/etc/passwd</a>', system_path =&gt; 1);

       If you have your data in a scalar variable, "send_file" can be useful as well. Pass a reference to that
       scalar, and "send_file" will behave as if there was a file with that contents:

          send_file( \$data, content_type =&gt; 'image/png' );

       Note that Dancer is unable to guess the content type from the data contents.  Therefore you might need to
       set the "content_type" properly. For this kind of usage an attribute named "filename" can be useful. It
       is used as the Content-Disposition header, to hint the browser about the filename it should use.

          send_file( \$data, content_type =&gt; 'image/png'
                             filename     =&gt; 'onion.png' );

       By default the Content-Disposition header uses the "attachment" type, which triggers a "Save" dialog in
       some browsers. Supply a "content_disposition" attribute of "inline" to have the file displayed inline by
       the browser.

   <b>session</b>
       Provides access to all data stored in the user's session (if any).

       It can also be used as a setter to store data in the session:

           # getter example
           get '/user' =&gt; sub {
               if (session('user')) {
                   return "Hello, ".session('user')-&gt;name;
               }
           };

           # setter example
           post '/user/login' =&gt; sub {
               ...
               if ($logged_in) {
                   session user =&gt; $user;
               }
               ...
           };

       You may also need to clear a session:

           # destroy session
           get '/logout' =&gt; sub {
               ...
               app-&gt;destroy_session;
               ...
           };

       If you need to fetch the session ID being used for any reason:

           my $id = session-&gt;id;

   <b>set</b>
       Defines a setting:

           set something =&gt; 'value';

       You can set more than one value at once:

           set something =&gt; 'value', otherthing =&gt; 'othervalue';

   <b>setting</b>
       Returns the value of a given setting:

           setting('something'); # 'value'

   <b>splat</b>
       Returns the list of captures made from a route handler with a route pattern which includes wildcards:

           get '/file/*.*' =&gt; sub {
               my ($file, $extension) = splat;
               ...
           };

       There is also the extensive splat (A.K.A. "megasplat"), which allows extensive greedier matching,
       available using two asterisks. The additional path is broken down and returned as an arrayref:

           get '/entry/*/tags/**' =&gt; sub {
               my ( $entry_id, $tags ) = splat;
               my @tags = @{$tags};
           };

       The "splat" keyword in the above example for the route <u>/entry/1/tags/one/two</u> would set $entry_id to 1 and
       $tags to "['one', 'two']".

   <b>start</b>
       Starts the application or the standalone server (depending on the deployment choices).

       This keyword should be called at the very end of the script, once all routes are defined. At this point,
       Dancer2 takes over.

       Prefer "to_app" instead of "start".

   <b>status</b>
       Changes the status code provided by an action. By default, an action will produce an "HTTP 200 OK" status
       code, meaning everything is OK:

           get '/download/:file' =&gt; {
               if (! -f route_parameters-&gt;get('file')) {
                   status 'not_found';
                   return "File does not exist, unable to download";
               }
               # serving the file...
           };

       In that example, Dancer will notice that the status has changed, and will render the response
       accordingly.

       The "status" keyword receives either a numeric status code or its name in lower case, with underscores as
       a separator for blanks - see the list in "HTTP CODES" in Dancer2::Core::HTTP. As an example, The above
       call translates to setting the code to 404.

   <b>template</b>
       Returns the response of processing the given template with the given parameters (and optional settings),
       wrapping it in the default or specified layout too, if layouts are in use.

       An example of a  route handler which returns the result of using template to build a response with the
       current template engine:

           get '/' =&gt; sub {
               ...
               return template 'some_view', { token =&gt; 'value'};
           };

       Note that "template" simply returns the content, so when you use it in a route handler, if execution of
       the route handler should stop at that point, make sure you use "return" to ensure your route handler
       returns the content.

       Since "template" just returns the result of rendering the template, you can also use it to perform other
       templating tasks, e.g. generating emails:

           post '/some/route' =&gt; sub {
               if (...) {
                   email {
                       to      =&gt; '<a href="mailto:someone@example.com">someone@example.com</a>',
                       from    =&gt; '<a href="mailto:foo@example.com">foo@example.com</a>',
                       subject =&gt; 'Hello there',
                       msg     =&gt; template('emails/foo', { name =&gt; body_parameters-&gt;get('name') }),
                   };

                   return template 'message_sent';
               } else {
                   return template 'error';
               }
           };

       Compatibility notice: "template" was changed in version 1.3090 to immediately interrupt execution of a
       route handler and return the content, as it's typically used at the end of a route handler to return
       content.  However, this caused issues for some people who were using "template" to generate emails etc,
       rather than accessing the template engine directly, so this change has been reverted in 1.3091.

       The first parameter should be a template available in the views directory, the second one (optional) is a
       hashref of tokens to interpolate, and the third (again optional) is a hashref of options.

       For example, to disable the layout for a specific request:

           get '/' =&gt; sub {
               template 'index', {}, { layout =&gt; undef };
           };

       Or to request a specific layout, of course:

           get '/user' =&gt; sub {
               template 'user', {}, { layout =&gt; 'user' };
           };

       Some tokens are automatically added to your template ("perl_version", "dancer_version", "settings",
       "request", "vars" and, if you have sessions enabled, "session"). Check Default Template Variables for
       further details.

   <b>to_app</b>
       Returns the PSGI coderef for the current (and only the current) application.

       You can call it as a method on the class or as a DSL:

           my $app = MyApp-&gt;to_app;

           # or

           my $app = to_app;

       There is a Dancer Advent Calendar article &lt;<a href="http://advent.perldancer.org/2014/9">http://advent.perldancer.org/2014/9</a>&gt; covering this keyword and
       its usage further.

   <b>to_dumper</b> <b>($structure)</b>
       Serializes a structure with Data::Dumper.

       Calling this function will <b>not</b> trigger the serialization's hooks.

   <b>to_json</b> <b>($structure,</b> <b>\%options)</b>
       Serializes a structure to JSON. You should probably use "encode_json" instead which handles encoding the
       result for you.

   <b>to_yaml</b> <b>($structure)</b>
       Serializes a structure to YAML.

       Calling this function will <b>not</b> trigger the serialization's hooks.

   <b>true</b>
       Constant that returns a true value (1).

   <b>upload</b>
       Provides access to file uploads. Any uploaded file is accessible as a Dancer2::Core::Request::Upload
       object. You can access all parsed uploads via:

           post '/some/route' =&gt; sub {
               my $file = upload('file_input_foo');
               # $file is a Dancer2::Core::Request::Upload object
           };

       If you named multiple inputs of type "file" with the same name, the "upload" keyword would return an
       Array of Dancer2::Core::Request::Upload objects:

           post '/some/route' =&gt; sub {
               my ($file1, $file2) = upload('files_input');
               # $file1 and $file2 are Dancer2::Core::Request::Upload objects
           };

       You can also access the raw hashref of parsed uploads via the current "request" object:

           post '/some/route' =&gt; sub {
               my $all_uploads = request-&gt;uploads;
               # $all_uploads-&gt;{'file_input_foo'} is a Dancer2::Core::Request::Upload object
               # $all_uploads-&gt;{'files_input'} is an arrayref of Dancer2::Core::Request::Upload objects
           };

       Note that you can also access the filename of the upload received via the "body_parameters" keyword:

           post '/some/route' =&gt; sub {
               # body_parameters-&gt;get('files_input') is the filename of the file uploaded
           };

       See Dancer2::Core::Request::Upload for details about the interface provided.

   <b>uri_for</b>
       Returns a fully-qualified URI for the given path:

           get '/' =&gt; sub {
               redirect uri_for('/path');
               # can be something like: <a href="http://localhost">http://localhost</a>:5000/path
           };

       Query string parameters can be provided by passing a hashref as a second param:

           uri_for('/path', { foo =&gt; 'bar' });
           # would return e.g. <a href="http://localhost">http://localhost</a>:5000/path?foo=bar

       By default, the parameters will be URL encoded:

           uri_for('/path', { foo =&gt; 'hope;faith' });
           # would return <a href="http://localhost">http://localhost</a>:5000/path?foo=hope%3Bfaith

       If desired (for example, if you've already encoded your query parameters and you want to prevent double
       encoding) you can disable URL encoding via a third parameter:

           uri_for('/path', { foo =&gt; 'qux%3Dquo' }, 1);
           # would return <a href="http://localhost">http://localhost</a>:5000/path?foo=qux%3Dquo

   <b>uri_for_route</b>
       An enhanced version of "uri_for" that utilizes routes' names.

           get 'view_entry' =&gt; '/entry/view/:id' =&gt; sub {...};

       Now that the route has a name we can use "uri_for_route" to create a URI for it:

           my $path = uri_for_route(
               'view_entry',
               { 'id'  =&gt; 3 },
               { 'foo' =&gt; 'bar' },
           );

           # (assuming it's run on a local server in HTTP port 5000)
           # $path = '<a href="http://localhost">http://localhost</a>:5000/entry/view/3?foo=bar'

       This works for every HTTP method, except "HEAD" (which is effectively a "GET").

       It can also be used in templates:

           &lt;!-- some_template.tt --&gt;
           [% request.uri_for_route( 'my_route_name', { 'foo' =&gt; 'bar' }, { 'id' =&gt; 4 } ) %]

       There are multiple arguments options:

       •   Route parameters

           The first argument controls the route parameters:

               get 'test' =&gt; '/:foo/:bar' =&gt; sub {1};
               # ...
               $path = uri_for_route( 'test', { 'foo' =&gt; 'hello', 'bar' =&gt; 'world' } );
               # $path = <a href="http://localhost">http://localhost</a>:5000/hello/world

       •   Splat route parameters

           If  you  provide  an  arrayref  instead of hashref, it will assume on these being splat and megasplat
           args:

               get 'test' =&gt; '/*/*/**' =&gt; sub {1};
               # ...
               $path = uri_for_route(
                   'test',
                   [ 'hello', 'world', [ 'myhello', 'myworld' ],
               );
               # $path = <a href="http://localhost">http://localhost</a>:5000/hello/world/myhello/myworld

       •   Mixed route parameters

           If you have a route that includes both, the splat and  megasplat  arguments  need  to  be  under  the
           "splat" key:

               patch 'test' =&gt; '/*/:id/*/:foo/*' =&gt; sub {1};
               # ...
               $path = uri_for_route(
                   'test',
                   {
                       'id'    =&gt; 4,
                       'foo  ' =&gt; 'bar',
                       'splat' =&gt; [ 'hello', 'world' ],
                   }
               );
               # $path = <a href="http://localhost">http://localhost</a>:5000/hello/4/world/bar

       •   Query parameters

           If you want to create a path the query parameters, use the second argument:

               get 'index'       =&gt; '/:foo' =&gt; sub {1};
               get 'update_form' =&gt; '/update' =&gt; sub {1};

               # ...

               $path = uri_for_route(
                   'index',
                   { 'foo' =&gt; 'bar' },
                   { 'id'  =&gt; 1 },
               );
               # $path = <a href="http://localhost">http://localhost</a>:5000/bar?id=1

               $path = uri_for_route( 'update_form', {}, { 'id' =&gt; 2 } );
               # $path = <a href="http://localhost">http://localhost</a>:5000/update?id=2

           (Technically,  only  "GET"  requests  should  include  query parameters, but "uri_for_route" does not
           enforce this.)

       •   Disable URI escaping

           The final parameter determines whether the URI will be URI-escaped or not:

               get 'show_entry' =&gt; '/view/:str_id' =&gt; sub {1};
               # ...
               $path = uri_for_route(
                   'show_entry',
                   { 'str_id' =&gt; '&lt;javascript&gt;...' },
                   {},
               );
               # $path = <a href="http://localhost/view/">http://localhost/view/</a>%3Cjavascript%3E...

           This is useful when your ID is not HTML-safe and might include  HTML  tags  and  Javascript  code  or
           include characters that interfere with the URI request string (like a forward slash).

           This is on by default, but you can disable it by setting this flag:

               get 'show_entry' =&gt; '/view/:str_id' =&gt; sub {1};
               # ...
               $path = uri_for_route(
                   'show_entry',
                   { 'str_id' =&gt; '&lt;javascript&gt;...' },
                   {},
                   1,
               );
               # $path = <a href="http://localhost/view/">http://localhost/view/</a>&lt;javascript&gt;...

   <b>var</b>
       Provides  an  accessor  for variables shared between hooks and route handlers. Given a key/value pair, it
       sets a variable:

           hook before =&gt; sub {
               var foo =&gt; 42;
           };

       Later, route handlers and other hooks will be able to read that variable:

           get '/path' =&gt; sub {
               my $foo = var 'foo';
               ...
           };

   <b>vars</b>
       Returns the hashref of all shared variables set during the hook/route chain with the "var" keyword:

           get '/path' =&gt; sub {
               if (vars-&gt;{foo} eq 42) {
                   ...
               }
           };

   <b>warning</b>
       Logs a warning message through the current logger engine:

           warning "This is a warning";

       See Dancer2::Core::Role::Logger for details on how to configure where log messages go.

</pre><h4><b>AUTHOR</b></h4><pre>
       Dancer Core Developers

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2024 by Alexis Sukrieh.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.40.0                                       2024-12-08                     <u>Dancer2::Manual::<a href="../man3pm/Keywords.3pm.html">Keywords</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>