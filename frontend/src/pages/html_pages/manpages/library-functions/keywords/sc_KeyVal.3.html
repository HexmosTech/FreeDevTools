<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sc::KeyVal - The KeyVal class is designed to simplify the process of allowing a user to specify</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libsc-doc">libsc-doc_2.3.1-21_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sc::KeyVal - The <b>KeyVal</b> class is designed to simplify the process of allowing a user to specify
       keyword/value associations to a C++ program.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;keyval.h&gt;

       Inherits <b>sc::RefCount</b>.

       Inherited by <b>sc::AggregateKeyVal</b>, <b>sc::AssignedKeyVal</b>, <b>sc::PrefixKeyVal</b>, and <b>sc::StringKeyVal</b>.

   <b>Public</b> <b>Types</b>
       enum { <b>MaxKeywordLength</b> = 256 }
       enum <b>KeyValError</b> { <b>OK</b>, <b>HasNoValue</b>, <b>WrongType</b>, <b>UnknownKeyword</b>, <b>OperationFailed</b> }

   <b>Public</b> <b>Member</b> <b>Functions</b>
       int <b>exists</b> (const char *)
           This takes as its only argument a keyword.
       int <b>count</b> (const char *=0)
           If the value of a keyword is an array, then return its length.
       <b>Ref</b>&lt; <b>KeyValValue</b> &gt; <b>value</b> (const char *=0, const <b>KeyValValue</b> &amp;def=<b>KeyValValue</b>())
           Return the value associated with the keyword.
       int <b>booleanvalue</b> (const char *key=0, const <b>KeyValValue</b> &amp;def=<b>KeyValValueboolean</b>())
           Returns the boolean value (0 = false, 1 = true) of key.
       double <b>doublevalue</b> (const char *key=0, const <b>KeyValValue</b> &amp;def=<b>KeyValValuedouble</b>())
           Returns the double value of key.
       float <b>floatvalue</b> (const char *key=0, const <b>KeyValValue</b> &amp;def=<b>KeyValValuefloat</b>())
           Returns the float value of key.
       char <b>charvalue</b> (const char *key=0, const <b>KeyValValue</b> &amp;def=<b>KeyValValuechar</b>())
           Returns the char value of key.
       int <b>intvalue</b> (const char *key=0, const <b>KeyValValue</b> &amp;def=<b>KeyValValueint</b>())
           Returns the int value of key.
       size_t <b>sizevalue</b> (const char *key=0, const <b>KeyValValue</b> &amp;def=<b>KeyValValuesize</b>())
           Returns the size_t value of key.
       char * <b>pcharvalue</b> (const char *key=0, const <b>KeyValValue</b> &amp;def=<b>KeyValValuepchar</b>())
           Returns a copy of the string representation of the key's value.
       std::string <b>stringvalue</b> (const char *key=0, const <b>KeyValValue</b> &amp;def=<b>KeyValValuestring</b>())
           Returns a string representation of the key's value.
       <b>Ref</b>&lt; <b>DescribedClass</b> &gt; <b>describedclassvalue</b> (const char *key=0, const <b>KeyValValue</b>
           &amp;def=<b>KeyValValueRefDescribedClass</b>())
           Returns a reference to an object of type <b>DescribedClass</b>.

       <b>Reading</b> <b>Vectors.</b>
       These members correspond to the above members, but take an additional integer argument, i, which is a
       vector index.

       This is equivalent to getting a value for a keyword named '&lt;i&gt;key&lt;/i&gt;:&lt;i&gt;i&lt;/i&gt;'. The routines that do not
       take key arguments get the value for the keyword named '&lt;i&gt;i&lt;/i&gt;'.

           int <b>exists</b> (const char *key, int i)
           int <b>count</b> (const char *key, int i)
           int <b>booleanvalue</b> (const char *key, int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValueboolean</b>())
           double <b>doublevalue</b> (const char *key, int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValuedouble</b>())
           float <b>floatvalue</b> (const char *key, int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValuefloat</b>())
           char <b>charvalue</b> (const char *key, int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValuechar</b>())
           int <b>intvalue</b> (const char *key, int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValueint</b>())
           size_t <b>sizevalue</b> (const char *key, int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValuesize</b>())
           char * <b>pcharvalue</b> (const char *key, int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValuepchar</b>())
           std::string <b>stringvalue</b> (const char *key, int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValuestring</b>())
           <b>Ref</b>&lt; <b>DescribedClass</b> &gt; <b>describedclassvalue</b> (const char *key, int, const <b>KeyValValue</b>
               &amp;def=<b>KeyValValueRefDescribedClass</b>())
           int <b>exists</b> (int i)
           int <b>count</b> (int i)
           int <b>booleanvalue</b> (int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValueboolean</b>())
           double <b>doublevalue</b> (int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValuedouble</b>())
           float <b>floatvalue</b> (int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValuefloat</b>())
           char <b>charvalue</b> (int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValuechar</b>())
           int <b>intvalue</b> (int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValueint</b>())
           size_t <b>sizevalue</b> (int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValuesize</b>())
           char * <b>pcharvalue</b> (int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValuepchar</b>())
           std::string <b>stringvalue</b> (int i, const <b>KeyValValue</b> &amp;def=<b>KeyValValuestring</b>())
           <b>Ref</b>&lt; <b>DescribedClass</b> &gt; <b>describedclassvalue</b> (int i, const <b>KeyValValue</b>
               &amp;def=<b>KeyValValueRefDescribedClass</b>())

       <b>Reading</b> <b>2D</b> <b>Arrays.</b>
       These members correspond to the above members, but take additional integer arguments, i and j, which is
       an array index.

       This is equivalent to getting a value for a keyword named '&lt;i&gt;key&lt;/i&gt;:&lt;i&gt;i&lt;/i&gt;:&lt;i&gt;j&lt;/i&gt;'. The routines
       that do not take key arguments get the value for the keyword named '&lt;i&gt;i&lt;/i&gt;:&lt;i&gt;j&lt;/i&gt;'.

           int <b>exists</b> (const char *, int, int)
           int <b>count</b> (const char *, int, int)
           int <b>booleanvalue</b> (const char *, int, int, const <b>KeyValValue</b> &amp;def=<b>KeyValValueboolean</b>())
           double <b>doublevalue</b> (const char *key, int, int, const <b>KeyValValue</b> &amp;def=<b>KeyValValuedouble</b>())
           float <b>floatvalue</b> (const char *key, int, int, const <b>KeyValValue</b> &amp;def=<b>KeyValValuefloat</b>())
           char <b>charvalue</b> (const char *key, int, int, const <b>KeyValValue</b> &amp;def=<b>KeyValValuechar</b>())
           int <b>intvalue</b> (const char *key, int, int, const <b>KeyValValue</b> &amp;def=<b>KeyValValueint</b>())
           size_t <b>sizevalue</b> (const char *key, int, int, const <b>KeyValValue</b> &amp;def=<b>KeyValValuesize</b>())
           char * <b>pcharvalue</b> (const char *key, int, int, const <b>KeyValValue</b> &amp;def=<b>KeyValValuepchar</b>())
           std::string <b>stringvalue</b> (const char *key, int, int, const <b>KeyValValue</b> &amp;def=<b>KeyValValuestring</b>())
           <b>Ref</b>&lt; <b>DescribedClass</b> &gt; <b>describedclassvalue</b> (const char *key, int, int, const <b>KeyValValue</b>
               &amp;def=<b>KeyValValueRefDescribedClass</b>())
           int <b>exists</b> (int i, int j)
           int <b>count</b> (int i, int j)
           int <b>booleanvalue</b> (int i, int j, const <b>KeyValValue</b> &amp;def=<b>KeyValValueboolean</b>())
           double <b>doublevalue</b> (int i, int j, const <b>KeyValValue</b> &amp;def=<b>KeyValValuedouble</b>())
           float <b>floatvalue</b> (int i, int j, const <b>KeyValValue</b> &amp;def=<b>KeyValValuefloat</b>())
           char <b>charvalue</b> (int i, int j, const <b>KeyValValue</b> &amp;def=<b>KeyValValuechar</b>())
           int <b>intvalue</b> (int i, int j, const <b>KeyValValue</b> &amp;def=<b>KeyValValueint</b>())
           size_t <b>sizevalue</b> (int i, int j, const <b>KeyValValue</b> &amp;def=<b>KeyValValuesize</b>())
           char * <b>pcharvalue</b> (int i, int j, const <b>KeyValValue</b> &amp;def=<b>KeyValValuepchar</b>())
           std::string <b>stringvalue</b> (int i, int j, const <b>KeyValValue</b> &amp;def=<b>KeyValValuestring</b>())
           <b>Ref</b>&lt; <b>DescribedClass</b> &gt; <b>describedclassvalue</b> (int i, int j, const <b>KeyValValue</b>
               &amp;def=<b>KeyValValueRefDescribedClass</b>())

       <b>Reading</b> <b>3D</b> <b>Arrays.</b>
       These members correspond to the above members, but can be used to read in arrays with more than two
       dimensions.

       The nindex argument is the number of indices in the array. It is followed by an int giving the value of
       each index.

           int <b>Va_exists</b> (const char *key, int nindex,...)
           int <b>Va_count</b> (const char *key, int nindex,...)
           int <b>Va_booleanvalue</b> (const char *key, int nindex,...)
           double <b>Va_doublevalue</b> (const char *key, int nindex,...)
           float <b>Va_floatvalue</b> (const char *key, int nindex,...)
           char <b>Va_charvalue</b> (const char *key, int nindex,...)
           int <b>Va_intvalue</b> (const char *key, int nindex,...)
           size_t <b>Va_sizevalue</b> (const char *key, int nindex,...)
           char * <b>Va_pcharvalue</b> (const char *key, int nindex,...)
           std::string <b>Va_stringvalue</b> (const char *key, int nindex,...)
           <b>Ref</b>&lt; <b>DescribedClass</b> &gt; <b>Va_describedclassvalue</b> (const char *key, int nindex,...)
           KeyValError <b>error</b> ()
               Return the current error condition.
           const char * <b>errormsg</b> (KeyValError err)
               Return a textual representation of err.
           const char * <b>errormsg</b> ()
               Return a textual representation of the current error.
           virtual void <b>errortrace</b> (std::ostream &amp;fp=<b>ExEnv::err0</b>())
               Write a message to fp describing the error.
           virtual void <b>dump</b> (std::ostream &amp;fp=<b>ExEnv::err0</b>())
               Write a message to fp describing the error.
           virtual void <b>print_unseen</b> (std::ostream &amp;fp=<b>ExEnv::out0</b>())
               Print keywords that were never looked at, if possible.
           virtual int <b>have_unseen</b> ()
               Return 1 if there were unseen keywords, 0 if there are none, or -1 this keyval doesn't keep track
               of unseen keywords.
           void <b>verbose</b> (int v)
               Control printing of assignments.
           int <b>verbose</b> () const
               Returns nonzero if assignments are printed.

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       void <b>seterror</b> (KeyValError err)
           Set the current error condition.
       void <b>seterror</b> (KeyValValue::KeyValValueError err)
           Set the current error condition.
       virtual int <b>key_exists</b> (const char *)=0
           Ultimately called by exists.
       virtual int <b>key_count</b> (const char *=0)
           Ultimately called by count.
       virtual <b>Ref</b>&lt; <b>KeyValValue</b> &gt; <b>key_value</b> (const char *, const <b>KeyValValue</b> &amp;def)=0
           Ultimately called by value.
       virtual int <b>key_booleanvalue</b> (const char *, const <b>KeyValValue</b> &amp;def)
           Ultimately called by booleanvalue.
       virtual double <b>key_doublevalue</b> (const char *key, const <b>KeyValValue</b> &amp;def)
           Ultimately called by doublevalue.
       virtual float <b>key_floatvalue</b> (const char *key, const <b>KeyValValue</b> &amp;def)
           Ultimately called by floatvalue.
       virtual char <b>key_charvalue</b> (const char *key, const <b>KeyValValue</b> &amp;def)
           Ultimately called by charvalue.
       virtual int <b>key_intvalue</b> (const char *key, const <b>KeyValValue</b> &amp;def)
           Ultimately called by intvalue.
       virtual size_t <b>key_sizevalue</b> (const char *key, const <b>KeyValValue</b> &amp;def)
           Ultimately called by sizevalue.
       virtual char * <b>key_pcharvalue</b> (const char *key, const <b>KeyValValue</b> &amp;def)
           Ultimately called by pcharvalue.
       virtual std::string <b>key_stringvalue</b> (const char *key, const <b>KeyValValue</b> &amp;def)
           Ultimately called by stringvalue.
       virtual <b>Ref</b>&lt; <b>DescribedClass</b> &gt; <b>key_describedclassvalue</b> (const char *key, const <b>KeyValValue</b> &amp;def)
           Ultimately called by describedclassvalue.

   <b>Protected</b> <b>Attributes</b>
       int <b>verbose_</b>

   <b>Friends</b>
       class <b>AggregateKeyVal</b>
       class <b>PrefixKeyVal</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       The <b>KeyVal</b> class is designed to simplify the process of allowing a user to specify keyword/value
       associations to a C++ program.

       A flexible input style and ease of use for the programmer is achieved with this method. Keywords are
       represented by null terminated character arrays. The keywords are organized hierarchially, in a manner
       similar to the way that many file systems are organized. One character is special, ':', which is used to
       separate the various hierarchial labels, which are referred to as 'segments', in the keyword.

       A convention for specifying arrays is provided by <b>KeyVal</b>. Each index of the array is given by appending a
       segment containing the character representation of the index. Thus, 'array:3:4' would be a the keyword
       corresponding to fourth row and fifth column of 'array', since indexing starts at zero.

       To allow the <b>KeyVal</b> class to have associations that can represent data for classes, the keyword can be
       associated with a class as well as a value. This permits polymorphic data to be unambiguously represented
       by keyword/value associations. Most use of <b>KeyVal</b> need not be concerned with this.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>int</b> <b>sc::KeyVal::count</b> <b>(const</b> <b>char</b> <b>*</b> <b>=</b> <b>0)</b>
       If the value of a keyword is an array, then return its length. If no arguments are given then the top
       level will be checked to see if it is an array and, if so, the number of elements will be counted.

   <b>int</b> <b>sc::KeyVal::exists</b> <b>(const</b> <b>char</b> <b>*)</b>
       This takes as its only argument a keyword. Returns 1 if the keyword has a value and 0 otherwise.

   <b>char*</b> <b>sc::KeyVal::pcharvalue</b> <b>(const</b> <b>char</b> <b>*</b> <b>key</b> <b>=</b> <b>0,</b> <b>const</b> <b>KeyValValue</b> <b>&amp;</b> <b>def</b> <b>=</b> <b>KeyValValuepchar())</b>
       Returns a copy of the string representation of the key's value. Storage for the copy is obtained with
       new.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for MPQC from the source code.

Version 2.3.1                                    Sun Oct 4 2020                                    <u>sc::<a href="../man3/KeyVal.3.html">KeyVal</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>