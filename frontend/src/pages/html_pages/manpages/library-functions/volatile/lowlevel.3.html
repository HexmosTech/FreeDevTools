<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lowlevel - Low level register access</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbcm2835-dev">libbcm2835-dev_1.75+ds-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       lowlevel - Low level register access

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       uint32_t * <b>bcm2835_regbase</b> (uint8_t regbase)
       uint32_t <b>bcm2835_peri_read</b> (volatile uint32_t *paddr)
       uint32_t <b>bcm2835_peri_read_nb</b> (volatile uint32_t *paddr)
       void <b>bcm2835_peri_write</b> (volatile uint32_t *paddr, uint32_t value)
       void <b>bcm2835_peri_write_nb</b> (volatile uint32_t *paddr, uint32_t value)
       void <b>bcm2835_peri_set_bits</b> (volatile uint32_t *paddr, uint32_t value, uint32_t mask)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       These functions provide low level register access, and should not generally need to be used

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>uint32_t</b> <b>bcm2835_peri_read</b> <b>(volatile</b> <b>uint32_t</b> <b>*</b> <b>paddr)</b> <b>[extern]</b>
       Reads 32 bit value from a peripheral address WITH a memory barrier before and after each read. This is
       safe, but slow. The MB before protects this read from any in-flight reads that didn't use a MB. The MB
       after protects subsequent reads from another peripheral.

       <b>Parameters</b>
           <u>paddr</u> Physical address to read from. See BCM2835_GPIO_BASE etc.

       <b>Returns</b>
           the value read from the 32 bit register

       <b>See</b> <b>also</b>
           Physical Addresses

   <b>uint32_t</b> <b>bcm2835_peri_read_nb</b> <b>(volatile</b> <b>uint32_t</b> <b>*</b> <b>paddr)</b> <b>[extern]</b>
       Reads 32 bit value from a peripheral address WITHOUT the read barriers You should only use this when: o
       your code has previously called <b>bcm2835_peri_read()</b> for a register within the same peripheral, and no
       read or write to another peripheral has occurred since. o your code has called bcm2835_memory_barrier()
       since the last access to ANOTHER peripheral.

       <b>Parameters</b>
           <u>paddr</u> Physical address to read from. See BCM2835_GPIO_BASE etc.

       <b>Returns</b>
           the value read from the 32 bit register

       <b>See</b> <b>also</b>
           Physical Addresses

   <b>void</b> <b>bcm2835_peri_set_bits</b> <b>(volatile</b> <b>uint32_t</b> <b>*</b> <b>paddr,</b> <b>uint32_t</b> <b>value,</b> <b>uint32_t</b> <b>mask)</b> <b>[extern]</b>
       Alters a number of bits in a 32 peripheral regsiter. It reads the current valu and then alters the bits
       defines as 1 in mask, according to the bit value in value. All other bits that are 0 in the mask are
       unaffected. Use this to alter a subset of the bits in a register. Memory barriers are used. Note that
       this is not atomic; an interrupt routine can cause unexpected results.

       <b>Parameters</b>
           <u>paddr</u> Physical address to read from. See BCM2835_GPIO_BASE etc.
           <u>value</u> The 32 bit value to write, masked in by mask.
           <u>mask</u> Bitmask that defines the bits that will be altered in the register.

       <b>See</b> <b>also</b>
           Physical Addresses

   <b>void</b> <b>bcm2835_peri_write</b> <b>(volatile</b> <b>uint32_t</b> <b>*</b> <b>paddr,</b> <b>uint32_t</b> <b>value)</b> <b>[extern]</b>
       Writes 32 bit value from a peripheral address WITH a memory barrier before and after each write This is
       safe, but slow. The MB before ensures that any in-flight write to another peripheral completes before
       this write is issued. The MB after ensures that subsequent reads and writes to another peripheral will
       see the effect of this write.

       This is a tricky optimization; if you aren't sure, use the barrier version.

       <b>Parameters</b>
           <u>paddr</u> Physical address to read from. See BCM2835_GPIO_BASE etc.
           <u>value</u> The 32 bit value to write

       <b>See</b> <b>also</b>
           Physical Addresses

   <b>void</b> <b>bcm2835_peri_write_nb</b> <b>(volatile</b> <b>uint32_t</b> <b>*</b> <b>paddr,</b> <b>uint32_t</b> <b>value)</b> <b>[extern]</b>
       Writes 32 bit value from a peripheral address without the write barrier You should only use this when: o
       your code has previously called <b>bcm2835_peri_write()</b> for a register within the same peripheral, and no
       other peripheral access has occurred since. o your code has called bcm2835_memory_barrier() since the
       last access to ANOTHER peripheral.

       This is a tricky optimization; if you aren't sure, use the barrier version.

       <b>Parameters</b>
           <u>paddr</u> Physical address to read from. See BCM2835_GPIO_BASE etc.
           <u>value</u> The 32 bit value to write

       <b>See</b> <b>also</b>
           Physical Addresses

   <b>uint32_t</b> <b>*</b> <b>bcm2835_regbase</b> <b>(uint8_t</b> <b>regbase)</b> <b>[extern]</b>
       Gets the base of a register

       <b>Parameters</b>
           <u>regbase</u> You can use one of the common values BCM2835_REGBASE_* in <b>bcm2835RegisterBase</b>

       <b>Returns</b>
           the register base

       <b>See</b> <b>also</b>
           Physical Addresses

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for bcm2835 from the source code.

bcm2835                                           Version 1.75                                       <u><a href="../man3/lowlevel.3.html">lowlevel</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>