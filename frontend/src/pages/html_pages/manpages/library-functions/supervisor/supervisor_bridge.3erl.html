<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>supervisor_bridge - Generic supervisor bridge behavior.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       supervisor_bridge - Generic supervisor bridge behavior.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  behavior  module  provides  a  supervisor  bridge, a process that connects a subsystem not designed
       according to the OTP design principles to a supervision  tree.  The  supervisor  bridge  sits  between  a
       supervisor  and  the  subsystem.  It  behaves  like  a  real  supervisor to its own supervisor, but has a
       different interface than a real supervisor to  the  subsystem.  For  more  information,  see   Supervisor
       Behaviour in OTP Design Principles.

       A  supervisor  bridge  assumes  the  functions for starting and stopping the subsystem to be located in a
       callback module exporting a predefined set of functions.

       The <u><a href="../man3erl/sys.3erl.html">sys</a>(3erl)</u> module can be used for debugging a supervisor bridge.

       Unless otherwise stated, all functions in this module fail if the specified supervisor  bridge  does  not
       exist or if bad arguments are specified.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>start_link(Module,</b> <b>Args)</b> <b>-&gt;</b> <b>Result</b>

       <b>start_link(SupBridgeName,</b> <b>Module,</b> <b>Args)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 SupBridgeName =
                     {local, Name} | {global, GlobalName} | {via, Module, ViaName}
                 Name = atom()
                 GlobalName = ViaName = term()
                 Module = module()
                 Args = term()
                 Result = {ok, Pid} | ignore | {error, Error}
                 Error = {already_started, Pid} | term()
                 Pid = pid()

              Creates  a  supervisor bridge process, linked to the calling process, which calls <u>Module:init/1</u> to
              start the subsystem. To ensure a synchronized startup procedure, this  function  does  not  return
              until <u>Module:init/1</u> has returned.

                * If  <u>SupBridgeName={local,Name}</u>,  the  supervisor  bridge  is  registered locally as <u>Name</u> using
                  <u>register/2</u>.

                * If  <u>SupBridgeName={global,GlobalName}</u>,  the  supervisor  bridge  is  registered  globally   as
                  <u>GlobalName</u> using <u>global:register_name/2</u>.

                * If  <u>SupBridgeName={via,Module,ViaName}</u>, the supervisor bridge is registered as <u>ViaName</u> using a
                  registry represented by Module. The <u>Module</u> callback is to  export  functions  <u>register_name/2</u>,
                  <u>unregister_name/1</u>, and <u>send/2</u>, which are to behave like the corresponding functions in <u>global</u>.
                  Thus, <u>{via,global,GlobalName}</u> is a valid reference.

              If no name is provided, the supervisor bridge is not registered.

              <u>Module</u> is the name of the callback module.

              <u>Args</u> is an arbitrary term that is passed as the argument to <u>Module:init/1</u>.

                * If  the  supervisor  bridge  and  the subsystem are successfully started, the function returns
                  <u>{ok,Pid}</u>, where <u>Pid</u> is is the pid of the supervisor bridge.

                * If there already exists a process with  the  specified  <u>SupBridgeName</u>,  the  function  returns
                  <u>{error,{already_started,Pid}}</u>, where <u>Pid</u> is the pid of that process.

                * If  <u>Module:init/1</u>  returns  <u>ignore</u>,  this  function  returns <u>ignore</u> as well and the supervisor
                  bridge terminates with reason <u>normal</u>.

                * If <u>Module:init/1</u> fails or returns an error tuple or an incorrect value, this function  returns
                  <u>{error,Errorr}</u>,  where  <u>Error</u>  is  a term with information about the error, and the supervisor
                  bridge terminates with reason <u>Error</u>.

</pre><h4><b>CALLBACK</b> <b>FUNCTIONS</b></h4><pre>
       The following functions must be exported from a <u>supervisor_bridge</u> callback module.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>Module:init(Args)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Args = term()
                 Result = {ok,Pid,State} | ignore | {error,Error}
                  Pid = pid()
                  State = term()
                  Error = term()

              Whenever a supervisor bridge is started using <u>start_link/2,3</u>, this function is called by  the  new
              process to start the subsystem and initialize.

              <u>Args</u> is the <u>Args</u> argument provided to the start function.

              The  function  is  to  return  <u>{ok,Pid,State}</u>,  where  <u>Pid</u>  is  the pid of the main process in the
              subsystem and <u>State</u> is any term.

              If later <u>Pid</u> terminates with a reason <u>Reason</u>, the supervisor bridge terminates with reason  <u>Reason</u>
              as  well. If later the supervisor bridge is stopped by its supervisor with reason <u>Reason</u>, it calls
              <u>Module:terminate(Reason,State)</u> to terminate.

              If the initialization fails, the function is to return <u>{error,Error}</u>, where <u>Error</u> is any term,  or
              <u>ignore</u>.

       <b>Module:terminate(Reason,</b> <b>State)</b>

              Types:

                 Reason = shutdown | term()
                 State = term()

              This  function  is  called by the supervisor bridge when it is about to terminate. It is to be the
              opposite of <u>Module:init/1</u> and stop the subsystem and do any  necessary  cleaning  up.  The  return
              value is ignored.

              <u>Reason</u>  is  <u>shutdown</u>  if  the supervisor bridge is terminated by its supervisor. If the supervisor
              bridge terminates because a a linked process (apart from the main process of  the  subsystem)  has
              terminated with reason <u>Term</u>, then <u>Reason</u> becomes <u>Term</u>.

              <u>State</u> is taken from the return value of <u>Module:init/1</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/supervisor.3erl.html">supervisor</a>(3erl)</u>, <u><a href="../man3erl/sys.3erl.html">sys</a>(3erl)</u>

Ericsson AB                                        stdlib 3.17                           <u><a href="../man3erl/supervisor_bridge.3erl.html">supervisor_bridge</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>