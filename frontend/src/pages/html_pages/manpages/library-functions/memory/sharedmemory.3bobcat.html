<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::SharedMemory - Shared Memory memory structure</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::SharedMemory - Shared Memory memory structure

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/sharedmemory&gt;</b>
       Linking option: <u>-lbobcat</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  class  <b>FBB::SharedMemory</b>  implements a usable interface to a shared memory segment made available by
       <u>FBB::SharedSegment</u> and monitored by <u>FBB::SharedPos</u>. It is the main  building  block  for  <u>FBB::SharedBuf</u>,
       defining  the  `device’  to  which  <u>FBB::SharedBuf</u>  interfaces.  All  shared memory related I/O should be
       performed by <b>FBB::SharedMemory</b> objects, which are true objects, not themselves residing in shared memory.

       An <b>FBB::SharedMemory</b> object defines, connects to and manages access to shared memory,  encapsulating  all
       raw   shared   memory   operations.   In   addition  to  the  class  <b>FBB::SharedMemory</b>  the  header  file
       <u>bobcat/sharedmemory</u> also defines a <b>struct</b> <b>SharedEnum__</b> defining <b>enum</b> <b>SizeUnit</b> within the namespace <u>FBB</u>.

       The requested amount of shared memory is always a lower bound to the maximum amount of shared memory that
       eventually may become available. When defining a <b>SharedMemory</b> object not all of its potentially available
       shared memory is immediately allocated. Shared memory will be allocated by the <b>SharedMemory</b>  object  once
       needed (up to a calculated maximum).

       As  a  fictitious example: assume 100 kB of memory is requested. The <b>SharedMemory</b> object then maintains a
       table of, e.g., 10 entries, each entry controlling access to a shared memory block of 10 kB. These 10  kB
       blocks  aren’t  immediately  allocated,  but  become  available  once the program reads from or writes to
       addresses located in these data blocks. Newly allocated data blocks are initialized to 0-bytes.

       Caveat: when constructing a shared memory segment make sure the segment’s ID is stored at  a  retrievable
       location.  This  allows  other  processes  to  access  the  shared segment. The shared segment ID is also
       required to delete a shared memory segment. If the shared segment ID is lost, the memory occupied by  the
       shared  memory  segment  remains  inaccessible  (although they can be retrieved and removed by additional
       means, like <b><a href="../man1/ipcs.1.html">ipcs</a></b>(1) and <b><a href="../man1/ipcrm.1.html">ipcrm</a></b>(1)). The member <u>id</u> returns the ID of the shared memory currently  monitored
       by an <b>FBB::SharedMemory</b> object.

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All  constructors,  members,  operators  and manipulators, mentioned in this man-page, are defined in the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       <b>FBB::SharedEnum__</b>

       The <b>struct</b> <b>SharedEnum__</b> is a wrapper struct around <b>enum</b> <b>SizeUnit</b>, which is available through  inheritance
       in  several  <b>FBB::Shared*</b> classes, and offers symbolic constants defining standard memory sizes. The <b>enum</b>
       <b>SizeUnit</b> defines the following symbolic constants:

       o      <b>kB</b>, representing 1024 (2**10) bytes of memory;

       o      <b>MB</b>, representing 1048576 (2**20) bytes of memory;

       o      <b>GB</b>, representing 1073741824 (2**30) bytes of memory

</pre><h4><b>CONSTRUCTORS,</b> <b>DESTRUCTOR</b></h4><pre>
       o      <b>SharedMemory()</b>:
              The default constructor defines  an  empty  stub,  which  cannot  immediately  be  used.   As  the
              <b>SharedMemory</b>  class supports move assignment, empty stubs can easily be (re)configured at any time
              after their construction.

       o      <b>SharedMemory(size_t</b> <b>maxSize,</b> <b>SizeUnit</b> <b>sizeUnit,</b> <b>size_t</b> <b>access</b> <b>=</b> <b>0600)</b>:
              This constructor creates a shared memory segment having a capacity of at least <u>maxSize</u> <u>*</u>  <u>sizeUnit</u>
              bytes. The shared memory’s access rights are defined by the <u>access</u> parameter, using the well-known
              (<b><a href="../man1/chmod.1.html">chmod</a></b>(1))  octal  values  to  define  access  rights  for  the  owner,  the  group and others. If
              construction succeeds the shared memory is ready for use. If construction fails, an <u>FBB::Exception</u>
              is thrown.

       o      <b>SharedMemory(int</b> <b>id)</b>:
              This constructor connects to a shared memory segment having ID <u>id</u>. If  construction  succeeds  the
              shared memory is ready for use. If construction fails (e.g., no shared memory segment having ID <u>id</u>
              exists), an <u>FBB::Exception</u> is thrown.

       o      <b>~SharedMemory()</b>:
              The  destructor detaches any attached shared memory segments from the <b>FBB::SharedMemory</b> object. If
              the shared memory segment is currently  locked  by  the  <b>FBB::SharedMemory</b>  object,  the  lock  is
              removed.

       Copy and move constructors (and assignment operators) are not available.

</pre><h4><b>OVERLOADED</b> <b>OPERATORS</b></h4><pre>
       o      <b>std::ostream</b> <b>&amp;operator&lt;&lt;(std::ostream</b> <b>&amp;out,</b> <b>SharedMemory</b> <b>const</b> <b>&amp;sharedMemory)</b>:
              The  overloaded  insertion  operator  inserts  information  about the <u>SharedMemory</u> object into the
              provide <u>ostream</u> object. The IDs of the shared segments, their sizes, the maximum number of  shared
              memory  segments,  the  number  of  bytes  that can be read from the shared memory, and its actual
              storage capacity, etc., are displayed.

       o      <b>SharedMemory</b> <b>&amp;operator=(SharedMemory</b> <b>&amp;&amp;rhs)</b>:
              The overloaded move assignment operator is available. It is used to (re)define the  shared  memory
              segment an <b>FBB::SharedMemory</b> object is interfacing with.

</pre><h4><b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       o      <b>size_t</b> <b>blockOffset()</b> <b>const</b>:
              The  offset  within the shared segment data block matching <u>offset</u>’s return value is returned. 0 is
              returned if the <b>SharedMemory</b> object has not yet been connected to a shared memory block (or if the
              offset happens to be at the block’s offset 0).

       o      <b>void</b> <b>clear()</b>:
              First, the shared memory is locked. Next, all shared data segment  are  deleted,  and  the  shared
              memory’s  own  data are reset to indicate it is completely empty. Following this the shared memory
              segment is unlocked again. Returning from <u>clear</u> the shared memory The <b>FBB::SharedMemory</b> object  is
              effectively re-initialized, with <u>offset</u> and <u>nReadable</u> returning 0.

              An  <u>FBB::Exception</u>  is  thrown  if  the <b>SharedMemory</b> object has not yet been connected to a shared
              memory block.

       o      <b>size_t</b> <b>dataSegmentSize()</b> <b>const</b>:
              Returns the size (in bytes) of shared memory data block. 0 is returned if the <b>SharedMemory</b>  object
              has not yet been connected to a shared memory block.

       o      <b>int</b> <b>get()</b>:
              First  the  <b>FBB::SharedMemory</b>  object  calls  <u>lock</u>  to  lock  the  shared memory segment. Next the
              character at <u>offset</u> is retrieved and <u>offset</u>  is  incremented.  Then  <u>unlock</u>  is  called,  and  the
              retrieved  character  is  returned.  If  <u>offset</u> is at least equal to <u>nReadable,</u> <u>EOF</u> is immediately
              returned.

              An <u>FBB::Exception</u> is thrown if the <b>SharedMemory</b> object has not yet  been  connected  to  a  shared
              memory block.

       o      <b>int</b> <b>id()</b> <b>const</b>:
              The ID of the shared memory segment is returned. Following <u>kill</u> <u>id</u> returns -1, indicating that the
              shared  segment  cannot  be  used  anymore  (note  that <u>operator=</u> can be used to re-initialize the
              <b>FBB::SharedMemory</b> object).

       o      <b>SharedType</b> <b>*install(std::streamsize</b> <b>*offset,</b> <b>Params</b> <b>&amp;&amp;...params)</b>:
              This member was  implemented  as  a  member  template,  using  <u>typename</u>  <u>SharedType</u>  and  <u>typename</u>
              <u>...Params</u>, allowing perfect forwarding of arguments to <u>SharedType</u>’s constructor.

              This  member  installs  a  <u>SharedType</u>  object  at <b>SharedMemory’s</b> at <b>SharedMemory</b>’s first available
              offset: either at the current offset, or (if <u>SharedType’s</u> size is too big to fit  in  the  current
              data block at offset) at the first byte of the next <u>SharedSegment</u> shared data block.

              The  actual  offset  where  the  <u>SharedType</u>  object  is installed is returned in <u>*offset</u>, unless a
              <u>nullptr</u> is passed as <u>install’s</u> first argument.

              A pointer to the  installed  <u>SharedType</u>  is  returned,  with  <u>shmem.offset</u>  pointing  just  beyond
              <u>SharedType’s</u> last byte.

              The  <u>SharedType</u>  object  is installed using placement new. E.g., the following example illustrates
              how a <b><a href="../man3bobcat/SharedMutex.3bobcat.html">SharedMutex</a></b>(3bobcat) object can be installed at the first possible location of  <u>SharedMemory</u>
              <u>shmem</u>:

                  std::streamsize offset;
                  FBB::SharedMutex *mutexPtr = shmem.install&lt;FBB::SharedMutex&gt;(&amp;offset);

              If  the  installed  object  must  be destroyed, its destructor must explicitly be called. E.g., to
              destroy the <u>Mutex</u> pointed at by <u>mutexPtr</u> use <u>mutexPtr-&gt;~SharedMutex()</u>.

              An <u>FBB::Exception</u> is thrown if <u>shmem</u> could not install  the  object  in  its  shared  memory  data
              blocks.

       o      <b>void</b> <b>kill()</b>:
              Without  locking  the  shared  memory  all  shared memory controlled by the <b>SharedMemory</b> object is
              deleted. The <b>SharedMemory</b> object is unusable after returning from <u>kill</u>, with its <u>id</u> member returns
              -1. Nothing happens if this member is called  when  the  <b>SharedMemory</b>  object  has  not  yet  been
              connected to a shared memory block.

       o      <b>std::streamsize</b> <b>maxOffset()</b> <b>const</b>:
              The  maximum  possible  offset  that  can  be used with the shared memory segment is returned. The
              members <u>offset</u> and <u>nReadable</u> never exceed the value returned by <u>maxOffset</u>. 0 is  returned  if  the
              <b>SharedMemory</b> object has not yet been connected to a shared memory block.

       o      <b>std::streamsize</b> <b>nReadable()</b> <b>const</b>:
              The  number  of  characters  (bytes)  that  can be read from the beginning of the shared memory is
              returned. 0 is returned if the <b>SharedMemory</b> object has not yet been connected to a  shared  memory
              block.

       o      <b>std::streamsize</b> <b>offset()</b> <b>const</b>:
              The offset within the shared memory segment (i.e., relative to the segment’s <u>ios::beg</u> position) is
              returned.  0  is returned if the <b>SharedMemory</b> object has not yet been connected to a shared memory
              block (or if the offset happens to be at the shared memory’s offset 0).

       o      <b>char</b> <b>*ptr()</b>:
              Returns 0 if <u>offset()</u> <u>==</u> <u>maxOffset()</u>. Otherwise it returns a pointer to  the  character  at  index
              <u>offset</u> within the shared memory segment.

              An  <u>FBB::Exception</u>  is  thrown  if  the <b>SharedMemory</b> object has not yet been connected to a shared
              memory block.

       o      <b>int</b> <b>put(int</b> <b>ch)</b>:
              After locking the appropriate shared data segment, <u>ch</u> is written at position <u>offset</u>,  incrementing
              <u>offset</u> thereafter. If <u>ch</u> <u>==</u> <u>EOF,</u> <u>EOF</u> is immediately returned.

              An  <u>FBB::Exception</u>  is  thrown  if  the <b>SharedMemory</b> object has not yet been connected to a shared
              memory block.

       o      <b>int</b> <b>read(Type</b> <b>*value)</b>:
              This member was implemented as a member template. It calls the next member, casting <u>Type</u> <u>*</u> to <u>char</u>
              <u>*</u>, and using <u>sizeof(Type)</u> as its second argument.  The number of bytes actually read is  returned.
              This member returns -1 if initially <u>offset</u> was at least equal to <u>nReadable</u>.

              An  <u>FBB::Exception</u>  is  thrown  if  the <b>SharedMemory</b> object has not yet been connected to a shared
              memory block.

       o      <b>int</b> <b>read(char</b> <b>*data,</b> <b>std::streamsize</b> <b>len)</b>:
              While locking the appropriate shared data segment(s) at most <u>len</u> bytes are read  from  the  shared
              memory,  starting  at <u>offset</u>. The bytes read from shared memory are stored at <u>data</u>.  The number of
              bytes actually read is returned. This member returns -1 if initially <u>offset</u> was at least equal  to
              <u>nReadable</u>.

              An  <u>FBB::Exception</u>  is  thrown  if  the <b>SharedMemory</b> object has not yet been connected to a shared
              memory block.

       o      <b>int</b> <b>read(std::ios::off_type</b> <b>offset,</b> <b>Type</b> <b>*value,</b> <b>std::ios::seekdir</b> <b>origin</b> <b>=</b> <b>std::ios::beg)</b>:
              This member was implemented as a member template. After  changing  the  <b>SharedMemory</b>’s  offset  to
              <u>offset</u> (relative to <u>origin</u>), it calls the first <u>read</u> member, passing it <u>value</u>. The number of bytes
              actually  read  is  returned.  This  member  returns  -1 if initially <u>offset</u> was at least equal to
              <u>nReadable</u>.

              An <u>FBB::Exception</u> is thrown if the <b>SharedMemory</b> object has not yet  been  connected  to  a  shared
              memory block.

       o      <b>void</b> <b>remove()</b>:
              The  shared  memory  is  locked, after which all shared memory controlled by the <b>FBB::SharedMemory</b>
              object is deleted. The <b>FBB::SharedMemory</b> object is unusable after returning from <u>remove</u>.

              An <u>FBB::Exception</u> is thrown if the <b>SharedMemory</b> object has not yet  been  connected  to  a  shared
              memory block.

       o      <b>std::ios::pos_type</b> <b>seek(std::ios::off_type</b> <b>offset,</b> <b>std::ios::seekdir</b> <b>origin</b> <b>=</b> <b>std::ios::beg)</b>:
              Moves  the  <u>offset</u> position relative to <u>way</u>. The value -1 is returned when seeking before offset 0
              or beyond <u>maxOffset</u>, otherwise the offset relative to the begin  location  of  the  shared  memory
              (i.e,  <u>offset</u>  for  <u>origin</u> <u>==</u> <u>ios::beg</u>) is returned.  0 is returned if the <b>SharedMemory</b> object has
              not yet been connected to a shared memory block (or if the offset happens  to  be  at  the  shared
              memory’s offset 0).

       o      <b>std::streamsize</b> <b>showmanyc()</b> <b>const</b>:
              The  number of characters that can be read from the current shared segment data block is returned.
              This member interrogates the number of readable characters in  the  shared  memory  segment.  This
              number  may change while this member is being executed. In order to receive a stable return value,
              calling functions should have obtained a lock on the shared memory  segment  before  calling  this
              member.  0  is  returned  if the <b>SharedMemory</b> object has not yet been connected to a shared memory
              block (or if the no characters can currently be read).

       o      <b>void</b> <b>swap(SharedMemory</b> <b>&amp;other)</b>:
              The current and other <b>FBB::SharedMemory</b> objects are swapped.

       o      <b>bool</b> <b>truncate(std::streamsize</b> <b>offset)</b>:
              If <u>offset</u> is not exceeding the value returned by <u>nReadable</u> <u>nReadable</u> is changed to <u>offset</u> and <u>true</u>
              is returned. Otherwise <u>false</u> is returned, and the value returned by <u>nReadable</u> is not changed.

              An <u>FBB::Exception</u> is thrown if the <b>SharedMemory</b> object has not yet  been  connected  to  a  shared
              memory block.

       o      <b>int</b> <b>write(Type</b> <b>const</b> <b>*value)</b>:
              This  member  was implemented as a member template. It calls the next member, casting <u>Type</u> <u>const</u> <u>*</u>
              to <u>char</u> <u>const</u> <u>*</u>, and using <u>sizeof(Type)</u> as its second argument.   The  number  of  bytes  actually
              written is returned. This member returns -1 if initially <u>offset</u> was at least equal to <u>maxOffset</u>.

              An  <u>FBB::Exception</u>  is  thrown  if  the <b>SharedMemory</b> object has not yet been connected to a shared
              memory block.

       o      <b>int</b> <b>write(char</b> <b>const</b> <b>*data,</b> <b>std::streamsize</b> <b>len)</b>:
              The <b>FBB::SharedMemory</b> object calls <u>lock</u> to lock the shared memory, and writes at  most  <u>len</u>  bytes
              into  the  shared memory, starting at <u>offset</u>. Next, <u>unlock</u> is called. The number of bytes actually
              written is returned. The member function returns -1 if initially <u>offset</u> is equal to <u>maxOffset</u>.

              An <u>FBB::Exception</u> is thrown if the <b>SharedMemory</b> object has not yet  been  connected  to  a  shared
              memory block.

       o      <b>int</b> <b>write(std::ios::off_type</b> <b>offset,</b> <b>Type</b> <b>const</b> <b>*value,</b> <b>std::ios::seekdir</b> <b>origin</b> <b>=</b> <b>std::ios::beg)</b>:
              This  member  was  implemented  as  a member template. After changing the <b>SharedMemory</b>’s offset to
              <u>offset</u> (relative to <u>origin</u>), it calls the first <u>write</u> member, passing  it  <u>value</u>.  The  number  of
              bytes  actually written is returned. This member returns -1 if initially <u>offset</u> was at least equal
              to <u>maxOffset</u>.

              An <u>FBB::Exception</u> is thrown if the <b>SharedMemory</b> object has not yet  been  connected  to  a  shared
              memory block.

</pre><h4><b>EXAMPLE</b></h4><pre>
       See the <b><a href="../man3bobcat/sharedstream.3bobcat.html">sharedstream</a></b>(3bobcat) man page.

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/sharedmemory</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7),     <b><a href="../man1/chmod.1.html">chmod</a></b>(1),     <b><a href="../man1/ipcs.1.html">ipcs</a></b>(1),     <b><a href="../man1/ipcrm.1.html">ipcrm</a></b>(1),    <b><a href="../man3bobcat/isharedstream.3bobcat.html">isharedstream</a></b>(3bobcat),    <b><a href="../man3bobcat/osharedstream.3bobcat.html">osharedstream</a></b>(3bobcat),
       <b><a href="../man3bobcat/sharedblock.3bobcat.html">sharedblock</a></b>(3bobcat),      <b><a href="../man3bobcat/sharedcondition.3bobcat.html">sharedcondition</a></b>(3bobcat),      <b><a href="../man3bobcat/sharedmutex.3bobcat.html">sharedmutex</a></b>(3bobcat),       <b><a href="../man3bobcat/sharedpos.3bobcat.html">sharedpos</a></b>(3bobcat),
       <b><a href="../man7bobcat/sharedreadme.7bobcat.html">sharedreadme</a></b>(7bobcat), <b><a href="../man3bobcat/sharedsegment.3bobcat.html">sharedsegment</a></b>(3bobcat), <b><a href="../man3bobcat/sharedstream.3bobcat.html">sharedstream</a></b>(3bobcat), <b><a href="../man3bobcat/sharedbuf.3bobcat.html">sharedbuf</a></b>(3bobcat)

</pre><h4><b>BUGS</b></h4><pre>
       None Reported.

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>:  debian package containing the static library, headers, manual pages, and developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                         <u>FBB::<a href="../man3bobcat/SharedMemory.3bobcat.html">SharedMemory</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>