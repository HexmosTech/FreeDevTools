<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hwlocality_membinding - Memory binding</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhwloc-doc">libhwloc-doc_2.12.0-4build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       hwlocality_membinding - Memory binding

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Enumerations</b>
       enum <b>hwloc_membind_policy_t</b> { <b>HWLOC_MEMBIND_DEFAULT</b>, <b>HWLOC_MEMBIND_FIRSTTOUCH</b>, <b>HWLOC_MEMBIND_BIND</b>,
           <b>HWLOC_MEMBIND_INTERLEAVE</b>, <b>HWLOC_MEMBIND_WEIGHTED_INTERLEAVE</b>, <b>HWLOC_MEMBIND_NEXTTOUCH</b>,
           <b>HWLOC_MEMBIND_MIXED</b> }
       enum <b>hwloc_membind_flags_t</b> { <b>HWLOC_MEMBIND_PROCESS</b>, <b>HWLOC_MEMBIND_THREAD</b>, <b>HWLOC_MEMBIND_STRICT</b>,
           <b>HWLOC_MEMBIND_MIGRATE</b>, <b>HWLOC_MEMBIND_NOCPUBIND</b>, <b>HWLOC_MEMBIND_BYNODESET</b> }

   <b>Functions</b>
       int <b>hwloc_set_membind</b> (<b>hwloc_topology_t</b> topology, <b>hwloc_const_bitmap_t</b> set, <b>hwloc_membind_policy_t</b>
           policy, int flags)
       int <b>hwloc_get_membind</b> (<b>hwloc_topology_t</b> topology, <b>hwloc_bitmap_t</b> set, <b>hwloc_membind_policy_t</b> *policy, int
           flags)
       int <b>hwloc_set_proc_membind</b> (<b>hwloc_topology_t</b> topology, hwloc_pid_t pid, <b>hwloc_const_bitmap_t</b> set,
           <b>hwloc_membind_policy_t</b> policy, int flags)
       int <b>hwloc_get_proc_membind</b> (<b>hwloc_topology_t</b> topology, hwloc_pid_t pid, <b>hwloc_bitmap_t</b> set,
           <b>hwloc_membind_policy_t</b> *policy, int flags)
       int <b>hwloc_set_area_membind</b> (<b>hwloc_topology_t</b> topology, const void *addr, size_t len, <b>hwloc_const_bitmap_t</b>
           set, <b>hwloc_membind_policy_t</b> policy, int flags)
       int <b>hwloc_get_area_membind</b> (<b>hwloc_topology_t</b> topology, const void *addr, size_t len, <b>hwloc_bitmap_t</b> set,
           <b>hwloc_membind_policy_t</b> *policy, int flags)
       int <b>hwloc_get_area_memlocation</b> (<b>hwloc_topology_t</b> topology, const void *addr, size_t len, <b>hwloc_bitmap_t</b>
           set, int flags)
       void * <b>hwloc_alloc</b> (<b>hwloc_topology_t</b> topology, size_t len)
       void * <b>hwloc_alloc_membind</b> (<b>hwloc_topology_t</b> topology, size_t len, <b>hwloc_const_bitmap_t</b> set,
           <b>hwloc_membind_policy_t</b> policy, int flags)
       void * <b>hwloc_alloc_membind_policy</b> (<b>hwloc_topology_t</b> topology, size_t len, <b>hwloc_const_bitmap_t</b> set,
           <b>hwloc_membind_policy_t</b> policy, int flags)
       int <b>hwloc_free</b> (<b>hwloc_topology_t</b> topology, void *addr, size_t len)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Memory binding can be done three ways:

       • explicit memory allocation thanks to <b>hwloc_alloc_membind()</b> and friends: the binding will have effect on
         the memory allocated by these functions.

       • implicit memory binding through binding policy: <b>hwloc_set_membind()</b> and friends only define the current
         policy of the process, which will be applied to the subsequent calls to malloc() and friends.

       • migration  of  existing  memory  ranges,  thanks  to  <b>hwloc_set_area_membind()</b>  and friends, which move
         already-allocated data.

       Not all operating systems support all three ways. <b>hwloc_topology_get_support()</b> may be used to query about
       the actual memory binding support in the currently used operating system.

       When the requested binding operation is not available and the <b>HWLOC_MEMBIND_STRICT</b> flag was  passed,  the
       function  returns  -1.  errno  will be set to ENOSYS when the system does support the specified action or
       policy (e.g., some systems only allow binding memory on a per-thread basis, whereas  other  systems  only
       allow binding memory for all threads in a process). errno will be set to EXDEV when the requested set can
       not be enforced (e.g., some systems only allow binding memory to a single NUMA node).

       If  <b>HWLOC_MEMBIND_STRICT</b> was not passed, the function may fail as well, or the operating system may use a
       slightly different operation (with side-effects, smaller binding set, etc.) when the requested  operation
       is not exactly supported.

       The  most  portable  form  that  should  be preferred over the others whenever possible is as follows. It
       allocates some memory hopefully bound to the specified set. To do so, hwloc will possibly have to  change
       the  current  memory binding policy in order to actually get the memory bound, if the OS does not provide
       any other way to simply allocate bound memory without changing the policy for all  allocations.  That  is
       the difference with <b>hwloc_alloc_membind()</b>, which will never change the current memory binding policy.

       hwloc_alloc_membind_policy(topology, size, set,
                                  HWLOC_MEMBIND_BIND, 0);

       Each hwloc memory binding function takes a bitmap argument that is a CPU set by default, or a NUMA memory
       node  set  if  the  flag  <b>HWLOC_MEMBIND_BYNODESET</b>  is  specified.  See  <b>Object</b>  <b>Sets</b>  <b>(hwloc_cpuset_t</b> <b>and</b>
       <b>hwloc_nodeset_t)</b> and <b>The</b> <b>bitmap</b> <b>API</b> for a discussion of CPU sets and NUMA memory node sets.  It  is  also
       possible   to   convert   between   CPU   set   and   node   set   using   <b>hwloc_cpuset_to_nodeset()</b>   or
       <b>hwloc_cpuset_from_nodeset()</b>.

       Memory binding by CPU set cannot work for CPU-less NUMA memory nodes. Binding by nodeset should therefore
       be preferred whenever possible.

       <b>See</b> <b>also</b>
           Some example codes are available under doc/examples/ in the source tree.

       <b>Note</b>
           On some operating systems, memory binding affects the CPU binding; see <b>HWLOC_MEMBIND_NOCPUBIND</b>

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>hwloc_membind_flags_t</b>
       Memory binding flags. These flags can be used to refine the binding policy. All flags  can  be  logically
       OR'ed  together with the exception of <b>HWLOC_MEMBIND_PROCESS</b> and <b>HWLOC_MEMBIND_THREAD</b>; these two flags are
       mutually exclusive.

       Not all systems support all kinds of binding. <b>hwloc_topology_get_support()</b> may be used to query about the
       actual memory binding support in the currently used operating  system.  See  the  'Detailed  Description'
       section of <b>Memory</b> <b>binding</b> for a description of errors that can occur.

       <b>Enumerator</b>

       <u>HWLOC_MEMBIND_PROCESS</u>
              Set  policy  for  all  threads  of  the  specified  (possibly multithreaded) process. This flag is
              mutually exclusive with <b>HWLOC_MEMBIND_THREAD</b>.

       <u>HWLOC_MEMBIND_THREAD</u>
              Set policy for a specific thread of the current process. This  flag  is  mutually  exclusive  with
              <b>HWLOC_MEMBIND_PROCESS</b>.

       <u>HWLOC_MEMBIND_STRICT</u>
              Request  strict binding from the OS. The function will fail if the binding can not be guaranteed /
              completely enforced.

       This flag has slightly different meanings depending on which function it is used with.

       <u>HWLOC_MEMBIND_MIGRATE</u>
              Migrate existing allocated memory. If the memory cannot be migrated and  the  <b>HWLOC_MEMBIND_STRICT</b>
              flag is passed, an error will be returned.

       <u>HWLOC_MEMBIND_NOCPUBIND</u>
              Avoid  any  effect  on  CPU  binding.  On  some  operating systems, some underlying memory binding
              functions also bind the application to the corresponding CPU(s). Using this flag will cause  hwloc
              to  avoid using OS functions that could potentially affect CPU bindings. Note, however, that using
              NOCPUBIND may reduce hwloc's overall memory binding support. Specifically: some of hwloc's  memory
              binding functions may fail with errno set to ENOSYS when used with NOCPUBIND.

       <u>HWLOC_MEMBIND_BYNODESET</u>
              Consider  the  bitmap  argument  as a nodeset. The bitmap argument is considered a nodeset if this
              flag is given, or a cpuset otherwise by default.

       Memory binding by CPU set cannot work for CPU-less NUMA memory nodes. Binding by nodeset should therefore
       be preferred whenever possible.

   <b>enum</b> <b>hwloc_membind_policy_t</b>
       Memory binding policy. These constants can be used to choose the binding policy. Only one policy  can  be
       used at a time (i.e., the values cannot be OR'ed together).

       Not all systems support all kinds of binding. <b>hwloc_topology_get_support()</b> may be used to query about the
       actual  memory  binding  policy  support  in  the  currently  used  operating  system.  See the 'Detailed
       Description' section of <b>Memory</b> <b>binding</b> for a description of errors that can occur.

       <b>Enumerator</b>

       <u>HWLOC_MEMBIND_DEFAULT</u>
              Reset the memory allocation policy to the system default. Depending on the operating system,  this
              may  correspond  to  <b>HWLOC_MEMBIND_FIRSTTOUCH</b> (Linux, FreeBSD), or <b>HWLOC_MEMBIND_BIND</b> (AIX, HP-UX,
              Solaris, Windows). This policy is never returned by get membind functions. The nodeset argument is
              ignored.

       <u>HWLOC_MEMBIND_FIRSTTOUCH</u>
              Allocate each memory page individually on the local NUMA node of the thread that touches  it.  The
              given  nodeset should usually be <b>hwloc_topology_get_topology_nodeset()</b> so that the touching thread
              may run and allocate on any node in the system.

       On AIX, if the nodeset is smaller, pages are allocated locally (if the local node is in the  nodeset)  or
       from a random non-local node (otherwise).

       <u>HWLOC_MEMBIND_BIND</u>
              Allocate  memory  on  the specified nodes. The actual behavior may slightly vary between operating
              systems, especially when (some of) the requested  nodes  are  full.  On  Linux,  by  default,  the
              MPOL_PREFERRED_MANY  (or MPOL_PREFERRED) policy is used. However, if the hwloc strict flag is also
              given, the Linux MPOL_BIND policy is rather used.

       <u>HWLOC_MEMBIND_INTERLEAVE</u>
              Allocate memory on the given nodes in an interleaved / round-robin manner. The precise  layout  of
              the  memory  across  multiple  NUMA  nodes  is OS/system specific. Interleaving can be useful when
              threads distributed across the specified NUMA nodes will all be accessing the whole  memory  range
              concurrently, since the interleave will then balance the memory references.

       <u>HWLOC_MEMBIND_WEIGHTED_INTERLEAVE</u>
              Allocate  memory on the given nodes in an interleaved / weighted manner. The precise layout of the
              memory across multiple NUMA nodes is OS/system specific. Weighted interleaving can be useful  when
              threads distributed across the specified NUMA nodes with different bandwidth capabilities will all
              be  accessing  the  whole  memory  range  concurrently, since the interleave will then balance the
              memory references.

       <u>HWLOC_MEMBIND_NEXTTOUCH</u>
              For each page bound with this policy, by next time it is touched (and next time only), it is moved
              from its current location to the local NUMA node of the thread where the memory reference occurred
              (if it needs to be moved at all).

       <u>HWLOC_MEMBIND_MIXED</u>
              Returned by get_membind() functions when multiple threads or parts of a memory area have differing
              memory binding policies. Also returned when binding is unknown because  binding  hooks  are  empty
              when the topology is loaded from XML without HWLOC_THISSYSTEM=1, etc.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>*</b> <b>hwloc_alloc</b> <b>(hwloc_topology_t</b> <b>topology,</b> <b>size_t</b> <b>len)</b>
       Allocate  some  memory.  This  is  equivalent  to malloc(), except that it tries to allocate page-aligned
       memory from the OS.

       <b>Returns</b>
           a pointer to the allocated area, or NULL on error.

       <b>Note</b>
           The allocated memory should be freed with <b>hwloc_free()</b>.

   <b>void</b>   <b>*</b>   <b>hwloc_alloc_membind</b>   <b>(hwloc_topology_t</b>   <b>topology,</b>   <b>size_t</b>   <b>len,</b>   <b>hwloc_const_bitmap_t</b>    <b>set,</b>
       <b>hwloc_membind_policy_t</b> <b>policy,</b> <b>int</b> <b>flags)</b>
       Allocate some memory on NUMA memory nodes specified by set.

       <b>Returns</b>
           a pointer to the allocated area.

           NULL with errno set to ENOSYS if the action is not supported and <b>HWLOC_MEMBIND_STRICT</b> is given.

           NULL with errno set to EXDEV if the binding cannot be enforced and <b>HWLOC_MEMBIND_STRICT</b> is given.

           NULL with errno set to ENOMEM if the memory allocation failed even before trying to bind.

       If <b>HWLOC_MEMBIND_BYNODESET</b> is specified, set is considered a nodeset. Otherwise it's a cpuset.

       <b>Note</b>
           The allocated memory should be freed with <b>hwloc_free()</b>.

   <b>void</b>   <b>*</b>   <b>hwloc_alloc_membind_policy</b>  <b>(hwloc_topology_t</b>  <b>topology,</b>  <b>size_t</b>  <b>len,</b>  <b>hwloc_const_bitmap_t</b>  <b>set,</b>
       <b>hwloc_membind_policy_t</b> <b>policy,</b> <b>int</b> <b>flags)</b> <b>[inline]</b>
       Allocate some memory on NUMA memory nodes  specified  by  set.  First,  try  to  allocate  properly  with
       <b>hwloc_alloc_membind()</b>.  On  failure,  the current process or thread memory binding policy is changed with
       <b>hwloc_set_membind()</b> before allocating memory. Thus this function works in more cases, at the  expense  of
       changing the current state (possibly affecting future allocations that would not specify any policy).

       If <b>HWLOC_MEMBIND_BYNODESET</b> is specified, set is considered a nodeset. Otherwise it's a cpuset.

       <b>Returns</b>
           a pointer to the allocated area, or NULL on error.

   <b>int</b> <b>hwloc_free</b> <b>(hwloc_topology_t</b> <b>topology,</b> <b>void</b> <b>*</b> <b>addr,</b> <b>size_t</b> <b>len)</b>
       Free memory that was previously allocated by <b>hwloc_alloc()</b> or <b>hwloc_alloc_membind()</b>.

       <b>Returns</b>
           0 on success, -1 on error.

   <b>int</b>  <b>hwloc_get_area_membind</b>  <b>(hwloc_topology_t</b>  <b>topology,</b>  <b>const</b> <b>void</b> <b>*</b> <b>addr,</b> <b>size_t</b> <b>len,</b> <b>hwloc_bitmap_t</b> <b>set,</b>
       <b>hwloc_membind_policy_t</b> <b>*</b> <b>policy,</b> <b>int</b> <b>flags)</b>
       Query the CPUs near the physical NUMA node(s) and binding policy of the memory identified by  (addr,  len
       ). The bitmap set (previously allocated by the caller) is filled with the memory area binding.

       This  function  has two output parameters: set and policy. The values returned in these parameters depend
       on both the flags passed in and the memory binding policies and nodesets of  the  pages  in  the  address
       range.

       If <b>HWLOC_MEMBIND_STRICT</b> is specified, the target pages are first checked to see if they all have the same
       memory  binding policy and nodeset. If they do not, -1 is returned and errno is set to EXDEV. If they are
       identical across all pages, the set and policy are returned in set and policy, respectively.

       If <b>HWLOC_MEMBIND_STRICT</b> is not specified, the union of all NUMA node(s) containing pages in  the  address
       range  is  calculated.  If  all  pages  in  the  target  have  the same policy, it is returned in policy.
       Otherwise, policy is set to <b>HWLOC_MEMBIND_MIXED</b>.

       If <b>HWLOC_MEMBIND_BYNODESET</b> is specified, set is considered a nodeset. Otherwise it's a cpuset.

       If any other flags are specified, -1 is returned and errno is set to EINVAL.

       <b>Returns</b>
           0 on success.

           -1 with errno set to EINVAL if len is 0.

   <b>int</b> <b>hwloc_get_area_memlocation</b> <b>(hwloc_topology_t</b> <b>topology,</b> <b>const</b> <b>void</b> <b>*</b> <b>addr,</b> <b>size_t</b> <b>len,</b> <b>hwloc_bitmap_t</b> <b>set,</b>
       <b>int</b> <b>flags)</b>
       Get the NUMA nodes where memory identified by (addr, len  )  is  physically  allocated.  The  bitmap  set
       (previously  allocated  by  the caller) is filled according to the NUMA nodes where the memory area pages
       are physically allocated. If no page is actually allocated yet, set may be empty.

       If pages spread to multiple nodes, it is not specified whether they spread equitably, or whether most  of
       them are on a single node, etc.

       The  operating  system may move memory pages from one processor to another at any time according to their
       binding, so this function may return something that is already outdated.

       If <b>HWLOC_MEMBIND_BYNODESET</b> is specified in flags, set is considered a nodeset. Otherwise it's a cpuset.

       If len is 0, set is emptied.

       <b>Returns</b>
           0 on success, -1 on error.

   <b>int</b> <b>hwloc_get_membind</b> <b>(hwloc_topology_t</b> <b>topology,</b> <b>hwloc_bitmap_t</b> <b>set,</b> <b>hwloc_membind_policy_t</b>  <b>*</b>  <b>policy,</b>  <b>int</b>
       <b>flags)</b>
       Query  the  default  memory  binding  policy  and physical locality of the current process or thread. The
       bitmap set (previously allocated by the caller) is filled with the process or thread memory binding.

       This function has two output parameters: set and policy. The values returned in these  parameters  depend
       on both the flags passed in and the current memory binding policies and nodesets in the queried target.

       Passing  the  <b>HWLOC_MEMBIND_PROCESS</b>  flag  specifies  that  the  query target is the current policies and
       nodesets for all the threads in the current process.  Passing  <b>HWLOC_MEMBIND_THREAD</b>  specifies  that  the
       query target is the current policy and nodeset for only the thread invoking this function.

       If  neither  of  these flags are passed (which is the most portable method), the process is assumed to be
       single threaded. This allows hwloc to use either process-based OS functions or thread-based OS functions,
       depending on which are available.

       <b>HWLOC_MEMBIND_STRICT</b> is only meaningful when <b>HWLOC_MEMBIND_PROCESS</b> is also specified. In this case, hwloc
       will check the default memory policies and nodesets for all threads in  the  process.  If  they  are  not
       identical,  -1  is  returned and errno is set to EXDEV. If they are identical, the values are returned in
       set and policy.

       Otherwise, if <b>HWLOC_MEMBIND_PROCESS</b> is specified (and <b>HWLOC_MEMBIND_STRICT</b> is <u>not</u> specified), the default
       set from each thread is logically OR'ed together. If all threads' default policies are the  same,  policy
       is set to that policy. If they are different, policy is set to <b>HWLOC_MEMBIND_MIXED</b>.

       In  the  <b>HWLOC_MEMBIND_THREAD</b>  case  (or  when  neither  <b>HWLOC_MEMBIND_PROCESS</b> or <b>HWLOC_MEMBIND_THREAD</b> is
       specified), there is only one set and policy; they are returned in set and policy, respectively.

       If <b>HWLOC_MEMBIND_BYNODESET</b> is specified, set is considered a nodeset. Otherwise it's a cpuset.

       If any other flags are specified, -1 is returned and errno is set to EINVAL.

       <b>Returns</b>
           0 on success, -1 on error.

   <b>int</b>   <b>hwloc_get_proc_membind</b>   <b>(hwloc_topology_t</b>   <b>topology,</b>    <b>hwloc_pid_t</b>    <b>pid,</b>    <b>hwloc_bitmap_t</b>    <b>set,</b>
       <b>hwloc_membind_policy_t</b> <b>*</b> <b>policy,</b> <b>int</b> <b>flags)</b>
       Query  the  default  memory binding policy and physical locality of the specified process. The bitmap set
       (previously allocated by the caller) is filled with the process memory binding.

       This function has two output parameters: set and policy. The values returned in these  parameters  depend
       on both the flags passed in and the current memory binding policies and nodesets in the queried target.

       Passing  the  <b>HWLOC_MEMBIND_PROCESS</b>  flag  specifies  that  the  query target is the current policies and
       nodesets for all the threads in the specified process. If <b>HWLOC_MEMBIND_PROCESS</b> is not  specified  (which
       is  the  most  portable  method),  the process is assumed to be single threaded. This allows hwloc to use
       either process-based OS functions or thread-based OS functions, depending on which are available.

       Note that it does not make sense to pass <b>HWLOC_MEMBIND_THREAD</b> to this function.

       If <b>HWLOC_MEMBIND_STRICT</b> is specified, hwloc will check the default memory policies and nodesets  for  all
       threads in the specified process. If they are not identical, -1 is returned and errno is set to EXDEV. If
       they are identical, the values are returned in set and policy.

       Otherwise, set is set to the logical OR of all threads' default set. If all threads' default policies are
       the same, policy is set to that policy. If they are different, policy is set to <b>HWLOC_MEMBIND_MIXED</b>.

       If <b>HWLOC_MEMBIND_BYNODESET</b> is specified, set is considered a nodeset. Otherwise it's a cpuset.

       If any other flags are specified, -1 is returned and errno is set to EINVAL.

       <b>Returns</b>
           0 on success, -1 on error.

       <b>Note</b>
           hwloc_pid_t is pid_t on Unix platforms, and HANDLE on native Windows platforms.

   <b>int</b>  <b>hwloc_set_area_membind</b>  <b>(hwloc_topology_t</b>  <b>topology,</b> <b>const</b> <b>void</b> <b>*</b> <b>addr,</b> <b>size_t</b> <b>len,</b> <b>hwloc_const_bitmap_t</b>
       <b>set,</b> <b>hwloc_membind_policy_t</b> <b>policy,</b> <b>int</b> <b>flags)</b>
       Bind the already-allocated memory identified by (addr, len) to the NUMA  node(s)  specified  by  set.  If
       <b>HWLOC_MEMBIND_BYNODESET</b> is specified, set is considered a nodeset. Otherwise it's a cpuset.

       <b>Returns</b>
           0 on success or if len is 0.

           -1 with errno set to ENOSYS if the action is not supported.

           -1 with errno set to EXDEV if the binding cannot be enforced.

   <b>int</b>  <b>hwloc_set_membind</b>  <b>(hwloc_topology_t</b>  <b>topology,</b> <b>hwloc_const_bitmap_t</b> <b>set,</b> <b>hwloc_membind_policy_t</b> <b>policy,</b>
       <b>int</b> <b>flags)</b>
       Set the default memory binding policy of the current  process  or  thread  to  prefer  the  NUMA  node(s)
       specified  by  set.  If  neither <b>HWLOC_MEMBIND_PROCESS</b> nor <b>HWLOC_MEMBIND_THREAD</b> is specified, the current
       process is assumed to be single-threaded. This is the most portable form  as  it  permits  hwloc  to  use
       either process-based OS functions or thread-based OS functions, depending on which are available.

       If <b>HWLOC_MEMBIND_BYNODESET</b> is specified, set is considered a nodeset. Otherwise it's a cpuset.

       <b>Returns</b>
           0 on success.

           -1 with errno set to ENOSYS if the action is not supported.

           -1 with errno set to EXDEV if the binding cannot be enforced.

   <b>int</b>   <b>hwloc_set_proc_membind</b>   <b>(hwloc_topology_t</b>   <b>topology,</b>   <b>hwloc_pid_t</b>   <b>pid,</b>  <b>hwloc_const_bitmap_t</b>  <b>set,</b>
       <b>hwloc_membind_policy_t</b> <b>policy,</b> <b>int</b> <b>flags)</b>
       Set the default memory binding policy of the specified process to prefer the NUMA  node(s)  specified  by
       set. If <b>HWLOC_MEMBIND_BYNODESET</b> is specified, set is considered a nodeset. Otherwise it's a cpuset.

       <b>Returns</b>
           0 on success.

           -1 with errno set to ENOSYS if the action is not supported.

           -1 with errno set to EXDEV if the binding cannot be enforced.

       <b>Note</b>
           hwloc_pid_t is pid_t on Unix platforms, and HANDLE on native Windows platforms.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for Hardware Locality (hwloc) from the source code.

Hardware Locality (hwloc)                        Version 2.12.0                         <u><a href="../man3/hwlocality_membinding.3.html">hwlocality_membinding</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>