<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FFI::Platypus::Memory - Memory functions for FFI</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libffi-platypus-perl">libffi-platypus-perl_2.10-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FFI::Platypus::Memory - Memory functions for FFI

</pre><h4><b>VERSION</b></h4><pre>
       version 2.10

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use FFI::Platypus::Memory;

        # allocate 64 bytes of memory using the
        # libc malloc function.
        my $pointer = malloc 64;

        # use that memory wisely
        ...

        # free the memory when you are done.
        free $pointer;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides an interface to common memory functions provided by the standard C library.  They
       may be useful when constructing interfaces to C libraries with FFI.  It works mostly with the "opaque"
       type and it is worth reviewing the section on opaque pointers in FFI::Platypus::Type.

       Allocating memory and forgetting to free it is a common source of memory leaks in C and when using this
       module.  Very recent Perls have a "defer" keyword that lets you automatically call functions like "free"
       when a block ends.  This can be especially handy when you have multiple code paths or possible exceptions
       to keep track of.

        use feature 'defer';
        use FFI::Platypus::Memory qw( malloc free );

        sub run {
          my $ptr = malloc 66;
          defer { free $ptr };

          my $data = do_something($ptr);

          # do not need to remember to place free $ptr here, as it will
          # run through defer.

          return $data;
        }

       If you are not lucky enough to have the "defer" feature in your version of Perl you may be able to use
       Feature::Compat::Defer, which will use the feature if available, and provides its own mostly compatible
       version if not.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>calloc</b>
        my $pointer = calloc $count, $size;

       The "calloc" function contiguously allocates enough space for <u>$count</u> objects that are <u>$size</u> bytes of
       memory each.

   <b>free</b>
        free $pointer;

       The "free" function frees the memory allocated by "malloc", "calloc", "realloc" or "strdup".  It is
       important to only free memory that you yourself have allocated.  A good way to crash your program is to
       try and free a pointer that some C library has returned to you.

   <b>malloc</b>
        my $pointer = malloc $size;

       The "malloc" function allocates <u>$size</u> bytes of memory.

   <b>memcpy</b>
        memcpy $dst_pointer, $src_pointer, $size;

       The "memcpy" function copies <u>$size</u> bytes from <u>$src_pointer</u> to <u>$dst_pointer</u>.  It also returns
       <u>$dst_pointer</u>.

   <b>memset</b>
        memset $buffer, $value, $length;

       The "memset" function writes <u>$length</u> bytes of <u>$value</u> to the address specified by <u>$buffer</u>.

   <b>realloc</b>
        my $new_pointer = realloc $old_pointer, $size;

       The "realloc" function reallocates enough memory to fit <u>$size</u> bytes.  It copies the existing data and
       frees <u>$old_pointer</u>.

       If you pass "undef" in as <u>$old_pointer</u>, then it behaves exactly like "malloc":

        my $pointer = realloc undef, 64; # same as malloc 64

   <b>strcpy</b>
        strcpy $opaque, $string;

       Copies the string to the memory location pointed to by $opaque.

   <b>strdup</b>
        my $pointer = strdup $string;

       The "strdup" function allocates enough memory to contain <u>$string</u> and then copies it to that newly
       allocated memory.  This version of "strdup" returns an opaque pointer type, not a string type.  This may
       seem a little strange, but returning a string type would not be very useful in Perl.

   <b>strndup</b>
        my $pointer = strndup $string, $max;

       The same as "strdup" above, except at most $max characters will be copied in the new string.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       FFI::Platypus
           Main Platypus documentation.

</pre><h4><b>AUTHOR</b></h4><pre>
       Author: Graham Ollis &lt;<a href="mailto:plicease@cpan.org">plicease@cpan.org</a>&gt;

       Contributors:

       Bakkiaraj Murugesan (bakkiaraj)

       Dylan Cali (calid)

       pipcet

       Zaki Mughal (zmughal)

       Fitz Elliott (felliott)

       Vickenty Fesunov (vyf)

       Gregor Herrmann (gregoa)

       Shlomi Fish (shlomif)

       Damyan Ivanov

       Ilya Pavlov (Ilya33)

       Petr Písař (ppisar)

       Mohammad S Anwar (MANWAR)

       Håkon Hægland (hakonhagland, HAKONH)

       Meredith (merrilymeredith, MHOWARD)

       Diab Jerius (DJERIUS)

       Eric Brine (IKEGAMI)

       szTheory

       José Joaquín Atria (JJATRIA)

       Pete Houston (openstrike, HOUSTON)

       Lukas Mai (MAUKE)

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2015-2022 by Graham Ollis.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.0                                       2025-01-11                         <u>FFI::Platypus::<a href="../man3pm/Memory.3pm.html">Memory</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>