<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCL_MEM_DEBUG - Compile-time flag to enable Tcl memory debugging</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       TCL_MEM_DEBUG - Compile-time flag to enable Tcl memory debugging
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       When  Tcl  is compiled with <b>TCL_MEM_DEBUG</b> defined, a powerful set of memory debugging aids is included in
       the compiled binary.  This includes C and Tcl functions which can aid with debugging memory leaks, memory
       allocation overruns, and other memory related errors.

</pre><h4><b>ENABLING</b> <b>MEMORY</b> <b>DEBUGGING</b></h4><pre>
       To enable memory debugging, Tcl should be recompiled from scratch with  <b>TCL_MEM_DEBUG</b>  defined  (e.g.  by
       passing  the <u>--enable-symbols=mem</u> flag to the <u>configure</u> script when building).  This will also compile in
       a non-stub version of <b>Tcl_InitMemory</b> to add the <b>memory</b> command to Tcl.

       <b>TCL_MEM_DEBUG</b> must be either left defined for all modules or undefined for all modules that are going  to
       be  linked together.  If they are not, link errors will occur, with either <b>Tcl_DbCkfree</b> and <b>Tcl_DbCkalloc</b>
       or <b>Tcl_Alloc</b> and <b>Tcl_Free</b> being undefined.

       Once memory debugging support has been compiled into Tcl,  the  C  functions  <b>Tcl_ValidateAllMemory</b>,  and
       <b>Tcl_DumpActiveMemory</b>, and the Tcl <b>memory</b> command can be used to validate and examine memory usage.

</pre><h4><b>GUARD</b> <b>ZONES</b></h4><pre>
       When  memory  debugging  is  enabled,  whenever  a  call  to <b>Tcl_Alloc</b> is made, slightly more memory than
       requested is allocated so the memory debugging code can keep track of the allocated  memory,  and  eight-
       byte “guard zones” are placed in front of and behind the space that will be returned to the caller.  (The
       sizes  of  the guard zones are defined by the C #define <b>LOW_GUARD_SIZE</b> and #define <b>HIGH_GUARD_SIZE</b> in the
       file <u>generic/tclCkalloc.c</u> — it can be extended if you suspect large overwrite problems, at some  cost  in
       performance.)   A  known  pattern  is  written into the guard zones and, on a call to <b>Tcl_Free</b>, the guard
       zones of the space being freed are checked to see if either zone has been modified in any  way.   If  one
       has  been, the guard bytes and their new contents are identified, and a “low guard failed” or “high guard
       failed” message is issued.  The “guard failed” message includes the address of the memory packet and  the
       file  name  and line number of the code that called <b>Tcl_Free</b>.  This allows you to detect the common sorts
       of one-off problems, where not enough space was allocated to contain the data written, for example.

</pre><h4><b>DEBUGGING</b> <b>DIFFICULT</b> <b>MEMORY</b> <b>CORRUPTION</b> <b>PROBLEMS</b></h4><pre>
       Normally, Tcl compiled with memory debugging enabled will make it easy to isolate a  corruption  problem.
       Turning on memory validation with the memory command can help isolate difficult problems.  If you suspect
       (or  know)  that  corruption is occurring before the Tcl interpreter comes up far enough for you to issue
       commands, you can set <b>MEM_VALIDATE</b> define, recompile tclCkalloc.c and  rebuild  Tcl.   This  will  enable
       memory validation from the first call to <b>Tcl_Alloc</b>, again, at a large performance impact.

       If you are desperate and validating memory on every call to <b>Tcl_Alloc</b> and <b>Tcl_Free</b> is not enough, you can
       explicitly  call  <b>Tcl_ValidateAllMemory</b>  directly  at  any point.  It takes a <u>char</u> <u>*</u> and an <u>int</u> which are
       normally the filename and line number of the  caller,  but  they  can  actually  be  anything  you  want.
       Remember to remove the calls after you find the problem.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Tcl_Alloc, memory, Tcl_ValidateAllMemory, Tcl_DumpActiveMemory

</pre><h4><b>KEYWORDS</b></h4><pre>
       memory, debug

Tcl                                                    8.1                                   <u><a href="../man3tcl/TCL_MEM_DEBUG.3tcl.html">TCL_MEM_DEBUG</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>