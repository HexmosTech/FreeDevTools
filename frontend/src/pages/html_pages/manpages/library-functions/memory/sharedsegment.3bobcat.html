<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::SharedSegment - Shared Memory data structure</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::SharedSegment - Shared Memory data structure

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/sharedsegment&gt;</b>
       Linking option: <u>-lbobcat</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  class  <b>FBB::SharedSegment</b> implements the shared memory data structure used by Bobcat’s shared memory
       classes. Bobcat’s <u>SharedMemory</u> class accesses or defines a shared memory  segment,  controlling  all  its
       read and write operations.

       The requested amount of shared memory is always a lower bound to the maximum amount of shared memory that
       eventually  may  become  available.  When  defining  a  <b>SharedSegment</b>  object  not all of its potentially
       available shared memory is immediately allocated. Shared memory will be allocated  by  the  <b>SharedSegment</b>
       object once needed (up to a calculated maximum).

       As a fictitious example: assume 100 kB of memory is requested, then the <b>SharedSegment</b> object, maintains a
       table  of,  e.g.,  10 entries, each controlling the access to a shared memory block of 10 kB. These 10 kB
       blocks aren’t immediately allocated, but become available once  the  program  reads  from  or  writes  to
       addresses located in these data segments.

       The class <b>SharedSegment</b> therefore defines a gateway, controlling access to and allocating required shared
       memory  data segments. The mentioned table consists of <u>nBlocks</u> <u>SharedBlock</u> (<b><a href="../man3bobcat/sharedblock.3bobcat.html">sharedblock</a></b>(3bobcat)) values,
       offering mutexes and IDs of shared data segments. The mutexes control  which  process  has  access  to  a
       particular  block of shared data memory, and the IDs are either -1, meaning that their shared memory data
       segments has as not yet been allocated, or they contain the IDs of defined shared memory data segments.

       The class <b>SharedSegment</b>’s sole responsibility is to offer the framework as  described.  When  used  by  a
       <u>FBB::SharedMemory</u> object different processes may gain access to different parts of the shared memory data
       without interfering each other’s read and write actions.

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All  constructors,  members,  operators  and manipulators, mentioned in this man-page, are defined in the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       -

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
       No publicly accessible constructors have been defined for <b>SharedSegment</b>. A static member function  <u>create</u>
       (see  below)  is  available, returning a pointer to a shared memory segment, in which a <b>SharedSegment</b> has
       been defined.

</pre><h4><b>OVERLOADED</b> <b>OPERATORS</b></h4><pre>
       o      <b>std::ostream</b> <b>&amp;operator&lt;&lt;(std::ostream</b> <b>&amp;out,</b> <b>SharedSegment</b> <b>const</b> <b>&amp;sharedData)</b>:
              The overloaded insertion operator inserts basic statistics of the  shared  memory  data  into  the
              <u>ostream</u>  object. Information about the IDs of the shared segments, their sizes, the maximum number
              of shared data segments and the number of bytes that can  be  read  from  the  shared  memory  are
              displayed.

       o      <b>FBB::SharedBlock</b> <b>&amp;operator[](size_t</b> <b>idx)</b>:
              Table  element  <u>idx</u>  of  the  table of <u>FBB::SharedBlock</u> block IDs is returned. The behavior of the
              program is undefined if <u>idx</u> is or exceeds <u>nBlocks()</u>.

              Copy and move constructors (and assignment operators) are not available.

</pre><h4><b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       o      <b>size_t</b> <b>access()</b> <b>const</b>:
              Returns the access rights of the shared memory segment as a number which is usually interpreted as
              an octal value, using the well-known (<b><a href="../man1/chmod.1.html">chmod</a></b>(1)) way to define the access rights for  owner,  group
              and others.

       o      <b>void</b> <b>clear()</b>:
              All  the shared memory data blocks are unconditionally deleted and <u>nReadable</u> returns 0 (the shared
              memory data blocks are not locked prior to deleting  them).  After  calling  <u>clear</u>  all  allocated
              <b>SharedSegment</b>’s shared memory segments have ceased to exist and can no longer be used.

       o      <b>void</b> <b>lock(size_t</b> <b>idx)</b> <b>const</b>:
              Access  to  shared  data  segment  <u>idx</u>  is  locked.  This member itself does not support recursive
              locking.

       o      <b>size_t</b> <b>nBlocks()</b> <b>const</b>:
              Returns the number of shared memory data blocks that can be used by the <b>FBB::SharedSegment</b> object.

       o      <b>int</b> <b>newData(size_t</b> <b>idx)</b>:
              Returns the ID of a newly created shared memory data segment. The ID is also stored in  the  table
              of shared memory data segments that is maintained by the <b>SharedSegment</b> object.

              An <u>FBB::Exception</u> is thrown if the shared memory data segment could not be allocated.

       o      <b>std::streamsize</b> <b>nReadable()</b> <b>const</b>:
              Returns the number of characters (bytes) that can be read from the beginning of the shared memory.

       o      <b>void</b> <b>nReadableLock()</b> <b>const</b>:
              When  returning  from  this  member  function  a  lock  has been obtained of <b>SharedSegment</b>’s mutex
              controlling access the the object’s data member storing the number of characters that can be  read
              from the shared memory controlled by the <b>SharedSegment</b> object.

       o      <b>void</b> <b>nReadableUnlock()</b> <b>const</b>:
              This member function releases the lock previously acquired by <u>nReadableLock</u>.

       o      <b>size_t</b> <b>segmentSize()</b> <b>const</b>:
              Returns  the  size  (in  bytes)  of  the  shared  memory data blocks. The <b>SharedSegment</b> object can
              accommodate at most <u>segmentSize()</u> <u>*</u> <u>nBlocks()</u> bytes.

       o      <b>bool</b> <b>truncate(std::streamsize</b> <b>offset)</b>:
              After calling <u>nReadableLock</u>, if <u>offset</u> is not exceeding the value returned by <u>nReadable</u>  <u>nReadable</u>
              is  changed to <u>offset</u> and <u>true</u> is returned. Otherwise <u>false</u> is returned, and the value returned by
              <u>nReadable</u> has not been changed. Before returning <u>nReadableUnlock</u> is called.

       o      <b>void</b> <b>unlock(size_t</b> <b>idx)</b> <b>const</b>:
              Releases the lock on the shared memory data segment <u>idx</u>. If the current process does not  own  the
              lock of shared memory data block <u>idx</u> nothing happens and the function immediately returns.

       o      <b>void</b> <b>updateNreadable(std::streamsize</b> <b>offset)</b>:
              The  number  of  bytes that can be retrieved from the shared memory is updated to <u>max(nReadable(),</u>
              <u>offset)</u>.

</pre><h4><b>STATIC</b> <b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       o      <b>void</b> <b>*attach(int</b> <b>id)</b>:
              Returns the address of shared memory segment <u>id</u>, mapped to the calling process’s memory area.

              An <u>FBB::Exception</u> is thrown if the shared memory data segment could not be attached.

       o      <b>SharedSegment</b> <b>*create(int</b> <b>*id,</b> <b>size_t</b> <b>nBlocks,</b> <b>size_t</b> <b>segmentSize,</b> <b>size_t</b> <b>access)</b>:
              Returns a pointer to a newly created  <b>SharedSegment</b>  object,  defined  in  the  computer’s  shared
              memory.

              The  created  shared  memory’s  ID  is stored at <u>*id</u>. The remaining arguments define the potential
              number of shared memory data blocks (<u>nBlocks</u>); the size of these data  blocks  (<u>segmentSize</u>);  and
              the shared memory’s access rights (<u>access</u>, using the well-known octal value representation as used
              by (<b><a href="../man1/chmod.1.html">chmod</a></b>(1)) to define access rights for the owner, the group and others).

              To return the shared segment to the operating system <u>deleteSegment</u> should be used.

              An <u>FBB::Exception</u> is thrown if the shared memory data segment could not be created.

       o      <b>void</b> <b>deleteSegment(int</b> <b>id)</b>:
              The  shared  memory  segment  having  ID  <u>id</u> is deleted. After calling <u>deleteSegment</u> shared memory
              segment <u>id</u> doesn’t exist anymore. The <u>id</u> can be the shared memory ID of any segment for which  the
              current user has write permissions.

              An <u>FBB::Exception</u> is thrown if shared memory data segment <u>id</u> could not be deleted.

       o      <b>Type</b> <b>*detach(Type</b> <b>*sharedPtr,</b> <b>bool</b> <b>requireOK</b> <b>=</b> <b>true)</b>:
              This  member  is  defined  as  a member template. It expects a pointer to a shared memory segment,
              previously mapped on the calling process’s memory space  by  <u>attach</u>,  and  detaches  it  from  the
              process’s memory space, returning 0.

              By  default,  detaching  the  memory  must  succeed  or  an  <b>FBB::Exception</b> is thrown. Throwing an
              exception on failure can be prevented by passing <u>false</u> as the member’s second argument.

              Note that detaching a memory segment does not destroy it.  To  return  a  shared  segment  to  the
              operating system <u>deleteSegment</u> should be used.

       o      <b>size_t</b> <b>size(int</b> <b>id)</b>:
              The size (in bytes) of shared memory data block having ID <u>id</u> is returned.

              An <u>FBB::Exception</u> is thrown if the size of segment <u>id</u> could not be determined.

</pre><h4><b>EXAMPLE</b></h4><pre>
       See the <b><a href="../man3bobcat/sharedstream.3bobcat.html">sharedstream</a></b>(3bobcat) man page.

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/sharedsegment</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7),     <b><a href="../man1/chmod.1.html">chmod</a></b>(1),     <b><a href="../man3bobcat/isharedstream.3bobcat.html">isharedstream</a></b>(3bobcat),     <b><a href="../man3bobcat/osharedstream.3bobcat.html">osharedstream</a></b>(3bobcat),    <b><a href="../man3bobcat/sharedblock.3bobcat.html">sharedblock</a></b>(3bobcat),
       <b><a href="../man3bobcat/sharedcondition.3bobcat.html">sharedcondition</a></b>(3bobcat),      <b><a href="../man3bobcat/sharedmemory.3bobcat.html">sharedmemory</a></b>(3bobcat),      <b><a href="../man3bobcat/sharedmutex.3bobcat.html">sharedmutex</a></b>(3bobcat),      <b><a href="../man3bobcat/sharedpos.3bobcat.html">sharedpos</a></b>(3bobcat),
       <b><a href="../man7bobcat/sharedreadme.7bobcat.html">sharedreadme</a></b>(7bobcat), <b><a href="../man3bobcat/sharedstream.3bobcat.html">sharedstream</a></b>(3bobcat), <b><a href="../man3bobcat/sharedbuf.3bobcat.html">sharedbuf</a></b>(3bobcat)

</pre><h4><b>BUGS</b></h4><pre>
       None Reported.

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>:  debian package containing the static library, headers, manual pages, and developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                        <u>FBB::<a href="../man3bobcat/SharedSegment.3bobcat.html">SharedSegment</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>