<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sc::MemoryGrp - The MemoryGrp abstract class provides a way of accessing distributed memory in a parallel</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libsc-doc">libsc-doc_2.3.1-21_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sc::MemoryGrp - The <b>MemoryGrp</b> abstract class provides a way of accessing distributed memory in a parallel
       machine.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/memory.h">memory.h</a>&gt;

       Inherits <b>sc::DescribedClass</b>.

       Inherited by <b>sc::MsgMemoryGrp</b>, and <b>sc::ProcMemoryGrp</b>.

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>MemoryGrp</b> (const <b>Ref</b>&lt; <b>KeyVal</b> &gt; &amp;)
       int <b>me</b> () const
           Returns who I am.
       int <b>n</b> () const
           Returns how many nodes there are.
       virtual void <b>set_localsize</b> (size_t)=0
           Set the size of locally held memory.
       size_t <b>localsize</b> ()
           Returns the amount of memory residing locally on <b>me()</b>.
       virtual void * <b>localdata</b> ()=0
           Returns a pointer to the local data.
       <b>distsize_t</b> <b>localoffset</b> ()
           Returns the global offset to this node's memory.
       int <b>size</b> (int node)
           Returns the amount of memory residing on node.
       <b>distsize_t</b> <b>offset</b> (int node)
           Returns the global offset to node's memory.
       <b>distsize_t</b> <b>totalsize</b> ()
           Returns the sum of all memory allocated on all nodes.
       virtual void <b>activate</b> ()
           Activate is called before the memory is to be used.
       virtual void <b>deactivate</b> ()
           Deactivate is called after the memory has been used.
       virtual void * <b>obtain_writeonly</b> (<b>distsize_t</b> <b>offset</b>, int <b>size</b>)=0
           This gives write access to the memory location. No locking is done.
       virtual void * <b>obtain_readwrite</b> (<b>distsize_t</b> <b>offset</b>, int <b>size</b>)=0
           Only one thread can have an unreleased obtain_readwrite at a time.
       virtual void * <b>obtain_readonly</b> (<b>distsize_t</b> <b>offset</b>, int <b>size</b>)=0
           This gives read access to the memory location. No locking is done.
       virtual void <b>release_readonly</b> (void *data, <b>distsize_t</b> <b>offset</b>, int <b>size</b>)=0
           This is called when read access is no longer needed.
       virtual void <b>release_writeonly</b> (void *data, <b>distsize_t</b> <b>offset</b>, int <b>size</b>)=0
           This is called when write access is no longer needed.
       virtual void <b>release_readwrite</b> (void *data, <b>distsize_t</b> <b>offset</b>, int <b>size</b>)=0
           This is called when read/write access is no longer needed.
       virtual void <b>sum_reduction</b> (double *data, <b>distsize_t</b> doffset, int dsize)
       virtual void <b>sum_reduction_on_node</b> (double *data, size_t doffset, int dsize, int node=-1)
       virtual void <b>sync</b> ()=0
           Synchronizes all the nodes.
       virtual void * <b>malloc_local</b> (size_t nbyte)
           Allocate data that will be accessed locally only.
       virtual double * <b>malloc_local_double</b> (size_t ndouble)
       virtual void <b>free_local</b> (void *data)
           Free data that was allocated with malloc_local_double.
       virtual void <b>free_local_double</b> (double *data)
       virtual void <b>catchup</b> ()
           Processes outstanding requests.
       virtual void <b>print</b> (std::ostream &amp;o=<b>ExEnv::out0</b>()) const
           Prints out information about the object.

   <b>Static</b> <b>Public</b> <b>Member</b> <b>Functions</b>
       static <b>MemoryGrp</b> * <b>initial_memorygrp</b> (int &amp;argc, char **argv)
           Create a memory group.
       static <b>MemoryGrp</b> * <b>initial_memorygrp</b> ()
       static void <b>set_default_memorygrp</b> (const <b>Ref</b>&lt; <b>MemoryGrp</b> &gt; &amp;)
           The default memory group contains the primary memory group to be used by an application.
       static <b>MemoryGrp</b> * <b>get_default_memorygrp</b> ()
           Returns the default memory group.

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       void <b>obtain_local_lock</b> (size_t start, size_t fence)
       void <b>release_local_lock</b> (size_t start, size_t fence)

   <b>Protected</b> <b>Attributes</b>
       int <b>me_</b>
       int <b>n_</b>
       <b>distsize_t</b> * <b>offsets_</b>
       int <b>debug_</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       The <b>MemoryGrp</b> abstract class provides a way of accessing distributed memory in a parallel machine.

       Several specializations are available. For one processor, <b>ProcMemoryGrp</b> provides a simple stub
       implementation. Parallel specializations include <b>ShmMemoryGrp</b>, <b>MTMPIMemoryGrp</b>, and <b>ARMCIMemoryGrp</b>. The
       particular specializations that work depend highly on the target hardware and software environment.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>virtual</b> <b>void</b> <b>sc::MemoryGrp::catchup</b> <b>()</b> <b>[virtual]</b>
       Processes outstanding requests. Some memory group implementations don't have access to real shared memory
       or even active messages. Instead, requests are processed whenever certain memory group routines are
       called. This can cause large latencies and buffer overflows. If this is a problem, then the catchup
       member can be called to process all outstanding requests.

   <b>static</b> <b>MemoryGrp*</b> <b>sc::MemoryGrp::get_default_memorygrp</b> <b>()</b> <b>[static]</b>
       Returns the default memory group. If the default memory group has not yet been set, then one is created.
       The particular specialization used is determined by configuration options and which specializations are
       being used for <b>MessageGrp</b> and <b>ThreadGrp</b>.

   <b>static</b> <b>MemoryGrp*</b> <b>sc::MemoryGrp::initial_memorygrp</b> <b>(int</b> <b>&amp;</b> <b>argc,</b> <b>char</b> <b>**</b> <b>argv)</b> <b>[static]</b>
       Create a memory group. This routine looks for a -memorygrp argument, and then the environmental variable
       MEMORYGRP to decide which specialization of <b>MemoryGrp</b> would be appropriate. The argument to -memorygrp or
       the value of the environmental variable should be either string for a <b>ParsedKeyVal</b> constructor or a
       classname. The default <b>ThreadGrp</b> and <b>MessageGrp</b> objects should be initialized before this is called.

       References initial_memorygrp().

       Referenced by initial_memorygrp().

   <b>virtual</b> <b>void*</b> <b>sc::MemoryGrp::malloc_local</b> <b>(size_t</b> <b>nbyte)</b> <b>[virtual]</b>
       Allocate data that will be accessed locally only. Using this for data that will be used for global
       operation can improve efficiency. Data allocated in this way must be freed with free_local_double.

       Reimplemented in <b>sc::ARMCIMemoryGrp</b>.

   <b>virtual</b> <b>void*</b> <b>sc::MemoryGrp::obtain_readwrite</b> <b>(distsize_t</b> <b>offset,</b> <b>int</b> <b>size)</b> <b>[pure</b> <b>virtual]</b>
       Only one thread can have an unreleased obtain_readwrite at a time. The actual memory region locked can be
       larger than that requested. If the memory region is already locked this will block. For this reason, data
       should be held as read/write for as short a time as possible.

       Implemented in <b>sc::ActiveMsgMemoryGrp</b>, <b>sc::ShmMemoryGrp</b>, <b>sc::RDMAMemoryGrp</b>, and <b>sc::ProcMemoryGrp</b>.

   <b>virtual</b> <b>void</b> <b>sc::MemoryGrp::release_readwrite</b> <b>(void</b> <b>*</b> <b>data,</b> <b>distsize_t</b> <b>offset,</b> <b>int</b> <b>size)</b> <b>[pure</b> <b>virtual]</b>
       This is called when read/write access is no longer needed. The memory will be unlocked.

       Implemented in <b>sc::ActiveMsgMemoryGrp</b>, <b>sc::ShmMemoryGrp</b>, <b>sc::RDMAMemoryGrp</b>, and <b>sc::ProcMemoryGrp</b>.

   <b>virtual</b> <b>void</b> <b>sc::MemoryGrp::set_localsize</b> <b>(size_t)</b> <b>[pure</b> <b>virtual]</b>
       Set the size of locally held memory. When memory is accessed using a global offset counting starts at
       node 0 and proceeds up to node <b>n()</b> - 1.

       Implemented in <b>sc::ActiveMsgMemoryGrp</b>, <b>sc::ShmMemoryGrp</b>, <b>sc::ARMCIMemoryGrp</b>, <b>sc::ProcMemoryGrp</b>,
       <b>sc::RDMAMemoryGrp</b>, and <b>sc::MsgMemoryGrp</b>.

   <b>virtual</b> <b>void</b> <b>sc::MemoryGrp::sync</b> <b>()</b> <b>[pure</b> <b>virtual]</b>
       Synchronizes all the nodes. This is useful after remote memory writes to be certain that all of the
       writes have completed and the data can be accessed locally, for example.

       Implemented in <b>sc::MTMPIMemoryGrp</b>, <b>sc::ARMCIMemoryGrp</b>, <b>sc::ProcMemoryGrp</b>, and <b>sc::MsgMemoryGrp</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for MPQC from the source code.

Version 2.3.1                                    Sun Oct 4 2020                                 <u>sc::<a href="../man3/MemoryGrp.3.html">MemoryGrp</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>