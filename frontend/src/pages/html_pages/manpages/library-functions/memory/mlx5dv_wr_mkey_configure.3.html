<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mlx5dv_wr_mkey_configure - Create a work request to configure an MKEY</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libibverbs-dev">libibverbs-dev_56.1-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mlx5dv_wr_mkey_configure - Create a work request to configure an MKEY

       mlx5dv_wr_set_mkey_access_flags - Set the memory protection attributes for an MKEY

       mlx5dv_wr_set_mkey_layout_list - Set a memory layout for an MKEY based on SGE list

       mlx5dv_wr_set_mkey_layout_interleaved - Set an interleaved memory layout for an MKEY

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;infiniband/mlx5dv.h&gt;

              static inline void mlx5dv_wr_mkey_configure(struct mlx5dv_qp_ex *mqp,
                                                          struct mlx5dv_mkey *mkey,
                                                          uint8_t num_setters,
                                                          struct mlx5dv_mkey_conf_attr *attr);

              static inline void mlx5dv_wr_set_mkey_access_flags(struct mlx5dv_qp_ex *mqp,
                                                                 uint32_t access_flags);

              static inline void mlx5dv_wr_set_mkey_layout_list(struct mlx5dv_qp_ex *mqp,
                                                                uint16_t num_sges,
                                                                const struct ibv_sge *sge);

              static inline void mlx5dv_wr_set_mkey_layout_interleaved(struct mlx5dv_qp_ex *mqp,
                                                                       uint32_t repeat_count,
                                                                       uint16_t num_interleaved,
                                                                       const struct mlx5dv_mr_interleaved *data);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  MLX5DV MKEY configure API and the related setters (mlx5dv_wr_set_mkey*) are an extension of IBV work
       request API (ibv_wr*) with specific features for MLX5DV MKEY.

       MKEYs allow creation of virtually-contiguous address  spaces  out  of  non-contiguous  chunks  of  memory
       regions  already registered with the hardware.  Additionally it provides access to some advanced hardware
       offload features, e.g.  signature offload.

       These APIs are intended to be used  to  access  additional  functionality  beyond  what  is  provided  by
       <b>mlx5dv_wr_mr_list</b>()  and  <b>mlx5dv_wr_mr_interleaved</b>().   The MKEY features can be optionally enabled using
       the mkey configure setters.  It allows using different features in the same MKEY.

</pre><h4><b>USAGE</b></h4><pre>
       To  use  these  APIs  a  QP  must  be  created  using  <b><a href="../man3/mlx5dv_create_qp.3.html">mlx5dv_create_qp</a></b>(3)  which  allows   setting   the
       <b>MLX5DV_QP_EX_WITH_MKEY_CONFIGURE</b> in <b>send_ops_flags</b>.

       The  MKEY  configuration  work  request  is  created  by calling <b>mlx5dv_wr_mkey_configure</b>(), a WR builder
       function, followed by required setter functions.  <u>num_setters</u> is a number of required setters for the WR.
       All setters are optional.  <u>num_setters</u> can be zero to apply <u>attr</u> only.  Each setter can  be  called  only
       once per the WR builder.

       The  WR  configures <u>mkey</u> and applies <u>attr</u> of the builder function and setter functions’ arguments for it.
       If <u>mkey</u> is already configured, the WR overrides some  <u>mkey</u>  properties  depends  on  builder  and  setter
       functions’  arguments  (see  details  in  setters’  description).   To  clear  configuration of <u>mkey</u>, use
       <b>ibv_post_send</b>() with <b>IBV_WR_LOCAL_INV</b> opcode or <b>ibv_wr_local_inv</b>().

       Current implementation requires the <b>IBV_SEND_INLINE</b> option to be  set  in  <b>wr_flags</b>  field  of  <b>ibv_qp_ex</b>
       structure  prior  to  builder  function call.  Non-inline payload is currently not supported by this API.
       Please note that inlining here is done for MKEY configuration data, not for user data referenced by  data
       layouts.

       Once  MKEY  is configured, it may be used in subsequent work requests (SEND, RDMA_READ, RDMA_WRITE, etc).
       If these work requests are posted on the same QP, there is  no  need  to  wait  for  completion  of  MKEY
       configuration  work  request.   They  can  be  posted immediately after the last setter (or builder if no
       setters).  Usually there is no need to even request a completion for MKEY configuration work request.

       If completion  is  requested  for  MKEY  configuration  work  request  it  will  be  delivered  with  the
       <b>IBV_WC_DRIVER1</b> opcode.

   <b>Builder</b> <b>function</b>
       <b>mlx5dv_wr_mkey_configure()</b>
              Post  a  work  request  to  configure  an  existing MKEY.  With this call alone, it is possible to
              configure the MKEY and keep or reset signature attributes.  This call may be followed by  zero  or
              more optional setters.

              <u>mqp</u>    The QP to post the work request on.

              <u>mkey</u>   The MKEY to configure.

              <u>num_setters</u>
                     The number of setters that must be called after this function.

              <u>attr</u>   The MKEY configuration attributes

   <b>MKEY</b> <b>configuration</b> <b>attributes</b>
       MKEY configuration attributes are provided in <b>mlx5dv_mkey_conf_attr</b> structure.

              struct mlx5dv_mkey_conf_attr {
                      uint32_t conf_flags;
                      uint64_t comp_mask;
              };

       <u>conf_flags</u>
              Bitwise OR of the following flags:

              <b>MLX5DV_MKEY_CONF_FLAG_RESET_SIG_ATTR</b>
                     Reset  the  signature  attributes of the MKEY.  If not set, previously configured signature
                     attributes will be kept.

       <u>comp_mask</u>
              Reserved for future extension, must be 0 now.

   <b>Generic</b> <b>setters</b>
       <b>mlx5dv_wr_set_mkey_access_flags()</b>
              Set the memory protection attributes for  the  MKEY.   If  the  MKEY  is  configured,  the  setter
              overrides  the previous value.  For example, two MKEY configuration WRs are posted.  The first one
              sets <b>IBV_ACCESS_REMOTE_READ</b>.  The second one sets  <b>IBV_ACCESS_REMOTE_WRITE</b>.   In  this  case,  the
              second  WR overrides the memory protection attributes, and only <b>IBV_ACCESS_REMOTE_WRITE</b> is allowed
              for the MKEY when the WR is completed.

              <u>mqp</u>    The QP where an MKEY configuration work request was created by <b>mlx5dv_wr_mkey_configure()</b>.

              <u>access_flags</u>
                     The desired memory protection attributes; it is either 0 or the bitwise OR of one  or  more
                     of flags in <b>enum</b> <b>ibv_access_flags</b>.

   <b>Data</b> <b>layout</b> <b>setters</b>
       Data  layout setters define how data referenced by the MKEY will be scattered/gathered in the memory.  In
       order to use MKEY with RDMA operations, it must be configured with a layout.

       Not more than one data layout setter may follow builder function.  Layout can  be  updated  in  the  next
       calls to builder function.

       When  MKEY  is  used  in  RDMA operations, it should be used in a zero-based mode, i.e. the <b>addr</b> field in
       <b>ibv_sge</b> structure is an offset in the total data.

       <b>mlx5dv_wr_set_mkey_layout_list()</b>
              Set a memory layout for an MKEY based on SGE list.  If the MKEY is configured and the data  layout
              was defined by some data layout setter (not necessary this one), the setter overrides the previous
              value.

              Default  WQE  size  can  fit  only  4 SGE entries.  To allow more, the QP should be created with a
              larger WQE size that may fit it.  This should be  done  using  the  <b>max_inline_data</b>  attribute  of
              <b>struct</b> <b>ibv_qp_cap</b> upon QP creation.

              <u>mqp</u>    The QP where an MKEY configuration work request was created by <b>mlx5dv_wr_mkey_configure()</b>.

              <u>num_sges</u>
                     Number of SGEs in the list.

              <u>sge</u>    Pointer to the list of <b>ibv_sge</b> structures.

       <b>mlx5dv_wr_set_mkey_layout_interleaved()</b>
              Set  an  interleaved memory layout for an MKEY.  If the MKEY is configured and the data layout was
              defined by some data layout setter (not necessary this one), the  setter  overrides  the  previous
              value.

              Default WQE size can fit only 3 interleaved entries.  To allow more, the QP should be created with
              a  larger  WQE  size  that may fit it.  This should be done using the <b>max_inline_data</b> attribute of
              <b>struct</b> <b>ibv_qp_cap</b> upon QP creation.

              As one entry will be consumed for strided header, the MKEY should be created with one  more  entry
              than the required <u>num_interleaved</u>.

              <u>mqp</u>    The QP where an MKEY configuration work request was created by <b>mlx5dv_wr_mkey_configure()</b>.

              <u>repeat_count</u>
                     The <u>data</u> layout representation is repeated <u>repeat_count</u> times.

              <u>num_interleaved</u>
                     Number of entries in the <u>data</u> representation.

              <u>data</u>   Pointer to the list of interleaved data layout descriptions.

              Interleaved data layout is described by <b>mlx5dv_mr_interleaved</b> structure.

                     struct mlx5dv_mr_interleaved {
                         uint64_t addr;
                         uint32_t bytes_count;
                         uint32_t bytes_skip;
                         uint32_t lkey;
                     };

              <u>addr</u>   Start address of the local memory buffer.

              <u>bytes_count</u>
                     Number of data bytes to put into the buffer.

              <u>bytes_skip</u>
                     Number of bytes to skip in the buffer before the next data block.

              <u>lkey</u>   Key of the local Memory Region

   <b>Signature</b> <b>setters</b>
       The  signature  attributes  of the MKEY allow adding/modifying/stripping/validating integrity fields when
       transmitting data from memory to network and when receiving data from network to memory.

       Use the signature setters to set/update the signature attributes of the MKEY.   To  reset  the  signature
       attributes without invalidating the MKEY, use the <b>MLX5DV_MKEY_CONF_FLAG_RESET_SIG_ATTR</b> flag.

       <b>mlx5dv_wr_set_mkey_sig_block</b>()
              Set  MKEY  block  signature  attributes.   If  the  MKEY  is already configured with the signature
              attributes,  the  setter  overrides  the   previous   value.    See   dedicated   man   page   for
              <b><a href="../man3/mlx5dv_wr_set_mkey_sig_block.3.html">mlx5dv_wr_set_mkey_sig_block</a></b>(3).

   <b>Crypto</b> <b>setter</b>
       The  crypto  attributes  of  the  MKey allow encryption and decryption of transmitted data from memory to
       network and when receiving data from network to memory.

       Use the crypto setter to set/update the crypto attributes of the MKey.  When the  MKey  is  created  with
       <b>MLX5DV_MKEY_INIT_ATTR_FLAGS_CRYPTO</b>  it  must  be configured with crypto attributes before the MKey can be
       used.

       <b>mlx5dv_wr_set_mkey_crypto()</b>
              Set MKey crypto attributes.  If the MKey is already configured with crypto attributes, the  setter
              overrides the previous value.  see dedicated man page for <b><a href="../man3/mlx5dv_wr_set_mkey_crypto.3.html">mlx5dv_wr_set_mkey_crypto</a></b>(3).

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Create</b> <b>QP</b> <b>and</b> <b>MKEY</b>
       Code below creates a QP with MKEY configure operation support and an indirect mkey.

              /* Create QP with MKEY configure support */
              struct ibv_qp_init_attr_ex attr_ex = {};
              attr_ex.comp_mask |= IBV_QP_INIT_ATTR_SEND_OPS_FLAGS;
              attr_ex.send_ops_flags |= IBV_QP_EX_WITH_RDMA_WRITE;

              struct mlx5dv_qp_init_attr attr_dv = {};
              attr_dv.comp_mask |= MLX5DV_QP_INIT_ATTR_MASK_SEND_OPS_FLAGS;
              attr_dv.send_ops_flags = MLX5DV_QP_EX_WITH_MKEY_CONFIGURE;

              ibv_qp *qp = mlx5dv_create_qp(ctx, attr_ex, attr_dv);
              ibv_qp_ex *qpx = ibv_qp_to_qp_ex(qp);
              mlx5dv_qp_ex *mqpx = mlx5dv_qp_ex_from_ibv_qp_ex(qpx);

              mkey_attr.create_flags = MLX5DV_MKEY_INIT_ATTR_FLAGS_INDIRECT;
              struct mlx5dv_mkey *mkey = mlx5dv_create_mkey(&amp;mkey_attr);

   <b>List</b> <b>data</b> <b>layout</b> <b>configuration</b>
       Code  below  configures  an  MKEY  which allows remote access for read and write and is based on SGE list
       layout with two entries.  When this MKEY is used in RDMA write operation, data will be scattered  between
       two memory regions.  The first 64 bytes will go to memory referenced by <b>mr1</b>.  The next 4096 bytes will go
       to memory referenced by <b>mr2</b>.

              ibv_wr_start(qpx);
              qpx-&gt;wr_id = my_wr_id_1;
              qpx-&gt;wr_flags = IBV_SEND_INLINE;

              struct mlx5dv_mkey_conf_attr mkey_attr = {};
              mlx5dv_wr_mkey_configure(mqpx, mkey, 2, &amp;mkey_attr);
              mlx5dv_wr_set_mkey_access_flags(mqpx, IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE);
              struct ibv_sge sgl[2];
              sgl[0].addr = mr1-&gt;addr;
              sgl[0].length = 64;
              sgl[0].lkey = mr1-&gt;lkey;
              sgl[1].addr = mr2-&gt;addr;
              sgl[1].length = 4096;
              sgl[1].lkey = mr2-&gt;lkey;
              mlx5dv_wr_set_mkey_layout_list(mqpx, 2, sgl);
              ret = ibv_wr_complete(qpx);

   <b>Interleaved</b> <b>data</b> <b>layout</b> <b>configuration</b>
       Code  below  configures an MKEY which allows remote access for read and write and is based on interleaved
       data layout with two entries and repeat count of two.  When this MKEY is used in  RDMA  write  operation,
       data  will  be scattered between two memory regions.  The first 512 bytes will go to memory referenced by
       <b>mr1</b> at offset 0.  The next 8 bytes will go to memory referenced by <b>mr2</b> at offset 0.  The next  512  bytes
       will  go to memory referenced by <b>mr1</b> at offset 516.  The next 8 bytes will go to memory referenced by <b>mr2</b>
       at offset 8.

              ibv_wr_start(qpx);
              qpx-&gt;wr_id = my_wr_id_1;
              qpx-&gt;wr_flags = IBV_SEND_INLINE;

              struct mlx5dv_mkey_conf_attr mkey_attr = {};
              mlx5dv_wr_mkey_configure(mqpx, mkey, 2, &amp;mkey_attr);
              mlx5dv_wr_set_mkey_access_flags(mqpx, IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE);
              struct mlx5dv_mr_interleaved data[2];
              data[0].addr = mr1-&gt;addr;
              data[0].bytes_count = 512;
              data[0].bytes_skip = 4;
              data[0].lkey = mr1-&gt;lkey;
              data[1].addr = mr2-&gt;addr;
              data[1].bytes_count = 8;
              data[1].bytes_skip = 0;
              data[1].lkey = mr2-&gt;lkey;
              mlx5dv_wr_set_mkey_layout_interleaved(mqpx, 2, 2, &amp;data);
              ret = ibv_wr_complete(qpx);

</pre><h4><b>NOTES</b></h4><pre>
       A DEVX context should be opened by using <b><a href="../man3/mlx5dv_open_device.3.html">mlx5dv_open_device</a></b>(3).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/mlx5dv_create_mkey.3.html">mlx5dv_create_mkey</a></b>(3), <b><a href="../man3/mlx5dv_create_qp.3.html">mlx5dv_create_qp</a></b>(3), <b><a href="../man3/mlx5dv_wr_set_mkey_sig_block.3.html">mlx5dv_wr_set_mkey_sig_block</a></b>(3), <b><a href="../man3/mlx5dv_wr_set_mkey_crypto.3.html">mlx5dv_wr_set_mkey_crypto</a></b>(3)

</pre><h4><b>AUTHORS</b></h4><pre>
       Oren Duer <a href="mailto:oren@nvidia.com">oren@nvidia.com</a>

       Sergey Gorenko <a href="mailto:sergeygo@nvidia.com">sergeygo@nvidia.com</a>

       Evgenii Kochetov <a href="mailto:evgeniik@nvidia.com">evgeniik@nvidia.com</a>

                                                                                     <u><a href="../man3/mlx5dv_wr_mkey_configure.3.html">mlx5dv_wr_mkey_configure</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>