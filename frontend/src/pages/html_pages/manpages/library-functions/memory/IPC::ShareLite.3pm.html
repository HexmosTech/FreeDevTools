<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPC::ShareLite - Lightweight interface to shared memory</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libipc-sharelite-perl">libipc-sharelite-perl_0.17-5build4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IPC::ShareLite - Lightweight interface to shared memory

</pre><h4><b>VERSION</b></h4><pre>
       This document describes IPC::ShareLite version 0.17

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use IPC::ShareLite;

           my $share = IPC::ShareLite-&gt;new(
               -key     =&gt; 1971,
               -create  =&gt; 'yes',
               -destroy =&gt; 'no'
           ) or die $!;

           $share-&gt;store( "This is stored in shared memory" );
           my $str = $share-&gt;fetch;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       IPC::ShareLite provides a simple interface to shared memory, allowing data to be efficiently communicated
       between processes. Your operating system must support SysV IPC (shared memory and semaphores) in order to
       use this module.

       IPC::ShareLite provides an abstraction of the shared memory and semaphore facilities of SysV IPC,
       allowing the storage of arbitrarily large data; the module automatically acquires and removes shared
       memory segments as needed. Storage and retrieval of data is atomic, and locking functions are provided
       for higher-level synchronization.

       In many respects, this module is similar to IPC::Shareable. However, IPC::ShareLite does not provide a
       tied interface, does not (automatically) allow the storage of variables, and is written in C for
       additional speed.

       Construct an IPC::ShareLite object by calling its constructor:

           my $share = IPC::ShareLite-&gt;new(
               -key     =&gt; 1971,
               -create  =&gt; 'yes',
               -destroy =&gt; 'no'
           ) or die $!;

       Once an instance has been created, data can be written to shared memory by calling the <b>store()</b> method:

               $share-&gt;store("This is going in shared memory");

       Retrieve the data by calling the <b>fetch()</b> method:

               my $str = $share-&gt;fetch();

       The <b>store()</b> and <b>fetch()</b> methods are atomic; any processes attempting to read or write to the memory are
       blocked until these calls finish.  However, in certain situations, you'll want to perform multiple
       operations atomically.  Advisory locking methods are available for this purpose.

       An exclusive lock is obtained by calling the <b>lock()</b> method:

               $share-&gt;lock();

       Happily, the <b>lock()</b> method also accepts all of the flags recognized by the <b>flock()</b> system call.  So, for
       example, you can obtain a shared lock like this:

               $share-&gt;lock( LOCK_SH );

       Or, you can make either type of lock non-blocking:

               $share-&gt;lock( LOCK_EX|LOCK_NB );

       Release the lock by calling the <b>unlock()</b> method:

               $share-&gt;unlock;

</pre><h4><b>METHODS</b></h4><pre>
   <b>"new($key,</b> <b>$create,</b> <b>$destroy,</b> <b>$exclusive,</b> <b>$mode,</b> <b>$flags,</b> <b>$size)"</b>
       This is the constructor for IPC::ShareLite.  It accepts both the positional and named parameter calling
       styles.

       $key is an integer value used to associate data between processes.  All processes wishing to communicate
       should use the same $key value.  $key may also be specified as a four character string, in which case it
       will be converted to an integer value automatically.  If $key is undefined, the shared memory will not be
       accessible from other processes.

       $create specifies whether the shared memory segment should be created if it does not already exist.
       Acceptable values are 1, 'yes', 0, or 'no'.

       $destroy indicates whether the shared memory segments and semaphores should be removed from the system
       once the object is destroyed.  Acceptable values are 1, 'yes', 0, or 'no'.

       If $exclusive is true, instantiation will fail if the shared memory segment already exists. Acceptable
       values are 1, 'yes', 0, or 'no'.

       $mode specifies the permissions for the shared memory and semaphores.  The default value is 0666.

       $flags specifies the exact shared memory and semaphore flags to use. The constants IPC_CREAT, IPC_EXCL,
       and IPC_PRIVATE are available for import.

       $size specifies the shared memory segment size, in bytes. The default size is 65,536 bytes, which is
       fairly portable. Linux, as an example, supports segment sizes of 4 megabytes.

       The constructor croaks on error.

   <b>store(</b> <b>$scalar</b> <b>)</b>
       This method stores $scalar into shared memory.  $scalar may be arbitrarily long.  Shared memory segments
       are acquired and released automatically as the data length changes.  The only limits on the amount of
       data are the system-wide limits on shared memory pages (SHMALL) and segments (SHMMNI) as compiled into
       the kernel.

       The method raises an exception on error.

       Note that unlike IPC::Shareable, this module does not automatically allow references to be stored.
       Serializing all data is expensive, and is not always necessary. If you need to store a reference, you
       should employ the Storable module yourself. For example:

           use Storable qw( freeze thaw );
           ...
               $hash = { red =&gt; 1, white =&gt; 1, blue =&gt; 1 };
           $share-&gt;store( freeze( $hash ) );
           ...
           $hash = thaw( $share-&gt;fetch );

   <b>"fetch"</b>
       This method returns the data that was previously stored in shared memory.  The empty string is returned
       if no data was previously stored.

       The method raises an exception on error.

   <b>lock(</b> <b>$type</b> <b>)</b>
       Obtains a lock on the shared memory.  $type specifies the type of lock to acquire.  If $type is not
       specified, an exclusive read/write lock is obtained.  Acceptable values for $type are the same as for the
       <b>flock()</b> system call.  The method returns true on success, and undef on error.  For non-blocking calls
       (see below), the method returns 0 if it would have blocked.

       Obtain an exclusive lock like this:

               $share-&gt;lock( LOCK_EX ); # same as default

       Only one process can hold an exclusive lock on the shared memory at a given time.

       Obtain a shared lock this this:

               $share-&gt;lock( LOCK_SH );

       Multiple processes can hold a shared lock at a given time.  If a process attempts to obtain an exclusive
       lock while one or more processes hold shared locks, it will be blocked until they have all finished.

       Either of the locks may be specified as non-blocking:

               $share-&gt;lock( LOCK_EX|LOCK_NB );
               $share-&gt;lock( LOCK_SH|LOCK_NB );

       A non-blocking lock request will return 0 if it would have had to wait to obtain the lock.

       Note that these locks are advisory (just like flock), meaning that all cooperating processes must
       coordinate their accesses to shared memory using these calls in order for locking to work.  See the
       <b>flock()</b> call for details.

       Locks are inherited through forks, which means that two processes actually can possess an exclusive lock
       at the same time.  Don't do that.

       The constants LOCK_EX, LOCK_SH, LOCK_NB, and LOCK_UN are available for import:

               use IPC::ShareLite qw( :lock );

       Or, just use the flock constants available in the Fcntl module.

   <b>"unlock"</b>
       Releases any locks.  This is actually equivalent to:

               $share-&gt;lock( LOCK_UN );

       The method returns true on success and undef on error.

   <b>"version"</b>
       Each share has a version number that incrementents monotonically for each write to the share. When the
       share is initally created its version number will be 1.

           my $num_writes = $share-&gt;version;

   <b>"key"</b>
       Get a share's key.

           my $key = $share-&gt;key;

   <b>"create"</b>
       Get a share's create flag.

   <b>"exclusive"</b>
       Get a share's exclusive flag.

   <b>"flags"</b>
       Get a share's flag.

   <b>"mode"</b>
       Get a share's mode.

   <b>"size"</b>
       Get a share's segment size.

   <b>"num_segments"</b>
       Get the number of segments in a share. The memory usage of a share can be approximated like this:

           my $usage = $share-&gt;size * $share-&gt;num_segments;

       $usage will be the memory usage rounded up to the next segment boundary.

   <b>"destroy"</b>
       Get or set the share's destroy flag.

</pre><h4><b>PERFORMANCE</b></h4><pre>
       For a rough idea of the performance you can expect, here are some benchmarks.  The tests were performed
       using the Benchmark module on a Cyrix PR166+ running RedHat Linux 5.2 with the 2.0.36 kernel, perl
       5.005_02 using perl's malloc, and the default shared memory segment size.  Each test was run 5000 times.

               DATA SIZE (bytes)       TIME (seconds)  Op/Sec

        store  16384                   2               2500
        fetch  16384                   2               2500

        store  32768                   3               1666
        fetch  32768                   3               1666

        store  65536                   6               833
        fetch  65536                   5               1000

        store  131072                  12              416
        fetch  131072                  12              416

        store  262144                  28              178
        fetch  262144                  27              185

        store  524288                  63              79
        fetch  524288                  61              81

       Most of the time appears to be due to memory copying.  Suggestions for speed improvements are welcome.

</pre><h4><b>PORTABILITY</b></h4><pre>
       The module should compile on any system with SysV IPC and an ANSI C compiler, and should compile cleanly
       with the -pedantic and -Wall flags.

       The module has been tested under Solaris, FreeBSD, and Linux.  Testing on other platforms is needed.

       If you encounter a compilation error due to the definition of the semun union, edit the top of
       sharestuff.c and undefine the semun definition.  And then please tell me about it.

       I've heard rumors that a SysV IPC interface has been constructed for Win32 systems.  Support for it may
       be added to this module.

       IPC::ShareLite does not understand the shared memory data format used by IPC::Shareable.

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright 1998-2002, Maurice Aubrey &lt;<a href="mailto:maurice@hevanet.com">maurice@hevanet.com</a>&gt;.  All rights reserved.

       This release by Andy Armstrong &lt;<a href="mailto:andy@hexten.net">andy@hexten.net</a>&gt;.

       This module is free software; you may redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>CREDITS</b></h4><pre>
       Special thanks to Benjamin Sugars for developing the IPC::Shareable module.

       See the Changes file for other contributors.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       IPC::Shareable, <b><a href="../man2/ipc.2.html">ipc</a></b>(2), <b><a href="../man2/shmget.2.html">shmget</a></b>(2), <b><a href="../man2/semget.2.html">semget</a></b>(2), perl.

perl v5.40.0                                       2024-10-20                                <u>IPC::<a href="../man3pm/ShareLite.3pm.html">ShareLite</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>