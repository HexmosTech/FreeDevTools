<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       shm_open — open a shared memory object (<b>REALTIME</b>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;sys/mman.h&gt;

       int shm_open(const char *<u>name</u>, int <u>oflag</u>, mode_t <u>mode</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>shm_open</u>()  function  shall  establish  a  connection  between  a  shared  memory  object and a file
       descriptor. It shall create an open file description that refers to the shared memory object and  a  file
       descriptor that refers to that open file description. The file descriptor shall be allocated as described
       in  <u>Section</u>  <u>2.14</u>, <u>File</u> <u>Descriptor</u> <u>Allocation</u>, and can be used by other functions to refer to that shared
       memory object.  The <u>name</u> argument points to a string naming a shared memory  object.  It  is  unspecified
       whether  the  name  appears  in  the file system and is visible to other functions that take pathnames as
       arguments. The <u>name</u> argument conforms  to  the  construction  rules  for  a  pathname,  except  that  the
       interpretation  of &lt;slash&gt; characters other than the leading &lt;slash&gt; character in <u>name</u> is implementation-
       defined, and that the length limits for the <u>name</u> argument are implementation-defined and need not be  the
       same  as  the pathname limits {PATH_MAX} and {NAME_MAX}.  If <u>name</u> begins with the &lt;slash&gt; character, then
       processes calling <u>shm_open</u>() with the same value of <u>name</u> refer to the same shared memory object, as  long
       as  that  name  has  not  been  removed. If <u>name</u> does not begin with the &lt;slash&gt; character, the effect is
       implementation-defined.

       If successful, <u>shm_open</u>() shall return a file descriptor for the shared memory  object.   The  open  file
       description  is  new, and therefore the file descriptor does not share it with any other processes. It is
       unspecified whether the file offset is set. The FD_CLOEXEC file descriptor flag associated with  the  new
       file descriptor is set.

       The  file  status  flags and file access modes of the open file description are according to the value of
       <u>oflag</u>.  The <u>oflag</u> argument is the bitwise-inclusive OR of the following flags defined  in  the  <u>&lt;fcntl.h&gt;</u>
       header.  Applications  specify  exactly  one of the first two values (access modes) below in the value of
       <u>oflag</u>:

       O_RDONLY    Open for read access only.

       O_RDWR      Open for read or write access.

       Any combination of the remaining flags may be specified in the value of <u>oflag</u>:

       O_CREAT     If the shared memory object exists, this flag has no effect, except  as  noted  under  O_EXCL
                   below.  Otherwise,  the  shared  memory  object  is created. The user ID of the shared memory
                   object shall be set to the effective user ID of the process.  The  group  ID  of  the  shared
                   memory  object  shall  be  set to the effective group ID of the process; however, if the <u>name</u>
                   argument is visible in the file system, the group ID may be  set  to  the  group  ID  of  the
                   containing  directory.  The  permission  bits of the shared memory object shall be set to the
                   value of the <u>mode</u> argument except those set in the file mode creation mask  of  the  process.
                   When bits in <u>mode</u> other than the file permission bits are set, the effect is unspecified. The
                   <u>mode</u>  argument  does  not  affect whether the shared memory object is opened for reading, for
                   writing, or for both. The shared memory object has a size of zero.

       O_EXCL      If O_EXCL and O_CREAT are set, <u>shm_open</u>() fails if the shared memory object exists. The check
                   for the existence of the shared memory object and the creation of the object if it  does  not
                   exist  is  atomic with respect to other processes executing <u>shm_open</u>() naming the same shared
                   memory object with O_EXCL and O_CREAT set. If O_EXCL is set  and  O_CREAT  is  not  set,  the
                   result is undefined.

       O_TRUNC     If the shared memory object exists, and it is successfully opened O_RDWR, the object shall be
                   truncated to zero length and the mode and owner shall be unchanged by this function call. The
                   result of using O_TRUNC with O_RDONLY is undefined.

       When  a  shared  memory  object  is  created,  the  state of the shared memory object, including all data
       associated with the shared memory object, persists until the shared memory object  is  unlinked  and  all
       other references are gone. It is unspecified whether the name and shared memory object state remain valid
       after a system reboot.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon  successful completion, the <u>shm_open</u>() function shall return a non-negative integer representing the
       file descriptor. Otherwise, it shall return -1 and set <u>errno</u> to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>shm_open</u>() function shall fail if:

       <b>EACCES</b> The shared memory object exists and the permissions specified by <u>oflag</u> are denied, or  the  shared
              memory  object  does  not  exist  and  permission to create the shared memory object is denied, or
              O_TRUNC is specified and write permission is denied.

       <b>EEXIST</b> O_CREAT and O_EXCL are set and the named shared memory object already exists.

       <b>EINTR</b>  The <u>shm_open</u>() operation was interrupted by a signal.

       <b>EINVAL</b> The <u>shm_open</u>() operation is not supported for the given name.

       <b>EMFILE</b> All file descriptors available to the process are currently open.

       <b>ENFILE</b> Too many shared memory objects are currently open in the system.

       <b>ENOENT</b> O_CREAT is not set and the named shared memory object does not exist.

       <b>ENOSPC</b> There is insufficient space for the creation of the new shared memory object.

       The <u>shm_open</u>() function may fail if:

       <b>ENAMETOOLONG</b>
              The length of the <u>name</u> argument exceeds {_POSIX_PATH_MAX} on systems that do not support  the  XSI
              option  or  exceeds  {_XOPEN_PATH_MAX}  on XSI systems, or has a pathname component that is longer
              than  {_POSIX_NAME_MAX}  on  systems  that  do  not  support  the  XSI  option  or   longer   than
              {_XOPEN_NAME_MAX} on XSI systems.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Creating</b> <b>and</b> <b>Mapping</b> <b>a</b> <b>Shared</b> <b>Memory</b> <b>Object</b>
       The  following  code segment demonstrates the use of <u>shm_open</u>() to create a shared memory object which is
       then sized using <u>ftruncate</u>() before being mapped into the process address space using <u>mmap</u>():

           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           #include &lt;sys/mman.h&gt;
           ...

           #define MAX_LEN 10000
           struct region {        /* Defines "structure" of shared memory */
               int len;
               char buf[MAX_LEN];
           };
           struct region *rptr;
           int fd;

           /* Create shared memory object and set its size */

           fd = shm_open("/myregion", O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
           if (fd == -1)
               /* Handle error */;

           if (ftruncate(fd, sizeof(struct region)) == -1)
               /* Handle error */;

           /* Map shared memory object */

           rptr = mmap(NULL, sizeof(struct region),
                  PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
           if (rptr == MAP_FAILED)
               /* Handle error */;

           /* Now we can refer to mapped region using fields of rptr;
              for example, rptr-&gt;len */
           ...

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       None.

</pre><h4><b>RATIONALE</b></h4><pre>
       When the Memory Mapped Files option is supported, the normal <u>open</u>() call is used to obtain  a  descriptor
       to a file to be mapped according to existing practice with <u>mmap</u>().  When the Shared Memory Objects option
       is supported, the <u>shm_open</u>() function shall obtain a descriptor to the shared memory object to be mapped.

       There  is  ample  precedent  for  having  a  file  descriptor  represent several types of objects. In the
       POSIX.1‐1990 standard, a file descriptor can represent a file, a pipe, a FIFO, a  tty,  or  a  directory.
       Many  implementations  simply have an operations vector, which is indexed by the file descriptor type and
       does very different operations. Note that in some cases the file descriptor passed to generic  operations
       on  file  descriptors is returned by <u>open</u>() or <u>creat</u>() and in some cases returned by alternate functions,
       such as <u>pipe</u>().  The latter technique is used by <u>shm_open</u>().

       Note that such shared memory objects can actually be implemented as mapped files. In both cases, the size
       can be set after the open using <u>ftruncate</u>().  The <u>shm_open</u>() function itself does  not  create  a  shared
       object of a specified size because this would duplicate an extant function that set the size of an object
       referenced by a file descriptor.

       On  implementations  where  memory objects are implemented using the existing file system, the <u>shm_open</u>()
       function may be implemented using a macro that invokes <u>open</u>(),  and  the  <u>shm_unlink</u>()  function  may  be
       implemented using a macro that invokes <u>unlink</u>().

       For  implementations without a permanent file system, the definition of the name of the memory objects is
       allowed not to survive a system reboot. Note that this allows systems with a  permanent  file  system  to
       implement memory objects as data structures internal to the implementation as well.

       On  implementations  that choose to implement memory objects using memory directly, a <u>shm_open</u>() followed
       by an <u>ftruncate</u>() and <u>close</u>() can be used to preallocate a shared memory area and to set the size of that
       preallocation. This may be necessary for systems without virtual memory  hardware  support  in  order  to
       ensure that the memory is contiguous.

       The  set  of  valid  open  flags  to  <u>shm_open</u>() was restricted to O_RDONLY, O_RDWR, O_CREAT, and O_TRUNC
       because these could be easily implemented on most memory mapping systems. This volume of POSIX.1‐2017  is
       silent  on  the  results  if  the  implementation  cannot  supply  the  requested  file access because of
       implementation-defined reasons, including hardware ones.

       The  error  conditions  <b>[EACCES]</b>  and  <b>[ENOTSUP]</b>  are  provided  to  inform  the  application  that   the
       implementation cannot complete a request.

       <b>[EACCES]</b> indicates for implementation-defined reasons, probably hardware-related, that the implementation
       cannot comply with a requested mode because it conflicts with another requested mode. An example might be
       that  an  application  desires  to open a memory object two times, mapping different areas with different
       access modes. If the implementation cannot map a single area into a process space in  two  places,  which
       would  be required if different access modes were required for the two areas, then the implementation may
       inform the application at the time of the second open.

       <b>[ENOTSUP]</b>  indicates  for   implementation-defined   reasons,   probably   hardware-related,   that   the
       implementation  cannot  comply with a requested mode at all. An example would be that the hardware of the
       implementation cannot support write-only shared memory areas.

       On all implementations, it may be desirable to restrict the location of the memory  objects  to  specific
       file  systems  for  performance  (such  as  a  RAM disk) or implementation-defined reasons (shared memory
       supported directly only on certain file systems). The <u>shm_open</u>() function may be used  to  enforce  these
       restrictions. There are a number of methods available to the application to determine an appropriate name
       of  the  file  or the location of an appropriate directory. One way is from the environment via <u>getenv</u>().
       Another would be from a configuration file.

       This volume of POSIX.1‐2017 specifies that memory objects have initial contents  of  zero  when  created.
       This  is  consistent  with  current  behavior  for  both  files  and  newly  allocated  memory. For those
       implementations that use physical memory, it would be possible that such implementations could simply use
       available memory and give it to the  process  uninitialized.   This,  however,  is  not  consistent  with
       standard behavior for the uninitialized data area, the stack, and of course, files. Finally, it is highly
       desirable  to set the allocated memory to zero for security reasons. Thus, initializing memory objects to
       zero is required.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       A future version might require the <u>shm_open</u>() and <u>shm_unlink</u>() functions to  have  semantics  similar  to
       normal file system operations.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u>  <u>2.14</u>,  <u>File</u>  <u>Descriptor</u>  <u>Allocation</u>,  <u>close</u>(),  <u>dup</u>(), <u>exec</u>, <u>fcntl</u>(), <u>mmap</u>(), <u>shmat</u>(), <u>shmctl</u>(),
       <u>shmdt</u>(), <u>shm_unlink</u>(), <u>umask</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;fcntl.h&gt;</b>, <b>&lt;sys_mman.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                      <u><a href="../man3POSIX/SHM_OPEN.3POSIX.html">SHM_OPEN</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>