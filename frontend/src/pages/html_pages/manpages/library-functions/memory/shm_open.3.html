<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>shm_open, shm_unlink - create/open or unlink POSIX shared memory objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       shm_open, shm_unlink - create/open or unlink POSIX shared memory objects

</pre><h4><b>LIBRARY</b></h4><pre>
       Real-time library (<u>librt</u>, <u>-lrt</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/mman.h&gt;</b>
       <b>#include</b> <b>&lt;sys/stat.h&gt;</b>        /* For mode constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;</b>           /* For O_* constants */

       <b>int</b> <b>shm_open(const</b> <b>char</b> <b>*</b><u>name</u><b>,</b> <b>int</b> <u>oflag</u><b>,</b> <b>mode_t</b> <u>mode</u><b>);</b>
       <b>int</b> <b>shm_unlink(const</b> <b>char</b> <b>*</b><u>name</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>shm_open</b>()  creates  and  opens  a new, or opens an existing, POSIX shared memory object.  A POSIX shared
       memory object is in effect a handle which can be used by unrelated processes to <b><a href="../man2/mmap.2.html">mmap</a></b>(2) the  same  region
       of  shared  memory.   The  <b>shm_unlink</b>()  function  performs  the  converse  operation, removing an object
       previously created by <b>shm_open</b>().

       The operation of <b>shm_open</b>() is analogous to that of <b><a href="../man2/open.2.html">open</a></b>(2).  <u>name</u> specifies the shared memory object  to
       be  created  or  opened.   For portable use, a shared memory object should be identified by a name of the
       form <u>/somename</u>; that is, a null-terminated string of up to <b>NAME_MAX</b> (i.e., 255) characters consisting  of
       an initial slash, followed by one or more characters, none of which are slashes.

       <u>oflag</u>  is  a  bit  mask  created by ORing together exactly one of <b>O_RDONLY</b> or <b>O_RDWR</b> and any of the other
       flags listed here:

       <b>O_RDONLY</b>
              Open the object for read access.  A shared memory object opened in this way can be <b><a href="../man2/mmap.2.html">mmap</a></b>(2)ed  only
              for read (<b>PROT_READ</b>) access.

       <b>O_RDWR</b> Open the object for read-write access.

       <b>O_CREAT</b>
              Create  the shared memory object if it does not exist.  The user and group ownership of the object
              are taken from the corresponding effective IDs of the calling process, and the object's permission
              bits are set according to the low-order 9 bits of <u>mode</u>, except that those bits set in the  process
              file  mode  creation mask (see <b><a href="../man2/umask.2.html">umask</a></b>(2)) are cleared for the new object.  A set of macro constants
              which can be used to define <u>mode</u> is listed in <b><a href="../man2/open.2.html">open</a></b>(2).  (Symbolic definitions of  these  constants
              can be obtained by including <u>&lt;sys/stat.h&gt;</u>.)

              A  new  shared  memory  object  initially  has zero length—the size of the object can be set using
              <b><a href="../man2/ftruncate.2.html">ftruncate</a></b>(2).  The newly allocated bytes of a shared memory object are  automatically  initialized
              to 0.

       <b>O_EXCL</b> If  <b>O_CREAT</b>  was  also  specified,  and a shared memory object with the given <u>name</u> already exists,
              return an error.  The check for the existence of the object, and  its  creation  if  it  does  not
              exist, are performed atomically.

       <b>O_TRUNC</b>
              If the shared memory object already exists, truncate it to zero bytes.

       Definitions of these flag values can be obtained by including <u>&lt;fcntl.h&gt;</u>.

       On  successful completion <b>shm_open</b>() returns a new file descriptor referring to the shared memory object.
       This file descriptor is guaranteed to be the lowest-numbered file descriptor not previously opened within
       the process.  The <b>FD_CLOEXEC</b> flag (see <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2)) is set for the file descriptor.

       The file descriptor is normally used in subsequent calls to <b><a href="../man2/ftruncate.2.html">ftruncate</a></b>(2) (for a newly created object) and
       <b><a href="../man2/mmap.2.html">mmap</a></b>(2).  After a call to <b><a href="../man2/mmap.2.html">mmap</a></b>(2) the file descriptor may be closed without affecting the memory mapping.

       The operation of <b>shm_unlink</b>() is analogous to <b><a href="../man2/unlink.2.html">unlink</a></b>(2): it removes a shared  memory  object  name,  and,
       once  all  processes  have  unmapped  the object, deallocates and destroys the contents of the associated
       memory region.  After a successful <b>shm_unlink</b>(), attempts to <b>shm_open</b>() an object with the same <u>name</u> fail
       (unless <b>O_CREAT</b> was specified, in which case a new, distinct object is created).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>shm_open</b>() returns a file descriptor  (a  nonnegative  integer).   On  success,  <b>shm_unlink</b>()
       returns 0.  On failure, both functions return -1 and set <u>errno</u> to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EACCES</b> Permission to <b>shm_unlink</b>() the shared memory object was denied.

       <b>EACCES</b> Permission  was  denied to <b>shm_open</b>() <u>name</u> in the specified <u>mode</u>, or <b>O_TRUNC</b> was specified and the
              caller does not have write permission on the object.

       <b>EEXIST</b> Both <b>O_CREAT</b> and <b>O_EXCL</b> were specified to <b>shm_open</b>() and the shared  memory  object  specified  by
              <u>name</u> already exists.

       <b>EINVAL</b> The <u>name</u> argument to <b>shm_open</b>() was invalid.

       <b>EMFILE</b> The per-process limit on the number of open file descriptors has been reached.

       <b>ENAMETOOLONG</b>
              The length of <u>name</u> exceeds <b>PATH_MAX</b>.

       <b>ENFILE</b> The system-wide limit on the total number of open files has been reached.

       <b>ENOENT</b> An attempt was made to <b>shm_open</b>() a <u>name</u> that did not exist, and <b>O_CREAT</b> was not specified.

       <b>ENOENT</b> An attempt was to made to <b>shm_unlink</b>() a <u>name</u> that does not exist.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       For an explanation of the terms used in this section, see <b><a href="../man7/attributes.7.html">attributes</a></b>(7).
       ┌──────────────────────────────────────────────────────────────────────┬───────────────┬────────────────┐
       │ <b>Interface</b>                                                            │ <b>Attribute</b>     │ <b>Value</b>          │
       ├──────────────────────────────────────────────────────────────────────┼───────────────┼────────────────┤
       │ <b>shm_open</b>(), <b>shm_unlink</b>()                                             │ Thread safety │ MT-Safe locale │
       └──────────────────────────────────────────────────────────────────────┴───────────────┴────────────────┘

</pre><h4><b>VERSIONS</b></h4><pre>
       POSIX  leaves  the  behavior of the combination of <b>O_RDONLY</b> and <b>O_TRUNC</b> unspecified.  On Linux, this will
       successfully truncate an existing shared memory object—this may not be so on other UNIX systems.

       The POSIX shared memory object implementation on Linux makes use of a dedicated <b><a href="../man5/tmpfs.5.html">tmpfs</a></b>(5) filesystem  that
       is normally mounted under <u><a href="file:/dev/shm">/dev/shm</a></u>.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       glibc 2.2.  POSIX.1-2001.

       POSIX.1-2001  says  that the group ownership of a newly created shared memory object is set to either the
       calling process's effective group ID or "a system default group ID".  POSIX.1-2008 says  that  the  group
       ownership  may  be set to either the calling process's effective group ID or, if the object is visible in
       the filesystem, the group ID of the parent directory.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The programs below employ POSIX shared memory and POSIX unnamed semaphores to exchange a piece  of  data.
       The "bounce" program (which must be run first) raises the case of a string that is placed into the shared
       memory  by  the  "send"  program.   Once  the  data has been modified, the "send" program then prints the
       contents of the modified shared memory.  An example execution of the two programs is the following:

           $ <b>./pshm_ucase_bounce</b> <b>/myshm</b> <b>&amp;</b>
           [1] 270171
           $ <b>./pshm_ucase_send</b> <b>/myshm</b> <b>hello</b>
           HELLO

       Further detail about these programs is provided below.

   <b>Program</b> <b>source:</b> <b>pshm_ucase.h</b>
       The following header file is included by both programs  below.   Its  primary  purpose  is  to  define  a
       structure that will be imposed on the memory object that is shared between the two programs.

           #ifndef PSHM_UCASE_H
           #define PSHM_UCASE_H

           #include &lt;<a href="file:/usr/include/semaphore.h">semaphore.h</a>&gt;
           #include &lt;stddef.h&gt;
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

           #define <a href="../manmsg/errExit.msg.html">errExit</a>(msg)    do { <a href="../manmsg/perror.msg.html">perror</a>(msg); exit(EXIT_FAILURE); \
                                   } while (0)

           #define BUF_SIZE 1024   /* Maximum size for exchanged string */

           /* Define a structure that will be imposed on the shared
              memory object */

           struct shmbuf {
               sem_t  sem1;            /* POSIX unnamed semaphore */
               sem_t  sem2;            /* POSIX unnamed semaphore */
               size_t cnt;             /* Number of bytes used in 'buf' */
               char   buf[BUF_SIZE];   /* Data being transferred */
           };

           #endif  // include guard

   <b>Program</b> <b>source:</b> <b>pshm_ucase_bounce.c</b>
       The  "bounce" program creates a new shared memory object with the name given in its command-line argument
       and sizes the object to match the size of the <u>shmbuf</u> structure defined in the header file.  It then  maps
       the object into the process's address space, and initializes two POSIX semaphores inside the object to 0.

       After  the  "send"  program  has posted the first of the semaphores, the "bounce" program upper cases the
       data that has been placed in the memory by the "send" program and then posts the second semaphore to tell
       the "send" program that it may now access the shared memory.

           /* pshm_ucase_bounce.c

              Licensed under GNU General Public License v2 or later.
           */
           #include &lt;<a href="file:/usr/include/ctype.h">ctype.h</a>&gt;
           #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;sys/mman.h&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

           #include "pshm_ucase.h"

           int
           main(int argc, char *argv[])
           {
               int            fd;
               char           *shmpath;
               struct shmbuf  *shmp;

               if (argc != 2) {
                   fprintf(stderr, "Usage: %s /shm-path\n", argv[0]);
                   exit(EXIT_FAILURE);
               }

               shmpath = argv[1];

               /* Create shared memory object and set its size to the size
                  of our structure. */

               fd = shm_open(shmpath, O_CREAT | O_EXCL | O_RDWR, 0600);
               if (fd == -1)
                   errExit("shm_open");

               if (ftruncate(fd, sizeof(struct shmbuf)) == -1)
                   errExit("ftruncate");

               /* Map the object into the caller's address space. */

               shmp = mmap(NULL, sizeof(*shmp), PROT_READ | PROT_WRITE,
                           MAP_SHARED, fd, 0);
               if (shmp == MAP_FAILED)
                   errExit("mmap");

               /* Initialize semaphores as process-shared, with value 0. */

               if (sem_init(&amp;shmp-&gt;sem1, 1, 0) == -1)
                   errExit("sem_init-sem1");
               if (sem_init(&amp;shmp-&gt;sem2, 1, 0) == -1)
                   errExit("sem_init-sem2");

               /* Wait for 'sem1' to be posted by peer before touching
                  shared memory. */

               if (sem_wait(&amp;shmp-&gt;sem1) == -1)
                   errExit("sem_wait");

               /* Convert data in shared memory into upper case. */

               for (size_t j = 0; j &lt; shmp-&gt;cnt; j++)
                   shmp-&gt;buf[j] = toupper((unsigned char) shmp-&gt;buf[j]);

               /* Post 'sem2' to tell the peer that it can now
                  access the modified data in shared memory. */

               if (sem_post(&amp;shmp-&gt;sem2) == -1)
                   errExit("sem_post");

               /* Unlink the shared memory object. Even if the peer process
                  is still using the object, this is okay. The object will
                  be removed only after all open references are closed. */

               shm_unlink(shmpath);

               exit(EXIT_SUCCESS);
           }

   <b>Program</b> <b>source:</b> <b>pshm_ucase_send.c</b>
       The "send" program takes two command-line arguments: the pathname of a shared  memory  object  previously
       created by the "bounce" program and a string that is to be copied into that object.

       The  program  opens  the shared memory object and maps the object into its address space.  It then copies
       the data specified in its second argument into the shared memory, and posts the  first  semaphore,  which
       tells the "bounce" program that it can now access that data.  After the "bounce" program posts the second
       semaphore, the "send" program prints the contents of the shared memory on standard output.

           /* pshm_ucase_send.c

              Licensed under GNU General Public License v2 or later.
           */
           #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
           #include &lt;stddef.h&gt;
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
           #include &lt;sys/mman.h&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

           #include "pshm_ucase.h"

           int
           main(int argc, char *argv[])
           {
               int            fd;
               char           *shmpath, *string;
               size_t         len;
               struct shmbuf  *shmp;

               if (argc != 3) {
                   fprintf(stderr, "Usage: %s /shm-path string\n", argv[0]);
                   exit(EXIT_FAILURE);
               }

               shmpath = argv[1];
               string = argv[2];
               len = strlen(string);

               if (len &gt; BUF_SIZE) {
                   fprintf(stderr, "String is too long\n");
                   exit(EXIT_FAILURE);
               }

               /* Open the existing shared memory object and map it
                  into the caller's address space. */

               fd = shm_open(shmpath, O_RDWR, 0);
               if (fd == -1)
                   errExit("shm_open");

               shmp = mmap(NULL, sizeof(*shmp), PROT_READ | PROT_WRITE,
                           MAP_SHARED, fd, 0);
               if (shmp == MAP_FAILED)
                   errExit("mmap");

               /* Copy data into the shared memory object. */

               shmp-&gt;cnt = len;
               memcpy(&amp;shmp-&gt;buf, string, len);

               /* Tell peer that it can now access shared memory. */

               if (sem_post(&amp;shmp-&gt;sem1) == -1)
                   errExit("sem_post");

               /* Wait until peer says that it has finished accessing
                  the shared memory. */

               if (sem_wait(&amp;shmp-&gt;sem2) == -1)
                   errExit("sem_wait");

               /* Write modified data in shared memory to standard output. */

               write(STDOUT_FILENO, &amp;shmp-&gt;buf, len);
               write(STDOUT_FILENO, "\n", 1);

               exit(EXIT_SUCCESS);
           }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/close.2.html">close</a></b>(2),  <b><a href="../man2/fchmod.2.html">fchmod</a></b>(2),  <b><a href="../man2/fchown.2.html">fchown</a></b>(2),  <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2),  <b><a href="../man2/fstat.2.html">fstat</a></b>(2),  <b><a href="../man2/ftruncate.2.html">ftruncate</a></b>(2), <b><a href="../man2/memfd_create.2.html">memfd_create</a></b>(2), <b><a href="../man2/mmap.2.html">mmap</a></b>(2), <b><a href="../man2/open.2.html">open</a></b>(2),
       <b><a href="../man2/umask.2.html">umask</a></b>(2), <b><a href="../man7/shm_overview.7.html">shm_overview</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                        <u><a href="../man3/shm_open.3.html">shm_open</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>