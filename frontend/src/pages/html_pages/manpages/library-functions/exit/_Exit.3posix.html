<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
<b>_</b><u>EXIT</u>(3POSIX)                               POSIX Programmer's Manual                              <b>_</b><u>EXIT</u>(3POSIX)

</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       _Exit, _exit — terminate a process

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

       void _Exit(int <u>status</u>);

       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       void _exit(int <u>status</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       For  <b>_</b><u>Exit</u>():  The functionality described on this reference page is aligned with the ISO C standard. Any
       conflict between the requirements described here and the ISO C standard is unintentional. This volume  of
       POSIX.1‐2017 defers to the ISO C standard.

       The  value  of  <u>status</u>  may  be  0, EXIT_SUCCESS, EXIT_FAILURE, or any other value, though only the least
       significant 8 bits (that is, <u>status</u> &amp; 0377) shall be available from <u>wait</u>() and <u>waitpid</u>(); the full  value
       shall be available from <u>waitid</u>() and in the <b>siginfo_t</b> passed to a signal handler for SIGCHLD.

       The <b>_</b><u>Exit</u>() and <b>_</b><u>exit</u>() functions shall be functionally equivalent.

       The  <b>_</b><u>Exit</u>()  and  <b>_</b><u>exit</u>() functions shall not call functions registered with <u>atexit</u>() nor any registered
       signal handlers.  Open streams shall not be flushed.  Whether open streams are closed (without  flushing)
       is  implementation-defined.  Finally,  the  calling  process  shall  be  terminated with the consequences
       described below.

   <b>Consequences</b> <b>of</b> <b>Process</b> <b>Termination</b>
       Process termination caused by any reason shall have the following consequences:

       <b>Note:</b>     These consequences are all extensions to the ISO C standard and  are  not  further  CX  shaded.
                 However, functionality relating to the XSI option is shaded.

        *  All  of  the  file  descriptors,  directory  streams,  conversion  descriptors,  and  message catalog
           descriptors open in the calling process shall be closed.

        *  If the parent process of the calling process has set its SA_NOCLDWAIT flag or has set the action  for
           the SIGCHLD signal to SIG_IGN:

           --  The  process'  status  information  (see  <u>Section</u>  <u>2.13</u>,  <u>Status</u>  <u>Information</u>),  if any, shall be
               discarded.

           --  The lifetime of the calling process  shall  end  immediately.  If  SA_NOCLDWAIT  is  set,  it  is
               implementation-defined whether a SIGCHLD signal is sent to the parent process.

           --  If  a  thread  in  the  parent process of the calling process is blocked in <u>wait</u>(), <u>waitpid</u>(), or
               <u>waitid</u>(), and the parent process has no remaining  child  processes  in  the  set  of  waited-for
               children, the <u>wait</u>(), <u>waitid</u>(), or <u>waitpid</u>() function shall fail and set <u>errno</u> to <b>[ECHILD]</b>.

           Otherwise:

           --  Status information (see <u>Section</u> <u>2.13</u>, <u>Status</u> <u>Information</u>) shall be generated.

           --  The  calling  process shall be transformed into a zombie process. Its status information shall be
               made available to the parent process until the process' lifetime ends.

           --  The process' lifetime shall end once its parent obtains the process'  status  information  via  a
               currently-blocked or future call to <u>wait</u>(), <u>waitid</u>() (without WNOWAIT), or <u>waitpid</u>().

           --  If  one  or  more  threads  in  the parent process of the calling process is blocked in a call to
               <u>wait</u>(), <u>waitid</u>(), or <u>waitpid</u>() awaiting termination of the process, one (or, if any  are  calling
               <u>waitid</u>()  with  WNOWAIT,  possibly  more)  of  these  threads  shall  obtain  the process' status
               information as specified in <u>Section</u> <u>2.13</u>, <u>Status</u> <u>Information</u> and become unblocked.

           --  A SIGCHLD shall be sent to the parent process.

        *  Termination of a process does not directly terminate its children.  The sending of a SIGHUP signal as
           described below indirectly terminates children in some circumstances.

        *  The parent process ID of all of the existing child processes and  zombie  processes  of  the  calling
           process  shall  be  set to the process ID of an implementation-defined system process. That is, these
           processes shall be inherited by a special system process.

        *  Each attached shared-memory segment is detached and the value of <u>shm_nattch</u>  (see  <u>shmget</u>())  in  the
           data structure associated with its shared memory ID shall be decremented by 1.

        *  For  each  semaphore  for  which the calling process has set a <u>semadj</u> value (see <u>semop</u>()), that value
           shall be added to the <u>semval</u> of the specified semaphore.

        *  If the process is a controlling process, the SIGHUP signal shall be  sent  to  each  process  in  the
           foreground process group of the controlling terminal belonging to the calling process.

        *  If  the  process is a controlling process, the controlling terminal associated with the session shall
           be disassociated from the session, allowing it to be acquired by a new controlling process.

        *  If the exit of the process causes a process group to become orphaned, and if any member of the newly-
           orphaned process group is stopped, then a SIGHUP signal followed by a SIGCONT signal shall be sent to
           each process in the newly-orphaned process group.

        *  All open named semaphores in the calling process shall be  closed  as  if  by  appropriate  calls  to
           <u>sem_close</u>().

        *  Any  memory  locks established by the process via calls to <u>mlockall</u>() or <u>mlock</u>() shall be removed. If
           locked pages in the address space of the calling process are also mapped into the address  spaces  of
           other processes and are locked by those processes, the locks established by the other processes shall
           be unaffected by the call by this process to <b>_</b><u>Exit</u>() or <b>_</b><u>exit</u>().

        *  Memory mappings that were created in the process shall be unmapped before the process is destroyed.

        *  Any  blocks of typed memory that were mapped in the calling process shall be unmapped, as if <u>munmap</u>()
           was implicitly called to unmap them.

        *  All open message queue descriptors in the calling process shall be closed as if by appropriate  calls
           to <u>mq_close</u>().

        *  Any  outstanding  cancelable  asynchronous  I/O  operations  may  be canceled. Those asynchronous I/O
           operations that are not canceled shall complete as if the <b>_</b><u>Exit</u>() or <b>_</b><u>exit</u>() operation  had  not  yet
           occurred,  but  any  associated  signal  notifications  shall  be  suppressed. The <b>_</b><u>Exit</u>() or <b>_</b><u>exit</u>()
           operation may block awaiting such I/O completion. Whether any I/O is canceled, and which I/O  may  be
           canceled upon <b>_</b><u>Exit</u>() or <b>_</b><u>exit</u>(), is implementation-defined.

        *  Threads  terminated  by  a  call  to  <b>_</b><u>Exit</u>()  or <b>_</b><u>exit</u>() shall not invoke their cancellation cleanup
           handlers or per-thread data destructors.

        *  If the calling process is a trace controller process, any trace streams  that  were  created  by  the
           calling  process  shall be shut down as described by the <u>posix_trace_shutdown</u>() function, and mapping
           of trace event names to trace event type identifiers of any process built for these trace streams may
           be deallocated.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       These functions do not return.

</pre><h4><b>ERRORS</b></h4><pre>
       No errors are defined.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       None.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       Normally applications should use <u>exit</u>() rather than <b>_</b><u>Exit</u>() or <b>_</b><u>exit</u>().

</pre><h4><b>RATIONALE</b></h4><pre>
   <b>Process</b> <b>Termination</b>
       Early proposals drew a distinction between normal and abnormal process termination. Abnormal  termination
       was  caused  only  by  certain  signals  and resulted in implementation-defined ``actions'', as discussed
       below.  Subsequent proposals distinguished three types of termination:  <u>normal</u>  <u>termination</u>  (as  in  the
       current  specification),  <u>simple</u>  <u>abnormal</u> <u>termination</u>, and <u>abnormal</u> <u>termination</u> <u>with</u> <u>actions</u>.  Again the
       distinction between the two types of abnormal termination was that they were caused by different  signals
       and  that  implementation-defined  actions would result in the latter case. Given that these actions were
       completely implementation-defined, the early proposals were only saying when the actions could occur  and
       how  their  occurrence  could  be  detected,  but  not  what  they  were. This was of little or no use to
       conforming applications, and thus the distinction is not made in this volume of POSIX.1‐2017.

       The implementation-defined actions usually include, in most historical implementations, the creation of a
       file named <b>core</b> in the current working directory of the process. This  file  contains  an  image  of  the
       memory  of  the  process,  together with descriptive information about the process, perhaps sufficient to
       reconstruct the state of the process at the receipt of the signal.

       There is a potential security problem in creating a <b>core</b> file if the  process  was  set-user-ID  and  the
       current  user  is  not  the  owner of the program, if the process was set-group-ID and none of the user's
       groups match the group of the program, or if the user does not have permission to write  in  the  current
       directory.  In  this  situation, an implementation either should not create a <b>core</b> file or should make it
       unreadable by the user.

       Despite the silence of this volume of POSIX.1‐2017 on this  feature,  applications  are  advised  not  to
       create  files named <b>core</b> because of potential conflicts in many implementations. Some implementations use
       a name other than <b>core</b> for the file; for example, by appending the process ID to the filename.

   <b>Terminating</b> <b>a</b> <b>Process</b>
       It is important that the consequences of process termination as described occur regardless of whether the
       process called <b>_</b><u>exit</u>() (perhaps indirectly through <u>exit</u>()) or instead was terminated due to a  signal  or
       for  some  other reason.  Note that in the specific case of <u>exit</u>() this means that the <u>status</u> argument to
       <u>exit</u>() is treated in the same way as the <u>status</u> argument to <b>_</b><u>exit</u>().

       A language other than C may have other termination primitives than the C-language  <u>exit</u>()  function,  and
       programs  written  in such a language should use its native termination primitives, but those should have
       as part of their function the behavior of <b>_</b><u>exit</u>() as described. Implementations in languages other than C
       are outside the scope of this version of this volume of POSIX.1‐2017, however.

       As required by the ISO C standard, using <b>return</b> from <u>main</u>()  has  the  same  behavior  (other  than  with
       respect  to  language  scope  issues)  as calling <u>exit</u>() with the returned value. Reaching the end of the
       <u>main</u>() function has the same behavior as calling <u><a href="../man0/exit.0.html">exit</a></u>(0).

       A value of zero (or EXIT_SUCCESS, which is required to be zero) for the  argument  <u>status</u>  conventionally
       indicates successful termination. This corresponds to the specification for <u>exit</u>() in the ISO C standard.
       The  convention  is  followed by utilities such as <u>make</u> and various shells, which interpret a zero status
       from a child process as success. For this reason, applications should not call <u><a href="../man0/exit.0.html">exit</a></u>(0) or  <b>_</b><u><a href="../man0/exit.0.html">exit</a></u>(0)  when
       they terminate unsuccessfully; for example, in signal-catching functions.

       Historically,  the  implementation-defined  process  that inherits children whose parents have terminated
       without waiting on them is called <u>init</u> and has a process ID of 1.

       The sending of a SIGHUP to the foreground process group when a controlling process terminates corresponds
       to somewhat different historical implementations. In System V, the kernel sends a SIGHUP  on  termination
       of  (essentially) a controlling process. In 4.2 BSD, the kernel does not send SIGHUP in a case like this,
       but the termination of a controlling process is usually noticed by a system  daemon,  which  arranges  to
       send  a  SIGHUP  to the foreground process group with the <u>vhangup</u>() function. However, in 4.2 BSD, due to
       the behavior of the shells that support job control, the controlling process is usually a shell  with  no
       other  processes  in  its  process  group. Thus, a change to make <b>_</b><u>exit</u>() behave this way in such systems
       should not cause problems with existing applications.

       The termination of a process may cause a process group to become orphaned in either  of  two  ways.   The
       connection of a process group to its parent(s) outside of the group depends on both the parents and their
       children.  Thus, a process group may be orphaned by the termination of the last connecting parent process
       outside of the group or by the termination of the last direct descendant of the  parent  process(es).  In
       either  case, if the termination of a process causes a process group to become orphaned, processes within
       the group are disconnected from their job control shell, which no  longer  has  any  information  on  the
       existence  of  the  process group. Stopped processes within the group would languish forever. In order to
       avoid this problem, newly orphaned process groups that contain stopped processes are sent a SIGHUP signal
       and a SIGCONT signal to indicate that they have been disconnected from their session.  The SIGHUP  signal
       causes  the  process  group  members to terminate unless they are catching or ignoring SIGHUP. Under most
       circumstances, all of the members of the process group are stopped if any of them are stopped.

       The action of sending a SIGHUP and a SIGCONT signal to members of  a  newly  orphaned  process  group  is
       similar  to  the  action  of  4.2 BSD, which sends SIGHUP and SIGCONT to each stopped child of an exiting
       process.  If such children exit in response to the SIGHUP, any  additional  descendants  receive  similar
       treatment  at that time. In this volume of POSIX.1‐2017, the signals are sent to the entire process group
       at the same time. Also, in this volume of POSIX.1‐2017, but not in 4.2  BSD,  stopped  processes  may  be
       orphaned,  but  may  be  members  of a process group that is not orphaned; therefore, the action taken at
       <b>_</b><u>exit</u>() must consider processes other than child processes.

       It is possible for a process group to be orphaned by a call to <u>setpgid</u>()  or  <u>setsid</u>(),  as  well  as  by
       process  termination.  This  volume  of POSIX.1‐2017 does not require sending SIGHUP and SIGCONT in those
       cases, because, unlike process termination, those cases are not caused accidentally by applications  that
       are  unaware of job control. An implementation can choose to send SIGHUP and SIGCONT in those cases as an
       extension; such an extension must be documented as required in <u>&lt;signal.h&gt;</u>.

       The ISO/IEC 9899:1999 standard adds the <b>_</b><u>Exit</u>() function that results in  immediate  program  termination
       without  triggering  signals or <u>atexit</u>()-registered functions. In POSIX.1‐2008, this is equivalent to the
       <b>_</b><u>exit</u>() function.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>atexit</u>(), <u>exit</u>(), <u>mlock</u>(), <u>mlockall</u>(), <u>mq_close</u>(), <u>munmap</u>(), <u>posix_trace_create</u>(), <u>sem_close</u>(),  <u>semop</u>(),
       <u>setpgid</u>(), <u>setsid</u>(), <u>shmget</u>(), <u>wait</u>(), <u>waitid</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;stdlib.h&gt;</b>, <b>&lt;unistd.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                         <b>_</b><u><a href="../man3POSIX/EXIT.3POSIX.html">EXIT</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>