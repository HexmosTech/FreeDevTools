<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Validate::Email - common email validation methods</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-validate-email-perl">libdata-validate-email-perl_0.06-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Validate::Email - common email validation methods

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Data::Validate::Email qw(is_email is_email_rfc822);

         if(is_email($suspect)){
               print "Looks like an email address\n";
         } elsif(is_email_rfc822($suspect)){
               print "Doesn't much look like an email address, but passes rfc822\n";
         } else {
               print "Not an email address\n";
         }

         # or as an object
         my $v = Data::Validate::Email-&gt;new();

         die "not an email" unless ($v-&gt;is_email('foo'));

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module collects common email validation routines to make input validation, and untainting easier and
       more readable.

       All functions return an untainted value if the test passes, and undef if it fails.  This means that you
       should always check for a defined status explicitly.  Don't assume the return will be true. (e.g.
       is_username('0'))

       The value to test is always the first (and often only) argument.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       <b>new</b> - constructor for OO usage
             new([\%opts]);

           <u>Description</u>
               Returns  a  Data::Validator::Email object.  This lets you access all the validator function calls
               as   methods   without   importing   them   into   your   namespace   or   using    the    clumsy
               <u>Data::Validate::Email::function_name()</u> format.

           <u>Arguments</u>
               An  optional  hash  reference  is  retained  and  passed  on  to  other  function  calls  in  the
               Data::Validate module series.  This module does not utilize the extra data, but some child  calls
               do.  See Data::Validate::Domain for an example.

           <u>Returns</u>
               Returns a Data::Validate::Email object

       <b>is_email</b> - is the value a well-formed email address?
             is_email($value);

           <u>Description</u>
               Returns  the untainted address if the test value appears to be a well-formed email address.  This
               method tries to match real-world addresses, rather than trying to support everything that  rfc822
               allows.  (see is_email_rfc822 if you want the more permissive behavior.)

               In  short,  it  pretty much looks for <a href="mailto:something@something.tld">something@something.tld</a>.  It does not understand real names
               ("bob smith" &lt;<a href="mailto:bsmith@test.com">bsmith@test.com</a>&gt;), or other  comments.   It  will  not  accept  partially-qualified
               addresses ('bob', or 'bob@machine')

           <u>Arguments</u>
               $value
                   The potential address to test.

           <u>Returns</u>
               Returns the untainted address on success, undef on failure.

           <u>Notes,</u> <u>Exceptions,</u> <u>&amp;</u> <u>Bugs</u>
               This  function does not make any attempt to check whether an address is genuinely deliverable. It
               only looks to see that the format is email-like.

               The function accepts an optional hash reference as a second argument  to  change  the  validation
               behavior.   It  is  passed  on  unchanged  to  Neil  Neely's  <u>Data::Validate::Domain::is_domain()</u>
               function.  See that module's documentation for legal values.

       <b>is_email_rfc822</b> - does the value look like an RFC 822 address?
             is_email_rfc822($value);

           <u>Description</u>
               Returns the untainted address if the test  value  appears  to  be  a  well-formed  email  address
               according  to  RFC822.  Note  that  the  standard  allows  for a wide variety of address formats,
               including ones with real names and comments.

               In most cases you probably want to use <u>is_email()</u> instead.  This one will accept things that  you
               probably aren't expecting ('foo@bar', for example.)

           <u>Arguments</u>
               $value
                   The potential address to test.

           <u>Returns</u>
               Returns the untainted address on success, undef on failure.

           <u>Notes,</u> <u>Exceptions,</u> <u>&amp;</u> <u>Bugs</u>
               This check uses Email::Address::XS module to do its validation.

               The  function  does not make any attempt to check whether an address is genuinely deliverable. It
               only looks to see that the format is email-like.

       <b>is_domain</b> - does the value look like a domain name?
             is_domain($value);

           <u>Description</u>
               Returns the untainted domain if the test value appears to be a  well-formed  domain  name.   This
               test  uses  the  same  logic  as  <u>is_email()</u>,  rather  than  the somewhat more permissive pattern
               specified by RFC822.

           <u>Arguments</u>
               $value
                   The potential domain to test.

           <u>Returns</u>
               Returns the untainted domain on success, undef on failure.

           <u>Notes,</u> <u>Exceptions,</u> <u>&amp;</u> <u>Bugs</u>
               The function does not make any attempt to check whether a domain  is  actually  exists.  It  only
               looks to see that the format is appropriate.

               As    of    version    0.03,    this    is    a    direct    pass-through    to    Neil   Neely's
               <u>Data::Validate::Domain::is_domain()</u> function.

               The function accepts an optional hash reference as a second argument  to  change  the  validation
               behavior.   It  is  passed  on  unchanged  to  Neil  Neely's  <u>Data::Validate::Domain::is_domain()</u>
               function.  See that module's documentation for legal values.

       <b>is_username</b> - does the value look like a username?
             is_username($value);

           <u>Description</u>
               Returns the untainted username if the test value appears to  be  a  well-formed  username.   More
               specifically, it tests to see if the value is legal as the username component of an email address
               as defined by <u>is_email()</u>.  Note that this definition is more restrictive than the one in RFC822.

           <u>Arguments</u>
               $value
                   The potential username to test.

           <u>Returns</u>
               Returns the untainted username on success, undef on failure.

           <u>Notes,</u> <u>Exceptions,</u> <u>&amp;</u> <u>Bugs</u>
               The  function  does  not  make  any  attempt  to check whether a username actually exists on your
               system. It only looks to see that the format is appropriate.

</pre><h4><b>AUTHOR</b></h4><pre>
       Richard Sonnen &lt;<u><a href="mailto:sonnen@richardsonnen.com">sonnen@richardsonnen.com</a></u>&gt;.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2004 Richard Sonnen. All rights reserved.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.26.2                                       2018-07-22                                         <u><a href="../man3pm/Email.3pm.html">Email</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>