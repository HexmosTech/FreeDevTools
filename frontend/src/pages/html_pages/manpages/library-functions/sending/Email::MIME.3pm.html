<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email::MIME - easy MIME message handling</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libemail-mime-perl">libemail-mime-perl_1.954-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Email::MIME - easy MIME message handling

</pre><h4><b>VERSION</b></h4><pre>
       version 1.954

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>Wait!</b>  Before you read this, maybe you just need Email::Stuffer, which is a much easier-to-use tool for
       building simple email messages that might have attachments or both plain text and HTML.  If that doesn't
       do it for you, then by all means keep reading.

         use Email::MIME;
         my $parsed = Email::MIME-&gt;new($message);

         my @parts = $parsed-&gt;parts; # These will be Email::MIME objects, too.
         my $decoded = $parsed-&gt;body;
         my $non_decoded = $parsed-&gt;body_raw;

         my $content_type = $parsed-&gt;content_type;

       ...or...

         use Email::MIME;
         use IO::All;

         # multipart message
         my @parts = (
             Email::MIME-&gt;create(
                 attributes =&gt; {
                     filename     =&gt; "report.pdf",
                     content_type =&gt; "application/pdf",
                     encoding     =&gt; "quoted-printable",
                     name         =&gt; "2004-financials.pdf",
                 },
                 body =&gt; io( "2004-financials.pdf" )-&gt;binary-&gt;all,
             ),
             Email::MIME-&gt;create(
                 attributes =&gt; {
                     content_type =&gt; "text/plain",
                     disposition  =&gt; "attachment",
                     charset      =&gt; "US-ASCII",
                 },
                 body_str =&gt; "Hello there!",
             ),
         );

         my $email = Email::MIME-&gt;create(
             header_str =&gt; [
                 From =&gt; '<a href="mailto:casey@geeknest.com">casey@geeknest.com</a>',
                 To =&gt; [ '<a href="mailto:user1@host.com">user1@host.com</a>', 'Name &lt;<a href="mailto:user2@host.com">user2@host.com</a>&gt;' ],
                 Cc =&gt; Email::Address::XS-&gt;new("Display Name \N{U+1F600}", '<a href="mailto:user@example.com">user@example.com</a>'),
             ],
             parts      =&gt; [ @parts ],
         );

         # nesting parts
         $email-&gt;parts_set(
             [
               $email-&gt;parts,
               Email::MIME-&gt;create( parts =&gt; [ @parts ] ),
             ],
         );

         # standard modifications
         $email-&gt;header_str_set( 'X-PoweredBy' =&gt; 'RT v3.0'      );
         $email-&gt;header_str_set( To            =&gt; rcpts()        );
         $email-&gt;header_str_set( Cc            =&gt; aux_rcpts()    );
         $email-&gt;header_str_set( Bcc           =&gt; sekrit_rcpts() );

         # more advanced
         $_-&gt;encoding_set( 'base64' ) for $email-&gt;parts;

         # Quick multipart creation
         my $email = Email::MIME-&gt;create(
             header_str =&gt; [
                 From =&gt; 'my@address',
                 To   =&gt; 'your@address',
             ],
             parts =&gt; [
                 q[This is part one],
                 q[This is part two],
                 q[These could be binary too],
             ],
         );

         print $email-&gt;as_string;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is an extension of the Email::Simple module, to handle MIME encoded messages. It takes a message as
       a string, splits it up into its constituent parts, and allows you access to various parts of the message.
       Headers are decoded from MIME encoding.

</pre><h4><b>PERL</b> <b>VERSION</b></h4><pre>
       This library should run on perls released even a long time ago.  It should work on any version of perl
       released in the last five years.

       Although it may work on older versions of perl, no guarantee is made that the minimum required version
       will not be increased.  The version may be increased for any reason, and there is no promise that patches
       will be accepted to lower the minimum required perl.

</pre><h4><b>METHODS</b></h4><pre>
       Please see Email::Simple for the base set of methods. It won't take very long. Added to that, you have:

   <b>create</b>
         my $single = Email::MIME-&gt;create(
           header_str =&gt; [ ... ],
           body_str   =&gt; '...',
           attributes =&gt; { ... },
         );

         my $multi = Email::MIME-&gt;create(
           header_str =&gt; [ ... ],
           parts      =&gt; [ ... ],
           attributes =&gt; { ... },
         );

       This method creates a new MIME part. The "header_str" parameter is a list of headers pairs to include in
       the message. The value for each pair is expected to be a text string that will be MIME-encoded as needed.
       Alternatively it can be an object with "as_mime_string" method which implements conversion of that object
       to MIME-encoded string.  That object method is called with two named input parameters: "charset" and
       "header_name_length".  It should return MIME-encoded representation of the object.  As of 2017-07-25, the
       header-value-as-object code is very young, and may yet change.

       In case header name is registered in %Email::MIME::Header::header_to_class_map hash then registered class
       is used for conversion from Unicode string to 8bit MIME encoding.  Value can be either string or array
       reference to strings.  Object is constructed via method "from_string" with string value (or values in
       case of array reference) and converted to MIME-encoded string via "as_mime_string" method.

       A similar "header" parameter can be provided in addition to or instead of "header_str".  Its values will
       be used verbatim.

       "attributes" is a hash of MIME attributes to assign to the part, and may override portions of the header
       set in the "header" parameter. The hash keys correspond directly to methods for modifying a message. The
       allowed keys are: content_type, charset, name, format, boundary, encoding, disposition, and filename.
       They will be mapped to "$attr\_set" for message modification.

       The "parts" parameter is a list reference containing "Email::MIME" objects. Elements of the "parts" list
       can also be a non-reference string of data. In that case, an "Email::MIME" object will be created for
       you. Simple checks will determine if the part is binary or not, and all parts created in this fashion are
       encoded with "base64", just in case.

       If "body" is given instead of "parts", it specifies the body to be used for a flat (subpart-less) MIME
       message.  It is assumed to be a sequence of octets.

       If "body_str" is given instead of "body" or "parts", it is assumed to be a character string to be used as
       the body.  If you provide a "body_str" parameter, you <b>must</b> provide "charset" and "encoding" attributes.

   <b>content_type_set</b>
         $email-&gt;content_type_set( 'text/html' );

       Change the content type. All "Content-Type" header attributes will remain intact.

   <b>charset_set</b>
   <b>name_set</b>
   <b>format_set</b>
   <b>boundary_set</b>
         $email-&gt;charset_set( 'UTF-8' );
         $email-&gt;name_set( 'some_filename.txt' );
         $email-&gt;format_set( 'flowed' );
         $email-&gt;boundary_set( undef ); # remove the boundary

       These four methods modify common "Content-Type" attributes. If set to "undef", the attribute is removed.
       All other "Content-Type" header information is preserved when modifying an attribute.

   <b>encode_check</b>
   <b>encode_check_set</b>
         $email-&gt;encode_check;
         $email-&gt;<a href="../man0/encode_check_set.0.html">encode_check_set</a>(0);
         $email-&gt;encode_check_set(Encode::FB_DEFAULT);

       Gets/sets the current "encode_check" setting (default: <u>FB_CROAK</u>).  This is the parameter passed to
       "decode" in Encode and "encode" in Encode when body_str(), body_str_set(), and create() are called.

       With the default setting, Email::MIME may crash if the claimed charset of a body does not match its
       contents (for example - utf8 data in a text/plain; charset=us-ascii message).

       With an "encode_check" of 0, the unrecognized bytes will instead be replaced with the "REPLACEMENT
       CHARACTER" (U+0FFFD), and may end up as either that or question marks (?).

       See "Handling Malformed Data" in Encode for more information.

   <b>encoding_set</b>
         $email-&gt;encoding_set( 'base64' );
         $email-&gt;encoding_set( 'quoted-printable' );
         $email-&gt;encoding_set( '8bit' );

       Convert the message body and alter the "Content-Transfer-Encoding" header using this method. Your message
       body, the output of the body() method, will remain the same. The raw body, output with the body_raw()
       method, will be changed to reflect the new encoding.

   <b>body_set</b>
         $email-&gt;body_set( $unencoded_body_string );

       This method will encode the new body you send using the encoding specified in the
       "Content-Transfer-Encoding" header, then set the body to the new encoded body.

   <b>body_str_set</b>
         $email-&gt;body_str_set($unicode_str);

       This method behaves like "body_set", but assumes that the given value is a Unicode string that should be
       encoded into the message's charset before being set.

       The charset must already be set, either manually (via the "attributes" argument to "create" or
       "charset_set") or through the "Content-Type" of a parsed message.  If the charset can't be determined, an
       exception is thrown.

   <b>disposition_set</b>
         $email-&gt;disposition_set( 'attachment' );

       Alter the "Content-Disposition" of a message. All header attributes will remain intact.

   <b>filename_set</b>
         $email-&gt;filename_set( 'boo.pdf' );

       Sets the filename attribute in the "Content-Disposition" header. All other header information is
       preserved when setting this attribute.

   <b>parts_set</b>
         $email-&gt;parts_set( \@new_parts );

       Replaces the parts for an object. Accepts a reference to a list of "Email::MIME" objects, representing
       the new parts. If this message was originally a single part, the "Content-Type" header will be changed to
       "multipart/mixed", and given a new boundary attribute.

   <b>parts_add</b>
         $email-&gt;parts_add( \@more_parts );

       Adds MIME parts onto the current MIME part. This is a simple extension of "parts_set" to make our lives
       easier. It accepts an array reference of additional parts.

   <b>walk_parts</b>
         $email-&gt;walk_parts(sub {
             my ($part) = @_;
             return if $part-&gt;subparts; # multipart

             if ( $part-&gt;content_type =~ m[text/html]i ) {
                 my $body = $part-&gt;body;
                 $body =~ s/&lt;link [^&gt;]+&gt;//; # simple filter example
                 $part-&gt;body_set( $body );
             }
         });

       Walks through all the MIME parts in a message and applies a callback to each. Accepts a code reference as
       its only argument. The code reference will be passed a single argument, the current MIME part within the
       top-level MIME object. All changes will be applied in place.

   <b>header</b>
       <b>Achtung!</b>  Beware this method!  In Email::MIME, it means the same as "header_str", but on an Email::Simple
       object, it means "header_raw".  Unless you always know what kind of object you have, you could get one of
       two significantly different behaviors.

       Try to use either "header_str" or "header_raw" as appropriate.

   <b>header_str_set</b>
         $email-&gt;header_str_set($header_name =&gt; @value_strings);

       This behaves like "header_raw_set", but expects Unicode (character) strings as the values to set, rather
       than pre-encoded byte strings.  It will encode them as MIME encoded-words if they contain any control or
       8-bit characters.

       Alternatively, values can be objects with "as_mime_string" method.  Same as in method "create".

   <b>header_str_pairs</b>
         my @pairs = $email-&gt;header_str_pairs;

       This method behaves like "header_raw_pairs", returning a list of field name/value pairs, but the values
       have been decoded to character strings, when possible.

   <b>header_as_obj</b>
         my $first_obj = $email-&gt;header_as_obj($field);
         my $nth_obj   = $email-&gt;header_as_obj($field, $index);
         my @all_objs  = $email-&gt;header_as_obj($field);

         my $nth_obj_of_class  = $email-&gt;header_as_obj($field, $index, $class);
         my @all_objs_of_class = $email-&gt;header_as_obj($field, undef, $class);

       This method returns an object representation of the header value.  It instances new object via method
       "from_mime_string" of specified class.  Input argument for that class method is list of the raw MIME-
       encoded values.  If class argument is not specified then class name is taken from the hash
       %Email::MIME::Header::header_to_class_map via key field.  Use class method
       "Email::MIME::Header-&gt;set_class_for_header($class, $field)" for adding new mapping.

   <b>parts</b>
       This returns a list of "Email::MIME" objects reflecting the parts of the message. If it's a single-part
       message, you get the original object back.

       In scalar context, this method returns the number of parts.

       This is a stupid method.  Don't use it.

   <b>subparts</b>
       This returns a list of "Email::MIME" objects reflecting the parts of the message.  If it's a single-part
       message, this method returns an empty list.

       In scalar context, this method returns the number of subparts.

   <b>body</b>
       This decodes and returns the body of the object <u>as</u> <u>a</u> <u>byte</u> <u>string</u>. For top-level objects in multi-part
       messages, this is highly likely to be something like "This is a multi-part message in MIME format."

   <b>body_str</b>
       This decodes both the Content-Transfer-Encoding layer of the body (like the "body" method) as well as the
       charset encoding of the body (unlike the "body" method), returning a Unicode string.

       If the charset is known, it is used.  If there is no charset but the content type is either "text/plain"
       or "text/html", us-ascii is assumed.  Otherwise, an exception is thrown.

   <b>body_raw</b>
       This returns the body of the object, but doesn't decode the transfer encoding.

   <b>decode_hook</b>
       This method is called before the Email::MIME::Encodings "decode" method, to decode the body of non-binary
       messages (or binary messages, if the "force_decode_hook" method returns true).  By default, this method
       does nothing, but subclasses may define behavior.

       This method could be used to implement the decryption of content in secure email, for example.

   <b>content_type</b>
       This is a shortcut for access to the content type header.

   <b>filename</b>
       This provides the suggested filename for the attachment part. Normally it will return the filename from
       the headers, but if "filename" is passed a true parameter, it will generate an appropriate "stable"
       filename if one is not found in the MIME headers.

   <b>invent_filename</b>
         my $filename = Email::MIME-&gt;invent_filename($content_type);

       This routine is used by "filename" to generate filenames for attached files.  It will attempt to choose a
       reasonable extension, falling back to <u>dat</u>.

   <b>debug_structure</b>
         my $description = $email-&gt;debug_structure;

       This method returns a string that describes the structure of the MIME entity.  For example:

         + multipart/alternative; boundary="=_NextPart_2"; charset="BIG-5"
           + text/plain
           + text/html

</pre><h4><b>CONFIGURATION</b></h4><pre>
       The variable $Email::MIME::MAX_DEPTH is the maximum depth of parts that will be processed.  It defaults
       to 10, already higher than legitimate mail is ever likely to be.  This value may go up over time as the
       parser is improved.

       The variable $Email::MIME::MAX_PARTS is the maximum number of parts that will be processed.  It defaults
       to 100, already higher than legitimate mail is ever likely to be.  This value may go up over time as the
       parser is improved or as research suggests that our starting position was wrong.

       Increasing either of these variables risks significant consumption of memory.  Test before changing
       things.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Email::Simple

</pre><h4><b>THANKS</b></h4><pre>
       This module was generously sponsored by Best Practical (<a href="http://www.bestpractical.com/">http://www.bestpractical.com/</a>), Pete Sergeant,
       and Pobox.com.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Ricardo SIGNES &lt;<a href="mailto:cpan@semiotic.systems">cpan@semiotic.systems</a>&gt;

       •   Casey West &lt;<a href="mailto:casey@geeknest.com">casey@geeknest.com</a>&gt;

       •   Simon Cozens &lt;<a href="mailto:simon@cpan.org">simon@cpan.org</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Alex Vandiver &lt;<a href="mailto:alexmv@mit.edu">alexmv@mit.edu</a>&gt;

       •   Anirvan Chatterjee &lt;<a href="mailto:anirvan@users.noreply.github.com">anirvan@users.noreply.github.com</a>&gt;

       •   Arthur Axel 'fREW' Schmidt &lt;<a href="mailto:frioux@gmail.com">frioux@gmail.com</a>&gt;

       •   Brian Cassidy &lt;<a href="mailto:bricas@cpan.org">bricas@cpan.org</a>&gt;

       •   Damian Lukowski &lt;<a href="mailto:damian.lukowski@credativ.de">damian.lukowski@credativ.de</a>&gt;

       •   Dan Book &lt;<a href="mailto:grinnz@gmail.com">grinnz@gmail.com</a>&gt;

       •   David Steinbrunner &lt;<a href="mailto:dsteinbrunner@pobox.com">dsteinbrunner@pobox.com</a>&gt;

       •   Dotan Dimet &lt;<a href="mailto:dotan@corky.net">dotan@corky.net</a>&gt;

       •   dxdc &lt;<a href="mailto:dan@element26.net">dan@element26.net</a>&gt;

       •   Eric Wong &lt;<a href="mailto:e@80x24.org">e@80x24.org</a>&gt;

       •   Geraint Edwards &lt;<a href="mailto:gedge-oss@yadn.org">gedge-oss@yadn.org</a>&gt;

       •   ivulfson &lt;9122139+<a href="mailto:ivulfson@users.noreply.github.com">ivulfson@users.noreply.github.com</a>&gt;

       •   Jesse Luehrs &lt;<a href="mailto:doy@tozt.net">doy@tozt.net</a>&gt;

       •   Kurt Anderson &lt;<a href="mailto:kboth@drkurt.com">kboth@drkurt.com</a>&gt;

       •   Lance A. Brown &lt;<a href="mailto:lance@bearcircle.net">lance@bearcircle.net</a>&gt;

       •   Matthew Horsfall &lt;<a href="mailto:wolfsage@gmail.com">wolfsage@gmail.com</a>&gt;

       •   memememomo &lt;<a href="mailto:memememomo@gmail.com">memememomo@gmail.com</a>&gt;

       •   Michael McClimon &lt;<a href="mailto:michael@mcclimon.org">michael@mcclimon.org</a>&gt;

       •   Mishrakk &lt;48946018+<a href="mailto:Mishrakk@users.noreply.github.com">Mishrakk@users.noreply.github.com</a>&gt;

       •   Pali &lt;<a href="mailto:pali@cpan.org">pali@cpan.org</a>&gt;

       •   Ricardo Signes &lt;<a href="mailto:rjbs@semiotic.systems">rjbs@semiotic.systems</a>&gt;

       •   Ricardo Signes &lt;<a href="mailto:rjbs@users.noreply.github.com">rjbs@users.noreply.github.com</a>&gt;

       •   Shawn Sorichetti &lt;<a href="mailto:ssoriche@coloredblocks.com">ssoriche@coloredblocks.com</a>&gt;

       •   Tomohiro Hosaka &lt;<a href="mailto:bokutin@bokut.in">bokutin@bokut.in</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2004 by Simon Cozens and Casey West.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.38.2                                       2024-05-03                                   <u>Email::<a href="../man3pm/MIME.3pm.html">MIME</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>