<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mail::Sender - module for sending mails with attachments through an SMTP server</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libmail-sender-perl">libmail-sender-perl_0.8.16-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mail::Sender - module for sending mails with attachments through an SMTP server

       Version 0.8.16

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Mail::Sender;
        $sender = new Mail::Sender
         {smtp =&gt; 'mail.yourdomain.com', from =&gt; '<a href="mailto:your@address.com">your@address.com</a>'};
        $sender-&gt;MailFile({to =&gt; '<a href="mailto:some@address.com">some@address.com</a>',
         subject =&gt; 'Here is the file',
         msg =&gt; "I'm sending you the list you wanted.",
         file =&gt; 'filename.txt'});

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Mail::Sender" provides an object oriented interface to sending mails.  It doesn't need any outer
       program. It connects to a mail server directly from Perl, using Socket.

       Sends mails directly from Perl through a socket connection.

</pre><h4><b>new</b> <b>Mail::Sender</b></h4><pre>
        new Mail::Sender ([from [,replyto [,to [,smtp [,subject [,headers [,boundary]]]]]]])
        new Mail::Sender {[from =&gt; '<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>'] , [to =&gt; '<a href="mailto:else@nowhere.com">else@nowhere.com</a>'] [...]}

       Prepares a sender. This doesn't start any connection to the server. You have to use "$Sender-"Open&gt; or
       "$Sender-"OpenMultipart&gt; to start talking to the server.

       The parameters are used in subsequent calls to "$Sender-"Open&gt; and "$Sender-"OpenMultipart&gt;. Each such
       call changes the saved variables.  You can set "smtp", "from" and other options here and then use the
       info in all messages.

   <b>Parameters</b>
       from
           ""=&gt; the sender's e-mail address

       fake_from
           ""=&gt; the address that will be shown in headers.

           If not specified we use the value of "from".

       replyto
           ""=&gt; the reply-to address

       to  ""=&gt; the recipient's address(es)

           This  parameter  may  be either a comma separated list of email addresses or a reference to a list of
           addresses.

       fake_to
           ""=&gt; the recipient's address that will be shown in headers.  If not specified we  use  the  value  of
           "to".

           If  the  list  of  addresses  you  want  to  send  your  message to is long or if you do not want the
           recipients to see each other's address set the "fake_to" parameter to some  informative,  yet  bogus,
           address or to the address of your mailing/distribution list.

       cc  ""=&gt; address(es) to send a copy (CC:) to

       fake_cc
           ""=&gt; the address that will be shown in headers.

           If not specified we use the value of "cc".

       bcc ""=&gt;  address(es) to send a copy (BCC: or blind carbon copy).  these addresses will not be visible in
           the mail!

       smtp
           ""=&gt; the IP or domain address of your SMTP (mail) server

           This is the name of your LOCAL mail server, do NOT try to contact directly the adressee's mailserver!
           That would be slow and buggy, your script should only pass the messages to the  nearest  mail  server
           and leave the rest to it. Keep in mind that the recipient's server may be down temporarily.

       port
           ""=&gt;  the  TCP/IP  port  used  form the connection. By default getservbyname('smtp', 'tcp')||25.  You
           should only need to use this option if your mail server waits on a nonstandard port.

       subject
           ""=&gt; the subject of the message

       headers
           ""=&gt; the additional headers

           You may use this parameter to add custon headers into the message. The  parameter  may  be  either  a
           string containing the headers in the right format or a hash containing the headers and their values.

       boundary
           ""=&gt; the message boundary

           You  usualy do not have to change this, it might only come in handy if you need to attach a multipart
           mail created by Mail::Sender to your message as a single part.  Even in that case  any  problems  are
           unlikely.

       multipart
           ""=&gt; the MIME subtype for the whole message (Mixed/Related/Alternative)

           You  may  need  to change this setting if you want to send a HTML body with some inline images, or if
           you want to post the message in plain text as well as HTML (alternative). See the examples at the end
           of the docs.  You may also use the nickname "subtype".

           Please keep in mind though that it's not currently possible to create nested parts with Mail::Sender.
           If you need that level of control you should try MIME::Lite.

       ctype
           ""=&gt; the content type of a single part message

           Please do not confuse these two. The 'multipart' parameter is used to  specify  the  overall  content
           type  of  a  multipart  message  (for  example a HTML document with inlined images) while ctype is an
           ordinary content type for a single part message. For example a HTML mail message without any inlines.

       encoding
           ""=&gt; encoding of a single part message or the body of a multipart message.

           If the text of the message contains some extended characters  or  very  long  lines  you  should  use
           'encoding =&gt; "Quoted-printable"' in the call to <u>Open()</u>, <u>OpenMultipart()</u>, <u>MailMsg()</u> or <u>MailFile()</u>.

           Keep  in  mind  that  if  you  use  some  encoding you should either use <u>SendEnc()</u> or encode the data
           yourself !

       charset
           ""=&gt; the charset of the message

       client
           ""=&gt; the name of the client computer.

           During the connection you send the mailserver your computer's name.  By  default  Mail::Sender  sends
           "(gethostbyname  'localhost')[0]".   If that is not the address you need, you can specify a different
           one.

       priority
           ""=&gt; the message priority number

           1 = highest, 2 = high, 3 = normal, 4 = low, 5 = lowest

       confirm
           ""=&gt; whether you request reading or delivery confirmations and to what addresses:

                   "delivery" - only delivery, to the C&lt;from&gt; address
                   "reading" - only reading, to the C&lt;from&gt; address
                   "delivery, reading" - both confirmations, to the C&lt;from&gt; address
                   "delivery: <a href="mailto:my.other@address.com">my.other@address.com</a>" - only delivery, to <a href="mailto:my.other@address.com">my.other@address.com</a>
                   ...

           Keep in mind though that neither of those is guaranteed to work. Some  servers/mail  clients  do  not
           support  this feature and some users/admins may have disabled it. So it's possible that your mail was
           delivered and read, but you wount get any confirmation!

       ESMPT
                   ESMTP =&gt; {
                           NOTIFY =&gt; 'SUCCESS,FAILURE,DELAY',
                           RET =&gt; 'HDRS',
                           ORCPT =&gt; 'rfc822;<a href="mailto:my.other@address.com">my.other@address.com</a>',
                           ENVID =&gt; 'iuhsdfobwoe8t237',
                   }

           This option contains data for SMTP extensions, for example it allows you to request  delivery  status
           notifications according to RFC1891.

           NOTIFY  -  to  specify the conditions under which a delivery status notification should be generated.
           Should be either "NEVER" or a comma separated list of "SUCCESS", "FAILURE"  and "DELAY".

           ORCPT - used to convey the "original" (sender-specified) recipient address

           RET - to request that Delivery Status Notifications containing  an  indication  of  delivery  failure
           either  return  the  entire contents of a message or only the message headers. Must be either FULL or
           HDRS

           ENVID - used to propagate an identifier for this message transmission envelope, which is  also  known
           to the sender and will, if present, be returned in any Delivery Status Notifications  issued for this
           transmission

           You do not need to worry about encoding the ORCPT or ENVID parameters.

           If the SMTP server you connect to doesn't support this extension, the options will be ignored.

       debug
           ""=&gt; "/path/to/debug/file.txt"

           or

           ""=&gt;  \*FILEHANDLE

           or

           ""=&gt; $FH

           All  the  conversation  with the server will be logged to that file or handle.  All lines in the file
           should end with CRLF (the Windows and Internet format).  If even a  single  one  of  them  does  not,
           please let me know!

           If  you  pass  the path to the log file, Mail::Sender will overwrite it. If you want to append to the
           file, you have to open it yourself and pass the filehandle:

                   open my $DEBUG, "&gt;&gt; /path/to/debug/file.txt"
                           or die "Can't open the debug file: $!\n"
                   $sender = new Mail::Sender ({
                           ...
                           debug =&gt; $DEBUG,
                   });

       debug_level
           Only taken into account if the "debug" option is specified.

                   1 - only log the conversation with the server, skip all message data
                   2 - log the conversation and message headers
                   3 - log the conversation and the message and part headers
                   4 - log everything (default)

       auth
           the SMTP authentication protocol to use to login to the server currently the only ones supported  are
           LOGIN, PLAIN, CRAM-MD5 and NTLM.

           Some   protocols  have  module  dependencies.  CRAM-MD5  depends  on  Digest::HMAC_MD5  and  NTLM  on
           Authen::NTLM.

           You may add support for other authentication protocols yourself. See below.

       authid
           the username used to login to the server

       authpwd
           the password used to login to the server

       authdomain
           the domain name. Used optionaly by the NTLM authentication.

           Other authentication protocols may use other options as well.  They  should  all  start  with  "auth"
           though.

           Please see the authentication section bellow.

       auth_encoded
           If  set  to  a  true  value the LOGIN authentication assumes the authid and authpwd is already base64
           encoded.

       keepconnection
           If set to a true value causes the Mail::Sender to keep the connection open for several messages.  The
           connection will be closed if you call the <u>Close()</u> method with a true  value  or  if  you  call  Open,
           OpenMultipart, MailMsg or MailFile with the "smtp" parameter.  This means that if you want the object
           to  keep  the connection you should pass the "smtp" either to "new Mail::Sender" or only to the first
           Open, OpenMultipart, MailMsg or MailFile!

       skip_bad_recipients
           If this option is set to false or not specified then Mail::Sender stops trying to send a  message  as
           soon  as the first recipient's address fails. If it is set to a true value Mail::Sender skips the bad
           addresses and tries to send the message at least to the good ones. If all addresses are  rejected  by
           the server it reports an "All recipients were rejected" message.

           If  any  addresses  were  skipped the "$sender-&gt;{'skipped_recipients'}" will be a reference to a hash
           containing the failed address and the server's response.

       createmessageid
           This option allows you to overwrite the function that generates the message IDs for the emails.   The
           function  gets the "pure" sender's address as it's only parameter and is supposed to return a string.
           See the MessageID subroutine in Mail::Sender.pm.

           If you want to specify a message id you  can  also  use  the  "messageid"  parameter  for  the  Open,
           OpenMultipart, MailMsg or MailFile methods.

       on_errors
           This option allows you to affect the way Mail::Sender reports errors.

                   =&gt; 'die' - raise an exception
                   =&gt; 'code' - return the negative error code (default)
                   =&gt; 'undef' - return an undef

           $Mail::Sender::Error, $sender-&gt;{'error'} and $sender-&gt;{'error_msg'} are set in all the cases.

           All methods return the $sender object if they succeed.

           P.S.:  The  die_on_errors option is deprecated. You may still use it, but it may be removed in future
           versions!

   <b>Return</b> <b>codes</b>
         ref to a Mail::Sender object =  success

         -1 = $smtphost unknown
         -2 = socket() failed
         -3 = connect() failed
         -4 = service not available
         -5 = unspecified communication error
         -6 = local user $to unknown on host $smtp
         -7 = transmission of message failed
         -8 = argument $to empty
         -9 = no message specified in call to MailMsg or MailFile
         -10 = no file name specified in call to SendFile or MailFile
         -11 = file not found
         -12 = not available in singlepart mode
         -13 = site specific error
         -14 = connection not established. Did you mean MailFile instead of SendFile?
         -15 = no SMTP server specified
         -16 = no From: address specified
         -17 = authentication protocol not accepted by the server
         -18 = login not accepted
         -19 = authentication protocol is not implemented

       $Mail::Sender::Error contains a textual description of last error.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Open</b>
        Open([from [, replyto [, to [, smtp [, subject [, headers]]]]]])
        Open({[from =&gt; "<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>"] , [to =&gt; "<a href="mailto:else@nowhere.com">else@nowhere.com</a>"] [...]})

       Opens a new message. If some parameters are unspecified or empty, it uses the parameters  passed  to  the
       ""$Sender=new Mail::Sender(...)"";

       See "new Mail::Sender" for info about the parameters.

       The  only additional parameter that may not be specified directly in the "new Mail::Sender" is messageid.
       If you set this option then the message will be sent with this Message-ID, otherwise  a  new  Message  ID
       will  be generated out of the sender's address, current date+time and a random number (or by the function
       you specified in the "createmessageid" option).

       After the message is sent "$sender-&lt;{messageid}" will contain the Message-ID with which the  message  was
       sent.

       Returns ref to the Mail::Sender object if successfull.

   <b>OpenMultipart</b>
        OpenMultipart([from [, replyto [, to [, smtp [, subject [, headers [, boundary]]]]]]])
        OpenMultipart({[from =&gt; "<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>"] , [to =&gt; "<a href="mailto:else@nowhere.com">else@nowhere.com</a>"] [...]})

       Opens  a multipart message. If some parameters are unspecified or empty, it uses the parameters passed to
       the "$Sender=new Mail::Sender(...)".

       See "new Mail::Sender" for info about the parameters.

       Returns ref to the Mail::Sender object if successfull.

   <b>MailMsg</b>
        MailMsg([from [, replyto [, to [, smtp [, subject [, headers]]]]]], message)
        MailMsg({[from =&gt; "<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>"]
                 [, to =&gt; "<a href="mailto:else@nowhere.com">else@nowhere.com</a>"] [...], msg =&gt; "Message"})

       Sends a message. If a mail in $sender is opened it gets closed and  a  new  mail  is  created  and  sent.
       $sender  is  then  closed.  If some parameters are unspecified or empty, it uses the parameters passed to
       the ""$Sender=new Mail::Sender(...)"";

       See "new Mail::Sender" for info about the parameters.

       The module was made so that you could create an object initialized with all the necesary options and then
       send several messages without need to specify the SMTP server and others each time. If you need  to  send
       only  one  mail  using <u>MailMsg()</u> or <u>MailFile()</u> you do not have to create a named object and then call the
       method. You may do it like this :

        (new Mail::Sender)-&gt;MailMsg({smtp =&gt; 'mail.company.com', ...});

       Returns ref to the Mail::Sender object if successfull.

   <b>MailFile</b>
        MailFile([from [, replyto [, to [, smtp [, subject [, headers]]]]]], message, file(s))
        MailFile({[from =&gt; "<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>"]
                  [, to =&gt; "<a href="mailto:else@nowhere.com">else@nowhere.com</a>"] [...],
                  msg =&gt; "Message", file =&gt; "File"})

       Sends one or more files by mail. If a mail in $sender is opened it gets closed and a new mail is  created
       and  sent.  $sender  is then closed.  If some parameters are unspecified or empty, it uses the parameters
       passed to the ""$Sender=new Mail::Sender(...)"";

       The "file" parameter may be a "filename", a "list, of, file, names" or a \@list_of_file_names.

       see "new Mail::Sender" for info about the parameters.

       Just keep in mind that parameters like ctype, charset and encoding will be used for  the  attached  file,
       not  the  body  of  the  message.   If  you want to specify those parameters for the body you have to use
       b_ctype, b_charset and b_encoding. Sorry.

       Returns ref to the Mail::Sender object if successfull.

   <b>Send</b>
        Send(@strings)

       Prints the strings to the socket. Doesn't add any end-of-line characters.  Doesn't encode the  data!  You
       should use "\r\n" as the end-of-line!

       UNLESS YOU ARE ABSOLUTELY SURE YOU KNOW WHAT YOU ARE DOING YOU SHOULD USE <u>SendEnc()</u> INSTEAD!

       Returns the object if successfull.

   <b>SendLine</b>
        SendLine(@strings)

       Prints  the  strings  to the socket. Adds the end-of-line character at the end.  Doesn't encode the data!
       You should use "\r\n" as the end-of-line!

       UNLESS YOU ARE ABSOLUTELY SURE YOU KNOW WHAT YOU ARE DOING YOU SHOULD USE <u>SendLineEnc()</u> INSTEAD!

       Returns the object if successfull.

   <b>print</b>
       Alias to <u>SendEnc()</u>.

       Keep in mind that you can't write :

               print $sender "...";

       you have to use

               $sender-&gt;print("...");

       If you want to be able to print into the message as if it was  a  normal  file  handle  take  a  look  at
       "GetHandle"()

   <b>SendEnc</b>
        SendEnc(@strings)

       Prints the strings to the socket. Doesn't add any end-of-line characters.

       Encodes the text using the selected encoding (none/Base64/Quoted-printable)

       Returns the object if successfull.

   <b>SendLineEnc</b>
        SendLineEnc(@strings)

       Prints  the  strings to the socket and adds the end-of-line character at the end.  Encodes the text using
       the selected encoding (none/Base64/Quoted-printable).

       Do NOT mix up /Send(Line)?(Ex)?/ and /Send(Line)?Enc/! SendEnc does some buffering necessary for  correct
       Base64 encoding, and /Send(Ex)?/ is not aware of that!

       Usage  of /Send(Line)?(Ex)?/ in non xBIT parts not recommended.  Using "Send(encode_base64($string))" may
       work, but more likely it will not!  In particular if you use several such to create one part, the data is
       very likely to get crippled.

       Returns the object if successfull.

   <b>SendEx</b>
        SendEx(@strings)

       Prints the strings to the socket. Doesn't add any end-of-line characters.  Changes  all  end-of-lines  to
       "\r\n". Doesn't encode the data!

       UNLESS YOU ARE ABSOLUTELY SURE YOU KNOW WHAT YOU ARE DOING YOU SHOULD USE <u>SendEnc()</u> INSTEAD!

       Returns the object if successfull.

   <b>SendLineEx</b>
        SendLineEx(@strings)

       Prints  the strings to the socket. Adds an end-of-line character at the end.  Changes all end-of-lines to
       "\r\n". Doesn't encode the data!

       UNLESS YOU ARE ABSOLUTELY SURE YOU KNOW WHAT YOU ARE DOING YOU SHOULD USE <u>SendEnc()</u> INSTEAD!

       Returns the object if successfull.

   <b>Part</b>
        Part( I&lt;description&gt;, I&lt;ctype&gt;, I&lt;encoding&gt;, I&lt;disposition&gt; [, I&lt;content_id&gt; [, I&lt;msg&gt;]]);
        Part( {[description =&gt; "desc"], [ctype =&gt; "content-type"], [encoding =&gt; "..."],
            [disposition =&gt; "..."], [content_id =&gt; "..."], [msg =&gt; ...]});

       Prints a part header for the multipart message and (if specified) the contents.  The undefined  or  empty
       variables are ignored.

       description
         The title for this part.

       ctype
         the content type (MIME type) of this part. May contain some other parameters, such as <b>charset</b> or <b>name</b>.

         Defaults to "application/octet-stream".

         Since  0.8.00  you may use even "multipart/..." types. Such a multipart part should be closed by a call
         to $sender-&gt;EndPart($ctype).

                 ...
                 $sender-&gt;Part({ctype =&gt; "multipart/related", ...});
                         $sender-&gt;Part({ctype =&gt; 'text/html', ...});
                         $sender-&gt;Attach({file =&gt; 'some_image.gif', content_id =&gt; 'foo', ...});
                 $sender-&gt;EndPart("multipart/related");
                 ...

         Please see the examples below.

       encoding
         the encoding used for this part of message. Eg. Base64, Uuencode, 7BIT ...

         Defaults to "7BIT".

       disposition
         This parts disposition. Eg: 'attachment; filename="send.pl"'.

         Defaults to "attachment". If you specify "none" or  "",  the  Content-disposition:  line  will  not  be
         included in the headers.

       content_id
         The content id of the part, used in multipart/related.  If not specified, the header is not included.

       msg
         The  content  of  the  part.  You do not have to specify the content here, you may use <u>SendEnc()</u> to add
         content to the part.

       charset
         The charset of the part.

       Returns the Mail::Sender object if successfull, negative error code if not.

   <b>Body</b>
        Body([charset [, encoding [, content-type]]]);
        Body({charset =&gt; '...', encoding =&gt; '...', ctype =&gt; '...', msg =&gt; '...');

       Sends the head of the multipart message body. You can specify the charset and the  encoding.  Default  is
       "US-ASCII","7BIT",'text/plain'.

       If you pass undef or zero as the parameter, this function uses the default value:

           Body(0,0,'text/html');

       Returns  the  Mail::Sender  object  if  successfull, negative error code if not.  You should NOT use this
       method in single part messages, that is, it works after <u>OpenMultipart()</u>, but has no meaning after <u>Open()</u>!

   <b>SendFile</b>
       Alias to <u>Attach()</u>

   <b>Attach</b>
        Attach( I&lt;description&gt;, I&lt;ctype&gt;, I&lt;encoding&gt;, I&lt;disposition&gt;, I&lt;file&gt;);
        Attach( { [description =&gt; "desc"] , [ctype =&gt; "ctype"], [encoding =&gt; "encoding"],
                    [disposition =&gt; "disposition"], file =&gt; "file"});

        Sends a file as a separate part of the mail message. Only in multipart mode.

       description
         The title for this part.

       ctype
         the content type (MIME type) of this part. May contain some other parameters, such as <b>charset</b> or <b>name</b>.

         Defaults to "application/octet-stream".

       encoding
         the encoding used for this part of message. Eg. Base64, Uuencode, 7BIT ...

         Defaults to "Base64".

       disposition
         This parts disposition. Eg: 'attachment; filename="send.pl"'. If you use 'attachment; filename=*' the *
         will be replaced by the respective names of the sent files.

         Defaults to "attachment; filename=*". If you do not want to include this header use "" as the value.

       file
         The    name    of    the    file    to     send     or     a     'list,     of,     names'     or     a
         ['reference','to','a','list','of','filenames']. Each file will be sent as a separate part.

         Please  keep in mind that if you pass a string as this parameter the module will split it on commas! If
         your filenames may contain commas and you want to be sure they are sent correctly you have to  use  the
         reference to array format:

                 file =&gt; [ $filename],

       content_id
         The content id of the message part. Used in multipart/related.

          Special values:
           "*" =&gt; the name of the file
           "#" =&gt; autoincremented number (starting from 0)

       Returns the Mail::Sender object if successfull, negative error code if not.

   <b>EndPart</b>
        $sender-&gt;EndPart($ctype);

       Closes a multipart part.

       If  the  $ctype  is  not present or evaluates to false, only the current SIMPLE part is closed!  Don't do
       that unless you are really sure you know what you are doing.

       It's best to always pass to the -&gt;<u>EndPart()</u> the content type of the corresponding -&gt;<u>Part()</u>.

   <b>Close</b>
        $sender-&gt;Close;
        $sender-&gt;<a href="../man1/Close.1.html">Close</a>(1);

       Close and send the email message. If you pass a true value to the method the connection  will  be  closed
       even  if the "keepconnection" was specified. You should only keep the connection open if you plan to send
       another message immediately. And you should not keep it open for hundreds of emails even if you  do  send
       them all in a row.

       This method should be called automatically when destructing the object, but you should not rely on it. If
       you want to be sure your message WAS processed by the SMTP server you SHOULD call <u>Close()</u> explicitely.

       Returns  the  Mail::Sender  object  if  successfull,  negative error code if not, zero if $sender was not
       connected at all.  The zero usualy means that the Open/OpenMultipart failed and  you  did  not  test  its
       return value.

   <b>Cancel</b>
        $sender-&gt;Cancel;

       Cancel an opened message.

       SendFile   and   other   methods  may  set  $sender-&gt;{'error'}.   In  that  case  "undef  $sender"  calls
       "$sender-"&gt;Cancel not "$sender-"&gt;Close!!!

       Returns the Mail::Sender object if successfull, negative error code if not.

   <b>QueryAuthProtocols</b>
               @protocols = $sender-&gt;QueryAuthProtocols();
               @protocols = $sender-&gt;QueryAuthProtocols( $smtpserver);

       Queryies the server (specified either in the default options for  Mail::Sender,  the  "new  Mail::Sender"
       command or as a parameter to this method for the authentication protocols it supports.

   <b>GetHandle</b>
       Returns  a  "filehandle"  to which you can print the message or file to attach or whatever.  The data you
       print to this handle will be encoded as necessary. Closing this handle closes  either  the  message  (for
       single part messages) or the part.

               $sender-&gt;Open({...});
               my $handle = $sender-&gt;GetHandle();
               print $handle "Hello world.\n"
               my ($mday,$mon,$year) = (localtime())[3,4,5];
               printf $handle "Today is %04d/%02d/%02d.", $year+1900, $mon+1, $mday;
               close $handle;

       P.S.:  There is a big difference between the handle stored in $sender-&gt;{'socket'} and the handle returned
       by this function ! If you print something to $sender-&gt;{'socket'} it will be sent to  the  server  without
       any  modifications,  encoding,  escaping,  ...   You  should NOT touch the $sender-&gt;{'socket'} unless you
       really really know what you are doing.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>GuessCType</b>
               $ctype = GuessCType $filename, $filepath;

       Guesses the content type based on the filename or the file contents.  This  function  is  used  when  you
       attach a file and do not specify the content type.  It is not exported by default!

       The  builtin  version  uses  the  filename  extension  to guess the type.  Currently there are only a few
       extensions defined, you may add other extensions this way:

               $Mail::Sender::CTypes{'EXT'} = 'content/type';
               ...

       The extension has to be in UPPERCASE and will be matched case sensitively.

       The package now includes two addins improving the guesswork. If you "use" one of them in your script,  it
       replaces the builtin <u>GuessCType()</u> subroutine with a better one:

               Mail::Sender::CType::Win32
                       Win32 only, the content type is read from the registry
               Mail::Sender::CType::Ext
                       any OS, a longer list of extensions from A. Guillaume

   <b>ResetGMTdiff</b>
               ResetGMTdiff()

       The module computes the local vs. GMT time difference to include in the timestamps added into the message
       headers.  As  the time difference may change due to summer savings time changes you may want to reset the
       time difference ocassionaly in long running programs.

</pre><h4><b>CONFIG</b></h4><pre>
       If you create a file named Sender.config in the same directory where Sender.pm resides, this file will be
       "require"d as soon as you "use Mail::Sender" in your script. Of course the Sender.config MUST  "return  a
       true  value",  that is it has to be succesfully compiled and the last statement must return a true value.
       You may use this to forbide the use of Mail::Sender to some users.

       You may define the default settings for new Mail::Sender objects and do a few more things.

       The default options are stored in hash %Mail::Sender::default. You may use all the options you'd  use  in
       "new", "Open", "OpenMultipart", "MailMsg" or "MailFile".

        Eg.
         %default = (
           smtp =&gt; 'mail.yourhost.cz',
           from =&gt; getlogin.'yourhost.cz',
           client =&gt; getlogin.'.yourhost.cz'
         );
         # of course you will use your own mail server here !

       The   other   options   you   may   set  here  (or  later  of  course)  are  $Mail::Sender::SITE_HEADERS,
       $Mail::Sender::NO_X_MAILER and $Mail::Sender::NO_DATE. (These are plain old scalar variables, there is no
       function or method for modifying them. Just set them to anything you need.)

       The $Mail::Sender::SITE_HEADERS may contain headers that will be added to each mail message sent by  this
       script,  the  $Mail::Sender::NO_X_MAILER disables the header item specifying that the message was sent by
       Mail::Sender and $Mail::Sender::NO_DATE turns off the Date: header generation.

       !!! $Mail::Sender::SITE_HEADERS may NEVER end with \r\n !!!

       If you want to set the $Mail::Sender::SITE_HEADERS for every script sent from your  server  without  your
       users being able to change it you may use this hack:

        $loginname = something_that_identifies_the_user();
        *Mail::Sender::SITE_HEADERS = \"X-Sender: $loginname via $0";
        $Mail::Sender::NO_X_MAILER = 1;

       You  may  even  "install"  your  custom  function  that  will  be  evaluated for each message just before
       contacting the server. You may change all the options from within as well as stop sending the message.

       All you have to do is to create a function named SiteHook in Mail::Sender package. This function will get
       the Mail::Sender object as its first argument. If it returns a TRUE value the  message  is  sent,  if  it
       returns FALSE the sending is canceled and the user gets "Site specific error" error message.

       If you want to give some better error message you may do it like this :

        sub SiteHook {
         my $self = shift;
         if (whatever($self)) {
           $self-&gt;Error( SITEERROR);
           $Mail::Sender::Error = "I don't like this mail";
           return 0
         } else {
           return 1;
         }
        }

       This example will ensure the from address is the users real address :

        sub SiteHook {
         my $self = shift;
         $self-&gt;{'fromaddr'} = getlogin.'@yoursite.com';
         $self-&gt;{'from'} = getlogin.'@yoursite.com';
         1;
        }

       Please note that at this stage the from address is in two different object properties.

       $self-&gt;{'from'} is the address as it will appear in the mail, that is it may include the full name of the
       user   or   any   other   comment   (   "Jan   Krynicky  &lt;<a href="mailto:jenda@krynicky.cz">jenda@krynicky.cz</a>&gt;"  for  example),  while  the
       $self-&gt;{'fromaddr'} is realy just the email address per se and it will be used in conversation  with  the
       SMTP server. It must be without comments ("<a href="mailto:jenda@krynicky.cz">jenda@krynicky.cz</a>" for example)!

       Without  write  access  to  .../lib/Mail/Sender.pm  or .../lib/Mail/Sender.config your users will then be
       unable to get rid of this header. Well ... everything is doable, if they are cheeky enough ... :-(

       So if you take care of some site with virtual servers for several clients and implement some  policy  via
       <u>SiteHook()</u>  or  $Mail::Sender::SITE_HEADERS search the clients' scripts for "SiteHook" and "SITE_HEADERS"
       from time to time. To see who's cheating.

</pre><h4><b>AUTHENTICATION</b></h4><pre>
       If you get a "Local user "<a href="mailto:xxx@yyy.com">xxx@yyy.com</a>" unknown on host "zzz"" message it  usualy  means  that  your  mail
       server  is set up to forbid mail relay. That is it only accepts messages to or from a local user.  If you
       need to be able to send a message with both the sender's and recipient's  address  remote,  you  need  to
       somehow  authenticate to the server. You may need the help of the mail server's administrator to find out
       what username and password and/or what authentication protocol are you supposed to use.

       There are many authentication protocols defined for ESTMP, Mail::Sender  natively  supports  only  PLAIN,
       LOGIN, CRAM-MD5 and NTLM (please see the docs for "new Mail::Sender").

       If you want to know what protocols are supported by your server you may get the list by this:

               <a href="file:/tmp">/tmp</a># perl -MMail::Sender -e 'Mail::Sender-&gt;printAuthProtocols("the.server.com")'
         or
               c:\&gt; perl -MMail::Sender -e "Mail::Sender-&gt;printAuthProtocols('the.server.com')"

       There  is  one  more  way  to  authenticate. Some servers want you to login by POP3 before you can send a
       message. You have to use Net::POP3 or Mail::POP3Client to do this.

   <b>Other</b> <b>protocols</b>
       It is possible to add new authentication protocols to Mail::Sender. All you have to do  is  to  define  a
       function Mail::Sender::Auth::PROTOCOL_NAME that will implement the login. The function gets one parameter
       ... the Mail::Sender object.  It can access these properties:

               $obj-&gt;{'socket'} : the socket to print to and read from
                       you may use the send_cmd() function to send a request
                       and read a response from the server
               $obj-&gt;{'authid'} : the username specified in the new Mail::Sender,
                       Open or OpenMultipart call
               $obj-&gt;{'authpwd'} : the password
               $obj-&gt;{auth...} : all unknown parameters passed to the constructor or the mail
                       opening/creation methods are preserved in the object. If the protocol requires
                       any other options, please use names starting with "auth". Eg. "authdomain", ...
               $obj-&gt;{'error'} : this should be set to a negative error number. Please use numbers
                       below -1000 for custom errors.
               $obj-&gt;{'error_msg'} : this should be set to the error message

               If the login fails you should
                       1) Set $Mail::Sender::Error to the error message
                       2) Set $obj-&gt;{'error_msg'} to the error message
                       2) Set $obj-&gt;{'error'} to a negative number
                       3) return a negative number
               If it succeeds, please return "nothing" :
                       return;

       Please use the protocols defined within Sender.pm as examples.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Object</b> <b>creation</b>
        ref ($sender = new Mail::Sender { from =&gt; '<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>',
              smtp =&gt; 'mail.yourISP.com', boundary =&gt; 'This-is-a-mail-boundary-435427'})
        or die "Error in mailing : $Mail::Sender::Error\n";

       or

        my $sender = new Mail::Sender { ... };
        die "Error in mailing : $Mail::Sender::Error\n" unless ref $sender;

       or

        my $sender = new Mail::Sender { ..., on_errors =&gt; 'undef' }
          or die "Error in mailing : $Mail::Sender::Error\n";

       You  may  specify  the  options  either  when  creating  the Mail::Sender object or later when you open a
       message. You may also set the default options when installing the module (See "CONFIG" section). This way
       the admin may set the SMTP server and even the authentication options  and  the  users  do  not  have  to
       specify it again.

       You  should  keep in mind that the way Mail::Sender reports failures depends on the 'on_errors'=&gt; option.
       If you set it to 'die' it throws an exception, if you set it to "undef" or 'undef' it returns  undef  and
       otherwise it returns a negative error code!

   <b>Simple</b> <b>single</b> <b>part</b> <b>message</b>
               $sender = new Mail::Sender {
                       smtp =&gt; 'mail.yourISP.com',
                       from =&gt; '<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>',
                       on_errors =&gt; undef,
               }
                       or die "Can't create the Mail::Sender object: $Mail::Sender::Error\n";
               $sender-&gt;Open({
                       to =&gt; '<a href="mailto:mama@home.org">mama@home.org</a>, <a href="mailto:papa@work.com">papa@work.com</a>',
                       cc =&gt; '<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>',
                       subject =&gt; 'Sorry, I\'ll come later.'
               })
                       or die "Can't open the message: $sender-&gt;{'error_msg'}\n";
               $sender-&gt;SendLineEnc("I'm sorry, but thanks to the lusers,
                       I'll come at 10pm at best.");
               $sender-&gt;SendLineEnc("\nHi, Jenda");
               $sender-&gt;Close()
                       or die "Failed to send the message: $sender-&gt;{'error_msg'}\n";

       or

               eval {
                       $sender = new Mail::Sender {
                               smtp =&gt; 'mail.yourISP.com',
                               from =&gt; '<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>',
                               on_errors =&gt; 'die',
                       };
                       $sender-&gt;Open({
                               to =&gt; '<a href="mailto:mama@home.org">mama@home.org</a>, <a href="mailto:papa@work.com">papa@work.com</a>',
                               cc =&gt; '<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>',
                               subject =&gt; 'Sorry, I\'ll come later.'
                       });
                       $sender-&gt;SendLineEnc("I'm sorry, but thanks to the lusers,
                               I'll come at 10pm at best.");
                       $sender-&gt;SendLineEnc("\nHi, Jenda");
                       $sender-&gt;Close();
               };
               if ($@) {
                       die "Failed to send the message: $@\n";
               }

       or

               $sender = new Mail::Sender {
                       smtp =&gt; 'mail.yourISP.com',
                       from =&gt; '<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>',
                       on_errors =&gt; 'code',
               };
               die "Can't create the Mail::Sender object: $Mail::Sender::Error\n"
                       unless ref $sender;
               ref $sender-&gt;Open({
                       to =&gt; '<a href="mailto:mama@home.org">mama@home.org</a>, <a href="mailto:papa@work.com">papa@work.com</a>',
                       cc =&gt; '<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>',
                       subject =&gt; 'Sorry, I\'ll come later.'
               })
                       or die "Can't open the message: $sender-&gt;{'error_msg'}\n";
               $sender-&gt;SendLineEnc("I'm sorry, but thanks to the lusers,
                       I'll come at 10pm at best.");
               $sender-&gt;SendLineEnc("\nHi, Jenda");
               ref $sender-&gt;Close
                       or die "Failed to send the message: $sender-&gt;{'error_msg'}\n";

   <b>Using</b> <u><b>GetHandle()</b></u>
         ref $sender-&gt;Open({to =&gt; '<a href="mailto:friend@other.com">friend@other.com</a>', subject =&gt; 'Hello dear friend'})
                or die "Error: $Mail::Sender::Error\n";
         my $FH = $sender-&gt;GetHandle();
         print $FH "How are you?\n\n";
         print $FH &lt;&lt;'*END*';
         I've found these jokes.

          Doctor, I feel like a pack of cards.
          Sit down and I'll deal with you later.

          Doctor, I keep thinking I'm a dustbin.
          Don't talk rubbish.

         Hope you like'em. Jenda
         *END*

         $sender-&gt;Close;
         # or
         # close $FH;

       or

         eval {
           $sender-&gt;Open({ on_errors =&gt; 'die',
                                to =&gt; '<a href="mailto:mama@home.org">mama@home.org</a>, <a href="mailto:papa@work.com">papa@work.com</a>',
                       cc =&gt; '<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>',
                       subject =&gt; 'Sorry, I\'ll come later.'});
           $sender-&gt;SendLineEnc("I'm sorry, but due to a big load of work,
         I'll come at 10pm at best.");
           $sender-&gt;SendLineEnc("\nHi, Jenda");
           $sender-&gt;Close;
         };
         if ($@) {
           print "Error sending the email: $@\n";
         } else {
           print "The mail was sent.\n";
         }

   <b>Multipart</b> <b>message</b> <b>with</b> <b>attachment</b>
        $sender-&gt;OpenMultipart({to =&gt; '<a href="mailto:Perl-Win32-Users@activeware.foo">Perl-Win32-Users@activeware.foo</a>',
                                subject =&gt; 'Mail::Sender.pm - new module'});
        $sender-&gt;Body;
        $sender-&gt;SendEnc(&lt;&lt;'*END*');
        Here is a new module Mail::Sender.
        It provides an object based interface to sending SMTP mails.
        It uses a direct socket connection, so it doesn't need any
        additional program.

        Enjoy, Jenda
        *END*
        $sender-&gt;Attach(
         {description =&gt; 'Perl module Mail::Sender.pm',
          ctype =&gt; 'application/x-zip-encoded',
          encoding =&gt; 'Base64',
          disposition =&gt; 'attachment; filename="Sender.zip"; type="ZIP archive"',
          file =&gt; 'sender.zip'
         });
        $sender-&gt;Close;

       or

        $sender-&gt;OpenMultipart({to =&gt; '<a href="mailto:Perl-Win32-Users@activeware.foo">Perl-Win32-Users@activeware.foo</a>',
                                subject =&gt; 'Mail::Sender.pm - new version'});
        $sender-&gt;Body({ msg =&gt; &lt;&lt;'*END*' });
        Here is a new module Mail::Sender.
        It provides an object based interface to sending SMTP mails.
        It uses a direct socket connection, so it doesn't need any
        additional program.

        Enjoy, Jenda
        *END*
        $sender-&gt;Attach(
         {description =&gt; 'Perl module Mail::Sender.pm',
          ctype =&gt; 'application/x-zip-encoded',
          encoding =&gt; 'Base64',
          disposition =&gt; 'attachment; filename="Sender.zip"; type="ZIP archive"',
          file =&gt; 'sender.zip'
         });
        $sender-&gt;Close;

       or (in case you have the file contents in a scalar)

        $sender-&gt;OpenMultipart({to =&gt; '<a href="mailto:Perl-Win32-Users@activeware.foo">Perl-Win32-Users@activeware.foo</a>',
                                subject =&gt; 'Mail::Sender.pm - new version'});
        $sender-&gt;Body({ msg =&gt; &lt;&lt;'*END*' });
        Here is a new module Mail::Sender.
        It provides an object based interface to sending SMTP mails.
        It uses a direct socket connection, so it doesn't need any
        additional program.

        Enjoy, Jenda
        *END*
        $sender-&gt;Part(
         {description =&gt; 'Perl module Mail::Sender.pm',
          ctype =&gt; 'application/x-zip-encoded',
          encoding =&gt; 'Base64',
          disposition =&gt; 'attachment; filename="Sender.zip"; type="ZIP archive"',
          msg =&gt; $sender_zip_contents,
         });
        $sender-&gt;Close;

   <b>Using</b> <b>exceptions</b> <b>(no</b> <b>need</b> <b>to</b> <b>test</b> <b>return</b> <b>values</b> <b>after</b> <b>each</b> <b>function)</b>
        use Mail::Sender;
        eval {
        (new Mail::Sender {on_errors =&gt; 'die'})
               -&gt;OpenMultipart({smtp=&gt; 'jenda.krynicky.cz', to =&gt; '<a href="mailto:jenda@krynicky.cz">jenda@krynicky.cz</a>',subject =&gt; 'Mail::Sender.pm - new version'})
               -&gt;Body({ msg =&gt; &lt;&lt;'*END*' })
        Here is a new module Mail::Sender.
        It provides an object based interface to sending SMTP mails.
        It uses a direct socket connection, so it doesn't need any
        additional program.

        Enjoy, Jenda
        *END*
               -&gt;Attach({
                       description =&gt; 'Perl module Mail::Sender.pm',
                       ctype =&gt; 'application/x-zip-encoded',
                       encoding =&gt; 'Base64',
                       disposition =&gt; 'attachment; filename="Sender.zip"; type="ZIP archive"',
                       file =&gt; 'W:\jenda\packages\Mail\Sender\Mail-Sender-0.7.14.3.tar.gz'
               })
               -&gt;Close();
        } or print "Error sending mail: $@\n";

   <b>Using</b> <u><b>MailMsg()</b></u> <b>shortcut</b> <b>to</b> <b>send</b> <b>simple</b> <b>messages</b>
       If everything you need is to send a simple message you may use:

        if (ref ($sender-&gt;MailMsg({to =&gt;'<a href="mailto:Jenda@Krynicky.czX">Jenda@Krynicky.czX</a>', subject =&gt; 'this is a test',
                                msg =&gt; "Hi Johnie.\nHow are you?"}))) {
         print "Mail sent OK."
        } else {
         die "$Mail::Sender::Error\n";
        }

       or

        if ($sender-&gt;MailMsg({
          smtp =&gt; 'mail.yourISP.com',
          from =&gt; '<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>',
          to =&gt;'<a href="mailto:Jenda@Krynicky.czX">Jenda@Krynicky.czX</a>',
          subject =&gt; 'this is a test',
          msg =&gt; "Hi Johnie.\nHow are you?"
        }) &lt; 0) {
         die "$Mail::Sender::Error\n";
        }
        print "Mail sent OK."

   <b>Using</b> <b>MailMsg</b> <b>and</b> <b>authentication</b>
        if ($sender-&gt;MailMsg({
          smtp =&gt; 'mail.yourISP.com',
          from =&gt; '<a href="mailto:somebody@somewhere.com">somebody@somewhere.com</a>',
          to =&gt;'<a href="mailto:Jenda@Krynicky.czX">Jenda@Krynicky.czX</a>',
          subject =&gt; 'this is a test',
          msg =&gt; "Hi Johnie.\nHow are you?"
          auth =&gt; 'NTLM',
          authid =&gt; 'jenda',
          authpwd =&gt; 'benda',
        }) &lt; 0) {
         die "$Mail::Sender::Error\n";
        }
        print "Mail sent OK."

   <b>Using</b> <u><b>MailFile()</b></u> <b>shortcut</b> <b>to</b> <b>send</b> <b>an</b> <b>attachment</b>
       If you want to attach some files:

        (ref ($sender-&gt;MailFile(
         {to =&gt;'<a href="mailto:you@address.com">you@address.com</a>', subject =&gt; 'this is a test',
          msg =&gt; "Hi Johnie.\nI'm sending you the pictures you wanted.",
          file =&gt; 'image1.jpg,image2.jpg'
         }))
         and print "Mail sent OK."
        )
        or die "$Mail::Sender::Error\n";

   <b>Sending</b> <b>HTML</b> <b>messages</b>
       If you are sure the HTML doesn't contain any accentuated characters (with codes above 127).

        open IN, $htmlfile or die "Cannot open $htmlfile : $!\n";
        $sender-&gt;Open({ from =&gt; '<a href="mailto:your@address.com">your@address.com</a>', to =&gt; '<a href="mailto:other@address.com">other@address.com</a>',
               subject =&gt; 'HTML test',
               ctype =&gt; "text/html",
               encoding =&gt; "7bit"
        }) or die $Mail::Sender::Error,"\n";

        while (&lt;IN&gt;) { $sender-&gt;SendEx($_) };
        close IN;
        $sender-&gt;Close();

       Otherwise use <u>SendEnc()</u> instead of <u>SendEx()</u> and "quoted-printable" instead of "7bit".

       Another ... quicker way ... would be:

        open IN, $htmlfile or die "Cannot open $htmlfile : $!\n";
        $sender-&gt;Open({ from =&gt; '<a href="mailto:your@address.com">your@address.com</a>', to =&gt; '<a href="mailto:other@address.com">other@address.com</a>',
               subject =&gt; 'HTML test',
               ctype =&gt; "text/html",
               encoding =&gt; "quoted-printable"
        }) or die $Mail::Sender::Error,"\n";

        while (read IN, $buff, 4096) { $sender-&gt;SendEnc($buff) };
        close IN;
        $sender-&gt;Close();

   <b>Sending</b> <b>HTML</b> <b>messages</b> <b>with</b> <b>inline</b> <b>images</b>
               if (ref $sender-&gt;OpenMultipart({
                       from =&gt; '<a href="mailto:someone@somewhere.net">someone@somewhere.net</a>', to =&gt; $recipients,
                       subject =&gt; 'Embedded Image Test',
                       boundary =&gt; 'boundary-test-1',
                       multipart =&gt; 'related'})) {
                       $sender-&gt;Attach(
                                {description =&gt; 'html body',
                                ctype =&gt; 'text/html; charset=us-ascii',
                                encoding =&gt; '7bit',
                                disposition =&gt; 'NONE',
                                file =&gt; 'test.html'
                       });
                       $sender-&gt;Attach({
                               description =&gt; 'ed\'s gif',
                               ctype =&gt; 'image/gif',
                               encoding =&gt; 'base64',
                               disposition =&gt; "inline; filename=\"apache_pb.gif\";\r\nContent-ID: &lt;img1&gt;",
                               file =&gt; 'apache_pb.gif'
                       });
                       $sender-&gt;Close() or die "Close failed! $Mail::Sender::Error\n";
               } else {
                       die "Cannot send mail: $Mail::Sender::Error\n";
               }

       And in the HTML you'll have this :
        ... &lt;IMG src="cid:img1"&gt; ...  on the place where you want the inlined image.

       Please keep in mind that the image name is unimportant, it's the Content-ID what counts!

       # or using the eval{ $obj-&gt;<u>Method()</u>-&gt;<u>Method()</u>-&gt;...-&gt;<u>Close()</u>} trick ...

               use Mail::Sender;
               eval {
               (new Mail::Sender)
                       -&gt;OpenMultipart({
                               to =&gt; '<a href="mailto:someone@somewhere.com">someone@somewhere.com</a>',
                               subject =&gt; 'Embedded Image Test',
                               boundary =&gt; 'boundary-test-1',
                               type =&gt; 'multipart/related'
                       })
                       -&gt;Attach({
                               description =&gt; 'html body',
                               ctype =&gt; 'text/html; charset=us-ascii',
                               encoding =&gt; '7bit',
                               disposition =&gt; 'NONE',
                               file =&gt; 'c:\temp\zk\HTMLTest.htm'
                       })
                       -&gt;Attach({
                               description =&gt; 'Test gif',
                               ctype =&gt; 'image/gif',
                               encoding =&gt; 'base64',
                               disposition =&gt; "inline; filename=\"test.gif\";\r\nContent-ID: &lt;img1&gt;",
                               file =&gt; 'test.gif'
                       })
                       -&gt;Close()
               }
               or die "Cannot send mail: $Mail::Sender::Error\n";

   <b>Sending</b> <b>message</b> <b>with</b> <b>plaintext</b> <b>and</b> <b>HTML</b> <b>alternatives</b>
               use Mail::Sender;

               eval {
                       (new Mail::Sender)
                       -&gt;OpenMultipart({
                               to =&gt; '<a href="mailto:someone@somewhere.com">someone@somewhere.com</a>',
                               subject =&gt; 'Alternatives',
               #               debug =&gt; 'c:\temp\zkMailFlow.log',
                               multipart =&gt; 'mixed',
                       })
                               -&gt;Part({ctype =&gt; 'multipart/alternative'})
                                       -&gt;Part({ ctype =&gt; 'text/plain', disposition =&gt; 'NONE', msg =&gt; &lt;&lt;'*END*' })
               A long
               mail
               message.
               *END*
                                       -&gt;Part({ctype =&gt; 'text/html', disposition =&gt; 'NONE', msg =&gt; &lt;&lt;'*END*'})
               &lt;html&gt;&lt;body&gt;&lt;h1&gt;A long&lt;/h1&gt;&lt;p align=center&gt;
               mail
               message.
               &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
               *END*
                               -&gt;EndPart("multipart/alternative")
                       -&gt;Close();
               } or print "Error sending mail: $Mail::Sender::Error\n";

   <b>Sending</b> <b>message</b> <b>with</b> <b>plaintext</b> <b>and</b> <b>HTML</b> <b>alternatives</b> <b>with</b> <b>inline</b> <b>images</b>
               use Mail::Sender;

               eval {
                       (new Mail::Sender)
                       -&gt;OpenMultipart({
                               to =&gt; '<a href="mailto:someone@somewhere.com">someone@somewhere.com</a>',
                               subject =&gt; 'Alternatives with images',
               #               debug =&gt; 'c:\temp\zkMailFlow.log',
                               multipart =&gt; 'related',
                       })
                               -&gt;Part({ctype =&gt; 'multipart/alternative'})
                                       -&gt;Part({ ctype =&gt; 'text/plain', disposition =&gt; 'NONE', msg =&gt; &lt;&lt;'*END*' })
               A long
               mail
               message.
               *END*
                                       -&gt;Part({ctype =&gt; 'text/html', disposition =&gt; 'NONE', msg =&gt; &lt;&lt;'*END*'})
               &lt;html&gt;&lt;body&gt;&lt;h1&gt;A long&lt;/h1&gt;&lt;p align=center&gt;
               mail
               message.
               &lt;img src="cid:img1"&gt;
               &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
               *END*
                               -&gt;EndPart("multipart/alternative")
                               -&gt;Attach({
                                       description =&gt; 'ed\'s jpg',
                                       ctype =&gt; 'image/jpeg',
                                       encoding =&gt; 'base64',
                                       disposition =&gt; "inline; filename=\"0518m_b.jpg\";\r\nContent-ID: &lt;img1&gt;",
                                       file =&gt; 'E:\pix\humor\0518m_b.jpg'
                               })
                       -&gt;Close();
               } or print "Error sending mail: $Mail::Sender::Error\n";

       Keep in mind please that different mail clients display messages differently. You may need to try several
       ways  to create messages so that they appear the way you need.  These two examples looked like I expected
       in Pegasus Email and MS Outlook.

       If this doesn't work with your mail client, please let me know and we might find a way.

   <b>Sending</b> <b>a</b> <b>file</b> <b>that</b> <b>was</b> <b>just</b> <b>uploaded</b> <b>from</b> <b>an</b> <b>HTML</b> <b>form</b>
        use CGI;
        use Mail::Sender;

        $query = new CGI;

        # uploading the file...
        $filename = $query-&gt;param('mailformFile');
        if ($filename ne ""){
         $tmp_file = $query-&gt;tmpFileName($filename);
        }

        $sender = new Mail::Sender {from =&gt; '<a href="mailto:script@krynicky.cz">script@krynicky.cz</a>',smtp =&gt; 'mail.krynicky.czX'};
        $sender-&gt;OpenMultipart({to=&gt; '<a href="mailto:jenda@krynicky.czX">jenda@krynicky.czX</a>',subject=&gt; 'test CGI attach'});
        $sender-&gt;Body();
        $sender-&gt;Send(&lt;&lt;"*END*");
        This is just a test of mail with an uploaded file.

        Jenda
        *END*
        $sender-&gt;Attach({
           encoding =&gt; 'Base64',
           description =&gt; $filename,
           ctype =&gt; $query-&gt;uploadInfo($filename)-&gt;{'Content-Type'},
           disposition =&gt; "attachment; filename = $filename",
           file =&gt; $tmp_file
        });
        $sender-&gt;Close();

        print "Content-type: text/plain\n\nYes, it's sent\n\n";

   <b>Listing</b> <b>the</b> <b>authentication</b> <b>protocols</b> <b>supported</b> <b>by</b> <b>the</b> <b>server</b>
        use Mail::Sender;
        my $sender = new Mail::Sender {smtp =&gt; 'localhost'};
        die "Error: $Mail::Sender::Error\n" unless ref $sender;
        print join(', ', $sender-&gt;QueryAuthProtocols()),"\n";

       or (if you have Mail::Sender 0.8.05 or newer)

        use Mail::Sender;
        print join(', ', Mail::Sender-&gt;QueryAuthProtocols('localhost')),"\n";

       or

        use Mail::Sender;
        print join(', ', Mail::Sender::QueryAuthProtocols('localhost')),"\n";

   <b>FAQ</b>
       <u>Forwarding</u> <u>the</u> <u>messages</u> <u>created</u> <u>by</u> <u>Mail::Sender</u> <u>removes</u> <u>accents.</u> <u>Why?</u>

       The most likely colprit is missing or incorrect charset specified for the body or a part  of  the  email.
       You should add something like

               charset =&gt; 'iso-8859-1',
               encoding =&gt; 'quoted-printable',

       to the parameters passed to <u>Open()</u>, <u>OpenMultipart()</u>, <u>MailMsg()</u>, <u>Body()</u> or <u>Part()</u> or

               b_charset =&gt; 'iso-8859-1',
               b_encoding =&gt; 'quoted-printable',

       to the parameters for <u>MailFile()</u>.

       If  you  use  a different charset ('iso-8859-2', 'win-1250', ...) you will of course need to specify that
       charset. If you are not sure, try to send a mail with some  other  mail  client  and  then  look  at  the
       message/part headers.

   <b>Sometimes</b>  <b>there</b>  <b>is</b>  <b>an</b>  <b>equals</b> <b>sign</b> <b>at</b> <b>the</b> <b>end</b> <b>of</b> <b>an</b> <b>attached</b> <b>file</b> <b>when</b> <b>I</b> <b>open</b> <b>the</b> <b>email</b> <b>in</b> <b>Outlook.</b> <b>What's</b>
       <b>wrong?</b>
       Outlook is. It has (had) a bug in its quoted printable decoding routines.  This problem happens  only  in
       quoted-printable  encoded parts on multipart messages.  And only if the data in that part do not end with
       a newline. (This is new in 0.8.08, in older versions it happened in all QP encoded parts.)

       The problem is that an equals sign at the end of a line in a quoted printable encoded text means  "ignore
       the newline". That is

               fooo sdfg sdfg sdfh dfh =
               dfsgdsfg

       should be decoded as

               fooo sdfg sdfg sdfh dfh dfsgdsfg

       The  problem  is  at  the  very  end  of  a file. The part boundary (text separating different parts of a
       multipart message) has to start on a new line, if the attached file ends by a newline everything is cool.
       If it doesn't I need to add a newline and to denote that the newline is not part of the original  file  I
       add an equals:

               dfgd dsfgh dfh dfh dfhdfhdfhdfgh
               this is the last line.=

               --message-boundary-146464--
       Otherwise  I'd add a newline at the end of the file.  If you do not care about the newline and want to be
       sure Outlook doesn't add the equals to the file add

               bypass_outlook_bug =&gt; 1

       parameter to "new Mail::Sender" or "Open"/"OpenMultipart".

   <b>WARNING</b>
       DO NOT mix Open(Multipart)|Send(Line)(Ex)|Close with MailMsg or MailFile.  Both Mail(Msg/File) close  any
       Open-ed mail.  Do not try this:

        $sender = new Mail::Sender ...;
        $sender-&gt;OpenMultipart...;
        $sender-&gt;Body;
        $sender-&gt;Send("...");
        $sender-&gt;MailFile({file =&gt; 'something.ext');
        $sender-&gt;Close;

       This WON'T work!!!

   <b>GOTCHAS</b>
       <u>Local</u> <u>user</u> <u>"<a href="mailto:someone@somewhere.com">someone@somewhere.com</a>"</u> <u>doesn't</u> <u>exist</u>

       "Thanks"  to  spammers mail servers usualy do not allow just anyone to post a message through them.  Most
       often they require that either the sender or the recipient is local to the server

       <u>Mail::Sendmail</u> <u>works,</u> <u>Mail::Sender</u> <u>doesn't</u>

       If you are able to connect to the mail server and scripts using  Mail::Sendmail  work,  but  Mail::Sender
       fails  with  "<u>connect()</u> failed", please review the settings in /etc/services. The port for SMTP should be
       25.

       <u>$/</u> <u>and</u> <u>$\</u>

       If you change the $/ ($RS, $INPUT_RECORD_SEPARATOR) or $\ ($ORS, $OUTPUT_RECORD_SEPARATOR) or  $,  ($OFS,
       $OUTPUT_FIELD_SEPARATOR)  Mail::Sender may stop working! Keep in mind that those variables are global and
       therefore they change the behaviour of &lt;&gt; and print everywhere.  And since  the  SMTP  is  a  plain  text
       protocol if you change the notion of lines you can break it.

       If  you  have to fiddle with $/, $\ or $, do it in the smallest possible block of code and <u>local()</u>ize the
       change!

               open my $IN, '&lt;', $filename or die "Can't open $filename: $!\n";
               my $data = do {local $/; &lt;$IN&gt;};
               close $IN;

</pre><h4><b>BUGS</b></h4><pre>
       I'm sure there are many. Please let me know if you find any.

       The problem with multiline responses from some SMTP servers (namely qmail) is solved. At last.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       MIME::Lite, MIME::Entity, Mail::Sendmail, Mail::Mailer, ...

       There are lots of mail related modules on CPAN, with different capabilities and interfaces. You  have  to
       find the right one yourself :-)

</pre><h4><b>DISCLAIMER</b></h4><pre>
       This  module  is  based  on  SendMail.pm  Version : 1.21 that appeared in <a href="mailto:Perl-Win32-Users@activeware.com">Perl-Win32-Users@activeware.com</a>
       mailing list. I don't remember the name of the poster and it's not mentioned in the script. Thank you mr.
       "undef".

</pre><h4><b>AUTHOR</b></h4><pre>
       Jan Krynicky &lt;<a href="mailto:Jenda@Krynicky.cz">Jenda@Krynicky.cz</a>&gt; <a href="http://Jenda.Krynicky.cz">http://Jenda.Krynicky.cz</a>

       With help of Rodrigo Siqueira  &lt;<a href="mailto:rodrigo@insite.com.br">rodrigo@insite.com.br</a>&gt;,  Ed  McGuigan  &lt;<a href="mailto:itstech1@gate.net">itstech1@gate.net</a>&gt;,  John  Sanche
       &lt;<a href="mailto:john@quadrant.net">john@quadrant.net</a>&gt;, Brian Blakley &lt;<a href="mailto:bblakley@mp5.net">bblakley@mp5.net</a>&gt;, and others.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 1997-2006 Jan Krynicky &lt;<a href="mailto:Jenda@Krynicky.cz">Jenda@Krynicky.cz</a>&gt;. All rights reserved.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself. There is only one aditional condition, you may NOT use  this  module  for  SPAMing!  NEVER!  (see
       <a href="http://spam.abuse.net/">http://spam.abuse.net/</a> for definition)

perl v5.10.1                                       2008-07-14                                        <u><a href="../man3pm/Sender.3pm.html">Sender</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>