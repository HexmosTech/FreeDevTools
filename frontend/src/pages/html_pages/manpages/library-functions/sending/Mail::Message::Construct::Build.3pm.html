<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mail::Message::Construct::Build - building a Mail::Message from components</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmail-message-perl">libmail-message-perl_3.017-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mail::Message::Construct::Build - building a Mail::Message from components

</pre><h4><b>SYNOPSIS</b></h4><pre>
        my $msg1 = Mail::Message-&gt;build
          ( From =&gt; 'me', data =&gt; "only two\nlines\n");

        my $msg2 = Mail::Message-&gt;buildFromBody($body);

        Mail::Message-&gt;build
          ( From     =&gt; '<a href="mailto:me@myhost.com">me@myhost.com</a>'
          , To       =&gt; '<a href="mailto:you@yourhost.com">you@yourhost.com</a>'
          , Subject  =&gt; "Read our folder!"

          , data     =&gt; \@lines
          , file     =&gt; 'folder.pdf'
          )-&gt;send(via =&gt; 'postfix');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Complex functionality on Mail::Message objects is implemented in different files which are autoloaded.
       This file implements the building of messages from various simpler components.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Constructing</b> <b>a</b> <b>message</b>
       Mail::Message-&gt;<b>build</b>( [$message|$part|$body], $content )
           Simplified  message  object builder.  In case a $message or message $part is specified, a new message
           is created with the same body to start with, but new headers.  A $body  may  be  specified  as  well.
           However, there are more ways to add data simply.

           The  $content  is  a  list  of key-value pairs and header field objects.  The keys which start with a
           capital are used as header-lines.  Lower-cased fields are used for other purposes  as  listed  below.
           Each field may be used more than once.  Pairs where the value is "undef" are ignored.

           If  more than one "data", "file", and "attach" is specified, a multi-parted message is created.  Some
           "Content-*" fields are treated separately: to enforce the content lines of the produced message  body
           <b>after</b> it has been created.  For instance, to explicitly state that you wish a "multipart/alternative"
           in  stead  of  the default "multipart/mixed".  If you wish to specify the type per datum, you need to
           start playing with Mail::Message::Body objects yourself.

           This "build" method will use <b>buildFromBody()</b> when the body object has  been  constructed.   Together,
           they produce your message.

            -Option--Default
             attach  undef
             data    undef
             file    undef
             files   [ ]
             head    undef

           attach =&gt; BODY|PART|MESSAGE|ARRAY
             One  attachment  to  the  message.  Each attachment can be full $message, a $part, or a $body.  Any
             $message will get encapsulated into a "message/rfc822" body.  You can specify many items (may be of
             different types) at once.

              attach =&gt; $folder-&gt;<a href="../man3/message.3.html">message</a>(3)-&gt;decoded  # body
              attach =&gt; $folder-&gt;<a href="../man3/message.3.html">message</a>(3)           # message
              attach =&gt; [ $msg1, $msg2-&gt;<a href="../man6/part.6.html">part</a>(6), $msg3-&gt;body ];

           data =&gt; STRING|ARRAY-OF-LINES
             The text for one part, specified as one STRING, or an ARRAY of lines.   Each  line,  including  the
             last,  must  be terminated by a newline.  This argument is passed to Mail::Message::Body::new(data)
             to construct one.

               data =&gt; [ "line 1\n", "line 2\n" ]     # array of lines
               data =&gt; &lt;&lt;'TEXT'                       # string
              line 1
              line 2
              TEXT

           file =&gt; FILENAME|FILEHANDLE|IOHANDLE|ARRAY
             Create a body where the data is read from the specified FILENAME, FILEHANDLE,  or  object  of  type
             IO::Handle.  Also this body is used to create a Mail::Message::Body. [2.119] You may even pass more
             than one file at once: 'file' and 'files' option are equivalent.

              my $in = IO::File-&gt;new('<a href="file:/etc/passwd">/etc/passwd</a>', 'r');

              file  =&gt; 'picture.jpg'                   # filename
              file  =&gt; \*MYINPUTFILE                   # file handle
              file  =&gt; $in                             # any IO::Handle
              files =&gt; [ 'picture.jpg', \*MYINPUTFILE, $in ]

              open my $in, '&lt;:raw', '<a href="file:/etc/passwd">/etc/passwd</a>';    # alternative for IO::File

           files =&gt; ARRAY-OF-FILE
             Alias for option "file".

           head =&gt; HEAD
             Start with a prepared header, otherwise one is created.

           example:

            my $msg = Mail::Message-&gt;build
             ( From    =&gt; '<a href="mailto:me@home.nl">me@home.nl</a>'
             , To      =&gt; Mail::Address-&gt;new('your name', '<a href="mailto:you@yourplace.aq">you@yourplace.aq</a>')
             , Cc      =&gt; '<a href="mailto:everyone@example.com">everyone@example.com</a>'
             , Subject =&gt; "Let's talk",
             , $other_message-&gt;get('Bcc')

             , data   =&gt; [ "This is\n", "the first part of\n", "the message\n" ]
             , file   =&gt; 'myself.gif'
             , file   =&gt; 'you.jpg'
             , attach =&gt; $signature
             );

            my $msg = Mail::Message-&gt;build
             ( To     =&gt; 'you'
             , 'Content-Type' =&gt; 'text/html'
             , data   =&gt; "&lt;html&gt;&lt;/html&gt;"
             );

       Mail::Message-&gt;<b>buildFromBody</b>($body, [$head], $headers)
           Shape  a  message around a $body.  Bodies have information about their content in them, which is used
           to construct a header for the message.  You may specify a $head object which is  pre-initialized,  or
           one  is  created  for you (also when $head is "undef").  Next to that, more $headers can be specified
           which are stored in that header.

           Header fields are added in order, and before the header lines as defined by the body are taken.  They
           may be supplied as key-value pairs or Mail::Message::Field objects.  In case of a key-value pair, the
           field's name is to be used as key and the value is a string, address (Mail::Address object), or array
           of addresses.

           A "Date", "Message-Id", and "MIME-Version" field are added unless supplied.

           example:

            my $type = Mail::Message::Field-&gt;new('Content-Type', 'text/html'
              , 'charset="us-ascii"');

            my @to   = ( Mail::Address-&gt;new('Your name', '<a href="mailto:you@example.com">you@example.com</a>')
                       , '<a href="mailto:world@example.info">world@example.info</a>'
                       );

            my $msg  = Mail::Message-&gt;buildFromBody
              ( $body
              , From =&gt; '<a href="mailto:me@example.nl">me@example.nl</a>'
              , To   =&gt; \@to
              , $type
              );

</pre><h4><b>DETAILS</b></h4><pre>
   <b>Building</b> <b>a</b> <b>message</b>
       <u>Rapid</u> <u>building</u>

       Most messages you need to construct are relatively simple.  Therefore, this module provides a  method  to
       prepare a message with only one method call: <b>build()</b>.

       <u>Compared</u> <u>to</u> <u><b>MIME::Entity::build()</b></u>

       The  "build"  method in MailBox is modelled after the "build" method as provided by MIMETools, but with a
       few simplifications:

       When a keys starts with a capital, than it is always a header field
       When a keys is lower-cased, it is always something else
       You use the real field-names, not abbreviations
       All field names are accepted
       You may specify field objects between key-value pairs
       A lot of facts are auto-detected, like content-type and encoding
       You can create a multipart at once

       Hum, reading the list above... what is equivalent?  MIME::Entity is not that  simple  after  all!   Let's
       look at an example from MIME::Entity's manual page:

        ### Create the top-level, and set up the mail headers:
        $top = MIME::Entity-&gt;build(Type     =&gt; "multipart/mixed",
                                   From     =&gt; '<a href="mailto:me@myhost.com">me@myhost.com</a>',
                                   To       =&gt; '<a href="mailto:you@yourhost.com">you@yourhost.com</a>',
                                   Subject  =&gt; "Hello, nurse!");

        ### Attachment #1: a simple text document:
        $top-&gt;attach(Path=&gt;"./testin/short.txt");

        ### Attachment #2: a GIF file:
        $top-&gt;attach(Path        =&gt; "./docs/mime-sm.gif",
                     Type        =&gt; "image/gif",
                     Encoding    =&gt; "base64");

        ### Attachment #3: text we'll create with text we have on-hand:
        $top-&gt;attach(Data =&gt; $contents);

       The MailBox equivalent could be

        my $msg = Mail::Message-&gt;build
          ( From     =&gt; '<a href="mailto:me@myhost.com">me@myhost.com</a>'
          , To       =&gt; '<a href="mailto:you@yourhost.com">you@yourhost.com</a>'
          , Subject  =&gt; "Hello, nurse!"

          , file     =&gt; "./testin/short.txt"
          , file     =&gt; "./docs/mime-sm.gif"
          , data     =&gt; $contents
          );

       One  of  the  simplifications  is  that  MIME::Types is used to lookup the right content type and optimal
       transfer encoding.  Good values for content-disposition and such are added as well.

       <u>build,</u> <u>starting</u> <u>with</u> <u>nothing</u>

       See <b>build()</b>.

       <u>buildFromBody,</u> <u>body</u> <u>becomes</u> <u>message</u>

       See <b>buildFromBody()</b>.

       <u>The</u> <u>Content-*</u> <u>fields</u>

       The various "Content-*" fields are not as harmless as they look.  For instance, the "Content-Type"  field
       will have an effect on the default transfer encoding.

       When a message is built this way:

        my $msg = Mail::Message-&gt;build
         ( 'Content-Type' =&gt; 'video/mpeg3'
         , 'Content-Transfer-Encoding' =&gt; 'base64'
         , 'Content-Disposition' =&gt; 'attachment'
         , file =&gt; '<a href="file:/etc/passwd">/etc/passwd</a>'
         );

       then  first a "text/plain" body is constructed (MIME::Types does not find an extension on the filename so
       defaults to "text/plain"), with no encoding.  Only when that body is ready, the new  type  and  requested
       encodings are set.  The content of the body will get base64 encoded, because it is requested that way.

       What basically happens is this:

        my $head = ...other header lines...;
        my $body = Mail::Message::Body::Lines-&gt;new(file =&gt; '<a href="file:/etc/passwd">/etc/passwd</a>');
        $body-&gt;type('video/mpeg3');
        $body-&gt;transferEncoding('base64');
        $body-&gt;disposition('attachment');
        my $msg  = Mail::Message-&gt;buildFromBody($body, $head);

       A safer way to construct the message is:

        my $body = Mail::Message::Body::Lines-&gt;new
         ( file              =&gt; '<a href="file:/etc/passwd">/etc/passwd</a>'
         , mime_type         =&gt; 'video/mpeg3'
         , transfer_encoding =&gt; 'base64'
         , disposition       =&gt; 'attachment'
         );

        my $msg  = Mail::Message-&gt;buildFromBody
         ( $body
         , ...other header lines...
         );

       In the latter program, you will immediately start with a body of the right type.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Error: Only <b>build()</b> Mail::Message's; they are not in a folder yet
           You may wish to construct a message to be stored in a some kind of folder, but you need to do that in
           two  steps.   First,  create  a  normal  Mail::Message,  and  then add it to the folder.  During this
           <b>Mail::Box::addMessage()</b> process, the message will get <b>coerce()</b>-d into the right message type,  adding
           storage information and the like.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This  module  is  part  of  Mail-Message  distribution  version  3.017, built on April 18, 2025. Website:
       <u><a href="http://perl.overmeer.net/CPAN/">http://perl.overmeer.net/CPAN/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 2001-2025 by [Mark Overmeer &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]. For other contributors see ChangeLog.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.40.1                                       2025-04-25               <u>Mail::Message::Construct::<a href="../man3pm/Build.3pm.html">Build</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>