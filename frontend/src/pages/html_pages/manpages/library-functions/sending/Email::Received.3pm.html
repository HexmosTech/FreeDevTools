<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email::Received - Parse an email Received: header</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libemail-received-perl">libemail-received-perl_1.00-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Email::Received - Parse an email Received: header

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Email::Received;

         for ($mail-&gt;header("Received")) {
           my $data = parse_received($_);
           return "SPAM" if rbl_lookup($data-&gt;{ip});
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is a Perl Email Project rewrite of SpamAssassin's email header parser. We did this so that
       the great work they did in analysing pretty much every possible Received header format could be used in
       applications other than SpamAssassin itself.

       The module provides one function, "parse_received", which takes a single Received line. It then produces
       either nothing, if the line is unparsable, a hash reference like this:

           { reason =&gt; "gateway noise" }

       if the line should be ignored for some good reason, and one like this:

          { ip =&gt; '64.12.136.4', id =&gt; '875522', by =&gt; 'xxx.com',
            helo =&gt; 'imo-m01.mx.aol.com' }

       if it parsed the message. Possible keys are:

           ip rdns helo ident envfrom auth by id

</pre><h4><b>RULE</b> <b>FORMAT</b></h4><pre>
       Where SpamAssassin used a big static subroutine full of regular expressions to parse the data, we build
       up a big subroutine full of regular expressions dynamically from a set of rules. The rules are stored at
       the bottom of this module. The basic format for a rule looks like this:

           ((var=~)?/REGEXP/)? [ACTION; ]+

       The "ACTION" is either "SET variable = $value", "IGNORE "reason"?", "UNPARSABLE" or "DONE".

       One control structure is provided, which is basically an "if" statement:

           GIVEN (NOT)? /REGEXP/ {
               ACTION+
           }

   <b>EXPORT</b>
       parse_received

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mail::SpamAssassin::Message::Metadata::Received, from which the rules and some of the IP address matching
       constants were blatantly stolen. Thanks, guys, for doing such a comprehensive job!

</pre><h4><b>AUTHOR</b></h4><pre>
       simon, &lt;simon@&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2006 by simon

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself, either Perl version 5.8.7 or, at your option, any later version of Perl 5 you may have available.

perl v5.36.0                                       2022-12-12                               <u>Email::<a href="../man3pm/Received.3pm.html">Received</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>