<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mail::MboxParser::Mail - Provide mail-objects and methods upon</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmail-mboxparser-perl">libmail-mboxparser-perl_0.55-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mail::MboxParser::Mail - Provide mail-objects and methods upon

</pre><h4><b>SYNOPSIS</b></h4><pre>
       See Mail::MboxParser for an outline on usage. Examples however are also provided in this manpage further
       below.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mail::MboxParser::Mail objects are usually not created directly though, in theory, they could be. A
       description of the provided methods can be found in Mail::MboxParser.

       However, go on reading if you want to use methods from MIME::Entity and learn about overloading.

</pre><h4><b>METHODS</b></h4><pre>
       <b>new(header,</b> <b>body)</b>
           This is usually not called directly but instead by "get_messages()". You could however create a mail-
           object  manually  providing  the  header  and  body  each  as  either  one  string or as an array-ref
           representing the lines.

           Here is a common scenario: Retrieving mails from  a  remote  POP-server  using  Mail::POP3Client  and
           directly feeding each mail to "Mail::MboxParser::Mail-&gt;new":

               use Mail::POP3Client;
               use Mail::MboxParser::Mail;

               my $pop = new Mail::POP3Client (...);

               for my $i (1 .. $pop-&gt;Count) {
                   my $msg = Mail::MboxParser::Mail-&gt;new( [ $pop-&gt;Head($i) ],
                                                          [ $pop-&gt;Body($i) ] );
                   $msg-&gt;store_all_attachments( path =&gt; '/home/user/dump' );
               }

           The above effectively behaves like an attachment-only retriever.

       <b>header</b>
           Returns  the mail-header as a hash-ref with header-fields as keys. All keys are turned to lower-case,
           so $header{Subject} has to be written as $header{subject}.

           If a header-field occurs more than once in the header, the value of the key is an array_ref. Example:

               my $field = $msg-&gt;header-&gt;{field};
               print $field-&gt;[0]; # first occurance of 'field'
               print $field-&gt;[1]; # second one
               ...

       <b>from_line</b>
           Returns the "From "-line of the message.

       <b>trace</b>
           This method returns the "Received: "-lines of the message as a list.

       <b>body</b>
       <b>body(n)</b>
           Returns a Mail::MboxParser::Mail::Body object. For methods upon that see further below.  When  called
           with the argument n, the n-th body of the message is retrieved. That is, the body of the n-th entity.

           Sets "$mail-&gt;error" if something went wrong.

       <b>find_body</b>
           This  will  return  an  index  number that represents what Mail::MboxParser::Mail considers to be the
           actual (main)-body of an email. This is useful if you don't know about the structure of a message but
           want to retrieve the message's signature for instance:

                   $signature = $msg-&gt;body($msg-&gt;find_body)-&gt;signature;

           Changes are good that find_body does what it is supposed to do.

       <b>make_convertable</b>
           Returns a Mail::MboxParser::Mail::Convertable object. For details on what you can do  with  it,  read
           Mail::MboxParser::Mail::Convertable.

       <b>get_field(headerfield)</b>
           Returns  the  specified raw field from the message header, that is: the fieldname is not stripped off
           nor is any decoding done. Returns multiple lines as needed if the  field  is  "Received"  or  another
           multi-line field.  Not case sensitive.

           "get_field()" always returns one string regardless of how many times the field occured in the header.
           Multiple  occurances  are separated by a newline and multiple whitespaces squeezed to one. That means
           you can process each occurance of the field thusly:

               for my $field ( split /\n/, $msg-&gt;get_field('received') ) {
                   # do something with $field
               }

           Sets "$mail-&gt;error" if the field was not found in which case "get_field()" returns "undef".

       <b>from</b>
           Returns a hash-ref with the two fields 'name' and 'email'. Returns "undef" if empty.  The  name-field
           does not necessarily contain a value either. Example:

                   print $mail-&gt;from-&gt;{email};

           On  behalf  of  suggestions  I  received from users, <b>from()</b> tries to be smart when 'name'is empty and
           'email' has the form '<a href="mailto:first.name@host.com">first.name@host.com</a>'. In this case, 'name' is set to "First Name".

       <b>to</b>  Returns an array of hash-references of all to-fields in the mail-header. Fields are the same as those
           of "$mail-&gt;from". Example:

                   for my $recipient ($mail-&gt;to) {
                           print $recipient-&gt;{name} || "&lt;no name&gt;", "\n";
                           print $recipient-&gt;{email};
                   }

           The same 'name'-smartness applies here as described under "from()".

       <b>cc</b>  Identical with <b>to()</b> but returning the hash-refed "Cc: "-line.

           The same 'name'-smartness applies here as described under "from()".

       <b>id</b>  Returns the message-id of a message cutting off the leading and trailing '&lt;' and '&gt;' respectively.

       <b>num_entities</b>
           Returns the number of MIME-entities. That is, the number of sub-entitities actually. If 0 is returned
           and you think this is wrong, check "$mail-&gt;log".

       <b>get_entities</b>
       <b>get_entities(n)</b>
           Either returns an array of all MIME::Entity objects or one particular if called with a number. If  no
           entity whatsoever could be found, an empty list is returned.

           "$mail-&gt;log"  instantly  called  after get_entities will give you some information of what internally
           may have failed. If set, this will be an error raised by MIME::Entity but you  don't  need  to  worry
           about it at all. It's just for the record.

       <b>get_entity_body(n)</b>
           Returns the body of the n-th MIME::Entity as a single string, undef otherwise in which case you could
           check "$mail-&gt;error".

       <b>store_entity_body(n,</b> <b>handle</b> <b>=&gt;</b> <b>FILEHANDLE)</b>
           Stores the stringified body of n-th entity to the specified filehandle. That's basically the same as:

            my $body = $mail-&gt;<a href="../man0/get_entity_body.0.html">get_entity_body</a>(0);
            print FILEHANDLE $body;

           and could be shortened to this:

            $mail-&gt;store_entity_body(0, handle =&gt; \*FILEHANDLE);

           It  returns  a  true  value  on  success  and  undef  on  failure. In this case, examine the value of
           $mail-&gt;error since the entity you specified with 'n' might not exist.

       <b>store_attachment(n)</b>
       <b>store_attachment(n,</b> <b>options)</b>
           It is really just a call to store_entity_body but it will take care that the n-th entity really is  a
           saveable attachment. That is, it wont save anything with a MIME-type of, say, text/html or so.

           Unless  further  'options'  have  been  given,  an  attachment  (if found) is stored into the current
           directory under the recommended filename  given  in  the  MIME-header.  'options'  are  specified  in
           key/value pairs:

               key:       | value:        | description:
               ===========|================|===============================
               path       | relative or    | directory to store attachment
               (".")      | absolute       |
                          | path           |
               -----------|----------------|-------------------------------
               encode     | encoding       | Some platforms store files
                          | suitable for   | in e.g. UTF-8. Specify the
                          | Encode::encode | appropriate encoding here and
                          |                | and the filename will be en-
                          |                | coded accordingly.
               -----------|----------------|-------------------------------
               store_only | a compiled     | store only files whose file
                          | regex-pattern  | names match this pattern
               -----------|----------------|-------------------------------
               code       | an anonym      | first argument will be the
                          | subroutine     | $msg-object, second one the
                          |                | index-number of the current
                          |                | MIME-part
                          |                | should return a filename for
                          |                | the attachment
               -----------|----------------|-------------------------------
               prefix     | prefix for     | all filenames are prefixed
                          | filenames      | with this value
               -----------|----------------|-------------------------------
               args       | additional     | this array-ref will be passed
                          | arguments as   | on to the 'code' subroutine
                          | array-ref      | as a dereferenced array

           Example:

                   $msg-&gt;store_attachment(1,
                                       path =&gt; "/home/ethan/",
                                       code =&gt; sub {
                                                   my ($msg, $n, @args) = @_;
                                                   return $msg-&gt;id."+$n";
                                                   },
                                       args =&gt; [ "Foo", "Bar" ]);

           This will save the attachment found in the second entity under the name that consists of the message-
           ID  and  the appendix "+1" since the above code works on the second entity (that is, with index = 1).
           'args' isn't used in this example but should demonstrate how to pass additional arguments. Inside the
           'code' sub, @args equals ("Foo", "Bar").

           If 'path' does not exist, it will try to create the directory for you.

           You can specify to save only files matching a certain pattern. To do that, use the store-only switch:

               $msg-&gt;store_attachment(1, path       =&gt; "/home/ethan/",
                                         store_only =&gt; qr/\.jpg$/i);

           The above will only save files that end on '.jpg', not case-sensitive. You  could  also  use  a  non-
           compiled  pattern  if  you  want, but that would make for instance case-insensitive matching a little
           cumbersome:

               store_only =&gt; '(?i)\.jpg$'

           If you are working on a platform that requires a certain encoding for filenames on disk, you can  use
           the 'encode' option. This becomes necessary for instance on Mac OS X which internally is UTF-8 based.
           If the filename contains 8bit characters (like the German umlauts or French accented characters as in
           'Ã©'),  storing  the  attachment  under  a  non-encoded  name will most likely fail. In this case, use
           something like this:

               $msg-&gt;store_attachment(1, path =&gt; '<a href="file:/tmp">/tmp</a>', encode =&gt; 'utf-8');

           See Encode::Supported for a list of encodings that you may use.

           Returns the filename under which the attachment has been saved. undef is returned in case the  entity
           did  not  contain a saveable attachment, there was no such entity at all or there was something wrong
           with the 'path' you specified. Check "$mail-&gt;error" to find out which of these possibilities apply.

       <b>store_all_attachments</b>
       <b>store_all_attachments(options)</b>
           Walks through an entire mail and stores all apparent attachments. 'options' are exactly the  same  as
           in "store_attachment()" with the same behaviour if no options are given.

           Returns a list of files that have been successfully saved and an empty list if no attachment could be
           extracted.

           "$mail-&gt;error" will tell you possible failures and a possible explanation for that.

       <b>get_attachments</b>
       <b>get_attachments(file)</b>
           This  method  returns a mapping from attachment-names (if those are saveable) to index-numbers of the
           MIME-part that represents this attachment. It returns a hash-reference, the file-names being the  key
           and the index the value:

               my $mapping = $msg-&gt;get_attachments;
               for my $filename (keys %$mapping) {
                   print "$filename =&gt; $mapping-&gt;{$filename}\n";
               }

           If  called  with a string as argument, it tries to look up this filename. If it can't be found, undef
           is returned. In this case you also should have an error-message patiently awaiting you in the  return
           value of "$mail-&gt;error".

           Even though it looks tempting, don't do the following:

               # BAD!

               for my $file (qw/file1.ext file2.ext file3.ext file4.ext/) {
                   print "$file is in message ", $msg-&gt;id, "\n"
                       if defined $msg-&gt;get_attachments($file);
               }

           The  reason is that "get_attachments()" is currently <b>not</b> optimized to cache the filename mapping. So,
           each time you call it on (even the same) message, it will scan it from beginning to end. Better would
           be:

               # GOOD!

               my $mapping = $msg-&gt;get_attachments;
               for my $file (qw/file1.ext file2.ext file3.ext file4.ext/) {
                   print "$file is in message ", $msg-&gt;id, "\n"
                       if exists $mapping-&gt;{$file};
               }

       <b>as_string</b>
           Returns the message as one string. This is the method that string overloading depends  on,  so  these
           two are the same:

               print $msg;

               print $msg-&gt;as_string;

</pre><h4><b>EXTERNAL</b> <b>METHODS</b></h4><pre>
       Mail::MboxParser::Mail  implements  an  autoloader that will do the appropriate type-casts for you if you
       invoke methods from external modules. This, however, currently only works with MIME::Entity. Support  for
       other modules will follow.  Example:

               my $mb = Mail::MboxParser-&gt;new("/home/user/Mail/received");
               for my $msg ($mb-&gt;get_messages) {
                       print $msg-&gt;effective_type, "\n";
               }

       "effective_type()"  is  not  implemented  by  Mail::MboxParser::Mail and thus the corresponding method of
       MIME::Entity is automatically called.

       To learn about what methods might be useful for you, you should read the  "Access"-part  of  the  section
       "PUBLIC  INTERFACE"  in  the  MIME::Entity  manpage.  It may become handy if you have mails with a lot of
       MIME-parts and you not just want to handle binary-attachments but any kind of MIME-data.

</pre><h4><b>OVERLOADING</b></h4><pre>
       Mail::MboxParser::Mail overloads the " " operator. Overloading operators is a fancy feature of  Perl  and
       some  other  languages  (C++ for instance) which will change the behaviour of an object when one of those
       overloaded operators is applied onto it. Here you get the stringified mail when  you  write  $mail  while
       otherwise you'd get the stringified reference: "Mail::MboxParser::Mail=HASH(...)".

</pre><h4><b>VERSION</b></h4><pre>
       This is version 0.55.

</pre><h4><b>AUTHOR</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Tassilo von Parseval &lt;<a href="mailto:tassilo.von.parseval@rwth-aachen.de">tassilo.von.parseval@rwth-aachen.de</a>&gt;

       Copyright  (c)   2001-2005  Tassilo von Parseval.  This program is free software; you can redistribute it
       and/or modify it under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       MIME::Entity

       Mail::MboxParser, Mail::MboxParser::Mail::Body, Mail::MboxParser::Mail::Convertable

perl v5.34.0                                       2022-06-15                              <u>MboxParser::<a href="../man3pm/Mail.3pm.html">Mail</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>