<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mail::Bulkmail::Dynamic - platform independent mailing list module for mail merges and dynamically built</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmail-bulkmail-perl">libmail-bulkmail-perl_3.12-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mail::Bulkmail::Dynamic - platform independent mailing list module for mail merges and dynamically built
       messages

</pre><h4><b>AUTHOR</b></h4><pre>
       Jim Thomason, <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>

</pre><h4><b>SYNOPSIS</b></h4><pre>
        my $bulk = Mail::Bulkmail::Dynamic-&gt;new(
               "merge_keys"            =&gt; [qw(BULK_EMAIL name id address city state zip)],
               "merge_delimiter"       =&gt; "::",
               "LIST"                          =&gt; "<a href="file:~/my.list.txt">~/my.list.txt</a>",
               "From"                          =&gt; "'Jim Thomason'&lt;<a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>&gt;",
               "Subject"                       =&gt; "This is a test message",
               "Message"                       =&gt; "Here is my test message"
        ) || die Mail::Bulkmail-&gt;error();

        $bulk-&gt;bulkmail() || die $bulk-&gt;error;

       Don't forget to set up your conf file!

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mail::Bulkmail 1.00 had a thing called "filemapping", it was to allow you to dynamically populate certain
       variables into your message. Put in people's names, or the like.

       2.00 renamed "filemapping" to the correct term - "mail merging", and also added in the ability to
       dynamically create your message, if so desired. So you could very easily send out completely different
       messages to everyone on your list, if so desired. But 2.00 also added a *lot* of processing overhead,
       most of which was unfortunately in the form of voodoo. i.e., I seem to recall lots of testing, debugging,
       etc. until I finally reached a point where the code worked and I sent it off. Not quite sure how it
       worked, mind you, but happy with the fact that it worked nonetheless.

       3.00 strips that ability out of Mail::Bulkmail, cleans it up, and places it here. This has a few
       advantages.  For one thing, if you're not doing any mailmerging, then you don't have to worry about any
       of the overhead of building hashes, doing checks, internally handling things, and so on. There wasn't a
       tremendous amount of useless work done in that case, but it was enough to be noticed. So now use
       Mail::Bulkmail if you're not doing mail merges, and Mail::Bulkmail::Dynamic if you are.

       And the other thing is that the code is cleaned up a <b>lot</b>. I actually know and understand how it all works
       now, and it functions much better than previous versions did. Faster, more efficient, and so on.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       log_all_data
                  boolean flag, 1/0.

                  Mail::Bulkmail has an easy job logging its list items - they're always guaranteed to be single
                  email  addresses.  Mail::Bulkmail::Dynamic  has  a  harder  time,  since it's usually an email
                  address and some other data.

                   '<a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim Thomason::24'
                   or
                   ['<a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>', "Jim Thomason", "24"]
                   or
                   {
                          "BULK_EMAIL" =&gt; '<a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>',
                          "name"           =&gt; "Jim Thomason",
                          "age"            =&gt; "24"
                   }

                  Most of that is obviously not simple scalar data  and  needs  to  be  logged  differently.  If
                  log_all_data  is  set to 0, then only the email address will be logged and everything is fine.
                  However, if log_all_data is 1,  then  a  hashref  containing  all  of  the  data  is  returned
                  (regardless  of  the type of data structure you initially handed in). Obviously, you will then
                  need to deal with logging yourself, either by logging to an arrayref or (better) to a function
                  call. Logging to a file with log_all_data set to 1 will  just  give  you  a  useless  list  of
                  "<a href="../man0x7482/HASH.0x7482.html">HASH</a>(0x7482)" and the like.

                  All  pieces  may  be  used  simultaneously.  So  in  one  mailing,  you  can  use  merge_keys,
                  dynamic_message_data, dynamic_header_data, and global_merge.

       merge_keys This should be much easier to use and understand than it was in prior versions.

                  Okay, let's start off with the simple case, you have a file that  contains  a  list  of  email
                  addresses:

                   <a href="mailto:foo@bar.com">foo@bar.com</a>
                   <a href="mailto:bob@hope.com">bob@hope.com</a>
                   <a href="mailto:john@junior.com">john@junior.com</a>

                  And  you  set  up  a  list with Mail::Bulkmail to mail to them. Your message is something like
                  this:

                   "Hi there. Things are great in my world, how's yours?"

                  This works fine for a while, people are happy, everything's dandy. But then, you  decide  that
                  it  would  be  nice  to  personalize  your  email  messages  in some fashion. So you switch to
                  Mail::Bulkmail::Dynamic.  You'll need more information in your list of addresses now.

                   <a href="mailto:foo@bar.com">foo@bar.com</a>::Mr. Foo
                   <a href="mailto:me@there.com">me@there.com</a>::Bob Hope
                   <a href="mailto:john@junior.com">john@junior.com</a>::John Jr.

                  And then you'll need to define your merge_keys. merge_keys is an arrayref that defines how the
                  data in your file is structured:

                   merge_keys =&gt; [qw(BULK_EMAIL &lt;&lt;NAME&gt;&gt;)]

                  That tells Mail::Bulkmail::Dynamic that the first item in your list is the email address,  and
                  the  second  one is your name. Please note that the email address <b>MUST</b> be called "BULK_EMAIL",
                  that's the keyword that the module looks for to find the address to send to. The rest of  your
                  keys  may  be  named anything you'd like, but avoid naming keys starting with "BULK_", because
                  those are reserved for my use internally and I may add more special  keys  like  that  in  the
                  future.

                  (You'll  also need to make sure that your merge_delimiter is set to "::", see merge_delimiter,
                  below).

                  Now you can change your message to the following:

                   "Hi there, &lt;&lt;NAME&gt;&gt;. Things are great in my world, how's yours?"

                  This will send out the messages, respectively:

                   Hi there, Mr. Foo. Things are great in my world, how's yours?

                   Hi there, Bob Hope. Things are great in my world, how's yours?

                   Hi there, John Junior. Things are great in my world, how's yours?

                  And voila. Customization. you may include as much data as you'd like:

                   merge_keys = [qw(&lt;&lt;NAME&gt;&gt; BULK_EMAIL &lt;&lt;STATE&gt;&gt; &lt;&lt;AGE&gt;&gt; &lt;&lt;HOBBY&gt;&gt; &lt;&lt;PREFERRED COMPUTER&gt;&gt;)]

                   #in your list:
                   Jim Thomason::<a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::IL::24::Programming Perl::titanium powerbook

                   #and then your message.

                   Dear &lt;&lt;NAME&gt;&gt;,
                   How've you been? I see that your email address is still BULK_EMAIL.
                   Are you still living in &lt;&lt;STATE&gt;&gt;? And you're still &lt;&lt;AGE&gt;&gt;, right?

                   Do you still enjoy &lt;&lt;HOBBY&gt;&gt;?
                   Well, email me back a message from your &lt;&lt;PREFERRED COMPUTER&gt;&gt;.

                  And that's all there is to it. Just be sure to remember that any  keys  you  define  will  get
                  clobbered *anywhere* in the message.

                   merge_keys =&gt; [qw(BULK_EMAIL name)]
                   LIST =&gt; [qw(<a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim)]

                   "Hi there, name. I've always liked your name."

                  You *probably* want that message to populate as:

                   "Hi there, Jim. I've always liked your name."

                  But it will populate as:

                   "Hi there, Jim. I've always liked your Jim."

                  Which  doesn't  make  sense. So just make sure your keys aren't anywhere else in your message.
                  For example,

                   merge_keys =&gt; [qw(BULK_EMAIL &lt;name&gt;)]
                   LIST =&gt; [qw(<a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim)]

                   "Hi there, &lt;name&gt;. I've always liked your name."

                  Your list data may be a delimited scalar, as we've been using in our examples:

                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim::24

                  Or an arrayref:

                   ['<a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>', 'Jim', '24']

                  In both of those cases, the order of the data is important. Each data element matches up to  a
                  particular  key.  So  be  sure that your data is actually in the same order as defined in your
                  merge_keys array.

                  Alternatively, you can also just store your data in a hash and pass that in:

                   {
                          'BULK_EMAIL'    =&gt; '<a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>',
                          '&lt;name&gt;'                =&gt; 'Jim',
                          '&lt;age&gt;'                 =&gt; '24'
                   }

                  This is the one case where your merge_keys values will be ignored, and  a  mailmerge  will  be
                  done with the key/value pairs passed in that hashtable.

                  Passing  in  a  hashtable  is  the  fastest  in terms of internal processing, but there may be
                  additional work on your end to generate the hash. When reading from a file, you should  always
                  use delimited strings (since that's what'd be in your file anyway), but from other sources you
                  can experiment with hashrefs or arrayrefs and see which is faster for your uses.

                  mail merges apply to <b>both</b> message <b>and</b> header information. So it's valid to do:

                   $dynamic-&gt;Subject("Hello there, &lt;name&gt;");

                  And have the mail merge pick that up.

                  Note  that  the merge will be performed in an arbitrary order, independent of what's specified
                  in merge_keys. So don't expect to have one piece of  the  merge  populate  into  your  message
                  before another one.

       merge_delimiter
                  If  you're  reading  in  from a file, you can't have arrayrefs, hashrefs, whatever. They don't
                  store nicely in text. So your data will probably be a delimited string. In that case, you need
                  to know the delimiter.  Set it with merge_delimiter.

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim

                   #then
                   $dynamic-&gt;merge_delimiter("::");

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>-+-Jim

                   #then
                   $dynamic-&gt;merge_delimiter('-+-');

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>,Jim

                   #then
                   $dynamic-&gt;merge_delimiter(',');

                  Just be sure that your delimiting string occurs *only* as the delimiter and is never  embedded
                  in your data.  No escaping of a delimiter is possible.

       global_merge
                  It  can  be  useful to to do a mail merge with non-address specific data. For example, you may
                  want to put today's date in your subject. But it's silly (if not impossible) to populate  that
                  data out to all of your addresses. This is where the global_merge comes in.

                   $dynamic-&gt;global_merge(
                          {
                                  "&lt;DATE&gt;" =&gt; scalar localtime
                          }
                   );

                   or, at creation:

                   my $dynamic = Mail::Bulkmail::Dynamic-&gt;new(
                          "global_merge" =&gt; {
                                  "&lt;DATE&gt;" =&gt; scalar localtime
                          }
                   );

                  &lt;DATE&gt; will now change to today's date in your message.

                   "Hello, list member. This is the list for &lt;DATE&gt;"

                  This is a hash table that populates merge data <b>before</b> individual mail merge items. There is no
                  way to use the same key for both a global_merge and a per-address merge. The global merge will
                  always pick it up and the individual merge will miss it. So, as always, use different keys.

       dynamic_message_data
                  Mail merges are all well and good, they store unique information about a unique email address.
                  But  sometimes  you  want  to  group together several users and send them the same information
                  based upon some other criteria.  That's where dynamic_message_data comes in handy.

                  This is probably  easiest  explained  via  examples.  dynamic_message_data  is  a  hashref  of
                  hashrefs, such as this:

                   $dynamic-&gt;dynamic_message_data(
                          {
                                  '&lt;agegroup&gt;' =&gt; {
                                          'over70'        =&gt; 'napping',
                                          '40-50'         =&gt; 'amassing wealth',
                                          '20-40'         =&gt; 'working',
                                          'under20'       =&gt; 'playing'
                                  },
                                  '&lt;animallover&gt;' =&gt; {
                                          'hates_animals' =&gt; "I see you hate animals.",
                                          "likes_animals" =&gt; "I see you like animals.",
                                          "loves_animals" =&gt; "I see you love animals."
                                  },
                                  '&lt;personalized&gt;' =&gt; {
                                          'yes'   =&gt; 'Hi there, &lt;name&gt;',
                                          'no'    =&gt; 'Hi there'
                                  }
                          }
                   );

                  Now then, your merge keys could be defined as such:

                   -&gt;merge_keys([qw(BULK_EMAIL &lt;name&gt; &lt;age&gt; BULK_DYNAMIC_MESSAGE)]);

                  Your list would be:

                   <a href="mailto:foo@bar.com">foo@bar.com</a>::Mr. Foo::23::&lt;agegroup&gt;=20-40;&lt;animallover&gt;=hates_animals;&lt;personalized&gt;=yes
                   <a href="mailto:me@there.com">me@there.com</a>::Bob Hope::78::&lt;agegroup&gt;=over70;&lt;animallover&gt;=likes_animals;&lt;personalized&gt;=no
                   <a href="mailto:john@junior.com">john@junior.com</a>::John Jr.::14::&lt;agegroup&gt;=under20;&lt;animallover&gt;=likes_animals;&lt;personalized&gt;=yes

                  And finally, your message would be:

                   &lt;personalized&gt;. Judging by your age, which is &lt;age&gt;, you should enjoy &lt;agegroup&gt;.
                   Oh, and &lt;animallover&gt;

                  The messages sent out would be, respectively:

                   Hi there, Mr. Foo. Judging by your age, which is 23, you should enjoy working.
                   Oh, and I see you hate animals.

                   Hi there. Judging by your age, which is 78, you should enjoy napping.
                   Oh, and I see you like animals.

                   Hi there, John Jr.. Judging by your age, which is 14, you should enjoy playing.
                   Oh, and I see you like animals.

                  See?   easy  as  pie.  Your  dynamic  message  should  be  specified  in  your  merge_keys  as
                  BULK_DYNAMIC_MESSAGE, and should be a delimited string (in this case).

                   agegroup=20-40;&lt;animallover&gt;=hates_animals;&lt;personilized&gt;=yes

                  You   can   specify   what   delimiters   you'd   like   to   use.   In   this   case,    your
                  dynamic_message_delimiter is ';', and your dynamic_message_value_delimiter is '='.

                  More clearly, this information translates to the following:

                   &lt;agegroup&gt;             =&gt; 20-40
                   &lt;animallover&gt;  =&gt; hates_animals
                   &lt;personilized&gt; =&gt; yes

                  Please  note  that  angle  brackets  are  not required, they're just useful for clarity in our
                  example.  This is also perfectly acceptable:

                   $dynamic-&gt;dynamic_message_data(
                          {
                                  'agegroup' =&gt; {
                                          'over70'        =&gt; 'napping',
                                          '40-50'         =&gt; 'amassing wealth',
                                          '20-40'         =&gt; 'working',
                                          'under20'       =&gt; 'playing'
                                  }
                          }
                   );

                    <a href="mailto:me@there.com">me@there.com</a>::Bob Hope::78::agegroup=over70

                  As long as you use the same keys, you're fine.

                  So you should be able to easily see that we'll look up the message associated  with  being  in
                  the agegroup of 20-40, the animallover that hates_animals, and then personilized with a choice
                  of 'yes'.

                  Dynamic message creation is done before mail merging, so you are more than welcome to put mail
                  merge  tokens  inside  your  dynamic message, as we did above with the "&lt;personalized&gt;" token,
                  which may include the mail merge token of "&lt;name&gt;".

                  Don't use the same tokens for mailmerges and  dynamic  messages,  since  the  system  may  get
                  confused.

                  Alternatively, instead of a delimited string, you may pass in an arrayref of strings:

                   [qw(agegroup=20-40 &lt;animallover&gt;=hates_animals &lt;personilized&gt;=yes)]

                  or an arrayref of arrayrefs:

                   [[qw(agegroup 20-40)], [qw(&lt;animallover&gt; hates_animals)], [qw(&lt;personlized&gt; yes)]]

                  or a hashref:

                   {
                           agegroup               =&gt; 20-40
                           animallover    =&gt; hates_animals
                           personilized   =&gt; yes
                   }

                  Passing  in  a  hashtable  is  the  fastest  in terms of internal processing, but there may be
                  additional work on your end to generate the hash. When reading from a file, you should  always
                  use delimited strings (since that's what'd be in your file anyway), but from other sources you
                  can experiment with hashrefs or arrayrefs and see which is faster for your uses.

                  dynamic messages apply to <b>only</b> message information. use dynamic_header_data for dynamic pieces
                  in headers.

                  Note  that  the  dynamic  message  creation  will be performed in an arbitrary order. So don't
                  expect to have one piece of the dynamic message populate into your message before another one.

                  There is one special key for dynamic_message_data, "_default".

                   $dynamic-&gt;dynamic_message_data(
                          {
                                  '&lt;agegroup&gt;' =&gt; {
                                          'over70'        =&gt; 'napping',
                                          '40-50'         =&gt; 'amassing wealth',
                                          '20-40'         =&gt; 'working',
                                          'under20'       =&gt; 'playing',
                                          '_default'      =&gt; 'You have not specified an age group'
                                  },
                                  '&lt;animallover&gt;' =&gt; {
                                          'hates_animals' =&gt; "I see you hate animals.",
                                          "likes_animals" =&gt; "I see you like animals.",
                                          "loves_animals" =&gt; "I see you love animals.",
                                          "_default"              =&gt; "I don't know how you feel about animals"
                                  },
                                  '&lt;personalized&gt;' =&gt; {
                                          'yes'   =&gt; 'Hi there, &lt;name&gt;',
                                          'no'    =&gt; 'Hi there',
                                  }
                          }
                   );

                  It should be fairly obvious - if that key is not specified, then the _default value  is  used.
                  Using our earlier example, with the following list:

                   <a href="mailto:foo@bar.com">foo@bar.com</a>::Mr. Foo::23::&lt;agegroup&gt;=20-40

                  And the same message of:

                   &lt;personalized&gt;. Judging by your age, which is &lt;age&gt;, you should enjoy &lt;agegroup&gt;.
                   Oh, and &lt;animallover&gt;

                  The messages sent out would be, respectively:

                   . Judging by your age, which is 23, you should enjoy working.
                   Oh, and I don't know how you feel about animals.

                  Note  that  since  &lt;agegroup&gt;  was  specified, we used that value. Since &lt;animallover&gt; was not
                  specified, the default was used, and  since  &lt;personalized&gt;  was  not  specified  and  has  no
                  default, it was simply wiped out.

       dynamic_message_delimiter
                  If  you're  reading  in  from a file, you can't have arrayrefs, hashrefs, whatever. They don't
                  store nicely in text. So your data will probably be a delimited string. In that case, you need
                  to know the delimiter.  Set it with dynamic_message_delimiter. Note that your dynamic  message
                  data  is  just  an  entry  in  your  merge  data. We'll assume a merge_delimiter of '::' and a
                  dynamic_message_value_delimiter of '=' for these examples

                   -&gt;merge_keys([qw(BULK_EMAIL &lt;name&gt; BULK_DYNAMIC_MESSAGE)]);

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim::agegroup=20-40;animallover=yes

                   #then
                   $dynamic-&gt;dynamic_message_delimiter(";");

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim::agegroup=20-40&amp;animallover=yes

                   #then
                   $dynamic-&gt;dynamic_message_delimiter('&amp;');

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim::agegroup=20-40,,animallover=yes

                   #then
                   $dynamic-&gt;dynamic_message_delimiter(',,');

                  Just be sure that your delimiting string occurs *only* as the delimiter and is never  embedded
                  in your data.  No escaping of a delimiter is possible.

       dynamic_message_value_delimiter
                  If  you're  reading  in  from a file, you can't have arrayrefs, hashrefs, whatever. They don't
                  store nicely in text. So your data will probably be a delimited string. In that case, you need
                  to know the delimiter.  Set it with dynamic_message_delimiter. Note that your dynamic  message
                  data  is  just  an  entry  in  your  merge  data. We'll assume a merge_delimiter of '::' and a
                  dynamic_message_delimiter of ';' for these examples

                   -&gt;merge_keys([qw(BULK_EMAIL &lt;name&gt; BULK_DYNAMIC_MESSAGE)]);

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim::agegroup=20-40;animallover=yes

                   #then
                   $dynamic-&gt;dynamic_message_value_delimiter("=");

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim::agegroup:=20-40;animallover:=yes

                   #then
                   $dynamic-&gt;dynamic_message_value_delimiter(':=');

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim::agegroup--20-40;animallover--yes

                   #then
                   $dynamic-&gt;dynamic_message_value_delimiter('--');

                  Just be sure that your delimiting string occurs *only* as the delimiter and is never  embedded
                  in your data.  No escaping of a delimiter is possible.

       dynamic_header_data
                  Mail merges are all well and good, they store unique information about a unique email address.
                  But  sometimes  you  want  to  group together several users and send them the same information
                  based  upon  some  other  criteria.   That's  where  dynamic_message_data  comes   in   handy.
                  dynamic_header_data  is  virtually identical to dynamic_message_data in terms of behavior, but
                  it operates on the message header instead of the message instelf.

                  This is probably easiest explained via examples. dynamic_header_data is a hashref of hashrefs,
                  such as this:

                   $dynamic-&gt;dynamic_header_data(
                          {
                                  'Subject' =&gt; {
                                          'polite'        =&gt; "Hello, sir",
                                          "impolite"      =&gt; "Hello",
                                          "rude"          =&gt; "Hey, jerk-off"
                                  },
                                  'Reply-To' =&gt; {
                                          'useful'                =&gt; '<a href="mailto:return@myaddress.com">return@myaddress.com</a>',
                                          'semiuseful'    =&gt; '<a href="mailto:filteredreturn@myaddress.com">filteredreturn@myaddress.com</a>',
                                          'useless'               =&gt; '<a href="mailto:nowhere@noemail.com">nowhere@noemail.com</a>'
                                  },
                                  'X-Type' =&gt; {
                                          'premium'               =&gt; "All Services are available",
                                          "gold"                  =&gt; "Most servies are available",
                                          "none"                  =&gt; "No services are available"
                                  }
                          }
                   );

                  Now then, your merge keys could be defined as such:

                   -&gt;merge_keys([qw(BULK_EMAIL &lt;name&gt; &lt;age&gt; BULK_DYNAMIC_MESSAGE BULK_DYNAMIC_HEADERS)]);

                  Your list would be:

                   <a href="mailto:foo@bar.com">foo@bar.com</a>::Mr. Foo::23::agegroup=20-40;animallover=hates_animals;personalized=yes::Subject=polite;Reply-To:useful;X-Type:gold
                   <a href="mailto:me@there.com">me@there.com</a>::Bob Hope::78::agegroup=over70;animallover=likes_animals;personalized=no::Subject=rude;Reply-To:useful;X-Type:premium
                   <a href="mailto:john@junior.com">john@junior.com</a>::John Jr.::14::agegroup=under20;animallover=likes_animals;personalized=yes::Subject=impolite;Reply-To:useless;X-Type:none

                  The messages sent out would have the following headers, respectively:

                   Subject : Hello, sir
                   Reply-To: <a href="mailto:return@myaddress.com">return@myaddress.com</a>
                   X-Type  : Most services are available

                   Subject : Hey, jerk-off
                   Reply-To: <a href="mailto:return@myaddress.com">return@myaddress.com</a>
                   X-Type  : All Services are available

                   Subject : Hello
                   Reply-To: <a href="mailto:nowhere@noemail.com">nowhere@noemail.com</a>
                   X-Type  : No services are available

                  See?  easy  as  pie.  Your  dynamic  headers  should  be  specified  in  your  merge_keys   as
                  BULK_DYNAMIC_HEADERS, and should be a delimited string (in this case).

                  Subject=polite;Reply-To=useful;X-Type=gold

                  You can specify what delimiters you'd like to use. In this case, your dynamic_header_delimiter
                  is ';', and your dynamic_header_value_delimiter is '='.

                  More clearly, this information translates to the following:

                   Subject                =&gt; polite
                   Reply-To               =&gt; useful
                   X-Type                 =&gt; gold

                  Note  that  unlike  dynamic_message_data, the key in this case is not used to substitute out a
                  string in your headers (or message), the key is used to name the header that  is  appended  on
                  the message.

                  Dynamic  header creation is done before mail merging, so you are more than welcome to put mail
                  merge tokens inside your dynamic headers.

                  Don't use the same tokens for mailmerges  and  dynamic  headers,  since  the  system  may  get
                  confused.

                  Alternatively, instead of a delimited string, you may pass in an arrayref of strings:

                   [qw(Subject=polite Reply-To=useful X-Type:gold)]

                  or an arrayref of arrayrefs:

                   [[qw(Subject polite)], [qw(Reply-To useful)], [qw(X-Type gold)]]

                  or a hashref:

                   {
                           Subject                =&gt; polite
                           Reply-To               =&gt; useful
                           X-Type                 =&gt; gold
                   }

                  Passing  in  a  hashtable  is  the  fastest  in terms of internal processing, but there may be
                  additional work on your end to generate the hash. When reading from a file, you should  always
                  use delimited strings (since that's what'd be in your file anyway), but from other sources you
                  can experiment with hashrefs or arrayrefs and see which is faster for your uses.

                  dynamic  headers apply to <b>only</b> header information. use dynamic_message_data for dynamic pieces
                  in messages.

                  Note that the dynamic header creation will be performed in an arbitrary order. So don't expect
                  to have one piece of the dynamic header populate into your message before another one.

                  There is one special key for dynamic_header_data, "_default".

                   $dynamic-&gt;dynamic_message_data(
                          {
                                  'Subject' =&gt; {
                                          'polite'        =&gt; "Hello, sir",
                                          "impolite"      =&gt; "Hello",
                                          "rude"          =&gt; "Hey, jerk-off",
                                          '_default'      =&gt; "Default subject",
                                  },
                                  'Reply-To' =&gt; {
                                          'useful'                =&gt; '<a href="mailto:return@myaddress.com">return@myaddress.com</a>',
                                          'semiuseful'    =&gt; '<a href="mailto:filteredreturn@myaddress.com">filteredreturn@myaddress.com</a>',
                                          'useless'               =&gt; '<a href="mailto:nowhere@noemail.com">nowhere@noemail.com</a>',
                                          '_default"              =&gt; '<a href="mailto:reply@to.com">reply@to.com</a>'
                                  },
                                  'X-Type' =&gt; {
                                          'premium'               =&gt; "All Services are available",
                                          "gold"                  =&gt; "Most servies are available",
                                          "none"                  =&gt; "No services are available"
                                  }
                          }
                   );

                  Behavior is similar to that of _default in dynamic_message_data. If a header is specified,  it
                  is  used.   If  no value is specified, it will attempt to use the _default value. But, in this
                  case, if there is no value passed and no default, then the header just won't be set. Unless it
                  is one of the speciality headers, such as From. In that  case,  it  will  attempt  a  specific
                  dynamic_message_data  value  for  From,  then the "_default" value in dynamic_message_data for
                  from, and then finally the -&gt;From value itself.

                  If there's a header specified in -&gt;dynamic_header_data, it will be preferred to use  over  one
                  set via -&gt;header.

                  i.e., the order that a header will be checked is:

                   1) Is there a specific header key for the header? (Subject =&gt; polite)
                   2) Is there a default header key for the header? (Subject =&gt; _default)
                   3) Is this a specialty header (i.e., -&gt;From), and is that set? ($bulk-&gt;From())
                   4) Is there a generic, non-dynamic header set? (-&gt;header('Foo'))

                  Headers will not be set more than once, no matter how many places you specify them.

       dynamic_header_delimiter
                  If  you're  reading  in  from a file, you can't have arrayrefs, hashrefs, whatever. They don't
                  store nicely in text. So your data will probably be a delimited string. In that case, you need
                  to know the delimiter.  Set it with dynamic_header_delimiter. Note that  your  dynamic  header
                  data  is  just  an  entry  in  your  merge  data. We'll assume a merge_delimiter of '::' and a
                  dynamic_header_value_delimiter of '=' for these examples

                   -&gt;merge_keys([qw(BULK_EMAIL &lt;name&gt; BULK_DYNAMIC_HEADERS)]);

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim::Subject=polite;Reply-To=useful

                   #then
                   $dynamic-&gt;dynamic_message_delimiter(";");

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim::Subject=polite&amp;Reply-To=useful

                   #then
                   $dynamic-&gt;dynamic_message_delimiter('&amp;');

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim::Subject=polite,,Reply-To=useful

                   #then
                   $dynamic-&gt;dynamic_message_delimiter(',,');

                  Just be sure that your delimiting string occurs *only* as the delimiter and is never  embedded
                  in your data.  No escaping of a delimiter is possible.

       dynamic_header_value_delimiter
                  If  you're  reading  in  from a file, you can't have arrayrefs, hashrefs, whatever. They don't
                  store nicely in text. So your data will probably be a delimited string. In that case, you need
                  to know the delimiter.  Set it with dynamic_header_delimiter. Note that  your  dynamic  header
                  data  is  just  an  entry  in  your  merge  data. We'll assume a merge_delimiter of '::' and a
                  dynamic_header_delimiter of ';' for these examples

                   -&gt;merge_keys([qw(BULK_EMAIL &lt;name&gt; BULK_DYNAMIC_HEADERS)]);

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim::Subject=polite;Reply-To=useful

                   #then
                   $dynamic-&gt;dynamic_message_value_delimiter("=");

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim::Subject:=polite;Reply-To:=useful

                   #then
                   $dynamic-&gt;dynamic_message_value_delimiter(':=');

                   #in your list
                   <a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>::Jim::Subject--polite;Reply-To--useful

                   #then
                   $dynamic-&gt;dynamic_message_value_delimiter('--');

                  Just be sure that your delimiting string occurs *only* as the delimiter and is never  embedded
                  in your data.  No escaping of a delimiter is possible.

       quotemeta  boolean flag. 1/0

                  While mailmerging, you can specify keys that would contain regex meta data.

                  For example:

                   -&gt;merge_keys [qw(*name* BULK_EMAIL)]

                  Would  generate  an  error,  because  the  *  character  has  special meaning to a regex. With
                  quotemeta turned on, you can use that as a token because it will be quoted when  used  in  the
                  regex.

                  It  is  <b>highly</b>  recommended  that you leave quotemeta set to 1. Set it to 0 only if you really
                  know what you're doing.

       use_envelope
                  In this subclass, use_envelope is a method that will always return 0.

                  For Dynamic messages, it's impossible to use the envelope. Sorry, gang, if  you  want  to  use
                  mail merges, then you can't use the added speed that the envelope provides you with.

                  And  it  only  makes  sense, because envelope sending sends the exact same message to multiple
                  people.  If you're doing a mail merge, then you're customizing each message,  so  it  wouldn't
                  make sense to send that thing to multiple people.

                  For raw speed, use Mail::Bulkmail and use_envelope =&gt; 1. For mail merges, use this.

</pre><h4><b>METHODS</b></h4><pre>
       extractEmail
                  extractEmail  is  an  overridden  method  from Mail::Bulkmail. Most of the time when you're in
                  Mail::Bulkmail::Dynamic, the data structure that's passed around internally is a hashref,  and
                  the email address is at the key BULK_EMAIL.

                  This  extracts  that  key  and  returns  it.  Again, this method is used internally and is not
                  something you need to worry about.

                  This method is known to be able to return:

                   MBD001 - no BULK_EMAIL defined

       extractSender
                  extractSender is an overridden method from Mail::Bulkmail. Most of the  time  when  you're  in
                  Mail::Bulkmail::Dynamic,  the data structure that's passed around internally is a hashref, and
                  the sender is at the key BULK_SENDER.

                  This extracts that key and returns it. Again, this  method  is  used  internally  and  is  not
                  something you need to worry about.

                  This method is known to be able to return:

                   MBD015 - no BULK_SENDER defined

       extractReplyTo
                  extractReplyTo  is  an  overridden method from Mail::Bulkmail. Most of the time when you're in
                  Mail::Bulkmail::Dynamic, the data structure that's passed around internally is a hashref,  and
                  the email address is at the key BULK_REPLYTO.

                  This  extracts  that  key  and  returns  it.  Again, this method is used internally and is not
                  something you need to worry about.

                  This method is known to be able to return:

                   MBD016 - no BULK_REPLYTO defined

       buildHeaders
                  Another overridden method from Mail::Bulkmail. This one constructs headers and  also  includes
                  any dynamic headers, if they have been specified in BULK_DYNAMIC_HEADERS.

                  And, finally, it will do a mail merge on all headers (first global, then individual).

                  Still called internally and still something you don't need to worry about.

                  This -&gt;buildHeaders cannot accept the optional second headers_hash parameter

                  This method is known to be able to return:

                   MBD013 - cannot bulkmail w/o From
                   MBD014 - cannot bulkmail w/o To

       buildMessage
                  Another  overridden  method  from  Mail::Bulkmail.  This  one  constructs the message and also
                  includes any dynamic message content, if it has been specified in BULK_DYNAMIC_MESSAGE.

                  And, finally, it will do a mail merge on the message (first global, then individual).

                  Still called internally and still something you don't need to worry about.

                  This method is known to be able to return:

                   MBD012 - cannot build message w/o message

       preprocess Overridden from Mail::Bulkmail, preprocesses the data returned  from  getNextLine($bulk-&gt;LIST)
                  and makes sure that Mail::Bulkmail::Dynamic knows how to work with it. Constructs the internal
                  data structures to handle mail merges, dynamic messages, and dynamic headers, for any of those
                  items that are in use.

                  Still called internally and still not something you need to worry about.

       buildMessageHash
                  Given  a  delimited  string,  arrayref,  or  hashref,  formats it according to the information
                  contained in merge_keys and returns it.

                  Called internally, and not something you should worry about.

                  This method is known to be able to return:

                   MBD002 - no merge_delimiter
                   MBD003 - different number of keys and values
                   MBD004 - cannot build merge hash

       buildDynamicMessageHash
                  Given a delimited string, arrayref, or  hashref,  formats  it  according  to  the  information
                  contained in dynamic_message_data and returns it.

                  Called internally, and not something you should worry about.

                  This method is known to be able to return:

                   MBD005 - cannot split w/o dynamic_message_delimiter
                   MBD006 - cannot split w/o dynamic_message_value_delimiter
                   MBD007 - invalid dynamic message key
                   MBD008 - cannot build dynamic message hash

       buildDynamicHeaderHash
                  Given  a  delimited  string,  arrayref,  or  hashref,  formats it according to the information
                  contained in dynamic_header_data and returns it.

                  Called internally, and not something you should worry about.

                  This method is known to be able to return:

                   MBD008 - cannot split w/o dynamic_header_delimiter
                   MBD009 - cannot split w/o dynamic_header_value_delimiter
                   MBD010 - invalid dynamic header key
                   MBD011 - cannot build dynamic header hash

       convert_to_scalar
                  convert_to_scalar is still used exclusively internally here, and you still don't need to worry
                  about it.  The difference is that this time, our data passed in is not  just  a  simple  email
                  address - it's a hash.  If log_all_data is set to true, then you get back the data in the form
                  that you had originally passed it, arrayref, hashref, or delimited string.

                  Alternatively,  the  user  can  decide to just log the email address, if the dynamic and merge
                  information are not important.

</pre><h4><b>EXAMPLES</b></h4><pre>
       #simple mailing with a list called "./list.txt". Note that this is inefficient, since we're  not  merging
       we #could just use Mail::Bulkmail instead.

        my $bulk = Mail::Bulkmail::Dynamic-&gt;new(
               "LIST"          =&gt; "./list.txt",
               "Subject"       =&gt; "A test message",
               "Message"       =&gt; "This is my test message",
               "From"          =&gt; '<a href="mailto:me@mydomain.com">me@mydomain.com</a>',
               "Reply-To"      =&gt; '<a href="mailto:replies@mydomain.com">replies@mydomain.com</a>'
        ) || die Mail::Bulkmail::Dynamic-&gt;error();

        $bulk-&gt;bulkmail || die $bulk-&gt;error;

       #simple merge example. Assume that this is your list file:

        <a href="mailto:test1@yourdomain.com">test1@yourdomain.com</a>::Person #1
        <a href="mailto:test2@yourdomain.com">test2@yourdomain.com</a>::Person #2
        <a href="mailto:test3@yourdomain.com">test3@yourdomain.com</a>::Person #3

        my $bulk = Mail::Bulkmail::Dynamic-&gt;new(
               "LIST"          =&gt; "./list.txt",
               "Subject"       =&gt; "A test message",
               "Message"       =&gt; "This is my test message just for you. And your name is NAME.",
               "From"          =&gt; '<a href="mailto:me@mydomain.com">me@mydomain.com</a>',
               "Reply-To"      =&gt; '<a href="mailto:replies@mydomain.com">replies@mydomain.com</a>',
               "merge_keys" =&gt; [qw(BULK_EMAIL NAME)]
        ) || die Mail::Bulkmail::Dynamic-&gt;error();

        $bulk-&gt;bulkmail || die $bulk-&gt;error;

       #simple dynamic message example. Assume that this is your list file:

        <a href="mailto:test1@yourdomain.com">test1@yourdomain.com</a>::Person #1::personal_message=mess1
        <a href="mailto:test2@yourdomain.com">test2@yourdomain.com</a>::Person #2::personal_message=mess2
        <a href="mailto:test3@yourdomain.com">test3@yourdomain.com</a>::Person #3::personal_message=mess3

        my $bulk = Mail::Bulkmail::Dynamic-&gt;new(
               "LIST"          =&gt; "./list.txt",
               "Subject"       =&gt; "A test message",
               "Message"       =&gt; "This is my test message. And here's something personalized for you : personal_message",
               "From"          =&gt; '<a href="mailto:me@mydomain.com">me@mydomain.com</a>',
               "Reply-To"      =&gt; '<a href="mailto:replies@mydomain.com">replies@mydomain.com</a>',
               "merge_keys" =&gt; [qw(BULK_EMAIL NAME)],
               "dynamic_message_data" =&gt; {
                       "message" =&gt; {
                               "mess1" =&gt; "Greetings, NAME",
                               "mess2" =&gt; "Hello there, "NAME",
                               "mess3" =&gt; "Hiya, NAME"
                       }
               }
        ) || die Mail::Bulkmail::Dynamic-&gt;error();

        $bulk-&gt;bulkmail || die $bulk-&gt;error;

       #simple dynamic message example with two dynamic components. Assume that this is your list file:

        <a href="mailto:test1@yourdomain.com">test1@yourdomain.com</a>::Person #1::personal_message=mess1;addendum=one
        <a href="mailto:test2@yourdomain.com">test2@yourdomain.com</a>::Person #2::personal_message=mess2;addendum=two
        <a href="mailto:test3@yourdomain.com">test3@yourdomain.com</a>::Person #3::personal_message=mess3;addendum=three

        my $bulk = Mail::Bulkmail::Dynamic-&gt;new(
               "LIST"          =&gt; "./list.txt",
               "Subject"       =&gt; "A test message",
               "Message"       =&gt; "This is my test message. And here's something personalized for you : personal_message. addendum",
               "From"          =&gt; '<a href="mailto:me@mydomain.com">me@mydomain.com</a>',
               "Reply-To"      =&gt; '<a href="mailto:replies@mydomain.com">replies@mydomain.com</a>',
               "merge_keys" =&gt; [qw(BULK_EMAIL NAME)],
               "dynamic_message_data" =&gt; {
                       "message" =&gt; {
                               "mess1" =&gt; "Greetings, NAME",
                               "mess2" =&gt; "Hello there, "NAME",
                               "mess3" =&gt; "Hiya, NAME"
                       },
                       'addendum' =&gt; {
                               'one'   =&gt; 'You have received addendum #1',
                               'two'   =&gt; "You're getting addendum number two",
                               "three" =&gt; "3 is what you get"
                       }
               }
        ) || die Mail::Bulkmail::Dynamic-&gt;error();

        $bulk-&gt;bulkmail || die $bulk-&gt;error;

       #simple  dynamic message example with a dynamic message, and a dynamic header component. Assume that this
       is your list file:

        <a href="mailto:test1@yourdomain.com">test1@yourdomain.com</a>::Person #1::personal_message=mess1;addendum=one::Subject=subject1
        <a href="mailto:test2@yourdomain.com">test2@yourdomain.com</a>::Person #2::personal_message=mess2;addendum=two::Subject=subject1
        <a href="mailto:test3@yourdomain.com">test3@yourdomain.com</a>::Person #3::personal_message=mess3;addendum=three::Subject=subject3

        my $bulk = Mail::Bulkmail::Dynamic-&gt;new(
               "LIST"          =&gt; "./list.txt",
               "Subject"       =&gt; "A test message",
               "Message"       =&gt; "This is my test message. And here's something personalized for you : personal_message. addendum",
               "From"          =&gt; '<a href="mailto:me@mydomain.com">me@mydomain.com</a>',
               "Reply-To"      =&gt; '<a href="mailto:replies@mydomain.com">replies@mydomain.com</a>',
               "merge_keys" =&gt; [qw(BULK_EMAIL NAME)],
               "dynamic_message_data" =&gt; {
                       "message" =&gt; {
                               "mess1" =&gt; "Greetings, NAME",
                               "mess2" =&gt; "Hello there, "NAME",
                               "mess3" =&gt; "Hiya, NAME"
                       },
                       'addendum' =&gt; {
                               'one'   =&gt; 'You have received addendum #1',
                               'two'   =&gt; "You're getting addendum number two",
                               "three" =&gt; "3 is what you get"
                       }
               },
               "dynamic_header_data" =&gt; {
                       "Subject" =&gt; {
                               "subject1" =&gt; "you're getting test message #1",
                               "subject2" =&gt; "you're getting test message #2",
                               "subject3" =&gt; "you're getting test message #3"
                       }
               }
        ) || die Mail::Bulkmail::Dynamic-&gt;error();

        $bulk-&gt;bulkmail || die $bulk-&gt;error;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mail::Bulkmail, Mail::Bulkmail::Server

</pre><h4><b>COPYRIGHT</b> <b>(again)</b></h4><pre>
       Copyright and (c) 1999, 2000, 2001, 2002, 2003 James A  Thomason  III  (<a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>).  All  rights
       reserved.  Mail::Bulkmail::Dynamic is distributed under the terms of the Perl Artistic License.

</pre><h4><b>CONTACT</b> <b>INFO</b></h4><pre>
       So  you  don't  have  to  scroll  all  the way back to the top, I'm Jim Thomason (<a href="mailto:jim@jimandkoka.com">jim@jimandkoka.com</a>) and
       feedback is appreciated.  Bug reports/suggestions/questions/etc.  Hell, drop me a line  to  let  me  know
       that you're using the module and that it's made your life easier.  :-)

perl v5.36.0                                       2022-10-22                             <u>Bulkmail::<a href="../man3pm/Dynamic.3pm.html">Dynamic</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>