<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Furl::HTTP - Low level interface to Furl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfurl-perl">libfurl-perl_3.14-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Furl::HTTP - Low level interface to Furl

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Furl;

           my $furl = Furl::HTTP-&gt;new(
               agent   =&gt; 'MyGreatUA/2.0',
               timeout =&gt; 10,
           );

           my ($minor_version, $code, $msg, $headers, $body) = $furl-&gt;request(
               method     =&gt; 'GET',
               host       =&gt; 'example.com',
               port       =&gt; 80,
               path_query =&gt; '/'
           );
           # or

           # Accept-Encoding is supported but optional
           $furl = Furl-&gt;new(
               headers =&gt; [ 'Accept-Encoding' =&gt; 'gzip' ],
           );
           my $body = $furl-&gt;get('<a href="http://example.com/some/compressed">http://example.com/some/compressed</a>');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Furl is yet another HTTP client library. LWP is the de facto standard HTTP client for Perl 5, but it is
       too slow for some critical jobs, and too complex for weekend hacking. Furl resolves these issues. Enjoy
       it!

</pre><h4><b>INTERFACE</b></h4><pre>
   <b>Class</b> <b>Methods</b>
       <u>"Furl::HTTP-&gt;new(%args</u> <u>|</u> <u>\%args)</u> <u>:Furl"</u>

       Creates and returns a new Furl client with <u>%args</u>. Dies on errors.

       <u>%args</u> might be:

       agent :Str = "Furl/$VERSION"
       timeout :Int = 10
           Seconds  until  the  call  to  $furl-&gt;request returns a timeout error (as an internally generated 500
           error). The timeout might not be accurate since some underlying  modules  /  built-ins  function  may
           block  longer  than  the  specified  timeout.  See  the  "FAQ" for how to support timeout during name
           resolution.

       inactivity_timeout :Int = 600
           An inactivity timer for TCP read/write (in seconds). $furl-&gt;request returns a  timeout  error  if  no
           additional data arrives (or is sent) within the specified threshold.

       max_redirects :Int = 7
       proxy :Str
       no_proxy :Str
       headers :ArrayRef
       header_format :Int = HEADERS_AS_ARRAYREF
           This option choose return value format of "$furl-&gt;request".

           This option allows HEADERS_NONE or HEADERS_AS_ARRAYREF.

           <b>HEADERS_AS_ARRAYREF</b> is a default value. This makes <b>$headers</b> as ArrayRef.

           <b>HEADERS_NONE</b> makes <b>$headers</b> as undef. Furl does not return parsing result of headers. You should take
           needed headers from <b>special_headers</b>.

       connection_pool :Object
           This  is  the  connection  pool  object  for  keep-alive  requests.  By  default, it is a instance of
           Furl::ConnectionCache.

           You may not customize this variable otherwise to use  Coro.  This  attribute  requires  a  duck  type
           object. It has two methods, "$obj-&gt;steal($host, $port" and "$obj-&gt;push($host, $port, $sock)".

       stop_if :CodeRef
           A  callback  function  that is called by Furl after when a blocking function call returns EINTR. Furl
           will abort the HTTP request and return immediately  if  the  callback  returns  true.  Otherwise  the
           operation is continued (the default behaviour).

       get_address :CodeRef
           A  callback  function  to  override  the  default  address  resolution  logic. Takes three arguments:
           ($hostname, $port, $timeout_in_seconds)  and  returns:  ($sockaddr,  $errReason).   If  the  returned
           $sockaddr  is  undef,  then the resolution is considered as a failure and $errReason is propagated to
           the caller.

       inet_aton :CodeRef
           Deprecated.  New applications should use <b>get_address</b> instead.

           A  callback   function   to   customize   name   resolution.   Takes   two   arguments:   ($hostname,
           $timeout_in_seconds). If omitted, Furl calls Socket::inet_aton.

       ssl_opts :HashRef
           SSL configuration used on https requests, passed directly to "IO::Socket::SSL-&gt;new()",

           for example:

               use IO::Socket::SSL;

               my $ua = Furl::HTTP-&gt;new(
                   ssl_opts =&gt; {
                       SSL_verify_mode =&gt; SSL_VERIFY_PEER(),
                   },
               });

           See IO::Socket::SSL for details.

   <b>Instance</b> <b>Methods</b>
       <u>"$furl-&gt;request(%args)</u> <u>:($protocol_minor_version,</u> <u>$code,</u> <u>$msg,</u> <u>\@headers,</u> <u>$body)"</u>

       Sends  an  HTTP  request  to  a  specified  URL and returns a protocol minor version, status code, status
       message, response headers, response body respectively.

       <u>%args</u> might be:

       scheme :Str = "http"
           Protocol scheme. May be "http" or "https".

       host :Str
           Server host to connect.

           You must specify at least "host" or "url".

       port :Int = 80
           Server port to connect. The default is 80 on "scheme =&gt; 'http'", or 443 on "scheme =&gt; 'https'".

       path_query :Str = "/"
           Path and query to request.

       url :Str
           URL to request.

           You can use "url" instead of "scheme", "host", "port" and "path_query".

       headers :ArrayRef
           HTTP request headers. e.g. "headers =&gt; [ 'Accept-Encoding' =&gt; 'gzip' ]".

       content : Str | ArrayRef[Str] | HashRef[Str] | FileHandle
           Content to request.

       write_file : FileHandle
           If this parameter is set, the response content will be saved here instead of in the response object.

           It's like a ":content_file" in LWP::UserAgent.

       write_code : CodeRef
           If a callback is provided with the "write_code" option then this function will  be  called  for  each
           chunk of the response content as it is received from the server.

           It's like a ":content_cb" in LWP::UserAgent.

       The  "request()"  method assumes the first argument to be an instance of "HTTP::Request" if the arguments
       are an odd number:

           my $req = HTTP::Request-&gt;new(...);
           my @res = $furl-&gt;request($req); # allowed

       You must encode all the queries or this method will die, saying "Wide character in ...".

       <u>"$furl-&gt;get($url</u> <u>:Str,</u> <u>$headers</u> <u>:ArrayRef[Str]</u> <u>)"</u>

       This is an easy-to-use alias to "request()", sending the "GET" method.

       <u>"$furl-&gt;head($url</u> <u>:Str,</u> <u>$headers</u> <u>:ArrayRef[Str]</u> <u>)"</u>

       This is an easy-to-use alias to "request()", sending the "HEAD" method.

       <u>"$furl-&gt;post($url</u> <u>:Str,</u> <u>$headers</u> <u>:ArrayRef[Str],</u> <u>$content</u> <u>:Any)"</u>

       This is an easy-to-use alias to "request()", sending the "POST" method.

       <u>"$furl-&gt;put($url</u> <u>:Str,</u> <u>$headers</u> <u>:ArrayRef[Str],</u> <u>$content</u> <u>:Any)"</u>

       This is an easy-to-use alias to "request()", sending the "PUT" method.

       <u>"$furl-&gt;delete($url</u> <u>:Str,</u> <u>$headers</u> <u>:ArrayRef[Str]</u> <u>)"</u>

       This is an easy-to-use alias to "request()", sending the "DELETE" method.

</pre><h4><b>FAQ</b></h4><pre>
       Why IO::Socket::SSL?
           Net::SSL is not well documented.

       Why is env_proxy optional?
           Environment variables are highly dependent on each users' environment, and we think  it  may  confuse
           users when something doesn't go right.

       What operating systems are supported?
           Linux 2.6 or higher, OSX Tiger or higher, Windows XP or higher.

           And other operating systems will be supported if you send a patch.

       Why doesn't Furl support chunked upload?
           There are reasons why chunked POST/PUTs should not be used in general.

           First,  you  cannot  send chunked requests unless the peer server at the other end of the established
           TCP connection is known to be a HTTP/1.1 server.

           Second, HTTP/1.1 servers disconnect their persistent connection quite quickly (compared to  the  time
           they  wait  for  the  first  request), so it is not a good idea to post non-idempotent requests (e.g.
           POST, PUT, etc.) as a succeeding request over persistent connections.

           These facts together makes using chunked requests virtually impossible (unless you  _know_  that  the
           server  supports  HTTP/1.1),  and  this  is why we decided that supporting the feature is NOT of high
           priority.

       How do you build the response content as it arrives?
           You can use IO::Callback for this purpose.

               my $fh = IO::Callback-&gt;new(
                   '&lt;',
                   sub {
                       my $x = shift @data;
                       $x ? "-$x" : undef;
                   }
               );
               my ( $code, $msg, $headers, $content ) =
                 $furl-&gt;put( "<a href="http://127.0.0.1">http://127.0.0.1</a>:$port/", [ 'Content-Length' =&gt; $len ], $fh,
                 );

       How do you use gzip/deflate compressed communication?
           Add an <b>Accept-Encoding</b> header to your request. Furl inflates response bodies transparently  according
           to the <b>Content-Encoding</b> response header.

       How do you use multipart/form-data?
           You can use multipart/form-data with HTTP::Request::Common.

               use HTTP::Request::Common;

               my $furl = Furl-&gt;new();
               $req = POST '<a href="http://www.perl.org/survey.cgi">http://www.perl.org/survey.cgi</a>',
                 Content_Type =&gt; 'form-data',
                 Content      =&gt; [
                   name   =&gt; 'Hiromu Tokunaga',
                   email  =&gt; '<a href="mailto:tokuhirom@example.com">tokuhirom@example.com</a>',
                   gender =&gt; 'F',
                   born   =&gt; '1978',
                   init   =&gt; ["$ENV{HOME}/.profile"],
                 ];
               $furl-&gt;request($req);

           Native multipart/form-data support for Furl is available if you can send a patch for me.

       How do you use Keep-Alive and what happens on the HEAD method?
           Furl  supports  HTTP/1.1,  hence "Keep-Alive". However, if you use the HEAD method, the connection is
           closed immediately.

           RFC 2616 section 9.4 says:

               The HEAD method is identical to GET except that the server MUST NOT
               return a message-body in the response.

           Some web applications, however, returns message bodies  on  the  HEAD  method,  which  might  confuse
           "Keep-Alive" processes, so Furl closes connection in such cases.

           Anyway,  the  HEAD  method is not so useful nowadays. The GET method and "If-Modified-Since" are more
           suitable to cache HTTP contents.

       Why does Furl take longer than specified until it returns a timeout error?
           Although Furl itself supports timeout, some underlying modules /  functions  do  not.  And  the  most
           noticeable  one is Socket::inet_aton, the function used for name resolution (a function that converts
           host names to IP addresses). If you need accurate and short timeout for name resolution, the  use  of
           Net::DNS::Lite  is  recommended.  The  following  code  snippet  describes  how  to use the module in
           conjunction with Furl.

               use Net::DNS::Lite qw();

               my $furl = Furl-&gt;new(
                   timeout   =&gt; $my_timeout_in_seconds,
                   inet_aton =&gt; sub { Net::DNS::Lite::inet_aton(@_) },
               );

       How can I replace Host header instead of hostname?
           Furl::HTTP does not provide a way to replace the Host header because such a design leads to  security
           issues.

           If  you  want  to  send  HTTP  requests  to a dedicated server (or a UNIX socket), you should use the
           <b>get_address</b> callback to designate the peer to which Furl should connect as <b>sockaddr</b>.

           The example below sends all requests to 127.0.0.1:8080.

               my $ua = Furl::HTTP-&gt;new(
                   get_address =&gt; sub {
                       my ($host, $port, $timeout) = @_;
                       pack_sockaddr_in(8080, inet_aton("127.0.0.1"));
                   },
               );

               my ($minor_version, $code, $msg, $headers, $body) = $furl-&gt;request(
                   url =&gt; '<a href="http://example.com/foo">http://example.com/foo</a>',
                   method =&gt; 'GET'
               );

</pre><h4><b>TODO</b></h4><pre>
           - AnyEvent::Furl?
           - ipv6 support
           - better docs for NO_PROXY

</pre><h4><b>OPTIONAL</b> <b>FEATURES</b></h4><pre>
   <b>Internationalized</b> <b>Domain</b> <b>Name</b> <b>(IDN)</b>
       This feature requires Net::IDN::Encode.

   <b>SSL</b>
       This feature requires IO::Socket::SSL.

   <b>Content-Encoding</b> <b>(deflate,</b> <b>gzip)</b>
       This feature requires Compress::Raw::Zlib.

</pre><h4><b>DEVELOPMENT</b></h4><pre>
       To setup your environment:

           $ git clone <a href="http://github.com/tokuhirom/Furl.git">http://github.com/tokuhirom/Furl.git</a>
           $ cd Furl

       To get picohttpparser:

           $ git submodule init
           $ git submodule update

           $ perl Makefile.PL
           $ make
           $ sudo make install

   <b>HOW</b> <b>TO</b> <b>CONTRIBUTE</b>
       Please send the pull request via &lt;<a href="http://github.com/tokuhirom/Furl/">http://github.com/tokuhirom/Furl/</a>&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       LWP

       HTTP                       specs:                        &lt;<a href="http://www.w3.org/Protocols/HTTP/1.0/spec.html">http://www.w3.org/Protocols/HTTP/1.0/spec.html</a>&gt;
       &lt;<a href="http://www.w3.org/Protocols/HTTP/1.1/spec.html">http://www.w3.org/Protocols/HTTP/1.1/spec.html</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright (C) Tokuhiro Matsuno.

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.34.0                                       2022-02-20                                    <u>Furl::<a href="../man3pm/HTTP.3pm.html">HTTP</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>