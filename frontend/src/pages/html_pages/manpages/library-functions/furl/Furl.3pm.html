<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Furl - Lightning-fast URL fetcher</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfurl-perl">libfurl-perl_3.14-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Furl - Lightning-fast URL fetcher

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Furl;

           my $furl = Furl-&gt;new(
               agent   =&gt; 'MyGreatUA/2.0',
               timeout =&gt; 10,
           );

           my $res = $furl-&gt;get('<a href="http://example.com/">http://example.com/</a>');
           die $res-&gt;status_line unless $res-&gt;is_success;
           print $res-&gt;content;

           my $res = $furl-&gt;post(
               '<a href="http://example.com/">http://example.com/</a>', # URL
               [...],                 # headers
               [ foo =&gt; 'bar' ],      # form data (HashRef/FileHandle are also okay)
           );

           # Accept-Encoding is supported but optional
           $furl = Furl-&gt;new(
               headers =&gt; [ 'Accept-Encoding' =&gt; 'gzip' ],
           );
           my $body = $furl-&gt;get('<a href="http://example.com/some/compressed">http://example.com/some/compressed</a>');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Furl is yet another HTTP client library. LWP is the de facto standard HTTP client for Perl 5, but it is
       too slow for some critical jobs, and too complex for weekend hacking. Furl resolves these issues. Enjoy
       it!

</pre><h4><b>INTERFACE</b></h4><pre>
   <b>Class</b> <b>Methods</b>
       <u>"Furl-&gt;new(%args</u> <u>|</u> <u>\%args)</u> <u>:Furl"</u>

       Creates and returns a new Furl client with <u>%args</u>. Dies on errors.

       <u>%args</u> might be:

       agent :Str = "Furl/$VERSION"
       timeout :Int = 10
       max_redirects :Int = 7
       capture_request :Bool = false
           If   this   parameter  is  true,  Furl::HTTP  captures  raw  request  string.   You  can  get  it  by
           "$res-&gt;captured_req_headers" and "$res-&gt;captured_req_content".

       proxy :Str
       no_proxy :Str
       headers :ArrayRef
       cookie_jar :Object
           (EXPERIMENTAL)

           An instance of HTTP::CookieJar or equivalent class that supports the add and cookie_header methods

   <b>Instance</b> <b>Methods</b>
       <u>"$furl-&gt;request([$request,]</u> <u>%args)</u> <u>:Furl::Response"</u>

       Sends an HTTP request to a specified URL and returns a instance of Furl::Response.

       <u>%args</u> might be:

       scheme :Str = "http"
           Protocol scheme. May be "http" or "https".

       host :Str
           Server host to connect.

           You must specify at least "host" or "url".

       port :Int = 80
           Server port to connect. The default is 80 on "scheme =&gt; 'http'", or 443 on "scheme =&gt; 'https'".

       path_query :Str = "/"
           Path and query to request.

       url :Str
           URL to request.

           You can use "url" instead of "scheme", "host", "port" and "path_query".

       headers :ArrayRef
           HTTP request headers. e.g. "headers =&gt; [ 'Accept-Encoding' =&gt; 'gzip' ]".

       content : Str | ArrayRef[Str] | HashRef[Str] | FileHandle
           Content to request.

       If the number of arguments is an odd number, this method assumes that the first argument is  an  instance
       of  "HTTP::Request".  Remaining  arguments  can  be  any of the previously describe values (but currently
       there's no way to really utilize them, so don't use it)

           my $req = HTTP::Request-&gt;new(...);
           my $res = $furl-&gt;request($req);

       You can also specify an object other  than  HTTP::Request  (e.g.  Furl::Request),  but  the  object  must
       implement the following methods:

       uri
       method
       content
       headers

       These must return the same type of values as their counterparts in "HTTP::Request".

       You must encode all the queries or this method will die, saying "Wide character in ...".

       <u>"$furl-&gt;get($url</u> <u>:Str,</u> <u>$headers</u> <u>:ArrayRef[Str]</u> <u>)"</u>

       This is an easy-to-use alias to "request()", sending the "GET" method.

       <u>"$furl-&gt;head($url</u> <u>:Str,</u> <u>$headers</u> <u>:ArrayRef[Str]</u> <u>)"</u>

       This is an easy-to-use alias to "request()", sending the "HEAD" method.

       <u>"$furl-&gt;post($url</u> <u>:Str,</u> <u>$headers</u> <u>:ArrayRef[Str],</u> <u>$content</u> <u>:Any)"</u>

       This is an easy-to-use alias to "request()", sending the "POST" method.

       <u>"$furl-&gt;put($url</u> <u>:Str,</u> <u>$headers</u> <u>:ArrayRef[Str],</u> <u>$content</u> <u>:Any)"</u>

       This is an easy-to-use alias to "request()", sending the "PUT" method.

       <u>"$furl-&gt;delete($url</u> <u>:Str,</u> <u>$headers</u> <u>:ArrayRef[Str]</u> <u>)"</u>

       This is an easy-to-use alias to "request()", sending the "DELETE" method.

       <u>"$furl-&gt;env_proxy()"</u>

       Loads proxy settings from $ENV{HTTP_PROXY} and $ENV{NO_PROXY}.

</pre><h4><b>TIPS</b></h4><pre>
       IO::Socket::SSL preloading
           Furl  interprets  the  "timeout" argument as the maximum time the module is permitted to spend before
           returning an error.

           The module also lazy-loads IO::Socket::SSL when an HTTPS request is being issued for the first  time.
           Loading the module usually takes ~0.1 seconds.

           The time spent for loading the SSL module may become an issue in case you want to impose a very small
           timeout value for connection establishment. In such case, users are advised to preload the SSL module
           explicitly.

</pre><h4><b>FAQ</b></h4><pre>
       Does Furl depends on XS modules?
           No.  Although  some  optional  features  require  XS modules, basic features are available without XS
           modules.

           Note that Furl requires HTTP::Parser::XS, which seems an XS module but includes a pure Perl  backend,
           HTTP::Parser::XS::PP.

       I need more speed.
           See  Furl::HTTP,  which  provides the low level interface of Furl.  It is faster than "Furl.pm" since
           Furl::HTTP does not create response objects.

       How do you use cookie_jar?
           Furl does not directly support the cookie_jar option available in LWP.  You  can  use  HTTP::Cookies,
           HTTP::Request, HTTP::Response like following.

               my $f = Furl-&gt;new();
               my $cookies = HTTP::Cookies-&gt;new();
               my $req = HTTP::Request-&gt;new(...);
               $cookies-&gt;add_cookie_header($req);
               my $res = $f-&gt;request($req)-&gt;as_http_response;
               $res-&gt;request($req);
               $cookies-&gt;extract_cookies($res);
               # and use $res.

       How do you limit the response content length?
           You can limit the content length by callback function.

               my $f = Furl-&gt;new();
               my $content = '';
               my $limit = 1_000_000;
               my %special_headers = ('content-length' =&gt; undef);
               my $res = $f-&gt;request(
                   method          =&gt; 'GET',
                   url             =&gt; $url,
                   special_headers =&gt; \%special_headers,
                   write_code      =&gt; sub {
                       my ( $status, $msg, $headers, $buf ) = @_;
                       if (($special_headers{'content-length'}||0) &gt; $limit || length($content) &gt; $limit) {
                           die "over limit: $limit";
                       }
                       $content .= $buf;
                   }
               );

       How do you display the progress bar?
               my $bar = Term::ProgressBar-&gt;new({count =&gt; 1024, ETA =&gt; 'linear'});
               $bar-&gt;<a href="../man0/minor.0.html">minor</a>(0);
               $bar-&gt;<a href="../man1/max_update_rate.1.html">max_update_rate</a>(1);

               my $f = Furl-&gt;new();
               my $content = '';
               my %special_headers = ('content-length' =&gt; undef);;
               my $did_set_target = 0;
               my $received_size = 0;
               my $next_update  = 0;
               $f-&gt;request(
                   method          =&gt; 'GET',
                   url             =&gt; $url,
                   special_headers =&gt; \%special_headers,
                   write_code      =&gt; sub {
                       my ( $status, $msg, $headers, $buf ) = @_;
                       unless ($did_set_target) {
                           if ( my $cl = $special_headers{'content-length'} ) {
                               $bar-&gt;target($cl);
                               $did_set_target++;
                           }
                           else {
                               $bar-&gt;target( $received_size + 2 * length($buf) );
                           }
                       }
                       $received_size += length($buf);
                       $content .= $buf;
                       $next_update = $bar-&gt;update($received_size)
                       if $received_size &gt;= $next_update;
                   }
               );

       HTTPS requests claims warnings!
           When you make https requests, IO::Socket::SSL may complain about it like:

               *******************************************************************
                Using the default of SSL_verify_mode of SSL_VERIFY_NONE for client
                is depreciated! Please set SSL_verify_mode to SSL_VERIFY_PEER
                together with SSL_ca_file|SSL_ca_path for verification.
                If you really don't want to verify the certificate and keep the
                connection open to Man-In-The-Middle attacks please set
                SSL_verify_mode explicitly to SSL_VERIFY_NONE in your application.
               *******************************************************************

           You should set "SSL_verify_mode" explicitly with Furl's "ssl_opts".

               use IO::Socket::SSL;

               my $ua = Furl-&gt;new(
                   ssl_opts =&gt; {
                       SSL_verify_mode =&gt; SSL_VERIFY_PEER(),
                   },
               );

           See IO::Socket::SSL for details.

</pre><h4><b>AUTHOR</b></h4><pre>
       Tokuhiro Matsuno &lt;<a href="mailto:tokuhirom@gmail.com">tokuhirom@gmail.com</a>&gt;

       Fuji, Goro (gfx)

</pre><h4><b>THANKS</b> <b>TO</b></h4><pre>
       Kazuho Oku

       mala

       mattn

       lestrrat

       walf443

       lestrrat

       audreyt

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       LWP

       IO::Socket::SSL

       Furl::HTTP

       Furl::Response

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright (C) Tokuhiro Matsuno.

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.34.0                                       2022-02-20                                          <u><a href="../man3pm/Furl.3pm.html">Furl</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>