<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WWW::Mechanize - Handy web browsing in a Perl object</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libwww-mechanize-perl">libwww-mechanize-perl_2.19-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       WWW::Mechanize - Handy web browsing in a Perl object

</pre><h4><b>VERSION</b></h4><pre>
       version 2.19

</pre><h4><b>SYNOPSIS</b></h4><pre>
       WWW::Mechanize supports performing a sequence of page fetches including following links and submitting
       forms. Each fetched page is parsed and its links and forms are extracted. A link or a form can be
       selected, form fields can be filled and the next page can be fetched.  Mech also stores a history of the
       URLs you've visited, which can be queried and revisited.

           use WWW::Mechanize ();
           my $mech = WWW::Mechanize-&gt;new();

           $mech-&gt;get( $url );

           $mech-&gt;follow_link( n =&gt; 3 );
           $mech-&gt;follow_link( text_regex =&gt; qr/download this/i );
           $mech-&gt;follow_link( url =&gt; '<a href="http://host.com/index.html">http://host.com/index.html</a>' );

           $mech-&gt;submit_form(
               form_number =&gt; 3,
               fields      =&gt; {
                   username    =&gt; 'mungo',
                   password    =&gt; 'lost-and-alone',
               }
           );

           $mech-&gt;submit_form(
               form_name =&gt; 'search',
               fields    =&gt; { query  =&gt; 'pot of gold', },
               button    =&gt; 'Search Now'
           );

           # Enable strict form processing to catch typos and non-existent form fields.
           my $strict_mech = WWW::Mechanize-&gt;new( strict_forms =&gt; 1);

           $strict_mech-&gt;get( $url );

           # This method call will die, saving you lots of time looking for the bug.
           $strict_mech-&gt;submit_form(
               form_number =&gt; 3,
               fields      =&gt; {
                   usernaem     =&gt; 'mungo',           # typo in field name
                   password     =&gt; 'lost-and-alone',
                   extra_field  =&gt; 123,               # field does not exist
               }
           );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "WWW::Mechanize", or Mech for short, is a Perl module for stateful programmatic web browsing, used for
       automating interaction with websites.

       Features include:

       •   All HTTP methods

       •   High-level hyperlink and HTML form support, without having to parse HTML yourself

       •   SSL support

       •   Automatic cookies

       •   Custom HTTP headers

       •   Automatic handling of redirections

       •   Proxies

       •   HTTP authentication

       Mech  is  well  suited  for  use  in  testing  web  applications.   If  you  use one of the Test::*, like
       Test::HTML::Lint modules, you can check the fetched content and use that as input to a test call.

           use Test::More;
           like( $mech-&gt;content(), qr/$expected/, "Got expected content" );

       Each page fetch stores its URL in a history stack which you can traverse.

           $mech-&gt;back();

       If you want finer control over  your  page  fetching,  you  can  use  these  methods.  follow_link()  and
       submit_form() are just high level wrappers around them.

           $mech-&gt;find_link( n =&gt; $number );
           $mech-&gt;form_number( $number );
           $mech-&gt;form_name( $name );
           $mech-&gt;field( $name, $value );
           $mech-&gt;set_fields( %field_values );
           $mech-&gt;set_visible( @criteria );
           $mech-&gt;click( $button );

       WWW::Mechanize  is  a  proper  subclass  of  LWP::UserAgent  and you can also use any of LWP::UserAgent's
       methods.

           $mech-&gt;add_header($name =&gt; $value);

       Please note that Mech does NOT support JavaScript, you need additional software for  that.  Please  check
       "JavaScript" in WWW::Mechanize::FAQ for more.

</pre><h4><b>IMPORTANT</b> <b>LINKS</b></h4><pre>
       •   &lt;https://github.com/libwww-perl/WWW-Mechanize/issues&gt;

           The   queue   for   bugs   &amp;   enhancements  in  WWW::Mechanize.   Please  note  that  the  queue  at
           &lt;<a href="http://rt.cpan.org">http://rt.cpan.org</a>&gt; is no longer maintained.

       •   &lt;https://metacpan.org/pod/WWW::Mechanize&gt;

           The CPAN documentation page for Mechanize.

       •   &lt;https://metacpan.org/pod/distribution/WWW-Mechanize/lib/WWW/Mechanize/FAQ.pod&gt;

           Frequently asked questions.  Make sure you read here FIRST.

</pre><h4><b>CONSTRUCTOR</b> <b>AND</b> <b>STARTUP</b></h4><pre>
   <b>new()</b>
       Creates and returns a new WWW::Mechanize object, hereafter referred to as the "agent".

           my $mech = WWW::Mechanize-&gt;new()

       The constructor for WWW::Mechanize overrides two of the params to the LWP::UserAgent constructor:

           agent =&gt; 'WWW-Mechanize/#.##'
           cookie_jar =&gt; {}    # an empty, memory-only HTTP::Cookies object

       You can override these overrides by passing params to the constructor, as in:

           my $mech = WWW::Mechanize-&gt;new( agent =&gt; 'wonderbot 1.01' );

       If you want none of the overhead of a cookie jar, or don't want your bot accepting cookies, you  have  to
       explicitly disallow it, like so:

           my $mech = WWW::Mechanize-&gt;new( cookie_jar =&gt; undef );

       Here  are  the  params  that  WWW::Mechanize recognizes.  These do not include params that LWP::UserAgent
       recognizes.

       •   "autocheck =&gt; [0|1]"

           Checks each request made to see if it was  successful.   This  saves  you  the  trouble  of  manually
           checking yourself.  Any errors found are errors, not warnings.

           The  default  value  is  ON,  unless it's being subclassed, in which case it is OFF.  This means that
           standalone WWW::Mechanize instances have autocheck turned  on,  which  is  protective  for  the  vast
           majority  of  Mech  users  who  don't  bother checking the return value of get() and post() and can't
           figure  why  their  code  fails.  However,   if   WWW::Mechanize   is   subclassed,   such   as   for
           Test::WWW::Mechanize  or  Test::WWW::Mechanize::Catalyst,  this may not be an appropriate default, so
           it's off.

       •   "noproxy =&gt; [0|1]"

           Turn off the automatic call to the LWP::UserAgent "env_proxy" function.

           This needs to be explicitly turned off if you're using Crypt::SSLeay to access a  https  site  via  a
           proxy server.  Note: you still need to set your HTTPS_PROXY environment variable as appropriate.

       •   "onwarn =&gt; \&amp;func"

           Reference  to a "warn"-compatible function, such as "Carp::carp", that is called when a warning needs
           to be shown.

           If this is set to "undef", no warnings will ever be shown.  However, it's probably better to use  the
           "quiet" method to control that behavior.

           If this value is not passed, Mech uses "Carp::carp" if Carp is installed, or "CORE::warn" if not.

       •   "onerror =&gt; \&amp;func"

           Reference  to a "die"-compatible function, such as "Carp::croak", that is called when there's a fatal
           error.

           If this is set to "undef", no errors will ever be shown.

           If this value is not passed, Mech uses "Carp::croak" if Carp is installed, or "CORE::die" if not.

       •   "quiet =&gt; [0|1]"

           Don't complain on warnings.  Setting "quiet =&gt; 1" is the same as calling "$mech-&gt;<a href="../man1/quiet.1.html">quiet</a>(1)".   Default
           is off.

       •   "stack_depth =&gt; $value"

           Sets the depth of the page stack that keeps track of all the downloaded pages. Default is effectively
           infinite stack size.  If the stack is eating up your memory, then set this to a smaller number, say 5
           or 10.  Setting this to zero means Mech will keep no history.

       In addition, WWW::Mechanize also allows you to globally enable strict and verbose mode for form handling,
       which is done with HTML::Form.

       •   "strict_forms =&gt; [0|1]"

           Globally  sets  the HTML::Form strict flag which causes form submission to croak if any of the passed
           fields don't exist in the form, and/or a value doesn't exist in a select element. This can  still  be
           disabled in individual calls to submit_form().

           Default is off.

       •   "verbose_forms =&gt; [0|1]"

           Globally  sets  the  HTML::Form  verbose flag which causes form submission to warn about any bad HTML
           form constructs found. This cannot be disabled later.

           Default is off.

       •   "marked_sections =&gt; [0|1]"

           Globally sets the HTML::Parser marked sections flag  which  causes  HTML  "CDATA[["  sections  to  be
           honoured. This cannot be disabled later.

           Default is on.

       To support forms, WWW::Mechanize's constructor pushes POST on to the agent's "requests_redirectable" list
       (see also LWP::UserAgent.)

   <b>$mech-&gt;agent_alias(</b> <b>$alias</b> <b>)</b>
       Sets  the  user  agent string to the expanded version from a table of actual user strings.  $alias can be
       one of the following:

       •   Windows IE 6

       •   Windows Mozilla

       •   Mac Safari

       •   Mac Mozilla

       •   Linux Mozilla

       •   Linux Konqueror

       then it will be replaced with a more interesting one.  For instance,

           $mech-&gt;agent_alias( 'Windows IE 6' );

       sets your User-Agent to

           Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)

       The list of valid aliases can be returned from known_agent_aliases().  The current list is:

       •   Windows IE 6

       •   Windows Mozilla

       •   Mac Safari

       •   Mac Mozilla

       •   Linux Mozilla

       •   Linux Konqueror

   <b>$mech-&gt;known_agent_aliases()</b>
       Returns a list of all the agent aliases that Mech knows about.  This can also be called as a  package  or
       class method.

           @aliases = WWW::Mechanize::known_agent_aliases();
           @aliases = WWW::Mechanize-&gt;known_agent_aliases();
           @aliases = $mech-&gt;known_agent_aliases();

</pre><h4><b>PAGE-FETCHING</b> <b>METHODS</b></h4><pre>
   <b>$mech-&gt;get(</b> <b>$uri</b> <b>)</b>
       Given  a URL/URI, fetches it.  Returns an HTTP::Response object.  $uri can be a well-formed URL string, a
       URI object, or a WWW::Mechanize::Link object.

       The results are stored internally in the agent object, but you don't know that.  Just use  the  accessors
       listed below.  Poking at the internals is deprecated and subject to change in the future.

       get() is a well-behaved overloaded version of the method in LWP::UserAgent.  This lets you do things like

           $mech-&gt;get( $uri, ':content_file' =&gt; $filename );

       and  you  can  rest  assured  that  the  params  will  get  filtered  down  appropriately.  See  "get" in
       LWP::UserAgent for more details.

       <b>NOTE:</b> The file in ":content_file" will contain the raw content of the response. If the  response  content
       is encoded (e.g. gzip encoded), the file will be encoded as well. Use $mech-&gt;save_content if you need the
       decoded content.

       <b>NOTE:</b>  Because  ":content_file"  causes  the page contents to be stored in a file instead of the response
       object, some Mech functions that expect it to be there won't work as expected. Use with caution.

       Here is a non-complete list of methods that do not work as expected with ":content_file":    forms()  ,
       current_form()  ,   links() ,  title() ,  content(...) ,  text() , all content-handling methods, all link
       methods, all image methods, all form methods, all field methods,  save_content(...) ,  dump_links(...) ,
       dump_images(...) ,  dump_forms(...) ,  dump_text(...)

   <b>$mech-&gt;post(</b> <b>$uri,</b> <b>content</b> <b>=&gt;</b> <b>$content</b> <b>)</b>
       POSTs $content to $uri.  Returns an HTTP::Response object.  $uri can be a well-formed URI string,  a  URI
       object, or a WWW::Mechanize::Link object.

   <b>$mech-&gt;put(</b> <b>$uri,</b> <b>content</b> <b>=&gt;</b> <b>$content</b> <b>)</b>
       PUTs  $content  to  $uri.  Returns an HTTP::Response object.  $uri can be a well-formed URI string, a URI
       object, or a WWW::Mechanize::Link object.

           my $res = $mech-&gt;put( $uri );
           my $res = $mech-&gt;put( $uri , $field_name =&gt; $value, ... );

   <b>$mech-&gt;head</b> <b>($uri</b> <b>)</b>
       Performs a HEAD request to $uri. Returns an HTTP::Response object.  $uri can be a well-formed URI string,
       a URI object, or a WWW::Mechanize::Link object.

   <b>$mech-&gt;delete</b> <b>($uri</b> <b>)</b>
       Performs a DELETE request to $uri. Returns an HTTP::Response object.   $uri  can  be  a  well-formed  URI
       string, a URI object, or a WWW::Mechanize::Link object.

   <b>$mech-&gt;reload()</b>
       Acts  like  the  reload  button in a browser: repeats the current request. The history (as per the <b>back()</b>
       method) is not altered.

       Returns the HTTP::Response object from the reload, or "undef" if there's no current request.

   <b>$mech-&gt;back()</b>
       The equivalent of hitting the "back" button in a browser.  Returns to the previous page.  Won't  go  back
       past the first page. (Really, what would it do if it could?)

       Returns true if it could go back, or false if not.

   <b>$mech-&gt;clear_history()</b>
       This deletes all the history entries and returns true.

   <b>$mech-&gt;history_count()</b>
       This returns the number of items in the browser history.  This number <u>does</u> include the most recently made
       request.

   <b>$mech-&gt;history($n)</b>
       This  returns the <u>n</u>th item in history.  The 0th item is the most recent request and response, which would
       be acted on by methods like find_link().  The 1st item is the state you'd return to if you called back().

       The maximum useful value for $n is "$mech-&gt;history_count - 1".  Requests beyond that  bound  will  return
       "undef".

       History items are returned as hash references, in the form:

         { req =&gt; $http_request, res =&gt; $http_response }

</pre><h4><b>STATUS</b> <b>METHODS</b></h4><pre>
   <b>$mech-&gt;success()</b>
       Returns  a  boolean  telling  whether the last request was successful.  If there hasn't been an operation
       yet, returns false.

       This is a convenience function that wraps "$mech-&gt;res-&gt;is_success".

   <b>$mech-&gt;uri()</b>
       Returns the current URI as a URI object. This object stringifies to the URI itself.

   <b>$mech-&gt;response()</b> <b>/</b> <b>$mech-&gt;res()</b>
       Return the current response as an HTTP::Response object.

       Synonym for "$mech-&gt;response()".

   <b>$mech-&gt;status()</b>
       Returns the HTTP status code of the response.  This is a 3-digit number like 200  for  OK,  404  for  not
       found, and so on.

   <b>$mech-&gt;ct()</b> <b>/</b> <b>$mech-&gt;content_type()</b>
       Returns the content type of the response.

   <b>$mech-&gt;base()</b>
       Returns the base URI for the current response

   <b>$mech-&gt;forms()</b>
       When  called  in  a list context, returns a list of the forms found in the last fetched page. In a scalar
       context, returns a reference to an array with those forms. The forms returned are all HTML::Form objects.

   <b>$mech-&gt;current_form()</b>
       Returns the current form as an HTML::Form object.

   <b>$mech-&gt;links()</b>
       When called in a list context, returns a list of the links found in the last fetched page.  In  a  scalar
       context it returns a reference to an array with those links.  Each link is a WWW::Mechanize::Link object.

   <b>$mech-&gt;is_html()</b>
       Returns true/false on whether our content is HTML, according to the HTTP headers.

   <b>$mech-&gt;title()</b>
       Returns the contents of the "&lt;TITLE&gt;" tag, as parsed by HTML::HeadParser.  Returns "undef" if the content
       is not HTML.

   <b>$mech-&gt;redirects()</b>
       Convenience method to get the redirects from the most recent HTTP::Response.

       Note that you can also use is_redirect to see if the most recent response was a redirect like this.

           $mech-&gt;get($url);
           do_stuff() if $mech-&gt;res-&gt;is_redirect;

</pre><h4><b>CONTENT-HANDLING</b> <b>METHODS</b></h4><pre>
   <b>$mech-&gt;content(...)</b>
       Returns  the content that the mech uses internally for the last page fetched. Ordinarily this is the same
       as "$mech-&gt;response()-&gt;decoded_content()", but this may differ for HTML  documents  if  "update_html"  is
       overloaded  (in  which  case the value passed to the base-class implementation of same will be returned),
       and/or extra named arguments are passed to content():

       <u>$mech-&gt;content(</u> <u>format</u> <u>=&gt;</u> <u>'text'</u> <u>)</u>
         Returns a text-only version of  the  page,  with  all  HTML  markup  stripped.  This  feature  requires
         HTML::TreeBuilder version 5 or higher to be installed, or a fatal error will be thrown. This works only
         if the contents are HTML.

       <u>$mech-&gt;content(</u> <u>base_href</u> <u>=&gt;</u> <u>[$base_href|undef]</u> <u>)</u>
         Returns  the  HTML  document,  modified  to contain a "&lt;base href="$base_href"&gt;" mark-up in the header.
         $base_href is "$mech-&gt;base()" if not specified. This is handy to pass the HTML to  e.g.  HTML::Display.
         This works only if the contents are HTML.

       <u>$mech-&gt;content(</u> <u>raw</u> <u>=&gt;</u> <u>1</u> <u>)</u>
         Returns "$self-&gt;response()-&gt;content()", i.e. the raw contents from the response.

       <u>$mech-&gt;content(</u> <u>decoded_by_headers</u> <u>=&gt;</u> <u>1</u> <u>)</u>
         Returns the content after applying all "Content-Encoding" headers but with not additional mangling.

       <u>$mech-&gt;content(</u> <u>charset</u> <u>=&gt;</u> <u>$charset</u> <u>)</u>
         Returns "$self-&gt;response()-&gt;decoded_content(charset =&gt; $charset)" (see HTTP::Response for details).

       To  preserve  backwards  compatibility,  additional  parameters  will  be  ignored  unless none of "raw |
       decoded_by_headers | charset" is specified and the  text  is  HTML,  in  which  case  an  error  will  be
       triggered.

       A  fresh  instance  of  WWW::Mechanize  will return "undef" when "$mech-&gt;content()" is called, because no
       content is present before a request has been made.

   <b>$mech-&gt;text()</b>
       Returns the text of the current HTML content.  If the content isn't HTML, $mech will die.

       The text is extracted by parsing the content, and then the extracted text is cached, so don't worry about
       performance of calling this repeatedly.

</pre><h4><b>LINK</b> <b>METHODS</b></h4><pre>
   <b>$mech-&gt;links()</b>
       Lists all the links on the current page.  Each link is a WWW::Mechanize::Link object.  In  list  context,
       returns a list of all links.  In scalar context, returns an array reference of all links.

   <b>$mech-&gt;follow_link(...)</b>
       Follows  a  specified  link  on  the  page.  You specify the match to be found using the same params that
       find_link() uses.

       Here some examples:

       •   3rd link called "download"

               $mech-&gt;follow_link( text =&gt; 'download', n =&gt; 3 );

       •   first link where the URL has "download" in it, regardless of case:

               $mech-&gt;follow_link( url_regex =&gt; qr/download/i );

           or

               $mech-&gt;follow_link( url_regex =&gt; qr/(?i:download)/ );

       •   3rd link on the page

               $mech-&gt;follow_link( n =&gt; 3 );

       •   the link with the url

               $mech-&gt;follow_link( url =&gt; '/other/page' );

           or

               $mech-&gt;follow_link( url =&gt; '<a href="http://example.com/page">http://example.com/page</a>' );

       Returns the result of the "GET" method (an HTTP::Response object) if a link was found.

       If the page has no links, or the specified link couldn't be found, returns "undef".   If  "autocheck"  is
       enabled an exception will be thrown instead.

   <b>$mech-&gt;find_link(</b> <b>...</b> <b>)</b>
       Finds  a link in the currently fetched page. It returns a WWW::Mechanize::Link object which describes the
       link.  (You'll probably be most interested in the url() property.)  If it fails to find a link it returns
       "undef".

       You can take the URL part and pass it to the get() method.  If that's your plan, you might  as  well  use
       the follow_link() method directly, since it does the get() for you automatically.

       Note  that  "&lt;FRAME SRC="..."&gt;" tags are parsed out of the HTML and treated as links so this method works
       with them.

       You can select which link to find by passing in one or more of these key/value pairs:

       •   "text =&gt; 'string'," and "text_regex =&gt; qr/regex/,"

           "text" matches the text of the link against <u>string</u>, which must be an exact match.  To select  a  link
           with text that is exactly "download", use

               $mech-&gt;find_link( text =&gt; 'download' );

           "text_regex"  matches  the  text  of  the  link  against  <u>regex</u>.  To select a link with text that has
           "download" anywhere in it, regardless of case, use

               $mech-&gt;find_link( text_regex =&gt; qr/download/i );

           Note that the text extracted from the page's links are trimmed.   For  example,  "&lt;a&gt;  foo  &lt;/a&gt;"  is
           stored as 'foo', and searching for leading or trailing spaces will fail.

       •   "url =&gt; 'string'," and "url_regex =&gt; qr/regex/,"

           Matches  the URL of the link against <u>string</u> or <u>regex</u>, as appropriate.  The URL may be a relative URL,
           like <u>foo/bar.html</u>, depending on how it's coded on the page.

       •   "url_abs =&gt; string" and "url_abs_regex =&gt; regex"

           Matches the absolute URL of the link against <u>string</u> or <u>regex</u>, as appropriate.  The  URL  will  be  an
           absolute URL, even if it's relative in the page.

       •   "name =&gt; string" and "name_regex =&gt; regex"

           Matches the name of the link against <u>string</u> or <u>regex</u>, as appropriate.

       •   "rel =&gt; string" and "rel_regex =&gt; regex"

           Matches  the  rel  of  the  link  against  <u>string</u> or <u>regex</u>, as appropriate.  This can be used to find
           stylesheets, favicons, or links the author of the page does not want bots to follow.

       •   "id =&gt; string" and "id_regex =&gt; regex"

           Matches the attribute 'id' of the link against <u>string</u> or <u>regex</u>, as appropriate.

       •   "class =&gt; string" and "class_regex =&gt; regex"

           Matches the attribute 'class' of the link against <u>string</u> or <u>regex</u>, as appropriate.

       •   "tag =&gt; string" and "tag_regex =&gt; regex"

           Matches the tag that the link came from against <u>string</u> or <u>regex</u>, as appropriate.  The "tag_regex"  is
           probably most useful to check for more than one tag, as in:

               $mech-&gt;find_link( tag_regex =&gt; qr/^(a|frame)$/ );

           The tags and attributes looked at are defined below.

       If  "n"  is  not  specified,  it  defaults to 1.  Therefore, if you don't specify any params, this method
       defaults to finding the first link on the page.

       Note that you can specify multiple text or URL parameters, which will be ANDed together.  For example, to
       find the first link with text of "News" and with "cnn.com" in the URL, use:

           $mech-&gt;find_link( text =&gt; 'News', url_regex =&gt; qr/cnn\.com/ );

       The return value is a reference to an array containing a WWW::Mechanize::Link object for  every  link  in
       "$self-&gt;content".

       The links come from the following:

       "&lt;a href=...&gt;"
       "&lt;area href=...&gt;"
       "&lt;frame src=...&gt;"
       "&lt;iframe src=...&gt;"
       "&lt;link href=...&gt;"
       "&lt;meta content=...&gt;"

   <b>$mech-&gt;find_all_links(</b> <b>...</b> <b>)</b>
       Returns  all  the  links  on  the  current  page that match the criteria.  The method for specifying link
       criteria is the same as in find_link().  Each of the links returned is a WWW::Mechanize::Link object.

       In list context, find_all_links() returns a list of the links.  Otherwise, it returns a reference to  the
       list of links.

       find_all_links() with no parameters returns all links in the page.

   <b>$mech-&gt;find_all_inputs(</b> <b>...</b> <b>criteria</b> <b>...</b> <b>)</b>
       find_all_inputs()  returns  an array of all the input controls in the current form whose properties match
       all of the regexes passed in.  The controls returned  are  all  descended  from  HTML::Form::Input.   See
       "INPUTS" in HTML::Form for details.

       If no criteria are passed, all inputs will be returned.

       If there is no current page, there is no form on the current page, or there are no submit controls in the
       current form then the return will be an empty array.

       You may use a regex or a literal string:

           # get all textarea controls whose names begin with "customer"
           my @customer_text_inputs = $mech-&gt;find_all_inputs(
               type       =&gt; 'textarea',
               name_regex =&gt; qr/^customer/,
           );

           # get all text or textarea controls called "customer"
           my @customer_text_inputs = $mech-&gt;find_all_inputs(
               type_regex =&gt; qr/^(text|textarea)$/,
               name       =&gt; 'customer',
           );

   <b>$mech-&gt;find_all_submits(</b> <b>...</b> <b>criteria</b> <b>...</b> <b>)</b>
       find_all_submits() does the same thing as find_all_inputs() except that it only returns controls that are
       submit controls, ignoring other types of input controls like text and checkboxes.

</pre><h4><b>IMAGE</b> <b>METHODS</b></h4><pre>
   <b>$mech-&gt;images</b>
       Lists all the images on the current page.  Each image is a WWW::Mechanize::Image object. In list context,
       returns a list of all images.  In scalar context, returns an array reference of all images.

   <b>$mech-&gt;find_image()</b>
       Finds  an image in the current page. It returns a WWW::Mechanize::Image object which describes the image.
       If it fails to find an image it returns "undef".

       You can select which image to find by passing in one or more of these key/value pairs:

       •   "alt =&gt; 'string'" and "alt_regex =&gt; qr/regex/"

           "alt" matches the ALT attribute of the image against <u>string</u>, which must be an exact match. To  select
           a image with an ALT tag that is exactly "download", use

               $mech-&gt;find_image( alt =&gt; 'download' );

           "alt_regex" matches the ALT attribute of the image  against a regular expression.  To select an image
           with an ALT attribute that has "download" anywhere in it, regardless of case, use

               $mech-&gt;find_image( alt_regex =&gt; qr/download/i );

       •   "url =&gt; 'string'" and "url_regex =&gt; qr/regex/"

           Matches the URL of the image against <u>string</u> or <u>regex</u>, as appropriate.  The URL may be a relative URL,
           like <u>foo/bar.html</u>, depending on how it's coded on the page.

       •   "url_abs =&gt; string" and "url_abs_regex =&gt; regex"

           Matches  the  absolute  URL of the image against <u>string</u> or <u>regex</u>, as appropriate.  The URL will be an
           absolute URL, even if it's relative in the page.

       •   "tag =&gt; string" and "tag_regex =&gt; regex"

           Matches the tag that the image came from against <u>string</u> or <u>regex</u>, as appropriate.  The "tag_regex" is
           probably most useful to check for more than one tag, as in:

               $mech-&gt;find_image( tag_regex =&gt; qr/^(img|input)$/ );

           The tags supported are "&lt;img&gt;" and "&lt;input&gt;".

       •   "id =&gt; string" and "id_regex =&gt; regex"

           "id" matches the id attribute of the image against <u>string</u>, which must be an exact match. To select an
           image with the exact id "download-image", use

               $mech-&gt;find_image( id =&gt; 'download-image' );

           "id_regex" matches the id attribute of the image against a regular expression. To  select  the  first
           image with an id that contains "download" anywhere in it, use

               $mech-&gt;find_image( id_regex =&gt; qr/download/ );

       •   "classs =&gt; string" and "class_regex =&gt; regex"

           "class"  matches  the  class  attribute of the image against <u>string</u>, which must be an exact match. To
           select an image with the exact class "img-fuid", use

               $mech-&gt;find_image( class =&gt; 'img-fluid' );

           To select an image with the class attribute "rounded float-left", use

               $mech-&gt;find_image( class =&gt; 'rounded float-left' );

           Note that the classes have to be matched as a complete string, in the exact order they appear in  the
           website's source code.

           "class_regex"  matches the class attribute of the image against a regular expression. Use this if you
           want a partial class name, or if an image has several classes, but you only care about one.

           To select the first image with the class "rounded", where there are multiple images that  might  also
           have either class "float-left" or "float-right", use

               $mech-&gt;find_image( class_regex =&gt; qr/\brounded\b/ );

           Selecting  an  image  with  multiple classes where you do not care about the order they appear in the
           website's source code is not currently supported.

       If "n" is not specified, it defaults to 1.  Therefore, if you  don't  specify  any  params,  this  method
       defaults to finding the first image on the page.

       Note  that you can specify multiple ALT or URL parameters, which will be ANDed together.  For example, to
       find the first image with ALT text of "News" and with "cnn.com" in the URL, use:

           $mech-&gt;find_image( image =&gt; 'News', url_regex =&gt; qr/cnn\.com/ );

       The return value is a reference to an array containing a WWW::Mechanize::Image object for every image  in
       "$mech-&gt;content".

   <b>$mech-&gt;find_all_images(</b> <b>...</b> <b>)</b>
       Returns  all  the  images  on  the current page that match the criteria.  The method for specifying image
       criteria is the same as in find_image().  Each of the images returned is a WWW::Mechanize::Image object.

       In list context, find_all_images() returns a list of the images.  Otherwise, it returns  a  reference  to
       the list of images.

       find_all_images() with no parameters returns all images in the page.

</pre><h4><b>FORM</b> <b>METHODS</b></h4><pre>
       These methods let you work with the forms on a page.  The idea is to choose a form that you'll later work
       with using the field methods below.

   <b>$mech-&gt;forms</b>
       Lists  all the forms on the current page.  Each form is an HTML::Form object.  In list context, returns a
       list of all forms.  In scalar context, returns an array reference of all forms.

   <b>$mech-&gt;form_number($number)</b>
       Selects the <u>number</u>th form on the page as the target for subsequent calls to field()  and  click().   Also
       returns the form that was selected.

       If it is found, the form is returned as an HTML::Form object and set internally for later use with Mech's
       form methods such as field() and click().  When called in a list context, the number of the found form is
       also returned as a second value.

       Emits a warning and returns "undef" if no form is found.

       The first form is number 1, not zero.

   <b>$mech-&gt;form_action(</b> <b>$action</b> <b>)</b>
       Selects  a  form by action, using a regex containing $action.  If there is more than one form on the page
       matching that action, then the first one is used, and a warning is generated.

       If it is found, the form is returned as an HTML::Form object and set internally for later use with Mech's
       form methods such as field() and click().

       Returns "undef" if no form is found.

   <b>$mech-&gt;form_name(</b> <b>$name</b> <b>[,</b> <b>\%args</b> <b>]</b> <b>)</b>
       Selects a form by name.

       By default, the first form that has this name will be returned.

           my $form = $mech-&gt;form_name("order_form");

       If you want the second, third or nth match, pass an  optional  arguments  hash  reference  as  the  final
       parameter with a key "n" to pick which instance you want. The numbering starts at 1.

           my $third_product_form = $mech-&gt;form_name("buy_now", { n =&gt; 3 });

       If  the "n" parameter is not passed, and there is more than one form on the page with that name, then the
       first one is used, and a warning is generated.

       If it is found, the form is returned as an HTML::Form object and set internally for later use with Mech's
       form methods such as field() and click().

       Returns "undef" if no form is found.

   <b>$mech-&gt;form_id(</b> <b>$id</b> <b>[,</b> <b>\%args</b> <b>]</b> <b>)</b>
       Selects a form by ID.

       By default, the first form that has this ID will be returned.

           my $form = $mech-&gt;form_id("order_form");

       Although the HTML specification requires the ID to be unique within a page, some pages might  not  adhere
       to  that.  If  you  want the second, third or nth match, pass an optional arguments hash reference as the
       final parameter with a key "n" to pick which instance you want. The numbering starts at 1.

           my $third_product_form = $mech-&gt;form_id("buy_now", { n =&gt; 3 });

       If the "n" parameter is not passed, and there is more than one form on the page with that  ID,  then  the
       first one is used, and a warning is generated.

       If it is found, the form is returned as an HTML::Form object and set internally for later use with Mech's
       form methods such as field() and click().

       If no form is found it returns "undef".  This will also trigger a warning, unless "quiet" is enabled.

   <b>$mech-&gt;all_forms_with_fields(</b> <b>@fields</b> <b>)</b>
       Selects  a  form  by passing in a list of field names it must contain.  All matching forms (perhaps none)
       are returned as a list of HTML::Form objects.

   <b>$mech-&gt;form_with_fields(</b> <b>@fields,</b> <b>[</b> <b>\%args</b> <b>]</b> <b>)</b>
       Selects a form by passing in a list of field names it must contain.  By  default,  the  first  form  that
       matches all of these field names will be returned.

           my $form = $mech-&gt;form_with_fields( qw/sku quantity add_to_cart/ );

       If  you  want  the  second,  third  or  nth match, pass an optional arguments hash reference as the final
       parameter with a key "n" to pick which instance you want. The numbering starts at 1.

           my $form = $mech-&gt;form_with_fields( 'sky', 'qty', { n =&gt; 2 } );

       If the "n" parameter is not passed, and there is more than one form on the page with that  ID,  then  the
       first one is used, and a warning is generated.

       If  it  is  found,  the  form  is returned as an HTML::Form object and set internally for later used with
       Mech's form methods such as field() and click().

       Returns "undef" and emits a warning if no form is found.

       Note that this functionality requires libwww-perl 5.69 or higher.

   <b>$mech-&gt;all_forms_with(</b> <b>$attr1</b> <b>=&gt;</b> <b>$value1,</b> <b>$attr2</b> <b>=&gt;</b> <b>$value2,</b> <b>...</b> <b>)</b>
       Searches for forms with arbitrary attribute/value pairs within the &lt;form&gt; tag.  When given more than  one
       pair,  all  criteria must match.  Using "undef" as value means that the attribute in question must not be
       present.

       All matching forms (perhaps none) are returned as a list of HTML::Form objects.

   <b>$mech-&gt;form_with(</b> <b>$attr1</b> <b>=&gt;</b> <b>$value1,</b> <b>$attr2</b> <b>=&gt;</b> <b>$value2,</b> <b>...,</b> <b>[</b> <b>\%args</b> <b>]</b> <b>)</b>
       Searches for forms with arbitrary attribute/value pairs within the &lt;form&gt; tag.  When given more than  one
       pair,  all  criteria must match.  Using "undef" as value means that the attribute in question must not be
       present.

       By default, the first form that matches all criteria will be returned.

           my $form = $mech-&gt;form_with( name =&gt; 'order_form', method =&gt; 'POST' );

       If you want the second, third or nth match, pass an  optional  arguments  hash  reference  as  the  final
       parameter with a key "n" to pick which instance you want. The numbering starts at 1.

           my $form = $mech-&gt;form_with( method =&gt; 'POST', { n =&gt; 4 } );

       If  the "n" parameter is not passed, and there is more than one form on the page matching these criteria,
       then the first one is used, and a warning is generated.

       If it is found, the form is returned as an HTML::Form object and  set  internally  for  later  used  with
       Mech's form methods such as field() and click().

       Returns "undef" if no form is found.

</pre><h4><b>FIELD</b> <b>METHODS</b></h4><pre>
       These methods allow you to set the values of fields in a given form.

   <b>$mech-&gt;field(</b> <b>$name,</b> <b>$value,</b> <b>$number</b> <b>)</b>
   <b>$mech-&gt;field(</b> <b>$name,</b> <b>\@values,</b> <b>$number</b> <b>)</b>
   <b>$mech-&gt;field(</b> <b>$name,</b> <b>\@file_upload_values,</b> <b>$number</b> <b>)</b>
       Given  the  name  of a field, set its value to the value specified.  This applies to the current form (as
       set by the form_name() or form_number() method or defaulting to the first form on the page).

       If the field is of type "file", its value should be an arrayref. Example:

           $mech-&gt;field( $file_input, ['/tmp/file.txt'] );

       Value examples for "file" inputs, followed by explanation of what each index mean:

           # 0: filepath      1: filename    3: headers
           ['/tmp/file.txt']
           ['/tmp/file.txt', 'filename.txt']
           ['/tmp/file.txt', 'filename.txt', @headers]
           ['/tmp/file.txt', 'filename.txt', Content =&gt; 'some content']
           [undef,           'filename.txt', Content =&gt; 'content here']

       Index 0 is the <u>filepath</u> that will be read from disk. Index 1 is the filename which will be  used  in  the
       HTTP  request  body;  if not given, filepath (index 0) is used instead. If "Content =&gt; 'content here'" is
       used as shown, then <u>filepath</u> will be ignored.

       The optional $number parameter is used to distinguish between two fields with the same name.  The  fields
       are numbered from 1.

   <b>$mech-&gt;select($name,</b> <b>$new_or_additional_single_value)</b>
   <b>$mech-&gt;select($name,</b> <b>\%new_single_value_by_number)</b>
   <b>$mech-&gt;select($name,</b> <b>\@new_list_of_values)</b>
   <b>$mech-&gt;select($name,</b> <b>\%new_list_of_values_by_number)</b>
       Given the name of a "select" field, set its value to the value specified.

           # select 'foo'
           $mech-&gt;select($name, 'foo');

       If  the  field is not "&lt;select multiple&gt;" and the $value is an array reference, only the <b>first</b> value will
       be set.  [Note: until version 1.05_03 the documentation claimed that only the last value  would  be  set,
       but this was incorrect.]

           # select 'bar'
           $mech-&gt;select($name, ['bar', 'ignored', 'ignored']);

       Passing $value as a hash reference with an "n" key selects an item by number.

           # select the third value
           $mech-&gt;select($name, {n =&gt; 3});

       The numbering starts at 1.  This applies to the current form.

       If  you  have a field with "&lt;select multiple&gt;" and you pass a single $value, then $value will be added to
       the list of fields selected, without clearing the others.

           # add 'bar' to the list of selected values
           $mech-&gt;select($name, 'bar');

       However, if you pass an array reference, then all previously selected values will be cleared and replaced
       with all values inside the array reference.

           # replace the selection with 'foo' and 'bar'
           $mech-&gt;select($name, ['foo', 'bar']);

       This also works when selecting by numbers, in which case the value of  the  "n"  key  will  be  an  array
       reference of value numbers you want to replace the selection with.

           # replace the selection with the 2nd and 4th element
           $mech-&gt;select($name, {n =&gt; [2, 4]});

       To  add  multiple additional values to the list of selected fields without clearing, call "select" in the
       simple $value form with each single value in a loop.

           # add all values in the array to the selection
           $mech-&gt;select($name, $_) for @additional_values;

       Returns true on successfully setting the value. On failure, returns false and calls "$self-&gt;warn()"  with
       an error message.

   <b>$mech-&gt;set_fields(</b> <b>$name</b> <b>=&gt;</b> <b>$value</b> <b>...</b> <b>)</b>
   <b>$mech-&gt;set_fields(</b> <b>$name</b> <b>=&gt;</b> <b>\@value_and_instance_number</b> <b>)</b>
   <b>$mech-&gt;set_fields(</b> <b>$name</b> <b>=&gt;</b> <b>\$value_instance_number</b> <b>)</b>
   <b>$mech-&gt;set_fields(</b> <b>$name</b> <b>=&gt;</b> <b>\@file_upload</b> <b>)</b>
       This  method  sets multiple fields of the current form. It takes a list of field name and value pairs. If
       there is more than one field with the same name, the first one found is set. If you want to select  which
       of  the duplicate field to set, use a value which is an anonymous array which has the field value and its
       number as the 2 elements.

               # set the second $name field to 'foo'
               $mech-&gt;set_fields( $name =&gt; [ 'foo', 2 ] );

       The value of a field of type "file" should be an arrayref as described in field(). Examples:

               $mech-&gt;set_fields( $file_field =&gt; ['/tmp/file.txt'] );
               $mech-&gt;set_fields( $file_field =&gt; ['/tmp/file.txt', 'filename.txt'] );

       The value for a "file" input can also be an arrayref containing an arrayref and a number,  as  documented
       in submit_form().  The number will be used to find the field in the form. Example:

               $mech-&gt;set_fields( $file_field =&gt; [['/tmp/file.txt'], 1] );

       The fields are numbered from 1.

       For  fields  that have a predefined set of values, you may also provide a reference to an integer, if you
       don't know the options for the field, but you know you just want (e.g.) the first one.

               # select the first value in the $name select box
               $mech-&gt;set_fields( $name =&gt; \0 );
               # select the last value in the $name select box
               $mech-&gt;set_fields( $name =&gt; \-1 );

       This applies to the current form.

   <b>$mech-&gt;set_visible(</b> <b>@criteria</b> <b>)</b>
       This method sets fields of the current form without having to know their names.  So if you have  a  login
       screen  that  wants a username and password, you do not have to fetch the form and inspect the source (or
       use the <u>mech-dump</u> utility, installed with WWW::Mechanize) to see what the field names are; you  can  just
       say

           $mech-&gt;set_visible( $username, $password );

       and  the  first  and  second fields will be set accordingly.  The method is called set_<u>visible</u> because it
       acts only on visible fields; hidden form inputs are not considered.  The order of the fields is the order
       in which they appear in the HTML source which is nearly always the order anyone viewing  the  page  would
       think they are in, but some creative work with tables could change that; caveat user.

       Each  element  in  @criteria is either a field value or a field specifier.  A field value is a scalar.  A
       field specifier allows you to specify the <u>type</u> of input field you want to set  and  is  denoted  with  an
       arrayref containing two elements.  So you could specify the first radio button with

           $mech-&gt;set_visible( [ radio =&gt; 'KCRW' ] );

       Field values and specifiers can be intermixed, hence

           $mech-&gt;set_visible( 'fred', 'secret', [ option =&gt; 'Checking' ] );

       would set the first two fields to "fred" and "secret", and the <u>next</u> "OPTION" menu field to "Checking".

       The  possible  field  specifier  types  are:  "text",  "password", "hidden", "textarea", "file", "image",
       "submit", "radio", "checkbox" and "option".

       "set_visible" returns the number of values set.

   <b>$mech-&gt;tick(</b> <b>$name,</b> <b>$value</b> <b>[,</b> <b>$set]</b> <b>)</b>
       "Ticks" the first checkbox that has both the name and value associated with it on the current  form.   If
       there  is  no  value  to  the  input,  just pass an empty string as the value.  Dies if there is no named
       checkbox for the value given, if a value is given.  Passing in  a  false  value  as  the  third  optional
       argument  will cause the checkbox to be unticked.  The third value does not need to be set if you wish to
       merely tick the box.

           $mech-&gt;tick('extra', 'cheese');
           $mech-&gt;tick('extra', 'mushrooms');

           $mech-&gt;tick('no_value', ''); # &lt;input type="checkbox" name="no_value"&gt;

   <b>$mech-&gt;untick($name,</b> <b>$value)</b>
       Causes the checkbox to be unticked.  Shorthand for "tick($name,$value,undef)"

   <b>$mech-&gt;value(</b> <b>$name</b> <b>[,</b> <b>$number]</b> <b>)</b>
       Given the name of a field, return its value. This applies to the current form.

       The optional $number parameter is used to distinguish between two fields with the same name.  The  fields
       are numbered from 1.

       If  the  field  is  of type file (file upload field), the value is always cleared to prevent remote sites
       from downloading your local files.  To upload a file, specify its file name explicitly.

   <b>$mech-&gt;click(</b> <b>$button</b> <b>[,</b> <b>$x,</b> <b>$y]</b> <b>)</b>
       Has the effect of clicking a button on the current form.  The first argument is the name of the button to
       be clicked.  The second and third arguments (optional) allow you to specify the (x,y) coordinates of  the
       click.

       If  there  is  only  one  button  on  the form, "$mech-&gt;click()" with no arguments simply clicks that one
       button.

       Returns an HTTP::Response object.

   <b>$mech-&gt;click_button(</b> <b>...</b> <b>)</b>
       Has the effect of clicking a button on the current form by specifying its attributes. The arguments are a
       list of key/value pairs. Only one of name, id, number, input or value must be specified in the keys.

       Dies if no button is found.

       •   "name =&gt; name"

           Clicks the button named <u>name</u> in the current form.

       •   "id =&gt; id"

           Clicks the button with the id <u>id</u> in the current form.

       •   "number =&gt; n"

           Clicks the <u>n</u>th button with type <u>submit</u> in the current form.  Numbering starts at 1.

       •   "value =&gt; value"

           Clicks the button with the value <u>value</u> in the current form.

       •   "input =&gt; $inputobject"

           Clicks on the button referenced by $inputobject, an instance of HTML::Form::SubmitInput obtained e.g.
           from

               $mech-&gt;current_form()-&gt;find_input( undef, 'submit' )

           $inputobject must belong to the current form.

       •   "x =&gt; x"

       •   "y =&gt; y"

           These arguments (optional) allow you to specify the (x,y) coordinates of the click.

   <b>$mech-&gt;submit()</b>
       Submits the current form, without specifying a button to click.  Actually, no button is clicked at all.

       Returns an HTTP::Response object.

       This used to be a synonym for "$mech-&gt;click( 'submit' )", but is no longer so.

   <b>$mech-&gt;submit_form(</b> <b>...</b> <b>)</b>
       This method lets you select a form from the previously fetched page, fill in its fields, and  submit  it.
       It  combines  the "form_number"/"form_name", "set_fields" and "click" methods into one higher level call.
       Its arguments are a list of key/value pairs, all of which are optional.

       •   "fields =&gt; \%fields"

           Specifies the fields to be filled in the current form.

       •   "with_fields =&gt; \%fields"

           Probably all you need for the common case. It combines a smart form selector and data setting in  one
           operation.  It selects the first form that contains all fields mentioned in "\%fields".  This is nice
           because you don't need to know the name or number of the form to do this.

           (calls form_with_fields() and set_fields()).

           If you choose "with_fields", the "fields" option will be ignored. The "form_number", "form_name"  and
           "form_id"  options  will  still be used.  An exception will be thrown unless exactly one form matches
           all of the provided criteria.

       •   "form_number =&gt; n"

           Selects the <u>n</u>th form (calls form_number().  If this param is not  specified,  the  currently-selected
           form is used.

       •   "form_name =&gt; name"

           Selects the form named <u>name</u> (calls form_name())

       •   "form_id =&gt; ID"

           Selects the form with ID <u>ID</u> (calls form_id())

       •   "button =&gt; button"

           Clicks on button <u>button</u> (calls click())

       •   "x =&gt; x, y =&gt; y"

           Sets the x or y values for click()

       •   "strict_forms =&gt; bool"

           Sets  the  HTML::Form  strict  flag which causes form submission to croak if any of the passed fields
           don't exist on the page, and/or a value doesn't exist in a select  element.   By  default  HTML::Form
           sets this value to false.

           This behavior can also be turned on globally by passing "strict_forms =&gt; 1" to "WWW::Mechanize-&gt;new".
           If you do that, you can still disable it for individual calls by passing "strict_forms =&gt; 0" here.

       If no form is selected, the first form found is used.

       If <u>button</u> is not passed, then the submit() method is used instead.

       If  you want to submit a file and get its content from a scalar rather than a file in the filesystem, you
       can use:

           $mech-&gt;submit_form(with_fields =&gt; { logfile =&gt; [ [ undef, 'whatever', Content =&gt; $content ], 1 ] } );

       Returns an HTTP::Response object.

</pre><h4><b>MISCELLANEOUS</b> <b>METHODS</b></h4><pre>
   <b>$mech-&gt;add_header(</b> <b>name</b> <b>=&gt;</b> <b>$value</b> <b>[,</b> <b>name</b> <b>=&gt;</b> <b>$value...</b> <b>]</b> <b>)</b>
       Sets HTTP headers for the agent to add or remove from the HTTP request.

           $mech-&gt;add_header( Encoding =&gt; 'text/klingon' );

       If a <u>value</u> is "undef", then that header will be removed from any future requests.  For example, to  never
       send a Referer header:

           $mech-&gt;add_header( Referer =&gt; undef );

       If you want to delete a header, use "delete_header".

       Returns the number of name/value pairs added.

       <b>NOTE</b>:  This  method was very different in WWW::Mechanize before 1.00.  Back then, the headers were stored
       in a package hash, not as a member of the object instance.  Calling add_header() would modify the headers
       for every WWW::Mechanize object, even after your object no longer existed.

   <b>$mech-&gt;delete_header(</b> <b>name</b> <b>[,</b> <b>name</b> <b>...</b> <b>]</b> <b>)</b>
       Removes HTTP headers from the agent's list of special headers.   For  instance,  you  might  need  to  do
       something like:

           # Don't send a Referer for this URL
           $mech-&gt;add_header( Referer =&gt; undef );

           # Get the URL
           $mech-&gt;get( $url );

           # Back to the default behavior
           $mech-&gt;delete_header( 'Referer' );

   <b>$mech-&gt;quiet(true/false)</b>
       Allows you to suppress warnings to the screen.

           $mech-&gt;<a href="../man0/quiet.0.html">quiet</a>(0); # turns on warnings (the default)
           $mech-&gt;<a href="../man1/quiet.1.html">quiet</a>(1); # turns off warnings
           $mech-&gt;quiet();  # returns the current quietness status

   <b>$mech-&gt;autocheck(true/false)</b>
       Allows you to enable and disable autochecking.

       Autocheck  checks  each  request made to see if it was successful. This saves you the trouble of manually
       checking yourself. Any errors found are errors, not warnings. Please see "new" for more details.

           $mech-&gt;<a href="../man1/autocheck.1.html">autocheck</a>(1); # turns on automatic request checking (the default)
           $mech-&gt;<a href="../man0/autocheck.0.html">autocheck</a>(0); # turns off automatic request checking
           $mech-&gt;autocheck();  # returns the current autocheck status

   <b>$mech-&gt;stack_depth(</b> <b>$max_depth</b> <b>)</b>
       Get or set the page stack depth. Use this if you're doing a lot of  page  scraping  and  running  out  of
       memory.

       A  value  of  0  means  "no  history  at  all."   By  default,  the max stack depth is humongously large,
       effectively keeping all history.

   <b>$mech-&gt;save_content(</b> <b>$filename,</b> <b>%opts</b> <b>)</b>
       Dumps the contents of "$mech-&gt;content" into $filename.  $filename will be overwritten.  Dies if there are
       any errors.

       If the content type does not begin with "text/", then the content is saved in binary mode (i.e. binmode()
       is set on the output filehandle).

       Additional arguments can be passed as <u>key</u>/<u>value</u> pairs:

       <u>$mech-&gt;save_content(</u> <u>$filename,</u> <u>binary</u> <u>=&gt;</u> <u>1</u> <u>)</u>
           Filehandle   is   set   with   "binmode"   to    ":raw"    and    contents    are    taken    calling
           "$self-&gt;content(decoded_by_headers =&gt; 1)". Same as calling:

               $mech-&gt;save_content( $filename, binmode =&gt; ':raw',
                                    decoded_by_headers =&gt; 1 );

           This <u>should</u> be the safest way to save contents verbatim.

       <u>$mech-&gt;save_content(</u> <u>$filename,</u> <u>binmode</u> <u>=&gt;</u> <u>$binmode</u> <u>)</u>
           Filehandle  is  set  to  binary  mode.  If  $binmode  begins with ':', it is passed as a parameter to
           "binmode":

               binmode $fh, $binmode;

           otherwise the filehandle is set to binary mode if $binmode is true:

               binmode $fh;

       <u>all</u> <u>other</u> <u>arguments</u>
           are passed as-is to "$mech-&gt;content(%opts)". In particular, "decoded_by_headers" might come handy  if
           you  want  to  revert  the effect of line compression performed by the web server but without further
           interpreting the contents (e.g. decoding it according to the charset).

   <b>$mech-&gt;dump_headers(</b> <b>[$fh]</b> <b>)</b>
       Prints a dump of the HTTP response headers for the most recent response.  If $fh is not specified  or  is
       "undef", it dumps to STDOUT.

       Unlike the rest of the "dump_*" methods, $fh can be a scalar. It will be used as a file name.

   <b>$mech-&gt;dump_links(</b> <b>[[$fh],</b> <b>$absolute]</b> <b>)</b>
       Prints  a  dump of the links on the current page to $fh.  If $fh is not specified or is "undef", it dumps
       to STDOUT.

       If $absolute is true, links displayed are absolute, not relative.

   <b>$mech-&gt;dump_images(</b> <b>[[$fh],</b> <b>$absolute]</b> <b>)</b>
       Prints a dump of the images on the current page to $fh.  If $fh is not specified or is "undef", it  dumps
       to STDOUT.

       If $absolute is true, links displayed are absolute, not relative.

       The output will include empty lines for images that have no "src" attribute and therefore no URL.

   <b>$mech-&gt;dump_forms(</b> <b>[$fh]</b> <b>)</b>
       Prints  a  dump of the forms on the current page to $fh.  If $fh is not specified or is "undef", it dumps
       to STDOUT. Running the following:

           my $mech = WWW::Mechanize-&gt;new();
           $mech-&gt;get("https://www.google.com/");
           $mech-&gt;dump_forms;

       will print:

           GET https://www.google.com/search [f]
             ie=ISO-8859-1                  (hidden readonly)
             hl=en                          (hidden readonly)
             source=hp                      (hidden readonly)
             biw=                           (hidden readonly)
             bih=                           (hidden readonly)
             q=                             (text)
             btnG=Google Search             (submit)
             btnI=I'm Feeling Lucky         (submit)
             gbv=1                          (hidden readonly)

   <b>$mech-&gt;dump_text(</b> <b>[$fh]</b> <b>)</b>
       Prints a dump of the text on the current page to $fh.  If $fh is not specified or is "undef", it dumps to
       STDOUT.

</pre><h4><b>OVERRIDDEN</b> <b>LWP::UserAgent</b> <b>METHODS</b></h4><pre>
   <b>$mech-&gt;clone()</b>
       Clone the mech object.  The clone will be using the same cookie jar as the original mech.

   <b>$mech-&gt;redirect_ok()</b>
       An overloaded version of redirect_ok() in LWP::UserAgent.  This method is used  to  determine  whether  a
       redirection in the request should be followed.

       Note that WWW::Mechanize's constructor pushes POST on to the agent's "requests_redirectable" list.

   <b>$mech-&gt;request(</b> <b>$request</b> <b>[,</b> <b>$arg</b> <b>[,</b> <b>$size]])</b>
       Overloaded  version  of  request()  in LWP::UserAgent.  Performs the actual request.  Normally, if you're
       using WWW::Mechanize, it's because you don't want to deal with this level of stuff anyway.

       Note that $request will be modified.

       Returns an HTTP::Response object.

   <b>$mech-&gt;update_html(</b> <b>$html</b> <b>)</b>
       Allows you to replace the HTML that the mech has found.  Updates the forms and links parse-trees that the
       mech uses internally.

       Say you have a page that you know has malformed output, and you want to update it so the links  come  out
       correctly:

           my $html = $mech-&gt;content;
           $html =~ s[&lt;/option&gt;.{0,3}&lt;/td&gt;][&lt;/option&gt;&lt;/select&gt;&lt;/td&gt;]isg;
           $mech-&gt;update_html( $html );

       This  method  is  also  used  internally by the mech itself to update its own HTML content when loading a
       page. This means that if you would like to <u>systematically</u> perform the above HTML substitution, you  would
       overload "update_html" in a subclass thusly:

          package MyMech;
          use parent 'WWW::Mechanize';

          sub update_html {
              my ($self, $html) = @_;
              $html =~ s[&lt;/option&gt;.{0,3}&lt;/td&gt;][&lt;/option&gt;&lt;/select&gt;&lt;/td&gt;]isg;
              $self-&gt;WWW::Mechanize::update_html( $html );
          }

       If  you  do this, then the mech will use the tidied-up HTML instead of the original both when parsing for
       its own needs, and for returning to you through content().

       Overloading this method is also the recommended way of implementing extra  validation  steps  (e.g.  link
       checkers)  for every HTML page received.  "warn" and "warn" would then come in handy to signal validation
       errors.

   <b>$mech-&gt;credentials(</b> <b>$username,</b> <b>$password</b> <b>)</b>
       Provide credentials to be used for HTTP Basic authentication for  all  sites  and  realms  until  further
       notice.

       The four argument form described in LWP::UserAgent is still supported.

   <b>$mech-&gt;get_basic_credentials(</b> <b>$realm,</b> <b>$uri,</b> <b>$isproxy</b> <b>)</b>
       Returns the credentials for the realm and URI.

   <b>$mech-&gt;clear_credentials()</b>
       Remove any credentials set up with credentials().

</pre><h4><b>INHERITED</b> <b>UNCHANGED</b> <b>LWP::UserAgent</b> <b>METHODS</b></h4><pre>
       As  a subclass of LWP::UserAgent, WWW::Mechanize inherits all of LWP::UserAgent's methods.  Many of which
       are overridden or extended. The following  methods  are  inherited  unchanged.  View  the  LWP::UserAgent
       documentation for their implementation descriptions.

       This is not meant to be an inclusive list.  LWP::UA may have added others.

   <b>$mech-&gt;head()</b>
       Inherited from LWP::UserAgent.

   <b>$mech-&gt;mirror()</b>
       Inherited from LWP::UserAgent.

   <b>$mech-&gt;simple_request()</b>
       Inherited from LWP::UserAgent.

   <b>$mech-&gt;is_protocol_supported()</b>
       Inherited from LWP::UserAgent.

   <b>$mech-&gt;prepare_request()</b>
       Inherited from LWP::UserAgent.

   <b>$mech-&gt;progress()</b>
       Inherited from LWP::UserAgent.

</pre><h4><b>INTERNAL-ONLY</b> <b>METHODS</b></h4><pre>
       These methods are only used internally.  You probably don't need to know about them.

   <b>$mech-&gt;_update_page($request,</b> <b>$response)</b>
       Updates  all  internal  variables  in $mech as if $request was just performed, and returns $response. The
       page stack is <b>not</b> altered by this method, it is up to caller (e.g.  "request") to do that.

   <b>$mech-&gt;_modify_request(</b> <b>$req</b> <b>)</b>
       Modifies a HTTP::Request before the request is sent out, for both GET and POST requests.

       We add a "Referer" header, as well as header to  note  that  we  can  accept  gzip  encoded  content,  if
       Compress::Zlib is installed.

   <b>$mech-&gt;_make_request()</b>
       Convenience method to make it easier for subclasses like WWW::Mechanize::Cached to intercept the request.

   <b>$mech-&gt;_reset_page()</b>
       Resets the internal fields that track page parsed stuff.

   <b>$mech-&gt;_extract_links()</b>
       Extracts   links   from   the   content   of  a  webpage,  and  populates  the  "{links}"  property  with
       WWW::Mechanize::Link objects.

   <b>$mech-&gt;_push_page_stack()</b>
       The agent keeps a stack of visited pages, which it can pop when it needs to go BACK and so on.

       The current page needs to be pushed onto the stack before we get a new page, and the stack  needs  to  be
       popped when BACK occurs.

       Neither of these take any arguments, they just operate on the $mech object.

   <b>warn(</b> <b>@messages</b> <b>)</b>
       Centralized  warning  method,  for diagnostics and non-fatal problems.  Defaults to calling "CORE::warn",
       but may be overridden by setting "onwarn" in the constructor.

   <b>die(</b> <b>@messages</b> <b>)</b>
       Centralized error method.  Defaults to calling "CORE::die", but may be overridden by setting "onerror" in
       the constructor.

</pre><h4><b>BEST</b> <b>PRACTICES</b></h4><pre>
       The default settings can get you up and running quickly, but there are settings you can change  in  order
       to make your life easier.

       autocheck
           "autocheck"  can  save  you the overhead of checking status codes for success.  You may outgrow it as
           your needs get more sophisticated, but it's a safe option to start with.

               my $agent = WWW::Mechanize-&gt;new( autocheck =&gt; 1 );

       cookie_jar
           You are encouraged to install Mozilla::PublicSuffix and use HTTP::CookieJar::LWP as your cookie  jar.
           HTTP::CookieJar::LWP  provides  a  better  security  model matching that of current Web browsers when
           Mozilla::PublicSuffix is installed.

               use HTTP::CookieJar::LWP ();

               my $jar = HTTP::CookieJar::LWP-&gt;new;
               my $agent = WWW::Mechanize-&gt;new( cookie_jar =&gt; $jar );

       protocols_allowed
           This option is inherited directly from LWP::UserAgent.  It may be used to allow arbitrary protocols.

               my $agent = WWW::Mechanize-&gt;new(
                   protocols_allowed =&gt; [ 'http', 'https' ]
               );

           This will prevent you from inadvertently following URLs like "file://<a href="file:/etc/passwd">/etc/passwd</a>"

       protocols_forbidden
           This option is also inherited directly from  LWP::UserAgent.   It  may  be  used  to  deny  arbitrary
           protocols.

               my $agent = WWW::Mechanize-&gt;new(
                   protocols_forbidden =&gt; [ 'file', 'mailto', 'ssh', ]
               );

           This will prevent you from inadvertently following URLs like "file://<a href="file:/etc/passwd">/etc/passwd</a>"

       strict_forms
           Consider  turning  on  the  "strict_forms"  option  when  you create a new Mech.  This will perform a
           helpful sanity check on form fields every time you are submitting a form, which can save you a lot of
           debugging time.

               my $agent = WWW::Mechanize-&gt;new( strict_forms =&gt; 1 );

           If you do not want to have this option globally, you can still turn it on for individual forms.

               $agent-&gt;submit_form( fields =&gt; { foo =&gt; 'bar' } , strict_forms =&gt; 1 );

</pre><h4><b>WWW::MECHANIZE'S</b> <b>GIT</b> <b>REPOSITORY</b></h4><pre>
       WWW::Mechanize is hosted at GitHub.

       Repository:                    &lt;https://github.com/libwww-perl/WWW-Mechanize&gt;.                      Bugs:
       &lt;https://github.com/libwww-perl/WWW-Mechanize/issues&gt;.

</pre><h4><b>OTHER</b> <b>DOCUMENTATION</b></h4><pre>
   <u><b>Spidering</b></u> <u><b>Hacks</b></u><b>,</b> <b>by</b> <b>Kevin</b> <b>Hemenway</b> <b>and</b> <b>Tara</b> <b>Calishain</b>
       <u>Spidering</u>  <u>Hacks</u>  from  O'Reilly (&lt;<a href="http://www.oreilly.com/catalog/spiderhks/">http://www.oreilly.com/catalog/spiderhks/</a>&gt;) is a great book for anyone
       wanting to know more about screen-scraping and spidering.

       There are six hacks that use Mech or a Mech derivative:

       #21 WWW::Mechanize 101
       #22 Scraping with WWW::Mechanize
       #36 Downloading Images from Webshots
       #44 Archiving Yahoo! Groups Messages with WWW::Yahoo::Groups
       #64 Super Author Searching
       #73 Scraping TV Listings

       The        book         was         also         positively         reviewed         on         Slashdot:
       &lt;<a href="http://books.slashdot.org/article.pl">http://books.slashdot.org/article.pl</a>?sid=03/12/11/2126256&gt;

</pre><h4><b>ONLINE</b> <b>RESOURCES</b> <b>AND</b> <b>SUPPORT</b></h4><pre>
       •   WWW::Mechanize mailing list

           The  Mech  mailing list is at &lt;<a href="http://groups.google.com/group/www-mechanize-users">http://groups.google.com/group/www-mechanize-users</a>&gt; and is specific to
           Mechanize, unlike the LWP mailing  list  below.   Although  it  is  a  users  list,  all  development
           discussion takes place here, too.

       •   LWP mailing list

           The  LWP  mailing  list  is  at  &lt;<a href="http://lists.perl.org/showlist.cgi">http://lists.perl.org/showlist.cgi</a>?name=libwww&gt;,  and is more user-
           oriented and well-populated than the WWW::Mechanize list.

       •   Perlmonks

           &lt;<a href="http://perlmonks.org">http://perlmonks.org</a>&gt; is an excellent community of support,  and  many  questions  about  Mech  have
           already been answered there.

       •   WWW::Mechanize::Examples

           A random array of examples submitted by users, included with the Mechanize distribution.

</pre><h4><b>ARTICLES</b> <b>ABOUT</b> <b>WWW::MECHANIZE</b></h4><pre>
       •   &lt;<a href="http://www.ibm.com/developerworks/linux/library/wa-perlsecure/">http://www.ibm.com/developerworks/linux/library/wa-perlsecure/</a>&gt;

           IBM article "Secure Web site access with Perl"

       •   &lt;<a href="http://www.oreilly.com/catalog/googlehks2/chapter/hack84.pdf">http://www.oreilly.com/catalog/googlehks2/chapter/hack84.pdf</a>&gt;

           Leland Johnson's hack #84 in <u>Google</u> <u>Hacks,</u> <u>2nd</u> <u>Edition</u> is an example of a production script that uses
           WWW::Mechanize  and HTML::TableContentParser. It takes in keywords and returns the estimated price of
           these keywords on Google's AdWords program.

       •   &lt;<a href="http://www.perl.com/pub/a/2004/06/04/recorder.html">http://www.perl.com/pub/a/2004/06/04/recorder.html</a>&gt;

           Linda Julien writes about using HTTP::Recorder to create WWW::Mechanize scripts.

       •   &lt;<a href="http://www.developer.com/lang/other/article.php/3454041">http://www.developer.com/lang/other/article.php/3454041</a>&gt;

           Jason Gilmore's article on using WWW::Mechanize for scraping sales information from Amazon and eBay.

       •   &lt;<a href="http://www.perl.com/pub/a/2003/01/22/mechanize.html">http://www.perl.com/pub/a/2003/01/22/mechanize.html</a>&gt;

           Chris Ball's article about using WWW::Mechanize for scraping TV listings.

       •   &lt;<a href="http://www.stonehenge.com/merlyn/LinuxMag/col47.html">http://www.stonehenge.com/merlyn/LinuxMag/col47.html</a>&gt;

           Randal Schwartz's article on scraping Yahoo News for images.  It's already out of date:  He  manually
           walks  the  list  of links hunting for matches, which wouldn't have been necessary if the find_link()
           method existed at press time.

       •   &lt;<a href="http://www.perladvent.org/2002/16th/">http://www.perladvent.org/2002/16th/</a>&gt;

           WWW::Mechanize on the Perl Advent Calendar, by Mark Fowler.

       •   &lt;<a href="http://www.linux-magazin.de/ausgaben/2004/03/datenruessel/">http://www.linux-magazin.de/ausgaben/2004/03/datenruessel/</a>&gt;

           Michael Schilli's article on Mech and WWW::Mechanize::Shell for the German magazine <u>Linux</u> <u>Magazin</u>.

   <b>Other</b> <b>modules</b> <b>that</b> <b>use</b> <b>Mechanize</b>
       Here are modules that use or subclass Mechanize.  Let me know of any others:

       •   Finance::Bank::LloydsTSB

       •   HTTP::Recorder

           Acts as a proxy for web interaction, and then generates WWW::Mechanize scripts.

       •   Win32::IE::Mechanize

           Just like Mech, but using Microsoft Internet Explorer to do the work.

       •   WWW::Bugzilla

       •   WWW::Google::Groups

       •   WWW::Hotmail

       •   WWW::Mechanize::Cached

       •   WWW::Mechanize::Cached::GZip

       •   WWW::Mechanize::FormFiller

       •   WWW::Mechanize::Shell

       •   WWW::Mechanize::Sleepy

       •   WWW::Mechanize::SpamCop

       •   WWW::Mechanize::Timed

       •   WWW::SourceForge

       •   WWW::Yahoo::Groups

       •   WWW::Scripter

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to the numerous people who have helped out on WWW::Mechanize in  one  way  or  another,  including
       Kirrily Robert for the original "WWW::Automate", Lyle Hopkins, Damien Clark, Ansgar Burchardt, Gisle Aas,
       Jeremy  Ary,  Hilary  Holz,  Rafael Kitover, Norbert Buchmuller, Dave Page, David Sainty, H.Merijn Brand,
       Matt Lawrence, Michael Schwern, Adriano  Ferreira,  Miyagawa,  Peteris  Krumins,  Rafael  Kitover,  David
       Steinbrunner,  Kevin Falcone, Mike O'Regan, Mark Stosberg, Uri Guttman, Peter Scott, Philippe Bruhat, Ian
       Langworth, John Beppu, Gavin Estey, Jim Brandt, Ask Bjoern Hansen,  Greg  Davies,  Ed  Silva,  Mark-Jason
       Dominus, Autrijus Tang, Mark Fowler, Stuart Children, Max Maischein, Meng Wong, Prakash Kailasa, Abigail,
       Jan  Pazdziora,  Dominique  Quatravaux,  Scott Lanning, Rob Casey, Leland Johnson, Joshua Gatcomb, Julien
       Beasley, Abe Timmerman, Peter Stevens, Pete Krawczyk, Tad McClellan, and the late great Iain Truskett.

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Lester &lt;andy at petdance.com&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2004 by Andy Lester.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.40.1                                       2025-02-18                                <u>WWW::<a href="../man3pm/Mechanize.3pm.html">Mechanize</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>