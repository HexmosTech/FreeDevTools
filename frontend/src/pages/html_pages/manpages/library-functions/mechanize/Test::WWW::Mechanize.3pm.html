<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::WWW::Mechanize - Testing-specific WWW::Mechanize subclass</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-www-mechanize-perl">libtest-www-mechanize-perl_1.60-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::WWW::Mechanize - Testing-specific WWW::Mechanize subclass

</pre><h4><b>VERSION</b></h4><pre>
       Version 1.60

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Test::WWW::Mechanize is a subclass of WWW::Mechanize that incorporates features for web application
       testing.  For example:

           use Test::More tests =&gt; 5;
           use Test::WWW::Mechanize;

           my $mech = Test::WWW::Mechanize-&gt;new;
           $mech-&gt;get_ok( $page );
           $mech-&gt;base_is( '<a href="http://petdance.com/">http://petdance.com/</a>', 'Proper &lt;BASE HREF&gt;' );
           $mech-&gt;title_is( 'Invoice Status', "Make sure we're on the invoice page" );
           $mech-&gt;text_contains( 'Andy Lester', 'My name somewhere' );
           $mech-&gt;content_like( qr/(cpan|perl)\.org/, 'Link to perl.org or CPAN' );

       This is equivalent to:

           use Test::More tests =&gt; 5;
           use WWW::Mechanize;

           my $mech = WWW::Mechanize-&gt;new;
           $mech-&gt;get( $page );
           ok( $mech-&gt;success );
           is( $mech-&gt;base, '<a href="http://petdance.com">http://petdance.com</a>', 'Proper &lt;BASE HREF&gt;' );
           is( $mech-&gt;title, 'Invoice Status', "Make sure we're on the invoice page" );
           ok( index( $mech-&gt;content( format =&gt; 'text' ), 'Andy Lester' ) &gt;= 0, 'My name somewhere' );
           like( $mech-&gt;content, qr/(cpan|perl)\.org/, 'Link to perl.org or CPAN' );

       but has nicer diagnostics if they fail.

       Default descriptions will be supplied for most methods if you omit them. e.g.

           my $mech = Test::WWW::Mechanize-&gt;new;
           $mech-&gt;get_ok( '<a href="http://petdance.com/">http://petdance.com/</a>' );
           $mech-&gt;base_is( '<a href="http://petdance.com/">http://petdance.com/</a>' );
           $mech-&gt;title_is( 'Invoice Status' );
           $mech-&gt;content_contains( 'Andy Lester' );
           $mech-&gt;content_like( qr/(cpan|perl)\.org/ );

       results in

           ok - Got '<a href="http://petdance.com/">http://petdance.com/</a>' ok
           ok - Base is '<a href="http://petdance.com/">http://petdance.com/</a>'
           ok - Title is 'Invoice Status'
           ok - Text contains 'Andy Lester'
           ok - Content is like '(?-xism:(cpan|perl)\.org)'

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
   <b>new(</b> <b>%args</b> <b>)</b>
       Behaves like, and calls, WWW::Mechanize's "new" method.  Any parms passed in get passed to
       WWW::Mechanize's constructor.

       You can pass in "autolint =&gt; 1" to make Test::WWW::Mechanize automatically run HTML::Lint after any of
       the following methods are called. You can also pass in an HTML::Lint object like this:

           my $lint = HTML::Lint-&gt;new( only_types =&gt; HTML::Lint::Error::STRUCTURE );
           my $mech = Test::WWW::Mechanize-&gt;new( autolint =&gt; $lint );

       The same is also possible with "autotidy =&gt; 1" to use HTML::Tidy5.

       •   <b>get_ok()</b>

       •   <b>post_ok()</b>

       •   <b>submit_form_ok()</b>

       •   <b>follow_link_ok()</b>

       •   <b>click_ok()</b>

       This means you no longer have to do the following:

           my $mech = Test::WWW::Mechanize-&gt;new();
           $mech-&gt;get_ok( $url, 'Fetch the intro page' );
           $mech-&gt;html_lint_ok( 'Intro page looks OK' );

       and can simply do

           my $mech = Test::WWW::Mechanize-&gt;new( autolint =&gt; 1 );
           $mech-&gt;get_ok( $url, 'Fetch the intro page' );

       The  "$mech-&gt;get_ok()"  only  counts  as  one test in the test count.  Both the main IO operation and the
       linting must pass for the entire test to pass.

       You can control autolint and autotidy on the fly with the "autolint" and "autotidy" methods.

</pre><h4><b>METHODS:</b> <b>HTTP</b> <b>VERBS</b></h4><pre>
   <b>$mech-&gt;get_ok($url,</b> <b>[</b> <b>\%LWP_options</b> <b>,]</b> <b>$desc)</b>
       A wrapper around WWW::Mechanize's <b>get()</b>, with similar options, except the second argument needs to  be  a
       hash  reference, not a hash. Like well-behaved "*_ok()" functions, it returns true if the test passed, or
       false if not.

       A default description of "GET $url" is used if none if provided.

   <b>$mech-&gt;head_ok($url,</b> <b>[</b> <b>\%LWP_options</b> <b>,]</b> <b>$desc)</b>
       A wrapper around WWW::Mechanize's <b>head()</b>, with similar options, except the second argument needs to be  a
       hash  reference, not a hash. Like well-behaved "*_ok()" functions, it returns true if the test passed, or
       false if not.

       A default description of "HEAD $url" is used if none if provided.

   <b>$mech-&gt;post_ok(</b> <b>$url,</b> <b>[</b> <b>\%LWP_options</b> <b>,]</b> <b>$desc</b> <b>)</b>
       A wrapper around WWW::Mechanize's <b>post()</b>, with similar options, except the second argument needs to be  a
       hash  reference, not a hash. Like well-behaved "*_ok()" functions, it returns true if the test passed, or
       false if not.

       <b>NOTE</b> Due to compatibility reasons it is not possible to pass additional LWP_options beyond form data  via
       this  method  (such  as  Content  or Content-Type).  It is recommend that you use WWW::Mechanize's <b>post()</b>
       directly for instances where more granular control of the post is needed.

       A default description of "POST to $url" is used if none if provided.

   <b>$mech-&gt;put_ok(</b> <b>$url,</b> <b>[</b> <b>\%LWP_options</b> <b>,]</b> <b>$desc</b> <b>)</b>
       A wrapper around WWW::Mechanize's <b>put()</b>, with similar options, except the second argument needs to  be  a
       hash  reference, not a hash. Like well-behaved "*_ok()" functions, it returns true if the test passed, or
       false if not.

       A default description of "PUT to $url" is used if none if provided.

   <b>$mech-&gt;delete_ok(</b> <b>$url,</b> <b>[</b> <b>\%LWP_options</b> <b>,]</b> <b>$desc</b> <b>)</b>
       A wrapper around WWW::Mechanize's <b>delete()</b>, with similar options, except the second argument needs to  be
       a  hash  reference, not a hash. Like well-behaved "*_ok()" functions, it returns true if the test passed,
       or false if not.

       A default description of "DELETE to $url" is used if none if provided.

   <b>$mech-&gt;submit_form_ok(</b> <b>\%parms</b> <b>[,</b> <b>$desc]</b> <b>)</b>
       Makes a "submit_form()" call and executes tests on the  results.   The  form  must  be  found,  and  then
       submitted successfully.  Otherwise, this test fails.

       <u>%parms</u>  is  a  hashref  containing  the  parms  to  pass  to  "submit_form()".   Note  that  the parms to
       "submit_form()" are a hash whereas the parms to this function are a  hashref.   You  have  to  call  this
       function like:

           $mech-&gt;submit_form_ok( {
                   form_number =&gt; 3,
                   fields      =&gt; {
                       answer =&gt; 42
                   },
               }, 'now we just need the question'
           );

       As with other test functions, $desc is optional.  If it is supplied then it will display when running the
       test harness in verbose mode.

       Returns  true value if the specified link was found and followed successfully.  The HTTP::Response object
       returned by <b>submit_form()</b> is not available.

   <b>$mech-&gt;follow_link_ok(</b> <b>\%parms</b> <b>[,</b> <b>$desc]</b> <b>)</b>
       Makes a "follow_link()" call and executes tests on the  results.   The  link  must  be  found,  and  then
       followed successfully.  Otherwise, this test fails.

       <u>%parms</u>  is  a  hashref  containing  the  parms  to  pass  to  "follow_link()".   Note  that  the parms to
       "follow_link()" are a hash whereas the parms to this function are a  hashref.   You  have  to  call  this
       function like:

           $mech-&gt;follow_link_ok( {n=&gt;3}, 'looking for 3rd link' );

       As with other test functions, $desc is optional.  If it is supplied then it will display when running the
       test harness in verbose mode.

       Returns  a  true  value  if  the  specified link was found and followed successfully.  The HTTP::Response
       object returned by <b>follow_link()</b> is not available.

   <b>$mech-&gt;click_ok(</b> <b>$button[,</b> <b>$desc]</b> <b>)</b>
   <b>$mech-&gt;click_ok(</b> <b>\@button-and-coordinates</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Clicks the button named by $button.  An optional $desc can be given for the test.

           $mech-&gt;click_ok( 'continue', 'Clicking the "Continue" button' );

       Alternatively the first argument can be an arrayref with three elements: The name of the button and the X
       and Y coordinates of the button.

           $mech-&gt;click_ok( [ 'continue', 12, 47 ], 'Clicking the "Continue" button' );

</pre><h4><b>METHODS:</b> <b>HEADER</b> <b>CHECKING</b></h4><pre>
   <b>$mech-&gt;header_exists_ok(</b> <b>$header</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Assures that a given response header exists. The actual value of the response header is not checked, only
       that the header exists.

   <b>$mech-&gt;lacks_header_ok(</b> <b>$header</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Assures that a given response header does NOT exist.

   <b>$mech-&gt;header_is(</b> <b>$header,</b> <b>$value</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Assures that a given response header exists and has the given value.

   <b>$mech-&gt;header_like(</b> <b>$header,</b> <b>$value</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Assures that a given response header exists and has the given value.

</pre><h4><b>METHODS:</b> <b>CONTENT</b> <b>CHECKING</b></h4><pre>
   <b>$mech-&gt;html_lint_ok(</b> <b>[$desc]</b> <b>)</b>
       Checks the validity of the HTML on the current page using the HTML::Lint module.   If  the  page  is  not
       HTML, then it fails.  The URI is automatically appended to the <u>$desc</u>.

       Note that HTML::Lint must be installed for this to work.  Otherwise, it will blow up.

   <b>$mech-&gt;html_tidy_ok(</b> <b>[$desc]</b> <b>)</b>
       Checks  the  validity  of  the  HTML on the current page using the HTML::Tidy module.  If the page is not
       HTML, then it fails.  The URI is automatically appended to the <u>$desc</u>.

       Note that HTML::tidy must be installed for this to work.  Otherwise, it will blow up.

   <b>$mech-&gt;content_for_tidy()</b>
       This method is called by "html_tidy_ok()" to get the content that should be validated by HTML::Tidy5.  By
       default,  this  is  just  "content()",  but  subclasses  can  override  it  to  modify the content before
       validation.

       This method should not change any state in the Mech object.  Specifically, it should not actually  modify
       any of the actual content.

   <b>$mech-&gt;title_is(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the title of the page is the given string.

           $mech-&gt;title_is( 'Invoice Summary' );

   <b>$mech-&gt;title_like(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the title of the page matches the given regex.

           $mech-&gt;title_like( qr/Invoices for (.+)/ );

   <b>$mech-&gt;title_unlike(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the title of the page matches the given regex.

           $mech-&gt;title_unlike( qr/Invoices for (.+)/ );

   <b>$mech-&gt;base_is(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the base of the page is the given string.

           $mech-&gt;base_is( '<a href="http://example.com/">http://example.com/</a>' );

   <b>$mech-&gt;base_like(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the base of the page matches the given regex.

           $mech-&gt;base_like( qr{<a href="http://example.com/index.php">http://example.com/index.php</a>?PHPSESSID=(.+)});

   <b>$mech-&gt;base_unlike(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the base of the page matches the given regex.

           $mech-&gt;base_unlike( qr{<a href="http://example.com/index.php">http://example.com/index.php</a>?PHPSESSID=(.+)});

   <b>$mech-&gt;content_is(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page matches the given string

   <b>$mech-&gt;content_contains(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page contains <u>$str</u>.

   <b>$mech-&gt;content_lacks(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page lacks <u>$str</u>.

   <b>$mech-&gt;content_like(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page matches <u>$regex</u>.

   <b>$mech-&gt;content_unlike(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page does NOT match <u>$regex</u>.

   <b>$mech-&gt;text_contains(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the text form of the page's content contains <u>$str</u>.

       When your page contains HTML which is difficult, unimportant, or unlikely to match over time as designers
       alter markup, use "text_contains" instead of "content_contains".

        # &lt;b&gt;Hi, &lt;i&gt;&lt;a href="some/path"&gt;User&lt;/a&gt;&lt;/i&gt;!&lt;/b&gt;
        $mech-&gt;content_contains('Hi, User'); # Fails.
        $mech-&gt;text_contains('Hi, User'); # Passes.

       Text is determined by calling "$mech-&gt;text()".  See "content" in WWW::Mechanize.

   <b>$mech-&gt;text_lacks(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the text of the page lacks <u>$str</u>.

   <b>$mech-&gt;text_like(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the text form of the page's content matches <u>$regex</u>.

   <b>$mech-&gt;text_unlike(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the text format of the page's content does NOT match <u>$regex</u>.

   <b>$mech-&gt;has_tag(</b> <b>$tag,</b> <b>$text</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the page has a $tag tag with the given content in its text.

   <b>$mech-&gt;has_tag_like(</b> <b>$tag,</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the page has a $tag tag with the given content in its text.

   <b>$mech-&gt;page_links_ok(</b> <b>[</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow all links on the current page and test for HTTP status 200

           $mech-&gt;page_links_ok('Check all links');

   <b>$mech-&gt;page_links_content_like(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow all links on the current page and test their contents for <u>$regex</u>.

           $mech-&gt;page_links_content_like( qr/foo/,
             'Check all links contain "foo"' );

   <b>$mech-&gt;page_links_content_unlike(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow all links on the current page and test their contents do not contain the specified regex.

           $mech-&gt;page_links_content_unlike(qr/Restricted/,
             'Check all links do not contain Restricted');

   <b>$mech-&gt;links_ok(</b> <b>$links</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow specified links on the current page and test for HTTP status 200.  The links may be specified as a
       reference to an array containing WWW::Mechanize::Link objects, an array of URLs, or a scalar URL name.

           my @links = $mech-&gt;find_all_links( url_regex =&gt; qr/cnn\.com$/ );
           $mech-&gt;links_ok( \@links, 'Check all links for cnn.com' );

           my @links = qw( index.html search.html about.html );
           $mech-&gt;links_ok( \@links, 'Check main links' );

           $mech-&gt;links_ok( 'index.html', 'Check link to index' );

   <b>$mech-&gt;link_status_is(</b> <b>$links,</b> <b>$status</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow  specified  links on the current page and test for HTTP status passed.  The links may be specified
       as a reference to an array containing WWW::Mechanize::Link objects, an array of URLs,  or  a  scalar  URL
       name.

           my @links = $mech-&gt;followable_links();
           $mech-&gt;link_status_is( \@links, 403,
             'Check all links are restricted' );

   <b>$mech-&gt;link_status_isnt(</b> <b>$links,</b> <b>$status</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow  specified  links on the current page and test for HTTP status passed.  The links may be specified
       as a reference to an array containing WWW::Mechanize::Link objects, an array of URLs,  or  a  scalar  URL
       name.

           my @links = $mech-&gt;followable_links();
           $mech-&gt;link_status_isnt( \@links, 404,
             'Check all links are not 404' );

   <b>$mech-&gt;link_content_like(</b> <b>$links,</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow  specified  links  on the current page and test the resulting content of each against <u>$regex</u>.  The
       links may be specified as a reference to an array containing WWW::Mechanize::Link objects,  an  array  of
       URLs, or a scalar URL name.

           my @links = $mech-&gt;followable_links();
           $mech-&gt;link_content_like( \@links, qr/Restricted/,
               'Check all links are restricted' );

   <b>$mech-&gt;link_content_unlike(</b> <b>$links,</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow  specified  links  on  the current page and test that the resulting content of each does not match
       <u>$regex</u>.  The links may be specified as a reference to an array containing  WWW::Mechanize::Link  objects,
       an array of URLs, or a scalar URL name.

           my @links = $mech-&gt;followable_links();
           $mech-&gt;link_content_unlike( \@links, qr/Restricted/,
             'No restricted links' );

</pre><h4><b>METHODS:</b> <b>SCRAPING</b></h4><pre>
   <b>$mech-&gt;scrape_text_by_attr(</b> <b>$attr,</b> <b>$attr_value</b> <b>[,</b> <b>$html</b> <b>]</b> <b>)</b>
   <b>$mech-&gt;scrape_text_by_attr(</b> <b>$attr,</b> <b>$attr_regex</b> <b>[,</b> <b>$html</b> <b>]</b> <b>)</b>
       Returns  a  list  of strings, each string the text surrounded by an element with attribute <u>$attr</u> of value
       <u>$value</u>.  You can also pass in a regular expression.  If nothing is found the return is an empty list.  In
       scalar context the return is the first string found.

       If passed, <u>$html</u> is scraped instead of the current page's content.

   <b>$mech-&gt;scrape_text_by_id(</b> <b>$id</b> <b>[,</b> <b>$html</b> <b>]</b> <b>)</b>
       Finds all elements with the given ID attribute and pulls out the text that that element encloses.

       In list context, returns a list of all strings found. In scalar context, returns the first one found.

       If $html is not provided then the current content is used.

   <b>$mech-&gt;scraped_id_is(</b> <b>$id,</b> <b>$expected</b> <b>[,</b> <b>$msg]</b> <b>)</b>
       Scrapes the current page for given ID and tests that it matches the expected value.

   <b>$mech-&gt;scraped_id_like(</b> <b>$id,</b> <b>$expected_regex</b> <b>[,</b> <b>$msg]</b> <b>)</b>
       Scrapes the current page for given id and tests that it matches the expected regex.

   <b>$mech-&gt;id_exists(</b> <b>$id</b> <b>)</b>
       Returns TRUE/FALSE if the given ID exists in the given HTML, or if none is  provided,  then  the  current
       page.

       The Mech object caches the IDs so that it doesn't bother reparsing every time it's asked about an ID.

   <b>$agent-&gt;id_exists_ok(</b> <b>$id</b> <b>[,</b> <b>$msg]</b> <b>)</b>
       Verifies there is an HTML element with ID $id in the page.

   <b>$agent-&gt;ids_exist_ok(</b> <b>\@ids</b> <b>[,</b> <b>$msg]</b> <b>)</b>
       Verifies an HTML element exists with each ID in "\@ids".

   <b>$agent-&gt;lacks_id_ok(</b> <b>$id</b> <b>[,</b> <b>$msg]</b> <b>)</b>
       Verifies there is NOT an HTML element with ID $id in the page.

   <b>$agent-&gt;lacks_ids_ok(</b> <b>\@ids</b> <b>[,</b> <b>$msg]</b> <b>)</b>
       Verifies there are no HTML elements with any of the ids given in "\@ids".

   <b>$mech-&gt;button_exists(</b> <b>$button</b> <b>)</b>
       Returns  a  boolean  saying whether a submit button with the name $button exists. Does not do a test. For
       that you want "button_exists_ok" or "lacks_button_ok".

   <b>$mech-&gt;button_exists_ok(</b> <b>$button</b> <b>[,</b> <b>$msg]</b> <b>)</b>
       Asserts that the button exists on the page.

   <b>$mech-&gt;lacks_button_ok(</b> <b>$button</b> <b>[,</b> <b>$msg]</b> <b>)</b>
       Asserts that no button named $button exists on the page.

</pre><h4><b>METHODS:</b> <b>MISCELLANEOUS</b></h4><pre>
   <b>$mech-&gt;autolint(</b> <b>[$status]</b> <b>)</b>
       Without an argument, this method returns a true or false value indicating whether autolint is active.

       When passed an argument, autolint is turned on or off depending on whether the argument is true or false,
       and the previous autolint status is returned.  As with the autolint option of "new", $status  can  be  an
       HTML::Lint object.

       If  autolint  is currently using an HTML::Lint object you provided, the return is that object, so you can
       change and exactly restore autolint status:

           my $old_status = $mech-&gt;autolint( 0 );
           ... operations that should not be linted ...
           $mech-&gt;autolint( $old_status );

   <b>$mech-&gt;autotidy(</b> <b>[$status]</b> <b>)</b>
       Without an argument, this method returns a true or false value indicating whether autotidy is active.

       When passed an argument, autotidy is turned on or off depending on whether the argument is true or false,
       and the previous autotidy status is returned.  As with the autotidy option of "new", $status  can  be  an
       HTML::Tidy5 object.

       If  autotidy is currently using an HTML::Tidy5 object you provided, the return is that object, so you can
       change and exactly restore autotidy status:

           my $old_status = $mech-&gt;autotidy( 0 );
           ... operations that should not be tidied ...
           $mech-&gt;autotidy( $old_status );

   <b>$mech-&gt;grep_inputs(</b> <b>\%properties</b> <b>)</b>
       Returns a list of all the input controls in the current form whose properties match all of the regexes in
       $properties.  The controls returned are all descended from HTML::Form::Input.

       If $properties is undef or empty then all inputs will be returned.

       If there is no current page, there is no form on the current page, or there are no submit controls in the
       current form then the return will be an empty list.

           # Get all text controls whose names begin with "customer".
           my @customer_text_inputs =
               $mech-&gt;grep_inputs( {
                   type =&gt; qr/^(text|textarea)$/,
                   name =&gt; qr/^customer/
               }
           );

   <b>$mech-&gt;grep_submits(</b> <b>\%properties</b> <b>)</b>
       <b>grep_submits()</b> does the same thing as <b>grep_inputs()</b> except that it only returns controls that are  submit
       controls, ignoring other types of input controls like text and checkboxes.

   <b>$mech-&gt;stuff_inputs(</b> <b>[\%options]</b> <b>)</b>
       Finds  all  free-text  input  fields (text, textarea, and password) in the current form and fills them to
       their maximum length in hopes of finding application code that can't handle it.  Fields with  no  maximum
       length  and all textarea fields are set to 66000 bytes, which will often be enough to overflow the data's
       eventual receptacle.

       There is no return value.

       If there is no current form then nothing is done.

       The hashref $options can contain the following keys:

       •   ignore

           hash value is arrayref of field names to not touch, e.g.:

               $mech-&gt;stuff_inputs( {
                   ignore =&gt; [qw( specialfield1 specialfield2 )],
               } );

       •   fill

           hash value is default string to use when stuffing fields.  Copies of the string are  repeated  up  to
           the max length of each field.  E.g.:

               $mech-&gt;stuff_inputs( {
                   fill =&gt; '@'  # stuff all fields with something easy to recognize
               } );

       •   specs

           hash value is arrayref of hashrefs with which you can pass detailed instructions about how to stuff a
           given field.  E.g.:

               $mech-&gt;stuff_inputs( {
                   specs=&gt;{
                       # Some fields are datatype-constrained.  It's most common to
                       # want the field stuffed with valid data.
                       widget_quantity =&gt; { fill=&gt;'9' },
                       notes =&gt; { maxlength=&gt;2000 },
                   }
               } );

           The  specs  allowed are <u>fill</u> (use this fill for the field rather than the default) and <u>maxlength</u> (use
           this as the field's maxlength instead of any maxlength specified in the HTML).

   <b>$mech-&gt;followable_links()</b>
       Returns a list of links that Mech can follow.  This is only http and https links.

   <b>$mech-&gt;lacks_uncapped_inputs(</b> <b>[$comment]</b> <b>)</b>
       Executes a test to make sure that the current form content  has  no  text  input  fields  that  lack  the
       "maxlength"  attribute,  and  that  each  "maxlength" value is a positive integer.  The test fails if the
       current form has such a field, and succeeds otherwise.

       Checks that all text input fields in the current form specify a maximum input length.  Fields  for  which
       the  concept  of  input  length  is  irrelevant, and controls that HTML does not allow to be capped (e.g.
       textarea) are ignored.

       The return is true if the test succeeded, false otherwise.

   <b>$mech-&gt;check_all_images_ok(</b> <b>[%criterium</b> <b>],</b> <b>[$comment]</b> <b>)</b>
       Executes a test to make sure all images in the page can be downloaded. It does  this  by  running  "HEAD"
       requests on them. The current page content stays the same.

       The test fails if any image cannot be found, but reports all of the ones that were not found.

       For a definition of <u>all</u> <u>images</u>, see "images"in WWW::Mechanize.

       The  optional  %criterium  argument can be passed in before the $comment and will be used to define which
       images should be considered. This is useful to filter out specific paths.

           $mech-&gt;check_all_images_ok( url_regex =&gt; qr{^/}, 'All absolute images should exist');
           $mech-&gt;check_all_images_ok( url_regex =&gt; qr{\.(?:gif|jpg)$}, 'All gif and jpg images should exist');
           $mech-&gt;check_all_images_ok(
               url_regex =&gt; qr{^((?!\Qhttps://googleads.g.doubleclick.net/\E).)*$},
               'All images should exist, but Ignore the ones from Doubleclick'
           );

       For a full list of possible arguments see "find_all_images"in WWW::Mechanize.

       The return is true if the test succeeded, false otherwise.

</pre><h4><b>TODO</b></h4><pre>
       Other ideas for features are at https://github.com/petdance/test-www-mechanize

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Lester, "&lt;andy at petdance.com&gt;"

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests to &lt;https://github.com/petdance/test-www-mechanize&gt;.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc Test::WWW::Mechanize

       You can also look for information at:

       •   Bug tracker

           &lt;https://github.com/petdance/test-www-mechanize&gt;

       •   CPAN Ratings

           &lt;<a href="http://cpanratings.perl.org/d/Test-WWW-Mechanize">http://cpanratings.perl.org/d/Test-WWW-Mechanize</a>&gt;

       •   Search CPAN

           &lt;<a href="http://search.cpan.org/dist/Test-WWW-Mechanize">http://search.cpan.org/dist/Test-WWW-Mechanize</a>&gt;

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to Julien Fiegehenn, @marderh, Eric A.  Zarko,  @moznion,  Robert  Stone,  @tynovsky,  Jerry  Gay,
       Jonathan  "Duke"  Leto,  Philip  G.  Potter, Niko Tyni, Greg Sheard, Michael Schwern, Mark Blackman, Mike
       O'Regan, Shawn Sorichetti, Chris Dolan, Matt Trout, MATSUNO Tokuhiro, and Pete Krawczyk for patches.

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2004-2022 Andy Lester.

       This library is free software; you can redistribute it and/or modify it under the terms of  the  Artistic
       License version 2.0.

perl v5.36.0                                       2022-12-16                                     <u><a href="../man3pm/Mechanize.3pm.html">Mechanize</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>