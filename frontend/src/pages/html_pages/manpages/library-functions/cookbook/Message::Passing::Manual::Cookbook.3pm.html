<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Message::Passing::Manual::Cookbook - Common recipies</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmessage-passing-perl">libmessage-passing-perl_0.117-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Message::Passing::Manual::Cookbook - Common recipies

</pre><h4><b>Aggregating</b> <b>logs</b></h4><pre>
   <b>Logging</b> <b>from</b> <b>an</b> <b>application.</b>
       You can use Log::Dispatch, or any log system which will output into Log::Dispatch.

           use Log::Dispatch;
           use Log::Dispatch::Message::Passing;
           use Message::Passing::Filter::Encoder::JSON;
           use Message::Passing::Output::ZeroMQ;

           my $log = Log::Dispatch-&gt;new;

           $log-&gt;add(Log::Dispatch::Message::Passing-&gt;new(
               name      =&gt; 'myapp_aggregate_log',
               min_level =&gt; 'debug',
               output    =&gt; Message::Passing::Filter::Encoder::JSON-&gt;new(
                   output_to =&gt; Message::Passing::Output::ZeroMQ-&gt;new(
                       connect =&gt; 'tcp://192.168.0.1:5558',
                   ),
               ),
           ));

           $log-&gt;warn($_) for qw/ foo bar baz /;

   <b>Aggregating</b> <b>this</b> <b>log</b>
       As simple as using the command line interface:

           message-pass --input ZeroMQ --input_options '{"socket_bind":"tcp://192.168.0.1:5558"}' \
               --output File --output_options '{"filename":"/tmp/mylog"}'

       And you've now got a multi-host log aggregation system for your application!

   <b>Doing</b> <b>it</b> <b>manually</b>
       You don't have to do any of the above, if you don't want to - you can easily reuse the ZeroMQ output
       yourself:

           my $log = Message::Passing::Output::ZeroMQ-&gt;new(
               connect =&gt; 'tcp://192.168.0.1:5558',
               linger  =&gt; 1,  # make sure message is sent (flushed) before thread dies
           );
           $log-&gt;consume("A log message");

   <b>A</b> <b>note</b> <b>about</b> <b>outputs</b>
       ZeroMQ is the recommended <b>output</b> for sending messages from within your application.  This is because
       ZeroMQ uses a different (POSIX) thread to send messages - meaning that it transports messages
       independently to whatever your perl code is doing.

       This is <b>not</b> the case for other message outputs, and therefore they are unlikely to work well, or at all,
       unless your application is already asynchronous and using an AnyEvent supported event library.

   <b>A</b> <b>note</b> <b>about</b> <b>ZeroMQ</b>
       By default Message::Passing::ZeroMQ will use PUB/SUB sockets for logging, with a finite 'high water
       mark'.

       This means that if your application logs significantly more data than you can fit down the network, you
       <b>will</b> <b>drop</b> <b>logs</b>.

       If your application needs to do this, you can either increase this high water mark, or disable it (so
       ZeroMQ will buffer an infinite number of messages at the sending client - potentially using infinite
       RAM).

       The default setting is for the output to buffer up to 10000 messages on the output side, which should be
       enough to manage short term peaks, but is low enough to be reasonably safe in terms of memory consumption
       for buffering

</pre><h4><b>Aggregating</b> <b>syslog</b></h4><pre>
       Assuming that you've got a regular syslogd setup and working, then you probably want to keep that.
       Having <b>some</b> <b>of</b> the log files on individual hosts can be very useful. Also, we'd like to avoid the script
       being a privileged user (which would be needed to get the standard port).

       Therefore, we'll run a syslog listener on a high port (5140), and get the regular syslogd to ship
       messages to it. The listener will then forward from each host to a central aggregate logger (which is
       setup as above).

   <b>On</b> <b>host</b> <b>collector</b>
           message-pass --input Syslog --output ZeroMQ --output_options '{"connect":"tcp://192.168.0.1:5558"}'

   <b>Configuring</b> <b>your</b> <b>syslogd</b>
       This should be easy, here's an example of what to add to rsyslogd.conf to get the syslog resent.

           *.* =192.168.0.1:5140

</pre><h4><b>Aggregating</b> <b>everything</b></h4><pre>
       If you have hosts with both applications and syslog that you want to aggregate, then you can easily do
       both at once. This also means that your apps ship logs to a local buffer process rather than directly
       across the network - which is more resilient to short network outages.

</pre><h4><b>AUTHOR,</b> <b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       See Message::Passing.

perl v5.32.1                                       2021-11-09             <u>Message::Passin...anual::<a href="../man3pm/Cookbook.3pm.html">Cookbook</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>