<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APR::Brigade - Perl API for manipulating APR Bucket Brigades</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libapache2-mod-perl2">libapache2-mod-perl2_2.0.13-2build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       APR::Brigade - Perl API for manipulating APR Bucket Brigades

</pre><h4><b>Synopsis</b></h4><pre>
         use APR::Brigade ();

         $bb = APR::Brigade-&gt;new($r-&gt;pool, $c-&gt;bucket_alloc);
         $ba = $bb-&gt;bucket_alloc();
         $pool = $bb-&gt;pool;

         $bb-&gt;insert_head($b);
         $bb-&gt;insert_tail($b);

         $b_first = $bb-&gt;first;
         $b_last  = $bb-&gt;last;

         $b_prev = $bb-&gt;prev($b_last);
         $b_next = $bb-&gt;next($b);

         $bb2 = APR::Brigade-&gt;new($r-&gt;pool, $c-&gt;bucket_alloc);
         $bb1-&gt;concat($bb2);

         $len = $bb-&gt;flatten($data);
         $len = $bb2-&gt;flatten($data, $wanted);

         $len = $bb-&gt;length;
         $bb3 = $bb-&gt;split($b_last);

         last if $bb-&gt;is_empty();
         $bb-&gt;cleanup();
         $bb-&gt;destroy();

</pre><h4><b>Description</b></h4><pre>
       "APR::Brigade" allows you to create, manipulate and delete APR bucket brigades.

</pre><h4><b>API</b></h4><pre>
       "APR::Brigade" provides the following functions and/or methods:

   <b>"cleanup"</b>
       Empty out an entire bucket brigade:

         $bb-&gt;cleanup;

       obj: $bb ( "APR::Brigade object" )
           The brigade to cleanup

       ret: no return value
       since: 2.0.00

       This  method  destroys  all  of  the buckets within the bucket brigade's bucket list.  This is similar to
       destroy(), except that it does not deregister the brigade's pool() cleanup function.

       Generally, you should use destroy().  This function can be useful in situations where you have  a  single
       brigade that you wish to reuse many times by destroying all of the buckets in the brigade and putting new
       buckets into it later.

   <b>"concat"</b>
       Concatenate brigade $bb2 onto the end of brigade $bb1, leaving brigade $bb2 empty:

         $bb1-&gt;concat($bb2);

       obj: $bb1 ( "APR::Brigade object" )
           The brigade to concatenate to.

       arg1: $bb2 ( "APR::Brigade object" )
           The brigade to concatenate and empty afterwards.

       ret: no return value
       since: 2.0.00

   <b>"destroy"</b>
       destroy an entire bucket brigade, includes all of the buckets within the bucket brigade's bucket list.

         $bb-&gt;destroy();

       obj: $bb ( "APR::Brigade object" )
           The bucket brigade to destroy.

       ret: no return value
       excpt: "APR::Error"
       since: 2.0.00

   <b>"is_empty"</b>
       Test whether the bucket brigade is empty

         $ret = $bb-&gt;is_empty();

       obj: $bb ( "APR::Brigade object" )
       ret: $ret ( boolean )
       since: 2.0.00

   <b>"first"</b>
       Return the first bucket in a brigade

         $b_first = $bb-&gt;first;

       obj: $bb ( "APR::Brigade object" )
       ret: $b_first ( "APR::Bucket object" )
           The first bucket in the bucket brigade $bb.

           "undef" is returned if there are no buckets in $bb.

       since: 2.0.00

   <b>"flatten"</b>
       Get the data from buckets in the bucket brigade as one string

         $len = $bb-&gt;flatten($buffer);
         $len = $bb-&gt;flatten($buffer, $wanted);

       obj: $bb ( "APR::Brigade object" )
       arg1: $buffer ( SCALAR )
           The buffer to fill. All previous data will be lost.

       opt arg2: $wanted ( number )
           If  no  argument  is passed then all data will be returned. If $wanted is specified -- that number or
           less bytes will be returned.

       ret: $len ( number )
           How many bytes were actually read.

           $buffer gets populated with the string that is read. It will contain an empty  string  if  there  was
           nothing to read.

       since: 2.0.00
       excpt: "APR::Error"

   <b>"insert_head"</b>
       Insert a list of buckets at the front of a brigade

         $bb-&gt;insert_head($b);

       obj: $bb ( "APR::Brigade object" )
           Brigade to insert into

       arg1: $b ( "APR::Bucket object" )
           the bucket to insert. More buckets could be attached to that bucket.

       ret: no return value
       since: 2.0.00

   <b>"insert_tail"</b>
       Insert a list of buckets at the end of a brigade

         $bb-&gt;insert_tail($b);

       obj: $bb ( "APR::Brigade object" )
           Brigade to insert into

       arg1: $b ( "APR::Bucket object" )
           the bucket to insert. More buckets could be attached to that bucket.

       ret: no return value
       since: 2.0.00

   <b>"last"</b>
       Return the last bucket in the brigade

         $b_last = $bb-&gt;last;

       obj: $bb ( "APR::Brigade object" )
       ret: $b_last ( "APR::Bucket object" )
           The last bucket in the bucket brigade $bb.

           "undef" is returned if there are no buckets in $bb.

       since: 2.0.00

   <b>"length"</b>
       Return the total length of the data in the brigade (not the number of buckets)

         $len = $bb-&gt;length;

       obj: $bb ( "APR::Brigade object" )
       ret: $len ( number )
       since: 2.0.00

   <b>"new"</b>
         my $nbb = APR::Brigade-&gt;new($p, $bucket_alloc);
         my $nbb =          $bb-&gt;new($p, $bucket_alloc);

       obj: $bb ( "APR::Brigade object or class" )
       arg1: $p ( "APR::Pool object" )
       arg2: $bucket_alloc ( "APR::BucketAlloc object" )
       ret: $nbb ( "APR::Brigade object" )
           a newly created bucket brigade object

       since: 2.0.00

       Example:

       Create a new bucket brigade, using the request object's pool:

         use Apache2::Connection ();
         use Apache2::RequestRec ();
         use APR::Brigade ();
         my $bb = APR::Brigade-&gt;new($r-&gt;pool, $r-&gt;connection-&gt;bucket_alloc);

   <b>"bucket_alloc"</b>
       Get the bucket allocator associated with this brigade.

         my $ba = $bb-&gt;bucket_alloc();

       obj: $bb ( "APR::Brigade object or class" )
       ret: $ba ( "APR::BucketAlloc object" )
       since: 2.0.00

   <b>"next"</b>
       Return the next bucket in a brigade

         $b_next = $bb-&gt;next($b);

       obj: $bb ( "APR::Brigade object" )
       arg1: $b ( "APR::Bucket object" )
           The bucket after which the next bucket $b_next is located

       ret: $b_next ( "APR::Bucket object" )
           The next bucket after bucket $b.

           "undef" is returned if there is no next bucket (i.e. $b is the last bucket).

       since: 2.0.00

   <b>"pool"</b>
       The pool the brigade is associated with.

         $pool = $bb-&gt;pool;

       obj: $bb ( "APR::Brigade object" )
       ret: $pool ( "APR::Pool object" )
       since: 2.0.00

       The data is not allocated out of the pool, but a cleanup is registered with this pool.  If the brigade is
       destroyed  by  some  mechanism  other  than  pool destruction, the destroying function is responsible for
       killing the registered cleanup.

   <b>"prev"</b>
       Return the previous bucket in the brigade

         $b_prev = $bb-&gt;prev($b);

       obj: $bb ( "APR::Brigade object" )
       arg1: $b ( "APR::Bucket object" )
           The bucket located after bucket $b_prev

       ret: $b_prev ( "APR::Bucket object" )
           The bucket located before bucket $b.

           "undef" is returned if there is no previous bucket (i.e. $b is the first bucket).

       since: 2.0.00

   <b>"split"</b>
       Split a bucket brigade into two, such that the given bucket is the first in the new bucket brigade.

         $bb2 = $bb-&gt;split($b);

       obj: $bb ( "APR::Brigade object" )
           The brigade to split

       arg1: $b ( "APR::Bucket object" )
           The first bucket of the new brigade

       ret: $bb2 ( "APR::Brigade object" )
           The new brigade.

       since: 2.0.00

       This function is useful when a filter wants to pass only the initial  part  of  a  brigade  to  the  next
       filter.

       Example:

       Create  a  bucket  brigade with three buckets, and split it into two brigade such that the second brigade
       will have the last two buckets.

         my $bb1 = APR::Brigade-&gt;new($r-&gt;pool, $c-&gt;bucket_alloc);
         my $ba  = $c-&gt;bucket_alloc();
         $bb1-&gt;insert_tail(APR::Bucket-&gt;new($ba, "1"));
         $bb1-&gt;insert_tail(APR::Bucket-&gt;new($ba, "2"));
         $bb1-&gt;insert_tail(APR::Bucket-&gt;new($ba, "3"));

       $bb1 now contains buckets "1", "2", "3". Now do the split at the second bucket:

         my $b = $bb1-&gt;first; # 1
         $b = $bb1-&gt;next($b); # 2
         my $bb2 = $bb1-&gt;split($b);

       Now $bb1 contains bucket "1".  $bb2 contains buckets: "2", "3"

</pre><h4><b>See</b> <b>Also</b></h4><pre>
       mod_perl 2.0 documentation.

</pre><h4><b>Copyright</b></h4><pre>
       mod_perl 2.0 and its core modules are copyrighted under The Apache Software License, Version 2.0.

</pre><h4><b>Authors</b></h4><pre>
       The mod_perl development team and numerous contributors.

perl v5.40.0                                       2024-10-20             <u>libapache2-mod-...i::APR::<a href="../man3pm/Brigade.3pm.html">Brigade</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>