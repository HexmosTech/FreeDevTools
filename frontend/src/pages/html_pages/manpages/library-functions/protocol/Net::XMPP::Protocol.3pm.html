<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::XMPP::Protocol - XMPP Protocol Module</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-xmpp-perl">libnet-xmpp-perl_1.05-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::XMPP::Protocol - XMPP Protocol Module

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Net::XMPP::Protocol is a module that provides a developer easy access to the XMPP Instant Messaging
       protocol.  It provides high level functions to the Net::XMPP Client object.  These functions are
       inherited by that modules.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Protocol.pm seeks to provide enough high level APIs and automation of the low level APIs that writing a
       XMPP Client in Perl is trivial.  For those that wish to work with the low level you can do that too, but
       those functions are covered in the documentation for each module.

       Net::XMPP::Protocol provides functions to login, send and receive messages, set personal information,
       create a new user account, manage the roster, and disconnect.  You can use all or none of the functions,
       there is no requirement.

       For more information on how the details for how Net::XMPP is written please see the help for Net::XMPP
       itself.

       For more information on writing a Client see Net::XMPP::Client.

   <b>Modes</b>
       Several of the functions take a mode argument that let you specify how the function should behave:

       block
           send  the packet with an ID, and then block until an answer comes back.  You can optionally specify a
           timeout so that you do not block forever.

       nonblock
           send the packet with an ID, but then return that id and control to the master program.  Net::XMPP  is
           still  tracking  this  packet,  so you must use the CheckID function to tell when it comes in.  (This
           might not be very useful...)

       passthru
           send the packet with an ID, but do NOT register it with Net::XMPP,  then  return  the  ID.   This  is
           useful when combined with the XPath function because you can register a one shot function tied to the
           id you get back.

   <b>Basic</b> <b>Functions</b>
           use Net::XMPP qw( Client );
           $Con = Net::XMPP::Client-&gt;new();                  # From
           $status = $Con-&gt;Connect(hostname=&gt;"jabber.org"); # Net::XMPP::Client

           $Con-&gt;SetCallBacks(send=&gt;\&amp;sendCallBack,
                              receive=&gt;\&amp;receiveCallBack,
                              message=&gt;\&amp;messageCallBack,
                              iq=&gt;\&amp;handleTheIQTag);

           $Con-&gt;SetMessageCallBacks(normal=&gt;\&amp;messageNormalCB,
                                     chat=&gt;\&amp;messageChatCB);

           $Con-&gt;SetPresenceCallBacks(available=&gt;\&amp;presenceAvailableCB,
                                      unavailable=&gt;\&amp;presenceUnavailableCB);

           $Con-&gt;SetIQCallBacks("custom-namespace"=&gt;
                                                    {
                                                        get=&gt;\&amp;iqCustomGetCB,
                                                        set=&gt;\&amp;iqCustomSetCB,
                                                        result=&gt;\&amp;iqCustomResultCB,
                                                    },
                                                    etc...
                                                   );

           $Con-&gt;SetXPathCallBacks("/message[@type='chat']"=&gt;&amp;messageChatCB,
                                   "/message[@type='chat']"=&gt;&amp;otherMessageChatCB,
                                   ...
                                  );

           $Con-&gt;RemoveXPathCallBacks("/message[@type='chat']"=&gt;&amp;otherMessageChatCB);

           $Con-&gt;SetDirectXPathCallBacks("/anything"=&gt;&amp;anythingCB,
                                         "/anotherthing[@foo='bar']"=&gt;&amp;anotherthingFooBarCB,
                                         ...
                                        );

           $Con-&gt;RemoveDirectXPathCallBacks("/message[@type='chat']"=&gt;&amp;otherMessageChatCB);

           $error = $Con-&gt;GetErrorCode();
           $Con-&gt;SetErrorCode("Timeout limit reached");

           $status = $Con-&gt;Process();
           $status = $Con-&gt;<a href="../man5/Process.5.html">Process</a>(5);

           $Con-&gt;Send($object);
           $Con-&gt;Send("&lt;tag&gt;XML&lt;/tag&gt;");

           $Con-&gt;Send($object,1);
           $Con-&gt;Send("&lt;tag&gt;XML&lt;/tag&gt;",1);

           $Con-&gt;Disconnect();

   <b>ID</b> <b>Functions</b>
           $id         = $Con-&gt;SendWithID($sendObj);
           $id         = $Con-&gt;SendWithID("&lt;tag&gt;XML&lt;/tag&gt;");
           $receiveObj = $Con-&gt;SendAndReceiveWithID($sendObj);
           $receiveObj = $Con-&gt;SendAndReceiveWithID($sendObj,
                                                    10);
           $receiveObj = $Con-&gt;SendAndReceiveWithID("&lt;tag&gt;XML&lt;/tag&gt;");
           $receiveObj = $Con-&gt;SendAndReceiveWithID("&lt;tag&gt;XML&lt;/tag&gt;",
                                                    5);
           $yesno      = $Con-&gt;ReceivedID($id);
           $receiveObj = $Con-&gt;GetID($id);
           $receiveObj = $Con-&gt;WaitForID($id);
           $receiveObj = $Con-&gt;WaitForID($id,
                                         20);

   <b>Namespace</b> <b>Functions</b>
           $Con-&gt;AddNamespace(ns=&gt;"foo:bar",
                              tag=&gt;"myfoo",
                              xpath=&gt;{Foo=&gt;{ path=&gt; "foo/text()" },
                                      Bar=&gt;{ path=&gt; "bar/text()" },
                                      FooBar=&gt;{ type=&gt; "master" },
                                     }
                             );

   <b>Message</b> <b>Functions</b>
           $Con-&gt;MessageSend(to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>",
                             subject=&gt;"Lunch",
                             body=&gt;"Let's go grab some...\n",
                             thread=&gt;"ABC123",
                             priority=&gt;10);

   <b>Presence</b> <b>Functions</b>
           $Con-&gt;PresenceSend();
           $Con-&gt;PresenceSend(type=&gt;"unavailable");
           $Con-&gt;PresenceSend(show=&gt;"away");
           $Con-&gt;PresenceSend(signature=&gt;...signature...);

   <b>Subscription</b> <b>Functions</b>
           $Con-&gt;Subscription(type=&gt;"subscribe",
                              to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>");

           $Con-&gt;Subscription(type=&gt;"unsubscribe",
                              to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>");

           $Con-&gt;Subscription(type=&gt;"subscribed",
                              to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>");

           $Con-&gt;Subscription(type=&gt;"unsubscribed",
                              to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>");

   <b>Presence</b> <b>DB</b> <b>Functions</b>
           $Con-&gt;PresenceDB();

           $Con-&gt;PresenceDBParse(Net::XMPP::Presence);

           $Con-&gt;PresenceDBDelete("bob\@jabber.org");
           $Con-&gt;PresenceDBDelete(Net::XMPP::JID);

           $Con-&gt;PresenceDBClear();

           $presence  = $Con-&gt;PresenceDBQuery("bob\@jabber.org");
           $presence  = $Con-&gt;PresenceDBQuery(Net::XMPP::JID);

           @resources = $Con-&gt;PresenceDBResources("bob\@jabber.org");
           @resources = $Con-&gt;PresenceDBResources(Net::XMPP::JID);

   <b>IQ</b>  <b>Functions</b>
   <b>Auth</b> <b>Functions</b>
           @result = $Con-&gt;AuthSend();
           @result = $Con-&gt;AuthSend(username=&gt;"bob",
                                    password=&gt;"bobrulez",
                                    resource=&gt;"Bob");

   <b>Register</b> <b>Functions</b>
           %hash   = $Con-&gt;RegisterRequest();
           %hash   = $Con-&gt;RegisterRequest(to=&gt;"transport.jabber.org");
           %hash   = $Con-&gt;RegisterRequest(to=&gt;"transport.jabber.org",
                                           timeout=&gt;10);

           @result = $Con-&gt;RegisterSend(to=&gt;"somewhere",
                                        username=&gt;"newuser",
                                        resource=&gt;"New User",
                                        password=&gt;"imanewbie",
                                        email=&gt;"<a href="mailto:newguy@new.com">newguy@new.com</a>",
                                        key=&gt;"some key");

   <b>Roster</b> <b>Functions</b>
           $Roster = $Con-&gt;Roster();

           %roster = $Con-&gt;RosterParse($iq);
           %roster = $Con-&gt;RosterGet();
           $Con-&gt;RosterRequest();
           $Con-&gt;RosterAdd(jid=&gt;"bob\@jabber.org",
                           name=&gt;"Bob");
           $Con-&gt;RosterRemove(jid=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>");

   <b>Roster</b> <b>DB</b> <b>Functions</b>
           $Con-&gt;RosterDB();

           $Con-&gt;RosterDBParse(Net::XMPP::IQ);

           $Con-&gt;RosterDBAdd("bob\@jabber.org",
                             name=&gt;"Bob",
                             groups=&gt;["foo"]
                            );

           $Con-&gt;RosterDBRemove("bob\@jabber.org");
           $Con-&gt;RosterDBRemove(Net::XMPP::JID);

           $Con-&gt;RosterDBClear();

           if ($Con-&gt;RosterDBExists("bob\@jabber.org")) { ...
           if ($Con-&gt;RosterDBExists(Net::XMPP::JID)) { ...

           @jids = $Con-&gt;RosterDBJIDs();

           if ($Con-&gt;RosterDBGroupExists("foo")) { ...

           @groups = $Con-&gt;RosterDBGroups();

           @jids = $Con-&gt;RosterDBGroupJIDs("foo");

           @jids = $Con-&gt;RosterDBNonGroupJIDs();

           %hash = $Con-&gt;RosterDBQuery("bob\@jabber.org");
           %hash = $Con-&gt;RosterDBQuery(Net::XMPP::JID);

           $value = $Con-&gt;RosterDBQuery("bob\@jabber.org","name");
           $value = $Con-&gt;RosterDBQuery(Net::XMPP::JID,"groups");

</pre><h4><b>METHODS</b></h4><pre>
   <b>Basic</b> <b>Functions</b>
       <b>GetErrorCode()</b>
           returns a string that will hopefully contain some useful information about why a function returned an
           undef to you.

       SetErrorCode
             SetErrorCode(string)

           set a useful error message before you return an undef to the caller.

       SetCallBacks
             SetCallBacks(message=&gt;function,
                            presence=&gt;function,
                            iq=&gt;function,
                            send=&gt;function,
                            receive=&gt;function,
                            update=&gt;function)

           sets  the  callback  functions  for  the  top  level tags listed.  The available tags to look for are
           &lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt;.  If a packet is received  with  an  ID  which  is  found  in  the
           registered  ID  list  (see  RegisterID  below)  then it is not sent to these functions, instead it is
           inserted into a LIST and can be retrieved by some functions we will mention later.

           send and receive are used to log what XML is sent and received.  update is used as way to update your
           program while waiting for a packet with an ID to be returned (useful for GUI apps).

           A major change that came with the last release is that the session id is passed to  the  callback  as
           the first argument.  This was done to facilitate the Server module.

           The next argument depends on which callback you are talking about.  message, presence, and iq all get
           passed  in Net::XMPP objects that match those types.  send and receive get passed in strings.  update
           gets passed nothing, not even the session id.

           If you set the function to undef, then the callback is removed from the list.

       SetPresenceCallBacks
             SetPresenceCallBacks(type=&gt;function etc...)

           sets the callback functions for the specified presence type.  The function takes types  as  the  main
           key, and lets you specify a function for each type of packet you can get.

             "available"
             "unavailable"
             "subscribe"
             "unsubscribe"
             "subscribed"
             "unsubscribed"
             "probe"
             "error"

           When it gets a &lt;presence/&gt; packet it checks the type='' for a defined callback.  If there is one then
           it calls the function with two arguments:

             the session ID, and the
             Net::XMPP::Presence object.

           If you set the function to undef, then the callback is removed from the list.

           NOTE: If you use this, which is a cleaner method, then you must *NOT* specify a callback for presence
           in the SetCallBacks function.

            Net::XMPP defines a few default
            callbacks for various types:

            "subscribe" -
              replies with subscribed

            "unsubscribe" -
              replies with unsubscribed

            "subscribed" -
              replies with subscribed

            "unsubscribed" -
              replies with unsubscribed

       SetMessageCallBacks
               SetMessageCallBacks(type=&gt;function, etc...)

           sets the callback functions for the specified message type. The function takes types as the main key,
           and lets you specify a function for each type of packet you can get.

            "normal"
            "chat"
            "groupchat"
            "headline"
            "error"

           When  it  gets a &lt;message/&gt; packet it checks the type='' for a defined callback. If there is one then
           it calls the function with two arguments:

             the session ID, and the
             Net::XMPP::Message object.

           If you set the function to undef, then the callback is removed from the list.

           NOTE: If you use this, which is a cleaner method, then you must *NOT* specify a callback for  message
           in the SetCallBacks function.

       SetIQCallBacks
             SetIQCallBacks(namespace=&gt;{
                                get=&gt;function,
                                set=&gt;function,
                                result=&gt;function
                              },
                              etc...)

           sets  the  callback  functions for the specified namespace. The function takes namespaces as the main
           key, and lets you specify a function for each type of packet you can get.

             "get"
             "set"
             "result"

           When it gets an &lt;iq/&gt; packet it checks the type='' and the xmlns='' for a defined callback.  If there
           is one then it calls the function with two arguments: the session ID, and the Net::XMPP::xxxx object.

           If you set the function to undef, then the callback is removed from the list.

           NOTE: If you use this, which is a cleaner method, then you must *NOT* specify a callback  for  iq  in
           the SetCallBacks function.

       SetXPathCallBacks
             SetXPathCallBacks(xpath=&gt;function, etc...)

           registers  a  callback  function  for  each xpath specified.  If Net::XMPP matches the xpath, then it
           calls the function with two arguments:

             the session ID, and the
             Net::XMPP::Message object.

           Xpaths are rooted at each packet:

             /message[@type="chat"]
             /iq/*[xmlns="jabber:iq:roster"][1]
             ...

       RemoveXPathCallBacks
            RemoveXPathCallBacks(xpath=&gt;function, etc...)

           unregisters a callback function for each xpath specified.

       SetDirectXPathCallBacks
            SetDirectXPathCallBacks(xpath=&gt;function, etc...)

           registers a callback function for each xpath specified.  If Net::XMPP  matches  the  xpath,  then  it
           calls the function with two arguments:

             the session ID, and the
             XML::Stream::Node object.

           Xpaths are rooted at each packet:

             /anything
             /anotherthing/foo/[1]
             ...

           The  big  difference  between this and regular XPathCallBacks is the fact that this passes in the XML
           directly and not a Net::XMPP based object.

       RemoveDirectXPathCallBacks
             RemoveDirectXPathCallBacks(xpath=&gt;function, etc...)

           unregisters a callback function for each xpath specified.

       Process
               Process(integer)
           takes the timeout period as an argument.  If no
           timeout is listed then the function blocks until
           a packet is received.  Otherwise it waits that
           number of seconds and then exits so your program
           can continue doing useful things.  NOTE: This is
           important for GUIs.  You need to leave time to
           process GUI commands even if you are waiting for
           packets.  The following are the possible return
           values, and what they mean:

               1   - Status ok, data received.
               0   - Status ok, no data received.
             undef - Status not ok, stop processing.

           IMPORTANT: You need to check the output of every Process.  If you get an undef  then  the  connection
           died and you should behave accordingly.

       Send
               Send(object, ignoreActivity)
               Send(string, ignoreActivity)

           takes  either  a  Net::XMPP::xxxxx object or an XML string as an argument and sends it to the server.
           If you set ignoreActivty to 1, then the XML::Stream module will not record  this  packet  as  couting
           towards user activity.

   <b>ID</b> <b>Functions</b>
       SendWithID
               SendWithID(object)
               SendWithID(string)

           takes  either  a  Net::XMPP::xxxxx object or an XML string as an argument, adds the next available ID
           number and sends that packet to the server.  Returns the ID number assigned.

       SendAndReceiveWithID
               SendAndReceiveWithID(object, timeout)
               SendAndReceiveWithID(string, timeout)

           uses SendWithID and WaitForID to provide a complete way to send and receive packets  with  IDs.   Can
           take  either  a Net::XMPP::xxxxx object or an XML string.  Returns the proper Net::XMPP::xxxxx object
           based on the type of packet received.  The timeout is passed on to WaitForID, see that  function  for
           how the timeout works.

       ReceivedID
            ReceivedID(integer)

           returns 1 if a packet has been received with specified ID, 0 otherwise.

       GetID
               GetID(integer)

           returns  the  proper  Net::XMPP::xxxxx object based on the type of packet received with the specified
           ID.  If the ID has been received the GetID returns 0.

       WaitForID
             WaitForID(integer, timeout)

           blocks until a packet with the ID is received.  Returns the proper Net::XMPP::xxxxx object  based  on
           the  type  of  packet  received.  If the timeout limit is reached then if the packet does come in, it
           will be discarded.

           NOTE:  Only &lt;iq/&gt; officially support ids, so sending a &lt;message/&gt;, or &lt;presence/&gt; with  an  id  is  a
           risk.  The server will ignore the id tag and pass it through, so both clients must support the id tag
           for these functions to be useful.

   <b>Namespace</b> <b>Functions</b>
       AddNamespace
               AddNamespace(ns=&gt;string,
                            tag=&gt;string,
                            xpath=&gt;hash)

           This  function  is  very  complex.  It is a little too complex to discuss within the confines of this
           small paragraph.  Please refer to the man page for Net::XMPP::Namespaces for the  full  documentation
           on this subject.

   <b>Message</b> <b>Functions</b>
       MessageSend
               MessageSend(hash)

           takes  the  hash  and passes it to SetMessage in Net::XMPP::Message (refer there for valid settings).
           Then it sends the message to the server.

   <b>Presence</b> <b>Functions</b>
       PresenceSend
             PresenceSend()
             PresenceSend(hash, signature=&gt;string)

           No arguments will send an empty Presence to the server to tell it that you  are  available.   If  you
           provide  a  hash,  then  it  will  pass  that  hash  to  the <b>SetPresence()</b> function as defined in the
           Net::XMPP::Presence module.  Optionally, you can specify a signature and a  jabber:x:signed  will  be
           placed in the &lt;presence/&gt;.

   <b>Subscription</b> <b>Functions</b>
       Subscription
            Subscription(hash)

           taks  the  hash and passes it to SetPresence in Net::XMPP::Presence (refer there for valid settings).
           Then it sends the subscription to server.

           The valid types of subscription are:

             subscribe    - subscribe to JID's presence
             unsubscribe  - unsubscribe from JID's presence
             subscribed   - response to a subscribe
             unsubscribed - response to an unsubscribe

   <b>Presence</b> <b>DB</b> <b>Functions</b>
       PresenceDB
            PresenceDB()

           Tell the object to initialize the callbacks to automatically populate the Presence DB.

       PresenceDBParse
             PresenceDBParse(Net::XMPP::Presence)

           for every presence that you receive pass the Presence object to the DB  so  that  it  can  track  the
           resources  and  priorities  for you.  Returns either the presence passed in, if it not able to parsed
           for the DB, or the current presence as found by the PresenceDBQuery function.

       PresenceDBDelete
             PresenceDBDelete(string|Net::XMPP::JID)

           delete thes JID entry from the DB.

       PresenceDBClear
            PresenceDBClear()

           delete all entries in the database.

       PresenceDBQuery
             PresenceDBQuery(string|Net::XMPP::JID)

           returns the NX::Presence that was last received for the highest priority of this JID.  You  can  pass
           it a string or a NX::JID object.

       PresenceDBResources
             PresenceDBResources(string|Net::XMPP::JID)

           returns an array of resources in order from highest priority to lowest.

   <b>IQ</b> <b>Functions</b>
   <b>Auth</b> <b>Functions</b>
       AuthSend
               AuthSend(username=&gt;string,
                        password=&gt;string,
                        resource=&gt;string)

           takes  all  of the information and builds a Net::XMPP::IQ::Auth packet.  It then sends that packet to
           the server with an ID and waits for that ID to  return.   Then  it  looks  in  resulting  packet  and
           determines  if  authentication  was  successful for not.  The array returned from AuthSend looks like
           this:

             [ type , message ]

           If type is "ok" then authentication was successful, otherwise message contains a little  more  detail
           about the error.

   <b>IQ::Register</b> <b>Functions</b>
       RegisterRequest
            RegisterRequest(to=&gt;string,  timeout=&gt;int)
            RegisterRequest()

           send  an  &lt;iq/&gt;  request  to the specified server/transport, if not specified it sends to the current
           active server.  The function returns a hash that contains the required fields.   Here is  an  example
           of the hash:

           $hash{fields}    - The raw fields from
                              the iq:register.
                              To be used if there
                              is no x:data in the
                              packet.

           $hash{instructions} - How to fill out
                                 the form.

           $hash{form}   - The new dynamic forms.

           In $hash{form}, the fields that are present are the required fields the server needs.

       RegisterSend
             RegisterSend(hash)

           takes  the  contents  of  the  hash  and  passes  it  to  the  SetRegister  function  in  the  module
           Net::XMPP::Query jabber:iq:register namespace.  This function returns an array that looks like this:

             [ type , message ]

           If type is "ok" then registration was successful, otherwise message contains  a  little  more  detail
           about the error.

   <b>Roster</b> <b>Functions</b>
       Roster
               Roster()

           returns a Net::XMPP::Roster object.  This will automatically intercept all of the roster and presence
           packets  sent  from the server and give you an accurate Roster.  For more information please read the
           man page for Net::XMPP::Roster.

       RosterParse
               RosterParse(IQ object)

           returns a hash that contains the roster parsed into the following data structure:

             $roster{'<a href="mailto:bob@jabber.org">bob@jabber.org</a>'}-&gt;{name}
                                 - Name you stored in the roster

             $roster{'<a href="mailto:bob@jabber.org">bob@jabber.org</a>'}-&gt;{subscription}
                                 - Subscription status
                                   (to, from, both, none)

             $roster{'<a href="mailto:bob@jabber.org">bob@jabber.org</a>'}-&gt;{ask}
                                 - The ask status from this user
                                   (subscribe, unsubscribe)

             $roster{'<a href="mailto:bob@jabber.org">bob@jabber.org</a>'}-&gt;{groups}
                                 - Array of groups that
                                   <a href="mailto:bob@jabber.org">bob@jabber.org</a> is in

       RosterGet
             RosterGet()

           sends an empty Net::XMPP::IQ::Roster tag to the server so the server will  send  the  Roster  to  the
           client.  Returns the above hash from RosterParse.

       RosterRequest
             RosterRequest()

           sends  an  empty  Net::XMPP::IQ::Roster  tag  to the server so the server will send the Roster to the
           client.

       RosterAdd
               RosterAdd(hash)

           sends a packet asking that the jid be added to the roster.  The hash format is defined in the SetItem
           function in the Net::XMPP::Query jabber:iq:roster namespace.

       RosterRemove
            RosterRemove(hash)

           sends a packet asking that the jid be removed from the roster.  The hash format  is  defined  in  the
           SetItem function in the Net::XMPP::Query jabber:iq:roster namespace.

   <b>Roster</b> <b>DB</b> <b>Functions</b>
       RosterDB
               RosterDB()

           Tell the object to initialize the callbacks to automatically populate the Roster DB.  If you do this,
           then  make  sure that you call <b>RosterRequest()</b> instead of <b>RosterGet()</b> so that the callbacks can catch
           it and parse it.

       RosterDBParse
               RosterDBParse(IQ object)

           If you  want  to  manually  control  the  database,  then  you  can  pass  in  all  iq  packets  with
           jabber:iq:roster queries to this function.

       RosterDBAdd
             RosterDBAdd(jid,hash)

           Add  a new JID into the roster DB.  The JID is either a string, or a Net::XMPP::JID object.  The hash
           must be the same format as the has returned by RosterParse above, and  is  the  actual  hash,  not  a
           reference.

       RosterDBRemove
             RosterDBRemove(jid)

           Remove a JID from the roster DB. The JID is either a string, or a Net::XMPP::JID object.

       RosterDBClear
           Remove all JIDs from the roster DB.

       RosterDBExists
            RosterDBExists(jid)

           return  1  if  the  JID  exists  in the roster DB, undef otherwise.  The JID is either a string, or a
           Net::XMPP::JID object.

       RosterDBJIDs
             RosterDBJIDs()

           returns a list of Net::XMPP::JID objects that represents all of the JIDs in the DB.

       RosterDBGroups
           returns the complete list of roster groups in the roster.

       RosterDBGroupExists
               RosterDBGroupExists(group)

           return 1 if the group is a group in the roster DB, undef otherwise.

       RosterDBGroupJIDs
               RosterDBGroupJIDs(group)

           returns a list of Net::XMPP::JID objects that represents all of the  JIDs  in  the  specified  roster
           group.

       RosterDBNonGroupJIDs
           returns a list of Net::XMPP::JID objects that represents all of the JIDs not in a roster group.

       RosterDBQuery
             RosterDBQuery(jid)

           returns  a  hash  containing  the data from the roster DB for the specified JID.  The JID is either a
           string, or a Net::XMPP::JID object.  The hash format the same as in RosterParse above.

       RosterDBQuery
             RosterDBQuery(jid,key)

           returns the entry from the above hash for the given key.  The available keys are:
             name, ask, subsrcription and groups The JID is either a string, or a Net::XMPP::JID object.

</pre><h4><b>AUTHOR</b></h4><pre>
       Originally authored by Ryan Eatmon.

       Previously maintained by Eric Hacker.

       Currently maintained by Darian Anthony Patrick.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This module is free software, you can redistribute it and/or modify it under the LGPL 2.1.

perl v5.34.0                                       2022-06-16                           <u>Net::XMPP::<a href="../man3pm/Protocol.3pm.html">Protocol</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>