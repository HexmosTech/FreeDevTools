<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POE::Component::Jabber::Protocol - A base class for implementing protocol differences</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpoe-component-jabber-perl">libpoe-component-jabber-perl_3.00-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       POE::Component::Jabber::Protocol - A base class for implementing protocol differences

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Inherit from this base class when implementing specifc protocol extentions that may exist when writing to
       support various other jabber server implementations.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       PCJ::Protocol is the base class used when differences between authentication or other connection
       initialization methods require special processing.

       A prime example is JABBER(tm) vs. XMPP. The Jabber protocol uses a much different method to authenticate
       (ie. using the iq:auth namespace) than XMPP which uses SASL. While the rest of the protocol is
       substantially unchanged, these differences mean they must be accounted. In the 1.x versions of PCJ, this
       was solved by having different duplicate classes in the same domain with these differences manifest. It
       led to lots of headaches if there was a problem because it then needed to be fixed in four places.

       The solution is to keep the core aspect of PCJ immutable, while loading separate individual Protocol
       classes that then implement the details for each specific dialect.

       As an end developer, if you wish to add support for another dialect (ie.  support another jabber server
       implementation that does service management differently), subclass from this module and then add your
       entry into the ProtocolFactory.

       Also be aware that PCJ uses object_states to construct its own session.  Protocol subclassees are
       expected to fit smoothly into that. See the METHOD <b>get_states()</b> for more information.

       And remember when you are finished handling the protocol specifics and the connection is finished, fire
       off the PCJ_INIT_FINISHED status, and call <b>relinquish_states()</b> from the $_[HEAP] object to return control
       back to the PCJ Core. (Yes, you read that correctly, $_[HEAP] is actually the PCJ object).

       If in doubt, please see the source code for the other Protocol subclasses (ie.  XMPP.pm, J14.pm, etc).

</pre><h4><b>METHODS</b></h4><pre>
       At a bare minimum, some methods must be implemented by the end developer. These will be indicated with a
       MANDATORY flag.

       <b>new()</b> [OPTIONAL]
           <b>new()</b> provides a default constructor. It returns a hash reference blessed into the provided class

       <b>get_version()</b> [MANDATORY]
           <b>get_version()</b> is used by PCJ to populate the 'version' attribute in the opening &lt;stream:stream/&gt;. For
           XMPP  enabled  clients, this must return '1.0'. For legacy Jabber connections, it should return '0.9'
           but it isn't required. For all other applications, see  the  appropriate  RFC  for  details  on  what
           version it expects.

       <b>get_xmlns()</b> [MANDATORY]
           <b>get_xmlns()</b>  is  used  by  PCJ  to  populate  the  default  XML  namespace  attribute  in the opening
           &lt;stream:stream/&gt;. Please feel free to use the constants in POE::Filter::XML::NS to provide this.

       <b>get_states()</b> [MANDATORY]
           get_states is used by PCJ to fill its object_states with the Protocol  states.   An  array  reference
           containing event names should be returned that corespond one-to-one with the methods you implement in
           your  subclass.  Or  if  a mapping is required, a hash reference should be returned that includes the
           mapping. See POE::Session for more detail on object_states.

       <b>get_input_event()</b> [MANDATORY]
           <b>get_input_event()</b> returns the main entry point event into the Protocol subclass. This is then used by
           PCJ to assign the event to the Wheel, so that the Protocol's events get fired from Wheel events.

       <b>get_error_event()</b> [OPTIONAL]
           <b>get_error_event()</b> returns the event to be called when an error occurs in the Wheel.  Typically,  this
           isn't required for Protocol subclasses, but is available if needed.

       <b>get_flushed_event()</b> [OPTIONAL]
           <b>get_flushed_event()</b>  returns  the  event  to  be  called  when the flushed event occurs in the Wheel.
           Typically, this isn't required for Protocol subclasses, but is available if needed.

</pre><h4><b>NOTES</b></h4><pre>
       Here are some quick tips to keep in mind when subclassing:

       Protocol subclassees execute within the same Session space as PCJ $_[HEAP] contains the PCJ  object.   If
       you  need storage space, use $_[OBJECT] (ie. yourself).  Send status events. See PCJ::Status Don't forget
       to send PCJ_READY.  And don't forget to call $_[HEAP]-&gt;<b>relinquish_states()</b> when finished.  When in doubt,
       use the source!

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (c) 2007-2009 Nicholas Perez. Distributed under the GPL.

perl v5.36.0                                       2023-08-26              <u>POE::Component::Jabber::<a href="../man3pm/Protocol.3pm.html">Protocol</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>