<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>inet - Access to TCP/IP protocols.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       inet - Access to TCP/IP protocols.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides access to TCP/IP protocols.

       See  also  ERTS  User's  Guide:  Inet Configuration for more information about how to configure an Erlang
       runtime system for IP communication.

       The following two Kernel configuration parameters affect the behavior of all sockets opened on an  Erlang
       node:

         * <u>inet_default_connect_options</u> can contain a list of default options used for all sockets returned when
           doing <u>connect</u>.

         * <u>inet_default_listen_options</u> can contain a list of default options used when issuing a <u>listen</u> call.

       When  <u>accept</u>  is  issued,  the  values of the listening socket options are inherited. No such application
       variable is therefore needed for <u>accept</u>.

       Using the Kernel configuration parameters above, one can set default options for all  TCP  sockets  on  a
       node,  but  use  this  with  care.  Options  such  as <u>{delay_send,true}</u> can be specified in this way. The
       following is an example of starting an Erlang node with all sockets using delayed send:

       $ erl -sname test -kernel \
       inet_default_connect_options '[{delay_send,true}]' \
       inet_default_listen_options '[{delay_send,true}]'

       Notice that default option <u>{active,</u> <u>true}</u> cannot be changed, for internal reasons.

       Addresses as inputs to functions can be either  a  string  or  a  tuple.  For  example,  the  IP  address
       150.236.20.73  can  be passed to <u>gethostbyaddr/1</u>, either as string <u>"150.236.20.73"</u> or as tuple <u>{150,</u> <u>236,</u>
       <u>20,</u> <u>73}</u>.

       <u>IPv4</u> <u>address</u> <u>examples:</u>

       Address          ip_address()
       -------          ------------
       127.0.0.1        {127,0,0,1}
       192.168.42.2     {192,168,42,2}

       <u>IPv6</u> <u>address</u> <u>examples:</u>

       Address          ip_address()
       -------          ------------
       ::1             {0,0,0,0,0,0,0,1}
       ::192.168.42.2  {0,0,0,0,0,0,(192 bsl 8) bor 168,(42 bsl 8) bor 2}
       ::FFFF:192.168.42.2
                       {0,0,0,0,0,16#FFFF,(192 bsl 8) bor 168,(42 bsl 8) bor 2}
       3ffe:b80:1f8d:2:204:acff:fe17:bf38
                       {16#3ffe,16#b80,16#1f8d,16#2,16#204,16#acff,16#fe17,16#bf38}
       fe80::204:acff:fe17:bf38
                       {16#fe80,0,0,0,16#204,16#acff,16#fe17,16#bf38}

       Function <u>parse_address/1</u> can be useful:

       1&gt; inet:parse_address("192.168.42.2").
       {ok,{192,168,42,2}}
       2&gt; inet:parse_address("::FFFF:192.168.42.2").
       {ok,{0,0,0,0,0,65535,49320,10754}}

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>hostent()</b> =
           #hostent{h_name = inet:hostname(),
                    h_aliases = [inet:hostname()],
                    h_addrtype = inet | inet6,
                    h_length = integer() &gt;= 0,
                    h_addr_list = [inet:ip_address()]}

              The record is defined in the Kernel include file <u>"inet.hrl"</u>.

              Add the following directive to the module:

              -include_lib("kernel/include/inet.hrl").

       <b>hostname()</b> = atom() | string()

       <b>ip_address()</b> = ip4_address() | ip6_address()

       <b>ip4_address()</b> = {0..255, 0..255, 0..255, 0..255}

       <b>ip6_address()</b> =
           {0..65535,
            0..65535,
            0..65535,
            0..65535,
            0..65535,
            0..65535,
            0..65535,
            0..65535}

       <b>port_number()</b> = 0..65535

       <b>family_address()</b> =
           inet_address() | inet6_address() | local_address()

              A general address format on the form <u>{Family,</u> <u>Destination}</u> where <u>Family</u> is an atom such  as  <u>local</u>
              and  the  format  of  <u>Destination</u>  depends on <u>Family</u>, and is a complete address (for example an IP
              address including port number).

       <b>inet_address()</b> =
           {inet, {ip4_address() | any | loopback, port_number()}}

          <b>Warning:</b>
              This address format is for now experimental and for completeness to make all address families have
              a <u>{Family,</u> <u>Destination}</u> representation.

       <b>inet6_address()</b> =
           {inet6, {ip6_address() | any | loopback, port_number()}}

          <b>Warning:</b>
              This address format is for now experimental and for completeness to make all address families have
              a <u>{Family,</u> <u>Destination}</u> representation.

       <b>local_address()</b> = {local, File :: binary() | string()}

              This address family only works on Unix-like systems.

              <u>File</u> is normally a file pathname in a local filesystem. It is limited in length by  the  operating
              system, traditionally to 108 bytes.

              A  <u>binary()</u>  is  passed  as is to the operating system, but a <u>string()</u> is encoded according to the
              system filename encoding mode.

              Other addresses  are  possible,  for  example  Linux  implements  "Abstract  Addresses".  See  the
              documentation for Unix Domain Sockets on your system, normally <u>unix</u> in manual section 7.

              In most API functions where you can use this address family the port number must be <u>0</u>.

       <b>inet_backend()</b> = {inet_backend, inet | socket}

              Select  the  implementation  backend  for sockets. The current default is <u>inet</u> which at the bottom
              uses <u>inet_drv.c</u> to call the platform's socket API. The value <u>socket</u> instead at the bottom uses the
              <u>socket</u> module and its NIF implementation.

              This is a <u>temporary</u> option that will be ignored in a future release.

       <b>socket_address()</b> =
           ip_address() | any | loopback | local_address()

       <b>socket_getopt()</b> =
           gen_sctp:option_name() |
           gen_tcp:option_name() |
           gen_udp:option_name()

       <b>socket_setopt()</b> =
           gen_sctp:option() | gen_tcp:option() | gen_udp:option()

       <b>returned_non_ip_address()</b> =
           {local, binary()} | {unspec, &lt;&lt;&gt;&gt;} | {undefined, any()}

              Addresses besides <u>ip_address()</u> ones that are returned from socket API functions. See in particular
              <u>local_address()</u>.  The <u>unspec</u> family corresponds to AF_UNSPEC and can occur if the other  side  has
              no  socket address. The <u>undefined</u> family can only occur in the unlikely event of an address family
              that the VM does not recognize.

       <b>ancillary_data()</b> =
           [{tos, byte()} | {tclass, byte()} | {ttl, byte()}]

              Ancillary data received with the data packet, read with the socket option <u>pktoptions</u>  from  a  TCP
              socket, or to set in a call to <u>gen_udp:send/4</u> or <u>gen_udp:send/5</u>.

              The value(s) correspond to the currently active socket options <u>recvtos</u>, <u>recvtclass</u> and <u>recvttl</u>, or
              for a single send operation the option(s) to override the currently active socket option(s).

       <b>getifaddrs_ifopts()</b> =
           [Ifopt ::
                {flags,
                 Flags ::
                     [up | broadcast | loopback | pointtopoint |
                      running | multicast]} |
                {addr, Addr :: ip_address()} |
                {netmask, Netmask :: ip_address()} |
                {broadaddr, Broadaddr :: ip_address()} |
                {dstaddr, Dstaddr :: ip_address()} |
                {hwaddr, Hwaddr :: [byte()]}]

              Interface  address description list returned from <u>getifaddrs/0,1</u> for a named interface, translated
              from the returned data of the POSIX API function <u>getaddrinfo()</u>.

              <u>Hwaddr</u> is hardware dependent, for example, on  Ethernet  interfaces  it  is  the  6-byte  Ethernet
              address (MAC address (EUI-48 address)).

              The tuples <u>{addr,Addr}</u>, <u>{netmask,Netmask}</u>, and possibly <u>{broadaddr,Broadaddr}</u> or <u>{dstaddr,Dstaddr}</u>
              are  repeated  in  the  list  if  the  interface has got multiple addresses. An interface may have
              multiple <u>{flag,_}</u> tuples for example if it has different flags  for  different  address  families.
              Multiple  <u>{hwaddr,Hwaddr}</u>  tuples  is  hard  to  say  anything  definite  about, though. The tuple
              <u>{flag,Flags}</u> is mandatory, all others are optional.

              Do not rely too much on the order of <u>Flags</u> atoms or the  <u>Ifopt</u>  tuples.  There  are  however  some
              rules:

                * A <u>{flag,_}</u> tuple applies to all other tuples that follow.

                * Immediately after <u>{addr,_}</u> follows <u>{netmask,_}</u>.

                * Immediately  thereafter  may  <u>{broadaddr,_}</u>  follow  if  <u>broadcast</u>  is  member  of  <u>Flags</u>,  or
                  <u>{dstaddr,_}</u> if <u>pointtopoint</u> is member of <u>Flags</u>. Both <u>{dstaddr,_}</u> and  <u>{broadaddr,_}</u>  does  not
                  occur for the same <u>{addr,_}</u>.

                * Any  <u>{netmask,_}</u>,  <u>{broadaddr,_}</u>,  or  <u>{dstaddr,_}</u>  tuples  that  follow  an <u>{addr,Addr}</u> tuple
                  concerns the address <u>Addr</u>.

              The tuple <u>{hwaddr,_}</u> is not returned on Solaris, as the hardware address historically  belongs  to
              the link layer and it is not returned by the Solaris API function <u>getaddrinfo()</u>.

          <b>Warning:</b>
              On  Windows,  the  data  is  fetched from different OS API functions, so the <u>Netmask</u> and <u>Broadaddr</u>
              values may be calculated, just as some <u>Flags</u> values.

       <b>posix()</b> =
           eaddrinuse | eaddrnotavail | eafnosupport | ealready |
           econnaborted | econnrefused | econnreset | edestaddrreq |
           ehostdown | ehostunreach | einprogress | eisconn | emsgsize |
           enetdown | enetunreach | enopkg | enoprotoopt | enotconn |
           enotty | enotsock | eproto | eprotonosupport | eprototype |
           esocktnosupport | etimedout | ewouldblock | exbadport |
           exbadseq |
           file:posix()

              An atom that is named from the POSIX error codes used in Unix, and in  the  runtime  libraries  of
              most C compilers. See section POSIX Error Codes.

       <b>socket()</b>

              See <u>gen_tcp:type-socket</u> and <u>gen_udp:type-socket</u>.

       <b>address_family()</b> = inet | inet6 | local

       <b>socket_protocol()</b> = tcp | udp | sctp

       <b>stat_option()</b> =
           recv_cnt | recv_max | recv_avg | recv_oct | recv_dvi |
           send_cnt | send_max | send_avg | send_oct | send_pend

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>close(Socket)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Socket = socket()

              Closes a socket of any type.

       <b>cancel_monitor(MRef)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 MRef = reference()

              If  <u>MRef</u>  is  a  reference that the calling process obtained by calling <u>monitor/1</u>, this monitor is
              turned off. If the monitoring is already turned off, nothing happens.

              The returned value is one of the following:

                <u>true</u>:
                  The monitor was found and removed. In this case,  no  <u>'DOWN'</u>  message  corresponding  to  this
                  monitor has been delivered and will not be delivered.

                <u>false</u>:
                  The  monitor  was  not  found and could not be removed. This probably because a <u>'DOWN'</u> message
                  corresponding to this monitor has already been placed in the caller message queue.

              Failure: It is an error if <u>MRef</u> refers to a monitor started by another process.

       <b>format_error(Reason)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Reason = posix() | system_limit

              Returns a diagnostic error string. For  possible  POSIX  values  and  corresponding  strings,  see
              section POSIX Error Codes.

       <b>get_rc()</b> <b>-&gt;</b>
                 [{Par :: atom(), Val :: any()} |
                  {Par :: atom(), Val1 :: any(), Val2 :: any()}]

              Returns  the  state of the <u>Inet</u> configuration database in form of a list of recorded configuration
              parameters. For more information, see ERTS User's Guide: Inet Configuration.

              Only actual parameters with other than default values are returned,  for  example  not  directives
              that specify other sources for configuration parameters nor directives that clear parameters.

       <b>getaddr(Host,</b> <b>Family)</b> <b>-&gt;</b> <b>{ok,</b> <b>Address}</b> <b>|</b> <b>{error,</b> <b>posix()}</b>

              Types:

                 Host = ip_address() | hostname()
                 Family = address_family()
                 Address = ip_address()

              Returns  the  IP  address  for  <u>Host</u>  as  a tuple of integers. <u>Host</u> can be an IP address, a single
              hostname, or a fully qualified hostname.

       <b>getaddrs(Host,</b> <b>Family)</b> <b>-&gt;</b> <b>{ok,</b> <b>Addresses}</b> <b>|</b> <b>{error,</b> <b>posix()}</b>

              Types:

                 Host = ip_address() | hostname()
                 Family = address_family()
                 Addresses = [ip_address()]

              Returns a list of all IP addresses for <u>Host</u>. <u>Host</u> can be an IP address, a single  hostname,  or  a
              fully qualified hostname.

       <b>gethostbyaddr(Address)</b> <b>-&gt;</b> <b>{ok,</b> <b>Hostent}</b> <b>|</b> <b>{error,</b> <b>posix()}</b>

              Types:

                 Address = string() | ip_address()
                 Hostent = hostent()

              Returns a <u>hostent</u> record for the host with the specified address.

       <b>gethostbyname(Hostname)</b> <b>-&gt;</b> <b>{ok,</b> <b>Hostent}</b> <b>|</b> <b>{error,</b> <b>posix()}</b>

              Types:

                 Hostname = hostname()
                 Hostent = hostent()

              Returns a <u>hostent</u> record for the host with the specified hostname.

              If resolver option <u>inet6</u> is <u>true</u>, an IPv6 address is looked up.

       <b>gethostbyname(Hostname,</b> <b>Family)</b> <b>-&gt;</b>
                        {ok, Hostent} | {error, posix()}

              Types:

                 Hostname = hostname()
                 Family = address_family()
                 Hostent = hostent()

              Returns a <u>hostent</u> record for the host with the specified name, restricted to the specified address
              family.

       <b>gethostname()</b> <b>-&gt;</b> <b>{ok,</b> <b>Hostname}</b>

              Types:

                 Hostname = string()

              Returns the local hostname. Never fails.

       <b>getifaddrs()</b> <b>-&gt;</b>
                     {ok,
                      [{Ifname :: string(),
                        Ifopts :: getifaddrs_ifopts()}]} |
                     {error, posix()}

              Returns  a  list of 2-tuples containing interface names and the interfaces' addresses. <u>Ifname</u> is a
              Unicode string and <u>Ifopts</u> is a list of interface address description tuples.

              The interface address description tuples are documented under the type of the <u>Ifopts</u> value.

       <b>getifaddrs(Opts)</b> <b>-&gt;</b> <b>{ok,</b> <b>[{Ifname,</b> <b>Ifopts}]}</b> <b>|</b> <b>{error,</b> <b>Posix}</b>

              Types:

                  Opts = [{netns, Namespace}]
                  Namespace =  file:filename_all()
                 Ifname = string()
                  Ifopts =  getifaddrs_ifopts()
                 Posix = posix()

              The same as <u>getifaddrs/0</u> but the <u>Option</u> <u>{netns,</u> <u>Namespace}</u> sets a network  namespace  for  the  OS
              call, on platforms that supports that feature.

              See the socket option <u>{netns,</u> <u>Namespace}</u> under <u>setopts/2</u>.

       <b>getopts(Socket,</b> <b>Options)</b> <b>-&gt;</b> <b>{ok,</b> <b>OptionValues}</b> <b>|</b> <b>{error,</b> <b>posix()}</b>

              Types:

                 Socket = socket()
                 Options = [socket_getopt()]
                 OptionValues = [socket_setopt() | gen_tcp:pktoptions_value()]

              Gets  one  or  more options for a socket. For a list of available options, see <u>setopts/2</u>. See also
              the description for the type <u>gen_tcp:pktoptions_value()</u>.

              The number of elements in the returned <u>OptionValues</u> list does not necessarily  correspond  to  the
              number of options asked for. If the operating system fails to support an option, it is left out in
              the  returned  list.  An  error  tuple  is  returned  only  when getting options for the socket is
              impossible (that is, the socket is closed or the buffer size in a raw request is too large).  This
              behavior is kept for backward compatibility reasons.

              A  raw  option  request  <u>RawOptReq</u>  <u>=</u>  <u>{raw,</u>  <u>Protocol,</u>  <u>OptionNum,</u>  <u>ValueSpec}</u> can be used to get
              information about socket options not (explicitly) supported by the emulator. The use of raw socket
              options makes the code non-portable, but allows the Erlang programmer to take advantage of unusual
              features present on a particular platform.

              <u>RawOptReq</u> consists of tag <u>raw</u> followed by the protocol level, the  option  number,  and  either  a
              binary or the size, in bytes, of the buffer in which the option value is to be stored. A binary is
              to  be used when the underlying <u>getsockopt</u> requires <u>input</u> in the argument field. In this case, the
              binary size is to correspond to the required buffer size of the return value. The supplied  values
              in a <u>RawOptReq</u> correspond to the second, third, and fourth/fifth parameters to the <u>getsockopt</u> call
              in  the  C  socket API. The value stored in the buffer is returned as a binary <u>ValueBin</u>, where all
              values are coded in the native endianess.

              Asking for and inspecting raw socket options  require  low-level  information  about  the  current
              operating system and TCP stack.

              <u>Example:</u>

              Consider a Linux machine where option <u>TCP_INFO</u> can be used to collect TCP statistics for a socket.
              Assume  you  are  interested  in  field  <u>tcpi_sacked</u>  of <u>struct</u> <u>tcp_info</u> filled in when asking for
              <u>TCP_INFO</u>. To be able to access this information, you need to know the following:

                * The numeric value of protocol level <u>IPPROTO_TCP</u>

                * The numeric value of option <u>TCP_INFO</u>

                * The size of <u>struct</u> <u>tcp_info</u>

                * The size and offset of the specific field

              By inspecting the headers or writing a small C  program,  it  is  found  that  <u>IPPROTO_TCP</u>  is  6,
              <u>TCP_INFO</u>  is  11, the structure size is 92 (bytes), the offset of <u>tcpi_sacked</u> is 28 bytes, and the
              value is a 32-bit integer. The following code can be used to retrieve the value:

              get_tcpi_sacked(Sock) -&gt;
                  {ok,[{raw,_,_,Info}]} = inet:getopts(Sock,[{raw,6,11,92}]),
                  &lt;&lt;_:28/binary,TcpiSacked:32/native,_/binary&gt;&gt; = Info,
                  TcpiSacked.

              Preferably, you would check the machine type, the operating system, and the Kernel version  before
              executing anything similar to this code.

       <b>getstat(Socket)</b> <b>-&gt;</b> <b>{ok,</b> <b>OptionValues}</b> <b>|</b> <b>{error,</b> <b>posix()}</b>

       <b>getstat(Socket,</b> <b>Options)</b> <b>-&gt;</b> <b>{ok,</b> <b>OptionValues}</b> <b>|</b> <b>{error,</b> <b>posix()}</b>

              Types:

                 Socket = socket()
                 Options = [stat_option()]
                 OptionValues = [{stat_option(), integer()}]
                 <b>stat_option()</b> =
                     recv_cnt | recv_max | recv_avg | recv_oct | recv_dvi |
                     send_cnt | send_max | send_avg | send_oct | send_pend

              Gets one or more statistic options for a socket.

              <u>getstat(Socket)</u>   is  equivalent  to  <u>getstat(Socket,</u>  <u>[recv_avg,</u>  <u>recv_cnt,</u>  <u>recv_dvi,</u>  <u>recv_max,</u>
              <u>recv_oct,</u> <u>send_avg,</u> <u>send_cnt,</u> <u>send_pend,</u> <u>send_max,</u> <u>send_oct])</u>.

              The following options are available:

                <u>recv_avg</u>:
                  Average size of packets, in bytes, received by the socket.

                <u>recv_cnt</u>:
                  Number of packets received by the socket.

                <u>recv_dvi</u>:
                  Average packet size deviation, in bytes, received by the socket.

                <u>recv_max</u>:
                  Size of the largest packet, in bytes, received by the socket.

                <u>recv_oct</u>:
                  Number of bytes received by the socket.

                <u>send_avg</u>:
                  Average size of packets, in bytes, sent from the socket.

                <u>send_cnt</u>:
                  Number of packets sent from the socket.

                <u>send_pend</u>:
                  Number of bytes waiting to be sent by the socket.

                <u>send_max</u>:
                  Size of the largest packet, in bytes, sent from the socket.

                <u>send_oct</u>:
                  Number of bytes sent from the socket.

       <b>i()</b> <b>-&gt;</b> <b>ok</b>

       <b>i(Proto</b> <b>::</b> <b>socket_protocol())</b> <b>-&gt;</b> <b>ok</b>

       <b>i(X1</b> <b>::</b> <b>socket_protocol(),</b> <b>Fs</b> <b>::</b> <b>[atom()])</b> <b>-&gt;</b> <b>ok</b>

              Lists all TCP, UDP and SCTP sockets, including those that the Erlang runtime system uses  as  well
              as those created by the application.

              The following options are available:

                <u>port</u>:
                  The internal index of the port.

                <u>module</u>:
                  The callback module of the socket.

                <u>recv</u>:
                  Number of bytes received by the socket.

                <u>sent</u>:
                  Number of bytes sent from the socket.

                <u>owner</u>:
                  The socket owner process.

                <u>local_address</u>:
                  The local address of the socket.

                <u>foreign_address</u>:
                  The address and port of the other end of the connection.

                <u>state</u>:
                  The connection state.

                <u>type</u>:
                  STREAM or DGRAM or SEQPACKET.

       <b>info(Socket)</b> <b>-&gt;</b> <b>Info</b>

              Types:

                 Socket = socket()
                 Info = term()

              Produces a term containg miscellaneous information about a socket.

       <b>monitor(Socket)</b> <b>-&gt;</b> <b>reference()</b>

              Types:

                 Socket = socket()

              Start monitor the socket <u>Socket</u>.

              If  the monitored socket does not exist or when the monitor is triggered, a <u>'DOWN'</u> message is sent
              that has the following pattern:

                       {'DOWN', MonitorRef, Type, Object, Info}

                <u>MonitorRef</u>:
                  The identity of the socket.

                <u>Type</u>:
                  The type of socket, can be one of the following atoms: port or socket.

                <u>Object</u>:
                  The monitored entity, the socket, which triggered the event.

                <u>Info</u>:
                  Either the termination reason of the socket or <u>nosock</u> (socket <u>Socket</u> did not exist at the time
                  of monitor creation).

              Making several calls to <u>inet:monitor/1</u> for the same <u>Socket</u> is not an error; it results in as  many
              independent monitoring instances.

       <b>ntoa(IpAddress)</b> <b>-&gt;</b> <b>Address</b> <b>|</b> <b>{error,</b> <b>einval}</b>

              Types:

                 Address = string()
                 IpAddress = ip_address()

              Parses an <u>ip_address()</u> and returns an IPv4 or IPv6 address string.

       <b>parse_address(Address)</b> <b>-&gt;</b> <b>{ok,</b> <b>IPAddress}</b> <b>|</b> <b>{error,</b> <b>einval}</b>

              Types:

                 Address = string()
                 IPAddress = ip_address()

              Parses  an  IPv4  or  IPv6 address string and returns an <u>ip4_address()</u> or <u>ip6_address()</u>. Accepts a
              shortened IPv4 address string.

       <b>parse_ipv4_address(Address)</b> <b>-&gt;</b> <b>{ok,</b> <b>IPv4Address}</b> <b>|</b> <b>{error,</b> <b>einval}</b>

              Types:

                 Address = string()
                 IPv4Address = ip_address()

              Parses an IPv4 address string and returns an  <u>ip4_address()</u>.  Accepts  a  shortened  IPv4  address
              string.

       <b>parse_ipv4strict_address(Address)</b> <b>-&gt;</b>
                                   {ok, IPv4Address} | {error, einval}

              Types:

                 Address = string()
                 IPv4Address = ip_address()

              Parses  an  IPv4  address  string  containing  four fields, that is, <u>not</u> shortened, and returns an
              <u>ip4_address()</u>.

       <b>parse_ipv6_address(Address)</b> <b>-&gt;</b> <b>{ok,</b> <b>IPv6Address}</b> <b>|</b> <b>{error,</b> <b>einval}</b>

              Types:

                 Address = string()
                 IPv6Address = ip_address()

              Parses an IPv6 address string  and  returns  an  <u>ip6_address()</u>.  If  an  IPv4  address  string  is
              specified, an IPv4-mapped IPv6 address is returned.

       <b>parse_ipv6strict_address(Address)</b> <b>-&gt;</b>
                                   {ok, IPv6Address} | {error, einval}

              Types:

                 Address = string()
                 IPv6Address = ip_address()

              Parses an IPv6 address string and returns an <u>ip6_address()</u>. Does <u>not</u> accept IPv4 addresses.

       <b>ipv4_mapped_ipv6_address(X1</b> <b>::</b> <b>ip_address())</b> <b>-&gt;</b> <b>ip_address()</b>

              Convert  an  IPv4  address  to an IPv4-mapped IPv6 address or the reverse. When converting from an
              IPv6 address all but the 2 low words are ignored so this function also works on some  other  types
              of addresses than IPv4-mapped.

       <b>parse_strict_address(Address)</b> <b>-&gt;</b> <b>{ok,</b> <b>IPAddress}</b> <b>|</b> <b>{error,</b> <b>einval}</b>

              Types:

                 Address = string()
                 IPAddress = ip_address()

              Parses  an  IPv4  or  IPv6  address string and returns an <u>ip4_address()</u> or <u>ip6_address()</u>. Does <u>not</u>
              accept a shortened IPv4 address string.

       <b>peername(Socket</b> <b>::</b> <b>socket())</b> <b>-&gt;</b>
                   {ok,
                    {ip_address(), port_number()} |
                    returned_non_ip_address()} |
                   {error, posix()}

              Returns the address and port for the other end of a connection.

              Notice that for SCTP sockets, this function returns only one of the peer addresses of the  socket.
              Function <u>peernames/1,2</u> returns all.

       <b>peernames(Socket</b> <b>::</b> <b>socket())</b> <b>-&gt;</b>
                    {ok,
                     [{ip_address(), port_number()} |
                      returned_non_ip_address()]} |
                    {error, posix()}

              Equivalent to <u>peernames(Socket,</u> <u>0)</u>.

              Notice  that  the behavior of this function for an SCTP one-to-many style socket is not defined by
              the SCTP Sockets API Extensions.

       <b>peernames(Socket,</b> <b>Assoc)</b> <b>-&gt;</b>
                    {ok, [{Address, Port}]} | {error, posix()}

              Types:

                 Socket = socket()
                 Assoc = #sctp_assoc_change{} | gen_sctp:assoc_id()
                 Address = ip_address()
                 Port = integer() &gt;= 0

              Returns a list of all address/port number pairs for the other end of an  association  <u>Assoc</u>  of  a
              socket.

              This  function  can  return  multiple  addresses for multihomed sockets, such as SCTP sockets. For
              other sockets it returns a one-element list.

              Notice that parameter <u>Assoc</u> is by the SCTP Sockets API Extensions defined to be ignored  for  one-
              to-one  style  sockets.  What  the special value <u>0</u> means, hence its behavior for one-to-many style
              sockets, is unfortunately undefined.

       <b>port(Socket)</b> <b>-&gt;</b> <b>{ok,</b> <b>Port}</b> <b>|</b> <b>{error,</b> <b>any()}</b>

              Types:

                 Socket = socket()
                 Port = port_number()

              Returns the local port number for a socket.

       <b>setopts(Socket,</b> <b>Options)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>posix()}</b>

              Types:

                 Socket = socket()
                 Options = [socket_setopt()]

              Sets one or more options for a socket.

              The following options are available:

                <u>{active,</u> <u>true</u> <u>|</u> <u>false</u> <u>|</u> <u>once</u> <u>|</u> <u>N}</u>:
                  If the value is <u>true</u>, which is the default, everything received from the  socket  is  sent  as
                  messages to the receiving process.

                  If  the  value  is  <u>false</u> (passive mode), the process must explicitly receive incoming data by
                  calling <u>gen_tcp:recv/2,3</u>, <u>gen_udp:recv/2,3</u>, or <u>gen_sctp:recv/1,2</u> (depending  on  the  type  of
                  socket).

                  If  the  value  is  <u>once</u>  (<u>{active,</u>  <u>once}</u>),  <u>one</u>  data message from the socket is sent to the
                  process. To receive one more message, <u>setopts/2</u> must be  called  again  with  option  <u>{active,</u>
                  <u>once}</u>.

                  If  the  value is an integer <u>N</u> in the range -32768 to 32767 (inclusive), the value is added to
                  the socket's count of data messages sent  to  the  controlling  process.  A  socket's  default
                  message count is <u>0</u>. If a negative value is specified, and its magnitude is equal to or greater
                  than  the  socket's  current  message  count, the socket's message count is set to <u>0</u>. Once the
                  socket's message count reaches <u>0</u>, either because of sending  received  data  messages  to  the
                  process  or  by  being  explicitly  set,  the  process  is then notified by a special message,
                  specific to the type of socket, that the socket has entered  passive  mode.  Once  the  socket
                  enters passive mode, to receive more messages <u>setopts/2</u> must be called again to set the socket
                  back into an active mode.

                  When  using <u>{active,</u> <u>once}</u> or <u>{active,</u> <u>N}</u>, the socket changes behavior automatically when data
                  is received. This can be confusing in combination with connection-oriented sockets  (that  is,
                  <u>gen_tcp</u>),  as a socket with <u>{active,</u> <u>false}</u> behavior reports closing differently than a socket
                  with <u>{active,</u> <u>true}</u> behavior. To simplify programming, a socket where  the  peer  closed,  and
                  this  is  detected  while in <u>{active,</u> <u>false}</u> mode, still generates message <u>{tcp_closed,Socket}</u>
                  when set to <u>{active,</u> <u>once}</u>, <u>{active,</u> <u>true}</u>, or <u>{active,</u> <u>N}</u>  mode.  It  is  therefore  safe  to
                  assume  that  message  <u>{tcp_closed,Socket}</u>,  possibly  followed  by  socket  port  termination
                  (depending on option <u>exit_on_close</u>) eventually appears when a socket changes  back  and  forth
                  between  <u>{active,</u> <u>true}</u> and <u>{active,</u> <u>false}</u> mode. However, <u>when</u> peer closing is detected it is
                  all up to the underlying TCP/IP stack and protocol.

                  Notice that <u>{active,</u> <u>true}</u> mode provides no flow control; a fast sender  can  easily  overflow
                  the  receiver with incoming messages. The same is true for <u>{active,</u> <u>N}</u> mode, while the message
                  count is greater than zero.

                  Use active mode only if your high-level protocol provides its own flow control  (for  example,
                  acknowledging  received  messages)  or  the amount of data exchanged is small. <u>{active,</u> <u>false}</u>
                  mode, use of the <u>{active,</u> <u>once}</u> mode, or <u>{active,</u> <u>N}</u> mode with values of <u>N</u> appropriate for the
                  application provides flow control. The other side cannot send faster  than  the  receiver  can
                  read.

                <u>{broadcast,</u> <u>Boolean}</u> (UDP sockets):
                  Enables/disables permission to send broadcasts.

                <u>{buffer,</u> <u>Size}</u>:
                  The  size  of the user-level buffer used by the driver. Not to be confused with options <u>sndbuf</u>
                  and <u>recbuf</u>, which correspond to the Kernel socket buffers. For TCP it is recommended  to  have
                  <u>val(buffer)</u> <u>&gt;=</u> <u>val(recbuf)</u> to avoid performance issues because of unnecessary copying. For UDP
                  the  same recommendation applies, but the max should not be larger than the MTU of the network
                  path. <u>val(buffer)</u> is automatically set to the above maximum when <u>recbuf</u> is  set.  However,  as
                  the  size set for <u>recbuf</u> usually become larger, you are encouraged to use <u>getopts/2</u> to analyze
                  the behavior of your operating system.

                  Note that this is also the maximum amount of data that can be  received  from  a  single  recv
                  call. If you are using higher than normal MTU consider setting buffer higher.

                <u>{delay_send,</u> <u>Boolean}</u>:
                  Normally,  when  an  Erlang  process  sends  to  a  socket,  the driver tries to send the data
                  immediately. If that fails, the driver uses any means available to queue up the message to  be
                  sent whenever the operating system says it can handle it. Setting <u>{delay_send,</u> <u>true}</u> makes <u>all</u>
                  messages  queue  up.  The  messages  sent to the network are then larger but fewer. The option
                  affects the scheduling of send requests versus Erlang processes instead of changing  any  real
                  property of the socket. The option is implementation-specific. Defaults to <u>false</u>.

                <u>{deliver,</u> <u>port</u> <u>|</u> <u>term}</u>:
                  When  <u>{active,</u>  <u>true}</u>,  data is delivered on the form <u>port</u> : <u>{S,</u> <u>{data,</u> <u>[H1,..Hsz</u> <u>|</u> <u>Data]}}</u> or
                  <u>term</u> : <u>{tcp,</u> <u>S,</u> <u>[H1..Hsz</u> <u>|</u> <u>Data]}</u>.

                <u>{dontroute,</u> <u>Boolean}</u>:
                  Enables/disables routing bypass for outgoing messages.

                <u>{exit_on_close,</u> <u>Boolean}</u>:
                  This option is set to <u>true</u> by default.

                  The only reason to set it to <u>false</u> is if you want to continue sending data to the socket after
                  a close is detected, for example, if the peer uses <u>gen_tcp:shutdown/2</u> to shut down  the  write
                  side.

                <u>{header,</u> <u>Size}</u>:
                  This  option is only meaningful if option <u>binary</u> was specified when the socket was created. If
                  option <u>header</u> is specified, the first <u>Size</u> number bytes of data received from the  socket  are
                  elements of a list, and the remaining data is a binary specified as the tail of the same list.
                  For example, if <u>Size</u> <u>==</u> <u>2</u>, the data received matches <u>[Byte1,Byte2|Binary]</u>.

                <u>{high_msgq_watermark,</u> <u>Size}</u>:
                  The  socket  message queue is set to a busy state when the amount of data on the message queue
                  reaches this limit. Notice that this limit only concerns data that has  not  yet  reached  the
                  ERTS internal socket implementation. Defaults to 8 kB.

                  Senders  of data to the socket are suspended if either the socket message queue is busy or the
                  socket itself is busy.

                  For more information, see options <u>low_msgq_watermark</u>, <u>high_watermark</u>, and <u>low_watermark</u>.

                  Notice   that   distribution   sockets   disable   the   use   of   <u>high_msgq_watermark</u>    and
                  <u>low_msgq_watermark</u>.  Instead  use  the  distribution  buffer  busy  limit,  which is a similar
                  feature.

                <u>{high_watermark,</u> <u>Size}</u> (TCP/IP sockets):
                  The socket is set to a busy state when the amount of data queued internally by the ERTS socket
                  implementation reaches this limit. Defaults to 8 kB.

                  Senders of data to the socket are suspended if either the socket message queue is busy or  the
                  socket itself is busy.

                  For more information, see options <u>low_watermark</u>, <u>high_msgq_watermark</u>, and <u>low_msqg_watermark</u>.

                <u>{ipv6_v6only,</u> <u>Boolean}</u>:
                  Restricts  the  socket  to  use  only  IPv6,  prohibiting  any  IPv4 connections. This is only
                  applicable for IPv6 sockets (option <u>inet6</u>).

                  On most platforms this option must be set on the socket before associating it to  an  address.
                  It  is therefore only reasonable to specify it when creating the socket and not to use it when
                  calling function (<u>setopts/2</u>) containing this description.

                  The behavior of a socket with this option set to <u>true</u> is the only portable one.  The  original
                  idea  when  IPv6  was new of using IPv6 for all traffic is now not recommended by FreeBSD (you
                  can use <u>{ipv6_v6only,false}</u> to override the recommended system default  value),  forbidden  by
                  OpenBSD (the supported GENERIC kernel), and impossible on Windows (which has separate IPv4 and
                  IPv6  protocol  stacks).  Most  Linux distros still have a system default value of <u>false</u>. This
                  policy shift among operating systems to separate IPv6 from IPv4 traffic  has  evolved,  as  it
                  gradually proved hard and complicated to get a dual stack implementation correct and secure.

                  On  some  platforms,  the only allowed value for this option is <u>true</u>, for example, OpenBSD and
                  Windows. Trying to set this option to <u>false</u>, when creating the socket, fails in this case.

                  Setting this option on platforms where it does not exist is ignored. Getting this option  with
                  <u>getopts/2</u>  returns  no  value,  that is, the returned list does not contain an <u>{ipv6_v6only,_}</u>
                  tuple. On Windows, the option does not exist, but it is emulated as a  read-only  option  with
                  value <u>true</u>.

                  Therefore,  setting this option to <u>true</u> when creating a socket never fails, except possibly on
                  a platform where you have customized the kernel to only allow <u>false</u>, which can be doable  (but
                  awkward) on, for example, OpenBSD.

                  If  you read back the option value using <u>getopts/2</u> and get no value, the option does not exist
                  in the host operating system. The behavior of both an IPv6 and an IPv4 socket listening on the
                  same port, and for an IPv6 socket getting IPv4 traffic is then no longer predictable.

                <u>{keepalive,</u> <u>Boolean}</u>(TCP/IP sockets):
                  Enables/disables periodic transmission on a connected socket when no other data is  exchanged.
                  If the other end does not respond, the connection is considered broken and an error message is
                  sent to the controlling process. Defaults to <u>false</u>.

                <u>{linger,</u> <u>{true|false,</u> <u>Seconds}}</u>:
                  Determines the time-out, in seconds, for flushing unsent data in the <u>close/1</u> socket call.

                  The first component is if linger is enabled, the second component is the flushing time-out, in
                  seconds. There are 3 alternatives:

                  <u>{false,</u> <b>_</b><u>}</u>:
                    close/1  or shutdown/2 returns immediately, not waiting for data to be flushed, with closing
                    happening in the background.

                  <u>{true,</u> <u>0}</u>:
                    Aborts the connection when it is closed. Discards any  data  still  remaining  in  the  send
                    buffers and sends RST to the peer.

                    This   avoids   TCP's  TIME_WAIT  state,  but  leaves  open  the  possibility  that  another
                    "incarnation" of this connection being created.

                  <u>{true,</u> <u>Time}</u> <u>when</u> <u>Time</u> <u>&gt;</u> <u>0</u>:
                    close/1 or shutdown/2 will not return until all queued messages for  the  socket  have  been
                    successfully sent or the linger timeout (Time) has been reached.

                <u>{low_msgq_watermark,</u> <u>Size}</u>:
                  If  the socket message queue is in a busy state, the socket message queue is set in a not busy
                  state when the amount of data queued in the message queue falls below this limit. Notice  that
                  this   limit   only  concerns  data  that  has  not  yet  reached  the  ERTS  internal  socket
                  implementation. Defaults to 4 kB.

                  Senders that are suspended because of either a busy message queue or a busy socket are resumed
                  when the socket message queue and the socket are not busy.

                  For more information, see options <u>high_msgq_watermark</u>, <u>high_watermark</u>, and <u>low_watermark</u>.

                  Notice   that   distribution   sockets   disable   the   use   of   <u>high_msgq_watermark</u>    and
                  <u>low_msgq_watermark</u>.  Instead  they  use the distribution buffer busy limit, which is a similar
                  feature.

                <u>{low_watermark,</u> <u>Size}</u> (TCP/IP sockets):
                  If the socket is in a busy state, the socket is set in a not busy state  when  the  amount  of
                  data queued internally by the ERTS socket implementation falls below this limit. Defaults to 4
                  kB.

                  Senders  that  are suspended because of a busy message queue or a busy socket are resumed when
                  the socket message queue and the socket are not busy.

                  For more information, see options <u>high_watermark</u>, <u>high_msgq_watermark</u>, and <u>low_msgq_watermark</u>.

                <u>{mode,</u> <u>Mode</u> <u>::</u> <u>binary</u> <u>|</u> <u>list}</u>:
                  Received <u>Packet</u> is delivered as defined by <u>Mode</u>.

                <u>{netns,</u> <u>Namespace</u> <u>::</u> <u>file:filename_all()}</u>:
                  Sets a network namespace for the socket.  Parameter  <u>Namespace</u>  is  a  filename  defining  the
                  namespace,  for  example,  <u>"/var/run/netns/example"</u>, typically created by command <u>ip</u> <u>netns</u> <u>add</u>
                  <u>example</u>. This option must be used  in  a  function  call  that  creates  a  socket,  that  is,
                  <u>gen_tcp:connect/3,4</u>,  <u>gen_tcp:listen/2</u>,  <u>gen_udp:open/1,2</u>  or  <u>gen_sctp:open/0,1,2</u>,  and  also
                  <u>getifaddrs/1</u>.

                  This option uses the Linux-specific syscall <u>setns()</u>, such as in Linux kernel 3.0 or later, and
                  therefore only exists when the runtime system is compiled for such an operating system.

                  The virtual machine also needs elevated privileges, either running as superuser or (for Linux)
                  having capability <u>CAP_SYS_ADMIN</u> according to the documentation for <u><a href="../man2/setns.2.html">setns</a>(2)</u>.  However,  during
                  testing also <u>CAP_SYS_PTRACE</u> and <u>CAP_DAC_READ_SEARCH</u> have proven to be necessary.

                  <u>Example:</u>

                setcap cap_sys_admin,cap_sys_ptrace,cap_dac_read_search+epi beam.smp

                  Notice that the filesystem containing the virtual machine executable (<u>beam.smp</u> in the example)
                  must be local, mounted without flag <u>nosetuid</u>, support extended attributes, and the kernel must
                  support  file  capabilities. All this runs out of the box on at least Ubuntu 12.04 LTS, except
                  that SCTP sockets appear to not support network namespaces.

                  <u>Namespace</u> is a filename and is encoded and decoded as  discussed  in  module  file,  with  the
                  following exceptions:

                  * Emulator flag <u>+fnu</u> is ignored.

                  * <u>getopts/2</u> for this option returns a binary for the filename if the stored filename cannot be
                    decoded.  This  is only to occur if you set the option using a binary that cannot be decoded
                    with the emulator's filename encoding: <u>file:native_name_encoding/0</u>.

                <u>{bind_to_device,</u> <u>Ifname</u> <u>::</u> <u>binary()}</u>:
                  Binds a socket to a specific network interface. This option must be used in  a  function  call
                  that  creates  a  socket, that is, <u>gen_tcp:connect/3,4</u>, <u>gen_tcp:listen/2</u>, <u>gen_udp:open/1,2</u>, or
                  <u>gen_sctp:open/0,1,2</u>.

                  Unlike <u>getifaddrs/0</u>, Ifname is encoded a binary. In the unlikely case that a system  is  using
                  non-7-bit-ASCII characters in network device names, special care has to be taken when encoding
                  this argument.

                  This  option  uses  the  Linux-specific socket option <u>SO_BINDTODEVICE</u>, such as in Linux kernel
                  2.0.30 or later, and therefore only exists when the runtime system is  compiled  for  such  an
                  operating system.

                  Before  Linux  3.8,  this  socket option could be set, but could not retrieved with <u>getopts/2</u>.
                  Since Linux 3.8, it is readable.

                  The virtual machine also needs elevated privileges, either running as superuser or (for Linux)
                  having capability <u>CAP_NET_RAW</u>.

                  The primary use case for this option is to bind sockets into Linux VRF instances.

                <u>list</u>:
                  Received <u>Packet</u> is delivered as a list.

                <u>binary</u>:
                  Received <u>Packet</u> is delivered as a binary.

                <u>{nodelay,</u> <u>Boolean}</u>(TCP/IP sockets):
                  If <u>Boolean</u> <u>==</u> <u>true</u>, option <u>TCP_NODELAY</u> is turned on for the  socket,  which  means  that  also
                  small amounts of data are sent immediately.

                  This  option  is  <u>not</u>  supported for <u>domain</u> <u>=</u> <u>local</u>, but if <u>inet_backend</u> <u>=/=</u> <u>socket</u> this error
                  will be <u>ignored</u>.

                <u>{nopush,</u> <u>Boolean}</u>(TCP/IP sockets):
                  This translates to <u>TCP_NOPUSH</u> on BSD and to <u>TCP_CORK</u> on Linux.

                  If <u>Boolean</u> <u>==</u> <u>true</u>, the corresponding option is turned on for the  socket,  which  means  that
                  small  amounts  of  data  are  accumulated until a full MSS-worth of data is available or this
                  option is turned off.

                  Note that while <u>TCP_NOPUSH</u> socket option is available on OSX, its semantics is very  different
                  (e.g.,  unsetting  it does not cause immediate send of accumulated data). Hence, <u>nopush</u> option
                  is intentionally ignored on OSX.

                <u>{packet,</u> <u>PacketType}</u>(TCP/IP sockets):
                  Defines the type of packets to use for a socket. Possible values:

                  <u>raw</u> <u>|</u> <u>0</u>:
                    No packaging is done.

                  <u>1</u> <u>|</u> <u>2</u> <u>|</u> <u>4</u>:
                    Packets consist of a header specifying the number of bytes in the packet, followed  by  that
                    number  of  bytes.  The  header  length  can  be  one, two, or four bytes, and containing an
                    unsigned integer in big-endian byte order. Each send operation generates the header, and the
                    header is stripped off on each receive operation.

                    The 4-byte header is limited to 2Gb.

                  <u>asn1</u> <u>|</u> <u>cdr</u> <u>|</u> <u>sunrm</u> <u>|</u> <u>fcgi</u> <u>|</u> <u>tpkt</u> <u>|</u> <u>line</u>:
                    These packet types only have  effect  on  receiving.  When  sending  a  packet,  it  is  the
                    responsibility  of  the  application  to supply a correct header. On receiving, however, one
                    message is sent  to  the  controlling  process  for  each  complete  packet  received,  and,
                    similarly,  each  call  to  <u>gen_tcp:recv/2,3</u>  returns one complete packet. The header is <u>not</u>
                    stripped off.

                    The meanings of the packet types are as follows:

                    * <u>asn1</u> - ASN.1 BER

                    * <u>sunrm</u> - Sun's RPC encoding

                    * <u>cdr</u> - CORBA (GIOP 1.1)

                    * <u>fcgi</u> - Fast CGI

                    * <u>tpkt</u> - TPKT format [RFC1006]

                    * <u>line</u> - Line mode, a packet is a  line-terminated  with  newline,  lines  longer  than  the
                      receive buffer are truncated

                  <u>http</u> <u>|</u> <u>http_bin</u>:
                    The  Hypertext  Transfer  Protocol.  The  packets  are returned with the format according to
                    <u>HttpPacket</u> described in <u>erlang:decode_packet/3</u> in ERTS. A socket  in  passive  mode  returns
                    <u>{ok,</u> <u>HttpPacket}</u> from <u>gen_tcp:recv</u> while an active socket sends messages like <u>{http,</u> <u>Socket,</u>
                    <u>HttpPacket}</u>.

                  <u>httph</u> <u>|</u> <u>httph_bin</u>:
                    These   two  types  are  often  not  needed,  as  the  socket  automatically  switches  from
                    <u>http</u>/<u>http_bin</u> to <u>httph</u>/<u>httph_bin</u> internally after the first line is read. However, there can
                    be occasions when they are useful, such as parsing trailers from chunked encoding.

                <u>{packet_size,</u> <u>Integer}</u>(TCP/IP sockets):
                  Sets the maximum allowed length of the packet body. If the packet header  indicates  that  the
                  length  of  the  packet  is  longer  than the maximum allowed length, the packet is considered
                  invalid. The same occurs if the packet header is too large for the socket receive buffer.

                  For line-oriented protocols (<u>line</u>, <u>http*</u>), option <u>packet_size</u> also guarantees that lines up to
                  the indicated length are accepted and  not  considered  invalid  because  of  internal  buffer
                  limitations.

                <u>{line_delimiter,</u> <u>Char}</u>(TCP/IP sockets):
                  Sets the line delimiting character for line-oriented protocols (<u>line</u>). Defaults to <u>$\n</u>.

                <u>{raw,</u> <u>Protocol,</u> <u>OptionNum,</u> <u>ValueBin}</u>:
                  See below.

                <u>{read_packets,</u> <u>Integer}</u>(UDP sockets):
                  Sets  the maximum number of UDP packets to read without intervention from the socket when data
                  is available. When this many packets have been read and delivered to the destination  process,
                  new  packets  are not read until a new notification of available data has arrived. Defaults to
                  <u>5</u>. If this parameter is set too high, the system can become unresponsive because of UDP packet
                  flooding.

                <u>{recbuf,</u> <u>Size}</u>:
                  The minimum size of the receive buffer to use for  the  socket.  You  are  encouraged  to  use
                  <u>getopts/2</u> to retrieve the size set by your operating system.

                <u>{recvtclass,</u> <u>Boolean}</u>:
                  If  set to <u>true</u> activates returning the received <u>TCLASS</u> value on platforms that implements the
                  protocol <u>IPPROTO_IPV6</u> option <u>IPV6_RECVTCLASS</u> or <u>IPV6_2292RECVTCLASS</u> for the socket. The  value
                  is returned as a <u>{tclass,TCLASS}</u> tuple regardless of if the platform returns an <u>IPV6_TCLASS</u> or
                  an <u>IPV6_RECVTCLASS</u> CMSG value.

                  For  packet  oriented  sockets  that  supports  receiving ancillary data with the payload data
                  (<u>gen_udp</u> and <u>gen_sctp</u>), the <u>TCLASS</u> value is returned in an extended return tuple contained  in
                  an  ancillary data  list. For stream oriented sockets (<u>gen_tcp</u>) the only way to get the <u>TCLASS</u>
                  value is if the platform supports the <u>pktoptions</u> option.

                <u>{recvtos,</u> <u>Boolean}</u>:
                  If  set  to  <u>true</u>  activates returning the received <u>TOS</u> value on platforms that implements the
                  protocol <u>IPPROTO_IP</u> option <u>IP_RECVTOS</u> for the socket. The value is  returned  as  a  <u>{tos,TOS}</u>
                  tuple regardless of if the platform returns an <u>IP_TOS</u> or an <u>IP_RECVTOS</u> CMSG value.

                  For  packet  oriented  sockets  that  supports  receiving ancillary data with the payload data
                  (<u>gen_udp</u> and <u>gen_sctp</u>), the <u>TOS</u> value is returned in an extended return tuple contained in  an
                  ancillary  data  list. For stream oriented sockets (<u>gen_tcp</u>) the only way to get the <u>TOS</u> value
                  is if the platform supports the <u>pktoptions</u> option.

                <u>{recvttl,</u> <u>Boolean}</u>:
                  If set to <u>true</u> activates returning the received <u>TTL</u> value on  platforms  that  implements  the
                  protocol  <u>IPPROTO_IP</u>  option  <u>IP_RECVTTL</u>  for the socket. The value is returned as a <u>{ttl,TTL}</u>
                  tuple regardless of if the platform returns an <u>IP_TTL</u> or an <u>IP_RECVTTL</u> CMSG value.

                  For packet oriented sockets that supports receiving  ancillary  data  with  the  payload  data
                  (<u>gen_udp</u>  and <u>gen_sctp</u>), the <u>TTL</u> value is returned in an extended return tuple contained in an
                  ancillary data  list. For stream oriented sockets (<u>gen_tcp</u>) the only way to get the <u>TTL</u>  value
                  is if the platform supports the <u>pktoptions</u> option.

                <u>{reuseaddr,</u> <u>Boolean}</u>:
                  Allows or disallows local reuse of port numbers. By default, reuse is disallowed.

                <u>{send_timeout,</u> <u>Integer}</u>:
                  Only allowed for connection-oriented sockets.

                  Specifies  a  longest  time  to wait for a send operation to be accepted by the underlying TCP
                  stack. When the limit is exceeded, the send operation returns <u>{error,timeout}</u>. How much  of  a
                  packet  that got sent is unknown; the socket is therefore to be closed whenever a time-out has
                  occurred (see <u>send_timeout_close</u> below). Defaults to <u>infinity</u>.

                <u>{send_timeout_close,</u> <u>Boolean}</u>:
                  Only allowed for connection-oriented sockets.

                  Used together with <u>send_timeout</u> to specify whether the socket is to  be  automatically  closed
                  when  the  send  operation  returns  <u>{error,timeout}</u>.  The  recommended setting is <u>true</u>, which
                  automatically closes the socket. Defaults to <u>false</u> because of backward compatibility.

                <u>{show_econnreset,</u> <u>Boolean}</u> (TCP/IP sockets) :
                  When this option is set to <u>false</u>, which is default, an RST  received  from  the  TCP  peer  is
                  treated as a normal close (as though an FIN was sent). A caller to <u>gen_tcp:recv/2</u> gets <u>{error,</u>
                  <u>closed}</u>.  In  active  mode,  the  controlling process receives a <u>{tcp_closed,</u> <u>Socket}</u> message,
                  indicating that the peer has closed the connection.

                  Setting this option to <u>true</u> allows you to distinguish between a  connection  that  was  closed
                  normally,  and one that was aborted (intentionally or unintentionally) by the TCP peer. A call
                  to <u>gen_tcp:recv/2</u> returns  <u>{error,</u>  <u>econnreset}</u>.  In  active  mode,  the  controlling  process
                  receives  a  <u>{tcp_error,</u> <u>Socket,</u> <u>econnreset}</u> message before the usual <u>{tcp_closed,</u> <u>Socket}</u>, as
                  is the case for  any  other  socket  error.  Calls  to  <u>gen_tcp:send/2</u>  also  returns  <u>{error,</u>
                  <u>econnreset}</u> when it is detected that a TCP peer has sent an RST.

                  A  connected  socket  returned from <u>gen_tcp:accept/1</u> inherits the <u>show_econnreset</u> setting from
                  the listening socket.

                <u>{sndbuf,</u> <u>Size}</u>:
                  The minimum size of the send buffer  to  use  for  the  socket.  You  are  encouraged  to  use
                  <u>getopts/2</u>, to retrieve the size set by your operating system.

                <u>{priority,</u> <u>Integer}</u>:
                  Sets  the <u>SO_PRIORITY</u> socket level option on platforms where this is implemented. The behavior
                  and allowed range varies between different systems. The option is ignored on  platforms  where
                  it is not implemented. Use with caution.

                <u>{tos,</u> <u>Integer}</u>:
                  Sets  <u>IP_TOS</u> <u>IP</u> level options on platforms where this is implemented. The behavior and allowed
                  range varies between different systems. The option is ignored on platforms  where  it  is  not
                  implemented. Use with caution.

                <u>{tclass,</u> <u>Integer}</u>:
                  Sets  <u>IPV6_TCLASS</u>  <u>IP</u>  level  options on platforms where this is implemented. The behavior and
                  allowed range varies between different systems. The option is ignored on platforms where it is
                  not implemented. Use with caution.

              In addition to these options, <u>raw</u> option specifications can be used. The raw options are specified
              as a tuple of arity four, beginning with tag <u>raw</u>, followed  by  the  protocol  level,  the  option
              number,  and  the  option  value specified as a binary. This corresponds to the second, third, and
              fourth arguments to the <u>setsockopt</u> call in the C socket API. The option value must be coded in the
              native endianess of the platform and, if a  structure  is  required,  must  follow  the  structure
              alignment conventions on the specific platform.

              Using  raw  socket  options requires detailed knowledge about the current operating system and TCP
              stack.

              <u>Example:</u>

              This example concerns the use of raw options. Consider a Linux system where you want to set option
              <u>TCP_LINGER2</u> on protocol level <u>IPPROTO_TCP</u> in the stack. You know that on this particular system it
              defaults to 60 (seconds), but you want  to  lower  it  to  30  for  a  particular  socket.  Option
              <u>TCP_LINGER2</u>  is  not explicitly supported by <u>inet</u>, but you know that the protocol level translates
              to number 6, the option number to number 8, and the value is to be specified as a 32-bit  integer.
              You can use this code line to set the option for the socket named <u>Sock</u>:

              inet:setopts(Sock,[{raw,6,8,&lt;&lt;30:32/native&gt;&gt;}]),

              As  many options are silently discarded by the stack if they are specified out of range; it can be
              a good idea to check that a raw option is  accepted.  The  following  code  places  the  value  in
              variable <u>TcpLinger2:</u>

              {ok,[{raw,6,8,&lt;&lt;TcpLinger2:32/native&gt;&gt;}]}=inet:getopts(Sock,[{raw,6,8,4}]),

              Code  such as these examples is inherently non-portable, even different versions of the same OS on
              the same platform can respond differently to this kind of option manipulation. Use with care.

              Notice that the default options for TCP/IP sockets can be changed with  the  Kernel  configuration
              parameters mentioned in the beginning of this manual page.

       <b>sockname(Socket</b> <b>::</b> <b>socket())</b> <b>-&gt;</b>
                   {ok,
                    {ip_address(), port_number()} |
                    returned_non_ip_address()} |
                   {error, posix()}

              Returns the local address and port number for a socket.

              Notice  that  for  SCTP  sockets  this function returns only one of the socket addresses. Function
              <u>socknames/1,2</u> returns all.

       <b>socknames(Socket</b> <b>::</b> <b>socket())</b> <b>-&gt;</b>
                    {ok,
                     [{ip_address(), port_number()} |
                      returned_non_ip_address()]} |
                    {error, posix()}

              Equivalent to <u>socknames(Socket,</u> <u>0)</u>.

       <b>socknames(Socket,</b> <b>Assoc)</b> <b>-&gt;</b>
                    {ok, [{Address, Port}]} | {error, posix()}

              Types:

                 Socket = socket()
                 Assoc = #sctp_assoc_change{} | gen_sctp:assoc_id()
                 Address = ip_address()
                 Port = integer() &gt;= 0

              Returns a list of all local address/port number pairs for a socket for the  specified  association
              <u>Assoc</u>.

              This  function  can  return  multiple  addresses for multihomed sockets, such as SCTP sockets. For
              other sockets it returns a one-element list.

              Notice that parameter <u>Assoc</u> is by the SCTP Sockets API Extensions defined to be ignored  for  one-
              to-one  style  sockets. For one-to-many style sockets, the special value <u>0</u> is defined to mean that
              the  returned  addresses  must  be  without  any  particular  association.  How   different   SCTP
              implementations interpret this varies somewhat.

</pre><h4><b>POSIX</b> <b>ERROR</b> <b>CODES</b></h4><pre>
         * <u>e2big</u> - Too long argument list

         * <u>eacces</u> - Permission denied

         * <u>eaddrinuse</u> - Address already in use

         * <u>eaddrnotavail</u> - Cannot assign requested address

         * <u>eadv</u> - Advertise error

         * <u>eafnosupport</u> - Address family not supported by protocol family

         * <u>eagain</u> - Resource temporarily unavailable

         * <u>ealign</u> - EALIGN

         * <u>ealready</u> - Operation already in progress

         * <u>ebade</u> - Bad exchange descriptor

         * <u>ebadf</u> - Bad file number

         * <u>ebadfd</u> - File descriptor in bad state

         * <u>ebadmsg</u> - Not a data message

         * <u>ebadr</u> - Bad request descriptor

         * <u>ebadrpc</u> - Bad RPC structure

         * <u>ebadrqc</u> - Bad request code

         * <u>ebadslt</u> - Invalid slot

         * <u>ebfont</u> - Bad font file format

         * <u>ebusy</u> - File busy

         * <u>echild</u> - No children

         * <u>echrng</u> - Channel number out of range

         * <u>ecomm</u> - Communication error on send

         * <u>econnaborted</u> - Software caused connection abort

         * <u>econnrefused</u> - Connection refused

         * <u>econnreset</u> - Connection reset by peer

         * <u>edeadlk</u> - Resource deadlock avoided

         * <u>edeadlock</u> - Resource deadlock avoided

         * <u>edestaddrreq</u> - Destination address required

         * <u>edirty</u> - Mounting a dirty fs without force

         * <u>edom</u> - Math argument out of range

         * <u>edotdot</u> - Cross mount point

         * <u>edquot</u> - Disk quota exceeded

         * <u>eduppkg</u> - Duplicate package name

         * <u>eexist</u> - File already exists

         * <u>efault</u> - Bad address in system call argument

         * <u>efbig</u> - File too large

         * <u>ehostdown</u> - Host is down

         * <u>ehostunreach</u> - Host is unreachable

         * <u>eidrm</u> - Identifier removed

         * <u>einit</u> - Initialization error

         * <u>einprogress</u> - Operation now in progress

         * <u>eintr</u> - Interrupted system call

         * <u>einval</u> - Invalid argument

         * <u>eio</u> - I/O error

         * <u>eisconn</u> - Socket is already connected

         * <u>eisdir</u> - Illegal operation on a directory

         * <u>eisnam</u> - Is a named file

         * <u>el2hlt</u> - Level 2 halted

         * <u>el2nsync</u> - Level 2 not synchronized

         * <u>el3hlt</u> - Level 3 halted

         * <u>el3rst</u> - Level 3 reset

         * <u>elbin</u> - ELBIN

         * <u>elibacc</u> - Cannot access a needed shared library

         * <u>elibbad</u> - Accessing a corrupted shared library

         * <u>elibexec</u> - Cannot exec a shared library directly

         * <u>elibmax</u> - Attempting to link in more shared libraries than system limit

         * <u>elibscn</u> - <u>.lib</u> section in <u>a.out</u> corrupted

         * <u>elnrng</u> - Link number out of range

         * <u>eloop</u> - Too many levels of symbolic links

         * <u>emfile</u> - Too many open files

         * <u>emlink</u> - Too many links

         * <u>emsgsize</u> - Message too long

         * <u>emultihop</u> - Multihop attempted

         * <u>enametoolong</u> - Filename too long

         * <u>enavail</u> - Unavailable

         * <u>enet</u> - ENET

         * <u>enetdown</u> - Network is down

         * <u>enetreset</u> - Network dropped connection on reset

         * <u>enetunreach</u> - Network is unreachable

         * <u>enfile</u> - File table overflow

         * <u>enoano</u> - Anode table overflow

         * <u>enobufs</u> - No buffer space available

         * <u>enocsi</u> - No CSI structure available

         * <u>enodata</u> - No data available

         * <u>enodev</u> - No such device

         * <u>enoent</u> - No such file or directory

         * <u>enoexec</u> - Exec format error

         * <u>enolck</u> - No locks available

         * <u>enolink</u> - Link has been severed

         * <u>enomem</u> - Not enough memory

         * <u>enomsg</u> - No message of desired type

         * <u>enonet</u> - Machine is not on the network

         * <u>enopkg</u> - Package not installed

         * <u>enoprotoopt</u> - Bad protocol option

         * <u>enospc</u> - No space left on device

         * <u>enosr</u> - Out of stream resources or not a stream device

         * <u>enosym</u> - Unresolved symbol name

         * <u>enosys</u> - Function not implemented

         * <u>enotblk</u> - Block device required

         * <u>enotconn</u> - Socket is not connected

         * <u>enotdir</u> - Not a directory

         * <u>enotempty</u> - Directory not empty

         * <u>enotnam</u> - Not a named file

         * <u>enotsock</u> - Socket operation on non-socket

         * <u>enotsup</u> - Operation not supported

         * <u>enotty</u> - Inappropriate device for <u>ioctl</u>

         * <u>enotuniq</u> - Name not unique on network

         * <u>enxio</u> - No such device or address

         * <u>eopnotsupp</u> - Operation not supported on socket

         * <u>eperm</u> - Not owner

         * <u>epfnosupport</u> - Protocol family not supported

         * <u>epipe</u> - Broken pipe

         * <u>eproclim</u> - Too many processes

         * <u>eprocunavail</u> - Bad procedure for program

         * <u>eprogmismatch</u> - Wrong program version

         * <u>eprogunavail</u> - RPC program unavailable

         * <u>eproto</u> - Protocol error

         * <u>eprotonosupport</u> - Protocol not supported

         * <u>eprototype</u> - Wrong protocol type for socket

         * <u>erange</u> - Math result unrepresentable

         * <u>erefused</u> - EREFUSED

         * <u>eremchg</u> - Remote address changed

         * <u>eremdev</u> - Remote device

         * <u>eremote</u> - Pathname hit remote filesystem

         * <u>eremoteio</u> - Remote I/O error

         * <u>eremoterelease</u> - EREMOTERELEASE

         * <u>erofs</u> - Read-only filesystem

         * <u>erpcmismatch</u> - Wrong RPC version

         * <u>erremote</u> - Object is remote

         * <u>eshutdown</u> - Cannot send after socket shutdown

         * <u>esocktnosupport</u> - Socket type not supported

         * <u>espipe</u> - Invalid seek

         * <u>esrch</u> - No such process

         * <u>esrmnt</u> - Srmount error

         * <u>estale</u> - Stale remote file handle

         * <u>esuccess</u> - Error 0

         * <u>etime</u> - Timer expired

         * <u>etimedout</u> - Connection timed out

         * <u>etoomanyrefs</u> - Too many references

         * <u>etxtbsy</u> - Text file or pseudo-device busy

         * <u>euclean</u> - Structure needs cleaning

         * <u>eunatch</u> - Protocol driver not attached

         * <u>eusers</u> - Too many users

         * <u>eversion</u> - Version mismatch

         * <u>ewouldblock</u> - Operation would block

         * <u>exdev</u> - Cross-domain link

         * <u>exfull</u> - Message tables full

         * <u>nxdomain</u> - Hostname or domain name cannot be found

Ericsson AB                                        kernel 8.2                                         <u><a href="../man3erl/inet.3erl.html">inet</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>