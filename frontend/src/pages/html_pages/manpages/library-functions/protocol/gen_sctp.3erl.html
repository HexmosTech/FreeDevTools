<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gen_sctp - Functions for communicating with sockets using the SCTP</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gen_sctp - Functions for communicating with sockets using the SCTP
           protocol.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides functions for communicating with sockets using the SCTP protocol. The implementation
       assumes that the OS kernel supports SCTP (RFC 2960) through the user-level Sockets API Extensions.

       During development, this implementation was tested on:

         * Linux Fedora Core 5.0 (kernel 2.6.15-2054 or later is needed)

         * Solaris 10, 11

       During OTP adaptation it was tested on:

         * SUSE Linux Enterprise Server 10 (x86_64) kernel 2.6.16.27-0.6-smp, with lksctp-tools-1.0.6

         * Briefly on Solaris 10

         * SUSE  Linux  Enterprise  Server  10  Service  Pack 1 (x86_64) kernel 2.6.16.54-0.2.3-smp with lksctp-
           tools-1.0.7

         * FreeBSD 8.2

       This module was written for one-to-many style sockets (type <u>seqpacket</u>). With the addition  of  <u>peeloff/2</u>,
       one-to-one style sockets (type <u>stream</u>) were introduced.

       Record definitions for this module can be found using:

       -include_lib("kernel/include/inet_sctp.hrl").

       These  record  definitions use the "new" spelling 'adaptation', not the deprecated 'adaption', regardless
       of which spelling the underlying C API uses.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>assoc_id()</b>

              An opaque term returned in, for example, <u>#sctp_paddr_change{}</u>, which identifies an association for
              an SCTP socket. The term is opaque except for the special value <u>0</u>, which has  a  meaning  such  as
              "the whole endpoint" or "all future associations".

       <b>option()</b> =
           {active, true | false | once | -32768..32767} |
           {buffer, integer() &gt;= 0} |
           {dontroute, boolean()} |
           {high_msgq_watermark, integer() &gt;= 1} |
           {linger, {boolean(), integer() &gt;= 0}} |
           {low_msgq_watermark, integer() &gt;= 1} |
           {mode, list | binary} |
           list | binary |
           {priority, integer() &gt;= 0} |
           {recbuf, integer() &gt;= 0} |
           {reuseaddr, boolean()} |
           {ipv6_v6only, boolean()} |
           {sctp_adaptation_layer, #sctp_setadaptation{}} |
           {sctp_associnfo, #sctp_assocparams{}} |
           {sctp_autoclose, integer() &gt;= 0} |
           {sctp_default_send_param, #sctp_sndrcvinfo{}} |
           {sctp_delayed_ack_time, #sctp_assoc_value{}} |
           {sctp_disable_fragments, boolean()} |
           {sctp_events, #sctp_event_subscribe{}} |
           {sctp_get_peer_addr_info, #sctp_paddrinfo{}} |
           {sctp_i_want_mapped_v4_addr, boolean()} |
           {sctp_initmsg, #sctp_initmsg{}} |
           {sctp_maxseg, integer() &gt;= 0} |
           {sctp_nodelay, boolean()} |
           {sctp_peer_addr_params, #sctp_paddrparams{}} |
           {sctp_primary_addr, #sctp_prim{}} |
           {sctp_rtoinfo, #sctp_rtoinfo{}} |
           {sctp_set_peer_primary_addr, #sctp_setpeerprim{}} |
           {sctp_status, #sctp_status{}} |
           {sndbuf, integer() &gt;= 0} |
           {tos, integer() &gt;= 0} |
           {tclass, integer() &gt;= 0} |
           {ttl, integer() &gt;= 0} |
           {recvtos, boolean()} |
           {recvtclass, boolean()} |
           {recvttl, boolean()}

              One of the SCTP Socket Options.

       <b>option_name()</b> =
           active | buffer | dontroute | high_msgq_watermark | linger |
           low_msgq_watermark | mode | priority | recbuf | reuseaddr |
           ipv6_v6only | sctp_adaptation_layer | sctp_associnfo |
           sctp_autoclose | sctp_default_send_param |
           sctp_delayed_ack_time | sctp_disable_fragments | sctp_events |
           sctp_get_peer_addr_info | sctp_i_want_mapped_v4_addr |
           sctp_initmsg | sctp_maxseg | sctp_nodelay |
           sctp_peer_addr_params | sctp_primary_addr | sctp_rtoinfo |
           sctp_set_peer_primary_addr | sctp_status | sndbuf | tos |
           tclass | ttl | recvtos | recvtclass | recvttl

       <b>sctp_socket()</b>

              Socket identifier returned from <u>open/*</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>abort(Socket,</b> <b>Assoc)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>inet:posix()}</b>

              Types:

                 Socket = sctp_socket()
                 Assoc = #sctp_assoc_change{}

              Abnormally  terminates  the  association  specified by <u>Assoc</u>, without flushing of unsent data. The
              socket itself remains open. Other associations opened on this socket  are  still  valid,  and  the
              socket can be used in new associations.

       <b>close(Socket)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>inet:posix()}</b>

              Types:

                 Socket = sctp_socket()

              Closes  the socket and all associations on it. The unsent data is flushed as in <u>eof/2</u>. The <u>close/1</u>
              call is blocking or otherwise depending of the value of the <u>linger</u> socket option.  If  <u>close</u>  does
              not linger or linger time-out expires, the call returns and the data is flushed in the background.

       <b>connect(Socket,</b> <b>Addr,</b> <b>Port,</b> <b>Opts)</b> <b>-&gt;</b>
                  {ok, #sctp_assoc_change{state = comm_up}} |
                  {error, #sctp_assoc_change{state = cant_assoc}} |
                  {error, inet:posix()}

              Types:

                 Socket = sctp_socket()
                 Addr = inet:ip_address() | inet:hostname()
                 Port = inet:port_number()
                 Opts = [Opt :: option()]

              Same as <u>connect(Socket,</u> <u>Addr,</u> <u>Port,</u> <u>Opts,</u> <u>infinity)</u>.

       <b>connect(Socket,</b> <b>Addr,</b> <b>Port,</b> <b>Opts,</b> <b>Timeout)</b> <b>-&gt;</b>
                  {ok, #sctp_assoc_change{state = comm_up}} |
                  {error, #sctp_assoc_change{state = cant_assoc}} |
                  {error, inet:posix()}

              Types:

                 Socket = sctp_socket()
                 Addr = inet:ip_address() | inet:hostname()
                 Port = inet:port_number()
                 Opts = [Opt :: option()]
                 Timeout = timeout()

              Establishes  a  new association for socket <u>Socket</u>, with the peer (SCTP server socket) specified by
              <u>Addr</u> and <u>Port</u>. <u>Timeout</u>, is expressed in milliseconds. A socket can  be  associated  with  multiple
              peers.

          <b>Warning:</b>
              Using  a  value  of <u>Timeout</u> less than the maximum time taken by the OS to establish an association
              (around 4.5 minutes if the default values from RFC 4960 are used), can result in  inconsistent  or
              incorrect  return  values.  This  is  especially relevant for associations sharing the same <u>Socket</u>
              (that is, source address and port), as the controlling process  blocks  until  <u>connect/*</u>  returns.
              <u>connect_init/*</u> provides an alternative without this limitation.

              The  result  of  <u>connect/*</u>  is an <u>#sctp_assoc_change{}</u> event that contains, in particular, the new
              Association ID:

              #sctp_assoc_change{
                    state             = atom(),
                    error             = integer(),
                    outbound_streams  = integer(),
                    inbound_streams   = integer(),
                    assoc_id          = assoc_id()
              }

              The number of outbound and inbound streams can be set by giving an <u>sctp_initmsg</u> option to  <u>connect</u>
              as in:

              connect(Socket, Ip, Port&gt;,
                    [{sctp_initmsg,#sctp_initmsg{num_ostreams=OutStreams,
                                                 max_instreams=MaxInStreams}}])

              All options <u>Opt</u> are set on the socket before the association is attempted. If an option record has
              undefined  field  values,  the  options  record is first read from the socket for those values. In
              effect, <u>Opt</u> option records only define field values to change before connecting.

              The returned <u>outbound_streams</u> and <u>inbound_streams</u> are the stream numbers on the socket. These  can
              be  different  from  the  requested values (<u>OutStreams</u> and <u>MaxInStreams</u>, respectively) if the peer
              requires lower values.

              <u>state</u> can have the following values:

                <u>comm_up</u>:
                  Association is successfully established. This indicates a successful completion of <u>connect</u>.

                <u>cant_assoc</u>:
                  The association cannot be established (<u>connect/*</u> failure).

              Other states do not normally occur in the  output  from  <u>connect/*</u>.  Rather,  they  can  occur  in
              <u>#sctp_assoc_change{}</u>  events received instead of data in <u>recv/*</u> calls. All of them indicate losing
              the association because of various  error  conditions,  and  are  listed  here  for  the  sake  of
              completeness:

                <u>comm_lost</u>:

                <u>restart</u>:

                <u>shutdown_comp</u>:

              Field  <u>error</u>  can provide more detailed diagnostics. The <u>error</u> field value can be converted into a
              string using <u>error_string/1</u>.

       <b>connect_init(Socket,</b> <b>Addr,</b> <b>Port,</b> <b>Opts)</b> <b>-&gt;</b>
                       ok | {error, inet:posix()}

              Types:

                 Socket = sctp_socket()
                 Addr = inet:ip_address() | inet:hostname()
                 Port = inet:port_number()
                 Opts = [option()]

              Same as <u>connect_init(Socket,</u> <u>Addr,</u> <u>Port,</u> <u>Opts,</u> <u>infinity)</u>.

       <b>connect_init(Socket,</b> <b>Addr,</b> <b>Port,</b> <b>Opts,</b> <b>Timeout)</b> <b>-&gt;</b>
                       ok | {error, inet:posix()}

              Types:

                 Socket = sctp_socket()
                 Addr = inet:ip_address() | inet:hostname()
                 Port = inet:port_number()
                 Opts = [option()]
                 Timeout = timeout()

              Initiates a new association for socket <u>Socket</u>, with the peer (SCTP  server  socket)  specified  by
              <u>Addr</u> and <u>Port</u>.

              The  fundamental difference between this API and <u>connect/*</u> is that the return value is that of the
              underlying OS  <u><a href="../man2/connect.2.html">connect</a>(2)</u>  system  call.  If  <u>ok</u>  is  returned,  the  result  of  the  association
              establishment  is  received  by  the calling process as an <u>#sctp_assoc_change{}</u> event. The calling
              process must be prepared to receive this, or poll for it using <u>recv/*</u>, depending on the  value  of
              the active option.

              The parameters are as described in <u>connect/*</u>, except the <u>Timeout</u> value.

              The timer associated with <u>Timeout</u> only supervises IP resolution of <u>Addr</u>.

       <b>controlling_process(Socket,</b> <b>Pid)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Socket = sctp_socket()
                 Pid = pid()
                 Reason = closed | not_owner | badarg | inet:posix()

              Assigns    a    new    controlling    process    <u>Pid</u>    to    <u>Socket</u>.   Same   implementation   as
              <u>gen_udp:controlling_process/2</u>.

       <b>eof(Socket,</b> <b>Assoc)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Socket = sctp_socket()
                 Assoc = #sctp_assoc_change{}
                 Reason = term()

              Gracefully terminates the association specified by <u>Assoc</u>, with flushing of all  unsent  data.  The
              socket  itself  remains open. Other associations opened on this socket are still valid. The socket
              can be used in new associations.

       <b>error_string(ErrorNumber)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>string()</b> <b>|</b> <b>unknown_error</b>

              Types:

                 ErrorNumber = integer()

              Translates an SCTP error number from, for  example,  <u>#sctp_remote_error{}</u>  or  <u>#sctp_send_failed{}</u>
              into  an  explanatory string, or one of the atoms <u>ok</u> for no error or <u>undefined</u> for an unrecognized
              error.

       <b>listen(Socket,</b> <b>IsServer)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>listen(Socket,</b> <b>Backlog)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Socket = sctp_socket()
                 Backlog = integer()
                 Reason = term()

              Sets up a socket to listen on the IP address and port number it is bound to.

              For type <u>seqpacket</u>, sockets (the default) <u>IsServer</u> must be <u>true</u> or  <u>false</u>.  In  contrast  to  TCP,
              there  is  no  listening  queue  length  in  SCTP.  If  <u>IsServer</u>  is  <u>true</u>, the socket accepts new
              associations, that is, it becomes an SCTP server socket.

              For type <u>stream</u>, sockets Backlog define the backlog queue length just like in TCP.

       <b>open()</b> <b>-&gt;</b> <b>{ok,</b> <b>Socket}</b> <b>|</b> <b>{error,</b> <b>inet:posix()}</b>

       <b>open(Port)</b> <b>-&gt;</b> <b>{ok,</b> <b>Socket}</b> <b>|</b> <b>{error,</b> <b>inet:posix()}</b>

       <b>open(Opts)</b> <b>-&gt;</b> <b>{ok,</b> <b>Socket}</b> <b>|</b> <b>{error,</b> <b>inet:posix()}</b>

       <b>open(Port,</b> <b>Opts)</b> <b>-&gt;</b> <b>{ok,</b> <b>Socket}</b> <b>|</b> <b>{error,</b> <b>inet:posix()}</b>

              Types:

                 Opts = [Opt]
                 Opt =
                     {ip, IP} |
                     {ifaddr, IP} |
                     inet:address_family() |
                     {port, Port} |
                     {type, SockType} |
                     option()
                 IP = inet:ip_address() | any | loopback
                 Port = inet:port_number()
                 SockType = seqpacket | stream
                 Socket = sctp_socket()

              Creates an SCTP socket and  binds  it  to  the  local  addresses  specified  by  all  <u>{ip,IP}</u>  (or
              synonymously  <u>{ifaddr,IP}</u>)  options (this feature is called SCTP multi-homing). The default <u>IP</u> and
              <u>Port</u> are <u>any</u> and <u>0</u>, meaning bind to all local addresses on any free port.

              Other options:

                <u>inet6</u>:
                  Sets up the socket for IPv6.

                <u>inet</u>:
                  Sets up the socket for IPv4. This is the default.

              A default set of socket options is used. In particular, the socket is opened in binary and passive
              mode, with SockType <u>seqpacket</u>, and with reasonably large kernel and driver buffers.

              If the socket is in passive mode data can be received through the <u>recv/1,2</u> calls.

              If the socket is in active mode data received data is delivered  to  the  controlling  process  as
              messages:

              {sctp, Socket, FromIP, FromPort, {AncData, Data}}

              See <u>recv/1,2</u> for a description of the message fields.

          <b>Note:</b>
              This  message format unfortunately differs slightly from the <u>gen_udp</u> message format with ancillary
              data, and from the <u>recv/1,2</u> return tuple format.

       <b>peeloff(Socket,</b> <b>Assoc)</b> <b>-&gt;</b> <b>{ok,</b> <b>NewSocket}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Socket = sctp_socket()
                 Assoc = #sctp_assoc_change{} | assoc_id()
                 NewSocket = sctp_socket()
                 Reason = term()

              Branches off an existing association <u>Assoc</u> in a  socket  <u>Socket</u>  of  type  <u>seqpacket</u>  (one-to-many
              style) into a new socket <u>NewSocket</u> of type <u>stream</u> (one-to-one style).

              The  existing  association  argument <u>Assoc</u> can be either a <u>#sctp_assoc_change{}</u> record as returned
              from, for example, <u>recv/*</u>, <u>connect/*</u>, or from a listening socket in active mode. It  can  also  be
              just the field <u>assoc_id</u> integer from such a record.

       <b>recv(Socket)</b> <b>-&gt;</b>
               {ok, {FromIP, FromPort, AncData, Data}} | {error, Reason}

       <b>recv(Socket,</b> <b>Timeout)</b> <b>-&gt;</b>
               {ok, {FromIP, FromPort, AncData, Data}} | {error, Reason}

              Types:

                 Socket = sctp_socket()
                 Timeout = timeout()
                 FromIP = inet:ip_address()
                 FromPort = inet:port_number()
                 AncData = [#sctp_sndrcvinfo{} | inet:ancillary_data()]
                 Data =
                     binary() |
                     string() |
                     #sctp_sndrcvinfo{} |
                     #sctp_assoc_change{} |
                     #sctp_paddr_change{} |
                     #sctp_adaptation_event{}
                 Reason =
                     inet:posix() |
                     #sctp_send_failed{} |
                     #sctp_paddr_change{} |
                     #sctp_pdapi_event{} |
                     #sctp_remote_error{} |
                     #sctp_shutdown_event{}

              Receives  the  <u>Data</u>  message  from  any  association  of  the  socket.  If  the receive times out,
              <u>{error,timeout}</u> is returned. The default time-out is <u>infinity</u>. <u>FromIP</u> and  <u>FromPort</u>  indicate  the
              address of the sender.

              <u>AncData</u> is a list of ancillary data items that can be received along with the main <u>Data</u>. This list
              can be empty, or contain a single <u>#sctp_sndrcvinfo{}</u> record if receiving of such ancillary data is
              enabled  (see  option  <u>sctp_events</u>).  It is enabled by default, as such ancillary data provides an
              easy way of determining the association and  stream  over  which  the  message  is  received.  (An
              alternative  way  is  to  get  the  association  ID  from  <u>FromIP</u> and <u>FromPort</u> using socket option
              <u>sctp_get_peer_addr_info</u>, but this does still not produce the stream number).

              <u>AncData</u> may also contain  ancillary data  from the socket options <u>recvtos</u>, <u>recvtclass</u> or  <u>recvttl</u>,
              if that is supported by the platform for the socket.

              The  <u>Data</u>  received  can  be a <u>binary()</u> or a <u>list()</u> of bytes (integers in the range 0 through 255)
              depending on the socket mode, or an SCTP event.

              Possible SCTP events:

                * <u>#sctp_sndrcvinfo{}</u>

                * <u>#sctp_assoc_change{}</u>

                *

                #sctp_paddr_change{
                      addr      = {ip_address(),port()},
                      state     = atom(),
                      error     = integer(),
                      assoc_id  = assoc_id()
                }

                  Indicates change of the status of the  IP  address  of  the  peer  specified  by  <u>addr</u>  within
                  association <u>assoc_id</u>. Possible values of <u>state</u> (mostly self-explanatory) include:

                  <u>addr_unreachable</u>:

                  <u>addr_available</u>:

                  <u>addr_removed</u>:

                  <u>addr_added</u>:

                  <u>addr_made_prim</u>:

                  <u>addr_confirmed</u>:

                  In case of an error (for example, <u>addr_unreachable</u>), field <u>error</u> provides more diagnostics. In
                  such  cases, event <u>#sctp_paddr_change{}</u> is automatically converted into an <u>error</u> term returned
                  by <u>recv</u>. The <u>error</u> field value can be converted into a string using <u>error_string/1</u>.

                *

                #sctp_send_failed{
                      flags     = true | false,
                      error     = integer(),
                      info      = #sctp_sndrcvinfo{},
                      assoc_id  = assoc_id()
                      data      = binary()
                }

                  The sender can receive this event if a send operation fails.

                  <u>flags</u>:
                    A Boolean specifying if the data has been transmitted over the wire.

                  <u>error</u>:
                    Provides extended diagnostics, use <u>error_string/1</u>.

                  <u>info</u>:
                    The original <u>#sctp_sndrcvinfo{}</u> record used in the failed <u>send/*</u>.

                  <u>data</u>:
                    The whole original data chunk attempted to be sent.

                  In the current implementation of the Erlang/SCTP binding, this event is  internally  converted
                  into an <u>error</u> term returned by <u>recv/*</u>.

                *

                #sctp_adaptation_event{
                      adaptation_ind = integer(),
                      assoc_id       = assoc_id()
                }

                  Delivered  when  a  peer  sends  an  adaptation layer indication parameter (configured through
                  option <u>sctp_adaptation_layer</u>). Notice that with the current implementation of the  Erlang/SCTP
                  binding, this event is disabled by default.

                *

                #sctp_pdapi_event{
                      indication = sctp_partial_delivery_aborted,
                      assoc_id   = assoc_id()
                }

                  A  partial  delivery  failure.  In the current implementation of the Erlang/SCTP binding, this
                  event is internally converted into an <u>error</u> term returned by <u>recv/*</u>.

       <b>send(Socket,</b> <b>SndRcvInfo,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Socket = sctp_socket()
                 SndRcvInfo = #sctp_sndrcvinfo{}
                 Data = binary() | iolist()
                 Reason = term()

              Sends the <u>Data</u> message with all sending parameters from a <u>#sctp_sndrcvinfo{}</u> record. This way, the
              user can specify the PPID (passed to the remote end) and context (passed to the local SCTP layer),
              which can be used, for example, for error identification. However,  such  a  fine  level  of  user
              control is rarely required. The function <u>send/4</u> is sufficient for most applications.

       <b>send(Socket,</b> <b>Assoc,</b> <b>Stream,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Socket = sctp_socket()
                 Assoc = #sctp_assoc_change{} | assoc_id()
                 Stream = integer()
                 Data = binary() | iolist()
                 Reason = term()

              Sends a <u>Data</u> message over an existing association and specified stream.

</pre><h4><b>SCTP</b> <b>SOCKET</b> <b>OPTIONS</b></h4><pre>
       The  set  of  admissible  SCTP  socket options is by construction orthogonal to the sets of TCP, UDP, and
       generic <u>inet</u> options. Only options listed here are allowed for SCTP sockets. Options can be  set  on  the
       socket  using  <u>open/1,2</u>  or  <u>inet:setopts/2</u>,  retrieved using <u>inet:getopts/2</u>. Options can be changed when
       calling <u>connect/4,5</u>.

         <u>{mode,</u> <u>list|binary}</u> or just <u>list</u> or <u>binary</u>:
           Determines the type of data returned from <u>recv/1,2</u>.

         <u>{active,</u> <u>true|false|once|N}</u>:

           * If <u>false</u> (passive mode, the default), the caller must do an explicit  <u>recv</u>  call  to  retrieve  the
             available data from the socket.

           * If <u>true|once|N</u> (active modes) received data or events are sent to the owning process. See <u>open/0..2</u>
             for the message format.

           * If <u>true</u> (full active mode) there is no flow control.

       <b>Note:</b>
           Note that this can cause the message queue to overflow causing for example the virtual machine to run
           out of memory and crash.

           * If  <u>once</u>, only one message is automatically placed in the message queue, and after that the mode is
             automatically reset to passive. This provides flow control and the possibility for the receiver  to
             listen for its incoming SCTP data interleaved with other inter-process messages.

           * If  <u>active</u>  is  specified  as an integer <u>N</u> in the range -32768 to 32767 (inclusive), that number is
             added to the socket's counting of data messages to be delivered to the controlling process. If  the
             result of the addition is negative, the count is set to <u>0</u>. Once the count reaches <u>0</u>, either through
             the  delivery  of  messages  or  by  being  explicitly  set with <u>inet:setopts/2</u>, the socket mode is
             automatically reset to passive (<u>{active,</u> <u>false}</u>). When a socket in this active mode transitions  to
             passive  mode,  the  message <u>{sctp_passive,</u> <u>Socket}</u> is sent to the controlling process to notify it
             that if it wants to receive more data messages from the socket, it must call <u>inet:setopts/2</u> to  set
             the socket back into an active mode.

         <u>{tos,</u> <u>integer()}</u>:
           Sets  the  Type-Of-Service  field  on  the  IP  datagrams that are sent, to the specified value. This
           effectively determines a prioritization policy for the outbound packets. The  acceptable  values  are
           system-dependent.

         <u>{priority,</u> <u>integer()}</u>:
           A protocol-independent equivalent of <u>tos</u> above. Setting priority implies setting <u>tos</u> as well.

         <u>{dontroute,</u> <u>true|false}</u>:
           Defaults  to <u>false</u>. If <u>true</u>, the kernel does not send packets through any gateway, only sends them to
           directly connected hosts.

         <u>{reuseaddr,</u> <u>true|false}</u>:
           Defaults to <u>false</u>. If true, the  local  binding  address  <u>{IP,Port}</u>  of  the  socket  can  be  reused
           immediately.  No  waiting  in  state  <u>CLOSE_WAIT</u>  is  performed  (can be required for high-throughput
           servers).

         <u>{sndbuf,</u> <u>integer()}</u>:
           The size, in bytes, of the OS kernel send buffer for this socket.  Sending  errors  would  occur  for
           datagrams  larger  than  <u>val(sndbuf)</u>.  Setting this option also adjusts the size of the driver buffer
           (see <u>buffer</u> above).

         <u>{recbuf,</u> <u>integer()}</u>:
           The size, in bytes, of the OS kernel receive buffer for this socket. Sending errors would  occur  for
           datagrams  larger  than  <u>val(recbuf)</u>.  Setting this option also adjusts the size of the driver buffer
           (see <u>buffer</u> above).

         <u>{sctp_module,</u> <u>module()}</u>:
           Overrides which callback module is used. Defaults to <u>inet_sctp</u> for IPv4 and <u>inet6_sctp</u> for IPv6.

         <u>{sctp_rtoinfo,</u> <u>#sctp_rtoinfo{}}</u>:

         #sctp_rtoinfo{
               assoc_id = assoc_id(),
               initial  = integer(),
               max      = integer(),
               min      = integer()
         }

           Determines retransmission time-out parameters, in milliseconds, for the association(s)  specified  by
           <u>assoc_id</u>.

           <u>assoc_id</u> <u>=</u> <u>0</u> (default) indicates the whole endpoint. See RFC 2960 and Sockets API Extensions for SCTP
           for the exact semantics of the field values.

         <u>{sctp_associnfo,</u> <u>#sctp_assocparams{}}</u>:

         #sctp_assocparams{
               assoc_id                 = assoc_id(),
               asocmaxrxt               = integer(),
               number_peer_destinations = integer(),
               peer_rwnd                = integer(),
               local_rwnd               = integer(),
               cookie_life              = integer()
         }

           Determines association parameters for the association(s) specified by <u>assoc_id</u>.

           <u>assoc_id</u>  <u>=</u>  <u>0</u>  (default)  indicates  the whole endpoint. See Sockets API Extensions for SCTP for the
           discussion of their semantics. Rarely used.

         <u>{sctp_initmsg,</u> <u>#sctp_initmsg{}}</u>:

         #sctp_initmsg{
              num_ostreams   = integer(),
              max_instreams  = integer(),
              max_attempts   = integer(),
              max_init_timeo = integer()
         }

           Determines the  default  parameters  that  this  socket  tries  to  negotiate  with  its  peer  while
           establishing  an  association  with  it.  Is  to  be set after <u>open/*</u> but before the first <u>connect/*</u>.
           <u>#sctp_initmsg{}</u> can also be used as ancillary data with the first call of <u>send/*</u> to a new peer  (when
           a new association is created).

           <u>num_ostreams</u>:
             Number of outbound streams

           <u>max_instreams</u>:
             Maximum number of inbound streams

           <u>max_attempts</u>:
             Maximum retransmissions while establishing an association

           <u>max_init_timeo</u>:
             Time-out, in milliseconds, for establishing an association

         <u>{sctp_autoclose,</u> <u>integer()</u> <u>&gt;=</u> <u>0}</u>:
           Determines  the  time,  in  seconds, after which an idle association is automatically closed. <u>0</u> means
           that the association is never automatically closed.

         <u>{sctp_nodelay,</u> <u>true|false}</u>:
           Turns on|off the Nagle algorithm for merging small packets into larger ones. This improves throughput
           at the expense of latency.

         <u>{sctp_disable_fragments,</u> <u>true|false}</u>:
           If <u>true</u>, induces an error on an attempt to send a message larger than the current  PMTU  size  (which
           would  require  fragmentation/reassembling).  Notice  that  message fragmentation does not affect the
           logical atomicity of its delivery; this option is provided for performance reasons only.

         <u>{sctp_i_want_mapped_v4_addr,</u> <u>true|false}</u>:
           Turns on|off automatic mapping of IPv4 addresses into IPv6 ones (if  the  socket  address  family  is
           <u>AF_INET6</u>).

         <u>{sctp_maxseg,</u> <u>integer()}</u>:
           Determines  the  maximum chunk size if message fragmentation is used. If <u>0</u>, the chunk size is limited
           by the Path MTU only.

         <u>{sctp_primary_addr,</u> <u>#sctp_prim{}}</u>:

         #sctp_prim{
               assoc_id = assoc_id(),
               addr     = {IP, Port}
         }
          IP = ip_address()
          Port = port_number()

           For the association specified by <u>assoc_id</u>, <u>{IP,Port}</u> must be one of the peer addresses.  This  option
           determines  that  the  specified address is treated by the local SCTP stack as the primary address of
           the peer.

         <u>{sctp_set_peer_primary_addr,</u> <u>#sctp_setpeerprim{}}</u>:

         #sctp_setpeerprim{
               assoc_id = assoc_id(),
               addr     = {IP, Port}
         }
          IP = ip_address()
          Port = port_number()

           When set, informs the peer to use <u>{IP,</u> <u>Port}</u> as the primary address of the  local  endpoint  for  the
           association specified by <u>assoc_id</u>.

         <u>{sctp_adaptation_layer,</u> <u>#sctp_setadaptation{}}</u>:

         #sctp_setadaptation{
               adaptation_ind = integer()
         }

           When  set,  requests  that  the  local  endpoint  uses  the  value specified by <u>adaptation_ind</u> as the
           Adaptation Indication parameter for establishing new associations. For  details,  see  RFC  2960  and
           Sockets API Extenstions for SCTP.

         <u>{sctp_peer_addr_params,</u> <u>#sctp_paddrparams{}}</u>:

         #sctp_paddrparams{
               assoc_id   = assoc_id(),
               address    = {IP, Port},
               hbinterval = integer(),
               pathmaxrxt = integer(),
               pathmtu    = integer(),
               sackdelay  = integer(),
               flags      = list()
         }
         IP = ip_address()
         Port = port_number()

           Determines  various  per-address  parameters  for  the association specified by <u>assoc_id</u> and the peer
           address <u>address</u> (the SCTP protocol supports multi-homing, so more than one address can correspond  to
           a specified association).

           <u>hbinterval</u>:
             Heartbeat interval, in milliseconds

           <u>pathmaxrxt</u>:
             Maximum number of retransmissions before this address is considered unreachable (and an alternative
             address is selected)

           <u>pathmtu</u>:
             Fixed Path MTU, if automatic discovery is disabled (see <u>flags</u> below)

           <u>sackdelay</u>:
             Delay, in milliseconds, for SAC messages (if the delay is enabled, see <u>flags</u> below)

           <u>flags</u>:
             The following flags are available:

             <u>hb_enable</u>:
               Enables heartbeat

             <u>hb_disable</u>:
               Disables heartbeat

             <u>hb_demand</u>:
               Initiates heartbeat immediately

             <u>pmtud_enable</u>:
               Enables automatic Path MTU discovery

             <u>pmtud_disable</u>:
               Disables automatic Path MTU discovery

             <u>sackdelay_enable</u>:
               Enables SAC delay

             <u>sackdelay_disable</u>:
               Disables SAC delay

         <u>{sctp_default_send_param,</u> <u>#sctp_sndrcvinfo{}}</u>:

         #sctp_sndrcvinfo{
               stream     = integer(),
               ssn        = integer(),
               flags      = list(),
               ppid       = integer(),
               context    = integer(),
               timetolive = integer(),
               tsn        = integer(),
               cumtsn     = integer(),
               assoc_id   = assoc_id()
         }

           <u>#sctp_sndrcvinfo{}</u>  is  used  both  in  this  socket  option,  and as ancillary data while sending or
           receiving SCTP messages. When set as an option, it provides default values for subsequent <u>send</u>  calls
           on the association specified by <u>assoc_id</u>.

           <u>assoc_id</u> <u>=</u> <u>0</u> (default) indicates the whole endpoint.

           The following fields typically must be specified by the sender:

           <u>sinfo_stream</u>:
             Stream number (0-base) within the association to send the messages through;

           <u>sinfo_flags</u>:
             The following flags are recognised:

             <u>unordered</u>:
               The message is to be sent unordered

             <u>addr_over</u>:
               The address specified in <u>send</u> overwrites the primary peer address

             <u>abort</u>:
               Aborts the current association without flushing any unsent data

             <u>eof</u>:
               Gracefully shuts down the current association, with flushing of unsent data

             Other fields are rarely used. For complete information, see RFC 2960 and Sockets API Extensions for
             SCTP.

         <u>{sctp_events,</u> <u>#sctp_event_subscribe{}}</u>:

         #sctp_event_subscribe{
                 data_io_event          = true | false,
                 association_event      = true | false,
                 address_event          = true | false,
                 send_failure_event     = true | false,
                 peer_error_event       = true | false,
                 shutdown_event         = true | false,
                 partial_delivery_event = true | false,
                 adaptation_layer_event = true | false
         }

           This option determines which SCTP Events are to be received (through <u>recv/*</u>) along with the data. The
           only  exception is <u>data_io_event</u>, which enables or disables receiving of <u>#sctp_sndrcvinfo{}</u> ancillary
           data, not  events.  By  default,  all  flags  except  <u>adaptation_layer_event</u>  are  enabled,  although
           <u>sctp_data_io_event</u>  and  <u>association_event</u> are used by the driver itself and not exported to the user
           level.

         <u>{sctp_delayed_ack_time,</u> <u>#sctp_assoc_value{}}</u>:

         #sctp_assoc_value{
               assoc_id    = assoc_id(),
               assoc_value = integer()
         }

           Rarely used. Determines the ACK time (specified by <u>assoc_value</u>, in milliseconds)  for  the  specified
           association or the whole endpoint if <u>assoc_value</u> <u>=</u> <u>0</u> (default).

         <u>{sctp_status,</u> <u>#sctp_status{}}</u>:

         #sctp_status{
               assoc_id            = assoc_id(),
               state               = atom(),
               rwnd                = integer(),
               unackdata           = integer(),
               penddata            = integer(),
               instrms             = integer(),
               outstrms            = integer(),
               fragmentation_point = integer(),
               primary             = #sctp_paddrinfo{}
         }

           This option is read-only. It determines the status of the SCTP association specified by <u>assoc_id</u>. The
           following are the possible values of <u>state</u> (the state designations are mostly self-explanatory):

           <u>sctp_state_empty</u>:
             Default. Means that no other state is active.

           <u>sctp_state_closed</u>:

           <u>sctp_state_cookie_wait</u>:

           <u>sctp_state_cookie_echoed</u>:

           <u>sctp_state_established</u>:

           <u>sctp_state_shutdown_pending</u>:

           <u>sctp_state_shutdown_sent</u>:

           <u>sctp_state_shutdown_received</u>:

           <u>sctp_state_shutdown_ack_sent</u>:

           Semantics of the other fields:

           <u>sstat_rwnd</u>:
             Current receiver window size of the association

           <u>sstat_unackdata</u>:
             Number of unacked data chunks

           <u>sstat_penddata</u>:
             Number of data chunks pending receipt

           <u>sstat_instrms</u>:
             Number of inbound streams

           <u>sstat_outstrms</u>:
             Number of outbound streams

           <u>sstat_fragmentation_point</u>:
             Message size at which SCTP fragmentation occurs

           <u>sstat_primary</u>:
             Information on the current primary peer address (see below for the format of <u>#sctp_paddrinfo{}</u>)

         <u>{sctp_get_peer_addr_info,</u> <u>#sctp_paddrinfo{}}</u>:

         #sctp_paddrinfo{
               assoc_id  = assoc_id(),
               address   = {IP, Port},
               state     = inactive | active | unconfirmed,
               cwnd      = integer(),
               srtt      = integer(),
               rto       = integer(),
               mtu       = integer()
         }
         IP = ip_address()
         Port = port_number()

           This  option  is  read-only.  It  determines the parameters specific to the peer address specified by
           <u>address</u> within the association specified by <u>assoc_id</u>. Field <u>address</u> fmust be set by the  caller;  all
           other  fields  are  filled  in  on  return.  If  <u>assoc_id</u> <u>=</u> <u>0</u> (default), the <u>address</u> is automatically
           translated into the corresponding association ID. This option is rarely used. For  the  semantics  of
           all fields, see RFC 2960 and Sockets API Extensions for SCTP.

</pre><h4><b>SCTP</b> <b>EXAMPLES</b></h4><pre>
       Example of an Erlang SCTP server that receives SCTP messages and prints them on the standard output:

       -module(sctp_server).

       -export([server/0,server/1,server/2]).
       -include_lib("kernel/include/inet.hrl").
       -include_lib("kernel/include/inet_sctp.hrl").

       server() -&gt;
           server(any, 2006).

       server([Host,Port]) when is_list(Host), is_list(Port) -&gt;
           {ok, #hostent{h_addr_list = [IP|_]}} = inet:gethostbyname(Host),
           io:format("~w -&gt; ~w~n", [Host, IP]),
           server([IP, list_to_integer(Port)]).

       server(IP, Port) when is_tuple(IP) orelse IP == any orelse IP == loopback,
                             is_integer(Port) -&gt;
           {ok,S} = gen_sctp:open(Port, [{recbuf,65536}, {ip,IP}]),
           io:format("Listening on ~w:~w. ~w~n", [IP,Port,S]),
           ok     = gen_sctp:listen(S, true),
           server_loop(S).

       server_loop(S) -&gt;
           case gen_sctp:recv(S) of
           {error, Error} -&gt;
               io:format("SCTP RECV ERROR: ~p~n", [Error]);
           Data -&gt;
               io:format("Received: ~p~n", [Data])
           end,
           server_loop(S).

       Example  of  an  Erlang  SCTP  client  interacting with the above server. Notice that in this example the
       client creates an association with the server with 5 outbound streams. Therefore,  sending  of  <u>"Test</u>  <u>0"</u>
       over  stream  0  succeeds,  but  sending  of  <u>"Test</u>  <u>5"</u>  over  stream 5 fails. The client then <u>abort</u>s the
       association, which results in that the corresponding event is received on the server side.

       -module(sctp_client).

       -export([client/0, client/1, client/2]).
       -include_lib("kernel/include/inet.hrl").
       -include_lib("kernel/include/inet_sctp.hrl").

       client() -&gt;
           client([localhost]).

       client([Host]) -&gt;
           client(Host, 2006);

       client([Host, Port]) when is_list(Host), is_list(Port) -&gt;
           client(Host,list_to_integer(Port)),
           init:stop().

       client(Host, Port) when is_integer(Port) -&gt;
           {ok,S}     = gen_sctp:open(),
           {ok,Assoc} = gen_sctp:connect
               (S, Host, Port, [{sctp_initmsg,#sctp_initmsg{num_ostreams=5}}]),
           io:format("Connection Successful, Assoc=~p~n", [Assoc]),

           io:write(gen_sctp:send(S, Assoc, 0, &lt;&lt;"Test 0"&gt;&gt;)),
           io:nl(),
           timer:<a href="../man10000/sleep.10000.html">sleep</a>(10000),
           io:write(gen_sctp:send(S, Assoc, 5, &lt;&lt;"Test 5"&gt;&gt;)),
           io:nl(),
           timer:<a href="../man10000/sleep.10000.html">sleep</a>(10000),
           io:write(gen_sctp:abort(S, Assoc)),
           io:nl(),

           timer:<a href="../man1000/sleep.1000.html">sleep</a>(1000),
           gen_sctp:close(S).

       A simple Erlang SCTP client that uses the <u>connect_init</u> API:

       -module(ex3).

       -export([client/4]).
       -include_lib("kernel/include/inet.hrl").
       -include_lib("kernel/include/inet_sctp.hrl").

       client(Peer1, Port1, Peer2, Port2)
         when is_tuple(Peer1), is_integer(Port1), is_tuple(Peer2), is_integer(Port2) -&gt;
           {ok,S}     = gen_sctp:open(),
           SctpInitMsgOpt = {sctp_initmsg,#sctp_initmsg{num_ostreams=5}},
           ActiveOpt = {active, true},
           Opts = [SctpInitMsgOpt, ActiveOpt],
           ok = gen_sctp:connect(S, Peer1, Port1, Opts),
           ok = gen_sctp:connect(S, Peer2, Port2, Opts),
           io:format("Connections initiated~n", []),
           client_loop(S, Peer1, Port1, undefined, Peer2, Port2, undefined).

       client_loop(S, Peer1, Port1, AssocId1, Peer2, Port2, AssocId2) -&gt;
           receive
               {sctp, S, Peer1, Port1, {_Anc, SAC}}
                 when is_record(SAC, sctp_assoc_change), AssocId1 == undefined -&gt;
                   io:format("Association 1 connect result: ~p. AssocId: ~p~n",
                             [SAC#sctp_assoc_change.state,
                              SAC#sctp_assoc_change.assoc_id]),
                   client_loop(S, Peer1, Port1, SAC#sctp_assoc_change.assoc_id,
                               Peer2, Port2, AssocId2);

               {sctp, S, Peer2, Port2, {_Anc, SAC}}
                 when is_record(SAC, sctp_assoc_change), AssocId2 == undefined -&gt;
                   io:format("Association 2 connect result: ~p. AssocId: ~p~n",
                             [SAC#sctp_assoc_change.state, SAC#sctp_assoc_change.assoc_id]),
                   client_loop(S, Peer1, Port1, AssocId1, Peer2, Port2,
                              SAC#sctp_assoc_change.assoc_id);

               {sctp, S, Peer1, Port1, Data} -&gt;
                   io:format("Association 1: received ~p~n", [Data]),
                   client_loop(S, Peer1, Port1, AssocId1,
                               Peer2, Port2, AssocId2);

               {sctp, S, Peer2, Port2, Data} -&gt;
                   io:format("Association 2: received ~p~n", [Data]),
                   client_loop(S, Peer1, Port1, AssocId1,
                               Peer2, Port2, AssocId2);

               Other -&gt;
                   io:format("Other ~p~n", [Other]),
                   client_loop(S, Peer1, Port1, AssocId1,
                               Peer2, Port2, AssocId2)

           after 5000 -&gt;
                   ok
           end.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/gen_tcp.3erl.html">gen_tcp</a>(3erl)</u>, <u><a href="../man3erl/gen_udp.3erl.html">gen_udp</a>(3erl)</u>, <u><a href="../man3erl/inet.3erl.html">inet</a>(3erl)</u>, RFC 2960 (Stream Control Transmission  Protocol),  Sockets  API
       Extensions for SCTP

Ericsson AB                                        kernel 8.2                                     <u><a href="../man3erl/gen_sctp.3erl.html">gen_sctp</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>