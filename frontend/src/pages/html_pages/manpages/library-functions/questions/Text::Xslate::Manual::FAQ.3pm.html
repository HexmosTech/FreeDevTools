<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::Xslate::Manual::FAQ - Frequently asked questions and answers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-xslate-perl">libtext-xslate-perl_3.5.9-2build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::Xslate::Manual::FAQ - Frequently asked questions and answers

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This manual page lists FAQs, which we've heard for now.

</pre><h4><b>QUESTIONS</b></h4><pre>
   <b>General</b>
       <u>How</u> <u>do</u> <u>you</u> <u>pronounce</u> <u>'Xslate'?</u>

       We read it "/eks-leit/".

       <u>What</u> <u>'Xslate'</u> <u>stands</u> <u>for?</u>

       It stands for <u>XS</u> <u>template</u>, a template engine written in XS, although pure Perl implementations are also
       provided.

       <u>What</u> <u>are</u> <u>'Kolon',</u> <u>'Metakolon',</u> <u>and</u> <u>'TTerse'</u> <u>?</u>

       Xslate supports multiple template syntaxes. Kolon is the default syntax, Metakolon is suitable to output
       Kolon templates, and TTerse is compatible with Template-Toolkit 2. You can specify the template syntax by
       passing "syntax" option to the Text::Xslate constructor.

           my $tx = Text::Xslate-&gt;new(
               syntax =&gt; 'TTerse', # by moniker
           );

           my $tx = Text::Xslate-&gt;new(
               syntax =&gt; 'Text::Xslate::Syntax::TTerse', # by fully qualified name
           );

       <u>What</u> <u>version</u> <u>of</u> <u>perl</u> <u>does</u> <u>Xslate</u> <u>require?</u>

       Xslate is tested on perl v5.8.1. No special settings should be required.

       <u>How</u> <u>can</u> <u>I</u> <u>install</u> <u>the</u> <u>pure-Perl</u> <u>version</u> <u>of</u> <u>Xslate?</u>

       Pass "PUREPERL_ONLY=1" to <u>Makefile.PL</u>, which requests the Xslate build system not to make XS parts.

       Note that "cpanm 1.7" supports "--pp" option to install pure-Perl alternatives, so you can type "cpanm
       --pp Text::Xslate".

       <u>What</u> <u>optimizations</u> <u>does</u> <u>Xslate</u> <u>employs?</u>

       Here are some optimizations worth noting that makes Text::Xslate run so fast, in no particular order:

       Pre-compiled templates
           Text::Xslate  is among the template engines that pre-compile the templates.  This is similar to, say,
           Template::Toolkit, but Text::Xslate compiles the templates to C structures and stores them as  binary
           data.

       Built on top of a virtual machine
           Text::Xslate  is  built on top of virtual machine that executes bytecode, and this virtual machine is
           fine-tuned <u>specifically</u> for template processing.

           The virtual machine also employs optimizations such as direct-threading style coding to shave off any
           extra milliseconds that the engine might take otherwise

       Custom byte codes for oft-used operations
           Some operations which are used very often are optimized into its  own  byte  code.  For  example  (as
           described  elsewhere) Text::Xslate automatically escapes HTML unless you tell it not to. Text::Xslate
           implements this process which involves escaping the string <u>while</u> appending the result to  the  output
           buffer  in  C,  as  a  custom  byte  code. This lets you avoid the penalties usually involved in such
           operations.

       Pre-allocation of output buffers
           One of the main things to consider to reduce performance degradation while processing a  template  is
           to  avoid the number of calls to malloc().  One of the tricks that Text::Xslate employs to reduce the
           number of calls to malloc() is to pre-allocate the  output  buffer  in  an  intelligent  manner:  For
           example,  Text::Xslate  assumes  that  most  templates  will  be rendered to be about the same as the
           previous run, so when a template is rendered it uses the size allocated for the previous rendering as
           an approximation of how much space the current rendering will require. This  allows  you  to  greatly
           reduce the number of malloc() calls required to render a template.

       <u>How</u> <u>can</u> <u>I</u> <u>throw</u> <u>errors</u> <u>in</u> <u>functions</u> <u>and/or</u> <u>methods?</u>

       Handle warnings by "warn_handler" and raises exceptions if needed.

       That's because Xslate catches exceptions in templates and emits them as warnings.

   <b>Configuration</b>
       <u>When</u> <u>should</u> <u>I</u> <u>create</u> <u>the</u> <u>Xslate</u> <u>instance?</u>

       Xslate  instances  are  reusable  and creating the instance costs somewhat so you're recommended to reuse
       them as much as possible.  That is, you should make the instance global.

       Consider a PSGI application:

           # create Xslate here, not in psgi_app();
           my $xslate = Text::Xslate-&gt;new(...);

           sub psgi_app {
               my($env) = @_;
               # use $xslate and create $response
               return $response;
           }
           return \&amp;psgi_app; # as a PSGI app

       Don't create the instance in each request. It's less efficient.

       <u>How</u> <u>can</u> <u>I</u> <u>change</u> <u>instance</u> <u>attributes</u> <u>dynamically?</u>

       Instance attributes, e.g. "include_path", "function", or "syntax", are immutable, so  you  cannot  change
       them dynamically.

       Instead,  you  can  create multiple instances by different options.  instance in order to avoid conflicts
       with cache directories.

       For example:

           my %common_config = ( cache_dir =&gt; $dir, module =&gt; \@module );
           my %xslate = (
               ja =&gt; Text::Xslate-&gt;new( path =&gt; [ $template_ja ], %common_config ),
               en =&gt; Text::Xslate-&gt;new( path =&gt; [ $template_en ], %common_config ),
               ro =&gt; Text::Xslate-&gt;new( path =&gt; [ $template_ro ], %common_config ),
           );
           $xslate{$lang}-&gt;render(...);

   <b>Templates</b>
       <u>How</u> <u>can</u> <u>I</u> <u>changes</u> <u>template</u> <u>tags?</u>

       Use "start_tag", "end_tag", and "line_start" options to "new" method, which can be joined  together  with
       "syntax" option:

           my $tx = Text::Xslate-&gt;new(
               syntax     =&gt; 'TTerse',
               tag_start  =&gt; '{{',
               tag_end    =&gt; '}}',
               line_start =&gt; undef,
           );
           print $tx-&gt;render_string('Hello, {{lang}} world!', { lang =&gt; 'Xslate' });

       Note that you'd better to avoid symbols which can be used for operators.

       <u>How</u> <u>can</u> <u>I</u> <u>iterate</u> <u>over</u> <u>HASH</u> <u>references?</u>

       Convert HASH references into ARRAY references because "for" methods can deal with just ARRAY references.

           : # in Kolon
           : # iterate $hash by keys
           : for $hash.keys() -&gt; $key {
               &lt;: $key :&gt;
           : }
           : # by values
           : for $hash.values() -&gt; $value {
               &lt;: $value :&gt;
           : }
           : # by key-value pairs
           : for $hash.kv() -&gt; $pair {
               &lt;: $pair.key :&gt;=&lt;: $pair.value :&gt;
           : }

       Note that the above methods return ARRAY references sorted by the keys.

       <u>How</u> <u>can</u> <u>I</u> <u>use</u> <u>Template-Toolkit</u> <u>virtual</u> <u>methods</u> <u>and</u> <u>filters?</u>

       Xslate  itself  does  not support these methods and filters, but there are modules on CPAN that implement
       them.

       Text::Xslate::Bridge::TT2 provides almost all the TT methods  and  filters,  but  it  requires  Template-
       Toolkit installed.

       Text::Xslate::Bridge::TT2Like  provides the same features as "T::X::Bridge::TT2", and it does not require
       the Template-Toolkit runtime.

       These bridge modules are useful not only for TTerse users, but also for Kolon users.

       <u>How</u> <u>can</u> <u>I</u> <u>(write|get)</u> <u>plugins?</u>

       It is unlikely to need to write plugins for Xslate, because Xslate allows you to export any functions  to
       templates. Any function-based modules are available by the "module" option.

       Xslate  also allows you to call methods for object instances, so you can use any object-oriented modules,
       except for classes which only provide class methods (they need wrappers).

       If you want to add methods to builtin data types (nil, scalars, arrays and hashes), you can write  bridge
       modules. See Text::Xslate::Bridge for details.

       <u>How</u> <u>to</u> <u>limit</u> <u>while-loop</u> <u>like</u> <u>Template-Toolkit?</u>

       While  Template-Toolkit  has  a  loop  counter  to  prevent runaway "WHILE" loop, Xslate has no arbitrary
       limitation.

       Instead, you can use alarm() to limit <b>any</b> runaway code:

           eval {
               local $SIG{ALRM} = sub { die @_ };
               <a href="../man1/alarm.1.html">alarm</a>(1); # set timeout
               $tx-&gt;render('&lt;: while true { } :&gt;', \%vars);
           };
           if($@ =~ /\b ALRM \b/xms) {
               # timeout!
           }

       <u>Does</u> <u>Xslate</u> <u>process</u> <u>text</u> <u>strings,</u> <u>or</u> <u>binary</u> <u>strings?</u>

       (The meaning of <u>text</u> <u>string</u> and <u>binary</u> <u>string</u> is that of Perl, see perlunifaq.)

       Xslate assumes template files to be encoded in "UTF-8" by default, so the output is  a  text  string  and
       template parameters, including values which registered functions return, <b>must</b> be text strings.

       However,  if  you  want  to  process  binary strings, you can do so by passing ":bytes" to "input_layer",
       although it's not recommended.

       <u>Why</u> <u>doesn't</u> <u>I</u> <u>cannot</u> <u>access</u> <u>$object.attr</u> <u>like</u> <u>TT2?</u>

       Template-Toolkit allows objects (i.e. blessed references) to access its element  if  the  object  has  no
       accessor   methods,  i.e.  "[%  object.attr  %]"  might  mean  "$object-&gt;{attr}".  This  behavior  breaks
       encapsulation and hides typos, so Xslate doesn't allow such fallbacks.

       If you want to access object attributes, define the accessors of them, or prepare values as a  non-object
       before calling render().

       <u>Can</u> <u>I</u> <u>load</u> <u>macros</u> <u>in</u> <u>other</u> <u>template</u> <u>files?</u>

       Not yet. Currently Xslate doesn't support external macros.

   <b>Functions,</b> <b>filters</b> <b>and</b> <b>macros</b>
       <u>Where</u> <u>are</u> <u>the</u> <u>list</u> <u>of</u> <u>builtin</u> <u>functions?</u>

       See Text::Xslate::Manual::Builtin.

       <u>How</u> <u>can</u> <u>I</u> <u>use</u> <u>macros</u> <u>as</u> <u>a</u> <u>callback</u> <u>to</u> <u>high-level</u> <u>functions?</u>

       Macros  are  objects that overload "&amp;{}", the CODE dereference operator, so all you have to do is to call
       them simply, but don't check their types because they are not a <u>real</u> CODE reference.

           my $tx = Text::Xslate-&gt;new(
               function =&gt; {
                   count =&gt; sub {
                       my($a, $cb) = @_;
                       # Don't check the type of $cb!
                       return scalar grep { $cb-&gt;($_) } @{$a};
                   },
               },
           );

           print $tx-&gt;render_string('&lt;: count($a, -&gt; $x { $x &gt;= 50 }) :&gt;',
               { a =&gt; [ 0 .. 100 ] },
           ); # =&gt; 50

   <b>Web</b> <b>Application</b> <b>Frameworks</b>
       <u>How</u> <u>can</u> <u>I</u> <u>use</u> <u>Xslate</u> <u>in</u> <u>$my_favorite_WAF?</u>

       There are bridges that integrate Xslate into WAFs:

       •   Catalyst::View::Xslate for Catalyst

       •   MojoX::Renderer::Xslate for Mojolicious

       •   Tiffany for general usage

       There are WAFs which adopt Xslate as the default template engine:

       •   Amon2

       •   Pickles

       <u>Where</u> <u>are</u> <u>examples</u> <u>which</u> <u>use</u> <u>Xslate</u> <u>in</u> <u>Catalyst?</u>

       There is a real-world project that uses Xslate with Catalyst.

       &lt;https://github.com/duckduckgo/community-platform&gt;

       Initializing Xslate: &lt;https://github.com/duckduckgo/community-platform/blob/master/lib/DDGC.pm#L268&gt;

       Working on: &lt;https://dukgo.com/&gt;

       Enjoy!

   <b>Development</b> <b>and</b> <b>support</b>
       <u>How</u> <u>can</u> <u>I</u> <u>colorize</u> <u>Xslate</u> <u>templates?</u>

       For "vim" user, there is <u>xslate.vim</u> for Kolon:

       &lt;https://github.com/motemen/xslate-vim&gt;

       For "emacs" user, there are plugins:

       &lt;https://github.com/samvtran/kolon-mode&gt;

       &lt;https://github.com/yoshiki/tx-mode&gt;

       <u>Where</u> <u>can</u> <u>I</u> <u>ask</u> <u>questions?</u>

       The mailing list is recommended to ask questions.

       &lt;<a href="http://groups.google.com/group/xslate">http://groups.google.com/group/xslate</a>&gt;

       If you find a bug or have a request, creating github issues is better  because  those  tickets  are  less
       likely to disappear than the ports in the mailing list.

       &lt;https://github.com/xslate/p5-Text-Xslate/issues&gt;

       <u>I</u> <u>found</u> <u>a</u> <u>bug!</u> <u>What</u> <u>can</u> <u>I</u> <u>do</u> <u>for</u> <u>you?</u>

       Please  make a minimal test case to show the problem clearly.  The code is the common language both I and
       you speak fluently ;)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Text::Xslate

       Text::Xslate::Manual

       Text::Xslate::Manual::Cookbook

perl v5.40.0                                       2024-10-20                     <u>Text::Xslate::Manual::<a href="../man3pm/FAQ.3pm.html">FAQ</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>