<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Compile::FAQ - frequently asked questions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-compile-perl">libxml-compile-perl_1.64-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Compile::FAQ - frequently asked questions

</pre><h4><b>DESCRIPTION</b></h4><pre>
       On this page, a wild collection of questions are answered.  If you have contributions either in question
       or as answer, then please contribute via the mailinglist.

       See also XML::Compile::SOAP::FAQ.

   <b>The</b> <b>data</b> <b>structure</b>
       <u>what</u> <u>do</u> <u>the</u> <u>cho_,</u> <u>seq</u><b>_</b> <u>and</u> <u>all</u><b>_</b> <u>start</u> <u>of</u> <u>labels</u> <u>mean?</u>

       X::C tries to give you a simple data-structure in Perl, however XML does not always map directly only
       that.  One such situation is where you have blocks within a list of elements.  In such case, the block
       gets a name which is composed by the type of block and the first element in the block.  You will
       encounter these names in some error messages and when these block have a maxOccurs larger than 1.

       Example. The name "cho_tic" is used to represent the following nameless choice block:

         &lt;choice&gt;
           &lt;element name="tic" /&gt;
           &lt;element name="tac" /&gt;
           &lt;element name="toe" /&gt;
         &lt;/choice&gt;

       <u>localName</u> <u>collission</u>

       In the default behavior, only the "local" names of the XML elements are used in the Perl structure.
       However, it is very well possible that the same name appears in more than on XML name-space, used within
       the same data structure.  So see this often with substitutionGroups.

       When collissions happen, you have to switch to use "key_rewrite =&gt; 'PREFIXED'" in the compile rules.  All
       keys will now get rewritten: the name-space prefix will be prepended.  The prefixes are defined by the
       mapping table provided with the "prefixes" option or by default from the XML schemas.

       See "Key rewrite" in XML::Compile::Schema for the full list of options.

       <u>Overruling</u> <u>produced</u> <u>structures</u> <u>(writer)</u>

       You may encounter broken servers.  Actually, I have seen even expensive server implementations and
       professional high-profile services which do not follow the rules...

       On any location in the data structure you provide, you can give a value but also a fully prepared
       XML::LibXML node.  For instance

          my $doc  = XML::LibXML::Document-&gt;new('1.1', 'UTF-8');
          my $node = $doc-&gt;createElement('field);
          $node-&gt;<a href="../man42/appendText.42.html">appendText</a>(42);
          my $xml  = $schema-&gt;writer($type)-&gt;($doc, { field =&gt; $node });
          $doc-&gt;setDocumentElement($xml);

          print $xml-&gt;<a href="../man1/toString.1.html">toString</a>(1);   # perl string
          print $doc-&gt;<a href="../man1/toString.1.html">toString</a>(1);   # bytes

       You will probably need more than one attempt to produce the correct output... Only use this when you are
       sure that the receiving party is broken.

       <u>Producing</u> <u>CDATA</u> <u>blocks</u> <u>(writer)</u>

       To get CDATA blocks, the solution is very close to the example in the previous section:

          my $doc   = XML::LibXML::Document-&gt;new('1.1', 'UTF-8');
          my $cdata = $doc-&gt;createCDATASection($content);
          my $xml   = $schema-&gt;writer($type)-&gt;($doc, { field =&gt; $cdata });
          $doc-&gt;setDocumentElement($xml);

       The "$content" is a Perl string, which means that it needs to be utf8 when it is utf8.  For instance:

          use File::Slurp::Tiny;
          my $content = read_file $filename, binmode =&gt; 'utf8';
          my $cdata   = $doc-&gt;createCDATASection($content);

       When using SOAP (with or without WSDL) you need to do something like this:

          use XML::LibXML;   # for ::Document
          my $wsdl     = ...usual...

          my $doc      = XML::LibXML::Document-&gt;new('1.0', 'UTF-8');
          my %data     = (
             _doc     =&gt; $doc,
             password =&gt; $doc-&gt;createCDATASection($password),
          );
          $wsdl-&gt;call(Login =&gt; \%data);

       The XML which is sent is usually created inside the client library, but you need to create the CDATA
       block inside the same document structure.  But the "_doc" provides a way to use your own document object.
       Do not reuse it over multiple calls!

   <b>Schemas</b>
       Be aware that the "2001" schema specification is continuously under development.  So, the namespace has
       not been changed over time, but the content has.

       <u>qualified</u> <u>elements</u>

       One of the more noticeable problems with schemas is the specification of the namespaces to be used for
       the schema.  In older schema's, like many important protocols, there was no way to specify whether
       elements should be used qualified or not.  Some schema's lack the target namespace declaration.  Those
       fields did not exist in earlier versions of the "2001" spec; it was defined in the documentation.

       So, what you may encounter is something like:

         &lt;schema xmlns="<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a>"&gt;

       where (in the current syntax) it should have been

         &lt;schema xmlns="<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a>"
           targetNamespace="<a href="http://my-namespace">http://my-namespace</a>"
           elementFormDefault="qualified"
           attributeFormDefault="unqualified"&gt;

       The default for "targetNamespace" is "namespace-less".  The *FormDefault defaults are "unqualified",
       which is a pity: most schemas will use qualified elements.

       Of course, you can add these fields to the schema file, but that violates the intergrity of that external
       resource.  Therefore, use options:

         my $schema = XML::Compile::Schema-&gt;new;
         $schema-&gt;importDefinitions("schema.xsd"
            , target_namespace     =&gt; '<a href="http://my-namespace">http://my-namespace</a>'
            , element_form_default =&gt; 'qualified'
            );

       You may also provide all these options with new() directly.

         my $schema = XML::Compile::Schema-&gt;new("schema.xsd"
            , target_namespace     =&gt; '<a href="http://my-namespace">http://my-namespace</a>'
            , element_form_default =&gt; 'qualified'
            );

       If you use the XML::Compile::Cache object, which extends ::Schema, then you have a nice "printIndex"
       method which shows you what has been read.

       <u>schema</u> <u>location</u>

       The official idea about the use of schema's, is that you get the latest version of them on the moment you
       start the application.  There are two major problems with that:

       . you may not have (a working) internet connection on that moment
       . remote changes in the spec may break your application unexpectedly

       In  general,  IMO  as author of the XML::Compile suite, you should <b>never</b> want this dynamic, unpredictable
       behavior!

       Besides, the content of the "schemaLocation" attribute to "import", "include" and "schema"  elements  are
       usually broken, missing and/or flawed.  You can better do it by hand.

       Collect  the  schema's  you  need  in  a  directory.   The name of the schema file does not need to means
       anything useful.  Then, add the location where the schema's are found:

          my $schema = XML::Compile::Cache-&gt;new;
          $schema-&gt;addSchemaDirs($my_schema_dir);

       Add the mapping from namespaces to filenames (you may provide an ARRAY of names or use the same namespace
       multiple times).  It is useful to have a constant defined for your namespace.

          use constant MY_NS =&gt; '<a href="http://very-long">http://very-long</a>';
          $schema-&gt;knownNamespace(&amp;MY_NS =&gt; 'schemafile.xsd');
          $schema-&gt;importDefinitions(MY_NS, @options);

       There is also a less clean solution:

          my $schema = XML::Compile::Cache-&gt;new('schemafile.xsd', @options);

       When you have many xsd's to include, you may do this:

          my @xsds = glob "$my_schema_dir/*.xsd";
          my $schema = XML::Compile::Cache-&gt;new;
          $schema-&gt;knownNamespace(&amp;MY_NS =&gt; \@xsds);
          $schema-&gt;importDefinitions(MY_NS, @options);

       or

          my $schema = XML::Compile::Cache-&gt;new(\@xsds, @options);

       <u>fixing</u> <u>schemas</u>

       Many schema's are broken.  XML::Compile is not a good tool to figure-out what is wrong with  the  schema.
       Have you tried "xmllint"?  Sometimes, you get sufficient help adding to the top of your script:

          use Log::Report mode =&gt; 'DEBUG';

       When  you  know  what  is wrong, you can overrule parts of the schema by redefining elements; simply: the
       last definition for an element wins.  For instance:

          $schema-&gt;importDefinition(&lt;&lt;'_PATCH');
          &lt;schema ....&gt;
            &lt;element name="has_bug"&gt;
               ...
            &lt;/element&gt;
          _PATCH

       Of course, you can also use an external file for this.

       <u>Example</u>

       This is a piece of code actually used.  It  shows  various  complications  when  an  external  schema  is
       "loaded" "dynamically" into another schema.

         # In the top of your script
         my $schema_dir = '/usr/share/schemas';
         my $xyz_ns     = '<a href="http://www.xyzeorder.com/workflow">http://www.xyzeorder.com/workflow</a>';
         my $xyz_xsd    = 'xyzSchema.xsd';

         # In the main part of your script
         my $schema     = XML::Compile::Cache-&gt;new(....);
         $schema-&gt;addSchemaDirs($schema_dir);
         $schema-&gt;importDefinitions($xyz_xsd, target_namespace =&gt; $xyz_ns);
         $schema-&gt;addPrefixes(xyz =&gt; $xyz_ns);
         $schema-&gt;addKeyRewrite('PREFIXED(xyz)');

       The schema "forgets" to mention its "targetNamespace", so it is overruled.  The ::Cache extension handles
       prefixes  much  nicer than the ::Schema base object.  So, with reading/writing the hash keys which relate
       to the elements in this schema will have "xyz_" as prefix for clarity.

   <b>Processing</b>
       <u>my</u> <u>data</u> <u>is</u> <u>not</u> <u>recognized</u>

       You do specify the data in your structure, but it seems not to be recognized.  See "wrong error message"

       <u>wrong</u> <u>error</u> <u>message</u>

       You may get an error message about a "missing data item" on a higher  structural  level  than  where  the
       problem  actually  is.  This especially happens with unions and substitutionGroups.  The problem is cause
       by the fact that on a certain structural level, multiple alternatives may appear which only  differ  many
       levels  deep  in  structure.  X::C needs to scan all the alternatives, and when all fail it does not know
       which of the alternatives was "the best" alternative.

       Try turning on debugging with:

         use Log::Report  mode =&gt; "DEBUG";

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This module is part of XML-Compile distribution  version  1.64,  built  on  October  21,  2024.  Website:
       <u><a href="http://perl.overmeer.net/xml-compile/">http://perl.overmeer.net/xml-compile/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 2006-2024 by [Mark Overmeer &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]. For other contributors see ChangeLog.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.40.0                                       2024-10-27                             <u>XML::Compile::<a href="../man3pm/FAQ.3pm.html">FAQ</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>