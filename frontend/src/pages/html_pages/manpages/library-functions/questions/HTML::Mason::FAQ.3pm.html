<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::Mason::FAQ - Frequently asked questions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-mason-perl">libhtml-mason-perl_1.60-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::Mason::FAQ - Frequently asked questions

</pre><h4><b>AUTOHANDLERS,</b> <b>METHODS,</b> <b>ATTRIBUTES,</b> <b>INHERITANCE</b></h4><pre>
   <b>Can</b> <b>I</b> <b>set</b> <b>a</b> <b>page's</b> <b>inheritance</b> <b>dynamically</b> <b>at</b> <b>request</b> <b>time</b> <b>(e.g.</b> <b>based</b> <b>on</b> <b>URL</b> <b>arguments)?</b>
       No. Inheritance is a fixed property of a component, determined once when the component is loaded. Dynamic
       inheritance is on the todo list.

   <b>How</b> <b>can</b> <b>I</b> <b>tell</b> <b>Mason</b> <b>to</b> <b>use</b> <b>autohandlers</b> <b>or</b> <b>dhandlers</b> <b>when</b> <b>calling</b> <b>one</b> <b>component</b> <b>from</b> <b>another</b> <b>component</b> <b>(i.e.</b>
       <b>internal</b> <b>redirect)?</b>
       Usually this situation arises when a top-level component makes a run-time decision to use a second
       component as the "real" page, and calls it via &lt;&amp; &amp;&gt; or $m-&gt;comp.

       Autohandlers and dhandlers are only triggered for the top-level component of a request. In 1.1, you can
       use an Apache internal redirect or a Mason subrequest ($m-&gt;subexec) to solve the problem.

   <b>I</b> <b>added</b> <b>a</b> <b>simple</b> <b>autohandler</b> <b>to</b> <b>a</b> <b>directory</b> <b>and</b> <b>now</b> <b>my</b> <b>pages</b> <b>don't</b> <b>appear.</b>
       Make sure to include a call to $m-&gt;call_next somewhere in the autohandler.

   <b>Where</b> <b>does</b> <b>a</b> <b>dhandler</b> <b>inherit</b> <b>from?</b> <b>Can</b> <b>I</b> <b>change</b> <b>it</b> <b>to</b> <b>inherit</b> <b>based</b> <b>on</b> <b>the</b> <b>URL</b> <b>path?</b>
       A dhandler's inheritance is determined by its location in the hierarchy, not by the URL that invoked it.

       Consider a site with the following components:

              /autohandler
              /dhandler
              /products/autohandler

       and suppose a request comes in for /products/index.html. /dhandler will handle the request but will still
       inherit from /autohandler.

       This is not always the desired behavior, but there is no easy way to change it. If you want /products/*
       requests to use /products/autohandler, you'll need to create /products/dhandler as well.

   <b>Can</b> <b>I</b> <b>change</b> <b>the</b> <b>value</b> <b>of</b> <b>an</b> <b>attribute</b> <b>dynamically,</b> <b>based</b> <b>on</b> <b>the</b> <b>request?</b>
       No, attributes are static. The closest thing to a dynamic attribute is a method. If you've been using an
       attribute widely and don't want to change it to a method everywhere, consider using an attribute/method
       combination. Suppose your attribute is called 'bgcolor'. Create a default method called 'bgcolor' in the
       autohandler:

              &lt;%method bgcolor&gt;
              &lt;%init&gt;
              return $m-&gt;base_comp-&gt;attr('bgcolor');
              &lt;%init&gt;
              &lt;/%method&gt;

       Then replace every other

              $m-&gt;base_comp-&gt;attr('bgcolor');

       with

              $m-&gt;base_comp-&gt;call_method('bgcolor')

       or

              &lt;&amp; SELF:bgcolor &amp;&gt;

       Now you can leave the attribute definitions alone, but define a method if and when you need a dynamically
       computed value.

   <b>When</b> <b>using</b> <b>multiple</b> <b>component</b> <b>roots</b> <b>and</b> <b>autohandlers,</b> <b>does</b> <b>every</b> <b>autohandler</b> <b>in</b> <b>every</b> <b>root</b> <b>get</b> <b>called,</b> <b>and</b> <b>in</b>
       <b>what</b> <b>or</b>
       Mason will try each autohandler path in turn, e.g.

          /foo/bar/baz/autohandler
          /foo/bar/autohandler
          /foo/autohandler
          /autohandler

       For each path, it will search all of the component roots, and only run the *first* autohandler found.
       Some of the autohandlers might come from one root and some from another.  However, there is no way that
       multiple autohandlers would be run for the same path (/foo/autohandler, for example.) There is also no
       way for /foo/autohandler in root 1 to explicitly call /foo/autohandler in root 2.

       People sometimes ask for this behavior to be changed. We feel it's a bad idea because multiple component
       roots, right now, are very clean in both behavior and implementation. Trying to run multiple autohandlers
       for the same path would require a complex set of precedence rules that would almost certainly lead to
       unpredictable behavior. (Think about multiple versions of multiple autohandlers at different directory
       levels, and trying to predict which order they'd run in.)

</pre><h4><b>CACHING</b></h4><pre>
   <b>When</b> <b>I</b> <b>change</b> <b>a</b> <b>component</b> <b>I</b> <b>don't</b> <b>always</b> <b>see</b> <b>the</b> <b>results</b> <b>in</b> <b>the</b> <b>output.</b> <b>How</b> <b>do</b> <b>I</b> <b>invalidate</b> <b>Mason</b> <b>code</b>
       <b>caches?</b>
       Mason employs two kinds of code caching. First, Mason caches loaded components in memory. Second, Mason
       keeps an object file (a compiled version of the component) for every loaded component under
       data_root/obj.

       Before executing a memory-cached component, Mason compares the stored timestamp with the timestamp of the
       source file. If the source file has a later timestamp, Mason will load the component from the filesystem.

       Similarly, before using an object file, Mason compares the modified timestamp of the source and object
       files. If the source file has a later timestamp, then it is reparsed and the object file is overwritten.

       The system is designed so that you will immediately see the effects of source file changes. There are
       several ways for this system to breakdown; most are easy to avoid once you know about them.

       * If you copy or move in a component source file from elsewhere, it will retain the original file's
       timestamp, which may be earlier than the object file.

       * If you use tar, rsync, rdist or similar programs to transfer components, the timestamps of the created
       files may not be updated to the current time. Check the program's documentation for timestamp-related
       options.

       * If you use a shared file system like NFS, the timestamps of locally created files may not jibe with
       timestamps of NFS files due to differences in machine clocks.

       * If you ftp files onto a running server, Mason may read the file while it is incomplete. If the ftp then
       completes within the same second, Mason will not notice the change, and won't ever read the complete
       file.

       When in doubt, touching the source files (with the Unix touch command, or by re-saving in an editor)
       should force Mason to reload the component. If that does not work, try removing the object files and/or
       restarting the server to clear the memory cache. However, these remedies should be necessary only to
       diagnose the caching problem, not for normal Mason operation. On a normal Mason system cache expiration
       should just work "as expected".

   <b>Mason</b> <b>code</b> <b>caching</b> <b>breaks</b> <b>down</b> <b>often</b> <b>in</b> <b>my</b> <b>situation.</b> <b>Couldn't</b> <b>you</b> <b>do</b> <b>something</b> <b>smarter</b> <b>than</b> <b>just</b> <b>comparing</b>
       <b>the</b> <b>timestamps?</b>
       When coming up with invalidation schemes, we must consider efficiency as well as failure predictability.
       The current scheme does fail in certain situations, but those situations are very predictable. If you
       incorrectly use tar or copy or another technique mentioned above, you'll see the cache invalidation
       failure very quickly.

       Some alternatives that have been suggested:

       * Compare the sizes of the files as well as timestamps, or use the more liberal "source timestamp !=
       object timestamp". This would indeed increase the chance of catching a change. But it would still fail
       occasionally (e.g. when changing a single character, or when copying an old-timestamp file that just
       happens to match the current timestamp), resulting in intermittent, head-scratching errors. In our
       opinion, it is better to fail miserably up front and be forced to fix your system than to have a mostly-
       working system that fails once a week. This is especially true when you are relying on Mason's cache
       invalidation on a production system.

       * Comparing MD5 or other signatures of the content. This would be very accurate, but would require
       reading and processing the source file instead of just performing a stat. This extra expense reduces the
       effectiveness of the cache.

       The bottom line: If you are relying on Mason's cache invalidation on a production system, you should take
       the time and build in the appropriate infrastructure to ensure that source file timestamps are always up-
       to-date after they are copied/untarred into place.

   <b>When</b> <b>I</b> <b>change</b> <b>code</b> <b>in</b> <b>a</b> <b>library</b> <b>file</b> <b>I</b> <b>don't</b> <b>see</b> <b>the</b> <b>results.</b> <b>How</b> <b>can</b> <b>I</b> <b>get</b> <b>Mason</b> <b>to</b> <b>reread</b> <b>the</b> <b>library</b>
       <b>files?</b>
       mod_perl processes, in general, do not automatically reread your library files. You either have to stop
       and start the server whenever you change a library file, or install something like Apache::Reload which
       will automate their reloading. However, see ApacheReload for important usage information.

   <b>Once</b> <b>I've</b> <b>made</b> <b>an</b> <b>error</b> <b>in</b> <b>a</b> <b>component,</b> <b>the</b> <b>error</b> <b>keeps</b> <b>appearing</b> <b>in</b> <b>the</b> <b>logs,</b> <b>no</b> <b>matter</b> <b>how</b> <b>many</b> <b>times</b> <b>I</b> <b>fix</b>
       <b>it</b> <b>and</b> <b>reload!</b>
       Are you using Apache::Reload in its default (!ReloadAll) mode? If so, see ApacheReload for details.

   <b>Do</b> <b>data</b> <b>cache</b> <b>files</b> <b>expire</b> <b>automatically</b> <b>when</b> <b>a</b> <b>component</b> <b>or</b> <b>its</b> <b>dependencies</b> <b>change?</b>
       Unfortunately they do not. This is on the to-do list.

       With Mason 1.1x and beyond, you can use the following idiom to say ``expire when my component source file
       changes'':

             $m-&gt;cache(...,
               expire_if=&gt;sub {
                     (stat($m-&gt;current_comp-&gt;source_file))[9] &gt; $_[0]-&gt;get_created_at
               } )

       With Mason &lt;= 1.05, the idiom looks like:

             $m-&gt;cache(...,
                expire_if=&gt;sub {
                     (stat($m-&gt;current_comp-&gt;source_file))[9] &gt; $_[0]
                } )

</pre><h4><b>COMPONENTS</b></h4><pre>
   <b>What</b> <b>is</b> <b>a</b> <b>component?</b>
       A component is a file that contains some combination of text (typically HTML), perl code and HTML::Mason
       directives.

       Some components are accessed directly by web browsers. These are called top-level components. A top-level
       component might consist purely of static HTML.

       Other components are support components, which are called by top-level components or other support
       components. These components are analogous to perl subroutines -- they allow you to create small packages
       of code that you can reuse throughout your project.

   <b>How</b> <b>do</b> <b>components</b> <b>communicate</b> <b>with</b> <b>each</b> <b>other?</b>
       Components can return values to their callers, just like subroutines.

       Some components may have very simple return values. As an example, consider a component called isNetscape
       which returns a true value when the client's browser is Netscape and undef when it is not. The isNetscape
       component could then be used easily in an <b>if()</b> or other control statement.

       Of course, components can also return strings of text, arrays, hashes or other arbitrarily complex perl
       data structures.

   <b>How</b> <b>do</b> <b>I</b> <b>use</b> <b>modules</b> <b>in</b> <b>components?</b>
       Technically you can just say "use module-name" at the beginning of a component. The disadvantages of this
       method are that:

       * the module will be used separately by every httpd child process, costing both time and memory.

       * it is difficult to keep track of all the modules being used on a site.

       A more efficient method is to put the use line in the handler.pl or use the PerlModule directive. If you
       want components to be able to refer to symbols exported by the module, you need to use the module inside
       the HTML::Mason::Commands package. See the "External modules" section of the Administrator's Guide:

   <b>Can</b> <b>I</b> <b>define</b> <b>subroutines</b> <b>in</b> <b>components?</b>
       Defining a named subroutine in a &lt;%perl&gt; or &lt;%init&gt; section does not work reliably because such a
       definition would end up residing inside another subroutine, and Perl doesn't like that.

       You can technically define named subroutines inside the &lt;%once&gt; section of any component, but we highly
       discourage this, because all components are executed in the same namespace. This makes it easy to create
       two subroutines with the same name in two different components.

       Consider the following options:

       * If the routine is going to display HTML, use a separate component or a &lt;%def&gt; subcomponent.

       * If the subroutine is only of use in your component, use an anonymous subroutine defined in &lt;%once&gt;.
       Even though you could define the anonymous subroutine in any section, a &lt;%once&gt; is recommended, both for
       performance and to avoid nested-anonymous-subroutine leaks in Perl &lt;=5.6. Example:

             &lt;%once&gt;
             my $foo = sub {
               ...
             };
             &lt;/%once&gt;

             ...

             % $foo-&gt;()

       * If the subroutine is of interest to more than just your component, have you considered putting it in a
       module?

       Note that calling a component, while reasonably fast, is about an order of magnitude slower than calling
       an equivalent subroutine. So if you're going to call the routine many times in a loop, you may wish to
       use the anonymous subroutine for performance reasons. Benchmark for yourself.

   <b>Does</b> <b>Mason</b> <b>set</b> <b>the</b> <b>current</b> <b>working</b> <b>directory</b> <b>(".")</b> <b>for</b> <b>me?</b>
       Mason does not touch the working directory, as this would entail an unnecessary performance hit for the
       majority of users that don't need it.

       In an Apache environment, the working directory will be set in a more-or-less random way, depending on
       such seemingly irrelevant factors as whether you started the server in single-process mode or not. In a
       non-Apache environment the working directory will be whatever it was before Mason started executing.

       Often people expect the working directory to be the directory of the current component. You can, instead,
       get that directory manually with

              $m-&gt;current_comp-&gt;source_dir

   <b>How</b> <b>do</b> <b>I</b> <b>exit</b> <b>from</b> <b>all</b> <b>components</b> <b>including</b> <b>the</b> <b>ones</b> <b>that</b> <b>called</b> <b>me?</b>
       Use $m-&gt;abort, documented in the Request manual:

   <b>Why</b> <b>does</b> <b>my</b> <b>output</b> <b>have</b> <b>extra</b> <b>newlines/whitespace</b> <b>and</b> <b>how</b> <b>can</b> <b>I</b> <b>get</b> <b>rid</b> <b>of</b> <b>it?</b>
       Any newlines that are not either inside a tag or on a %-line will become part of the output. Since
       browsers ignore extra whitespace this is not generally a problem, but there are situations where it
       matters, e.g. within &lt;pre&gt; tags.

       First, for components that only return a value and shouldn't output *any* content, you should always use
       &lt;%init&gt;:

             &lt;%args&gt;
              $foo
             &lt;/%args&gt;

             This content will be ignored.

             &lt;%init&gt;
              my $bar = $dbh-&gt;selectrow_array("SELECT bar FROM t WHERE foo=?", $foo);
              return $bar;
             &lt;/%init&gt;

       In components that do display content, there are various strategies. To eliminate selected newlines, use
       the backslash. For example,

              &lt;PRE&gt;
              foo\
              % if (1) {
              bar\
              % }
              baz
              &lt;/PRE&gt;

       outputs "foobarbaz" with no newlines.

       To prevent a component from outputting any newlines, use a filter:

              &lt;%filter&gt;
              s/\n//g;
              &lt;/%filter&gt;

       To emit binary data without the risk of inserting extra whitespace, surround your code with
       $m-&gt;clear_buffer and $m-&gt;abort, to suppress any preceding and following content:

             &lt;%init&gt;
              $m-&gt;clear_buffer;
              my $fh = IO::File-&gt;new('&lt; binary_file') or die $!;
              my $buffer;
              while (read $fh, $buffer, 8192) {
                $m-&gt;print($buffer);
              }
              $m-&gt;abort;
             &lt;/%init&gt;

       At some point Mason will probably offer a "reasonable" whitespace removal feature, controlled by
       parameter.

   <b>I'm</b> <b>trying</b> <b>to</b> <b>generate</b> <b>an</b> <b>image</b> <b>or</b> <b>other</b> <b>binary</b> <b>file,</b> <b>but</b> <b>it</b> <b>seems</b> <b>to</b> <b>be</b> <b>getting</b> <b>corrup</b>
       This is almost always caused by unwanted whitespace at the beginning or end of your binary data. Put a
       $m-&gt;clear_buffer before, and an $m-&gt;abort after, your code. See the last part of the answer above.

       In Apache 1.0 a real working example looks like this:

          my $fh;
          my $fileName = '/tmp/mypic.jpg';
          open ( $fh, $fileName ) or die $!;

          $m-&gt;clear_buffer();
          $r-&gt;content_type( 'image/jpeg' ); # set mime-type
          $r-&gt;send_http_header;
          $r-&gt;send_fd ( $fh );
          close ( $fh );

       In Apache 2.0 use:

          use Apache2::Const qw(HTTP_OK)

          my $fileName = 'someimage.jpg';
          $m-&gt;clear_buffer();
          $r-&gt;content_type( 'image/jpeg' );
          $r-&gt;sendfile( $fileName )
          $r-&gt;abort( Apache2::Const::HTTP_OK );

   <b>How</b> <b>do</b> <b>I</b> <b>put</b> <b>comments</b> <b>in</b> <b>components?</b>
       * Put general comments in the &lt;%doc&gt; section.

       * In the &lt;%init&gt; and &lt;%cleanup&gt; sections, and in a &lt;%perl&gt; block, use standard Perl comments ('#').

       * In Mason 1.3 and beyond, use &lt;%# %&gt; for single or multi-line comments anywhere outside of Perl
       sections. Before 1.3, this syntax isn't guaranteed to work; one alternative is to begin a line with %#.

       * If you are producing HTML, you can use standard HTML comments delimited by &lt;!-- --&gt;. The difference is
       that these comments will appear in the final output.

   <b>What's</b> <b>a</b> <b>good</b> <b>way</b> <b>to</b> <b>temporarily</b> <b>comment</b> <b>out</b> <b>code</b> <b>in</b> <b>a</b> <b>component?</b>
       For HTML, you might be tempted to surround the section with &lt;!-- --&gt;. But be careful! Any code inside the
       section will still execute. Here's a example of commenting out a call to an ad server:

             &lt;!-- temporarily comment out
             &lt;&amp; FetchAd &amp;&gt;
             --&gt;

       The ad will still be fetched and counted, but not displayed!

       A better way to block out a section is if (0):

             % if (0) {
               ...
             % }

       Code blocked out in this way will neither be executed nor displayed, and multiple if (0) blocks can be
       nested inside each other (unlike HTML comments).

       Another way to block out code is with a &lt;%doc&gt; tag or a &lt;%# %&gt; comment, although these not cannot be
       nested.

   <b>How</b> <b>can</b> <b>I</b> <b>capture</b> <b>the</b> <b>output</b> <b>of</b> <b>a</b> <b>component</b> <b>(and</b> <b>modify</b> <b>it,</b> <b>etc.)</b> <b>instead</b> <b>of</b> <b>having</b> <b>it</b> <b>automatically</b> <b>output?</b>

       Use $m-&gt;scomp, documented in the Request manual:

   <b>Can</b> <b>I</b> <b>use</b> <b>globals</b> <b>in</b> <b>components?</b>
       All HTML::Mason components run in the same package (HTML::Mason::Commands), so if you set a global
       variable in one you'll be able to read it in all the others. The only problem is that Mason by default
       parses components with strict mode on, so you'll get a warning about the global (and Mason considers all
       such warnings fatal). To avoid errors, simply declare your globals via the MasonAllowGlobals parameter.

             PerlSetVar MasonAllowGlobals $dbh
             PerlAddVar MasonAllowGlobals $user

       If you have a handler.pl file, you can also declare global variables in the <b>handler()</b> subroutine as long
       as you explicitly put them in the HTML::Mason::Commands package.

             package HTML::Mason::Commands;
             use vars qw(...);

       or use the Parser allow_globals parameter.

       Alternatively you can turn off strict entirely by passing:

             use_strict =&gt; 0

       when you create the Parser object. Then you can use all the globals you want. Doing this is terribly
       silly, however, and is bound to get you in trouble down the road.

   <b>How</b> <b>do</b> <b>I</b> <b>share</b> <b>variables</b> <b>between</b> <b>components?</b>
       First, you can pass variables from one component to another.

       Second, you can use globals. All components run in the same package (HTML::Mason::Commands as of this
       writing), so globals in this package are visible to all components. See the previous question.

       There is no way to share a variable between just a few components; this is a limitation of Perl's scoping
       rules. You can make a variable /visible/ to only certain components using 'our' declarations:

               &lt;%once&gt;
               our ($shared_var);
               &lt;/%once&gt;

       See the Perl documentation on 'our' to make sure you understand what this is doing.

       The &lt;%shared&gt; section is /not/ for sharing variables among different file components. It is for sharing
       variables among the subcomponents and methods of a single file component.

   <b>Why</b> <b>does</b> <b>the</b> <b>order</b> <b>of</b> <b>output</b> <b>get</b> <b>mixed</b> <b>up</b> <b>when</b> <b>I</b> <b>use</b> <b>print</b> <b>or</b> <b>$r-&gt;print?</b>
       This should no longer happen with Mason 1.10+. For those users still using older versions of Mason, read
       the following:

       Since your server is most likely in batch mode, all Mason output gets buffered til the end of the
       request. print and $r-&gt;print circumvent the buffer and thus come out before other Mason output.

       Solution: don't use print or $r-&gt;print. Use $m-&gt;out if you must output inside a Perl section. See the
       section on output mode in the Administrator's Guide.

       and the section on $m-&gt;out in the Request manual.

   <b>Why</b> <b>doesn't</b> <b>my</b> <b>&lt;%cleanup&gt;</b> <b>code</b> <b>run</b> <b>every</b> <b>time</b> <b>the</b> <b>component</b> <b>runs?</b>
       A &lt;%cleanup&gt; block is equivalent to a "&lt;%perl&gt;" block at the end of the component. This means it will NOT
       execute if the component explicitly returns, or if an abort or error occurs in that component or one of
       its children.

       If you need code that is guaranteed to run when the component or request exits, consider using a mod_perl
       cleanup handler, or creating a custom class with a DESTROY method.

   <b>Is</b> <b>&lt;%args&gt;</b> <b>exactly</b> <b>like</b> <b>%ARGS,</b> <b>and</b> <b>do</b> <b>I</b> <b>need</b> <b>to</b> <b>worry</b> <b>about</b> <b>it?</b>
       Mason allows you to predeclare arguments to components by specifying variables to hold those arguments in
       an &lt;%args&gt;&lt;/%args&gt; section. Because these are perl variables that you are predeclaring, they must have
       legal perl identifier names -- they can't, for example, contain periods.

       If you want to pass arguments that are not identified with legal perl names, you must manually pull those
       arguments out of the %ARGS hash that mod_perl sets up for you. Why would you want to name your arguments
       un-legally, you ask? Well, just for starters, the form input element &lt;input type="image"
       name="clickable"&gt; will pass arguments clickable.x and clickable.y to the action url automatically. If you
       want to access these, you'd have to use $ARGS{clickable.x} and $ARGS{clickable.y} rather than trying to
       declare them in &lt;%args&gt;.

   <b>Why</b> <b>does</b> <b>Mason</b> <b>display</b> <b>the</b> <b>wrong</b> <b>line</b> <b>numbers</b> <b>in</b> <b>errors?</b>
       Due to limitations in the 1.0x parser, Mason can only display line numbers relative to object files.

       In 1.1 and on, error line numbers correctly reflect the component source.

   <b>How</b> <b>can</b> <b>I</b> <b>get</b> <b>a</b> <b>list</b> <b>of</b> <b>components</b> <b>matching</b> <b>a</b> <b>path</b> <b>pattern?</b>
       Use the resolver's glob_path method:

             my @paths = $m-&gt;interp-&gt;resolver-&gt;glob_path('/some/comp/path/*');

       This will work even with multiple component roots; you'll get a combined list of all matching component
       paths in all component roots.

   <b>Can</b> <b>I</b> <b>access</b> <b>$m</b> <b>(the</b> <b>request</b> <b>object)</b> <b>from</b> <b>outside</b> <b>a</b> <b>component,</b> <b>e.g.</b> <b>inside</b> <b>a</b> <b>subroutine?</b>
       In 1.1x and on, use

             my $m = HTML::Mason::Request-&gt;instance;

       Before 1.1x, use

             my $m = HTML::Mason::Commands::m;

   <b>How</b> <b>can</b> <b>I</b> <b>make</b> <b>the</b> <b>|h</b> <b>escape</b> <b>flag</b> <b>work</b> <b>with</b> <b>my</b> <b>Russian/Japanese/other-non-western</b> <b>encoding?</b>
       The |h flag is implemented with [=HTML::Entities::encode_html]. This function, by default, escapes
       control chars and high-bit chars as well as &lt;, &gt;, &amp;, and ". This works well for ISO-8559-1 encoding but
       not with other encodings.

       To make |h escape just &lt;, &gt;, &amp;, and ", which is often what people want, put the following in your Apache
       configuration:

              PerlSetVar  MasonEscapeFlags  "h =&gt; \&amp;HTML::Mason::Escapes::basic_html_escape"

       Or, in a top-level autohandler:

              $m-&gt;interp-&gt;set_escape( h =&gt; \&amp;HTML::Mason::Escapes::basic_html_escape );

   <b>When</b> <b>using</b> <b>multiple</b> <b>component</b> <b>roots,</b> <b>is</b> <b>there</b> <b>a</b> <b>way</b> <b>to</b> <b>explicitly</b> <b>call</b> <b>a</b> <b>component</b> <b>in</b> <b>a</b> <b>specific</b> <b>root?</b>
       Multiple component roots were designed to work just like Perl's @INC.  A given component path matches
       exactly one file, the first file found in an ordered search through the roots. There is no way to
       explicitly ask for a file in a specific root.

       People sometimes ask for the ability to do this. We feel it's a bad idea because it would endanger the
       cleanliness of multiple component roots in both behavior and implementation. As it stands now, the rules
       are very easy to understand and the implementation is very clean and isolated; only the resolver really
       needs know about multiple component roots.

       If you want to be able to explicitly refer to components in a given root, put an extra subdirectory
       between the root and the components.  e.g. put your components in

           /usr/local/htdocs/global/global/...

       then add the root as

           ['global', '/usr/local/htdocs/global']

       Now you can prefix a path with /global to refer to any component in that root.

       Alternatively, [<a href="http://search.cpan.org/dist/MasonX-Request-ExtendedCompRoot">http://search.cpan.org/dist/MasonX-Request-ExtendedCompRoot</a>
       MasonX::Request::ExtendedCompRoot] is a subclass of Mason that does allow you to call components in a
       specific component root.

   <b>Is</b> <b>there</b> <b>a</b> <b>syntax</b> <b>checker</b> <b>like</b> <b>perl</b> <b>-c</b> <b>for</b> <b>components?</b>
       It is impossible to write a truly generic standalone script to syntax check components, because
       components rely on certain globals and modules to be present in their environment. Mason may report
       compile errors from such a script even though they would not occur in your normal web environment.

       The best you can do is write a standalone script that mimics your web environment as much as possible -
       in particular, declaring the same globals and loading the same modules. Instead of actually executing
       components, your script need only load them with $interp-&gt;<b>load()</b>. This method will throw a fatal error if
       a component fails to load.

</pre><h4><b>HTTP</b> <b>AND</b> <b>HTML</b></h4><pre>
   <b>How</b> <b>do</b> <b>I</b> <b>access</b> <b>GET</b> <b>or</b> <b>POST</b> <b>arguments?</b>
       GET and POST arguments are automatically parsed and placed into named component arguments just as if you
       had called the component with &lt;&amp; &amp;&gt; or $m-&gt;comp. So you can get at GET/POST data by pre-declaring
       argument names and/or using the %ARGS hash which is always available.

   <b>How</b> <b>can</b> <b>I</b> <b>access</b> <b>the</b> <b>raw</b> <b>content</b> <b>of</b> <b>a</b> <b>POST</b> <b>in</b> <b>a</b> <b>Mason</b> <b>component?</b>
       It depends on your environment as to what you can do.

       Apache/mod_perl has an easier way of doing it than CGI/FCGi, which uses FakeApache. As you can see from
       the comment, since FakeApache implements read, I couldn't get it to be completely dynamic:

               my $inputText;
               # FakeApache implements read, so we can't automatically tell
               # if we're in mod_perl or FCGI
               if (0 &amp;&amp; $r-&gt;can('read')){
                       $r-&gt;read( $inputText, $r-&gt;headers_in-&gt;{'Content-length'} );
                       }
               else {
                       my %params = $r-&gt;params;
                       my $posted_content = $params{POSTDATA} || $params{keywords};
                       $posted_content ||= join '', %params if ($r-&gt;method eq 'POST');
                       $posted_content = join '', @$posted_content if (ref $posted_content eq 'ARRAY');
                       $inputText = $posted_content
               }

       -- Gareth Kirwan

       Probably $r-&gt;params does not work. there is no such method in 'man Apache'

       -- Rajesh Kumar Mallah.

   <b>What</b> <b>happens</b> <b>if</b> <b>I</b> <b>include</b> <b>query</b> <b>args</b> <b>in</b> <b>a</b> <b>POST?</b>
       As of Mason 1.01, query string and POST arguments are always combined.

   <b>Should</b> <b>I</b> <b>use</b> <b>CGI.pm</b> <b>to</b> <b>read</b> <b>GET/POST</b> <b>arguments?</b>
       No! HTML::Mason automatically parses GET/POST arguments and places them in declared component arguments
       and %ARGS (see previous question). If you create a CGI object in the usual way for a POST request, it
       will hang the process trying to read $r-&gt;content a second time.

   <b>Can</b> <b>I</b> <b>use</b> <b>CGI.pm</b> <b>to</b> <b>output</b> <b>HTML</b> <b>constructs?</b>
       Yes. To get a new CGI object, use

             my $query = new CGI('');

       You have to give the empty string argument or CGI will try to read GET/POST arguments.

       To print HTML constructs returned by CGI functions, just enclose them in &lt;%%&gt;, e.g.

             &lt;% $query-&gt;radio_group(...) %&gt;

   <b>How</b> <b>do</b> <b>I</b> <b>modify</b> <b>the</b> <b>outgoing</b> <b>HTTP</b> <b>headers?</b>
       Use the usual Apache.pm functions, such as $r-&gt;header_out. See the "Sending HTTP Headers" section in the
       Component Developer's Guide.

   <b>How</b> <b>do</b> <b>I</b> <b>do</b> <b>an</b> <b>external</b> <b>redirect?</b>
       In Mason 1.0x, use code like this:

               $m-&gt;clear_buffer;
               # The next two lines are necessary to stop Apache from re-reading
               # POSTed data.
               $r-&gt;method('GET');
               $r-&gt;headers_in-&gt;unset('Content-length');
               $r-&gt;content_type('text/html');
               $r-&gt;header_out('Location' =&gt; $location);
               $m-&gt;<a href="../man301/abort.301.html">abort</a>(301);

       In Mason 1.1x, use the [=$m-&gt;redirect] method.

       See the next question if your redirect isn't producing the right status code.

   <b>When</b> <b>trying</b> <b>to</b> <b>use</b> <b>$m-&gt;redirect</b> <b>I</b> <b>get</b> <b>'Can't</b> <b>locate</b> <b>object</b> <b>method</b> <b>"redirect"</b> <b>via</b> <b>package</b>
       <b>"HTML::Mason::!ApacheHandler"'.</b>
       $m-&gt;redirect is supported only in Mason 1.1x and on. Check your Mason version by putting

              Version = &lt;% $HTML::Mason::VERSION %&gt;

       in a component.

   <b>Why</b> <b>isn't</b> <b>my</b> <b>status</b> <b>code</b> <b>reaching</b> <b>users'</b> <b>browsers?</b>
       If you are using a handler.pl, your <b>handler()</b> routine should always return the error code that
       handle_request($r) produces. Otherwise, things like $m-&gt;<b>abort()</b> will not work correctly. So a very, very
       simple <b>handler()</b> routine would look like this:

             sub handler {
               my $r = shift;
               $ah-&gt;handle_request($r);
             }

       If you are using $m-&gt;abort or $m-&gt;redirect and there is an <b>eval()</b> wrapped directly or indirectly around
       the call, you must take care to propagate abort exceptions after the <b>eval()</b>. This looks like:

              eval { $m-&gt;comp('...') };
              if ($@) {
                 if ($m-&gt;aborted) {
                     die $@;
                 } else {
                     # deal with non-abort exceptions
                 }
              }

   <b>How</b> <b>can</b> <b>I</b> <b>handle</b> <b>file</b> <b>uploads</b> <b>under</b> <b>Mason?</b>
       The basic HTML for an upload form looks like:

              &lt;form action="..." method="post" enctype="multipart/form-data"&gt;
              Upload new file:
              &lt;input name="userfile" type="file" class="button"&gt;
              &lt;input type="submit" value="Upload"&gt;

       The way you handle the submission depends on which args method you chose for the !ApacheHandler class.

       Under the 'CGI' method (default for 1.0x), you can use the [=$m-&gt;cgi_object] method to retrieve a CGI.pm
       object which can be used to retrieve the uploaded file. Here is an example using the 'CGI' method:

         &lt;%init&gt;
         my $query = $m-&gt;cgi_object;

         # get a filehandle for the uploaded file
         my $fh = $query-&gt;upload('userfile');

         # print out the contents of the uploaded file
         while (&lt;$fh&gt;) {
               print;
         }
         close($fh);
         &lt;/%init&gt;

       Please see the [CGI.pm <a href="http://search.cpan.org/~lds/CGI.pm-3.05/CGI.pm">http://search.cpan.org/~lds/CGI.pm-3.05/CGI.pm</a>#CREATING_A_FILE_UPLOAD_FIELD
       documentation] for more details.

       Under the 'mod_perl' method (default for 1.1x), the request object available as [=$r] in your components
       will be an object in the Apache::Request class (as opposed to the Apache class). This object is capable
       of returning Apache::Upload objects for parameters which were file uploads. Please see the
       [Apache::Request
       <a href="http://search.cpan.org/~joesuf/libapreq-1.3/Request/Request.pm">http://search.cpan.org/~joesuf/libapreq-1.3/Request/Request.pm</a>#Apache%3A%3AUpload_METHODS documentation]
       for more details.  Here is an example using the 'mod_perl' method:

         &lt;%init&gt;

          # NOTE: If you are using libapreq2 + mod_perl2 + Apache 2,
          # you will need to uncomment the following line:
          # use Apache::Upload;

          # you can store the file's contents in a scalar
          my $file_contents;

          # create an Apache::Upload object
          my $upload = $r-&gt;upload;

          # get a filehandle for the uploaded file
          my $upload_fh = $upload-&gt;fh;

          while(&lt;$upload_fh&gt;) {
              # loop through the file and copy each line to $file_contents
              $file_contents .= $_;
          }
          close($upload_fh);
         &lt;/%init&gt;

       For more information on how to manually set the args method, see the !ApacheHandler documentation.

       If you are using CGI.pm, there are some configuration issues to be aware of. CGI.pm needs a tmp
       directory, and you probably want to be able to specify what that directory is.

       Try doing this in your httpd.conf or handler.pl:

             &lt;Perl&gt;
             use CGI qw(-private_tempfiles);
             &lt;/Perl&gt;

       You must do this _before_ you load either the HTML::Mason or HTML::Mason::!ApacheHandler modules.

       That may change which directories CGI tries to use.

       You could also try

             $CGI::TempFile::TMPDIRECTORY = '<a href="file:/tmp">/tmp</a>';

       during startup, either in your httpd.conf or handler.pl

       The root of the problem is probably that the temp directory is being chosen when the module loads uring
       server startup while its still root. It sees it can write to /usr/tmp and is happy. Then when actually
       running as nobody it dies.

       I bet Lincoln would welcome a patch (hint, hint). One solution would be to check if you're running under
       mod_perl and you're root. If so, then check Apache-&gt;server-&gt;uid and see if that id can write to the temp
       directory too.

   <b>How</b> <b>can</b> <b>I</b> <b>manipulate</b> <b>cookies?</b>
       You can use the helpful modules Apache::Cookie and CGI::Cookie. It's also fairly easy to roll your own
       cookie-manipulation functions, using the methods provided by the $r global.

       One thing to avoid: the combination of CGI::Cookie, Apache::Request, and POST requests has caused people
       problems. It seems that Apache::Cookie and Apache::Request make a better pair.

   <b>How</b> <b>can</b> <b>I</b> <b>populate</b> <b>form</b> <b>values</b> <b>automatically?</b>
       Several CPAN modules provide form-filling capabilities. HTML::!FillInForm is one good choice and works
       well with Mason. Here's a sample code snippet:

            &lt;%filter&gt;
            $_ = HTML::FillInForm-&gt;new-&gt;fill(scalarref =&gt; \$_, fdat =&gt; \%ARGS );
            &lt;/%filter&gt;

       This will work for any component that contains a complete form in its output.

       If you are using Apache::Request to process incoming arguments under mod_perl (the default as of 1.10),
       then you can also do this:

            &lt;%filter&gt;
            use HTML::FillInForm;
            $_ = HTML::FillInForm-&gt;new-&gt;fill(scalarref =&gt; \$_, fobject =&gt; $r );
            &lt;/%filter&gt;

       These two examples are slightly different from each other, in that each makes a different set of
       parameters available to HTML::!FillInForm. In the first example, the arguments used are those that were
       explicitly passed to the component. In the second example, the arguments are those that were passed in
       the initial HTTP request. Of course, variations on this are possible by mixing and matching %ARGS,
       $m-&gt;request_args, $m-&gt;caller_args, and so on.

</pre><h4><b>INSTALLATION</b></h4><pre>
   <b>What</b> <b>else</b> <b>do</b> <b>I</b> <b>need</b> <b>to</b> <b>use</b> <b>Mason?</b>
       If you are planning on using Mason in a web environment with the Apache webserver, you'll need a working
       copy of Apache and mod_perl installed. Make sure that your mod_perl installation works correctly before
       trying to get Mason working. Also, if you are running RedHat Linux, beware the mod_perl RPMs that ship
       with RedHat. They were unreliable for a very long time, and their current state is still murky.

   <b>What</b> <b>platforms</b> <b>does</b> <b>Mason</b> <b>run</b> <b>on?</b>
       Because Mason consists of only Perl code, it should work anywhere Perl runs (including most Unix and
       Win32 variants). If it doesn't work on your operating system, let us know.

   <b>Can</b> <b>I</b> <b>run</b> <b>Mason</b> <b>outside</b> <b>a</b> <b>web</b> <b>server?</b>
       Yes, in fact Mason can be useful for generating a set of web pages offline, as a general templating tool,
       or even as a code generator for another language. See the "Standalone Mode" section of the Interpreter
       manual.

   <b>Can</b> <b>I</b> <b>run</b> <b>Mason</b> <b>via</b> <b>CGI?</b>
       Yes. See "Using Mason from a CGI script" in the Interpreter manual.

       The examples in the docs requires that you have Mason 1.10+ installed.

       Note that running Mason under CGI (or other non-persistent environments) will entail a substantial
       performance hit, since the perl interpreter will have to load, load up Mason and its supporting modules
       for every CGI execution. Using mod_perl or similar persistent environments (SpeedyCGI, FastCGI, etc.)
       avoids this performance bottleneck.

   <b>Can</b> <b>I</b> <b>use</b> <b>Mason</b> <b>with</b> <b>Apache/mod_perl</b> <b>2.0?</b>
       Yes, as of Mason 1.27 (released 10/28/2004), there is support for Apache/mod_perl 2.0 in the core Mason
       code. You may find other hints at ApacheModPerl2.

   <b>Where</b> <b>can</b> <b>I</b> <b>find</b> <b>a</b> <b>web</b> <b>host</b> <b>supporting</b> <b>Mason?</b>
       Please check the [Hosting] page for a list of hosting providers supporting HTML::Mason.  You may also be
       interested in the list of [<a href="http://perl.apache.org/help/isps.html">http://perl.apache.org/help/isps.html</a> ISPs supporting mod_perl], however,
       there are reports that this document has not been maintained in several years.

   <b>What</b> <b>does</b> <b>the</b> <b>error</b> <b>"Can't</b> <b>locate</b> <b>object</b> <b>method</b> <b>'TIEHASH'</b> <b>via</b> <b>package</b> <b>'Apache::Table'"</b> <b>mean?</b>
       It means that Mason is trying to use some of mod_perl's "table" interface methods, like
       $r-&gt;dir_config-&gt;get('key') or the like. It's failing because your mod_perl server wasn't compiled with
       support for Apache's Table API.

       To fix the problem, you'll have to recompile your server, adding the PERL_TABLE_API=1 flag (or
       EVERYTHING=1).

       If you can't recompile your server, you can edit the Mason source code. Find a line in ApacheHandler.pm
       that looks like this (it's line 365 in Mason 1.04):

             my @val = $mod_perl::VERSION &lt; 1.24 ? $c-&gt;dir_config($p) :
                $c-&gt;dir_config-&gt;get($p);

       and change it to:

             my @val = Apache::perl_hook('TableApi') ? $c-&gt;dir_config-&gt;get($p) :
                $c-&gt;dir_config($p);

       Recent versions of Mason use that, or a variant of it.

   <b>What</b> <b>does</b> <b>the</b> <b>error</b> <b>"Can't</b> <b>locate</b> <b>Apache/Request.pm</b> <b>in</b> <b>@INC"</b> <b>m</b>
       You are using the default !ApacheHandler args_method ('mod_perl'), which requires that you have installed
       the Apache::Request package (libapreq).

       You can either install libapreq, or change args_method to 'CGI'. The latter is a bit slower and uses more
       memory.

   <b>Why</b> <b>am</b> <b>I</b> <b>getting</b> <b>segmentation</b> <b>faults</b> <b>(or</b> <b>silently</b> <b>failing</b> <b>on</b> <b>startup)?</b>
       There are a few known mod_perl issues that cause segmentation faults or a silent failure on the part of
       Apache to start itself up. Though not specific to Mason, they are worth keeping in mind:

       * Are you using a dynamically-linked mod_perl? DSO mod_perl builds were unstable for a long time,
       although they might finally be getting better. Rebuild Apache with mod_perl linked statically and see if
       the problem goes away. Also see <a href="http://perl.apache.org/docs/1.0/guide/install.html">http://perl.apache.org/docs/1.0/guide/install.html</a>#When_DSO_can_be_Used.

       * Earlier versions of XML::Parser and Apache could conflict, because both  would statically compile in
       expat for XML parsing. This was fixed as of Apache version 1.3.20 and XML::Parser 2.30, both of which can
       be compiled against the same shared libexpat. You can also build Apache with '--disable-rule=EXPAT'.
       Matthew Kennedy points out that 'If "strings `which httpd` | grep -i xml" returns anything, you have this
       problem.'

       * Are you using Perl 5.6.0? Though not widespread, Perl 5.6.0 can generate sporadic segmentation faults
       at runtime for some Perl code. Specifically, evals of moderate complexity appear problematic. And, since
       Mason uses lots of evals of moderate complexity, you can't avoid them. If the two suggestions above don't
       solve your segfault problem and you are running Perl 5.6.0, try upgrading to Perl 5.6.1.

       MISCELLANEOUS

   <b>Where</b> <b>did</b> <b>the</b> <b>name</b> <b>come</b> <b>from?</b>
       It was inspired by a recent reading of Ken Follett's "The Pillars Of The Earth." The book centered around
       the life of a mason, a builder of great churches and buildings.

       PERFORMANCE

   <b>Is</b> <b>Mason</b> <b>fast?</b>
       It is typically more than fast enough. 50-100 requests per second for a simple component is typical for a
       reasonably modern Linux system. Some simple benchmarking indicates that a Mason component is typically
       about two to three times slower than an equivalent, hand-coded mod_perl module.

       Although benchmarks on [<a href="http://chamas.com/bench/">http://chamas.com/bench/</a> Apache Hello World! benchmarks] site shows that Mason
       code is five (simple Hello World page, [=hello.mas]) to ten (heavyweight template, [=h2000.mas]) times
       slower than mod_perl solution.

       Beware of "Hello World!" and other simple benchmarks. While these benchmarks do a good job of measuring
       the setup and initialization time for a package, they are typically not good measures of how a package
       will perform in a complex, real-world application. As with any program, the only way to know if it meets
       your requirements is to test it yourself.

       In general, however, if your application is fast enough in pure mod_perl, it will most likely be fast
       enough under HTML::Mason as well.

   <b>How</b> <b>can</b> <b>I</b> <b>make</b> <b>my</b> <b>Mason</b> <b>application</b> <b>run</b> <b>faster?</b>
       The first thing you can do to optimize Mason performance is to optimize your mod_perl installation.
       Consider implementing some of the tuning tips recommended in mod_perl_tuning, which ships with every copy
       of mod_perl.

       If your application still needs to run faster, consider using Mason's caching methods ($m-&gt;cache and
       $m-&gt;cache_self) to avoid regenerating dynamic content unnecessarily.

   <b>Does</b> <b>Mason</b> <b>leak</b> <b>memory?</b>
       Mason 1.10 and 1.11 do have a memory leak. This is fixed with 1.12. Earlier versions of Mason may leak
       some memory when using the "mod_perl" args_method, due to what is arguably a bug in Apache::Request.

       If you do find other memory leaks that are traceable to Mason, please check the known bugs list to make
       sure it hasn't already been reported. If it hasn't, simplify your handler.pl (if you have one) and the
       offending component as much as possible, and post your findings to the mason-users mailing list.

       Of course it is always possible for your own component code to leak, e.g. by creating and not cleaning up
       global variables. And mod_perl processes do tend to grow as they run because of "copy-on-write" shared-
       memory management. The mod_perl documentation and performance faq make good bedtime reading.

       If you are using RedHat's mod_perl RPM, or another DSO mod_perl installation, you will leak memory and
       should switch to a statically compiled mod_perl.

       SERVER CONFIGURATION

   <b>Why</b> <b>are</b> <b>my</b> <b>config</b> <b>file</b> <b>changes</b> <b>not</b> <b>taking</b> <b>effect?</b>
       1. After changing an httpd.conf or handler.pl or other server configuration file, make sure to do a FULL
       stop and start of the server. By default, the server will not reread Perl scripts or configuration when
       using "apachectl restart" or when sending a HUP or USR1 signal to the server.

       For more details see "Server Stopping and Restarting" in the mod_perl guide.

       2. Note that you cannot use Mason httpd parameters (MasonCompRoot, MasonErrorMode, etc.) and a handler.pl
       script that creates an ApacheHandler object at the same time. Depending on how you declare your
       PerlHandler, one or the other will always take precedence and the other will be ignored. For more details
       see "Site Configuration Methods" in the Admin manual.

   <b>What</b> <b>filename</b> <b>extensions</b> <b>should</b> <b>I</b> <b>use</b> <b>for</b> <b>Mason</b> <b>components?</b>
       Unlike many templating systems, Mason comes with no obvious filenaming standards. While this flexibility
       was initially considered an advantage, in retrospect it has led to the proliferation of a million
       different component extensions (.m, .mc, .mhtml, .mcomp, ...) and has made it more difficult for users to
       share components and configuration.

       The Mason team now recommends a filenaming scheme with extensions like .html, .txt, .pl for top-level
       components, and .mhtml, .mtxt, .mpl for internal (non-top-level) components.

       Whatever naming scheme you choose should ideally accomplish three things:

       * Distinguish top-level from internal components. This is obviously crucial for security.

       * Distinguish output components from those that compute and return values. This improves clarity, and
       forces the component writer to decide between outputting and returning, as it is bad style to do both.

       * Indicate the type of output of a component: text, html, xml, etc. This improves clarity, and helps
       browsers that ignore content-type headers (such as IE) process non-HTML pages correctly.

   <b>Can</b> <b>I</b> <b>serve</b> <b>images</b> <b>through</b> <b>a</b> <b>HTML::Mason</b> <b>server?</b>
       If you put images in the same directories as components, you need to make sure that the images don't get
       handled through HTML::Mason. The reason is that HTML::Mason will try to parse the images and may
       inadvertently find HTML::Mason syntax (e.g. "&lt;%"). Most images will probably pass through successfully
       but a few will cause HTML::Mason errors.

       The simplest remedy is to have HTML::Mason decline image and other non-HTML requests, thus letting Apache
       serve them in the normal way.

       Another solution is to put all images in a separate directory; it is then easier to tell Apache to serve
       them in the normal way. See the next question.

       For performance reasons you should consider serving images from a completely separate (non-HTML::Mason)
       server. This will save a lot of memory as most requests will go to a thin image server instead of a large
       mod_perl server. See Stas Bekman's mod_perl guide and Vivek Khera's performance FAQ for a more detailed
       explanation. Both are available at <a href="http://perl.apache.org/">http://perl.apache.org/</a>

   <b>How</b> <b>can</b> <b>I</b> <b>prevent</b> <b>a</b> <b>particular</b> <b>subdirectory</b> <b>from</b> <b>being</b> <b>handled</b> <b>by</b> <b>HTML::Mason?</b>
       Suppose you have a directory under your document root, "/plain", and you would like to serve these files
       normally instead of using the HTML::Mason handler. Use a Location directive like:

             &lt;Location /plain&gt;
               SetHandler default-handler
             &lt;/Location&gt;

       Or suppose you have a "/cgi-bin" that you want to process via CGI:

             &lt;Location /cgi-bin&gt;
               SetHandler cgi-script
             &lt;/Location&gt;

       When you have multiple Location directives, the latest ones in the configuration have the highest
       precedence. So to combine the previous directive with a typical Mason directive:

             &lt;Location /&gt;
               SetHandler perl-script
               PerlHandler HTML::Mason
             &lt;/Location&gt;

             &lt;Location /cgi-bin&gt;
               SetHandler cgi-script
             &lt;/Location&gt;

       More generally, you can use various Apache configuration methods to control which handlers are called for
       a given request. Ken Williams uses a FilesMatch directive to invoke Mason only on requests for ".html"
       files:

              &lt;FilesMatch  "\.html$"&gt;
                SetHandler perl-script
                PerlHandler HTML::Mason
              &lt;/FilesMatch&gt;

       Or you could reverse this logic, and write FilesMatch directives just for gifs and jpegs, or whatever.

       If you are using a handler.pl, you can put the abort decision in your <b>handler()</b> routine. For example, a
       line like the following will produce the same end result as the &lt;Location /plain&gt; directive, above.

             return -1 if $r-&gt;uri() =~ m|^/plain|;

       However, performance will not be as good as the all-Apache configuration.

   <b>Why</b> <b>am</b> <b>I</b> <b>getting</b> <b>404</b> <b>errors</b> <b>for</b> <b>pages</b> <b>that</b> <b>clearly</b> <b>exist?</b>
       The filename that Apache has resolved to may not fall underneath the component root you specified when
       you created the interpreter in handler.pl. HTML::Mason requires the file to fall under the component root
       so that it can call it as a top-level component. (For various reasons, such as object file creation,
       HTML::Mason cannot treat files outside the component root as a component.)

       If you believe the file is in fact inside the component root and HTML::Mason is in error, it may be
       because you're referring to the Apache document root or the HTML::Mason component root through a symbolic
       link. The symbolic link may confuse HTML::Mason into thinking that two directories are different when
       they are in fact the same. This is a known "bug", but there is no obvious fix at this time. For now, you
       must refrain from using symbolic links in either of these configuration items.

       The same thing could also happen in any context with more than one way to specify a canonical filename.
       For example, on Windows, if your document root starts with "C:" and your component root starts with "c:",
       you might have this problem even though both paths should resolve to the same file.

       With Mason 0.895 and above, if you set Apache's LogLevel to warn, you will get appropriate warnings for
       these Mason-related 404s.

   <b>Some</b> <b>of</b> <b>my</b> <b>pages</b> <b>are</b> <b>being</b> <b>served</b> <b>with</b> <b>a</b> <b>content</b> <b>type</b> <b>other</b> <b>than</b> <b>text/html.</b>  <b>How</b> <b>do</b> <b>I</b> <b>get</b> <b>HTML::Mason</b> <b>to</b>
       <b>properly</b> <b>set</b> <b>the</b> <b>content</b> <b>type?</b>
       HTML::Mason doesn't actually touch the content type -- it relies on Apache to set it correctly. You can
       affect how Apache sets your content type in the configuration files (e.g. srm.conf). The most common
       change you'll want to make is to add the line

             DefaultType text/html

       This indicates that files with no extension and files with an unknown extension should be treated as
       text/html. By default, Apache would treat them as text/plain.

   <b>Microsoft</b> <b>Internet</b> <b>Explorer</b> <b>displays</b> <b>my</b> <b>page</b> <b>just</b> <b>fine,</b> <b>but</b> <b>Netscape</b> <b>or</b> <b>other</b> <b>browsers</b> <b>just</b> <b>display</b> <b>the</b> <b>raw</b>
       <b>HTML</b> <b>code.</b>
       The most common cause of this is an incorrect content-type. All browsers are supposed to honor content-
       type, but MSIE tries to be smart and assumes content-type of text/html based on filename extension or
       page content.

       The solution is to set your default content-type to text/html. See previous question.

   <b>My</b> <b>configuration</b> <b>prevents</b> <b>HTML::Mason</b> <b>from</b> <b>processing</b> <b>anything</b> <b>but</b> <b>html</b> <b>and</b> <b>text</b> <b>extensions,</b> <b>but</b> <b>I</b> <b>want</b> <b>to</b>
       <b>generate</b> <b>a</b> <b>dynamic</b> <b>image</b> <b>using</b> <b>HTML::Mason.</b>  <b>How</b> <b>can</b> <b>I</b> <b>get</b> <b>HTML::Mason</b> <b>to</b> <b>set</b> <b>the</b> <b>correct</b> <b>MIME</b> <b>type?</b>
       Use mod_perl's $r-&gt;content_type function to set the appropriate MIME type. This will allow you to output,
       for example, a GIF file, even if your component is called dynamicImage.html. However there's no guarantee
       that every browser (e.g. Internet Explorer) will respect your MIME type rather than your file extension.
       Make sure to test on multiple browsers.

   <b>How</b> <b>do</b> <b>I</b> <b>bring</b> <b>in</b> <b>external</b> <b>modules?</b>
       Use the PerlModule directive in your httpd.conf, or if you have a startup.pl file, put the 'use module'
       in there. If you want components to be able to refer to symbols exported by the module, however, you'll
       need to use the module inside the HTML::Mason::Commands package. See the "External modules" section of
       the Administrator's Guide.

   <b>How</b> <b>do</b> <b>I</b> <b>adjust</b> <b>Perl's</b> <b>INC</b> <b>path</b> <b>so</b> <b>it</b> <b>can</b> <b>find</b> <b>my</b> <b>modules?</b>
       You can do this:

           &lt;Perl&gt;
           use lib ...
           &lt;/Perl&gt;

       or this:

           PerlSetEnv PERL5LIB /path/one:/path/two:...

   <b>How</b> <b>do</b> <b>I</b> <b>use</b> <b>Mason</b> <b>in</b> <b>conjunction</b> <b>with</b> <b>UserDir</b> <b>to</b> <b>support</b> <b>Mason</b> <b>in</b> <b>user's</b> <b>home</b> <b>directories?</b>
       The idea is to create one ApacheHandler for each user, dynamically. You will need to use a handler.pl or
       other wrapper code (see "Writing a Wrapper" in the Adminstrator's Manual).

       Outside your handler subroutine:

              # $user_regexp: a regexp that matches the root directory of Mason.
              #               Make sure there is one arg in parens that represents
              #               the actual username--the handler uses this.
              my $user_regexp = qr'/Users/([^/]*)/(?:public_html|Sites)';
              my %user_handlers;

              # Create base ApacheHandler object at startup.
              my $base_ah = new HTML::Mason::ApacheHandler( comp_root =&gt; $comp_root,
                                                         data_dir  =&gt; $data_dir );

       Inside your handler subroutine:

              sub handler
              {
                  my $r=$_[0];
                  ...
                  #
                  # Have a different handler for each home directory
                  #
                  my $curr_ah;
                  my $filename = $r-&gt;filename();
                  if($filename =~ m!$user_regexp!) {
                      my $user_name = $1;
                      $curr_ah = $user_handlers{$user_name};
                      if(!$curr_ah) {
                          $filename =~ m!($user_regexp)!;
                          my $user_dir = $1;
                          $curr_ah = new HTML::Mason::ApacheHandler(comp_root=&gt;[[$user_name =&gt; $user_dir]],
                                                                    data_dir=&gt;$data_dir);
                          $user_handlers{$1} = $curr_ah;
                      }
                  } else {
                      $curr_ah = $base_ah;
                  }
                  my $status = $curr_ah-&gt;handle_request($r);

                  return $status;
              }

   <b>How</b> <b>do</b> <b>I</b> <b>connect</b> <b>to</b> <b>a</b> <b>database</b> <b>from</b> <b>Mason?</b>
       The short answer is that most any perl code that works outside Mason, for connecting to a database,
       should work inside a component. I sometimes do draft development and quick debugging with something like:

             &lt;%once&gt;
             use DBI;
             &lt;/%once&gt;

             &lt;%init&gt;
             my $dbh = DBI-&gt;connect ( blah, blah );
             ...
             &lt;/%init&gt;

       The long answer is, of course, longer. A good deal of thought should be put into how a web application
       talks to databases that it depends on, as these interconnections can easily be both performance
       bottlenecks and very un-robust.

       Most people use some sort of connection pooling -- opening and then re-using a limited number of database
       connections. The Apache::DBI module provides connection pooling that is reliable and nearly painless. If
       Apache::DBI has been use'd, DBI-&gt;<b>connect()</b> will transparently reuse an already open connections, if it
       can.

       The "right" place to ask Apache::DBI for database handles is often in a top level autohandler.

       For example:

             &lt;%init&gt;
             my $dbh = DBI-&gt;connect('dbi:mysq:somedb', 'user', 'pw');
             ... # other processing
             $m-&gt;call_next( %ARGS, dbh =&gt; $dbh );
             &lt;/%init&gt;

       Alternately, $dbh could be a global variable which you set via MasonAllowGlobals.

       You can use Apache::DBI in your httpd.conf file quite easily simply by adding:

             PerlModule Apache::DBI

       If you want to do more with Apache::DBI, like call connect_on_init, you can use a &lt;Perl&gt; section

             &lt;Perl&gt;
             use Apache::DBI;
             Apache::DBI-&gt;connect_on_init('dbi:mysql:somedb', 'user', 'pw');
             Apache::DBI-&gt;setPingTimeOut('dbi:mysql:somedb', 0);
             &lt;/Perl&gt;

       Others may simply use a handler.pl file. Georgiou Kiriakos writes:

             You can connect in the handler.pl - I find it convenient to setup a
             global $dbh in it.  You just need to make sure you connect inside
             the handler subroutine (using Apache::DBI of course).  This way a)
             each httpd gets it's own connection and b) each httpd reconnects if
             the database is recycled.

       Regardless of whether you set up global $dbh variables in handler.pl, the static sections of handler.pl
       should set up Apache::DBI stuff:

             # List of modules that you want to use from components (see Admin
             # manual for details)
             {
                package HTML::Mason::Commands;
                use Apache::DBI;
                # use'ing Apache::DBI here lets us connect from inside components
                # if we need to.
                # --
                # declare global variables, like $dbh, here as well.
              }

             # Configure database connection stuff
             my $datasource = "DBI:blah:blah";
             my $username = "user";
             my $password = "pass";
             my $attr = { RaiseError=&gt;1 ,AutoCommit=&gt;1 };
             Apache::DBI-&gt;connect_on_init($datasource, $username, $password, $attr);
             Apache::DBI-&gt;setPingTimeOut($datasource, 0);

   <b>How</b> <b>come</b> <b>a</b> <b>certain</b> <b>piece</b> <b>of</b> <b>Perl</b> <b>code</b> <b>runs</b> <b>fine</b> <b>under</b> <b>"regular"</b> <b>perl,</b> <b>but</b> <b>fails</b> <b>under</b> <b>Mason?</b>
       Mason is usually a red herring in this situation. Mason IS "regular" perl, with a very simple system to
       translate Mason component syntax to Perl code.  You can look at the object files Mason creates for your
       components (in the obj/ subdirectory of the Mason data directory) to see the actual Perl code Mason
       generates.

       If something suddenly stops working when you place it in a Mason environment, the problem is far more
       likely to rest with the following environmental changes than with Mason itself:

       * With mod_perl, the server is running under a different user/group and thus has different permissions
       for the resource you're trying to access

       * With mod_perl, code can stay resident in the perl interpreter for a long time.

       * Your headers may be sent differently under mod_perl than under your previous CGI situation (or whatever
       it was)

       Mason does not have anything to do with sending mail, or accessing a database, or maintaining user
       accounts, or server authentication, so if your problems are in areas like these, your time will be better
       spent looking at other environmental changes like the ones mentioned above.

   <b>I'm</b> <b>using</b> <b>HTML::Mason::!ApacheHandler</b> <b>and</b> <b>I</b> <b>have</b> <b>decline_dirs</b> <b>disabled</b> <b>and</b> <b>am</b> <b>using</b> <b>a</b> <b>dhandler</b> <b>to</b> <b>handle</b>
       <b>directory</b> <b>requests.</b> <b>But</b> <b>when</b> <b>a</b> <b>request</b> <b>comes</b> <b>in</b> <b>without</b> <b>the</b> <b>final</b> <b>slash</b> <b>after</b> <b>the</b> <b>directory</b> <b>name,</b>
       <b>relative</b> <b>links</b> <b>are</b> <b>broken.</b> <b>What</b> <b>gives?</b>
       Mason has always incorrectly handled such directory requests; this issue will be resolved in the 1.3
       release. The reason it will only be fixed in the next major version is that some folks may have come to
       rely on this functionality. So it's considered breaking backwards compatibility. But if you need it to do
       the right thing now, fear not! There are a number of workarounds to ensure that Apache adds a slash and
       redirects the browser to the appropriate URL. See HandlingDirectoriesWithDhandlers for all the juicy
       details.

       UPGRADING TO 1.1x

   <b>After</b> <b>upgrading,</b> <b>I</b> <b>see</b> <b>this</b> <b>error</b> <b>whenever</b> <b>I</b> <b>load</b> <b>a</b> <b>page:</b> <b>"The</b> <b>following</b> <b>parameter</b> <b>was</b> <b>passed</b> <b>in</b> <b>the</b> <b>call</b> <b>to</b>
       <b>HTML::Mason::Component::FileBased-&gt;new()</b> <b>but</b> <b>was</b> <b>not</b> <b>listed</b> <b>in</b> <b>the</b> <b>validation</b> <b>options:</b> <b>create_time"</b>
       Delete all of your object files.

   <b>When</b> <b>I</b> <b>try</b> <b>to</b> <b>start</b> <b>my</b> <b>server</b> <b>I</b> <b>see</b> <b>an</b> <b>error</b> <b>like:</b> <b>"The</b> <b>resolver</b> <b>class</b> <b>your</b> <b>Interp</b> <b>object</b> <b>uses</b> <b>does</b> <b>not</b>
       <b>implement</b> <b>the</b> <b>apache_request_to_comp_path'</b> <b>method.</b>
       This means that ApacheHandler cannot resolve requests.

       Are you using a handler.pl file created before version 1.10?  Please see the handler.pl sample that comes
       with the latest version of Mason.

       You are explicitly creating an Interp object in your handler.pl and then passing that to
       ApacheHandler-&gt;new.

       Instead, simply pass all of your Interp parameters to ApacheHandler-&gt;new directly. The parameters will
       end up going where they belong.

   <b>When</b> <b>I</b> <b>start</b> <b>Apache</b> <b>(or</b> <b>try</b> <b>to</b> <b>use</b> <b>Mason)</b> <b>I</b> <b>get</b> <b>an</b> <b>error</b> <b>like</b> <b>this:</b> <b>"The</b> <b>Parser</b> <b>module</b> <b>is</b> <b>no</b> <b>longer</b> <b>a</b> <b>part</b> <b>of</b>
       <b>HTML::Mason.</b>  <b>Please</b> <b>see</b> <b>the</b> <b>Lexer</b> <b>and</b> <b>Compiler</b> <b>modules,</b> <b>its</b> <b>replacements."</b>
       The Parser module is no longer used.

   <b>I</b> <b>get</b> <b>an</b> <b>error</b> <b>like:</b> <b>"The</b> <b>following</b> <b>parameters</b> <b>were</b> <b>passed</b> <b>in</b> <b>the</b> <b>call</b> <b>to</b> <b>HTML::Mason::Container::new</b> <b>but</b>
       <b>were</b> <b>not</b> <b>listed</b> <b>in</b> <b>the</b> <b>validation</b> <b>options:</b> <b>error_format</b> <b>error_mode</b> <b>request_class</b> <b>resolver_class"</b> <b>when</b>
       <b>using</b> <b>ApacheHandler</b>
       Do you have PerlFreshRestart turned on? Turn it off.

       See <a href="http://perl.apache.org/docs/1.0/guide/troubleshooting.html">http://perl.apache.org/docs/1.0/guide/troubleshooting.html</a> - "Evil things might happen when using
       PerlFreshRestart".

   <b>I</b> <b>get</b> <b>an</b> <b>error</b> <b>like</b> <b>this:</b> <b>'Can't</b> <b>locate</b> <b>object</b> <b>method</b> <b>"make_ah"</b>
       package "Apache"' === We're not kidding. PerlFreshRestart is evil. Turn it off. See question above.

   <b>I</b> <b>get:</b> <b>"Unknown</b> <b>config</b> <b>item</b> <b>'comp_root'"</b> <b>or</b> <b>"Unknown</b> <b>config</b> <b>item</b> <b>'comp_root'"</b> <b>or</b> <b>something</b> <b>similar</b> <b>with</b>
       <b>ApacheHandler.</b>
       Turn PerlFreshRestart off. Really.

   <b>I</b> <b>get</b> <b>this</b> <b>with</b> <b>a</b> <b>custom</b> <b>handler.pl:</b> <b>'Can't</b> <b>call</b> <b>method</b> <b>"handle_request"</b> <b>on</b> <b>an</b> <b>undefined</b> <b>value</b> <b>at</b> <b>...'</b>
       Just in case you weren't convinced that PerlFreshRestart is a bad idea, this should help convince you.

   <b>After</b> <b>upgrading,</b> <b>I</b> <b>get</b> <b>this</b> <b>error</b> <b>for</b> <b>all</b> <b>my</b> <b>components:</b> <b>'&lt;%'</b> <b>without</b> <b>matching</b> <b>'%&gt;'</b> <b>...</b>
       The "perl_' prefix for Mason tags, like &lt;%perl_args&gt;, is no longer supported. Remove this prefix.

</pre><h4><b>WHERE</b> <b>TO</b> <b>FIND</b> <b>INFORMATION</b></h4><pre>
   <b>Where</b> <b>do</b> <b>I</b> <b>obtain</b> <b>HTML::Mason?</b>
       HTML::Mason is available from CPAN (the Comprehensive Perl Archive Network). Details about CPAN are
       available at <a href="http://www.perl.com/">http://www.perl.com/</a>. See the [FAQ:Installation] section of this document for tips on
       obtaining and installing Mason.

   <b>Where</b> <b>can</b> <b>I</b> <b>ask</b> <b>questions</b> <b>about</b> <b>HTML::Mason?</b>
       See ContactUs and MailingLists.

perl v5.38.2                                       2024-03-05                              <u>HTML::Mason::<a href="../man3pm/FAQ.3pm.html">FAQ</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>