<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::FAQ - Frequently asked questions about PDL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/pdl">pdl_2.100-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::FAQ - Frequently asked questions about PDL

</pre><h4><b>VERSION</b></h4><pre>
       Current FAQ version:  1.008

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is version 1.008 of the PDL FAQ, a collection of  frequently asked questions about PDL - the Perl
       Data Language.

</pre><h4><b>ABOUT</b> <b>THIS</b> <b>DOCUMENT</b></h4><pre>
   <b>Q:</b> <b>1.1</b>    <b>Where</b> <b>to</b> <b>find</b> <b>this</b> <b>document</b>
       You can find the latest version of this document at
       &lt;<a href="http://pdl.perl.org/">http://pdl.perl.org/</a>?docs=FAQ&amp;title=Frequently%20Asked%20Questions&gt; .

   <b>Q:</b> <b>1.2</b>    <b>How</b> <b>to</b> <b>contribute</b> <b>to</b> <b>this</b> <b>document</b>
       This is a considerably reworked version of the PDL FAQ. As such many errors might have crept in and many
       updates might not have made it in.  You are explicitly encouraged to let us know about questions which
       you think should be answered in this document but currently aren't.

       Similarly, if you think parts of this document are unclear, please tell the FAQ maintainer about it.
       Where a specific answer is taken in full from someones posting the authorship should be indicated, let
       the FAQ maintainer know if it isn't. For more general information explicit acknowledgment is not made in
       the text, but rather there is an incomplete list of contributors at the end of this document. Please
       contact the FAQ maintainer if you feel hard done by.

       Send your comments, additions, suggestions or corrections to the PDL mailing list at
       <a href="mailto:pdl-general@lists.sourceforge.net">pdl-general@lists.sourceforge.net</a>.  See Q: 3.2 below for instructions on how to join the mailing lists.

</pre><h4><b>GENERAL</b> <b>QUESTIONS</b></h4><pre>
   <b>Q:</b> <b>2.1</b>    <b>What</b> <b>is</b> <b>PDL</b> <b>?</b>
       PDL stands for <u>Perl</u> <u>Data</u>  <u>Language</u> . To say it with the words of Karl Glazebrook, initiator of the PDL
       project:

           The PDL concept is to give standard perl5 the ability
           to COMPACTLY store and SPEEDILY manipulate the large
           N-dimensional data sets which are the bread and butter
           of scientific computing. e.g. $x=$y+$z can add two
           2048x2048 images in only a fraction of a second.

       It provides tons of useful functionality for scientific and numeric analysis.

       For readers familiar with other scientific data evaluation packages it may be helpful to add that PDL is
       in many respects similar to IDL, MATLAB and similar packages. However, it tries to improve on a number of
       issues which were perceived (by the authors of PDL) as shortcomings of those existing packages.

   <b>Q:</b> <b>2.2</b>    <b>Who</b> <b>supports</b> <b>PDL?</b> <b>Who</b> <b>develops</b> <b>it?</b>
       PDL is supported by its users. General informal support for PDL is provided through the PDL mailing list
       (<a href="mailto:pdl-general@lists.sourceforge.net">pdl-general@lists.sourceforge.net</a> , see below).

       As a Perl extension (see Q: 2.5 below) it is devoted to the idea of free and open development put forth
       by the Perl community. PDL was and is being actively developed by a loosely knit group of people around
       the world who coordinate their activities through the PDL development mailing list
       (<a href="mailto:pdl-devel@lists.sourceforge.net">pdl-devel@lists.sourceforge.net</a> , see Q: 3.2 below). If you would like to join in the ongoing efforts to
       improve PDL please join this list.

   <b>Q:</b> <b>2.3</b>    <b>Why</b> <b>yet</b> <b>another</b> <b>Data</b> <b>Language</b> <b>?</b>
       There are actually several reasons and everyone should decide for themselves which are the most important
       ones:

       •   PDL  is  "free software". The authors of PDL think that this concept has several advantages: everyone
           has access to the sources -&gt; better debugging, easily adaptable to your  own  needs,  extensible  for
           your  purposes,  etc...  In  comparison  with  commercial  packages such as MATLAB and IDL this is of
           considerable importance for workers who  want  to  do  some  work  at  home  and  cannot  afford  the
           considerable cost to buy commercial packages for personal use.

       •   PDL  is  based  on  a  powerful  and  well  designed  scripting  language: Perl. In contrast to other
           scientific/numeric data analysis languages it has been  designed  using  the  features  of  a  proven
           language  instead  of having grown into existence from scratch. Defining the control structures while
           features were added during development leads to languages that often appear clumsy and badly  planned
           for most existing packages with similar scope as PDL.

       •   Using  Perl  as the basis a PDL programmer has all the powerful features of Perl at their hand, right
           from the start. This  includes  regular  expressions,  associative  arrays  (hashes),  well  designed
           interfaces  to  the  operating  system,  network,  etc.  Experience  has  shown  that  even in mainly
           numerically oriented programming it is often extremely handy if you  have  easy  access  to  powerful
           semi-numerical  or  completely  non-numerical  functionality  as well. For example, you might want to
           offer the results of a complicated computation as a server process to other processes on the network,
           perhaps directly accepting input from other processes on the network. Using Perl  and  existing  Perl
           extension  packages  things  like  this  are  no  problem  at all (and it all will fit into your "PDL
           script").

       •   Extremely easy extensibility and interoperability as PDL is a Perl extension; development support for
           Perl extensions is an integral part of Perl and there are already  numerous  extensions  to  standard
           Perl freely available on the network.

       •   Integral   language  features  of  Perl  (regular  expressions,  hashes,  object  modules)  immensely
           facilitated development and implementation of key concepts of PDL. One of the most striking  examples
           for  this  point  is probably PDL::PP (see Q: 6.16 below), a code generator/parser/pre-processor that
           generates PDL functions from concise descriptions.

       •   None of the existing data languages follow the Perl language rules, which the authors firmly  believe
           in:

           •   TIMTOWTDI:  There  is  more  than  one  way  to  do it.  Minimalist languages are interesting for
               computer scientists, but for users, a little bit of redundancy makes things wildly easier to cope
               with and allows individual programming styles - just as people speak in different ways. For  many
               people this will undoubtedly be a reason to avoid PDL ;)

           •   Simple  things are simple, complicated things possible: Things that are often done should be easy
               to do in the language, whereas seldom done things shouldn't be too cumbersome.

           All existing languages violate at least one of these rules.

       •   As a project for the future  PDL  should  be  able  to  use  super  computer  features,  e.g.  vector
           capabilities/parallel  processing,  GPGPU  acceleration.  This  will  probably  be achieved by having
           PDL::PP (see Q: 6.16 below)  generate  appropriate  code  on  such  architectures  to  exploit  these
           features.

       •   [ fill in your personal 111 favourite reasons here...]

   <b>Q:</b> <b>2.4</b>    <b>What</b> <b>is</b> <b>PDL</b> <b>good</b> <b>for</b> <b>?</b>
       Just  in case you do not yet know what the main features of PDL are and what one could do with them, here
       is a (necessarily selective) list of key features:

       PDL is well suited for matrix computations, general handling of multidimensional data, image  processing,
       general  scientific  computation, numerical applications. It supports I/O for many popular image and data
       formats, 1D (line plots), 2D (images) and 3D (volume  visualization,  surface  plots  via  OpenGL  -  for
       instance  implemented  using  Mesa  or  video  card  OpenGL  drivers),  graphics display capabilities and
       implements many numerical and semi-numerical algorithms.

       Through the powerful pre-processor it is also easy to interface Perl to your favorite C routines, more of
       that further below.

   <b>Q:</b> <b>2.5</b>    <b>What</b> <b>is</b> <b>the</b> <b>connection</b> <b>between</b> <b>PDL</b> <b>and</b> <b>Perl</b> <b>?</b>
       PDL is a Perl5 extension package. As such it needs an existing Perl5 installation  (see  below)  to  run.
       Furthermore,  much  of  PDL  is  written  in  Perl  (+ some core functionality that is written in C). PDL
       programs are (syntactically) just Perl scripts that happen to use some of the  functionality  implemented
       by the package "PDL".

   <b>Q:</b> <b>2.6</b>    <b>What</b> <b>do</b> <b>I</b> <b>need</b> <b>to</b> <b>run</b> <b>PDL</b> <b>on</b> <b>my</b> <b>machine</b> <b>?</b>
       Since  PDL  is just a Perl5 package you need first of all an installation of Perl5 on your machine. As of
       this writing PDL requires version 5.10.x of perl, or higher.  More information on where and how to get  a
       Perl installation can be found at the Perl home page &lt;<a href="http://www.perl.org">http://www.perl.org</a>&gt; and at many CPAN sites (if you
       do not know what <u>CPAN</u> is, check the answer to the next question).

       To  build PDL you also need a working C compiler, support for Xsubs, and the package Extutils::MakeMaker.
       If you don't have a compiler there might be a binary distribution available, see  "Binary  distributions"
       below.

       If  you  can (or cannot) get PDL working on a new (previously unsupported) platform we would like to hear
       about    it.    Please,    report    your    success/failure    to    the    PDL    mailing    list    at
       <a href="mailto:pdl-general@lists.sourceforge.net">pdl-general@lists.sourceforge.net</a> . We will do our best to assist you in porting PDL to a new system.

   <b>Q:</b> <b>2.7</b>    <b>Where</b> <b>do</b> <b>I</b> <b>get</b> <b>it?</b>
       PDL  is available as source distribution in the <u>Comprehensive</u> <u>Perl</u> <u>Archive</u> <u>Network</u> (or CPAN) and from the
       GitHub project page at &lt;https://github.com/PDLPorters/pdl&gt;.  The CPAN archives contains not only the  PDL
       distribution  but  also  just  about everything else that is Perl-related.  CPAN is mirrored by dozens of
       sites all over the world.  The main site is &lt;<a href="http://www.cpan.org">http://www.cpan.org</a>&gt;, and local CPAN sites (mirrors) can  be
       found  there.  PDL's  homepage  is at &lt;<a href="http://pdl.perl.org">http://pdl.perl.org</a>&gt; and the latest version can also be downloaded
       from there.

   <b>Q:</b> <b>2.8</b>    <b>What</b> <b>do</b> <b>I</b> <b>have</b> <b>to</b> <b>pay</b> <b>to</b> <b>get</b> <b>PDL?</b>
       We are delighted to be able to give you the nicest possible answer on a question like this: PDL is  *free
       software* and all sources are publicly available. But still, there are some copyrights to comply with. So
       please, try to be as nice as we (the PDL authors) are and try to comply with them.

       Oh,  before you think it is *completely* free: you have to invest some time to pull the distribution from
       the net, compile and install it and (maybe) read the manuals.

</pre><h4><b>GETTING</b> <b>HELP/MORE</b> <b>INFORMATION</b></h4><pre>
   <b>Q:</b> <b>3.1</b>    <b>Where</b> <b>can</b> <b>I</b> <b>get</b> <b>information</b> <b>on</b> <b>PDL?</b>
       The complete PDL documentation is available with the PDL distribution.  Use the command "perldoc PDL"  to
       start learning about PDL.

       The  easiest  way  by far, however, to get familiar with PDL is to use the PDL on-line help facility from
       within the PDL shell, "perldl"  Just type "perldl" at  your  system  prompt.  Once  you  are  inside  the
       "perldl" shell type "help" .  Using the "help" and "apropos" commands inside the shell you should be able
       to find the way round the documentation.

       Even better, you can immediately try your newly acquired knowledge about PDL by issuing PDL/Perl commands
       directly  at  the  command  line.  To  illustrate  this process, here is the record of a typical "perldl"
       session of a PDL beginner (lengthy output is only symbolically reproduced in braces ( &lt;... ...&gt; ) ):

           unix&gt; perldl
           pdl&gt; help
           &lt; ... help output ... &gt;
           pdl&gt; help PDL::QuickStart
           &lt; ... perldoc page ... &gt;
           pdl&gt; $x = pdl (1,5,7.3,1.0)
           pdl&gt; $y = sequence float, 4, 4
           pdl&gt; help inner
           &lt; ... help on the 'inner' function ... &gt;
           pdl&gt; $c = inner $x, $y
           pdl&gt; p $c
           [22.6 79.8 137 194.2]

       For further sources of information that are accessible through the Internet see next question.

   <b>Q:</b> <b>3.2</b>    <b>Are</b> <b>there</b> <b>other</b> <b>PDL</b> <b>information</b> <b>sources</b> <b>on</b> <b>the</b> <b>Internet?</b>
       First of all, for all purely Perl-related questions there are tons of sources on the net. Good points  to
       start are &lt;<a href="http://www.perl.com">http://www.perl.com</a>&gt; and &lt;<a href="http://www.perl.org">http://www.perl.org</a>&gt; .

       The  PDL home site can be accessed by pointing your web browser to &lt;<a href="http://pdl.perl.org">http://pdl.perl.org</a>&gt; . It has tons of
       goodies for anyone interested in PDL:

       •   PDL distributions

       •   On-line documentation

       •   Pointers to an HTML archive of the PDL mailing lists

       •   A list of platforms on which PDL has been successfully tested.

       •   News about recently added features, ported libraries, etc.

       •   Name of the current pumpkin holders for the different PDL modules (if you  want  to  know  what  that
           means you better had a look at the web pages).

       If  you  are  interested  in PDL in general you can join the pdl-general mailing list. This is a forum to
       discuss programming issues in PDL, report bugs, seek assistance with PDL related problems, etc.

       If you are interested in all the technical details of the ongoing PDL development you can join  the  pdl-
       devel mailing list.

       Subscription    and    current    archive    links    to   both   mailing   lists   can   be   found   at
       &lt;<a href="http://pdl.perl.org/">http://pdl.perl.org/</a>?page=mailing-lists&gt;.

       Cross-posting between these lists should be avoided unless there is a <u>very</u> good reason for doing that.

       The PDL project, begun in the late 1990s, has undergone considerable evolution since that time,  and  the
       support for it has as well. Thus mailing-list archives are in several places.  Originally pdl-general was
       called 'perldl', and pdl-devel was called 'pdl-porters'.

         |Time Period | URL                                                   |
         |------------|-------------------------------------------------------|
         |1996 - 2004 | <a href="http://www.xray.mpe.mpg.de/mailing-lists/perldl/">http://www.xray.mpe.mpg.de/mailing-lists/perldl/</a>      |
         |1997 - 2004 | <a href="http://www.xray.mpe.mpg.de/mailing-lists/pdl-porters/">http://www.xray.mpe.mpg.de/mailing-lists/pdl-porters/</a> |
         |2005 - 2015 | <a href="http://perldl.jach.hawaii.narkive.com/">http://perldl.jach.hawaii.narkive.com/</a>                |
         |2005 - 2015 | <a href="http://pdl-porters.jach.hawaii.narkive.com/">http://pdl-porters.jach.hawaii.narkive.com/</a>           |
         |2015 -      | https://sourceforge.net/p/pdl/mailman/pdl-general/    |
         |2015 -      | https://sourceforge.net/p/pdl/mailman/pdl-devel/      |
         |--------------------------------------------------------------------|

   <b>Q:</b> <b>3.3</b>    <b>What</b> <b>is</b> <b>the</b> <b>current</b> <b>version</b> <b>of</b> <b>PDL</b> <b>?</b>
       As  of  this  writing  (FAQ version 1.008 of 21 May 2017) the latest stable version is 2.018.  The latest
       stable version should always be available from a CPAN mirror site near you (see Question 2.7 for info  on
       where to get PDL).

       The most current (possibly unstable) version of PDL can be obtained from the Git repository, see Question
       4.10  and  periodic  CPAN  developers releases of the Git code will be made for testing purposes and more
       general availability.

   <b>Q:</b> <b>3.4</b>  <b>How</b> <b>can</b> <b>PDL-2.2</b> <b>be</b> <b>older</b> <b>than</b> <b>PDL-2.007?</b>
       Over its development, PDL has used both a single floating point version number  (from  the  versions  1.x
       through  2.005)  at  which  point  it  switched  to a dotted triple version for 2.1.1 onward---EXCEPT for
       version 2.2 which came out which should have been 2.2.0.  To simplify and unify things, PDL has  reverted
       to  a single float version representation with PDL-2.006.  This can cause dependency problems for modules
       that set a minimum PDL version of 2.2.  The work around it,  note  that  all  extant  PDL  releases  have
       version numbers greater than 2.2.1 so that using 0 as the minimum version will work.

   <b>Q:</b> <b>3.5</b>    <b>I</b> <b>want</b> <b>to</b> <b>contribute</b> <b>to</b> <b>the</b> <b>further</b> <b>development</b> <b>of</b> <b>PDL.</b> <b>How</b> <b>can</b> <b>I</b> <b>help?</b>
       Two  ways  that you could help almost immediately are (1) participate in CPAN Testers for PDL and related
       modules, and (2) proofreading and clarifying the PDL documentation so that it is  most  useable  for  PDL
       users, especially new users.

       To     participate     in     CPAN     Testers     and     contribute     test    reports,    the    page
       &lt;<a href="http://wiki.cpantesters.org/wiki/QuickStart">http://wiki.cpantesters.org/wiki/QuickStart</a>&gt;  has  instructions  for  starting  for  either  "CPAN"   or
       "CPANPLUS" users.

       If  you  have  a certain project in mind you should check if somebody else is already working on it or if
       you could benefit from existing modules. Do so by posting your planned  project  to  the  PDL  developers
       mailing  list at <a href="mailto:pdl-devel@lists.sourceforge.net">pdl-devel@lists.sourceforge.net</a> . See the subscription instructions in Question 3.2.  We
       are always looking for people to write code and/or documentation.  The Developer  Guide  should  get  you
       started.

   <b>Q:</b> <b>3.6</b>    <b>I</b> <b>think</b> <b>I</b> <b>have</b> <b>found</b> <b>a</b> <b>bug</b> <b>in</b> <b>the</b> <b>current</b> <b>version</b> <b>of</b> <b>PDL.</b> <b>What</b> <b>shall</b> <b>I</b> <b>do?</b>
       First,  make  sure that the bug/problem you came across has not already been dealt with somewhere else in
       this FAQ.  Secondly, you can check the searchable archive of the PDL mailing lists to find  whether  this
       bug has already been discussed.  If you still haven't found any explanations you can post a bug report to
       <a href="mailto:pdl-general@lists.sourceforge.net">pdl-general@lists.sourceforge.net</a>  ,  or  through  the Bugs link on &lt;<a href="http://pdl.perl.org">http://pdl.perl.org</a>&gt; .  See the <u>BUGS</u>
       file in the PDL distribution for what information to include.  If you are  unsure,  discussions  via  the
       perldl mailing list can be most helpful.

</pre><h4><b>INSTALLATION</b></h4><pre>
   <b>Q:</b> <b>4.1</b>    <b>I</b> <b>have</b> <b>problems</b> <b>installing</b> <b>PDL.</b> <b>What</b> <b>shall</b> <b>I</b> <b>do?</b>
       First  make  sure  you  have  read  the file <u>INSTALL</u> in the distribution.  This contains a list of common
       problems which are unnecessary to repeat here.

       Next, check the file <u>perldl.conf</u> to see if by editing the configuration options in that file you will  be
       able  to  successfully build PDL. Some of the modules need additional software installed, please refer to
       the file <u>DEPENDENCIES</u> for further  details.  Make  sure  to  edit  the  location  of  these  packages  in
       perldl.conf if you have them in non-standard locations.

       N.B.  Unix shell specific: If you would like to save an edited perldl.conf for future builds just copy it
       as <u><a href="file:~/.perldl.conf">~/.perldl.conf</a></u> into your home directory where it will be picked up automatically during the PDL  build
       process.

       Also,  check  for another, pre-existing version of PDL on the build system.  Multiple PDL installs in the
       same PATH or @INC can cause puzzling test or build failures.

       If you still can't make it work properly please submit a bug report including detailed information on the
       problems you encountered to the perldl  mailing  list  (  <a href="mailto:pdl-general@lists.sourceforge.net">pdl-general@lists.sourceforge.net</a>  ,  see  also
       above). Response is often rapid.

   <b>Q:</b> <b>4.2</b>    <b>Are</b> <b>there</b> <b>configuration</b> <b>files</b> <b>for</b> <b>PDL</b> <b>I</b> <b>have</b> <b>to</b> <b>edit?</b>
       Most  users  should  not have to edit any configuration files manually.  However, in some cases you might
       have to supply some information about awkwardly placed include  files/libraries  or  you  might  want  to
       explicitly  disable  building  some of the optional PDL modules.  Check the files <u>INSTALL</u> and <u>perldl.conf</u>
       for details.

       If you had to manually edit <u>perldl.conf</u> and are happy with the results you can keep the  file  handy  for
       future  reference.  Place  it  in  <u><a href="file:~/.perldl.conf">~/.perldl.conf</a></u>  where  it will be picked up automatically or use "perl
       Makefile.PL  PDLCONF=your_file_name" next time you build PDL.

   <b>Q:</b> <b>4.3</b>    <b>Do</b> <b>I</b> <b>need</b> <b>other</b> <b>software</b> <b>for</b> <b>successful</b> <b>operation?</b>
       For the basic PDL functionality you don't need any additional software.  However, some  of  the  optional
       PDL  modules  included  in  the distribution (notably most graphics and some I/O modules) require certain
       other libraries/programs to be installed. Check the file <u>DEPENDENCIES</u> in the distribution for details and
       directions on how to get these.

   <b>Q:</b> <b>4.4</b>    <b>How</b> <b>can</b> <b>I</b> <b>install</b> <b>PDL</b> <b>in</b> <b>a</b> <b>non-standard</b> <b>location?</b>
       To install PDL in a non-standard  location,  use  the  INSTALL_BASE  option  in  the  "perl  Makefile.PL"
       configure  step.  For example, "perl Makefile.PL INSTALL_BASE=/mydir/perl5" will configure PDL to install
       into the tree rooted at "/mydir/perl5".  For more details see  "How  do  I  keep  my  own  module/library
       directory?"  in  perlfaq8  and  subsequent  sections.  Another alternative is to use local::lib to do the
       heavy lifting for the needed configuration.

   <b>Q:</b> <b>4.5</b>    <b>How</b> <b>can</b> <b>I</b> <b>force</b> <b>a</b> <b>completely</b> <b>clean</b> <b>installation?</b>
       To guarantee a completely clean  installation  of  PDL,  you  will  need  to  first  delete  the  current
       installation  files  and folders.  These will be all directories named "PDL" in the Perl @INC path, files
       named "*Pdlpp*" in any "Inline" directories, and the programs  "pdl,  pdldoc,  perldl,  and  pptemplate".
       Then  just  build and install as usual.  This is much easier to keep track of if you always install "PDL"
       into a non-standard location.  See Q: 4.4 above.

</pre><h4><b>BINARY</b> <b>DISTRIBUTIONS</b></h4><pre>
   <b>Q:</b> <b>4.5</b>    <b>What</b> <b>binary</b> <b>distributions</b> <b>are</b> <b>available?</b>
       Information about binary distributions of PDL can be found on &lt;<a href="http://pdl.perl.org">http://pdl.perl.org</a>&gt; .  At  present  there
       are binary distributions of PDL for Linux (RedHat and Debian), FreeBSD, Mac OS X and Windows, though they
       might not be the most recent version.

       If  someone  is  interested in providing binary distributions for other architectures, that would be very
       welcome. Let us  know  on  the  <a href="mailto:pdl-devel@lists.sourceforge.net">pdl-devel@lists.sourceforge.net</a>  mailing  list.  Also  check  your  Linux
       distribution's  package  manager as many now include PDL.  PPMs for win32 versions (both 32bit and 64bit)
       are also available.

   <b>Q:</b> <b>4.6</b>    <b>Does</b> <b>PDL</b> <b>run</b> <b>on</b> <b>Linux?</b> <b>(And</b> <b>what</b> <b>about</b> <b>packages?)</b>
       Yes, PDL does run  on  Linux  and  indeed  much  of  the  development  has  been  done  under  Linux.  On
       &lt;<a href="http://pdl.perl.org">http://pdl.perl.org</a>&gt; you can find links to packages for some of the major distributions. Also check your
       distribution's package manager (yum, apt, urpmi, ...)  as PDL is now found by many of these.

   <b>Q:</b> <b>4.7</b>    <b>Does</b> <b>PDL</b> <b>run</b> <b>under</b> <b>Windows?</b>
       PDL  builds  fine  on  Win32  using  MinGW or Microsoft compilers.  See the <u>win32/INSTALL</u> file in the PDL
       source distribution for details.  Other compilers have not been tested--input is welcome.  There is  also
       a  distribution  of  PDL  through  ActiveState's  ppm,  though it might not always be the latest version.
       PDL-2.018 builds out of the box on Strawberry Perl and ActiveState Perl and there  are  distributions  of
       Strawberry Perl with bundled PDL (see &lt;<a href="http://strawberryperl.com/releases.html">http://strawberryperl.com/releases.html</a>&gt;).

</pre><h4><b>CVS,</b> <b>GIT,</b> <b>AND</b> <b>ON-GOING</b> <b>DEVELOPMENT</b></h4><pre>
   <b>Q:</b> <b>4.8</b>    <b>Can</b> <b>I</b> <b>get</b> <b>PDL</b> <b>via</b> <b>CVS?</b>
       No.  PDL development was conducted with a CVS repository from December 1999 to April 2009.  In April 2009
       the project switched to the Git version control system (see &lt;<a href="http://git-scm.com">http://git-scm.com</a>&gt;).

   <b>Q:</b> <b>4.9</b>    <b>How</b> <b>do</b> <b>I</b> <b>get</b> <b>PDL</b> <b>via</b> <b>Git?</b>
       Assume  you  have  Git  installed  on  your  system and want to download the project source code into the
       directory "PDL". To get read-only access to the repository, you type at the command line

          git clone git://github.com/PDLPorters/pdl

       If   you   wish   to   submit   changes   to   PDL,   you   should    "fork"    the    repository    from
       &lt;https://github.com/PDLPorters/pdl&gt;, then clone your fork in the normal fashion.

       To become an official PDL developer, you will need to be added to the GitHub "PDLPorters" organisation.

       For official PDL developers, to get read/write access to the repository type at the command line

          git clone git://github.com/PDLPorters/pdl

       They  can still use their own fork; at least one active developer uses that model rather than branches on
       the main repository.

   <b>Q:</b> <b>4.10</b>   <b>I</b> <b>had</b> <b>a</b> <b>problem</b> <b>with</b> <b>the</b> <b>Git</b> <b>version,</b> <b>how</b> <b>do</b> <b>I</b> <b>check</b> <b>if</b> <b>someone</b> <b>has</b> <b>submitted</b> <b>a</b> <b>patch?</b>
       The best way is to check &lt;https://github.com/PDLPorters/pdl/pulls&gt; to see if  somebody  has  submitted  a
       pull request related to your problem.

       In  addition,  if  you  are not subscribing to the mailing list, check the archive of the "pdl-devel" and
       "pdl-general" mailing lists.  See Question 3.2 for details.

   <b>Q:</b> <b>4.11</b>   <b>I</b> <b>have</b> <b>gotten</b> <b>developer</b> <b>access</b> <b>to</b> <b>Git,</b> <b>how</b> <b>do</b> <b>I</b> <b>upload</b> <b>my</b> <b>changes?</b>
       The first thing you should do is to read the Git documentation and learn the basics about Git. There  are
       many sources available online.  It is very important that you use Git "best practice", with branches, but
       fortunately this is very easy! Here are the basics.

       Make sure your copy is up to date with the main repo:

          git checkout master
          git pull --rebase # rebase in case you wrongly changed your own master

       Make a branch:

          git checkout -b mybranch-name

       Commit your changes locally:

          git add &lt;file1&gt; &lt;file2&gt; ...
          git commit

       or combine these two with:

          git commit -a

       Test  the  PDL before you push it to the main repository.  If the code is broken for you, then it is most
       likely broken for others.  Luckily, the rest of this process will test that  automatically  to  help  you
       catch such errors.

       Then update the shared repository with your changes:

          git push -u origin mybranch-name

       This  will  still  leave  your  changes  on  a  branch,  but  this  is  good.  Now go to the GitHub page,
       &lt;https://github.com/PDLPorters/pdl&gt;. It will ask you whether you want to make a "pull request" - you  do.
       Follow  the  prompts.  This will then initiate the automated "continuous integration" tests, on Linux and
       Windows, with various versions of Perl, with various compilers. You will also want to get  at  least  one
       other developer to review your changes.

       Once this review process is successfully completed, you can merge your changes to the master branch!

</pre><h4><b>PDL</b> <b>JARGON</b></h4><pre>
   <b>Q:</b> <b>5.1</b>    <b>What</b> <b>is</b> <b>broadcasting</b> <b>(is</b> <b>PDL</b> <b>a</b> <b>newsreader)?</b>
       Until  2.075,  "threading"  was  used  to refer to two ideas, but that ambiguity has now been resolved by
       using the now (as  of  2022)  industry-standard  term  "broadcasting"  for  the  vectorisation  /  array-
       programming concept.

       •   When  mentioned  in  the  <u>INSTALL</u>  directions and possibly during the build process we have the usual
           computer science meaning of multi-threading in mind (useful  mainly  on  multiprocessor  machines  or
           clusters), currently (as of 2.074) POSIX threads (see PDL::ParallelCPU).

       •   PDL  broadcasting of operations on ndarrays (as mentioned in the indexing docs) is the iteration of a
           basic operation over appropriate sub-slices of ndarrays, e.g. the inner product "inner $x, $y"  of  a
           (3) pdl $x and a (3,5,4) pdl $y results in a (5,4) ndarray where each value is the result of an inner
           product of the (3) pdl with a (3) sub-slice of the (3,5,4) ndarray.  For details check PDL::Indexing

       The connection is that broadcasting divides up independent operations that can be done in parallel.

   <b>Q:</b> <b>5.2</b>    <b>What</b> <b>is</b> <b>an</b> <b>ndarray?</b>
       Well,  PDL  scalar  variables  (which  are  instances of a particular class of Perl objects, i.e. blessed
       thingies (see "perldoc perlobj" )) are in common PDL parlance often called <u>ndarrays</u> (for  example,  check
       the  mailing  list  archives).   Err, clear?  If not, simply use the term <u>ndarray</u> when you refer to a PDL
       variable (an instance of a PDL object as you might remember) regardless  of  what  actual  data  the  PDL
       variable contains.

</pre><h4><b>TECHNICAL</b> <b>QUESTIONS</b></h4><pre>
   <b>Q:</b> <b>6.1</b>    <b>What</b> <b>is</b> <b>perldl?</b>
       Sometimes  "perldl"  is  used  as  a  synonym  for  PDL. Strictly speaking, however, the name "perldl" is
       reserved for the little shell that comes with the PDL distribution and is supposed to  be  used  for  the
       interactive prototyping of PDL scripts. For details check perldl.

   <b>Q:</b> <b>6.2</b>    <b>How</b> <b>do</b> <b>I</b> <b>get</b> <b>on-line</b> <b>help</b> <b>for</b> <b>PDL?</b>
       Just  type  "help"  (shortcut  = "?") at the "perldl" shell prompt and proceed from there. Another useful
       command is the "apropos" (shortcut = "??") command.  Also try the "demo" command in the "perldl" shell if
       you are new to PDL.

</pre><h4><b>MANIPULATION</b> <b>OF</b> <b>NDARRAYS</b></h4><pre>
   <b>Q:</b> <b>6.3</b>    <b>I</b> <b>want</b> <b>to</b> <b>access</b> <b>the</b> <b>third</b> <b>element</b> <b>of</b> <b>a</b> <b>pdl</b> <b>but</b> <b>$x[2]</b> <b>doesn't</b> <b>work</b> <b>?!</b>
       See answer to the next question why the normal Perl array syntax doesn't work for ndarrays.

   <b>Q:</b> <b>6.4</b>    <b>The</b> <b>docs</b> <b>say</b> <b>ndarrays</b> <b>are</b> <b>some</b> <b>kind</b> <b>of</b> <b>array.</b> <b>But</b> <b>why</b> <b>doesn't</b>  <b>the</b>  <b>Perl</b>  <b>array</b>  <b>syntax</b>  <b>work</b>  <b>with</b>
       <b>ndarrays</b> <b>then</b> <b>?</b>
       OK,  you  are right in a way. The docs say that ndarrays can be thought of arrays.  More specifically, it
       says ( PDL::QuickStart ):

           I find when using the Perl Data Language it is most useful
           to think of standard Perl @x variables as "lists" of generic
           "things" and PDL variables like $x as "arrays" which can be
           contained in lists or hashes.

       So, while ndarrays can be thought of as some kind of multi-dimensional array they are  <b>not</b> arrays in  the
       Perl  sense.  Rather,  from  the  point  of  view of Perl they are some special class (which is currently
       implemented as an opaque pointer to some stuff in  memory)  and  therefore  need  special  functions  (or
       'methods'  if  you  are  using  the OO version) to access individual elements or a range of elements. The
       functions/methods to check are "at" / "set" (see the section  'Sections'  in  PDL::QuickStart  )  or  the
       powerful "slice" function and friends (see PDL::Slices and PDL::Indexing and especially PDL::NiceSlice ).

       Finally,  to  confuse  you completely, you can have Perl arrays of ndarrays, e.g. $spec[3] can refer to a
       pdl representing ,e.g, a spectrum, where $spec[3] is the fourth element of the Perl  list  (or  array  ;)
       @spec .  This may be confusing but is very useful !

   <b>Q:</b> <b>6.5</b>    <b>How</b> <b>do</b> <b>I</b> <b>concatenate</b> <b>ndarrays?</b>
       Most  people  will  try to form new ndarrays from old ndarrays using some variation over the theme: "$x =
       pdl([$y, 0, 2])".  This does work, but may not work in the way that a novice user would  expect.  (If  $y
       has  N  dimensions  then  $x will have N+1 dimensions.) Other ways to concatenate ndarrays are to use the
       functions "cat", "append", and "glue". Similarly you can split ndarrays using the command "dog".

   <b>Q:</b> <b>6.6</b>    <b>Sometimes</b> <b>I</b> <b>am</b> <b>getting</b> <b>these</b> <b>strange</b> <b>results</b> <b>when</b> <b>using</b> <b>inplace</b>  <b>operations?</b>
       This question is related to the "inplace" function. From the documentation (see PDL::QuickStart):

           Most functions, e.g. log(), return a result which is a
           transformation of their argument. This makes for good
           programming practice. However many operations can be done
           "in-place" and this may be required when large arrays are in
           use and memory is at a premium. For these circumstances the
           operator inplace() is provided which prevents the extra copy
           and allows the argument to be modified. e.g.:

           $x = log($array);          # $array unaffected
           log( inplace($bigarray) ); # $bigarray changed in situ

       And also from the doc !!:

           Obviously when used with some functions which can not be
           applied in situ (e.g. convolve()) unexpected effects may
           occur!

       As of PDL 2.099, all functions' inplace capability are automatically inserted in their documentation.

   <b>Q:</b> <b>6.7</b>    <b>What</b> <b>is</b> <b>this</b> <b>strange</b> <b>usage</b> <b>of</b> <b>the</b> <b>string</b> <b>concatenation</b> <b>operator</b>  <b>".="</b>  <b>in</b> <b>PDL</b> <b>scripts?</b>
       See next question on assignment in PDL.

   <b>Q:</b> <b>6.8</b>    <b>Why</b> <b>are</b> <b>there</b> <b>two</b> <b>different</b> <b>kinds</b> <b>of</b> <b>assignment</b> <b>in</b> <b>PDL</b> <b>?</b>
       This is caused by the fact that currently the assignment operator "=" allows only restricted overloading.
       For some purposes of PDL it turned out to be necessary to have more control over the  overloading  of  an
       assignment operator. Therefore, PDL peruses the operator ".=" for certain types of assignments.

   <b>Q:</b> <b>6.9</b>    <b>How</b> <b>do</b> <b>I</b> <b>set</b> <b>a</b> <b>set</b> <b>of</b> <b>values</b> <b>in</b> <b>an</b> <b>ndarray?</b>
       In Perl 5.6.7 and higher this assignment can be made using lvalue subroutines:

           pdl&gt; $x = <a href="../man5/sequence.5.html">sequence</a>(5); p $x
           [0 1 2 3 4]
           pdl&gt; $x-&gt;slice('1:2') .= pdl([5,6])
           pdl&gt; p $x
           [0 5 6 3 4]

       PDL also supports a more matrix-like slice syntax via the PDL::NiceSlice module:

           pdl&gt; $x(1:2) .= pdl([5,6])
           pdl&gt; p $x
           [0 5 6 3 4]

       With  versions of Perl prior to 5.6.7 <b>or</b> <b>when</b> <b>running</b> <b>under</b> <b>the</b> <b>perl</b> <b>debugger</b> this has to be done using a
       temporary variable:

           pdl&gt; $x = <a href="../man5/sequence.5.html">sequence</a>(5); p $x
           [0 1 2 3 4]
           pdl&gt; $tmp = $x-&gt;slice('1:2'); p $tmp;
           [1 2]
           pdl&gt; $tmp .= pdl([5, 6]);    # Note .= !!
           pdl&gt; p $x
           [0 5 6 3 4]

       This can also be made into one expression, which is often seen in PDL code:

           pdl&gt; ($tmp = $x-&gt;slice('1:2')) .= pdl([5,6])
           pdl&gt; p $x
           [0 5 6 3 4]

   <b>Q:</b> <b>6.10</b>   <b>Can</b> <b>I</b> <b>use</b> <b>an</b> <b>ndarray</b> <b>in</b> <b>a</b> <b>conditional</b> <b>expression?</b>
       Yes you can, but not in the way you probably tried first. It is not possible to use an  ndarray  directly
       in  a  conditional  expression  since  this  is  usually  poorly defined. Instead PDL has two very useful
       functions: "any" and "all" . Use these to test if any  or  all  elements  in  an  ndarray  fulfills  some
       criterion:

           pdl&gt; $x=pdl ( 1, -2, 3);
           pdl&gt; print '$x has at least one element &lt; 0' if (any $x &lt; 0);
           $x has at least one element &lt; 0

           pdl&gt; print '$x is not positive definite' unless (all $x &gt; 0);
           $x is not positive definite

   <b>Q:</b> <b>6.11</b>   <b>Logical</b> <b>operators</b> <b>and</b> <b>ndarrays</b> <b>-</b>  <b>'||'</b> <b>and</b> <b>'&amp;&amp;'</b> <b>don't</b> <b>work!</b>
       It is a common problem that you try to make a mask array or something similar using a construct such as

           $mask = which($ndarray &gt; 1 &amp;&amp; $ndarray &lt; 2);   # incorrect

       This  <b>does</b> <b>not</b> work! What you are looking for is the  <b>bitwise</b> logical operators '|' and '&amp;' which work on
       an  element-by-element  basis. So it is really very simple: Do not use logical operators on multi-element
       ndarrays since that really doesn't make sense, instead write the example as:

           $mask = which($ndarray &gt; 1 &amp; $ndarray &lt; 2);

       which works correctly.

</pre><h4><b>ADVANCED</b> <b>TOPICS</b></h4><pre>
   <b>Q:</b> <b>6.12</b>   <b>What</b> <b>is</b> <b>a</b> <b>null</b> <b>pdl</b> <b>?</b>
       "null" is a special token for 'empty ndarray'. A null pdl can be used to flag to a PDL function  that  it
       should  create  an appropriately sized and typed ndarray. <u>Null</u> ndarrays can be used in places where a PDL
       function expects an <u>output</u> or <u>temporary</u> argument. <u>Output</u> and  <u>temporary</u>  arguments  are  flagged  in  the
       <u>signature</u> of a PDL function with the "[o]" and "[t]" qualifiers (see next question if you don't know what
       the <u>signature</u> of a PDL function is).  For example, you can invoke the "sumover" function as follows:

           sumover $x, $y=null;

       which is equivalent to

           $y = sumover $x;

       If  this  seems  still a bit murky check PDL::Indexing and PDL::PP for details about calling conventions,
       the <u>signature</u> and <u>broadcasting</u> (see also below).

   <b>Q:</b> <b>6.13</b>   <b>What</b> <b>is</b> <b>the</b> <b>signature</b> <b>of</b> <b>a</b> <b>PDL</b> <b>function</b> <b>?</b>
       The <u>signature</u> of a function is an important concept in PDL.  Many (but  not  all)  PDL  function  have  a
       <u>signature</u>  which  specifies  the arguments and their (minimal) dimensionality. As an example, look at the
       signature of the "maximum" function:

           'a(n); [o] b;'

       this says that "maximum" takes two arguments, the first of which is (at least) one-dimensional while  the
       second  one  is zero-dimensional and an <u>output</u> argument (flagged by the "[o]" qualifier). If the function
       is called with ndarrays of higher dimension the function will be repeatedly called with slices  of  these
       ndarrays of appropriate dimension(this is called <u>broadcasting</u> in PDL).

       For details and further explanations consult PDL::Indexing and PDL::PP .

   <b>Q:</b> <b>6.14</b>   <b>How</b> <b>can</b> <b>I</b> <b>subclass</b> <b>(inherit</b> <b>from)</b> <b>ndarrays?</b>
       The short answer is: read PDL::Objects (e.g. type "help PDL::Objects" in the <u>perldl</u> shell).

       The  longer  answer  (extracted  from  PDL::Objects  ):  Since a PDL object is an opaque reference to a C
       struct, it is not possible to extend the PDL class by e.g. extra data via sub-classing (as you  could  do
       with  a  hash  based Perl object).  To circumvent this problem PDL has built-in support to extend the PDL
       class via the <u>has-a</u> relation for blessed hashes. You can get the <u>HAS-A</u> to behave like <u>IS-A</u> simply in that
       you assign the PDL object to the attribute named "PDL" and redefine the method <b>initialize()</b>. For example:

           package FOO;

           @FOO::ISA = qw(PDL);
           sub initialize {
              my $class = shift;
              my $self = {
                 creation_time =&gt; time(),  # necessary extension :-)
                 PDL =&gt; PDL-&gt;null,         # used to store PDL object
              };
              bless $self, $class;
           }

       For another example check the script <u>t/subclass.t</u> in the PDL distribution.

   <b>Q:</b> <b>6.15</b>   <b>What</b> <b>on</b> <b>earth</b> <b>is</b> <b>this</b> <b>dataflow</b> <b>stuff</b> <b>?</b>
       Dataflow is an experimental project that you don't need to concern yourself with (it should not interfere
       with your usual programming).  However, if you want to know, have a look at  PDL::Dataflow  .  There  are
       applications which will benefit from this feature (and it is already at work behind the scenes).

   <b>Q:</b> <b>6.16</b>   <b>What</b> <b>is</b> <b>PDL::PP?</b>
       Simple  answer:  PDL::PP  is  both  a  glue between external libraries and PDL and a concise language for
       writing PDL functions.

       Slightly longer answer:  PDL::PP  is  used  to  compile  very  concise  definitions  into  XSUB  routines
       implemented  in  C  that  can  easily  be  called  from PDL and which automatically support broadcasting,
       dataflow and other things without you having to worry about it.

       For further details check PDL::PP and the section below on Extensions of PDL.

   <b>Q:</b> <b>6.17</b>   <b>What</b> <b>happens</b> <b>when</b> <b>I</b> <b>have</b> <b>several</b> <b>references</b> <b>to</b> <b>the</b> <b>same</b> <b>PDL</b> <b>object</b> <b>in</b> <b>different</b> <b>variables</b> <b>(cloning,</b>
       <b>etc?)</b> <b>?</b>
       ndarrays behave like Perl references in many respects. So when you say

           $x = pdl [0,1,2,3];
           $y = $x;

       then both $y and $x point to the same object, e.g. then saying

           $y++;

       will *not* create a copy of the original ndarray but just increment in place, of which you  can  convince
       yourself by saying

           print $x;
           [1 2 3 4]

       This  should not be mistaken for dataflow which connects several *different* objects so that data changes
       are propagated between the so linked ndarrays (though, under certain circumstances,  dataflowed  ndarrays
       can share physically the same data).

       It  is  important  to  keep  the  "reference  nature"  of  ndarrays  in  mind  when passing ndarrays into
       subroutines. If you modify the input ndarrays you modify the original argument, <u>not</u> a copy of it. This is
       different from some other array processing languages but makes for very  efficient  passing  of  ndarrays
       between  subroutines.  If  you  do  not want to modify the original argument but rather a copy of it just
       create a copy explicitly (this example also demonstrates how to properly check for an <u>explicit</u> request to
       process inplace, assuming your routine can work inplace):

           sub myfunc {
              my $pdl = shift;
              if ($pdl-&gt;is_inplace) {
                 $pdl-&gt;<a href="../man0/set_inplace.0.html">set_inplace</a>(0)
              } else {
                 # modify a copy by default
                 $pdl = $pdl-&gt;copy
              }
              $pdl-&gt;set(0,0);
              return $pdl;
           }

</pre><h4><b>MISCELLANEOUS</b></h4><pre>
   <b>Q:</b> <b>6.18</b>   <b>What</b> <b>I/O</b> <b>formats</b> <b>are</b> <b>supported</b> <b>by</b> <b>PDL</b> <b>?</b>
       The current versions of PDL already support quite a number of different I/O formats.  However, it is  not
       always  obvious  which module implements which formats.  To help you find the right module for the format
       you require, here is a short list of the current list of I/O formats and a hint in which module  to  find
       the implementation:

       •   A home brew fast raw (binary) I/O format for PDL is implemented by the FastRaw module

       •   The  FlexRaw  module  implements  generic  methods for the input and output of `raw' data arrays.  In
           particular, it is designed to read output from FORTRAN 77  UNFORMATTED  files  and  the  low-level  C
           "write" function, even if the files are compressed or gzipped.

           It  is possible that the FastRaw functionality will be included in the FlexRaw module at some time in
           the future.

       •   FITS I/O is implemented by the "wfits"/"rfits" functions in PDL::IO::FITS .

       •   ASCII file I/O in various formats can be achieved by using the "rcols" and "rgrep" functions, also in
           PDL::IO::Misc .

       •   PDL::IO::Pic implements an interface to the NetPBM/PBM+ filters to read/write several  popular  image
           formats; also supported is output of image sequences as MPEG movies, animated GIFs and a wide variety
           of other video formats.

       •   On CPAN you can find the PDL::NetCDF module that works with PDL 2.007.

       For  further details consult the more detailed list in the PDL::IO documentation or the documentation for
       the individual modules.

   <b>Q:</b> <b>6.19</b>   <b>How</b> <b>can</b> <b>I</b> <b>stack</b> <b>a</b> <b>set</b> <b>of</b> <b>2D</b> <b>arrays</b> <b>(images)</b> <b>into</b> <b>a</b> <b>3D</b> <b>ndarray?</b>
       Assuming all arrays are of the same size and in some format recognized by "rpic" (see PDL::IO::Pic )  you
       could say:

           use PDL::IO::Pic;
           @names = qw/name1.tif .... nameN.tif/;  # some file names
           $dummy = PDL-&gt;rpic($names[0]);
           $cube = PDL-&gt;zeroes($dummy-&gt;type,$dummy-&gt;dims,$#names+1); # make 3D ndarray
           for (0..$#names) {
               # this is the slice assignment
               ($tmp = $cube-&gt;slice(":,:,($_)")) .= PDL-&gt;rpic($names[$_]);
           }

       or

           $cube(:,:,($_)) .= PDL-&gt;rpic($names[$_]);

       for the slice assignment using the new PDL::NiceSlice syntax and lvalue assignments.

       The  for  loop  reads the actual images into a temporary 2D ndarray whose values are then assigned (using
       the overloaded ".=" operator) to the appropriate slices of the 3D ndarray $cube .

   <b>Q:</b> <b>6.20</b>   <b>Where</b> <b>are</b> <b>test</b> <b>files</b> <b>for</b> <b>the</b> <b>graphics</b> <b>modules?</b>
       The demo programs can be run most easily from the "perldl" interactive shell:

           perl -Mblib perldl

       followed by "demo 3d" or "demo 3d2" at the prompt.  "demo"  by  itself  will  give  you  a  list  of  the
       available PDL demos.

   <b>Q:</b> <b>6.21</b>   <b>What</b> <b>is</b> <b>TriD</b> <b>or</b> <b>PDL::TriD</b> <b>or</b> <b>PDL::Graphics::TriD?</b>
       Questions  like  this  should  be a thing of the past with the PDL on-line help system in place. Just try
       (after installation):

           un*x&gt; perldl
           pdl&gt; apropos trid

       Check the output for promising hits and then try to look up some of them, e.g.

           pdl&gt; help PDL::Graphics::TriD

       Note that case matters with "help" but not with "apropos" .

   <b>Q:</b> <b>6.22</b>   <b>PGPLOT</b> <b>does</b> <b>not</b> <b>write</b> <b>out</b> <b>PNG</b> <b>files.</b>
       As of 2.086, PDL's PGPLOT-using modules are now all supplied with the PGPLOT module itself.

</pre><h4><b>EXTENSIONS</b> <b>OF</b> <b>PDL</b></h4><pre>
   <b>Q:</b> <b>7.1</b>    <b>I</b> <b>am</b> <b>looking</b> <b>for</b> <b>a</b> <b>package</b> <b>to</b> <b>do</b> <b>XXX</b> <b>in</b> <b>PDL.</b> <b>Where</b> <b>shall</b> <b>I</b> <b>look</b> <b>for</b> <b>it?</b>
       The first stop is again "perldl" and the on-line help or the PDL documentation. There is already a lot of
       functionality in PDL which you might not be aware of.  The easiest way to look for  functionality  is  to
       use the "apropos" command:

           pdl&gt; apropos 'integral'
           ceil            Round to integral values in floating-point format
           floor           Round to integral values in floating-point format
           intover         Project via integral to N-1 dimensions
           rint            Round to integral values in floating-point format

       Since  the  apropos  command  is  no sophisticated search engine make sure that you search on a couple of
       related topics and use short phrases.

       However there is a good chance that what you need is not part of the PDL distribution. You are then  well
       advised  to check out &lt;<a href="http://pdl.perl.org">http://pdl.perl.org</a>&gt; where there is a list of packages using PDL. If that does not
       solve your problem, ask on the mailing-list, if nothing else you might get assistance which will let  you
       interface your package with PDL yourself, see also the next question.

   <b>Q:</b> <b>7.2</b>    <b>Can</b> <b>I</b> <b>access</b> <b>my</b> <b>C/FORTRAN</b> <b>library</b> <b>routines</b> <b>in</b>  <b>PDL?</b>
       Yes,  you  can,  in  fact  it  is very simple for many simple applications. What you want is the PDL pre-
       processor PP (PDL::PP ). This will allow you to make a simple interface to your C routine.

       The two functions you need to learn (at least first) are "pp_def" which defines the calling interface  to
       the  function,  specifying  input and output parameters, and contains the code that links to the external
       library. The other command is "pp_end" which finishes the PP definitions.  For details  see  the  PDL::PP
       man-page, but we also have a worked example here.

           double eight_sum(int n)
           {
                int i;
                double sum, x;

                sum = 0.0; x=0.0;
                for (i=1; i&lt;=n; i++) {
                  x++;
                  sum += x/((4.0*x*x-1.0)*(4.0*x*x-1.0));
                }
                return 1.0/sum;
           }

       We will here show you an example of how you interface C code with PDL. This is the first example and will
       show you how to approximate the number 8...

       The  C  code  is  shown above and is a simple function returning a double, and expecting an integer - the
       number of terms in the sum - as input. This function could be defined in a library or, as we do here,  as
       an inline function.

       We  will postpone the writing of the Makefile till later. First we will construct the ".pd" file. This is
       the file containing PDL::PP code. We call this "eight.pd" .

           #
           # pp_def defines a PDL function.
           #
           pp_addhdr (
           '
           double eight_sum(int n)
           {
             int i;
             double sum, x;

             sum = 0.0; x=0.0;
             for (i=1; i&lt;=n; i++) {
              x++;
              sum += x/((4.0*x*x-1.0)*(4.0*x*x-1.0));
             }
            return 1.0/sum;

           }
           ');

           pp_def (
                   'eight',
                Pars =&gt; 'int a(); double [o]b();',
                   Code =&gt; '$b()=eight_sum($a());'
                  );

           # Always make sure that you finish your PP declarations with
           # pp_done

           pp_done();

       A peculiarity with our example is that we have included the  entire  code  with  "pp_addhdr"  instead  of
       linking  it  in.  This  is  only  for  the  purposes  of  example,  in a typical application you will use
       "pp_addhdr" to include header files. Note that the argument to "pp_addhdr" is enclosed in quotes.

       What is most important in this example is however the "pp_def" command. The first argument to this is the
       name of the new function <u>eight</u>  , then comes a hash which the real meat:

       •   This gives the input parameters (here  "a") and the output parameters (here   "b").  The  latter  are
           indicated by the  "[o]" specifier. Both arguments can have a type specification as shown here.

           Many  variations and further flexibility in the interface can be specified. See "perldoc PDL::PP" for
           details.

       •   This switch contains the code that should be executed. As you can see this is a rather  peculiar  mix
           of  C  and  Perl,  but  essentially it is just as you would write it in C, but the variables that are
           passed from PDL are treated differently and have to be referred to with a preceding '$'.

           There are also simple macros to pass pointers to  data  and  to  obtain  the  values  of  other  Perl
           quantities, see the manual page for further details.

       Finally note the call to pp_done() at the end of the file. This is necessary in all PP files.

       OK.  So now we have a file with code that we dearly would like to use in Perl via PDL. To do this we need
       to compile the function, and to do that we need a Makefile.

           use PDL::Core::Dev;
           use ExtUtils::MakeMaker;
           PDL::Core::Dev-&gt;import();

           $package = ["eight.pd",Eight,PDL::Eight,'',1];
           %hash = pdlpp_stdargs($package);

           WriteMakefile( %hash );

           sub MY::postamble {pdlpp_postamble($package)}

       The code above should go in a file called Makefile.PL,  which  should  subsequently  be  called  in   the
       standard  Perl  way:  "perl  Makefile.PL"  .   This  should give you a Makefile and running "make" should
       compile the module for you and "make install" will install it for you.

       The fifth element in the $package array-ref is true. This tells  PDL  to  generate  one  C  file  per  PP
       function,  which  with  the  right  "make"  options  can be compiled in parallel, for a useful speedup of
       development / installation.

   <b>Q:</b> <b>7.3</b>    <b>How</b> <b>can</b> <b>I</b> <b>interface</b> <b>package</b> <b>XXX</b> <b>in</b> <b>PDL?</b>
       This question is closely related to the previous one, and as we said there, the PDL::PP pre-processor  is
       the standard way of interfacing external packages with PDL. The most usual way to use PDL::PP is to write
       a  short  interface  routine,  see  the  PDL::PP perldoc page and the answer to the previous question for
       examples.

       However it is also possible to interface a  package  to  PDL  by  re-writing  your  function  in  PDL::PP
       directly.  This can be convenient in certain situations, in particular if you have a routine that expects
       a function as input and you would like to pass the function a Perl function for convenience.

       The PDL::PP perldoc page is the main source of information for writing PDL::PP extensions, but it is very
       useful to look for files in the distribution of PDL as many of the core functions are written in PDL::PP.
       Look for files that end in ".pd" which is the generally accepted suffix for PDL::PP files.  But  we  also
       have a simple example here.

       The  following  example  will  show  you  how  to  write  a  simple  function  that  automatically allows
       broadcasting. To make this concise the example is of an almost trivial function, but the intention is  to
       show the basics of writing a PDL::PP interface.

       We  will  write  a  simple function that calculates the minimum, maximum and average of an ndarray. On my
       machine the resulting function is 8 times faster than the built-in function "stats" (of course the latter
       also calculates the median).

       Let's jump straight in. Here is the code (from a file called "quickstats.pd" )

           #
           pp_def('quickstats',
                Pars =&gt; 'a(n); [o]avg(); [o]max(); [o]min()',
                Code =&gt; '$GENERIC(a) curmax, curmin;
                         $GENERIC(a) tmp=0;
                            loop(n) %{
                              tmp += $a();
                              if (!n || $a() &gt; curmax) { curmax = $a();}
                              if (!n || $a() &lt; curmin) { curmin = $a();}
                            %}
                            $avg() = tmp/$SIZE(n);
                         $max() = curmax;
                         $min() = curmin;
                           '
                );

           pp_done();

       The above might look like a confusing mixture of C and Perl, but behind the peculiar syntax lies  a  very
       powerful language. Let us take it line by line.

       The first line declares that we are starting the definition of a PDL:PP function called "quickstats" .

       The  second line is very important as it specifies the input and output parameters of the function.  a(n)
       tells us that there is one input parameter that we will refer to as "a" which is expected to be a  vector
       of  length  n  (likewise  matrices, both square and rectangular would be written as "a(n,n)" and "a(n,m)"
       respectively). To indicate that something is an output parameter we put "[o]" in front of their names, so
       referring back to the code we see that avg, max and min are three output parameters,  all  of  which  are
       scalar (since they have no dimensional size indicated.

       The  third  line  starts  the code definition which is essentially pure C but with a couple of convenient
       functions.  $GENERIC is a function that returns the C type of its argument - here the input parameter  a.
       Thus the first two lines of the code section are variable declarations.

       The  loop(n)  construct is a convenience function that loops over the dimension called n in the parameter
       section. Inside this loop we calculate the cumulative sum of the input  vector  and  keep  track  of  the
       maximum and minimum values. Finally we assign the resulting values to the output parameters.

       Finally we finish our function declaration with pp_done() .

       To  compile  our new function we need to create a Makefile, which we will just list since its creation is
       discussed in an earlier question.

           use PDL::Core::Dev;
           use ExtUtils::MakeMaker;
           PDL::Core::Dev-&gt;import();

           $package = ["quickstats.pd",Quickstats,PDL::Quickstats,'',1];
           %hash = pdlpp_stdargs($package);

           WriteMakefile( %hash );

           sub MY::postamble {pdlpp_postamble($package)}

       An example <u>Makefile.PL</u>

       Our new statistic function should now compile using the tried and tested  Perl  way:  "perl  Makefile.PL;
       make" .

       You  should  experiment with this function, changing the calculations and input and output parameters. In
       conjunction with the PDL::PP perldoc page this should allow you to quickly write more  advanced  routines
       directly in PDL::PP.

</pre><h4><b>BUGS</b></h4><pre>
       If  you  find  any  inaccuracies  in  this  document (or dis-functional URLs) please report to the perldl
       mailing list <a href="mailto:pdl-general@lists.sourceforge.net">pdl-general@lists.sourceforge.net</a>.

</pre><h4><b>ACKNOWLEDGMENTS</b></h4><pre>
       Achim Bohnet (<a href="mailto:ach@mpe.mpg.de">ach@mpe.mpg.de</a> ) for suggesting CoolHTML as a prettypodder (although we  have  switched  to
       XML  now)  and  various  other  improvements. Suggestions for some questions were taken from Perl FAQ and
       adapted for PDL.

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       Many people have contributed or given feedback on the current version of the FAQ, here is  an  incomplete
       list of individuals whose contributions or posts to the mailing-list have improved this FAQ at some point
       in  time  alphabetically  listed by first name: Christian Soeller, Chris Marshall, Doug Burke, Doug Hunt,
       Frank Schmauder, Jarle Brinchmann, John Cerney, Karl Glazebrook, Kurt Starsinic, Thomas Yengst, Tuomas J.
       Lukka.

</pre><h4><b>AUTHOR</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       This document emerged from a joint effort of several PDL developers (Karl Glazebrook,  Tuomas  J.  Lukka,
       Christian  Soeller)  to  compile  a  list  of the most frequently asked questions about PDL with answers.
       Permission is granted for verbatim copying (and formatting) of this material as part of PDL.

       Permission is explicitly not granted for distribution in book or any corresponding form. Ask on  the  PDL
       mailing list <a href="mailto:pdl-general@lists.sourceforge.net">pdl-general@lists.sourceforge.net</a> if some of the issues covered in here are unclear.

perl v5.40.1                                       2025-03-27                                      <u>PDL::<a href="../man3pm/FAQ.3pm.html">FAQ</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>