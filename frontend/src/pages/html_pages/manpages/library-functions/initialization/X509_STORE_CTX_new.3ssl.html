<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X509_STORE_CTX_new_ex, X509_STORE_CTX_new, X509_STORE_CTX_cleanup, X509_STORE_CTX_free,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       X509_STORE_CTX_new_ex, X509_STORE_CTX_new, X509_STORE_CTX_cleanup, X509_STORE_CTX_free,
       X509_STORE_CTX_init, X509_STORE_CTX_init_rpk, X509_STORE_CTX_set0_trusted_stack, X509_STORE_CTX_set_cert,
       X509_STORE_CTX_set0_crls, X509_STORE_CTX_set0_rpk, X509_STORE_CTX_get0_param, X509_STORE_CTX_set0_param,
       X509_STORE_CTX_get0_untrusted, X509_STORE_CTX_set0_untrusted, X509_STORE_CTX_get_num_untrusted,
       X509_STORE_CTX_get0_chain, X509_STORE_CTX_set0_verified_chain, X509_STORE_CTX_get0_rpk,
       X509_STORE_CTX_set_default, X509_STORE_CTX_set_verify, X509_STORE_CTX_verify_fn,
       X509_STORE_CTX_set_purpose, X509_STORE_CTX_set_trust, X509_STORE_CTX_purpose_inherit - X509_STORE_CTX
       initialisation

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/x509_vfy.h&gt;

        X509_STORE_CTX *X509_STORE_CTX_new_ex(OSSL_LIB_CTX *libctx, const char *propq);
        X509_STORE_CTX *X509_STORE_CTX_new(void);
        void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx);
        void X509_STORE_CTX_free(X509_STORE_CTX *ctx);

        int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *trust_store,
                                X509 *target, STACK_OF(X509) *untrusted);
        int X509_STORE_CTX_init_rpk(X509_STORE_CTX *ctx, X509_STORE *trust_store,
                                    EVP_PKEY *rpk);

        void X509_STORE_CTX_set0_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk);

        void X509_STORE_CTX_set_cert(X509_STORE_CTX *ctx, X509 *target);
        void X509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx, STACK_OF(X509_CRL) *sk);
        void X509_STORE_CTX_set0_rpk(X509_STORE_CTX *ctx, EVP_PKEY *target);

        X509_VERIFY_PARAM *X509_STORE_CTX_get0_param(const X509_STORE_CTX *ctx);
        void X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param);

        STACK_OF(X509)* X509_STORE_CTX_get0_untrusted(const X509_STORE_CTX *ctx);
        void X509_STORE_CTX_set0_untrusted(X509_STORE_CTX *ctx, STACK_OF(X509) *sk);

        int X509_STORE_CTX_get_num_untrusted(const X509_STORE_CTX *ctx);
        STACK_OF(X509) *X509_STORE_CTX_get0_chain(const X509_STORE_CTX *ctx);
        void X509_STORE_CTX_set0_verified_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *chain);
        EVP_PKEY *X509_STORE_CTX_get0_rpk(const X509_STORE_CTX *ctx);

        int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name);
        typedef int (*X509_STORE_CTX_verify_fn)(X509_STORE_CTX *);
        void X509_STORE_CTX_set_verify(X509_STORE_CTX *ctx, X509_STORE_CTX_verify_fn verify);

        int X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose);
        int X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust);
        int X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,
                                           int purpose, int trust);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These functions initialise an <b>X509_STORE_CTX</b> structure for subsequent use by <b><a href="../man3/X509_verify_cert.3.html">X509_verify_cert</a></b>(3) or
       <b><a href="../man3/X509_STORE_CTX_verify.3.html">X509_STORE_CTX_verify</a></b>(3).

       <b>X509_STORE_CTX_new_ex()</b> returns a newly initialised <b>X509_STORE_CTX</b> structure associated with the
       specified library context <u>libctx</u> and property query string <u>propq</u>. Any cryptographic algorithms fetched
       while performing processing with the X509_STORE_CTX will use that library context and property query
       string.

       <b>X509_STORE_CTX_new()</b> is the same as <b>X509_STORE_CTX_new_ex()</b> except that the default library context and a
       NULL property query string are used.

       <b>X509_STORE_CTX_cleanup()</b> internally cleans up an <b>X509_STORE_CTX</b> structure.  It is used by
       <b>X509_STORE_CTX_init()</b> and <b>X509_STORE_CTX_free()</b>.

       <b>X509_STORE_CTX_free()</b> completely frees up <u>ctx</u>. After this call <u>ctx</u> is no longer valid.  If <u>ctx</u> is NULL
       nothing is done.

       <b>X509_STORE_CTX_init()</b> sets up <u>ctx</u> for a subsequent verification operation.

       <b>X509_STORE_CTX_init()</b> initializes the internal state and resources of the given <u>ctx</u>. Among others, it
       sets the verification parameters associcated with the method name "default", which includes the "any"
       purpose, and takes over callback function pointers from <u>trust_store</u> (unless NULL).  It must be called
       before each call to <b><a href="../man3/X509_verify_cert.3.html">X509_verify_cert</a></b>(3) or <b><a href="../man3/X509_STORE_CTX_verify.3.html">X509_STORE_CTX_verify</a></b>(3), i.e., a context is only good for one
       verification.  If you want to verify a further certificate or chain with the same <u>ctx</u> then you must call
       <b>X509_STORE_CTX_init()</b> again.  The trusted certificate store is set to <u>trust_store</u> of type <b>X509_STORE</b>.
       This may be NULL because there are no trusted certificates or because they are provided simply as a list
       using <b>X509_STORE_CTX_set0_trusted_stack()</b>.  The certificate to be verified is set to <u>target</u>, and a list
       of additional certificates may be provided in <u>untrusted</u>, which will be untrusted but may be used to build
       the chain.  The <u>target</u> certificate is not copied (its reference count is not updated), and the caller
       must not free it before verification is complete.  Each of the <u>trust_store</u>, <u>target</u> and <u>untrusted</u>
       parameters can be NULL.  Yet note that <b><a href="../man3/X509_verify_cert.3.html">X509_verify_cert</a></b>(3) and <b><a href="../man3/X509_STORE_CTX_verify.3.html">X509_STORE_CTX_verify</a></b>(3) will need a
       verification target.  This can also be set using <b>X509_STORE_CTX_set_cert()</b>.  For
       <b><a href="../man3/X509_STORE_CTX_verify.3.html">X509_STORE_CTX_verify</a></b>(3), which takes by default the first element of the list of untrusted certificates
       as its verification target, this can be also set indirectly using <b>X509_STORE_CTX_set0_untrusted()</b>.

       <b>X509_STORE_CTX_init_rpk()</b> sets up <u>ctx</u> for a subsequent verification operation for the <u>target</u> raw public
       key.  It behaves similarly to <b>X509_STORE_CTX_init()</b>.  The <u>target</u> raw public key can also be supplied
       separately, via <b>X509_STORE_CTX_set0_rpk()</b>.  The <u>target</u> public key is not copied (its reference count is
       not updated), and the caller must not free it before verification is complete.

       <b>X509_STORE_CTX_set0_trusted_stack()</b> sets the set of trusted certificates of <u>ctx</u> to <u>sk</u>. This is an
       alternative way of specifying trusted certificates instead of using an <b>X509_STORE</b> where its complexity is
       not needed or to make sure that only the given set <u>sk</u> of certificates are trusted.

       <b>X509_STORE_CTX_set_cert()</b> sets the target certificate to be verified in <u>ctx</u> to <u>target</u>.  The target
       certificate is not copied (its reference count is not updated), and the caller must not free it before
       verification is complete.

       <b>X509_STORE_CTX_set0_rpk()</b> sets the target raw public key to be verified in <u>ctx</u> to <u>target</u>, a non-NULL raw
       public key preempts any target certificate, which is then ignored.  The <u>target</u> public key is not copied
       (its reference count is not updated), and the caller must not free it before verification is complete.

       <b>X509_STORE_CTX_set0_verified_chain()</b> sets the validated chain to <u>chain</u>.  Ownership of the chain is
       transferred to <u>ctx</u>, and so it should not be free'd by the caller.

       <b>X509_STORE_CTX_get0_chain()</b> returns the internal pointer used by the <u>ctx</u> that contains the constructed
       (output) chain.

       <b>X509_STORE_CTX_get0_rpk()</b> returns the internal pointer used by the <u>ctx</u> that contains the raw public key.

       <b>X509_STORE_CTX_set0_crls()</b> sets a set of CRLs to use to aid certificate verification to <u>sk</u>. These CRLs
       will only be used if CRL verification is enabled in the associated <b>X509_VERIFY_PARAM</b> structure. This
       might be used where additional "useful" CRLs are supplied as part of a protocol, for example in a PKCS#7
       structure.

       <b>X509_STORE_CTX_get0_param()</b> retrieves an internal pointer to the verification parameters associated with
       <u>ctx</u>.

       <b>X509_STORE_CTX_set0_param()</b> sets the internal verification parameter pointer to <u>param</u>. After this call
       <b>param</b> should not be used.

       <b>X509_STORE_CTX_get0_untrusted()</b> retrieves an internal pointer to the stack of untrusted certificates
       associated with <u>ctx</u>.

       <b>X509_STORE_CTX_set0_untrusted()</b> sets the internal pointer to the stack of untrusted certificates
       associated with <u>ctx</u> to <u>sk</u>.  <b>X509_STORE_CTX_verify()</b> will take the first element, if any, as its default
       target if the target certificate is not set explicitly.

       <b>X509_STORE_CTX_get_num_untrusted()</b> returns the number of untrusted certificates that were used in
       building the chain.  This is can be used after calling <b><a href="../man3/X509_verify_cert.3.html">X509_verify_cert</a></b>(3) and similar functions.  With
       <b><a href="../man3/X509_STORE_CTX_verify.3.html">X509_STORE_CTX_verify</a></b>(3), this does not count the first chain element.

       <b>X509_STORE_CTX_get0_chain()</b> returns the internal pointer used by the <u>ctx</u> that contains the validated
       chain.

       Details of the chain building and checking process are described in "Certification Path Building" in
       <b><a href="../man1/openssl-verification-options.1.html">openssl-verification-options</a></b>(1) and "Certification Path Validation" in <b><a href="../man1/openssl-verification-options.1.html">openssl-verification-options</a></b>(1).

       <b>X509_STORE_CTX_set0_verified_chain()</b> sets the validated chain used by <u>ctx</u> to be <u>chain</u>.  Ownership of the
       chain is transferred to <u>ctx</u>, and so it should not be free'd by the caller.

       <b>X509_STORE_CTX_set_default()</b> looks up and sets the default verification method.  This uses the function
       <b>X509_VERIFY_PARAM_lookup()</b> to find the set of parameters associated with the given verification method
       <u>name</u>.  Among others, the parameters determine the trust model and verification purpose.  More detail,
       including the list of currently predefined methods, is described for the <b>-verify_name</b> command-line option
       in "Verification Options" in <b><a href="../man1/openssl-verification-options.1.html">openssl-verification-options</a></b>(1).

       <b>X509_STORE_CTX_set_verify()</b> provides the capability for overriding the default verify function. This
       function is responsible for verifying chain signatures and expiration times.

       A verify function is defined as an X509_STORE_CTX_verify type which has the following signature:

        int (*verify)(X509_STORE_CTX *);

       This function should receive the current X509_STORE_CTX as a parameter and return 1 on success or 0 on
       failure.

       X509 certificates may contain information about what purposes keys contained within them can be used for.
       For example "TLS WWW Server Authentication" or "Email Protection". This "key usage" information is held
       internally to the certificate itself. In addition the trust store containing trusted certificates can
       declare what purposes we trust different certificates for. This "trust" information is not held within
       the certificate itself but is "meta" information held alongside it. This "meta" information is associated
       with the certificate after it is issued and could be determined by a system administrator. For example a
       certificate might declare that it is suitable for use for both "TLS WWW Server Authentication" and "TLS
       Client Authentication", but a system administrator might only trust it for the former. An X.509
       certificate extension exists that can record extended key usage information to supplement the purpose
       information described above. This extended mechanism is arbitrarily extensible and not well suited for a
       generic library API; applications that need to validate extended key usage information in certificates
       will need to define a custom "purpose" (see below) or supply a nondefault verification callback
       (<b><a href="../man3/X509_STORE_set_verify_cb_func.3.html">X509_STORE_set_verify_cb_func</a></b>(3)).

       <b>X509_STORE_CTX_set_purpose()</b> sets the purpose for the target certificate being verified in the <u>ctx</u>.
       Built-in available values for the <u>purpose</u> argument are <b>X509_PURPOSE_SSL_CLIENT</b>, <b>X509_PURPOSE_SSL_SERVER</b>,
       <b>X509_PURPOSE_NS_SSL_SERVER</b>, <b>X509_PURPOSE_SMIME_SIGN</b>, <b>X509_PURPOSE_SMIME_ENCRYPT</b>, <b>X509_PURPOSE_CRL_SIGN</b>,
       <b>X509_PURPOSE_ANY</b>, <b>X509_PURPOSE_OCSP_HELPER</b>, <b>X509_PURPOSE_TIMESTAMP_SIGN</b> and <b>X509_PURPOSE_CODE_SIGN</b>.  It
       is also possible to create a custom purpose value. Setting a purpose requests that the key usage and
       extended key usage (EKU) extensions optionally declared within the certificate and its chain are verified
       to be consistent with that purpose.  For SSL client, SSL server, and S/MIME purposes, the EKU is checked
       also for the CA certificates along the chain, including any given trust anchor certificate.  Potentially
       also further checks are done (depending on the purpose given).  Every purpose also has an associated
       default trust value, which will also be set at the same time. During verification, this trust setting
       will be verified to check whether it is consistent with the trust set by the system administrator for
       certificates in the chain.

       <b>X509_STORE_CTX_set_trust()</b> sets the trust value for the target certificate being verified in the <u>ctx</u>.
       Built-in available values for the <u>trust</u> argument are <b>X509_TRUST_COMPAT</b>, <b>X509_TRUST_SSL_CLIENT</b>,
       <b>X509_TRUST_SSL_SERVER</b>, <b>X509_TRUST_EMAIL</b>, <b>X509_TRUST_OBJECT_SIGN</b>, <b>X509_TRUST_OCSP_SIGN</b>,
       <b>X509_TRUST_OCSP_REQUEST</b> and <b>X509_TRUST_TSA</b>. It is also possible to create a custom trust value. Since
       <b>X509_STORE_CTX_set_purpose()</b> also sets the trust value it is normally sufficient to only call that
       function.  If both are called then <b>X509_STORE_CTX_set_trust()</b> should be called after
       <b>X509_STORE_CTX_set_purpose()</b> since the trust setting of the last call will be used.

       It should not normally be necessary for end user applications to call <b>X509_STORE_CTX_purpose_inherit()</b>
       directly. Typically applications should call <b>X509_STORE_CTX_set_purpose()</b> or <b>X509_STORE_CTX_set_trust()</b>
       instead. Using this function it is possible to set the purpose and trust values for the <u>ctx</u> at the same
       time.  Both <u>ctx</u> and its internal verification parameter pointer must not be NULL.  The <u>def_purpose</u> and
       <u>purpose</u> arguments can have the same purpose values as described for <b>X509_STORE_CTX_set_purpose()</b> above.
       The <u>trust</u> argument can have the same trust values as described in <b>X509_STORE_CTX_set_trust()</b> above. Any
       of the <u>def_purpose</u>, <u>purpose</u> or <u>trust</u> values may also have the value 0 to indicate that the supplied
       parameter should be ignored. After calling this function the purpose to be used for verification is set
       from the <u>purpose</u> argument unless the purpose was already set in <u>ctx</u> before, and the trust is set from the
       <u>trust</u> argument unless the trust was already set in <u>ctx</u> before.  If <u>trust</u> is 0 then the trust value will
       be set from the default trust value for <u>purpose</u>. If the default trust value for the purpose is
       <u>X509_TRUST_DEFAULT</u> and <u>trust</u> is 0 then the default trust value associated with the <u>def_purpose</u> value is
       used for the trust setting instead.

</pre><h4><b>NOTES</b></h4><pre>
       The certificates and CRLs in a store are used internally and should <b>not</b> be freed up until after the
       associated <b>X509_STORE_CTX</b> is freed.

</pre><h4><b>BUGS</b></h4><pre>
       The certificates and CRLs in a context are used internally and should <b>not</b> be freed up until after the
       associated <b>X509_STORE_CTX</b> is freed. Copies should be made or reference counts increased instead.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>X509_STORE_CTX_new()</b> returns a newly allocated context or NULL if an error occurred.

       <b>X509_STORE_CTX_init()</b> and <b>X509_STORE_CTX_init_rpk()</b> return 1 for success or 0 if an error occurred.

       <b>X509_STORE_CTX_get0_param()</b> returns a pointer to an <b>X509_VERIFY_PARAM</b> structure or NULL if an error
       occurred.

       <b>X509_STORE_CTX_get0_rpk()</b> returns a pointer to an <b>EVP_PKEY</b> structure if present, or NULL if absent.

       <b>X509_STORE_CTX_cleanup()</b>, <b>X509_STORE_CTX_free()</b>, <b>X509_STORE_CTX_set0_trusted_stack()</b>,
       <b>X509_STORE_CTX_set_cert()</b>, <b>X509_STORE_CTX_set0_crls()</b> and <b>X509_STORE_CTX_set0_param()</b> do not return
       values.

       <b>X509_STORE_CTX_set_default()</b> returns 1 for success or 0 if an error occurred.

       <b>X509_STORE_CTX_get_num_untrusted()</b> returns the number of untrusted certificates used.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/X509_verify_cert.3.html">X509_verify_cert</a></b>(3), <b><a href="../man3/X509_STORE_CTX_verify.3.html">X509_STORE_CTX_verify</a></b>(3), <b><a href="../man3/X509_VERIFY_PARAM_set_flags.3.html">X509_VERIFY_PARAM_set_flags</a></b>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>X509_STORE_CTX_set0_crls()</b> function was added in OpenSSL 1.0.0.  The
       <b>X509_STORE_CTX_get_num_untrusted()</b> function was added in OpenSSL 1.1.0.  The <b>X509_STORE_CTX_new_ex()</b>
       function was added in OpenSSL 3.0.  The <b>X509_STORE_CTX_init_rpk()</b>, <b>X509_STORE_CTX_get0_rpk()</b>, and
       <b>X509_STORE_CTX_set0_rpk()</b> functions were added in OpenSSL 3.2.

       There is no need to call <b>X509_STORE_CTX_cleanup()</b> explicitly since OpenSSL 3.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2009-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                           <u><a href="../man3SSL/X509_STORE_CTX_NEW.3SSL.html">X509_STORE_CTX_NEW</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>