<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>itcl::extendedclass - create a extendedclass of objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl-itcl4-doc">tcl-itcl4-doc_4.3.2-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       itcl::extendedclass - create a extendedclass of objects

</pre><h4><b>WARNING!</b></h4><pre>
       This is new functionality in [incr Tcl] where the API can still change!!

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>itcl::extendedclass</b> <u>extendedclassName</u> <b>{</b>
           <b>inherit</b> <u>baseExtendedclass</u> ?<u>baseExtendedclass</u>...?
           <b>constructor</b> <u>args</u> ?<u>init</u>? <u>body</u>
           <b>destructor</b> <u>body</u>
           <b>public</b> <b>method</b> <u>name</u> ?<u>args</u>? ?<u>body</u>?
           <b>protected</b> <b>method</b> <u>name</u> ?<u>args</u>? ?<u>body</u>?
           <b>private</b> <b>method</b> <u>name</u> ?<u>args</u>? ?<u>body</u>?
           <b>public</b> <b>proc</b> <u>name</u> ?<u>args</u>? ?<u>body</u>?
           <b>protected</b> <b>proc</b> <u>name</u> ?<u>args</u>? ?<u>body</u>?
           <b>private</b> <b>proc</b> <u>name</u> ?<u>args</u>? ?<u>body</u>?
           <b>public</b> <b>variable</b> <u>varName</u> ?<u>init</u>? ?<u>config</u>?
           <b>protected</b> <b>variable</b> <u>varName</u> ?<u>init</u>? ?<u>config</u>?
           <b>private</b> <b>variable</b> <u>varName</u> ?<u>init</u>? ?<u>config</u>?
           <b>public</b> <b>common</b> <u>varName</u> ?<u>init</u>?
           <b>protected</b> <b>common</b> <u>varName</u> ?<u>init</u>?
           <b>private</b> <b>common</b> <u>varName</u> ?<u>init</u>?

           <b>public</b> <u>command</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
           <b>protected</b> <u>command</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
           <b>private</b> <u>command</u> ?<u>arg</u> <u>arg</u> <u>...</u>?

           <b>&lt;delegation</b> <b>info&gt;</b> see delegation page

           <b>&lt;option</b> <b>info&gt;</b> see option page

           <b>set</b> <u>varName</u> ?<u>value</u>?
           <b>array</b> <u>option</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
       <b>}</b>

       <u>extendedclassName</u> <u>objName</u> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <u>objName</u> <u>method</u> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <u>extendedclassName::proc</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  fundamental  construct  in <b>[incr</b> <b>Tcl]</b> is the extendedclass definition.  Each extendedclass acts as a
       template for actual objects that can be created.  The extendedclass itself is a namespace which  contains
       things  common to all objects.  Each object has its own unique bundle of data which contains instances of
       the "variables" defined in the extendedclass definition.  Each object also has a built-in variable  named
       "this",  which contains the name of the object.  Extendedclasses can also have "common" data members that
       are shared by all objects in a extendedclass.

       Two types of functions can be included in the extendedclass definition.  "Methods"  are  functions  which
       operate  on  a  specific object, and therefore have access to both "variables" and "common" data members.
       "Procs" are ordinary procedures in the extendedclass namespace, and only have  access  to  "common"  data
       members.

       If  the body of any method or proc starts with "<b>@</b>", it is treated as the symbolic name for a C procedure.
       Otherwise, it is treated as a Tcl code script.   See  below  for  details  on  registering  and  using  C
       procedures.

       A  extendedclass  can only be defined once, although the bodies of extendedclass methods and procs can be
       defined again and again for interactive debugging.  See the <b>body</b> and <b>configbody</b> commands for details.

       Each namespace can have its own collection of objects and extendedclasses.  The list  of  extendedclasses
       available  in  the current context can be queried using the "<b>itcl::find</b> <b>extendedclasses</b>" command, and the
       list of objects, with the "<b>itcl::find</b> <b>objects</b>" command.

       A extendedclass can be deleted using the "<b>delete</b>  <b>extendedclass</b>"  command.   Individual  objects  can  be
       deleted using the "<b>delete</b> <b>object</b>" command.

</pre><h4><b>CLASS</b> <b>DEFINITIONS</b></h4><pre>
       <b>extendedclass</b> <u>extendedclassName</u> <u>definition</u>
              Provides  the  definition  for  a  extendedclass  named  <u>extendedclassName</u>.   If the extendedclass
              <u>extendedclassName</u> already exists, or if a command called <u>extendedclassName</u> exists in  the  current
              namespace context, this command returns an error.  If the extendedclass definition is successfully
              parsed,  <u>extendedclassName</u>  becomes  a  command  in  the current context, handling the creation of
              objects for this extendedclass.

       The extendedclass <u>definition</u> is evaluated as a series of Tcl statements that define elements  within  the
       extendedclass.  The following extendedclass definition commands are recognized:

              <b>inherit</b> <u>baseExtendedclass</u> ?<u>baseExtendedclass</u>...?
                     Causes  the  current  extendedclass  to  inherit  characteristics  from  one  or  more base
                     extendedclasses.  Extendedclasses must  have  been  defined  by  a  previous  <b>extendedclass</b>
                     command,  or  must be available to the auto-loading facility (see "AUTO-LOADING" below).  A
                     single extendedclass definition can contain no more than one <b>inherit</b> command.

                     The order of <u>baseExtendedclass</u> names in the <b>inherit</b> list affects the  name  resolution  for
                     extendedclass   members.    When  the  same  member  name  appears  in  two  or  more  base
                     extendedclasses, the base extendedclass that  appears  first  in  the  <b>inherit</b>  list  takes
                     precedence.   For  example, if extendedclasses "Foo" and "Bar" both contain the member "x",
                     and if another extendedclass has the "<b>inherit</b>" statement:

                            inherit Foo Bar

                     then the name "x" means "Foo::x".  Other inherited members named  "x"  must  be  referenced
                     with their explicit name, like "Bar::x".

              <b>constructor</b> <u>args</u> ?<u>init</u>? <u>body</u>
                     Declares  the  <u>args</u> argument list and <u>body</u> used for the constructor, which is automatically
                     invoked whenever an object is created.

                     Before the <u>body</u> is executed, the optional  <u>init</u>  statement  is  used  to  invoke  any  base
                     extendedclass constructors that require arguments.  Variables in the <u>args</u> specification can
                     be  accessed  in  the  <u>init</u>  code  fragment, and passed to base extendedclass constructors.
                     After evaluating the <u>init</u> statement, any base extendedclass constructors that have not been
                     executed  are  invoked  automatically  without  arguments.   This  ensures  that  all  base
                     extendedclasses are fully constructed before the constructor <u>body</u> is executed.  By default,
                     this  scheme causes constructors to be invoked in order from least- to most-specific.  This
                     is exactly the opposite of the order that extendedclasses are reported by the <b>info</b> <b>heritage</b>
                     command.

                     If construction is successful, the constructor always returns the object name-regardless of
                     how the <u>body</u> is defined-and the object name becomes a  command  in  the  current  namespace
                     context.  If construction fails, an error message is returned.

              <b>destructor</b> <u>body</u>
                     Declares the <u>body</u> used for the destructor, which is automatically invoked when an object is
                     deleted.  If the destructor is successful, the object data is destroyed and the object name
                     is  removed  as  a command from the interpreter.  If destruction fails, an error message is
                     returned and the object remains.

              When an object is destroyed, all destructors in its extendedclass hierarchy are invoked  in  order
              from  most-  to  least-specific.   This  is the order that the extendedclasses are reported by the
              "<b>info</b> <b>heritage</b>" command, and it is exactly the opposite of the default constructor order.

       <b>method</b> <u>name</u> ?<u>args</u>? ?<u>body</u>?
              Declares a method called <u>name</u>.  When the method <u>body</u> is executed, it will have automatic access to
              object-specific variables and common data members.

              If the <u>args</u> list is specified, it establishes the usage information for  this  method.   The  <b>body</b>
              command can be used to redefine the method body, but the <u>args</u> list must match this specification.

              Within  the  body  of  another  extendedclass  method,  a  method  can  be  invoked like any other
              command-simply by using its name.  Outside of the extendedclass context, the method name  must  be
              prefaced  an object name, which provides the context for the data that it manipulates.  Methods in
              a base extendedclass that are redefined in the current extendedclass, or hidden  by  another  base
              extendedclass, can be qualified using the "<u>extendedclassName</u>::<u>method</u>" syntax.

       <b>proc</b> <u>name</u> ?<u>args</u>? ?<u>body</u>?
              Declares  a proc called <u>name</u>.  A proc is an ordinary procedure within the extendedclass namespace.
              Unlike a method, a proc is invoked without referring to a specific object.  When the proc <u>body</u>  is
              executed, it will have automatic access only to common data members.

              If  the  <u>args</u>  list  is  specified,  it establishes the usage information for this proc.  The <b>body</b>
              command can be used to redefine the proc body, but the <u>args</u> list must match this specification.

              Within the body of another extendedclass method or proc, a proc can  be  invoked  like  any  other
              command-simply  by  using  its  name.  In any other namespace context, the proc is invoked using a
              qualified name like "<u>extendedclassName</u><b>::</b><u>proc</u>".  Procs in a base extendedclass that  are  redefined
              in  the  current  extendedclass, or hidden by another base extendedclass, can also be accessed via
              their qualified name.

       <b>variable</b> <u>varName</u> ?<u>init</u>? ?<u>config</u>?
              Defines  an  object-specific  variable  named  <u>varName</u>.    All   object-specific   variables   are
              automatically  available  in  extendedclass methods.  They need not be declared with anything like
              the <b>global</b> command.

              If the optional <u>init</u> string is specified, it is used as the initial value of the variable  when  a
              new  object  is  created.   Initialization  forces  the  variable  to  be  a  simple scalar value;
              uninitialized variables, on the other hand, can be set within the constructor and used as arrays.

              The optional <u>config</u> script is only allowed for public variables.  If specified, this code fragment
              is executed whenever a public variable is modified by the built-in "configure" method.  The <u>config</u>
              script can also be specified outside of the extendedclass definition using the <b>configbody</b> command.

       <b>common</b> <u>varName</u> ?<u>init</u>?
              Declares a common variable named <u>varName</u>.  Common variables reside in the extendedclass  namespace
              and  are  shared  by  all  objects  belonging  to  the  extendedclass.   They are just like global
              variables, except that they need not  be  declared  with  the  usual  <b>global</b>  command.   They  are
              automatically visible in all extendedclass methods and procs.

              If  the  optional  <u>init</u>  string  is  specified,  it  is used as the initial value of the variable.
              Initialization forces the variable to be a simple scalar value; uninitialized  variables,  on  the
              other hand, can be set with subsequent <b>set</b> and <b>array</b> commands and used as arrays.

              Once  a common data member has been defined, it can be set using <b>set</b> and <b>array</b> commands within the
              extendedclass definition.  This allows common data members  to  be  initialized  as  arrays.   For
              example:

                     itcl::extendedclass Foo {
                         common boolean
                         set boolean(true) 1
                         set boolean(false) 0
                     }

              Note  that  if  common  data  members are initialized within the constructor, they get initialized
              again and again whenever new objects are created.

       <b>public</b> <u>command</u> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <b>protected</b> <u>command</u> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <b>private</b> <u>command</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
              These commands are used to set the protection level for extendedclass  members  that  are  created
              when  <u>command</u>  is  evaluated.   The  <u>command</u>  is  usually <b>method</b>, <b>proc</b>, <b>variable</b> or<b>common</b>, and the
              remaining <u>arg</u>'s complete the member definition.  However, <u>command</u> can also be a script  containing
              many  different member definitions, and the protection level will apply to all of the members that
              are created.

</pre><h4><b>CLASS</b> <b>USAGE</b></h4><pre>
       Once a extendedclass has been defined, the extendedclass name can be used as  a  command  to  create  new
       objects belonging to the extendedclass.

       <u>extendedclassName</u> <u>objName</u> ?<u>args...</u>?
              Creates  a  new  object  in  extendedclass  <u>extendedclassName</u>  with  the  name <u>objName</u>.  Remaining
              arguments are passed to the constructor of the most-specific extendedclass.  This in  turn  passes
              arguments  to  base  extendedclass  constructors  before  invoking  its  own body of commands.  If
              construction is successful, a command called <u>objName</u> is created in the current namespace  context,
              and  <u>objName</u>  is  returned  as  the  result  of this operation.  If an error is encountered during
              construction, the destructors are automatically invoked to  free  any  resources  that  have  been
              allocated, the object is deleted, and an error is returned.

              If  <u>objName</u>  contains  the string "<b>#auto</b>", that string is replaced with an automatically generated
              name.  Names have the form <u>extendedclassName&lt;number&gt;</u>, where the <u>extendedclassName</u> part is modified
              to start  with  a  lowercase  letter.   In  extendedclass  "Toaster",  for  example,  the  "<b>#auto</b>"
              specification  would produce names like toaster0, toaster1, etc.  Note that "<b>#auto</b>" can be also be
              buried within an object name:

                     fileselectiondialog .foo.bar.#auto -background red

              This would generate an object named ".foo.bar.fileselectiondialog0".

</pre><h4><b>OBJECT</b> <b>USAGE</b></h4><pre>
       Once an object has been created, the object name can be used as a command to invoke methods that  operate
       on the object.

       <u>objName</u> <u>method</u> ?<u>args...</u>?
              Invokes  a  method named <u>method</u> on an object named <u>objName</u>.  Remaining arguments are passed to the
              argument list for the method.  The method name can be "constructor", "destructor", any method name
              appearing in the extendedclass definition, or any of the following built-in methods.

</pre><h4><b>BUILT-IN</b> <b>METHODS</b></h4><pre>
       <u>objName</u> <b>cget</b> <b>option</b>
              Provides access to public variables as configuration options.  This mimics  the  behavior  of  the
              usual  "cget"  operation  for Tk widgets.  The <u>option</u> argument is a string of the form "<b>-</b><u>varName</u>",
              and this method returns the current value of the public variable <u>varName</u>.

       <u>objName</u> <b>configure</b> ?<u>option</u>? ?<u>value</u> <u>option</u> <u>value</u> <u>...</u>?
              Provides access to public variables as configuration options.  This mimics  the  behavior  of  the
              usual  "configure"  operation  for  Tk  widgets.  With no arguments, this method returns a list of
              lists describing all of the public variables.  Each list has three elements:  the  variable  name,
              its initial value and its current value.

              If  a  single <u>option</u> of the form "<b>-</b><u>varName</u>" is specified, then this method returns the information
              for that one variable.

              Otherwise, the arguments are  treated  as  <u>option</u>/<u>value</u>  pairs  assigning  new  values  to  public
              variables.   Each  variable  is assigned its new value, and if it has any "config" code associated
              with it, it is executed in the context of the extendedclass where it was defined.  If the "config"
              code generates an error, the variable is set back to its previous value, and the <b>configure</b>  method
              returns an error.

       <u>objName</u> <b>isa</b> <u>extendedclassName</u>
              Returns  non-zero  if  the given <u>extendedclassName</u> can be found in the object's heritage, and zero
              otherwise.

       <u>objName</u> <b>info</b> <u>option</u> ?<u>args...</u>?
              Returns information related to  a  particular  object  named  <u>objName</u>,  or  to  its  extendedclass
              definition.  The <u>option</u> parameter includes the following things, as well as the options recognized
              by the usual Tcl "info" command:

              <u>objName</u> <b>info</b> <b>extendedclass</b>
                     Returns the name of the most-specific extendedclass for object <u>objName</u>.

              <u>objName</u> <b>info</b> <b>inherit</b>
                     Returns  the list of base extendedclasses as they were defined in the "<b>inherit</b>" command, or
                     an empty string if this extendedclass has no base extendedclasses.

              <u>objName</u> <b>info</b> <b>heritage</b>
                     Returns the current extendedclass name and the entire list of base extendedclasses  in  the
                     order that they are traversed for member lookup and object destruction.

              <u>objName</u> <b>info</b> <b>function</b> ?<u>cmdName</u>? ?<b>-protection</b>? ?<b>-type</b>? ?<b>-name</b>? ?<b>-args</b>? ?<b>-body</b>?
                     With  no arguments, this command returns a list of all extendedclass methods and procs.  If
                     <u>cmdName</u> is specified, it returns information for a specific method or proc.   If  no  flags
                     are  specified,  this  command  returns a list with the following elements:  the protection
                     level, the type (method/proc), the qualified name, the argument list and the  body.   Flags
                     can be used to request specific elements from this list.

              <u>objName</u> <b>info</b> <b>variable</b> ?<u>varName</u>? ?<b>-protection</b>? ?<b>-type</b>? ?<b>-name</b>? ?<b>-init</b>? ?<b>-value</b>? ?<b>-config</b>?
                     With  no arguments, this command returns a list of all object-specific variables and common
                     data members.  If <u>varName</u> is specified, it returns information for a specific data  member.
                     If  no  flags  are specified, this command returns a list with the following elements:  the
                     protection level, the type (variable/common), the qualified name, the  initial  value,  and
                     the  current value.  If <u>varName</u> is a public variable, the "config" code is included on this
                     list.  Flags can be used to request specific elements from this list.

</pre><h4><b>CHAINING</b> <b>METHODS/PROCS</b></h4><pre>
       Sometimes a base extendedclass has a method or proc that is redefined with the same  name  in  a  derived
       extendedclass.   This is a way of making the derived extendedclass handle the same operations as the base
       extendedclass, but  with  its  own  specialized  behavior.   For  example,  suppose  we  have  a  Toaster
       extendedclass that looks like this:

              itcl::extendedclass Toaster {
                  variable crumbs 0
                  method toast {nslices} {
                      if {$crumbs &gt; 50} {
                          error "== FIRE! FIRE! =="
                      }
                      set crumbs [expr {$crumbs+4*$nslices}]
                  }
                  method clean {} {
                      set crumbs 0
                  }
              }

       We might create another extendedclass like SmartToaster that redefines the "toast" method.  If we want to
       access  the  base  extendedclass  method,  we  can  qualify it with the base extendedclass name, to avoid
       ambiguity:

              itcl::extendedclass SmartToaster {
                  inherit Toaster
                  method toast {nslices} {
                      if {$crumbs &gt; 40} {
                          clean
                      }
                      return [Toaster::toast $nslices]
                  }
              }

       Instead of hard-coding the base extendedclass name, we can use the "chain" command like this:

              itcl::extendedclass SmartToaster {
                  inherit Toaster
                  method toast {nslices} {
                      if {$crumbs &gt; 40} {
                          clean
                      }
                      return [chain $nslices]
                  }
              }

       The chain command searches through  the  extendedclass  hierarchy  for  a  slightly  more  generic  (base
       extendedclass)  implementation  of  a  method  or  proc, and invokes it with the specified arguments.  It
       starts at the current extendedclass context and searches through base extendedclasses in the  order  that
       they  are  reported by the "info heritage" command.  If another implementation is not found, this command
       does nothing and returns the null string.

</pre><h4><b>AUTO-LOADING</b></h4><pre>
       Extendedclass definitions need not be loaded explicitly; they can be loaded as needed by  the  usual  Tcl
       auto-loading  facility.   Each  directory  containing  extendedclass  definition  files  should  have  an
       accompanying "tclIndex" file.   Each  line  in  this  file  identifies  a  Tcl  procedure  or  <b>[incr</b> <b>Tcl]</b>
       extendedclass definition and the file where the definition can be found.

       For   example,   suppose   a  directory  contains  the  definitions  for  extendedclasses  "Toaster"  and
       "SmartToaster".  Then the "tclIndex" file for this directory would look like:

              # Tcl autoload index file, version 2.0 for [incr Tcl]
              # This file is generated by the "auto_mkindex" command
              # and sourced to set up indexing information for one or
              # more commands.  Typically each line is a command that
              # sets an element in the auto_index array, where the
              # element name is the name of a command and the value is
              # a script that loads the command.

              set auto_index(::Toaster) "source $dir/Toaster.itcl"
              set auto_index(::SmartToaster) "source $dir/SmartToaster.itcl"

       The <b>auto_mkindex</b> command is used to automatically generate "tclIndex" files.

       The auto-loader must be made aware of this directory by appending the directory name to  the  "auto_path"
       variable.   When  this  is  in  place,  extendedclasses  will  be  auto-loaded  as needed when used in an
       application.

</pre><h4><b>C</b> <b>PROCEDURES</b></h4><pre>
       C procedures can be integrated into an <b>[incr</b> <b>Tcl]</b> extendedclass definition to implement  methods,  procs,
       and  the  "config"  code  for public variables.  Any body that starts with "<b>@</b>" is treated as the symbolic
       name for a C procedure.

       Symbolic names are established by registering procedures via <b>Itcl_RegisterC()</b>.  This is usually  done  in
       the  <b>Tcl_AppInit()</b>  procedure,  which  is  automatically  called  when the interpreter starts up.  In the
       following example, the procedure My_FooCmd() is registered with the symbolic name "foo".  This  procedure
       can be referenced in the <b>body</b> command as "@foo".

              int
              Tcl_AppInit(interp)
                  Tcl_Interp *interp;     /* Interpreter for application. */
              {
                  if (Itcl_Init(interp) == TCL_ERROR) {
                      return TCL_ERROR;
                  }

                  if (Itcl_RegisterC(interp, "foo", My_FooCmd) != TCL_OK) {
                      return TCL_ERROR;
                  }
              }

       C  procedures  are implemented just like ordinary Tcl commands.  See the <b>CrtCommand</b> man page for details.
       Within the  procedure,  extendedclass  data  members  can  be  accessed  like  ordinary  variables  using
       <b>Tcl_SetVar()</b>,  <b>Tcl_GetVar()</b>,  <b>Tcl_TraceVar()</b>,  etc.  Extendedclass methods and procs can be executed like
       ordinary commands using <b>Tcl_Eval()</b>.  <b>[incr</b> <b>Tcl]</b> makes this  possible  by  automatically  setting  up  the
       context before executing the C procedure.

       This  scheme  provides  a  natural migration path for code development.  Extendedclasses can be developed
       quickly using Tcl code to implement the bodies.  An entire application can be  built  and  tested.   When
       necessary, individual bodies can be implemented with C code to improve performance.

</pre><h4><b>KEYWORDS</b></h4><pre>
       extendedclass, object, object-oriented

itcl                                                   4.0                                  <u><a href="../man3itcl/extendedclass.3itcl.html">extendedclass</a></u>(3itcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>