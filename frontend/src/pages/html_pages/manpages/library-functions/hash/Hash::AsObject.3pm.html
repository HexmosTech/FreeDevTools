<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hash::AsObject - treat hashes as objects, with arbitrary accessors/mutators</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhash-asobject-perl">libhash-asobject-perl_0.13-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Hash::AsObject - treat hashes as objects, with arbitrary accessors/mutators

</pre><h4><b>SYNOPSIS</b></h4><pre>
           $h = Hash::AsObject-&gt;new;
           $h-&gt;<a href="../man123/foo.123.html">foo</a>(123);
           print $h-&gt;foo;       # prints 123
           print $h-&gt;{'foo'};   # prints 123
           $h-&gt;{'bar'}{'baz'} = 456;
           print $h-&gt;bar-&gt;baz;  # prints 456

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A Hash::AsObject is a blessed hash that provides read-write access to its elements using accessors.
       (Actually, they're both accessors and mutators.)

       It's designed to act as much like a plain hash as possible; this means, for example, that you can use
       methods like "DESTROY" to get or set hash elements with that name.  See below for more information.

</pre><h4><b>METHODS</b></h4><pre>
       The whole point of this module is to provide arbitrary methods.  For the most part, these are defined at
       runtime by a specially written "AUTOLOAD" function.

       In order to behave properly in all cases, however, a number of special methods and functions must be
       supported.  Some of these are defined while others are simply emulated in AUTOLOAD.

       <b>new</b>
               $h = Hash::AsObject-&gt;new;
               $h = Hash::AsObject-&gt;new(\%some_hash);
               $h = Hash::AsObject-&gt;new(%some_other_hash);

           Create a new Hash::AsObject.

           If called as an instance method, this accesses a hash element 'new':

               $h-&gt;{'new'} = 123;
               $h-&gt;new;       # 123
               $h-&gt;<a href="../man456/new.456.html">new</a>(456);  # 456

       <b>isa</b> This  method cannot be used to access a hash element 'isa', because Hash::AsObject doesn't attempt to
           handle it specially.

       <b>can</b> Similarly, this can't be used to access a hash element 'can'.

       <b>AUTOLOAD</b>
               $h-&gt;{'AUTOLOAD'} = 'abc';
               $h-&gt;AUTOLOAD;       # 'abc'
               $h-&gt;AUTOLOAD('xyz') # 'xyz'

           Hash::AsObject::AUTOLOAD recognizes when AUTOLOAD is begin called as an instance method,  and  treats
           this as an attempt to get or set the 'AUTOLOAD' hash element.

       <b>DESTROY</b>
               $h-&gt;{'DESTROY'} = [];
               $h-&gt;DESTROY;    # []
               $h-&gt;DESTROY({}) # {}

           "DESTROY"  is  called  automatically  by  the  Perl  runtime  when  an  object  goes out of scope.  A
           Hash::AsObject can't distinguish this from a call to access the element $h-&gt;{'DESTROY'},  and  so  it
           blithely  gets  (or  sets)  the  hash's  'DESTROY'  element;  this  isn't  a  problem, since the Perl
           interpreter discards any value that DESTROY returns when called automatically.

       <b>VERSION</b>
           When called as a class method, this returns $Hash::AsObject::VERSION;  when  called  as  an  instance
           method, it gets or sets the hash element 'VERSION';

       <b>import</b>
           Since  Hash::AsObject doesn't export any symbols, this method has no special significance and you can
           safely call it as a method to get or set an 'import' element.

           When called as a class method, nothing happens.

       The methods "can()" and "isa()" are special, because they're defined in the "UNIVERSAL"  class  that  all
       packages  automatically  inherit  from.   Unfortunately,  this means that you can't use Hash::AsObject to
       access elements 'can' and 'isa'.

</pre><h4><b>CAVEATS</b></h4><pre>
       No distinction is  made  between  non-existent  elements  and  those  that  are  present  but  undefined.
       Furthermore, there's no way to delete an element without resorting to "delete $h-&gt;{'foo'}".

       Storing a hash directly into an element of a Hash::AsObject instance has the effect of blessing that hash
       into Hash::AsObject.

       For example, the following code:

           my $h = Hash::AsObject-&gt;new;
           my $foo = { 'bar' =&gt; 1, 'baz' =&gt; 2 };
           print ref($foo), "\n";
           $h-&gt;foo($foo);
           print ref($foo), "\n";

       Produces the following output:

           HASH
           Hash::AsObject

       I could fix this, but then code like the following would throw an exception, because "$h-&gt;foo($foo)" will
       return a plain hash reference, not an object:

           $h-&gt;foo($foo)-&gt;bar;

       Well, I can make "$h-&gt;foo($foo)-&gt;bar" work, but then code like this won't have the desired effect:

           my $foo = { 'bar' =&gt; 123 };
           $h-&gt;foo($foo);
           $h-&gt;foo-&gt;<a href="../man456/bar.456.html">bar</a>(456);
           print $foo-&gt;{'bar'};  # prints 123
           print $h-&gt;foo-&gt;bar;   # prints 456

       I suppose I could fix <u>that</u>, but that's an awful lot of work for little apparent benefit.

       Let me know if you have any thoughts on this.

</pre><h4><b>BUGS</b></h4><pre>
       Autovivification is probably not emulated correctly.

       The blessing of hashes stored in a Hash::AsObject might be considered a bug.  Or a feature; it depends on
       your point of view.

</pre><h4><b>TO</b> <b>DO</b></h4><pre>
       •   Add the capability to delete elements, perhaps like this:

               use Hash::AsObject 'deleter' =&gt; 'kill';
               $h = Hash::AsObject-&gt;new({'one' =&gt; 1, 'two' =&gt; 2});
               kill $h, 'one';

           That might seem to violate the prohibition against exporting functions from object-oriented packages,
           but  then  technically  it  wouldn't  be  exporting  it  <b>from</b>  anywhere  since  the function would be
           constructed by hand.  Alternatively, it could work like this:

               use Hash::AsObject 'deleter' =&gt; 'kill';
               $h = Hash::AsObject-&gt;new({'one' =&gt; 1, 'two' =&gt; 2});
               $h-&gt;kill('one');

           But, again, what if the hash contained an element named 'kill'?

       •   Define multiple classes in "Hash/AsObject.pm"?  For example, there could be one package for read-only
           access to a hash, one for hashes that throw exceptions  when  accessors  for  non-existent  keys  are
           called,  etc.  But this is hard to do fully without (a) altering the underlying hash, or (b) defining
           methods besides AUTOLOAD. Hmmm...

</pre><h4><b>VERSION</b></h4><pre>
       0.06

</pre><h4><b>AUTHOR</b></h4><pre>
       Paul Hoffman &lt;nkuitse AT cpan DOT org&gt;

</pre><h4><b>CREDITS</b></h4><pre>
       Andy Wardley for Template::Stash, which was my inspiration.  Writing template code like this:

           [% foo.bar.baz(qux) %]

       Made me yearn to write Perl code like this:

           foo-&gt;bar-&gt;baz($qux);

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2003-2007 Paul M. Hoffman. All rights reserved.

       This program is free software; you can redistribute it and modify it under the same terms as Perl itself.

perl v5.36.0                                       2022-12-12                                <u>Hash::<a href="../man3pm/AsObject.3pm.html">AsObject</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>