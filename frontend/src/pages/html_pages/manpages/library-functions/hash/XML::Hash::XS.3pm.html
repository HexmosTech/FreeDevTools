<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Hash::XS - Simple and fast hash to XML and XML to hash conversion written in C</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-hash-xs-perl">libxml-hash-xs-perl_0.64-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Hash::XS - Simple and fast hash to XML and XML to hash conversion written in C

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use XML::Hash::XS;

           my $xmlstr = hash2xml \%hash;
           hash2xml \%hash, output =&gt; $fh;

           my $hash = xml2hash $xmlstr;
           my $hash = xml2hash \$xmlstr;
           my $hash = xml2hash 'test.xml', encoding =&gt; 'cp1251';
           my $hash = xml2hash $fh;
           my $hash = xml2hash *STDIN;

       Or OOP way:

           use XML::Hash::XS qw();

           my $conv   = XML::Hash::XS-&gt;new(utf8 =&gt; 0, encoding =&gt; 'utf-8')
           my $xmlstr = $conv-&gt;hash2xml(\%hash, utf8 =&gt; 1);
           my $hash   = $conv-&gt;xml2hash($xmlstr, encoding =&gt; 'cp1251');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module implements simple hash to XML and XML to hash conversion written in C.

       During conversion uses minimum of memory, XML or hash is written directly without building DOM.

       Some features are optional and are available with appropriate libraries:

       • XML::LibXML library is required  in order to build DOM

       • ICU or iconv library is required in order to perform charset conversions

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>hash2xml</b> <b>$hash,</b> <b>[</b> <b>%options</b> <b>]</b>
       $hash is reference to hash

           hash2xml
               {
                   node1 =&gt; 'value1',
                   node2 =&gt; [ 'value21', { node22 =&gt; 'value22' } ],
                   node3 =&gt; \'value3',
                   node4 =&gt; sub { return 'value4' },
                   node5 =&gt; sub { return { node51 =&gt; 'value51' } },
               },
               canonical =&gt; 1,
               indent    =&gt; 2,
           ;

       will convert to:

           &lt;?xml version="1.0" encoding="utf-8"?&gt;
           &lt;root&gt;
             &lt;node1&gt;value1&lt;/node1&gt;
             &lt;node2&gt;value21&lt;/node2&gt;
             &lt;node2&gt;
               &lt;node22&gt;value22&lt;/node22&gt;
             &lt;/node2&gt;
             &lt;node3&gt;value3&lt;/node3&gt;
             &lt;node4&gt;value4&lt;/node4&gt;
             &lt;node5&gt;
               &lt;node51&gt;value51&lt;/node51&gt;
             &lt;/node5&gt;
           &lt;<a href="file:/root">/root</a>&gt;

       and (use_attr=1):

           hash2xml
               {
                   node1 =&gt; 'value1',
                   node2 =&gt; [ 'value21', { node22 =&gt; 'value22' } ],
                   node3 =&gt; \'value3',
                   node4 =&gt; sub { return 'value4' },
                   node5 =&gt; sub { return { node51 =&gt; 'value51' } },
               },
               use_attr  =&gt; 1,
               canonical =&gt; 1,
               indent    =&gt; 2,
           ;

       will convert to:

           &lt;?xml version="1.0" encoding="utf-8"?&gt;
           &lt;root node1="value1" node3="value3" node4="value4"&gt;
             &lt;node2&gt;value21&lt;/node2&gt;
             &lt;node2 node22="value22"/&gt;
             &lt;node5 node51="value51"/&gt;
           &lt;<a href="file:/root">/root</a>&gt;

   <b>xml2hash</b> <b>$xml,</b> <b>[</b> <b>%options</b> <b>]</b>
       $xml may be string, reference to string, file handle or tied file handle:

           xml2hash '&lt;root&gt;text&lt;<a href="file:/root">/root</a>&gt;';
           # output: 'text'

           xml2hash '&lt;root a="1" b="2"&gt;text&lt;<a href="file:/root">/root</a>&gt;';
           # output: { a =&gt; '1', b =&gt; '2', content =&gt; 'text' }

           open(my $fh, '&lt;', 'test.xml');
           xml2hash $fh;

           xml2hash *STDIN;

</pre><h4><b>OPTIONS</b></h4><pre>
       doc [ =&gt; 0 ] <u>#</u> <u>hash2xml</u>
           if doc is '1', then returned value is XML::LibXML::Document.

       root [ = 'root' ] <u>#</u> <u>hash2xml</u>
           Root node name.

       version [ = '1.0' ] <u>#</u> <u>hash2xml</u>
           XML document version

       encoding [ = 'utf-8' ] <u>#</u> <u>hash2xml+xml2hash</u>
           XML input/output encoding

       indent [ = 0 ] <u>#</u> <u>hash2xml</u>
           if  indent great than "0", XML output should be indented according to its hierarchic structure.  This
           value determines the number of spaces.

           if indent is "0", XML output will all be on one line.

       output [ = undef ] <u>#</u> <u>hash2xml</u>
           XML output method

           if output is undefined, XML document dumped into string.

           if output is FH, XML document writes directly to a filehandle or a stream.

       canonical [ = 0 ] <u>#</u> <u>hash2xml</u>
           if canonical is "1", converter will be write hashes sorted by key.

           if canonical is "0", order of the element will be pseudo-randomly.

       use_attr [ = 0 ] <u>#</u> <u>hash2xml</u>
           if use_attr is "1", converter will be use the attributes.

           if use_attr is "0", converter will be use tags only.

       content [ = undef ] <u>#</u> <u>hash2xml+xml2hash</u>
           if defined that the key name for the text content(used only if use_attr=1).

       force_array =&gt; [ = undef ] <u>#</u> <u>xml2hash</u>
           This     option     is      similar      to      "ForceArray"      from      XML::Simple      module:
           &lt;https://metacpan.org/pod/XML::Simple#ForceArray-=%3E-1-%23-in-important&gt;.

       force_content =&gt; [ = 0 ] <u>#</u> <u>xml2hash</u>
           This      option      is      similar      to     "ForceContent"     from     XML::Simple     module:
           &lt;https://metacpan.org/pod/XML::Simple#ForceContent-=%3E-1-%23-in-seldom-used&gt;.

       merge_text [ = 0 ] <u>#</u> <u>xml2hash</u>
           Setting this option to "1" will cause merge adjacent text nodes.

       xml_decl [ = 1 ] <u>#</u> <u>hash2xml</u>
           if  xml_decl  is  "1",  output  will  start   with   the   XML   declaration   '&lt;?xml   version="1.0"
           encoding="utf-8"?&gt;'.

           if xml_decl is "0", XML declaration will not be output.

       trim [ = 0 ] <u>#</u> <u>hash2xml+xml2hash</u>
           Trim leading and trailing whitespace from text nodes.

       suppress_empty =&gt; [ = 0 ] <u>#</u> <u>xml2hash</u>
           This      option      is      similar     to     "SuppressEmpty"     from     XMl::Simple     module:
           &lt;https://metacpan.org/pod/XML::Simple#SuppressEmpty-=%3E-1-%7C-''-%7C-undef-%23-in+out-handy&gt;.

       utf8 [ = 1 ] <u>#</u> <u>hash2xml+xml2hash</u>
           Turn on utf8 flag for strings if enabled.

       max_depth [ = 1024 ] <u>#</u> <u>xml2hash</u>
           Maximum recursion depth.

       buf_size [ = 4096 ] <u>#</u> <u>hash2xml+xml2hash</u>
           Buffer size for reading end encoding data.

       keep_root [ = 1 ] <u>#</u> <u>hash2xml+xml2hash</u>
           Keep root element.

       filter [ = undef ] <u>#</u> <u>xml2hash</u>
           Filter nodes matched by pattern and return reference to array of nodes.

           Sample:

               my $xml = &lt;&lt;'XML';
                   &lt;root&gt;
                      &lt;item1&gt;111&lt;/item1&gt;
                      &lt;item2&gt;222&lt;/item2&gt;
                      &lt;item3&gt;333&lt;/item3&gt;
                   &lt;<a href="file:/root">/root</a>&gt;
               XML

               my $nodes = xml2hash($xml, filter =&gt; '/root/item1');
               # $nodes = [ 111 ]

               my $nodes = xml2hash($xml, filter =&gt; ['/root/item1', '/root/item2']);
               # $nodes = [ 111, 222 ]

               my $nodes = xml2hash($xml, filter =&gt; qr[/root/item\d$]);
               # $nodes = [ 111, 222, 333 ]

           It may be used to parse large XML because does not require a lot of memory.

       cb [ = undef ] <u>#</u> <u>xml2hash</u>
           This option is used in conjunction with "filter" option and defines callback  that  will  called  for
           each matched node.

           Sample:

               xml2hash($xml, filter =&gt; qr[/root/item\d$], cb =&gt; sub {
                   print $_[0], "\n";
               });
               # 111
               # 222
               # 333

       method [ = 'NATIVE' ] <u>#</u> <u>hash2xml</u>
           experimental support the conversion methods other libraries

           if method is 'LX' then conversion result is the same as using XML::Hash::LX library

           Note: for 'LX' method following additional options are available:
               attr
               cdata
               text
               comm

</pre><h4><b>OBJECT</b> <b>SERIALISATION(hash2xml)</b></h4><pre>
       1. When object has a "toString" method
         In  this  case,  the &lt;toString&gt; method of object is invoked in scalar context.  It must return a single
         scalar that can be directly encoded into XML.

         Example:

             use XML::LibXML;
             local $XML::LibXML::skipXMLDeclaration = 1;
             my $doc = XML::LibXML-&gt;new-&gt;parse_string('&lt;foo bar="1"/&gt;');
             print hash2xml({ doc =&gt; $doc }, indent =&gt; 2, xml_decl =&gt; 0);
             =&gt;
             &lt;root&gt;
               &lt;doc&gt;&lt;foo bar="1"/&gt;&lt;/doc&gt;
             &lt;<a href="file:/root">/root</a>&gt;

       2. When object has overloaded stringification
         In this case, the stringification method of object is invoked and result is directly encoded into XML.

         Example:

             package Test {
                 use overload '""' =&gt; sub { shift-&gt;stringify }, fallback =&gt; 1;
                 sub new {
                     my ($class, $str) = @_;
                     bless { str =&gt; $str }, $class;
                 }
                 sub stringify {
                     shift-&gt;{str}
                 }
             }
             my $obj = Test-&gt;new('test string');
             print hash2xml({ obj =&gt; $obj }, indent =&gt; 2, xml_decl =&gt; 0);
             =&gt;
             &lt;root&gt;
               &lt;obj&gt;test string&lt;/obj&gt;
             &lt;<a href="file:/root">/root</a>&gt;

       3. When object has a "iternext" method ("NATIVE" method only)
         In this case, the &lt;iternext&gt; method method will invoke a few  times  until  the  return  value  is  not
         undefined.

         Example:

             my $count = 0;
             my $o = bless {}, 'Iterator';
             *Iterator::iternext = sub { $count++ &lt; 3 ? { count =&gt; $count } : undef };
             print hash2xml({ item =&gt; $o }, use_attr =&gt; 1, indent =&gt; 2, xml_decl =&gt; 0);
             =&gt;
             &lt;root&gt;
               &lt;item count="1"/&gt;
               &lt;item count="2"/&gt;
               &lt;item count="3"/&gt;
             &lt;<a href="file:/root">/root</a>&gt;

         This can be used to generate a large XML using minimum memory, example with DBI:

             my $sth = $dbh-&gt;prepare('SELECT * FROM foo WHERE bar=?');
             $sth-&gt;execute(...);
             my $o = bless {}, 'Iterator';
             *Iterator::iternext = sub { $sth-&gt;fetchrow_hashref() };
             open(my $fh, '&gt;', 'data.xml');
             hash2xml({ row =&gt; $o }, use_attr =&gt; 1, indent =&gt; 2, xml_decl =&gt; 0, output =&gt; $fh);
             =&gt;
             &lt;root&gt;
               &lt;row bar="..." ... /&gt;
               &lt;row bar="..." ... /&gt;
               ...
             &lt;<a href="file:/root">/root</a>&gt;

</pre><h4><b>BENCHMARK</b></h4><pre>
       Performance benchmark in comparison with some popular modules(hash2xml):

                           Rate     XML::Hash XML::Hash::LX   XML::Simple XML::Hash::XS
           XML::Hash     65.0/s            --           -6%          -37%          -99%
           XML::Hash::LX 68.8/s            6%            --          -33%          -99%
           XML::Simple    103/s           58%           49%            --          -98%
           XML::Hash::XS 4879/s         7404%         6988%         4658%            --

       Benchmark was done on &lt;<a href="http://search.cpan.org/uploads.rdf">http://search.cpan.org/uploads.rdf</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Yuriy Ustushenko, &lt;<a href="mailto:yoreek@yahoo.com">yoreek@yahoo.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2012-2021 Yuriy Ustushenko

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.0                                       2025-01-02                                 <u>XML::Hash::<a href="../man3pm/XS.3pm.html">XS</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>