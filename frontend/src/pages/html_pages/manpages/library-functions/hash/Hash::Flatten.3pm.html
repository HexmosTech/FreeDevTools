<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hash::Flatten - flatten/unflatten complex data hashes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhash-flatten-perl">libhash-flatten-perl_1.19-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Hash::Flatten - flatten/unflatten complex data hashes

</pre><h4><b>SYNOPSIS</b></h4><pre>
               # Exported functions
               use Hash::Flatten qw(:all);
               $flat_hash = flatten($nested_hash);
               $nested_hash = unflatten($flat_hash);

               # OO interface
               my $o = new Hash::Flatten({
                       HashDelimiter =&gt; '-&gt;',
                       ArrayDelimiter =&gt; '=&gt;',
                       OnRefScalar =&gt; 'warn',
               });
               $flat_hash = $o-&gt;flatten($nested_hash);
               $nested_hash = $o-&gt;unflatten($flat_hash);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Converts back and forth between a nested hash structure and a flat hash of delimited key-value pairs.
       Useful for protocols that only support key-value pairs (such as CGI and DBMs).

   <b>Functional</b> <b>interface</b>
       $flat_hash = flatten($nested_hash, \%options)
           Reduces  a  nested  data-structure  to key-value form.  The top-level container must be hashref.  For
           example:

                   $nested = {
                           'x' =&gt; 1,
                           'y' =&gt; {
                                   'a' =&gt; 2,
                                   'b' =&gt; 3
                           },
                           'z' =&gt; [
                                   'a', 'b', 'c'
                           ]
                   }

                   $flat = flatten($nested);
                   use Data::Dumper;
                   print Dumper($flat);

                   $VAR1 = {
                           'y.a' =&gt; 2,
                           'x' =&gt; 1,
                           'y.b' =&gt; 3,
                           'z:0' =&gt; 'a',
                           'z:1' =&gt; 'b',
                           'z:2' =&gt; 'c'
                   };

           The "\%options" hashref can be used to override the default behaviour (see "OPTIONS").

       $nested_hash = unflatten($flat_hash, \%options)
           The <b>unflatten()</b> routine takes the flattened hash and returns the original nested hash (see  "CAVEATS"
           though).

   <b>OO</b> <b>interface</b>
       $o = new Hash::Flatten(\%options)
           Options can be squirreled away in an object (see "OPTIONS")

       $flat = $o-&gt;flatten($nested)
           Flatten the structure using the options stored in the object.

       $nested = $o-&gt;unflatten($flat)
           Unflatten the structure using the options stored in the object.

</pre><h4><b>OPTIONS</b></h4><pre>
       HashDelimiter and ArrayDelimiter
           By  default,  hash  dereferences are denoted by a dot, and array dereferences are denoted by a colon.
           However you may change these characters to any string you want, because you don't want  there  to  be
           any  confusion  as  to  which part of a string is the 'key' and which is the 'delimiter'. You may use
           multicharacter strings if you prefer.

       OnRefScalar and OnRefRef and OnRefGlob
           Behaviour if a reference of this type is encountered during flattening.  Possible values  are  'die',
           'warn' (default behaviour but warns) or a coderef which is passed the reference and should return the
           flattened value.

           By default references to references, and references to scalars, are followed silently.

       EscapeSequence
           This  is  the  character  or  sequence  of  characters that will be used to escape the hash and array
           delimiters.  The default escape sequence is '\\'. The  escaping  strategy  is  to  place  the  escape
           sequence  in front of delimiter sequences; the escape sequence itself is escaped by replacing it with
           two instances.

       DisableEscapes
           Stop the escaping from happening.  No escape  sequences  will  be  added  to  flattened  output,  nor
           interpreted on the way back.

           <b>WARNING:</b> If your structure has keys that contain the delimiter characters, it will not be possible to
           unflatten the structure correctly.

</pre><h4><b>CAVEATS</b></h4><pre>
       Any  blessings  will be discarded during flattening, so that if you flatten an object you must re-<b>bless()</b>
       it on unflattening.

       Note that there is no delimiter for scalar references, or references to references.  If your structure to
       be flattened contains scalar, or reference, references these will be followed by default, i.e.  "'foo' =&gt;
       \\\\\\$foo" will be collapsed to "'foo' =&gt; $foo".  You can override this behaviour using the  OnRefScalar
       and OnRefRef constructor option.

       Recursive structures are detected and cause a fatal error.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The  perlmonks  site  has  a  helpful  introduction  to  when  and  why you might want to flatten a hash:
       <a href="http://www.perlmonks.org/index.pl">http://www.perlmonks.org/index.pl</a>?node_id=234186

       CGI::Expand
           Unflattens hashes using "." as a delimiter, similar to Template::Toolkit's behaviour.

       Tie::MultiDim
           This provides a tie interface to unflattening a data structure if you specify a  "template"  for  the
           structure of the data.

       MLDBM
           This  also  provides  a tie interface but reduces a nested structure to key-value form by serialising
           the values below the top level.

</pre><h4><b>VERSION</b></h4><pre>
       $Id: Flatten.pm,v 1.19 2009/05/09 12:42:02 jamiel Exp $

</pre><h4><b>AUTHOR</b></h4><pre>
       John Alden &amp; P Kent &lt;cpan _at_ bbc _dot_ co _dot_ uk&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       (c) BBC 2005. This program is free software; you can redistribute it and/or modify it under the GNU GPL.

       See the file COPYING in this distribution, or <a href="http://www.gnu.org/licenses/gpl.txt">http://www.gnu.org/licenses/gpl.txt</a>

perl v5.36.0                                       2022-12-07                                 <u>Hash::<a href="../man3pm/Flatten.3pm.html">Flatten</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>