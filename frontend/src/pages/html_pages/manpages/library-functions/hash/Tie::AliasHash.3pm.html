<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tie::AliasHash - Hash with aliases key (multiple keys, one value)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtie-aliashash-perl">libtie-aliashash-perl_1.02-1.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tie::AliasHash - Hash with aliases key (multiple keys, one value)

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Tie::AliasHash;

         tie %hash, 'Tie::AliasHash';

         $hash{ 'foo', 'bar' } = 'baz';

         print $hash{foo}; # prints 'baz'
         print $hash{bar}; # prints 'baz' too

         $hash{bar} = 'zab'; # $hash{foo} is changed too
         print $hash{foo}; # prints 'zab'

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Tie::AliasHash</b> creates hashes that can have multiple keys for a single value. This means that some keys
       are just 'aliases' for other keys.

       The example shown in the synopsys above creates a key 'foo' and an alias key 'bar'. The two keys share
       the same value, so that fetching either of them will always return the same value, and storing a value in
       one of them will change both.

       The only difference between the two keys is that 'bar' is not reported by <b>keys()</b> and <b>each()</b>:

         use Tie::AliasHash;
         tie %hash, 'Tie::AliasHash';
         tied(%hash)-&gt;add_alias( 'foo', 'bar' );
         foreach $k (keys %hash) { print "$k\n"; } # prints 'foo'

       To get the 'real' keys and the aliases together, use the "allkeys" function:

         use Tie::AliasHash;
         tie %hash, 'Tie::AliasHash';
         tied(%hash)-&gt;add_alias( 'foo', 'bar' );
         foreach $k (tied(%hash)-&gt;allkeys) { print "$k\n"; } # prints 'foo' and 'bar'

       You can create alias keys with 3 methods:

       •   pre-declaring them while tieing the hash

           The 'tie' constructor accepts an optional list of key names and aliases.  The synopsis is:

             tie %HASH, 'Tie::AliasHash',
               KEY =&gt; ALIAS,
               KEY =&gt; [ALIAS, ALIAS, ALIAS, ...],
               ...

       •   explicitly with the add_alias method

             tied(%hash)-&gt;add_alias( KEY, ALIAS );
             tied(%hash)-&gt;add_alias( KEY, ALIAS, ALIAS, ALIAS, ... );

       •   implicitly with a multiple-key hash assignement

             $hash{ KEY, ALIAS } = VALUE;
             $hash{ KEY, ALIAS, ALIAS, ALIAS, ... } = VALUE;

           The list of keys and aliases can be either an array reference, eg.:

             $hash{ [ 'foo', 'bar', 'baz' ] } = $value;
             $hash{ \@foobarbaz } = $value;

           or an explicit list, eg.:

             $hash{ qw(foo bar baz) } = $value;
             $hash{ @foobarbaz } = $value;

           Be  warned  that,  with  the  last example, Perl uses the $; variable (or subscript separator), which
           defaults to '\034' (ASCII 28). This can cause problems if you plan to use keys with  arbitrary  ASCII
           characters. Always use the first form when in doubt. Consult perlvar for more information.

   <b>EXPORT</b>
       None  by default. You can optionally export the "allkeys" function to your main namespace, so that it can
       be used like the builtin "keys".

         use Tie::AliasHash 'allkeys';
         tie %hash, 'Tie::AliasHash';
         foreach $k (allkeys %hash) { print "$k\n"; }

       But see CAVEATS below for important information about "allkeys".

   <b>METHODS</b>
       add_alias( KEY, ALIAS, [ALIAS, ALIAS, ...] )
           Add one or more ALIAS for KEY. If KEY itself is an alias, the aliases are added to the real key which
           KEY points to.

       aliases( KEY )
           Returns a list of all the aliases defined for KEY. If KEY itself is an alias, returns  the  real  key
           pointed by KEY, as well as any other alias (thus excluding KEY itself) it has.

       allkeys
           Returns all the (real) keys of the hash, as well as all the aliases.

       is_alias( KEY )
           Returns  true if the specified KEY is an alias, false otherwise (either if KEY does not exists in the
           hash, or it is a real key).

       is_key( KEY )
           Returns true if the specified KEY is a real key, false otherwise (either if KEY does  not  exists  in
           the hash, or it is an alias for another key).

       remove( KEY )
           Remove  KEY  from  the  hash:  if KEY is a real key, it is removed with all its aliases. If KEY is an
           alias, <b>only</b> <b>the</b> <b>alias</b> <b>is</b> <b>removed</b>.  This is different from the builtin "delete", see CAVEATS below.

       remove_alias( ALIAS )
           Removes the specified ALIAS from its real key. ALIAS is no longer an alias and can  be  assigned  its
           own value. The real key which ALIAS used to point to is left unchanged.

       remove_aliases( KEY )
           Removes all the aliases defined for KEY.

       remove_jolly( )
           Removes the 'jolly' key from the hash. Operations on non-existant keys are restored to normality.

       set_jolly( KEY )
           Sets the 'jolly' key to KEY. When you set a jolly key, all fetch and store operations on non-existant
           keys will be done on KEY instead.

</pre><h4><b>CAVEATS</b></h4><pre>
       This  module can generate a wonderful amount of confusion if not used properly. The package should really
       have a big 'HANDLE WITH CARE' sticker on it. Other than paying special attention to  what  you're  doing,
       you should be aware of the following subtlenesses:

       •   transitivity

           Aliases are 'transitive', and always resolve to their aliased key. This means that if you write:

             use Tie::AliasHash;
             tie %hash, 'Tie::AliasHash';
             tied(%hash)-&gt;add_alias( 'foo', 'bar' );
             tied(%hash)-&gt;add_alias( 'bar', 'baz' );

           $hash{baz}  is  created as an alias for $hash{foo}, not for $hash{bar} (which isn't a real key). This
           also means that if you later change $hash{bar} to  point  to  something  else,  <b>you</b>  <b>haven't</b>  <b>changed</b>
           $hash{baz}:

             tied(%hash)-&gt;add_alias( 'gup', 'bar' );
             # $hash{bar} is now really --&gt; $hash{gup}
             # $hash{baz} is still      --&gt; $hash{foo}

       •   delete

           The  builtin  "delete"  function  resolves  aliases  to real keys, so it deletes everything even when
           called on an alias:

             use Tie::AliasHash;
             tie %hash, 'Tie::AliasHash';
             tied(%hash)-&gt;add_alias( 'foo', 'bar' );

             delete $hash{bar}; # deletes $hash{foo} too!

           To delete an alias leaving its key intact, use the "remove_alias" method instead:

             use Tie::AliasHash;
             tie %hash, 'Tie::AliasHash';
             tied(%hash)-&gt;add_alias( 'foo', 'bar' );

             tied(%hash)-&gt;remove_alias( 'bar' ); # $hash{foo} remains intact

       •   exists

           The builtin "exists" function returns true on aliases too:

             use Tie::AliasHash;
             tie %hash, 'Tie::AliasHash';
             tied(%hash)-&gt;add_alias( 'foo', 'bar' );

             print exists $hash{'foo'}; # TRUE
             print exists $hash{'bar'}; # TRUE

           To distinguish between aliases and real keys, use the "is_key" method:

             print exists $hash{'foo'} and tied(%hash)-&gt;is_key('foo'); # TRUE
             print exists $hash{'bar'} and tied(%hash)-&gt;is_key('bar'); # FALSE

       •   allkeys

           If you export "allkeys" into your main namespace, it can  be  used  as  the  builtin  "keys"  in  the
           following code:

             use Tie::AliasHash 'allkeys';
             tie %hash, 'Tie::AliasHash';
             foreach $key (allkeys %hash) { print "$key\n"; }

           But note that "allkeys" is always a function call, so this does not work as you expect:

             foreach $key (sort allkeys %hash) { print "$key\n"; }

           You have to fool "sort", or it will use "allkeys" as its sort routine.  This can be done by providing
           an  explicit  sort  routine,  or  forcing  the  result  of "allkeys" to be interpreted as an array by
           referencing-dereferencing it, or with a two-step operation where you first  assign  "allkeys"  to  an
           array, and then operate on it:

             foreach $key (sort { $a cmp $b } allkeys %hash) { print "$key\n"; }
             foreach $key (sort @{[ allkeys %hash ]}) { print "$key\n"; }

             @allkeys = allkeys %hash;
             foreach $key (sort @allkeys) { print "$key\n"; }

       •   the 'jolly' key

           The  most  potentially  confusing feature of this module is the 'jolly' key. When you set a value for
           it, all 'unknown' keys become aliases for the jolly key. This means that <b>you</b> <b>can't</b> <b>create</b> <b>new</b> <b>keys</b> in
           the hash, because if a key does not exists, the value will be 'redirected' to the jolly key.

           We make an example of how this works and for what can be useful.  Suppose you have a table of records
           with a 'city' field. You want to  count  the  occurrencies  for  Rome,  Paris  and  London  (possibly
           expressed in different languages), and count every other city as 'Other'.

             tie %cities, 'Tie::AliasHash';

             $cities{['Rome', 'Roma', 'Rom']} = 0;
             $cities{['Paris', 'Parigi']} = 0;
             $cities{['London', 'Londra', 'Londres']} = 0;
             $cities{'Other'} = 0;
             tied(%cities)-&gt;set_jolly('Other');

             while($city = get_city()) {
                 $cities{$city}++;
             }
             foreach $city (sort keys %cities) {
                 print "$city:\t$cities{$city}\n";
             }

           A possible output for the above script can be:

             London: 4
             Other:  92
             Paris:  7
             Rome:   16

           Also  note that the use of the jolly key is limited to fetch and store, it does not affect other hash
           operations, like exists, delete, each, keys and values.

</pre><h4><b>HISTORY</b></h4><pre>
       v1.02 (11 Mar 2016)
           Moved to github, using Build.PL instead of Makefile.PL, added license.

       v1.01 (26 Jun 2003)
           Fixed a bug in the EXISTS sub, now works as documented (thanks wk)

       v1.00 (07 Mar 2001)
           First released version

       v0.01 (20 Feb 2001)
           Original version; created by h2xs 1.20 with options

             -CAXn Tie::AliasHash

</pre><h4><b>AUTHOR</b></h4><pre>
       Aldo Calpini &lt;<a href="mailto:dada@perl.it">dada@perl.it</a>&gt;

perl v5.40.0                                       2024-10-13                                <u>Tie::<a href="../man3pm/AliasHash.3pm.html">AliasHash</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>