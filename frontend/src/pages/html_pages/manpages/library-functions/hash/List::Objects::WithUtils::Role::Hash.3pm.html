<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>List::Objects::WithUtils::Role::Hash - Hash manipulation methods</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblist-objects-withutils-perl">liblist-objects-withutils-perl_2.028003-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       List::Objects::WithUtils::Role::Hash - Hash manipulation methods

</pre><h4><b>SYNOPSIS</b></h4><pre>
         ## Via List::Objects::WithUtils::Hash -&gt;
         use List::Objects::WithUtils 'hash';

         my $hash = hash(foo =&gt; 'bar');

         $hash-&gt;set(
           foo =&gt; 'baz',
           pie =&gt; 'tasty',
         );

         my @matches = $hash-&gt;keys-&gt;grep(sub { $_[0] =~ /foo/ })-&gt;all;

         my $pie = $hash-&gt;get('pie')
           if $hash-&gt;exists('pie');

         for my $pair ( $hash-&gt;kv-&gt;all ) {
           my ($key, $val) = @$pair;
           ...
         }

         my $obj = $hash-&gt;inflate;
         my $foo = $obj-&gt;foo;

         ## As a Role -&gt;
         use Role::Tiny::With;
         with 'List::Objects::WithUtils::Role::Hash';

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A Role::Tiny role defining methods for creating and manipulating HASH-type objects.

       In addition to the methods documented below, these objects provide a "TO_JSON" method exporting a plain
       HASH-type reference for convenience when feeding JSON::Tiny or similar, as well as a "TO_ZPL" method for
       compatibility with Text::ZPL.

   <b>Basic</b> <b>hash</b> <b>methods</b>
       <u>new</u>

       Constructs a new HASH-type object.

       <u>copy</u>

       Creates a shallow clone of the current object.

       <u>defined</u>

         if ( $hash-&gt;defined($key) ) { ... }

       Returns boolean true if the key has a defined value.

       <u>exists</u>

         if ( $hash-&gt;exists($key) ) { ... }

       Returns boolean true if the key exists.

       <u>export</u>

         my %hash = $hash-&gt;export;

       Returns a raw key =&gt; value list.

       For a plain HASH-type reference, see: "unbless"

       <u>array_type</u>

       The class name of array-type objects that will be used to contain the results of methods returning a
       list.

       Defaults to List::Objects::WithUtils::Array.

       Subclasses can override "array_type" to produce different types of array objects.

       <u>inflate</u>

         my $obj = hash(foo =&gt; 'bar', baz =&gt; 'quux')-&gt;inflate;
         my $baz = $obj-&gt;baz;

       Inflates the hash-type object into a simple struct-like object with accessor methods matching the keys of
       the hash.

       By default, accessors are read-only; specifying "rw =" 1&gt; allows setting new values:

         my $obj = hash(foo =&gt; 'bar', baz =&gt; 'quux')-&gt;inflate(rw =&gt; 1);
         $obj-&gt;foo('frobulate');

       Returns an "inflated_type" (or "inflated_rw_type") object.

       The default objects provide a "DEFLATE" method returning a plain hash; this makes it easy to turn
       inflated objects back into a hash() for modification:

         my $first = hash( foo =&gt; 'bar', baz =&gt; 'quux' )-&gt;inflate;
         my $second = hash( $first-&gt;DEFLATE, frobulate =&gt; 1 )-&gt;inflate;

       <u>inflated_type</u>

       The class that objects are blessed into when calling "inflate".

       Defaults to List::Objects::WithUtils::Hash::Inflated.

       <u>inflated_rw_type</u>

       The class that objects are blessed into when calling "inflate" with "rw =" 1&gt; specified.

       Defaults to List::Objects::WithUtils::Hash::Inflated::RW, a subclass of
       List::Objects::WithUtils::Hash::Inflated.

       <u>is_empty</u>

       Returns boolean true if the hash has no keys.

       <u>is_mutable</u>

       Returns boolean true if the hash is mutable; immutable subclasses can override to provide a negative
       value.

       <u>is_immutable</u>

       The opposite of "is_mutable".

       <u>unbless</u>

       Returns a plain "HASH" reference (shallow clone).

   <b>Methods</b> <b>that</b> <b>manipulate</b> <b>the</b> <b>hash</b>
       <u>clear</u>

       Clears the current hash entirely.

       Returns the (same, but now empty) hash object.

       <u>delete</u>

         $hash-&gt;delete(@keys);

       Deletes the given key(s) from the hash.

       Returns an "array_type" object containing the deleted values.

       <u>set</u>

         $hash-&gt;set(
           key1 =&gt; $val,
           key2 =&gt; $other,
         )

       Sets keys in the hash.

       Returns the current hash object.

       <u>maybe_set</u>

         my $hash = hash(foo =&gt; 1, bar =&gt; 2, baz =&gt; 3);
         $hash-&gt;maybe_set(foo =&gt; 2, bar =&gt; 3, quux =&gt; 4);
         # $hash = +{ foo =&gt; 1, bar =&gt; 2, baz =&gt; 3, quux =&gt; 4 }

       Like "set", but only sets values that do not already exist in the hash.

       Returns the current hash object.

   <b>Methods</b> <b>that</b> <b>retrieve</b> <b>items</b>
       <u>get</u>

         my $val  = $hash-&gt;get($key);
         my @vals = $hash-&gt;get(@keys)-&gt;all;

       Retrieves a key or list of keys from the hash.

       If taking a slice (multiple keys were specified), values are returned as an "array_type" object. (See
       "sliced" if you'd rather generate a new hash.)

       <u>get_path</u>

         my $hash = hash(
           foo  =&gt; +{ bar =&gt; +{ baz =&gt; 'bork'  } },
           quux =&gt; [ +{ weeble =&gt; 'snork' } ],
         );
         my $item = $hash-&gt;get_path(qw/foo bar baz/);  # 'bork'

       Attempt to retrieve a value from a 'deep' hash (without risking autovivification).

       If an element of the given path is a (plain) array reference, as in this example:

         my $item = $hash-&gt;get_path('quux', [1], 'weeble');  # "snork"

       ... then it is taken as the index of an array or array-type object in the path.

       Returns undef if any of the path elements are nonexistant.

       An exception is thrown if an invalid access is attempted, such as trying to use a hash-type object as if
       it were an array.

       (Available from v2.15.1)

       <u>get_or_else</u>

         # Expect to find an array() obj at $key in $hash,
         # or create an empty one if $key doesn't exist:
         my @all = $hash-&gt;get_or_else($key =&gt; array)-&gt;all;

         # Or pass a coderef
         # First arg is the object being operated on
         # Second arg is the requested key
         my $item = $hash-&gt;get_or_else($key =&gt; sub { shift-&gt;get($defaultkey) });

       Retrieves a key from the hash; optionally takes a second argument that is used as a default value if the
       given key does not exist in the hash.

       If the second argument is a coderef, it is invoked on the object (with the requested key as an argument)
       and its return value is taken as the default value.

       <u>keys</u>

         my @keys = $hash-&gt;keys-&gt;all;

       Returns the list of keys in the hash as an "array_type" object.

       <u>values</u>

         my @vals = $hash-&gt;values-&gt;all;

       Returns the list of values in the hash as an "array_type" object.

       <u>inverted</u>

         my $hash = hash(
           a =&gt; 1,
           b =&gt; 2,
           c =&gt; 2,
           d =&gt; 3
         );
         my $newhash = $hash-&gt;inverted;
         # $newhash = +{
         #   1 =&gt; array('a'),
         #   2 =&gt; array('b', 'c'),
         #   3 =&gt; array('d'),
         # }

       Inverts the hash; the values of the original hash become keys in the new object. Their corresponding
       values are "array_type" objects containing the key(s) that mapped to the original value.

       This is a bit like reversing the hash, but lossless with regards to non-unique values.

       (Available from v2.14.1)

       <u>iter</u>

         my $iter = $hash-&gt;iter;
         while (my ($key, $val) = $iter-&gt;()) {
           # ...
         }

       Returns an iterator that, when called, returns ($key, $value) pairs.  When the list is exhausted, an
       empty list is returned.

       The iterator operates on a shallow clone of the hash, making it safe to operate on the original hash
       while using the iterator.

       (Available from v2.9.1)

       <u>kv</u>

         for my $pair ($hash-&gt;kv-&gt;all) {
           my ($key, $val) = @$pair;
         }

       Returns an "array_type" object containing the key/value pairs in the hash, each of which is a two-element
       (unblessed) ARRAY.

       <u>kv_grep</u>

         my $positive_vals = $hash-&gt;kv_grep(sub { $b &gt; 0 });

       Like "grep", but operates on pairs. See "pairgrep" in List::Util.

       Returns a hash-type object consisting of the key/value pairs for which the given block returned true.

       (Available from v2.21.1)

       <u>kv_map</u>

         # Add 1 to each value, get back an array-type object:
         my $kvs = hash(a =&gt; 2, b =&gt; 2, c =&gt; 3)
           -&gt;kv_map(sub { ($a, $b + 1) });

       Like "map", but operates on pairs. See "pairmap" in List::Util.

       Returns an "array_type" object containing the results of the map.

       (Available from v2.8.1; in versions prior to v2.20.1, $_[0] and $_[1] must be used in place of $a and $b,
       respectively.)

       <u>kv_sort</u>

         my $kvs = hash(a =&gt; 1, b =&gt; 2, c =&gt; 3)-&gt;kv_sort;
         # $kvs = array(
         #          [ a =&gt; 1 ],
         #          [ b =&gt; 2 ],
         #          [ c =&gt; 3 ]
         #        )

         my $reversed = hash(a =&gt; 1, b =&gt; 2, c =&gt; 3)
           -&gt;kv_sort(sub { $b cmp $a });
         # Reverse result as above

       Like "kv", but sorted by key. A sort routine can be provided.

       In versions prior to v2.19.1, $_[0] and $_[1] must be used in place of $a and $b, respectively.

       <u>random_kv</u>

       Returns a random key/value pair from the hash as an "ARRAY"-type reference.

       Returns undef if the hash is empty.

       (Available from v2.28.1)

       <u>random_key</u>

       Returns a random key from the hash.

       Returns undef if the hash is empty.

       (Available from v2.28.1)

       <u>random_value</u>

       Returns a random value from the hash.

       Returns undef if the hash is empty.

       (Available from v2.28.1)

       <u>sliced</u>

         my $newhash = $hash-&gt;sliced(@keys);

       Returns a new hash object built from the specified set of keys and their respective values.

       If a given key is not found in the hash, it is omitted from the result (this is different than
       "perl-5.20+" hash slice syntax, which sets unknown keys to "undef" in the slice).

       If you only need the values, see "get".

   <b>Methods</b> <b>that</b> <b>compare</b> <b>hashes</b>
       <u>intersection</u>

         my $first  = hash(a =&gt; 1, b =&gt; 2, c =&gt; 3);
         my $second = hash(b =&gt; 2, c =&gt; 3, d =&gt; 4);
         my $intersection = $first-&gt;intersection($second);
         my @common = $intersection-&gt;sort-&gt;all;

       Returns the list of keys common between all given hash-type objects (including the invocant) as an
       "array_type" object.

       <u>diff</u>

       The opposite of "intersection"; returns the list of keys that are not common to all given hash-type
       objects (including the invocant) as an "array_type" object.

</pre><h4><b>NOTES</b> <b>FOR</b> <b>CONSUMERS</b></h4><pre>
       If creating your own consumer of this role, some extra effort is required to make $a and $b work in sort
       statements without warnings; an example with a custom exported constructor might look something like:

         package My::Custom::Hash;
         use strictures 2;
         require Role::Tiny;
         Role::Tiny-&gt;apply_roles_to_package( __PACKAGE__,
           qw/
             List::Objects::WithUtils::Role::Hash
             My::Custom::Hash::Role
           /
         );

         use Exporter ();
         our @EXPORT = 'myhash';
         sub import {
           my $pkg = caller;
           { no strict 'refs';
             ${"${pkg}::a"} = ${"${pkg}::a"};
             ${"${pkg}::b"} = ${"${pkg}::b"};
           }
           goto &amp;Exporter::import
         }

         sub myhash { __PACKAGE__-&gt;new(@_) }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       List::Objects::WithUtils

       List::Objects::WithUtils::Hash

       List::Objects::WithUtils::Hash::Immutable

       List::Objects::WithUtils::Hash::Typed

       Data::Perl

</pre><h4><b>AUTHOR</b></h4><pre>
       Jon Portnoy &lt;<a href="mailto:avenj@cobaltirc.org">avenj@cobaltirc.org</a>&gt;

       Portions of this code are derived from Data::Perl by Matthew Phillips (CPAN: MATTP), haarg et al

       Licensed under the same terms as Perl.

perl v5.38.2                                       2024-03-07             <u>List::Objects::...ils::Role::<a href="../man3pm/Hash.3pm.html">Hash</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>