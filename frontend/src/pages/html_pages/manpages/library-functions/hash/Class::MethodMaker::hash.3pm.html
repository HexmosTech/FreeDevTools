<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::Method::hash - Create methods for handling a hash value.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-methodmaker-perl">libclass-methodmaker-perl_2.25-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::Method::hash - Create methods for handling a hash value.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Class::MethodMaker
           [ hash =&gt; [qw/ x /] ];

         $instance-&gt;x;                 # empty
         $instance-&gt;x(a =&gt; 1, b =&gt; 2, c =&gt; 3);
         $instance-&gt;x_count == 3;      # true
         $instance-&gt;x = (b =&gt; 5, d =&gt; 8); # Note this *replaces* the hash,
                                          # not adds to it
         $instance-&gt;x_index('b') == 5; # true
         $instance-&gt;x_exists('c');     # false
         $instance-&gt;x_exists('d');     # true

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Creates methods to handle hash values in an object.  For a component named "x", by default creates
       methods "x", "x_reset", "x_clear", "x_isset", "x_count", "x_index", "x_keys", "x_values", "x_each",
       "x_exists", "x_delete", "x_set", "x_get".

       Methods available are:

       <u>"*"</u>

       <u>Created</u> <u>by</u> <u>default</u>.  This method returns the list of keys and values stored in the slot (they are
       returned pairwise, i.e., key, value, key, value; as with perl hashes, no order of keys is guaranteed).
       If any arguments are provided to this method, they <b>replace</b> the current hash contents.  In an array
       context it returns the keys, values as an array and in a scalar context as a hash-reference.  Note that
       this reference is no longer a direct reference to the storage, in contrast to Class::MethodMaker v1.
       This is to protect encapsulation.  See x_ref if you need that functionality (and are prepared to take the
       associated risk.)

       If a single argument is provided that is an arrayref or hashref, it is expanded and its contents used in
       place of the existing contents.  This is a more efficient passing mechanism for large numbers of values.

       <u>*_reset</u>

       <u>Created</u> <u>by</u> <u>default</u>.  Called without an argument, this resets the component as a whole; deleting any
       associated storage, and returning the component to its default state.  Normally, this means that <u>*_isset</u>
       will return false, and <u>*</u> will return undef.  If "-default" is in effect, then the component will be set
       to the default value, and <u>*_isset</u> will return true.  If "-default_ctor" is in effect, then the default
       subr will be invoked, and its return value used to set the value of the component, and <u>*_isset</u> will
       return true.

       If called with arguments, these arguments are treated as indexes into the component, and the individual
       elements thus referenced are reset (their storage deleted, so that <u>*_isset(n)</u> will return false for
       appropriate <u>n</u>, except where "-default" or "-default_ctor" are in force, as above).  As with perl arrays,
       resetting the highest set value implicitly decreases the count (but x_reset(n) never unsets the aggregate
       itself, even if all the elements are not set).

       <u>*_clear</u>

       <u>Created</u> <u>by</u> <u>default</u>.  Empty the component of all elements, but without deleting the storage itself.

       If given a list of keys, then the elements <u>that</u> <u>exist</u> indexed by those keys are set to undef (but not
       deleted).

       Note the very different semantics: "$x-&gt;a_clear('b')" sets the value of "b" in component 'a' to undef (if
       "b") already exists (so "$x-&gt;a_isset('b'))" returns true), but "$x-&gt;a_clear()" deletes the element "b"
       from component 'a' (so "$x-&gt;a_isset('b'))" returns false).

       <u>*_isset</u>

       <u>Created</u> <u>by</u> <u>default</u>.  Whether the component is currently set.  This is different from being defined;
       initially, the component is not set (and if read, will return undef); it can be set to undef (which is a
       set value, which also returns undef).  Having been set, the only way to unset the component is with
       *_reset.

       If a default value is in effect, then *_isset will always return true.

       <u>*_<b>isset()</b></u> tests the component as a whole.  <u>*_isset(a)</u> tests the element indexed by <u>a</u>.  <u>*_isset(a,b)</u> tests
       the elements indexed by <u>a</u>, <u>b</u>, and returns the logical conjunction (<u>and</u>) of the tests.

       <u>*_count</u>

       <u>Created</u> <u>by</u> <u>default</u>.  Returns the number of elements in this component.  This is not affected by presence
       (or lack) of a "default" (or "default_ctor").  Returns "undef" if whole component not set (as per
       <u>*_isset</u>).

       <u>*_index</u>

       <u>Created</u> <u>by</u> <u>default</u>.  Takes a list of indices, returns a list of the corresponding values.

       If a default (or a default ctor) is in force, then a lookup by index will vivify &amp; set to the default the
       respective elements (and therefore the aggregate data-structure also, if it's not already).

       <u>*_keys</u>

       <u>Created</u> <u>by</u> <u>default</u>.  The known keys, as a list in list context, as an arrayref in scalar context.

       If you're expecting a count of the keys in scalar context, see <u>*_count</u>.

       <u>*_values</u>

       <u>Created</u> <u>by</u> <u>default</u>.  The known values, as a list in list context, as an arrayref in scalar context.

       <u>*_each</u>

       <u>Created</u> <u>by</u> <u>default</u>.  The next pair of key, value (as a list) from the hash.

       <u>*_exists</u>

       <u>Created</u> <u>by</u> <u>default</u>.  Takes any number of arguments, considers each as a key, and determines whether the
       key exists in the has.  Returns the logical conjunction (<u>and</u>).

       <u>*_delete</u>

       <u>Created</u> <u>by</u> <u>default</u>.  This operates exactly like <u>*_reset</u>, except that calling this with no args does
       nothing.  This is provided for orthogonality with the Perl "delete" operator, while <u>*_reset</u> is provided
       for orthogonality with other component types.

       <u>*_set</u>

         %n = $x-&gt;h; # (a=&gt;1,b=&gt;2,c=&gt;3) (in some order)
         $h-&gt;h_set(b=&gt;4,d=&gt;7);
         %n = $h-&gt;a; # (a=&gt;1,b=&gt;4,c=&gt;3,d=&gt;7) (in some order)

       <u>Created</u> <u>by</u> <u>default</u>.  Takes a list, treated as pairs of index =&gt; value; each given index is set to the
       corresponding value.  No return.

       If two arguments are given, of which the first is an arrayref, then it is treated as a list of indices of
       which the second argument (which must also be an arrayref) are the corresponding values.  Thus the
       following two commands are equivalent:

         $x-&gt;a_set(b=&gt;4,d=&gt;7);
         $x-&gt;a_set(['b','d'],[4,7]);

       <u>*_get</u>

       <u>Created</u> <u>by</u> <u>default</u>.  Retrieves the value of the component without setting (ignores any arguments passed).

perl v5.40.0                                       2024-11-15                      <u>Class::MethodMaker::<a href="../man3pm/hash.3pm.html">hash</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>