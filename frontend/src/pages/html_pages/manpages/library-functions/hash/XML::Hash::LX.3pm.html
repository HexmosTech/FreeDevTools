<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Hash::LX - Convert hash to xml and xml to hash using LibXML</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-hash-lx-perl">libxml-hash-lx-perl_0.0603-1.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Hash::LX - Convert hash to xml and xml to hash using LibXML

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use XML::Hash::LX;

           my $hash = xml2hash $xmlstring, attr =&gt; '.', text =&gt; '~';
           my $hash = xml2hash $xmldoc;

           my $xmlstr = hash2html $hash, attr =&gt; '+', text =&gt; '#text';
           my $xmldoc = hash2html $hash, doc =&gt; 1, attr =&gt; '+';

           # Usage with XML::LibXML

           my $doc = XML::LibXML-&gt;new-&gt;parse_string($xml);
           my $xp  = XML::LibXML::XPathContext-&gt;new($doc);
           $xp-&gt;registerNs('rss', '<a href="http://purl.org/rss/1.0/">http://purl.org/rss/1.0/</a>');

           # then process xpath
           for ($xp-&gt;findnodes('//rss:item')) {
               # and convert to hash concrete nodes
               my $item = xml2hash($_);
               print Dumper+$item
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is a companion for "XML::LibXML". It operates with LibXML objects, could return or accept
       LibXML objects, and may be used for easy data transformations

       It is faster in parsing then XML::Simple, XML::Hash, XML::Twig and of course much slower than XML::Bare
       ;)

       It is faster in composing than XML::Hash, but slower than XML::Simple

       Parse benchmark:

                      Rate   Simple     Hash     Twig Hash::LX     Bare
           Simple   11.3/s       --      -2%     -16%     -44%     -97%
           Hash     11.6/s       2%       --     -14%     -43%     -97%
           Twig     13.5/s      19%      16%       --     -34%     -96%
           Hash::LX 20.3/s      79%      75%      51%       --     -95%
           Bare      370/s    3162%    3088%    2650%    1721%       --

       Compose benchmark:

                      Rate     Hash Hash::LX   Simple
           Hash     49.2/s       --     -18%     -40%
           Hash::LX 60.1/s      22%       --     -26%
           Simple   81.5/s      66%      36%       --

       Benchmark was done on &lt;<a href="http://search.cpan.org/uploads.rdf">http://search.cpan.org/uploads.rdf</a>&gt;

</pre><h4><b>EXPORT</b></h4><pre>
       "xml2hash" and "hash2xml" are exported by default

   <b>:inject</b>
       Inject toHash method in the namespace of XML::LibXML::Node and allow one to call it on any subclass of
       XML::LibXML::Node directly

       By default is disabled

           use XML::Hash::LX ':inject';

           my $doc = XML::LibXML-&gt;new-&gt;parse_string($xml);
           my $hash = $doc-&gt;toHash(%opts);

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>xml2hash</b> <b>$xml,</b> <b>[</b> <b>OPTIONS</b> <b>]</b>
       XML could be XML::LibXML::Document, XML::LibXML::DocumentPart or string

   <b>hash2xml</b> <b>$hash,</b> <b>[</b> <b>doc</b> <b>=&gt;</b> <b>1,</b> <b>]</b> <b>[</b> <b>OPTIONS</b> <b>]</b>
       Id "doc" option is true, then returned value is XML::LibXML::Document, not string

</pre><h4><b>OPTIONS</b></h4><pre>
       Every option could be passed as arguments to function or set as global variable in "XML::Hash::LX"
       namespace

   <b>%XML::Hash::LX::X2H</b>
       Options respecting convertations from xml to hash

       order [ = 0 ]
           <b>Strictly</b>  keep  the  output  order.  When  enabled,  structures become more complex, but xml could be
           completely reverted

       attr [ = '-' ]
           Attribute prefix

                   &lt;node attr="test" /&gt;  =&gt;  { node =&gt; { -attr =&gt; "test" } }

       text [ = '#text' ]
           Key name for storing text

                   &lt;node&gt;text&lt;sub /&gt;&lt;/node&gt;  =&gt;  { node =&gt; { sub =&gt; '', '#text' =&gt; "test" } }

       join [ = '' ]
           Join separator for text nodes, split by subnodes

           Ignored when "order" in effect

                   # default:
                   xml2hash( '&lt;item&gt;Test1&lt;sub /&gt;Test2&lt;/item&gt;' )
                   : { item =&gt; { sub =&gt; '', '~' =&gt; 'Test1Test2' } };

                   # global
                   $XML::Hash::LX::X2H{join} = '+';
                   xml2hash( '&lt;item&gt;Test1&lt;sub /&gt;Test2&lt;/item&gt;' )
                   : { item =&gt; { sub =&gt; '', '~' =&gt; 'Test1+Test2' } };

                   # argument
                   xml2hash( '&lt;item&gt;Test1&lt;sub /&gt;Test2&lt;/item&gt;', join =&gt; '+' )
                   : { item =&gt; { sub =&gt; '', '~' =&gt; 'Test1+Test2' } };

       trim [ = 1 ]
           Trim leading and trailing whitespace from text nodes

       cdata [ = undef ]
           When defined, CDATA sections will be stored under this key

                   # cdata = undef
                   &lt;node&gt;&lt;![CDATA[ test ]]&gt;&lt;/node&gt;  =&gt;  { node =&gt; 'test' }

                   # cdata = '#'
                   &lt;node&gt;&lt;![CDATA[ test ]]&gt;&lt;/node&gt;  =&gt;  { node =&gt; { '#' =&gt; 'test' } }

       comm [ = undef ]
           When defined, comments sections will be stored under this key

           When undef, comments will be ignored

                   # comm = undef
                   &lt;node&gt;&lt;!-- comm --&gt;&lt;sub/&gt;&lt;/node&gt;  =&gt;  { node =&gt; { sub =&gt; '' } }

                   # comm = '/'
                   &lt;node&gt;&lt;!-- comm --&gt;&lt;sub/&gt;&lt;/node&gt;  =&gt;  { node =&gt; { sub =&gt; '', '/' =&gt; 'comm' } }

   <b>$XML::Hash::LX::X2A</b> <b>[</b> <b>=</b> <b>0</b> <b>]</b>
       Global array casing

       Ignored when "X2H{order}" in effect

       As option should be passed as

               xml2hash $xml, array =&gt; 1;

       Effect:

               # $X2A = 0
               &lt;node&gt;&lt;sub/&gt;&lt;/node&gt;  =&gt;  { node =&gt; { sub =&gt; '' } }

               # $X2A = 1
               &lt;node&gt;&lt;sub/&gt;&lt;/node&gt;  =&gt;  { node =&gt; [ { sub =&gt; [ '' ] } ] }

   <b>%XML::Hash::LX::X2A</b>
       By element array casing

       Ignored when "X2H{order}" in effect

       As option should be passed as

               xml2hash $xml, array =&gt; [ nodes list ];

       Effect:

               # %X2A = ()
               &lt;node&gt;&lt;sub/&gt;&lt;/node&gt;  =&gt;  { node =&gt; { sub =&gt; '' } }

               # %X2A = ( sub =&gt; 1 )
               &lt;node&gt;&lt;sub/&gt;&lt;/node&gt;  =&gt;  { node =&gt; { sub =&gt; [ '' ] } }

   <b>%XML::Hash::LX::H2X</b>
       Options respecting convertations from hash to xml

       encoding [ = 'utf-8' ]
           XML output encoding

       attr [ = '-' ]
           Attribute prefix

                   { node =&gt; { -attr =&gt; "test", sub =&gt; 'test' } }
                   &lt;node attr="test"&gt;&lt;sub&gt;test&lt;/sub&gt;&lt;/node&gt;

       text [ = '#text' ]
           Key name for storing text

                   { node =&gt; { sub =&gt; '', '#text' =&gt; "test" } }
                   &lt;node&gt;text&lt;sub /&gt;&lt;/node&gt;
                   # or
                   &lt;node&gt;&lt;sub /&gt;text&lt;/node&gt;
                   # order of keys is not predictable

       trim [ = 1 ]
           Trim leading and trailing whitespace from text nodes

                   # trim = 1
                   { node =&gt; { sub =&gt; [ '    ', 'test' ], '#text' =&gt; "test" } }
                   &lt;node&gt;test&lt;sub&gt;test&lt;/sub&gt;&lt;/node&gt;

                   # trim = 0
                   { node =&gt; { sub =&gt; [ '    ', 'test' ], '#text' =&gt; "test" } }
                   &lt;node&gt;test&lt;sub&gt;    test&lt;/sub&gt;&lt;/node&gt;

       cdata [ = undef ]
           When defined, such key elements will be saved as CDATA sections

                   # cdata = undef
                   { node =&gt; { '#' =&gt; 'test' } } =&gt; &lt;node&gt;&lt;#&gt;test&lt;/#&gt;&lt;/node&gt; # it's bad ;)

                   # cdata = '#'
                   { node =&gt; { '#' =&gt; 'test' } } =&gt; &lt;node&gt;&lt;![CDATA[test]]&gt;&lt;/node&gt;

       comm [ = undef ]
           When defined, such key elements will be saved as comment sections

                   # comm = undef
                   { node =&gt; { '/' =&gt; 'test' } } =&gt; &lt;node&gt;&lt;/&gt;test&lt;//&gt;&lt;/node&gt; # it's very bad! ;)

                   # comm = '/'
                   { node =&gt; { '/' =&gt; 'test' } } =&gt; &lt;node&gt;&lt;!-- test --&gt;&lt;/node&gt;

</pre><h4><b>BUGS</b></h4><pre>
       None known

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       â€¢   XML::Parser::Style::EasyTree

           With default settings should produce the same output as this module. Settings are similar by effect

</pre><h4><b>AUTHOR</b></h4><pre>
       Mons Anderson, "&lt;mons at cpan.org&gt;"

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2009 Mons Anderson, all rights reserved.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.32.0                                       2021-01-05                                 <u>XML::Hash::<a href="../man3pm/LX.3pm.html">LX</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>