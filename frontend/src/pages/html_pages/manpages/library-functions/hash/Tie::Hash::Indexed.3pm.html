<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tie::Hash::Indexed - Ordered hashes for Perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtie-hash-indexed-perl">libtie-hash-indexed-perl_0.08+ds1-1build6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tie::Hash::Indexed - Ordered hashes for Perl

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Tie::Hash::Indexed;

         # Object Oriented Interface
         my $hash = Tie::Hash::Indexed-&gt;new(
                      I =&gt; 1, n =&gt; 2, d =&gt; 3, e =&gt; 4);
         $hash-&gt;push(x =&gt; 5);

         print $hash-&gt;keys, "\n";   # prints 'Index'
         print $hash-&gt;values, "\n"; # prints '12345'

         # Tied Interface
         tie my %hash, 'Tie::Hash::Indexed';

         %hash = ( I =&gt; 1, n =&gt; 2, d =&gt; 3, e =&gt; 4 );
         $hash{x} = 5;

         print keys %hash, "\n";    # prints 'Index'
         print values %hash, "\n";  # prints '12345'

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Tie::Hash::Indexed is intentionally very similar to other ordered hash modules, most prominently
       Hash::Ordered.  However, Tie::Hash::Indexed is written completely in XS and is, often significantly,
       faster than other modules.  For a lot of operations, it's more than twice as fast as Hash::Ordered,
       especially when using the object-oriented interface instead of the tied interface. Other modules, for
       example Tie::IxHash, are even slower.

       The object-oriented interface of Tie::Hash::Indexed is almost identical to that of Hash::Ordered, so in
       most cases you should be able to easily replace one with the other.

       If you don't need the last bit of performance and feel more comfortable with a pure-Perl module,
       Hash::Ordered is definitely a good alternative.

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       Tie::Hash::Indexed should build with perl versions as old as 5.005. It should build on any platform if a
       C compiler is available.

   <b>Hash::Ordered</b>
       Tie::Hash::Indexed has no "clone" method, but cloning can be emulated with:

         $clone = Tie::Hash::Indexed-&gt;new($orig-&gt;items);

       Tie::Hash::Indexed has an "items" method as an alias for "as_list", which Hash::Ordered lacks. If you
       want to be able to switch modules, you should prefer to use "as_list".

       Tie::Hash::Indexed also has a "has" method as an alias for "exists".

       Tie::Hash::Indexed also has "dor_assign" and "or_assign" as aliases for "dor_equals" and "or_equals".

       Tie::Hash::Indexed has "multiply", "divide" and "modulo" methods in addition to "add" and "subtract".
       Hash::Ordered only supports "add" and "subtract".

       Tie::Hash::Indexed has an "assign" method that can be used to directly assign a new list of key-value
       pairs to an existing instance. With Hash::Ordered, you can call "clear" followed by "merge" to get the
       same behaviour.

       Tie::Hash::Indexed has a "reverse_iterator" method, which can be emulated in Hash::Ordered by passing the
       reversed list of keys to "iterator". On the other hand, the "iterator" method of Tie::Hash::Indexed
       doesn't support passing in a list of keys at all.

       Tie::Hash::Indexed objects always evaluate to a true value in boolean context, unlike Hash::Ordered
       object, which evaluate to a false value if they are empty, and a true value otherwise.  You can use
       "$obj-"keys&gt; with Tie::Hash::Indexed instead, which is extremely cheap to call in scalar context.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
         $obj = Tie::Hash::Indexed-&gt;new;
         $obj = Tie::Hash::Indexed-&gt;new(@kvpairs);

       Construct and optionally initialize a new object.

   <b>clear</b>
         $obj-&gt;clear;

       Removes all contents from the hash. Returns the object, which allows for method chaining.

       Invalidates iterators.

   <b>assign</b>
         $obj-&gt;assign(@kvpairs);

       Clears the hash and assigns the list of key-value pairs.  Identical to:

         $obj-&gt;clear-&gt;merge(@kvpairs);

       Returns the number of keys stored in the hash after assigning.

       Invalidates iterators.

   <b>merge</b>
         $obj-&gt;merge(@kvpairs);

       Merge a lists of key-value pairs into the hash. Existing keys will remain in their position and have
       their value updated.  New keys will be appended to the end.

       Returns the number of keys stored in the hash after merging.

       Invalidates iterators.

   <b>exists</b>
         $bool = $obj-&gt;exists($key)

       Returns a boolean indicating if a key exists in the hash.

   <b>has</b>
       An alias for "exists".

   <b>get</b>
         $value = $obj-&gt;get($key)

       Returns the value for a single key, or "undef" if the key was not found.

   <b>set</b>
         $obj-&gt;set($key, $value)

       If the key already exists, update the value without affecting the item order. Otherwise append the key-
       value pair. This is equivalent to calling "merge" with a single key-value pair, except for the return
       value.

       Returns the value.

       Invalidates iterators.

   <b>push</b>
         $obj-&gt;push(@kvpairs)

       Push one or more key-value pairs. This is similar to "merge", but instead of preserving the position of
       existing keys, this will remove existing keys and append all key-value pairs to the end.

       Returns the number of keys stored in the hash after pushing.

       Invalidates iterators.

   <b>unshift</b>
         $obj-&gt;unshift(@kvpairs)

       Pushes one or more key-value pairs to the start. This is similar to "push", but operates on the start of
       the ordered hash.  Existing keys will be removed and inserted at the start.

       Returns the number of keys stored in the hash after unshifting.

       Invalidates iterators.

   <b>pop</b>
         $value = $obj-&gt;pop;
         ($key, $value) = $obj-&gt;pop;

       Removes the last item from the ordered hash.

       Returns the value in scalar context or the key-value pair in list context.

       Invalidates iterators.

   <b>shift</b>
         $value = $obj-&gt;shift;
         ($key, $value) = $obj-&gt;shift;

       Removes the first item from the ordered hash.

       Returns the value in scalar context or the key-value pair in list context.

       Invalidates iterators.

   <b>delete</b>
         $value = $obj-&gt;delete($key);

       Removes a key-value pair from the ordered hash and returns the value.

       Invalidates iterators if the key was found.

   <b>items</b>
         @kvpairs = $obj-&gt;items;
         @kvpairs = $obj-&gt;items(@keys);

       Returns the key-value pairs for all items in the hash, or just for the selected keys. In scalar context,
       returns the number of list elements that would be returned in list context.

       If a key is not found, the associated value will be returned as "undef".

   <b>as_list</b>
       An alias for "items".

   <b>keys</b>
         @keys = $obj-&gt;keys;
         @keys = $obj-&gt;keys(@keys);

       Returns the keys for all items in the hash, or just for the selected keys. In scalar context, returns the
       number of list elements that would be returned in list context.

   <b>values</b>
         @values = $obj-&gt;values;
         @values = $obj-&gt;values(@keys);

       Returns the values for all items in the hash, or just for the selected keys. In scalar context, returns
       the number of list elements that would be returned in list context.

       If a key is not found, the associated value will be returned as "undef".

   <b>concat</b>
         $obj-&gt;concat($key, $str);

       This is equivalent to, but more efficient than:

         $obj-&gt;set($key, $obj-&gt;get($key) . $str);

   <b>add</b>
         $obj-&gt;add($key, $value);

       This is equivalent to, but more efficient than:

         $obj-&gt;set($key, $obj-&gt;get($key) + $value);

   <b>subtract</b>
         $obj-&gt;subtract($key, $value);

       This is equivalent to, but more efficient than:

         $obj-&gt;set($key, $obj-&gt;get($key) - $value);

   <b>multiply</b>
         $obj-&gt;multiply($key, $value);

       This is equivalent to, but more efficient than:

         $obj-&gt;set($key, $obj-&gt;get($key) * $value);

   <b>divide</b>
         $obj-&gt;divide($key, $value);

       This is equivalent to, but more efficient than:

         $obj-&gt;set($key, $obj-&gt;get($key) / $value);

   <b>modulo</b>
         $obj-&gt;modulo($key, $value);

       This is equivalent to, but more efficient than:

         $obj-&gt;set($key, $obj-&gt;get($key) % $value);

   <b>dor_assign</b>
         $obj-&gt;dor_assign($key, $value);

       This is equivalent to, but more efficient than:

         $obj-&gt;set($key, $obj-&gt;get($key) // $value);

   <b>dor_equals</b>
       This is an alias for "dor_assign".

   <b>or_assign</b>
         $obj-&gt;or_assign($key, $value);

       This is equivalent to, but more efficient than:

         $obj-&gt;set($key, $obj-&gt;get($key) || $value);

   <b>or_equals</b>
       This is an alias for "or_assign".

   <b>postinc</b>
         $val = $obj-&gt;postinc($key);

       This is equivalent to, but more efficient than:

         $val = $obj-&gt;get($key);
         $obj-&gt;set($key, $val + 1);

   <b>postdec</b>
         $val = $obj-&gt;postdec($key);

       This is equivalent to, but more efficient than:

         $val = $obj-&gt;get($key);
         $obj-&gt;set($key, $val - 1);

   <b>preinc</b>
         $val = $obj-&gt;preinc($key);

       This is equivalent to, but more efficient than:

         $val = $obj-&gt;set($key, $obj-&gt;get($key) + 1);

   <b>predec</b>
         $val = $obj-&gt;predec($key);

       This is equivalent to, but more efficient than:

         $val = $obj-&gt;set($key, $obj-&gt;get($key) - 1);

   <b>iterator</b>
         my $i = $h-&gt;iterator;
         while (my($k, $v) = $i-&gt;next) {
           push @key, $k;
           push @val, $v;
         }

       Bidirectional forward iterator for ordered hash traversal.

   <b>reverse_iterator</b>
         for (my $i = $h-&gt;reverse_iterator; $i-&gt;valid; $i-&gt;next) {
           push @key, $i-&gt;key;
           push @val, $i-&gt;value;
         }

       Bidirectional reverse iterator for ordered hash traversal.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
   <b>"THI_DEBUG_OPT"</b>
       If Tie::Hash::Indexed is built with debugging support, you can use this environment variable to specify
       debugging options. Currently, the only useful values you can pass in are "d" or "all", which both enable
       debug output for the module.

</pre><h4><b>PROBLEMS</b></h4><pre>
       As the data of Tie::Hash::Indexed objects is hidden inside the XS implementation, cloning/serialization
       is problematic.  Tie::Hash::Indexed implements hooks for Storable, so cloning or serializing objects
       using Storable is safe.

       Tie::Hash::Indexed tries very hard to detect any corruption in its data at runtime. So if something goes
       wrong, you'll most probably receive an appropriate error message.

</pre><h4><b>BUGS</b></h4><pre>
       If you find any bugs, Tie::Hash::Indexed doesn't seem to build on your system or any of its tests fail,
       please report the issue at &lt;https://github.com/mhx/Tie-Hash-Indexed/issues&gt;.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) Marcus Holland-Moritz. All rights reserved.  This program is free software; you can
       redistribute it and/or modify it under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See perltie, Hash::Ordered, Tie::IxHash.

perl v5.40.0                                       2024-10-20                            <u>Tie::Hash::<a href="../man3pm/Indexed.3pm.html">Indexed</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>