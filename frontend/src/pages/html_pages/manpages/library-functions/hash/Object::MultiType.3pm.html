<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Object::MultiType - Perl Objects as Hash, Array, Scalar, Code and Glob at the same time.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libobject-multitype-perl">libobject-multitype-perl_0.05-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Object::MultiType - Perl Objects as Hash, Array, Scalar, Code and Glob at the same time.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Object::MultiType ;

         my $scalar = 'abc' ;
         my @array  = qw(x y z);
         my %hash   = (A =&gt; 1 , B =&gt; 2) ;

         my $obj = Object::MultiType-&gt;new(
         scalar =&gt; \$scalar ,
         array  =&gt; \@array ,
         hash   =&gt; \%hash ,
         code   =&gt; sub{ return("I'm a sub ref!") ; }
         glob   =&gt; \*STDOUT ,
         ) ;

         print "Me as scalar: $obj\n" ;

         my $array_1 = $obj-&gt;[1] ;
         print "$array_1\n" ;

         my $hash_B = $obj-&gt;{B} ;
         print "$hash_B\n" ;

         my $hash = $$obj-&gt;hash ;
         foreach my $Key (sort keys %$hash ) {
           print "$Key = $$hash{$Key}\n" ;
         }

         &amp;$obj(args) ;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module return an object that works like a Hash, Array, Scalar, Code and Glob object at the same
       time.

       The usual way is to call it from your module at <b>new()</b>:

         package FOO ;

         use Object::MultiType ;
         use vars qw(@ISA) ;
         @ISA = qw(Object::MultiType) ; ## Is good to 'Object::MultiType' be the last in @ISA!

         sub new {
           my $class = shift ;
           my $this = Object::MultiType-&gt;new() ;
           bless($this,$class) ;
         }

</pre><h4><b>METHODS</b></h4><pre>
       ** See the methods of the Saver too.

   <b>new</b>
       <b>Arguments</b>:

       bool      The <u>boolean</u> reference. Default: undef

       boolcode|boolsub
                 Set the sub/function (CODE reference) that will return/generate the <u>boolean</u> value.

       scalar    The SCALAR reference. If not sent a null SCALAR will be created.

       scalarcode|scalarsub
                 Set the sub/function (CODE reference) that will return/generate the scalar data of the object.

       array     The ARRAY reference. If not sent a null ARRAY will be created.

       hash      The HASH reference. If not sent a null HASH will be created.

       code      The CODE reference. If not sent a null sub{} will be created.

                 With this your object can be used as a sub reference:

                   my $multi = Object::MultiType-&gt;new( code =&gt; sub { print "Args: @_\n" ;} ) ;
                   &amp;$multi();

                 Note that the first argument sent to the SUB is the object ($multi).

       glob      The GLOB (HANDLE) reference. If not sent a null GLOB will be created.

                 **  Note that you can't use the default (null) GLOB created when you don't paste this argument!
                 Since all the objects will share it, and was there just to avoid erros!

       tiearray  Package name to create a TIEARRAY. The argument $$this is sent to <b>tie()</b>.

                 <b>tie()</b> is called as:

                   tie(@array,$args{tiearray},$$this) ;

                 Note that is hard to implement the tie methods for PUSH, POP, SHIFT, UNSHIFT, SPLICE...  Unless
                 you make just an alias to another array through the tie methods.

                 ** See <b>tiehash</b> too.

       tiehash   Package name to create a TIEHASH. The argument $$this is sent to <b>tie()</b>.

                 <b>tie()</b> is called as:

                   tie(%hash,$args{tiehash},$$this) ;

                 ** $$this (the Saver) is sent, and not $this, to avoid the break of DESTROY (auto reference).

                 ** $$this is a reference to the Saver object that save the SCALAR, ARRAY, HASH, CODE and GLOB.

                   sub TIEHASH {
                     my $class = shift ;
                     my $multi = shift ; ## $$this

                     my $scalarref = $multi-&gt;scalar ; ## \${*$multi}
                     my $arrayref  = $multi-&gt;array  ; ## \@{*$multi}
                     my $hashref   = $multi-&gt;hash   ; ## \%{*$multi}

                     my $this = { s =&gt; $scalarref , a =&gt; $arrayref , h =&gt; $hashref } ;
                     bless($this,$class) ;
                   }

       tiehandle Make the object works like a tied glob (TIEHANDLE).

                 If used with <u>glob</u> will <b>tie()</b> it. If <u>glob</u> is not sent a NULL GLOB is used:

                   my $multi = Object::MultiType-&gt;new(
                   glob      =&gt; \*MYOUT ,               ## 'glob' is Optional.
                   tiehandle =&gt; 'TieHandlePack' ,
                   ) ;

       tieonuse  The reference is only tied when it's used! So, the HASH, ARRAY or GLOB (handle) are  only  tied
                 if/when they are accessed.

       nodefault If  set  to  true  tell to not create the default references inside the Saver, and it will have
                 only the references paste (scalar, array, hash, code, glob).

                 ** This is good to save memory.

   <b>is_saver</b>
       Return 0. Good to see if what you have is the Saver or the MultiType object.

</pre><h4><b>SAVER</b></h4><pre>
       The MultiType object has a Saver object (Object::MultiType::Saver), that save all the different data type
       (references). This saver can be accessed from the main object:

         my $multi = Object::MultiType-&gt;new() ;

         my $saver = $$multi ;
         print $saver-&gt;scalar ;

       <b>If</b> <b>you</b> <b>want</b> <b>to</b> <b>save</b> <b>attributes</b> <b>in</b> <b>your</b> <b>Object</b> <b>and</b> <b>you</b> <b>use</b> <u><b>tiehash</b></u><b>,</b> <b>you</b> <b>can't</b> <b>set</b> <b>attributes</b>  <b>directly</b>  <b>in</b>
       <b>the</b> <b>MultiType</b> <b>object</b>!:

         sub new {
           my $class = shift ;
           my $this = Object::MultiType-&gt;new(tiehash =&gt; 'TieHashPack') ;

           ## Dont do that! This will call the STORE() at TIEHASH, and not save it in the object:
           $this-&gt;{flagx} = 1 ;

           bless($this,$class) ;
         }

       So, if you use tiehash and want to save attributes (outside tie) use that:

           ## This save the attribute inside the Saver:
           $$this-&gt;{flagx} = 1 ;

       Note that this set an attribute in the saver, and it has their own attributes!

         ## $saver = $$this ;

         $saver-&gt;{s} ## the sacalar ref.
         $saver-&gt;{a} ## the array ref.
         $saver-&gt;{h} ## the hash ref.
         $saver-&gt;{c} ## the code ref.
         $saver-&gt;{g} ## the glob ref.

       ** See <u>"Direct</u> <u>access</u> <u>to</u> <u>the</u> <u>data</u> <u>types"</u>.

</pre><h4><b>DESTROY</b></h4><pre>
       When  the  object  is  DESTROIED,  the  Saver inside it is cleanned, so the tied objects can be DESTROIED
       automatically too.

</pre><h4><b>Direct</b> <b>access</b> <b>to</b> <b>the</b> <b>data</b> <b>types</b></h4><pre>
       To access directly the reference of the different data types (SCALAR, ARRAY, HASH, CODE &amp; GLOB) use:

         my $multi = Object::MultiType-&gt;new() ;

         my $saver = $$multi ;

         my $scalarref = $saver-&gt;scalar ; ## $saver-&gt;{s}
         my $arrayref  = $saver-&gt;array  ; ## $saver-&gt;{a}
         my $hashref   = $saver-&gt;hash   ; ## $saver-&gt;{h}
         my $coderef   = $saver-&gt;code   ; ## $saver-&gt;{c}
         my $globeref  = $saver-&gt;glob   ; ## $saver-&gt;{g}

         ## You can access the Saver directly from the main object:
         $$multi-&gt;hash  ;

       Setting the data:

         $saver-&gt;set_bool( 1 ) ;
         $saver-&gt;set_scalar( 'xyz' ) ;
         $saver-&gt;set_array( [qw(x y z)] ) ;
         $saver-&gt;set_hash( {X =&gt; 1} ) ;
         $saver-&gt;set_code( sub{ print "XYZ\n" ; } ) ;
         $saver-&gt;set_glob( \*STDOUT ) ;

</pre><h4><b>As</b> <b>SCALAR</b></h4><pre>
       You can use it as SCALAR when you put it inside quotes or make a copy of it:

         my $multi = Object::MultiType-&gt;new( scalar =&gt; 'Foo' ) ;

         ## Quote:
         print "Me as scalar: $multi\n" ;

         ## Copy:
         my $str = $multi ;
         $str .= '_x' ; ## Copy made when you change it! Until that $str works like $multi.
         print "$str\n" ;

       using the argument <b>scalarsub</b> you can use a function that will generate the scalar data, in the place of a
       reference to a SCALAR:

         my $multi = Object::MultiType-&gt;new(scalarsub =&gt; sub{ return 'generated data' ;} ) ;

         print "My scalar have $multi!\n" ;

</pre><h4><b>As</b> <b>ARRAY</b></h4><pre>
       You can use it as ARRAY directly from the object:

         my $multi = Object::MultiType-&gt;new( array =&gt; [qw(FOO BAR)] ) ;
         my $array_0 = $multi-&gt;[0] ;
         $multi-&gt;[1] = 'foo' ;

</pre><h4><b>As</b> <b>HASH</b></h4><pre>
       You can use it as HASH directly from the object:

         my $multi = Object::MultiType-&gt;new( hash =&gt; {key =&gt; 'foo'} ) ;
         my $k = $multi-&gt;{key} ;
         $multi-&gt;{foo} = 'bar' ;

</pre><h4><b>With</b> <b>TIE</b></h4><pre>
       To use your ARRAY and HASH part tied, you can paste the reference already tied of the HASH or  ARRAY,  or
       use the arguments tiehash and tiearray at <b>new()</b>:

         ## Using the reference:
         my %hash ;
         tie(%hash,'TieHash') ;
         my $multi = Object::MultiType-&gt;new(hash =&gt; \%hash) ;

         ## Or using directly the argument:
         my $multi = Object::MultiType-&gt;new(tiehash =&gt; 'TieHashPack') ;

       Note that using tiehash or tiearray is better, since your tied HASH or ARRAY can see the object Saver and
       the other data type of it. <b>See</b> <b>the</b> <b>method</b> <b>new()</b> <b>and</b> <b>their</b> <b>arguments</b>.

       Here's an example of a TieHash package that is called from Object::MultiType-&gt;<b>new()</b>:

         ## The call inside Object::MultiType-&gt;new():
         tie(%hash,$args{tiehash},$$this) ;

         ## The package:
         package TieHash ;

         sub TIEHASH {
             my $class = shift ;
             my $Saver = shift ; ## Object::MultiType paste as $$this (only the Saver) to avoid break of DESTROY!
                                 ## $this = Object::MultiType &gt;&gt; $$this = Object::MultiType::Saver

             my $scalarref = $Saver-&gt;scalar ;
             my $arrayref  = $Saver-&gt;array  ;

             ## Note that $Saver-&gt;hash will return the tied hash, and is not needed here!
             ## my $hashref   = $Saver-&gt;hash ;

             ## Saving the references inside the TIE object:
             my $this = { scalar =&gt; $scalarref , array =&gt; $arrayref , hash =&gt; {} } ;

             bless($this,$class) ;
         }

         sub FETCH    { my $this = shift ; return( 'key' ) ;}

         sub NEXTKEY  { my $this = shift ; return( 'key' ) ;}

         sub STORE    { my $this = shift ; $this-&gt;{hash}{$_[0]} = $_[1] }

         sub DELETE   { my $this = shift ; delete $this-&gt;{hash}{$_[0]} }

         sub CLEAR    { my $this = shift ; $this-&gt;{hash} = {} ;}

         sub EXISTS   { my $this = shift ; defined $this-&gt;{hash}{$_[0]} ;}

         sub FIRSTKEY { my $this = shift ; (sort keys %{$this-&gt;{hash}} )[0] }

         sub DESTROY  {}

       <b>Using</b> <b>tiehash,</b> <b>you</b> <b>need</b> <b>to</b> <b>save</b> <b>the</b> <b>attributes</b> <b>in</b> <b>the</b> <b>Saver,</b> <b>or</b> <b>you</b> <b>call</b> <b>the</b> <b>tie()</b>.

           $$this-&gt;{flagx} = 1 ;

</pre><h4><b>Object::MultiType::Saver</b></h4><pre>
       This is a litte package where the Saver objects are created.  It will save the data types (SCALAR, ARRAY,
       HASH, CODE &amp; GLOB) of the main objects (Object::MultiType).

       <b>METHODS:</b>

   <b>is_saver</b>
       Return 1. Good to see if what you have is the Saver or the MultiType object.

   <b>bool</b>
       Return the BOOL reference inside the Saver.

   <b>scalar</b>
       Return the SCALAR reference inside the Saver.

   <b>array</b>
       Return the ARRAY reference inside the Saver.

   <b>hash</b>
       Return the HASH reference inside the Saver.

   <b>code</b>
       Return the CODE/sub reference inside the Saver.

   <b>glob</b>
       Return the GLOB/HANDLE reference inside the Saver.

   <b>set_bool</b>
       Set the boolean reference inside the Saver.

   <b>set_scalar</b>
       Set the SCALAR reference inside the Saver.

   <b>set_array</b>
       Set the ARRAY reference inside the Saver.

   <b>set_hash</b>
       Set the HASH reference inside the Saver.

   <b>set_code</b>
       Set the CODE/sub reference inside the Saver.

   <b>set_glob</b>
       Set the GLOB/HANDLE reference inside the Saver.

   <b>clean</b>
       Clean all the references saved in the Saver.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       overload, perltie, Scalar::Util.

       This module/class was created for XML::Smart.

</pre><h4><b>AUTHOR</b></h4><pre>
       Graciliano M. P. &lt;<a href="mailto:gm@virtuasites.com.br">gm@virtuasites.com.br</a>&gt;

       I will appreciate any type of feedback (include your opinions and/or suggestions). ;-P

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2022-10-13                                     <u><a href="../man3pm/MultiType.3pm.html">MultiType</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>