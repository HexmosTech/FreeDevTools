<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Validate::Struct - Validate recursive Hash Structures</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-validate-struct-perl">libdata-validate-struct-perl_0.12-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Validate::Struct - Validate recursive Hash Structures

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Data::Validate::Struct;
        my $validator = new Data::Validate::Struct($reference);
        if ( $validator-&gt;validate($config_hash_reference) ) {
          print "valid\n";
        }
        else {
          print "invalid " . $validator-&gt;errstr() . "\n";
        }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module validates a config hash reference against a given hash structure in contrast to
       Data::Validate in which you have to check each value separately using certain methods.

       This hash could be the result of a config parser or just any hash structure. Eg. the hash returned by
       XML::Simple could be validated using this module. You may also use it to validate CGI input, just fetch
       the input data from CGI, map it to a hash and validate it.

       Data::Validate::Struct uses some of the methods exported by Data::Validate, so you need to install it
       too.

</pre><h4><b>PREDEFINED</b> <b>BUILTIN</b> <b>DATA</b> <b>TYPES</b></h4><pre>
       <b>int</b> Match a simple integer number.

       <b>range(a-b)</b>
           Match a simple integer number in a range between a and b. Eg:

            { loginport =&gt; 'range(22-23)' }

       <b>hex</b> Match a hex value.

       <b>oct</b> Match an octagonal value.

       <b>number</b>
           Match a decimal number, it may contain , or . and may be signed.

       <b>word</b>
           Match a single word, _ and - are tolerated.

       <b>line</b>
           Match a line of text - no newlines are allowed.

       <b>text</b>
           Match  a  whole text(blob) including newlines. This expression is very loosy, consider it as an alias
           to <b>any</b>.

       <b>regex</b>
           Match a perl regex using the operator <b>qr()</b>. Valid examples include:

             qr/[0-9]+/
             qr([^%]*)
             qr{\w+(\d+?)}

           Please note, that this doesn't mean you can provide here a regex against config options must match.

           Instead this means that the config options contains a regex.

           eg:

             $cfg = {
               grp  = qr/root|wheel/
             };

           <b>regex</b> would match the content of the variable 'grp' in this example.

           To add your own rules for validation, use the <b>type()</b> method, see below.

       <b>uri</b> Match an internet URI.

       <b>ipv4</b>
           Match an IPv4 address.

       <b>cidrv4</b>
           The same as above including cidr netmask (/24), IPv4 only, eg:

             10.2.123.0/23

           Note: shortcuts are not supported for the moment, eg:

             10.10/16

           will fail while  it  is  still  a  valid  IPv4  cidr  notation  for  a  network  address  (short  for
           10.10.0.0/16). Must be fixed in Regex::Common.

       <b>ipv6</b>
           Match an IPv6 address. Some examples:

             3ffe:1900:4545:3:200:f8ff:fe21:67cf
             fe80:0:0:0:200:f8ff:fe21:67cf
             fe80::200:f8ff:fe21:67cf
             ff02:0:0:0:0:0:0:1
             ff02::1

       <b>cidrv6</b>
           The same as above including cidr netmask (/64), IPv6 only, eg:

             2001:db8:dead:beef::1/64
             2001:db8::/32

       <b>quoted</b>
           Match a text quoted with single quotes, eg:

             'barbara is sexy'

       <b>hostname</b>
           Match a valid hostname, it must qualify to the definitions in RFC 2396.

       <b>resolvablehost</b>
           Match a hostname resolvable via dns lookup. Will fail if no dns is available at runtime.

       <b>path</b>
           Match  a  valid  absolute  path,  it  won't do a <b>stat()</b> system call.  This will work on any operating
           system at runtime. So this one:

             C:\Temp

           will return TRUE if running on WIN32, but FALSE on FreeBSD!

       <b>fileexists</b>
           Look if value is a file which exists. Does a <b>stat()</b> system call.

       <b>user</b>
           Looks if the given value is an existent user. Does a <b>getpwnam()</b> system call.

       <b>group</b>
           Looks if the given value is an existent group. Does a <b>getgrnam()</b> system call.

       <b>port</b>
           Match a valid tcp/udp port. Must be a digit between 0 and 65535.

       <b>vars</b>
           Matches a string of text containing variables (perl style variables though) eg:

             $user is $attribute
             I am $(years) old
             Missing ${points} points to succeed

</pre><h4><b>MIXED</b> <b>TYPES</b></h4><pre>
       If there is an element which could match more than one type, this can be matched by using the  pipe  sign
       "|" to separate the types.

         { name =&gt; 'int | number' }

       There  is  no limit on the number of types that can be checked for, and the check is done in the sequence
       written (first the type 'int', and then 'number' in the example above).

</pre><h4><b>OPTIONAL</b> <b>ITEMS</b></h4><pre>
       If there is an element which is optional in the hash, you can use the type 'optional' in  the  type.  The
       'optional' type can also be mixed with ordinary types, like:

         { name =&gt; 'text | optional' }

       The type 'optional' can be placed anywhere in the type string.

</pre><h4><b>NEGATIVE</b> <b>MATCHING</b></h4><pre>
       In  some  rare situations you might require a negative match. So a test shall return TRUE if a particular
       value does NOT match the given type. This might be useful to prevent certain things.

       To achieve this, you just have to prepend one of the below mentioned types with the keyword <b>no</b>.

       Example:

        $ref = { path =&gt; 'novars' }

       This returns TRUE if the value of the given config hash does NOT contain ANY variables.

</pre><h4><b>VALIDATOR</b> <b>STRUCTURE</b></h4><pre>
       The expected structure must be a standard perl hash reference.  This hash may look like  the  config  you
       are  validating  but instead of real-live values it contains <b>types</b> that define of what type a given value
       has to be.

       In addition the hash may be deeply nested. In this case the validated config must be nested the same  way
       as the reference hash.

       Example:

         $reference = { user =&gt; 'word', uid =&gt; 'int' };

       The following config would be validated successful:

         $config = { user =&gt; 'HansDampf',  uid =&gt; 92 };

       this one not:

         $config = { user =&gt; 'Hans Dampf', uid =&gt; 'nine' };
                                  ^                ^^^^
                                  |                |
                                  |                +----- is not a number
                                  +---------------------- space not allowed

       For  easier  writing  of  references  you  yould  use a configuration file parser like Config::General or
       Config::Any, just write the definition using the syntax of such a module, get the hash of it and use this
       hash as validation reference.

</pre><h4><b>NESTED</b> <b>HASH</b> <b>STRUCTURES</b></h4><pre>
       You can also match against nested structures. <b>Data::Validate::Struct</b> iterates into the given config  hash
       the same way as the reference hash looks like.

       If   the   config  hash  doesn't  match  the  reference  structure,  perl  will  throw  an  error,  which
       <b>Data::Validate::Struct</b> catches and returns FALSE.

       Given the following reference hash:

         $ref = {
             'b1' =&gt; {
                 'b2' =&gt; {
                     'b3' =&gt; {
                         'item' =&gt; 'int'
                     }
                 }
             }
         }

       Now if you validate it against the following config hash it will return TRUE:

         $cfg = {
             'b1' =&gt; {
                 'b2' =&gt; {
                     'b3' =&gt; {
                         'item' =&gt; '100'
                     }
                 }
             }
         }

       If you validate it for example against this hash, it will return FALSE:

         $cfg = {
             'b1' =&gt; {
                 'b2' =&gt; {
                     'item' =&gt; '100'
                 }
             }
         }

</pre><h4><b>SUBROUTINES/METHODS</b></h4><pre>
       <b>validate($config)</b>
           $config must be a hash reference you'd like to validate.

           It returns a true value if the given structure looks valid.

           If the return value is false (0), then the error message will be written to the variable $!.

       <b>type(%types)</b>
           You can enhance the validator by adding your own rules. Just add one or more new types using a simple
           hash using the <b>type()</b> method. Values in this hash can be regexes or anonymous subs.

           "type" does accept either a hash (%hash), a hash ref (%$hash)  or  a  list  of  key/values  ("key  =&gt;
           value") as input.

           For details see "CUSTOM VALIDATORS".

       <b>debug()</b>
           Enables debug output which gets printed to STDERR.

       <b>errors</b>
           Returns  an  array  ref  with the errors found when validating the hash.  Each error is on the format
           '&lt;value&gt; doesn't match &lt;types&gt; at &lt;ref&gt;', where &lt;ref&gt; is a comma separated tree view depicting  where
           in the the error occurred.

       <b>errstr()</b>
           Returns the last error, which is useful to notify the user about what happened. The format is like in
           "errors".

</pre><h4><b>EXPORTED</b> <b>FUNCTIONS</b></h4><pre>
   <b>add_validators</b>
       This  is  a  class  function  which  adds  types  not  per  object  but  globally  for  each  instance of
       Data::Validate::Struct.

        use Data::Validate::Struct qw(add_validators);
        add_validators( name =&gt; .. );
        my $v = Data::Validate::Struct-&gt;new(..);

       Parameters to <b>add_validators</b> are the same as of the <b>type</b> method.

       For details see "CUSTOM VALIDATORS".

</pre><h4><b>CUSTOM</b> <b>VALIDATORS</b></h4><pre>
       You can add your own validators, which maybe regular expressions or anonymous  subs.  Validators  can  be
       added using the <b>type()</b> method or globally using the <b>add_validators()</b> function.

   <b>CUSTOM</b> <b>REGEX</b> <b>VALIDATORS</b>
       If  you  add  a  validator which is just a regular expressions, it will evaluated as is. This is the most
       simplest way to customize validation.

       Sample:

        use Data::Validate::Struct qw(add_validators);
        add_validators(address =&gt; qr(^\w+\s\s*\d+$));
        my $v = Data::Validate::Struct-&gt;new({place =&gt; 'address'});
        $v-&gt;validate({place =&gt; 'Livermore 19'});

       Regexes will be executed exactly as given. No flags or ^ or $ will be used by the module. Eg. if you want
       to match the whole value from beginning to the end, add ^ and $,  like  you  can  see  in  our  'address'
       example above.

   <b>CUSTOM</b> <b>VALIDATOR</b> <b>FUNCTIONS</b>
       If the validator is a coderef, it will be executed as a sub.

       Example:

        use Data::Validate::Struct qw(add_validators);
        add_validators(
           list =&gt; sub {
             my $list = shift;
             my @list = split /\s*,\s*/, $list;
             return scalar @list &gt; 1;
           },
        );

       In  this  example  we  add  a  new type 'list', which is really simple. 'list' is a subroutine which gets
       called during evaluation for each option which you define as type 'list'.

       Such a subroutine must return a true value in order to  produce  a  match.   It  receives  the  following
       arguments:

       •   value to be evaluated

       •   unparsed arguments, if defined in the reference

       •   array of parsed arguments, tokenized by , and -

       That  way  you  may  define  a  type which accepts an arbitrary number of arguments, which makes the type
       customizable. Sample:

        # new validator
        $v4 = Data::Validate::Struct-&gt;new({ list =&gt; <a href="../man4/nwords.4.html">nwords</a>(4) });

        # define type 'nwords' with support for 1 argument
        $v4-&gt;type(
          nwords =&gt; sub {
            my($val, $ignore, $count) = @_;
            return (scalar(split /\s+/, $val) == $count) ? 1 : 0;
          },
        );

        # validate
        $v4-&gt;validate({ list =&gt; 'these are four words' });

   <b>CUSTOM</b> <b>VALIDATORS</b> <b>USING</b> <b>A</b> <b>GRAMMAR</b>
       Sometimes you want to be more flexible, in such cases you may use a parser generator to  validate  input.
       This is no feature of Data::Validate::Struct, you will just write a custom code ref validator, which then
       uses the grammar.

       Here's a complete example using Parse::RecDescent:

        use Parse::RecDescent;
        use Data::Validate::Struct qw(add_validators);

        my $grammar = q{
           line: expr(s)
           expr: number operator number
           number: int | float
           int: /\d+/
           float: /\d*\\.\d+/
           operator: '+' | '-' | '*' | '/'
        };

        my $parse = Parse::RecDescent-&gt;new($grammar);

        add_validators(calc =&gt; sub { defined $parse-&gt;line($_[0]) ? 1 : 0; });

        my $val = Data::Validate::Struct-&gt;new({line =&gt; 'calc'});

        if ($val-&gt;validate({line =&gt; "@ARGV"})) {
          my $r;
          eval "\$r = @ARGV";
          print "$r\n";
        }
        else {
          print "syntax error\n";
        }

       Now you can use it as follows:

        ./mycalc 54 + 100 - .1
        153.9

        ./mycalc 8^2
        syntax error

   <b>NEGATED</b> <b>VALIDATOR</b>
       A negative/reverse match is automatically added as well, see "NEGATIVE MATCHING".

</pre><h4><b>EXAMPLES</b></h4><pre>
       Take a look to <u>t/run.t</u> for lots of examples.

</pre><h4><b>CONFIGURATION</b> <b>AND</b> <b>ENVIRONMENT</b></h4><pre>
       No environment variables will be used.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       I recommend you to read the following documentations, which are supplied with perl:

       perlreftut Perl references short introduction.

       perlref Perl references, the rest of the story.

       perldsc Perl data structures intro.

       perllol Perl data structures: arrays of arrays.

       Data::Validate common data validation methods.

       Data::Validate::IP common data validation methods for IP-addresses.

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2007-2015 T. v.Dein

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       Some implementation details as well as the API may change in the future. This  will  no  more  happen  if
       entering a stable release (starting with 1.00).

       To submit use &lt;<a href="http://rt.cpan.org">http://rt.cpan.org</a>&gt;.

</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
       None known.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       To debug Data::Validate::Struct use <b>debug()</b> or the perl debugger, see perldebug.

       For example to debug the regex matching during processing try this:

        perl -Mre=debug yourscript.pl

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       Data::Validate::Struct   depends   on   the  module  Data::Validate,  Data::Validate:IP,  Regexp::Common,
       File::Spec and File::stat.

</pre><h4><b>AUTHORS</b></h4><pre>
       T. v.Dein &lt;tlinden |AT| cpan.org&gt;

       Per Carlson &lt;pelle |AT| cpan.org&gt;

       Thanks to David Cantrell for his helpful hints.

</pre><h4><b>VERSION</b></h4><pre>
       0.11

perl v5.36.0                                       2023-03-12                                        <u><a href="../man3pm/Struct.3pm.html">Struct</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>