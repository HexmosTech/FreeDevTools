<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pod::SAX - a SAX parser for Pod</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpod-sax-perl">libpod-sax-perl_0.14-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Pod::SAX - a SAX parser for Pod

</pre><h4><b>SYNOPSIS</b></h4><pre>
         my $h = XML::SAX::Writer-&gt;new();
         my $p = Pod::SAX-&gt;new( Handler =&gt; $h );
         $p-&gt;parse_uri('perlpodspec.pod');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Very simply, this module parses POD (or perl) files and turns the Plain Old Documentation into SAX events
       (which often you'll use to turn into XML, but there are other uses as well).

       The aim of this module is not round-tripping, so some things may be lost in the conversion. The aim is to
       be as standards compliant as possible, while giving you very simple access to the data.

       The main motivation for this module though was simple standards compliance - all the Pod parsers out
       there seem to have their own unique way of doing things, and so my aim was to unify that and allow the
       flexibility that SAX gives me at the same time.

       For an introduction to SAX, please read XML::SAX::Intro.

       One very important point to note is that just because this is a SAX module it doesn't mandate that the
       results are XML. You could just as easily use this module to extract all filenames from a POD file, or
       extract custom =for/=begin sections. And because it uses standardised interfaces this is a lot simpler
       than working with any other POD parser out there, and the knowledge is transferrable.

</pre><h4><b>API</b></h4><pre>
   <b>new()</b>
       To construct a parser simply call <b>new()</b>. It is customary to pass in the handler object that will receive
       the SAX events at this time, though you do not have to:

         my $parser = Pod::SAX-&gt;new(Handler =&gt; $h);

       You can re-use this parser object multiple times. It's possible to change the handler at a later date
       using "$parser-"<b>set_handler()</b>&gt;. This and many other API calls are documented in XML::SAX::Base, which
       this module inherits from.

   <b>parse()</b>
       This method is an auto-detecting parser - it will try and figure out what you passed to it (a string, a
       file handle or a filename) and parse the data using the appropriate technique.

   <b>parse_file(),</b> <b>parse_string(),</b> <b>parse_uri(),</b> <b>parse_fh()</b>
       These are simply the non-detecting methods that <b>parse()</b> uses internally.  Use these if you are paranoid
       about what you're parsing, and don't want the overhead of SAX trying to guess.

</pre><h4><b>XML</b> <b>Format</b></h4><pre>
       The XML format is intended to be simple and map fairly closely to the source POD. The documentation here
       shows the POD marker and the tag that it maps to.

   <b>=pod</b> <b>(or</b> <b>any</b> <b>other</b> <b>way</b> <b>to</b> <b>begin</b> <b>the</b> <b>document)</b>
         &lt;pod&gt;
         &lt;!-- Pod::SAX v0.14, using POD::Parser v1.13 --&gt;

       The comment is automatically generated so that you can see what version of Pod::SAX was used in parsing
       this document. The closing "&lt;/pod&gt;" tag is generated when the end of the POD is reached.

   <b>=head1</b> <b>and</b> <b>=headN</b>
         &lt;head1&gt;Text here&lt;/head1&gt;

       All head levels are supported.

   <b>Paragraphs</b>
       Plain paragraphs are represented with:

         &lt;para&gt;text&lt;/para&gt;

   <b>Verbatim</b>
       Verbatim sections (i.e. when you indent the text) are represented with:

         &lt;verbatim&gt;text&lt;/verbatim&gt;

   <b>=over/=back</b>
       Pod::SAX automatically detects whether a list is itemized or ordered (i.e.  whether it should have bullet
       points or numbers), and so =over/=back are represented by:

         &lt;itemizedlist&gt;  &lt;/itemizedlist&gt;

       and

         &lt;orderedlist&gt;   &lt;/orderedlist&gt;

       respectively. The indent value (as in "=over 4") is saved in the "indent_width" attribute, although for
       most purposes this can be ignored.

   <b>=item</b>
       For both bulleted and numbered lists, the =item tag always maps to:

         &lt;listitem&gt;text&lt;/listitem&gt;

       If a paragraph follows an =item tag (and occurs before any =back) then the paragraph is included
       immediately after the tag, so for example:

         =item foo

         Some text about foo

       Maps to:

         &lt;listitem&gt;foo
           &lt;para&gt;Some text about foo&lt;/para&gt;
         &lt;/listitem&gt;

   <b>=begin</b> <b>foo</b>
       And "=for foo" (the two are semantically equivalent in Pod)

         &lt;markup type="foo" ordinary_paragraph="0"&gt;text here&lt;/markup&gt;

       If the markup section is meant for ordinary processing (see the perlpodspec section on "About Data
       Paragraphs and "=begin/=end" Regions"), which means the type name begins with a colon as in:

         =begin :biblio

       Then the markup produced indicates that using:

         &lt;markup type="biblio" ordinary_paragraph="1"/&gt;

       And the parser will expand all interior Pod commands as it should.

       <b>Note</b>: There is <u>no</u> special treatment of =begin html or =begin XML or any variant thereof. The contents of
       those markers will simply be treated as text, and it is up to the user of this module to parse that data
       as XML if they wish to do so.

   <b>Sequences</b> <b>or</b> <b>Formatting</b> <b>Codes</b>
       Sequences in POD consist of the following:

         L&lt;&gt; - Links
         E&lt;&gt; - Entities
         I&lt;&gt; - Italics
         B&lt;&gt; - Bold
         C&lt;&gt; - Code
         F&lt;&gt; - Filename
         S&lt;&gt; - Non breaking space
         X&lt;&gt; - Index marker
         Z&lt;&gt; - Null

       Most sequences are simply converted to tags of the same name, case preserved:

         &lt;B&gt;This is bold text&lt;/B&gt; and also &lt;I&gt;some in italics&lt;/I&gt;.

       Special treatment is given to the L&lt;&gt; E&lt;&gt; and S&lt;&gt; tags only.

       <u>Links</u>

       Links in Pod are... funky.

       Parsing links is really hard, so don't expect that I've got this right.  Basically though you've got this
       mapping:

         L&lt;foo/bar&gt;
          =&gt; &lt;link type="pod" page="foo" section="bar"&gt;foo&lt;/link&gt;

         L&lt;Some Foo|foo&gt;
          =&gt; &lt;link type="pod" page="foo" section=""&gt;Some Foo&lt;/link&gt;

         L&lt;<a href="../man3/select.3.html">select</a>(3)&gt;
          =&gt; &lt;link type="man" page="<a href="../man3/select.3.html">select</a>(3)" section=""&gt;<a href="../man3/select.3.html">select</a>(3)&lt;/link&gt;

         L&lt;<a href="http://foo.com">http://foo.com</a>&gt;
          =&gt; &lt;xlink href="<a href="http://foo.com">http://foo.com</a>"&gt;<a href="http://foo.com">http://foo.com</a>&lt;/xlink&gt;

       And many variations thereof! Basically it should do the right thing

       <u>Entities</u>

       In POD an E&lt;&gt; marker defines an entity. In pod these are single characters only, and take either a text
       form, in which case they map to the standard HTML entities (e.g. ouml, Agrave etc), or a decimal number
       in which case they map to the unicode character at that code point.

       In Pod::SAX entities are always converted to unicode and never generate any tags or markers in the data
       stream so it will be as though the entity was never there.

       <u>Non-Breaking</u> <u>Space</u>

       Non breaking space is simply achieved by changing all space within the S&lt;&gt; section into the unicode
       codepoint 160 - the non-breaking space character. Normally this is enough to do the right thing, but if
       you need to you can detect this with a regexp.

</pre><h4><b>AUTHOR</b></h4><pre>
       Matt Sergeant, <a href="mailto:matt@sergeant.org">matt@sergeant.org</a>. Copyright AxKit.com Ltd 2002

</pre><h4><b>BUGS</b></h4><pre>
       There may be bugs in the unicode handling on perl 5.8, because it's just really hard to get things right
       on 5.8 when dealing with unicode. :-)

</pre><h4><b>LICENSE</b></h4><pre>
       This is free software. You may use it and redistribute it under the same terms as Perl itself.

perl v5.30.0                                       2020-05-17                                      <u>Pod::<a href="../man3pm/SAX.3pm.html">SAX</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>