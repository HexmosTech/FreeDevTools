<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pod::Simple - framework for parsing Pod</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Pod::Simple - framework for parsing Pod

</pre><h4><b>SYNOPSIS</b></h4><pre>
        TODO

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Pod::Simple is a Perl library for parsing text in the Pod ("plain old documentation") markup language
       that is typically used for writing documentation for Perl and for Perl modules. The Pod format is
       explained in perlpod; the most common formatter is called "perldoc".

       Be sure to read "ENCODING" if your Pod contains non-ASCII characters.

       Pod formatters can use Pod::Simple to parse Pod documents and render them into plain text, HTML, or any
       number of other formats. Typically, such formatters will be subclasses of Pod::Simple, and so they will
       inherit its methods, like "parse_file".  But note that Pod::Simple doesn't understand and properly parse
       Perl itself, so if you have a file which contains a Perl program that has a multi-line quoted string
       which has lines that look like pod, Pod::Simple will treat them as pod.  This can be avoided if the file
       makes these into indented here documents instead.

       If you're reading this document just because you have a Pod-processing subclass that you want to use,
       this document (plus the documentation for the subclass) is probably all you need to read.

       If you're reading this document because you want to write a formatter subclass, continue reading it and
       then read Pod::Simple::Subclassing, and then possibly even read perlpodspec (some of which is for parser-
       writers, but much of which is notes to formatter-writers).

</pre><h4><b>MAIN</b> <b>METHODS</b></h4><pre>
       "$parser = <u>SomeClass</u>-&gt;new();"
           This returns a new parser object, where <u>"SomeClass"</u> is a subclass of Pod::Simple.

       "$parser-&gt;output_fh( *OUT );"
           This  sets the filehandle that $parser's output will be written to.  You can pass *STDOUT or *STDERR,
           otherwise you should probably do something like this:

               my $outfile = "output.txt";
               open TXTOUT, "&gt;$outfile" or die "Can't write to $outfile: $!";
               $parser-&gt;output_fh(*TXTOUT);

           ...before you call one of the "$parser-&gt;parse_<u>whatever</u>" methods.

       "$parser-&gt;output_string( \$somestring );"
           This sets the string that $parser's output will be sent to, instead of any filehandle.

       "$parser-&gt;parse_file( <u>$some_filename</u> );"
       "$parser-&gt;parse_file( *INPUT_FH );"
           This reads the Pod content of the file (or filehandle) that you specify, and processes it  with  that
           $parser  object, according to however $parser's class works, and according to whatever parser options
           you have set up for this $parser object.

       "$parser-&gt;parse_string_document( <u>$all_content</u> );"
           This works just like "parse_file" except that it reads the Pod content not from a file,  but  from  a
           string that you have already in memory.

       "$parser-&gt;parse_lines( <u>...@lines...</u>, undef );"
           This  processes  the  lines in @lines (where each list item must be a defined value, and must contain
           exactly one line of content -- so no items like "foo\nbar" are allowed).  The final "undef"  is  used
           to indicate the end of document being parsed.

           The  other  "parser_<u>whatever</u>"  methods  are  meant  to  be  called  only once per $parser object; but
           "parse_lines" can be called as many times per $parser object as you want, as long as  the  last  call
           (and only the last call) ends with an "undef" value.

       "$parser-&gt;content_seen"
           This  returns  true  only if there has been any real content seen for this document. Returns false in
           cases where the document contains content, but does not make use of any Pod markup.

       "<u>SomeClass</u>-&gt;filter( <u>$filename</u> );"
       "<u>SomeClass</u>-&gt;filter( <u>*INPUT_FH</u> );"
       "<u>SomeClass</u>-&gt;filter( <u>\$document_content</u> );"
           This is a shortcut method for creating a new parser object, setting the output handle to STDOUT,  and
           then  processing  the  specified  file (or filehandle, or in-memory document). This is handy for one-
           liners like this:

             perl -MPod::Simple::Text -e "Pod::Simple::Text-&gt;filter('thingy.pod')"

</pre><h4><b>SECONDARY</b> <b>METHODS</b></h4><pre>
       Some of these methods might be of interest to general users, as well as of interest to formatter-writers.

       Note that the general pattern here is that the accessor-methods read the attribute's value with "$value =
       $parser-&gt;<u>attribute</u>"  and  set  the  attribute's  value  with  "$parser-&gt;<u>attribute</u>(<u>newvalue</u>)".   For  each
       accessor,  I  typically  only mention one syntax or another, based on which I think you are actually most
       likely to use.

       "$parser-&gt;parse_characters( <u>SOMEVALUE</u> )"
           The Pod parser normally expects to read octets and to convert those octets to characters based on the
           "=encoding" declaration in the Pod source.  Set this option to a true value to indicate that the  Pod
           source  is  already a Perl character stream.  This tells the parser to ignore any "=encoding" command
           and to skip all the code paths involving decoding octets.

       "$parser-&gt;no_whining( <u>SOMEVALUE</u> )"
           If you set this attribute  to  a  true  value,  you  will  suppress  the  parser's  complaints  about
           irregularities  in  the  Pod  coding.  By  default,  this  attribute's  value  is false, meaning that
           irregularities will be reported.

           Note that turning this attribute to true won't suppress one or two kinds of complaints  about  rarely
           occurring unrecoverable errors.

       "$parser-&gt;no_errata_section( <u>SOMEVALUE</u> )"
           If  you  set  this attribute to a true value, you will stop the parser from generating a "POD ERRORS"
           section at the end of the document. By default, this attribute's value  is  false,  meaning  that  an
           errata section will be generated, as necessary.

       "$parser-&gt;complain_stderr( <u>SOMEVALUE</u> )"
           If  you  set  this  attribute  to  a true value, it will send reports of parsing errors to STDERR. By
           default, this attribute's value is false, meaning that no output is sent to STDERR.

           Setting "complain_stderr" also sets "no_errata_section".

       "$parser-&gt;source_filename"
           This returns the filename that this parser object was set to read from.

       "$parser-&gt;doc_has_started"
           This returns true if $parser has read from a source, and has seen Pod content in it.

       "$parser-&gt;source_dead"
           This returns true if $parser has read from a source, and come to the end of that source.

       "$parser-&gt;strip_verbatim_indent( <u>SOMEVALUE</u> )"
           The perlpod spec for a Verbatim paragraph is "It should be reproduced exactly...", which  means  that
           the  whitespace  you've used to indent your verbatim blocks will be preserved in the output. This can
           be annoying for outputs such as HTML, where that whitespace will remain in front of every line.  It's
           an unfortunate case where syntax is turned into semantics.

           If  the  POD you're parsing adheres to a consistent indentation policy, you can have such indentation
           stripped from the beginning of every line of your verbatim blocks. This method tells Pod::Simple what
           to strip. For two-space indents, you'd use:

             $parser-&gt;strip_verbatim_indent('  ');

           For tab indents, you'd use a tab character:

             $parser-&gt;strip_verbatim_indent("\t");

           If the POD is inconsistent about the indentation of verbatim blocks,  but  you  have  figured  out  a
           heuristic  to  determine  how  much  a  particular  verbatim  block  is indented, you can pass a code
           reference instead. The code reference will be executed with one argument, an array reference  of  all
           the  lines  in  the  verbatim  block,  and should return the value to be stripped from each line. For
           example, if you decide that you're fine to use the first line  of  the  verbatim  block  to  set  the
           standard  for  indentation  of  the  rest of the block, you can look at the first line and return the
           appropriate value, like so:

             $new-&gt;strip_verbatim_indent(sub {
                 my $lines = shift;
                 (my $indent = $lines-&gt;[0]) =~ s/\S.*//;
                 return $indent;
             });

           If you'd rather treat each line individually, you can do that, too, by  just  transforming  them  in-
           place  in  the  code reference and returning "undef". Say that you don't want <u>any</u> lines indented. You
           can do something like this:

             $new-&gt;strip_verbatim_indent(sub {
                 my $lines = shift;
                 sub { s/^\s+// for @{ $lines },
                 return undef;
             });

       "$parser-&gt;expand_verbatim_tabs( <u>n</u> )"
           Default: 8

           If after any stripping of indentation in  verbatim  blocks,  there  remain  tabs,  this  method  call
           indicates what to do with them.  0 means leave them as tabs, any other number indicates that each tab
           is to be translated so as to have tab stops every "n" columns.

           This  is  independent of other methods (except that it operates after any verbatim input stripping is
           done).

           Like the other methods, the input parameter is not checked for validity.  "undef" or containing  non-
           digits has the same effect as 8.

</pre><h4><b>TERTIARY</b> <b>METHODS</b></h4><pre>
       "$parser-&gt;abandon_output_fh()"
           Cancel output to the file handle. Any POD read by the $parser is not effected.

       "$parser-&gt;abandon_output_string()"
           Cancel output to the output string. Any POD read by the $parser is not effected.

       "$parser-&gt;accept_code( @codes )"
           Alias for accept_codes.

       "$parser-&gt;accept_codes( @codes )"
           Allows $parser to accept a list of "Formatting Codes" in perlpod. This can be used to implement user-
           defined codes.

       "$parser-&gt;accept_directive_as_data( @directives )"
           Allows  $parser  to  accept  a  list of directives for data paragraphs. A directive is the label of a
           "Command Paragraph" in perlpod. A data paragraph is one delimited by  "=begin/=for/=end"  directives.
           This can be used to implement user-defined directives.

       "$parser-&gt;accept_directive_as_processed( @directives )"
           Allows $parser to accept a list of directives for processed paragraphs. A directive is the label of a
           "Command  Paragraph"  in  perlpod.  A  processed  paragraph  is also known as "Ordinary Paragraph" in
           perlpod. This can be used to implement user-defined directives.

       "$parser-&gt;accept_directive_as_verbatim( @directives )"
           Allows $parser to accept a list of directives for "Verbatim Paragraph" in perlpod. A directive is the
           label of a "Command Paragraph" in perlpod. This can be used to implement user-defined directives.

       "$parser-&gt;accept_target( @targets )"
           Alias for accept_targets.

       "$parser-&gt;accept_target_as_text( @targets )"
           Alias for accept_targets_as_text.

       "$parser-&gt;accept_targets( @targets )"
           Accepts targets for "=begin/=for/=end" sections of the POD.

       "$parser-&gt;accept_targets_as_text( @targets )"
           Accepts targets for "=begin/=for/=end" sections that should be parsed as POD. For details, see "About
           Data Paragraphs" in perlpodspec.

       "$parser-&gt;any_errata_seen()"
           Used to check if any errata was seen.

           <u>Example:</u>

             die "too many errors\n" if $parser-&gt;any_errata_seen();

       "$parser-&gt;errata_seen()"
           Returns a hash reference of all errata seen, both whines and screams. The hash reference's  keys  are
           the line number and the value is an array reference of the errors for that line.

           <u>Example:</u>

             if ( $parser-&gt;any_errata_seen() ) {
                $logger-&gt;log( $parser-&gt;errata_seen() );
             }

       "$parser-&gt;detected_encoding()"
           Return  the  encoding  corresponding  to  "=encoding",  but  only  if the encoding was recognized and
           handled.

       "$parser-&gt;encoding()"
           Return encoding of the document, even if the encoding is not correctly handled.

       "$parser-&gt;parse_from_file( $source, $to )"
           Parses from $source file to $to file. Similar to "parse_from_file" in Pod::Parser.

       "$parser-&gt;scream( @error_messages )"
           Log an error that can't be ignored.

       "$parser-&gt;unaccept_code( @codes )"
           Alias for unaccept_codes.

       "$parser-&gt;unaccept_codes( @codes )"
           Removes @codes as valid codes for the parse.

       "$parser-&gt;unaccept_directive( @directives )"
           Alias for unaccept_directives.

       "$parser-&gt;unaccept_directives( @directives )"
           Removes @directives as valid directives for the parse.

       "$parser-&gt;unaccept_target( @targets )"
           Alias for unaccept_targets.

       "$parser-&gt;unaccept_targets( @targets )"
           Removes @targets as valid targets for the parse.

       "$parser-&gt;version_report()"
           Returns a string describing the version.

       "$parser-&gt;whine( @error_messages )"
           Log an error unless "$parser-&gt;no_whining( TRUE );".

</pre><h4><b>ENCODING</b></h4><pre>
       The Pod::Simple parser expects to read <b>octets</b>.  The parser will decode the octets  into  Perl's  internal
       character string representation using the value of the "=encoding" declaration in the POD source.

       If  the  POD  source  does  not  include an "=encoding" declaration, the parser will attempt to guess the
       encoding (selecting one of UTF-8 or CP 1252) by examining the first  non-ASCII  bytes  and  applying  the
       heuristic  described  in  perlpodspec.   (If  the  POD  source contains only ASCII bytes, the encoding is
       assumed to be ASCII.)

       If you set the "parse_characters" option to a true value the parser will expect  characters  rather  than
       octets; will ignore any "=encoding"; and will make no attempt to decode the input.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Pod::Simple::Subclassing

       perlpod

       perlpodspec

       Pod::Escapes

       perldoc

</pre><h4><b>SUPPORT</b></h4><pre>
       Questions  or  discussion  about POD and Pod::Simple should be sent to the <a href="mailto:pod-people@perl.org">pod-people@perl.org</a> mail list.
       Send an empty email to <a href="mailto:pod-people-subscribe@perl.org">pod-people-subscribe@perl.org</a> to subscribe.

       This module is managed in an open GitHub repository, &lt;https://github.com/perl-pod/pod-simple/&gt;. Feel free
       to fork and contribute, or to clone &lt;https://github.com/perl-pod/pod-simple.git&gt; and send patches!

       Please use &lt;https://github.com/perl-pod/pod-simple/issues/new&gt; to file a bug report.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>DISCLAIMERS</b></h4><pre>
       Copyright (c) 2002 Sean M. Burke.

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

       This  program  is  distributed in the hope that it will be useful, but without any warranty; without even
       the implied warranty of merchantability or fitness for a particular purpose.

</pre><h4><b>AUTHOR</b></h4><pre>
       Pod::Simple was created by Sean M. Burke &lt;<a href="mailto:sburke@cpan.org">sburke@cpan.org</a>&gt;.  But don't bother him, he's retired.

       Pod::Simple is maintained by:

       •   Allison Randal "<a href="mailto:allison@perl.org">allison@perl.org</a>"

       •   Hans Dieter Pearcey "<a href="mailto:hdp@cpan.org">hdp@cpan.org</a>"

       •   David E. Wheeler "<a href="mailto:dwheeler@cpan.org">dwheeler@cpan.org</a>"

       •   Karl Williamson "<a href="mailto:khw@cpan.org">khw@cpan.org</a>"

       Documentation has been contributed by:

       •   Gabor Szabo "<a href="mailto:szabgab@gmail.com">szabgab@gmail.com</a>"

       •   Shawn H Corey  "SHCOREY at cpan.org"

perl v5.40.1                                       2025-07-27                                 <u>Pod::<a href="../man3perl/Simple.3perl.html">Simple</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>