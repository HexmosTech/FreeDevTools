<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pt::peg::to::peg - PEG Conversion. Write PEG format</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pt::peg::to::peg - PEG Conversion. Write PEG format

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>pt::peg::to::peg</b> <b>?1.0.3?</b>

       package require <b>pt::peg</b>

       package require <b>pt::pe</b>

       package require <b>text::write</b>

       <b>pt::peg::to::peg</b> <b>reset</b>

       <b>pt::peg::to::peg</b> <b>configure</b>

       <b>pt::peg::to::peg</b> <b>configure</b> <u>option</u>

       <b>pt::peg::to::peg</b> <b>configure</b> <u>option</u> <u>value</u>...

       <b>pt::peg::to::peg</b> <b>convert</b> <u>serial</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Are  you lost ?  Do you have trouble understanding this document ?  In that case please read the overview
       provided by the <u>Introduction</u> <u>to</u> <u>Parser</u> <u>Tools</u>. This document is the entrypoint to  the  whole  system  the
       current package is a part of.

       This package implements the converter from parsing expression grammars to PEG markup.

       It  resides in the Export section of the Core Layer of Parser Tools, and can be used either directly with
       the other packages of this layer, or indirectly through the export manager provided  by  <b>pt::peg::export</b>.
       The latter is intented for use in untrusted environments and done through the corresponding export plugin
       <b>pt::peg::export::peg</b> sitting between converter and export manager.

       IMAGE: arch_core_eplugins

</pre><h4><b>API</b></h4><pre>
       The  API  provided  by  this package satisfies the specification of the Converter API found in the <u>Parser</u>
       <u>Tools</u> <u>Export</u> <u>API</u> specification.

       <b>pt::peg::to::peg</b> <b>reset</b>
              This command resets the configuration of the package to its default settings.

       <b>pt::peg::to::peg</b> <b>configure</b>
              This command returns a dictionary containing the current configuration of the package.

       <b>pt::peg::to::peg</b> <b>configure</b> <u>option</u>
              This command returns the current value of the specified configuration <u>option</u> of the  package.  For
              the set of legal options, please read the section <b>Options</b>.

       <b>pt::peg::to::peg</b> <b>configure</b> <u>option</u> <u>value</u>...
              This command sets the given configuration <u>option</u>s of the package, to the specified <u>value</u>s. For the
              set of legal options, please read the section <b>Options</b>.

       <b>pt::peg::to::peg</b> <b>convert</b> <u>serial</u>
              This  command  takes  the canonical serialization of a parsing expression grammar, as specified in
              section <b>PEG</b> <b>serialization</b> <b>format</b>, and contained in <u>serial</u>, and generates PEG markup  encoding  the
              grammar, per the current package configuration.  The created string is then returned as the result
              of the command.

</pre><h4><b>OPTIONS</b></h4><pre>
       The  converter  to  the  PEG  language recognizes the following options and changes its behaviour as they
       specify.

       <b>-file</b> string
              The value of this option is the name of the file or other entity from which the grammar came,  for
              which the command is run. The default value is <b>unknown</b>.

       <b>-name</b> string
              The  value  of  this  option  is  the name of the grammar we are processing.  The default value is
              <b>a_pe_grammar</b>.

       <b>-user</b> string
              The value of this option is the name of the user for which the command is run. The  default  value
              is <b>unknown</b>.

       <b>-template</b> string
              The  value  of  this option is a string into which to put the generated text and the values of the
              other options. The various  locations  for  user-data  are  expected  to  be  specified  with  the
              placeholders listed below. The default value is "<b>@code@</b>".

              <b>@user@</b> To be replaced with the value of the option <b>-user</b>.

              <b>@format@</b>
                     To be replaced with the the constant <b>PEG</b>.

              <b>@file@</b> To be replaced with the value of the option <b>-file</b>.

              <b>@name@</b> To be replaced with the value of the option <b>-name</b>.

              <b>@code@</b> To be replaced with the generated text.

</pre><h4><b>PEG</b> <b>SPECIFICATION</b> <b>LANGUAGE</b></h4><pre>
       <b>peg</b>,  a  language for the specification of parsing expression grammars is meant to be human readable, and
       writable as well, yet strict enough to allow its processing by machine. Like any  computer  language.  It
       was defined to make writing the specification of a grammar easy, something the other formats found in the
       Parser Tools do not lend themselves too.

       It  is formally specified by the grammar shown below, written in itself. For a tutorial / introduction to
       the language please go and read the <u>PEG</u> <u>Language</u> <u>Tutorial</u>.

              PEG pe_grammar_for_peg (Grammar)

                # --------------------------------------------------------------------
                      # Syntactical constructs

                      Grammar         &lt;- WHITESPACE Header Definition* Final EOF ;

                      Header          &lt;- PEG Identifier StartExpr ;
                      Definition      &lt;- Attribute? Identifier IS Expression SEMICOLON ;
                      Attribute       &lt;- (VOID / LEAF) COLON ;
                      Expression      &lt;- Sequence (SLASH Sequence)* ;
                      Sequence        &lt;- Prefix+ ;
                      Prefix          &lt;- (AND / NOT)? Suffix ;
                      Suffix          &lt;- Primary (QUESTION / STAR / PLUS)? ;
                      Primary         &lt;- ALNUM / ALPHA / ASCII / CONTROL / DDIGIT / DIGIT
                                      /  GRAPH / LOWER / PRINTABLE / PUNCT / SPACE / UPPER
                                      /  WORDCHAR / XDIGIT
                                      / Identifier
                                      /  OPEN Expression CLOSE
                                      /  Literal
                                      /  Class
                                      /  DOT
                                      ;
                      Literal         &lt;- APOSTROPH  (!APOSTROPH  Char)* APOSTROPH  WHITESPACE
                                      /  DAPOSTROPH (!DAPOSTROPH Char)* DAPOSTROPH WHITESPACE ;
                      Class           &lt;- OPENB (!CLOSEB Range)* CLOSEB WHITESPACE ;
                      Range           &lt;- Char TO Char / Char ;

                      StartExpr       &lt;- OPEN Expression CLOSE ;
              void:   Final           &lt;- "END" WHITESPACE SEMICOLON WHITESPACE ;

                      # --------------------------------------------------------------------
                      # Lexing constructs

                      Identifier      &lt;- Ident WHITESPACE ;
              leaf:   Ident           &lt;- ([_:] / &lt;alpha&gt;) ([_:] / &lt;alnum&gt;)* ;
                      Char            &lt;- CharSpecial / CharOctalFull / CharOctalPart
                                      /  CharUnicode / CharUnescaped
                                      ;

              leaf:   CharSpecial     &lt;- "\\" [nrt'"\[\]\\] ;
              leaf:   CharOctalFull   &lt;- "\\" [0-3][0-7][0-7] ;
              leaf:   CharOctalPart   &lt;- "\\" [0-7][0-7]? ;
              leaf:   CharUnicode     &lt;- "\\" 'u' HexDigit (HexDigit (HexDigit HexDigit?)?)? ;
              leaf:   CharUnescaped   &lt;- !"\\" . ;

              void:   HexDigit        &lt;- [0-9a-fA-F] ;

              void:   TO              &lt;- '-'           ;
              void:   OPENB           &lt;- "["           ;
              void:   CLOSEB          &lt;- "]"           ;
              void:   APOSTROPH       &lt;- "'"           ;
              void:   DAPOSTROPH      &lt;- '"'           ;
              void:   PEG             &lt;- "PEG" !([_:] / &lt;alnum&gt;) WHITESPACE ;
              void:   IS              &lt;- "&lt;-"    WHITESPACE ;
              leaf:   VOID            &lt;- "void"  WHITESPACE ; # Implies that definition has no semantic value.
              leaf:   LEAF            &lt;- "leaf"  WHITESPACE ; # Implies that definition has no terminals.
              void:   SEMICOLON       &lt;- ";"     WHITESPACE ;
              void:   COLON           &lt;- ":"     WHITESPACE ;
              void:   SLASH           &lt;- "/"     WHITESPACE ;
              leaf:   AND             &lt;- "&amp;"     WHITESPACE ;
              leaf:   NOT             &lt;- "!"     WHITESPACE ;
              leaf:   QUESTION        &lt;- "?"     WHITESPACE ;
              leaf:   STAR            &lt;- "*"     WHITESPACE ;
              leaf:   PLUS            &lt;- "+"     WHITESPACE ;
              void:   OPEN            &lt;- "("     WHITESPACE ;
              void:   CLOSE           &lt;- ")"     WHITESPACE ;
              leaf:   DOT             &lt;- "."     WHITESPACE ;

              leaf:   ALNUM           &lt;- "&lt;alnum&gt;"    WHITESPACE ;
              leaf:   ALPHA           &lt;- "&lt;alpha&gt;"    WHITESPACE ;
              leaf:   ASCII           &lt;- "&lt;ascii&gt;"    WHITESPACE ;
              leaf:   CONTROL         &lt;- "&lt;control&gt;"  WHITESPACE ;
              leaf:   DDIGIT          &lt;- "&lt;ddigit&gt;"   WHITESPACE ;
              leaf:   DIGIT           &lt;- "&lt;digit&gt;"    WHITESPACE ;
              leaf:   GRAPH           &lt;- "&lt;graph&gt;"    WHITESPACE ;
              leaf:   LOWER           &lt;- "&lt;lower&gt;"    WHITESPACE ;
              leaf:   PRINTABLE       &lt;- "&lt;print&gt;"    WHITESPACE ;
              leaf:   PUNCT           &lt;- "&lt;punct&gt;"    WHITESPACE ;
              leaf:   SPACE           &lt;- "&lt;space&gt;"    WHITESPACE ;
              leaf:   UPPER           &lt;- "&lt;upper&gt;"    WHITESPACE ;
              leaf:   WORDCHAR        &lt;- "&lt;wordchar&gt;" WHITESPACE ;
              leaf:   XDIGIT          &lt;- "&lt;xdigit&gt;"   WHITESPACE ;

              void:   WHITESPACE      &lt;- (" " / "\t" / EOL / COMMENT)* ;
              void:   COMMENT         &lt;- '#' (!EOL .)* EOL ;
              void:   EOL             &lt;- "\n\r" / "\n" / "\r" ;
              void:   EOF             &lt;- !. ;

                      # --------------------------------------------------------------------
              END;

   <b>EXAMPLE</b>
       Our example specifies the grammar for a basic 4-operation calculator.

              PEG calculator (Expression)
                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'       ;
                  Sign       &lt;- '-' / '+'                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- '*' / '/'                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- '+'/'-'                                       ;
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

       Using higher-level features of the notation, i.e. the character classes  (predefined  and  custom),  this
       example can be rewritten as

              PEG calculator (Expression)
                  Sign       &lt;- [-+]                                          ;
                  Number     &lt;- Sign? &lt;ddigit&gt;+                               ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- [*/];
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- [-+];
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

</pre><h4><b>PEG</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here we specify the format used by the Parser Tools to serialize Parsing Expression Grammars as immutable
       values for transport, comparison, etc.

       We  distinguish between <u>regular</u> and <u>canonical</u> serializations.  While a PEG may have more than one regular
       serialization only exactly one of them will be <u>canonical</u>.

       regular serialization

              [1]    The serialization of any PEG is a nested Tcl dictionary.

              [2]    This dictionary holds a single key, <b>pt::grammar::peg</b>, and its value. This value  holds  the
                     contents of the grammar.

              [3]    The contents of the grammar are a Tcl dictionary holding the set of nonterminal symbols and
                     the starting expression. The relevant keys and their values are

                     <b>rules</b>  The  value  is  a Tcl dictionary whose keys are the names of the nonterminal symbols
                            known to the grammar.

                            [1]    Each nonterminal symbol may occur only once.

                            [2]    The empty string is not a legal nonterminal symbol.

                            [3]    The value for each symbol is a Tcl dictionary itself. The relevant  keys  and
                                   their values in this dictionary are

                                   <b>is</b>     The  value  is  the serialization of the parsing expression describing
                                          the symbols sentennial structure,  as  specified  in  the  section  <b>PE</b>
                                          <b>serialization</b> <b>format</b>.

                                   <b>mode</b>   The  value  can  be one of three values specifying how a parser should
                                          handle the semantic value produced by the symbol.

                                          <b>value</b>  The semantic value of the nonterminal  symbol  is  an  abstract
                                                 syntax   tree   consisting  of  a  single  node  node  for  the
                                                 nonterminal itself, which has the ASTs of  the  symbol's  right
                                                 hand side as its children.

                                          <b>leaf</b>   The  semantic  value  of  the nonterminal symbol is an abstract
                                                 syntax  tree  consisting  of  a  single  node  node   for   the
                                                 nonterminal,  without  any  children. Any ASTs generated by the
                                                 symbol's right hand side are discarded.

                                          <b>void</b>   The nonterminal has no semantic value. Any  ASTs  generated  by
                                                 the symbol's right hand side are discarded (as well).

                     <b>start</b>  The  value  is  the serialization of the start parsing expression of the grammar, as
                            specified in the section <b>PE</b> <b>serialization</b> <b>format</b>.

              [4]    The terminal symbols of the grammar are specified implicitly as the  set  of  all  terminal
                     symbols used in the start expression and on the RHS of the grammar rules.

       canonical serialization
              The  canonical  serialization  of  a grammar has the format as specified in the previous item, and
              then additionally satisfies the constraints below, which make it unique  among  all  the  possible
              serializations of this grammar.

              [1]    The keys found in all the nested Tcl dictionaries are sorted in ascending dictionary order,
                     as generated by Tcl's builtin command <b>lsort</b> <b>-increasing</b> <b>-dict</b>.

              [2]    The string representation of the value is the canonical representation of a Tcl dictionary.
                     I.e. it does not contain superfluous whitespace.

   <b>EXAMPLE</b>
       Assuming the following PEG for simple mathematical expressions

              PEG calculator (Expression)
                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'       ;
                  Sign       &lt;- '-' / '+'                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- '*' / '/'                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- '+'/'-'                                       ;
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

       then its canonical serialization (except for whitespace) is

              pt::grammar::peg {
                  rules {
                      AddOp      {is {/ {t -} {t +}}                                                                mode value}
                      Digit      {is {/ {t 0} {t 1} {t 2} {t 3} {t 4} {t 5} {t 6} {t 7} {t 8} {t 9}}                mode value}
                      Expression {is {x {n Term} {* {x {n AddOp} {n Term}}}}                                        mode value}
                      Factor     {is {/ {x {t (} {n Expression} {t )}} {n Number}}                                  mode value}
                      MulOp      {is {/ {t *} {t /}}                                                                mode value}
                      Number     {is {x {? {n Sign}} {+ {n Digit}}}                                                 mode value}
                      Sign       {is {/ {t -} {t +}}                                                                mode value}
                      Term       {is {x {n Factor} {* {x {n MulOp} {n Factor}}}}                                    mode value}
                  }
                  start {n Expression}
              }

</pre><h4><b>PE</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here  we specify the format used by the Parser Tools to serialize Parsing Expressions as immutable values
       for transport, comparison, etc.

       We distinguish between <u>regular</u> and <u>canonical</u> serializations.  While a parsing expression  may  have  more
       than one regular serialization only exactly one of them will be <u>canonical</u>.

       Regular serialization

              <b>Atomic</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    The string <b>epsilon</b> is an atomic parsing expression. It matches the empty string.

                     [2]    The string <b>dot</b> is an atomic parsing expression. It matches any character.

                     [3]    The string <b>alnum</b> is an atomic parsing expression. It matches any Unicode alphabet or
                            digit  character.  This  is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [4]    The string <b>alpha</b> is an atomic parsing expression. It matches  any  Unicode  alphabet
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [5]    The string <b>ascii</b> is an atomic parsing expression. It matches any  Unicode  character
                            below U0080. This is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [6]    The  string  <b>control</b> is an atomic parsing expression. It matches any Unicode control
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [7]    The  string  <b>digit</b>  is  an  atomic  parsing expression. It matches any Unicode digit
                            character. Note that this includes characters outside of the [0..9] range. This is a
                            custom extension of PEs based on Tcl's builtin command <b>string</b> <b>is</b>.

                     [8]    The string <b>graph</b> is an atomic parsing expression. It matches  any  Unicode  printing
                            character,  except  for  space.  This  is  a  custom extension of PEs based on Tcl's
                            builtin command <b>string</b> <b>is</b>.

                     [9]    The string <b>lower</b> is an atomic parsing expression. It matches any Unicode  lower-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [10]   The  string  <b>print</b>  is an atomic parsing expression. It matches any Unicode printing
                            character, including space. This is a custom extension of PEs based on Tcl's builtin
                            command <b>string</b> <b>is</b>.

                     [11]   The string <b>punct</b> is an atomic parsing expression. It matches any Unicode punctuation
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [12]   The  string  <b>space</b>  is  an  atomic  parsing expression. It matches any Unicode space
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [13]   The  string <b>upper</b> is an atomic parsing expression. It matches any Unicode upper-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [14]   The string <b>wordchar</b> is an atomic parsing expression. It  matches  any  Unicode  word
                            character.  This  is  any  alphanumeric  character  (see  alnum),  and any connector
                            punctuation characters (e.g.  underscore). This is a custom extension of  PEs  based
                            on Tcl's builtin command <b>string</b> <b>is</b>.

                     [15]   The  string <b>xdigit</b> is an atomic parsing expression. It matches any hexadecimal digit
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [16]   The  string  <b>ddigit</b>  is  an  atomic parsing expression. It matches any decimal digit
                            character. This is a custom extension of PEs based on Tcl's builtin command <b>regexp</b>.

                     [17]   The expression [list t <b>x</b>] is an atomic parsing expression. It matches  the  terminal
                            string <b>x</b>.

                     [18]   The  expression  [list  n  <b>A</b>]  is  an  atomic  parsing  expression.  It  matches the
                            nonterminal <b>A</b>.

              <b>Combined</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    For parsing expressions <b>e1</b>, <b>e2</b>, ... the result of [list / <b>e1</b> <b>e2</b> ... ] is  a  parsing
                            expression as well.  This is the <u>ordered</u> <u>choice</u>, aka <u>prioritized</u> <u>choice</u>.

                     [2]    For  parsing  expressions <b>e1</b>, <b>e2</b>, ... the result of [list x <b>e1</b> <b>e2</b> ... ] is a parsing
                            expression as well.  This is the <u>sequence</u>.

                     [3]    For a parsing expression <b>e</b> the result of [list * <b>e</b>] is a parsing expression as well.
                            This is the <u>kleene</u> <u>closure</u>, describing zero or more repetitions.

                     [4]    For a parsing expression <b>e</b> the result of [list + <b>e</b>] is a parsing expression as well.
                            This is the <u>positive</u> <u>kleene</u> <u>closure</u>, describing one or more repetitions.

                     [5]    For a parsing expression <b>e</b> the result of [list &amp; <b>e</b>] is a parsing expression as well.
                            This is the <u>and</u> <u>lookahead</u> <u>predicate</u>.

                     [6]    For a parsing expression <b>e</b> the result of [list ! <b>e</b>] is a parsing expression as well.
                            This is the <u>not</u> <u>lookahead</u> <u>predicate</u>.

                     [7]    For a parsing expression <b>e</b> the result of [list ? <b>e</b>] is a parsing expression as well.
                            This is the <u>optional</u> <u>input</u>.

       Canonical serialization
              The canonical serialization of a parsing expression has the format as specified  in  the  previous
              item,  and  then  additionally satisfies the constraints below, which make it unique among all the
              possible serializations of this parsing expression.

              [1]    The string representation of the value is the canonical representation of a pure Tcl  list.
                     I.e. it does not contain superfluous whitespace.

              [2]    Terminals are <u>not</u> encoded as ranges (where start and end of the range are identical).

   <b>EXAMPLE</b>
       Assuming the parsing expression shown on the right-hand side of the rule

                  Expression &lt;- Term (AddOp Term)*

       then its canonical serialization (except for whitespace) is

                  {x {n Term} {* {x {n AddOp} {n Term}}}}

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category <u>pt</u> of the  <u>Tcllib</u>  <u>Trackers</u>  [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].   Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       EBNF,  LL(k),  PEG,  TDPL,  context-free  languages,  conversion, expression, format conversion, grammar,
       matching, parser, parsing expression, parsing expression grammar, push down automaton, recursive descent,
       serialization, state, top-down parsing languages, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Parsing and Grammars

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                1.0.3                               <u>pt::peg::to::<a href="../man3tcl/peg.3tcl.html">peg</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>