<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pt::peg::export::peg - PEG Export Plugin. Write PEG format</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pt::peg::export::peg - PEG Export Plugin. Write PEG format

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>pt::peg::export::peg</b> <b>?1?</b>

       package require <b>pt::peg::to::peg</b>

       <b>export</b> <u>serial</u> <u>configuration</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Are  you lost ?  Do you have trouble understanding this document ?  In that case please read the overview
       provided by the <u>Introduction</u> <u>to</u> <u>Parser</u> <u>Tools</u>. This document is the entrypoint to  the  whole  system  the
       current package is a part of.

       This package implements the parsing expression grammar export plugin for the generation of PEG markup.

       It  resides  in  the  Export  section  of  the  Core  Layer of Parser Tools and is intended to be used by
       <b>pt::peg::export</b>,  the  export  manager,  sitting  between  it  and  the  corresponding  core   conversion
       functionality provided by <b>pt::peg::to::peg</b>.

       IMAGE: arch_core_eplugins

       While  the  direct  use  of  this  package  with  a  regular  interpreter  is  possible, this is strongly
       disrecommended and requires a number of contortions to provide the expected environment.  The proper  way
       to use this functionality depends on the situation:

       [1]    In  an  untrusted  environment  the  proper  access is through the package <b>pt::peg::export</b> and the
              export manager objects it provides.

       [2]    In a trusted environment however simply use the  package  <b>pt::peg::to::peg</b>  and  access  the  core
              conversion functionality directly.

</pre><h4><b>API</b></h4><pre>
       The  API provided by this package satisfies the specification of the Plugin API found in the <u>Parser</u> <u>Tools</u>
       <u>Export</u> <u>API</u> specification.

       <b>export</b> <u>serial</u> <u>configuration</u>
              This command takes the canonical serialization of a parsing expression grammar,  as  specified  in
              section  <b>PEG</b>  <b>serialization</b>  <b>format</b>, and contained in <u>serial</u>, the <u>configuration</u>, a dictionary, and
              generates PEG markup encoding the grammar.  The created string is then returned as the  result  of
              the command.

</pre><h4><b>CONFIGURATION</b></h4><pre>
       The  PEG export plugin recognizes the following configuration variables and changes its behaviour as they
       specify.

       string <u>template</u>
              If this configuration variable is set it is assumed to contain a string  into  which  to  put  the
              generated  text  and  other configuration data. The various locations are expected to be specified
              with the following placeholders:

              <b>@user@</b> To be replaced with the value of the configuration variable <b>user</b>.

              <b>@format@</b>
                     To be replaced with the the constant <b>PEG</b>.

              <b>@file@</b> To be replaced with the value of the configuration variable <b>file</b>.

              <b>@name@</b> To be replaced with the value of the configuration variable <b>name</b>.

              <b>@code@</b> To be replaced with the generated text.

       If this configuration variable is not set, or empty, then the plugin falls back to a  standard  template,
       which is defined as "<b>@code@</b>".

       <u>Note</u>  that  this  plugin  may  ignore  the standard configuration variables <b>user</b>, <b>format</b>, <b>file</b>, and their
       values, depending on the chosen template.

       The content of the standard configuration variable <b>name</b>, if set, is used as name of the  grammar  in  the
       output. Otherwise the plugin falls back to the default name <b>a_pe_grammar</b>.

</pre><h4><b>PEG</b> <b>SPECIFICATION</b> <b>LANGUAGE</b></h4><pre>
       <b>peg</b>,  a  language for the specification of parsing expression grammars is meant to be human readable, and
       writable as well, yet strict enough to allow its processing by machine. Like any  computer  language.  It
       was defined to make writing the specification of a grammar easy, something the other formats found in the
       Parser Tools do not lend themselves too.

       It  is formally specified by the grammar shown below, written in itself. For a tutorial / introduction to
       the language please go and read the <u>PEG</u> <u>Language</u> <u>Tutorial</u>.

              PEG pe_grammar_for_peg (Grammar)

                # --------------------------------------------------------------------
                      # Syntactical constructs

                      Grammar         &lt;- WHITESPACE Header Definition* Final EOF ;

                      Header          &lt;- PEG Identifier StartExpr ;
                      Definition      &lt;- Attribute? Identifier IS Expression SEMICOLON ;
                      Attribute       &lt;- (VOID / LEAF) COLON ;
                      Expression      &lt;- Sequence (SLASH Sequence)* ;
                      Sequence        &lt;- Prefix+ ;
                      Prefix          &lt;- (AND / NOT)? Suffix ;
                      Suffix          &lt;- Primary (QUESTION / STAR / PLUS)? ;
                      Primary         &lt;- ALNUM / ALPHA / ASCII / CONTROL / DDIGIT / DIGIT
                                      /  GRAPH / LOWER / PRINTABLE / PUNCT / SPACE / UPPER
                                      /  WORDCHAR / XDIGIT
                                      / Identifier
                                      /  OPEN Expression CLOSE
                                      /  Literal
                                      /  Class
                                      /  DOT
                                      ;
                      Literal         &lt;- APOSTROPH  (!APOSTROPH  Char)* APOSTROPH  WHITESPACE
                                      /  DAPOSTROPH (!DAPOSTROPH Char)* DAPOSTROPH WHITESPACE ;
                      Class           &lt;- OPENB (!CLOSEB Range)* CLOSEB WHITESPACE ;
                      Range           &lt;- Char TO Char / Char ;

                      StartExpr       &lt;- OPEN Expression CLOSE ;
              void:   Final           &lt;- "END" WHITESPACE SEMICOLON WHITESPACE ;

                      # --------------------------------------------------------------------
                      # Lexing constructs

                      Identifier      &lt;- Ident WHITESPACE ;
              leaf:   Ident           &lt;- ([_:] / &lt;alpha&gt;) ([_:] / &lt;alnum&gt;)* ;
                      Char            &lt;- CharSpecial / CharOctalFull / CharOctalPart
                                      /  CharUnicode / CharUnescaped
                                      ;

              leaf:   CharSpecial     &lt;- "\\" [nrt'"\[\]\\] ;
              leaf:   CharOctalFull   &lt;- "\\" [0-3][0-7][0-7] ;
              leaf:   CharOctalPart   &lt;- "\\" [0-7][0-7]? ;
              leaf:   CharUnicode     &lt;- "\\" 'u' HexDigit (HexDigit (HexDigit HexDigit?)?)? ;
              leaf:   CharUnescaped   &lt;- !"\\" . ;

              void:   HexDigit        &lt;- [0-9a-fA-F] ;

              void:   TO              &lt;- '-'           ;
              void:   OPENB           &lt;- "["           ;
              void:   CLOSEB          &lt;- "]"           ;
              void:   APOSTROPH       &lt;- "'"           ;
              void:   DAPOSTROPH      &lt;- '"'           ;
              void:   PEG             &lt;- "PEG" !([_:] / &lt;alnum&gt;) WHITESPACE ;
              void:   IS              &lt;- "&lt;-"    WHITESPACE ;
              leaf:   VOID            &lt;- "void"  WHITESPACE ; # Implies that definition has no semantic value.
              leaf:   LEAF            &lt;- "leaf"  WHITESPACE ; # Implies that definition has no terminals.
              void:   SEMICOLON       &lt;- ";"     WHITESPACE ;
              void:   COLON           &lt;- ":"     WHITESPACE ;
              void:   SLASH           &lt;- "/"     WHITESPACE ;
              leaf:   AND             &lt;- "&amp;"     WHITESPACE ;
              leaf:   NOT             &lt;- "!"     WHITESPACE ;
              leaf:   QUESTION        &lt;- "?"     WHITESPACE ;
              leaf:   STAR            &lt;- "*"     WHITESPACE ;
              leaf:   PLUS            &lt;- "+"     WHITESPACE ;
              void:   OPEN            &lt;- "("     WHITESPACE ;
              void:   CLOSE           &lt;- ")"     WHITESPACE ;
              leaf:   DOT             &lt;- "."     WHITESPACE ;

              leaf:   ALNUM           &lt;- "&lt;alnum&gt;"    WHITESPACE ;
              leaf:   ALPHA           &lt;- "&lt;alpha&gt;"    WHITESPACE ;
              leaf:   ASCII           &lt;- "&lt;ascii&gt;"    WHITESPACE ;
              leaf:   CONTROL         &lt;- "&lt;control&gt;"  WHITESPACE ;
              leaf:   DDIGIT          &lt;- "&lt;ddigit&gt;"   WHITESPACE ;
              leaf:   DIGIT           &lt;- "&lt;digit&gt;"    WHITESPACE ;
              leaf:   GRAPH           &lt;- "&lt;graph&gt;"    WHITESPACE ;
              leaf:   LOWER           &lt;- "&lt;lower&gt;"    WHITESPACE ;
              leaf:   PRINTABLE       &lt;- "&lt;print&gt;"    WHITESPACE ;
              leaf:   PUNCT           &lt;- "&lt;punct&gt;"    WHITESPACE ;
              leaf:   SPACE           &lt;- "&lt;space&gt;"    WHITESPACE ;
              leaf:   UPPER           &lt;- "&lt;upper&gt;"    WHITESPACE ;
              leaf:   WORDCHAR        &lt;- "&lt;wordchar&gt;" WHITESPACE ;
              leaf:   XDIGIT          &lt;- "&lt;xdigit&gt;"   WHITESPACE ;

              void:   WHITESPACE      &lt;- (" " / "\t" / EOL / COMMENT)* ;
              void:   COMMENT         &lt;- '#' (!EOL .)* EOL ;
              void:   EOL             &lt;- "\n\r" / "\n" / "\r" ;
              void:   EOF             &lt;- !. ;

                      # --------------------------------------------------------------------
              END;

   <b>EXAMPLE</b>
       Our example specifies the grammar for a basic 4-operation calculator.

              PEG calculator (Expression)
                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'       ;
                  Sign       &lt;- '-' / '+'                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- '*' / '/'                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- '+'/'-'                                       ;
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

       Using higher-level features of the notation, i.e. the character classes  (predefined  and  custom),  this
       example can be rewritten as

              PEG calculator (Expression)
                  Sign       &lt;- [-+]                                          ;
                  Number     &lt;- Sign? &lt;ddigit&gt;+                               ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- [*/];
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- [-+];
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

</pre><h4><b>PEG</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here we specify the format used by the Parser Tools to serialize Parsing Expression Grammars as immutable
       values for transport, comparison, etc.

       We  distinguish between <u>regular</u> and <u>canonical</u> serializations.  While a PEG may have more than one regular
       serialization only exactly one of them will be <u>canonical</u>.

       regular serialization

              [1]    The serialization of any PEG is a nested Tcl dictionary.

              [2]    This dictionary holds a single key, <b>pt::grammar::peg</b>, and its value. This value  holds  the
                     contents of the grammar.

              [3]    The contents of the grammar are a Tcl dictionary holding the set of nonterminal symbols and
                     the starting expression. The relevant keys and their values are

                     <b>rules</b>  The  value  is  a Tcl dictionary whose keys are the names of the nonterminal symbols
                            known to the grammar.

                            [1]    Each nonterminal symbol may occur only once.

                            [2]    The empty string is not a legal nonterminal symbol.

                            [3]    The value for each symbol is a Tcl dictionary itself. The relevant  keys  and
                                   their values in this dictionary are

                                   <b>is</b>     The  value  is  the serialization of the parsing expression describing
                                          the symbols sentennial structure,  as  specified  in  the  section  <b>PE</b>
                                          <b>serialization</b> <b>format</b>.

                                   <b>mode</b>   The  value  can  be one of three values specifying how a parser should
                                          handle the semantic value produced by the symbol.

                                          <b>value</b>  The semantic value of the nonterminal  symbol  is  an  abstract
                                                 syntax   tree   consisting  of  a  single  node  node  for  the
                                                 nonterminal itself, which has the ASTs of  the  symbol's  right
                                                 hand side as its children.

                                          <b>leaf</b>   The  semantic  value  of  the nonterminal symbol is an abstract
                                                 syntax  tree  consisting  of  a  single  node  node   for   the
                                                 nonterminal,  without  any  children. Any ASTs generated by the
                                                 symbol's right hand side are discarded.

                                          <b>void</b>   The nonterminal has no semantic value. Any  ASTs  generated  by
                                                 the symbol's right hand side are discarded (as well).

                     <b>start</b>  The  value  is  the serialization of the start parsing expression of the grammar, as
                            specified in the section <b>PE</b> <b>serialization</b> <b>format</b>.

              [4]    The terminal symbols of the grammar are specified implicitly as the  set  of  all  terminal
                     symbols used in the start expression and on the RHS of the grammar rules.

       canonical serialization
              The  canonical  serialization  of  a grammar has the format as specified in the previous item, and
              then additionally satisfies the constraints below, which make it unique  among  all  the  possible
              serializations of this grammar.

              [1]    The keys found in all the nested Tcl dictionaries are sorted in ascending dictionary order,
                     as generated by Tcl's builtin command <b>lsort</b> <b>-increasing</b> <b>-dict</b>.

              [2]    The string representation of the value is the canonical representation of a Tcl dictionary.
                     I.e. it does not contain superfluous whitespace.

   <b>EXAMPLE</b>
       Assuming the following PEG for simple mathematical expressions

              PEG calculator (Expression)
                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'       ;
                  Sign       &lt;- '-' / '+'                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- '*' / '/'                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- '+'/'-'                                       ;
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

       then its canonical serialization (except for whitespace) is

              pt::grammar::peg {
                  rules {
                      AddOp      {is {/ {t -} {t +}}                                                                mode value}
                      Digit      {is {/ {t 0} {t 1} {t 2} {t 3} {t 4} {t 5} {t 6} {t 7} {t 8} {t 9}}                mode value}
                      Expression {is {x {n Term} {* {x {n AddOp} {n Term}}}}                                        mode value}
                      Factor     {is {/ {x {t (} {n Expression} {t )}} {n Number}}                                  mode value}
                      MulOp      {is {/ {t *} {t /}}                                                                mode value}
                      Number     {is {x {? {n Sign}} {+ {n Digit}}}                                                 mode value}
                      Sign       {is {/ {t -} {t +}}                                                                mode value}
                      Term       {is {x {n Factor} {* {x {n MulOp} {n Factor}}}}                                    mode value}
                  }
                  start {n Expression}
              }

</pre><h4><b>PE</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here  we specify the format used by the Parser Tools to serialize Parsing Expressions as immutable values
       for transport, comparison, etc.

       We distinguish between <u>regular</u> and <u>canonical</u> serializations.  While a parsing expression  may  have  more
       than one regular serialization only exactly one of them will be <u>canonical</u>.

       Regular serialization

              <b>Atomic</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    The string <b>epsilon</b> is an atomic parsing expression. It matches the empty string.

                     [2]    The string <b>dot</b> is an atomic parsing expression. It matches any character.

                     [3]    The string <b>alnum</b> is an atomic parsing expression. It matches any Unicode alphabet or
                            digit  character.  This  is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [4]    The string <b>alpha</b> is an atomic parsing expression. It matches  any  Unicode  alphabet
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [5]    The string <b>ascii</b> is an atomic parsing expression. It matches any  Unicode  character
                            below U0080. This is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [6]    The  string  <b>control</b> is an atomic parsing expression. It matches any Unicode control
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [7]    The  string  <b>digit</b>  is  an  atomic  parsing expression. It matches any Unicode digit
                            character. Note that this includes characters outside of the [0..9] range. This is a
                            custom extension of PEs based on Tcl's builtin command <b>string</b> <b>is</b>.

                     [8]    The string <b>graph</b> is an atomic parsing expression. It matches  any  Unicode  printing
                            character,  except  for  space.  This  is  a  custom extension of PEs based on Tcl's
                            builtin command <b>string</b> <b>is</b>.

                     [9]    The string <b>lower</b> is an atomic parsing expression. It matches any Unicode  lower-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [10]   The  string  <b>print</b>  is an atomic parsing expression. It matches any Unicode printing
                            character, including space. This is a custom extension of PEs based on Tcl's builtin
                            command <b>string</b> <b>is</b>.

                     [11]   The string <b>punct</b> is an atomic parsing expression. It matches any Unicode punctuation
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [12]   The  string  <b>space</b>  is  an  atomic  parsing expression. It matches any Unicode space
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [13]   The  string <b>upper</b> is an atomic parsing expression. It matches any Unicode upper-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [14]   The string <b>wordchar</b> is an atomic parsing expression. It  matches  any  Unicode  word
                            character.  This  is  any  alphanumeric  character  (see  alnum),  and any connector
                            punctuation characters (e.g.  underscore). This is a custom extension of  PEs  based
                            on Tcl's builtin command <b>string</b> <b>is</b>.

                     [15]   The  string <b>xdigit</b> is an atomic parsing expression. It matches any hexadecimal digit
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [16]   The  string  <b>ddigit</b>  is  an  atomic parsing expression. It matches any decimal digit
                            character. This is a custom extension of PEs based on Tcl's builtin command <b>regexp</b>.

                     [17]   The expression [list t <b>x</b>] is an atomic parsing expression. It matches  the  terminal
                            string <b>x</b>.

                     [18]   The  expression  [list  n  <b>A</b>]  is  an  atomic  parsing  expression.  It  matches the
                            nonterminal <b>A</b>.

              <b>Combined</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    For parsing expressions <b>e1</b>, <b>e2</b>, ... the result of [list / <b>e1</b> <b>e2</b> ... ] is  a  parsing
                            expression as well.  This is the <u>ordered</u> <u>choice</u>, aka <u>prioritized</u> <u>choice</u>.

                     [2]    For  parsing  expressions <b>e1</b>, <b>e2</b>, ... the result of [list x <b>e1</b> <b>e2</b> ... ] is a parsing
                            expression as well.  This is the <u>sequence</u>.

                     [3]    For a parsing expression <b>e</b> the result of [list * <b>e</b>] is a parsing expression as well.
                            This is the <u>kleene</u> <u>closure</u>, describing zero or more repetitions.

                     [4]    For a parsing expression <b>e</b> the result of [list + <b>e</b>] is a parsing expression as well.
                            This is the <u>positive</u> <u>kleene</u> <u>closure</u>, describing one or more repetitions.

                     [5]    For a parsing expression <b>e</b> the result of [list &amp; <b>e</b>] is a parsing expression as well.
                            This is the <u>and</u> <u>lookahead</u> <u>predicate</u>.

                     [6]    For a parsing expression <b>e</b> the result of [list ! <b>e</b>] is a parsing expression as well.
                            This is the <u>not</u> <u>lookahead</u> <u>predicate</u>.

                     [7]    For a parsing expression <b>e</b> the result of [list ? <b>e</b>] is a parsing expression as well.
                            This is the <u>optional</u> <u>input</u>.

       Canonical serialization
              The canonical serialization of a parsing expression has the format as specified  in  the  previous
              item,  and  then  additionally satisfies the constraints below, which make it unique among all the
              possible serializations of this parsing expression.

              [1]    The string representation of the value is the canonical representation of a pure Tcl  list.
                     I.e. it does not contain superfluous whitespace.

              [2]    Terminals are <u>not</u> encoded as ranges (where start and end of the range are identical).

   <b>EXAMPLE</b>
       Assuming the parsing expression shown on the right-hand side of the rule

                  Expression &lt;- Term (AddOp Term)*

       then its canonical serialization (except for whitespace) is

                  {x {n Term} {* {x {n AddOp} {n Term}}}}

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category <u>pt</u> of the  <u>Tcllib</u>  <u>Trackers</u>  [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].   Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       EBNF,  LL(k),  PEG,  TDPL, context-free languages, export, expression, grammar, matching, parser, parsing
       expression, parsing expression grammar, plugin, push down automaton,  recursive  descent,  serialization,
       state, top-down parsing languages, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Parsing and Grammars

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                  1                             <u>pt::peg::export::<a href="../man3tcl/peg.3tcl.html">peg</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>