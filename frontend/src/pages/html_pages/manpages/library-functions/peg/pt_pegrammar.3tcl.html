<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pt::peg - Parsing Expression Grammar Serialization</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pt::peg - Parsing Expression Grammar Serialization

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>pt::peg</b> <b>?1.1?</b>

       package require <b>pt::pe</b>

       <b>::pt::peg</b> <b>verify</b> <u>serial</u> ?<u>canonvar</u>?

       <b>::pt::peg</b> <b>verify-as-canonical</b> <u>serial</u>

       <b>::pt::peg</b> <b>canonicalize</b> <u>serial</u>

       <b>::pt::peg</b> <b>print</b> <u>serial</u>

       <b>::pt::peg</b> <b>merge</b> <u>seriala</u> <u>serialb</u>

       <b>::pt::peg</b> <b>equal</b> <u>seriala</u> <u>serialb</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Are  you lost ?  Do you have trouble understanding this document ?  In that case please read the overview
       provided by the <u>Introduction</u> <u>to</u> <u>Parser</u> <u>Tools</u>. This document is the entrypoint to  the  whole  system  the
       current package is a part of.

       This  package provides commands to work with the serializations of parsing expression grammars as managed
       by the Parser Tools, and specified in section <b>PEG</b> <b>serialization</b> <b>format</b>.

       This is a supporting package in the Core Layer of Parser Tools.

       IMAGE: arch_core_support

</pre><h4><b>API</b></h4><pre>
       <b>::pt::peg</b> <b>verify</b> <u>serial</u> ?<u>canonvar</u>?
              This command verifies that the content of <u>serial</u> is a valid serialization of a parsing  expression
              and will throw an error if that is not the case. The result of the command is the empty string.

              If  the  argument <u>canonvar</u> is specified it is interpreted as the name of a variable in the calling
              context. This variable will be written to if and only if <u>serial</u> is a valid regular  serialization.
              Its  value  will  be a boolean, with <b>True</b> indicating that the serialization is not only valid, but
              also <u>canonical</u>. <b>False</b> will be written for a valid, but non-canonical serialization.

              For the specification of serializations see the section <b>PE</b> <b>serialization</b> <b>format</b>.

       <b>::pt::peg</b> <b>verify-as-canonical</b> <u>serial</u>
              This command verifies that the content of <u>serial</u> is a valid <u>canonical</u> serialization of a  PEG  and
              will throw an error if that is not the case. The result of the command is the empty string.

              For the specification of canonical serializations see the section <b>PEG</b> <b>serialization</b> <b>format</b>.

       <b>::pt::peg</b> <b>canonicalize</b> <u>serial</u>
              This command assumes that the content of <u>serial</u> is a valid <u>regular</u> serialization of a PEG and will
              throw an error if that is not the case.

              It will then convert the input into the <u>canonical</u> serialization of the contained PEG and return it
              as its result. If the input is already canonical it will be returned unchanged.

              For  the  specification  of regular and canonical serializations see the section <b>PEG</b> <b>serialization</b>
              <b>format</b>.

       <b>::pt::peg</b> <b>print</b> <u>serial</u>
              This command assumes that the  argument  <u>serial</u>  contains  a  valid  serialization  of  a  parsing
              expression and returns a string containing that PE in a human readable form.

              The  exact  format  of  this  form  is  not specified and cannot be relied on for parsing or other
              machine-based activities.

              For the specification of serializations see the section <b>PEG</b> <b>serialization</b> <b>format</b>.

       <b>::pt::peg</b> <b>merge</b> <u>seriala</u> <u>serialb</u>
              This command accepts the regular serializations of two grammars and  uses  them  to  create  their
              union.  The result of the command is the canonical serialization of this unified grammar.

              A  merge  errors  occurs  if  for any nonterminal symbol S occuring in both input grammars the two
              input grammars specify different semantic modes.

              The semantic mode of each nonterminal symbol S is the semantic mode of  S  in  any  of  its  input
              grammars.  The previous rule made sure that for symbols occuring in both grammars these values are
              identical.

              The right-hand side of each nonterminal symbol S occuring in both input  grammars  is  the  choice
              between  the  right-hand  sides  of  S  in the input grammars, with the parsing expression of S in
              <u>seriala</u> coming first, except if both expressions are identical. In that case the first  expression
              is taken.

              The right-hand side of each nonterminal symbol S occuring in only one of the input grammars is the
              right-hand side of S in its input grammar.

              The  start  expression  of  the unified grammar is the choice between the start expressions of the
              input grammars, with the start expression of <u>seriala</u> coming first, except if both expressions  are
              identical.  In that case the first expression is taken

       <b>::pt::peg</b> <b>equal</b> <u>seriala</u> <u>serialb</u>
              This command tests the two grammars <u>seriala</u> and <u>serialb</u> for structural equality. The result of the
              command  is  a  boolean  value. It will be set to <b>true</b> if the expressions are identical, and <b>false</b>
              otherwise.

              String equality is usable only if we can assume that the two  grammars  are  pure  Tcl  lists  and
              dictionaries.

</pre><h4><b>PEG</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here we specify the format used by the Parser Tools to serialize Parsing Expression Grammars as immutable
       values for transport, comparison, etc.

       We  distinguish between <u>regular</u> and <u>canonical</u> serializations.  While a PEG may have more than one regular
       serialization only exactly one of them will be <u>canonical</u>.

       regular serialization

              [1]    The serialization of any PEG is a nested Tcl dictionary.

              [2]    This dictionary holds a single key, <b>pt::grammar::peg</b>, and its value. This value  holds  the
                     contents of the grammar.

              [3]    The contents of the grammar are a Tcl dictionary holding the set of nonterminal symbols and
                     the starting expression. The relevant keys and their values are

                     <b>rules</b>  The  value  is  a Tcl dictionary whose keys are the names of the nonterminal symbols
                            known to the grammar.

                            [1]    Each nonterminal symbol may occur only once.

                            [2]    The empty string is not a legal nonterminal symbol.

                            [3]    The value for each symbol is a Tcl dictionary itself. The relevant  keys  and
                                   their values in this dictionary are

                                   <b>is</b>     The  value  is  the serialization of the parsing expression describing
                                          the symbols sentennial structure,  as  specified  in  the  section  <b>PE</b>
                                          <b>serialization</b> <b>format</b>.

                                   <b>mode</b>   The  value  can  be one of three values specifying how a parser should
                                          handle the semantic value produced by the symbol.

                                          <b>value</b>  The semantic value of the nonterminal  symbol  is  an  abstract
                                                 syntax   tree   consisting  of  a  single  node  node  for  the
                                                 nonterminal itself, which has the ASTs of  the  symbol's  right
                                                 hand side as its children.

                                          <b>leaf</b>   The  semantic  value  of  the nonterminal symbol is an abstract
                                                 syntax  tree  consisting  of  a  single  node  node   for   the
                                                 nonterminal,  without  any  children. Any ASTs generated by the
                                                 symbol's right hand side are discarded.

                                          <b>void</b>   The nonterminal has no semantic value. Any  ASTs  generated  by
                                                 the symbol's right hand side are discarded (as well).

                     <b>start</b>  The  value  is  the serialization of the start parsing expression of the grammar, as
                            specified in the section <b>PE</b> <b>serialization</b> <b>format</b>.

              [4]    The terminal symbols of the grammar are specified implicitly as the  set  of  all  terminal
                     symbols used in the start expression and on the RHS of the grammar rules.

       canonical serialization
              The  canonical  serialization  of  a grammar has the format as specified in the previous item, and
              then additionally satisfies the constraints below, which make it unique  among  all  the  possible
              serializations of this grammar.

              [1]    The keys found in all the nested Tcl dictionaries are sorted in ascending dictionary order,
                     as generated by Tcl's builtin command <b>lsort</b> <b>-increasing</b> <b>-dict</b>.

              [2]    The string representation of the value is the canonical representation of a Tcl dictionary.
                     I.e. it does not contain superfluous whitespace.

   <b>EXAMPLE</b>
       Assuming the following PEG for simple mathematical expressions

              PEG calculator (Expression)
                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'       ;
                  Sign       &lt;- '-' / '+'                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- '*' / '/'                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- '+'/'-'                                       ;
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

       then its canonical serialization (except for whitespace) is

              pt::grammar::peg {
                  rules {
                      AddOp      {is {/ {t -} {t +}}                                                                mode value}
                      Digit      {is {/ {t 0} {t 1} {t 2} {t 3} {t 4} {t 5} {t 6} {t 7} {t 8} {t 9}}                mode value}
                      Expression {is {x {n Term} {* {x {n AddOp} {n Term}}}}                                        mode value}
                      Factor     {is {/ {x {t (} {n Expression} {t )}} {n Number}}                                  mode value}
                      MulOp      {is {/ {t *} {t /}}                                                                mode value}
                      Number     {is {x {? {n Sign}} {+ {n Digit}}}                                                 mode value}
                      Sign       {is {/ {t -} {t +}}                                                                mode value}
                      Term       {is {x {n Factor} {* {x {n MulOp} {n Factor}}}}                                    mode value}
                  }
                  start {n Expression}
              }

</pre><h4><b>PE</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here  we specify the format used by the Parser Tools to serialize Parsing Expressions as immutable values
       for transport, comparison, etc.

       We distinguish between <u>regular</u> and <u>canonical</u> serializations.  While a parsing expression  may  have  more
       than one regular serialization only exactly one of them will be <u>canonical</u>.

       Regular serialization

              <b>Atomic</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    The string <b>epsilon</b> is an atomic parsing expression. It matches the empty string.

                     [2]    The string <b>dot</b> is an atomic parsing expression. It matches any character.

                     [3]    The string <b>alnum</b> is an atomic parsing expression. It matches any Unicode alphabet or
                            digit  character.  This  is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [4]    The string <b>alpha</b> is an atomic parsing expression. It matches  any  Unicode  alphabet
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [5]    The string <b>ascii</b> is an atomic parsing expression. It matches any  Unicode  character
                            below U0080. This is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [6]    The  string  <b>control</b> is an atomic parsing expression. It matches any Unicode control
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [7]    The  string  <b>digit</b>  is  an  atomic  parsing expression. It matches any Unicode digit
                            character. Note that this includes characters outside of the [0..9] range. This is a
                            custom extension of PEs based on Tcl's builtin command <b>string</b> <b>is</b>.

                     [8]    The string <b>graph</b> is an atomic parsing expression. It matches  any  Unicode  printing
                            character,  except  for  space.  This  is  a  custom extension of PEs based on Tcl's
                            builtin command <b>string</b> <b>is</b>.

                     [9]    The string <b>lower</b> is an atomic parsing expression. It matches any Unicode  lower-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [10]   The  string  <b>print</b>  is an atomic parsing expression. It matches any Unicode printing
                            character, including space. This is a custom extension of PEs based on Tcl's builtin
                            command <b>string</b> <b>is</b>.

                     [11]   The string <b>punct</b> is an atomic parsing expression. It matches any Unicode punctuation
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [12]   The  string  <b>space</b>  is  an  atomic  parsing expression. It matches any Unicode space
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [13]   The  string <b>upper</b> is an atomic parsing expression. It matches any Unicode upper-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [14]   The string <b>wordchar</b> is an atomic parsing expression. It  matches  any  Unicode  word
                            character.  This  is  any  alphanumeric  character  (see  alnum),  and any connector
                            punctuation characters (e.g.  underscore). This is a custom extension of  PEs  based
                            on Tcl's builtin command <b>string</b> <b>is</b>.

                     [15]   The  string <b>xdigit</b> is an atomic parsing expression. It matches any hexadecimal digit
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [16]   The  string  <b>ddigit</b>  is  an  atomic parsing expression. It matches any decimal digit
                            character. This is a custom extension of PEs based on Tcl's builtin command <b>regexp</b>.

                     [17]   The expression [list t <b>x</b>] is an atomic parsing expression. It matches  the  terminal
                            string <b>x</b>.

                     [18]   The  expression  [list  n  <b>A</b>]  is  an  atomic  parsing  expression.  It  matches the
                            nonterminal <b>A</b>.

              <b>Combined</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    For parsing expressions <b>e1</b>, <b>e2</b>, ... the result of [list / <b>e1</b> <b>e2</b> ... ] is  a  parsing
                            expression as well.  This is the <u>ordered</u> <u>choice</u>, aka <u>prioritized</u> <u>choice</u>.

                     [2]    For  parsing  expressions <b>e1</b>, <b>e2</b>, ... the result of [list x <b>e1</b> <b>e2</b> ... ] is a parsing
                            expression as well.  This is the <u>sequence</u>.

                     [3]    For a parsing expression <b>e</b> the result of [list * <b>e</b>] is a parsing expression as well.
                            This is the <u>kleene</u> <u>closure</u>, describing zero or more repetitions.

                     [4]    For a parsing expression <b>e</b> the result of [list + <b>e</b>] is a parsing expression as well.
                            This is the <u>positive</u> <u>kleene</u> <u>closure</u>, describing one or more repetitions.

                     [5]    For a parsing expression <b>e</b> the result of [list &amp; <b>e</b>] is a parsing expression as well.
                            This is the <u>and</u> <u>lookahead</u> <u>predicate</u>.

                     [6]    For a parsing expression <b>e</b> the result of [list ! <b>e</b>] is a parsing expression as well.
                            This is the <u>not</u> <u>lookahead</u> <u>predicate</u>.

                     [7]    For a parsing expression <b>e</b> the result of [list ? <b>e</b>] is a parsing expression as well.
                            This is the <u>optional</u> <u>input</u>.

       Canonical serialization
              The canonical serialization of a parsing expression has the format as specified  in  the  previous
              item,  and  then  additionally satisfies the constraints below, which make it unique among all the
              possible serializations of this parsing expression.

              [1]    The string representation of the value is the canonical representation of a pure Tcl  list.
                     I.e. it does not contain superfluous whitespace.

              [2]    Terminals are <u>not</u> encoded as ranges (where start and end of the range are identical).

   <b>EXAMPLE</b>
       Assuming the parsing expression shown on the right-hand side of the rule

                  Expression &lt;- Term (AddOp Term)*

       then its canonical serialization (except for whitespace) is

                  {x {n Term} {* {x {n AddOp} {n Term}}}}

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category <u>pt</u> of the  <u>Tcllib</u>  <u>Trackers</u>  [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].   Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       EBNF,   LL(k),  PEG,  TDPL,  context-free  languages,  expression,  grammar,  matching,  parser,  parsing
       expression, parsing expression grammar, push down automaton, recursive descent, state,  top-down  parsing
       languages, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Parsing and Grammars

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                1.1.1                                        <u>pt::<a href="../man3tcl/peg.3tcl.html">peg</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>