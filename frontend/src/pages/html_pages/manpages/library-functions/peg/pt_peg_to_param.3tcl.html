<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pt::peg::to::param - PEG Conversion. Write PARAM format</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pt::peg::to::param - PEG Conversion. Write PARAM format

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>pt::peg::to::param</b> <b>?1.1?</b>

       package require <b>pt::peg</b>

       package require <b>pt::pe</b>

       <b>pt::peg::to::param</b> <b>reset</b>

       <b>pt::peg::to::param</b> <b>configure</b>

       <b>pt::peg::to::param</b> <b>configure</b> <u>option</u>

       <b>pt::peg::to::param</b> <b>configure</b> <u>option</u> <u>value</u>...

       <b>pt::peg::to::param</b> <b>convert</b> <u>serial</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Are  you lost ?  Do you have trouble understanding this document ?  In that case please read the overview
       provided by the <u>Introduction</u> <u>to</u> <u>Parser</u> <u>Tools</u>. This document is the entrypoint to  the  whole  system  the
       current package is a part of.

       This package implements the converter from parsing expression grammars to PARAM markup.

       It  resides in the Export section of the Core Layer of Parser Tools, and can be used either directly with
       the other packages of this layer, or indirectly through the export manager provided  by  <b>pt::peg::export</b>.
       The latter is intented for use in untrusted environments and done through the corresponding export plugin
       <b>pt::peg::export::param</b> sitting between converter and export manager.

       IMAGE: arch_core_eplugins

</pre><h4><b>API</b></h4><pre>
       The  API  provided  by  this package satisfies the specification of the Converter API found in the <u>Parser</u>
       <u>Tools</u> <u>Export</u> <u>API</u> specification.

       <b>pt::peg::to::param</b> <b>reset</b>
              This command resets the configuration of the package to its default settings.

       <b>pt::peg::to::param</b> <b>configure</b>
              This command returns a dictionary containing the current configuration of the package.

       <b>pt::peg::to::param</b> <b>configure</b> <u>option</u>
              This command returns the current value of the specified configuration <u>option</u> of the  package.  For
              the set of legal options, please read the section <b>Options</b>.

       <b>pt::peg::to::param</b> <b>configure</b> <u>option</u> <u>value</u>...
              This command sets the given configuration <u>option</u>s of the package, to the specified <u>value</u>s. For the
              set of legal options, please read the section <b>Options</b>.

       <b>pt::peg::to::param</b> <b>convert</b> <u>serial</u>
              This  command  takes  the canonical serialization of a parsing expression grammar, as specified in
              section <b>PEG</b> <b>serialization</b> <b>format</b>, and contained in <u>serial</u>, and generates PARAM markup encoding the
              grammar, per the current package configuration.  The created string is then returned as the result
              of the command.

</pre><h4><b>OPTIONS</b></h4><pre>
       The converter to PARAM markup recognizes the following configuration variables and changes its  behaviour
       as they specify.

       <b>-template</b> string
              The  value of this configuration variable is a string into which to put the generated text and the
              other configuration settings. The various locations for user-data are  expected  to  be  specified
              with the placeholders listed below. The default value is "<b>@code@</b>".

              <b>@user@</b> To be replaced with the value of the configuration variable <b>-user</b>.

              <b>@format@</b>
                     To be replaced with the the constant <b>PARAM</b>.

              <b>@file@</b> To be replaced with the value of the configuration variable <b>-file</b>.

              <b>@name@</b> To be replaced with the value of the configuration variable <b>-name</b>.

              <b>@code@</b> To be replaced with the generated text.

       <b>-name</b> string
              The  value  of  this configuration variable is the name of the grammar for which the conversion is
              run. The default value is <b>a_pe_grammar</b>.

       <b>-user</b> string
              The value of this configuration variable is the name of the user for which the conversion is  run.
              The default value is <b>unknown</b>.

       <b>-file</b> string
              The  value  of  this configuration variable is the name of the file or other entity from which the
              grammar came, for which the conversion is run. The default value is <b>unknown</b>.

</pre><h4><b>PARAM</b> <b>CODE</b> <b>REPRESENTATION</b> <b>OF</b> <b>PARSING</b> <b>EXPRESSION</b> <b>GRAMMARS</b></h4><pre>
       The  PARAM  code  representation  of  parsing  expression  grammars  is  assembler-like  text  using  the
       instructions  of the virtual machine documented in the <u>PackRat</u> <u>Machine</u> <u>Specification</u>, plus a few more for
       control flow (jump ok, jump fail, call symbol, return).

       It is not really useful, except possibly as a tool demonstrating how a grammar is  compiled  in  general,
       without  getting  distracted  by the incidentials of a framework, i.e. like the supporting C and Tcl code
       generated by the other PARAM-derived formats.

       It has no direct formal specification beyond what was said above.

   <b>EXAMPLE</b>
       Assuming the following PEG for simple mathematical expressions

              PEG calculator (Expression)
                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'       ;
                  Sign       &lt;- '-' / '+'                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- '*' / '/'                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- '+'/'-'                                       ;
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

       one possible PARAM serialization for it is

              # -*- text -*-
              # Parsing Expression Grammar 'TEMPLATE'.
              # Generated for unknown, from file 'TEST'

              #
              # Grammar Start Expression
              #

              &lt;&lt;MAIN&gt;&gt;:
                       call              sym_Expression
                       halt

              #
              # value Symbol 'AddOp'
              #

              sym_AddOp:
              # /
              #     '-'
              #     '+'

                       symbol_restore    AddOp
                found! jump              found_7
                       loc_push

                       call              choice_5

                 fail! value_clear
                   ok! value_leaf        AddOp
                       symbol_save       AddOp
                       error_nonterminal AddOp
                       loc_pop_discard

              found_7:
                   ok! ast_value_push
                       return

              choice_5:
              # /
              #     '-'
              #     '+'

                       error_clear

                       loc_push
                       error_push

                       input_next        "t -"
                   ok! test_char         "-"

                       error_pop_merge
                   ok! jump              oknoast_4

                       loc_pop_rewind
                       loc_push
                       error_push

                       input_next        "t +"
                   ok! test_char         "+"

                       error_pop_merge
                   ok! jump              oknoast_4

                       loc_pop_rewind
                       status_fail
                       return

              oknoast_4:
                       loc_pop_discard
                       return
              #
              # value Symbol 'Digit'
              #

              sym_Digit:
              # /
              #     '0'
              #     '1'
              #     '2'
              #     '3'
              #     '4'
              #     '5'
              #     '6'
              #     '7'
              #     '8'
              #     '9'

                       symbol_restore    Digit
                found! jump              found_22
                       loc_push

                       call              choice_20

                 fail! value_clear
                   ok! value_leaf        Digit
                       symbol_save       Digit
                       error_nonterminal Digit
                       loc_pop_discard

              found_22:
                   ok! ast_value_push
                       return

              choice_20:
              # /
              #     '0'
              #     '1'
              #     '2'
              #     '3'
              #     '4'
              #     '5'
              #     '6'
              #     '7'
              #     '8'
              #     '9'

                       error_clear

                       loc_push
                       error_push

                       input_next        "t 0"
                   ok! test_char         "0"

                       error_pop_merge
                   ok! jump              oknoast_19

                       loc_pop_rewind
                       loc_push
                       error_push

                       input_next        "t 1"
                   ok! test_char         "1"

                       error_pop_merge
                   ok! jump              oknoast_19

                       loc_pop_rewind
                       loc_push
                       error_push

                       input_next        "t 2"
                   ok! test_char         "2"

                       error_pop_merge
                   ok! jump              oknoast_19

                       loc_pop_rewind
                       loc_push
                       error_push

                       input_next        "t 3"
                   ok! test_char         "3"

                       error_pop_merge
                   ok! jump              oknoast_19

                       loc_pop_rewind
                       loc_push
                       error_push

                       input_next        "t 4"
                   ok! test_char         "4"

                       error_pop_merge
                   ok! jump              oknoast_19

                       loc_pop_rewind
                       loc_push
                       error_push

                       input_next        "t 5"
                   ok! test_char         "5"

                       error_pop_merge
                   ok! jump              oknoast_19

                       loc_pop_rewind
                       loc_push
                       error_push

                       input_next        "t 6"
                   ok! test_char         "6"

                       error_pop_merge
                   ok! jump              oknoast_19

                       loc_pop_rewind
                       loc_push
                       error_push

                       input_next        "t 7"
                   ok! test_char         "7"

                       error_pop_merge
                   ok! jump              oknoast_19

                       loc_pop_rewind
                       loc_push
                       error_push

                       input_next        "t 8"
                   ok! test_char         "8"

                       error_pop_merge
                   ok! jump              oknoast_19

                       loc_pop_rewind
                       loc_push
                       error_push

                       input_next        "t 9"
                   ok! test_char         "9"

                       error_pop_merge
                   ok! jump              oknoast_19

                       loc_pop_rewind
                       status_fail
                       return

              oknoast_19:
                       loc_pop_discard
                       return
              #
              # value Symbol 'Expression'
              #

              sym_Expression:
              # /
              #     x
              #         '\('
              #         (Expression)
              #         '\)'
              #     x
              #         (Factor)
              #         *
              #             x
              #                 (MulOp)
              #                 (Factor)

                       symbol_restore    Expression
                found! jump              found_46
                       loc_push
                       ast_push

                       call              choice_44

                 fail! value_clear
                   ok! value_reduce      Expression
                       symbol_save       Expression
                       error_nonterminal Expression
                       ast_pop_rewind
                       loc_pop_discard

              found_46:
                   ok! ast_value_push
                       return

              choice_44:
              # /
              #     x
              #         '\('
              #         (Expression)
              #         '\)'
              #     x
              #         (Factor)
              #         *
              #             x
              #                 (MulOp)
              #                 (Factor)

                       error_clear

                       ast_push
                       loc_push
                       error_push

                       call              sequence_27

                       error_pop_merge
                   ok! jump              ok_43

                       ast_pop_rewind
                       loc_pop_rewind
                       ast_push
                       loc_push
                       error_push

                       call              sequence_40

                       error_pop_merge
                   ok! jump              ok_43

                       ast_pop_rewind
                       loc_pop_rewind
                       status_fail
                       return

              ok_43:
                       ast_pop_discard
                       loc_pop_discard
                       return

              sequence_27:
              # x
              #     '\('
              #     (Expression)
              #     '\)'

                       loc_push
                       error_clear

                       error_push

                       input_next        "t ("
                   ok! test_char         "("

                       error_pop_merge
                 fail! jump              failednoast_29
                       ast_push
                       error_push

                       call              sym_Expression

                       error_pop_merge
                 fail! jump              failed_28
                       error_push

                       input_next        "t )"
                   ok! test_char         ")"

                       error_pop_merge
                 fail! jump              failed_28

                       ast_pop_discard
                       loc_pop_discard
                       return

              failed_28:
                       ast_pop_rewind

              failednoast_29:
                       loc_pop_rewind
                       return

              sequence_40:
              # x
              #     (Factor)
              #     *
              #         x
              #             (MulOp)
              #             (Factor)

                       ast_push
                       loc_push
                       error_clear

                       error_push

                       call              sym_Factor

                       error_pop_merge
                 fail! jump              failed_41
                       error_push

                       call              kleene_37

                       error_pop_merge
                 fail! jump              failed_41

                       ast_pop_discard
                       loc_pop_discard
                       return

              failed_41:
                       ast_pop_rewind
                       loc_pop_rewind
                       return

              kleene_37:
              # *
              #     x
              #         (MulOp)
              #         (Factor)

                       loc_push
                       error_push

                       call              sequence_34

                       error_pop_merge
                 fail! jump              failed_38
                       loc_pop_discard
                       jump              kleene_37

              failed_38:
                       loc_pop_rewind
                       status_ok
                       return

              sequence_34:
              # x
              #     (MulOp)
              #     (Factor)

                       ast_push
                       loc_push
                       error_clear

                       error_push

                       call              sym_MulOp

                       error_pop_merge
                 fail! jump              failed_35
                       error_push

                       call              sym_Factor

                       error_pop_merge
                 fail! jump              failed_35

                       ast_pop_discard
                       loc_pop_discard
                       return

              failed_35:
                       ast_pop_rewind
                       loc_pop_rewind
                       return
              #
              # value Symbol 'Factor'
              #

              sym_Factor:
              # x
              #     (Term)
              #     *
              #         x
              #             (AddOp)
              #             (Term)

                       symbol_restore    Factor
                found! jump              found_60
                       loc_push
                       ast_push

                       call              sequence_57

                 fail! value_clear
                   ok! value_reduce      Factor
                       symbol_save       Factor
                       error_nonterminal Factor
                       ast_pop_rewind
                       loc_pop_discard

              found_60:
                   ok! ast_value_push
                       return

              sequence_57:
              # x
              #     (Term)
              #     *
              #         x
              #             (AddOp)
              #             (Term)

                       ast_push
                       loc_push
                       error_clear

                       error_push

                       call              sym_Term

                       error_pop_merge
                 fail! jump              failed_58
                       error_push

                       call              kleene_54

                       error_pop_merge
                 fail! jump              failed_58

                       ast_pop_discard
                       loc_pop_discard
                       return

              failed_58:
                       ast_pop_rewind
                       loc_pop_rewind
                       return

              kleene_54:
              # *
              #     x
              #         (AddOp)
              #         (Term)

                       loc_push
                       error_push

                       call              sequence_51

                       error_pop_merge
                 fail! jump              failed_55
                       loc_pop_discard
                       jump              kleene_54

              failed_55:
                       loc_pop_rewind
                       status_ok
                       return

              sequence_51:
              # x
              #     (AddOp)
              #     (Term)

                       ast_push
                       loc_push
                       error_clear

                       error_push

                       call              sym_AddOp

                       error_pop_merge
                 fail! jump              failed_52
                       error_push

                       call              sym_Term

                       error_pop_merge
                 fail! jump              failed_52

                       ast_pop_discard
                       loc_pop_discard
                       return

              failed_52:
                       ast_pop_rewind
                       loc_pop_rewind
                       return
              #
              # value Symbol 'MulOp'
              #

              sym_MulOp:
              # /
              #     '*'
              #     '/'

                       symbol_restore    MulOp
                found! jump              found_67
                       loc_push

                       call              choice_65

                 fail! value_clear
                   ok! value_leaf        MulOp
                       symbol_save       MulOp
                       error_nonterminal MulOp
                       loc_pop_discard

              found_67:
                   ok! ast_value_push
                       return

              choice_65:
              # /
              #     '*'
              #     '/'

                       error_clear

                       loc_push
                       error_push

                       input_next        "t *"
                   ok! test_char         "*"

                       error_pop_merge
                   ok! jump              oknoast_64

                       loc_pop_rewind
                       loc_push
                       error_push

                       input_next        "t /"
                   ok! test_char         "/"

                       error_pop_merge
                   ok! jump              oknoast_64

                       loc_pop_rewind
                       status_fail
                       return

              oknoast_64:
                       loc_pop_discard
                       return
              #
              # value Symbol 'Number'
              #

              sym_Number:
              # x
              #     ?
              #         (Sign)
              #     +
              #         (Digit)

                       symbol_restore    Number
                found! jump              found_80
                       loc_push
                       ast_push

                       call              sequence_77

                 fail! value_clear
                   ok! value_reduce      Number
                       symbol_save       Number
                       error_nonterminal Number
                       ast_pop_rewind
                       loc_pop_discard

              found_80:
                   ok! ast_value_push
                       return

              sequence_77:
              # x
              #     ?
              #         (Sign)
              #     +
              #         (Digit)

                       ast_push
                       loc_push
                       error_clear

                       error_push

                       call              optional_70

                       error_pop_merge
                 fail! jump              failed_78
                       error_push

                       call              poskleene_73

                       error_pop_merge
                 fail! jump              failed_78

                       ast_pop_discard
                       loc_pop_discard
                       return

              failed_78:
                       ast_pop_rewind
                       loc_pop_rewind
                       return

              optional_70:
              # ?
              #     (Sign)

                       loc_push
                       error_push

                       call              sym_Sign

                       error_pop_merge
                 fail! loc_pop_rewind
                   ok! loc_pop_discard
                       status_ok
                       return

              poskleene_73:
              # +
              #     (Digit)

                       loc_push

                       call              sym_Digit

                 fail! jump              failed_74

              loop_75:
                       loc_pop_discard
                       loc_push
                       error_push

                       call              sym_Digit

                       error_pop_merge
                   ok! jump              loop_75
                       status_ok

              failed_74:
                       loc_pop_rewind
                       return
              #
              # value Symbol 'Sign'
              #

              sym_Sign:
              # /
              #     '-'
              #     '+'

                       symbol_restore    Sign
                found! jump              found_86
                       loc_push

                       call              choice_5

                 fail! value_clear
                   ok! value_leaf        Sign
                       symbol_save       Sign
                       error_nonterminal Sign
                       loc_pop_discard

              found_86:
                   ok! ast_value_push
                       return
              #
              # value Symbol 'Term'
              #

              sym_Term:
              # (Number)

                       symbol_restore    Term
                found! jump              found_89
                       loc_push
                       ast_push

                       call              sym_Number

                 fail! value_clear
                   ok! value_reduce      Term
                       symbol_save       Term
                       error_nonterminal Term
                       ast_pop_rewind
                       loc_pop_discard

              found_89:
                   ok! ast_value_push
                       return

              #
              #

</pre><h4><b>PEG</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here we specify the format used by the Parser Tools to serialize Parsing Expression Grammars as immutable
       values for transport, comparison, etc.

       We distinguish between <u>regular</u> and <u>canonical</u> serializations.  While a PEG may have more than one  regular
       serialization only exactly one of them will be <u>canonical</u>.

       regular serialization

              [1]    The serialization of any PEG is a nested Tcl dictionary.

              [2]    This  dictionary  holds a single key, <b>pt::grammar::peg</b>, and its value. This value holds the
                     contents of the grammar.

              [3]    The contents of the grammar are a Tcl dictionary holding the set of nonterminal symbols and
                     the starting expression. The relevant keys and their values are

                     <b>rules</b>  The value is a Tcl dictionary whose keys are the names of  the  nonterminal  symbols
                            known to the grammar.

                            [1]    Each nonterminal symbol may occur only once.

                            [2]    The empty string is not a legal nonterminal symbol.

                            [3]    The  value  for each symbol is a Tcl dictionary itself. The relevant keys and
                                   their values in this dictionary are

                                   <b>is</b>     The value is the serialization of the  parsing  expression  describing
                                          the  symbols  sentennial  structure,  as  specified  in the section <b>PE</b>
                                          <b>serialization</b> <b>format</b>.

                                   <b>mode</b>   The value can be one of three values specifying how  a  parser  should
                                          handle the semantic value produced by the symbol.

                                          <b>value</b>  The  semantic  value  of  the nonterminal symbol is an abstract
                                                 syntax  tree  consisting  of  a  single  node  node   for   the
                                                 nonterminal  itself,  which  has the ASTs of the symbol's right
                                                 hand side as its children.

                                          <b>leaf</b>   The semantic value of the nonterminal  symbol  is  an  abstract
                                                 syntax   tree   consisting  of  a  single  node  node  for  the
                                                 nonterminal, without any children. Any ASTs  generated  by  the
                                                 symbol's right hand side are discarded.

                                          <b>void</b>   The  nonterminal  has  no semantic value. Any ASTs generated by
                                                 the symbol's right hand side are discarded (as well).

                     <b>start</b>  The value is the serialization of the start parsing expression of  the  grammar,  as
                            specified in the section <b>PE</b> <b>serialization</b> <b>format</b>.

              [4]    The  terminal  symbols  of  the grammar are specified implicitly as the set of all terminal
                     symbols used in the start expression and on the RHS of the grammar rules.

       canonical serialization
              The canonical serialization of a grammar has the format as specified in  the  previous  item,  and
              then  additionally  satisfies  the  constraints below, which make it unique among all the possible
              serializations of this grammar.

              [1]    The keys found in all the nested Tcl dictionaries are sorted in ascending dictionary order,
                     as generated by Tcl's builtin command <b>lsort</b> <b>-increasing</b> <b>-dict</b>.

              [2]    The string representation of the value is the canonical representation of a Tcl dictionary.
                     I.e. it does not contain superfluous whitespace.

   <b>EXAMPLE</b>
       Assuming the following PEG for simple mathematical expressions

              PEG calculator (Expression)
                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'       ;
                  Sign       &lt;- '-' / '+'                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- '*' / '/'                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- '+'/'-'                                       ;
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

       then its canonical serialization (except for whitespace) is

              pt::grammar::peg {
                  rules {
                      AddOp      {is {/ {t -} {t +}}                                                                mode value}
                      Digit      {is {/ {t 0} {t 1} {t 2} {t 3} {t 4} {t 5} {t 6} {t 7} {t 8} {t 9}}                mode value}
                      Expression {is {x {n Term} {* {x {n AddOp} {n Term}}}}                                        mode value}
                      Factor     {is {/ {x {t (} {n Expression} {t )}} {n Number}}                                  mode value}
                      MulOp      {is {/ {t *} {t /}}                                                                mode value}
                      Number     {is {x {? {n Sign}} {+ {n Digit}}}                                                 mode value}
                      Sign       {is {/ {t -} {t +}}                                                                mode value}
                      Term       {is {x {n Factor} {* {x {n MulOp} {n Factor}}}}                                    mode value}
                  }
                  start {n Expression}
              }

</pre><h4><b>PE</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here we specify the format used by the Parser Tools to serialize Parsing Expressions as immutable  values
       for transport, comparison, etc.

       We  distinguish  between  <u>regular</u> and <u>canonical</u> serializations.  While a parsing expression may have more
       than one regular serialization only exactly one of them will be <u>canonical</u>.

       Regular serialization

              <b>Atomic</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    The string <b>epsilon</b> is an atomic parsing expression. It matches the empty string.

                     [2]    The string <b>dot</b> is an atomic parsing expression. It matches any character.

                     [3]    The string <b>alnum</b> is an atomic parsing expression. It matches any Unicode alphabet or
                            digit character. This is a custom extension of PEs based on  Tcl's  builtin  command
                            <b>string</b> <b>is</b>.

                     [4]    The  string  <b>alpha</b>  is an atomic parsing expression. It matches any Unicode alphabet
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [5]    The  string  <b>ascii</b> is an atomic parsing expression. It matches any Unicode character
                            below U0080. This is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [6]    The string <b>control</b> is an atomic parsing expression. It matches any  Unicode  control
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [7]    The string <b>digit</b> is an atomic parsing  expression.  It  matches  any  Unicode  digit
                            character. Note that this includes characters outside of the [0..9] range. This is a
                            custom extension of PEs based on Tcl's builtin command <b>string</b> <b>is</b>.

                     [8]    The  string  <b>graph</b>  is an atomic parsing expression. It matches any Unicode printing
                            character, except for space. This is a  custom  extension  of  PEs  based  on  Tcl's
                            builtin command <b>string</b> <b>is</b>.

                     [9]    The  string <b>lower</b> is an atomic parsing expression. It matches any Unicode lower-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [10]   The string <b>print</b> is an atomic parsing expression. It matches  any  Unicode  printing
                            character, including space. This is a custom extension of PEs based on Tcl's builtin
                            command <b>string</b> <b>is</b>.

                     [11]   The string <b>punct</b> is an atomic parsing expression. It matches any Unicode punctuation
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [12]   The string <b>space</b> is an atomic parsing  expression.  It  matches  any  Unicode  space
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [13]   The string <b>upper</b> is an atomic parsing expression. It matches any Unicode  upper-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [14]   The  string  <b>wordchar</b>  is  an atomic parsing expression. It matches any Unicode word
                            character. This is  any  alphanumeric  character  (see  alnum),  and  any  connector
                            punctuation  characters  (e.g.  underscore). This is a custom extension of PEs based
                            on Tcl's builtin command <b>string</b> <b>is</b>.

                     [15]   The string <b>xdigit</b> is an atomic parsing expression. It matches any hexadecimal  digit
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [16]   The string <b>ddigit</b> is an atomic parsing expression.  It  matches  any  decimal  digit
                            character. This is a custom extension of PEs based on Tcl's builtin command <b>regexp</b>.

                     [17]   The  expression  [list t <b>x</b>] is an atomic parsing expression. It matches the terminal
                            string <b>x</b>.

                     [18]   The expression  [list  n  <b>A</b>]  is  an  atomic  parsing  expression.  It  matches  the
                            nonterminal <b>A</b>.

              <b>Combined</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    For  parsing  expressions <b>e1</b>, <b>e2</b>, ... the result of [list / <b>e1</b> <b>e2</b> ... ] is a parsing
                            expression as well.  This is the <u>ordered</u> <u>choice</u>, aka <u>prioritized</u> <u>choice</u>.

                     [2]    For parsing expressions <b>e1</b>, <b>e2</b>, ... the result of [list x <b>e1</b> <b>e2</b> ... ] is  a  parsing
                            expression as well.  This is the <u>sequence</u>.

                     [3]    For a parsing expression <b>e</b> the result of [list * <b>e</b>] is a parsing expression as well.
                            This is the <u>kleene</u> <u>closure</u>, describing zero or more repetitions.

                     [4]    For a parsing expression <b>e</b> the result of [list + <b>e</b>] is a parsing expression as well.
                            This is the <u>positive</u> <u>kleene</u> <u>closure</u>, describing one or more repetitions.

                     [5]    For a parsing expression <b>e</b> the result of [list &amp; <b>e</b>] is a parsing expression as well.
                            This is the <u>and</u> <u>lookahead</u> <u>predicate</u>.

                     [6]    For a parsing expression <b>e</b> the result of [list ! <b>e</b>] is a parsing expression as well.
                            This is the <u>not</u> <u>lookahead</u> <u>predicate</u>.

                     [7]    For a parsing expression <b>e</b> the result of [list ? <b>e</b>] is a parsing expression as well.
                            This is the <u>optional</u> <u>input</u>.

       Canonical serialization
              The  canonical  serialization  of a parsing expression has the format as specified in the previous
              item, and then additionally satisfies the constraints below, which make it unique  among  all  the
              possible serializations of this parsing expression.

              [1]    The  string representation of the value is the canonical representation of a pure Tcl list.
                     I.e. it does not contain superfluous whitespace.

              [2]    Terminals are <u>not</u> encoded as ranges (where start and end of the range are identical).

   <b>EXAMPLE</b>
       Assuming the parsing expression shown on the right-hand side of the rule

                  Expression &lt;- Term (AddOp Term)*

       then its canonical serialization (except for whitespace) is

                  {x {n Term} {* {x {n AddOp} {n Term}}}}

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category <u>pt</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       EBNF, LL(k), PARAM,  PEG,  TDPL,  context-free  languages,  conversion,  expression,  format  conversion,
       grammar, matching, parser, parsing expression, parsing expression grammar, push down automaton, recursive
       descent, serialization, state, top-down parsing languages, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Parsing and Grammars

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 1.1                              <u>pt::peg::to::<a href="../man3tcl/param.3tcl.html">param</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>