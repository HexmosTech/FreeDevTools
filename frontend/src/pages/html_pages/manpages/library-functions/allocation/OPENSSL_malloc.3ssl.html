<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPENSSL_malloc_init, OPENSSL_malloc, OPENSSL_aligned_alloc, OPENSSL_zalloc, OPENSSL_realloc,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       OPENSSL_malloc_init, OPENSSL_malloc, OPENSSL_aligned_alloc, OPENSSL_zalloc, OPENSSL_realloc,
       OPENSSL_free, OPENSSL_clear_realloc, OPENSSL_clear_free, OPENSSL_cleanse, CRYPTO_malloc,
       CRYPTO_aligned_alloc, CRYPTO_zalloc, CRYPTO_realloc, CRYPTO_free, OPENSSL_strdup, OPENSSL_strndup,
       OPENSSL_memdup, OPENSSL_strlcpy, OPENSSL_strlcat, OPENSSL_strtoul, CRYPTO_strdup, CRYPTO_strndup,
       OPENSSL_mem_debug_push, OPENSSL_mem_debug_pop, CRYPTO_mem_debug_push, CRYPTO_mem_debug_pop,
       CRYPTO_clear_realloc, CRYPTO_clear_free, CRYPTO_malloc_fn, CRYPTO_realloc_fn, CRYPTO_free_fn,
       CRYPTO_get_mem_functions, CRYPTO_set_mem_functions, CRYPTO_get_alloc_counts, CRYPTO_set_mem_debug,
       CRYPTO_mem_ctrl, CRYPTO_mem_leaks, CRYPTO_mem_leaks_fp, CRYPTO_mem_leaks_cb, OPENSSL_MALLOC_FAILURES,
       OPENSSL_MALLOC_FD - Memory allocation functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/crypto.h&gt;

        int OPENSSL_malloc_init(void);

        void *OPENSSL_malloc(size_t num);
        void *OPENSSL_aligned_alloc(size_t num, size_t alignment, void **freeptr);
        void *OPENSSL_zalloc(size_t num);
        void *OPENSSL_realloc(void *addr, size_t num);
        void OPENSSL_free(void *addr);
        char *OPENSSL_strdup(const char *str);
        char *OPENSSL_strndup(const char *str, size_t s);
        size_t OPENSSL_strlcat(char *dst, const char *src, size_t size);
        size_t OPENSSL_strlcpy(char *dst, const char *src, size_t size);
        int OPENSSL_strtoul(char *src, char **endptr, int base, unsigned long *num);
        void *OPENSSL_memdup(void *data, size_t s);
        void *OPENSSL_clear_realloc(void *p, size_t old_len, size_t num);
        void OPENSSL_clear_free(void *str, size_t num);
        void OPENSSL_cleanse(void *ptr, size_t len);

        void *CRYPTO_malloc(size_t num, const char *file, int line);
        void *CRYPTO_aligned_alloc(size_t num, size_t align, void **freeptr,
                                   const char *file, int line);
        void *CRYPTO_zalloc(size_t num, const char *file, int line);
        void *CRYPTO_realloc(void *p, size_t num, const char *file, int line);
        void CRYPTO_free(void *str, const char *, int);
        char *CRYPTO_strdup(const char *p, const char *file, int line);
        char *CRYPTO_strndup(const char *p, size_t num, const char *file, int line);
        void *CRYPTO_clear_realloc(void *p, size_t old_len, size_t num,
                                   const char *file, int line);
        void CRYPTO_clear_free(void *str, size_t num, const char *, int);

        typedef void *(*CRYPTO_malloc_fn)(size_t num, const char *file, int line);
        typedef void *(*CRYPTO_realloc_fn)(void *addr, size_t num, const char *file,
                                           int line);
        typedef void (*CRYPTO_free_fn)(void *addr, const char *file, int line);
        void CRYPTO_get_mem_functions(CRYPTO_malloc_fn *malloc_fn,
                                      CRYPTO_realloc_fn *realloc_fn,
                                      CRYPTO_free_fn *free_fn);
        int CRYPTO_set_mem_functions(CRYPTO_malloc_fn malloc_fn,
                                     CRYPTO_realloc_fn realloc_fn,
                                     CRYPTO_free_fn free_fn);

        void CRYPTO_get_alloc_counts(int *mcount, int *rcount, int *fcount);

        env OPENSSL_MALLOC_FAILURES=... &lt;application&gt;
        env OPENSSL_MALLOC_FD=... &lt;application&gt;

       The following functions have been deprecated since OpenSSL 3.0, and can be hidden entirely by defining
       <b>OPENSSL_API_COMPAT</b> with a suitable version value, see <b><a href="../man7/openssl_user_macros.7.html">openssl_user_macros</a></b>(7):

        int CRYPTO_mem_leaks(BIO *b);
        int CRYPTO_mem_leaks_fp(FILE *fp);
        int CRYPTO_mem_leaks_cb(int (*cb)(const char *str, size_t len, void *u),
                                void *u);

        int CRYPTO_set_mem_debug(int onoff);
        int CRYPTO_mem_ctrl(int mode);
        int OPENSSL_mem_debug_push(const char *info);
        int OPENSSL_mem_debug_pop(void);
        int CRYPTO_mem_debug_push(const char *info, const char *file, int line);
        int CRYPTO_mem_debug_pop(void);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       OpenSSL memory allocation is handled by the <b>OPENSSL_xxx</b> API. These are generally macro's that add the
       standard C <b>__FILE__</b> and <b>__LINE__</b> parameters and call a lower-level <b>CRYPTO_xxx</b> API.  Some functions do not
       add those parameters, but exist for consistency.

       <b>OPENSSL_malloc_init()</b> does nothing and does not need to be called. It is included for compatibility with
       older versions of OpenSSL.

       <b>OPENSSL_malloc()</b>, <b>OPENSSL_realloc()</b>, and <b>OPENSSL_free()</b> are like the C <b>malloc()</b>, <b>realloc()</b>, and <b>free()</b>
       functions.  <b>OPENSSL_zalloc()</b> calls <b>memset()</b> to zero the memory before returning.

       <b>OPENSSL_aligned_alloc()</b> operates just as OPENSSL_malloc does, but it allows for the caller to specify an
       alignment value, for instances in which the default alignment of malloc is insufficient for the callers
       needs.  Note, the alignment value must be a power of 2, and the size specified must be a multiple of the
       alignment.  NOTE: The call to <b>OPENSSL_aligned_alloc()</b> accepts a 3rd argument, <u>freeptr</u> which must point to
       a void pointer.  On some platforms, there is no available library call to obtain memory allocations
       greater than what malloc provides.  In this case, OPENSSL_aligned_alloc implements its own alignment
       routine, allocating additional memory and offsetting the returned pointer to be on the requested
       alignment boundary.  In order to safely free allocations made by this method, the caller must return the
       value in the <u>freeptr</u> variable, rather than the returned pointer.

       <b>OPENSSL_clear_realloc()</b> and <b>OPENSSL_clear_free()</b> should be used when the buffer at <b>addr</b> holds sensitive
       information.  The old buffer is filled with zero's by calling <b>OPENSSL_cleanse()</b> before ultimately calling
       <b>OPENSSL_free()</b>. If the argument to <b>OPENSSL_free()</b> is NULL, nothing is done.

       <b>OPENSSL_cleanse()</b> fills <b>ptr</b> of size <b>len</b> with a string of 0's.  Use <b>OPENSSL_cleanse()</b> with care if the
       memory is a mapping of a file.  If the storage controller uses write compression, then it's possible that
       sensitive tail bytes will survive zeroization because the block of zeros will be compressed. If the
       storage controller uses wear leveling, then the old sensitive data will not be overwritten; rather, a
       block of 0's will be written at a new physical location.

       <b>OPENSSL_strdup()</b>, <b>OPENSSL_strndup()</b> and <b>OPENSSL_memdup()</b> are like the equivalent C functions, except that
       memory is allocated by calling the <b>OPENSSL_malloc()</b> and should be released by calling <b>OPENSSL_free()</b>.

       <b>OPENSSL_strlcpy()</b>, <b>OPENSSL_strlcat()</b> and <b>OPENSSL_strnlen()</b> are equivalents of the common C library
       functions and are provided for portability.

       <b>OPENSSL_strtoul()</b> is a wrapper around the POSIX function strtoul, with the same behaviors listed in the
       POSIX documentation, with the additional behavior that it validates the input <u>str</u> and <u>num</u> parameters for
       not being NULL, and confirms that at least a single byte of input has been consumed in the translation,
       returning an error in the event that no bytes were consumed.

       If no allocations have been done, it is possible to "swap out" the default implementations for
       <b>OPENSSL_malloc()</b>, <b>OPENSSL_realloc()</b> and <b>OPENSSL_free()</b> and replace them with alternate versions.
       <b>CRYPTO_get_mem_functions()</b> function fills in the given arguments with the function pointers for the
       current implementations.  With <b>CRYPTO_set_mem_functions()</b>, you can specify a different set of functions.
       If any of <b>malloc_fn</b>, <b>realloc_fn</b>, or <b>free_fn</b> are NULL, then the function is not changed.  While it's
       permitted to swap out only a few and not all the functions with <b>CRYPTO_set_mem_functions()</b>, it's
       recommended to swap them all out at once.

       If the library is built with the "crypto-mdebug" option, then one function, <b>CRYPTO_get_alloc_counts()</b>,
       and two additional environment variables, <b>OPENSSL_MALLOC_FAILURES</b> and <b>OPENSSL_MALLOC_FD</b>, are available.

       The function <b>CRYPTO_get_alloc_counts()</b> fills in the number of times each of <b>CRYPTO_malloc()</b>,
       <b>CRYPTO_realloc()</b>, and <b>CRYPTO_free()</b> have been called, into the values pointed to by <b>mcount</b>, <b>rcount</b>, and
       <b>fcount</b>, respectively.  If a pointer is NULL, then the corresponding count is not stored.

       The variable <b>OPENSSL_MALLOC_FAILURES</b> controls how often allocations should fail.  It is a set of fields
       separated by semicolons, which each field is a count (defaulting to zero) and an optional atsign and
       percentage (defaulting to 100).  If the count is zero, then it lasts forever.  For example, "100;@25" or
       "100@0;0@25" means the first 100 allocations pass, then all other allocations (until the program exits or
       crashes) have a 25% chance of failing. The length of the value of <b>OPENSSL_MALLOC_FAILURES</b> must be 256 or
       fewer characters.

       If the variable <b>OPENSSL_MALLOC_FD</b> is parsed as a positive integer, then it is taken as an open file
       descriptor. This is used in conjunction with <b>OPENSSL_MALLOC_FAILURES</b> described above. For every
       allocation it will log details about how many allocations there have been so far, what percentage chance
       there is for this allocation failing, and whether it has actually failed.  The following example in
       classic shell syntax shows how to use this (will not work on all platforms):

         OPENSSL_MALLOC_FAILURES='200;@10'
         export OPENSSL_MALLOC_FAILURES
         OPENSSL_MALLOC_FD=3
         export OPENSSL_MALLOC_FD
         ...app invocation... 3&gt;/tmp/log$$

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>OPENSSL_malloc_init()</b>, <b>OPENSSL_free()</b>, <b>OPENSSL_clear_free()</b> <b>CRYPTO_free()</b>, <b>CRYPTO_clear_free()</b> and
       <b>CRYPTO_get_mem_functions()</b> return no value.

       <b>OPENSSL_malloc()</b>, <b>OPENSSL_aligned_alloc()</b>, <b>OPENSSL_zalloc()</b>, <b>OPENSSL_realloc()</b>, <b>OPENSSL_clear_realloc()</b>,
       <b>CRYPTO_malloc()</b>, <b>CRYPTO_zalloc()</b>, <b>CRYPTO_realloc()</b>, <b>CRYPTO_clear_realloc()</b>, <b>OPENSSL_strdup()</b>, and
       <b>OPENSSL_strndup()</b> return a pointer to allocated memory or NULL on error.

       <b>CRYPTO_set_mem_functions()</b> returns 1 on success or 0 on failure (almost always because allocations have
       already happened).

       <b>CRYPTO_mem_leaks()</b>, <b>CRYPTO_mem_leaks_fp()</b>, <b>CRYPTO_mem_leaks_cb()</b>, <b>CRYPTO_set_mem_debug()</b>, and
       <b>CRYPTO_mem_ctrl()</b> are deprecated and are no-ops that always return -1.  <b>OPENSSL_mem_debug_push()</b>,
       <b>OPENSSL_mem_debug_pop()</b>, <b>CRYPTO_mem_debug_push()</b>, and <b>CRYPTO_mem_debug_pop()</b> are deprecated and are no-
       ops that always return 0.

       <b>OPENSSL_strtoul()</b> returns 1 on success and 0 in the event that an error has occurred. Specifically, 0 is
       returned in the following events:

       •   If the underlying call to strtoul returned a non zero errno value

       •   If the translation did not consume the entire input string, and the passed endptr value was NULL

       •   If no characters were consumed in the translation

       Note  that  a  success  condition  does  not imply that the expected translation has been performed.  For
       instance calling

           OPENSSL_strtoul("0x12345", &amp;endptr, 10, &amp;num);

       will result in a successful translation with num having the value 0, and  *endptr  =  'x'.   Be  sure  to
       validate how much data was consumed when calling this function.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>OPENSSL_mem_debug_push()</b>,   <b>OPENSSL_mem_debug_pop()</b>,   <b>CRYPTO_mem_debug_push()</b>,   <b>CRYPTO_mem_debug_pop()</b>,
       <b>CRYPTO_mem_leaks()</b>,      <b>CRYPTO_mem_leaks_fp()</b>,      <b>CRYPTO_mem_leaks_cb()</b>,       <b>CRYPTO_set_mem_debug()</b>,
       <b>CRYPTO_mem_ctrl()</b>  were  deprecated  in  OpenSSL  3.0.   The  memory-leak checking has been deprecated in
       OpenSSL   3.0   in   favor   of   clang's   memory   and   leak   sanitizer.     <b>OPENSSL_aligned_alloc()</b>,
       <b>CRYPTO_aligned_alloc()</b>, <b>OPENSSL_strtoul()</b> were added in OpenSSL 3.4.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2016-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed  under  the  Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain  a  copy  in  the  file  LICENSE  in  the  source  distribution  or  at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                               <u><a href="../man3SSL/OPENSSL_MALLOC.3SSL.html">OPENSSL_MALLOC</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>