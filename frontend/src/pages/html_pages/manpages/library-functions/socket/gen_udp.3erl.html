<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gen_udp - Interface to UDP sockets.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gen_udp - Interface to UDP sockets.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides functions for communicating with sockets using the UDP protocol.

   <b>Note:</b>
       Functions  that  create  sockets can take an optional option; <u>{inet_backend,</u> <u>Backend}</u> that, if specified,
       has to be the first option. This selects the implementation backend towards the platform's socket API.

       This is a <u>temporary</u> option that will be ignored in a future release.

       The default is <u>Backend</u> <u>=</u> <u>inet</u> that selects the traditional <u>inet_drv.c</u> driver. The other choice is <u>Backend</u>
       <u>=</u> <u>socket</u> that selects the new <u>socket</u> module and its NIF implementation.

       The system default can be changed when the node is started with the  application  <u>kernel</u>'s  configuration
       variable <u>inet_backend</u>.

       For  <u>gen_udp</u>  with  <u>inet_backend</u>  <u>=</u>  <u>socket</u>  we  have  tried  to be as "compatible" as possible which has
       sometimes been impossible. Here is a list of cases when the behaviour of inet-backend <u>inet</u> (default)  and
       <u>socket</u> are different:

         * The option read_packets is currently <u>ignored</u>.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>option()</b> =
           {active, true | false | once | -32768..32767} |
           {add_membership, {inet:ip_address(), inet:ip_address()}} |
           {broadcast, boolean()} |
           {buffer, integer() &gt;= 0} |
           {deliver, port | term} |
           {dontroute, boolean()} |
           {drop_membership, {inet:ip_address(), inet:ip_address()}} |
           {header, integer() &gt;= 0} |
           {high_msgq_watermark, integer() &gt;= 1} |
           {low_msgq_watermark, integer() &gt;= 1} |
           {mode, list | binary} |
           list | binary |
           {multicast_if, inet:ip_address()} |
           {multicast_loop, boolean()} |
           {multicast_ttl, integer() &gt;= 0} |
           {priority, integer() &gt;= 0} |
           {raw,
            Protocol :: integer() &gt;= 0,
            OptionNum :: integer() &gt;= 0,
            ValueBin :: binary()} |
           {read_packets, integer() &gt;= 0} |
           {recbuf, integer() &gt;= 0} |
           {reuseaddr, boolean()} |
           {sndbuf, integer() &gt;= 0} |
           {tos, integer() &gt;= 0} |
           {tclass, integer() &gt;= 0} |
           {ttl, integer() &gt;= 0} |
           {recvtos, boolean()} |
           {recvtclass, boolean()} |
           {recvttl, boolean()} |
           {ipv6_v6only, boolean()}

       <b>option_name()</b> =
           active | broadcast | buffer | deliver | dontroute | header |
           high_msgq_watermark | low_msgq_watermark | mode |
           multicast_if | multicast_loop | multicast_ttl | priority |
           {raw,
            Protocol :: integer() &gt;= 0,
            OptionNum :: integer() &gt;= 0,
            ValueSpec ::
                (ValueSize :: integer() &gt;= 0) | (ValueBin :: binary())} |
           read_packets | recbuf | reuseaddr | sndbuf | tos | tclass |
           ttl | recvtos | recvtclass | recvttl | pktoptions |
           ipv6_v6only

       <b>open_option()</b> =
           {ip, inet:socket_address()} |
           {fd, integer() &gt;= 0} |
           {ifaddr, inet:socket_address()} |
           inet:address_family() |
           {port, inet:port_number()} |
           {netns, file:filename_all()} |
           {bind_to_device, binary()} |
           option()

       <b>socket()</b>

              As returned by <u>open/1,2</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>close(Socket)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Socket = socket()

              Closes a UDP socket.

       <b>controlling_process(Socket,</b> <b>Pid)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Socket = socket()
                 Pid = pid()
                 Reason = closed | not_owner | badarg | inet:posix()

              Assigns  a  new  controlling  process  <u>Pid</u>  to <u>Socket</u>. The controlling process is the process that
              receives messages from the socket. If called by any other process  than  the  current  controlling
              process, <u>{error,</u> <u>not_owner}</u> is returned. If the process identified by <u>Pid</u> is not an existing local
              pid,  <u>{error,</u>  <u>badarg}</u> is returned. <u>{error,</u> <u>badarg}</u> may also be returned in some cases when <u>Socket</u>
              is closed during the execution of this function.

       <b>open(Port)</b> <b>-&gt;</b> <b>{ok,</b> <b>Socket}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>open(Port,</b> <b>Opts)</b> <b>-&gt;</b> <b>{ok,</b> <b>Socket}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Port = inet:port_number()
                 Opts = [inet:inet_backend() | open_option()]
                 Socket = socket()
                 Reason = system_limit | inet:posix()

              Associates a UDP port number (<u>Port</u>) with the calling process.

              The following options are available:

                <u>list</u>:
                  Received <u>Packet</u> is delivered as a list.

                <u>binary</u>:
                  Received <u>Packet</u> is delivered as a binary.

                <u>{ip,</u> <u>Address}</u>:
                  If the host has many network interfaces, this option specifies which one to use.

                <u>{ifaddr,</u> <u>Address}</u>:
                  Same as <u>{ip,</u> <u>Address}</u>. If the host has many network interfaces, this  option  specifies  which
                  one to use.

                <u>{fd,</u> <u>integer()</u> <u>&gt;=</u> <u>0}</u>:
                  If  a  socket  has somehow been opened without using <u>gen_udp</u>, use this option to pass the file
                  descriptor for it. If <u>Port</u> is not set to <u>0</u> and/or <u>{ip,</u> <u>ip_address()}</u>  is  combined  with  this
                  option, the <u>fd</u> is bound to the specified interface and port after it is being opened. If these
                  options are not specified, it is assumed that the <u>fd</u> is already bound appropriately.

                <u>inet6</u>:
                  Sets up the socket for IPv6.

                <u>inet</u>:
                  Sets up the socket for IPv4.

                <u>local</u>:
                  Sets up a Unix Domain Socket. See <u>inet:local_address()</u>

                <u>{udp_module,</u> <u>module()}</u>:
                  Overrides which callback module is used. Defaults to <u>inet_udp</u> for IPv4 and <u>inet6_udp</u> for IPv6.

                <u>{multicast_if,</u> <u>Address}</u>:
                  Sets the local device for a multicast socket.

                <u>{multicast_loop,</u> <u>true</u> <u>|</u> <u>false}</u>:
                  When <u>true</u>, sent multicast packets are looped back to the local sockets.

                <u>{multicast_ttl,</u> <u>Integer}</u>:
                  Option  <u>multicast_ttl</u>  changes  the  time-to-live  (TTL)  for  outgoing multicast datagrams to
                  control the scope of the multicasts.

                  Datagrams with a TTL of 1 are not forwarded beyond the local network. Defaults to <u>1</u>.

                <u>{add_membership,</u> <u>{MultiAddress,</u> <u>InterfaceAddress}}</u>:
                  Joins a multicast group.

                <u>{drop_membership,</u> <u>{MultiAddress,</u> <u>InterfaceAddress}}</u>:
                  Leaves a multicast group.

                <u>Opt</u>:
                  See <u>inet:setopts/2</u>.

              The returned socket <u>Socket</u> is used to send packets from this port with <u>send/4</u>.  When  UDP  packets
              arrive  at  the  opened  port,  if  the  socket is in an active mode, the packets are delivered as
              messages to the controlling process:

              {udp, Socket, IP, InPortNo, Packet} % Without ancillary data
              {udp, Socket, IP, InPortNo, AncData, Packet} % With ancillary data

              The message contains an <u>AncData</u> field if any of the socket options <u>recvtos</u>, <u>recvtclass</u> or  <u>recvttl</u>
              are active, otherwise it does not.

              If  the  socket is not in an active mode, data can be retrieved through the <u>recv/2,3</u> calls. Notice
              that arriving UDP packets that are  longer  than  the  receive  buffer  option  specifies  can  be
              truncated without warning.

              When  a  socket  in  <u>{active,</u>  <u>N}</u>  mode  (see  <u>inet:setopts/2</u> for details), transitions to passive
              (<u>{active,</u> <u>false}</u>) mode, the controlling process is notified by a message of the following form:

              {udp_passive, Socket}

              <u>IP</u> and <u>InPortNo</u> define the address from which <u>Packet</u> comes. <u>Packet</u> is a list of  bytes  if  option
              <u>list</u> is specified. <u>Packet</u> is a binary if option <u>binary</u> is specified.

              Default value for the receive buffer option is <u>{recbuf,</u> <u>8192}</u>.

              If <u>Port</u> <u>==</u> <u>0</u>, the underlying OS assigns a free UDP port, use <u>inet:port/1</u> to retrieve it.

       <b>recv(Socket,</b> <b>Length)</b> <b>-&gt;</b> <b>{ok,</b> <b>RecvData}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>recv(Socket,</b> <b>Length,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{ok,</b> <b>RecvData}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Socket = socket()
                 Length = integer() &gt;= 0
                 Timeout = timeout()
                 RecvData =
                     {Address, Port, Packet} | {Address, Port, AncData, Packet}
                 Address = inet:ip_address() | inet:returned_non_ip_address()
                 Port = inet:port_number()
                 AncData = inet:ancillary_data()
                 Packet = string() | binary()
                 Reason = not_owner | timeout | inet:posix()

              Receives  a  packet from a socket in passive mode. Optional parameter <u>Timeout</u> specifies a time-out
              in milliseconds. Defaults to <u>infinity</u>.

              If any of the socket options <u>recvtos</u>,  <u>recvtclass</u>  or  <u>recvttl</u>  are  active,  the  <u>RecvData</u>  tuple
              contains an <u>AncData</u> field, otherwise it does not.

       <b>send(Socket,</b> <b>Destination,</b> <b>Packet)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Socket = socket()
                 Destination =
                     {inet:ip_address(), inet:port_number()} |
                     inet:family_address()
                 Packet = iodata()
                 Reason = not_owner | inet:posix()

              Sends a packet to the specified <u>Destination</u>.

              This function is equivalent to <u>send(Socket,</u> <u>Destination,</u> <u>[],</u> <u>Packet)</u>.

       <b>send(Socket,</b> <b>Host,</b> <b>Port,</b> <b>Packet)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Socket = socket()
                 Host = inet:hostname() | inet:ip_address()
                 Port = inet:port_number() | atom()
                 Packet = iodata()
                 Reason = not_owner | inet:posix()

              Sends a packet to the specified <u>Host</u> and <u>Port</u>.

              This clause is equivalent to <u>send(Socket,</u> <u>Host,</u> <u>Port,</u> <u>[],</u> <u>Packet)</u>.

       <b>send(Socket,</b> <b>Destination,</b> <b>AncData,</b> <b>Packet)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Socket = socket()
                 Destination =
                     {inet:ip_address(), inet:port_number()} |
                     inet:family_address()
                 AncData = inet:ancillary_data()
                 Packet = iodata()
                 Reason = not_owner | inet:posix()

              Sends a packet to the specified <u>Destination</u> with ancillary data <u>AncData</u>.

          <b>Note:</b>
              The  ancillary  data  <u>AncData</u>  contains  options that for this single message override the default
              options for the socket, an operation that may not be supported on all platforms, and if so  return
              <u>{error,</u>  <u>einval}</u>.  Using  more  than one of an ancillary data item type may also not be supported.
              <u>AncData</u> <u>=:=</u> <u>[]</u> is always supported.

       <b>send(Socket,</b> <b>Destination,</b> <b>PortZero,</b> <b>Packet)</b> <b>-&gt;</b>
               ok | {error, Reason}

              Types:

                 Socket = socket()
                 Destination =
                     {inet:ip_address(), inet:port_number()} |
                     inet:family_address()
                 PortZero = inet:port_number()
                 Packet = iodata()
                 Reason = not_owner | inet:posix()

              Sends a packet to the specified <u>Destination</u>. Since <u>Destination</u> is complete, <u>PortZero</u> is  redundant
              and has to be <u>0</u>.

              This is a legacy clause mostly for <u>Destination</u> <u>=</u> <u>{local,</u> <u>Binary}</u> where <u>PortZero</u> is superfluous. It
              is equivalent to <u>send(Socket,</u> <u>Destination,</u> <u>[],</u> <u>Packet)</u>, the clause right above here.

       <b>send(Socket,</b> <b>Host,</b> <b>Port,</b> <b>AncData,</b> <b>Packet)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Socket = socket()
                 Host =
                     inet:hostname() | inet:ip_address() | inet:local_address()
                 Port = inet:port_number() | atom()
                 AncData = inet:ancillary_data()
                 Packet = iodata()
                 Reason = not_owner | inet:posix()

              Sends a packet to the specified <u>Host</u> and <u>Port</u>, with ancillary data <u>AncData</u>.

              Argument  <u>Host</u>  can  be a hostname or a socket address, and <u>Port</u> can be a port number or a service
              name atom. These are resolved into a <u>Destination</u> and after that this  function  is  equivalent  to
              <u>send(Socket,</u> <u>Destination,</u> <u>AncData,</u> <u>Packet)</u>, read there about ancillary data.

Ericsson AB                                        kernel 8.2                                      <u><a href="../man3erl/gen_udp.3erl.html">gen_udp</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>