<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zsock - Class for high-level socket API that hides libzmq contexts and sockets</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libczmq-dev">libczmq-dev_4.2.1-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       zsock - Class for high-level socket API that hides libzmq contexts and sockets

</pre><h4><b>SYNOPSIS</b></h4><pre>
       //  This is a stable class, and may not change except for emergencies. It
       //  is provided in stable builds.
       //  This class has draft methods, which may change over time. They are not
       //  in stable releases, by default. Use --enable-drafts to enable.
       //  Create a new socket. Returns the new socket, or NULL if the new socket
       //  could not be created. Note that the symbol zsock_new (and other
       //  constructors/destructors for zsock) are redirected to the *_checked
       //  variant, enabling intelligent socket leak detection. This can have
       //  performance implications if you use a LOT of sockets. To turn off this
       //  redirection behaviour, define ZSOCK_NOCHECK.
       CZMQ_EXPORT zsock_t *
           zsock_new (int type);

       //  Create a PUB socket. Default action is bind.
       CZMQ_EXPORT zsock_t *
           zsock_new_pub (const char *endpoint);

       //  Create a SUB socket, and optionally subscribe to some prefix string. Default
       //  action is connect.
       CZMQ_EXPORT zsock_t *
           zsock_new_sub (const char *endpoint, const char *subscribe);

       //  Create a REQ socket. Default action is connect.
       CZMQ_EXPORT zsock_t *
           zsock_new_req (const char *endpoint);

       //  Create a REP socket. Default action is bind.
       CZMQ_EXPORT zsock_t *
           zsock_new_rep (const char *endpoint);

       //  Create a DEALER socket. Default action is connect.
       CZMQ_EXPORT zsock_t *
           zsock_new_dealer (const char *endpoint);

       //  Create a ROUTER socket. Default action is bind.
       CZMQ_EXPORT zsock_t *
           zsock_new_router (const char *endpoint);

       //  Create a PUSH socket. Default action is connect.
       CZMQ_EXPORT zsock_t *
           zsock_new_push (const char *endpoint);

       //  Create a PULL socket. Default action is bind.
       CZMQ_EXPORT zsock_t *
           zsock_new_pull (const char *endpoint);

       //  Create an XPUB socket. Default action is bind.
       CZMQ_EXPORT zsock_t *
           zsock_new_xpub (const char *endpoint);

       //  Create an XSUB socket. Default action is connect.
       CZMQ_EXPORT zsock_t *
           zsock_new_xsub (const char *endpoint);

       //  Create a PAIR socket. Default action is connect.
       CZMQ_EXPORT zsock_t *
           zsock_new_pair (const char *endpoint);

       //  Create a STREAM socket. Default action is connect.
       CZMQ_EXPORT zsock_t *
           zsock_new_stream (const char *endpoint);

       //  Destroy the socket. You must use this for any socket created via the
       //  zsock_new method.
       CZMQ_EXPORT void
           zsock_destroy (zsock_t **self_p);

       //  Bind a socket to a formatted endpoint. For tcp:// endpoints, supports
       //  ephemeral ports, if you specify the port number as "*". By default
       //  zsock uses the IANA designated range from C000 (49152) to FFFF (65535).
       //  To override this range, follow the "*" with "[first-last]". Either or
       //  both first and last may be empty. To bind to a random port within the
       //  range, use "!" in place of "*".
       //
       //  Examples:
       //      tcp://127.0.0.1:*           bind to first free port from C000 up
       //      tcp://127.0.0.1:!           bind to random port from C000 to FFFF
       //      tcp://127.0.0.1:*[60000-]   bind to first free port from 60000 up
       //      tcp://127.0.0.1:![-60000]   bind to random port from C000 to 60000
       //      tcp://127.0.0.1:![55000-55999]
       //                                  bind to random port from 55000 to 55999
       //
       //  On success, returns the actual port number used, for tcp:// endpoints,
       //  and 0 for other transports. On failure, returns -1. Note that when using
       //  ephemeral ports, a port may be reused by different services without
       //  clients being aware. Protocols that run on ephemeral ports should take
       //  this into account.
       CZMQ_EXPORT int
           zsock_bind (zsock_t *self, const char *format, ...) CHECK_PRINTF (2);

       //  Returns last bound endpoint, if any.
       CZMQ_EXPORT const char *
           zsock_endpoint (zsock_t *self);

       //  Unbind a socket from a formatted endpoint.
       //  Returns 0 if OK, -1 if the endpoint was invalid or the function
       //  isn't supported.
       CZMQ_EXPORT int
           zsock_unbind (zsock_t *self, const char *format, ...) CHECK_PRINTF (2);

       //  Connect a socket to a formatted endpoint
       //  Returns 0 if OK, -1 if the endpoint was invalid.
       CZMQ_EXPORT int
           zsock_connect (zsock_t *self, const char *format, ...) CHECK_PRINTF (2);

       //  Disconnect a socket from a formatted endpoint
       //  Returns 0 if OK, -1 if the endpoint was invalid or the function
       //  isn't supported.
       CZMQ_EXPORT int
           zsock_disconnect (zsock_t *self, const char *format, ...) CHECK_PRINTF (2);

       //  Attach a socket to zero or more endpoints. If endpoints is not null,
       //  parses as list of ZeroMQ endpoints, separated by commas, and prefixed by
       //  '@' (to bind the socket) or '&gt;' (to connect the socket). Returns 0 if all
       //  endpoints were valid, or -1 if there was a syntax error. If the endpoint
       //  does not start with '@' or '&gt;', the serverish argument defines whether
       //  it is used to bind (serverish = true) or connect (serverish = false).
       CZMQ_EXPORT int
           zsock_attach (zsock_t *self, const char *endpoints, bool serverish);

       //  Returns socket type as printable constant string.
       CZMQ_EXPORT const char *
           zsock_type_str (zsock_t *self);

       //  Send a 'picture' message to the socket (or actor). The picture is a
       //  string that defines the type of each frame. This makes it easy to send
       //  a complex multiframe message in one call. The picture can contain any
       //  of these characters, each corresponding to one or two arguments:
       //
       //      i = int (signed)
       //      1 = uint8_t
       //      2 = uint16_t
       //      4 = uint32_t
       //      8 = uint64_t
       //      s = char *
       //      b = byte *, size_t (2 arguments)
       //      c = zchunk_t *
       //      f = zframe_t *
       //      h = zhashx_t *
       //      l = zlistx_t * (DRAFT)
       //      U = zuuid_t *
       //      p = void * (sends the pointer value, only meaningful over inproc)
       //      m = zmsg_t * (sends all frames in the zmsg)
       //      z = sends zero-sized frame (0 arguments)
       //      u = uint (deprecated)
       //
       //  Note that s, b, c, and f are encoded the same way and the choice is
       //  offered as a convenience to the sender, which may or may not already
       //  have data in a zchunk or zframe. Does not change or take ownership of
       //  any arguments. Returns 0 if successful, -1 if sending failed for any
       //  reason.
       CZMQ_EXPORT int
           zsock_send (void *self, const char *picture, ...);

       //  Send a 'picture' message to the socket (or actor). This is a va_list
       //  version of zsock_send (), so please consult its documentation for the
       //  details.
       CZMQ_EXPORT int
           zsock_vsend (void *self, const char *picture, va_list argptr);

       //  Receive a 'picture' message to the socket (or actor). See zsock_send for
       //  the format and meaning of the picture. Returns the picture elements into
       //  a series of pointers as provided by the caller:
       //
       //      i = int * (stores signed integer)
       //      4 = uint32_t * (stores 32-bit unsigned integer)
       //      8 = uint64_t * (stores 64-bit unsigned integer)
       //      s = char ** (allocates new string)
       //      b = byte **, size_t * (2 arguments) (allocates memory)
       //      c = zchunk_t ** (creates zchunk)
       //      f = zframe_t ** (creates zframe)
       //      U = zuuid_t * (creates a zuuid with the data)
       //      h = zhashx_t ** (creates zhashx)
       //      l = zlistx_t ** (creates zlistx) (DRAFT)
       //      p = void ** (stores pointer)
       //      m = zmsg_t ** (creates a zmsg with the remaining frames)
       //      z = null, asserts empty frame (0 arguments)
       //      u = uint * (stores unsigned integer, deprecated)
       //
       //  Note that zsock_recv creates the returned objects, and the caller must
       //  destroy them when finished with them. The supplied pointers do not need
       //  to be initialized. Returns 0 if successful, or -1 if it failed to recv
       //  a message, in which case the pointers are not modified. When message
       //  frames are truncated (a short message), sets return values to zero/null.
       //  If an argument pointer is NULL, does not store any value (skips it).
       //  An 'n' picture matches an empty frame; if the message does not match,
       //  the method will return -1.
       CZMQ_EXPORT int
           zsock_recv (void *self, const char *picture, ...);

       //  Receive a 'picture' message from the socket (or actor). This is a
       //  va_list version of zsock_recv (), so please consult its documentation
       //  for the details.
       CZMQ_EXPORT int
           zsock_vrecv (void *self, const char *picture, va_list argptr);

       //  Send a binary encoded 'picture' message to the socket (or actor). This
       //  method is similar to zsock_send, except the arguments are encoded in a
       //  binary format that is compatible with zproto, and is designed to reduce
       //  memory allocations. The pattern argument is a string that defines the
       //  type of each argument. Supports these argument types:
       //
       //   pattern    C type                  zproto type:
       //      1       uint8_t                 type = "number" size = "1"
       //      2       uint16_t                type = "number" size = "2"
       //      4       uint32_t                type = "number" size = "3"
       //      8       uint64_t                type = "number" size = "4"
       //      s       char *, 0-255 chars     type = "string"
       //      S       char *, 0-2^32-1 chars  type = "longstr"
       //      c       zchunk_t *              type = "chunk"
       //      f       zframe_t *              type = "frame"
       //      u       zuuid_t *               type = "uuid"
       //      m       zmsg_t *                type = "msg"
       //      p       void *, sends pointer value, only over inproc
       //
       //  Does not change or take ownership of any arguments. Returns 0 if
       //  successful, -1 if sending failed for any reason.
       CZMQ_EXPORT int
           zsock_bsend (void *self, const char *picture, ...);

       //  Receive a binary encoded 'picture' message from the socket (or actor).
       //  This method is similar to zsock_recv, except the arguments are encoded
       //  in a binary format that is compatible with zproto, and is designed to
       //  reduce memory allocations. The pattern argument is a string that defines
       //  the type of each argument. See zsock_bsend for the supported argument
       //  types. All arguments must be pointers; this call sets them to point to
       //  values held on a per-socket basis.
       //  For types 1, 2, 4 and 8 the caller must allocate the memory itself before
       //  calling zsock_brecv.
       //  For types S, the caller must free the value once finished with it, as
       //  zsock_brecv will allocate the buffer.
       //  For type s, the caller must not free the value as it is stored in a
       //  local cache for performance purposes.
       //  For types c, f, u and m the caller must call the appropriate destructor
       //  depending on the object as zsock_brecv will create new objects.
       //  For type p the caller must coordinate with the sender, as it is just a
       //  pointer value being passed.
       CZMQ_EXPORT int
           zsock_brecv (void *self, const char *picture, ...);

       //  Set socket to use unbounded pipes (HWM=0); use this in cases when you are
       //  totally certain the message volume can fit in memory. This method works
       //  across all versions of ZeroMQ. Takes a polymorphic socket reference.
       CZMQ_EXPORT void
           zsock_set_unbounded (void *self);

       //  Send a signal over a socket. A signal is a short message carrying a
       //  success/failure code (by convention, 0 means OK). Signals are encoded
       //  to be distinguishable from "normal" messages. Accepts a zsock_t or a
       //  zactor_t argument, and returns 0 if successful, -1 if the signal could
       //  not be sent. Takes a polymorphic socket reference.
       CZMQ_EXPORT int
           zsock_signal (void *self, byte status);

       //  Wait on a signal. Use this to coordinate between threads, over pipe
       //  pairs. Blocks until the signal is received. Returns -1 on error, 0 or
       //  greater on success. Accepts a zsock_t or a zactor_t as argument.
       //  Takes a polymorphic socket reference.
       CZMQ_EXPORT int
           zsock_wait (void *self);

       //  If there is a partial message still waiting on the socket, remove and
       //  discard it. This is useful when reading partial messages, to get specific
       //  message types.
       CZMQ_EXPORT void
           zsock_flush (void *self);

       //  Probe the supplied object, and report if it looks like a zsock_t.
       //  Takes a polymorphic socket reference.
       CZMQ_EXPORT bool
           zsock_is (void *self);

       //  Probe the supplied reference. If it looks like a zsock_t instance, return
       //  the underlying libzmq socket handle; else if it looks like a file
       //  descriptor, return NULL; else if it looks like a libzmq socket handle,
       //  return the supplied value. Takes a polymorphic socket reference.
       CZMQ_EXPORT void *
           zsock_resolve (void *self);

       //  Get socket option `priority`.
       //  Available from libzmq 4.3.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_priority (void *self);

       //  Set socket option `priority`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_priority (void *self, int priority);

       //  Get socket option `reconnect_stop`.
       //  Available from libzmq 4.3.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_reconnect_stop (void *self);

       //  Set socket option `reconnect_stop`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_reconnect_stop (void *self, int reconnect_stop);

       //  Set socket option `only_first_subscribe`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_only_first_subscribe (void *self, int only_first_subscribe);

       //  Set socket option `hello_msg`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_hello_msg (void *self, zframe_t *hello_msg);

       //  Set socket option `disconnect_msg`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_disconnect_msg (void *self, zframe_t *disconnect_msg);

       //  Set socket option `wss_trust_system`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_wss_trust_system (void *self, int wss_trust_system);

       //  Set socket option `wss_hostname`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_wss_hostname (void *self, const char *wss_hostname);

       //  Set socket option `wss_trust_pem`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_wss_trust_pem (void *self, const char *wss_trust_pem);

       //  Set socket option `wss_cert_pem`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_wss_cert_pem (void *self, const char *wss_cert_pem);

       //  Set socket option `wss_key_pem`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_wss_key_pem (void *self, const char *wss_key_pem);

       //  Get socket option `out_batch_size`.
       //  Available from libzmq 4.3.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_out_batch_size (void *self);

       //  Set socket option `out_batch_size`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_out_batch_size (void *self, int out_batch_size);

       //  Get socket option `in_batch_size`.
       //  Available from libzmq 4.3.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_in_batch_size (void *self);

       //  Set socket option `in_batch_size`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_in_batch_size (void *self, int in_batch_size);

       //  Get socket option `socks_password`.
       //  Available from libzmq 4.3.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_socks_password (void *self);

       //  Set socket option `socks_password`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_socks_password (void *self, const char *socks_password);

       //  Get socket option `socks_username`.
       //  Available from libzmq 4.3.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_socks_username (void *self);

       //  Set socket option `socks_username`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_socks_username (void *self, const char *socks_username);

       //  Set socket option `xpub_manual_last_value`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_xpub_manual_last_value (void *self, int xpub_manual_last_value);

       //  Get socket option `router_notify`.
       //  Available from libzmq 4.3.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_router_notify (void *self);

       //  Set socket option `router_notify`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_router_notify (void *self, int router_notify);

       //  Get socket option `multicast_loop`.
       //  Available from libzmq 4.3.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_multicast_loop (void *self);

       //  Set socket option `multicast_loop`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_multicast_loop (void *self, int multicast_loop);

       //  Get socket option `metadata`.
       //  Available from libzmq 4.3.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_metadata (void *self);

       //  Set socket option `metadata`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_metadata (void *self, const char *metadata);

       //  Get socket option `loopback_fastpath`.
       //  Available from libzmq 4.3.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_loopback_fastpath (void *self);

       //  Set socket option `loopback_fastpath`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_loopback_fastpath (void *self, int loopback_fastpath);

       //  Get socket option `zap_enforce_domain`.
       //  Available from libzmq 4.3.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_zap_enforce_domain (void *self);

       //  Set socket option `zap_enforce_domain`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_zap_enforce_domain (void *self, int zap_enforce_domain);

       //  Get socket option `gssapi_principal_nametype`.
       //  Available from libzmq 4.3.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_gssapi_principal_nametype (void *self);

       //  Set socket option `gssapi_principal_nametype`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_gssapi_principal_nametype (void *self, int gssapi_principal_nametype);

       //  Get socket option `gssapi_service_principal_nametype`.
       //  Available from libzmq 4.3.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_gssapi_service_principal_nametype (void *self);

       //  Set socket option `gssapi_service_principal_nametype`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_gssapi_service_principal_nametype (void *self, int gssapi_service_principal_nametype);

       //  Get socket option `bindtodevice`.
       //  Available from libzmq 4.3.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_bindtodevice (void *self);

       //  Set socket option `bindtodevice`.
       //  Available from libzmq 4.3.0.
       CZMQ_EXPORT void
           zsock_set_bindtodevice (void *self, const char *bindtodevice);

       //  Get socket option `heartbeat_ivl`.
       //  Available from libzmq 4.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_heartbeat_ivl (void *self);

       //  Set socket option `heartbeat_ivl`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_heartbeat_ivl (void *self, int heartbeat_ivl);

       //  Get socket option `heartbeat_ttl`.
       //  Available from libzmq 4.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_heartbeat_ttl (void *self);

       //  Set socket option `heartbeat_ttl`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_heartbeat_ttl (void *self, int heartbeat_ttl);

       //  Get socket option `heartbeat_timeout`.
       //  Available from libzmq 4.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_heartbeat_timeout (void *self);

       //  Set socket option `heartbeat_timeout`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_heartbeat_timeout (void *self, int heartbeat_timeout);

       //  Get socket option `use_fd`.
       //  Available from libzmq 4.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_use_fd (void *self);

       //  Set socket option `use_fd`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_use_fd (void *self, int use_fd);

       //  Set socket option `xpub_manual`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_xpub_manual (void *self, int xpub_manual);

       //  Set socket option `xpub_welcome_msg`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_xpub_welcome_msg (void *self, const char *xpub_welcome_msg);

       //  Set socket option `stream_notify`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_stream_notify (void *self, int stream_notify);

       //  Get socket option `invert_matching`.
       //  Available from libzmq 4.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_invert_matching (void *self);

       //  Set socket option `invert_matching`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_invert_matching (void *self, int invert_matching);

       //  Set socket option `xpub_verboser`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_xpub_verboser (void *self, int xpub_verboser);

       //  Get socket option `connect_timeout`.
       //  Available from libzmq 4.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_connect_timeout (void *self);

       //  Set socket option `connect_timeout`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_connect_timeout (void *self, int connect_timeout);

       //  Get socket option `tcp_maxrt`.
       //  Available from libzmq 4.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_tcp_maxrt (void *self);

       //  Set socket option `tcp_maxrt`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_tcp_maxrt (void *self, int tcp_maxrt);

       //  Get socket option `thread_safe`.
       //  Available from libzmq 4.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_thread_safe (void *self);

       //  Get socket option `multicast_maxtpdu`.
       //  Available from libzmq 4.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_multicast_maxtpdu (void *self);

       //  Set socket option `multicast_maxtpdu`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_multicast_maxtpdu (void *self, int multicast_maxtpdu);

       //  Get socket option `vmci_buffer_size`.
       //  Available from libzmq 4.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_vmci_buffer_size (void *self);

       //  Set socket option `vmci_buffer_size`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_vmci_buffer_size (void *self, int vmci_buffer_size);

       //  Get socket option `vmci_buffer_min_size`.
       //  Available from libzmq 4.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_vmci_buffer_min_size (void *self);

       //  Set socket option `vmci_buffer_min_size`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_vmci_buffer_min_size (void *self, int vmci_buffer_min_size);

       //  Get socket option `vmci_buffer_max_size`.
       //  Available from libzmq 4.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_vmci_buffer_max_size (void *self);

       //  Set socket option `vmci_buffer_max_size`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_vmci_buffer_max_size (void *self, int vmci_buffer_max_size);

       //  Get socket option `vmci_connect_timeout`.
       //  Available from libzmq 4.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_vmci_connect_timeout (void *self);

       //  Set socket option `vmci_connect_timeout`.
       //  Available from libzmq 4.2.0.
       CZMQ_EXPORT void
           zsock_set_vmci_connect_timeout (void *self, int vmci_connect_timeout);

       //  Get socket option `tos`.
       //  Available from libzmq 4.1.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_tos (void *self);

       //  Set socket option `tos`.
       //  Available from libzmq 4.1.0.
       CZMQ_EXPORT void
           zsock_set_tos (void *self, int tos);

       //  Set socket option `router_handover`.
       //  Available from libzmq 4.1.0.
       CZMQ_EXPORT void
           zsock_set_router_handover (void *self, int router_handover);

       //  Set socket option `connect_rid`.
       //  Available from libzmq 4.1.0.
       CZMQ_EXPORT void
           zsock_set_connect_rid (void *self, const char *connect_rid);

       //  Set socket option `connect_rid` from 32-octet binary
       //  Available from libzmq 4.1.0.
       CZMQ_EXPORT void
           zsock_set_connect_rid_bin (void *self, const byte *connect_rid);

       //  Get socket option `handshake_ivl`.
       //  Available from libzmq 4.1.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_handshake_ivl (void *self);

       //  Set socket option `handshake_ivl`.
       //  Available from libzmq 4.1.0.
       CZMQ_EXPORT void
           zsock_set_handshake_ivl (void *self, int handshake_ivl);

       //  Get socket option `socks_proxy`.
       //  Available from libzmq 4.1.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_socks_proxy (void *self);

       //  Set socket option `socks_proxy`.
       //  Available from libzmq 4.1.0.
       CZMQ_EXPORT void
           zsock_set_socks_proxy (void *self, const char *socks_proxy);

       //  Set socket option `xpub_nodrop`.
       //  Available from libzmq 4.1.0.
       CZMQ_EXPORT void
           zsock_set_xpub_nodrop (void *self, int xpub_nodrop);

       //  Set socket option `router_mandatory`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_router_mandatory (void *self, int router_mandatory);

       //  Set socket option `probe_router`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_probe_router (void *self, int probe_router);

       //  Set socket option `req_relaxed`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_req_relaxed (void *self, int req_relaxed);

       //  Set socket option `req_correlate`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_req_correlate (void *self, int req_correlate);

       //  Set socket option `conflate`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_conflate (void *self, int conflate);

       //  Get socket option `zap_domain`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_zap_domain (void *self);

       //  Set socket option `zap_domain`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_zap_domain (void *self, const char *zap_domain);

       //  Get socket option `mechanism`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_mechanism (void *self);

       //  Get socket option `plain_server`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_plain_server (void *self);

       //  Set socket option `plain_server`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_plain_server (void *self, int plain_server);

       //  Get socket option `plain_username`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_plain_username (void *self);

       //  Set socket option `plain_username`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_plain_username (void *self, const char *plain_username);

       //  Get socket option `plain_password`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_plain_password (void *self);

       //  Set socket option `plain_password`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_plain_password (void *self, const char *plain_password);

       //  Get socket option `curve_server`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_curve_server (void *self);

       //  Set socket option `curve_server`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_curve_server (void *self, int curve_server);

       //  Get socket option `curve_publickey`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_curve_publickey (void *self);

       //  Set socket option `curve_publickey`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_curve_publickey (void *self, const char *curve_publickey);

       //  Set socket option `curve_publickey` from 32-octet binary
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_curve_publickey_bin (void *self, const byte *curve_publickey);

       //  Get socket option `curve_secretkey`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_curve_secretkey (void *self);

       //  Set socket option `curve_secretkey`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_curve_secretkey (void *self, const char *curve_secretkey);

       //  Set socket option `curve_secretkey` from 32-octet binary
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_curve_secretkey_bin (void *self, const byte *curve_secretkey);

       //  Get socket option `curve_serverkey`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_curve_serverkey (void *self);

       //  Set socket option `curve_serverkey`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_curve_serverkey (void *self, const char *curve_serverkey);

       //  Set socket option `curve_serverkey` from 32-octet binary
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_curve_serverkey_bin (void *self, const byte *curve_serverkey);

       //  Get socket option `gssapi_server`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_gssapi_server (void *self);

       //  Set socket option `gssapi_server`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_gssapi_server (void *self, int gssapi_server);

       //  Get socket option `gssapi_plaintext`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_gssapi_plaintext (void *self);

       //  Set socket option `gssapi_plaintext`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_gssapi_plaintext (void *self, int gssapi_plaintext);

       //  Get socket option `gssapi_principal`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_gssapi_principal (void *self);

       //  Set socket option `gssapi_principal`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_gssapi_principal (void *self, const char *gssapi_principal);

       //  Get socket option `gssapi_service_principal`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_gssapi_service_principal (void *self);

       //  Set socket option `gssapi_service_principal`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_gssapi_service_principal (void *self, const char *gssapi_service_principal);

       //  Get socket option `ipv6`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_ipv6 (void *self);

       //  Set socket option `ipv6`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_ipv6 (void *self, int ipv6);

       //  Get socket option `immediate`.
       //  Available from libzmq 4.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_immediate (void *self);

       //  Set socket option `immediate`.
       //  Available from libzmq 4.0.0.
       CZMQ_EXPORT void
           zsock_set_immediate (void *self, int immediate);

       //  Get socket option `sndhwm`.
       //  Available from libzmq 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_sndhwm (void *self);

       //  Set socket option `sndhwm`.
       //  Available from libzmq 3.0.0.
       CZMQ_EXPORT void
           zsock_set_sndhwm (void *self, int sndhwm);

       //  Get socket option `rcvhwm`.
       //  Available from libzmq 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_rcvhwm (void *self);

       //  Set socket option `rcvhwm`.
       //  Available from libzmq 3.0.0.
       CZMQ_EXPORT void
           zsock_set_rcvhwm (void *self, int rcvhwm);

       //  Get socket option `maxmsgsize`.
       //  Available from libzmq 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_maxmsgsize (void *self);

       //  Set socket option `maxmsgsize`.
       //  Available from libzmq 3.0.0.
       CZMQ_EXPORT void
           zsock_set_maxmsgsize (void *self, int maxmsgsize);

       //  Get socket option `multicast_hops`.
       //  Available from libzmq 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_multicast_hops (void *self);

       //  Set socket option `multicast_hops`.
       //  Available from libzmq 3.0.0.
       CZMQ_EXPORT void
           zsock_set_multicast_hops (void *self, int multicast_hops);

       //  Set socket option `xpub_verbose`.
       //  Available from libzmq 3.0.0.
       CZMQ_EXPORT void
           zsock_set_xpub_verbose (void *self, int xpub_verbose);

       //  Get socket option `tcp_keepalive`.
       //  Available from libzmq 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_tcp_keepalive (void *self);

       //  Set socket option `tcp_keepalive`.
       //  Available from libzmq 3.0.0.
       CZMQ_EXPORT void
           zsock_set_tcp_keepalive (void *self, int tcp_keepalive);

       //  Get socket option `tcp_keepalive_idle`.
       //  Available from libzmq 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_tcp_keepalive_idle (void *self);

       //  Set socket option `tcp_keepalive_idle`.
       //  Available from libzmq 3.0.0.
       CZMQ_EXPORT void
           zsock_set_tcp_keepalive_idle (void *self, int tcp_keepalive_idle);

       //  Get socket option `tcp_keepalive_cnt`.
       //  Available from libzmq 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_tcp_keepalive_cnt (void *self);

       //  Set socket option `tcp_keepalive_cnt`.
       //  Available from libzmq 3.0.0.
       CZMQ_EXPORT void
           zsock_set_tcp_keepalive_cnt (void *self, int tcp_keepalive_cnt);

       //  Get socket option `tcp_keepalive_intvl`.
       //  Available from libzmq 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_tcp_keepalive_intvl (void *self);

       //  Set socket option `tcp_keepalive_intvl`.
       //  Available from libzmq 3.0.0.
       CZMQ_EXPORT void
           zsock_set_tcp_keepalive_intvl (void *self, int tcp_keepalive_intvl);

       //  Get socket option `tcp_accept_filter`.
       //  Available from libzmq 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_tcp_accept_filter (void *self);

       //  Set socket option `tcp_accept_filter`.
       //  Available from libzmq 3.0.0.
       CZMQ_EXPORT void
           zsock_set_tcp_accept_filter (void *self, const char *tcp_accept_filter);

       //  Get socket option `last_endpoint`.
       //  Available from libzmq 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_last_endpoint (void *self);

       //  Set socket option `router_raw`.
       //  Available from libzmq 3.0.0.
       CZMQ_EXPORT void
           zsock_set_router_raw (void *self, int router_raw);

       //  Get socket option `ipv4only`.
       //  Available from libzmq 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_ipv4only (void *self);

       //  Set socket option `ipv4only`.
       //  Available from libzmq 3.0.0.
       CZMQ_EXPORT void
           zsock_set_ipv4only (void *self, int ipv4only);

       //  Set socket option `delay_attach_on_connect`.
       //  Available from libzmq 3.0.0.
       CZMQ_EXPORT void
           zsock_set_delay_attach_on_connect (void *self, int delay_attach_on_connect);

       //  Get socket option `hwm`.
       //  Available from libzmq 2.0.0 to 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_hwm (void *self);

       //  Set socket option `hwm`.
       //  Available from libzmq 2.0.0 to 3.0.0.
       CZMQ_EXPORT void
           zsock_set_hwm (void *self, int hwm);

       //  Get socket option `swap`.
       //  Available from libzmq 2.0.0 to 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_swap (void *self);

       //  Set socket option `swap`.
       //  Available from libzmq 2.0.0 to 3.0.0.
       CZMQ_EXPORT void
           zsock_set_swap (void *self, int swap);

       //  Get socket option `affinity`.
       //  Available from libzmq 2.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_affinity (void *self);

       //  Set socket option `affinity`.
       //  Available from libzmq 2.0.0.
       CZMQ_EXPORT void
           zsock_set_affinity (void *self, int affinity);

       //  Get socket option `identity`.
       //  Available from libzmq 2.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zsock_identity (void *self);

       //  Set socket option `identity`.
       //  Available from libzmq 2.0.0.
       CZMQ_EXPORT void
           zsock_set_identity (void *self, const char *identity);

       //  Get socket option `rate`.
       //  Available from libzmq 2.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_rate (void *self);

       //  Set socket option `rate`.
       //  Available from libzmq 2.0.0.
       CZMQ_EXPORT void
           zsock_set_rate (void *self, int rate);

       //  Get socket option `recovery_ivl`.
       //  Available from libzmq 2.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_recovery_ivl (void *self);

       //  Set socket option `recovery_ivl`.
       //  Available from libzmq 2.0.0.
       CZMQ_EXPORT void
           zsock_set_recovery_ivl (void *self, int recovery_ivl);

       //  Get socket option `recovery_ivl_msec`.
       //  Available from libzmq 2.0.0 to 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_recovery_ivl_msec (void *self);

       //  Set socket option `recovery_ivl_msec`.
       //  Available from libzmq 2.0.0 to 3.0.0.
       CZMQ_EXPORT void
           zsock_set_recovery_ivl_msec (void *self, int recovery_ivl_msec);

       //  Get socket option `mcast_loop`.
       //  Available from libzmq 2.0.0 to 3.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_mcast_loop (void *self);

       //  Set socket option `mcast_loop`.
       //  Available from libzmq 2.0.0 to 3.0.0.
       CZMQ_EXPORT void
           zsock_set_mcast_loop (void *self, int mcast_loop);

       //  Get socket option `rcvtimeo`.
       //  Available from libzmq 2.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_rcvtimeo (void *self);

       //  Set socket option `rcvtimeo`.
       //  Available from libzmq 2.2.0.
       CZMQ_EXPORT void
           zsock_set_rcvtimeo (void *self, int rcvtimeo);

       //  Get socket option `sndtimeo`.
       //  Available from libzmq 2.2.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_sndtimeo (void *self);

       //  Set socket option `sndtimeo`.
       //  Available from libzmq 2.2.0.
       CZMQ_EXPORT void
           zsock_set_sndtimeo (void *self, int sndtimeo);

       //  Get socket option `sndbuf`.
       //  Available from libzmq 2.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_sndbuf (void *self);

       //  Set socket option `sndbuf`.
       //  Available from libzmq 2.0.0.
       CZMQ_EXPORT void
           zsock_set_sndbuf (void *self, int sndbuf);

       //  Get socket option `rcvbuf`.
       //  Available from libzmq 2.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_rcvbuf (void *self);

       //  Set socket option `rcvbuf`.
       //  Available from libzmq 2.0.0.
       CZMQ_EXPORT void
           zsock_set_rcvbuf (void *self, int rcvbuf);

       //  Get socket option `linger`.
       //  Available from libzmq 2.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_linger (void *self);

       //  Set socket option `linger`.
       //  Available from libzmq 2.0.0.
       CZMQ_EXPORT void
           zsock_set_linger (void *self, int linger);

       //  Get socket option `reconnect_ivl`.
       //  Available from libzmq 2.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_reconnect_ivl (void *self);

       //  Set socket option `reconnect_ivl`.
       //  Available from libzmq 2.0.0.
       CZMQ_EXPORT void
           zsock_set_reconnect_ivl (void *self, int reconnect_ivl);

       //  Get socket option `reconnect_ivl_max`.
       //  Available from libzmq 2.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_reconnect_ivl_max (void *self);

       //  Set socket option `reconnect_ivl_max`.
       //  Available from libzmq 2.0.0.
       CZMQ_EXPORT void
           zsock_set_reconnect_ivl_max (void *self, int reconnect_ivl_max);

       //  Get socket option `backlog`.
       //  Available from libzmq 2.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_backlog (void *self);

       //  Set socket option `backlog`.
       //  Available from libzmq 2.0.0.
       CZMQ_EXPORT void
           zsock_set_backlog (void *self, int backlog);

       //  Set socket option `subscribe`.
       //  Available from libzmq 2.0.0.
       CZMQ_EXPORT void
           zsock_set_subscribe (void *self, const char *subscribe);

       //  Set socket option `unsubscribe`.
       //  Available from libzmq 2.0.0.
       CZMQ_EXPORT void
           zsock_set_unsubscribe (void *self, const char *unsubscribe);

       //  Get socket option `type`.
       //  Available from libzmq 2.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_type (void *self);

       //  Get socket option `rcvmore`.
       //  Available from libzmq 2.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_rcvmore (void *self);

       //  Get socket option `fd`.
       //  Available from libzmq 2.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT SOCKET
           zsock_fd (void *self);

       //  Get socket option `events`.
       //  Available from libzmq 2.0.0.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT int
           zsock_events (void *self);

       //  Self test of this class.
       CZMQ_EXPORT void
           zsock_test (bool verbose);

       #ifdef CZMQ_BUILD_DRAFT_API
       //  *** Draft method, for development use, may change without warning ***
       //  Create a SERVER socket. Default action is bind.
       CZMQ_EXPORT zsock_t *
           zsock_new_server (const char *endpoint);

       //  *** Draft method, for development use, may change without warning ***
       //  Create a CLIENT socket. Default action is connect.
       CZMQ_EXPORT zsock_t *
           zsock_new_client (const char *endpoint);

       //  *** Draft method, for development use, may change without warning ***
       //  Create a RADIO socket. Default action is bind.
       CZMQ_EXPORT zsock_t *
           zsock_new_radio (const char *endpoint);

       //  *** Draft method, for development use, may change without warning ***
       //  Create a DISH socket. Default action is connect.
       CZMQ_EXPORT zsock_t *
           zsock_new_dish (const char *endpoint);

       //  *** Draft method, for development use, may change without warning ***
       //  Create a GATHER socket. Default action is bind.
       CZMQ_EXPORT zsock_t *
           zsock_new_gather (const char *endpoint);

       //  *** Draft method, for development use, may change without warning ***
       //  Create a SCATTER socket. Default action is connect.
       CZMQ_EXPORT zsock_t *
           zsock_new_scatter (const char *endpoint);

       //  *** Draft method, for development use, may change without warning ***
       //  Create a DGRAM (UDP) socket. Default action is bind.
       //  The endpoint is a string consisting of a
       //  'transport'`://` followed by an 'address'. As this is
       //  a UDP socket the 'transport' has to be 'udp'. The
       //  'address' specifies the ip address and port to
       //  bind to. For example:  udp://127.0.0.1:1234
       //  Note: To send to an endpoint over UDP you have to
       //  send a message with the destination endpoint address
       //  as a first message!
       CZMQ_EXPORT zsock_t *
           zsock_new_dgram (const char *endpoint);

       //  *** Draft method, for development use, may change without warning ***
       //  Return socket routing ID if any. This returns 0 if the socket is not
       //  of type ZMQ_SERVER or if no request was already received on it.
       CZMQ_EXPORT uint32_t
           zsock_routing_id (zsock_t *self);

       //  *** Draft method, for development use, may change without warning ***
       //  Set routing ID on socket. The socket MUST be of type ZMQ_SERVER.
       //  This will be used when sending messages on the socket via the zsock API.
       CZMQ_EXPORT void
           zsock_set_routing_id (zsock_t *self, uint32_t routing_id);

       //  *** Draft method, for development use, may change without warning ***
       //  Join a group for the RADIO-DISH pattern. Call only on ZMQ_DISH.
       //  Returns 0 if OK, -1 if failed.
       CZMQ_EXPORT int
           zsock_join (void *self, const char *group);

       //  *** Draft method, for development use, may change without warning ***
       //  Leave a group for the RADIO-DISH pattern. Call only on ZMQ_DISH.
       //  Returns 0 if OK, -1 if failed.
       CZMQ_EXPORT int
           zsock_leave (void *self, const char *group);

       //  *** Draft method, for development use, may change without warning ***
       //  Check whether the socket has available message to read.
       CZMQ_EXPORT bool
           zsock_has_in (void *self);

       #endif // CZMQ_BUILD_DRAFT_API
       Please add '@interface' section in './../src/zsock.c'.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The zsock class wraps the libzmq socket handle (a void *) with a proper structure that follows the CLASS
       rules for construction and destruction. Some zsock methods take a void * "polymorphic" reference, which
       can be either a zsock_t or a zactor_t reference, or a libzmq void *.

       Please add <u>@discuss</u> section in <u>./../src/zsock.c</u>.

</pre><h4><b>EXAMPLE</b></h4><pre>
       <b>From</b> <b>zsock_test</b> <b>method</b>.

           zsock_t *writer = zsock_new (ZMQ_PUSH);
           assert (writer);
           int port = zsock_bind (writer, "tcp://127.0.0.1:*");
           assert (port != -1);
           assert (zsock_resolve (writer) != writer);
           assert (streq (zsock_type_str (writer), "PUSH"));

           int rc;
           #if (ZMQ_VERSION &gt;= ZMQ_MAKE_VERSION (3, 2, 0))
           //  Check unbind
           rc = zsock_unbind (writer, "tcp://127.0.0.1:%d", port);
           assert (rc == 0);

           //  In some cases and especially when running under Valgrind, doing
           //  a bind immediately after an unbind causes an EADDRINUSE error.
           //  Even a short sleep allows the OS to release the port for reuse.
           zclock_sleep (100);

           //  Bind again
           rc = zsock_bind (writer, "tcp://127.0.0.1:%d", port);
           assert (rc == port);
           char endpoint [40];
           sprintf (endpoint, "tcp://127.0.0.1:%d", port);
           assert (streq (zsock_endpoint (writer), endpoint));
           #endif

           zsock_t *reader = zsock_new (ZMQ_PULL);
           assert (reader);
           rc = zsock_connect (reader, "tcp://127.0.0.1:%d", port);
           assert (rc != -1);
           assert (zsock_resolve (reader) != reader);
           assert (streq (zsock_type_str (reader), "PULL"));

           //  Basic Hello, World
           zstr_send (writer, "Hello, World");
           zmsg_t *msg = zmsg_recv (reader);
           assert (msg);
           char *string = zmsg_popstr (msg);
           assert (streq (string, "Hello, World"));
           freen (string);
           zmsg_destroy (&amp;msg);

           //  Test resolve libzmq socket
           #if (ZMQ_VERSION &gt;= ZMQ_MAKE_VERSION (3, 2, 0))
           void *zmq_ctx = zmq_ctx_new ();
           #else
           void *zmq_ctx = zmq_ctx_new (1);
           #endif
           assert (zmq_ctx);
           void *zmq_sock = zmq_socket (zmq_ctx, ZMQ_PUB);
           assert (zmq_sock);
           assert (zsock_resolve (zmq_sock) == zmq_sock);
           zmq_close (zmq_sock);
           zmq_ctx_term (zmq_ctx);

           //  Test resolve zsock
           zsock_t *resolve = zsock_new_pub("@tcp://127.0.0.1:*");
           assert (resolve);
           assert (zsock_resolve (resolve) == resolve-&gt;handle);
           zsock_destroy (&amp;resolve);

           //  Test resolve FD
           SOCKET fd = zsock_fd (reader);
           assert (zsock_resolve ((void *) &amp;fd) == NULL);

           //  Test binding to ephemeral ports, sequential and random
           port = zsock_bind (writer, "tcp://127.0.0.1:*");
           assert (port &gt;= DYNAMIC_FIRST &amp;&amp; port &lt;= DYNAMIC_LAST);
           port = zsock_bind (writer, "tcp://127.0.0.1:*[50000-]");
           assert (port &gt;= 50000 &amp;&amp; port &lt;= DYNAMIC_LAST);
           port = zsock_bind (writer, "tcp://127.0.0.1:*[-50001]");
           assert (port &gt;= DYNAMIC_FIRST &amp;&amp; port &lt;= 50001);
           port = zsock_bind (writer, "tcp://127.0.0.1:*[60000-60500]");
           assert (port &gt;= 60000 &amp;&amp; port &lt;= 60500);

           port = zsock_bind (writer, "tcp://127.0.0.1:!");
           assert (port &gt;= DYNAMIC_FIRST &amp;&amp; port &lt;= DYNAMIC_LAST);
           port = zsock_bind (writer, "tcp://127.0.0.1:![50000-]");
           assert (port &gt;= 50000 &amp;&amp; port &lt;= DYNAMIC_LAST);
           port = zsock_bind (writer, "tcp://127.0.0.1:![-50001]");
           assert (port &gt;= DYNAMIC_FIRST &amp;&amp; port &lt;= 50001);
           port = zsock_bind (writer, "tcp://127.0.0.1:![60000-60500]");
           assert (port &gt;= 60000 &amp;&amp; port &lt;= 60500);

           //  Test zsock_attach method
           zsock_t *dealer = zsock_new (ZMQ_DEALER);
           assert (dealer);
           rc = zsock_attach (dealer, "@inproc://myendpoint,tcp://127.0.0.1:*,inproc://others", true);
           assert (rc == 0);
           rc = zsock_attach (dealer, "", false);
           assert (rc == 0);
           rc = zsock_attach (dealer, NULL, true);
           assert (rc == 0);
           rc = zsock_attach (dealer, "&gt;a,@b, c,, ", false);
           assert (rc == -1);
           zsock_destroy (&amp;dealer);

           //  Test zsock_endpoint method
           rc = zsock_bind (writer, "inproc://test.%s", "writer");
           assert (rc == 0);
           assert (streq (zsock_endpoint (writer), "inproc://test.writer"));

           //  Test error state when connecting to an invalid socket type
           //  ('txp://' instead of 'tcp://', typo intentional)
           rc = zsock_connect (reader, "txp://127.0.0.1:5560");
           assert (rc == -1);

           //  Test signal/wait methods
           rc = zsock_signal (writer, 123);
           assert (rc == 0);
           rc = zsock_wait (reader);
           assert (rc == 123);

           //  Test zsock_send/recv pictures
           uint8_t  number1 = 123;
           uint16_t number2 = 123 * 123;
           uint32_t number4 = 123 * 123;
           number4 *= 123;
           uint32_t number4_MAX = UINT32_MAX;
           uint64_t number8 = 123 * 123;
           number8 *= 123;
           number8 *= 123;
           uint64_t number8_MAX = UINT64_MAX;

           zchunk_t *chunk = zchunk_new ("HELLO", 5);
           assert (chunk);
           zframe_t *frame = zframe_new ("WORLD", 5);
           assert (frame);
           zhashx_t *hash = zhashx_new ();
           assert (hash);
           #ifdef CZMQ_BUILD_DRAFT_API
           zlistx_t *list = zlistx_new ();
           assert (list);
           #endif
           zuuid_t *uuid = zuuid_new ();
           assert (uuid);
           zhashx_set_destructor (hash, (zhashx_destructor_fn *) zstr_free);
           zhashx_set_duplicator (hash, (zhashx_duplicator_fn *) strdup);
           zhashx_insert (hash, "1", "value A");
           zhashx_insert (hash, "2", "value B");
           #ifdef CZMQ_BUILD_DRAFT_API
           zlistx_set_destructor (list, (zlistx_destructor_fn *) zstr_free);
           zlistx_set_duplicator (list, (zlistx_duplicator_fn *) strdup);
           zlistx_add_end (list, "1");
           zlistx_add_end (list, "2");
           #endif
           char *original = "pointer";

           //  Test zsock_recv into each supported type
           #ifdef CZMQ_BUILD_DRAFT_API
           zsock_send (writer, "i124488zsbcfUhlp",
           #else
           zsock_send (writer, "i124488zsbcfUhp",
           #endif
                       -12345, number1, number2, number4, number4_MAX,
                       number8, number8_MAX,
                       "This is a string", "ABCDE", 5,
           #ifdef CZMQ_BUILD_DRAFT_API
                       chunk, frame, uuid, hash, list, original);
           #else
                       chunk, frame, uuid, hash, original);
           #endif
           char *uuid_str = strdup (zuuid_str (uuid));
           zchunk_destroy (&amp;chunk);
           zframe_destroy (&amp;frame);
           zuuid_destroy (&amp;uuid);
           zhashx_destroy (&amp;hash);
           #ifdef CZMQ_BUILD_DRAFT_API
           zlistx_destroy (&amp;list);
           #endif

           int integer;
           byte *data;
           size_t size;
           char *pointer;
           number8_MAX = number8 = number4_MAX = number4 = number2 = number1 = 0ULL;
           #ifdef CZMQ_BUILD_DRAFT_API
           rc = zsock_recv (reader, "i124488zsbcfUhlp",
           #else
           rc = zsock_recv (reader, "i124488zsbcfUhp",
           #endif
                            &amp;integer, &amp;number1, &amp;number2, &amp;number4, &amp;number4_MAX,
                            &amp;number8, &amp;number8_MAX, &amp;string, &amp;data, &amp;size, &amp;chunk,
           #ifdef CZMQ_BUILD_DRAFT_API
                            &amp;frame, &amp;uuid, &amp;hash, &amp;list, &amp;pointer);
           #else
                            &amp;frame, &amp;uuid, &amp;hash, &amp;pointer);
           #endif
           assert (rc == 0);
           assert (integer == -12345);
           assert (number1 == 123);
           assert (number2 == 123 * 123);
           assert (number4 == 123 * 123 * 123);
           assert (number4_MAX == UINT32_MAX);
           assert (number8 == 123 * 123 * 123 * 123);
           assert (number8_MAX == UINT64_MAX);
           assert (streq (string, "This is a string"));
           assert (memcmp (data, "ABCDE", 5) == 0);
           assert (size == 5);
           assert (memcmp (zchunk_data (chunk), "HELLO", 5) == 0);
           assert (zchunk_size (chunk) == 5);
           assert (streq (uuid_str, zuuid_str (uuid)));
           assert (memcmp (zframe_data (frame), "WORLD", 5) == 0);
           assert (zframe_size (frame) == 5);
           char *value = (char *) zhashx_lookup (hash, "1");
           assert (streq (value, "value A"));
           value = (char *) zhashx_lookup (hash, "2");
           assert (streq (value, "value B"));
           #ifdef CZMQ_BUILD_DRAFT_API
           value = (char *) zlistx_first (list);
           assert (streq (value, "1"));
           value = (char *) zlistx_last (list);
           assert (streq (value, "2"));
           #endif
           assert (original == pointer);
           freen (string);
           freen (data);
           freen (uuid_str);
           zframe_destroy (&amp;frame);
           zchunk_destroy (&amp;chunk);
           zhashx_destroy (&amp;hash);
           #ifdef CZMQ_BUILD_DRAFT_API
           zlistx_destroy (&amp;list);
           #endif
           zuuid_destroy (&amp;uuid);

           //  Test zsock_recv of short message; this lets us return a failure
           //  with a status code and then nothing else; the receiver will get
           //  the status code and NULL/zero for all other values
           zsock_send (writer, "i", -1);
           zsock_recv (reader, "izsbcfp",
               &amp;integer, &amp;string, &amp;data, &amp;size, &amp;chunk, &amp;frame, &amp;pointer);
           assert (integer == -1);
           assert (string == NULL);
           assert (data == NULL);
           assert (size == 0);
           assert (chunk == NULL);
           assert (frame == NULL);
           assert (pointer == NULL);

           msg = zmsg_new ();
           zmsg_addstr (msg, "frame 1");
           zmsg_addstr (msg, "frame 2");
           zsock_send (writer, "szm", "header", msg);
           zmsg_destroy (&amp;msg);

           zsock_recv (reader, "szm", &amp;string, &amp;msg);

           assert (streq ("header", string));
           assert (zmsg_size (msg) == 2);
           assert (zframe_streq (zmsg_first (msg), "frame 1"));
           assert (zframe_streq (zmsg_next (msg), "frame 2"));
           zstr_free (&amp;string);
           zmsg_destroy (&amp;msg);

           //  Test zsock_recv with null arguments
           chunk = zchunk_new ("HELLO", 5);
           assert (chunk);
           frame = zframe_new ("WORLD", 5);
           assert (frame);
           zsock_send (writer, "izsbcfp",
                       -12345, "This is a string", "ABCDE", 5, chunk, frame, original);
           zframe_destroy (&amp;frame);
           zchunk_destroy (&amp;chunk);
           zsock_recv (reader, "izsbcfp", &amp;integer, NULL, NULL, NULL, &amp;chunk, NULL, NULL);
           assert (integer == -12345);
           assert (memcmp (zchunk_data (chunk), "HELLO", 5) == 0);
           assert (zchunk_size (chunk) == 5);
           zchunk_destroy (&amp;chunk);

           //  Test zsock_bsend/brecv pictures with binary encoding
           frame = zframe_new ("Hello", 5);
           chunk = zchunk_new ("World", 5);

           msg = zmsg_new ();
           zmsg_addstr (msg, "Hello");
           zmsg_addstr (msg, "World");

           zsock_bsend (writer, "1248sSpcfm",
                        number1, number2, number4, number8,
                        "Hello, World",
                        "Goodbye cruel World!",
                        original,
                        chunk, frame, msg);
           zchunk_destroy (&amp;chunk);
           zframe_destroy (&amp;frame);
           zmsg_destroy (&amp;msg);

           number8 = number4 = number2 = number1 = 0;
           char *longstr;
           zsock_brecv (reader, "1248sSpcfm",
                        &amp;number1, &amp;number2, &amp;number4, &amp;number8,
                        &amp;string, &amp;longstr,
                        &amp;pointer,
                        &amp;chunk, &amp;frame, &amp;msg);
           assert (number1 == 123);
           assert (number2 == 123 * 123);
           assert (number4 == 123 * 123 * 123);
           assert (number8 == 123 * 123 * 123 * 123);
           assert (streq (string, "Hello, World"));
           assert (streq (longstr, "Goodbye cruel World!"));
           assert (pointer == original);
           zstr_free (&amp;longstr);
           zchunk_destroy (&amp;chunk);
           zframe_destroy (&amp;frame);
           zmsg_destroy (&amp;msg);

           #ifdef ZMQ_SERVER

           //  Test zsock_bsend/brecv pictures with binary encoding on SERVER and CLIENT sockets
           zsock_t *server = zsock_new (ZMQ_SERVER);
           assert (server);
           port = zsock_bind (server, "tcp://127.0.0.1:*");
           assert (port != -1);
           zsock_t* client = zsock_new (ZMQ_CLIENT);
           assert (client);
           rc = zsock_connect (client, "tcp://127.0.0.1:%d", port);
           assert (rc != -1);

           //  From client to server
           chunk = zchunk_new ("World", 5);
           zsock_bsend (client, "1248sSpc",
                        number1, number2, number4, number8,
                        "Hello, World",
                        "Goodbye cruel World!",
                        original,
                        chunk);
           zchunk_destroy (&amp;chunk);

           number8 = number4 = number2 = number1 = 0;
           zsock_brecv (server, "1248sSpc",
                        &amp;number1, &amp;number2, &amp;number4, &amp;number8,
                        &amp;string, &amp;longstr,
                        &amp;pointer,
                        &amp;chunk);
           assert (number1 == 123);
           assert (number2 == 123 * 123);
           assert (number4 == 123 * 123 * 123);
           assert (number8 == 123 * 123 * 123 * 123);
           assert (streq (string, "Hello, World"));
           assert (streq (longstr, "Goodbye cruel World!"));
           assert (pointer == original);
           assert (zsock_routing_id (server));
           zstr_free (&amp;longstr);
           zchunk_destroy (&amp;chunk);

           //  From server to client
           chunk = zchunk_new ("World", 5);
           zsock_bsend (server, "1248sSpc",
                        number1, number2, number4, number8,
                        "Hello, World",
                        "Goodbye cruel World!",
                        original,
                        chunk);
           zchunk_destroy (&amp;chunk);

           number8 = number4 = number2 = number1 = 0;
           zsock_brecv (client, "1248sSpc",
                        &amp;number1, &amp;number2, &amp;number4, &amp;number8,
                        &amp;string, &amp;longstr,
                        &amp;pointer,
                        &amp;chunk);
           assert (number1 == 123);
           assert (number2 == 123 * 123);
           assert (number4 == 123 * 123 * 123);
           assert (number8 == 123 * 123 * 123 * 123);
           assert (streq (string, "Hello, World"));
           assert (streq (longstr, "Goodbye cruel World!"));
           assert (pointer == original);
           assert (zsock_routing_id (client) == 0);
           zstr_free (&amp;longstr);
           zchunk_destroy (&amp;chunk);

           zsock_destroy (&amp;client);
           zsock_destroy (&amp;server);

           #else
           errno = 0;
           zsock_t* server = zsock_new_server (NULL);
           assert(server == NULL);
           assert(errno == ENOTSUP);

           errno = 0;
           zsock_t* client = zsock_new_client (NULL);
           assert(client == NULL);
           assert(errno == ENOTSUP);
           #endif

           #ifdef ZMQ_SCATTER

           zsock_t* gather = zsock_new_gather ("inproc://test-gather-scatter");
           assert (gather);
           zsock_t* scatter = zsock_new_scatter ("inproc://test-gather-scatter");
           assert (scatter);

           rc = zstr_send (scatter, "HELLO");
           assert (rc == 0);

           char* message;
           message = zstr_recv (gather);
           assert (streq(message, "HELLO"));
           zstr_free (&amp;message);

           zsock_destroy (&amp;gather);
           zsock_destroy (&amp;scatter);
           #else
           errno = 0;
           zsock_t* scatter = zsock_new_scatter (NULL);
           assert(scatter == NULL);
           assert(errno == ENOTSUP);

           errno = 0;
           zsock_t* gather = zsock_new_gather (NULL);
           assert(gather == NULL);
           assert(errno == ENOTSUP);
           #endif

           #ifndef ZMQ_RADIO
           errno = 0;
           zsock_t* radio = zsock_new_radio (NULL);
           assert(radio == NULL);
           assert(errno == ENOTSUP);

           errno = 0;
           zsock_t* dish = zsock_new_dish (NULL);
           assert(dish == NULL);
           assert(errno == ENOTSUP);

           errno = 0;
           zsock_t* sock = zsock_new_req (NULL); // any supported socket type
           rc = zsock_join (sock, "group1");
           assert(rc == -1);
           assert(errno == ENOTSUP);
           errno = 0;
           rc = zsock_leave (sock, "group1");
           assert(rc == -1);
           assert(errno == ENOTSUP);
           zsock_destroy (&amp;sock);
           #endif

           //  Check that we can send a zproto format message
           zsock_bsend (writer, "1111sS4", 0xAA, 0xA0, 0x02, 0x01, "key", "value", 1234);
           zgossip_msg_t *gossip = zgossip_msg_new ();
           zgossip_msg_recv (gossip, reader);
           assert (zgossip_msg_id (gossip) == ZGOSSIP_MSG_PUBLISH);
           zgossip_msg_destroy (&amp;gossip);

           zsock_destroy (&amp;reader);
           zsock_destroy (&amp;writer);

           #ifdef ZMQ_DGRAM
           // ZMQ_DGRAM ipv4 unicast test
           zsock_t* dgramr = zsock_new_dgram ("udp://*:7777");
           assert (dgramr);
           assert ( streq( "DGRAM", zsys_sockname(ZMQ_DGRAM)) );
           //zsock_t* dgrams = zsock_new_dgram ("udp://*:*");
           zsock_t* dgrams = zsock_new (ZMQ_DGRAM);
           zsock_bind (dgrams, "udp://127.0.0.1:7778" );

           assert (dgrams);
           // perhaps sleep a little for sockets to setup?

           rc = zstr_sendm( dgrams, "127.0.0.1:7777" );
           assert (rc == 0);
           rc = zstr_send (dgrams, "HELLO");
           assert (rc == 0);

           char *dmessage, *addr;

           zmsg_t *dmsg = zmsg_recv( dgramr );
           assert (dmsg);
           addr = zmsg_popstr (dmsg);
           dmessage = zmsg_popstr (dmsg);
           assert (streq(dmessage, "HELLO"));
           zmsg_destroy ( &amp;dmsg );
           zsock_destroy (&amp;dgrams);
           zsock_destroy (&amp;dgramr);
           zstr_free (&amp;dmessage);
           zstr_free (&amp;addr);
           zstr_free (&amp;message);

           // ZMQ_DGRAM ipv4 multicast test
           zsock_t* mdgramr = zsock_new_dgram ("udp://225.25.25.25:7777");
           assert (mdgramr);
           zsock_t* mdgrams = zsock_new_dgram ("udp://*:*");
           assert (mdgrams);

           rc = zstr_sendm( mdgrams, "225.25.25.25:7777" );
           assert (rc == 0);
           rc = zstr_send (mdgrams, "HELLO");
           assert (rc == 0);

           char *mdmessage, *maddr;

           zmsg_t *mdmsg = zmsg_recv( mdgramr );
           assert (mdmsg);
           maddr = zmsg_popstr (mdmsg);
           mdmessage = zmsg_popstr (mdmsg);
           assert (streq(mdmessage, "HELLO"));
           zmsg_destroy ( &amp;mdmsg );
           zsock_destroy (&amp;mdgrams);
           zsock_destroy (&amp;mdgramr);
           zstr_free (&amp;mdmessage);
           zstr_free (&amp;maddr);
           zstr_free (&amp;mdmessage);

           //    // ipv6 (not supported yet)
           //    <a href="../man1/zsys_set_ipv6.1.html">zsys_set_ipv6</a>(1);
           //    zsock_t* dgramr6 = zsock_new_dgram ("udp://*:7777");
           //    assert (dgramr6);
           //    zsock_t* dgrams6 = zsock_new_dgram ("udp://*:*");
           //    assert (dgrams6);
           //    // perhaps sleep a little for sockets to setup?
           //    <a href="../man100/zclock_sleep.100.html">zclock_sleep</a>(100);

           //    rc = zstr_sendm( dgrams6, "::1:7777" );
           //    assert (rc == 0);
           //    rc = zstr_send (dgrams6, "HELLO");
           //    assert (rc == 0);

           //    char *dmessage6, *addr6;
           //    zmsg_t *dmsg6 = zmsg_recv( dgramr6 );
           //    assert (dmsg6);
           //    addr6 = zmsg_popstr (dmsg6);
           //    dmessage6 = zmsg_popstr(dmsg6);
           //    assert (streq(dmessage6, "HELLO"));
           //    zmsg_destroy( &amp;dmsg6 );
           //    zsock_destroy (&amp;dgrams6);
           //    zsock_destroy (&amp;dgramr6);

           //    zstr_free (&amp;dmessage6);
           //    zstr_free (&amp;addr6);
           //    zstr_free (&amp;dmessage6);
           #endif

</pre><h4><b>AUTHORS</b></h4><pre>
       The czmq manual was written by the authors in the AUTHORS file.

</pre><h4><b>RESOURCES</b></h4><pre>
       Main web site:

       Report bugs to the email &lt;<b><a href="mailto:zeromq-dev@lists.zeromq.org">zeromq-dev@lists.zeromq.org</a></b>[1]&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) the Contributors as noted in the AUTHORS file. This file is part of CZMQ, the high-level C
       binding for 0MQ: <a href="http://czmq.zeromq.org">http://czmq.zeromq.org</a>. This Source Code Form is subject to the terms of the Mozilla
       Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at
       <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. LICENSE included with the czmq distribution.

</pre><h4><b>NOTES</b></h4><pre>
        1. <a href="mailto:zeromq-dev@lists.zeromq.org">zeromq-dev@lists.zeromq.org</a>
           <a href="mailto:zeromq-dev@lists.zeromq.org">mailto:zeromq-dev@lists.zeromq.org</a>

CZMQ 4.2.1                                         05/24/2024                                           <u><a href="../man3/ZSOCK.3.html">ZSOCK</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>