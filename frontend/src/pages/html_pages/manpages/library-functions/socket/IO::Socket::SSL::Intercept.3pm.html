<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IO::Socket::SSL::Intercept -- SSL interception (man in the middle)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libio-socket-ssl-perl">libio-socket-ssl-perl_2.089-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IO::Socket::SSL::Intercept -- SSL interception (man in the middle)

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use IO::Socket::SSL::Intercept;
           # create interceptor with proxy certificates
           my $mitm = IO::Socket::SSL::Intercept-&gt;new(
               proxy_cert_file =&gt; 'proxy_cert.pem',
               proxy_key_file  =&gt; 'proxy_key.pem',
               ...
           );
           my $listen = IO::Socket::INET-&gt;new( LocalAddr =&gt; .., Listen =&gt; .. );
           while (1) {
               # TCP accept new client
               my $client = $listen-&gt;accept or next;
               # SSL connect to server
               my $server = IO::Socket::SSL-&gt;new(
                   PeerAddr =&gt; ..,
                   SSL_verify_mode =&gt; ...,
                   ...
               ) or die "ssl connect failed: $!,$SSL_ERROR";
               # clone server certificate
               my ($cert,$key) = $mitm-&gt;clone_cert( $server-&gt;peer_certificate );
               # and upgrade client side to SSL with cloned certificate
               IO::Socket::SSL-&gt;start_SSL($client,
                   SSL_server =&gt; 1,
                   SSL_cert =&gt; $cert,
                   SSL_key =&gt; $key
               ) or die "upgrade failed: $SSL_ERROR";
               # now transfer data between $client and $server and analyze
               # the unencrypted data
               ...
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides functionality to clone certificates and sign them with a proxy certificate, thus
       making it easy to intercept SSL connections (man in the middle). It also manages a cache of the generated
       certificates.

</pre><h4><b>How</b> <b>Intercepting</b> <b>SSL</b> <b>Works</b></h4><pre>
       Intercepting SSL connections is useful for analyzing encrypted traffic for security reasons or for
       testing. It does not break the end-to-end security of SSL, e.g. a properly written client will notice the
       interception unless you explicitly configure the client to trust your interceptor.  Intercepting SSL
       works the following way:

       •   Create  a  new  CA  certificate,  which  will be used to sign the cloned certificates.  This proxy CA
           certificate should be trusted by the client, or (a properly written client) will throw error messages
           or deny the connections because it detected a  man  in  the  middle  attack.   Due  to  the  way  the
           interception works there no support for client side certificates is possible.

           Using openssl such a proxy CA certificate and private key can be created with:

             openssl genrsa -out proxy_key.pem 1024
             openssl req -new -x509 -extensions v3_ca -key proxy_key.pem -out proxy_cert.pem
             # export as PKCS12 for import into browser
             openssl pkcs12 -export -in proxy_cert.pem -inkey proxy_key.pem -out proxy_cert.p12

       •   Configure  client to connect to use intercepting proxy or somehow redirect connections from client to
           the proxy (e.g. packet filter redirects, ARP or DNS spoofing etc).

       •   Accept the TCP connection from the client, e.g. don't do any SSL handshakes with the client yet.

       •   Establish the SSL connection to the server and verify the servers certificate as usually. Then create
           a new certificate based on the original servers certificate, but signed by your proxy  CA.   This  is
           the step where IO::Socket::SSL::Intercept helps.

       •   Upgrade  the TCP connection to the client to SSL using the cloned certificate from the server. If the
           client trusts your proxy CA it will accept the upgrade to SSL.

       •   Transfer data between client and server.  While  the  connections  to  client  and  server  are  both
           encrypted with SSL you will read/write the unencrypted data in your proxy application.

</pre><h4><b>METHODS</b></h4><pre>
       IO::Socket::SSL::Intercept helps creating the cloned certificate with the following methods:

       <b>$mitm</b> <b>=</b> <b>IO::Socket::SSL::Intercept-&gt;new(%args)</b>
           This creates a new interceptor object. %args should be

           proxy_cert X509 | proxy_cert_file filename
                   This  is  the  proxy certificate.  It can be either given by an X509 object from Net::SSLeays
                   internal representation, or using a file in PEM format.

           proxy_key EVP_PKEY | proxy_key_file filename
                   This is the key for the proxy certificate.  It can be either given by an EVP_PKEY object from
                   Net::SSLeays internal representation, or using a file in PEM format.  The key should not have
                   a passphrase.

           pubkey EVP_PKEY | pubkey_file filename
                   This optional argument specifies the public key used for the cloned certificate.  It  can  be
                   either given by an EVP_PKEY object from Net::SSLeays internal representation, or using a file
                   in PEM format.  If not given it will create a new public key on each call of "new".

           serial INTEGER|CODE
                   This  optional  argument gives the starting point for the serial numbers of the newly created
                   certificates. If not set the serial number will  be  created  based  on  the  digest  of  the
                   original    certificate.    If    the    value    is    code   it   will   be   called   with
                   "serial(original_cert,CERT_asHash(original_cert))" and should return the new serial number.

           cache HASH | SUBROUTINE
                   This optional argument gives a way to cache created certificates,  so  that  they  don't  get
                   recreated  on  future  accesses  to the same host.  If the argument ist not given an internal
                   HASH ist used.

                   If the argument is a hash it will store for each generated certificate a hash reference  with
                   "cert"  and  "atime"  in the hash, where "atime" is the time of last access (to expire unused
                   entries) and "cert" is the certificate. Please note, that the certificate is in  Net::SSLeays
                   internal X509 format and can thus not be simply dumped and restored.  The key for the hash is
                   an "ident" either given to "clone_cert" or generated from the original certificate.

                   If the argument is a subroutine it will be called as "$cache-&gt;(ident,sub)".  This call should
                   return  either  an existing (cached) "(cert,key)" or call "sub" without arguments to create a
                   new "(cert,key)", store it and return it.   If  called  with  $cache-&gt;('type')  the  function
                   should  just  return  1  to  signal that it supports the current type of cache. If it returns
                   nothing instead the older cache interface is assumed for compatibility reasons.

       <b>($clone_cert,$key)</b> <b>=</b> <b>$mitm-&gt;clone_cert($original_cert,[</b> <b>$ident</b> <b>])</b>
           This clones the given certificate.   An  ident  as  the  key  into  the  cache  can  be  given  (like
           "host:port"),  if not it will be created from the properties of the original certificate.  It returns
           the cloned certificate and its key (which is the same for alle created certificates).

       <b>$string</b> <b>=</b> <b>$mitm-&gt;serialize</b>
           This creates a serialized version  of  the  object  (e.g.  a  string)  which  can  then  be  used  to
           persistently  store  created  certificates  over  restarts of the application. The cache will only be
           serialized if it is a HASH.  To work together with Storable the "STORABLE_freeze" function is defined
           to call "serialize".

       <b>$mitm</b> <b>=</b> <b>IO::Socket::SSL::Intercept-&gt;unserialize($string)</b>
           This restores an Intercept object from a serialized string.   To  work  together  with  Storable  the
           "STORABLE_thaw" function is defined to call "unserialize".

</pre><h4><b>AUTHOR</b></h4><pre>
       Steffen Ullrich

perl v5.40.0                                       2024-09-01                    <u>IO::Socket::SSL::<a href="../man3pm/Intercept.3pm.html">Intercept</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>