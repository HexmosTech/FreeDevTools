<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       bind — bind a name to a socket

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;sys/socket.h&gt;

       int bind(int <u>socket</u>, const struct sockaddr *<u>address</u>,
           socklen_t <u>address_len</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>bind</u>()  function  shall  assign  a local socket address <u>address</u> to a socket identified by descriptor
       <u>socket</u> that has no local socket  address  assigned.  Sockets  created  with  the  <u>socket</u>()  function  are
       initially unnamed; they are identified only by their address family.

       The <u>bind</u>() function takes the following arguments:

       <u>socket</u>      Specifies the file descriptor of the socket to be bound.

       <u>address</u>     Points  to  a <b>sockaddr</b> structure containing the address to be bound to the socket. The length
                   and format of the address depend on the address family of the socket.

       <u>address_len</u> Specifies the length of the <b>sockaddr</b> structure pointed to by the <u>address</u> argument.

       The socket specified by <u>socket</u> may require the process to have appropriate privileges to use  the  <u>bind</u>()
       function.

       If  the address family of the socket is AF_UNIX and the pathname in <u>address</u> names a symbolic link, <u>bind</u>()
       shall fail and set <u>errno</u> to <b>[EADDRINUSE]</b>.

       If the socket address cannot be assigned immediately and O_NONBLOCK is set for the  file  descriptor  for
       the  socket,  <u>bind</u>()  shall  fail and set <u>errno</u> to <b>[EINPROGRESS]</b>, but the assignment request shall not be
       aborted, and the assignment shall be completed asynchronously. Subsequent calls to <u>bind</u>()  for  the  same
       socket, before the assignment is completed, shall fail and set <u>errno</u> to <b>[EALREADY]</b>.

       When  the  assignment  has  been performed asynchronously, <u>pselect</u>(), <u>select</u>(), and <u>poll</u>() shall indicate
       that the file descriptor for the socket is ready for reading and writing.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon successful completion, <u>bind</u>() shall return 0; otherwise, -1 shall  be  returned  and  <u>errno</u>  set  to
       indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>bind</u>() function shall fail if:

       <b>EADDRINUSE</b>
              The specified address is already in use.

       <b>EADDRNOTAVAIL</b>
              The specified address is not available from the local machine.

       <b>EAFNOSUPPORT</b>
              The specified address is not a valid address for the address family of the specified socket.

       <b>EALREADY</b>
              An assignment request is already in progress for the specified socket.

       <b>EBADF</b>  The <u>socket</u> argument is not a valid file descriptor.

       <b>EINPROGRESS</b>
              O_NONBLOCK  is set for the file descriptor for the socket and the assignment cannot be immediately
              performed; the assignment shall be performed asynchronously.

       <b>EINVAL</b> The socket is already bound to an address, and the protocol does not  support  binding  to  a  new
              address; or the socket has been shut down.

       <b>ENOBUFS</b>
              Insufficient resources were available to complete the call.

       <b>ENOTSOCK</b>
              The <u>socket</u> argument does not refer to a socket.

       <b>EOPNOTSUPP</b>
              The socket type of the specified socket does not support binding to an address.

       If the address family of the socket is AF_UNIX, then <u>bind</u>() shall fail if:

       <b>EACCES</b> A component of the path prefix denies search permission, or the requested name requires writing in
              a directory with a mode that denies write permission.

       <b>EDESTADDRREQ</b> or <b>EISDIR</b>
              The <u>address</u> argument is a null pointer.

       <b>EIO</b>    An I/O error occurred.

       <b>ELOOP</b>  A loop exists in symbolic links encountered during resolution of the pathname in <u>address</u>.

       <b>ENAMETOOLONG</b>
              The length of a component of a pathname is longer than {NAME_MAX}.

       <b>ENOENT</b> A  component  of  the path prefix of the pathname in <u>address</u> does not name an existing file or the
              pathname is an empty string.

       <b>ENOENT</b> or <b>ENOTDIR</b>
              The pathname in <u>address</u> contains at least one non-&lt;slash&gt; character and  ends  with  one  or  more
              trailing &lt;slash&gt; characters. If the pathname without the trailing &lt;slash&gt; characters would name an
              existing file, an <b>[ENOENT]</b> error shall not occur.

       <b>ENOTDIR</b>
              A component of the path prefix of the pathname in <u>address</u> names an existing file that is neither a
              directory  nor  a  symbolic  link to a directory, or the pathname in <u>address</u> contains at least one
              non-&lt;slash&gt; character and ends with one or more trailing &lt;slash&gt; characters and the last  pathname
              component names an existing file that is neither a directory nor a symbolic link to a directory.

       <b>EROFS</b>  The name would reside on a read-only file system.

       The <u>bind</u>() function may fail if:

       <b>EACCES</b> The specified address is protected and the current user does not have permission to bind to it.

       <b>EINVAL</b> The <u>address_len</u> argument is not a valid length for the address family.

       <b>EISCONN</b>
              The socket is already connected.

       <b>ELOOP</b>  More  than  {SYMLOOP_MAX}  symbolic  links  were  encountered during resolution of the pathname in
              <u>address</u>.

       <b>ENAMETOOLONG</b>
              The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an
              intermediate result with a length that exceeds {PATH_MAX}.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following code segment shows how to create a socket and bind it to a name in the AF_UNIX domain.

           #define MY_SOCK_PATH "/somepath"

           int sfd;
           struct sockaddr_un my_addr;

           sfd = socket(AF_UNIX, SOCK_STREAM, 0);
           if (sfd == -1)
               /* Handle error */;

           memset(&amp;my_addr, '\0', sizeof(struct sockaddr_un));
                                /* Clear structure */
           my_addr.sun_family = AF_UNIX;
           strncpy(my_addr.sun_path, MY_SOCK_PATH, sizeof(my_addr.sun_path) -1);

           if (bind(sfd, (struct sockaddr *) &amp;my_addr,
               sizeof(struct sockaddr_un)) == -1)
               /* Handle error */;

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       An application program can retrieve the assigned socket name with the <u>getsockname</u>() function.

</pre><h4><b>RATIONALE</b></h4><pre>
       None.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>connect</u>(), <u>getsockname</u>(), <u>listen</u>(), <u>socket</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;sys_socket.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                          <u><a href="../man3POSIX/BIND.3POSIX.html">BIND</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>