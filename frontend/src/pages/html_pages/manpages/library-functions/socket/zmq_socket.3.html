<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zmq_socket - create 0MQ socket</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libzmq3-dev">libzmq3-dev_4.3.5-1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       zmq_socket - create 0MQ socket

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>void</b> <b>*zmq_socket</b> <b>(void</b> <u>*context</u><b>,</b> <b>int</b> <u>type</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>zmq_socket()</u> function shall create a 0MQ socket within the specified <u>context</u> and return an opaque
       handle to the newly created socket. The <u>type</u> argument specifies the socket type, which determines the
       semantics of communication over the socket.

       The newly created socket is initially unbound, and not associated with any endpoints. In order to
       establish a message flow a socket must first be connected to at least one endpoint with <b><a href="../man3/zmq_connect.3.html">zmq_connect</a></b>(3),
       or at least one endpoint must be created for accepting incoming connections with <b><a href="../man3/zmq_bind.3.html">zmq_bind</a></b>(3).

       <b>Key</b> <b>differences</b> <b>to</b> <b>conventional</b> <b>sockets</b>. Generally speaking, conventional sockets present a <u>synchronous</u>
       interface to either connection-oriented reliable byte streams (SOCK_STREAM), or connection-less
       unreliable datagrams (SOCK_DGRAM). In comparison, 0MQ sockets present an abstraction of an asynchronous
       <u>message</u> <u>queue</u>, with the exact queueing semantics depending on the socket type in use. Where conventional
       sockets transfer streams of bytes or discrete datagrams, 0MQ sockets transfer discrete <u>messages</u>.

       0MQ sockets being <u>asynchronous</u> means that the timings of the physical connection setup and tear down,
       reconnect and effective delivery are transparent to the user and organized by 0MQ itself. Further,
       messages may be <u>queued</u> in the event that a peer is unavailable to receive them.

       Conventional sockets allow only strict one-to-one (two peers), many-to-one (many clients, one server), or
       in some cases one-to-many (multicast) relationships. With the exception of <u>ZMQ_PAIR</u> and <u>ZMQ_CHANNEL</u>, 0MQ
       sockets may be connected <b>to</b> <b>multiple</b> <b>endpoints</b> using <u>zmq_connect()</u>, while simultaneously accepting
       incoming connections <b>from</b> <b>multiple</b> <b>endpoints</b> bound to the socket using <u>zmq_bind()</u>, thus allowing
       many-to-many relationships.

       <b>Thread</b> <b>safety</b>. 0MQ has both thread safe socket type and <u>not</u> thread safe socket types. Applications MUST
       NOT use a <u>not</u> thread safe socket from multiple threads under any circumstances. Doing so results in
       undefined behaviour.

       Following are the thread safe sockets: * ZMQ_CLIENT * ZMQ_SERVER * ZMQ_DISH * ZMQ_RADIO * ZMQ_SCATTER *
       ZMQ_GATHER * ZMQ_PEER * ZMQ_CHANNEL

       <b>Socket</b> <b>types</b>. The following sections present the socket types defined by 0MQ, grouped by the general
       <u>messaging</u> <u>pattern</u> which is built from related socket types.

   <b>Client-server</b> <b>pattern</b>
       The client-server pattern is used to allow a single <u>ZMQ_SERVER</u> <u>server</u> talk to one or more <u>ZMQ_CLIENT</u>
       <u>clients</u>. The client always starts the conversation, after which either peer can send messages
       asynchronously, to the other.

       The client-server pattern is formally defined by <b><a href="http://rfc.zeromq.org/spec">http://rfc.zeromq.org/spec</a>:41</b>.

           <b>Note</b>

           Server-client is still in draft phase.

       <b>ZMQ_CLIENT</b>

           A <u>ZMQ_CLIENT</u> socket talks to a <u>ZMQ_SERVER</u> socket. Either peer can connect, though the usual and
           recommended model is to bind the <u>ZMQ_SERVER</u> and connect the <u>ZMQ_CLIENT</u>.

           If the <u>ZMQ_CLIENT</u> socket has established a connection, <b><a href="../man3/zmq_send.3.html">zmq_send</a></b>(3) will accept messages, queue them,
           and send them as rapidly as the network allows. The outgoing buffer limit is defined by the high
           water mark for the socket. If the outgoing buffer is full, or, for connection-oriented transports, if
           the ZMQ_IMMEDIATE option is set and there is no connected peer, <b><a href="../man3/zmq_send.3.html">zmq_send</a></b>(3) will block. The
           <u>ZMQ_CLIENT</u> socket will not drop messages.

           When a <u>ZMQ_CLIENT</u> socket is connected to multiple <u>ZMQ_SERVER</u> sockets, outgoing messages are
           distributed between connected peers on a round-robin basis. Likewise, the <u>ZMQ_CLIENT</u> socket receives
           messages fairly from each connected peer. This usage is sensible only for stateless protocols.

           <u>ZMQ_CLIENT</u> sockets are threadsafe and can be used from multiple threads at the same time. Note that
           replies from a <u>ZMQ_SERVER</u> socket will go to the first client thread that calls <b><a href="../man3/zmq_msg_recv.3.html">zmq_msg_recv</a></b>(3). If
           you need to get replies back to the originating thread, use one <u>ZMQ_CLIENT</u> socket per thread.

               <b>Note</b>

               <u>ZMQ_CLIENT</u> sockets are threadsafe. They do not accept the ZMQ_SNDMORE option on sends not
               ZMQ_RCVMORE on receives. This limits them to single part data. The intention is to extend the API
               to allow scatter/gather of multi-part data.

           <b>Table</b> <b>1.</b> <b>Summary</b> <b>of</b> <b>ZMQ_CLIENT</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_SERVER</u>

           Direction                   Bidirectional

           Send/receive pattern        Unrestricted

           Outgoing routing strategy   Round-robin

           Incoming routing strategy   Fair-queued

           Action in mute state        Block

       <b>ZMQ_SERVER</b>

           A <u>ZMQ_SERVER</u> socket talks to a set of <u>ZMQ_CLIENT</u> sockets. A <u>ZMQ_SERVER</u> socket can only reply to an
           incoming message: the <u>ZMQ_CLIENT</u> peer must always initiate a conversation.

           Each received message has a <u>routing_id</u> that is a 32-bit unsigned integer. The application can fetch
           this with <b><a href="../man3/zmq_msg_routing_id.3.html">zmq_msg_routing_id</a></b>(3). To send a message to a given <u>ZMQ_CLIENT</u> peer the application must
           set the peer’s <u>routing_id</u> on the message, using <b><a href="../man3/zmq_msg_set_routing_id.3.html">zmq_msg_set_routing_id</a></b>(3).

           If the <u>routing_id</u> is not specified, or does not refer to a connected client peer, the send call will
           fail with EHOSTUNREACH. If the outgoing buffer for the client peer is full, the send call shall
           block, unless ZMQ_DONTWAIT is used in the send, in which case it shall fail with EAGAIN. The
           <u>ZMQ_SERVER</u> socket shall not drop messages in any case.

               <b>Note</b>

               <u>ZMQ_SERVER</u> sockets are threadsafe. They do not accept the ZMQ_SNDMORE option on sends not
               ZMQ_RCVMORE on receives. This limits them to single part data. The intention is to extend the API
               to allow scatter/gather of multi-part data.

           <b>Table</b> <b>2.</b> <b>Summary</b> <b>of</b> <b>ZMQ_SERVER</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_CLIENT</u>

           Direction                   Bidirectional

           Send/receive pattern        Unrestricted

           Outgoing routing strategy   See text

           Incoming routing strategy   Fair-queued

           Action in mute state        Return EAGAIN

   <b>Radio-dish</b> <b>pattern</b>
       The radio-dish pattern is used for one-to-many distribution of data from a single <u>publisher</u> to multiple
       <u>subscribers</u> in a fan out fashion.

       Radio-dish is using groups (vs Pub-sub topics), Dish sockets can join a group and each message sent by
       Radio sockets belong to a group.

       Groups are null terminated strings limited to 16 chars length (including null). The intention is to
       increase the length to 40 chars (including null). The encoding of groups shall be UTF8.

       Groups are matched using exact matching (vs prefix matching of PubSub).

           <b>Note</b>

           Radio-dish is still in draft phase.

       <b>ZMQ_RADIO</b>

           A socket of type <u>ZMQ_RADIO</u> is used by a <u>publisher</u> to distribute data. Each message belong to a group,
           a group is specified with <b><a href="../man3/zmq_msg_set_group.3.html">zmq_msg_set_group</a></b>(3). Messages are distributed to all members of a group.
           The <b><a href="../man3/zmq_recv.3.html">zmq_recv</a></b>(3) function is not implemented for this socket type.

           When a <u>ZMQ_RADIO</u> socket enters the <u>mute</u> state due to having reached the high water mark for a
           <u>subscriber</u>, then any messages that would be sent to the <u>subscriber</u> in question shall instead be
           dropped until the mute state ends. The <u>zmq_send()</u> function shall never block for this socket type.

               <b>Note</b>

               <u>ZMQ_RADIO</u> sockets are threadsafe. They do not accept the ZMQ_SNDMORE option on sends. This limits
               them to single part data.

           <b>Table</b> <b>3.</b> <b>Summary</b> <b>of</b> <b>ZMQ_RADIO</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_DISH</u>

           Direction                   Unidirectional

           Send/receive pattern        Send only

           Incoming routing strategy   N/A

           Outgoing routing strategy   Fan out

           Action in mute state        Drop

       <b>ZMQ_DISH</b>

           A socket of type <u>ZMQ_DISH</u> is used by a <u>subscriber</u> to subscribe to groups distributed by a <u>radio</u>.
           Initially a <u>ZMQ_DISH</u> socket is not subscribed to any groups, use <b><a href="../man3/zmq_join.3.html">zmq_join</a></b>(3) to join a group. To get
           the group the message belong to call <b><a href="../man3/zmq_msg_group.3.html">zmq_msg_group</a></b>(3). The <u>zmq_send()</u> function is not implemented for
           this socket type.

               <b>Note</b>

               <u>ZMQ_DISH</u> sockets are threadsafe. They do not accept ZMQ_RCVMORE on receives. This limits them to
               single part data.

           <b>Table</b> <b>4.</b> <b>Summary</b> <b>of</b> <b>ZMQ_DISH</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_RADIO</u>

           Direction                   Unidirectional

           Send/receive pattern        Receive only

           Incoming routing strategy   Fair-queued

           Outgoing routing strategy   N/A

   <b>Publish-subscribe</b> <b>pattern</b>
       The publish-subscribe pattern is used for one-to-many distribution of data from a single <u>publisher</u> to
       multiple <u>subscribers</u> in a fan out fashion.

       The publish-subscribe pattern is formally defined by <b><a href="http://rfc.zeromq.org/spec">http://rfc.zeromq.org/spec</a>:29</b>.

       <b>ZMQ_PUB</b>

           A socket of type <u>ZMQ_PUB</u> is used by a <u>publisher</u> to distribute data. Messages sent are distributed in
           a fan out fashion to all connected peers. The <b><a href="../man3/zmq_recv.3.html">zmq_recv</a></b>(3) function is not implemented for this socket
           type.

           When a <u>ZMQ_PUB</u> socket enters the <u>mute</u> state due to having reached the high water mark for a
           <u>subscriber</u>, then any messages that would be sent to the <u>subscriber</u> in question shall instead be
           dropped until the mute state ends. The <u>zmq_send()</u> function shall never block for this socket type.

           <b>Table</b> <b>5.</b> <b>Summary</b> <b>of</b> <b>ZMQ_PUB</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_SUB</u>, <u>ZMQ_XSUB</u>

           Direction                   Unidirectional

           Send/receive pattern        Send only

           Incoming routing strategy   N/A

           Outgoing routing strategy   Fan out

           Action in mute state        Drop

       <b>ZMQ_SUB</b>

           A socket of type <u>ZMQ_SUB</u> is used by a <u>subscriber</u> to subscribe to data distributed by a <u>publisher</u>.
           Initially a <u>ZMQ_SUB</u> socket is not subscribed to any messages, use the <u>ZMQ_SUBSCRIBE</u> option of
           <b><a href="../man3/zmq_setsockopt.3.html">zmq_setsockopt</a></b>(3) to specify which messages to subscribe to. The <u>zmq_send()</u> function is not
           implemented for this socket type.

           <b>Table</b> <b>6.</b> <b>Summary</b> <b>of</b> <b>ZMQ_SUB</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_PUB</u>, <u>ZMQ_XPUB</u>

           Direction                   Unidirectional

           Send/receive pattern        Receive only

           Incoming routing strategy   Fair-queued

           Outgoing routing strategy   N/A

       <b>ZMQ_XPUB</b>

           Same as ZMQ_PUB except that you can receive subscriptions from the peers in form of incoming
           messages. Subscription message is a byte 1 (for subscriptions) or byte 0 (for unsubscriptions)
           followed by the subscription body. Messages without a sub/unsub prefix are also received, but have no
           effect on subscription status.

           <b>Table</b> <b>7.</b> <b>Summary</b> <b>of</b> <b>ZMQ_XPUB</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_SUB</u>, <u>ZMQ_XSUB</u>

           Direction                   Unidirectional

           Send/receive pattern        Send messages, receive subscriptions

           Incoming routing strategy   N/A

           Outgoing routing strategy   Fan out

           Action in mute state        Drop

       <b>ZMQ_XSUB</b>

           Same as ZMQ_SUB except that you subscribe by sending subscription messages to the socket.
           Subscription message is a byte 1 (for subscriptions) or byte 0 (for unsubscriptions) followed by the
           subscription body. Messages without a sub/unsub prefix may also be sent, but have no effect on
           subscription status.

           <b>Table</b> <b>8.</b> <b>Summary</b> <b>of</b> <b>ZMQ_XSUB</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_PUB</u>, <u>ZMQ_XPUB</u>

           Direction                   Unidirectional

           Send/receive pattern        Receive messages, send subscriptions

           Incoming routing strategy   Fair-queued

           Outgoing routing strategy   N/A

           Action in mute state        Drop

   <b>Pipeline</b> <b>pattern</b>
       The pipeline pattern is used for distributing data to <u>nodes</u> arranged in a pipeline. Data always flows
       down the pipeline, and each stage of the pipeline is connected to at least one <u>node</u>. When a pipeline
       stage is connected to multiple <u>nodes</u> data is round-robined among all connected <u>nodes</u>.

       The pipeline pattern is formally defined by <b><a href="http://rfc.zeromq.org/spec">http://rfc.zeromq.org/spec</a>:30</b>.

       <b>ZMQ_PUSH</b>

           A socket of type <u>ZMQ_PUSH</u> is used by a pipeline <u>node</u> to send messages to downstream pipeline <u>nodes</u>.
           Messages are round-robined to all connected downstream <u>nodes</u>. The <u>zmq_recv()</u> function is not
           implemented for this socket type.

           When a <u>ZMQ_PUSH</u> socket enters the <u>mute</u> state due to having reached the high water mark for all
           downstream <u>nodes</u>, or, for connection-oriented transports, if the ZMQ_IMMEDIATE option is set and
           there are no downstream <u>nodes</u> at all, then any <b><a href="../man3/zmq_send.3.html">zmq_send</a></b>(3) operations on the socket shall block until
           the mute state ends or at least one downstream <u>node</u> becomes available for sending; messages are not
           discarded.

           <b>Table</b> <b>9.</b> <b>Summary</b> <b>of</b> <b>ZMQ_PUSH</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_PULL</u>

           Direction                   Unidirectional

           Send/receive pattern        Send only

           Incoming routing strategy   N/A

           Outgoing routing strategy   Round-robin

           Action in mute state        Block

       <b>ZMQ_PULL</b>

           A socket of type <u>ZMQ_PULL</u> is used by a pipeline <u>node</u> to receive messages from upstream pipeline
           <u>nodes</u>. Messages are fair-queued from among all connected upstream <u>nodes</u>. The <u>zmq_send()</u> function is
           not implemented for this socket type.

           <b>Table</b> <b>10.</b> <b>Summary</b> <b>of</b> <b>ZMQ_PULL</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_PUSH</u>

           Direction                   Unidirectional

           Send/receive pattern        Receive only

           Incoming routing strategy   Fair-queued

           Outgoing routing strategy   N/A

           Action in mute state        Block

           Scatter-gather pattern

               The scatter-gather pattern is the thread-safe version of the pipeline pattern.
               The scatter-gather pattern is used for distributing data to _nodes_ arranged in
               a pipeline. Data always flows down the pipeline, and each stage of the pipeline
               is connected to at least one _node_. When a pipeline stage is connected to
               multiple _nodes_ data is round-robined among all connected _nodes_.

               ZMQ_SCATTER
               ^^^^^^^^
               A socket of type 'ZMQ_SCATTER' is used by a scatter-gather _node_ to send messages
               to downstream scatter-gather _nodes_. Messages are round-robined to all connected
               downstream _nodes_. The _zmq_recv()_ function is not implemented for this
               socket type.

               When a 'ZMQ_SCATTER' socket enters the 'mute' state due to having reached the
               high water mark for all downstream _nodes_, or, for connection-oriented transports,
               if the ZMQ_IMMEDIATE option is set and there are no downstream _nodes_ at all,
               then any linkzmq:zmq_send[3] operations on the socket shall block until the mute
               state ends or at least one downstream _node_ becomes available for sending;
               messages are not discarded.

               NOTE: 'ZMQ_SCATTER' sockets are threadsafe. They do not accept ZMQ_RCVMORE on receives.
               This limits them to single part data.

               [horizontal]
               .Summary of ZMQ_SCATTER characteristics
               Compatible peer sockets:: 'ZMQ_SCATTER'
               Direction:: Unidirectional
               Send/receive pattern:: Send only
               Incoming routing strategy:: N/A
               Outgoing routing strategy:: Round-robin
               Action in mute state:: Block

               ZMQ_GATHER
               ^^^^^^^^
               A socket of type 'ZMQ_GATHER' is used by a scatter-gather _node_ to receive messages
               from upstream scatter-gather _nodes_. Messages are fair-queued from among all
               connected upstream _nodes_. The _zmq_send()_ function is not implemented for
               this socket type.

               NOTE: 'ZMQ_GATHER' sockets are threadsafe. They do not accept ZMQ_RCVMORE on receives.
               This limits them to single part data.

               [horizontal]
               .Summary of ZMQ_GATHER characteristics
               Compatible peer sockets:: 'ZMQ_GATHER'
               Direction:: Unidirectional
               Send/receive pattern:: Receive only
               Incoming routing strategy:: Fair-queued
               Outgoing routing strategy:: N/A
               Action in mute state:: Block

               Exclusive pair pattern

           The exclusive pair pattern is used to connect a peer to precisely one other peer. This pattern is
           used for inter-thread communication across the inproc transport.

           The exclusive pair pattern is formally defined by <b><a href="http://rfc.zeromq.org/spec">http://rfc.zeromq.org/spec</a>:31</b>.

       <b>ZMQ_PAIR</b>

           A socket of type <u>ZMQ_PAIR</u> can only be connected to a single peer at any one time. No message routing
           or filtering is performed on messages sent over a <u>ZMQ_PAIR</u> socket.

           When a <u>ZMQ_PAIR</u> socket enters the <u>mute</u> state due to having reached the high water mark for the
           connected peer, or, for connection-oriented transports, if the ZMQ_IMMEDIATE option is set and there
           is no connected peer, then any <b><a href="../man3/zmq_send.3.html">zmq_send</a></b>(3) operations on the socket shall block until the peer
           becomes available for sending; messages are not discarded.

           While <u>ZMQ_PAIR</u> sockets can be used over transports other than <b><a href="../man7/zmq_inproc.7.html">zmq_inproc</a></b>(7), their inability to
           auto-reconnect coupled with the fact new incoming connections will be terminated while any previous
           connections (including ones in a closing state) exist makes them unsuitable for TCP in most cases.

               <b>Note</b>

               <u>ZMQ_PAIR</u> sockets are designed for inter-thread communication across the <b><a href="../man7/zmq_inproc.7.html">zmq_inproc</a></b>(7) transport
               and do not implement functionality such as auto-reconnection.

           <b>Table</b> <b>11.</b> <b>Summary</b> <b>of</b> <b>ZMQ_PAIR</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_PAIR</u>

           Direction                   Bidirectional

           Send/receive pattern        Unrestricted

           Incoming routing strategy   N/A

           Outgoing routing strategy   N/A

           Action in mute state        Block

   <b>Peer-to-peer</b> <b>pattern</b>
       The peer-to-peer pattern is used to connect a peer to multiple peers. Peer can both connect and bind and
       mix both of them with the same socket. The peer-to-peer pattern is useful to build peer-to-peer networks
       (e.g zyre, bitcoin, torrent) where a peer can both accept connections from other peers or connect to
       them.

           <b>Note</b>

           Peer-to-peer is still in draft phase.

       <b>ZMQ_PEER</b>

           A <u>ZMQ_PEER</u> socket talks to a set of <u>ZMQ_PEER</u> sockets.

           To connect and fetch the <u>routing_id</u> of the peer use <b><a href="../man3/zmq_connect_peer.3.html">zmq_connect_peer</a></b>(3).

           Each received message has a <u>routing_id</u> that is a 32-bit unsigned integer. The application can fetch
           this with <b><a href="../man3/zmq_msg_routing_id.3.html">zmq_msg_routing_id</a></b>(3).

           To send a message to a given <u>ZMQ_PEER</u> peer the application must set the peer’s <u>routing_id</u> on the
           message, using <b><a href="../man3/zmq_msg_set_routing_id.3.html">zmq_msg_set_routing_id</a></b>(3).

           If the <u>routing_id</u> is not specified, or does not refer to a connected client peer, the send call will
           fail with EHOSTUNREACH. If the outgoing buffer for the peer is full, the send call shall block,
           unless ZMQ_DONTWAIT is used in the send, in which case it shall fail with EAGAIN. The <u>ZMQ_PEER</u> socket
           shall not drop messages in any case.

               <b>Note</b>

               <u>ZMQ_PEER</u> sockets are threadsafe. They do not accept the ZMQ_SNDMORE option on sends not
               ZMQ_RCVMORE on receives. This limits them to single part data.

           <b>Table</b> <b>12.</b> <b>Summary</b> <b>of</b> <b>ZMQ_PEER</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_PEER</u>

           Direction                   Bidirectional

           Send/receive pattern        Unrestricted

           Outgoing routing strategy   See text

           Incoming routing strategy   Fair-queued

           Action in mute state        Return EAGAIN

           Channel pattern

               The channel pattern is the thread-safe version of the exclusive pair pattern.
               The channel pattern is used to connect a peer to precisely one other
               peer. This pattern is used for inter-thread communication across the inproc
               transport.

               NOTE: Channel is still in draft phase.

               ZMQ_CHANNEL
               ^^^^^^^^
               A socket of type 'ZMQ_CHANNEL' can only be connected to a single peer at any one
               time.  No message routing or filtering is performed on messages sent over a
               'ZMQ_CHANNEL' socket.

               When a 'ZMQ_CHANNEL' socket enters the 'mute' state due to having reached the
               high water mark for the connected peer, or, for connection-oriented transports,
               if the ZMQ_IMMEDIATE option is set and there is no connected peer, then
               any linkzmq:zmq_send[3] operations on the socket shall block until the peer
               becomes available for sending; messages are not discarded.

               While 'ZMQ_CHANNEL' sockets can be used over transports other than linkzmq:zmq_inproc[7],
               their inability to auto-reconnect coupled with the fact new incoming connections will
               be terminated while any previous connections (including ones in a closing state)
               exist makes them unsuitable for TCP in most cases.

               NOTE: 'ZMQ_CHANNEL' sockets are designed for inter-thread communication across
               the linkzmq:zmq_inproc[7] transport and do not implement functionality such
               as auto-reconnection.

               NOTE: 'ZMQ_CHANNEL' sockets are threadsafe. They do not accept ZMQ_RCVMORE on receives.
               This limits them to single part data.

               [horizontal]
               .Summary of ZMQ_CHANNEL characteristics
               Compatible peer sockets:: 'ZMQ_CHANNEL'
               Direction:: Bidirectional
               Send/receive pattern:: Unrestricted
               Incoming routing strategy:: N/A
               Outgoing routing strategy:: N/A
               Action in mute state:: Block

               Native Pattern

           The native pattern is used for communicating with TCP peers and allows asynchronous requests and
           replies in either direction.

       <b>ZMQ_STREAM</b>

           A socket of type <u>ZMQ_STREAM</u> is used to send and receive TCP data from a non-0MQ peer, when using the
           tcp:// transport. A <u>ZMQ_STREAM</u> socket can act as client and/or server, sending and/or receiving TCP
           data asynchronously.

           When receiving TCP data, a <u>ZMQ_STREAM</u> socket shall prepend a message part containing the <u>routing</u> <u>id</u>
           of the originating peer to the message before passing it to the application. Messages received are
           fair-queued from among all connected peers.

           When sending TCP data, a <u>ZMQ_STREAM</u> socket shall remove the first part of the message and use it to
           determine the <u>routing</u> <u>id</u> of the peer the message shall be routed to, and unroutable messages shall
           cause an EHOSTUNREACH or EAGAIN error.

           To open a connection to a server, use the zmq_connect call, and then fetch the socket routing id
           using the zmq_getsockopt call with the ZMQ_ROUTING_ID option.

           To close a specific connection, send the routing id frame followed by a zero-length message (see
           EXAMPLE section).

           When a connection is made, a zero-length message will be received by the application. Similarly, when
           the peer disconnects (or the connection is lost), a zero-length message will be received by the
           application.

           You must send one routing id frame followed by one data frame. The ZMQ_SNDMORE flag is required for
           routing id frames but is ignored on data frames.

           <b>Table</b> <b>13.</b> <b>Summary</b> <b>of</b> <b>ZMQ_STREAM</b> <b>characteristics</b>

           Compatible peer sockets     none.

           Direction                   Bidirectional

           Send/receive pattern        Unrestricted

           Outgoing routing strategy   See text

           Incoming routing strategy   Fair-queued

           Action in mute state        EAGAIN

   <b>Request-reply</b> <b>pattern</b>
       The request-reply pattern is used for sending requests from a ZMQ_REQ <u>client</u> to one or more ZMQ_REP
       <u>services</u>, and receiving subsequent replies to each request sent.

       The request-reply pattern is formally defined by <b><a href="http://rfc.zeromq.org/spec">http://rfc.zeromq.org/spec</a>:28</b>.

       <b>ZMQ_REQ</b>

           A socket of type <u>ZMQ_REQ</u> is used by a <u>client</u> to send requests to and receive replies from a <u>service</u>.
           This socket type allows only an alternating sequence of <u>zmq_send(request)</u> and subsequent
           <u>zmq_recv(reply)</u> calls. Each request sent is round-robined among all <u>services</u>, and each reply received
           is matched with the last issued request.

           For connection-oriented transports, If the ZMQ_IMMEDIATE option is set and there is no service
           available, then any send operation on the socket shall block until at least one <u>service</u> becomes
           available. The REQ socket shall not discard messages.

           <b>Table</b> <b>14.</b> <b>Summary</b> <b>of</b> <b>ZMQ_REQ</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_REP</u>, <u>ZMQ_ROUTER</u>

           Direction                   Bidirectional

           Send/receive pattern        Send, Receive, Send, Receive, ...

           Outgoing routing strategy   Round-robin

           Incoming routing strategy   Last peer

           Action in mute state        Block

       <b>ZMQ_REP</b>

           A socket of type <u>ZMQ_REP</u> is used by a <u>service</u> to receive requests from and send replies to a <u>client</u>.
           This socket type allows only an alternating sequence of <u>zmq_recv(request)</u> and subsequent
           <u>zmq_send(reply)</u> calls. Each request received is fair-queued from among all <u>clients</u>, and each reply
           sent is routed to the <u>client</u> that issued the last request. If the original requester does not exist
           any more the reply is silently discarded.

           <b>Table</b> <b>15.</b> <b>Summary</b> <b>of</b> <b>ZMQ_REP</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_REQ</u>, <u>ZMQ_DEALER</u>

           Direction                   Bidirectional

           Send/receive pattern        Receive, Send, Receive, Send, ...

           Incoming routing strategy   Fair-queued

           Outgoing routing strategy   Last peer

       <b>ZMQ_DEALER</b>

           A socket of type <u>ZMQ_DEALER</u> is an advanced pattern used for extending request/reply sockets. Each
           message sent is round-robined among all connected peers, and each message received is fair-queued
           from all connected peers.

           When a <u>ZMQ_DEALER</u> socket enters the <u>mute</u> state due to having reached the high water mark for all
           peers, or, for connection-oriented transports, if the ZMQ_IMMEDIATE option is set and there are no
           peers at all, then any <b><a href="../man3/zmq_send.3.html">zmq_send</a></b>(3) operations on the socket shall block until the mute state ends or
           at least one peer becomes available for sending; messages are not discarded.

           When a <u>ZMQ_DEALER</u> socket is connected to a <u>ZMQ_REP</u> socket each message sent must consist of an empty
           message part, the <u>delimiter</u>, followed by one or more <u>body</u> <u>parts</u>.

           <b>Table</b> <b>16.</b> <b>Summary</b> <b>of</b> <b>ZMQ_DEALER</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_ROUTER</u>, <u>ZMQ_REP</u>, <u>ZMQ_DEALER</u>

           Direction                   Bidirectional

           Send/receive pattern        Unrestricted

           Outgoing routing strategy   Round-robin

           Incoming routing strategy   Fair-queued

           Action in mute state        Block

       <b>ZMQ_ROUTER</b>

           A socket of type <u>ZMQ_ROUTER</u> is an advanced socket type used for extending request/reply sockets. When
           receiving messages a <u>ZMQ_ROUTER</u> socket shall prepend a message part containing the <u>routing</u> <u>id</u> of the
           originating peer to the message before passing it to the application. Messages received are
           fair-queued from among all connected peers. When sending messages a <u>ZMQ_ROUTER</u> socket shall remove
           the first part of the message and use it to determine the _routing id _ of the peer the message shall
           be routed to. If the peer does not exist anymore, or has never existed, the message shall be silently
           discarded. However, if <u>ZMQ_ROUTER_MANDATORY</u> socket option is set to <u>1</u>, the socket shall fail with
           EHOSTUNREACH in both cases.

           When a <u>ZMQ_ROUTER</u> socket enters the <u>mute</u> state due to having reached the high water mark for all
           peers, then any messages sent to the socket shall be dropped until the mute state ends. Likewise, any
           messages routed to a peer for which the individual high water mark has been reached shall also be
           dropped. If, <u>ZMQ_ROUTER_MANDATORY</u> is set to <u>1</u>, the socket shall block or return EAGAIN in both cases.

           When a <u>ZMQ_ROUTER</u> socket has <u>ZMQ_ROUTER_MANDATORY</u> flag set to <u>1</u>, the socket shall generate <u>ZMQ_POLLIN</u>
           events upon reception of messages from one or more peers. Likewise, the socket shall generate
           <u>ZMQ_POLLOUT</u> events when at least one message can be sent to one or more peers.

           When a <u>ZMQ_REQ</u> socket is connected to a <u>ZMQ_ROUTER</u> socket, in addition to the <u>routing</u> <u>id</u> of the
           originating peer each message received shall contain an empty <u>delimiter</u> message part. Hence, the
           entire structure of each received message as seen by the application becomes: one or more <u>routing</u> <u>id</u>
           parts, <u>delimiter</u> part, one or more <u>body</u> <u>parts</u>. When sending replies to a <u>ZMQ_REQ</u> socket the
           application must include the <u>delimiter</u> part.

           <b>Table</b> <b>17.</b> <b>Summary</b> <b>of</b> <b>ZMQ_ROUTER</b> <b>characteristics</b>

           Compatible peer sockets     <u>ZMQ_DEALER</u>, <u>ZMQ_REQ</u>, <u>ZMQ_ROUTER</u>

           Direction                   Bidirectional

           Send/receive pattern        Unrestricted

           Outgoing routing strategy   See text

           Incoming routing strategy   Fair-queued

           Action in mute state        Drop (see text)

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The <u>zmq_socket()</u> function shall return an opaque handle to the newly created socket if successful.
       Otherwise, it shall return NULL and set <u>errno</u> to one of the values defined below.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EINVAL</b>
           The requested socket <u>type</u> is invalid.

       <b>EFAULT</b>
           The provided <u>context</u> is invalid.

       <b>EMFILE</b>
           The limit on the total number of open 0MQ sockets has been reached.

       <b>ETERM</b>
           The context specified was shutdown or terminated.

</pre><h4><b>EXAMPLE</b></h4><pre>
       <b>Creating</b> <b>a</b> <b>simple</b> <b>HTTP</b> <b>server</b> <b>using</b> <b>ZMQ_STREAM</b>.

           void *ctx = zmq_ctx_new ();
           assert (ctx);
           /* Create ZMQ_STREAM socket */
           void *socket = zmq_socket (ctx, ZMQ_STREAM);
           assert (socket);
           int rc = zmq_bind (socket, "tcp://*:8080");
           assert (rc == 0);
           /* Data structure to hold the ZMQ_STREAM routing id */
           uint8_t routing_id [256];
           size_t routing_id_size = 256;
           /* Data structure to hold the ZMQ_STREAM received data */
           uint8_t raw [256];
           size_t raw_size = 256;
           while (1) {
                   /*  Get HTTP request; routing id frame and then request */
                   routing_id_size = zmq_recv (socket, routing_id, 256, 0);
                   assert (routing_id_size &gt; 0);
                   do {
                           raw_size = zmq_recv (socket, raw, 256, 0);
                           assert (raw_size &gt;= 0);
                   } while (raw_size == 256);
                   /* Prepares the response */
                   char http_response [] =
                           "HTTP/1.0 200 OK\r\n"
                           "Content-Type: text/plain\r\n"
                           "\r\n"
                           "Hello, World!";
                   /* Sends the routing id frame followed by the response */
                   zmq_send (socket, routing_id, routing_id_size, ZMQ_SNDMORE);
                   zmq_send (socket, http_response, strlen (http_response), 0);
                   /* Closes the connection by sending the routing id frame followed by a zero response */
                   zmq_send (socket, routing_id, routing_id_size, ZMQ_SNDMORE);
                   zmq_send (socket, 0, 0, 0);
           }
           zmq_close (socket);
           zmq_ctx_destroy (ctx);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/zmq_init.3.html">zmq_init</a></b>(3) <b><a href="../man3/zmq_setsockopt.3.html">zmq_setsockopt</a></b>(3) <b><a href="../man3/zmq_bind.3.html">zmq_bind</a></b>(3) <b><a href="../man3/zmq_connect.3.html">zmq_connect</a></b>(3) <b><a href="../man3/zmq_send.3.html">zmq_send</a></b>(3) <b><a href="../man3/zmq_recv.3.html">zmq_recv</a></b>(3) <b><a href="../man7/zmq_inproc.7.html">zmq_inproc</a></b>(7) <b><a href="../man7/zmq.7.html">zmq</a></b>(7)

</pre><h4><b>AUTHORS</b></h4><pre>
       This page was written by the 0MQ community. To make a change please read the 0MQ Contribution Policy at
       <b><a href="http://www.zeromq.org/docs">http://www.zeromq.org/docs</a>:contributing</b>.

0MQ 4.3.5                                          03/31/2024                                      <u><a href="../man3/ZMQ_SOCKET.3.html">ZMQ_SOCKET</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>