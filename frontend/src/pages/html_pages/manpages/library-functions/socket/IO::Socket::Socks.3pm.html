<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IO::Socket::Socks - Provides a way to create socks client or server both 4 and 5 version.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libio-socket-socks-perl">libio-socket-socks-perl_0.74-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IO::Socket::Socks - Provides a way to create socks client or server both 4 and 5 version.

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Client</b>
         use IO::Socket::Socks;

         my $socks_client = IO::Socket::Socks-&gt;new(
           ProxyAddr   =&gt; "proxy host",
           ProxyPort   =&gt; "proxy port",
           ConnectAddr =&gt; "remote host",
           ConnectPort =&gt; "remote port",
         ) or die $SOCKS_ERROR;

         print $socks_client "foo\n";
         $socks_client-&gt;close();

   <b>Server</b>
         use IO::Socket::Socks ':constants';

         my $socks_server = IO::Socket::Socks-&gt;new(
           ProxyAddr   =&gt; "localhost",
           ProxyPort   =&gt; 8000,
           Listen      =&gt; 1,
           UserAuth    =&gt; \&amp;auth,
           RequireAuth =&gt; 1
         ) or die $SOCKS_ERROR;

         <a href="../man1/while.1.html">while</a>(1) {
           my $client = $socks_server-&gt;accept();

           unless ($client) {
             print "ERROR: $SOCKS_ERROR\n";
             next;
           }

           my $command = $client-&gt;command();
           if ($command-&gt;[0] == CMD_CONNECT) {
              # Handle the CONNECT
              $client-&gt;command_reply(REPLY_SUCCESS, addr, port);
           }

           ...
           #read from the client and send to the CONNECT address
           ...

           $client-&gt;close();
         }

         sub auth {
           my ($user, $pass) = @_;

           return 1 if $user eq "foo" &amp;&amp; $pass eq "bar";
           return 0;
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "IO::Socket::Socks" connects to a SOCKS proxy, tells it to open a connection to a remote host/port when
       the object is created.  The object you receive can be used directly as a socket (with "IO::Socket"
       interface) for sending and receiving data from the remote host. In addition to create socks client this
       module could be used to create socks server. See examples below.

</pre><h4><b>EXAMPLES</b></h4><pre>
       For complete examples of socks 4/5 client and server see `examples' subdirectory in the distribution.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Socks</b> <b>Client</b>
       <u>new(</u> <u>%cfg</u> <u>)</u>

       <u>new_from_socket($socket,</u> <u>%cfg)</u>

       <u>new_from_fd($socket,</u> <u>%cfg)</u>

       Creates a new IO::Socket::Socks client object.  <b>new_from_socket()</b> is the same as <b>new()</b>, but allows one to
       create object from an existing and not connected socket (new_from_fd is new_from_socket alias). To make
       IO::Socket::Socks object from connected socket see "start_SOCKS"

       Both takes the following config hash:

         SocksVersion =&gt; 4 or 5. Default is 5

         Timeout =&gt; connect/accept timeout

         Blocking =&gt; Since IO::Socket::Socks version 0.5 you can perform non-blocking connect/bind by
                     passing false value for this option. Default is true - blocking. See ready()
                     below for more details.

         SocksResolve =&gt; resolve host name to ip by proxy server or
                         not (will resolve by client). This
                         overrides value of $SOCKS4_RESOLVE or $SOCKS5_RESOLVE
                         variable. Boolean.

         SocksDebug =&gt; This will cause all of the SOCKS traffic to
                       be presented on the command line in a form
                       similar to the tables in the RFCs. This overrides value
                       of $SOCKS_DEBUG variable. Boolean.

         ProxyAddr =&gt; Hostname of the proxy

         ProxyPort =&gt; Port of the proxy

         ConnectAddr =&gt; Hostname of the remote machine

         ConnectPort =&gt; Port of the remote machine

         BindAddr =&gt; Hostname of the remote machine which will
                     connect to the proxy server after bind request

         BindPort =&gt; Port of the remote machine which will
                     connect to the proxy server after bind request

         UdpAddr =&gt; Expected address where datagrams will be sent. Fill it with address
                    of all zeros if address is not known at this moment.
                    Proxy server may use this information to limit access to the association.

         UdpPort =&gt; Expected port where datagrams will be sent. Use zero port
                    if port is not known at this moment. Proxy server may use this
                    information to limit access to the association.

         AuthType =&gt; What kind of authentication to support:
                     none       - no authentication (default)
                     userpass  - Username/Password. For socks5
                     proxy only.

         RequireAuth =&gt; Do not send ANON as a valid auth mechanism.
                        For socks5 proxy only

         Username =&gt; For socks5 if AuthType is set to userpass, then
                     you must provide a username. For socks4 proxy with
                     this option you can specify userid.

         Password =&gt; If AuthType is set to userpass, then you must
                     provide a password. For socks5 proxy only.

       The following options should be specified:

         (ProxyAddr and ProxyPort)
         (ConnectAddr and ConnectPort) or (BindAddr and BindPort) or (UdpAddr and UdpPort)

       Other options are facultative.

        <u>start_SOCKS($socket,</u> <u>%cfg)</u>

       This is a class method to start socks handshake on already connected socket. This will bless passed
       $socket to IO::Socket::Socks class. %cfg is like hash in the constructor.  Only options listed below
       makes sense:

         Timeout
         ConnectAddr
         ConnectPort
         BindAddr
         BindPort
         UdpAddr
         UdpPort
         SocksVersion
         SocksDebug
         SocksResolve
         AuthType
         RequireAuth
         Username
         Password
         AuthMethods

       On success this method will return same $socket, but as IO::Socket::Socks object. On failure it will
       return undef (but socket will be still blessed to IO::Socket::Socks class). See example:

         use IO::Socket;
         use IO::Socket::Socks;

         my $sock = IO::Socket::INET-&gt;new("$proxy_host:$proxy_port") or die $@;
         $sock = IO::Socket::Socks-&gt;start_SOCKS($sock, ConnectAddr =&gt; "google.com", ConnectPort =&gt; 80) or die $SOCKS_ERROR;

        <u>version(</u> <u>)</u>

       Returns socks version for this socket

        <u>ready(</u> <u>)</u>

       Returns true when socket becomes ready to transfer data (socks handshake done), false otherwise. This is
       useful for non-blocking connect/bind. When this method returns false value you can determine what socks
       handshake need for with $SOCKS_ERROR variable. It may need for read, then $SOCKS_ERROR will be
       SOCKS_WANT_READ or need for write, then it will be SOCKS_WANT_WRITE.

       Example:

           use IO::Socket::Socks;
           use IO::Select;

           my $sock = IO::Socket::Socks-&gt;new(
               ProxyAddr =&gt; 'localhost', ProxyPort =&gt; 1080, ConnectAddr =&gt; 'mail.com', ConnectPort =&gt; 80, Blocking =&gt; 0
           ) or die $SOCKS_ERROR;

           my $sel = IO::Select-&gt;new($sock);
           until ($sock-&gt;ready) {
               if ($SOCKS_ERROR == SOCKS_WANT_READ) {
                   $sel-&gt;can_read();
               }
               elsif ($SOCKS_ERROR == SOCKS_WANT_WRITE) {
                   $sel-&gt;can_write();
               }
               else {
                   die $SOCKS_ERROR;
               }

               # NOTE: when base class ($IO::Socket::Socks::SOCKET_CLASS) is IO::Socket::IP
               # and you are using kqueue or epoll to check for readable/writable sockets
               # you need to readd $sock to kqueue/epoll after each call to ready() (actually until socket will be connected to proxy server),
               # because IO::Socket::IP may change internal socket of $sock for milti-homed hosts.
               # There is no such problem when you are using select/poll
           }

           # you may want to return socket to blocking state by $sock-&gt;<a href="../man1/blocking.1.html">blocking</a>(1)
           $sock-&gt;syswrite("I am ready");

        <u>accept(</u> <u>)</u>

       Accept an incoming connection after bind request. On failed returns undef.  On success returns socket. No
       new socket created, returned socket is same on which this method was called. Because <b><a href="../man2/accept.2.html">accept</a></b>(2) is not
       invoked on the client side, socks server calls <b><a href="../man2/accept.2.html">accept</a></b>(2) and proxify all traffic via socket opened by
       client bind request. You can call accept only once on IO::Socket::Socks client socket.

        <u>command(</u> <u>%cfg</u> <u>)</u>

       Allows one to execute socks command on already opened socket. Thus you can create socks chain. For
       example see "EXAMPLES" section.

       %cfg is like hash in the constructor. Only options listed below makes sense:

         ConnectAddr
         ConnectPort
         BindAddr
         BindPort
         UdpAddr
         UdpPort
         SocksVersion
         SocksDebug
         SocksResolve
         AuthType
         RequireAuth
         Username
         Password
         AuthMethods

       Values of the other options (Timeout for example) inherited from the constructor.  Options like ProxyAddr
       and ProxyPort are not included.

        <u>dst(</u> <u>)</u>

       Return (host, port, address_type) of the remote host after connect/accept or socks server (host, port,
       address_type) after bind/udpassoc.

   <b>Socks</b> <b>Server</b>
       <u>new(</u> <u>%cfg</u> <u>)</u>

       <u>new_from_socket($socket,</u> <u>%cfg)</u>

       <u>new_from_fd($socket,</u> <u>%cfg)</u>

       Creates a new IO::Socket::Socks server object. <b>new_from_socket()</b> is the same as <b>new()</b>, but allows one to
       create object from an existing socket (new_from_fd is new_from_socket alias).  Both takes the following
       config hash:

         SocksVersion =&gt; 4 for socks4, 5 for socks5 or [4,5] if you want accept both 4 and 5. Default is 5

         Timeout =&gt; Timeout value for various operations

         Blocking =&gt; Since IO::Socket::Socks version 0.6 you can perform non-blocking accept by
                     passing false value for this option. Default is true - blocking. See ready()
                     below for more details.

         SocksResolve =&gt; For socks v5: return destination address to the client
                         in form of 4 bytes if true, otherwise in form of host
                         length and host name.
                         For socks v4: allow use socks4a protocol extension if
                         true and not otherwise.
                         This overrides value of $SOCKS4_RESOLVE or $SOCKS5_RESOLVE.
                         See also command_reply().

         SocksDebug =&gt; This will cause all of the SOCKS traffic to
                       be presented on the command line in a form
                       similar to the tables in the RFCs. This overrides value
                       of $SOCKS_DEBUG variable. Boolean.

         ProxyAddr =&gt; Local host bind address

         ProxyPort =&gt; Local host bind port

         UserAuth =&gt; Reference to a function that returns 1 if client
                     allowed to use socks server, 0 otherwise. For
                     socks5 proxy it takes login and password as
                     arguments. For socks4 argument is userid.

         RequireAuth =&gt; Not allow anonymous access for socks5 proxy.

         Listen =&gt; Same as IO::Socket::INET listen option. Should be
                   specified as number &gt; 0.

       The following options should be specified:

         Listen
         ProxyAddr
         ProxyPort

       Other options are facultative.

       <u>accept(</u> <u>)</u>

       Accept an incoming connection and return a new IO::Socket::Socks object that represents that connection.
       You must call <b>command()</b> on this to find out what the incoming connection wants you to do, and then call
       <b>command_reply()</b> to send back the reply.

       <u>version(</u> <u>)</u>

       Returns socks version for socket. It is useful when your server accepts both 4 and 5 version. Then you
       should know socks version to make proper response. Just call "version()" on socket received after
       "accept()".

       <u>ready(</u> <u>)</u>

       After non-blocking accept you will get new client socket object, which may be not ready to transfer data
       (if socks handshake is not done yet). <b>ready()</b> will return true value when handshake will be done
       successfully and false otherwise. Note, socket returned by <b>accept()</b> call will be always in blocking mode.
       So if your program can't block you should set non-blocking mode for this socket before <b>ready()</b> call:
       $socket-&gt;<b><a href="../man0/blocking.0.html">blocking</a></b>(0).  When <b>ready()</b> returns false value you can determine what socks handshake needs for
       with $SOCKS_ERROR variable. It may need for read, then $SOCKS_ERROR will be SOCKS_WANT_READ or need for
       write, then it will be SOCKS_WANT_WRITE.

       Example:

         use IO::Socket::Socks;
         use IO::Select;

         my $server = IO::Socket::Socks-&gt;new(ProxyAddr =&gt; 'localhost', ProxyPort =&gt; 1080, Blocking =&gt; 0)
             or die $@;
         my $select = IO::Select-&gt;new($server);
         $select-&gt;can_read(); # wait for client

         my $client = $server-&gt;accept()
           or die "accept(): $! ($SOCKS_ERROR)";
         $client-&gt;<a href="../man0/blocking.0.html">blocking</a>(0); # !!!
         $select-&gt;add($client);
         $select-&gt;remove($server); # no more connections

         while (1) {
             if ($client-&gt;ready) {
                 my $command = $client-&gt;command;

                 ... # do client command

                 $client-&gt;command_reply(IO::Socket::Socks::REPLY_SUCCESS, $command-&gt;[1], $command-&gt;[2]);

                 ... # transfer traffic

                 last;
             }
             elsif ($SOCKS_ERROR == SOCKS_WANT_READ) {
                 $select-&gt;can_read();
             }
             elsif ($SOCKS_ERROR == SOCKS_WANT_WRITE) {
                 $select-&gt;can_write();
             }
             else {
                 die "Unexpected error: $SOCKS_ERROR";
             }
         }

       <u>command(</u> <u>)</u>

       After you call <b>accept()</b> the client has sent the command they want you to process.  This function should
       be called on the socket returned by <b>accept()</b>. It returns a reference to an array with the following
       format:

         [ COMMAND, ADDRESS, PORT, ADDRESS TYPE ]

       <u>command_reply(</u> <u>REPLY</u> <u>CODE,</u> <u>ADDRESS,</u> <u>PORT</u> <u>)</u>

       After you call <b>command()</b> the client needs to be told what the result is.  The REPLY CODE is one of the
       constants as follows (integer value):

         For socks v4
         <a href="../man90/REQUEST_GRANTED.90.html">REQUEST_GRANTED</a>(90): request granted
         <a href="../man91/REQUEST_FAILED.91.html">REQUEST_FAILED</a>(91): request rejected or failed
         <a href="../man92/REQUEST_REJECTED_IDENTD.92.html">REQUEST_REJECTED_IDENTD</a>(92): request rejected because SOCKS server cannot connect to identd on the client
         <a href="../man93/REQUEST_REJECTED_USERID.93.html">REQUEST_REJECTED_USERID</a>(93): request rejected because the client program and identd report different user-ids

         For socks v5
         <a href="../man0/REPLY_SUCCESS.0.html">REPLY_SUCCESS</a>(0): Success
         <a href="../man1/REPLY_GENERAL_FAILURE.1.html">REPLY_GENERAL_FAILURE</a>(1): General Failure
         <a href="../man2/REPLY_CONN_NOT_ALLOWED.2.html">REPLY_CONN_NOT_ALLOWED</a>(2): Connection Not Allowed
         <a href="../man3/REPLY_NETWORK_UNREACHABLE.3.html">REPLY_NETWORK_UNREACHABLE</a>(3): Network Unreachable
         <a href="../man4/REPLY_HOST_UNREACHABLE.4.html">REPLY_HOST_UNREACHABLE</a>(4): Host Unreachable
         <a href="../man5/REPLY_CONN_REFUSED.5.html">REPLY_CONN_REFUSED</a>(5): Connection Refused
         <a href="../man6/REPLY_TTL_EXPIRED.6.html">REPLY_TTL_EXPIRED</a>(6): TTL Expired
         <a href="../man7/REPLY_CMD_NOT_SUPPORTED.7.html">REPLY_CMD_NOT_SUPPORTED</a>(7): Command Not Supported
         <a href="../man8/REPLY_ADDR_NOT_SUPPORTED.8.html">REPLY_ADDR_NOT_SUPPORTED</a>(8): Address Not Supported

       HOST and PORT are the resulting host and port (where server socket responsible for this command bound).

       Note: for 5 version "command_reply" will try to resolve passed address if "SocksResolve" has true value
       and passed address is domain name. To avoid this just pass ip address ("$socket-&gt;sockhost") instead of
       host name or turn off "SocksResolve" for this server. For version 4 passed host name will always be
       resolved to ip address even if "SocksResolve" has false value. Because this version doesn't support
       "ADDRESS" as domain name.

</pre><h4><b>VARIABLES</b></h4><pre>
   <b>$SOCKS_ERROR</b>
       This scalar behaves like $! in that if undef is returned. $SOCKS_ERROR is IO::Socket::Socks::Error object
       with some overloaded operators. In string context this variable should contain a string reason for the
       error. In numeric context it contains error code.

   <b>$SOCKS4_RESOLVE</b>
       If this variable has true value resolving of host names will be done by proxy server, otherwise resolving
       will be done locally. Resolving host by socks proxy version 4 is extension to the protocol also known as
       socks4a. So, only socks4a proxy  supports resolving of hostnames.  Default value of this variable is
       false. This variable is not importable.  See also `SocksResolve' parameter in the constructor.

   <b>$SOCKS5_RESOLVE</b>
       If this variable has true value resolving of host names will be done by proxy server, otherwise resolving
       will be done locally. Note: some bugous socks5 servers doesn't support resolving of host names. Default
       value is true. This variable is not importable.  See also `SocksResolve' parameter in the constructor.

   <b>$SOCKS_DEBUG</b>
       Default value is $ENV{SOCKS_DEBUG}. If this variable has true value and no SocksDebug option in the
       constructor specified, then SocksDebug will has true value. This variable is not importable.

   <b>$SOCKET_CLASS</b>
       With this variable you can get/set base socket class for "IO::Socket::Socks".  By default it tries to use
       "IO::Socket::IP" 0.36+ as socket class. And falls back to "IO::Socket::INET" if not available. You can
       set $IO::Socket::Socks::SOCKET_CLASS before loading of "IO::Socket::Socks" and then it will not try to
       detect proper base class itself. You can also set it after loading of "IO::Socket::Socks" and this will
       automatically update @ISA, so you shouldn't worry about inheritance.

</pre><h4><b>CONSTANTS</b></h4><pre>
       The following constants could be imported manually or using `:constants' tag:

         SOCKS5_VER
         SOCKS4_VER
         ADDR_IPV4
         ADDR_DOMAINNAME
         ADDR_IPV6
         CMD_CONNECT
         CMD_BIND
         CMD_UDPASSOC
         AUTHMECH_ANON
         AUTHMECH_USERPASS
         AUTHMECH_INVALID
         AUTHREPLY_SUCCESS
         AUTHREPLY_FAILURE
         ISS_UNKNOWN_ADDRESS # address type sent by client/server not supported by I::S::S
         ISS_BAD_VERSION     # socks version sent by client/server != specified version
         ISS_CANT_RESOLVE    # I::S::S failed to resolve some host
         REPLY_SUCCESS
         REPLY_GENERAL_FAILURE
         REPLY_CONN_NOT_ALLOWED
         REPLY_NETWORK_UNREACHABLE
         REPLY_HOST_UNREACHABLE
         REPLY_CONN_REFUSED
         REPLY_TTL_EXPIRED
         REPLY_CMD_NOT_SUPPORTED
         REPLY_ADDR_NOT_SUPPORTED
         REQUEST_GRANTED
         REQUEST_FAILED
         REQUEST_REJECTED_IDENTD
         REQUEST_REJECTED_USERID
         SOCKS_WANT_READ
         SOCKS_WANT_WRITE
         ESOCKSPROTO

       SOCKS_WANT_READ, SOCKS_WANT_WRITE and ESOCKSPROTO are imported by default.

</pre><h4><b>IPv6</b></h4><pre>
       Since version 0.66 "IO::Socket::Socks" supports IPv6 with help of IO::Socket::IP 0.36+. And will use
       "IO::Socket::IP" as base class if available. However you can force set "$SOCKET_CLASS =
       "IO::Socket::INET"" to use IPv4 only. See also "$SOCKET_CLASS"

</pre><h4><b>FAQ</b></h4><pre>
       How to determine is connection to socks server (client accept) failed or some protocol error occurred?
           You  can  check  $! variable. If $! == ESOCKSPROTO constant, then it was error in the protocol. Error
           description could be found in $SOCKS_ERROR.

       How to determine which error in the protocol occurred?
           You should compare $SOCKS_ERROR with constants below:

             AUTHMECH_INVALID
             AUTHREPLY_FAILURE
             ISS_UNKNOWN_ADDRESS
             ISS_BAD_VERSION
             REPLY_GENERAL_FAILURE
             REPLY_CONN_NOT_ALLOWED
             REPLY_NETWORK_UNREACHABLE
             REPLY_HOST_UNREACHABLE
             REPLY_CONN_REFUSED
             REPLY_TTL_EXPIRED
             REPLY_CMD_NOT_SUPPORTED
             REPLY_ADDR_NOT_SUPPORTED
             REQUEST_FAILED
             REQUEST_REJECTED_IDENTD
             REQUEST_REJECTED_USERID

</pre><h4><b>BUGS</b></h4><pre>
       The following options are not implemented:

       GSSAPI authentication
       UDP server side support

       Patches are welcome.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       IO::Socket::Socks::Wrapper

</pre><h4><b>AUTHOR</b></h4><pre>
       Original author is Ryan Eatmon

       Now maintained by Oleg G &lt;<a href="mailto:oleg@cpan.org">oleg@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This module is free software, you can redistribute it and/or modify it under the terms of LGPL.

perl v5.36.0                                       2022-10-15                             <u>IO::Socket::<a href="../man3pm/Socks.3pm.html">Socks</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>