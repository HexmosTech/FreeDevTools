<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dict - Manipulate dictionaries</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dict - Manipulate dictionaries

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>dict</b> <u>option</u> <u>arg</u> ?<u>arg</u> <u>...</u>?
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Performs  one  of  several operations on dictionary values or variables containing dictionary values (see
       the <b>DICTIONARY</b> <b>VALUES</b> section below for a description), depending on <u>option</u>.  The  legal  <u>option</u>s  (which
       may be abbreviated) are:

       <b>dict</b> <b>append</b> <u>dictionaryVariable</u> <u>key</u> ?<u>string</u> <u>...</u>?
              This  appends  the  given  string  (or  strings)  to  the  value that the given key maps to in the
              dictionary value contained in the given variable, writing the resulting dictionary value  back  to
              that  variable.   Non-existent  keys  are  treated  as if they map to an empty string. The updated
              dictionary value is returned.  If <u>dictionaryVariable</u> indicates an element that does not  exist  of 2
              an  array  that  has  a  default value set, the default value and will be used as the value of the 2
              dictionary prior to the appending operation.

       <b>dict</b> <b>create</b> ?<u>key</u> <u>value</u> <u>...</u>?
              Return a new dictionary that contains each of the key/value mappings listed as arguments (keys and
              values alternating, with each key being followed by its associated value.)

       <b>dict</b> <b>exists</b> <u>dictionaryValue</u> <u>key</u> ?<u>key</u> <u>...</u>?
              This returns a boolean value indicating whether the given key (or path of keys through  a  set  of
              nested  dictionaries) exists in the given dictionary value. This returns a true value exactly when
              <b>dict</b> <b>get</b> on that path will succeed.

       <b>dict</b> <b>filter</b> <u>dictionaryValue</u> <u>filterType</u> <u>arg</u> ?<u>arg</u> <u>...</u>?
              This takes a dictionary value and returns a new dictionary  that  contains  just  those  key/value
              pairs  that  match  the  specified filter type (which may be abbreviated.)  Supported filter types
              are:

              <b>dict</b> <b>filter</b> <u>dictionaryValue</u> <b>key</b> ?<u>globPattern</u> <u>...</u>?
                     The key rule only matches those key/value pairs whose keys match any of the given  patterns
                     (in the style of <b>string</b> <b>match</b>.)

              <b>dict</b> <b>filter</b> <u>dictionaryValue</u> <b>script</b> <b>{</b><u>keyVariable</u> <u>valueVariable</u><b>}</b> <u>script</u>
                     The script rule tests for matching by assigning the key to the <u>keyVariable</u> and the value to
                     the  <u>valueVariable</u>,  and  then evaluating the given script which should result in a boolean
                     value (with the key/value pair only being included in the result of the <b>dict</b> <b>filter</b> when  a
                     true  value  is returned.)  Note that the first argument after the rule selection word is a
                     two-element list.  If the  <u>script</u>  returns  with  a  condition  of  <b>TCL_BREAK</b>,  no  further
                     key/value  pairs  are considered for inclusion in the resulting dictionary, and a condition
                     of <b>TCL_CONTINUE</b> is equivalent to a false result. The key/value  pairs  are  tested  in  the
                     order in which the keys were inserted into the dictionary.

              <b>dict</b> <b>filter</b> <u>dictionaryValue</u> <b>value</b> ?<u>globPattern</u> <u>...</u>?
                     The  value  rule  only  matches  those  key/value pairs whose values match any of the given
                     patterns (in the style of <b>string</b> <b>match</b>.)

       <b>dict</b> <b>for</b> <b>{</b><u>keyVariable</u> <u>valueVariable</u><b>}</b> <u>dictionaryValue</u> <u>body</u>
              This command takes three arguments, the first a two-element list of variable names  (for  the  key
              and  value  respectively  of  each  mapping in the dictionary), the second the dictionary value to
              iterate across, and the third a script to be evaluated for each mapping with  the  key  and  value
              variables  set  appropriately  (in  the manner of <b>foreach</b>.)  The result of the command is an empty
              string. If any evaluation of the body generates a <b>TCL_BREAK</b> result,  no  further  pairs  from  the
              dictionary will be iterated over and the <b>dict</b> <b>for</b> command will terminate successfully immediately.
              If  any evaluation of the body generates a <b>TCL_CONTINUE</b> result, this shall be treated exactly like
              a normal <b>TCL_OK</b> result. The order of iteration is the order in which the keys were  inserted  into
              the dictionary.

       <b>dict</b> <b>get</b> <u>dictionaryValue</u> ?<u>key</u> <u>...</u>?
              Given  a  dictionary  value  (first  argument) and a key (second argument), this will retrieve the
              value for that key. Where several keys are supplied, the behaviour of the command shall be  as  if
              the  result  of  <b>dict</b>  <b>get</b>  <b>$dictVal</b>  <b>$key</b>  was  passed as the first argument to <b>dict</b> <b>get</b> with the
              remaining arguments as second (and possibly subsequent) arguments.  This  facilitates  lookups  in
              nested dictionaries. For example, the following two commands are equivalent:

                     dict get $dict foo bar spong
                     dict get [dict get [dict get $dict foo] bar] spong

              If  no  keys  are  provided,  <b>dict</b> <b>get</b> will return a list containing pairs of elements in a manner
              similar to <b>array</b> <b>get</b>. That is, the first element of each pair would be  the  key  and  the  second
              element would be the value for that key.

              It is an error to attempt to retrieve a value for a key that is not present in the dictionary.

       <b>dict</b> <b>getdef</b> <u>dictionaryValue</u> ?<u>key</u> <u>...</u>? <u>key</u> <u>default</u>

       <b>dict</b> <b>getwithdefault</b> <u>dictionaryValue</u> ?<u>key</u> <u>...</u>? <u>key</u> <u>default</u>
              This  behaves  the same as <b>dict</b> <b>get</b> (with at least one <u>key</u> argument), returning the value that the 2
              key path maps to in the dictionary <u>dictionaryValue</u>, except that  instead  of  producing  an  error 2
              because  the  <u>key</u>  (or one of the <u>key</u>s on the key path) is absent, it returns the <u>default</u> argument 2
              instead.                                                                                           2

              Note that there must always be  at  least  one  <u>key</u>  provided,  and  that  <b>dict</b>  <b>getdef</b>  and  <b>dict</b> 2
              <b>getwithdefault</b> are aliases for each other.                                                         2

       <b>dict</b> <b>incr</b> <u>dictionaryVariable</u> <u>key</u> ?<u>increment</u>?
              This  adds the given increment value (an integer that defaults to 1 if not specified) to the value
              that the given key maps to in the dictionary value contained in the given  variable,  writing  the
              resulting  dictionary value back to that variable. Non-existent keys are treated as if they map to
              0. It is an error to increment a value for an existing key if that value is not  an  integer.  The
              updated  dictionary  value  is returned.  If <u>dictionaryVariable</u> indicates an element that does not 2
              exist of an array that has a default value set, the default value and will be used as the value of 2
              the dictionary prior to the incrementing operation.

       <b>dict</b> <b>info</b> <u>dictionaryValue</u>
              This returns information (intended for display to people) about the given  dictionary  though  the
              format  of  this  data is dependent on the implementation of the dictionary. For dictionaries that
              are implemented by hash tables, it is expected that  this  will  return  the  string  produced  by
              <b>Tcl_HashStats</b>, similar to <b>array</b> <b>statistics</b>.

       <b>dict</b> <b>keys</b> <u>dictionaryValue</u> ?<u>globPattern</u>?
              Return a list of all keys in the given dictionary value. If a pattern is supplied, only those keys
              that match it (according to the rules of <b>string</b> <b>match</b>) will be returned. The returned keys will be
              in the order that they were inserted into the dictionary.

       <b>dict</b> <b>lappend</b> <u>dictionaryVariable</u> <u>key</u> ?<u>value</u> <u>...</u>?
              This  appends the given items to the list value that the given key maps to in the dictionary value
              contained in the given variable, writing the resulting dictionary value  back  to  that  variable.
              Non-existent  keys are treated as if they map to an empty list, and it is legal for there to be no
              items to append to the list. It is an error for  the  value  that  the  key  maps  to  to  not  be
              representable  as  a  list.  The  updated  dictionary  value  is  returned.  If <u>dictionaryVariable</u> 2
              indicates an element that does not exist of an array that has a default  value  set,  the  default 2
              value and will be used as the value of the dictionary prior to the list-appending operation.

       <b>dict</b> <b>map</b> {<u>keyVariable</u> <u>valueVariable</u>} <u>dictionaryValue</u> <u>body</u>
              This command applies a transformation to each element of a dictionary, returning a new dictionary.
              It takes three arguments: the first is a two-element list of variable names (for the key and value
              respectively  of  each  mapping  in  the  dictionary),  the second the dictionary value to iterate
              across, and the third a script to be evaluated for each mapping with the key and  value  variables
              set  appropriately  (in  the manner of <b>lmap</b>). In an iteration where the evaluated script completes
              normally (<b>TCL_OK</b>, as opposed to an  <b>error</b>,  etc.)  the  result  of  the  script  is  put  into  an
              accumulator  dictionary  using the key that is the current contents of the <u>keyVariable</u> variable at
              that point. The result of the <b>dict</b> <b>map</b> command is the accumulator dictionary after all  keys  have
              been iterated over.

              If the evaluation of the body for any particular step generates a <b>break</b>, no further pairs from the
              dictionary will be iterated over and the <b>dict</b> <b>map</b> command will terminate successfully immediately.
              If  the  evaluation  of  the  body  for a particular step generates a <b>continue</b> result, the current
              iteration is aborted and the accumulator dictionary is not modified. The order of iteration is the
              natural order of the dictionary (typically  the  order  in  which  the  keys  were  added  to  the
              dictionary; the order is the same as that used in <b>dict</b> <b>for</b>).

       <b>dict</b> <b>merge</b> ?<u>dictionaryValue</u> <u>...</u>?
              Return  a  dictionary  that contains the contents of each of the <u>dictionaryValue</u> arguments.  Where
              two (or more) dictionaries contain a mapping for the same key, the resulting dictionary maps  that
              key  to  the  value  according to the last dictionary on the command line containing a mapping for
              that key.

       <b>dict</b> <b>remove</b> <u>dictionaryValue</u> ?<u>key</u> <u>...</u>?
              Return a new dictionary that is a copy of an old one passed in as first  argument  except  without
              mappings  for each of the keys listed.  It is legal for there to be no keys to remove, and it also
              legal for any of the keys to be removed to not be present in the input  dictionary  in  the  first
              place.

       <b>dict</b> <b>replace</b> <u>dictionaryValue</u> ?<u>key</u> <u>value</u> <u>...</u>?
              Return  a new dictionary that is a copy of an old one passed in as first argument except with some
              values different or some extra key/value pairs added. It is legal for this command  to  be  called
              with no key/value pairs, but illegal for this command to be called with a key but no value.

       <b>dict</b> <b>set</b> <u>dictionaryVariable</u> <u>key</u> ?<u>key</u> <u>...</u>? <u>value</u>
              This  operation  takes  the name of a variable containing a dictionary value and places an updated
              dictionary value in that variable containing a mapping from the given key to the given value. When
              multiple keys are present, this operation creates or updates a chain of nested  dictionaries.  The
              updated  dictionary  value  is returned.  If <u>dictionaryVariable</u> indicates an element that does not 2
              exist of an array that has a default value set, the default value and will be used as the value of 2
              the dictionary prior to the value insert/update operation.

       <b>dict</b> <b>size</b> <u>dictionaryValue</u>
              Return the number of key/value mappings in the given dictionary value.

       <b>dict</b> <b>unset</b> <u>dictionaryVariable</u> <u>key</u> ?<u>key</u> <u>...</u>?
              This operation (the companion to <b>dict</b> <b>set</b>) takes the name of a variable  containing  a  dictionary
              value  and places an updated dictionary value in that variable that does not contain a mapping for
              the given key. Where multiple keys are present, this describes a path through nested  dictionaries
              to  the  mapping  to  remove. At least one key must be specified, but the last key on the key-path
              need not exist.  All other components on the path must exist.  The  updated  dictionary  value  is
              returned.   If  <u>dictionaryVariable</u> indicates an element that does not exist of an array that has a 2
              default value set, the default value and will be used as the value of the dictionary prior to  the 2
              value remove operation.

       <b>dict</b> <b>update</b> <u>dictionaryVariable</u> <u>key</u> <u>varName</u> ?<u>key</u> <u>varName</u> <u>...</u>? <u>body</u>
              Execute  the  Tcl  script  in <u>body</u> with the value for each <u>key</u> (as found by reading the dictionary
              value in <u>dictionaryVariable</u>) mapped to the variable <u>varName</u>. There  may  be  multiple  <u>key</u>/<u>varName</u>
              pairs.  If  a  <u>key</u>  does  not  have  a  mapping,  that  corresponds to an unset <u>varName</u>. When <u>body</u>
              terminates, any changes  made  to  the  <u>varName</u>s  is  reflected  back  to  the  dictionary  within
              <u>dictionaryVariable</u>  (unless  <u>dictionaryVariable</u>  itself  becomes  unreadable, when all updates are
              silently discarded), even if the result of <u>body</u> is an error or  some  other  kind  of  exceptional
              exit. The result of <b>dict</b> <b>update</b> is (unless some kind of error occurs) the result of the evaluation
              of  <u>body</u>.   If  <u>dictionaryVariable</u> indicates an element that does not exist of an array that has a 2
              default value set, the default value and will be used as the value of the dictionary prior to  the 2
              update operation.

              Each <u>varName</u> is mapped in the scope enclosing the <b>dict</b> <b>update</b>; it is recommended that this command
              only  be used in a local scope (<b>proc</b>edure, lambda term for <b>apply</b>, or method). Because of this, the
              variables set by <b>dict</b> <b>update</b> will continue to exist after the command finishes (unless  explicitly
              <b>unset</b>).

              Note   that   the   mapping   of  values  to  variables  does  not  use  traces;  changes  to  the
              <u>dictionaryVariable</u>'s contents only happen when <u>body</u> terminates.

       <b>dict</b> <b>values</b> <u>dictionaryValue</u> ?<u>globPattern</u>?
              Return a list of all values in the given dictionary value. If a pattern is  supplied,  only  those
              values  that  match  it  (according  to  the rules of <b>string</b> <b>match</b>) will be returned. The returned
              values will be in the order of that the keys associated with those values were inserted  into  the
              dictionary.

       <b>dict</b> <b>with</b> <u>dictionaryVariable</u> ?<u>key</u> <u>...</u>? <u>body</u>
              Execute  the  Tcl  script  in  <u>body</u> with the value for each key in <u>dictionaryVariable</u> mapped (in a
              manner similarly to <b>dict</b> <b>update</b>) to a variable with the same name. Where  one  or  more  <u>key</u>s  are
              available,  these indicate a chain of nested dictionaries, with the innermost dictionary being the
              one opened out for  the  execution  of  <u>body</u>.  As  with  <b>dict</b>  <b>update</b>,  making  <u>dictionaryVariable</u>
              unreadable  will  make  the  updates  to the dictionary be discarded, and this also happens if the
              contents of <u>dictionaryVariable</u> are adjusted so that the chain of dictionaries  no  longer  exists.
              The  result  of  <b>dict</b>  <b>with</b>  is (unless some kind of error occurs) the result of the evaluation of
              <u>body</u>.  If <u>dictionaryVariable</u> indicates an element that does not exist  of  an  array  that  has  a 2
              default  value set, the default value and will be used as the value of the dictionary prior to the 2
              updating operation.

              The variables are mapped in the scope enclosing the <b>dict</b> <b>with</b>; it is recommended that this command
              only be used in a local scope (<b>proc</b>edure, lambda term for <b>apply</b>, or method). Because of this,  the
              variables  set  by  <b>dict</b> <b>with</b> will continue to exist after the command finishes (unless explicitly
              <b>unset</b>).

              Note  that  the  mapping  of  values  to  variables  does  not  use   traces;   changes   to   the
              <u>dictionaryVariable</u>'s contents only happen when <u>body</u> terminates.

              If  the  <u>dictionaryVariable</u>  contains  a value that is not a dictionary at the point when the <u>body</u>
              terminates (which can easily happen if the name is the same as any of the keys in dictionary) then
              an error occurs at that point. This command is thus not recommended for use when the keys  in  the
              dictionary  are expected to clash with the <u>dictionaryVariable</u> name itself. Where the contained key
              does map to a dictionary, the net effect is to  combine  that  inner  dictionary  into  the  outer
              dictionary; see the <b>EXAMPLES</b> below for an illustration of this.

</pre><h4><b>DICTIONARY</b> <b>VALUES</b></h4><pre>
       Dictionaries  are  values  that  contain  an  efficient,  order-preserving mapping from arbitrary keys to
       arbitrary values.  Each key in the dictionary maps to a single value.  They have a textual format that is
       exactly that of any list with an even number of elements, with  each  mapping  in  the  dictionary  being
       represented  as  two  items  in the list. When a command takes a dictionary and produces a new dictionary
       based on it (either returning it or writing it back into the variable that the  starting  dictionary  was
       read from) the new dictionary will have the same order of keys, modulo any deleted keys and with new keys
       added  on to the end.  When a string is interpreted as a dictionary and it would otherwise have duplicate
       keys, only the last value for a particular key is used; the others  are  ignored,  meaning  that,  “apple
       banana”   and   “apple   carrot   apple  banana”  are  equivalent  dictionaries  (with  different  string
       representations).

       Operations that derive a new dictionary from an old one (e.g., updates like  <b>dict</b>  <b>set</b>  and  <b>dict</b>  <b>unset</b>)
       preserve the order of keys in the dictionary. The exceptions to this are for any new keys they add, which
       are appended to the sequence, and any keys that are removed, which are excised from the order.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Basic dictionary usage:

              # Make a dictionary to map extensions to descriptions
              set filetypes [<b>dict</b> <b>create</b> .txt "Text File" .tcl "Tcl File"]

              # Add/update the dictionary
              <b>dict</b> <b>set</b> filetypes .tcl "Tcl Script"
              <b>dict</b> <b>set</b> filetypes .tm  "Tcl Module"
              <b>dict</b> <b>set</b> filetypes .gif "GIF Image"
              <b>dict</b> <b>set</b> filetypes .png "PNG Image"

              # Simple read from the dictionary
              set ext ".tcl"
              set desc [<b>dict</b> <b>get</b> $filetypes $ext]
              puts "$ext is for a $desc"

              # Somewhat more complex, with existence test
              foreach filename [glob *] {
                  set ext [file extension $filename]
                  if {[<b>dict</b> <b>exists</b> $filetypes $ext]} {
                      puts "$filename is a [<b>dict</b> <b>get</b> $filetypes $ext]"
                  }
              }

       Constructing and using nested dictionaries:

              # Data for one employee
              <b>dict</b> <b>set</b> employeeInfo 12345-A forenames "Joe"
              <b>dict</b> <b>set</b> employeeInfo 12345-A surname   "Schmoe"
              <b>dict</b> <b>set</b> employeeInfo 12345-A street "147 Short Street"
              <b>dict</b> <b>set</b> employeeInfo 12345-A city   "Springfield"
              <b>dict</b> <b>set</b> employeeInfo 12345-A phone  "555-1234"
              # Data for another employee
              <b>dict</b> <b>set</b> employeeInfo 98372-J forenames "Anne"
              <b>dict</b> <b>set</b> employeeInfo 98372-J surname   "Other"
              <b>dict</b> <b>set</b> employeeInfo 98372-J street "32995 Oakdale Way"
              <b>dict</b> <b>set</b> employeeInfo 98372-J city   "Springfield"
              <b>dict</b> <b>set</b> employeeInfo 98372-J phone  "555-8765"
              # The above data probably ought to come from a database...

              # Print out some employee info
              set i 0
              puts "There are [<b>dict</b> <b>size</b> $employeeInfo] employees"
              <b>dict</b> <b>for</b> {id info} $employeeInfo {
                  puts "Employee #[incr i]: $id"
                  <b>dict</b> <b>with</b> info {
                      puts "   Name: $forenames $surname"
                      puts "   Address: $street, $city"
                      puts "   Telephone: $phone"
                  }
              }
              # Another way to iterate and pick out names...
              foreach id [<b>dict</b> <b>keys</b> $employeeInfo] {
                  puts "Hello, [<b>dict</b> <b>get</b> $employeeInfo $id forenames]!"
              }

       A localizable version of <b>string</b> <b>toupper</b>:

              # Set up the basic C locale
              set capital [<b>dict</b> <b>create</b> C [<b>dict</b> <b>create</b>]]
              foreach c [split {abcdefghijklmnopqrstuvwxyz} ""] {
                  <b>dict</b> <b>set</b> capital C $c [string toupper $c]
              }

              # English locales can luckily share the "C" locale
              <b>dict</b> <b>set</b> capital en [<b>dict</b> <b>get</b> $capital C]
              <b>dict</b> <b>set</b> capital en_US [<b>dict</b> <b>get</b> $capital C]
              <b>dict</b> <b>set</b> capital en_GB [<b>dict</b> <b>get</b> $capital C]

              # ... and so on for other supported languages ...

              # Now get the mapping for the current locale and use it.
              set upperCaseMap [<b>dict</b> <b>get</b> $capital $env(LANG)]
              set upperCase [string map $upperCaseMap $string]

       Showing the detail of <b>dict</b> <b>with</b>:

              proc sumDictionary {varName} {
                  upvar 1 $varName vbl
                  foreach key [<b>dict</b> <b>keys</b> $vbl] {
                      # Manufacture an entry in the subdictionary
                      <b>dict</b> <b>set</b> vbl $key total 0
                      # Add the values and remove the old
                      <b>dict</b> <b>with</b> vbl $key {
                          set total [expr {$x + $y + $z}]
                          unset x y z
                      }
                  }
                  puts "last total was $total, for key $key"
              }

              set myDict {
                  a {x 1 y 2 z 3}
                  b {x 6 y 5 z 4}
              }

              sumDictionary myDict
              #    prints: <u>last</u> <u>total</u> <u>was</u> <u>15,</u> <u>for</u> <u>key</u> <u>b</u>

              puts "dictionary is now \"$myDict\""
              #    prints: <u>dictionary</u> <u>is</u> <u>now</u> <u>"a</u> <u>{total</u> <u>6}</u> <u>b</u> <u>{total</u> <u>15}"</u>

       When <b>dict</b> <b>with</b> is used with a key that clashes with the name of the dictionary variable:

              set foo {foo {a b} bar 2 baz 3}
              <b>dict</b> <b>with</b> foo {}
              puts $foo
              #    prints: <u>a</u> <u>b</u> <u>foo</u> <u>{a</u> <u>b}</u> <u>bar</u> <u>2</u> <u>baz</u> <u>3</u>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/append.3tcl.html">append</a>(3tcl), <a href="../man3tcl/array.3tcl.html">array</a>(3tcl), <a href="../man3tcl/foreach.3tcl.html">foreach</a>(3tcl), <a href="../man3tcl/incr.3tcl.html">incr</a>(3tcl), <a href="../man3tcl/list.3tcl.html">list</a>(3tcl), <a href="../man3tcl/lappend.3tcl.html">lappend</a>(3tcl), <a href="../man3tcl/lmap.3tcl.html">lmap</a>(3tcl), <a href="../man3tcl/set.3tcl.html">set</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       dictionary, create, update, lookup, iterate, filter, map

Tcl                                                    8.5                                            <u><a href="../man3tcl/dict.3tcl.html">dict</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>