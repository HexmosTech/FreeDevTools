<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lamtsqr - lamtsqr: multiply by Q from latsqr</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       lamtsqr - lamtsqr: multiply by Q from latsqr

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>clamtsqr</b> (side, trans, m, n, k, mb, nb, a, lda, t, ldt, c, ldc, work, lwork, info)
           <b>CLAMTSQR</b>
       subroutine <b>dlamtsqr</b> (side, trans, m, n, k, mb, nb, a, lda, t, ldt, c, ldc, work, lwork, info)
           <b>DLAMTSQR</b>
       subroutine <b>slamtsqr</b> (side, trans, m, n, k, mb, nb, a, lda, t, ldt, c, ldc, work, lwork, info)
           <b>SLAMTSQR</b>
       subroutine <b>zlamtsqr</b> (side, trans, m, n, k, mb, nb, a, lda, t, ldt, c, ldc, work, lwork, info)
           <b>ZLAMTSQR</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>clamtsqr</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>k,</b> <b>integer</b> <b>mb,</b> <b>integer</b>
       <b>nb,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>complex,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>t,</b> <b>integer</b> <b>ldt,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>CLAMTSQR</b>

       <b>Purpose:</b>

                 CLAMTSQR overwrites the general complex M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
                 where Q is a complex unitary matrix defined as the product
                 of blocked elementary reflectors computed by tall skinny
                 QR factorization (CLATSQR)

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'C':  Conjugate Transpose, apply Q**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;=0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q. M &gt;= K &gt;= 0;

           <u>MB</u>

                     MB is INTEGER
                     The block size to be used in the blocked QR.
                     MB &gt; N. (must be the same as CLATSQR)

           <u>NB</u>

                     NB is INTEGER
                     The column block size to be used in the blocked QR.
                     N &gt;= NB &gt;= 1.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,K)
                     The i-th column must contain the vector which defines the
                     blockedelementary reflector H(i), for i = 1,2,...,k, as
                     returned by CLATSQR in the first k columns of
                     its array argument A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If SIDE = 'L', LDA &gt;= max(1,M);
                     if SIDE = 'R', LDA &gt;= max(1,N).

           <u>T</u>

                     T is COMPLEX array, dimension
                     ( N * Number of blocks(CEIL(M-K/MB-K)),
                     The blocked upper triangular block reflectors stored in compact form
                     as a sequence of upper triangular blocks.  See below
                     for further details.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= NB.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     (workspace) COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the minimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If MIN(M,N,K) = 0, LWORK &gt;= 1.
                     If SIDE = 'L', LWORK &gt;= max(1,N*NB).
                     If SIDE = 'R', LWORK &gt;= max(1,MB*NB).

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the minimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

            Tall-Skinny QR (TSQR) performs QR by a sequence of unitary transformations,
            representing Q as a product of other unitary matrices
              Q = <a href="../man1/Q.1.html">Q</a>(1) * <a href="../man2/Q.2.html">Q</a>(2) * . . . * Q(k)
            where each Q(i) zeros out subdiagonal entries of a block of MB rows of A:
              <a href="../man1/Q.1.html">Q</a>(1) zeros out the subdiagonal entries of rows 1:MB of A
              <a href="../man2/Q.2.html">Q</a>(2) zeros out the bottom MB-N rows of rows [1:N,MB+1:2*MB-N] of A
              <a href="../man3/Q.3.html">Q</a>(3) zeros out the bottom MB-N rows of rows [1:N,2*MB-N+1:3*MB-2*N] of A
              . . .

            <a href="../man1/Q.1.html">Q</a>(1) is computed by GEQRT, which represents <a href="../man1/Q.1.html">Q</a>(1) by Householder vectors
            stored under the diagonal of rows 1:MB of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,1:N).
            For more information see Further Details in GEQRT.

            Q(i) for i&gt;1 is computed by TPQRT, which represents Q(i) by Householder vectors
            stored in rows [(i-1)*(MB-N)+N+1:i*(MB-N)+N] of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,(i-1)*N+1:i*N).
            The last Q(k) may use fewer rows.
            For more information see Further Details in TPQRT.

            For more details of the overall algorithm, see the description of
            Sequential TSQR in Section 2.2 of [1].

            [1] “Communication-Optimal Parallel and Sequential QR and LU Factorizations,”
                J. Demmel, L. Grigori, M. Hoemmen, J. Langou,
                SIAM J. Sci. Comput, vol. 34, no. 1, 2012

   <b>subroutine</b> <b>dlamtsqr</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>k,</b> <b>integer</b> <b>mb,</b> <b>integer</b>
       <b>nb,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>t,</b>
       <b>integer</b> <b>ldt,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b>
       <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>DLAMTSQR</b>

       <b>Purpose:</b>

                 DLAMTSQR overwrites the general real M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
                 where Q is a real orthogonal matrix defined as the product
                 of blocked elementary reflectors computed by tall skinny
                 QR factorization (DLATSQR)

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**T from the Left;
                     = 'R': apply Q or Q**T from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'T':  Transpose, apply Q**T.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;=0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q. M &gt;= K &gt;= 0;

           <u>MB</u>

                     MB is INTEGER
                     The block size to be used in the blocked QR.
                     MB &gt; N. (must be the same as DLATSQR)

           <u>NB</u>

                     NB is INTEGER
                     The column block size to be used in the blocked QR.
                     N &gt;= NB &gt;= 1.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,K)
                     The i-th column must contain the vector which defines the
                     blockedelementary reflector H(i), for i = 1,2,...,k, as
                     returned by DLATSQR in the first k columns of
                     its array argument A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If SIDE = 'L', LDA &gt;= max(1,M);
                     if SIDE = 'R', LDA &gt;= max(1,N).

           <u>T</u>

                     T is DOUBLE PRECISION array, dimension
                     ( N * Number of blocks(CEIL(M-K/MB-K)),
                     The blocked upper triangular block reflectors stored in compact form
                     as a sequence of upper triangular blocks.  See below
                     for further details.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= NB.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the minimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If MIN(M,N,K) = 0, LWORK &gt;= 1.
                     If SIDE = 'L', LWORK &gt;= max(1,N*NB).
                     If SIDE = 'R', LWORK &gt;= max(1,MB*NB).

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the minimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

            Tall-Skinny QR (TSQR) performs QR by a sequence of orthogonal transformations,
            representing Q as a product of other orthogonal matrices
              Q = <a href="../man1/Q.1.html">Q</a>(1) * <a href="../man2/Q.2.html">Q</a>(2) * . . . * Q(k)
            where each Q(i) zeros out subdiagonal entries of a block of MB rows of A:
              <a href="../man1/Q.1.html">Q</a>(1) zeros out the subdiagonal entries of rows 1:MB of A
              <a href="../man2/Q.2.html">Q</a>(2) zeros out the bottom MB-N rows of rows [1:N,MB+1:2*MB-N] of A
              <a href="../man3/Q.3.html">Q</a>(3) zeros out the bottom MB-N rows of rows [1:N,2*MB-N+1:3*MB-2*N] of A
              . . .

            <a href="../man1/Q.1.html">Q</a>(1) is computed by GEQRT, which represents <a href="../man1/Q.1.html">Q</a>(1) by Householder vectors
            stored under the diagonal of rows 1:MB of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,1:N).
            For more information see Further Details in GEQRT.

            Q(i) for i&gt;1 is computed by TPQRT, which represents Q(i) by Householder vectors
            stored in rows [(i-1)*(MB-N)+N+1:i*(MB-N)+N] of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,(i-1)*N+1:i*N).
            The last Q(k) may use fewer rows.
            For more information see Further Details in TPQRT.

            For more details of the overall algorithm, see the description of
            Sequential TSQR in Section 2.2 of [1].

            [1] “Communication-Optimal Parallel and Sequential QR and LU Factorizations,”
                J. Demmel, L. Grigori, M. Hoemmen, J. Langou,
                SIAM J. Sci. Comput, vol. 34, no. 1, 2012

   <b>subroutine</b> <b>slamtsqr</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>k,</b> <b>integer</b> <b>mb,</b> <b>integer</b>
       <b>nb,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>real,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>t,</b> <b>integer</b> <b>ldt,</b> <b>real,</b> <b>dimension(</b>
       <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>SLAMTSQR</b>

       <b>Purpose:</b>

                 SLAMTSQR overwrites the general real M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
                 where Q is a real orthogonal matrix defined as the product
                 of blocked elementary reflectors computed by tall skinny
                 QR factorization (SLATSQR)

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**T from the Left;
                     = 'R': apply Q or Q**T from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'T':  Transpose, apply Q**T.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;=0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q. M &gt;= K &gt;= 0;

           <u>MB</u>

                     MB is INTEGER
                     The block size to be used in the blocked QR.
                     MB &gt; N. (must be the same as SLATSQR)

           <u>NB</u>

                     NB is INTEGER
                     The column block size to be used in the blocked QR.
                     N &gt;= NB &gt;= 1.

           <u>A</u>

                     A is REAL array, dimension (LDA,K)
                     The i-th column must contain the vector which defines the
                     blockedelementary reflector H(i), for i = 1,2,...,k, as
                     returned by SLATSQR in the first k columns of
                     its array argument A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If SIDE = 'L', LDA &gt;= max(1,M);
                     if SIDE = 'R', LDA &gt;= max(1,N).

           <u>T</u>

                     T is REAL array, dimension
                     ( N * Number of blocks(CEIL(M-K/MB-K)),
                     The blocked upper triangular block reflectors stored in compact form
                     as a sequence of upper triangular blocks.  See below
                     for further details.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= NB.

           <u>C</u>

                     C is REAL array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     (workspace) REAL array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the minimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If MIN(M,N,K) = 0, LWORK &gt;= 1.
                     If SIDE = 'L', LWORK &gt;= max(1,N*NB).
                     If SIDE = 'R', LWORK &gt;= max(1,MB*NB).

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the minimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

            Tall-Skinny QR (TSQR) performs QR by a sequence of orthogonal transformations,
            representing Q as a product of other orthogonal matrices
              Q = <a href="../man1/Q.1.html">Q</a>(1) * <a href="../man2/Q.2.html">Q</a>(2) * . . . * Q(k)
            where each Q(i) zeros out subdiagonal entries of a block of MB rows of A:
              <a href="../man1/Q.1.html">Q</a>(1) zeros out the subdiagonal entries of rows 1:MB of A
              <a href="../man2/Q.2.html">Q</a>(2) zeros out the bottom MB-N rows of rows [1:N,MB+1:2*MB-N] of A
              <a href="../man3/Q.3.html">Q</a>(3) zeros out the bottom MB-N rows of rows [1:N,2*MB-N+1:3*MB-2*N] of A
              . . .

            <a href="../man1/Q.1.html">Q</a>(1) is computed by GEQRT, which represents <a href="../man1/Q.1.html">Q</a>(1) by Householder vectors
            stored under the diagonal of rows 1:MB of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,1:N).
            For more information see Further Details in GEQRT.

            Q(i) for i&gt;1 is computed by TPQRT, which represents Q(i) by Householder vectors
            stored in rows [(i-1)*(MB-N)+N+1:i*(MB-N)+N] of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,(i-1)*N+1:i*N).
            The last Q(k) may use fewer rows.
            For more information see Further Details in TPQRT.

            For more details of the overall algorithm, see the description of
            Sequential TSQR in Section 2.2 of [1].

            [1] “Communication-Optimal Parallel and Sequential QR and LU Factorizations,”
                J. Demmel, L. Grigori, M. Hoemmen, J. Langou,
                SIAM J. Sci. Comput, vol. 34, no. 1, 2012

   <b>subroutine</b> <b>zlamtsqr</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>k,</b> <b>integer</b> <b>mb,</b> <b>integer</b>
       <b>nb,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>t,</b> <b>integer</b> <b>ldt,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b>
       <b>info)</b>
       <b>ZLAMTSQR</b>

       <b>Purpose:</b>

                 ZLAMTSQR overwrites the general complex M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
                 where Q is a complex unitary matrix defined as the product
                 of blocked elementary reflectors computed by tall skinny
                 QR factorization (ZLATSQR)

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'C':  Conjugate Transpose, apply Q**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;=0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q. M &gt;= K &gt;= 0;

           <u>MB</u>

                     MB is INTEGER
                     The block size to be used in the blocked QR.
                     MB &gt; N. (must be the same as ZLATSQR)

           <u>NB</u>

                     NB is INTEGER
                     The column block size to be used in the blocked QR.
                     N &gt;= NB &gt;= 1.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,K)
                     The i-th column must contain the vector which defines the
                     blockedelementary reflector H(i), for i = 1,2,...,k, as
                     returned by ZLATSQR in the first k columns of
                     its array argument A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If SIDE = 'L', LDA &gt;= max(1,M);
                     if SIDE = 'R', LDA &gt;= max(1,N).

           <u>T</u>

                     T is COMPLEX*16 array, dimension
                     ( N * Number of blocks(CEIL(M-K/MB-K)),
                     The blocked upper triangular block reflectors stored in compact form
                     as a sequence of upper triangular blocks.  See below
                     for further details.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= NB.

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     (workspace) COMPLEX*16 array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the minimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If MIN(M,N,K) = 0, LWORK &gt;= 1.
                     If SIDE = 'L', LWORK &gt;= max(1,N*NB).
                     If SIDE = 'R', LWORK &gt;= max(1,MB*NB).

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the minimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

            Tall-Skinny QR (TSQR) performs QR by a sequence of unitary transformations,
            representing Q as a product of other unitary matrices
              Q = <a href="../man1/Q.1.html">Q</a>(1) * <a href="../man2/Q.2.html">Q</a>(2) * . . . * Q(k)
            where each Q(i) zeros out subdiagonal entries of a block of MB rows of A:
              <a href="../man1/Q.1.html">Q</a>(1) zeros out the subdiagonal entries of rows 1:MB of A
              <a href="../man2/Q.2.html">Q</a>(2) zeros out the bottom MB-N rows of rows [1:N,MB+1:2*MB-N] of A
              <a href="../man3/Q.3.html">Q</a>(3) zeros out the bottom MB-N rows of rows [1:N,2*MB-N+1:3*MB-2*N] of A
              . . .

            <a href="../man1/Q.1.html">Q</a>(1) is computed by GEQRT, which represents <a href="../man1/Q.1.html">Q</a>(1) by Householder vectors
            stored under the diagonal of rows 1:MB of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,1:N).
            For more information see Further Details in GEQRT.

            Q(i) for i&gt;1 is computed by TPQRT, which represents Q(i) by Householder vectors
            stored in rows [(i-1)*(MB-N)+N+1:i*(MB-N)+N] of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,(i-1)*N+1:i*N).
            The last Q(k) may use fewer rows.
            For more information see Further Details in TPQRT.

            For more details of the overall algorithm, see the description of
            Sequential TSQR in Section 2.2 of [1].

            [1] “Communication-Optimal Parallel and Sequential QR and LU Factorizations,”
                J. Demmel, L. Grigori, M. Hoemmen, J. Langou,
                SIAM J. Sci. Comput, vol. 34, no. 1, 2012

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                               Thu Aug 7 2025 17:26:25                                  <u><a href="../man3/lamtsqr.3.html">lamtsqr</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>