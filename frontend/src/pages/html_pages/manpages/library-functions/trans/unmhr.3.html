<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unmhr - {un,or}mhr: multiply by Q from gehrd</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unmhr - {un,or}mhr: multiply by Q from gehrd

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>cunmhr</b> (side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork, info)
           <b>CUNMHR</b>
       subroutine <b>dormhr</b> (side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork, info)
           <b>DORMHR</b>
       subroutine <b>sormhr</b> (side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork, info)
           <b>SORMHR</b>
       subroutine <b>zunmhr</b> (side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork, info)
           <b>ZUNMHR</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>cunmhr</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>ilo,</b> <b>integer</b> <b>ihi,</b> <b>complex,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>tau,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b>
       <b>ldc,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>CUNMHR</b>

       <b>Purpose:</b>

            CUNMHR overwrites the general complex M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            where Q is a complex unitary matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
            IHI-ILO elementary reflectors, as returned by CGEHRD:

            Q = H(ilo) H(ilo+1) . . . H(ihi-1).

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply Q  (No transpose)
                     = 'C': apply Q**H (Conjugate transpose)

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER

                     ILO and IHI must have the same values as in the previous call
                     of CGEHRD. Q is equal to the unit matrix except in the
                     submatrix Q(ilo+1:ihi,ilo+1:ihi).
                     If SIDE = 'L', then 1 &lt;= ILO &lt;= IHI &lt;= M, if M &gt; 0, and
                     ILO = 1 and IHI = 0, if M = 0;
                     if SIDE = 'R', then 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0, and
                     ILO = 1 and IHI = 0, if N = 0.

           <u>A</u>

                     A is COMPLEX array, dimension
                                          (LDA,M) if SIDE = 'L'
                                          (LDA,N) if SIDE = 'R'
                     The vectors which define the elementary reflectors, as
                     returned by CGEHRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     LDA &gt;= max(1,M) if SIDE = 'L'; LDA &gt;= max(1,N) if SIDE = 'R'.

           <u>TAU</u>

                     TAU is COMPLEX array, dimension
                                          (M-1) if SIDE = 'L'
                                          (N-1) if SIDE = 'R'
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGEHRD.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and
                     LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal
                     blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dormhr</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>ilo,</b> <b>integer</b> <b>ihi,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>tau,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>DORMHR</b>

       <b>Purpose:</b>

            DORMHR overwrites the general real M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T

            where Q is a real orthogonal matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
            IHI-ILO elementary reflectors, as returned by DGEHRD:

            Q = H(ilo) H(ilo+1) . . . H(ihi-1).

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**T from the Left;
                     = 'R': apply Q or Q**T from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'T':  Transpose, apply Q**T.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER

                     ILO and IHI must have the same values as in the previous call
                     of DGEHRD. Q is equal to the unit matrix except in the
                     submatrix Q(ilo+1:ihi,ilo+1:ihi).
                     If SIDE = 'L', then 1 &lt;= ILO &lt;= IHI &lt;= M, if M &gt; 0, and
                     ILO = 1 and IHI = 0, if M = 0;
                     if SIDE = 'R', then 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0, and
                     ILO = 1 and IHI = 0, if N = 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension
                                          (LDA,M) if SIDE = 'L'
                                          (LDA,N) if SIDE = 'R'
                     The vectors which define the elementary reflectors, as
                     returned by DGEHRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     LDA &gt;= max(1,M) if SIDE = 'L'; LDA &gt;= max(1,N) if SIDE = 'R'.

           <u>TAU</u>

                     TAU is DOUBLE PRECISION array, dimension
                                          (M-1) if SIDE = 'L'
                                          (N-1) if SIDE = 'R'
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by DGEHRD.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and
                     LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal
                     blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>sormhr</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>ilo,</b> <b>integer</b> <b>ihi,</b> <b>real,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>tau,</b> <b>real,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>SORMHR</b>

       <b>Purpose:</b>

            SORMHR overwrites the general real M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T

            where Q is a real orthogonal matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
            IHI-ILO elementary reflectors, as returned by SGEHRD:

            Q = H(ilo) H(ilo+1) . . . H(ihi-1).

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**T from the Left;
                     = 'R': apply Q or Q**T from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'T':  Transpose, apply Q**T.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER

                     ILO and IHI must have the same values as in the previous call
                     of SGEHRD. Q is equal to the unit matrix except in the
                     submatrix Q(ilo+1:ihi,ilo+1:ihi).
                     If SIDE = 'L', then 1 &lt;= ILO &lt;= IHI &lt;= M, if M &gt; 0, and
                     ILO = 1 and IHI = 0, if M = 0;
                     if SIDE = 'R', then 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0, and
                     ILO = 1 and IHI = 0, if N = 0.

           <u>A</u>

                     A is REAL array, dimension
                                          (LDA,M) if SIDE = 'L'
                                          (LDA,N) if SIDE = 'R'
                     The vectors which define the elementary reflectors, as
                     returned by SGEHRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     LDA &gt;= max(1,M) if SIDE = 'L'; LDA &gt;= max(1,N) if SIDE = 'R'.

           <u>TAU</u>

                     TAU is REAL array, dimension
                                          (M-1) if SIDE = 'L'
                                          (N-1) if SIDE = 'R'
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by SGEHRD.

           <u>C</u>

                     C is REAL array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and
                     LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal
                     blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zunmhr</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>ilo,</b> <b>integer</b> <b>ihi,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>tau,</b> <b>complex*16,</b> <b>dimension(</b>
       <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>ZUNMHR</b>

       <b>Purpose:</b>

            ZUNMHR overwrites the general complex M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            where Q is a complex unitary matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
            IHI-ILO elementary reflectors, as returned by ZGEHRD:

            Q = H(ilo) H(ilo+1) . . . H(ihi-1).

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply Q  (No transpose)
                     = 'C': apply Q**H (Conjugate transpose)

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER

                     ILO and IHI must have the same values as in the previous call
                     of ZGEHRD. Q is equal to the unit matrix except in the
                     submatrix Q(ilo+1:ihi,ilo+1:ihi).
                     If SIDE = 'L', then 1 &lt;= ILO &lt;= IHI &lt;= M, if M &gt; 0, and
                     ILO = 1 and IHI = 0, if M = 0;
                     if SIDE = 'R', then 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0, and
                     ILO = 1 and IHI = 0, if N = 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension
                                          (LDA,M) if SIDE = 'L'
                                          (LDA,N) if SIDE = 'R'
                     The vectors which define the elementary reflectors, as
                     returned by ZGEHRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     LDA &gt;= max(1,M) if SIDE = 'L'; LDA &gt;= max(1,N) if SIDE = 'R'.

           <u>TAU</u>

                     TAU is COMPLEX*16 array, dimension
                                          (M-1) if SIDE = 'L'
                                          (N-1) if SIDE = 'R'
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by ZGEHRD.

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and
                     LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal
                     blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                               Thu Aug 7 2025 17:26:25                                    <u><a href="../man3/unmhr.3.html">unmhr</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>