<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unmtr - {un,or}mtr: multiply by Q from hetrd</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unmtr - {un,or}mtr: multiply by Q from hetrd

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>cunmtr</b> (side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork, info)
           <b>CUNMTR</b>
       subroutine <b>dormtr</b> (side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork, info)
           <b>DORMTR</b>
       subroutine <b>sormtr</b> (side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork, info)
           <b>SORMTR</b>
       subroutine <b>zunmtr</b> (side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork, info)
           <b>ZUNMTR</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>cunmtr</b> <b>(character</b> <b>side,</b> <b>character</b> <b>uplo,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>complex,</b> <b>dimension(</b>
       <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>tau,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b>
       <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>CUNMTR</b>

       <b>Purpose:</b>

            CUNMTR overwrites the general complex M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            where Q is a complex unitary matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
            nq-1 elementary reflectors, as returned by CHETRD:

            if UPLO = 'U', Q = H(nq-1) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1);

            if UPLO = 'L', Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nq-1).

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U': Upper triangle of A contains elementary reflectors
                            from CHETRD;
                     = 'L': Lower triangle of A contains elementary reflectors
                            from CHETRD.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'C':  Conjugate transpose, apply Q**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension
                                          (LDA,M) if SIDE = 'L'
                                          (LDA,N) if SIDE = 'R'
                     The vectors which define the elementary reflectors, as
                     returned by CHETRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     LDA &gt;= max(1,M) if SIDE = 'L'; LDA &gt;= max(1,N) if SIDE = 'R'.

           <u>TAU</u>

                     TAU is COMPLEX array, dimension
                                          (M-1) if SIDE = 'L'
                                          (N-1) if SIDE = 'R'
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CHETRD.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and
                     LWORK &gt;=M*NB if SIDE = 'R', where NB is the optimal
                     blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dormtr</b> <b>(character</b> <b>side,</b> <b>character</b> <b>uplo,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>tau,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>DORMTR</b>

       <b>Purpose:</b>

            DORMTR overwrites the general real M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T

            where Q is a real orthogonal matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
            nq-1 elementary reflectors, as returned by DSYTRD:

            if UPLO = 'U', Q = H(nq-1) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1);

            if UPLO = 'L', Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nq-1).

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**T from the Left;
                     = 'R': apply Q or Q**T from the Right.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U': Upper triangle of A contains elementary reflectors
                            from DSYTRD;
                     = 'L': Lower triangle of A contains elementary reflectors
                            from DSYTRD.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'T':  Transpose, apply Q**T.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension
                                          (LDA,M) if SIDE = 'L'
                                          (LDA,N) if SIDE = 'R'
                     The vectors which define the elementary reflectors, as
                     returned by DSYTRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     LDA &gt;= max(1,M) if SIDE = 'L'; LDA &gt;= max(1,N) if SIDE = 'R'.

           <u>TAU</u>

                     TAU is DOUBLE PRECISION array, dimension
                                          (M-1) if SIDE = 'L'
                                          (N-1) if SIDE = 'R'
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by DSYTRD.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and
                     LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal
                     blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>sormtr</b> <b>(character</b> <b>side,</b> <b>character</b> <b>uplo,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>real,</b> <b>dimension(</b>
       <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>tau,</b> <b>real,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>SORMTR</b>

       <b>Purpose:</b>

            SORMTR overwrites the general real M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T

            where Q is a real orthogonal matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
            nq-1 elementary reflectors, as returned by SSYTRD:

            if UPLO = 'U', Q = H(nq-1) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1);

            if UPLO = 'L', Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nq-1).

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**T from the Left;
                     = 'R': apply Q or Q**T from the Right.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U': Upper triangle of A contains elementary reflectors
                            from SSYTRD;
                     = 'L': Lower triangle of A contains elementary reflectors
                            from SSYTRD.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'T':  Transpose, apply Q**T.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>A</u>

                     A is REAL array, dimension
                                          (LDA,M) if SIDE = 'L'
                                          (LDA,N) if SIDE = 'R'
                     The vectors which define the elementary reflectors, as
                     returned by SSYTRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     LDA &gt;= max(1,M) if SIDE = 'L'; LDA &gt;= max(1,N) if SIDE = 'R'.

           <u>TAU</u>

                     TAU is REAL array, dimension
                                          (M-1) if SIDE = 'L'
                                          (N-1) if SIDE = 'R'
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by SSYTRD.

           <u>C</u>

                     C is REAL array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and
                     LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal
                     blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zunmtr</b> <b>(character</b> <b>side,</b> <b>character</b> <b>uplo,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>tau,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b>
       <b>integer</b> <b>ldc,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>ZUNMTR</b>

       <b>Purpose:</b>

            ZUNMTR overwrites the general complex M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            where Q is a complex unitary matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
            nq-1 elementary reflectors, as returned by ZHETRD:

            if UPLO = 'U', Q = H(nq-1) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1);

            if UPLO = 'L', Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nq-1).

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U': Upper triangle of A contains elementary reflectors
                            from ZHETRD;
                     = 'L': Lower triangle of A contains elementary reflectors
                            from ZHETRD.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'C':  Conjugate transpose, apply Q**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension
                                          (LDA,M) if SIDE = 'L'
                                          (LDA,N) if SIDE = 'R'
                     The vectors which define the elementary reflectors, as
                     returned by ZHETRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     LDA &gt;= max(1,M) if SIDE = 'L'; LDA &gt;= max(1,N) if SIDE = 'R'.

           <u>TAU</u>

                     TAU is COMPLEX*16 array, dimension
                                          (M-1) if SIDE = 'L'
                                          (N-1) if SIDE = 'R'
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by ZHETRD.

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and
                     LWORK &gt;=M*NB if SIDE = 'R', where NB is the optimal
                     blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                               Thu Aug 7 2025 17:26:25                                    <u><a href="../man3/unmtr.3.html">unmtr</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>