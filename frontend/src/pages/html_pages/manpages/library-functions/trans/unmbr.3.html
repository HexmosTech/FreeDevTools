<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unmbr - {un,or}mbr: multiply by Q, P from gebrd</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unmbr - {un,or}mbr: multiply by Q, P from gebrd

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>cunmbr</b> (vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info)
           <b>CUNMBR</b>
       subroutine <b>dormbr</b> (vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info)
           <b>DORMBR</b>
       subroutine <b>sormbr</b> (vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info)
           <b>SORMBR</b>
       subroutine <b>zunmbr</b> (vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info)
           <b>ZUNMBR</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>cunmbr</b> <b>(character</b> <b>vect,</b> <b>character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>k,</b> <b>complex,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>tau,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b>
       <b>ldc,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>CUNMBR</b>

       <b>Purpose:</b>

            If VECT = 'Q', CUNMBR overwrites the general complex M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            If VECT = 'P', CUNMBR overwrites the general complex M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      P * C          C * P
            TRANS = 'C':      P**H * C       C * P**H

            Here Q and P**H are the unitary matrices determined by CGEBRD when
            reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
            and P**H are defined as products of elementary reflectors H(i) and
            G(i) respectively.

            Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
            order of the unitary matrix Q or P**H that is applied.

            If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
            if nq &gt;= k, Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k);
            if nq &lt; k, Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nq-1).

            If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
            if k &lt; nq, P = <a href="../man1/G.1.html">G</a>(1) <a href="../man2/G.2.html">G</a>(2) . . . G(k);
            if k &gt;= nq, P = <a href="../man1/G.1.html">G</a>(1) <a href="../man2/G.2.html">G</a>(2) . . . G(nq-1).

       <b>Parameters</b>
           <u>VECT</u>

                     VECT is CHARACTER*1
                     = 'Q': apply Q or Q**H;
                     = 'P': apply P or P**H.

           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q, Q**H, P or P**H from the Left;
                     = 'R': apply Q, Q**H, P or P**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q or P;
                     = 'C':  Conjugate transpose, apply Q**H or P**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     If VECT = 'Q', the number of columns in the original
                     matrix reduced by CGEBRD.
                     If VECT = 'P', the number of rows in the original
                     matrix reduced by CGEBRD.
                     K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension
                                           (LDA,min(nq,K)) if VECT = 'Q'
                                           (LDA,nq)        if VECT = 'P'
                     The vectors which define the elementary reflectors H(i) and
                     G(i), whose products determine the matrices Q and P, as
                     returned by CGEBRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If VECT = 'Q', LDA &gt;= max(1,nq);
                     if VECT = 'P', LDA &gt;= max(1,min(nq,K)).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (min(nq,K))
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i) or G(i) which determines Q or P, as returned
                     by CGEBRD in the array argument TAUQ or TAUP.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q
                     or P*C or P**H*C or C*P or C*P**H.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M);
                     if N = 0 or M = 0, LWORK &gt;= 1.
                     For optimum performance LWORK &gt;= max(1,N*NB) if SIDE = 'L',
                     and LWORK &gt;= max(1,M*NB) if SIDE = 'R', where NB is the
                     optimal blocksize. (NB = 0 if M = 0 or N = 0.)

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dormbr</b> <b>(character</b> <b>vect,</b> <b>character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>k,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>tau,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>DORMBR</b>

       <b>Purpose:</b>

            If VECT = 'Q', DORMBR overwrites the general real M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T

            If VECT = 'P', DORMBR overwrites the general real M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      P * C          C * P
            TRANS = 'T':      P**T * C       C * P**T

            Here Q and P**T are the orthogonal matrices determined by DGEBRD when
            reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
            P**T are defined as products of elementary reflectors H(i) and G(i)
            respectively.

            Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
            order of the orthogonal matrix Q or P**T that is applied.

            If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
            if nq &gt;= k, Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k);
            if nq &lt; k, Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nq-1).

            If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
            if k &lt; nq, P = <a href="../man1/G.1.html">G</a>(1) <a href="../man2/G.2.html">G</a>(2) . . . G(k);
            if k &gt;= nq, P = <a href="../man1/G.1.html">G</a>(1) <a href="../man2/G.2.html">G</a>(2) . . . G(nq-1).

       <b>Parameters</b>
           <u>VECT</u>

                     VECT is CHARACTER*1
                     = 'Q': apply Q or Q**T;
                     = 'P': apply P or P**T.

           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q, Q**T, P or P**T from the Left;
                     = 'R': apply Q, Q**T, P or P**T from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q  or P;
                     = 'T':  Transpose, apply Q**T or P**T.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     If VECT = 'Q', the number of columns in the original
                     matrix reduced by DGEBRD.
                     If VECT = 'P', the number of rows in the original
                     matrix reduced by DGEBRD.
                     K &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension
                                           (LDA,min(nq,K)) if VECT = 'Q'
                                           (LDA,nq)        if VECT = 'P'
                     The vectors which define the elementary reflectors H(i) and
                     G(i), whose products determine the matrices Q and P, as
                     returned by DGEBRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If VECT = 'Q', LDA &gt;= max(1,nq);
                     if VECT = 'P', LDA &gt;= max(1,min(nq,K)).

           <u>TAU</u>

                     TAU is DOUBLE PRECISION array, dimension (min(nq,K))
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i) or G(i) which determines Q or P, as returned
                     by DGEBRD in the array argument TAUQ or TAUP.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q
                     or P*C or P**T*C or C*P or C*P**T.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and
                     LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal
                     blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>sormbr</b> <b>(character</b> <b>vect,</b> <b>character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>k,</b> <b>real,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>tau,</b> <b>real,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>SORMBR</b>

       <b>Purpose:</b>

            If VECT = 'Q', SORMBR overwrites the general real M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T

            If VECT = 'P', SORMBR overwrites the general real M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      P * C          C * P
            TRANS = 'T':      P**T * C       C * P**T

            Here Q and P**T are the orthogonal matrices determined by SGEBRD when
            reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
            P**T are defined as products of elementary reflectors H(i) and G(i)
            respectively.

            Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
            order of the orthogonal matrix Q or P**T that is applied.

            If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
            if nq &gt;= k, Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k);
            if nq &lt; k, Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nq-1).

            If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
            if k &lt; nq, P = <a href="../man1/G.1.html">G</a>(1) <a href="../man2/G.2.html">G</a>(2) . . . G(k);
            if k &gt;= nq, P = <a href="../man1/G.1.html">G</a>(1) <a href="../man2/G.2.html">G</a>(2) . . . G(nq-1).

       <b>Parameters</b>
           <u>VECT</u>

                     VECT is CHARACTER*1
                     = 'Q': apply Q or Q**T;
                     = 'P': apply P or P**T.

           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q, Q**T, P or P**T from the Left;
                     = 'R': apply Q, Q**T, P or P**T from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q  or P;
                     = 'T':  Transpose, apply Q**T or P**T.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     If VECT = 'Q', the number of columns in the original
                     matrix reduced by SGEBRD.
                     If VECT = 'P', the number of rows in the original
                     matrix reduced by SGEBRD.
                     K &gt;= 0.

           <u>A</u>

                     A is REAL array, dimension
                                           (LDA,min(nq,K)) if VECT = 'Q'
                                           (LDA,nq)        if VECT = 'P'
                     The vectors which define the elementary reflectors H(i) and
                     G(i), whose products determine the matrices Q and P, as
                     returned by SGEBRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If VECT = 'Q', LDA &gt;= max(1,nq);
                     if VECT = 'P', LDA &gt;= max(1,min(nq,K)).

           <u>TAU</u>

                     TAU is REAL array, dimension (min(nq,K))
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i) or G(i) which determines Q or P, as returned
                     by SGEBRD in the array argument TAUQ or TAUP.

           <u>C</u>

                     C is REAL array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q
                     or P*C or P**T*C or C*P or C*P**T.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and
                     LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal
                     blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zunmbr</b> <b>(character</b> <b>vect,</b> <b>character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>k,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>tau,</b> <b>complex*16,</b> <b>dimension(</b>
       <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>ZUNMBR</b>

       <b>Purpose:</b>

            If VECT = 'Q', ZUNMBR overwrites the general complex M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            If VECT = 'P', ZUNMBR overwrites the general complex M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      P * C          C * P
            TRANS = 'C':      P**H * C       C * P**H

            Here Q and P**H are the unitary matrices determined by ZGEBRD when
            reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
            and P**H are defined as products of elementary reflectors H(i) and
            G(i) respectively.

            Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
            order of the unitary matrix Q or P**H that is applied.

            If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
            if nq &gt;= k, Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k);
            if nq &lt; k, Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nq-1).

            If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
            if k &lt; nq, P = <a href="../man1/G.1.html">G</a>(1) <a href="../man2/G.2.html">G</a>(2) . . . G(k);
            if k &gt;= nq, P = <a href="../man1/G.1.html">G</a>(1) <a href="../man2/G.2.html">G</a>(2) . . . G(nq-1).

       <b>Parameters</b>
           <u>VECT</u>

                     VECT is CHARACTER*1
                     = 'Q': apply Q or Q**H;
                     = 'P': apply P or P**H.

           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q, Q**H, P or P**H from the Left;
                     = 'R': apply Q, Q**H, P or P**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q or P;
                     = 'C':  Conjugate transpose, apply Q**H or P**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     If VECT = 'Q', the number of columns in the original
                     matrix reduced by ZGEBRD.
                     If VECT = 'P', the number of rows in the original
                     matrix reduced by ZGEBRD.
                     K &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension
                                           (LDA,min(nq,K)) if VECT = 'Q'
                                           (LDA,nq)        if VECT = 'P'
                     The vectors which define the elementary reflectors H(i) and
                     G(i), whose products determine the matrices Q and P, as
                     returned by ZGEBRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If VECT = 'Q', LDA &gt;= max(1,nq);
                     if VECT = 'P', LDA &gt;= max(1,min(nq,K)).

           <u>TAU</u>

                     TAU is COMPLEX*16 array, dimension (min(nq,K))
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i) or G(i) which determines Q or P, as returned
                     by ZGEBRD in the array argument TAUQ or TAUP.

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q
                     or P*C or P**H*C or C*P or C*P**H.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M);
                     if N = 0 or M = 0, LWORK &gt;= 1.
                     For optimum performance LWORK &gt;= max(1,N*NB) if SIDE = 'L',
                     and LWORK &gt;= max(1,M*NB) if SIDE = 'R', where NB is the
                     optimal blocksize. (NB = 0 if M = 0 or N = 0.)

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                               Thu Aug 7 2025 17:26:25                                    <u><a href="../man3/unmbr.3.html">unmbr</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>