<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::LinearAlgebra::Trans - Linear Algebra based transcendental functions for PDL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libpdl-linearalgebra-perl">libpdl-linearalgebra-perl_0.26-2build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::LinearAlgebra::Trans - Linear Algebra based transcendental functions for PDL

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use PDL::LinearAlgebra::Trans;

        $a = random (100,100);
        $sqrt = msqrt($a);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides some transcendental functions for matrices.  Moreover it provides sec, asec, sech,
       asech, cot, acot, acoth, coth, csc, acsc, csch, acsch. Beware, importing this module will overwrite the
       hidden PDL routine sec. If you need to call it specify its origin module : PDL::Basic::sec(args) #line 63
       "Trans.pm"

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>geexp</b>
         Signature: ([io,phys]A(n,n);int deg();scale();[io]trace();int [o]ns();int [o]info())

       Computes exp(t*A), the matrix exponential of a general matrix, using the irreducible rational Pade
       approximation to the exponential function exp(x) = r(x) = (+/-)( I + 2*(q(x)/p(x)) ), combined with
       scaling-and-squaring and optionally normalization of the trace.  The algorithm is described in Roger B.
       Sidje (rbs.uq.edu.au) "EXPOKIT: Software Package for Computing Matrix Exponentials".  ACM - Transactions
       On Mathematical Software, <a href="../man1/24.1.html">24</a>(1):130-156, 1998

            A:         On input argument matrix. On output exp(t*A).
                       Use Fortran storage type.

            deg:       the degre of the diagonal Pade to be used.
                       a value of 6 is generally satisfactory.

            scale:     time-scale (can be &lt; 0).

            trace:     on input, boolean value indicating whether or not perform
                       a trace normalization. On output value used.

            ns:        on output number of scaling-squaring used.

            info:      exit flag.
                             0 - no problem
                            &gt; 0 - Singularity in LU factorization when solving
                            Pade approximation

         = random(5,5);
         = <a href="../man1/pdl.1.html">pdl</a>(1);
        -&gt;xchg(0,1)-&gt;geexp(6,1,, ( = null), ( = null));

       geexp does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>cgeexp</b>
         Signature: ([io,phys]A(2,n,n);int deg();scale();int trace();int [o]ns();int [o]info())

       Complex version of geexp. The value used for trace normalization is not returned.  The algorithm is
       described in Roger B. Sidje (<a href="mailto:rbs@maths.uq.edu.au">rbs@maths.uq.edu.au</a>) "EXPOKIT: Software Package for Computing Matrix
       Exponentials".  ACM - Transactions On Mathematical Software, <a href="../man1/24.1.html">24</a>(1):130-156, 1998

       cgeexp does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>ctrsqrt</b>
         Signature: ([io,phys]A(2,n,n);int uplo();[phys,o] B(2,n,n);int [o]info())

       Root square of complex triangular matrix. Uses a recurrence of Bj√∂rck and Hammarling.  (See Nicholas J.
       Higham. A new sqrtm for MATLAB. Numerical Analysis Report No. 336, Manchester Centre for Computational
       Mathematics, Manchester, England, January 1999. It's available at
       <a href="http://www.ma.man.ac.uk/~higham/pap-mf.html">http://www.ma.man.ac.uk/~higham/pap-mf.html</a>) If uplo is true, A is lower triangular.

       ctrsqrt does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag
       is set for any of the input ndarrays.

   <b>ctrfun</b>
         Signature: ([io,phys]A(2,n,n);int uplo();[phys,o] B(2,n,n);int [o]info(); SV* func)

       Apply an arbitrary function to a complex triangular matrix. Uses a recurrence of Parlett.  If uplo is
       true, A is lower triangular.

       ctrfun does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>mlog</b>
       Return matrix logarithm of a square matrix.

        PDL = mlog(PDL(A))

        my $a = random(10,10);
        my $log = mlog($a);

   <b>msqrt</b>
       Return matrix square root (principal) of a square matrix.

        PDL = msqrt(PDL(A))

        my $a = random(10,10);
        my $sqrt = msqrt($a);

   <b>mexp</b>
       Return matrix exponential of a square matrix.

        PDL = mexp(PDL(A))

        my $a = random(10,10);
        my $exp = mexp($a);

   <b>mpow</b>
       Return matrix power of a square matrix.

        PDL = mpow(PDL(A), SCALAR(exponent))

        my $a = random(10,10);
        my $powered = mpow($a,2.5);

   <b>mcos</b>
       Return matrix cosine of a square matrix.

        PDL = mcos(PDL(A))

        my $a = random(10,10);
        my $cos = mcos($a);

   <b>macos</b>
       Return matrix inverse cosine of a square matrix.

        PDL = macos(PDL(A))

        my $a = random(10,10);
        my $acos = macos($a);

   <b>msin</b>
       Return matrix sine of a square matrix.

        PDL = msin(PDL(A))

        my $a = random(10,10);
        my $sin = msin($a);

   <b>masin</b>
       Return matrix inverse sine of a square matrix.

        PDL = masin(PDL(A))

        my $a = random(10,10);
        my $asin = masin($a);

   <b>mtan</b>
       Return matrix tangent of a square matrix.

        PDL = mtan(PDL(A))

        my $a = random(10,10);
        my $tan = mtan($a);

   <b>matan</b>
       Return matrix inverse tangent of a square matrix.

        PDL = matan(PDL(A))

        my $a = random(10,10);
        my $atan = matan($a);

   <b>mcot</b>
       Return matrix cotangent of a square matrix.

        PDL = mcot(PDL(A))

        my $a = random(10,10);
        my $cot = mcot($a);

   <b>macot</b>
       Return matrix inverse cotangent of a square matrix.

        PDL = macot(PDL(A))

        my $a = random(10,10);
        my $acot = macot($a);

   <b>msec</b>
       Return matrix secant of a square matrix.

        PDL = msec(PDL(A))

        my $a = random(10,10);
        my $sec = msec($a);

   <b>masec</b>
       Return matrix inverse secant of a square matrix.

        PDL = masec(PDL(A))

        my $a = random(10,10);
        my $asec = masec($a);

   <b>mcsc</b>
       Return matrix cosecant of a square matrix.

        PDL = mcsc(PDL(A))

        my $a = random(10,10);
        my $csc = mcsc($a);

   <b>macsc</b>
       Return matrix inverse cosecant of a square matrix.

        PDL = macsc(PDL(A))

        my $a = random(10,10);
        my $acsc = macsc($a);

   <b>mcosh</b>
       Return matrix hyperbolic cosine of a square matrix.

        PDL = mcosh(PDL(A))

        my $a = random(10,10);
        my $cos = mcosh($a);

   <b>macosh</b>
       Return matrix hyperbolic inverse cosine of a square matrix.

        PDL = macosh(PDL(A))

        my $a = random(10,10);
        my $acos = macosh($a);

   <b>msinh</b>
       Return matrix hyperbolic sine of a square matrix.

        PDL = msinh(PDL(A))

        my $a = random(10,10);
        my $sinh = msinh($a);

   <b>masinh</b>
       Return matrix hyperbolic inverse sine of a square matrix.

        PDL = masinh(PDL(A))

        my $a = random(10,10);
        my $asinh = masinh($a);

   <b>mtanh</b>
       Return matrix hyperbolic tangent of a square matrix.

        PDL = mtanh(PDL(A))

        my $a = random(10,10);
        my $tanh = mtanh($a);

   <b>matanh</b>
       Return matrix hyperbolic inverse tangent of a square matrix.

        PDL = matanh(PDL(A))

        my $a = random(10,10);
        my $atanh = matanh($a);

   <b>mcoth</b>
       Return matrix hyperbolic cotangent of a square matrix.

        PDL = mcoth(PDL(A))

        my $a = random(10,10);
        my $coth = mcoth($a);

   <b>macoth</b>
       Return matrix hyperbolic inverse cotangent of a square matrix.

        PDL = macoth(PDL(A))

        my $a = random(10,10);
        my $acoth = macoth($a);

   <b>msech</b>
       Return matrix hyperbolic secant of a square matrix.

        PDL = msech(PDL(A))

        my $a = random(10,10);
        my $sech = msech($a);

   <b>masech</b>
       Return matrix hyperbolic inverse secant of a square matrix.

        PDL = masech(PDL(A))

        my $a = random(10,10);
        my $asech = masech($a);

   <b>mcsch</b>
       Return matrix hyperbolic cosecant of a square matrix.

        PDL = mcsch(PDL(A))

        my $a = random(10,10);
        my $csch = mcsch($a);

   <b>macsch</b>
       Return matrix hyperbolic inverse cosecant of a square matrix.

        PDL = macsch(PDL(A))

        my $a = random(10,10);
        my $acsch = macsch($a);

   <b>mfun</b>
       Return matrix function of second argument of a square matrix.  Function will be applied on a PDL::Complex
       object.

        PDL = mfun(PDL(A),'cos')

        my $a = random(10,10);
        my $fun = mfun($a,'cos');
        sub sinbycos2{
               $_[0]-&gt;<a href="../man0/set_inplace.0.html">set_inplace</a>(0);
               $_[0] .= $_[0]-&gt;Csin/$_[0]-&gt;Ccos**2;
        }
        # Try diagonalization
        $fun = mfun($a, \&amp;sinbycos2,1);
        # Now try Schur/Parlett
        $fun = mfun($a, \&amp;sinbycos2);
        # Now with function.
        scalar msolve($a-&gt;mcos-&gt;<a href="../man2/mpow.2.html">mpow</a>(2), $a-&gt;msin);

</pre><h4><b>TODO</b></h4><pre>
       Improve error return and check singularity.  Improve (msqrt,mlog) / r2C

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) Gr√©gory Vanuxem 2005-2018.

       This library is free software; you can redistribute it and/or modify it under the terms of the Perl
       Artistic License as in the file Artistic_2 in this distribution.

perl v5.34.0                                       2022-02-06                                         <u><a href="../man3pm/Trans.3pm.html">Trans</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>