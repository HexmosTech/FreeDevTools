<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lamswlq - lamswlq: multiply by Q from laswlq</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       lamswlq - lamswlq: multiply by Q from laswlq

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>clamswlq</b> (side, trans, m, n, k, mb, nb, a, lda, t, ldt, c, ldc, work, lwork, info)
           <b>CLAMSWLQ</b>
       subroutine <b>dlamswlq</b> (side, trans, m, n, k, mb, nb, a, lda, t, ldt, c, ldc, work, lwork, info)
           <b>DLAMSWLQ</b>
       subroutine <b>slamswlq</b> (side, trans, m, n, k, mb, nb, a, lda, t, ldt, c, ldc, work, lwork, info)
           <b>SLAMSWLQ</b>
       subroutine <b>zlamswlq</b> (side, trans, m, n, k, mb, nb, a, lda, t, ldt, c, ldc, work, lwork, info)
           <b>ZLAMSWLQ</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>clamswlq</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>k,</b> <b>integer</b> <b>mb,</b> <b>integer</b>
       <b>nb,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>complex,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>t,</b> <b>integer</b> <b>ldt,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>CLAMSWLQ</b>

       <b>Purpose:</b>

               CLAMSWLQ overwrites the general complex M-by-N matrix C with

                               SIDE = 'L'     SIDE = 'R'
               TRANS = 'N':      Q * C          C * Q
               TRANS = 'T':      Q**H * C       C * Q**H
               where Q is a complex unitary matrix defined as the product of blocked
               elementary reflectors computed by short wide LQ
               factorization (CLASWLQ)

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'C':  Conjugate transpose, apply Q**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.  M &gt;=0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.
                     M &gt;= K &gt;= 0;

           <u>MB</u>

                     MB is INTEGER
                     The row block size to be used in the blocked LQ.
                     M &gt;= MB &gt;= 1

           <u>NB</u>

                     NB is INTEGER
                     The column block size to be used in the blocked LQ.
                     NB &gt; M.

           <u>A</u>

                     A is COMPLEX array, dimension
                                          (LDA,M) if SIDE = 'L',
                                          (LDA,N) if SIDE = 'R'
                     The i-th row must contain the vector which defines the blocked
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     CLASWLQ in the first k rows of its array argument A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA =&gt; max(1,K).

           <u>T</u>

                     T is COMPLEX array, dimension
                     ( M * Number of blocks(CEIL(N-K/NB-K)),
                     The blocked upper triangular block reflectors stored in compact form
                     as a sequence of upper triangular blocks.  See below
                     for further details.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= MB.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     (workspace) COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the minimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If MIN(M,N,K) = 0, LWORK &gt;= 1.
                     If SIDE = 'L', LWORK &gt;= max(1,NB*MB).
                     If SIDE = 'R', LWORK &gt;= max(1,M*MB).

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the minimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

            Short-Wide LQ (SWLQ) performs LQ by a sequence of unitary transformations,
            representing Q as a product of other unitary matrices
              Q = <a href="../man1/Q.1.html">Q</a>(1) * <a href="../man2/Q.2.html">Q</a>(2) * . . . * Q(k)
            where each Q(i) zeros out upper diagonal entries of a block of NB rows of A:
              <a href="../man1/Q.1.html">Q</a>(1) zeros out the upper diagonal entries of rows 1:NB of A
              <a href="../man2/Q.2.html">Q</a>(2) zeros out the bottom MB-N rows of rows [1:M,NB+1:2*NB-M] of A
              <a href="../man3/Q.3.html">Q</a>(3) zeros out the bottom MB-N rows of rows [1:M,2*NB-M+1:3*NB-2*M] of A
              . . .

            <a href="../man1/Q.1.html">Q</a>(1) is computed by GELQT, which represents <a href="../man1/Q.1.html">Q</a>(1) by Householder vectors
            stored under the diagonal of rows 1:MB of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,1:N).
            For more information see Further Details in GELQT.

            Q(i) for i&gt;1 is computed by TPLQT, which represents Q(i) by Householder vectors
            stored in columns [(i-1)*(NB-M)+M+1:i*(NB-M)+M] of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,(i-1)*M+1:i*M).
            The last Q(k) may use fewer rows.
            For more information see Further Details in TPLQT.

            For more details of the overall algorithm, see the description of
            Sequential TSQR in Section 2.2 of [1].

            [1] “Communication-Optimal Parallel and Sequential QR and LU Factorizations,”
                J. Demmel, L. Grigori, M. Hoemmen, J. Langou,
                SIAM J. Sci. Comput, vol. 34, no. 1, 2012

   <b>subroutine</b> <b>dlamswlq</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>k,</b> <b>integer</b> <b>mb,</b> <b>integer</b>
       <b>nb,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>t,</b>
       <b>integer</b> <b>ldt,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b>
       <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>DLAMSWLQ</b>

       <b>Purpose:</b>

               DLAMSWLQ overwrites the general real M-by-N matrix C with

                               SIDE = 'L'     SIDE = 'R'
               TRANS = 'N':      Q * C          C * Q
               TRANS = 'T':      Q**T * C       C * Q**T
               where Q is a real orthogonal matrix defined as the product of blocked
               elementary reflectors computed by short wide LQ
               factorization (DLASWLQ)

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**T from the Left;
                     = 'R': apply Q or Q**T from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'T':  Transpose, apply Q**T.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.  M &gt;=0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.
                     M &gt;= K &gt;= 0;

           <u>MB</u>

                     MB is INTEGER
                     The row block size to be used in the blocked LQ.
                     M &gt;= MB &gt;= 1

           <u>NB</u>

                     NB is INTEGER
                     The column block size to be used in the blocked LQ.
                     NB &gt; M.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension
                                          (LDA,M) if SIDE = 'L',
                                          (LDA,N) if SIDE = 'R'
                     The i-th row must contain the vector which defines the blocked
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     DLASWLQ in the first k rows of its array argument A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,K).

           <u>T</u>

                     T is DOUBLE PRECISION array, dimension
                     ( M * Number of blocks(CEIL(N-K/NB-K)),
                     The blocked upper triangular block reflectors stored in compact form
                     as a sequence of upper triangular blocks.  See below
                     for further details.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= MB.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the minimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.

                     If MIN(M,N,K) = 0, LWORK &gt;= 1.
                     If SIDE = 'L', LWORK &gt;= max(1,NB*MB).
                     If SIDE = 'R', LWORK &gt;= max(1,M*MB).
                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the minimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

            Short-Wide LQ (SWLQ) performs LQ by a sequence of orthogonal transformations,
            representing Q as a product of other orthogonal matrices
              Q = <a href="../man1/Q.1.html">Q</a>(1) * <a href="../man2/Q.2.html">Q</a>(2) * . . . * Q(k)
            where each Q(i) zeros out upper diagonal entries of a block of NB rows of A:
              <a href="../man1/Q.1.html">Q</a>(1) zeros out the upper diagonal entries of rows 1:NB of A
              <a href="../man2/Q.2.html">Q</a>(2) zeros out the bottom MB-N rows of rows [1:M,NB+1:2*NB-M] of A
              <a href="../man3/Q.3.html">Q</a>(3) zeros out the bottom MB-N rows of rows [1:M,2*NB-M+1:3*NB-2*M] of A
              . . .

            <a href="../man1/Q.1.html">Q</a>(1) is computed by GELQT, which represents <a href="../man1/Q.1.html">Q</a>(1) by Householder vectors
            stored under the diagonal of rows 1:MB of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,1:N).
            For more information see Further Details in GELQT.

            Q(i) for i&gt;1 is computed by TPLQT, which represents Q(i) by Householder vectors
            stored in columns [(i-1)*(NB-M)+M+1:i*(NB-M)+M] of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,(i-1)*M+1:i*M).
            The last Q(k) may use fewer rows.
            For more information see Further Details in TPLQT.

            For more details of the overall algorithm, see the description of
            Sequential TSQR in Section 2.2 of [1].

            [1] “Communication-Optimal Parallel and Sequential QR and LU Factorizations,”
                J. Demmel, L. Grigori, M. Hoemmen, J. Langou,
                SIAM J. Sci. Comput, vol. 34, no. 1, 2012

   <b>subroutine</b> <b>slamswlq</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>k,</b> <b>integer</b> <b>mb,</b> <b>integer</b>
       <b>nb,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>real,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>t,</b> <b>integer</b> <b>ldt,</b> <b>real,</b> <b>dimension(</b>
       <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>SLAMSWLQ</b>

       <b>Purpose:</b>

               SLAMSWLQ overwrites the general real M-by-N matrix C with

                               SIDE = 'L'     SIDE = 'R'
               TRANS = 'N':      Q * C          C * Q
               TRANS = 'T':      Q**T * C       C * Q**T
               where Q is a real orthogonal matrix defined as the product of blocked
               elementary reflectors computed by short wide LQ
               factorization (SLASWLQ)

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**T from the Left;
                     = 'R': apply Q or Q**T from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'T':  Transpose, apply Q**T.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.  M &gt;=0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.
                     M &gt;= K &gt;= 0;

           <u>MB</u>

                     MB is INTEGER
                     The row block size to be used in the blocked LQ.
                     M &gt;= MB &gt;= 1

           <u>NB</u>

                     NB is INTEGER
                     The column block size to be used in the blocked LQ.
                     NB &gt; M.

           <u>A</u>

                     A is REAL array, dimension
                                          (LDA,M) if SIDE = 'L',
                                          (LDA,N) if SIDE = 'R'
                     The i-th row must contain the vector which defines the blocked
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     SLASWLQ in the first k rows of its array argument A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,K).

           <u>T</u>

                     T is REAL array, dimension
                     ( M * Number of blocks(CEIL(N-K/NB-K)),
                     The blocked upper triangular block reflectors stored in compact form
                     as a sequence of upper triangular blocks.  See below
                     for further details.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= MB.

           <u>C</u>

                     C is REAL array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     (workspace) REAL array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the minimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.

                     If MIN(M,N,K) = 0, LWORK &gt;= 1.
                     If SIDE = 'L', LWORK &gt;= max(1,NB*MB).
                     If SIDE = 'R', LWORK &gt;= max(1,M*MB).
                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the minimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

            Short-Wide LQ (SWLQ) performs LQ by a sequence of orthogonal transformations,
            representing Q as a product of other orthogonal matrices
              Q = <a href="../man1/Q.1.html">Q</a>(1) * <a href="../man2/Q.2.html">Q</a>(2) * . . . * Q(k)
            where each Q(i) zeros out upper diagonal entries of a block of NB rows of A:
              <a href="../man1/Q.1.html">Q</a>(1) zeros out the upper diagonal entries of rows 1:NB of A
              <a href="../man2/Q.2.html">Q</a>(2) zeros out the bottom MB-N rows of rows [1:M,NB+1:2*NB-M] of A
              <a href="../man3/Q.3.html">Q</a>(3) zeros out the bottom MB-N rows of rows [1:M,2*NB-M+1:3*NB-2*M] of A
              . . .

            <a href="../man1/Q.1.html">Q</a>(1) is computed by GELQT, which represents <a href="../man1/Q.1.html">Q</a>(1) by Householder vectors
            stored under the diagonal of rows 1:MB of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,1:N).
            For more information see Further Details in GELQT.

            Q(i) for i&gt;1 is computed by TPLQT, which represents Q(i) by Householder vectors
            stored in columns [(i-1)*(NB-M)+M+1:i*(NB-M)+M] of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,(i-1)*M+1:i*M).
            The last Q(k) may use fewer rows.
            For more information see Further Details in TPLQT.

            For more details of the overall algorithm, see the description of
            Sequential TSQR in Section 2.2 of [1].

            [1] “Communication-Optimal Parallel and Sequential QR and LU Factorizations,”
                J. Demmel, L. Grigori, M. Hoemmen, J. Langou,
                SIAM J. Sci. Comput, vol. 34, no. 1, 2012

   <b>subroutine</b> <b>zlamswlq</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>k,</b> <b>integer</b> <b>mb,</b> <b>integer</b>
       <b>nb,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>t,</b> <b>integer</b> <b>ldt,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b>
       <b>info)</b>
       <b>ZLAMSWLQ</b>

       <b>Purpose:</b>

               ZLAMSWLQ overwrites the general complex M-by-N matrix C with

                               SIDE = 'L'     SIDE = 'R'
               TRANS = 'N':      Q * C          C * Q
               TRANS = 'C':      Q**H * C       C * Q**H
               where Q is a complex unitary matrix defined as the product of blocked
               elementary reflectors computed by short wide LQ
               factorization (ZLASWLQ)

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'C':  Conjugate Transpose, apply Q**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.  M &gt;=0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.
                     M &gt;= K &gt;= 0;

           <u>MB</u>

                     MB is INTEGER
                     The row block size to be used in the blocked LQ.
                     M &gt;= MB &gt;= 1

           <u>NB</u>

                     NB is INTEGER
                     The column block size to be used in the blocked LQ.
                     NB &gt; M.

           <u>A</u>

                     A is COMPLEX*16 array, dimension
                                          (LDA,M) if SIDE = 'L',
                                          (LDA,N) if SIDE = 'R'
                     The i-th row must contain the vector which defines the blocked
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     ZLASWLQ in the first k rows of its array argument A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= MAX(1,K).

           <u>T</u>

                     T is COMPLEX*16 array, dimension
                     ( M * Number of blocks(CEIL(N-K/NB-K)),
                     The blocked upper triangular block reflectors stored in compact form
                     as a sequence of upper triangular blocks.  See below
                     for further details.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= MB.

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     (workspace) COMPLEX*16 array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the minimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If MIN(M,N,K) = 0, LWORK &gt;= 1.
                     If SIDE = 'L', LWORK &gt;= max(1,NB*MB).
                     If SIDE = 'R', LWORK &gt;= max(1,M*MB).

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the minimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

            Short-Wide LQ (SWLQ) performs LQ by a sequence of unitary transformations,
            representing Q as a product of other unitary matrices
              Q = <a href="../man1/Q.1.html">Q</a>(1) * <a href="../man2/Q.2.html">Q</a>(2) * . . . * Q(k)
            where each Q(i) zeros out upper diagonal entries of a block of NB rows of A:
              <a href="../man1/Q.1.html">Q</a>(1) zeros out the upper diagonal entries of rows 1:NB of A
              <a href="../man2/Q.2.html">Q</a>(2) zeros out the bottom MB-N rows of rows [1:M,NB+1:2*NB-M] of A
              <a href="../man3/Q.3.html">Q</a>(3) zeros out the bottom MB-N rows of rows [1:M,2*NB-M+1:3*NB-2*M] of A
              . . .

            <a href="../man1/Q.1.html">Q</a>(1) is computed by GELQT, which represents <a href="../man1/Q.1.html">Q</a>(1) by Householder vectors
            stored under the diagonal of rows 1:MB of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,1:N).
            For more information see Further Details in GELQT.

            Q(i) for i&gt;1 is computed by TPLQT, which represents Q(i) by Householder vectors
            stored in columns [(i-1)*(NB-M)+M+1:i*(NB-M)+M] of A, and by upper triangular
            block reflectors, stored in array T(1:LDT,(i-1)*M+1:i*M).
            The last Q(k) may use fewer rows.
            For more information see Further Details in TPLQT.

            For more details of the overall algorithm, see the description of
            Sequential TSQR in Section 2.2 of [1].

            [1] “Communication-Optimal Parallel and Sequential QR and LU Factorizations,”
                J. Demmel, L. Grigori, M. Hoemmen, J. Langou,
                SIAM J. Sci. Comput, vol. 34, no. 1, 2012

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                               Thu Aug 7 2025 17:26:25                                  <u><a href="../man3/lamswlq.3.html">lamswlq</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>