<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>release_handler - Unpacking and Installation of Release Packages</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       release_handler - Unpacking and Installation of Release Packages

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>release</u>  <u>handler</u> process belongs to the SASL application, which is responsible for <u>release</u> <u>handling</u>,
       that is, unpacking, installation, and removal of release packages.

       An introduction to release handling and an example  is  provided  in  OTP  Design  Principles  in  <u>System</u>
       <u>Documentation</u>.

       A <u>release</u> <u>package</u> is a compressed tar file containing code for a certain version of a release, created by
       calling  <u>systools:make_tar/1,2</u>.  The  release package is to be located in the <u>$ROOT/releases</u> directory of
       the previous version of the release, where <u>$ROOT</u> is the  installation  root  directory,  <u>code:root_dir()</u>.
       Another <u>releases</u> directory can be specified using the SASL configuration parameter <u>releases_dir</u> or the OS
       environment  variable <u>RELDIR</u>. The release handler must have write access to this directory to install the
       new release. The persistent state of the release handler is stored there in a file called <u>RELEASES</u>.

       A release package is always to contain:

         * A release resource file, <u>Name.rel</u>

         * A boot script, <u>Name.boot</u>

       The <u>.rel</u> file contains information about the release: its name, version, and which ERTS  and  application
       versions it uses.

       A release package can also contain:

         * A release upgrade file, <u>relup</u>

         * A system configuration file, <u>sys.config</u>

         * A system configuration source file, <u>sys.config.src</u>

       The  <u>relup</u>  file  contains  instructions  for  how  to upgrade to, or downgrade from, this version of the
       release.

       The release package can be <u>unpacked</u>, which extracts the files. An unpacked release can be <u>installed</u>.  The
       currently  used  version  of  the  release  is  then  upgraded  or downgraded to the specified version by
       evaluating the instructions in the <u>relup</u> file. An installed release  can  be  made  <u>permanent</u>.  Only  one
       permanent  release  can  exist  in  the  system,  and this release is used if the system is restarted. An
       installed release, except the permanent one, can be  <u>removed</u>.  When  a  release  is  removed,  all  files
       belonging to that release only are deleted.

       Each release version has a status, which can be <u>unpacked</u>, <u>current</u>, <u>permanent</u>, or <u>old</u>. There is always one
       latest  release,  which either has status <u>permanent</u> (normal case) or <u>current</u> (installed, but not yet made
       permanent). The meaning of the status values are illustrated in the following table:

               Status     Action                NextStatus
               -------------------------------------------
               -          unpack                unpacked
               unpacked   install               current
                          remove                -
               current    make_permanent        permanent
                          install other         old
                          remove                -
               permanent  make other permanent  old
                          install               permanent
               old        reboot_old            permanent
                          install               current
                          remove                -

       The release handler process is a locally registered process on each node. When a release is installed  in
       a  distributed  system,  the release handler on each node must be called. The release installation can be
       synchronized between nodes. From an operator view, it can be unsatisfactory to specify each node. The aim
       is to install one release package in the system, no matter how many nodes there are.  It  is  recommended
       that  software  management functions are written that take care of this problem. Such a function can have
       knowledge of the system architecture, so it can contact each individual release handler  to  install  the
       package.

       For  release handling to work properly, the runtime system must know which release it is running. It must
       also be able to change (in runtime) which boot script and system configuration file are to be used if the
       system is restarted. This is taken care of automatically if Erlang is started as an embedded system. Read
       about this in Embedded System in <u>System</u> <u>Documentation</u>.  In  this  case,  the  system  configuration  file
       <u>sys.config</u> is mandatory.

       The  installation  of a new release can restart the system. Which program to use is specified by the SASL
       configuration parameter <u>start_prg</u>, which defaults to <u>$ROOT/bin/start</u>.

       The emulator restart on Windows NT expects that the system is started using  the  <u>erlsrv</u>  program  (as  a
       service).  Furthermore,  the  release  handler  expects that the service is named <u>NodeName</u>_<u>Release</u>, where
       <u>NodeName</u> is the first part of the Erlang node name (up to, but not including the "@") and <u>Release</u> is  the
       current  release  version.  The  release handler furthermore expects that a program like <u>start_erl.exe</u> is
       specified as "machine" to <u>erlsrv</u>. During upgrading with restart, a new service is registered and started.
       The new service is set to automatic and the  old  service  is  removed  when  the  new  release  is  made
       permanent.

       The  release  handler  at  a node running on a diskless machine, or with a read-only file system, must be
       configured accordingly using the following SASL configuration parameters (for details, see <a href="../man7/sasl.7.html">sasl</a>(7)):

         <u>masters</u>:
           This node uses some master nodes to store and fetch release information. All  master  nodes  must  be
           operational whenever release information is written by this node.

         <u>client_directory</u>:
           The <u>client_directory</u> in the directory structure of the master nodes must be specified.

         <u>static_emulator</u>:
           This  parameter  specifies  if the Erlang emulator is statically installed at the client node. A node
           with a static emulator cannot dynamically switch to a new  emulator,  as  the  executable  files  are
           statically written into memory.

       The release handler can also be used to unpack and install release packages when not running Erlang as an
       embedded  system.  However,  in  this  case  the  user  must somehow ensure that correct boot scripts and
       configuration files are used if the system must be restarted.

       Functions are provided for using another  file  structure  than  the  structure  defined  in  OTP.  These
       functions can be used to test a release upgrade locally.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>check_install_release(Vsn)</b> <b>-&gt;</b> <b>{ok,</b> <b>OtherVsn,</b> <b>Descr}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>check_install_release(Vsn,Opts)</b> <b>-&gt;</b> <b>{ok,</b> <b>OtherVsn,</b> <b>Descr}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Vsn = OtherVsn = string()
                 Opts = [Opt]
                 Opt = purge
                 Descr = term()
                 Reason = term()

              Checks  if  the  specified  version <u>Vsn</u> of the release can be installed. The release must not have
              status <u>current</u>. Issues warnings if <u>relup</u> file or <u>sys.config</u> is  not  present.  If  <u>relup</u>  file  is
              present, its contents are checked and <u>{error,Reason}</u> is returned if an error is found. Also checks
              that  all required applications are present and that all new code can be loaded; <u>{error,Reason}</u> is
              returned if an error is found.

              Evaluates all instructions that occur before the <u>point_of_no_return</u>  instruction  in  the  release
              upgrade script.

              Returns the same as <u>install_release/1</u>. <u>Descr</u> defaults to "" if no <u>relup</u> file is found.

              If  option  <u>purge</u>  is  specified,  all  old code that can be soft-purged is purged after all other
              checks  are  successfully  completed.  This  can  be  useful  to  reduce  the   time   needed   by
              <u>install_release/1</u>.

       <b>create_RELEASES(Root,</b> <b>RelDir,</b> <b>RelFile,</b> <b>AppDirs)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Root = RelDir = RelFile = string()
                 AppDirs = [{App, Vsn, Dir}]
                  App = atom()
                  Vsn = Dir = string()
                 Reason = term()

              Creates  an  initial  <u>RELEASES</u>  file  to  be  used by the release handler. This file must exist to
              install new releases.

              <u>Root</u> is the root of the installation (<u>$ROOT</u>) as described earlier. <u>RelDir</u> is the  directory  where
              the <u>RELEASES</u> file is to be created (normally <u>$ROOT/releases</u>). <u>RelFile</u> is the name of the <u>.rel</u> file
              that describes the initial release, including the extension <u>.rel</u>.

              <u>AppDirs</u>  can  be  used  to specify from where the modules for the specified applications are to be
              loaded. <u>App</u> is the name of an application, <u>Vsn</u> is  the  version,  and  <u>Dir</u>  is  the  name  of  the
              directory  where  <u>App-Vsn</u>  is  located. The corresponding modules are to be located under <u>Dir/App-</u>
              <u>Vsn/ebin</u>. The directories for applications not specified in <u>AppDirs</u> are assumed to be  located  in
              <u>$ROOT/lib</u>.

       <b>install_file(Vsn,</b> <b>File)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Vsn = File = string()
                 Reason = term()

              Installs  a release-dependent file in the release structure. The release-dependent file must be in
              the release structure when a new release is installed: <u>start.boot</u>, <u>relup</u>, and <u>sys.config</u>.

              The function can be called, for example, when  these  files  are  generated  at  the  target.  The
              function is to be called after <u>set_unpacked/2</u> has been called.

       <b>install_release(Vsn)</b> <b>-&gt;</b> <b>{ok,</b> <b>OtherVsn,</b> <b>Descr}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>install_release(Vsn,</b>  <b>[Opt])</b>  <b>-&gt;</b>  <b>{ok,</b>  <b>OtherVsn,</b>  <b>Descr}</b>  <b>|</b>  <b>{continue_after_restart,</b> <b>OtherVsn,</b> <b>Descr}</b> <b>|</b>
       <b>{error,</b> <b>Reason}</b>

              Types:

                 Vsn = OtherVsn = string()
                 Opt = {error_action, Action} | {code_change_timeout, Timeout}
                  | {suspend_timeout, Timeout} | {update_paths, Bool}
                  Action = restart | reboot
                  Timeout = default | infinity | pos_integer()
                  Bool = boolean()
                 Descr = term()
                 Reason = {illegal_option, Opt}  |  {already_installed,  Vsn}  |  {change_appl_data,  term()}  |
                 {missing_base_app, OtherVsn, App} | {could_not_create_hybrid_boot, term()} | term()
                 App = atom()

              Installs  the  specified  version  <u>Vsn</u>  of the release. Looks first for a <u>relup</u> file for <u>Vsn</u> and a
              script <u>{UpFromVsn,Descr1,Instructions1}</u> in this file for upgrading from the  current  version.  If
              not  found,  the  function  looks  for  a  <u>relup</u>  file  for  the  current  version  and  a  script
              <u>{Vsn,Descr2,Instructions2}</u> in this file for downgrading to <u>Vsn</u>.

              If a script is found, the first thing that happens is  that  the  application  specifications  are
              updated according to the <u>.app</u> files and <u>sys.config</u> belonging to the release version <u>Vsn</u>.

              After  the  application  specifications  have  been  updated,  the  instructions in the script are
              evaluated and the function returns <u>{ok,OtherVsn,Descr}</u> if successful. <u>OtherVsn</u> and <u>Descr</u>  are  the
              version (<u>UpFromVsn</u> or <u>Vsn</u>) and description (<u>Descr1</u> or <u>Descr2</u>) as specified in the script.

              If  <u>{continue_after_restart,OtherVsn,Descr}</u>  is  returned,  the  emulator  is restarted before the
              upgrade instructions are executed. This occurs if the emulator or any of the applications  Kernel,
              STDLIB,  or  SASL  are updated. The new emulator version and these core applications execute after
              the restart. For all other applications the old versions are started and the upgrade is  performed
              as normal by executing the upgrade instructions.

              If  a  recoverable  error occurs, the function returns <u>{error,Reason}</u> and the original application
              specifications are restored. If a non-recoverable error occurs, the system is restarted.

              <u>Options</u>:

                <u>error_action</u>:
                  Defines if the node is to be restarted (<u>init:restart()</u>) or rebooted (<u>init:reboot()</u>)  if  there
                  is an error during the installation. Default is <u>restart</u>.

                <u>code_change_timeout</u>:
                  Defines  the time-out for all calls to <u>sys:change_code</u>. If no value is specified or <u>default</u> is
                  specified, the default value defined in <u>sys</u> is used.

                <u>suspend_timeout</u>:
                  Defines the time-out for all calls to <u>sys:suspend</u>.  If  no  value  is  specified,  the  values
                  defined  by  the <u>Timeout</u> parameter of the <u>upgrade</u> or <u>suspend</u> instructions are used. If <u>default</u>
                  is specified, the default value defined in <u>sys</u> is used.

                <u>{update_paths,Bool}</u>:
                  Indicates if all application code paths are to be updated (<u>Bool==true</u>) or if only  code  paths
                  for  modified  applications  are  to  be  updated (<u>Bool==false</u>, default). This option has only
                  effect for  other  application  directories  than  the  default  <u>$ROOT/lib/App-Vsn</u>,  that  is,
                  application  directories  specified  in  argument  <u>AppDirs</u>  in  a call to <u>create_RELEASES/4</u> or
                  <u>set_unpacked/2</u>.

                  <u>Example:</u>

                  In  the  current  version  <u>CurVsn</u>  of  a  release,  the  application  directory  of  <u>myapp</u>  is
                  <u>$ROOT/lib/myapp-1.0</u>.  A  new  version  <u>NewVsn</u>  is unpacked outside the release handler and the
                  release handler is informed about this with a call as follows:

                release_handler:set_unpacked(RelFile, [{myapp,"1.0","/home/user"},...]).
                =&gt; {ok,NewVsn}

                  If <u>NewVsn</u> is installed  with  option  <u>{update_paths,true}</u>,  then  <u>code:<a href="../manmyapp/lib_dir.myapp.html">lib_dir</a>(myapp)</u>  returns
                  <u>/home/user/myapp-1.0</u>.

          <b>Note:</b>
              Installing  a  new  release  can  be time consuming if there are many processes in the system. The
              reason is that each process must be checked for references to old code  before  a  module  can  be
              purged. This check can lead to garbage collections and copying of data.

              To  speed  up  the  execution  of  <u>install_release</u>, first call <u>check_install_release</u>, using option
              <u>purge</u>. This does the same check for old code. Then purges all modules that can be soft-purged. The
              purged modules do then no longer have any old code, and <u>install_release</u> does not need  to  do  the
              checks.

              This  does  not  reduce  the  overall  time  for the upgrade, but it allows checks and purge to be
              executed in the background before the real upgrade is started.

          <b>Note:</b>
              When upgrading the emulator from a version older than OTP R15, an attempt  is  made  to  load  new
              application  beam  code into the old emulator. Sometimes the new beam format cannot be read by the
              old emulator, so the code loading fails and the complete upgrade is terminated. To  overcome  this
              problem,  the  new  application code is to be compiled with the old emulator. For more information
              about emulator upgrade from pre OTP R15 versions, see Design Principles in <u>System</u> <u>Documentation</u>.

       <b>make_permanent(Vsn)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Vsn = string()
                 Reason = {bad_status, Status} | term()

              Makes the specified release version <u>Vsn</u> permanent.

       <b>remove_release(Vsn)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Vsn = string()
                 Reason = {permanent, Vsn} | client_node | term()

              Removes a release and its files from the system. The release must not be  the  permanent  release.
              Removes only the files and directories not in use by another release.

       <b>reboot_old_release(Vsn)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Vsn = string()
                 Reason = {bad_status, Status} | term()

              Reboots  the  system  by  making  the old release permanent, and calls <u>init:reboot()</u> directly. The
              release must have status <u>old</u>.

       <b>set_removed(Vsn)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Vsn = string()
                 Reason = {permanent, Vsn} | term()

              Makes it possible to handle removal of releases outside the release  handler.  Tells  the  release
              handler that the release is removed from the system. This function does not delete any files.

       <b>set_unpacked(RelFile,</b> <b>AppDirs)</b> <b>-&gt;</b> <b>{ok,</b> <b>Vsn}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 RelFile = string()
                 AppDirs = [{App, Vsn, Dir}]
                  App = atom()
                  Vsn = Dir = string()
                 Reason = term()

              Makes  it  possible to handle unpacking of releases outside the release handler. Tells the release
              handler that the release is unpacked. <u>Vsn</u> is extracted from the release resource file <u>RelFile</u>.

              <u>AppDirs</u> can be used to specify from where the modules for the specified  applications  are  to  be
              loaded.  <u>App</u>  is  the  name  of  an  application,  <u>Vsn</u>  is the version, and <u>Dir</u> is the name of the
              directory where <u>App-Vsn</u> is located. The corresponding modules are to  be  located  under  <u>Dir/App-</u>
              <u>Vsn/ebin</u>.  The  directories for applications not specified in <u>AppDirs</u> are assumed to be located in
              <u>$ROOT/lib</u>.

       <b>unpack_release(Name)</b> <b>-&gt;</b> <b>{ok,</b> <b>Vsn}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = Vsn = string()
                 Reason = client_node | term()

              Unpacks a release package <u>Name.tar.gz</u> located in the <u>releases</u> directory.

              Performs some checks on the package, for example, checks that all mandatory files are present, and
              extracts its contents.

       <b>which_releases()</b> <b>-&gt;</b> <b>[{Name,</b> <b>Vsn,</b> <b>Apps,</b> <b>Status}]</b>

              Types:

                 Name = Vsn = string()
                 Apps = ["App-Vsn"]
                 Status = unpacked | current | permanent | old

              Returns all releases known to the release handler.

       <b>which_releases(Status)</b> <b>-&gt;</b> <b>[{Name,</b> <b>Vsn,</b> <b>Apps,</b> <b>Status}]</b>

              Types:

                 Name = Vsn = string()
                 Apps = ["App-Vsn"]
                 Status = unpacked | current | permanent | old

              Returns all releases, known to the release handler, of a specific status.

</pre><h4><b>APPLICATION</b> <b>UPGRADE/DOWNGRADE</b></h4><pre>
       The following functions can be used to test upgrade and downgrade  of  single  applications  (instead  of
       upgrading/downgrading an entire release). A script corresponding to the instructions in the <u>relup</u> file is
       created  on-the-fly,  based on the <u>.appup</u> file for the application, and evaluated exactly in the same way
       as <u>release_handler</u> does.

   <b>Warning:</b>
       These functions are primarily intended for simplified testing of <u>.appup</u> files. They are  not  run  within
       the  context  of  the  <u>release_handler</u>  process.  They  must therefore <u>not</u> be used together with calls to
       <u>install_release/1,2</u>, as this causes the <u>release_handler</u> to end up in an inconsistent state.

       No persistent information is updated, so these functions can be used on any Erlang node, embedded or not.
       Also, using these functions does not affect which code is loaded if there is a reboot.

       If the upgrade or downgrade fails, the application can end up in an inconsistent state.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>upgrade_app(App,</b> <b>Dir)</b> <b>-&gt;</b> <b>{ok,</b> <b>Unpurged}</b> <b>|</b> <b>restart_emulator</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 App = atom()
                 Dir = string()
                 Unpurged = [Module]
                  Module = atom()
                 Reason = term()

              Upgrades an application <u>App</u> from the current version to a new version located in <u>Dir</u> according  to
              the <u>.appup</u> file.

              <u>App</u>  is  the  name  of the application, which must be started. <u>Dir</u> is the new library directory of
              <u>App</u>. The corresponding modules as well as the <u>.app</u> and  <u>.appup</u>  files  are  to  be  located  under
              <u>Dir/ebin</u>.

              The function looks in the <u>.appup</u> file and tries to find an upgrade script from the current version
              of  the  application  using  <u>upgrade_script/2</u>. This script is evaluated using <u>eval_appup_script/4</u>,
              exactly in the same way as <u>install_release/1,2</u> does.

              Returns one of the following:

                * <u>{ok,</u> <u>Unpurged}</u> if evaluating the script is successful, where <u>Unpurged</u> is a  list  of  unpurged
                  modules

                * <u>restart_emulator</u> if this instruction is encountered in the script

                * <u>{error,</u> <u>Reason}</u> if an error occurred when finding or evaluating the script

              If   the   <u>restart_new_emulator</u>   instruction  is  found  in  the  script,  <u>upgrade_app/2</u>  returns
              <u>{error,restart_new_emulator}</u>. This because <u>restart_new_emulator</u> requires  a  new  version  of  the
              emulator  to  be started before the rest of the upgrade instructions can be executed, and this can
              only be done by <u>install_release/1,2</u>.

       <b>downgrade_app(App,</b> <b>Dir)</b> <b>-&gt;</b>
       <b>downgrade_app(App,</b> <b>OldVsn,</b> <b>Dir)</b> <b>-&gt;</b> <b>{ok,</b> <b>Unpurged}</b> <b>|</b> <b>restart_emulator</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 App = atom()
                 Dir = OldVsn = string()
                 Unpurged = [Module]
                  Module = atom()
                 Reason = term()

              Downgrades an application <u>App</u> from the current version to a previous version <u>OldVsn</u> located in <u>Dir</u>
              according to the <u>.appup</u> file.

              <u>App</u> is the name of the application, which must be started.  <u>OldVsn</u>  is  the  previous  application
              version  and  can be omitted if <u>Dir</u> is of the format <u>"App-OldVsn"</u>. <u>Dir</u> is the library directory of
              the previous version of <u>App</u>. The corresponding modules and the old <u>.app</u> file  are  to  be  located
              under  <u>Dir/ebin</u>.  The  <u>.appup</u>  file  is to be located in the <u>ebin</u> directory of the <u>current</u> library
              directory of the application (<u>code:lib_dir(App)</u>).

              The function looks in the <u>.appup</u> file and tries to find a downgrade script to the previous version
              of the application using <u>downgrade_script/3</u>. This script is evaluated  using  <u>eval_appup_script/4</u>,
              exactly in the same way as <u>install_release/1,2</u> does.

              Returns one of the following:

                * <u>{ok,</u>  <u>Unpurged}</u>  if  evaluating the script is successful, where <u>Unpurged</u> is a list of unpurged
                  modules

                * <u>restart_emulator</u> if this instruction is encountered in the script

                * <u>{error,</u> <u>Reason}</u> if an error occurred when finding or evaluating the script

       <b>upgrade_script(App,</b> <b>Dir)</b> <b>-&gt;</b> <b>{ok,</b> <b>NewVsn,</b> <b>Script}</b>

              Types:

                 App = atom()
                 Dir = string()
                 NewVsn = string()
                 Script = Instructions

              Tries to find an application upgrade script for <u>App</u> from the current  version  to  a  new  version
              located in <u>Dir</u>.

              The  upgrade  script  can  then  be  evaluated using <u>eval_appup_script/4</u>. It is recommended to use
              <u>upgrade_app/2</u> instead, but this function (<u>upgrade_script</u>) is useful to inspect the contents of the
              script.

              <u>App</u> is the name of the application, which must be started. <u>Dir</u> is the  new  library  directory  of
              <u>App</u>.  The  corresponding  modules  as  well  as  the <u>.app</u> and <u>.appup</u> files are to be located under
              <u>Dir/ebin</u>.

              The function looks in the <u>.appup</u> file and tries  to  find  an  upgrade  script  from  the  current
              application  version.  High-level  instructions  are  translated  to  low-level  instructions. The
              instructions are sorted in the same manner as when generating a <u>relup</u> file.

              Returns <u>{ok,</u> <u>NewVsn,</u> <u>Script}</u> if successful, where <u>NewVsn</u>  is  the  new  application  version.  For
              details about <u>Script</u>, see <u><a href="../man5/appup.5.html">appup</a>(5)</u>.

              Failure: If a script cannot be found, the function fails with an appropriate error reason.

       <b>downgrade_script(App,</b> <b>OldVsn,</b> <b>Dir)</b> <b>-&gt;</b> <b>{ok,</b> <b>Script}</b>

              Types:

                 App = atom()
                 OldVsn = Dir = string()
                 Script = Instructions

              Tries  to  find  an  application  downgrade  script for <u>App</u> from the current version to a previous
              version <u>OldVsn</u> located in <u>Dir</u>.

              The downgrade script can then be evaluated using <u>eval_appup_script/4</u>. It  is  recommended  to  use
              <u>downgrade_app/2,3</u>  instead, but this function (<u>downgrade_script</u>) is useful to inspect the contents
              of the script.

              <u>App</u> is the name of the application, which must be started. <u>Dir</u> is the previous  library  directory
              of  <u>App</u>.  The  corresponding  modules  and the old <u>.app</u> file are to be located under <u>Dir/ebin</u>. The
              <u>.appup</u> file is to be located in the <u>ebin</u>  directory  of  the  <u>current</u>  library  directory  of  the
              application (<u>code:lib_dir(App)</u>).

              The  function  looks  in  the  <u>.appup</u>  file  and tries to find a downgrade script from the current
              application version.  High-level  instructions  are  translated  to  low-level  instructions.  The
              instructions are sorted in the same manner as when generating a <u>relup</u> file.

              Returns <u>{ok,</u> <u>Script}</u> if successful. For details about <u>Script</u>, see <u><a href="../man5/appup.5.html">appup</a>(5)</u>.

              Failure: If a script cannot be found, the function fails with an appropriate error reason.

       <b>eval_appup_script(App,</b> <b>ToVsn,</b> <b>ToDir,</b> <b>Script)</b> <b>-&gt;</b> <b>{ok,</b> <b>Unpurged}</b> <b>|</b> <b>restart_emulator</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 App = atom()
                 ToVsn = ToDir = string()
                 Script
                   See <u>upgrade_script/2</u>, <u>downgrade_script/3</u>
                 Unpurged = [Module]
                  Module = atom()
                 Reason = term()

              Evaluates   an   application   upgrade  or  downgrade  script  <u>Script</u>,  the  result  from  calling
              <u>upgrade_script/2</u> or <u>downgrade_script/3</u>, exactly in the same way as <u>install_release/1,2</u> does.

              <u>App</u> is the name  of  the  application,  which  must  be  started.  <u>ToVsn</u>  is  the  version  to  be
              upgraded/downgraded  to,  and  <u>ToDir</u>  is  the library directory of this version. The corresponding
              modules as well as the <u>.app</u> and <u>.appup</u> files are to be located under <u>Dir/ebin</u>.

              Returns one of the following:

                * <u>{ok,</u> <u>Unpurged}</u> if evaluating the script is successful, where <u>Unpurged</u> is a  list  of  unpurged
                  modules

                * <u>restart_emulator</u> if this instruction is encountered in the script

                * <u>{error,</u> <u>Reason}</u> if an error occurred when finding or evaluating the script

              If  the  <u>restart_new_emulator</u>  instruction  is  found  in  the script, <u>eval_appup_script/4</u> returns
              <u>{error,restart_new_emulator}</u>. This because <u>restart_new_emulator</u> requires  a  new  version  of  the
              emulator  to  be started before the rest of the upgrade instructions can be executed, and this can
              only be done by <u>install_release/1,2</u>.

</pre><h4><b>TYPICAL</b> <b>ERROR</b> <b>REASONS</b></h4><pre>
         <u>{bad_masters,</u> <u>Masters}</u>:
           The master nodes <u>Masters</u> are not alive.

         <u>{bad_rel_file,</u> <u>File}</u>:
           Specified <u>.rel</u> file <u>File</u> cannot be read or does not contain a single term.

         <u>{bad_rel_data,</u> <u>Data}</u>:
           Specified <u>.rel</u> file does not contain a recognized release specification, but another term <u>Data</u>.

         <u>{bad_relup_file,</u> <u>File}</u>:
           Specified <u>relup</u> file <u>Relup</u> contains bad data.

         <u>{cannot_extract_file,</u> <u>Name,</u> <u>Reason}</u>:
           Problems when extracting from a tar file, <u>erl_tar:extract/2</u> returned <u>{error,</u> <u>{Name,</u> <u>Reason}}</u>.

         <u>{existing_release,</u> <u>Vsn}</u>:
           Specified release version <u>Vsn</u> is already in use.

         <u>{Master,</u> <u>Reason,</u> <u>When}</u>:
           Some operation, indicated by the term <u>When</u>, failed on the master node <u>Master</u> with the specified error
           reason <u>Reason</u>.

         <u>{no_matching_relup,</u> <u>Vsn,</u> <u>CurrentVsn}</u>:
           Cannot find a script for upgrading/downgrading between <u>CurrentVsn</u> and <u>Vsn</u>.

         <u>{no_such_directory,</u> <u>Path}</u>:
           The directory <u>Path</u>does not exist.

         <u>{no_such_file,</u> <u>Path}</u>:
           The path <u>Path</u> (file or directory) does not exist.

         <u>{no_such_file,</u> <u>{Master,</u> <u>Path}}</u>:
           The path <u>Path</u> (file or directory) does not exist at the master node <u>Master</u>.

         <u>{no_such_release,</u> <u>Vsn}</u>:
           The specified release version <u>Vsn</u> does not exist.

         <u>{not_a_directory,</u> <u>Path}</u>:
           <u>Path</u> exists but is not a directory.

         <u>{Posix,</u> <u>File}</u>:
           Some file operation failed for <u>File</u>. <u>Posix</u> is an atom named from  the  Posix  error  codes,  such  as
           <u>enoent</u>, <u>eacces</u>, or <u>eisdir</u>. See <u><a href="../man3erl/file.3erl.html">file</a>(3erl)</u> in Kernel.

         <u>Posix</u>:
           Some file operation failed, as for the previous item in the list.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       OTP Design Principles, <u><a href="../man5/config.5.html">config</a>(5)</u>, <u><a href="../man5/rel.5.html">rel</a>(5)</u>, <u><a href="../man5/relup.5.html">relup</a>(5)</u>, <u><a href="../man5/script.5.html">script</a>(5)</u>, <u><a href="../man3erl/sys.3erl.html">sys</a>(3erl)</u>, <u><a href="../man3erl/systools.3erl.html">systools</a>(3erl)</u>

Ericsson AB                                        sasl 4.1.1                              <u><a href="../man3erl/release_handler.3erl.html">release_handler</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>