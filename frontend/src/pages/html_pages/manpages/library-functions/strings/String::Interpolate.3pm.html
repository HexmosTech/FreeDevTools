<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String::Interpolate - Wrapper for builtin the Perl interpolation engine.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstring-interpolate-perl">libstring-interpolate-perl_0.33-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       String::Interpolate - Wrapper for builtin the Perl interpolation engine.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # Functional interface
           use String::Interpolate qw( safe_interpolate interpolate );
           our($GREET) = 'Hello'; # Cannot be lexical
           print interpolate( '$GREET $1\n', [ 'world' ] );

           # Object interface
           use String::Interpolate;
           my $who;
           my $template = String::Interpolate-&gt;new( { WHO =&gt; \$who } );
           $template-&gt;{TIME} = sub () { localtime }; # Tie $TIME to localtime()
           $template-&gt;( [ qw( now it ) ] ); # Set $1, $2
           $template-&gt;[3] = 'is'; # Sets $3
           $who = 'old friend';
           $template-&gt;( '$REV{olleH} $WHO, $2 $3 $1 $TIME$_' ); # Set string to process
           $template-&gt;{REV} = sub { reverse @_ }; # Tie %REV to reverse()
           $_ = '.';
           print "$template\n"; # Perform interpolation

           # Peform the interpolation in a Safe compartment.
           my $replace = safe String::Interpolate '\u\L$1';
           my $search = qr/(\w+)/;
           $_ = "HELLO world\n";
           s/$search/$replace/eg; # /e suppresses optimisation
           print;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "String::Interpolate" provides a neat interface to the solution to that perenial Perl problem - how to
       invoke the Perl string interpolation engine on a string contained in a scalar variable.

       A "String::Interpolate" object encapsulates a string and a context in which it should be subjected to
       Perl interpolation.  In the simplest, default, case the context is simply the namespace (package) from
       which the constructor was called.

       A "String::Interpolate" object may hold a reference to an array and hashes that will be used to populate
       the special variables $1 etc and some package variables respectively prior to each interpolation.

       In general special globally global variables such as $_ can be used in the interpolation, the exception
       being @_ which is always empty during the interpolation.

       The interpolated string is processed with strictures and warnings enabled excluding 'strict vars' and
       'warnings uninitialized' so that interpolating undefined variables will be silently ignored.  This
       behaviour can be altered using the <b>pragma()</b> method.

       Because the Perl string interpolation engine can call arbitrary Perl code you do not want to want to use
       it on strings from untrusted sources without some precautions.  For this reason "String::Interpolate"
       objects can be made to use "Safe" compartments.  This is, of course, only as safe as Safe and you are
       advised to read "WARNING" section of the Safe documentation.

       When interpolating in a Safe compartment package symbols are imported using tied wrapper variables so
       that their values cannot be interpreted as references and such that they cannot be used to alter the
       values outside the compartment.  This behaviour can be suppressed by the <b>unsafe_symbols()</b> method.  Note
       that if you want to import tied variable or variables containing references to objects that use
       overloading into a Safe compartment then you will need to do a lot of fancy footwork unless you use
       <b>safe_hole()</b> method.

       By default *_ is shared by Safe compartments and could potentially allow the compartment to leak.  The $_
       and %_ variables are therefore subjected to the same similar precautions to imported symbols.  This
       behaviour can be suppressed using the <b>unsafe_underscore()</b> method.

       Perl string interpolation can, of course, throw exceptions.  By default String::Interpolate objects do
       not catch (or rethrow) these exceptions when working in a simple namespace and do trap them when working
       in a Safe compartment.  This behaviour can be overridden by the <b>trap()</b> or <b>pragma()</b> methods.  If an
       exception during interpolation is trapped then undef will be returned as the result of the interpolation
       and $@ will hold the exception in the usual way.

       When taint checking enabled, attempting to perform interpolation (using <b>eval()</b>) on a tainted string would
       naturally fail.  However, when using a Safe compartment, String::Interpolate will strip the tainting off
       of the string prior to interpolation and put it back afterwards.  Also String::Interpolate will taint any
       arguments passed to callback functions called as the result of performing interpolation on a tainted
       string.  Note that due to the mechanism used to assign $1 et al they can never be tained even if the
       values in the array being used to set them are tainted.

       By default "String::Interpolate" does not export any subroutines but as a concession to programmers who
       prefer not to explicitly use objects the functions <b>interpolate()</b> and <b>safe_interpolate()</b> are exportable.

   <b>Principle</b> <b>methods</b>
       new Simple  constructor.   Creates a empty String::Interpolate object bound to the caller's namespace and
           then modifies the object by passing any arguments to the <b>exec()</b> method.  Returns a the object.

           If called as an instance method <b>new()</b> clones the object.  Be aware, however, that this is  a  shallow
           cloning  and if array or hash reference arguments have been passed to the object the parent and clone
           will continue to use the same array or hashes until one or other is passed a new argument.

           Most of the other methods in String::Interpolate will  implicitly  call  <b>new()</b>  if  called  as  class
           methods.

       safe
           Alternative  constructor  to create a String::Interpolate object that uses an automatically allocated
           temporary Safe compartment.  The automatically allocated  Safe  compartment  will  have  the  default
           opcode  mask  but  with  the  'bless'  opcode  denied as this can be used to execute code outside the
           compartment by putting it in DESTROY methods.  The 'tie' opcode is also denied although I'm not  sure
           if  it  really  can  be  exploited  in  this  way.  There is no point explicitly passing a package or
           existing safe compartment to this constructor as it will be ignored.

           The argument list is passed to <b>exec()</b> as in <b>new()</b>.

           The <b>safe()</b> method can also be called on an existing object in which case it instructs the  object  to
           forget  its  current  Safe compartment or namespace and use an automatically allocated temporary Safe
           compartment henceforth.

       exec
           This it the guts of the implementation but it it rarely needs to be called explicitly as  it  can  be
           more  elegantly  called  implicitly  by  using  the  String::Interpolate  object  in a string or CODE
           reference context.  The following are equivalent pairs:

               my $interpolated_string = $interpolate_object-&gt;exec;
               my $interpolated_string = "$interpolate_object";

               my $interpolated_string = $interpolate_object-&gt;exec(LIST);
               my $interpolated_string = $interpolate_object-&gt;(LIST);

           The <b>exec()</b> method modifies the object according the argument list.  Then, if  called  in  a  non-void
           context,  returns the result of the interpolation.  Note that the modifications are persistent.  This
           persistence can be avoided by creating a transient clone using the <b>new()</b> method.

               my $string = $inter-&gt;(LIST);      # $inter changed
               my $string = $inter-&gt;new-&gt;(LIST); # $inter unchanged

           Also, if <b>exec()</b> is called as a class method then it acts on a  temporary  String::Interpolate  object
           which is immediately destroyed.

           The  elements  of the argument list are interpreted according to their type as listed below.  If this
           mechanism does not provide sufficient flexibility in  manipulating  the  symbol  table  you  can,  of
           course, manipulate it directly too.

           ARRAY reference
               Tells  the  object  to use this array to populate the special variables $1 and so on.  The object
               holds a reference to the array itself and will use the values that are in the array at  the  time
               of  interpolation.   This ARRAY reference is exposed via the <b>positionals()</b> method.  The array can
               also be modified by using the String::Interpolate object in an ARRAY  reference  context.   Note,
               however, that the String::Interpolate object used in an ARRAY reference context does not refer to
               the  array  itself  but  to  a STORE-only tied array whose subscripts are offset by one such that
               $interpolate_object-&gt;[1] corresponds to $interpolate_object-&gt;positionals-&gt;[0] and hence the value
               that will be interpolated for $1.

           HASH reference
               Tells the object to use this hash to populate some package variables immediately  prior  to  each
               interpolation.   The object holds a reference to the hash itself and will use the values that are
               in the hash at the time of interpolation.

               After the object has been instructed to populate package variables in this way it will no  longer
               default  to  using  the  namespace  from  which the constructor was called and will instead auto-
               allocate a temporary one unless told to do otherwise.

               If multiple hash reference arguments are specified in a single call to <b>exec()</b> then each  hash  in
               turn  will be processed prior to each interpolation.  However, whenever a <b>exec()</b> is passed one or
               more hash references it forgets any previous hashes  and  deletes  any  auto-allocated  temporary
               package or safe compartment.

               The  keys  of  the hash should be unqualified Perl identifiers that will determine the entries in
               the package symbol to be modified.   Which  slot  in  the  symbol  table  entry  is  modified  is
               determined by the values' types as follows:

               ARRAY reference
                   Set the symbol table entry's ARRAY slot.

               HASH reference
                   Set the symbol table entry's HASH slot.

               SCALAR reference
                   Set the symbol table entry's SCALAR slot.

               CODE reference with prototype ()
                   Set  the  symbol table entry's SCALAR slot to point to an new tied scalar with a FETCH method
                   that calls the referenced code.

                   Note that if interpolation is taking place inside a Safe compartment the  callback  will,  by
                   default, simply be called from within the compartment.  The callback code will execute with a
                   false symbol table root so it will not be able to use any packages from the real symbol table
                   root.  This limitation can be overcome by using the <b>safe_hole()</b> method.

               CODE reference with prototype ($) or no prototype
                   Set  the symbol table entry's HASH slot to point to an new tied hash with a FETCH method that
                   calls the referenced code.

                   See above for limitations if the callback is called from interpolation taking place in a Safe
                   compartment.

                   The argument passed to the callback will be stringified.  It may seem like a nice idea to  be
                   able to pass multiple arguments using an ARRAY reference but unfortunately this could open up
                   security problems when passing arguments out of a Safe compartment via a Safe::Hole.

               Anything else
                   Set the symbol table entry's SCALAR slot to point scalar containing the value.

               Note  that  since  the  String::Interpolate object stores a reference to the hash and updates the
               symbol table prior to each interpolation, changes in the hash will  be  reflected  in  subsequent
               interpolations.   However,  if  items in the hash are deleted or changed to a different type then
               the previously created symbol table entries may persist.  This can be  overcome  by  calling  the
               <b>safe()</b> or <b>package()</b> methods.

               To  simplify  modifying  the hash, a String::Interpolated object used in a HASH reference context
               will return a reference to the last hash argument passed to object, implicitly  calling  exec({})
               first if necessary.

                   my %h = ( A =&gt; 1 );
                   my $i = String::Interpolate-&gt;new( \%h );
                   $i-&gt;{B} = 2;  # $h{B} = 2

           GLOB or GLOB reference
               Instruct  the  object to perform interpolation in the namespace defined by the GLOB.  For example
               the argument *Q:: would mean that the string should be interpolated in the context of the package
               Q.  The trailing '::' may be omitted.

               Passing a package argument to the object causes it  to  stop  using  a  Safe  compartment  if  it
               previously  was  doing  so.   If you want safe execution in a specific namespace then you need to
               explicitly constuct Safe object bound to the given namespace and pass that.

               Once a String::Interpolate object has been explicitly bound to a namespace it  will  continue  to
               use  that namespace even if the String::Interpolate object has been (or is subsequently) passed a
               hash reference argument.  In this case the symbols will be created/updated in the namespace prior
               to each interpolation and will persist afterwards.

               See also the <b>package()</b> method.

           Safe object
               Instruct the object to perform interpolation in the  given  Safe  compartment.   Passing  a  Safe
               object  argument  to the String::Interpolate object causes it to stop using a specified namespace
               if it previously was doing so.  If you choose to pass an explicit Safe object you should deny the
               'bless' and 'tie' opcodes for the reasons discussed under the <b>safe()</b> method.

               Once a String::Interpolate object has been explicitly bound to a Safe object it will continue  to
               use  that  object  even  if the String::Interpolate object has been (or is subsequently) passed a
               hash reference argument.  In this case the symbols  will  be  created/updated  in  the  namespace
               associated with the Safe object prior to each interpolation and will persist afterwards.

               See also the <b>safe()</b> method.

           Safe::Hole object
               Equivalent to calling the <b>safe_hole()</b> method with the same argument.

           SCALAR reference
               The referenced scalar is passed to the <b>pragma()</b> method.

           Anything else
               Use the stringified value of the argument as the string on which to perform interpolation.

   <b>Functional</b> <b>interface</b>
       For those heathens who don't like the OO interface.

       safe_interpolate
           Exportable function equivalent to String::Interpolate-&gt;safe-&gt;exec(LIST).

       interpolate
           Exportable function equivalent to String::Interpolate-&gt;lexicals-&gt;exec(LIST).

   <b>Ancillary</b> <b>methods</b>
       The following methods provide alternative interfaces and some fine tuning capabilities.

       trap
           Tells the String::Interpolate object whether or not to trap exceptions.

               $i-&gt;trap;    # Enable trapping
               $i-&gt;<a href="../man1/trap.1.html">trap</a>(1); # Enable trapping
               $i-&gt;<a href="../man0/trap.0.html">trap</a>(0); # Disable trapping

           Returns the object so that it can be tagged on to constructor calls.

               my $i = String::Interpolate-&gt;safe-&gt;<a href="../man0/trap.0.html">trap</a>(0);

           If the <b><a href="../man0/trap.0.html">trap</a></b>(0) method has not been called then trapping is enabled when using a Safe compartment.

       unsafe_underscore
           Tells the String::Interpolate object whether or not to use "unsafe underscore" mode.  In this mode no
           precautions  are  taken  to  prevent malicious code attempting to reach outside it's Safe compartment
           through the $_ and %_ variables.

               $i-&gt;unsafe_underscore;    # Enable unsafe underscore mode
               $i-&gt;<a href="../man1/unsafe_underscore.1.html">unsafe_underscore</a>(1); # Enable unsafe underscore mode
               $i-&gt;<a href="../man0/unsafe_underscore.0.html">unsafe_underscore</a>(0); # Disable unsafe underscore mode

           Returns the object so that it can be tagged on to constructor calls.

       unsafe_symbols
           Tells the String::Interpolate object whether or not to  use  "unsafe  symbol"  mode.   In  this  mode
           variables  are  simply  shared  with  the  Safe  compartment  rather  than being safely hidden behind
           variables tied to blessed closures.  The setting of this flag as no effect  when  not  using  a  Safe
           compartment.

               $i-&gt;unsafe_symbols;    # Enable unsafe symbol mode
               $i-&gt;<a href="../man1/unsafe_symbols.1.html">unsafe_symbols</a>(1); # Enable unsafe symbol mode
               $i-&gt;<a href="../man0/unsafe_symbols.0.html">unsafe_symbols</a>(0); # Disable unsafe symbol mode

           Returns the object so that it can be tagged on to constructor calls.

       lexicals
           This feature is EXPERIMENTAL.  Do not use it in real code.

           Tells the String::Interpolate object whether or not to use the PadWalker module to import all lexical
           variables  from  the calling context into the temporary package or Safe compartment.  By default this
           does not happen as it is conceptually ugly and quite expensive.

               $i-&gt;lexicals;     # Enable lexicals
               $i-&gt;<a href="../man1/lexicals.1.html">lexicals</a>(1)   # Enable lexicals
               $i-&gt;<a href="../man0/lexicals.0.html">lexicals</a>(0);  # Disable lexicals

           Returns the object so that it can be tagged on to constructor calls.

               my $i = String::Interpolate-&gt;safe-&gt;lexicals;

           Enabling lexicals with a Safe compartment like this will give the code read-only access to  all  your
           lexical variables.

           Note that the lexicals used are those in scope at the final call that performs the interpolation, not
           those in scope when the String::Interpolate object is constructed.  Also you can't have your cake and
           eat it.  If you cannot use this feature at the same time as an explicit package or Safe compartment.

       package
           Instructs  the String::Interpolate object to forget its current Safe compartment or namespace and use
           the specified one henceforth.  The package name can be specified as  a  string,  a  GLOB  or  a  GLOB
           reference.   The  trailing '::' may be omitted.  With an undefined argument this method instructs the
           object to use a new automatically allocated temporary namespace.

           The package method Returns the object so that it can be tagged on to constructor calls.  It can  also
           be used as a constructor.

               my $i = String::Interpolate-&gt;package('Q');   # Use namespace Q::
               $i-&gt;package;                                 # Use temporary namespace
               $i-&gt;package(*R);                             # Use namespace R::
               $i-&gt;package(\*S::);                          # Use namespace S::

           Note  that the last two forms are not commonly used as GLOB or GLOB reference arguments passed to the
           <b>exec()</b>, <b>new()</b> or methods are automatically passed on the the <b>package()</b> method.

       safe_hole
           Tells the String::Interpolate object whether or not to use a Safe::Hole object to wrap  callbacks  to
           subroutines  specified  in the symbol mapping hash.  Without a Safe::Hole <b>eval()</b>, symbolic references
           and method calls in callbacks won't function normally.

               my $i = String::Interpolate-&gt;safe-&gt;safe_hole;
               # Without a Safe::Hole Wibble::wobble() would be inaccessible
               $i-&gt;{FOO} = sub () { Wibble-&gt;wobble };

           This feature only makes sense when evaluating in a Safe compartment and you can only use  it  if  you
           have the Safe::Hole module installed.

               $i-&gt;safe_hole;         # Enable use of Safe::Hole
               $i-&gt;<a href="../man1/safe_hole.1.html">safe_hole</a>(1);      # Enable use of Safe::Hole
               $i-&gt;<a href="../man0/safe_hole.0.html">safe_hole</a>(0);      # Disable use of Safe::Hole
               $i-&gt;safe_hole($hole);  # Use the Safe::Hole object $hole

           This method can also be called implicitly as follows.

               $i-&gt;(\'SAFE HOLE');    # Enable use of Safe::Hole
               $i-&gt;(\'NO_SAFE_HOLE'); # Disable use of Safe::Hole
               $i-&gt;($hole);           # Use the Safe::Hole object $hole

           The <b>safe_hole()</b> method returns the object so that it can be tagged on to constructor calls.

       pragma
           Specify  various options including Perl code to be complied in a BEGIN{} block prior to compiling the
           string to be interpolated.  When working in a Safe compartment, what you can do here is,  of  course,
           highly  limited.   In  practice this is only useful for calling the <b>import()</b> an <b>unimport()</b> methods on
           the warnings and strict modules.

           For the most commonly used values, to control the handling of  interpolating  undefined  values,  the
           following shorthands can also be used:

             NOWARN =&gt; 'unimport warnings qw(uninitialized)'
             WARN   =&gt; ''
             FATAL  =&gt; 'import warnings FATAL =&gt; qw(uninitialized); import strict qw(vars)'

           The  default  state for a newly created String::Interpolate object is NOWARN.  All other warnings are
           enabled as are 'refs' and 'subs' strictures.

           You can call <b>pragma()</b> implicitly by passing SCALAR references to <b>exec()</b>.  Furthermore  pragma('TRAP')
           is  a  synonym for <b><a href="../man1/trap.1.html">trap</a></b>(1) and pragma('NO TRAP') is a synonym for <b><a href="../man0/trap.0.html">trap</a></b>(0).  Similarly for <b>lexicals()</b>,
           <b>unsafe_symbols()</b>,  <b>unsafe_underscore()</b>  and  <b>safe_hole()</b>.   This  makes  the   following   statements
           equivalent:

               $i-&gt;(\'FATAL',\'NO TRAP',\'SAFE SYMBOLS');
               $i-&gt;pragma('FATAL','NO_TRAP','NO UNSAFE_SYMBOLS');
               $i-&gt;pragma('FATAL')-&gt;<a href="../man0/trap.0.html">trap</a>(0)-&gt;<a href="../man0/unsafe_symbols.0.html">unsafe_symbols</a>(0);

           The <b>pragma()</b> method returns the object so that it can be tagged on to constructor calls.

       positionals
           Returns,  as  an  lvalue,  the reference to the array that holds the values to use for the positional
           variables $1 and so on.

               my @p = qw ( one two three );
               my $i = String::Interpolate-&gt;new( \@p );
               $i-&gt;positionals-&gt;[1] = "TWO";      # $p[1] = "TWO";
               $i-&gt;positionals = [ qw ( X Y ) ];  # Forget @p, use anon array
               undef $i-&gt;positionals;             # $1 etc. inherted from caller

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       String::Interpolate::Shell, String::Interpolate::RE, String::Expand, String::MatchInterpolate.

</pre><h4><b>REPOSITORY</b></h4><pre>
       &lt;https://github.com/neilb/String-Interpolate&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Created by Brian McCauley, currently maintained by Neil Bowers &lt;<a href="mailto:neilb@cpan.org">neilb@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2002 by Brian McCauley.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.32.1                                       2021-03-27                           <u>String::<a href="../man3pm/Interpolate.3pm.html">Interpolate</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>