<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>strlcpy, strlcat — size-bounded string copying and concatenation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbsd-dev">libbsd-dev_0.12.2-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       strlcpy, strlcat — size-bounded string copying and concatenation

</pre><h4><b>LIBRARY</b></h4><pre>
       Utility functions from BSD systems (libbsd, -lbsd)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/string.h">string.h</a>&gt;</b>
       (See <u><a href="../man7/libbsd.7.html">libbsd</a></u>(7) for include usage.)

       <u>size_t</u>
       <b>strlcpy</b>(<u>char</u> <u>*dst</u>, <u>const</u> <u>char</u> <u>*src</u>, <u>size_t</u> <u>size</u>);

       <u>size_t</u>
       <b>strlcat</b>(<u>char</u> <u>*dst</u>, <u>const</u> <u>char</u> <u>*src</u>, <u>size_t</u> <u>size</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>strlcpy</b>() and <b>strlcat</b>() functions copy and concatenate strings respectively.  They are designed to be
       safer,  more  consistent,  and less error prone replacements for <u><a href="../man3/strncpy.3.html">strncpy</a></u>(3) and <u><a href="../man3/strncat.3.html">strncat</a></u>(3).  Unlike those
       functions, <b>strlcpy</b>() and <b>strlcat</b>() take the full size of the buffer (not just the length)  and  guarantee
       to  NUL-terminate  the  result (as long as <u>size</u> is larger than 0 or, in the case of <b>strlcat</b>(), as long as
       there is at least one byte free in <u>dst</u>).  Note that a byte for the NUL should be included in <u>size</u>.   Also
       note  that  <b>strlcpy</b>()  and <b>strlcat</b>() only operate on true “C” strings.  This means that for <b>strlcpy</b>() <u>src</u>
       must be NUL-terminated and for <b>strlcat</b>() both <u>src</u> and <u>dst</u> must be NUL-terminated.

       The <b>strlcpy</b>() function copies up to <u>size</u> - 1 characters from the NUL-terminated string <u>src</u> to  <u>dst</u>,  NUL-
       terminating the result.

       The  <b>strlcat</b>()  function appends the NUL-terminated string <u>src</u> to the end of <u>dst</u>.  It will append at most
       <u>size</u> - strlen(dst) - 1 bytes, NUL-terminating the result.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The <b>strlcpy</b>() and <b>strlcat</b>() functions return the total length of the string they tried  to  create.   For
       <b>strlcpy</b>()  that  means  the  length  of <u>src</u>.  For <b>strlcat</b>() that means the initial length of <u>dst</u> plus the
       length of <u>src</u>.  While this may seem somewhat confusing, it was done to make truncation detection simple.

       Note, however, that if <b>strlcat</b>() traverses <u>size</u> characters without finding  a  NUL,  the  length  of  the
       string is considered to be <u>size</u> and the destination string will not be NUL-terminated (since there was no
       space  for the NUL).  This keeps <b>strlcat</b>() from running off the end of a string.  In practice this should
       not happen (as it means that either <u>size</u> is incorrect or that <u>dst</u> is not a proper “C” string).  The check
       exists to prevent potential security problems in incorrect code.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following code fragment illustrates the simple case:

             char *s, *p, buf[BUFSIZ];

             ...

             (void)strlcpy(buf, s, sizeof(buf));
             (void)strlcat(buf, p, sizeof(buf));

       To detect truncation, perhaps while building a pathname, something like the following might be used:

             char *dir, *file, pname[MAXPATHLEN];

             ...

             if (strlcpy(pname, dir, sizeof(pname)) &gt;= sizeof(pname))
                     goto toolong;
             if (strlcat(pname, file, sizeof(pname)) &gt;= sizeof(pname))
                     goto toolong;

       Since it is known how many characters were copied the first time, things can be sped up a bit by using  a
       copy instead of an append:

             char *dir, *file, pname[MAXPATHLEN];
             size_t n;

             ...

             n = strlcpy(pname, dir, sizeof(pname));
             if (n &gt;= sizeof(pname))
                     goto toolong;
             if (strlcpy(pname + n, file, sizeof(pname) - n) &gt;= sizeof(pname) - n)
                     goto toolong;

       However,  one  may  question  the  validity  of  such  optimizations, as they defeat the whole purpose of
       <b>strlcpy</b>() and <b>strlcat</b>().  As a matter of fact, the first version of this manual page got it wrong.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/snprintf.3.html">snprintf</a></u>(3), <u><a href="../man3/strncat.3.html">strncat</a></u>(3), <u><a href="../man3/strncpy.3.html">strncpy</a></u>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>strlcpy</b>() and <b>strlcat</b>() functions first appeared  in  OpenBSD  2.4,  and  made  their  appearance  in
       NetBSD 1.4.3, FreeBSD 3.3 and glibc 2.38.

Debian                                           January 7, 2024                                   <u><a href="../man3bsd/strlcpy.3bsd.html">strlcpy</a></u>(3bsd)
</pre>
 </div>
</div></section>
</div>
</body>
</html>