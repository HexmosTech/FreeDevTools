<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>string - String processing functions.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       string - String processing functions.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides functions for string processing.

       A  string  in  this  module is represented by <u>unicode:chardata()</u>, that is, a list of codepoints, binaries
       with UTF-8-encoded codepoints (<u>UTF-8</u> <u>binaries</u>), or a mix of the two.

       "abcd"               is a valid string
       &lt;&lt;"abcd"&gt;&gt;           is a valid string
       ["abcd"]             is a valid string
       &lt;&lt;"abc..åäö"/utf8&gt;&gt;  is a valid string
       &lt;&lt;"abc..åäö"&gt;&gt;       is NOT a valid string,
                            but a binary with Latin-1-encoded codepoints
       [&lt;&lt;"abc"&gt;&gt;, "..åäö"] is a valid string
       [atom]               is NOT a valid string

       This module operates on grapheme clusters. A <u>grapheme</u> <u>cluster</u> is a user-perceived character, which can be
       represented by several codepoints.

       "å"  [229] or [97, 778]
       "e̊"  [101, 778]

       The string length of "ß↑e̊" is 3, even though it is represented by the codepoints  <u>[223,8593,101,778]</u>  or
       the UTF-8 binary <u>&lt;&lt;195,159,226,134,145,101,204,138&gt;&gt;</u>.

       Grapheme  clusters  for  codepoints of class <u>prepend</u> and non-modern (or decomposed) Hangul is not handled
       for performance reasons in <u>find/3</u>, <u>replace/3</u>, <u>split/2</u>, <u>split/2</u> and <u>trim/3</u>.

       Splitting and appending strings is to be done on grapheme clusters borders. There is no verification that
       the results of appending strings are valid or normalized.

       Most  of  the  functions  expect  all  input  to  be  normalized   to   one   form,   see   for   example
       <u>unicode:characters_to_nfc_list/1</u>.

       Language or locale specific handling of input is not considered in any function.

       The functions can crash for non-valid input strings. For example, the functions expect UTF-8 binaries but
       not all functions verify that all binaries are encoded correctly.

       Unless  otherwise  specified  the  return value type is the same as the input type. That is, binary input
       returns binary output, list input returns a list output, and mixed input can return a mixed output.

       1&gt; string:trim("  sarah  ").
       "sarah"
       2&gt; string:trim(&lt;&lt;"  sarah  "&gt;&gt;).
       &lt;&lt;"sarah"&gt;&gt;
       3&gt; string:lexemes("foo bar", " ").
       ["foo","bar"]
       4&gt; string:lexemes(&lt;&lt;"foo bar"&gt;&gt;, " ").
       [&lt;&lt;"foo"&gt;&gt;,&lt;&lt;"bar"&gt;&gt;]

       This module has been reworked in Erlang/OTP 20 to  handle  <u>unicode:chardata()</u>  and  operate  on  grapheme
       clusters.  The  <u>old</u> <u>functions</u> that only work on Latin-1 lists as input are still available but should not
       be used, they will be deprecated in a future release.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>direction()</b> = leading | trailing

       <b>grapheme_cluster()</b> = char() | [char()]

              A user-perceived character, consisting of one or more codepoints.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>casefold(String</b> <b>::</b> <b>unicode:chardata())</b> <b>-&gt;</b> <b>unicode:chardata()</b>

              Converts <u>String</u> to a case-agnostic  comparable  string.  Function  <u>casefold/1</u>  is  preferred  over
              <u>lowercase/1</u> when two strings are to be compared for equality. See also <u>equal/4</u>.

              <u>Example:</u>

              1&gt; string:casefold("Ω and ẞ SHARP S").
              "ω and ss sharp s"

       <b>chomp(String</b> <b>::</b> <b>unicode:chardata())</b> <b>-&gt;</b> <b>unicode:chardata()</b>

              Returns a string where any trailing <u>\n</u> or <u>\r\n</u> have been removed from <u>String</u>.

              <u>Example:</u>

              182&gt; string:chomp(&lt;&lt;"\nHello\n\n"&gt;&gt;).
              &lt;&lt;"\nHello"&gt;&gt;
              183&gt; string:chomp("\nHello\r\r\n").
              "\nHello\r"

       <b>equal(A,</b> <b>B)</b> <b>-&gt;</b> <b>boolean()</b>

       <b>equal(A,</b> <b>B,</b> <b>IgnoreCase)</b> <b>-&gt;</b> <b>boolean()</b>

       <b>equal(A,</b> <b>B,</b> <b>IgnoreCase,</b> <b>Norm)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 A = B = unicode:chardata()
                 IgnoreCase = boolean()
                 Norm = none | nfc | nfd | nfkc | nfkd

              Returns <u>true</u> if <u>A</u> and <u>B</u> are equal, otherwise <u>false</u>.

              If <u>IgnoreCase</u> is <u>true</u> the function does <u>casefold</u>ing on the fly before the equality test.

              If  <u>Norm</u> is not <u>none</u> the function applies normalization on the fly before the equality test. There
              are four available normalization forms: <u>nfc</u>, <u>nfd</u>, <u>nfkc</u>, and <u>nfkd</u>.

              By default, <u>IgnoreCase</u> is <u>false</u> and <u>Norm</u> is <u>none</u>.

              <u>Example:</u>

              1&gt; string:equal("åäö", &lt;&lt;"åäö"/utf8&gt;&gt;).
              true
              2&gt; string:equal("åäö", unicode:characters_to_nfd_binary("åäö")).
              false
              3&gt; string:equal("åäö", unicode:characters_to_nfd_binary("ÅÄÖ"), true, nfc).
              true

       <b>find(String,</b> <b>SearchPattern)</b> <b>-&gt;</b> <b>unicode:chardata()</b> <b>|</b> <b>nomatch</b>

       <b>find(String,</b> <b>SearchPattern,</b> <b>Dir)</b> <b>-&gt;</b> <b>unicode:chardata()</b> <b>|</b> <b>nomatch</b>

              Types:

                 String = SearchPattern = unicode:chardata()
                 Dir = direction()

              Removes anything before <u>SearchPattern</u> in <u>String</u> and returns the remainder of the string or <u>nomatch</u>
              if <u>SearchPattern</u> is not found. <u>Dir</u>, which  can  be  <u>leading</u>  or  <u>trailing</u>,  indicates  from  which
              direction characters are to be searched.

              By default, <u>Dir</u> is <u>leading</u>.

              <u>Example:</u>

              1&gt; string:find("ab..cd..ef", ".").
              "..cd..ef"
              2&gt; string:find(&lt;&lt;"ab..cd..ef"&gt;&gt;, "..", trailing).
              &lt;&lt;"..ef"&gt;&gt;
              3&gt; string:find(&lt;&lt;"ab..cd..ef"&gt;&gt;, "x", leading).
              nomatch
              4&gt; string:find("ab..cd..ef", "x", trailing).
              nomatch

       <b>is_empty(String</b> <b>::</b> <b>unicode:chardata())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>String</u> is the empty string, otherwise <u>false</u>.

              <u>Example:</u>

              1&gt; string:is_empty("foo").
              false
              2&gt; string:is_empty(["",&lt;&lt;&gt;&gt;]).
              true

       <b>length(String</b> <b>::</b> <b>unicode:chardata())</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Returns the number of grapheme clusters in <u>String</u>.

              <u>Example:</u>

              1&gt; string:length("ß↑e̊").
              3
              2&gt; string:length(&lt;&lt;195,159,226,134,145,101,204,138&gt;&gt;).
              3

       <b>lexemes(String</b> <b>::</b> <b>unicode:chardata(),</b>
               SeparatorList :: [grapheme_cluster()]) -&gt;
                  [unicode:chardata()]

              Returns a list of lexemes in <u>String</u>, separated by the grapheme clusters in <u>SeparatorList</u>.

              Notice that, as shown in this example, two or more adjacent separator graphemes clusters in <u>String</u>
              are treated as one. That is, there are no empty strings in the resulting list of lexemes. See also
              <u>split/3</u> which returns empty strings.

              Notice that <u>[$\r,$\n]</u> is one grapheme cluster.

              <u>Example:</u>

              1&gt; string:lexemes("abc de̊fxxghix jkl\r\nfoo", "x e" ++ [[$\r,$\n]]).
              ["abc","de̊f","ghi","jkl","foo"]
              2&gt; string:lexemes(&lt;&lt;"abc de̊fxxghix jkl\r\nfoo"/utf8&gt;&gt;, "x e" ++ [$\r,$\n]).
              [&lt;&lt;"abc"&gt;&gt;,&lt;&lt;"de̊f"/utf8&gt;&gt;,&lt;&lt;"ghi"&gt;&gt;,&lt;&lt;"jkl\r\nfoo"&gt;&gt;]

       <b>lowercase(String</b> <b>::</b> <b>unicode:chardata())</b> <b>-&gt;</b> <b>unicode:chardata()</b>

              Converts <u>String</u> to lowercase.

              Notice that function <u>casefold/1</u> should be used when converting a string to be tested for equality.

              <u>Example:</u>

              2&gt; string:lowercase(string:uppercase("Michał")).
              "michał"

       <b>next_codepoint(String</b> <b>::</b> <b>unicode:chardata())</b> <b>-&gt;</b>
                         maybe_improper_list(char(), unicode:chardata()) |
                         {error, unicode:chardata()}

              Returns the first codepoint in <u>String</u> and the rest of <u>String</u> in the tail. Returns an empty list if
              <u>String</u> is empty or an <u>{error,</u> <u>String}</u> tuple if the next byte is invalid.

              <u>Example:</u>

              1&gt; string:next_codepoint(unicode:characters_to_binary("e̊fg")).
              [101|&lt;&lt;"̊fg"/utf8&gt;&gt;]

       <b>next_grapheme(String</b> <b>::</b> <b>unicode:chardata())</b> <b>-&gt;</b>
                        maybe_improper_list(grapheme_cluster(),
                                            unicode:chardata()) |
                        {error, unicode:chardata()}

              Returns  the first grapheme cluster in <u>String</u> and the rest of <u>String</u> in the tail. Returns an empty
              list if <u>String</u> is empty or an <u>{error,</u> <u>String}</u> tuple if the next byte is invalid.

              <u>Example:</u>

              1&gt; string:next_grapheme(unicode:characters_to_binary("e̊fg")).
              ["e̊"|&lt;&lt;"fg"&gt;&gt;]

       <b>nth_lexeme(String,</b> <b>N,</b> <b>SeparatorList)</b> <b>-&gt;</b> <b>unicode:chardata()</b>

              Types:

                 String = unicode:chardata()
                 N = integer() &gt;= 0
                 SeparatorList = [grapheme_cluster()]

              Returns lexeme number <u>N</u> in <u>String</u>, where  lexemes  are  separated  by  the  grapheme  clusters  in
              <u>SeparatorList</u>.

              <u>Example:</u>

              1&gt; string:nth_lexeme("abc.de̊f.ghiejkl", 3, ".e").
              "ghi"

       <b>pad(String,</b> <b>Length)</b> <b>-&gt;</b> <b>unicode:charlist()</b>

       <b>pad(String,</b> <b>Length,</b> <b>Dir)</b> <b>-&gt;</b> <b>unicode:charlist()</b>

       <b>pad(String,</b> <b>Length,</b> <b>Dir,</b> <b>Char)</b> <b>-&gt;</b> <b>unicode:charlist()</b>

              Types:

                 String = unicode:chardata()
                 Length = integer()
                 Dir = direction() | both
                 Char = grapheme_cluster()

              Pads  <u>String</u>  to  <u>Length</u> with grapheme cluster <u>Char</u>. <u>Dir</u>, which can be <u>leading</u>, <u>trailing</u>, or <u>both</u>,
              indicates where the padding should be added.

              By default, <u>Char</u> is <u>$\s</u> and <u>Dir</u> is <u>trailing</u>.

              <u>Example:</u>

              1&gt; string:pad(&lt;&lt;"He̊llö"/utf8&gt;&gt;, 8).
              [&lt;&lt;72,101,204,138,108,108,195,182&gt;&gt;,32,32,32]
              2&gt; io:format("'~ts'~n",[string:pad("He̊llö", 8, leading)]).
              3&gt; io:format("'~ts'~n",[string:pad("He̊llö", 8, both)]).

       <b>prefix(String</b> <b>::</b> <b>unicode:chardata(),</b> <b>Prefix</b> <b>::</b> <b>unicode:chardata())</b> <b>-&gt;</b>
                 nomatch | unicode:chardata()

              If <u>Prefix</u> is the prefix of <u>String</u>, removes it and  returns  the  remainder  of  <u>String</u>,  otherwise
              returns <u>nomatch</u>.

              <u>Example:</u>

              1&gt; string:prefix(&lt;&lt;"prefix of string"&gt;&gt;, "pre").
              &lt;&lt;"fix of string"&gt;&gt;
              2&gt; string:prefix("pre", "prefix").
              nomatch

       <b>replace(String,</b> <b>SearchPattern,</b> <b>Replacement)</b> <b>-&gt;</b>
                  [unicode:chardata()]

       <b>replace(String,</b> <b>SearchPattern,</b> <b>Replacement,</b> <b>Where)</b> <b>-&gt;</b>
                  [unicode:chardata()]

              Types:

                 String = SearchPattern = Replacement = unicode:chardata()
                 Where = direction() | all

              Replaces  <u>SearchPattern</u>  in <u>String</u> with <u>Replacement</u>. <u>Where</u>, default <u>leading</u>, indicates whether the
              <u>leading</u>, the <u>trailing</u> or <u>all</u> encounters of <u>SearchPattern</u> are to be replaced.

              Can be implemented as:

              lists:join(Replacement, split(String, SearchPattern, Where)).

              <u>Example:</u>

              1&gt; string:replace(&lt;&lt;"ab..cd..ef"&gt;&gt;, "..", "*").
              [&lt;&lt;"ab"&gt;&gt;,"*",&lt;&lt;"cd..ef"&gt;&gt;]
              2&gt; string:replace(&lt;&lt;"ab..cd..ef"&gt;&gt;, "..", "*", all).
              [&lt;&lt;"ab"&gt;&gt;,"*",&lt;&lt;"cd"&gt;&gt;,"*",&lt;&lt;"ef"&gt;&gt;]

       <b>reverse(String</b> <b>::</b> <b>unicode:chardata())</b> <b>-&gt;</b> <b>[grapheme_cluster()]</b>

              Returns the reverse list of the grapheme clusters in <u>String</u>.

              <u>Example:</u>

              1&gt; Reverse = string:reverse(unicode:characters_to_nfd_binary("ÅÄÖ")).
              [[79,776],[65,776],[65,778]]
              2&gt; io:format("~ts~n",[Reverse]).
              ÖÄÅ

       <b>slice(String,</b> <b>Start)</b> <b>-&gt;</b> <b>Slice</b>

       <b>slice(String,</b> <b>Start,</b> <b>Length)</b> <b>-&gt;</b> <b>Slice</b>

              Types:

                 String = unicode:chardata()
                 Start = integer() &gt;= 0
                 Length = infinity | integer() &gt;= 0
                 Slice = unicode:chardata()

              Returns a substring of <u>String</u> of at most <u>Length</u> grapheme clusters, starting at position <u>Start</u>.

              By default, <u>Length</u> is <u>infinity</u>.

              <u>Example:</u>

              1&gt; string:slice(&lt;&lt;"He̊llö Wörld"/utf8&gt;&gt;, 4).
              &lt;&lt;"ö Wörld"/utf8&gt;&gt;
              2&gt; string:slice(["He̊llö ", &lt;&lt;"Wörld"/utf8&gt;&gt;], 4,4).
              "ö Wö"
              3&gt; string:slice(["He̊llö ", &lt;&lt;"Wörld"/utf8&gt;&gt;], 4,50).
              "ö Wörld"

       <b>split(String,</b> <b>SearchPattern)</b> <b>-&gt;</b> <b>[unicode:chardata()]</b>

       <b>split(String,</b> <b>SearchPattern,</b> <b>Where)</b> <b>-&gt;</b> <b>[unicode:chardata()]</b>

              Types:

                 String = SearchPattern = unicode:chardata()
                 Where = direction() | all

              Splits <u>String</u> where <u>SearchPattern</u> is encountered and return the remaining  parts.  <u>Where</u>,  default
              <u>leading</u>, indicates whether the <u>leading</u>, the <u>trailing</u> or <u>all</u> encounters of <u>SearchPattern</u> will split
              <u>String</u>.

              <u>Example:</u>

              0&gt; string:split("ab..bc..cd", "..").
              ["ab","bc..cd"]
              1&gt; string:split(&lt;&lt;"ab..bc..cd"&gt;&gt;, "..", trailing).
              [&lt;&lt;"ab..bc"&gt;&gt;,&lt;&lt;"cd"&gt;&gt;]
              2&gt; string:split(&lt;&lt;"ab..bc....cd"&gt;&gt;, "..", all).
              [&lt;&lt;"ab"&gt;&gt;,&lt;&lt;"bc"&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;"cd"&gt;&gt;]

       <b>take(String,</b> <b>Characters)</b> <b>-&gt;</b> <b>{Leading,</b> <b>Trailing}</b>

       <b>take(String,</b> <b>Characters,</b> <b>Complement)</b> <b>-&gt;</b> <b>{Leading,</b> <b>Trailing}</b>

       <b>take(String,</b> <b>Characters,</b> <b>Complement,</b> <b>Dir)</b> <b>-&gt;</b> <b>{Leading,</b> <b>Trailing}</b>

              Types:

                 String = unicode:chardata()
                 Characters = [grapheme_cluster()]
                 Complement = boolean()
                 Dir = direction()
                 Leading = Trailing = unicode:chardata()

              Takes  characters  from  <u>String</u>  as  long  as  the characters are members of set <u>Characters</u> or the
              complement of set <u>Characters</u>. <u>Dir</u>,  which  can  be  <u>leading</u>  or  <u>trailing</u>,  indicates  from  which
              direction characters are to be taken.

              <u>Example:</u>

              5&gt; string:take("abc0z123", lists:seq($a,$z)).
              {"abc","0z123"}
              6&gt; string:take(&lt;&lt;"abc0z123"&gt;&gt;, lists:seq($0,$9), true, leading).
              {&lt;&lt;"abc"&gt;&gt;,&lt;&lt;"0z123"&gt;&gt;}
              7&gt; string:take("abc0z123", lists:seq($0,$9), false, trailing).
              {"abc0z","123"}
              8&gt; string:take(&lt;&lt;"abc0z123"&gt;&gt;, lists:seq($a,$z), true, trailing).
              {&lt;&lt;"abc0z"&gt;&gt;,&lt;&lt;"123"&gt;&gt;}

       <b>titlecase(String</b> <b>::</b> <b>unicode:chardata())</b> <b>-&gt;</b> <b>unicode:chardata()</b>

              Converts <u>String</u> to titlecase.

              <u>Example:</u>

              1&gt; string:titlecase("ß is a SHARP s").
              "Ss is a SHARP s"

       <b>to_float(String)</b> <b>-&gt;</b> <b>{Float,</b> <b>Rest}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 String = unicode:chardata()
                 Float = float()
                 Rest = unicode:chardata()
                 Reason = no_float | badarg

              Argument  <u>String</u>  is  expected  to start with a valid text represented float (the digits are ASCII
              values). Remaining characters in the string after the float are returned in <u>Rest</u>.

              <u>Example:</u>

              &gt; {F1,Fs} = string:to_float("1.0-1.0e-1"),
              &gt; {F2,[]} = string:to_float(Fs),
              &gt; F1+F2.
              0.9
              &gt; string:to_float("3/2=1.5").
              {error,no_float}
              &gt; string:to_float("-1.5eX").
              {-1.5,"eX"}

       <b>to_integer(String)</b> <b>-&gt;</b> <b>{Int,</b> <b>Rest}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 String = unicode:chardata()
                 Int = integer()
                 Rest = unicode:chardata()
                 Reason = no_integer | badarg

              Argument <u>String</u> is expected to start with a valid text represented integer (the digits  are  ASCII
              values). Remaining characters in the string after the integer are returned in <u>Rest</u>.

              <u>Example:</u>

              &gt; {I1,Is} = string:to_integer("33+22"),
              &gt; {I2,[]} = string:to_integer(Is),
              &gt; I1-I2.
              11
              &gt; string:to_integer("0.5").
              {0,".5"}
              &gt; string:to_integer("x=2").
              {error,no_integer}

       <b>to_graphemes(String</b> <b>::</b> <b>unicode:chardata())</b> <b>-&gt;</b> <b>[grapheme_cluster()]</b>

              Converts <u>String</u> to a list of grapheme clusters.

              <u>Example:</u>

              1&gt; string:to_graphemes("ß↑e̊").
              [223,8593,[101,778]]
              2&gt; string:to_graphemes(&lt;&lt;"ß↑e̊"/utf8&gt;&gt;).
              [223,8593,[101,778]]

       <b>trim(String)</b> <b>-&gt;</b> <b>unicode:chardata()</b>

       <b>trim(String,</b> <b>Dir)</b> <b>-&gt;</b> <b>unicode:chardata()</b>

       <b>trim(String,</b> <b>Dir,</b> <b>Characters)</b> <b>-&gt;</b> <b>unicode:chardata()</b>

              Types:

                 String = unicode:chardata()
                 Dir = direction() | both
                 Characters = [grapheme_cluster()]

              Returns  a string, where leading or trailing, or both, <u>Characters</u> have been removed. <u>Dir</u> which can
              be <u>leading</u>, <u>trailing</u>, or <u>both</u>, indicates from which direction characters are to be removed.

              Default  <u>Characters</u>   is   the   set   of   nonbreakable   whitespace   codepoints,   defined   as
              Pattern_White_Space in Unicode Standard Annex #31. <u>By</u> <u>default,</u> <u>Dir</u> is <u>both</u>.

              Notice that <u>[$\r,$\n]</u> is one grapheme cluster according to the Unicode Standard.

              <u>Example:</u>

              1&gt; string:trim("\t Hello \n").
              "Hello"
              2&gt; string:trim(&lt;&lt;"\t Hello \n"&gt;&gt;, leading).
              &lt;&lt;"Hello  \n"&gt;&gt;
              3&gt; string:trim(&lt;&lt;".Hello.\n"&gt;&gt;, trailing, "\n.").
              &lt;&lt;".Hello"&gt;&gt;

       <b>uppercase(String</b> <b>::</b> <b>unicode:chardata())</b> <b>-&gt;</b> <b>unicode:chardata()</b>

              Converts <u>String</u> to uppercase.

              See also <u>titlecase/1</u>.

              <u>Example:</u>

              1&gt; string:uppercase("Michał").
              "MICHAŁ"

</pre><h4><b>OBSOLETE</b> <b>API</b> <b>FUNCTIONS</b></h4><pre>
       Here follows the function of the old API. These functions only work on a list of Latin-1 characters.

   <b>Note:</b>
       The  functions are kept for backward compatibility, but are not recommended. They will be deprecated in a
       future release.

       Any undocumented functions in <u>string</u> are not to be used.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>centre(String,</b> <b>Number)</b> <b>-&gt;</b> <b>Centered</b>

       <b>centre(String,</b> <b>Number,</b> <b>Character)</b> <b>-&gt;</b> <b>Centered</b>

              Types:

                 String = Centered = string()
                 Number = integer() &gt;= 0
                 Character = char()

              Returns a string, where <u>String</u> is centered in the string and surrounded by  blanks  or  <u>Character</u>.
              The resulting string has length <u>Number</u>.

              This function is obsolete. Use <u>pad/3</u>.

       <b>chars(Character,</b> <b>Number)</b> <b>-&gt;</b> <b>String</b>

       <b>chars(Character,</b> <b>Number,</b> <b>Tail)</b> <b>-&gt;</b> <b>String</b>

              Types:

                 Character = char()
                 Number = integer() &gt;= 0
                 Tail = String = string()

              Returns  a  string  consisting of <u>Number</u> characters <u>Character</u>. Optionally, the string can end with
              string <u>Tail</u>.

              This function is obsolete. Use <u>lists:duplicate/2</u>.

       <b>chr(String,</b> <b>Character)</b> <b>-&gt;</b> <b>Index</b>

              Types:

                 String = string()
                 Character = char()
                 Index = integer() &gt;= 0

              Returns the index of the first occurrence of <u>Character</u> in <u>String</u>. Returns <u>0</u> if <u>Character</u> does  not
              occur.

              This function is obsolete. Use <u>find/2</u>.

       <b>concat(String1,</b> <b>String2)</b> <b>-&gt;</b> <b>String3</b>

              Types:

                 String1 = String2 = String3 = string()

              Concatenates <u>String1</u> and <u>String2</u> to form a new string <u>String3</u>, which is returned.

              This   function   is   obsolete.   Use   <u>[String1,</u>   <u>String2]</u>   as   <u>Data</u>   argument,   and   call
              <u>unicode:characters_to_list/2</u> or <u>unicode:characters_to_binary/2</u> to flatten the output.

       <b>copies(String,</b> <b>Number)</b> <b>-&gt;</b> <b>Copies</b>

              Types:

                 String = Copies = string()
                 Number = integer() &gt;= 0

              Returns a string containing <u>String</u> repeated <u>Number</u> times.

              This function is obsolete. Use <u>lists:duplicate/2</u>.

       <b>cspan(String,</b> <b>Chars)</b> <b>-&gt;</b> <b>Length</b>

              Types:

                 String = Chars = string()
                 Length = integer() &gt;= 0

              Returns the length of the maximum initial segment of <u>String</u>, which consists entirely of characters
              not from <u>Chars</u>.

              This function is obsolete. Use <u>take/3</u>.

              <u>Example:</u>

              &gt; string:cspan("\t    abcdef", " \t").
              0

       <b>join(StringList,</b> <b>Separator)</b> <b>-&gt;</b> <b>String</b>

              Types:

                 StringList = [string()]
                 Separator = String = string()

              Returns a string with the elements of <u>StringList</u> separated by the string in <u>Separator</u>.

              This function is obsolete. Use <u>lists:join/2</u>.

              <u>Example:</u>

              &gt; join(["one", "two", "three"], ", ").
              "one, two, three"

       <b>left(String,</b> <b>Number)</b> <b>-&gt;</b> <b>Left</b>

       <b>left(String,</b> <b>Number,</b> <b>Character)</b> <b>-&gt;</b> <b>Left</b>

              Types:

                 String = Left = string()
                 Number = integer() &gt;= 0
                 Character = char()

              Returns <u>String</u> with the length adjusted in accordance with <u>Number</u>. The left margin  is  fixed.  If
              <u>length(String)</u> &lt; <u>Number</u>, then <u>String</u> is padded with blanks or <u>Character</u>s.

              This function is obsolete. Use <u>pad/2</u> or <u>pad/3</u>.

              <u>Example:</u>

              &gt; string:left("Hello",10,$.).
              "Hello....."

       <b>len(String)</b> <b>-&gt;</b> <b>Length</b>

              Types:

                 String = string()
                 Length = integer() &gt;= 0

              Returns the number of characters in <u>String</u>.

              This function is obsolete. Use <u>length/1</u>.

       <b>rchr(String,</b> <b>Character)</b> <b>-&gt;</b> <b>Index</b>

              Types:

                 String = string()
                 Character = char()
                 Index = integer() &gt;= 0

              Returns  the  index of the last occurrence of <u>Character</u> in <u>String</u>. Returns <u>0</u> if <u>Character</u> does not
              occur.

              This function is obsolete. Use <u>find/3</u>.

       <b>right(String,</b> <b>Number)</b> <b>-&gt;</b> <b>Right</b>

       <b>right(String,</b> <b>Number,</b> <b>Character)</b> <b>-&gt;</b> <b>Right</b>

              Types:

                 String = Right = string()
                 Number = integer() &gt;= 0
                 Character = char()

              Returns <u>String</u> with the length adjusted in accordance with <u>Number</u>. The right margin is  fixed.  If
              the length of <u>(String)</u> &lt; <u>Number</u>, then <u>String</u> is padded with blanks or <u>Character</u>s.

              This function is obsolete. Use <u>pad/3</u>.

              <u>Example:</u>

              &gt; string:right("Hello", 10, $.).
              ".....Hello"

       <b>rstr(String,</b> <b>SubString)</b> <b>-&gt;</b> <b>Index</b>

              Types:

                 String = SubString = string()
                 Index = integer() &gt;= 0

              Returns  the  position  where  the  last  occurrence  of  <u>SubString</u> begins in <u>String</u>. Returns <u>0</u> if
              <u>SubString</u> does not exist in <u>String</u>.

              This function is obsolete. Use <u>find/3</u>.

              <u>Example:</u>

              &gt; string:rstr(" Hello Hello World World ", "Hello World").
              8

       <b>span(String,</b> <b>Chars)</b> <b>-&gt;</b> <b>Length</b>

              Types:

                 String = Chars = string()
                 Length = integer() &gt;= 0

              Returns the length of the maximum initial segment of <u>String</u>, which consists entirely of characters
              from <u>Chars</u>.

              This function is obsolete. Use <u>take/2</u>.

              <u>Example:</u>

              &gt; string:span("\t    abcdef", " \t").
              5

       <b>str(String,</b> <b>SubString)</b> <b>-&gt;</b> <b>Index</b>

              Types:

                 String = SubString = string()
                 Index = integer() &gt;= 0

              Returns the position where the first occurrence of  <u>SubString</u>  begins  in  <u>String</u>.  Returns  <u>0</u>  if
              <u>SubString</u> does not exist in <u>String</u>.

              This function is obsolete. Use <u>find/2</u>.

              <u>Example:</u>

              &gt; string:str(" Hello Hello World World ", "Hello World").
              8

       <b>strip(String</b> <b>::</b> <b>string())</b> <b>-&gt;</b> <b>string()</b>

       <b>strip(String,</b> <b>Direction)</b> <b>-&gt;</b> <b>Stripped</b>

       <b>strip(String,</b> <b>Direction,</b> <b>Character)</b> <b>-&gt;</b> <b>Stripped</b>

              Types:

                 String = Stripped = string()
                 Direction = left | right | both
                 Character = char()

              Returns  a  string,  where leading or trailing, or both, blanks or a number of <u>Character</u> have been
              removed. <u>Direction</u>, which can be <u>left</u>, <u>right</u>, or <u>both</u>, indicates from which direction  blanks  are
              to be removed. <u>strip/1</u> is equivalent to <u>strip(String,</u> <u>both)</u>.

              This function is obsolete. Use <u>trim/3</u>.

              <u>Example:</u>

              &gt; string:strip("...Hello.....", both, $.).
              "Hello"

       <b>sub_string(String,</b> <b>Start)</b> <b>-&gt;</b> <b>SubString</b>

       <b>sub_string(String,</b> <b>Start,</b> <b>Stop)</b> <b>-&gt;</b> <b>SubString</b>

              Types:

                 String = SubString = string()
                 Start = Stop = integer() &gt;= 1

              Returns  a  substring  of  <u>String</u>,  starting at position <u>Start</u> to the end of the string, or to and
              including position <u>Stop</u>.

              This function is obsolete. Use <u>slice/3</u>.

              <u>Example:</u>

              sub_string("Hello World", 4, 8).
              "lo Wo"

       <b>substr(String,</b> <b>Start)</b> <b>-&gt;</b> <b>SubString</b>

       <b>substr(String,</b> <b>Start,</b> <b>Length)</b> <b>-&gt;</b> <b>SubString</b>

              Types:

                 String = SubString = string()
                 Start = integer() &gt;= 1
                 Length = integer() &gt;= 0

              Returns a substring of <u>String</u>, starting at position <u>Start</u>, and ending at the end of the string  or
              at length <u>Length</u>.

              This function is obsolete. Use <u>slice/3</u>.

              <u>Example:</u>

              &gt; substr("Hello World", 4, 5).
              "lo Wo"

       <b>sub_word(String,</b> <b>Number)</b> <b>-&gt;</b> <b>Word</b>

       <b>sub_word(String,</b> <b>Number,</b> <b>Character)</b> <b>-&gt;</b> <b>Word</b>

              Types:

                 String = Word = string()
                 Number = integer()
                 Character = char()

              Returns the word in position <u>Number</u> of <u>String</u>. Words are separated by blanks or <u>Character</u>s.

              This function is obsolete. Use <u>nth_lexeme/3</u>.

              <u>Example:</u>

              &gt; string:sub_word(" Hello old boy !",3,$o).
              "ld b"

       <b>to_lower(String)</b> <b>-&gt;</b> <b>Result</b>

       <b>to_lower(Char)</b> <b>-&gt;</b> <b>CharResult</b>

       <b>to_upper(String)</b> <b>-&gt;</b> <b>Result</b>

       <b>to_upper(Char)</b> <b>-&gt;</b> <b>CharResult</b>

              Types:

                 String = Result = io_lib:latin1_string()
                 Char = CharResult = char()

              The  specified  string  or character is case-converted. Notice that the supported character set is
              ISO/IEC 8859-1 (also called Latin 1); all values outside this set are unchanged

              This function is obsolete use <u>lowercase/1</u>, <u>uppercase/1</u>, <u>titlecase/1</u> or <u>casefold/1</u>.

       <b>tokens(String,</b> <b>SeparatorList)</b> <b>-&gt;</b> <b>Tokens</b>

              Types:

                 String = SeparatorList = string()
                 Tokens = [Token :: nonempty_string()]

              Returns a list of tokens in <u>String</u>, separated by the characters in <u>SeparatorList</u>.

              <u>Example:</u>

              &gt; tokens("abc defxxghix jkl", "x ").
              ["abc", "def", "ghi", "jkl"]

              Notice that, as shown in this example, two or more adjacent separator  characters  in  <u>String</u>  are
              treated as one. That is, there are no empty strings in the resulting list of tokens.

              This function is obsolete. Use <u>lexemes/2</u>.

       <b>words(String)</b> <b>-&gt;</b> <b>Count</b>

       <b>words(String,</b> <b>Character)</b> <b>-&gt;</b> <b>Count</b>

              Types:

                 String = string()
                 Character = char()
                 Count = integer() &gt;= 1

              Returns the number of words in <u>String</u>, separated by blanks or <u>Character</u>.

              This function is obsolete. Use <u>lexemes/2</u>.

              <u>Example:</u>

              &gt; words(" Hello old boy!", $o).
              4

</pre><h4><b>NOTES</b></h4><pre>
       Some  of  the  general  string  functions  can seem to overlap each other. The reason is that this string
       package is the combination of two earlier packages and all functions of both packages have been retained.

Ericsson AB                                        stdlib 3.17                                      <u><a href="../man3erl/string.3erl.html">string</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>