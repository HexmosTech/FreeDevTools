<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String::Util -- String processing utility functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstring-util-perl">libstring-util-perl_1.35-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       String::Util -- String processing utility functions

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>String::Util</b> provides a collection of small, handy functions for processing strings in various ways.

</pre><h4><b>INSTALLATION</b></h4><pre>
         cpanm String::Util

</pre><h4><b>USAGE</b></h4><pre>
       No functions are exported by default, they must be specified:

         use String::Util qw(trim eqq contains)

       alternately you can use ":all" to export <b>all</b> of the functions

         use String::Util qw(:all)

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>collapse($string)</b>
       collapse() collapses all whitespace in the string down to single spaces.  Also removes all leading and
       trailing whitespace.  Undefined input results in undefined output.

         $var = collapse("  Hello     world!    "); # "Hello world!"

   <b>hascontent($scalar),</b> <b>nocontent($scalar)</b>
       hascontent() returns true if the given argument is defined and contains something besides whitespace.

       An undefined value returns false.  An empty string returns false.  A value containing nothing but
       whitespace (spaces, tabs, carriage returns, newlines, backspace) returns false.  A string containing any
       other characters (including zero) returns true.

       nocontent() returns the negation of hascontent().

         $var = hascontent("");  # False
         $var = hascontent(" "); # False
         $var = hascontent("a"); # True

         $var = nocontent("");   # True
         $var = nocontent("a");  # False

   <b>trim($string),</b> <b>ltrim($string),</b> <b>rtrim($string)</b>
       Returns the string with all leading and trailing whitespace removed.

         $var = trim(" my string  "); # "my string"

       ltrim() trims <b>leading</b> whitespace only.

       rtrim() trims <b>trailing</b> whitespace only.

   <b>nospace($string)</b>
       Removes <b>all</b> whitespace characters from the given string. This includes spaces between words.

         $var = nospace("  Hello World!   "); # "HelloWorld!"

   <b>htmlesc($string)</b>
       Formats a string for literal output in HTML.  An undefined value is returned as an empty string.

       <b>htmlesc()</b> is very similar to CGI.pm's escapeHTML.  However, there are a few differences. <b>htmlesc()</b>
       changes an undefined value to an empty string, whereas <b>escapeHTML()</b> returns undefs as undefs.

   <b>jsquote($string)</b>
       Escapes and quotes a string for use in JavaScript.  Escapes single quotes and surrounds the string in
       single quotes.  Returns the modified string.

   <b>unquote($string)</b>
       If the given string starts and ends with quotes, removes them. Recognizes single quotes and double
       quotes.  The value must begin and end with same type of quotes or nothing is done to the value. Undef
       input results in undef output.  Some examples and what they return:

         unquote(q|'Hendrix'|);   # Hendrix
         unquote(q|"Hendrix"|);   # Hendrix
         unquote(q|Hendrix|);     # Hendrix
         unquote(q|"Hendrix'|);   # "Hendrix'
         unquote(q|O'Sullivan|);  # O'Sullivan

       <b>option:</b> braces

       If the braces option is true, surrounding braces such as [] and {} are also removed. Some examples:

         unquote(q|[Janis]|, braces=&gt;1);  # Janis
         unquote(q|{Janis}|, braces=&gt;1);  # Janis
         unquote(q|(Janis)|, braces=&gt;1);  # Janis

   <b>repeat($string,</b> <b>$count)</b>
       Returns the given string repeated the given number of times. The following command outputs "Fred" three
       times:

         print repeat('Fred', 3), "\n";

       Note that repeat() was created a long time based on a misunderstanding of how the perl operator 'x'
       works.  The following command using "x" would perform exactly the same as the above command.

         print 'Fred' x 3, "\n";

       Use whichever you prefer.

   <b>eqq($scalar1,</b> <b>$scalar2)</b>
       Returns true if the two given values are equal.  Also returns true if both are "undef".  If only one is
       "undef", or if they are both defined but different, returns false. Here are some examples and what they
       return.

         $var = eqq('x', 'x');     # True
         $var = eqq('x', undef);   # False
         $var = eqq(undef, undef); # True

   <b>neqq($scalar1,</b> <b>$scalar2)</b>
       The opposite of "neqq", returns true if the two values are *not* the same.  Here are some examples and
       what they return.

         $var = neqq('x', 'x');     # False
         $var = neqq('x', undef);   # True
         $var = neqq(undef, undef); # False

   <b>ords($string)</b>
       Returns the given string represented as the ascii value of each character.

         $var = ords('Hendrix'); # {72}{101}{110}{100}{114}{105}{120}

       <b>options</b>

       •   convert_spaces=&gt;[true|false]

           If  convert_spaces  is  true  (which  is the default) then spaces are converted to their matching ord
           values. So, for example, this code:

             $var = ords('a b', convert_spaces=&gt;1); # {97}{32}{98}

           This code returns the same thing:

             $var = ords('a b');                    # {97}{32}{98}

           If convert_spaces is false, then spaces are just returned as spaces. So this code:

             ords('a b', convert_spaces=&gt;0);        # {97} {98}

       •   alpha_nums

           If the alpha_nums option is false, then characters 0-9, a-z, and A-Z are not converted. For  example,
           this code:

             $var = ords('a=b', alpha_nums=&gt;0); # a{61}b

   <b>deords($string)</b>
       Takes the output from ords() and returns the string that original created that output.

         $var = deords('{72}{101}{110}{100}{114}{105}{120}'); # 'Hendrix'

   <b>contains($string,</b> <b>$substring)</b>
       Checks if the string contains substring

         $var = contains("Hello world", "Hello");   # true
         $var = contains("Hello world", "llo wor"); # true
         $var = contains("Hello world", "");        # true
         $var = contains("Hello world", "QQQ");     # false
         $var = contains(undef, "QQQ");             # false
         $var = contains("Hello world", undef);     # false

         # Also works with grep
         @arr = grep { contains("cat") } @input;

   <b>startswith($string,</b> <b>$substring)</b>
       Checks if the string starts with the characters in substring

         $var = startwith("Hello world", "Hello"); # true
         $var = startwith("Hello world", "H");     # true
         $var = startwith("Hello world", "");      # true
         $var = startwith("Hello world", "Q");     # false
         $var = startwith(undef, "Q");             # false
         $var = startwith("Hello world", undef);   # false

         # Also works with grep
         @arr = grep { startswith("X") } @input;

   <b>endswith($string,</b> <b>$substring)</b>
       Checks if the string ends with the characters in substring

         $var = endswith("Hello world", "world");   # true
         $var = endswith("Hello world", "d");       # true
         $var = endswith("Hello world", "");        # true
         $var = endswith("Hello world", "QQQ");     # false
         $var = endswith(undef, "QQQ");             # false
         $var = endswith("Hello world", undef);     # false

         # Also works with grep
         @arr = grep { endswith("z") } @input;

   <b>crunchlines($string)</b>
       Compacts  contiguous  newlines into single newlines.  Whitespace between newlines is ignored, so that two
       newlines separated by whitespace is compacted down to a single newline.

         $var = crunchlines("x\n\n\nx"); # "x\nx";

   <b>sanitize($string,</b> <b>$separator</b> <b>=</b> <b>"_")</b>
       Sanitize all non alpha-numeric characters in a string to underscores.  This is useful to take a  URL,  or
       filename, or text description and know you can use it safely in a URL or a filename.

       <b>Note:</b> This will remove any trailing or leading '_' on the string

         $var = sanitize("<a href="http://www.google.com/">http://www.google.com/</a>") # http_www_google_com
         $var = sanitize("foo_bar()";              # foo_bar
         $var = sanitize("/path/to/file.txt");     # path_to_file_txt
         $var = sanitize("Big yellow bird!", "."); # Big.yellow.bird

   <b>file_get_contents($string,</b> <b>$boolean)</b>
       Read an entire file from disk into a string. Returns undef if the file cannot be read for any reason. Can
       also return the file as an array of lines.

         $str   = file_get_contents("/tmp/file.txt");    # Return a string
         @lines = file_get_contents("/tmp/file.txt", 1); # Return an array

       <b>Note:</b>  If  you  opt  to return an array, carriage returns and line feeds are removed from the end of each
       line.

       <b>Note:</b> File is read in <b>UTF-8</b> mode, unless $FGC_MODE is set to an appropriate encoding.

   <b>substr_count($haystack,</b> <b>$needle)</b>
       Count the occurences of a substr inside of a larger string. Returns an integer value with the  number  of
       matches, or "undef" if the input is invalid.

         my $cnt = substr_count("Perl is really rad", "r"); # 3
         my $num = substr_count("Perl is really rad", "Q"); # 0

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 2012-2016 by Miko O'Sullivan.  All rights reserved.  This program is free software; you can
       redistribute  it  and/or  modify  it  under  the  same  terms as Perl itself. This software comes with <b>NO</b>
       <b>WARRANTY</b> of any kind.

</pre><h4><b>AUTHORS</b></h4><pre>
       Miko O'Sullivan &lt;<a href="mailto:miko@idocs.com">miko@idocs.com</a>&gt;

       Scott Baker &lt;<a href="mailto:scott@perturb.org">scott@perturb.org</a>&gt;

perl v5.40.0                                       2024-09-07                                  <u>String::<a href="../man3pm/Util.3pm.html">Util</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>