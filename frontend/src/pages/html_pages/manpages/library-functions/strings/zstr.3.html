<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zstr - Class for sending and receiving strings</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libczmq-dev">libczmq-dev_4.2.1-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       zstr - Class for sending and receiving strings

</pre><h4><b>SYNOPSIS</b></h4><pre>
       //  This is a stable class, and may not change except for emergencies. It
       //  is provided in stable builds.
       //  This class has draft methods, which may change over time. They are not
       //  in stable releases, by default. Use --enable-drafts to enable.
       //  Receive C string from socket. Caller must free returned string using
       //  zstr_free(). Returns NULL if the context is being terminated or the
       //  process was interrupted.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zstr_recv (void *source);

       //  Receive a series of strings (until NULL) from multipart data.
       //  Each string is allocated and filled with string data; if there
       //  are not enough frames, unallocated strings are set to NULL.
       //  Returns -1 if the message could not be read, else returns the
       //  number of strings filled, zero or more. Free each returned string
       //  using zstr_free(). If not enough strings are provided, remaining
       //  multipart frames in the message are dropped.
       CZMQ_EXPORT int
           zstr_recvx (void *source, char **string_p, ...);

       //  Send a C string to a socket, as a frame. The string is sent without
       //  trailing null byte; to read this you can use zstr_recv, or a similar
       //  method that adds a null terminator on the received string. String
       //  may be NULL, which is sent as "".
       CZMQ_EXPORT int
           zstr_send (void *dest, const char *string);

       //  Send a C string to a socket, as zstr_send(), with a MORE flag, so that
       //  you can send further strings in the same multi-part message.
       CZMQ_EXPORT int
           zstr_sendm (void *dest, const char *string);

       //  Send a formatted string to a socket. Note that you should NOT use
       //  user-supplied strings in the format (they may contain '%' which
       //  will create security holes).
       CZMQ_EXPORT int
           zstr_sendf (void *dest, const char *format, ...) CHECK_PRINTF (2);

       //  Send a formatted string to a socket, as for zstr_sendf(), with a
       //  MORE flag, so that you can send further strings in the same multi-part
       //  message.
       CZMQ_EXPORT int
           zstr_sendfm (void *dest, const char *format, ...) CHECK_PRINTF (2);

       //  Send a series of strings (until NULL) as multipart data
       //  Returns 0 if the strings could be sent OK, or -1 on error.
       CZMQ_EXPORT int
           zstr_sendx (void *dest, const char *string, ...);

       //  Free a provided string, and nullify the parent pointer. Safe to call on
       //  a null pointer.
       CZMQ_EXPORT void
           zstr_free (char **string_p);

       //  Self test of this class.
       CZMQ_EXPORT void
           zstr_test (bool verbose);

       #ifdef CZMQ_BUILD_DRAFT_API
       //  *** Draft method, for development use, may change without warning ***
       //  De-compress and receive C string from socket, received as a message
       //  with two frames: size of the uncompressed string, and the string itself.
       //  Caller must free returned string using zstr_free(). Returns NULL if the
       //  context is being terminated or the process was interrupted.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zstr_recv_compress (void *source);

       //  *** Draft method, for development use, may change without warning ***
       //  Compress and send a C string to a socket, as a message with two frames:
       //  size of the uncompressed string, and the string itself. The string is
       //  sent without trailing null byte; to read this you can use
       //  zstr_recv_compress, or a similar method that de-compresses and adds a
       //  null terminator on the received string.
       CZMQ_EXPORT int
           zstr_send_compress (void *dest, const char *string);

       //  *** Draft method, for development use, may change without warning ***
       //  Compress and send a C string to a socket, as zstr_send_compress(),
       //  with a MORE flag, so that you can send further strings in the same
       //  multi-part message.
       CZMQ_EXPORT int
           zstr_sendm_compress (void *dest, const char *string);

       //  *** Draft method, for development use, may change without warning ***
       //  Accepts a void pointer and returns a fresh character string. If source
       //  is null, returns an empty string.
       //  Caller owns return value and must destroy it when done.
       CZMQ_EXPORT char *
           zstr_str (void *source);

       #endif // CZMQ_BUILD_DRAFT_API
       Please add '@interface' section in './../src/zstr.c'.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The zstr class provides utility functions for sending and receiving C strings across 0MQ sockets. It
       sends strings without a terminating null, and appends a null byte on received strings. This class is for
       simple message sending.

                  Memory                       Wire
                  +-------------+---+          +---+-------------+
           Send   | S t r i n g | 0 |  ----&gt;   | 6 | S t r i n g |
                  +-------------+---+          +---+-------------+

                  Wire                         Heap
                  +---+-------------+          +-------------+---+
           Recv   | 6 | S t r i n g |  ----&gt;   | S t r i n g | 0 |
                  +---+-------------+          +-------------+---+

</pre><h4><b>EXAMPLE</b></h4><pre>
       <b>From</b> <b>zstr_test</b> <b>method</b>.

           //  Create two PAIR sockets and connect over inproc
           zsock_t *output = zsock_new_pair ("@inproc://zstr.test");
           assert (output);
           zsock_t *input = zsock_new_pair ("&gt;inproc://zstr.test");
           assert (input);

           //  Send ten strings, five strings with MORE flag and then END
           int string_nbr;
           for (string_nbr = 0; string_nbr &lt; 10; string_nbr++)
               zstr_sendf (output, "this is string %d", string_nbr);
           zstr_sendx (output, "This", "is", "almost", "the", "very", "END", NULL);

           //  Read and count until we receive END
           string_nbr = 0;
           for (string_nbr = 0;; string_nbr++) {
               char *string = zstr_recv (input);
               assert (string);
               if (streq (string, "END")) {
                   zstr_free (&amp;string);
                   break;
               }
               zstr_free (&amp;string);
           }
           assert (string_nbr == 15);

           #ifdef HAVE_LIBLZ4
           int ret = zstr_send_compress (output, "loooong");
           assert (ret == 0);
           char *string = zstr_recv_compress (input);
           assert (string);
           assert (streq (string, "loooong"));
           zstr_free (&amp;string);

           zstr_send_compress (output, "loooong");
           assert (ret == 0);
           zmsg_t *msg = zmsg_recv (input);
           assert (msg);
           assert (*((size_t *)zframe_data (zmsg_first (msg))) == strlen ("loooong"));
           zmsg_destroy (&amp;msg);
           #endif

           zsock_destroy (&amp;input);
           zsock_destroy (&amp;output);

           #if defined (ZMQ_SERVER)
           //  Test SERVER/CLIENT over zstr
           zsock_t *server = zsock_new_server ("inproc://zstr-test-routing");
           zsock_t *client = zsock_new_client ("inproc://zstr-test-routing");;
           assert (server);
           assert (client);

           //  Try normal ping-pong to check reply routing ID
           int rc = zstr_send (client, "Hello");
           assert (rc == 0);
           char *request = zstr_recv (server);
           assert (streq (request, "Hello"));
           assert (zsock_routing_id (server));
           freen (request);

           rc = zstr_send (server, "World");
           assert (rc == 0);
           char *reply = zstr_recv (client);
           assert (streq (reply, "World"));
           freen (reply);

           rc = zstr_sendf (server, "%s", "World");
           assert (rc == 0);
           reply = zstr_recv (client);
           assert (streq (reply, "World"));
           freen (reply);

           //  Try ping-pong using sendx and recx
           rc = zstr_sendx (client, "Hello", NULL);
           assert (rc == 0);
           rc = zstr_recvx (server, &amp;request, NULL);
           assert (rc &gt;= 0);
           assert (streq (request, "Hello"));
           freen (request);

           rc = zstr_sendx (server, "World", NULL);
           assert (rc == 0);
           rc = zstr_recvx (client, &amp;reply, NULL);
           assert (rc &gt;= 0);
           assert (streq (reply, "World"));
           freen (reply);

           //  Client and server disallow multipart
           rc = zstr_sendm (client, "Hello");
           assert (rc == -1);
           rc = zstr_sendm (server, "World");
           assert (rc == -1);

           zsock_destroy (&amp;client);
           zsock_destroy (&amp;server);
           #endif

           #if defined (__WINDOWS__)
           zsys_shutdown();
           #endif

</pre><h4><b>AUTHORS</b></h4><pre>
       The czmq manual was written by the authors in the AUTHORS file.

</pre><h4><b>RESOURCES</b></h4><pre>
       Main web site:

       Report bugs to the email &lt;<b><a href="mailto:zeromq-dev@lists.zeromq.org">zeromq-dev@lists.zeromq.org</a></b>[1]&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) the Contributors as noted in the AUTHORS file. This file is part of CZMQ, the high-level C
       binding for 0MQ: <a href="http://czmq.zeromq.org">http://czmq.zeromq.org</a>. This Source Code Form is subject to the terms of the Mozilla
       Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at
       <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. LICENSE included with the czmq distribution.

</pre><h4><b>NOTES</b></h4><pre>
        1. <a href="mailto:zeromq-dev@lists.zeromq.org">zeromq-dev@lists.zeromq.org</a>
           <a href="mailto:zeromq-dev@lists.zeromq.org">mailto:zeromq-dev@lists.zeromq.org</a>

CZMQ 4.2.1                                         05/24/2024                                            <u><a href="../man3/ZSTR.3.html">ZSTR</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>