<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modem::Vgetty - interface to vgetty(8)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmodem-vgetty-perl">libmodem-vgetty-perl_0.03-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Modem::Vgetty - interface to <a href="../man8/vgetty.8.html">vgetty</a>(8)

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use Modem::Vgetty;
               $v = new Modem::Vgetty;

               $string = $v-&gt;receive;
               $v-&gt;send($string);
               $string = $v-&gt;expect($str1, $str2, ...);
               $v-&gt;waitfor($string);
               $rv = $v-&gt;chat($expect1, $send1, $expect2, $send2, ...);

               $ttyname = $v-&gt;getty;
               $rv = $v-&gt;device($dev_type);
               $rv = $v-&gt;autostop($bool);
               $rv = $v-&gt;modem_type; # !!! see the docs below.

               $rv = $v-&gt;beep($freq, $len);
               $rv = $v-&gt;dial($number);
               $rv = $v-&gt;play($filename);
               $rv = $v-&gt;record($filename);
               $rv = $v-&gt;wait($seconds);
               $rv = $v-&gt;play_and_wait($filename);
               $v-&gt;stop;

               $v-&gt;add_handler($event, $handler_name, $handler);
               $v-&gt;del_handler($event, $handler_name);
               $v-&gt;enable_events;
               $v-&gt;disable_events;

               $number = $v-&gt;readnum($message, $tmout, $repeat);

               $v-&gt;shutdown;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Modem::Vgetty" is an encapsulation object for writing applications for voice modems using the <b><a href="../man8/vgetty.8.html">vgetty</a>(8)</b>
       or <b><a href="../man8/vm.8.html">vm</a>(8)</b> package. The answering machines and sofisticated voice applications can be written using this
       module.

</pre><h4><b>OVERVIEW</b></h4><pre>
       <u>Voice</u> <u>modem</u> is a special kind of modem, which (besides the normal data and/or fax mode) can communicate
       also in voice mode. It means it can record sounds it hears from the phone line to the file, Play-back
       recorded files, it can beep to the line, and it can detect various standard sounds coming from the line
       (busy tone, silence, dual tone modulation frequency (DTMF) keypad tones, etc).  An example of the voice
       modem can be the ZyXEL U1496, US Robotics Sportster (not Courier), etc.

       To use this software with the voice modem you need to have the <b><a href="../man8/vgetty.8.html">vgetty</a>(8)</b> package installed. <b>Vgetty</b> is
       distributed as a part of <b>mgetty</b> package. In fact, <b>vgetty</b> is a <b><a href="../man8/mgetty.8.html">mgetty</a>(8)</b> with the voice extensions. Vgetty
       has some support for scripting - when it receives an incoming call, it runs a voice shell (it is program
       specified in the <b>voice.conf</b> file) as its child process, establishes the read and write pipes to it, and
       tells it the number of the appropriate descriptors in the environment variables. Voice shell can now
       communicate with <b>vgetty</b>. It can tell <b>vgetty</b> "Play this file", or "Record anything you hear to that file",
       or "Notify me when user hangs up", etc. Sophisticated voice systems and answering machines can be build
       on top of <b>vgetty</b>.

       <b>mgetty</b> (including the <b>vgetty</b>) is available at the following URL:

               <a href="ftp://alpha.greenie.net/pub/mgetty/">ftp://alpha.greenie.net/pub/mgetty/</a>

       Originally there was a (Bourne) shell interface to <b>vgetty</b> only.  The <b>Modem::Vgetty</b> module allows user to
       write the voice shell in Perl.  The typical use is to write a script and point the <b>vgetty</b> to it (in
       <b>voice.conf</b> file). The script will be run when somebody calls in.  Another use is running voice shell from
       the <b><a href="../man8/vm.8.html">vm</a>(8)</b> program, which can for example dial somewhere and say something.

</pre><h4><b>QUICK</b> <b>START</b></h4><pre>
               #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>
               use Modem::Vgetty;
               my $v = new Modem::Vgetty;
               $v-&gt;add_handler('BUSY_TONE', 'endh', sub { $v-&gt;stop; <a href="../man0/exit.0.html">exit</a>(0); });
               local $SIG{ALRM} = sub { $v-&gt;stop; };
               $v-&gt;enable_events;
               $v-&gt;record('/tmp/hello.rmd');
               <a href="../man20/alarm.20.html">alarm</a>(20);
               $v-&gt;waitfor('READY');
               $v-&gt;shutdown;

       The above example installs the simple `exit now'-style handler for the <b>BUSY_TONE</b> event (which is sent by
       <b>vgetty</b> when user hangs up) and then records the <b>hello.rmd</b> file. Put this text into a file and then point
       <b>vgetty</b> to it in the <b>voice.conf</b>. After you dial into your voice modem, you can record a 20-seconds of some
       message.  Verify that <b>/tmp/hello.rmd</b> exists. Now delete the line contaning the word "record" and two
       subsequent lines and insert to the file the following line instead of them:

               $v-&gt;play_and_wait('/tmp/hello.rmd');

       Now call the voice modem and listen to the sounds you have just recorded.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Begin</b> <b>and</b> <b>end</b> <b>of</b> <b>communication</b>
       The <b>Modem::Vgetty</b> object will initialize the communication pipes to the <b>vgetty</b> at the creation time - in
       the constructor. The closing of the communication is done via the <b>shutdown</b> method:

               $v-&gt;shutdown;

       The module will call this method itself from the destructor, if you do not call it explicitly.

   <b>Low-level</b> <b>communication</b>
       Users probably don't want to use these methods directly. Use the higher-level functions instead.

       receive
           This  method  returns a string received from the <b>vgetty</b>. It parses the string for the event types and
           runs appropriate event handlers.  If event handler is run it waits for another string.

       send($string)
           This method sends the string <b>$string</b> to the <b>vgetty</b> process.

       expect($string1, $string2, ...)
           Receives a string from <b>vgetty</b> (using the <b>receive</b> method described above) and returns  it  iff  it  is
           equal  to  one of the strings in the argument list. When something different is received, this method
           returns <b>undef</b>.

       waitfor($string)
           Waits until the string <b>$sring</b> is received from <b>vgetty</b> (using the  <b>receive</b>  method  described  above).
           =item chat($expect1, $sent1, $expect2, $sent2, ...)

           A  chat-script  with  <b>vgetty</b>. Arguments are interpreted as the received-sent string pairs. A received
           string equals to the empty string means that no <b>receive</b> method will be called at that place. This can
           be used for constructing chat scripts beginning with the sent string instead of the received one.

   <b>Vgetty</b> <b>control</b> <b>methods</b>
       There are miscellaneous methods for controllig <b>vgetty</b> and querying its status.

       getty
           Returns the name of the modem special file (e.g. <b>/dev/ttyC4</b>).

       device($name)
           Sets the port of the voice modem input and output is  done  to.   Possible  values  are  qw(NO_DEVICE
           DIALUP_LINE EXTERNAL_MICROPHONE INTERNAL_SPEAKER LOCAL_HANDSET).

       autostop($bool)
           With  autostop on, the voicelib will automatically abort a play in progress and return READY. This is
           useful for faster reaction times for voice menus. Possible  arguments  are  qw(ON  OFF).   <b>Note:</b>  The
           interface  should  probably  be changed to accept the Perl boolean arguments (undef, something else).
           Returns defined value on success, undef on failure.

       modem_type
           <b>vgetty</b> currently has no way of telling voice shell the type of the current modem. This  method  is  a
           proposed  interface  for  determining  this  type. Currently returns <b>undef</b>. The appropriate low-level
           interface has to be implemented in <b>vgetty</b> first.

   <b>Voice</b> <b>commands</b>
       beep($freq, $len)
           Sends a beep through the chosen device using  given  frequency  (HZ)  and  length  (in  miliseconds).
           Returns a defined value on success or undef on failure.  The state of the vgetty changes to "BEEPING"
           and <b>vgetty</b> returns "READY" after a beep is finshed. Example:

                   $v-&gt;beep(50,10);
                   # Possibly do something else
                   $v-&gt;waitfor('READY');

       dial($number)
           Modem  tries  to  dial  a given number. The <b>vgetty</b> changes its state to "DIALING" and returns "READY"
           after the dialing is finished.

       play($filename)
           The <b>vgetty</b> tries to play the given file as a raw modem  data.   See  the  "Voice  data"  section  for
           details  on  creating  the raw modem data file. It changes the state to "PLAYING" and returns "READY"
           after playing the whole file.

       record($filename)
           The <b>vgetty</b> records the voice it can hear on the line to the given file.  It uses the raw  modem  data
           format  (which  can  be re-played using the <b>play</b> subroutine). <b>vgetty</b> changes its state to "RECORDING"
           and you need to manually stop the recording using the <b>stop</b> method after some time (or,  you  can  set
           <b>autostop</b> and wait for any event - silence, busy tone, etc).

       wait($seconds)
           The  modem  waits  for  a given number of seconds. Changes its state to "WAITING" and returns "READY"
           after the wait is finished. Example:

                   $v-&gt;<a href="../man5/wait.5.html">wait</a>(5);
                   $v-&gt;waitfor('READY');

       stop
           The <b>vgetty</b> stops anything it is currently doing and returns to the command state. You must  use  <b>stop</b>
           when  you  want to call another <b>beep</b>, <b>dial</b>, <b>play</b>, <b>record</b> or <b>wait</b> before the previous one is finished.
           The <b>vgetty</b> returns "READY" after the <b>stop</b> is called. So it is possible to interrupt  a  main  routine
           waiting for "READY" from the event handler:

                   my $dtmf;
                   $v-&gt;add_handler('RECEIVED_DTMF', 'readnum',
                           sub { my $self=shift; $self-&gt;stop; $dtmf = $_[2]; });
                   $v-&gt;enable_events;
                   $v-&gt;<a href="../man10/wait.10.html">wait</a>(10);
                   $v-&gt;waitfor('READY');

           In  the  previous example the <b>waitfor</b> method can be finished either by the 10-second timeout expired,
           or by the 'READY' generated by the <b>stop</b> in the event handler. See also the <b>Events</b> section.

       play_and_wait($file)
           It is an abbreviation for the following:

                   $v-&gt;play($file);
                   $v-&gt;waitfor('READY');

           It is repeated so much time in the voice applications so I have decided to make a special routine for
           it. I may add the similar routines for <b>dial</b>, <b>record</b>, <b>beep</b> and even <b>wait</b> in the future releases.

   <b>Event</b> <b>handler</b> <b>methods</b>
       add_handler($event, $handler_name, $handler)
           Installs a call-back routine $handler for the event type $event.  The  call-back  routine  is  called
           with  three  arguments. The first one is the Modem::Vgetty object itself, the second one is the event
           name and the third one is optional event argument.  The <b>$handler_name</b> argument can be anything. It is
           used when you want to delete this handler for identificating it.

       del_handler($event, $handler_name)
           This method deletes the handler $handler_name for the $event event.  The result of unregistering  the
           handler from the event handler of the same event is unspecified. It may or may not be called.

       enable_events
           Tells  the  <b>vgetty</b>  that the voice shell is willing to dispatch events.  No events are sent by <b>vgetty</b>
           until this method is called.

       disable_events
           Tells the <b>vgetty</b> that the voice shell doesn't want to receive any events anymore.

   <b>The</b> <b>readnum</b> <b>method</b>
       readnum($message, $tmout, $repeat)
           The applications often need to read the multi-digit number via the DTMF tones.   This  routine  plays
           the <b>$message</b> to the voice object and then waits for the sequence of the DTMF keys finished by the `#'
           key. If no key is pressed for <b>$tmout</b> of seconds, it re-plays the message again. It returns failure if
           no  key  is  pressed  after the message is played <b>$repeat</b>-th time. It returns a string (a sequence of
           DTMF tones 0-9,A-D and `*') without the  final  `#'.  When  some  DTMF  tones  are  received  and  no
           terminating  `#'  or  other  tone  is  received for <b>$tmout</b> seconds, the routine returns the string it
           currently has without waiting for the final '#'.  DTMF tones  are  accepted  even  at  the  time  the
           <b>$message</b>  is  played.   When  the  DTMF  tone  is received, the playing of the <b>$message</b> is (with some
           latency, of course) stopped.

           <b>NOTE:</b> The interface of this routine can be changed in future releases, because I am not (yet) decided
           whether the current interface is the best one.  See also the <b>EXAMPLES</b> section where the  source  code
           of this routine (and its co-routine) is discussed.

</pre><h4><b>EVENTS</b></h4><pre>
   <b>Introduction</b>
       Events  are asynchronous messages sent by <b>vgetty</b> to the voice shell.  The <b>Modem::Vgetty</b> module dispatches
       events itself in the <b>receive</b> method. User can register any number of handlers for each  event.   When  an
       event arrives, all handlers for that event are called (in no specified order).

   <b>Event</b> <b>types</b>
       At  this  time,  the <b>Modem::Vgetty</b> module recognizes the following event types (description is mostly re-
       typed from the <b>vgetty</b> documentation):

       BONG_TONE
           The modem detected a bong tone on the line.

       BUSY_TONE
           The modem detected busy tone on the line (when dialing to the busy number or when caller finished the
           call).

       CALL_WAITING
           Defined in IS-101 (I think it is when the line receives another call-in when some call is already  in
           progress. -Yenya).

       DIAL_TONE
           The modem detected dial tone on the line.

       DATA_CALLING_TONE
           The modem detected data calling tone on the line.

       DATA_OR_FAX_DETECTED
           The modem detected data or fax calling tones on the line.

       FAX_CALLING_TONE
           The modem detected fax calling tone on the line.

       HANDSET_ON_HOOK
           Locally connected handset went on hook.

       HANDSET_OFF_HOOK
           Locally connected handset went off hook.

       LOOP_BREAK
           Defined in IS-101.

       LOOP_POLARITY_CHANGE
           Defined in IS-101.

       NO_ANSWER
           After dialing the modem didn't detect answer for the time give in dial_timeout in voice.conf.

       NO_DIAL_TONE
           The  modem  didn't  detect  dial  tone  (make sure your modem is connected properly to your telephone
           company's line, or check the ATX command if dial tone in your system differs from the standard).

       NO_VOICE_ENERGY
           It means that the modem detected voice energy at the beginning of the session, but after  that  there
           was  a  period  of  some  time  of  silence (the actual time can be set using the <b>rec_silence_len</b> and
           <b>rec_silence_treshold</b> parameters in <b>voice.conf</b>).

       RING_DETECTED
           The modem detected an incoming ring.

       RINGBACK_DETECTED
           The modem detected a ringback condition on the line.

       RECEIVE_DTMF
           The modem detected a dtmf code. The actual code value (one of 0-9, *, #, A-D) is given to  the  event
           handler as the third argument.

       SILENCE_DETECTED
           The modem detected that there was no voice energy at the beginning of the session and after some time
           of  silence (the actual time can be set using the <b>rec_silence_len</b> and <b>rec_silence_treshold</b> parameters
           in <b>voice.conf</b>).

       SIT_TONE
           Defined in IS-101.

       TDD_DETECTED
           Defined in IS-101.

       VOICE_DETECTED
           The modem detected a voice signal on the line. IS-101 does not  define,  how  the  modem  makes  this
           decision, so be careful.

       UNKNOWN_EVENT
           None of the above :)

</pre><h4><b>VOICE</b> <b>DATA</b></h4><pre>
       Voice  shell  can send the voice data to the modem using the <b>play</b> method and record them using the <b>record</b>
       method. The ".rmd" extension (Raw Modem Data) is usually used for these files. The ".rmd" is not a single
       format - every modem has its own format (sampling frequency, data bit depth, etc). There  is  a  <b>pvftools</b>
       package  for  converting  the sound files (it is a set of filters similar to the <b>netpbm</b> for image files).
       The <b><a href="../man1/pvftormd.1.html">pvftormd</a>(1)</b> filter can be used to create the RMD files for all known types of modems.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Answering</b> <b>machine</b>
       A simple answering machine can look like this:

               #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>
               use Modem::Vgetty;
               my $voicemaster = 'root@localhost';
               my $tmout = 30;
               my $finish = 0;
               my $v = new Modem::Vgetty;
               $v-&gt;add_handler('BUSY_TONE', 'finish',
                       sub { $v-&gt;stop; $finish=1; });
               $v-&gt;add_handler('SILENCE_DETECTED', 'finish',
                       sub { $v-&gt;stop; $finish=1; });
               local $SIG{ALRM} = sub { $v-&gt;stop; };
               $v-&gt;enable_events;
               $v-&gt;play_and_wait('/path/welcome.rmd');
               $v-&gt;beep(100,10);
               $v-&gt;waitfor('READY');
               if ($finish == 0) {
                       my $num = 0;
                       $num++ while(-r "/path/$num.rmd");
                       $v-&gt;record("/path/$num.rmd");
                       alarm $tmout;
                       $v-&gt;waitfor('READY');
               }
               system "echo 'Play with rmdtopvf /path/$num.rmd|pvftoau &gt;/dev/audio'" .
                        " | mail -s 'New voice message' $voicemaster";
               exit 0;

       See the <b>examples/answering_machine.pl</b> in the source distribution,  which  contains  a  more  configurable
       version  of the above text.  It first sets the event handlers for the case of busy tone (the caller hangs
       up) or silence (the caller doesn't speak at all). The handler stops <b>vgetty</b> from anything it is  currently
       doing  and  sets  the  $finish variable to 1. Then the reception of the events is enabled and the welcome
       message is played. Then the answering machine beeps and starts to record the message. Note that  we  need
       to  check the $finish variable before we start recording to determine if user hanged up the phone. Now we
       find the first filename &lt;number&gt;.rmd such that this file does not  exist  and  we  start  to  record  the
       message to this file. We record until user hangs up the phone or until the timeout occurs.

   <b>Readnum</b> <b>routine</b>
       An  interesting  application  of  the low-level routines is the <b>Voice::Modem::readnum</b> method. The calling
       sequence of this method has been discussed above. The source code for this  routine  and  its  co-routine
       will  be  discussed here, so that you can write your own variants of <b>readnum</b> (which in fact does not have
       too general interface). See also the source code of <b>Vgetty.pm</b> for the <b>readnum</b> source.

       The <b>readnum</b> routine needs to have its own event handler for the  <b>RECEIVED_DTMF</b>  event  and  the  way  the
       handler can communicate with this routine. In our solution we use "static" variables:

               my $_readnum_number = '';
               my $_readnum_timeout = 10;
               my $_readnum_in_timeout = 1;

       The  event  handler  will  add  the  new  character  to  the  end  of  the <b>$_readnum_number</b> variable. The
       <b>$_readnum_timeout</b> is the number of seconds both <b>readnum</b> and the event handler should wait  for  the  next
       keypress, and the <b>$_readnum_in_timeout</b> is a flag used by the event handler for notifying the main <b>readnum</b>
       routine that it forced the <b>vgetty</b> to emit the `READY' message because of the final `#' has been received.

               sub _readnum_event {
                       my $self = shift;
                       my $input = shift; # Unused. Should be 'RECEIVED_DTMF'.
                       my $dtmf = shift;

                       if ($dtmf eq '#') { # Stop the reading now.
                               $_readnum_in_timeout = 0;
                               $self-&gt;stop;
                               $self-&gt;{LOG}-&gt;print("_readnum_event(): Got #; stopping\n");
                               return;
                       }
                       $_readnum_number .= $dtmf;
                       $self-&gt;stop;
                       $self-&gt;expect('READY');
                       # Restart the wait again.
                       $_readnum_in_timeout = 1;
                       $self-&gt;wait($_readnum_timeout);
               }

       The  event  handler  is installed for the `RECEIVED_DTMF' event only, so it doesn't need to check for the
       <b>$input</b> value. The actual DTMF key is in the third parameter, <b>$dtmf</b>. Note that the handler will be  called
       when  <b>vgetty</b>  is PLAYING or WAITING and the <b>readnum</b> routine will be waiting for the `READY' message. This
       allows us to immediately interrupt waiting by the <b>$self-</b>stop&gt; (which emits the `READY' message).  So when
       the `#' DTMF tone is received, we send a <b>stop</b> to <b>vgetty</b>.  If something else  is  received,  we  <b>stop</b>  the
       <b>vgetty</b> too but we enter a new wait using <b>$self-</b>wait&gt;.

               sub readnum {
                       my $self = shift;
                       my $message = shift;
                       my $timeout = shift;
                       my $times = shift;
                       $_readnum_number = '';
                       $_readnum_in_timeout = 1;
                       $_readnum_timeout = $timeout if $timeout != 0;
                       $times = 3 if $times == 0;

                       # Install the handler.
                       $self-&gt;add_handler('RECEIVED_DTMF', 'readnum', \&amp;_readnum_event);
                       while($_readnum_in_timeout != 0 &amp;&amp; $_readnum_number eq ''
                               &amp;&amp; $times-- &gt; 0) {
                               $self-&gt;play_and_wait($message);
                               last if $_readnum_in_timeout == 0;
                               while ($_readnum_in_timeout != 0) {
                                       $self-&gt;wait($_readnum_timeout);
                                       $self-&gt;expect('READY');
                               }
                       }
                       return undef if $times &lt; 0;
                       $self-&gt;del_handler('RECEIVED_DTMF', 'readnum');
                       $self-&gt;stop;
                       $self-&gt;expect('READY');
                       $_readnum_number;
               }

       The  <b>readnum</b>  routine  just  sets  up  the event handler, then plays the <b>$message</b> and waits for the input
       (possibly several times).  The main work is done in  the  event  handler.  At  the  end  the  handler  is
       unregistered and the final value is returned.

   <b>Callme</b> <b>script</b>
       In the <b>examples</b> subdirectory of the source distribution there is a <b>callme.pl</b> script. This dials the given
       number and plays the given message. Use the following command to run it:

               vm shell -S <a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> callme.pl &lt;number&gt; &lt;message&gt;.rmd

</pre><h4><b>BUGS</b></h4><pre>
       There  may  be  some,  but  it will more likely be in the <b>vgetty</b> itself.  On the other hand, there can be
       typos in this manual (English is not my native language) or some parts of the interface  that  should  be
       redesigned. Feel free to mail any comments on this module to me.

</pre><h4><b>TODO</b></h4><pre>
       Modem type recognition
           The <b>vgetty</b> should be able to tell the voice shell the name of the current modem type.

       The <b>_wait()</b> routines
           I need to implement the routines similar to <b>play_and_wait</b> for other <b>vgetty</b> states as well.

       Debugging information
           The  module  has currently some support for writing a debug logs (use the $Modem::Vgetty::testing = 1
           and watch the /var/log/voicelog file). This needs to be re-done using (I think) Sys::Syslog.  I  need
           to implement some kind of log-levels, etc.

       Mgetty/Vgetty 1.1.17
           Need  to  figure  out what is new in 1.1.17 (I use 1.1.14 now). I think new <b>vgetty</b> can play more than
           one file in the single `PLAY' command, it (I think) have some support for sending voice data  from/to
           the voice shell via the pipe, etc.

</pre><h4><b>AUTHOR</b></h4><pre>
       The  <b>Modem::Vgetty</b> package was written by Jan "Yenya" Kasprzak &lt;<a href="mailto:kas@fi.muni.cz">kas@fi.muni.cz</a>&gt;. Feel free to mail me any
       suggestions etc.  on this module. Module itself is  available  from  CPAN,  but  be  sure  to  check  the
       following address, where the development versions can be found:

               <a href="http://www.fi.muni.cz/~kas/vgetty/">http://www.fi.muni.cz/~kas/vgetty/</a>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright  (c)  1998  Jan  "Yenya"  Kasprzak  &lt;<a href="mailto:kas@fi.muni.cz">kas@fi.muni.cz</a>&gt;. All rights reserved. This package is free
       software; you can redistribute it and/or modify it under the same terms as Perl itself.

perl v5.34.0                                       2022-05-12                                        <u><a href="../man3pm/Vgetty.3pm.html">Vgetty</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>