<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moose::Manual::Roles - Roles, an alternative to deep hierarchies and base classes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmoose-perl">libmoose-perl_2.2207-1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Moose::Manual::Roles - Roles, an alternative to deep hierarchies and base classes

</pre><h4><b>VERSION</b></h4><pre>
       version 2.2207

</pre><h4><b>WHAT</b> <b>IS</b> <b>A</b> <b>ROLE?</b></h4><pre>
       A role encapsulates some piece of behavior or state that can be shared between classes. It is something
       that classes <u>do</u>. It is important to understand that <u>roles</u> <u>are</u> <u>not</u> <u>classes</u>. You cannot inherit from a
       role, and a role cannot be instantiated. We sometimes say that roles are <u>consumed</u>, either by classes or
       other roles.

       Instead, a role is <u>composed</u> into a class. In practical terms, this means that all of the methods, method
       modifiers, and attributes defined in a role are added directly to (we sometimes say "flattened into") the
       class that consumes the role. These attributes and methods then appear as if they were defined in the
       class itself. A subclass of the consuming class will inherit all of these methods and attributes.

       Moose roles are similar to mixins or interfaces in other languages and are based on the original concept
       of Traits &lt;<a href="http://scg.unibe.ch/research/traits/">http://scg.unibe.ch/research/traits/</a>&gt; for the Smalltalk-80 dialect Squeak.

       Besides defining their own methods and attributes, roles can also require that the consuming class define
       certain methods of its own. You could have a role that consisted only of a list of required methods, in
       which case the role would be very much like a Java interface.

       Note that attribute accessors also count as methods for the purposes of satisfying the requirements of a
       role.

</pre><h4><b>A</b> <b>SIMPLE</b> <b>ROLE</b></h4><pre>
       Creating a role looks a lot like creating a Moose class:

         package Breakable;

         use Moose::Role;

         has 'is_broken' =&gt; (
             is  =&gt; 'rw',
             isa =&gt; 'Bool',
         );

         sub break {
             my $self = shift;

             print "I broke\n";

             $self-&gt;<a href="../man1/is_broken.1.html">is_broken</a>(1);
         }

       Except for our use of Moose::Role, this looks just like a class definition with Moose. However, this is
       not a class, and it cannot be instantiated.

       Instead, its attributes and methods will be composed into classes which use the role:

         package Car;

         use Moose;

         with 'Breakable';

         has 'engine' =&gt; (
             is  =&gt; 'ro',
             isa =&gt; 'Engine',
         );

       The "with" function composes roles into a class. Once that is done, the "Car" class has an "is_broken"
       attribute and a "break" method. The "Car" class also does('Breakable'):

         my $car = Car-&gt;new( engine =&gt; Engine-&gt;new );

         print $car-&gt;is_broken ? 'Busted' : 'Still working';
         $car-&gt;break;
         print $car-&gt;is_broken ? 'Busted' : 'Still working';

         $car-&gt;does('Breakable'); # true

       This prints:

         Still working
         I broke
         Busted

       We could use this same role in a "Bone" class:

         package Bone;

         use Moose;

         with 'Breakable';

         has 'marrow' =&gt; (
             is  =&gt; 'ro',
             isa =&gt; 'Marrow',
         );

       See also Moose::Cookbook::Roles::Comparable_CodeReuse for an example.

       It's possible to compose existing roles into new roles. For example, we can have a "HandleWithCare" class
       which applies both the "Breakable" and "Package" roles to any class which consumes it:

         package HandleWithCare;

         use Moose::Role;

         with 'Breakable', 'Package';

</pre><h4><b>REQUIRED</b> <b>METHODS</b></h4><pre>
       As mentioned previously, a role can require that consuming classes provide one or more methods. Using our
       "Breakable" example, let's make it require that consuming classes implement their own "break" methods:

         package Breakable;

         use Moose::Role;

         requires 'break';

         has 'is_broken' =&gt; (
             is  =&gt; 'rw',
             isa =&gt; 'Bool',
         );

         after 'break' =&gt; sub {
             my $self = shift;

             $self-&gt;<a href="../man1/is_broken.1.html">is_broken</a>(1);
         };

       If we try to consume this role in a class that does not have a "break" method, we will get an exception.

       You can see that we added a method modifier on "break". We want classes that consume this role to
       implement their own logic for breaking, but we make sure that the "is_broken" attribute is always set to
       true when "break" is called.

         package Car

         use Moose;

         with 'Breakable';

         has 'engine' =&gt; (
             is  =&gt; 'ro',
             isa =&gt; 'Engine',
         );

         sub break {
             my $self = shift;

             if ( $self-&gt;is_moving ) {
                 $self-&gt;stop;
             }
         }

   <b>Roles</b> <b>Versus</b> <b>Abstract</b> <b>Base</b> <b>Classes</b>
       If you are familiar with the concept of abstract base classes in other languages, you may be tempted to
       use roles in the same way.

       You <u>can</u> define an "interface-only" role, one that contains <u>just</u> a list of required methods.

       However, any class which consumes this role must implement all of the required methods, either directly
       or through inheritance from a parent. You cannot delay the method requirement check so that they can be
       implemented by future subclasses.

       Because the role defines the required methods directly, adding a base class to the mix would not achieve
       anything. We recommend that you simply consume the interface role in each class which implements that
       interface.

</pre><h4><b>CONSUMING</b> <b>ROLES</b></h4><pre>
       Roles are consumed using the "with" function.

       Most of the time, you should only use one "with", even if you are consuming multiple roles. If you
       consume roles using multiple "with" statements Moose cannot detect method conflicts between those roles.

       Roles can be consumed by classes or by other roles. When a class consumes a role which in turn consumes
       other roles, the class gets all of the roles applied at once.

   <b>Required</b> <b>Methods</b> <b>Provided</b> <b>by</b> <b>Attributes</b>
       As mentioned before, a role's required method may also be satisfied by an attribute accessor. However,
       the call to "has" which defines an attribute happens at runtime. This means that you must define the
       attribute <u>before</u> consuming the role, or else the role will not see the generated accessor.  These
       attributes are Moose Attributes.

         package Breakable;

         use Moose::Role;

         requires 'stress';

         ########

         package Car;

         use Moose;

         has 'stress' =&gt; (
             is  =&gt; 'ro',
             isa =&gt; 'Int',
         );

         with 'Breakable';

       In general, we recommend that you always consume roles <u>after</u> declaring all your attributes.

       It may also be the case that a class wants to consume two roles where one role has an attribute providing
       a required method for another. For example:

         package Breakable;

         use Moose::Role;

         requires 'stress';

         ########

         package Stressable;

         use Moose::Role;

         has 'stress' =&gt; (
             is  =&gt; 'ro',
             isa =&gt; 'Int',
         );

         ########

         package Car;

         use Moose;

         # XXX - this will not work
         with 'Breakable', 'Stressable';

       However, this won't work. The problem is that the accessor methods created for the "stress" attribute
       won't be present in the class when the required method checks are done.

       There are two possible workarounds. The recommended one is to use "stub" subroutine(s) in the role
       providing the accessor(s):

         package Stressable;

         use Moose::Role;

         sub stress;
         has 'stress' =&gt; (
             is  =&gt; 'ro',
             isa =&gt; 'Int',
         );

       The "sub stress;" line is called a "forward" declaration in the Perl documentation. It creates what is
       called a "stub" subroutine, a declaration without a body. This is good enough to satisfy the required
       method checks done by Moose. The stub will not interfere with the creation of a real subroutine later.

       The other alternative is to use two separate calls to "with" in the consuming class:

         package Car;

         use Moose;

         # Not recommended
         with 'Stressable';
         with 'Breakable';

       Each "with" is run as it is seen. The first call will consume just the "Stressable" role, which will add
       the "stress" attribute to the "Car" package, which in turn will create an accessor method named "stress".
       Then when the "Breakable" role is consumed, the method it requires already exists.

       However, as mentioned earlier, multiple "with" declarations are not recommended, because method conflicts
       between the roles cannot be seen. In the example above, if both "Stressable" and "Breakable" contained
       methods of the same name, what would happen is that the version in "Stressable" would <u>silently</u> override
       the one in "Breakable".

</pre><h4><b>USING</b> <b>METHOD</b> <b>MODIFIERS</b></h4><pre>
       Method modifiers and roles are a very powerful combination.  Often, a role will combine method modifiers
       and required methods. We already saw one example with our "Breakable" example.

       Method modifiers increase the complexity of roles, because they make the role application order relevant.
       If a class uses multiple roles, each of which modify the same method, those modifiers will be applied in
       the same order as the roles are used:

         package MovieCar;

         use Moose;

         extends 'Car';

         with 'Breakable', 'ExplodesOnBreakage';

       Assuming that the new "ExplodesOnBreakage" role <u>also</u> has an "after" modifier on "break", the "after"
       modifiers will run one after the other. The modifier from "Breakable" will run first, then the one from
       "ExplodesOnBreakage".

</pre><h4><b>METHOD</b> <b>CONFLICTS</b></h4><pre>
       If a class composes multiple roles, and those roles have methods of the same name, we will have a
       conflict. In that case, the composing class is required to provide its <u>own</u> method of the same name.

         package Breakdancer;

         use Moose::Role;

         sub break {

         }

       If we compose both "Breakable" and "Breakdancer" in a class, we must provide our own "break" method:

         package FragileDancer;

         use Moose;

         with 'Breakable', 'Breakdancer';

         sub break { ... }

       A role can be a collection of other roles:

         package Break::Bundle;

         use Moose::Role;

         with ('Breakable', 'Breakdancer');

       When a role consumes another a role, the <u>consuming</u> role's methods silently win in any conflict, and the
       consumed role's methods are simply ignored.

</pre><h4><b>METHOD</b> <b>EXCLUSION</b> <b>AND</b> <b>ALIASING</b></h4><pre>
       If we want our "FragileDancer" class to be able to call the methods from both its roles, we can alias the
       methods:

         package FragileDancer;

         use Moose;

         with 'Breakable'   =&gt; { -alias =&gt; { break =&gt; 'break_bone' } },
              'Breakdancer' =&gt; { -alias =&gt; { break =&gt; 'break_dance' } };

       However, aliasing a method simply makes a <u>copy</u> of the method with the new name. We also need to exclude
       the original name:

         with 'Breakable' =&gt; {
             -alias    =&gt; { break =&gt; 'break_bone' },
             -excludes =&gt; 'break',
             },
             'Breakdancer' =&gt; {
             -alias    =&gt; { break =&gt; 'break_dance' },
             -excludes =&gt; 'break',
             };

       The excludes parameter prevents the "break" method from being composed into the "FragileDancer" class, so
       we don't have a conflict. This means that "FragileDancer" does not need to implement its own "break"
       method.

       This is useful, but it's worth noting that this breaks the contract implicit in consuming a role. Our
       "FragileDancer" class does both the "Breakable" and "BreakDancer", but does not provide a "break" method.
       If some API expects an object that does one of those roles, it probably expects it to implement that
       method.

       In some use cases we might alias and exclude methods from roles, but then provide a method of the same
       name in the class itself.

       Also see Moose::Cookbook::Roles::Restartable_AdvancedComposition for an example.

</pre><h4><b>OVERLOADING</b></h4><pre>
       When a Moose role uses overloading, that overloading is composed into any classes that consume the role.
       This includes the setting of the "fallback" value for that role's overloading. Just as with methods and
       attributes, when a role consumes another role, that other role's overloading settings are applied to the
       role.

       Just as with methods, there can be conflicts with overloading implementations between multiple roles when
       they are all consumed by a class. If two roles both provide different overloading implementations for a
       given operator, that is a conflict. If two roles both implement overloading and have different "fallback"
       values, that is also considered a conflict. These conflicts are detected when multiple roles are being
       composed into a class together.

       When a role consumes another role, the consuming role's overloading fallback and operator implementations
       silently "win" the conflict.

</pre><h4><b>ROLE</b> <b>EXCLUSION</b></h4><pre>
       A role can say that it cannot be combined with some other role. This should be used with great caution,
       since it limits the re-usability of the role.

         package Breakable;

         use Moose::Role;

         excludes 'BreakDancer';

</pre><h4><b>ADDING</b> <b>A</b> <b>ROLE</b> <b>TO</b> <b>AN</b> <b>OBJECT</b> <b>INSTANCE</b></h4><pre>
       You may want to add a role to an object instance, rather than to a class. For example, you may want to
       add debug tracing to one instance of an object while debugging a particular bug. Another use case might
       be to dynamically change objects based on a user's configuration, as a plugin system.

       The best way to do this is to use the apply_all_roles() function from Moose::Util:

         use Moose::Util qw( apply_all_roles );

         my $car = Car-&gt;new;
         apply_all_roles( $car, 'Breakable' );

       This function can apply more than one role at a time, and will do so using the normal Moose role
       combination system. We recommend using this function to apply roles to an object. This is what Moose uses
       internally when you call "with".

   <b>Handling</b> <b>required</b> <b>attributes</b> <b>for</b> <b>roles.</b>
       Application of some roles will require additional parameters being specified to satisfy them, for
       example:

           {
               package Car;
               use Moose;
           }
           {
               package Breakable;
               use Moose::Role;

               has 'breakable_parts' =&gt; ( is =&gt; 'ro', required =&gt; 1 );
           }

           my $car = Car-&gt;new;

           # next line dies with: Attribute (breakable_parts) is required
           apply_all_roles( $car, 'Breakable' );

       This will require passing the additional parameters at application time as follows:

           apply_all_roles( $car, 'Breakable' =&gt; {
                   rebless_params =&gt; {
                       # Parameters to 'Breakable'
                       breakable_parts =&gt; [qw( tires wheels windscreen )],
                   }
           });

       Obviously, this interface is better simplified as a method on "Car":

           sub make_breakable {
               my ( $self, %params ) = @_;
               apply_all_roles($self, 'Breakable', { rebless_params =&gt; \%params });
           }

           my $car = Car-&gt;new();
           $car-&gt;make_breakable( breakable_parts =&gt; [qw( tires wheels windscreen )] );

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Stevan Little &lt;<a href="mailto:stevan@cpan.org">stevan@cpan.org</a>&gt;

       •   Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;

       •   Jesse Luehrs &lt;<a href="mailto:doy@cpan.org">doy@cpan.org</a>&gt;

       •   Shawn M Moore &lt;<a href="mailto:sartak@cpan.org">sartak@cpan.org</a>&gt;

       •   יובל קוג'מן (Yuval Kogman) &lt;<a href="mailto:nothingmuch@woobling.org">nothingmuch@woobling.org</a>&gt;

       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   Florian Ragwitz &lt;<a href="mailto:rafl@debian.org">rafl@debian.org</a>&gt;

       •   Hans Dieter Pearcey &lt;<a href="mailto:hdp@cpan.org">hdp@cpan.org</a>&gt;

       •   Chris Prather &lt;<a href="mailto:chris@prather.org">chris@prather.org</a>&gt;

       •   Matt S Trout &lt;<a href="mailto:mstrout@cpan.org">mstrout@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2006 by Infinity Interactive, Inc.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.0                                       2024-10-20                          <u>Moose::Manual::<a href="../man3pm/Roles.3pm.html">Roles</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>