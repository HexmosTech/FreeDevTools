<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rose::DB::Informix - Informix driver class for Rose::DB.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librose-db-perl">librose-db-perl_0.786-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Rose::DB::Informix - Informix driver class for Rose::DB.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Rose::DB;

         Rose::DB-&gt;register_db(
           domain   =&gt; 'development',
           type     =&gt; 'main',
           driver   =&gt; 'Informix',
           database =&gt; 'dev_db',
           host     =&gt; 'localhost',
           username =&gt; 'devuser',
           password =&gt; 'mysecret',
           server_time_zone =&gt; 'UTC',
         );

         Rose::DB-&gt;default_domain('development');
         Rose::DB-&gt;default_type('main');
         ...

         # Set max length of varchar columns used to emulate the array data type
         Rose::DB::Informix-&gt;<a href="../man128/max_array_characters.128.html">max_array_characters</a>(128);

         $db = Rose::DB-&gt;new; # $db is really a Rose::DB::Informix-derived object

         $dt  = $db-&gt;parse_datetime_year_to_minute(...);
         $val = $db-&gt;format_datetime_year_to_minute($dt);

         $dt  = $db-&gt;parse_datetime_year_to_second(...);
         $val = $db-&gt;format_datetime_year_to_second($dt);
         ...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Rose::DB blesses objects into a class derived from Rose::DB::Informix when the driver is "informix".
       This mapping of driver names to class names is configurable.  See the documentation for Rose::DB's <b>new()</b>
       and <b>driver_class()</b> methods for more information.

       This class cannot be used directly.  You must use Rose::DB and let its <b>new()</b> method return an object
       blessed into the appropriate class for you, according to its <b>driver_class()</b> mappings.

       Only the methods that are new or have different behaviors than those in Rose::DB are documented here.
       See the Rose::DB documentation for the full list of methods.

</pre><h4><b>CLASS</b> <b>METHODS</b></h4><pre>
       <b>default_supports_limit_with_offset</b> <b>[BOOL]</b>
           Get  or  set  a  boolean  value that indicates whether or not all Informix databases that you plan to
           connect to support the "SELECT SKIP N FIRST M ..." syntax.  If undefined, this feature will be looked
           up on a per-connection basis as needed.  The default is undefined.

       <b>max_array_characters</b> <b>[INT]</b>
           Get or set the maximum length of varchar columns used to emulate the array data  type.   The  default
           value is 255.

           Informix  does  not  have a native "ARRAY" data type, but it can be emulated using a "VARCHAR" column
           and a specially formatted string.  The formatting and parsing  of  this  string  is  handled  by  the
           format_array()  and  parse_array()  object  methods.   The  maximum  length  limit  is honored by the
           format_array() object method.

           Informix does have a native "SET" data type, serviced by  the  parse_set()  and  format_set()  object
           methods.  This is a better choice than the emulated array data type if you don't care about the order
           of the stored values.

</pre><h4><b>OBJECT</b> <b>METHODS</b></h4><pre>
   <b>Value</b> <b>Parsing</b> <b>and</b> <b>Formatting</b>
       <b>format_array</b> <b>ARRAYREF</b> <b>|</b> <b>LIST</b>
           Given  a  reference  to  an array or a list of values, return a specially formatted string.  Undef is
           returned if ARRAYREF points to an empty array or if LIST is not passed.  The array or list  must  not
           contain undefined values.

           If the resulting string is longer than max_array_characters(), a fatal error will occur.

       <b>format_date</b> <b>DATETIME</b>
           Converts the DateTime object DATETIME into the appropriate format for the "DATE" data type.

       <b>format_datetime</b> <b>DATETIME</b>
           Converts  the  DateTime object DATETIME into the appropriate format for the "DATETIME YEAR TO SECOND"
           data type.

       <b>format_datetime_year_to_fraction</b> <b>DATETIME</b>
           Converts the DateTime object DATETIME into the appropriate format for the "DATETIME YEAR TO FRACTION"
           data type.

       <b>format_datetime_year_to_fraction_[1-5]</b> <b>DATETIME</b>
           Converts the DateTime object  DATETIME  into  the  appropriate  format  for  the  "DATETIME  YEAR  TO
           FRACTION(N)" data type, where N is an integer from 1 to 5.

       <b>format_datetime_year_to_minute</b> <b>DATETIME</b>
           Converts  the  DateTime object DATETIME into the appropriate format for the "DATETIME YEAR TO MINUTE"
           data type.

       <b>format_datetime_year_to_month</b> <b>DATETIME</b>
           Converts the DateTime object DATETIME into the appropriate format for the "DATETIME  YEAR  TO  MONTH"
           data type.

       <b>format_datetime_year_to_second</b> <b>DATETIME</b>
           Converts  the  DateTime object DATETIME into the appropriate format for the "DATETIME YEAR TO SECOND"
           data type.

       <b>format_set</b> <b>ARRAYREF</b> <b>|</b> <b>LIST</b>
           Given a reference to an array or a list of values, return a string formatted according to  the  rules
           of  Informix's "SET" data type.  Undef is returned if ARRAYREF points to an empty array or if LIST is
           not passed.  If the array or list contains undefined values, a fatal error will occur.

       <b>format_timestamp</b> <b>DATETIME</b>
           Converts the DateTime object  DATETIME  into  the  appropriate  format  for  the  "DATETIME  YEAR  TO
           <b><a href="../man5/FRACTION.5.html">FRACTION</a></b>(5)" data type.

       <b>parse_array</b> <b>STRING</b> <b>|</b> <b>LIST</b> <b>|</b> <b>ARRAYREF</b>
           Parse  STRING  and  return  a  reference  to  an  array.  STRING should be formatted according to the
           Informix array data type emulation format returned by format_array().  Undef is returned if STRING is
           undefined.

           If a LIST of more than one item is passed, a reference to an array containing the values in  LIST  is
           returned.

           If a an ARRAYREF is passed, it is returned as-is.

       <b>parse_boolean</b> <b>STRING</b>
           Parse  STRING  and  return  a  boolean  value  of  1  or  0.  STRING should be formatted according to
           Informix's native "boolean" data type.  Acceptable values are 't', 'T', or '1'  for  true,  and  'f',
           'F', or '0' for false.

           If  STRING  is  a valid boolean keyword (according to validate_boolean_keyword) or if it looks like a
           function call (matches /^\w+\(.*\)$/)  and  keyword_function_calls  is  true,  then  it  is  returned
           unmodified.  Returns undef if STRING could not be parsed as a valid "boolean" value.

       <b>parse_date</b> <b>STRING</b>
           Parse  STRING  and  return  a  DateTime object.  STRING should be formatted according to the Informix
           "DATE" data type.

           If STRING is a valid date keyword (according to validate_date_keyword)  it  is  returned  unmodified.
           Returns undef if STRING could not be parsed as a valid "DATE" value.

       <b>parse_datetime</b> <b>STRING</b>
           Parse  STRING  and  return  a  DateTime object.  STRING should be formatted according to the Informix
           "DATETIME YEAR TO SECOND" data type.

           If    STRING    is    a    valid    "datetime    year    to    second"    keyword    (according    to
           validate_datetime_year_to_second_keyword)  it  is returned unmodified.  Returns undef if STRING could
           not be parsed as a valid "DATETIME YEAR TO SECOND" value.

       <b>parse_datetime_year_to_fraction</b> <b>STRING</b>
           Parse STRING and return a DateTime object.  STRING should be  formatted  according  to  the  Informix
           "DATETIME YEAR TO FRACTION" data type.

           If    STRING    is    a    valid    "datetime    year    to    fraction"    keyword   (according   to
           validate_datetime_year_to_fraction_keyword) it is returned unmodified.  Returns undef if STRING could
           not be parsed as a valid "DATETIME YEAR TO FRACTION" value.

       <b>parse_datetime_year_to_fraction_[1-5]</b> <b>STRING</b>
           These five methods parse STRING and return a DateTime object.  STRING should be  formatted  according
           to the Informix "DATETIME YEAR TO FRACTION(N)" data type, where N is an integer from 1 to 5.

           If    STRING    is    a    valid    "datetime    year    to    fraction"    keyword   (according   to
           validate_datetime_year_to_fraction_keyword) it is returned unmodified.  Returns undef if STRING could
           not be parsed as a valid "DATETIME YEAR TO FRACTION(N)" value.

       <b>parse_datetime_year_to_minute</b> <b>STRING</b>
           Parse STRING and return a DateTime object.  STRING should be  formatted  according  to  the  Informix
           "DATETIME YEAR TO MINUTE" data type.

           If    STRING    is    a    valid    "datetime    year    to    minute"    keyword    (according    to
           validate_datetime_year_to_minute_keyword) it is returned unmodified.  Returns undef if  STRING  could
           not be parsed as a valid "DATETIME YEAR TO MINUTE" value.

       <b>parse_datetime_year_to_month</b> <b>STRING</b>
           Parse  STRING  and  return  a  DateTime object.  STRING should be formatted according to the Informix
           "DATETIME YEAR TO MINUTE" data type.

           If    STRING    is    a    valid    "datetime    year    to    month"    keyword    (according     to
           validate_datetime_year_to_month_keyword)  it  is  returned unmodified.  Returns undef if STRING could
           not be parsed as a valid "DATETIME YEAR TO MONTH" value.

       <b>parse_datetime_year_to_second</b> <b>STRING</b>
           Parse STRING and return a DateTime object.  STRING should be  formatted  according  to  the  Informix
           "DATETIME YEAR TO SECOND" data type.

           If    STRING    is    a    valid    "datetime    year    to    second"    keyword    (according    to
           validate_datetime_year_to_second_keyword) it is returned unmodified.  Returns undef if  STRING  could
           not be parsed as a valid "DATETIME YEAR TO SECOND" value.

       <b>parse_set</b> <b>STRING</b> <b>|</b> <b>LIST</b> <b>|</b> <b>ARRAYREF</b>
           Parse  STRING and return a reference to an array.  STRING should be formatted according to Informix's
           "SET" data type.  Undef is returned if STRING is undefined.

           If a LIST of more than one item is passed, a reference to an array containing the values in  LIST  is
           returned.

           If a an ARRAYREF is passed, it is returned as-is.

       <b>parse_timestamp</b> <b>STRING</b>
           Parse  STRING  and  return  a  DateTime object.  STRING should be formatted according to the Informix
           "DATETIME YEAR TO <b><a href="../man5/FRACTION.5.html">FRACTION</a></b>(5)" data type.

           If STRING is a valid timestamp keyword  (according  to  validate_timestamp_keyword)  it  is  returned
           unmodified.   Returns  undef  if STRING could not be parsed as a valid "DATETIME YEAR TO <b><a href="../man5/FRACTION.5.html">FRACTION</a></b>(5)"
           value.

       <b>validate_boolean_keyword</b> <b>STRING</b>
           Returns true if STRING is a valid keyword for the "boolean" data type of  the  current  data  source,
           false otherwise.  Valid (case-insensitive) boolean keywords are:

               TRUE
               FALSE

       <b>validate_date_keyword</b> <b>STRING</b>
           Returns  true  if  STRING is a valid keyword for the Informix "date", false otherwise.   Valid (case-
           insensitive) date keywords are:

               current
               today

           The keywords are  not  case  sensitive.   Any  string  that  looks  like  a  function  call  (matches
           /^\w+\(.*\)$/) is also considered a valid date keyword if keyword_function_calls is true.

       <b>validate_datetime_keyword</b> <b>STRING</b>
           Returns true if STRING is a valid keyword for the Informix "datetime year to second" data type, false
           otherwise.  Valid (case-insensitive) datetime keywords are:

               current
               current year to second
               current year to minute
               current year to hour
               current year to day
               current year to month
               today

           The  keywords  are  not  case  sensitive.   Any  string  that  looks  like  a  function call (matches
           /^\w+\(.*\)$/) is also considered a valid datetime keyword if keyword_function_calls is true.

       <b>validate_datetime_year_to_fraction_keyword</b> <b>STRING</b>
           Returns true if STRING is a valid keyword for the Informix "datetime year to fraction(n)"  data  type
           (where  n  is  an  integer from 1 to 5), false otherwise.  Valid (case-insensitive) "datetime year to
           fraction" keywords are:

               current
               current year to fraction
               current year to <a href="../man1/fraction.1.html">fraction</a>(1)
               current year to <a href="../man2/fraction.2.html">fraction</a>(2)
               current year to <a href="../man3/fraction.3.html">fraction</a>(3)
               current year to <a href="../man4/fraction.4.html">fraction</a>(4)
               current year to <a href="../man5/fraction.5.html">fraction</a>(5)
               current year to second
               current year to minute
               current year to hour
               current year to day
               current year to month
               today

           The keywords are  not  case  sensitive.   Any  string  that  looks  like  a  function  call  (matches
           /^\w+\(.*\)$/)   is   also   considered   a   valid   "datetime   year   to   fraction"   keyword  if
           keyword_function_calls is true.

       <b>validate_datetime_year_to_minute_keyword</b> <b>STRING</b>
           Returns true if STRING is a valid keyword for the Informix "datetime year to minute" data type, false
           otherwise.  Valid (case-insensitive) "datetime year to minute" keywords are:

               current
               current year to second
               current year to minute
               current year to hour
               current year to day
               current year to month
               today

           The keywords are  not  case  sensitive.   Any  string  that  looks  like  a  function  call  (matches
           /^\w+\(.*\)$/) is also considered a valid "datetime year to minute" keyword if keyword_function_calls
           is true.

       <b>validate_datetime_year_to_month_keyword</b> <b>STRING</b>
           Returns  true if STRING is a valid keyword for the Informix "datetime year to month" data type, false
           otherwise.  Valid (case-insensitive) "datetime year to month" keywords are:

               current
               current year to second
               current year to minute
               current year to hour
               current year to day
               current year to month
               today

           The keywords are  not  case  sensitive.   Any  string  that  looks  like  a  function  call  (matches
           /^\w+\(.*\)$/)  is also considered a valid "datetime year to month" keyword if keyword_function_calls
           is true.

       <b>validate_datetime_year_to_second_keyword</b> <b>STRING</b>
           Returns true if STRING is a valid keyword for the Informix "datetime year to second" data type, false
           otherwise.  Valid (case-insensitive) datetime keywords are:

               current
               current year to second
               current year to minute
               current year to hour
               current year to day
               current year to month
               today

           The keywords are  not  case  sensitive.   Any  string  that  looks  like  a  function  call  (matches
           /^\w+\(.*\)$/) is also considered a valid "datetime year to second" keyword if keyword_function_calls
           is true.

       <b>validate_timestamp_keyword</b> <b>STRING</b>
           Returns  true  if  STRING is a valid keyword for the Informix "timestamp" data type, false otherwise.
           Valid (case-insensitive) timestamp keywords are:

               current
               current year to fraction
               current year to <a href="../man1/fraction.1.html">fraction</a>(1)
               current year to <a href="../man2/fraction.2.html">fraction</a>(2)
               current year to <a href="../man3/fraction.3.html">fraction</a>(3)
               current year to <a href="../man4/fraction.4.html">fraction</a>(4)
               current year to <a href="../man5/fraction.5.html">fraction</a>(5)
               current year to second
               current year to minute
               current year to hour
               current year to day
               current year to month
               today

           The keywords are  not  case  sensitive.   Any  string  that  looks  like  a  function  call  (matches
           /^\w+\(.*\)$/) is also considered a valid timestamp keyword if keyword_function_calls is true.

</pre><h4><b>AUTHOR</b></h4><pre>
       John C. Siracusa (<a href="mailto:siracusa@gmail.com">siracusa@gmail.com</a>)

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright  (c)  2010  by  John C. Siracusa.  All rights reserved.  This program is free software; you can
       redistribute it and/or modify it under the same terms as Perl itself.

perl v5.40.0                                       2024-08-29                            <u>Rose::DB::<a href="../man3pm/Informix.3pm.html">Informix</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>