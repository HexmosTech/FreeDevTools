<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rose::DB::SQLite - SQLite driver class for Rose::DB.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librose-db-perl">librose-db-perl_0.786-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Rose::DB::SQLite - SQLite driver class for Rose::DB.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Rose::DB;

         Rose::DB-&gt;register_db(
           domain   =&gt; 'development',
           type     =&gt; 'main',
           driver   =&gt; 'sqlite',
           database =&gt; '/path/to/some/file.db',
         );

         Rose::DB-&gt;default_domain('development');
         Rose::DB-&gt;default_type('main');
         ...

         # Set max length of varchar columns used to emulate the array data type
         Rose::DB::SQLite-&gt;<a href="../man128/max_array_characters.128.html">max_array_characters</a>(128);

         $db = Rose::DB-&gt;new; # $db is really a Rose::DB::SQLite-derived object
         ...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Rose::DB blesses objects into a class derived from Rose::DB::SQLite when the driver is "sqlite".  This
       mapping of driver names to class names is configurable.  See the documentation for Rose::DB's <b>new()</b> and
       <b>driver_class()</b> methods for more information.

       This class cannot be used directly.  You must use Rose::DB and let its <b>new()</b> method return an object
       blessed into the appropriate class for you, according to its <b>driver_class()</b> mappings.

       This class supports SQLite version 3 only.  See the SQLite web site for more information on the major
       versions of SQLite:

       &lt;<a href="http://www.sqlite.org/">http://www.sqlite.org/</a>&gt;

       Only the methods that are new or have different behaviors than those in Rose::DB are documented here.
       See the Rose::DB documentation for the full list of methods.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       SQLite doesn't care what value you pass for a given column, regardless of that column's nominal data
       type.  Rose::DB does care, however.  The following data type formats are enforced by Rose::DB::SQLite's
       parse_* and format_* functions.

           Type        Format
           ---------   ------------------------------
           DATE        YYYY-MM-DD
           DATETIME    YYYY-MM-DD HH:MM::SS
           TIMESTAMP   YYYY-MM-DD HH:MM::SS.NNNNNNNNN

</pre><h4><b>CLASS</b> <b>METHODS</b></h4><pre>
       <b>coerce_autoincrement_to_serial</b> <b>[BOOL]</b>
           Get  or set a boolean value that indicates whether or not "auto-increment" columns will be considered
           to have the column type  "serial."  The default value is true.

           This setting comes into play when Rose::DB::Object::Loader is used  to  auto-create  column  metadata
           based on an existing database schema.

       <b>max_array_characters</b> <b>[INT]</b>
           Get  or  set  the maximum length of varchar columns used to emulate the array data type.  The default
           value is 255.

           SQLite does not have a native "ARRAY" data type, but it can be emulated using a "VARCHAR" column  and
           a  specially  formatted  string.   The  formatting  and  parsing  of  this  string  is handled by the
           format_array() and parse_array() object  methods.   The  maximum  length  limit  is  honored  by  the
           format_array() object method.

</pre><h4><b>OBJECT</b> <b>METHODS</b></h4><pre>
       <b>auto_create</b> <b>[BOOL]</b>
           Get  or  set  a boolean value indicating whether or not a new SQLite database should be created if it
           does not already exist.  Defaults to true.

           If false, and if the specified database does not exist, then a fatal error will occur when an attempt
           is made to connect to the database.

       <b>sqlite_unicode</b> <b>[BOOL]</b>
           Get or set a boolean value that indicates whether or not Perl's UTF-8 flag will be set for  all  text
           strings coming out of the database.  See the DBD::SQLite documentation for more information.

   <b>Value</b> <b>Parsing</b> <b>and</b> <b>Formatting</b>
       <b>format_array</b> <b>ARRAYREF</b> <b>|</b> <b>LIST</b>
           Given  a  reference  to  an array or a list of values, return a specially formatted string.  Undef is
           returned if ARRAYREF points to an empty array or if LIST is not passed.  The array or list  must  not
           contain undefined values.

           If the resulting string is longer than max_array_characters(), a fatal error will occur.

       <b>parse_array</b> <b>STRING</b> <b>|</b> <b>LIST</b> <b>|</b> <b>ARRAYREF</b>
           Parse  STRING and return a reference to an array.  STRING should be formatted according to the SQLite
           array data type emulation format  returned  by  format_array().   Undef  is  returned  if  STRING  is
           undefined.

           If  a  LIST of more than one item is passed, a reference to an array containing the values in LIST is
           returned.

           If a an ARRAYREF is passed, it is returned as-is.

       <b>parse_date</b> <b>STRING</b>
           Parse STRING and return a DateTime object.  STRING should be  formatted  according  to  the  Informix
           "DATE" data type.

           If  STRING  is  a  valid date keyword (according to validate_date_keyword) it is returned unmodified.
           Returns undef if STRING could not be parsed as a valid "DATE" value.

       <b>parse_datetime</b> <b>STRING</b>
           Parse STRING and return a DateTime object.  STRING should be  formatted  according  to  the  Informix
           "DATETIME" data type.

           If  STRING  is  a  valid  datetime  keyword  (according  to validate_datetime_keyword) it is returned
           unmodified.  Returns undef if STRING could not be parsed as a valid "DATETIME" value.

       <b>parse_timestamp</b> <b>STRING</b>
           Parse STRING and return a DateTime object.  STRING should be  formatted  according  to  the  Informix
           "DATETIME" data type.

           If  STRING  is  a  valid  timestamp  keyword (according to validate_timestamp_keyword) it is returned
           unmodified.  Returns undef if STRING could not be parsed as a valid "DATETIME" value.

       <b>validate_date_keyword</b> <b>STRING</b>
           Returns true if STRING is a valid keyword for the "date" data type.  Valid date keywords are:

               current_timestamp

           The keywords are  not  case  sensitive.   Any  string  that  looks  like  a  function  call  (matches
           /^\w+\(.*\)$/) is also considered a valid date keyword if keyword_function_calls is true.

       <b>validate_datetime_keyword</b> <b>STRING</b>
           Returns  true  if  STRING  is  a  valid keyword for the "datetime" data type, false otherwise.  Valid
           datetime keywords are:

               current_timestamp

           The keywords are  not  case  sensitive.   Any  string  that  looks  like  a  function  call  (matches
           /^\w+\(.*\)$/) is also considered a valid datetime keyword if keyword_function_calls is true.

       <b>validate_timestamp_keyword</b> <b>STRING</b>
           Returns  true  if  STRING  is  a valid keyword for the "timestamp" data type, false otherwise.  Valid
           timestamp keywords are:

               current_timestamp

           The keywords are  not  case  sensitive.   Any  string  that  looks  like  a  function  call  (matches
           /^\w+\(.*\)$/) is also considered a valid timestamp keyword if keyword_function_calls is true.

</pre><h4><b>AUTHOR</b></h4><pre>
       John C. Siracusa (<a href="mailto:siracusa@gmail.com">siracusa@gmail.com</a>)

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright  (c)  2010  by  John C. Siracusa.  All rights reserved.  This program is free software; you can
       redistribute it and/or modify it under the same terms as Perl itself.

perl v5.40.0                                       2024-08-29                              <u>Rose::DB::<a href="../man3pm/SQLite.3pm.html">SQLite</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>