<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Syntax</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openmpi-doc">openmpi-doc_5.0.7-1build1_all</a> <br><br><pre>
</pre><h4><b>SYNTAX</b></h4><pre>
   <b>C</b> <b>Syntax</b>
          #include &lt;mpi.h&gt;

          int MPI_Pack_external(const char *datarep, const void *inbuf,
               int incount, MPI_Datatype datatype,
               void *outbuf, MPI_Aint outsize,
               MPI_Aint *position)

   <b>Fortran</b> <b>Syntax</b>
          USE MPI
          ! or the older form: INCLUDE 'mpif.h'
          MPI_PACK_EXTERNAL(DATAREP, INBUF, INCOUNT, DATATYPE,
               OUTBUF, OUTSIZE, POSITION, IERROR)

               INTEGER         INCOUNT, DATATYPE, IERROR
               INTEGER(KIND=MPI_ADDRESS_KIND) OUTSIZE, POSITION
               CHARACTER*(*)   DATAREP
               &lt;type&gt;          INBUF(*), OUTBUF(*)

   <b>Fortran</b> <b>2008</b> <b>Syntax</b>
          USE mpi_f08
          MPI_Pack_external(datarep, inbuf, incount, datatype, outbuf, outsize,
                       position, ierror)
               CHARACTER(LEN=*), INTENT(IN) :: datarep
               TYPE(*), DIMENSION(..), INTENT(IN) :: inbuf
               TYPE(*), DIMENSION(..) :: outbuf
               INTEGER, INTENT(IN) :: incount
               TYPE(MPI_Datatype), INTENT(IN) :: datatype
               INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: outsize
               INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(INOUT) :: position
               INTEGER, OPTIONAL, INTENT(OUT) :: ierror

</pre><h4><b>INPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>datarep</b>: Data representation (string).

       • <b>inbuf</b>: Input buffer start (choice).

       • <b>incount</b>: Number of input data items (integer).

       • <b>datatype</b>: Datatype of each input data item (handle).

       • <b>outsize</b>: Output buffer size, in bytes (integer).

</pre><h4><b>INPUT/OUTPUT</b> <b>PARAMETER</b></h4><pre>
       • <b>position</b>: Current position in buffer, in bytes (integer).

</pre><h4><b>OUTPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>outbuf</b>: Output buffer start (choice).

       • <b>ierror</b>: Fortran only: Error status (integer).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>MPI_Pack_external</u>  packs  data into the external32 format, a universal data representation defined by the
       MPI Forum. This format is useful for exchanging data between MPI implementations, or when writing data to
       a file.

       The input buffer is specified by <u>inbuf</u>, <u>incount</u> and <u>datatype</u>, and may be any communication buffer allowed
       in <u>MPI_Send</u>. The output buffer <u>outbuf</u> must be a contiguous storage area containing <u>outsize</u> bytes.

       The input value of <u>position</u> is the first position in <u>outbuf</u> to be used for packing  (measured  in  bytes,
       not elements, relative to the start of the buffer). When the function returns, <u>position</u> is incremented by
       the  size  of  the packed message, so that it points to the first location in <u>outbuf</u> following the packed
       message. This way it may be used as input to a subsequent call to <u>MPI_Pack_external</u>.

       <b>Example:</b> An example using <u>MPI_Pack_external</u>:

          int position, i;
          double msg[5];
          char buf[1000];

          ...

          MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);
          if (myrank == 0) {      /* SENDER CODE */
                  position = 0;
                  i = 5; /* number of doubles in msg[] */
                  MPI_Pack_external("external32", &amp;i, 1, MPI_INT,
                      buf, 1000, &amp;position);
                  MPI_Pack_external("external32", &amp;msg, i, MPI_DOUBLE,
                      buf, 1000, &amp;position);
                  MPI_Send(buf, position, MPI_BYTE, 1, 0,
                      MPI_COMM_WORLD);
          } else {                /* RECEIVER CODE */
                  MPI_Recv(buf, 1, MPI_BYTE, 0, 0, MPI_COMM_WORLD,
                      MPI_STATUS_IGNORE);
                  MPI_Unpack_external("external32", buf, 1000,
                      MPI_INT, &amp;i, 1, &amp;position);
                  MPI_Unpack_external("external32", buf, 1000,
                      MPI_DOUBLE, &amp;msg, i, &amp;position);
          }

</pre><h4><b>NOTES</b></h4><pre>
       The <u>datarep</u> argument specifies the data format. The only valid value in the current  version  of  MPI  is
       “external32”. The argument is provided for future extensibility.

       To understand the behavior of pack and unpack, it is convenient to think of the data part of a message as
       being  the  sequence  obtained  by  concatenating  the  successive  values sent in that message. The pack
       operation stores this sequence in the buffer space, as if sending the message to that buffer. The  unpack
       operation  retrieves  this sequence from buffer space, as if receiving a message from that buffer. (It is
       helpful to think of internal Fortran files or sscanf in C for a similar function.)

       Several messages can be successively packed into one packing unit. This is effected by several successive
       related calls to <u>MPI_Pack_external</u>, where the first call provides <u>position</u>=0, and  each  successive  call
       inputs  the value of <u>position</u> that was output by the previous call, along with the same values for <u>outbuf</u>
       and <u>outcount</u>. This packing unit now contains the equivalent information that would have been stored in  a
       message by one send call with a send buffer that is the “concatenation” of the individual send buffers.

       A  packing  unit can be sent using type MPI_BYTE. Any point-to-point or collective communication function
       can be used to move the sequence of bytes that forms the packing unit from one process to  another.  This
       packing unit can now be received using any receive operation, with any datatype. (The type-matching rules
       are relaxed for messages sent with type MPI_BYTE.)

       A  packing  unit can be unpacked into several successive messages. This is effected by several successive
       related calls to <u>MPI_Unpack_external</u>, where the first call provides <u>position</u>=0, and each successive  call
       inputs  the  value  of  position  that was output by the previous call, and the same values for <u>inbuf</u> and
       <u>insize</u>.

       The concatenation of two packing units is not necessarily a packing unit; nor is a substring of a packing
       unit necessarily a packing unit.  Thus, one cannot concatenate two packing  units  and  then  unpack  the
       result  as one packing unit; nor can one unpack a substring of a packing unit as a separate packing unit.
       Each packing unit that was created by a related sequence of pack calls must be unpacked as a  unit  by  a
       sequence of related unpack calls.

</pre><h4><b>ERRORS</b></h4><pre>
       Almost  all  MPI  routines  return  an  error  value; C routines as the return result of the function and
       Fortran routines in the last argument.

       Before the error value is returned, the current MPI  error  handler  associated  with  the  communication
       object  (e.g.,  communicator, window, file) is called.  If no communication object is associated with the
       MPI call, then the call is considered attached to MPI_COMM_SELF and will call the  associated  MPI  error
       handler.   When   MPI_COMM_SELF   is   not  initialized  (i.e.,  before  <u>MPI_Init</u>/<u>MPI_Init_thread</u>,  after
       <u>MPI_Finalize</u>, or when using the Sessions Model exclusively) the error raises the initial  error  handler.
       The  initial  error handler can be changed by calling <u>MPI_Comm_set_errhandler</u> on MPI_COMM_SELF when using
       the World model, or the mpi_initial_errhandler CLI argument to mpiexec or info  key  to  <u>MPI_Comm_spawn</u>/‐
       <u>MPI_Comm_spawn_multiple</u>.   If no other appropriate error handler has been set, then the MPI_ERRORS_RETURN
       error handler is called for MPI I/O functions and the MPI_ERRORS_ABORT error handler is  called  for  all
       other MPI functions.

       Open MPI includes three predefined error handlers that can be used:

       • <b>MPI_ERRORS_ARE_FATAL</b> Causes the program to abort all connected MPI processes.

       • <b>MPI_ERRORS_ABORT</b> An error handler that can be invoked on a communicator, window, file, or session. When
         called  on  a  communicator,  it  acts  as if <u>MPI_Abort</u> was called on that communicator. If called on a
         window or file, acts as if <u>MPI_Abort</u> was called on a communicator containing the group of processes  in
         the corresponding window or file. If called on a session, aborts only the local process.

       • <b>MPI_ERRORS_RETURN</b> Returns an error code to the application.

       MPI applications can also implement their own error handlers by calling:

       • <u>MPI_Comm_create_errhandler</u> then <u>MPI_Comm_set_errhandler</u>

       • <u>MPI_File_create_errhandler</u> then <u>MPI_File_set_errhandler</u>

       • <u>MPI_Session_create_errhandler</u> then <u>MPI_Session_set_errhandler</u> or at <u>MPI_Session_init</u>

       • <u>MPI_Win_create_errhandler</u> then <u>MPI_Win_set_errhandler</u>

       Note that MPI does not guarantee that an MPI program can continue past an error.

       See the <u>MPI</u> <u>man</u> <u>page</u> for a full list of <u>MPI</u> <u>error</u> <u>codes</u>.

       See the Error Handling section of the MPI-3.1 standard for more information.

       <b>SEE</b> <b>ALSO:</b>

          • <u>MPI_Pack_external_size</u>

          • <u>MPI_Send</u>

          • <u>MPI_Unpack_external</u>

          • <a href="../man3C/sscanf.3C.html">sscanf</a>(3C)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2003-2025, The Open MPI Community

                                                  Jun 07, 2025                              <u><a href="../man3/MPI_PACK_EXTERNAL.3.html">MPI_PACK_EXTERNAL</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>