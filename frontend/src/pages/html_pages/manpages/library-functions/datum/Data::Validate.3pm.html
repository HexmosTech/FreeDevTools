<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Validate - common data validation methods</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-validate-perl">libdata-validate-perl_0.09-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Validate - common data validation methods

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Data::Validate qw(:math);

         if(defined(is_integer($suspect))){
               print "Looks like an integer\n";
         }

         my $name = is_alphanumeric($suspect);
         if(defined($name)){
               print "$name is alphanumeric, and has been untainted\n";
         } else {
               print "$suspect was not alphanumeric"
         }

         # or as an object
         my $v = Data::Validate-&gt;new();

         die "'foo' is not an integer" unless defined($v-&gt;is_integer('foo'));

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module collects common validation routines to make input validation, and untainting easier and more
       readable.  Most of the functions are not much shorter than their direct perl equivalent (and are much
       longer in some cases), but their names make it clear what you're trying to test for.

       Almost all functions return an untainted value if the test passes, and undef if it fails.  This means
       that you should always check for a defined status explicitly.  Don't assume the return will be true.
       (e.g. <b><a href="../man0/is_integer.0.html">is_integer</a></b>(0))

       The value to test is always the first (and often only) argument.

</pre><h4><b>FUNCTIONS</b></h4><pre>
           <b>new</b> - constructor for OO usage

             new();

           <u>Description</u>
               Returns  a  Data::Validator  object.   This  lets  you access all the validator function calls as
               methods   without   importing   them    into    your    namespace    or    using    the    clumsy
               <b>Data::Validate::function_name()</b> format.

           <u>Arguments</u>
               None

           <u>Returns</u>
               Returns a Data::Validate object

           <b>is_integer</b> - is the value an integer?

             is_integer($value);

           <u>Description</u>
               Returns  the  untainted  number  if the test value is an integer, or can be cast to one without a
               loss of precision.  (i.e. 1.0 is considered an integer, but 1.0001 is not.)

           <u>Arguments</u>
               $value
                   The potential integer to test.

           <u>Returns</u>
               Returns the untainted integer on success, undef on failure.  Note that the return can  be  0,  so
               always check with <b>defined()</b>

           <u>Notes,</u> <u>Exceptions,</u> <u>&amp;</u> <u>Bugs</u>
               Number translation is done by POSIX casting tools (strtol).

           <b>is_numeric</b> - is the value numeric?

             is_numeric($value);

           <u>Description</u>
               Returns the untainted number if the test value is numeric according to Perl's own internal rules.
               (actually a wrapper on Scalar::Util::looks_like_number)

           <u>Arguments</u>
               $value
                   The potential number to test.

           <u>Returns</u>
               Returns  the  untainted  number  on success, undef on failure.  Note that the return can be 0, so
               always check with <b>defined()</b>

           <u>Notes,</u> <u>Exceptions,</u> <u>&amp;</u> <u>Bugs</u>
               Number translation is done by POSIX casting tools (strtol).

           <b>is_hex</b> - is the value a hex number?

             is_hex($value);

           <u>Description</u>
               Returns the untainted number if the test value is a hex number.

           <u>Arguments</u>
               $value
                   The potential number to test.

           <u>Returns</u>
               Returns the untainted number on success, undef on failure.  Note that the return  can  be  0,  so
               always check with <b>defined()</b>

           <u>Notes,</u> <u>Exceptions,</u> <u>&amp;</u> <u>Bugs</u>
               None

           <b>is_oct</b> - is the value an octal number?

             is_oct($value);

           <u>Description</u>
               Returns the untainted number if the test value is a octal number.

           <u>Arguments</u>
               $value
                   The potential number to test.

           <u>Returns</u>
               Returns  the  untainted  number  on success, undef on failure.  Note that the return can be 0, so
               always check with <b>defined()</b>

           <u>Notes,</u> <u>Exceptions,</u> <u>&amp;</u> <u>Bugs</u>
               None

           <b>is_between</b> - is the value between two numbers?

             is_between($value, $min, $max);

           <u>Description</u>
               Returns the untainted number if the test value is  numeric,  and  falls  between  $min  and  $max
               inclusive.   Note  that  either  $min  or  $max  can  be  undef,  which  means 'unlimited'.  i.e.
               is_between($val, 0, undef) would pass for any number zero or larger.

           <u>Arguments</u>
               $value
                   The potential number to test.

               $min
                   The minimum valid value.  Unlimited if set to undef

               $max
                   The maximum valid value.  Unlimited if set to undef

           <u>Returns</u>
               Returns the untainted number on success, undef on failure.  Note that the return  can  be  0,  so
               always check with <b>defined()</b>

           <b>is_greater_than</b> - is the value greater than a threshold?

             is_greater_than($value, $threshold);

           <u>Description</u>
               Returns  the  untainted number if the test value is numeric, and is greater than $threshold. (not
               inclusive)

           <u>Arguments</u>
               $value
                   The potential number to test.

               $threshold
                   The minimum value (non-inclusive)

           <u>Returns</u>
               Returns the untainted number on success, undef on failure.  Note that the return  can  be  0,  so
               always check with <b>defined()</b>

           <b>is_less_than</b> - is the value less than a threshold?

             is_less_than($value, $threshold);

           <u>Description</u>
               Returns  the  untainted  number  if  the test value is numeric, and is less than $threshold. (not
               inclusive)

           <u>Arguments</u>
               $value
                   The potential number to test.

               $threshold
                   The maximum value (non-inclusive)

           <u>Returns</u>
               Returns the untainted number on success, undef on failure.  Note that the return  can  be  0,  so
               always check with <b>defined()</b>

           <b>is_equal_to</b> - do a string/number neutral ==

             is_equal_to($value, $target);

           <u>Description</u>
               Returns  the  target if $value is equal to it.  Does a math comparison if both $value and $target
               are numeric, or a string comparison otherwise.  Both the $value and $target must  be  defined  to
               get a true return.  (i.e.  undef != undef)

           <u>Arguments</u>
               $value
                   The  value to test.

               $target
                   The value to test against

           <u>Returns</u>
               Unlike  most  validator routines, this one does not necessarily untaint its return value, it just
               returns $target.  This has the effect of untainting if the target is a constant  or  other  clean
               value.   (i.e.  is_equal_to($bar,  'foo')).   Note that the return can be 0, so always check with
               <b>defined()</b>

           <b>is_even</b> - is a number even?

             is_even($value);

           <u>Description</u>
               Returns the untainted $value if it's numeric, an integer, and even.

           <u>Arguments</u>
               $value
                   The  value to test.

           <u>Returns</u>
               Returns $value (untainted). Note that the return can be 0, so always check with <b>defined()</b>.

           <b>is_odd</b> - is a number odd?

             is_odd($value);

           <u>Description</u>
               Returns the untainted $value if it's numeric, an integer, and odd.

           <u>Arguments</u>
               $value
                   The value to test.

           <u>Returns</u>
               Returns $value (untainted). Note that the return can be 0, so always check with <b>defined()</b>.

           <b>is_alphanumeric</b> - does it only contain letters and numbers?

             is_alphanumeric($value);

           <u>Description</u>
               Returns the untainted $value if it is defined and only contains letters (upper or lower case) and
               numbers.  Also allows an empty string - ''.

           <u>Arguments</u>
               $value
                   The value to test.

           <u>Returns</u>
               Returns $value (untainted). Note that the return can be 0, so always check with <b>defined()</b>.

           <b>is_printable</b> - does it only contain printable characters?

             is_alphanumeric($value);

           <u>Description</u>
               Returns the untainted $value if it is defined and only contains printable characters  as  defined
               by the composite POSIX character class [[:print:][:space:]].  Also allows an empty string - ''.

           <u>Arguments</u>
               $value
                   The value to test.

           <u>Returns</u>
               Returns $value (untainted). Note that the return can be 0, so always check with <b>defined()</b>.

           <b>length_is_between</b> - is the string length between two limits?

             length_is_between($value, $min, $max);

           <u>Description</u>
               Returns  $value  if  it  is defined and its length is between $min and $max inclusive.  Note that
               this function does not untaint the value.

               If either $min or $max are undefined they are treated as no-limit.

           <u>Arguments</u>
               $value
                   The value to test.

               $min
                   The minimum length of the string (inclusive).

               $max
                   The maximum length of the string (inclusive).

           <u>Returns</u>
               Returns $value.  Note that the return can be 0, so always check with <b>defined()</b>.  The value is not
               automatically untainted.

</pre><h4><b>AUTHOR</b></h4><pre>
       Richard Sonnen &lt;<u><a href="mailto:sonnen@richardsonnen.com">sonnen@richardsonnen.com</a></u>&gt;.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2004 Richard Sonnen. All rights reserved.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

</pre><h4><b>POD</b> <b>ERRORS</b></h4><pre>
       Hey! <b>The</b> <b>above</b> <b>document</b> <b>had</b> <b>some</b> <b>coding</b> <b>errors,</b> <b>which</b> <b>are</b> <b>explained</b> <b>below:</b>

       Around line 89:
           You can't have =items (as at line 97) unless the first thing after the =over is an =item

perl v5.38.2                                       2024-03-05                                      <u><a href="../man3pm/Validate.3pm.html">Validate</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>