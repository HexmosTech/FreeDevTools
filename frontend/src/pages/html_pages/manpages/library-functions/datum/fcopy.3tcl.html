<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fcopy - Copy data from one channel to another</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fcopy - Copy data from one channel to another

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>fcopy</b> <u>inputChan</u> <u>outputChan</u> ?<b>-size</b> <u>size</u>? ?<b>-command</b> <u>callback</u>?
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>fcopy</b>  command copies data from one I/O channel, <u>inchan</u>, to another I/O channel, <u>outchan</u>.  The <b>fcopy</b>
       command leverages the buffering in the Tcl I/O system to avoid extra copies and to  avoid  buffering  too
       much data in main memory when copying large files to destinations like network sockets.

   <b>DATA</b> <b>QUANTITY</b>
       All  data  until  <u>EOF</u> is copied.  In addition, the quantity of copied data may be specified by the option
       <b>-size</b>. The given size is in bytes, if  the  input  channel  is  in  binary  mode.  Otherwise,  it  is  in
       characters.

       Depreciated  feature:  the  transfer  is  treated as a binary transfer, if the encoding profile is set to
       “tcl8” and the input encoding matches the output encoding.  In this case, eventual  encoding  errors  are
       not handled.  An eventually given size is in bytes in this case.

   <b>BLOCKING</b> <b>OPERATION</b> <b>MODE</b>
       Without  the  <b>-command</b> option, <b>fcopy</b> blocks until the copy is complete and returns the number of bytes or
       characters (using the same rules as for the <b>-size</b> option) written to <u>outchan</u>.

   <b>BACKGROUND</b> <b>OPERATION</b> <b>MODE</b>
       The <b>-command</b> argument makes <b>fcopy</b> work in the background.  In this case it returns  immediately  and  the
       <u>callback</u>  is  invoked  later  when the copy completes.  The <u>callback</u> is called with one or two additional
       arguments that indicates how many bytes were written  to  <u>outchan</u>.   If  an  error  occurred  during  the
       background  copy,  the  second argument is the error string associated with the error.  With a background
       copy, it is not necessary to put <u>inchan</u> or <u>outchan</u> into non-blocking mode; the <b>fcopy</b> command  takes  care
       of that automatically.  However, it is necessary to enter the event loop by using the <b>vwait</b> command or by
       using Tk.

       You are not allowed to do other input operations with <u>inchan</u>, or output operations with <u>outchan</u>, during a
       background  <b>fcopy</b>.  The  converse is entirely legitimate, as exhibited by the bidirectional fcopy example
       below.

       If either <u>inchan</u> or <u>outchan</u> get closed while the copy is in progress, the current copy is stopped and the
       command callback is <u>not</u> made.  If <u>inchan</u> is closed, then all data already queued for <u>outchan</u>  is  written
       out.

       Note  that  <u>inchan</u>  can  become  readable  during  a  background copy.  You should turn off any <b>fileevent</b>
       handlers during a background copy so those handlers do not interfere with the copy.  Any wrong-sided  I/O
       attempted (by a <b>fileevent</b> handler or otherwise) will get a “channel busy” error.

   <b>CHANNEL</b> <b>TRANSLATION</b> <b>OPTIONS</b>
       <b>Fcopy</b>  translates  end-of-line  sequences  in <u>inchan</u> and <u>outchan</u> according to the <b>-translation</b> option for
       these channels.  See the manual entry for  <b>fconfigure</b>  for  details  on  the  <b>-translation</b>  option.   The
       translations  mean  that  the  number of bytes read from <u>inchan</u> can be different than the number of bytes
       written to <u>outchan</u>.  Only the number of bytes written to <u>outchan</u> is reported, either as the return  value
       of a synchronous <b>fcopy</b> or as the argument to the callback for an asynchronous <b>fcopy</b>.

   <b>CHANNEL</b> <b>ENCODING</b> <b>OPTIONS</b>
       <b>Fcopy</b>  obeys  the  encodings, profiles and character translations configured for the channels. This means
       that the incoming characters are converted internally first UTF-8 and  then  into  the  encoding  of  the
       channel  <b>fcopy</b>  writes  to. See the manual entry for <b>fconfigure</b> for details on the <b>-encoding</b> and <b>-profile</b>
       options. No conversion is done  if  both  channels  are  set  to  encoding  “binary”  and  have  matching
       translations.  If  only the output channel is set to encoding “binary” the system will write the internal
       UTF-8 representation of the incoming characters. If only the input channel is set  to  encoding  “binary”
       the  system  will assume that the incoming bytes are valid UTF-8 characters and convert them according to
       the output encoding. The behaviour of the system for bytes  which  are  not  valid  UTF-8  characters  is
       undefined in this case.

       <b>Fcopy</b>  may  throw  encoding  errors  (error code <b>EILSEQ</b>), if input or output channel is configured to the
       “strict” encoding profile.

       If an encoding error arises on the input channel, any data before the error byte is written to the output
       channel. The input file pointer is located just before the values  causing  the  encoding  error.   Error
       inspection or recovery is possible by changing the encoding parameters and invoking a file command (<b>read</b>,
       <b>fcopy</b>).

       If  an  encoding  error arises on the output channel, the erroneous data is lost.  To make the difference
       between the input error case and the output error case, only the error message may be inspected (read  or
       write), as both throw the error code <u>EILSEQ</u>.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  first  example  transfers the contents of one channel exactly to another. Note that when copying one
       file to another, it is better to use <b>file</b> <b>copy</b> which also copies file  metadata  (e.g.  the  file  access
       permissions) where possible.

              fconfigure $in -translation binary
              fconfigure $out -translation binary
              <b>fcopy</b> $in $out

       This  second  example  shows  how the callback gets passed the number of bytes transferred.  It also uses
       vwait to put the application into the event loop.  Of course,  this  simplified  example  could  be  done
       without the command callback.

              proc Cleanup {in out bytes {error {}}} {
                  global total
                  set total $bytes
                  close $in
                  close $out
                  if {[string length $error] != 0} {
                      # error occurred during the copy
                  }
              }
              set in [open $file1]
              set out [socket $server $port]
              <b>fcopy</b> $in $out -command [list Cleanup $in $out]
              vwait total

       The third example copies in chunks and tests for end of file in the command callback.

              proc CopyMore {in out chunk bytes {error {}}} {
                  global total done
                  incr total $bytes
                  if {([string length $error] != 0) || [eof $in]} {
                      set done $total
                      close $in
                      close $out
                  } else {
                      <b>fcopy</b> $in $out -size $chunk \
                              -command [list CopyMore $in $out $chunk]
                  }
              }
              set in [open $file1]
              set out [socket $server $port]
              set chunk 1024
              set total 0
              <b>fcopy</b> $in $out -size $chunk \
                      -command [list CopyMore $in $out $chunk]
              vwait done

       The  fourth  example starts an asynchronous, bidirectional fcopy between two sockets. Those could also be
       pipes from two [open "|hal 9000" r+] (though their conversation would remain secret to the script,  since
       all four fileevent slots are busy).

              set flows 2
              proc Done {dir args} {
                   global flows done
                   puts "$dir is over."
                   incr flows -1
                   if {$flows&lt;=0} {set done 1}
              }
              <b>fcopy</b> $sok1 $sok2 -command [list Done UP]
              <b>fcopy</b> $sok2 $sok1 -command [list Done DOWN]
              vwait done

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/eof.3tcl.html">eof</a>(3tcl), <a href="../man3tcl/fblocked.3tcl.html">fblocked</a>(3tcl), <a href="../man3tcl/fconfigure.3tcl.html">fconfigure</a>(3tcl), <a href="../man3tcl/file.3tcl.html">file</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       blocking, channel, end of line, end of file, nonblocking, read, translation

Tcl                                                    8.0                                           <u><a href="../man3tcl/fcopy.3tcl.html">fcopy</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>