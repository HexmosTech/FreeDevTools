<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Hexdumper - Make binary data human-readable</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-hexdumper-perl">libdata-hexdumper-perl_3.0001-1.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Hexdumper - Make binary data human-readable

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Data::Hexdumper qw(hexdump);
           print hexdump(
             data           =&gt; $data, # what to dump
             # NB number_format is deprecated
             number_format  =&gt; 'S',   # display as unsigned 'shorts'
             start_position =&gt; 100,   # start at this offset ...
             end_position   =&gt; 148    # ... and end at this offset
           );
           print hexdump(
             "abcdefg",
             { output_format =&gt; '%4a : %C %S&lt; %L&gt; : %d' }
           );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Data::Hexdumper" provides a simple way to format arbitrary binary data into a nice human-readable
       format, somewhat similar to the Unix 'hexdump' utility.

       It gives the programmer a considerable degree of flexibility in how the data is formatted, with sensible
       defaults.  It is envisaged that it will primarily be of use for those wrestling alligators in the swamp
       of binary file formats, which is why it was written in the first place.

</pre><h4><b>SUBROUTINES</b></h4><pre>
       The following subroutines are exported by default, although this is deprecated and will be removed in
       some future version.  Please pretend that you need to ask the module to export them to you.

       If you do assume that the module will always export them, then you may also assume that your code will
       break at some point after 1 Aug 2012.

   <b>hexdump</b>
       Does everything.  Takes a hash of parameters, one of which is mandatory, the rest having sensible
       defaults if not specified.  Available parameters are:

       data
           A scalar containing the binary data we're interested in.  This is mandatory.

       start_position
           An integer telling us where in "data" to start dumping.  Defaults to the beginning of "data".

       end_position
           An integer telling us where in "data" to stop dumping.  Defaults to the end of "data".

       number_format
           This is deprecated.  See 'INCOMPATIBLE CHANGES' below.  If you use this your data will be padded with
           NULLs  to  be  an  integer  multiple of 16 bytes.  You can expect number_format to be removed at some
           point in 2014 or later.

           A string specifying how to format the data.  It can be any of the following, which  you  will  notice
           have the same meanings as they do to perl's "pack" function:

           C - unsigned char
           S - unsigned 16-bit, native endianness
           v or S&lt; - unsigned 16-bit, little-endian
           n or S&gt; - unsigned 16-bit, big-endian
           L - unsigned 32-bit, native endianness
           V or L&lt; - unsigned 32-bit, little-endian
           N or L&gt; - unsigned 32-bit, big-endian
           Q - unsigned 64-bit, native endianness
           Q&lt; - unsigned 64-bit, little-endian
           Q&gt; - unsigned 64-bit, big-endian

           Note  that 64-bit formats are *always* available, even if your perl is only 32-bit.  Similarly, using
           &lt; and &gt; on the S and L formats always works, even if you're using a pre 5.10.0 perl.  That's  because
           this code doesn't use "pack()".

       output_format
           This  is  an  alternative  and  much more flexible (but more complex) method of specifying the output
           format.  Instead of specifying a single format for all your output, you can specify formats like:

             %4a : %C %S %L&gt; %Q : %d

           which will, on each line, display first the address (consisting of '0x'  and  4  hexadecimal  digits,
           zero-padded if necessary), then a space, then a colon, then a single byte of data, then a space, then
           an  unsigned  16-bit  value  in  native  endianness, then a space, then an unsigned 32-bit big-endian
           value, ... then a colon, a space, then the characters representing your 15 byte record.

           You can use exactly  the  same  characters  and  character  sequences  as  are  specified  above  for
           number_format,  plus 'a' for the address, and 'd' for the data.  To output a literal % character, use
           %% as is normal with formats - see sprintf for details.  To output a literal &lt; or &gt;  character  where
           it  may be confused with any of the {S,L,Q}{&lt;,&gt;} sequences, use %&lt; or %&gt;.  So, for example, to output
           a 16-bit value in native endianness followed by &lt;, use %S%&lt;.

           %a takes an optional base-ten number between the % and the a signifying  the  number  of  hexadecimal
           digits.  This defaults to 4.

           %{C,S,L,Q}  also take an optional base-ten number between the % and the letter, signifying the number
           of repeats.  These will be separated by spaces in the output.  So '%4C' is equivalent to  '%C  %C  %C
           %C'.

           Anything  else  will  get  printed  literally.   This  format  will  be repeated for as many lines as
           necessary.  If the amount of data isn't enough to completely fill the last line, it  will  be  padded
           with NULL bytes.

           To specify both number_format and output_format is a fatal error.

           If neither are given, output_format defaults to:

             '  %4a : %16C : %d'

           which is equivalent to the old-style:

             number_format =&gt; 'C'

       suppress_warnings
           Make  this  true  if  you want to suppress any warnings - such as that your data may have been padded
           with NULLs if it didn't exactly fit into an integer number of words, or if you do something  that  is
           deprecated.

       space_as_space
           Make  this  true  if you want spaces (ASCII character 0x20) to be printed as spaces Otherwise, spaces
           will be printed as full stops / periods (ASCII 0x2E).

       Alternatively, you can supply the parameters as a scalar chunk of data followed by an optional hashref of
       the other options:

           $results = hexdump($string);
           $results = hexdump(
             $string,
             { start_position =&gt; 100, end_position   =&gt; 148 }
           );

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Data::Dumper

       Data::HexDump if your needs are simple

       perldoc -f unpack

       perldoc -f pack

</pre><h4><b>INCOMPATIBLE</b> <b>CHANGES</b></h4><pre>
       'number_format' is now implemented in terms of 'output_format'.  Your data will be padded to  a  multiple
       of 16 bytes.  Previously-silent code may now emit warnings.

       The mappings are:

         'C'  =&gt; '  %4a : %C %C %C %C %C %C %C %C %C %C %C %C %C %C %C %C : %d'
         'S'  =&gt; '  %4a : %S %S %S %S %S %S %S %S         : %d'
         'S&lt;' =&gt; '  %4a : %S&lt; %S&lt; %S&lt; %S&lt; %S&lt; %S&lt; %S&lt; %S&lt;         : %d'
         'S&gt;' =&gt; '  %4a : %S&gt; %S&gt; %S&gt; %S&gt; %S&gt; %S&gt; %S&gt; %S&gt;         : %d'
         'L'  =&gt; '  %4a : %L %L %L %L             : %d'
         'L&lt;' =&gt; '  %4a : %L&lt; %L&lt; %L&lt; %L&lt;             : %d'
         'L&gt;' =&gt; '  %4a : %L&gt; %L&gt; %L&gt; %L&gt;             : %d'
         'Q'  =&gt; '  %4a : %Q %Q               : %d'
         'Q&lt;' =&gt; '  %4a : %Q&lt; %Q&lt;               : %d'
         'Q&gt;' =&gt; '  %4a : %Q&gt; %Q&gt;               : %d'

       and of course:

         'V' =&gt; 'L&lt;'
         'N' =&gt; 'L&gt;'
         'v' =&gt; 'S&lt;'
         'n' =&gt; 'S&gt;'

</pre><h4><b>BUGS/LIMITATIONS</b></h4><pre>
       Behaviour of %a is not defined if your file is too big.

       Behaviour of %NNa is not defined if NN is too big for your sprintf implementation to handle 0x%0${NN}X.

</pre><h4><b>FEEDBACK</b></h4><pre>
       I welcome constructive criticism and bug reports.  Please report bugs either by email or via RT:
         &lt;<a href="http://rt.cpan.org/Public/Dist/Display.html">http://rt.cpan.org/Public/Dist/Display.html</a>?Name=Data-Hexdumper&gt;

       The best bug reports contain a test file that fails with the current code, and will pass once it has been
       fixed.  The code repository is on Github:
         &lt;git://github.com/DrHyde/perl-modules-Data-Hexdumper.git&gt;

</pre><h4><b>AUTHOR,</b> <b>COPYRIGHT</b> <b>and</b> <b>LICENCE</b></h4><pre>
       Copyright 2001 - 2012 David Cantrell &lt;<u><a href="mailto:david@cantrell.org.uk">david@cantrell.org.uk</a></u>&gt;

       This  software  is free-as-in-speech software, and may be used, distributed, and modified under the terms
       of either the GNU General Public Licence version 2 or the Artistic Licence.  It's up to you which one you
       use.  The full text of the licences can be found in the files GPL2.txt and ARTISTIC.txt, respectively.

</pre><h4><b>CONSPIRACY</b></h4><pre>
       This module is also free-as-in-mason software.

</pre><h4><b>THANKS</b> <b>TO</b> <b>...</b></h4><pre>
       MHX, for reporting a bug when dumping a single byte of data

       Stefan Siegl, for reporting a bug when dumping an ASCII 0

       Steffen Winkler, for inspiring me to use proper output formats

perl v5.32.0                                       2021-01-05                               <u>Data::<a href="../man3pm/Hexdumper.3pm.html">Hexdumper</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>