<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>egd_get_data - peek buffered data</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libeegdev-dev">libeegdev-dev_0.2-10_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       egd_get_data - peek buffered data

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;eegdev.h&gt;</b>

       <b>ssize_t</b> <b>egd_get_available(struct</b> <b>eegdev*</b> <u>dev</u><b>);</b>
       <b>ssize_t</b> <b>egd_get_data(struct</b> <b>eegdev*</b> <u>dev</u><b>,</b> <b>size_t</b> <u>ns</u><b>,</b> <b>...);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>egd_get_available</b>() returns the number of samples that have been buffered by the device referenced by <u>dev</u>
       and that have not been read yet.

       <b>egd_get_data</b>()  peeks the <u>ns</u> next samples from the buffered data acquired by the device referenced by <u>dev</u>
       and fills the arrays provided in the variable list of arguments with the obtained data. If all  requested
       samples  have  been  already acquired, the function returns immediately. Otherwise, the call blocks until
       the requested data is available, the acquisition stops or a problem occurs. In the last  two  cases,  the
       data read may be less than requested.

       The  arrays  provided  in  the  variable  list  of argument are filled following the formats specified by
       previous call to <b><a href="../man3/egd_acq_setup.3.html">egd_acq_setup</a></b>(3). In particular, the number of arrays supplied in the variable  list  of
       argument  and their size should be consistent with the number of arrays and strides specified by the call
       to <b><a href="../man3/egd_acq_setup.3.html">egd_acq_setup</a></b>(3).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>egd_get_available</b>() returns the number of unread samples in case of succes. Otherwise, -1 is returned and
       <u>errno</u> is set accordingly.

       In case of success, <b>egd_get_data</b>() returns the number of  read  samples  (which  can  be  less  than  the
       requested number). Otherwise, -1 is returned and <u>errno</u> is set accordingly.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>egd_get_available</b>() and <b>egd_get_data</b>() will fail if:

       <b>EINVAL</b> <u>dev</u> is NULL.

       <b>ENOMEM</b> The internal ringbuffer of the device referenced by <u>dev</u> is full.

       <b>EAGAIN</b> The  underlying  hardware  referenced  by <u>dev</u> has encountered a loss of connection, maybe due some
              cable disconnected or a power switch set to off.

       <b>EIO</b>    The underlying hardware referenced by <u>dev</u> has encountered a loss of synchronization for an unknown
              reason.

</pre><h4><b>NOTES</b></h4><pre>
       Please be aware  that  the  user  has  no  obligation  to  make  all  the  calls  to  <b>egd_get_data</b>()  and
       <b>egd_get_available</b>()  during the acquisition.  He can also peform some of them after the acquisition which
       will correspond to get the remaining buffered data.

       For example, it might happened that a user want to wait for an certain external  event  to  occur  before
       stopping  the  acquisition.  In this situation, the usual workflow would be to start the acquisition, get
       regurlarly some data while scanning the event to occur. When this happens, the acquisition is immediately
       stopped. However at the moment of stopping the acquisition, there might still be some buffered data which
       could be important.  Calling <b>egd_get_available</b>() after <b><a href="../man3/egd_stop.3.html">egd_stop</a></b>(3) would then  return  the  size  of  the
       remaining data that could be obtained with <b>egd_get_data</b>().

</pre><h4><b>EXAMPLE</b></h4><pre>
              #define NEEG   8
              #define NTRI   1
              #define NS     4

              int ns_tot;
              ssize_t ns_read;
              float eegarr[NEEG*NS];
              int32_t triarr[NTRI*NS];
              struct grpconf grp[2];
              unsigned int strides[2];

              <b>/*</b> <b>Assume</b> <b>that</b> <b>a</b> <b>device</b> <b>has</b> <b>been</b> <b>successfully</b> <b>opened,</b> <b>i.e.</b> <b>there</b>
              <b>is</b> <b>a</b> <b>valid</b> <b>'dev'</b> <b>variable</b> <b>of</b> <b>type</b> <b>struct</b> <b>eegdev*</b> <b>*/</b>

              strides[0] = NEEG*sizeof(float);
              strides[1] = NTRI*sizeof(int32_t);

              grp[0].sensortype = egd_sensor_type("eeg");
              grp[0].index = 0;
              grp[0].iarray = 0;
              grp[0].arr_offset = 0;
              grp[0].nch = NEEG;
              grp[0].datatype = EGD_FLOAT;
              grp[1].sensortype = egd_sensor_type("trigger");
              grp[1].index = 0;
              grp[1].iarray = 1;
              grp[1].arr_offset = 0;
              grp[1].nch = NTRI;
              grp[1].datatype = EGD_INT32;

              <b>/*</b> <b>Setup</b> <b>how</b> <b>to</b> <b>get</b> <b>the</b> <b>data</b> <b>*/</b>
              egd_acq_setup(dev, 2, strides, 2, grp);

              <b>/*</b> <b>Start</b> <b>the</b> <b>acquisition.</b>
              <b>From</b> <b>now,</b> <b>all</b> <b>incoming</b> <b>samples</b> <b>will</b> <b>be</b> <b>buffered</b> <b>*/</b>
              egd_start(dev);
              ns_tot = 0;

              while (ns_tot &lt; 1000) {
                   <b>/*</b> <b>Get</b> <b>the</b> <b>data</b> <b>*/</b>
                   ns_read = egd_get_data(dev, NS, eegarr, triarr);
                   if (ns_read &lt; 0) {
                        <b>/*</b> <b>Handle</b> <b>failure</b> <b>*/</b>
                   }
                   ns_tot += ns_read;

                   <b>/*</b> <b>do</b> <b>something</b> <b>with</b> <b>the</b> <b>new</b> <b>data</b> <b>*/</b>
              }

              <b>/*</b> <b>Stop</b> <b>the</b> <b>acquisition,</b> <b>i.e.</b> <b>no</b> <b>new</b> <b>data</b> <b>is</b> <b>buffered</b> <b>*/</b>
              egd_stop(dev);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/egd_acq_setup.3.html">egd_acq_setup</a></b>(3), <b><a href="../man3/egd_start.3.html">egd_start</a></b>(3), <b><a href="../man3/egd_stop.3.html">egd_stop</a></b>(3)

EPFL                                                  2010                                       <u><a href="../man3/EGD_GET_DATA.3.html">EGD_GET_DATA</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>