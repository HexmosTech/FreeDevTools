<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOAP::Data - this class provides the means by which to explicitly manipulate and control all aspects of</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsoap-lite-perl">libsoap-lite-perl_1.27-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SOAP::Data - this class provides the means by which to explicitly manipulate and control all aspects of
       the way in which Perl data gets expressed as SOAP data entities.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The SOAP::Data class provides the means by which to explicitly manipulate and control all aspects of the
       way in which Perl data gets expressed as SOAP data entities. Most of the methods are accessors, which
       like those in SOAP::Lite are designed to return the current value if no new one is passed, while
       returning the object reference otherwise (allowing for chained method calls). Note that most accessors
       (except value) accept a new value for the data object as a second argument.

</pre><h4><b>METHODS</b></h4><pre>
       new(optional key/value pairs)
               $obj = SOAP::Data-&gt;new(name =&gt; 'idx', value =&gt; 5);

           This is the class constructor. Almost all of the attributes related to the class may be passed to the
           constructor  as key/value pairs. This method isn't often used directly because SOAP::Data objects are
           generally created for temporary use. It is available for those situations that require it.

       name(new name, optional value)
               $obj-&gt;name('index');

           Gets or sets the current value of the name, as the object regards it. The name is what the serializer
           will use for the tag when generating the XML for this object. It is what will become the accessor for
           the data element. Optionally, the object's value may be updated if passed as a second argument.

       type(new type, optional value)
               $obj-&gt;type('int');

           Gets or sets the type associated with the current value in the object. This is useful for those cases
           where the SOAP::Data object is used to explicitly specify the type of data that  would  otherwise  be
           interpreted  as  a  different  type  completely  (such  as  perceiving  the string 123 as an integer,
           instead). Allows the setting of the object's value, if passed as a second argument to the method.

       uri(new uri, optional value)
               $obj-&gt;uri('<a href="http://www.perl.com/SOAP">http://www.perl.com/SOAP</a>');

           Gets or sets the URI that will be used as the namespace for the  resulting  XML  entity,  if  one  is
           desired.  This  doesn't set the label for the namespace. If one isn't provided by means of the prefix
           method, one is generated automatically when needed. Also allows the setting of the object's value, if
           passed as a second argument to the method.

       prefix(new prefix, optional value)
               $obj-&gt;prefix('perl');

           Provides the prefix, or label, for use when associating the data object with  a  specific  namespace.
           Also allows the setting of the object's value, if passed as a second argument to the method.

       attr(hash reference of attributes, optional value)
               $obj-&gt;attr({ attr1 =&gt; 'value' });

           Allows  for the setting of arbitrary attributes on the data object. Keep in mind the requirement that
           any attributes not natively known to SOAP must be namespace-qualified. Also allows the setting of the
           object's value, if passed as a second argument to the method.

       value(new value)
               $obj-&gt;<a href="../man10/value.10.html">value</a>(10);

           Fetches the current value encapsulated by the object, or explicitly sets it.

       The last four methods are convenience shortcuts for the attributes that SOAP itself supports.  Each  also
       permits inclusion of a new value, as an optional second argument.

       actor(new actor, optional value)
               $obj-&gt;actor($new_actor_name);

           Gets  or  sets  the value of the actor attribute; useful only when the object generates an entity for
           the message header.

       mustUnderstand(boolean, optional value)
               $obj-&gt;<a href="../man0/mustUnderstand.0.html">mustUnderstand</a>(0);

           Manipulates the mustUnderstand attribute, which tells the SOAP processor whether it  is  required  to
           understand the entity in question.

       encodingStyle(new encoding URN, optional value)
               $obj-&gt;encodingStyle($soap_11_encoding);

           This  method  is  most  likely  to be used in places outside the header creation. Sets encodingStyle,
           which specifies an encoding that differs from the one that would otherwise be defaulted to.

       root(boolean, optional value)
               $obj-&gt;<a href="../man1/root.1.html">root</a>(1);

           When the application must explicitly specify which data element is to be regarded as the root element
           for the sake of generating the object model, this method provides the access to the root attribute.

</pre><h4><b>TYPE</b> <b>DETECTION</b></h4><pre>
       SOAP::Lite's serializer will detect the type of any scalar passed in  as  a  SOAP::Data  object's  value.
       Because Perl is loosely typed, the serializer is only able to detect types based upon a predetermined set
       of  regular  expressions.  Therefore,  type detection is not always 100% accurate. In such a case you may
       need to explicitly set the type of the element being encoded. For example, by default the following  code
       will be serialized as an integer:

         $elem = SOAP::Data-&gt;name('idx')-&gt;<a href="../man5/value.5.html">value</a>(5);

       If, however, you need to serialize this into a long, then the following code will do so:

         $elem = SOAP::Data-&gt;name('idx')-&gt;<a href="../man5/value.5.html">value</a>(5)-&gt;type('long');

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>SIMPLE</b> <b>TYPES</b>
       The following example will all produce the same XML:

           $elem1 = SOAP::Data-&gt;new(name =&gt; 'idx', value =&gt; 5);
           $elem2 = SOAP::Data-&gt;name('idx' =&gt; 5);
           $elem3 = SOAP::Data-&gt;name('idx')-&gt;<a href="../man5/value.5.html">value</a>(5);

   <b>COMPLEX</b> <b>TYPES</b>
       A  common  question  is how to do you created nested XML elements using SOAP::Lite. The following example
       demonstrates how:

           SOAP::Data-&gt;name('foo' =&gt; \SOAP::Data-&gt;value(
               SOAP::Data-&gt;name('bar' =&gt; '123')));

       The above code will produce the following XML:

           &lt;foo&gt;
             &lt;bar&gt;123&lt;/bar&gt;
           &lt;/foo&gt;

   <b>ARRAYS</b>
       The following code:

           $elem1 = SOAP::Data-&gt;name('item' =&gt; 123)-&gt;type('SomeObject');
           $elem2 = SOAP::Data-&gt;name('item' =&gt; 456)-&gt;type('SomeObject');
           push(@array,$elem1);
           push(@array,$elem2);

           my $client = SOAP::Lite
               -&gt;<a href="../man1/readable.1.html">readable</a>(1)
               -&gt;uri($NS)
               -&gt;proxy($HOST);

           $temp_elements = SOAP::Data
               -&gt;name("CallDetails" =&gt; \SOAP::Data-&gt;value(
                     SOAP::Data-&gt;name("elem1" =&gt; 'foo'),
                     SOAP::Data-&gt;name("elem2" =&gt; 'baz'),
                     SOAP::Data-&gt;name("someArray" =&gt; \SOAP::Data-&gt;value(
                         SOAP::Data-&gt;name("someArrayItem" =&gt; @array)
                                   -&gt;type("SomeObject"))
                              )-&gt;type("ArrayOf_SomeObject") ))

           -&gt;type("SomeObject");

           $response = $client-&gt;someMethod($temp_elements);

       Will produce the following XML:

           &lt;?xml version="1.0" encoding="UTF-8"?&gt;
           &lt;SOAP-ENV:Envelope
               xmlns:xsi="<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>"
               xmlns:SOAP-ENC="<a href="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</a>"
               xmlns:SOAP-ENV="<a href="http://schemas.xmlsoap.org/soap/envelope/">http://schemas.xmlsoap.org/soap/envelope/</a>"
               xmlns:xsd="<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a>"
               xmlns:namesp2="<a href="http://namespaces.soaplite.com/perl">http://namespaces.soaplite.com/perl</a>"
               SOAP-ENV:encodingStyle="<a href="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</a>"&gt;
             &lt;SOAP-ENV:Body&gt;
               &lt;namesp1:someMethod xmlns:namesp1="urn:TemperatureService"&gt;
                 &lt;CallDetails xsi:type="namesp2:SomeObject"&gt;
                   &lt;elem1 xsi:type="xsd:string"&gt;foo&lt;/elem1&gt;
                   &lt;elem2 xsi:type="xsd:string"&gt;baz&lt;/elem2&gt;
                   &lt;someArray xsi:type="namesp2:ArrayOf_SomeObject"&gt;
                     &lt;item xsi:type="namesp2:SomeObject"&gt;123&lt;/bar&gt;
                     &lt;item xsi:type="namesp2:SomeObject"&gt;456&lt;/bar&gt;
                   &lt;/someArray&gt;
                 &lt;/CallDetails&gt;
               &lt;/namesp1:test&gt;
             &lt;/SOAP-ENV:Body&gt;
           &lt;/SOAP-ENV:Envelope&gt;

       In the code above, the @array variable can be an array of anything. If you pass in an array  of  numbers,
       then  SOAP::Lite  will  properly  serialize  that  into  such.  If however you need to encode an array of
       complex types, then simply pass in an array of other SOAP::Data objects and you are all set.

   <b>COMPOSING</b> <b>MESSAGES</b> <b>USING</b> <b>RAW</b> <b>XML</b>
       In some circumstances you may need to encode a message using raw unserialized XML text. To instantiate  a
       SOAP::Data object using raw XML, do the following:

           $xml_content = "&lt;foo&gt;&lt;bar&gt;123&lt;/bar&gt;&lt;/foo&gt;";
           $elem = SOAP::Data-&gt;type('xml' =&gt; $xml_content);

       SOAP::Lite's  serializer  simple  takes  whatever  text  is  passed  to  it, and inserts into the encoded
       SOAP::Data element <u>verbatim</u>. The text input is NOT validated to ensure  it  is  valid  XML,  nor  is  the
       resulting  SOAP::Data  element  validated  to  ensure  that  it  will produce valid XML. Therefore, it is
       incumbent upon the developer to ensure that any XML data used in this fashion is valid and will result in
       a valid XML document.

   <b>MULTIPLE</b> <b>NAMESPACES</b>
       When working with complex types it may be necessary to declare multiple namespaces.  The  following  code
       demonstrates how to do so:

           $elem = SOAP::Data-&gt;name("myElement" =&gt; "myValue")
                             -&gt;attr( { 'xmlns:foo2' =&gt; 'urn:Foo2',
                                       'xmlns:foo3' =&gt; 'urn:Foo3' } );

       This will produce the following XML:

           &lt;myElement xmlns:foo2="urn:Foo2" xmlns:foo3="urn:Foo3"&gt;myValue&lt;/myElement&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       SOAP::Header, SOAP::SOM, SOAP::Serializer

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Special  thanks  to  O'Reilly  publishing  which  has  graciously  allowed  SOAP::Lite  to  republish and
       redistribute large excerpts from <u>Programming</u> <u>Web</u> <u>Services</u> <u>with</u>  <u>Perl</u>,  mainly  the  SOAP::Lite  reference
       found in Appendix B.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2000-2004 Paul Kulchenko. All rights reserved.

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>AUTHORS</b></h4><pre>
       Paul Kulchenko (<a href="mailto:paulclinger@yahoo.com">paulclinger@yahoo.com</a>)

       Randy J. Ray (<a href="mailto:rjray@blackperl.com">rjray@blackperl.com</a>)

       Byrne Reese (<a href="mailto:byrne@majordojo.com">byrne@majordojo.com</a>)

perl v5.36.0                                       2023-03-01                                    <u>SOAP::<a href="../man3pm/Data.3pm.html">Data</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>