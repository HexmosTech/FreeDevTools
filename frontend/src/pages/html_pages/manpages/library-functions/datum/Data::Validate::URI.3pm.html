<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Validate::URI - common url validation methods</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-validate-uri-perl">libdata-validate-uri-perl_0.07-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Validate::URI - common url validation methods

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Data::Validate::URI qw(is_uri);

         if(is_uri($suspect)){
               print "Looks like an URI\n";
         } else {
               print "Not a URI\n";
         }

         # or as an object
         my $v = Data::Validate::URI-&gt;new();

         die "not a URI" unless ($v-&gt;is_uri('foo'));

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module collects common URI validation routines to make input validation, and untainting easier and
       more readable.

       All functions return an untainted value if the test passes, and undef if it fails.  This means that you
       should always check for a defined status explicitly.  Don't assume the return will be true.

       The value to test is always the first (and often only) argument.

       There are a number of other URI validation modules out there as well (see below.)  This one focuses on
       being fast, lightweight, and relatively 'real-world'.  i.e.  it's good if you want to check user input,
       and don't need to parse out the URI/URL into chunks.

       Right now the module focuses on HTTP URIs, since they're arguably the most common.  If you have a
       specialized scheme you'd like to have supported, let me know.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       <b>new</b> - constructor for OO usage
             new(%options);

           <u>Description</u>
               Returns  a Data::Validator::URI object.  This lets you access all the validator function calls as
               methods   without   importing   them    into    your    namespace    or    using    the    clumsy
               <b>Data::Validate::URI::function_name()</b> format.

           <u>Arguments</u>
               %options
                   Options to be passed into the underlying Data::Validate::Domain module

           <u>Returns</u>
               Returns a Data::Validate::URI object

       <b>is_uri</b> - is the value a well-formed uri?
             is_uri($value);

           <u>Description</u>
               Returns  the untainted URI if the test value appears to be well-formed.  Note that you may really
               want one of the more practical methods like is_http_uri or is_https_uri, since the  URI  standard
               (RFC 3986) allows a lot of things you probably don't want.

           <u>Arguments</u>
               $value
                   The potential URI to test.

           <u>Returns</u>
               Returns the untainted URI on success, undef on failure.

           <u>Notes,</u> <u>Exceptions,</u> <u>&amp;</u> <u>Bugs</u>
               This  function  does not make any attempt to check whether the URI is accessible or 'makes sense'
               in any meaningful way.  It just checks that it is formatted correctly.

       <b>is_http_uri</b> - is the value a well-formed HTTP uri?
             is_http_uri($value, \%options);

           <u>Description</u>
               Specialized version of <b>is_uri()</b> that only likes http:// urls.  As a result, it can also do a much
               more thorough job validating.  Also, unlike <b>is_uri()</b> it is  more  concerned  with  only  allowing
               real-world  URIs  through.   Things  like  relative  hostnames  are allowed by the standards, but
               probably aren't wise.  Conversely, null  paths  aren't  allowed  per  RFC  2616  (should  be  '/'
               instead), but are allowed by this function.

               This  function  only works for fully-qualified URIs.  /bob.html won't work.  See RFC 3986 for the
               appropriate method to turn a relative URI into an absolute one given its context.

               Returns the untainted URI if the test value appears to be well-formed.

               Note that you probably want to either call this in combo with <b>is_https_uri()</b>. i.e.

               print "Good" if(is_http_uri($uri) || is_https_uri($uri));

               or use the convenience method is_web_uri which is equivalent and faster, because it does the work
               only once.

           <u>Arguments</u>
               $value
                   The potential URI to test.

               \%options
                   Options to be passed into the  underlying  Data::Validate::Domain  module.  If  called  as  a
                   method, the options are ignored.

           <u>Returns</u>
               Returns the untainted URI on success, undef on failure.

           <u>Notes,</u> <u>Exceptions,</u> <u>&amp;</u> <u>Bugs</u>
               This  function  does not make any attempt to check whether the URI is accessible or 'makes sense'
               in any meaningful way.  It just checks that it is formatted correctly.

       <b>is_https_uri</b> - is the value a well-formed HTTPS uri?
             is_https_uri($value. \%options);

           <u>Description</u>
               See <b>is_http_uri()</b> for details.  This version only likes the https  URI  scheme.   Otherwise  it's
               identical to <b>is_http_uri()</b>

           <u>Arguments</u>
               $value
                   The potential URI to test.

               \%options
                   Options  to  be  passed  into  the  underlying  Data::Validate::Domain module. If called as a
                   method, the options are ignored.

           <u>Returns</u>
               Returns the untainted URI on success, undef on failure.

           <u>Notes,</u> <u>Exceptions,</u> <u>&amp;</u> <u>Bugs</u>
               This function does not make any attempt to check whether the URI is accessible or  'makes  sense'
               in any meaningful way.  It just checks that it is formatted correctly.

       <b>is_web_uri</b> - is the value a well-formed HTTP or HTTPS uri?
             is_web_uri($value, \%options);

           <u>Description</u>
               This  is  just  a  convinience  method  that combines is_http_uri and is_https_uri to accept most
               common real-world URLs. But it's faster, because it does the work only once.

           <u>Arguments</u>
               $value
                   The potential URI to test.

               \%options
                   Options to be passed into the  underlying  Data::Validate::Domain  module.  If  called  as  a
                   method, the options are ignored.

           <u>Returns</u>
               Returns the untainted URI on success, undef on failure.

           <u>Notes,</u> <u>Exceptions,</u> <u>&amp;</u> <u>Bugs</u>
               This  function  does not make any attempt to check whether the URI is accessible or 'makes sense'
               in any meaningful way.  It just checks that it is formatted correctly.

       <b>is_tel_uri</b> - is the value a well-formed telephone uri?
             is_tel_uri($value);

           <u>Description</u>
               Specialized version of <b>is_uri()</b> that only likes tel: urls.  As a result, it can also  do  a  much
               more thorough job validating according to RFC 3966.

               Returns the untainted URI if the test value appears to be well-formed.

           <u>Arguments</u>
               $value
                   The potential URI to test.

           <u>Returns</u>
               Returns the untainted URI on success, undef on failure.

           <u>Notes,</u> <u>Exceptions,</u> <u>&amp;</u> <u>Bugs</u>
               This  function  does not make any attempt to check whether the URI is accessible or 'makes sense'
               in any meaningful way.  It just checks that it is formatted correctly.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       URI, RFC 3986, RFC 3966, RFC 4694, RFC 4759, RFC 4904

</pre><h4><b>AUTHOR</b></h4><pre>
       Richard Sonnen &lt;<u><a href="mailto:sonnen@richardsonnen.com">sonnen@richardsonnen.com</a></u>&gt;.

       is_tel_uri by David Dick &lt;<u><a href="mailto:ddick@cpan.org">ddick@cpan.org</a></u>&gt;.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2005 Richard Sonnen. All rights reserved.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.38.2                                       2024-03-04                           <u>Data::Validate::<a href="../man3pm/URI.3pm.html">URI</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>