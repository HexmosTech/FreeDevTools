<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libacpi - general purpose library for ACPI</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libacpi-dev">libacpi-dev_0.2-7build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>libacpi</b> - general purpose library for ACPI

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;libacpi.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>libacpi</b> library routines provide its users a method of reading ACPI values in a comfortable way. This
       includes battery information, fan states, thermal zones and AC states.

       A program using these routines must be linked with <b>-lacpi</b> option.

       To initialize this functionality you have to first allocate space for a global_t structure

           <b>global_t</b> <b>*global</b> <b>=</b> <b>malloc</b> <b>(sizeof</b> <b>(global_t));</b>

       Now use the <b>check_acpi_support()</b> function to check if the system actually supports ACPI.  In case it does
       the function will return <b>SUCCESS</b> or <b>NOT_SUPPORTED</b> on failure.

       Now you can use the following functions to initialize the values you get from the ACPI interface:

           <b>init_acpi_batt(global);</b>
           <b>init_acpi_acadapt(global);</b>
           <b>init_acpi_fan(global);</b>
           <b>init_acpi_thermal(global);</b>

       To  know  if  some  of the features is not supported it is a good idea to store the return values in some
       variable.

       If you want to read non-static values the ACPI interface provides (for example battery  percentage),  use
       the following functions to do this:

           <b>read_acpi_batt(int</b> <b>num)</b>
           <b>read_acpi_zone(int</b> <b>num,</b> <b>global_t</b> <b>*globals);</b>
           <b>read_acpi_fan(int</b> <b>num)</b>
           <b>read_acpi_acstate(global_t</b> <b>*globals);</b>

       Since  you  can have more than one battery, fan and thermal zone, num is the number you want to read, for
       example in a loop.

           <b>thermal_t</b> <b>*tp;</b>
           ....
           <b>for(i=0;</b> <b>i&lt;global-&gt;thermal_count;</b> <b>i++){</b>
               <b>read_acpi_zone(i,</b> <b>global);</b>
               <b>tp</b> <b>=</b> <b>&amp;thermals[i];</b>
           ...
           <b>}</b>

   <b>Structures</b>
       struct <b>fan_t</b>
           <u>fan</u> <u>data</u>
       struct <b>battery_t</b>
           <u>information</u> <u>found</u> <u>about</u> <u>battery</u>
       struct <b>thermal_t</b>
           <u>information</u> <u>about</u> <u>thermal</u> <u>zone</u>
       struct <b>adapter_t</b>
           <u>information</u> <u>about</u> <u>ac</u> <u>adapter</u>
       struct <b>global_t</b>
           <u>global</u> <u>acpi</u> <u>structure</u>

   <b>Functions</b>
       int <b>init_acpi_batt</b> (<b>global_t</b> *globals)
       int <b>init_acpi_acadapt</b> (<b>global_t</b> *globals)
       int <b>init_acpi_thermal</b> (<b>global_t</b> *globals)
       int <b>init_acpi_fan</b> (<b>global_t</b> *globals)
       int <b>check_acpi_support</b> (void)
       int <b>read_acpi_batt</b> (const int num)
       void <b>read_acpi_acstate</b> (<b>global_t</b> *globals)
       int <b>read_acpi_zone</b> (const int num, <b>global_t</b> *globals)
       int <b>read_acpi_fan</b> (const int num)

   <b>Variables</b>
       <b>battery_t</b> <b>batteries</b> [MAX_ITEMS]
       <b>thermal_t</b> <b>thermals</b> [MAX_ITEMS]
       <b>fan_t</b> <b>fans</b> [MAX_ITEMS]

   <b>Enumerations</b>
       enum { <b>ITEM_EXCEED</b> =  -5, <b>DISABLED</b> =  -4, <b>NOT_PRESENT</b> =   -3,  <b>ALLOC_ERR</b>  =   -2,  <b>NOT_SUPPORTED</b>  =   -1,
           <b>SUCCESS</b> }
       enum <b>power_state_t</b> { <b>P_AC</b>, <b>P_BATT</b>, <b>P_ERR</b> }
       enum <b>thermal_state_t</b> { <b>T_CRIT</b>, <b>T_HOT</b>, <b>T_PASS</b>, <b>T_ACT</b>, <b>T_OK</b>, <b>T_ERR</b> }
       enum <b>charge_state_t</b> { <b>C_CHARGE</b>, <b>C_DISCHARGE</b>, <b>C_CHARGED</b>, <b>C_NOINFO</b>, <b>C_ERR</b> }
       enum <b>batt_state_t</b> { <b>B_HIGH</b>, <b>B_MED</b>, <b>B_LOW</b>, <b>B_CRIT</b>, <b>B_HARD_CRIT</b>, <b>B_ERR</b> }
       enum <b>thermal_mode_t</b> { <b>CO_ACT</b>, <b>CO_PASS</b>, <b>CO_CRIT</b>, <b>CO_ERR</b> }
       enum <b>fan_state_t</b> { <b>F_ON</b>, <b>F_OFF</b>, <b>F_ERR</b> }

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Now follows a more detailed description of functions, structures and enums.

       Definition in file <b>libacpi.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>int</b> <b>check_acpi_support</b> <b>(void)</b>
       Checks if the system does support ACPI or not.

       <b>Returns:</b>
           SUCCESS if the system supports ACPI or, NOT_SUPPORTED.

   <b>int</b> <b>init_acpi_acadapt</b> <b>(global_t</b> <b>*</b> <b>globals)</b>
       Finds existing ac adapter and fills the adapt (in globa struct) structure with the paths of the important
       files to parse.

       <b>Parameters:</b>
           <u>globals</u> pointer to global acpi structure

           <b>Returns:</b>
               SUCCESS  if  everything  is  ok,  NOT_SUPPORTED  if  no  information  can  be found, ALLOC_ERR on
               allocation errors.

   <b>int</b> <b>init_acpi_batt</b> <b>(global_t</b> <b>*</b> <b>globals)</b>
       Finds existing batteries and fills the corresponding batteries structures with the paths of the important
       files to parse.

       <b>Parameters:</b>
           <u>globals</u> pointer to global acpi structure

           <b>Returns:</b>
               SUCCESS if everything is  ok,  NOT_SUPPORTED  if  no  information  can  be  found,  ALLOC_ERR  on
               allocation  errors  and ITEM_EXCEED if there are more batteries found than MAX_ITEMS, this should
               never happen.

   <b>int</b> <b>init_acpi_fan</b> <b>(global_t</b> <b>*</b> <b>globals)</b>
       Finds existing fans and fills corresponding fan structures with the paths of the important files to parse
       for fan information.

       <b>Parameters:</b>
           <u>globals</u> pointer to global acpi structure

           <b>Returns:</b>
               SUCCESS if everything is  ok,  NOT_SUPPORTED  if  no  information  can  be  found,  ALLOC_ERR  on
               allocation  errors and ITEM_EXCEED if there are more fans found than MAX_ITEMS, this should never
               happen.

   <b>int</b> <b>init_acpi_thermal</b> <b>(global_t</b> <b>*</b> <b>globals)</b>
       Finds existing thermal zones and fills corresponding thermal structures with the paths of  the  important
       files to parse for thermal information.

       <b>Parameters:</b>
           <u>globals</u> pointer to global acpi structure

           <b>Returns:</b>
               SUCCESS  if  everything  is  ok,  NOT_SUPPORTED  if  no  information  can  be found, ALLOC_ERR on
               allocation errors and ITEM_EXCEED if there are more thermal  zones  found  than  MAX_ITEMS,  this
               should never happen.

   <b>void</b> <b>read_acpi_acstate</b> <b>(global_t</b> <b>*</b> <b>globals)</b>
       Looks up if the ac adapter is plugged in or not and sets the values in a struct

       <b>Parameters:</b>
           <u>globals</u> pointer to the global acpi structure

       Referenced by init_acpi_acadapt().

   <b>int</b> <b>read_acpi_batt</b> <b>(const</b> <b>int</b> <b>num)</b>
       Gathers all information of a given battery and filling a struct with it.

       <b>Parameters:</b>
           <u>num</u> number of battery

           <b>Returns:</b>
               SUCCESS if everything is ok or ITEM_EXCEED if there is not battery num.

   <b>int</b> <b>read_acpi_fan</b> <b>(const</b> <b>int</b> <b>num)</b>
       Gathers all information about given fan and sets the corresponding values in a struct.

       <b>Parameters:</b>
           <u>num</u> number for the fan to read

           <b>Returns:</b>
               SUCCESS  if  everything is ok, ITEM_EXCEED if there is not fan num or NOT_SUPPORTED if the values
               can't be read. This should not  happen  if  the  init  function  returned  SUCCESS  if  the  ACPI
               implementation.

   <b>int</b> <b>read_acpi_zone</b> <b>(const</b> <b>int</b> <b>num,</b> <b>global_t</b> <b>*</b> <b>globals)</b>
       Gathers all information of a given thermal zone and sets the corresponding values in a struct.

       <b>Parameters:</b>
           <u>num</u> zone
           <u>globals</u> pointer to global acpi struct, needed if there is just one zone

           <b>Returns:</b>
               SUCCESS if everything is ok, ITEM_EXCEED if there is not thermal zone num or NOT_SUPPORTED if the
               values  can't  be  read. This should not happen if the init function returned SUCCESS if the ACPI
               implementation.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>possible</b> <b>function</b> <b>return</b> <b>values</b>
       <b>Enumerator:</b>

       <u>ITEM_EXCEED</u>
              maximum item count reached

       <u>DISABLED</u>
              features is disabled

       <u>NOT_PRESENT</u>
              something is not present

       <u>ALLOC_ERR</u>
              an error occurred while allocating space

       <u>NOT_SUPPORTED</u>
              a feature is not supported

       <u>SUCCESS</u>
              everything was fine

   <b>enum</b> <b>batt_state_t</b>
       <b>Enumerator:</b>

       <u>B_HIGH</u> remaining battery life is high

       <u>B_MED</u>  remaining battery life is medium

       <u>B_LOW</u>  remaining battery life is low

       <u>B_CRIT</u> remaining battery life is critical

       <u>B_HARD_CRIT</u>
              remaining battery life is hard critical, you have a few minutes to charge

       <u>B_ERR</u>  some error occurred while reading the battery state

   <b>enum</b> <b>charge_state_t</b>
       <b>Enumerator:</b>

       <u>C_CHARGE</u>
              battery is currently charging

       <u>C_DISCHARGE</u>
              battery is currently discharging

       <u>C_CHARGED</u>
              battery is charged

       <u>C_NOINFO</u>
              hardware doesn't give information about the state

       <u>C_ERR</u>  some error occurred while reading the charge state

   <b>enum</b> <b>fan_state_t</b>
       fan states

       <b>Enumerator:</b>

       <u>F_ON</u>   fan is on

       <u>F_OFF</u>  fan is off

       <u>F_ERR</u>  some error occurred with this fan

   <b>enum</b> <b>power_state_t</b>
       <b>Enumerator:</b>

       <u>P_AC</u>   if computer runs on AC

       <u>P_BATT</u> if computer runs on battery

       <u>P_ERR</u>  no information can be found

   <b>enum</b> <b>thermal_mode_t</b>
       <b>Enumerator:</b>

       <u>CO_ACT</u> fans will be turned after the temperature passes a critical point

       <u>CO_PASS</u>
              devices will be put in a lower power state after a critical point

       <u>CO_CRIT</u>
              system goes into suspend to disk if possible after a critical temperature

       <u>CO_ERR</u> some error occurred while reading the cooling mode

   <b>enum</b> <b>thermal_state_t</b>
       <b>Enumerator:</b>

       <u>T_CRIT</u> zone reports critical temperature, will cause system to go to S4

       <u>T_HOT</u>  zone reports high temperature, will cause system to shutdown immediately

       <u>T_PASS</u> zone is on passive cooling

       <u>T_ACT</u>  zone is on active cooling, more power consumption

       <u>T_OK</u>   zone is ok

       <u>T_ERR</u>  some error occurred while reading the state of the zone

</pre><h4><b>Variable</b> <b>Documentation</b></h4><pre>
   <b>battery_t</b> <b>batteries[MAX_ITEMS]</b>
       Array for existing batteries, loop until globals-&gt;battery_count

   <b>fan_t</b> <b>fans[MAX_ITEMS]</b>
       Array for existing fans, loop until globals-&gt;fan_count

   <b>thermal_t</b> <b>thermals[MAX_ITEMS]</b>
       Array for existing thermal zones, loop until globals-&gt;thermal_count

</pre><h4><b>Additional</b> <b>information</b></h4><pre>
       The package ships a test-libacpi.c file which should be pretty self explanatory.  Also have a  look  into
       libacpi.h file and the doxygen documentation in the doc/ directory.

</pre><h4><b>Homepage</b></h4><pre>
       See <a href="http://www.ngolde.de/libacpi.html">http://www.ngolde.de/libacpi.html</a>

</pre><h4><b>Author</b></h4><pre>
       Write to nico (at) ngolde (dot) de for suggestions, hardware donations (very welcome, my notebook doesn't
       support all features and I could need a second battery), questions, fixes, bug reports, thanks, etc. :)

                                                     LIBACPI                                          <u><a href="../man3/libacpi.3.html">libacpi</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>