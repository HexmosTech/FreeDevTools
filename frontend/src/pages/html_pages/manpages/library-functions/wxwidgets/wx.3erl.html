<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wx - A port of wxWidgets.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       wx - A port of wxWidgets.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A port of wxWidgets.

       This  is  the  base  api  of  wxWidgets. This module contains functions for starting and stopping the wx-
       server, as well as other utility functions.

       wxWidgets is object oriented, and not functional. Thus, in wxErlang a module represents a class, and  the
       object  created  by this class has an own type, wxCLASS(). This module represents the base class, and all
       other wxMODULE's are sub-classes of this class.

       Objects of a class are  created  with  wxCLASS:new(...)  and  destroyed  with  wxCLASS:destroy().  Member
       functions are called with wxCLASS:member(Object, ...) instead of as in C++ Object.member(...).

       Sub  class  modules  inherit  (non  static) functions from their parents. The inherited functions are not
       documented in the sub-classes.

       This erlang port of wxWidgets tries to be a one-to-one mapping with the original wxWidgets library.  Some
       things  are  different  though, as the optional arguments use property lists and can be in any order. The
       main difference is the event handling which is different from the original library. See wxEvtHandler.

       The following classes are implemented directly as erlang types:
       wxPoint={x,y},wxSize={w,h},wxRect={x,y,w,h},wxColour={r,g,b      [,a]},      wxString=unicode:chardata(),
       wxGBPosition={r,c},wxGBSpan={rs,cs},wxGridCellCoords={r,c}.

       wxWidgets  uses  a  process  specific  environment,  which  is created by wx:new/0. To be able to use the
       environment from other processes, call get_env/0 to retrieve the environment and set_env/1 to assign  the
       environment in the other process.

       Global (classless) functions are located in the wx_misc module.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
         <b>wx_colour()</b> <b>=</b> <b>{R::byte(),</b> <b>G::byte(),</b> <b>B::byte()}</b> <b>|</b> <b>wx_colour4():</b>

         <b>wx_colour4()</b> <b>=</b> <b>{R::byte(),</b> <b>G::byte(),</b> <b>B::byte(),</b> <b>A::byte()}:</b>

         <b>wx_datetime()</b> <b>=</b> <b>{{Year::integer(),</b> <b>Month::integer(),</b> <b>Day::integer()},</b> <b>{Hour::integer(),</b>
         <b>Minute::integer(),</b> <b>Second::integer()}}:</b>

           In Local Timezone

         <b>wx_enum()</b> <b>=</b> <b>integer():</b>

           Constant defined in wx.hrl

         <b>wx_env()</b> <b>=</b> <b>#wx_env{}:</b>

           Opaque process environment

         <b>wx_memory()</b> <b>=</b> <b>binary()</b> <b>|</b> <b>#wx_mem{}:</b>

           Opaque memory reference

         <b>wx_object()</b> <b>=</b> <b>#wx_ref{}:</b>

           Opaque object reference

         <b>wx_wxHtmlLinkInfo()</b> <b>=</b> <b>#wxHtmlLinkInfo{href=unicode:chardata(),</b> <b>target=unicode:chardata()}:</b>

         <b>wx_wxMouseState()</b> <b>=</b> <b>#wxMouseState{x=integer(),</b> <b>y=integer(),</b> <b>leftDown=boolean(),</b> <b>middleDown=boolean(),</b>
         <b>rightDown=boolean(),</b> <b>controlDown=boolean(),</b> <b>shiftDown=boolean(),</b> <b>altDown=boolean(),</b> <b>metaDown=boolean(),</b>
         <b>cmdDown=boolean()}:</b>

           See #wxMouseState{} defined in wx.hrl

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>parent_class(X1)</b> <b>-&gt;</b> <b>term()</b>

       <b>new()</b> <b>-&gt;</b> <b>wx_object()</b>

              Starts a wx server.

       <b>new(Options::[Option])</b> <b>-&gt;</b> <b>wx_object()</b>

              Types:

                 Option = {debug, list() | atom()} | {silent_start, boolean()}

              Starts  a  wx  server.  Option  may be {debug, Level}, see debug/1. Or {silent_start, Bool}, which
              causes error messages at startup to be suppressed. The latter can be used  as  a  silent  test  of
              whether wx is properly installed or not.

       <b>destroy()</b> <b>-&gt;</b> <b>ok</b>

              Stops a wx server.

       <b>get_env()</b> <b>-&gt;</b> <b>wx_env()</b>

              Gets  this process's current wx environment. Can be sent to other processes to allow them use this
              process wx environment.

              <u>See</u> <u>also:</u> set_env/1.

       <b>set_env(Wx_env::wx_env())</b> <b>-&gt;</b> <b>ok</b>

              Sets the process wx environment, allows this process to use another process wx environment.

       <b>null()</b> <b>-&gt;</b> <b>wx_object()</b>

              Returns the null object

       <b>is_null(Wx_ref::wx_object())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns true if object is null, false otherwise

       <b>equal(Wx_ref::wx_object(),</b> <b>X2::wx_object())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns true if both arguments references the same object, false otherwise

       <b>getObjectType(Wx_ref::wx_object())</b> <b>-&gt;</b> <b>atom()</b>

              Returns the object type

       <b>typeCast(Old::wx_object(),</b> <b>NewType::atom())</b> <b>-&gt;</b> <b>wx_object()</b>

              Casts the object to class NewType. It is needed when using functions  like  wxWindow:findWindow/2,
              which returns a generic wxObject type.

       <b>batch(Fun::function())</b> <b>-&gt;</b> <b>term()</b>

              Batches  all  <u>wx</u>  commands  used  in  the  fun.  Improves performance of the command processing by
              grabbing the wxWidgets thread so that no event processing will be done before the  complete  batch
              of commands is invoked.

              <u>See</u> <u>also:</u> foldl/3, foldr/3, foreach/2, map/2.

       <b>foreach(Fun::function(),</b> <b>List::list())</b> <b>-&gt;</b> <b>ok</b>

              Behaves like lists:foreach/2 but batches wx commands. See batch/1.

       <b>map(Fun::function(),</b> <b>List::list())</b> <b>-&gt;</b> <b>list()</b>

              Behaves like lists:map/2 but batches wx commands. See batch/1.

       <b>foldl(Fun::function(),</b> <b>Acc::term(),</b> <b>List::list())</b> <b>-&gt;</b> <b>term()</b>

              Behaves like lists:foldl/3 but batches wx commands. See batch/1.

       <b>foldr(Fun::function(),</b> <b>Acc::term(),</b> <b>List::list())</b> <b>-&gt;</b> <b>term()</b>

              Behaves like lists:foldr/3 but batches wx commands. See batch/1.

       <b>create_memory(Size::integer())</b> <b>-&gt;</b> <b>wx_memory()</b>

              Creates  a  memory area (of Size in bytes) which can be used by an external library (i.e. opengl).
              It is up to the client to keep a reference to this object so it does not get garbage collected  by
              erlang while still in use by the external library.

              This is far from erlang's intentional usage and can crash the erlang emulator. Use it carefully.

       <b>get_memory_bin(Wx_mem::wx_memory())</b> <b>-&gt;</b> <b>binary()</b>

              Returns the memory area as a binary.

       <b>retain_memory(Wx_mem::wx_memory())</b> <b>-&gt;</b> <b>ok</b>

              Saves the memory from deletion until release_memory/1 is called. If release_memory/1 is not called
              the memory will not be garbage collected.

       <b>release_memory(Wx_mem::wx_memory())</b> <b>-&gt;</b> <b>ok</b>

       <b>debug(Debug::Level</b> <b>|</b> <b>[Level])</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Level = none | verbose | trace | driver | integer()

              Sets debug level. If debug level is 'verbose' or 'trace' each call is printed on console. If Level
              is 'driver' each allocated object and deletion is printed on the console.

       <b>demo()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>atom()}</b>

              Starts a wxErlang demo if examples directory exists and is compiled

</pre><h4><b>AUTHORS</b></h4><pre>
       <u>&lt;&gt;</u>

                                                    wx 2.1.1                                            <u><a href="../man3erl/wx.3erl.html">wx</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>