<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBD::Gofer - A stateless-proxy driver for communicating with a remote DBI</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbi-perl">libdbi-perl_1.647-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBD::Gofer - A stateless-proxy driver for communicating with a remote DBI

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use DBI;

         $original_dsn = "dbi:..."; # your original DBI Data Source Name

         $dbh = DBI-&gt;connect("dbi:Gofer:transport=$transport;...;dsn=$original_dsn",
                             $user, $passwd, \%attributes);

         ... use $dbh as if it was connected to $original_dsn ...

       The "transport=$transport" part specifies the name of the module to use to transport the requests to the
       remote DBI. If $transport doesn't contain any double colons then it's prefixed with
       "DBD::Gofer::Transport::".

       The "dsn=$original_dsn" part <u>must</u> <u>be</u> <u>the</u> <u>last</u> <u>element</u> of the DSN because everything after "dsn=" is
       assumed to be the DSN that the remote DBI should use.

       The "..." represents attributes that influence the operation of the Gofer driver or transport. These are
       described below or in the documentation of the transport module being used.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       DBD::Gofer is a DBI database driver that forwards requests to another DBI driver, usually in a separate
       process, often on a separate machine. It tries to be as transparent as possible so it appears that you
       are using the remote driver directly.

       DBD::Gofer is very similar to DBD::Proxy. The major difference is that with DBD::Gofer no state is
       maintained on the remote end. That means every request contains all the information needed to create the
       required state. (So, for example, every request includes the DSN to connect to.) Each request can be sent
       to any available server. The server executes the request and returns a single response that includes all
       the data.

       This is very similar to the way http works as a stateless protocol for the web.  Each request from your
       web browser can be handled by a different web server process.

   <b>Use</b> <b>Cases</b>
       This may seem like pointless overhead but there are situations where this is a very good thing. Let's
       consider a specific case.

       Imagine using DBD::Gofer with an http transport. Your application calls <b>connect()</b>, prepare("select * from
       table where foo=?"), <b>bind_param()</b>, and <b>execute()</b>.  At this point DBD::Gofer builds a request containing
       all the information about the method calls. It then uses the httpd transport to send that request to an
       apache web server.

       This 'dbi execute' web server executes the request (using DBI::Gofer::Execute and related modules) and
       builds a response that contains all the rows of data, if the statement returned any, along with all the
       attributes that describe the results, such as $sth-&gt;{NAME}. This response is sent back to DBD::Gofer
       which unpacks it and presents it to the application as if it had executed the statement itself.

   <b>Advantages</b>
       Okay, but you still don't see the point? Well let's consider what we've gained:

       <u>Connection</u> <u>Pooling</u> <u>and</u> <u>Throttling</u>

       The 'dbi execute' web server leverages all the functionality of web infrastructure in terms of load
       balancing, high-availability, firewalls, access management, proxying, caching.

       At its most basic level you get a configurable pool of persistent database connections.

       <u>Simple</u> <u>Scaling</u>

       Got thousands of processes all trying to connect to the database? You can use DBD::Gofer to connect them
       to your smaller pool of 'dbi execute' web servers instead.

       <u>Caching</u>

       Client-side caching is as simple as adding ""cache=1"" to the DSN.  This feature alone can be worth using
       DBD::Gofer for.

       <u>Fewer</u> <u>Network</u> <u>Round-trips</u>

       DBD::Gofer sends as few requests as possible (dependent on the policy being used).

       <u>Thin</u> <u>Clients</u> <u>/</u> <u>Unsupported</u> <u>Platforms</u>

       You no longer need drivers for your database on every system.  DBD::Gofer is pure perl.

</pre><h4><b>CONSTRAINTS</b></h4><pre>
       There are some natural constraints imposed by the DBD::Gofer 'stateless' approach.  But not many:

   <b>You</b> <b>can't</b> <b>change</b> <b>database</b> <b>handle</b> <b>attributes</b> <b>after</b> <b>connect()</b>
       You can't change database handle attributes after you've connected.  Use the <b>connect()</b> call to specify
       all the attribute settings you want.

       This is because it's critical that when a request is complete the database handle is left in the same
       state it was when first connected.

       An exception is made for attributes with names starting ""private_"": They can be set after <b>connect()</b> but
       the change is only applied locally.

   <b>You</b> <b>can't</b> <b>change</b> <b>statement</b> <b>handle</b> <b>attributes</b> <b>after</b> <b>prepare()</b>
       You can't change statement handle attributes after prepare.

       An exception is made for attributes with names starting ""private_"": They can be set after <b>prepare()</b> but
       the change is only applied locally.

   <b>You</b> <b>can't</b> <b>use</b> <b>transactions</b>
       AutoCommit only. Transactions aren't supported.

       (In theory transactions could be supported when using a transport that maintains a connection, like
       "stream" does. If you're interested in this please get in touch via <a href="mailto:dbi-dev@perl.org">dbi-dev@perl.org</a>)

   <b>You</b> <b>can't</b> <b>call</b> <b>driver-private</b> <b>sth</b> <b>methods</b>
       But that's rarely needed anyway.

</pre><h4><b>GENERAL</b> <b>CAVEATS</b></h4><pre>
       A few important things to keep in mind when using DBD::Gofer:

   <b>Temporary</b> <b>tables,</b> <b>locks,</b> <b>and</b> <b>other</b> <b>per-connection</b> <b>persistent</b> <b>state</b>
       You shouldn't expect any per-session state to persist between requests.  This includes locks and
       temporary tables.

       Because the server-side may execute your requests via a different database connections, you can't rely on
       any per-connection persistent state, such as temporary tables, being available from one request to the
       next.

       This is an easy trap to fall into. A good way to check for this is to test your code with a Gofer policy
       package that sets the "connect_method" policy to 'connect' to force a new connection for each request.
       The "pedantic" policy does this.

   <b>Driver-private</b> <b>Database</b> <b>Handle</b> <b>Attributes</b>
       Some driver-private dbh attributes may not be available if the driver has not implemented the
       <b>private_attribute_info()</b> method (added in DBI 1.54).

   <b>Driver-private</b> <b>Statement</b> <b>Handle</b> <b>Attributes</b>
       Driver-private sth attributes can be set in the <b>prepare()</b> call. TODO

       Some driver-private sth attributes may not be available if the driver has not implemented the
       <b>private_attribute_info()</b> method (added in DBI 1.54).

   <b>Multiple</b> <b>Resultsets</b>
       Multiple resultsets are supported only if the driver supports the <b>more_results()</b> method (an exception is
       made for DBD::Sybase).

   <b>Statement</b> <b>activity</b> <b>that</b> <b>also</b> <b>updates</b> <b>dbh</b> <b>attributes</b>
       Some drivers may update one or more dbh attributes after performing activity on a child sth.  For
       example, DBD::mysql provides $dbh-&gt;{mysql_insertid} in addition to $sth-&gt;{mysql_insertid}. Currently
       mysql_insertid is supported via a hack but a more general mechanism is needed for other drivers to use.

   <b>Methods</b> <b>that</b> <b>report</b> <b>an</b> <b>error</b> <b>always</b> <b>return</b> <b>undef</b>
       With DBD::Gofer, a method that sets an error always return an undef or empty list.  That shouldn't be a
       problem in practice because the DBI doesn't define any methods that return meaningful values while also
       reporting an error.

   <b>Subclassing</b> <b>only</b> <b>applies</b> <b>to</b> <b>client-side</b>
       The RootClass and DbTypeSubclass attributes are not passed to the Gofer server.

</pre><h4><b>CAVEATS</b> <b>FOR</b> <b>SPECIFIC</b> <b>METHODS</b></h4><pre>
   <b>last_insert_id</b>
       To enable use of last_insert_id you need to indicate to DBD::Gofer that you'd like to use it.  You do
       that my adding a "go_last_insert_id_args" attribute to the <b>do()</b> or <b>prepare()</b> method calls. For example:

           $dbh-&gt;do($sql, { go_last_insert_id_args =&gt; [...] });

       or

           $sth = $dbh-&gt;prepare($sql, { go_last_insert_id_args =&gt; [...] });

       The array reference should contains the args that you want passed to the <b>last_insert_id()</b> method.

   <b>execute_for_fetch</b>
       The array methods <b>bind_param_array()</b> and <b>execute_array()</b> are supported.  When <b>execute_array()</b> is called
       the data is serialized and executed in a single round-trip to the Gofer server. This makes it very fast,
       but requires enough memory to store all the serialized data.

       The <b>execute_for_fetch()</b> method currently isn't optimised, it uses the DBI fallback behaviour of executing
       each tuple individually.  (It could be implemented as a wrapper for <b>execute_array()</b> - patches welcome.)

</pre><h4><b>TRANSPORTS</b></h4><pre>
       DBD::Gofer doesn't concern itself with transporting requests and responses to and fro.  For that it uses
       special Gofer transport modules.

       Gofer transport modules usually come in pairs: one for the 'client' DBD::Gofer driver to use and one for
       the remote 'server' end. They have very similar names:

           DBD::Gofer::Transport::&lt;foo&gt;
           DBI::Gofer::Transport::&lt;foo&gt;

       Sometimes the transports on the DBD and DBI sides may have different names. For example
       DBD::Gofer::Transport::http is typically used with DBI::Gofer::Transport::mod_perl
       (DBD::Gofer::Transport::http and DBI::Gofer::Transport::mod_perl modules are part of the GoferTransport-
       http distribution).

   <b>Bundled</b> <b>Transports</b>
       Several transport modules are provided with DBD::Gofer:

       <u>null</u>

       The null transport is the simplest of them all. It doesn't actually transport the request anywhere.  It
       just serializes (freezes) the request into a string, then thaws it back into a data structure before
       passing it to DBI::Gofer::Execute to execute. The same freeze and thaw is applied to the results.

       The null transport is the best way to test if your application will work with Gofer.  Just set the
       DBI_AUTOPROXY environment variable to ""dbi:Gofer:transport=null;policy=pedantic"" (see "Using
       DBI_AUTOPROXY" below) and run your application, or ideally its test suite, as usual.

       It doesn't take any parameters.

       <u>pipeone</u>

       The pipeone transport launches a subprocess for each request. It passes in the request and reads the
       response.

       The fact that a new subprocess is started for each request ensures that the server side is truly
       stateless. While this does make the transport <u>very</u> slow, it is useful as a way to test that your
       application doesn't depend on per-connection state, such as temporary tables, persisting between
       requests.

       It's also useful both as a proof of concept and as a base class for the stream driver.

       <u>stream</u>

       The stream driver also launches a subprocess and writes requests and reads responses, like the pipeone
       transport.  In this case, however, the subprocess is expected to handle more that one request. (Though it
       will be automatically restarted if it exits.)

       This is the first transport that is truly useful because it can launch the subprocess on a remote machine
       using "ssh". This means you can now use DBD::Gofer to easily access any databases that's accessible from
       any system you can login to.  You also get all the benefits of ssh, including encryption and optional
       compression.

       See "Using DBI_AUTOPROXY" below for an example.

   <b>Other</b> <b>Transports</b>
       Implementing a Gofer transport is <u>very</u> simple, and more transports are very welcome.  Just take a look at
       any existing transports that are similar to your needs.

       <u>http</u>

       See the GoferTransport-http distribution on CPAN: <a href="http://search.cpan.org/dist/GoferTransport-http/">http://search.cpan.org/dist/GoferTransport-http/</a>

       <u>Gearman</u>

       I know Ask Bj√∏rn Hansen has implemented a transport for the "gearman" distributed job system, though it's
       not on CPAN at the time of writing this.

</pre><h4><b>CONNECTING</b></h4><pre>
       Simply prefix your existing DSN with ""dbi:Gofer:transport=$transport;dsn="" where $transport is the name
       of the Gofer transport you want to use (see "TRANSPORTS").  The "transport" and "dsn" attributes must be
       specified and the "dsn" attributes must be last.

       Other attributes can be specified in the DSN to configure DBD::Gofer and/or the Gofer transport module
       being used. The main attributes after "transport", are "url" and "policy". These and other attributes are
       described below.

   <b>Using</b> <b>DBI_AUTOPROXY</b>
       The simplest way to try out DBD::Gofer is to set the DBI_AUTOPROXY environment variable.  In this case
       you don't include the "dsn=" part. For example:

           export DBI_AUTOPROXY="dbi:Gofer:transport=null"

       or, for a more useful example, try:

           export DBI_AUTOPROXY="dbi:Gofer:transport=stream;url=ssh:<a href="mailto:user@example.com">user@example.com</a>"

   <b>Connection</b> <b>Attributes</b>
       These attributes can be specified in the DSN. They can also be passed in the \%attr parameter of the DBI
       connect method by adding a ""go_"" prefix to the name.

       <u>transport</u>

       Specifies the Gofer transport class to use. Required. See "TRANSPORTS" above.

       If the value does not include "::" then ""DBD::Gofer::Transport::"" is prefixed.

       The transport object can be accessed via $h-&gt;{go_transport}.

       <u>dsn</u>

       Specifies the DSN for the remote side to connect to. Required, and must be last.

       <u>url</u>

       Used to tell the transport where to connect to. The exact form of the value depends on the transport
       used.

       <u>policy</u>

       Specifies the policy to use. See "CONFIGURING BEHAVIOUR POLICY".

       If the value does not include "::" then ""DBD::Gofer::Policy"" is prefixed.

       The policy object can be accessed via $h-&gt;{go_policy}.

       <u>timeout</u>

       Specifies a timeout, in seconds, to use when waiting for responses from the server side.

       <u>retry_limit</u>

       Specifies the number of times a failed request will be retried. Default is 0.

       <u>retry_hook</u>

       Specifies a code reference to be called to decide if a failed request should be retried.  The code
       reference is called like this:

         $transport = $h-&gt;{go_transport};
         $retry = $transport-&gt;go_retry_hook-&gt;($request, $response, $transport);

       If it returns true then the request will be retried, up to the "retry_limit".  If it returns a false but
       defined value then the request will not be retried.  If it returns undef then the default behaviour will
       be used, as if "retry_hook" had not been specified.

       The default behaviour is to retry requests where $request-&gt;is_idempotent is true, or the error message
       matches "/induced by DBI_GOFER_RANDOM/".

       <u>cache</u>

       Specifies that client-side caching should be performed.  The value is the name of a cache class to use.

       Any class implementing get($key) and set($key, $value) methods can be used.  That includes a great many
       powerful caching classes on CPAN, including the Cache and Cache::Cache distributions.

       You can use ""cache=1"" is a shortcut for ""cache=DBI::Util::CacheMemory"".  See DBI::Util::CacheMemory
       for a description of this simple fast default cache.

       The cache object can be accessed via $h-&gt;go_cache. For example:

           $dbh-&gt;go_cache-&gt;clear; # free up memory being used by the cache

       The cache keys are the frozen (serialized) requests, and the values are the frozen responses.

       The default behaviour is to only use the cache for requests where $request-&gt;is_idempotent is true (i.e.,
       the dbh has the ReadOnly attribute set or the SQL statement is obviously a SELECT without a FOR UPDATE
       clause.)

       For even more control you can use the "go_cache" attribute to pass in an instantiated cache object.
       Individual methods, including <b>prepare()</b>, can also specify alternative caches via the "go_cache"
       attribute. For example, to specify no caching for a particular query, you could use

           $sth = $dbh-&gt;prepare( $sql, { go_cache =&gt; 0 } );

       This can be used to implement different caching policies for different statements.

       It's interesting to note that DBD::Gofer can be used to add client-side caching to any (gofer compatible)
       application, with no code changes and no need for a gofer server.  Just set the DBI_AUTOPROXY environment
       variable like this:

           DBI_AUTOPROXY='dbi:Gofer:transport=null;cache=1'

</pre><h4><b>CONFIGURING</b> <b>BEHAVIOUR</b> <b>POLICY</b></h4><pre>
       DBD::Gofer supports a 'policy' mechanism that allows you to fine-tune the number of round-trips to the
       Gofer server.  The policies are grouped into classes (which may be subclassed) and referenced by the name
       of the class.

       The DBD::Gofer::Policy::Base class is the base class for all the policy packages and describes all the
       available policies.

       Three policy packages are supplied with DBD::Gofer:

       DBD::Gofer::Policy::pedantic is most 'transparent' but slowest because it makes more  round-trips to the
       Gofer server.

       DBD::Gofer::Policy::classic is a reasonable compromise - it's the default policy.

       DBD::Gofer::Policy::rush is fastest, but may require code changes in your applications.

       Generally the default "classic" policy is fine. When first testing an existing application with Gofer it
       is a good idea to start with the "pedantic" policy first and then switch to "classic" or a custom policy,
       for final testing.

</pre><h4><b>AUTHOR</b></h4><pre>
       Tim Bunce, &lt;<a href="http://www.tim.bunce.name">http://www.tim.bunce.name</a>&gt;

</pre><h4><b>LICENCE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2007, Tim Bunce, Ireland. All rights reserved.

       This module is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself. See perlartistic.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       The development of DBD::Gofer and related modules was sponsored by Shopzilla.com
       (&lt;<a href="http://Shopzilla.com">http://Shopzilla.com</a>&gt;), where I currently work.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       DBI::Gofer::Request, DBI::Gofer::Response, DBI::Gofer::Execute.

       DBI::Gofer::Transport::Base, DBD::Gofer::Policy::Base.

       DBI

</pre><h4><b>Caveats</b> <b>for</b> <b>specific</b> <b>drivers</b></h4><pre>
       This section aims to record issues to be aware of when using Gofer with specific drivers.  It usually
       only documents issues that are not natural consequences of the limitations of the Gofer approach - as
       documented above.

</pre><h4><b>TODO</b></h4><pre>
       This is just a random brain dump... (There's more in the source of the Changes file, not the pod)

       Document policy mechanism

       Add mechanism for transports to list config params and for Gofer to apply any that match (and warn if any
       left over?)

       Driver-private sth attributes - set via <b>prepare()</b> - change DBI spec

       add hooks into transport base class for checking &amp; updating a result set cache
          ie via a standard cache interface such as:
          <a href="http://search.cpan.org/~robm/Cache-FastMmap/FastMmap.pm">http://search.cpan.org/~robm/Cache-FastMmap/FastMmap.pm</a>
          <a href="http://search.cpan.org/~bradfitz/Cache-Memcached/lib/Cache/Memcached.pm">http://search.cpan.org/~bradfitz/Cache-Memcached/lib/Cache/Memcached.pm</a>
          <a href="http://search.cpan.org/~dclinton/Cache-Cache/">http://search.cpan.org/~dclinton/Cache-Cache/</a>
          <a href="http://search.cpan.org/~cleishman/Cache/">http://search.cpan.org/~cleishman/Cache/</a> Also caching instructions could be passed through the httpd
       transport layer in such a way that appropriate http cache headers are added to the results so that web
       caches (squid etc) could be used to implement the caching.  (MUST require the use of GET rather than POST
       requests.)

       Rework handling of installed_methods to not piggyback on dbh_attributes?

       Perhaps support transactions for transports where it's possible (ie null and stream)?  Would make stream
       transport (ie ssh) more useful to more people.

       Make sth_result_attr more like dbh_attributes (using '*' etc)

       Add @val = FETCH_many(@names) to DBI in C and use in Gofer/Execute?

       Implement _new_sth in C.

perl v5.40.0                                       2025-02-01                                    <u>DBD::<a href="../man3pm/Gofer.3pm.html">Gofer</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>