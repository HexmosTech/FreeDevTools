<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOAP::Transport - an abstract class extended by more specialized transport modules</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsoap-lite-perl">libsoap-lite-perl_1.27-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SOAP::Transport - an abstract class extended by more specialized transport modules

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Objects of the SOAP::Transport class manage two roles: they manage both the parameters related to
       transport as set through the containing SOAP::Lite object, and they abstract the selection and loading of
       an appropriate transport module. This is done with an AUTOLOAD function within the class that intercepts
       all methods beyond the two defined next and reroutes them to the underlying transport implementation
       code.

</pre><h4><b>METHODS</b></h4><pre>
       new
               $trans = SOAP::Transport-&gt;new;

           This  is  the  constructor, which isn't usually called by an application directly. An application can
           use  this  to  create  a  fresh  new  SOAP::Transport  object,  which  may  be  installed  using  the
           SOAP::Lite-&gt;transport method defined earlier. No arguments are recognized.

       proxy(optional URL string)
               $trans-&gt;proxy('<a href="http://www.blackperl.com/SOAP">http://www.blackperl.com/SOAP</a>');

           Gets  or  sets  the proxy (endpoint). This method must be called before any other methods are called.
           The proper transport code is loaded based on the scheme specified by the URL  itself  (http,  jabber,
           etc.).  Until  this method is called the first time with a URL string, the underlying code has yet to
           be loaded, and the methods aren't  available.  When  getting  the  current  proxy  (calling  with  no
           parameters),  the  returned value is a reference to the client object created from the protocol class
           that matched the endpoint, not the endpoint itself.

</pre><h4><b>SOAP</b> <b>Transport</b> <b>Sub-Classes</b></h4><pre>
       Because the bulk of the work is done within the "SOAP::Lite" module itself, many of  the  transport-level
       modules  are  very  simple in their implementations. Transport modules are expected to define both client
       and server classes within their files. If a module defines only one of the types, it is assumed that  the
       transport   protocol   itself   supports   only   that   side   of   the   conversation.  An  example  is
       SOAP::Transport::FTP, which provides only a "SOAP::Transport::FTP::Client" class.

       "SOAP::Transport::FTP" - Client class only

       "SOAP::Transport::HTTP" - Client, and server classes for CGI, FCGI, Daemon and mod_perl

       "SOAP::Transport::IO" - Server class only

       "SOAP::Transport::JABBER" - Server and Client classes

       "SOAP::Transport::LOCAL" - Client class only

       "SOAP::Transport::MAILTO" - Client class only

       "SOAP::Transport::MQ" - Server and Client classes

       "SOAP::Transport::POP3" - Server class only

       "SOAP::Transport::TCP" - Server and Client classes

   <b>METHODS</b>
       Each SOAP::Transport sub-class is expected to define (or inherit, if it is subclassing another  transport
       class)  at  least  two methods. Any newly developed transport classes are also expected to adhere to this
       interface. Clients are expected to implement the  "new"  and  "send_receive"  methods,  and  servers  are
       expected to implement the "new" and "handle" methods. Here they are:

       new(optional key/value pairs)
               $object = $class-&gt;new(%params);

           Creates  a  new  object  instance  and  returns  it.  Like the constructors for both "SOAP::Lite" and
           SOAP::Server classes, all arguments passed in are treated  as  key/value  pairs,  where  the  key  is
           expected  to  be  one  of  the  methods  the  class  supports, and the value is the argument (or list
           reference of arguments) to the method.

       send_receive(key/value pairs)
               $client-&gt;send_recieve(%hash_table);

           (Required for client classes only) When the SOAP::Lite objects attempt  to  send  out  requests,  the
           means  for  doing  so is to attempt to call this method on the object held within the SOAP::Transport
           object contained within the client itself. All clients are expected to provide this, and the call  to
           this method always passes four values for the hash keys:

           action
               The  URI specifying the action being performed, usually the result from the on_action hook on the
               client object.

           encoding
               The URI of the encoding scheme that governs the message being sent.

           endpoint
               The URI specifying the endpoint to which the message is being sent.

           envelope
               The XML content of the message to be sent. It is generally  the  return  value  of  the  envelope
               method from the SOAP::Serializer object instance that the client object maintains.

           parts
               Attachments to add to the request. Currently this only supports an array of MIME::Entity objects,
               but in theory could support attachments of any format.

       handle
               $server-&gt;handle;

           (Required  for  server classes only.) This method is the central point for the various server classes
           to provide an interface to handling requests. The exact set and nature of parameters generally varies
           based on the classes themselves.

   <b>SOAP::Transport::HTTP</b>
       The most commonly used transport module is the HTTP implementation. This is loaded whenever  an  endpoint
       is  given  that  starts  with  the characters, http:// or https:/<a href="file:/.">/.</a> This is also the most involved of the
       transport modules, defining not only a client class but several different server classes as well.

       <u>HTTP</u> <u>PROXY</u> <u>SETTINGS</u>

       Because "SOAP::Client" inherits from "LWP::UserAgent",  you  can  use  any  of  "LWP::UserAgent"'s  proxy
       settings. For example:

          SOAP::Lite-&gt;proxy("<a href="http://endpoint.server/">http://endpoint.server/</a>",
                            proxy =&gt; ["http" =&gt; "<a href="http://my.proxy.server">http://my.proxy.server</a>"]);

       or

          $soap-&gt;transport-&gt;proxy("http" =&gt; "<a href="http://my.proxy.server">http://my.proxy.server</a>");

       The  above  code  samples should specify a proxy server for you. And should you use "HTTP_proxy_user" and
       "HTTP_proxy_pass" for proxy authorization, "SOAP::Lite" will handle it properly.

       <u>HTTP</u> <u>BASIC</u> <u>AUTHENTICATION</u>

       HTTP  Basic  authentication  is  accomplished  by  overriding  the  get_basic_credentials  subroutine  in
       "LWP::UserAgent" (which "SOAP::Transport::HTTP::Client" is a subclass):

         BEGIN {
           sub SOAP::Transport::HTTP::Client::get_basic_credentials {
             return 'username' =&gt; 'password';
           }
         }

       <u>COOKIE-BASED</u> <u>AUTHENTICATION</u>

           use HTTP::Cookies;
           my $cookies = HTTP::Cookies-&gt;new(ignore_discard =&gt; 1);
           # you may also add 'file' if you want to keep them between sessions
           my $soap = SOAP::Lite-&gt;proxy('<a href="http://localhost/">http://localhost/</a>');
           $soap-&gt;transport-&gt;cookie_jar($cookies);

       Or, alternatively, you can do the above on a single line:

         $soap-&gt;proxy('<a href="http://localhost/">http://localhost/</a>',
                      cookie_jar =&gt; HTTP::Cookies-&gt;new(ignore_discard =&gt; 1));

       Cookies  will  be  taken  from  the  response  and provided to the request. You may access and manipulate
       cookies received, as well as add cookies of your own by using the "HTTP::Cookies" interfaces.

       <u>SSL</u> <u>CERTIFICATE</u> <u>AUTHENTICATION</u>

       The default SSL implementation  for  the  HTTP  client  library  LWP::UserAgent  used  by  SOAP::Lite  is
       IO::Socket::SSL.

       To  enable  certificate  based authentication, you'll have to pass your certificate and key as additional
       options to the <b>proxy()</b> method like this:

           $soap-&gt;proxy( $url, ssl_opts =&gt; {
               SSL_cert_file =&gt; 'client-cert.pem',
               SSL_key_file  =&gt; 'client-key.pem'
           });

       Or you can set them later like this:

           $soap-&gt;transport-&gt;ssl_opts(
               SSL_cert_file =&gt; 'client-cert.pem',
               SSL_key_file  =&gt; 'client-key.pem'
           );

       If you're using Crypt::SSLeay, the following applies:

       To get certificate authentication working you need to set three environment variables: "HTTPS_CERT_FILE",
       "HTTPS_KEY_FILE", and optionally "HTTPS_CERT_PASS". This can be done either through the command line,  or
       directly within your Perl script using the $ENV variable:

         $ENV{HTTPS_CERT_FILE} = 'client-cert.pem';
         $ENV{HTTPS_KEY_FILE}  = 'client-key.pem';

       These  settings  are  referenced  by  "Crypt::SSLeay".  Other  options (e.g. CA peer verification) can be
       specified in a similar way. See Crypt::SSLeay documentation for more information.

       Please note that you probably should not be using Crypt::SSLeay because  it  does  not  perform  hostname
       verification;      LWP::UserAgent      uses      IO::Socket::SSL      by      default.      See      also
       &lt;https://metacpan.org/pod/Crypt::SSLeay#DO-YOU-NEED-Crypt::SSLeay&gt;.

       Those who would like to use encrypted keys may find the following  thread  in  the  SOAP::Lite  newsgroup
       helpful:

       <a href="http://groups.yahoo.com/group/soaplite/message/729">http://groups.yahoo.com/group/soaplite/message/729</a>

       <u>COMPRESSION</u>

       SOAP::Lite  provides  you  with the option for enabling compression over the wire using HTTP <u>only</u> in both
       the server and client  contexts,  provided  that  you  have  Compress::Zlib  installed.  Compression  and
       decompression is done transparently to your application.

       A  server  will  respond  with  an encoded/compressed message only if the client has asserted that it can
       accept it (indicated by client sending an "Accept-Encoding" HTTP header with a 'deflate' or '*' value).

       "SOAP::Lite" clients all have fallback logic implemented so that  if  a  server  doesn't  understand  the
       specified  encoding  (i.e.  "Content-Encoding: deflate") and returns the proper HTTP status code (415 NOT
       ACCEPTABLE), the client will repeat the request without using encoding/compression. The client will  then
       store  this  server  in  a  per-session  cache,  so  that  all subsequent requests to that server will be
       transmitted without encoding.

       Compression is enabled on the client side by specifying the "compress_threshold" option, and if the  size
       of the current request exceeds that threshold.

       <b>Client</b> <b>Code</b> <b>Sample</b>

         print SOAP::Lite
           -&gt;uri('<a href="http://localhost/My/Parameters">http://localhost/My/Parameters</a>')
           -&gt;proxy('<a href="http://localhost/">http://localhost/</a>', options =&gt; {compress_threshold =&gt; 10000})
           -&gt;echo(1 x 10000)
           -&gt;result;

       Servers  will respond with a compressed message if the "compress_threshold" option has been specified, if
       the size of the current response exceeds that threshold, and if the calling client transmitted the proper
       "Accept-Encoding" HTTP Header.

       <b>Server</b> <b>Code</b> <b>Sample</b>

         my $server = SOAP::Transport::HTTP::CGI
           -&gt;dispatch_to('My::Parameters')
           -&gt;options({compress_threshold =&gt; 10000})
           -&gt;handle;

       See also: Compress::Zlib

       <u>SOAP::Transport::HTTP::Client</u>

       Inherits from: SOAP::Client, LWP::UserAgent (from the LWP package).

       With this class, clients are able to use HTTP for sending messages. This class provides  just  the  basic
       new  and  send_receive methods. Objects of this class understand the compress_threshold option and use it
       if the server being communicated to also understands it.

       CHANGING THE DEFAULT USERAGENT CLASS

       By default, "SOAP::Transport::HTTP::Client" extends "LWP::UserAgent".  But under  some  circumstances,  a
       user  may  wish  to  change  the  default  UserAgent  class  with their in order to better handle persist
       connections, or to "LWP::UserAgent::ProxyAny", for example,  which  has  better  Win32/Internet  Explorer
       interoperability.

       One can use the code below as an example of how to change the default UserAgent class.

         use SOAP::Lite;
         use SOAP::Transport::HTTP;
         $SOAP::Transport::HTTP::Client::USERAGENT_CLASS = "My::UserAgent";
         my $client = SOAP::Lite-&gt;proxy(..)-&gt;uri(..);
         my $som = $client-&gt;myMethod();

       There  is  one caveat, however. The UserAgent class you use, <u>MUST</u> also be a subclass of "LWP::UserAgent".
       If it is not, then "SOAP::Lite"  will  issue  the  following  error:  "Could  not  load  UserAgent  class
       &lt;USERAGENT CLASS&gt;."

       HTTP-KEEP-ALIVE, TIMEOUTS, AND MORE

       Because  "SOAP::Transport::HTTP::Client" extends "LWP::UserAgent", all methods available "LWP::UserAgent"
       are also available to your SOAP Clients. For  example,  using  "LWP::UserAgent"  HTTP  keep  alive's  are
       accomplished using the following code:

         my $ua = LWP::UserAgent-&gt;new(
               keep_alive =&gt; 1,
               timeout    =&gt; 30
         );

       Therefore,  the  same  initialization parameters you would pass to "LWP::UserAgent" can also be passed to
       your SOAP::Lite client's "proxy" subroutine like so:

           my $soap = SOAP::Lite
              -&gt;uri($uri)
              -&gt;proxy($proxyUrl,
                  timeout =&gt; 30,
                  keep_alive =&gt; 1,
                );

       This is true for all initialization parameters and methods of "LWP::UserAgent".

       METHODS

       http_request
           This method gives you access to a prototype of the HTTP Request object that will be transmitted to  a
           SOAP::Server. The actual request used is a copy of that object.

           Do not use this method for anything else than setting prototypic behaviour for the client object.

       http_response
           This  method  gives you access to the HTTP Response object that will be, or was transmitted to a SOAP
           Server. It returns a HTTP::Response object.

       <u>SOAP::Transport::HTTP::Server</u>

       Inherits from: SOAP::Server.

       This is the most basic of the HTTP server implementations. It provides the
        basic methods, new and handle. The handle method's behavior is defined here,
        along with other methods specific to this class. The role of this class is
        primarily to act as a superclass for the other HTTP-based server classes.

       handle
               $server-&gt;handle;

           Expects the request method to have been used to associate a  HTTP::Request  object  with  the  server
           object prior to being called. This method retrieves that object reference to get at the request being
           handled.

       request(<u>optional</u> <u>value</u>)
               $server-&gt;request($req_object)

           Gets  or  sets  the  HTTP::Request  object  reference  that the server will process within the handle
           method.

       response(<u>optional</u> <u>value</u>)
               $server-&gt;response(HTTP::Response-&gt;new(...));

           Gets or sets the HTTP::Response object reference that the server has prepared for sending back to the
           client.

       make_response(<u>code</u>, <u>body</u>)
               $server-&gt;make_response(200, $body_xml);

           Constructs and returns an object of the HTTP::Response class, using the  response  code  and  content
           provided.

       make_fault(<u>fault</u> <u>arguments</u>)
               $server-&gt;response($server-&gt;make_fault(@data));

           Creates  a  HTTP::Response  object  reference using a predefined HTTP response code to signify that a
           fault has occurred. The arguments are the same as those for the make_fault method of the SOAP::Server
           class.

       product_tokens
           This method takes no arguments and simply returns a string identifying the  elements  of  the  server
           class itself. It is similar to the product_tokens methods in the HTTP::Daemon and Apache classes.

       <u>SOAP::Transport::HTTP::CGI</u>

       Inherits from: SOAP::Transport::HTTP::Server.

       This  class  is  a direct subclass of SOAP::Transport::HTTP::Server and defines no additional methods. It
       includes logic in its implementation of the handle  method  that  deals  with  the  request  headers  and
       parameters specific to a CGI environment.

       EXAMPLE CGI

       The following code sample is a CGI based Web Service that converts celsius to fahrenheit:

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>
           use SOAP::Transport::HTTP;
           SOAP::Transport::HTTP::CGI
             -&gt;dispatch_to('C2FService')
             -&gt;handle;
           BEGIN {
             package C2FService;
             use vars qw(@ISA);
             @ISA = qw(Exporter SOAP::Server::Parameters);
             use SOAP::Lite;
             sub c2f {
               my $self = shift;
               my $envelope = pop;
               my $temp = $envelope-&gt;dataof("//c2f/temperature");
               return SOAP::Data-&gt;name('convertedTemp' =&gt; (((9/5)*($temp-&gt;value)) + 32));
             }
           }

       EXAMPLE APACHE::REGISTRY USAGE

       Using  a strictly CGI based Web Service has certain performance drawbacks. Running the same CGI under the
       Apache::Registery system has certain performance gains.

       <b>httpd.conf</b>

         Alias /mod_perl/ "/Your/Path/To/Deployed/Modules"
         &lt;Location /mod_perl&gt;
           SetHandler perl-script
           PerlHandler Apache::Registry
           PerlSendHeader On
           Options +ExecCGI
         &lt;/Location&gt;

       <b>soap.cgi</b>

         use SOAP::Transport::HTTP;

         SOAP::Transport::HTTP::CGI
           -&gt;dispatch_to('/Your/Path/To/Deployed/Modules', 'Module::Name', 'Module::method')
           -&gt;handle;

       <u>WARNING:</u> <u>Dynamic</u> <u>deployments</u> <u>with</u> <u>"Apache::Registry"</u> <u>will</u> <u>fail</u> <u>because</u> <u>the</u> <u>module</u>  <u>will</u>  <u>be</u>  <u>only</u>  <u>loaded</u>
       <u>dynamically</u>  <u>the</u> <u>first</u> <u>time.</u> <u>Subsequent</u> <u>calls</u> <u>will</u> <u>produce</u> <u>"denied</u> <u>access"</u> <u>errors</u> <u>because</u> <u>once</u> <u>the</u> <u>module</u>
       <u>is</u> <u>already</u> <u>in</u> <u>memory</u> <u>"SOAP::Lite"</u> <u>will</u> <u>bypass</u> <u>dynamic</u> <u>deployment.</u> <u>To</u> <u>work</u>  <u>around</u>  <u>this,</u>  <u>simply</u>  <u>specify</u>
       <u>both</u> <u>the</u> <u>full</u> <u>PATH</u> <u>and</u> <u>MODULE</u> <u>name</u> <u>in</u> <u>"dispatch_to()"</u> <u>and</u> <u>the</u> <u>module</u> <u>will</u> <u>be</u> <u>loaded</u> <u>dynamically,</u> <u>but</u> <u>will</u>
       <u>then</u> <u>work</u> <u>as</u> <u>if</u> <u>under</u> <u>static</u> <u>deployment.</u> <u>See</u> <u>examples/server/soap.mod_cgi</u> <u>as</u> <u>an</u> <u>example.</u>

       <u>SOAP::Transport::HTTP::Daemon</u>

       Inherits from: SOAP::Transport::HTTP::Server.

       The  SOAP::Transport::HTTP::Daemon  class encapsulates a reference to an object of the HTTP::Daemon class
       (from the LWP package). The class catches methods that aren't provided locally or by the  superclass  and
       attempts to call them on the HTTP::Daemon object. Thus, all methods defined in the documentation for that
       class    are    available    to   this   class   as   well.   Any   that   conflict   with   methods   in
       SOAP::Transport::HTTP::Server (such as product_tokens) go to the superclass. Additionally,  the  behavior
       of the handle method is specific to this class:

       handle
           When  invoked, this method enters into the typical accept loop in which it waits for a request on the
           socket that the daemon object maintains and deals with the content of the request. When all  requests
           from  the  connection  returned  by the accept method of the HTTP::Daemon object have been processed,
           this method returns.

       REUSING SOCKETS ON RESTART

       Often when implementing an HTTP daemon, sockets will get tied up when  you  try  to  restart  the  daemon
       server.  This  prevents  the  server  from  restarting.  Often users will see an error like "Cannot start
       server: port already in use." To circumvent this, instruct SOAP::Lite to reuse open sockets using  "Reuse
       =&gt; 1":

         my $daemon = SOAP::Transport::HTTP::Daemon
                         -&gt; new (LocalPort =&gt; 80000, Reuse =&gt; 1)

       EXAMPLE DAEMON SERVER

         use SOAP::Transport::HTTP;
         # change LocalPort to 81 if you want to test it with soapmark.pl
         my $daemon = SOAP::Transport::HTTP::Daemon
           -&gt; new (LocalAddr =&gt; 'localhost', LocalPort =&gt; 80)
           # specify list of objects-by-reference here
           -&gt; objects_by_reference(qw(My::PersistentIterator My::SessionIterator My::Chat))
           # specify path to My/Examples.pm here
           -&gt; dispatch_to('/Your/Path/To/Deployed/Modules', 'Module::Name', 'Module::method')
         ;
         print "Contact to SOAP server at ", $daemon-&gt;url, "\n";
         $daemon-&gt;handle;

       <u>SOAP::Transport::HTTP::Apache</u>

       Inherits from: SOAP::Transport::HTTP::Server.

       This class provides an integration of the SOAP::Server base class with the mod_perl extension for Apache.
       To  work as a location handler, the package provides a method called handler, for which handle is made an
       alias. The new method isn't functionally different from  the  superclass.  Here  are  the  other  methods
       provided by this class:

       handler(<u>Apache</u> <u>request</u>)
               $server-&gt;handler($r)

           Defines  the  basis  for  a  location  handler  in the mod_perl fashion. The method expects an Apache
           request object as the parameter, from which it pulls the body of the request and calls the superclass
           handle method.

           Note that in this class, the local method named handle is aliased to this method.

       configure(<u>Apache</u> <u>request</u>)
               $server-&gt;configure(Apache-&gt;request);

           Per-location configuration information can  be  provided  to  the  server  object  using  the  Apache
           DirConfig  directive and calling this method on the object itself. When invoked, the method reads the
           directory configuration information from Apache and looks for lines of the form:

               method =&gt; param

           Each line that matches the pattern is regarded as a potential method to call on  the  server  object,
           with  the  remaining token taken as the parameter to the method. Methods that take hash references as
           arguments may be specified as:

               method =&gt; key =&gt; param, key =&gt; param

           The key/value pairs will be made into a hash reference  on  demand.  If  the  server  object  doesn't
           recognize the named method as valid, it ignores the line.

       EXAMPLE APACHE MOD_PERL SERVER

       See <u>examples/server/Apache.pm</u> and Apache::SOAP for more information.

       <b>httpd.conf</b>

         &lt;Location /soap&gt;
           SetHandler perl-script
           PerlHandler SOAP::Apache
           PerlSetVar options "compress_threshold =&gt; 10000"
         &lt;/Location&gt;

       <b>SOAP::Apache.pm</b>

         package SOAP::Apache;
         use SOAP::Transport::HTTP;
         my $server = SOAP::Transport::HTTP::Apache
           -&gt;dispatch_to('/Your/Path/To/Deployed/Modules', 'Module::Name', 'Module::method');
         sub handler { $server-&gt;handler(@_) }
         1;

       See also Apache::SOAP.

       <u>SOAP::Transport::HTTP::FCGI</u>

       Inherits from: SOAP::Transport::HTTP::CGI.

       This  is  an  extension  of the SOAP::Transport::HTTP::CGI that implements the differences needed for the
       FastCGI protocol. None of the methods are functionally different.

   <b>SOAP::Transport::IO</b>
       The SOAP::Transport::IO-based class allows for a sort of I/O proxying  by  allowing  the  application  to
       configure what files or filehandles are used. This module supplies only a server class.

       <u>SOAP::Transport::IO::Server</u>

       Inherits from: SOAP::Server.

       The  server  class  defined  here inherits all methods from SOAP::Server, and adds two additional methods
       specific to the nature of the class:

       in
               $server-&gt;in(IO::File-&gt;new($file));

           Gets or sets the current filehandle being used as the input source.

       out
               $server-&gt;out(\*STDERR);

           Gets or sets the filehandle being used as the output destination.

   <b>SOAP::Transport::LOCAL</b>
       The SOAP::Transport::LOCAL module is designed to provide a no-transport  client  class  for  tracing  and
       debugging  communications  traffic.  It  links SOAP::Client and SOAP::Server so that the same object that
       "sends" the request also "receives" it.

       <u>SOAP::Transport::LOCAL::Client</u>

       Inherits from: SOAP::Client, SOAP::Server.  The implementations  of  the  new  and  send_receive  methods
       aren't noticeably different in their interface. Their behavior warrants description, however:

       new When  the  constructor  creates  a new object of this class, it sets up a few things beyond the usual
           SOAP::Client layout. The is_success method is set to a default value of  1.  The  dispatch_to  method
           inherited  from  SOAP::Server is called with the current value of the global array @INC, allowing the
           client to call any methods that can be found in the  current valid search path. And as with  most  of
           the  constructors  in  this  module,  the  optional  key/value  pairs are treated as method names and
           parameters.

       send_receive
           The implementation of this method simply passes the envelope portion of the input data to the  handle
           method  of  SOAP::Server.  While no network traffic results (directly) from this, it allows for debug
           signals to be sent through the SOAP::Trace facility.

   <b>SOAP::Transport::MAILTO</b>
       This transport class manages SMTP-based sending of messages from a client perspective. It doesn't provide
       a server class. The class gets selected when a client object passes a  URI  to  proxy  or  endpoint  that
       starts with the characters, mailto:.

       <u>SOAP::Transport::MAILTO::Client</u>

       Inherits from: SOAP::Client.

       The  client class for this protocol doesn't define any new methods. The constructor functions in the same
       style as the others class  constructors.  The  functionality  of  the  send_receive  method  is  slightly
       different from other classes, however.

       When  invoked,  the  send_receive  method  uses  the  MIME::Lite  package to encapsulate and transmit the
       message. Because mail messages are one-way communications (the reply being a separate process), there  is
       no  response  message  to  be  returned  by the method. Instead, all the status-related attributes (code,
       message, status, is_success) are set, and no value is explicitly returned.

   <b>SOAP::Transport::POP3</b>
       POP3 support is limited to a server implementation. Just as the MAILTO class detailed earlier operates by
       sending requests without expecting to process a response,  the  server  described  here  accepts  request
       messages and dispatches them without regard for sending a response other than that which POP3 defines for
       successful delivery of a message.

       <u>SOAP::Transport::POP3::Server</u>

       Inherits from: SOAP::Server.

       The  new  method  of  this class creates an object of the Net::POP3 class to use internally for polling a
       specified POP3 server for incoming messages. When an object of this  class  is  created,  it  expects  an
       endpoint  to  be  specified  with  a  URI that begins with the characters pop:// and includes user ID and
       password information as well as the hostname itself.

       The handle method takes the messages present in the remote mailbox and passes them (one at a time) to the
       superclass handle method. Each message is deleted after being routed. All messages in  the  POP3  mailbox
       are presumed to be SOAP messages.

       Methods  for  the  Net::POP3  object  are  detected  and  properly  routed,  allowing  operations such as
       $server-&gt;ping( ).

       This means that the endpoint string doesn't need to provide the user ID and password  because  the  login
       method from the POP3 API may be used directly.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Special  thanks  to  O'Reilly  publishing  which  has  graciously  allowed  SOAP::Lite  to  republish and
       redistribute large excerpts from <u>Programming</u> <u>Web</u> <u>Services</u> <u>with</u>  <u>Perl</u>,  mainly  the  SOAP::Lite  reference
       found in Appendix B.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2000-2004 Paul Kulchenko. All rights reserved.

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>AUTHORS</b></h4><pre>
       Paul Kulchenko (<a href="mailto:paulclinger@yahoo.com">paulclinger@yahoo.com</a>)

       Randy J. Ray (<a href="mailto:rjray@blackperl.com">rjray@blackperl.com</a>)

       Byrne Reese (<a href="mailto:byrne@majordojo.com">byrne@majordojo.com</a>)

perl v5.36.0                                       2023-03-01                               <u>SOAP::<a href="../man3pm/Transport.3pm.html">Transport</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>