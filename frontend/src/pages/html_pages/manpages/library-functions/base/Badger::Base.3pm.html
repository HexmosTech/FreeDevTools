<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badger::Base - base class module</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbadger-perl">libbadger-perl_0.16-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Badger::Base - base class module

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # define a new object class derived from Badger::Base
           package Your::Badger::Module;
           use base 'Badger::Base';

           sub init {
               my ($self, $config) = @_;

               # $config is a hash of named parameters
               # - let's assume 'name' is mandatory
               $self-&gt;{ name } = $config-&gt;{ name }
                   || return $self-&gt;error('no name specified');

               # save the rest of the config for later
               $self-&gt;{ config } = $config;

               # return $self to indicate success
               return $self;
           }

           # ...any other methods follow....

           # now use it
           use Your::Badger::Module
           my $object = Your::Badger::Module-&gt;new( name =&gt; 'Brian' );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module implements a base class object from which most of the other "Badger" modules are derived. It
       implements a number of methods to aid in object creation, configuration, error handling and debugging.

       You can use it as a base class for your own modules to inherit the methods that it provides.

           package Your::Badger::Module;
           use base 'Badger::Base';

       You can inherit the default <b>new()</b> constructor method and define your own <b>init()</b> method to initialise
       objects.

           sub init {
               my ($self, $config)

               # $config is a hash of named parameters
               # - let's assume 'name' is mandatory
               $self-&gt;{ name } = $config-&gt;{ name }
                   || return $self-&gt;error('no name specified');

               # save the rest of the config in case any other
               # methods want to use it later
               $self-&gt;{ config } = $config;

               # return $self to indicate success
               return $self;
           }

       You can then use your module and instantiate objects. The <b>new()</b> method accepts a list or reference to a
       hash array of named parameters.

           use Your::Badger::Module;

           # list of named parameters
           my $object = Your::Badger::Module-&gt;new( name =&gt; 'Brian' );

           # hash ref of name parameters
           my $object = Your::Badger::Module-&gt;new({ name =&gt; 'Brian' });

       "Badger::Base" provides a number of other methods that are generally suitable for all (or most) objects
       to inherit.  These include methods for error reporting, debugging and raising warnings.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new(\%config)</b>
       This is a general purpose constructor method. It accepts either a reference to a hash array of named
       parameters or a list of named parameters which are then folded into a hash reference.

           # hash reference of named params
           my $object = Your::Badger::Module-&gt;new({
               arg1 =&gt; 'value1',
               arg2 =&gt; 'value2',
               ...etc...
           });

           # list of named params
           my $object = Your::Badger::Module-&gt;new(
               arg1 =&gt; 'value1',
               arg2 =&gt; 'value2',
               ...etc...
           );

       The constructor creates a new object by blessing a hash reference and then calling the "init()" method. A
       reference to the hash array of named parameters is passed as a single argument. In most cases you should
       be able to re-use the existing <b>new()</b> method and define your own <b>init()</b> method to initialise the object.

       The "new()" method returns whatever the <b>init()</b> method returns. This will normally be the $self object
       reference, but your own <b>init()</b> methods are free to return whatever they like. However, it must be a true
       value of some kind or the <b>new()</b> method will throw an error indicating that the <b>init()</b> method failed.

   <b>init(\%config)</b>
       This initialisation method is called by the "new()" constructor method.  This is the method that you'll
       normally want to redefine when you create a subclass of "Badger::Base".

       The "init()" method is passed a reference to a hash array of named configuration parameters. The method
       may perform any configuration or initialisation processes and should generally return the $self reference
       to indicate success.

           sub init {
               my ($self, $config) = @_;

               # set the 'answer' parameter or default to 42
               $self-&gt;{ answer } = $config-&gt;{ answer } || 42;

               return $self;
           }

       The "init()" method can return any true value which will then be sent back as the return value from
       <b>new()</b>. In most cases you'll want to return the $self object reference, but the possibility exists of
       returning other values instead (e.g. to implement singletons, prototypes, or some other clever object
       trickery).

       If something goes wrong in the "init()" method then you should call the <b>error()</b> method (or <b>error_msg()</b>)
       to throw an error.

           sub init {
               my ($self, $config) = @_;

               # set the 'answer' parameter or report error
               $self-&gt;{ answer } = $config-&gt;{ answer }
                   || return $self-&gt;error('no answer supplied');

               return $self;
           }

       The only function of the default <b>init()</b> method in "Badger::Base" is to save a reference to the $config
       hash array in "$self-&gt;{ config }". If you use the default <b>init()</b> method, or add an equivalent line to
       your own <b>init()</b> method, then you can defer inspection of the configuration parameters until later. For
       example, you might have a method which does something like this:

           our $DATE_FORMAT = '%Y-%d-%b';

           sub date_format {
               my $self = shift;
               return @_
                   ? ($self-&gt;{ date_format } = shift)      # set from argument
                   :  $self-&gt;{ date_format }               # get from self...
                  ||= $self-&gt;{ config }-&gt;{ date_format }   #  ...or config...
                  ||  $DATE_FORMAT;                        #  ...or pkg var
           }

       This allows you to use "$self-&gt;{date_format}" as a working copy of the value while keeping the original
       configuration value (if any) intact in "$self-&gt;{config}-&gt;{date_format}". The above method will set the
       value if you pass an argument and return the current value if you don't. If no current value is defined
       then it defaults to the value in the config hash or the $DATE_FORMAT package variable. Now any other
       methods that require access to a date format need only call to the "date_format()" method to have it Do
       The Right Thing.

       The benefit here is that you don't have to waste time (and memory) in the <b>init()</b> method copying the
       "date_format" parameter from $config into $self. That doesn't mean that it's always the right thing to
       do, but it can be useful for configuration options that are infrequently used.

       The <b>on_error()</b> and <b>on_warn()</b> methods follow this protocol. They look for an "ON_ERROR" or "ON_WARN" item
       in $self or an "on_error" or "on_warn" parameter in "$self-&gt;{config}". If you want to define "on_error"
       and/or "on_warn" handlers as configuration parameters then you'll need to either copy the $config
       reference into "$self-&gt;{config}" or copy the individual items into "$self-&gt;{ON_ERROR}" and/or
       "$self-&gt;{ON_WARN}", respectively.

           # either copy the config...
           sub init {
               my ($self, $config) = @_;
               $self-&gt;{ config } = $config;
               # ...more code...
               return $self;
           }

           # ...or the individual items
           sub init {
               my ($self, $config) = @_;

               # no need to check if either of these are defined because the
               # on_warn() and on_error() methods will Do The Right Thing.
               $self-&gt;{ ON_WARN  } = $config-&gt;{ on_warn  };
               $self-&gt;{ ON_ERROR } = $config-&gt;{ on_error };

               # ...more code...
               return $self;
           }

       With either of the above in place, you can then define "on_warn" and "on_error" handlers and expect them
       to work when the <b>error()</b> and <b>warn()</b> methods are called.

           my $object = Your::Badger::Module-&gt;new(
               on_warn  =&gt; \&amp;my_warn,
               on_error =&gt; \&amp;my_error,
           );

           $object-&gt;warn("Rebel Alliance engaging");    # calls my_warn()
           $object-&gt;error("Exhaust port unshielded!");  # calls my_error()

   <b>warn($message)</b>
       A method to raise a warning.  The default behaviour is to forward all arguments to Perl's "warn"
       function.  However, you can install your own warning handlers on a per-class or per-object basis using
       the <b>on_warn()</b> method or by setting a $ON_WARN package variable in your module.  See <b>on_warn()</b> for further
       details.

           $object-&gt;warn("Careful with that axe, Eugene!");

   <b>on_warn($handler,</b> <b>$another_handler,</b> <b>...)</b>
       This method allows you to install one or more callback handlers which are called whenever a warning is
       raised via the <b>warn()</b> method. Multiple handlers can be installed and will be called in turn whenever an
       error occurs.  The warning message is passed as an argument to the handlers.

       For example, if you wanted to forward warning messages to your favourite logging tool, you might do
       something like this:

           my $log = My::Fave::Log::Tool-&gt;new(%log_config);

           $object-&gt;on_warn(
               sub {
                   my $message = shift;
                   $log-&gt;warning("$message);
                   return $message;
               }
           );

       The value returned from the callback is forwarded to the next handler (if there is one). If a callback
       returns a false value or an empty list then the remaining handlers will not be called.

       The default behaviour of the "on_warn()" method is to replace any existing warning handlers with the new
       one(s) specified.  You can prefix the handler(s) with 'before' or 'after' to add them to the existing
       list of handlers. e.g.

           $object-&gt;on_warn( before =&gt; \&amp;one, \&amp;two );
           $object-&gt;on_warn( after  =&gt; \&amp;one, \&amp;two );

       The <b>on_warn()</b> method returns a reference to the list, so you can also monkey about with it directly if
       you want the handler(s) to go somewhere else.

           my $handlers = $object-&gt;on_warn;
           shift(@$handlers, \&amp;one);       # add before existing handlers
           push(@$handlers, \&amp;two);        # add after existing handlers

       You can also specify a method name as a warning handler. For example, if you want to automatically
       upgrade all warnings to errors for a particular object, you can write this:

           $object-&gt;on_warn('error');      # calls $object-&gt;error() on warnings

       You can also specify 'warn' as a handler which will call Perl's "warn()" function.  This is the default
       value.  To explicitly disable any handlers, you can use a value of 0.

           $object-&gt;on_warn('warn');       # raise warning - the default action
           $object-&gt;<a href="../man0/on_warn.0.html">on_warn</a>(0);            # no warnings

       These values can be imported from Badger::Constants as the "WARN" and "NONE" constants.

           use Badger::Constants 'WARN NONE';
           $object-&gt;on_warn(WARN);         # raise warning - the default action
           $object-&gt;on_warn(NONE);         # no warnings

       The <b>on_warn()</b> method works equally well as a class method. In this case it sets the $ON_WARN package
       variable for the class. This acts as the default handler list for any objects of that class that don't
       explicitly define their own warning handlers.

           Your::Badger::Module-&gt;on_warn(\&amp;handler_sub);

       If you prefer you can define this using the $ON_WARN package variable.  This will then be used as the
       default for all objects of this class.

           package Your::Badger::Module;
           use base 'Badger::Base';
           our $ON_WARN = \&amp;handler_sub;

       Multiple values should be defined using a list reference.  Method names and the special "warn" flag can
       also be included.

           our $ON_WARN = [ \&amp;this_code_first, 'this_method_next', 'warn' ]

   <b>error($message)</b>
       The "error()" method is used for error reporting.  When an object method fails for some reason, it calls
       the "error()" method passing an argument denoting the problem that occurred.  This causes an exception
       object to be created (see Badger::Exception) and thrown via "throw()".  In this case the "error()" method
       will never return.

           sub engage {
               my $self = shift;
               return $self-&gt;error('warp drive offline');
           }

       Multiple arguments can be passed to the "error()" method.  They are concatenated into a single string.

           sub engage {
               my $self = shift;
               return $self-&gt;error(
                   'warp drive ',
                    $self-&gt;{ engine_no },
                   ' is offline'
               );
           }

       The error method can also be called without arguments to return the error message previously thrown by a
       call to "error()". In this case it performs exactly the same function as the <b>reason()</b> method.

           eval { $enterprise-&gt;engage }
               || warn "Could not engage: ", $enterprise-&gt;error;

       The fact that the "error()" method can be called without arguments allows you to write things like this:

           # doesn't throw anything if list is empty
           $self-&gt;error(@list_of_errors);

       An existing exception object can also be passed as a single argument to the error method. In this case,
       the exception object is re-thrown unmodified.

           sub save_the_world {
               eval { $self-&gt;world_peace };

               if ($@) {
                   $self-&gt;call_international_rescue($@);   # call Thunderbirds
                   return $self-&gt;error($@);                # re-throw error
               };
           }

       ASIDE: You may have noticed in these examples that I'm using the "return" keyword when raising an error.
       For example:

           return $self-&gt;error('warp drive offline');

       The "error()" method doesn't return when you call it with arguments so the "return" keyword has no effect
       whatsoever. However, I like to put it there to give a clear indication of what my intentions are at that
       point. It also means that the code will continue to return even if a subclass should "accidentally"
       define a different <b>error()</b> method that doesn't throw an error (don't laugh - it happens). It's also
       useful when used in conjunction with syntax highlighting to see at a glance where the potential exit
       points from a method are (assuming you make "return" bright red or something obvious like I do).

       The "error()" method can also be called as a class method. In this case, it updates and retrieves the
       $ERROR package variable in the package of the subclass module. This can be used to raise and examine
       errors thrown by class methods.

           # calling package error() method
           my $object = eval { Your::Badger::Module-&gt;new() }
               || warn "Could not create badger module: ",
                       Your::Badger::Module-&gt;error();

           # accessing $ERROR package variable
           my $object = eval { Your::Badger::Module-&gt;new() }
               || warn 'Could not create badger module: ",
                       $Your::Badger::Module::ERROR;

   <b>on_error($handler,</b> <b>$another_handler,</b> <b>...)</b>
       This method is similar to <b>on_warn()</b> in allowing you to install a callback handler which is called
       whenever an error is raised via the <b>error()</b> method (or the <b>error_msg()</b> wrapper).

           $world-&gt;on_error(
               sub {
                   my $message = shift;

                   Thunderbirds-&gt;call({
                       priority =&gt; IR_PRIORITY_HIGH,
                       message  =&gt; $message,
                   });

                   return $message;    # forward message to next handler
               }
           );

       The value returned from the callback is forwarded to the next handler.  If a callback returns a false
       value or an empty list then the remaining handlers will not be called.  However, the error will still be
       raised regardless of what any of the handlers do or return.

   <b>decline($reason,</b> <b>$more_reasons,</b> <b>...)</b>
       The "decline()" method is used to indicate that a method failed but without raising an error. It is
       typically used for methods that are asked to fetch a resource (e.g. a record in a database, file in a
       filesystem, etc.) that may not exist. In the case where it <u>isn't</u> considered an error if the requested
       resource is missing then the method can call the <b>decline()</b> method. It works like <b>error()</b> in that it
       stores the message internally for later inspection via <b>reason()</b>. But instead of throwing the message as
       an exception, it simply returns "undef"

           sub forage {
               my ($self, $name) = @_;

               # hard error if database isn't connected
               my $db = $self-&gt;{ database }
                   || return $self-&gt;error('no database')

               if ($thing = $db-&gt;fetch_thing($name)) {
                   # return true value on success
                   return $thing;
               }
               else {
                   # soft decline if not found
                   return $self-&gt;decline("not found: $name")
               }
           }

       Like <b>error()</b>, the <b>decline()</b> method can be called without arguments to return the most recent decline
       message, although it's probably better to use <b>reason()</b> which is designed specifically for that purpose.
       The <b>decline()</b> method can also be called as a class method as well as an object method, as per <b>error()</b>.

   <b>declined()</b>
       Returns the values of the internal flag which indicates if an object declined by calling the <b>decline()</b>
       method.  This is set to 1 whenever the <b>decline()</b> method is called and cleared back to 0 whenever the
       <b>error()</b> method is called.

           my $result = eval { $forager-&gt;fetch('nuts') };

           if ($result) {
               print "result: $result\n";
           }
           elsif ($forager-&gt;declined) {
               print "declined: ", $forager-&gt;reason, "\n";
           }
           else {
               print "error: ", $forager-&gt;reason, "\n";
           }

   <b>reason()</b>
       Returns the message generated by the most recent call to <b>error()</b> or <b>decline()</b> (or any of the wrapper
       methods like <b>error_msg()</b> and <b>decline_msg()</b>).

           $forager-&gt;forage('nuts and berries')
               || die $forager-&gt;reason;

   <b>message($type,</b> <b>@args)</b>
       This method generates a message using a pre-defined format. Message formats should be defined in a
       $MESSAGES package variable in the object's package or one of its base classes.

           # base class
           package Badger::Example::One
           use base 'Badger::Base';

           our $MESSAGES = {
               hai =&gt; 'Hello %s',
           };

           # subclass
           package Badger::Example::Two;
           use base 'Badger::Example::One';

           our $MESSAGES = {
               bye =&gt; 'Goodbye %s',
           };

           # using the classes
           package main;

           my $two = Badger::Example::Two-&gt;new();
           $two-&gt;message( hai =&gt; 'World' );    # Hello World
           $two-&gt;message( bye =&gt; 'World' );    # Goodbye World

       The $two object can use message formats defined in its own package ("Badger::Example::Two") and also
       those of its base class ("Badger::Example::One").

       The messages are formatted using the <b>xprintf()</b> function in Badger::Utils. This is a thin wrapper around
       the built-in "sprintf()" function with some additional formatting controls to simplify the process of
       using positional arguments.

       Messages are used internally by the <b>error_msg()</b> and <b>decline_msg()</b> methods for generating error messages,
       but you can use them for any kind of simple message generation.

       There are a number of benefits to defining messages in a central repository like this.

       First, it makes it easy to reuse the same message format in different places.  Also known as the "DRY"
       principle - <u>Don't</u> <u>Repeat</u> <u>Yourself</u>.

       Second, it allows you to put all your messages in one place instead of dotting them all over your code.
       The benefit here is a clearer <u>separation</u> <u>of</u> <u>concerns</u> between the underlying logic of your application and
       the presentational aspects.

       The third benefit comes as a result of this clear separation - it becomes trivially easy to change the
       messages generated by your application because they're all defined in one place (possibly in several
       different modules if that's how you choose to break it down, but at least they're in <u>one</u> place in each of
       those modules). Possible applications of this include: localising an application to different spoken
       languages; generating messages in colour (as the Badger::Debug and Badger::Test modules do); or
       formatting messages as HTML.

   <b>warn_msg($message,</b> <b>@args)</b>
       This is a wrapper around the <b>warn()</b> and <b>message()</b> methods.  The first argument defines a message format.
       The remaining arguments are then applied to that format via the <b>message()</b> method.  The resulting output
       is then forwarded to the <b>warn()</b> method.

           our $NAME     = 'Badger';
           our $MESSAGES = {
               using_default =&gt; "Using default value for %s: %s",
           };

           sub init {
               my ($self, $config) = @_;

               if ($config-&gt;{ name }) {
                   $self-&gt;{ name } = $config-&gt;{ name };
               }
               else {
                   $self-&gt;warn_msg( using_default =&gt; name =&gt; $NAME );
                   $self-&gt;{ name } = $NAME;
               }

               return $self;
           }

       If a "name" isn't provided as a configuration parameter then the default $NAME will be used and the
       following warning will be generated:

           Using default value for name: Badger

   <b>error_msg($message,</b> <b>@args)</b>
       This is a wrapper around the <b>error()</b> and <b>message()</b> methods, similar to <b>warn_msg()</b>.

           package Your::Zoo;
           use base 'Badger::Base';

           our $MESSAGES = {
               not_found =&gt; "I can't find the %s you asked for: %s",
           }

           sub animal {
               my ($self, $name) = @_;

               return $self-&gt;fetch_an_animal($name)
                   || $self-&gt;error_msg( missing =&gt; animal =&gt; $name );
           }

       Calling the "animal()" method on this object with an animal that can't be found, like this:

           $zoo-&gt;animal('Badgerpotamus');

       Will generate an error message like this:

           your.zoo error - I can't find the animal you asked for: Badgerpotamus

   <b>decline_msg($message,</b> <b>@args)</b>
       This is a wrapper around the <b>decline()</b> and <b>message()</b> methods, similar to <b>warn_msg()</b> and <b>error_msg()</b>.

           our $MESSAGES = {
               not_found =&gt; 'No %s found in the forest',
           };

           sub forage {
               my ($self, $name) = @_;

               return $self-&gt;database-&gt;fetch_item($name)
                   || $self-&gt;decline_msg( not_found =&gt; $name );
           }

       The <b>reason()</b> method can be used to return the message generated.

           my $food = $forager-&gt;forage('nuts')
               || warn $forager-&gt;reason;       # No nuts found in the forest

   <b>fatal_msg($message,</b> <b>@args)</b>
       This is a wrapper around the <b>fatal()</b> and <b>message()</b> methods, similar to <b>error_msg()</b> and co.

   <b>throw($type,</b> <b>$info,</b> <b>%more_info)</b>
       This method throws an exception by calling "die()".  It can be called with one argument, which can either
       be a Badger::Exception object (or subclass), or an error message which is upgraded to an exception object
       (which makes it behave exactly the same as <b>error()</b>).

           # error message - same thing as error()
           $object-&gt;throw('an error has occurred');

           # exception object
           $e = Badger::Exception-&gt;new(
               type =&gt; 'engine',
               info =&gt; 'warp drive offline'
           );
           $object-&gt;throw($e);

       In the first case, the <b>exception()</b> and <b>throws()</b> methods will be called to determine the exception class
       (Badger::Exception by default) and type for the exception, respectively.

       The method can also be called with two arguments. The first defines the exception "type", the second the
       error message.

           $object-&gt;throw( engine =&gt; 'warp drive offline' );

       The second argument can also be another exception object.  If the exception has the same type as the
       first argument then it is re-thrown unchanged.

           $e = Badger::Exception-&gt;new(
               type =&gt; 'engine',
               info =&gt; 'warp drive offline'
           );
           $object-&gt;throw( engine =&gt; $e ) };

       In the example above, the $e exception already has a type of "engine" and so is thrown without change.
       If the exception types don't match, or if the exception isn't the right kind of exception object that
       we're expecting (as reported by <b>exception()</b>) then a new exception is thrown with the old one attached via
       the "info" field.

            $object-&gt;throw( propulsion =&gt; $e );

       Here a new "propulsion" exception is thrown, with the previous "engine" exception linked in via the
       "info" field. The exception object has <b>type()</b> and <b>info()</b> methods that allow you to inspect its value,
       iteratively if necessary. Or you can just print an exception and rely on its overloaded stringification
       operator to call the <b>text()</b> method. For the error thrown in the previous example, that would be:

           propulsion error - engine error - warp drive offline

   <b>throw_msg($type,</b> <b>$message,</b> <b>@args)</b>
       This is a wrapper around the <b>throw()</b> and <b>message()</b> methods for throwing custom exceptions using message
       formats to generate the error information string. The first argument defines the exception type. The
       second is the name of the message format. The remaining arguments are uses to populate the placeholders
       in the message format.

           our $MESSAGES = {
               offline =&gt; '%s is offline',
           };

           sub engage {
               my $self = shift;
               $self-&gt;throw_msg( warp =&gt; offline =&gt; 'warp drive' )
                   unless $self-&gt;warp_drive_ready;
               # make it so
           }

           # throws the following exception:
           warp error - warp drive is offline

   <b>try($method,</b> <b>@args)</b>
       This method wraps another method call in an "eval" block to catch any exceptions thrown.

           my $result = $object-&gt;try( fetch =&gt; 'answer' ) || 42;

       This example is equivalent to:

           my $result = eval { $object-&gt;fetch('answer') } || 42;

       The error thrown can be retrieved using the "reason()" method.

           my $result = $object-&gt;try( fetch =&gt; 'answer' )|| do {
               warn "Could not fetch answer: ", $object-&gt;reason;
               42;     # a sensible default
           };

       If you call the "try()" method without any arguments then it will return a "Badger::Base::Trial" object
       as a wafer thin wrapper around the original object.  Any methods called on this delegate object will be
       forwarded to the original object, wrapped up in an "eval" block to catch any errors thrown.

           my $result = $object-&gt;try-&gt;fetch('answer') ||= do {
               ...
           };

   <b>catch($type,</b> <b>$method,</b> <b>@args)</b>
       TODO - this method depends on some code in Badger::Exception which I haven't written yet.

   <b>throws($type)</b>
       You can set the default exception type for <b>throw()</b> by calling the <b>throws()</b> method with an argument,
       either as an object method (to affect that object only) or as a class method (to affect all objects that
       don't set their own value explicitly).  Note that the <b>error()</b> and <b>error_msg()</b> methods call <b>throw()</b>
       internally, so changing the exception type will also affect the exceptions thrown by those methods.

           # object method
           $object-&gt;throws('food');
           $object-&gt;throw('No nuts');              # food error - No nuts
           $object-&gt;error('No nuts');              # food error - No nuts

           # class method
           Badger::Example-&gt;throws('food');
           Badger::Example-&gt;throw('No berries');   # food error - No berries
           Badger::Example-&gt;error('No berries');   # food error - No berries

           # all objects of this class now throw food by default
           my $badger = Badger::Example-&gt;new;
           $badger-&gt;throw('No cheese');            # food error - No cheese
           $badger-&gt;error('No cheese');            # food error - No cheese

       You can also set this value for an object by passing a "throws" configuration parameter to the <b>new()</b>
       constructor method.

           my $badger = Badger::Example-&gt;new(
               throws =&gt; 'food',
           );

       This relies on the default behaviour of the <b>init()</b> method which stores a reference to the original
       configuration parameters in "$self-&gt;{config}".  If you want to use this feature then you should ensure
       that any specialised <b>init()</b> method you define does the same thing, or copies the "throws" value from
       $config into "$self-&gt;{THROWS}".

           # example 1: store entire config for later
           sub init {
               my ($self, $config) = @_;
               $self-&gt;{ config } = $config;
               # do other stuff
               return $self;
           }

           # example 2: extract specific parameter up front
           sub init {
               my ($self, $config) = @_;
               $self-&gt;{ THROWS } = $config-&gt;{ throws };
               # do other stuff
               return $self;
           }

       You can set the default exception type for your own modules that inherit from "Badger::Base" by adding a
       $THROWS package variable;

           package Badger::Example;
           use base 'Badger::Base';
           our $THROWS = 'food';

       If you don't specify an exception type then one will be generated from the module's class name using the
       <b>id()</b> method in Badger::Class.

   <b>exception($class)</b>
       This method can be used to get or set the exception class for an object.  The default value is
       Badger::Exception.

           use Badger::Example;
           use Some::Other::Exception;
           Badger::Example-&gt;exception('Some::Other::Exception');

           # now Badger::Example objects throw Some::Other::Exception

       You can set the default exception class for your own modules that inherit from "Badger::Base" by adding a
       $EXCEPTION package variable;

           package Badger::Example;
           use base 'Badger::Base';
           use Some::Other::Exception;
           our $EXCEPTION = 'Some::Other::Exception';

   <b>fatal($info,</b> <b>$more_info,</b> <b>...)</b>
       This method is used internally to raise a fatal error.  It bypasses the normal error reporting mechanism
       and dies with a stack backtrace by calling "confess()" (see Carp).

       The most common reason for a fatal error being raised is calling the <b>message()</b> method (or either of the
       <b>error_msg()</b> or <b>decline_msg()</b> wrapper methods) with a message format that doesn't exist. The stack
       backtrace will tell you where in your code you're making the call so you can easily find and fix it.

   <b>not_implemented($what)</b>
       A method of convenience which raises an error indicating that the method isn't implemented

           sub example_method {
               shift-&gt;not_implemented;
           }

       Calling the "example_method()" would result in an error message similar to this (shown here split across
       two lines):

           your.badger.module error - example_method() is not implemented
           for Your::Badger::Module in /path/to/your/script.pl at line 42

       Note that it tells you where the "example_method()" was called from, not where the method is defined.

       The "not_implemented()" method is typically used in methods defined in a base classes that subclasses are
       expected to re-define (a.k.a. pure virtual methods or abstract methods).

       You can pass an argument to be more specific about what it is that isn't implemented.

           sub example_method {
               shift-&gt;not_implemented('in base class');
           }

       The argument is added to the generated error message following the method name.  A single space is also
       added to separate them.

           your.badger.module error - example_method() is not implemented in
           base class for Your::Badger::Module in ...etc...

   <b>todo($what)</b>
       A method of convenience useful during developing to indicate that a method isn't implemented yet.  It
       raises an error stating that the method is still TODO.

           sub not_yet_working {
               shift-&gt;todo;
           }

       The error message generated looks something like this:

           your.badger.module error - not_yet_working() is TODO in
           Your::Badger::Module at line 42

       You can pass an argument to be more specific about what is still TODO.

           sub not_yet_working {
               my ($self, $x) = @_;
               if (ref $x) {
                   $self-&gt;todo('support for references');
               }
               else {
                   # do something
               }
           }

       The error message generated would then be:

           your.badger.module error - not_yet_working() support for
           references is TODO in Your::Badger::Module at line 42

   <b>debug($msg1,$msg2,...)</b>
       This method is mixed in from the Badger::Debug module. It provides a simple way of generating debugging
       messages which include the source module and line number where the message was generated.

           sub example {
               my $self = shift;
               $self-&gt;debug('entered example()');
               # ... some code ...
               $self-&gt;debug('leaving example()');
           }

   <b>debug_msg($message,</b> <b>@args)</b>
       This is a wrapper around the <b>debug()</b> and <b>message()</b> methods, similar to <b>warn_msg()</b>, <b>error_msg()</b> and
       friends.

           our $MESSAGES = {
               here =&gt; 'You are in %s',
           };

           sub example {
               my $self = shift;

               $self-&gt;debug_msg(
                   here =&gt; 'a maze of twisty little passages, all alike'
               ) if DEBUG;

               # ... some code ...

               $self-&gt;debug_msg(
                   here =&gt; 'boat, floating on a sea of purest green'
               ) if DEBUG;
           }

   <b>debug_up($level,$msg1,$msg2,...)</b>
       Another debugging method mixed in from Badger::Debug.  This is a wrapper around <b>debug()</b> which reports the
       file and line number of a caller higher up the call stack.  This is typically used when you create your
       own debugging methods, as shown in the following example.

           sub parse {
               my $self = shift;

               while (my ($foo, $bar) = $self-&gt;get_foo_bar) {
                   $self-&gt;trace($foo, $bar);               # report line here
                   # do something
               }
           }

           sub trace {
               my ($self, $foo, $bar) = @_;
               $self-&gt;debug_up(2, "foo: $foo  bar: $bar"); # not here
           }

       See Badger::Debug for further details.

</pre><h4><b>PACKAGE</b> <b>VARIABLES</b></h4><pre>
       The "Badger::Base" module uses a number of package variables to control the default behaviour of the
       objects derived from it.

   <b>$DEBUG</b>
       This flag can be set true to enable debugging in "Badger::Base".

           $Badger::Base::DEBUG = 1;

       The "Badger::Base" module does not use or define any $DEBUG variable in the subclasses derived from it.
       However, you may want to do something similar in your own modules to assist in debugging.

           package Your::Badger::Module;
           use base 'Badger::Base';

           # allow flag to be set before this module is loaded
           our $DEBUG = 0 unless defined $DEBUG;

           sub gnarly_method {
               my ($self, $item) = @_;
               $self-&gt;debug("gnarly_method($item)\n") if $DEBUG;
               # your gnarly code
           }

       The "Badger::Class" module defines the "debug" method and import hook which will automatically define a
       $DEBUG variable for you.

           package Your::Badger::Module;

           use Badger::Class
               base  =&gt; 'Badger::Base',
               debug =&gt; 0;

   <b>$DECLINED</b>
       This package variable is defined in each subclass derived from "Badger::Base". It is a boolean (0/1) flag
       used by the <b>error()</b>, <b>decline()</b> and <b>declined()</b> methods. The <b>decline()</b> method sets it to 1 to indicate that
       the object declined a request. The <b>error()</b> method clears it back to 0 to indicate that a hard error
       occurred. The <b>declined()</b> method simply returns the value.

   <b>$ERROR</b>
       This package variable is defined in each subclass derived from "Badger::Base".  It stores the most recent
       error message raised by <b>decline()</b> or <b>error()</b>.

   <b>$EXCEPTION</b>
       This package variable is used to define the name of the class that should be used to instantiate
       exception objects.  The default value in "Badger::Base" is "Badger::Exception".

       Subclasses may define an $EXCEPTION package variable to change this value.

           package Your::Badger::Module;
           use base 'Badger::Base';
           use Your::Exception;
           our $EXCEPTION = 'Your::Exception';

       Those that don't explicitly define an $EXCEPTION will inherit the value from any of their base classes,
       possibly coming all the way back up to the default value in "Badger::Base".

       Calling the "exception()" class method with an argument will update the $EXCEPTION package variable in
       that class.

           # sets $Your::Badger::Module::EXCEPTION
           Your::Badger::Module-&gt;exception('Your::Exception');

   <b>$MESSAGES</b>
       This package variable is used to reference a hash array of messages that can be used with the <b>message()</b>,
       <b>warn_msg()</b>, <b>error_msg()</b> and <b>decline_msg()</b> methods. The "Badger::Base" module defines a number of messages
       that it uses internally.

           our $MESSAGES = {
               not_found       =&gt; '%s not found: %s',
               not_found_in    =&gt; '%s not found in %s',
               not_implemented =&gt; '%s is not implemented %s',
               no_component    =&gt; 'No %s component defined',
               bad_method      =&gt; "Invalid method '%s' called on %s at %s line %s",
               invalid         =&gt; 'Invalid %s specified: %s',
               unexpected      =&gt; 'Invalid %s specified: %s (expected a %s)',
               missing_to      =&gt; 'No %s specified to %s',
               missing         =&gt; 'No %s specified',
               todo            =&gt; '%s is TODO %s',
               at_line         =&gt; '%s at line %s',
               at_file_line    =&gt; '%s in %s at line %s',
           };

       The <b>message()</b> method searches for $MESSAGES in the current class and those of any base classes.  That
       means that any objects derived from "Badger::Base" can use these message formats.

           package Your::Badger::Module;
           use base 'Badger::Base';

           sub init {
               my ($self, $config) = @_;
               $self-&gt;{ name } = $config-&gt;{ name }
                   || $self-&gt;error_msg( missing =&gt; $name );
               return $self;
           }

       You can define additional $MESSAGES for your own classes.

           package Your::Badger::Module;
           use base 'Badger::Base';

           our $MESSAGES = {
               life_jim  =&gt; "It's %s Jim, but not as we know it",
           }

           sub bones {
               my ($self, $thing)= @_;
               $self-&gt;warn_msg( life_jim =&gt; $thing );
               return $self;
           }

       Calling the "bones()" method like this:

           $object-&gt;bones('a badger');

       will generate a warning like this:

           It's a badger Jim, but not as we know it.

   <b>$ON_ERROR</b>
       This package variable is used to define one or more error handlers that will be invoked whenever the
       <b>error()</b> method is called.

       The "Badger::Base" module doesn't define any $ON_ERROR package variable by default.  The <b>on_error()</b>
       method can be called as a class method to set the $ON_ERROR package variable.

           Your::Badger::Module-&gt;on_error(\&amp;my_handler);

       You can also define an $ON_ERROR handler or list of handlers in your module.

           package Your::Badger::Module;
           use base 'Badger::Base';

           # one of the following...
           our $ON_ERROR = 'warn';         # call Perl's warn()
           our $ON_ERROR = 'method_name';
           our $ON_ERROR = \&amp;code_ref;
           our $ON_ERROR = [ 'warn', 'method_name', \&amp;code_ref ];

           # code refs get message as first argument
           sub code_ref {
               my $message = shift;
               # do something...
           }

           # methods get implicit $self, then message argument
           sub method_name {
               my ($self, $message) = @_;
               # do something...
           }

   <b>$ON_WARN</b>
       This package variable is used to define one or more error handlers that will be invoked whenever the
       <b>warning()</b> method is called.  It works in exactly the same way as $ON_ERROR.

   <b>$THROWS</b>
       This package variable is used to define the default exception type thrown by the <b>throw()</b> method (and
       <b>error()</b> and <b>error_msg()</b> which call it indirectly).  It can be set by calling the <b>throws()</b> class method.

           Your::Badger::Module-&gt;throws('food');

       You can define $THROWS in your own modules that are derived from "Badger::Base".

           package Your::Badger::Module;
           use base 'Badger::Base';
           our $THROWS = 'food';

       If the $THROWS value is not defined in the current class or any of an object's base classes, then the
       <b>id()</b> method is used to construct an identifier for the module to use instead.

</pre><h4><b>OBJECT</b> <b>INTERNALS</b></h4><pre>
       The "Badger::Base" module uses the following internal object items to store information.

   <b>config</b>
       The default <b>init()</b> method stores a reference to the hash array of configuration parameters in the
       "$self-&gt;{config}" slot. If you're using the default <b>init()</b> method then your other methods can use this to
       lookup configuration parameters lazily.

       If you've defined your own <b>init()</b> method then this item won't exist unless your <b>init()</b> method adds it
       explicitly.

   <b>DECLINED</b>
       The value of the declined flag, as per the $DECLINED package variable.

   <b>ERROR</b>
       The last error raised, as per the $ERROR package variable.

   <b>EXCEPTION</b>
       Used to store the class name that should used to instantiate exceptions.  Equivalent to the $EXCEPTION
       package variable but operating on a per-object basis. Can be inspected or modified by calling the
       <b>exception()</b> object method.

   <b>ON_ERROR</b>
       An internal list of handlers to call when an error is raised.  Equivalent to the $ON_ERROR package
       variable but operating on a per-object basis.  Can be inspected or modified by calling the <b>on_error()</b>
       object method.

   <b>ON_WARN</b>
       An internal list of handlers to call when a warning is raised.  Equivalent to the $ON_WARN package
       variable but operating on a per-object basis.  Can be inspected or modified by calling the <b>on_warn()</b>
       object method.

   <b>THROWS</b>
       Used to store the exception type that the object should throw.  Equivalent to the $THROWS package
       variable but operating on a per-object basis.  Can be inspected or modified by calling the <b>throws()</b>
       object method.

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Wardley &lt;<a href="http://wardley.org/">http://wardley.org/</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 1996-2009 Andy Wardley.  All Rights Reserved.

       This module is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2023-08-28                                  <u>Badger::<a href="../man3pm/Base.3pm.html">Base</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>