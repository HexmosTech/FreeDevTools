<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dancer2::Manual - A gentle introduction to Dancer2</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdancer2-perl">libdancer2-perl_1.1.2+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Dancer2::Manual - A gentle introduction to Dancer2

</pre><h4><b>VERSION</b></h4><pre>
       version 1.1.2

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Dancer2 is a free and open source web application framework written in Perl.

       It's a complete rewrite of Dancer, based on Moo and using a more robust and extensible fully-OO design.

       It's designed to be powerful and flexible, but also easy to use - getting up and running with your web
       app is trivial, and an ecosystem of adaptors for common template engines, session storage, logging
       methods, serializers, and plugins to make common tasks easy means you can do what you want to do, your
       way, easily.

</pre><h4><b>INSTALL</b></h4><pre>
       Installation of Dancer2 is simple, using your favourite method to install from CPAN, e.g.:

           perl -MCPAN -e 'install Dancer2'

       Thanks to the magic of cpanminus, if you do not have CPAN.pm configured, or just want a quickfire way to
       get running, the following should work, at least on Unix-like systems:

           wget -O - <a href="http://cpanmin.us">http://cpanmin.us</a> | sudo perl - Dancer2

       (If you don't have root access, omit the 'sudo', and cpanminus will install Dancer2 and prereqs into
       "<a href="file:~/perl5">~/perl5</a>".)

       Dancer2 is also available as a package from the package repository of several distributions, for example
       on Debian/Ubuntu you should be able to just:

           apt-get install libdancer2-perl

       Do be aware, though, that distribution-packaged versions sometimes lag behind the most recent version on
       CPAN.

</pre><h4><b>BOOTSTRAPPING</b> <b>A</b> <b>NEW</b> <b>APP</b></h4><pre>
       Create a web application using the dancer script:

           $ dancer2 gen -a MyApp &amp;&amp; cd MyApp
           + MyApp
           + MyApp/config.yml
           + MyApp/Makefile.PL
           + MyApp/MANIFEST.SKIP
           + MyApp/.dancer
           + MyApp/cpanfile
           + MyApp/bin
           + MyApp/bin/app.psgi
           + MyApp/environments
           + MyApp/environments/development.yml
           + MyApp/environments/production.yml
           + MyApp/lib
           + MyApp/lib/MyApp.pm
           + MyApp/public
           + MyApp/public/favicon.ico
           + MyApp/public/500.html
           + MyApp/public/dispatch.cgi
           + MyApp/public/404.html
           + MyApp/public/dispatch.fcgi
           + MyApp/public/css
           + MyApp/public/css/error.css
           + MyApp/public/css/style.css
           + MyApp/public/images
           + MyApp/public/images/perldancer.jpg
           + MyApp/public/images/perldancer-bg.jpg
           + MyApp/public/javascripts
           + MyApp/public/javascripts/jquery.js
           + MyApp/t
           + MyApp/t/001_base.t
           + MyApp/t/002_index_route.t
           + MyApp/views
           + MyApp/views/index.tt
           + MyApp/views/layouts
           + MyApp/views/layouts/main.tt

       It creates a directory named after the name of the app, along with a configuration file, a views
       directory (where your templates and layouts will live), an environments directory (where environment-
       specific settings live), a module containing the actual guts of your application, and a script to start
       it. Finally, <u>.dancer</u> indicates the root directory of your app, making it easier for Dancer2 to determine
       the various paths it needs for finding resources and code within your application.

       A default skeleton is used to bootstrap the new application, but you can use the "-s" option to provide
       another skeleton.  For example:

           $ dancer2 gen -a MyApp -s <a href="file:~/mydancerskel">~/mydancerskel</a>

       For an example of a skeleton directory check the default one available in the "share/" directory of your
       Dancer2 distribution.

       (In what follows we will refer to the directory in which you have created your Dancer2 application --
       <u>e.g.,</u> what "MyApp" was above -- as the "appdir".)

       Because Dancer2 is a PSGI web application framework, you can use the "plackup" tool (provided by Plack)
       for launching the application:

           plackup -p 5000 bin/app.psgi

       View the web application at:

           <a href="http://localhost">http://localhost</a>:5000

</pre><h4><b>USAGE</b></h4><pre>
       When Dancer2 is imported to a script, that script becomes a webapp, and at this point, all the script has
       to do is declare a list of <b>routes</b>. A route handler is composed by an HTTP method, a path pattern and a
       code block. "strict", "warnings" and "utf8" pragmas are also imported with Dancer2.

       The code block given to the route handler has to return a string which will be used as the content to
       render to the client.

       Routes are defined for a given HTTP method. For each method supported, a keyword is exported by the
       module.

   <b>HTTP</b> <b>Methods</b>
       Here are some of the standard HTTP methods which you can use to define your route handlers.

       •   <b>GET</b> The GET method retrieves information, and is the most common

           GET requests should be used for typical "fetch" requests - retrieving information. They should not be
           used for requests which change data on the server or have other effects.

           When  defining  a route handler for the GET method, Dancer2 automatically defines a route handler for
           the HEAD method (in order to honour HEAD requests for each of your GET route handlers).

           To define a GET action, use the get keyword.

       •   <b>POST</b> The POST method is used to create a resource on the server.

           To define a POST action, use the post keyword.

       •   <b>PUT</b> The PUT method is used to replace an existing resource.

           To define a PUT action, use the put keyword.

           a PUT request should replace the existing resource with that specified - for instance - if you wanted
           to just update an email address for a user, you'd have to specify all attributes of the  user  again;
           to make a partial update, a PATCH request is used.

       •   <b>PATCH</b> The PATCH method updates some attributes of an existing resource.

           To define a PATCH action, use the patch keyword.

       •   <b>DELETE</b>  The  DELETE  method  requests  that  the  origin server delete the resource identified by the
           Request-URI.

           To define a DELETE action, use the del keyword.

       <u>Handling</u> <u>multiple</u> <u>HTTP</u> <u>request</u> <u>methods</u>

       Routes can use "any" to match all, or a specified list of HTTP methods.

       The following will match any HTTP request to the path "/myaction":

           any '/myaction' =&gt; sub {
               # code
           }

       The following will match GET or POST requests to "/myaction":

           any ['get', 'post'] =&gt; '/myaction' =&gt; sub {
               # code
           };

       For convenience, any route which matches GET requests will also match HEAD requests.

   <b>Route</b> <b>Handlers</b>
       The route action is  the  code  reference  declared.  It  can  access  parameters  through  the  specific
       route_parameters, query_parameters, and body_parameters keywords, which return a Hash::MultiValue object.
       This hashref is a merge of the route pattern matches and the request params.

       You can find more details about how params are built and how to access them in the Dancer2::Core::Request
       documentation.

       <u>Declaring</u> <u>Routes</u>

       To control what happens when a web request is received by your webapp, you'll need to declare "routes". A
       route  declaration indicates which HTTP method(s) it is valid for, the path it matches (e.g. "/foo/bar"),
       and a coderef to execute, which returns the response.

           get '/hello/:name' =&gt; sub {
               return "Hi there " . route_parameters-&gt;get('name');
           };

       The above route specifies that, for GET requests to "/hello/...",  the  code  block  provided  should  be
       executed.

       You can also provide routes with a name:

           get 'hi_to' =&gt; '/hello/:name' =&gt; sub {...};

       See "uri_for_route" in Dancer2::Manual::Keywords on how this can be used.

       <u>Retrieving</u> <u>request</u> <u>parameters</u>

       The  query_parameters,  route_parameters,  and body_parameters keywords provide a Hash::MultiValue result
       from the three different parameters.

       <u>Named</u> <u>matching</u>

       A route pattern can contain one or more tokens (a word prefixed with ':').  Each token found in  a  route
       pattern is used as a named-pattern match. Any match will be set in the route parameters.

           get '/hello/:name' =&gt; sub {
               return "Hey " . route_parameters-&gt;get('name') . ", welcome here!";
           };

       Tokens can be optional, for example:

           get '/hello/:name?' =&gt; sub {
               my $name = route_parameters-&gt;get('name') // 'Whoever you are';
               return "Hello there, $name";
           };

       <u>Named</u> <u>matching</u> <u>with</u> <u>type</u> <u>constraints</u>

       Type constraints can be added to tokens.

           get '/user/:id[Int]' =&gt; sub {
               # matches /user/34 but not /user/jamesdean
               my $user_id = route_parameters-&gt;get('id');
           };

           get '/user/:username[Str]' =&gt; sub {
               # matches /user/jamesdean but not /user/34 since that is caught
               # by previous route
               my $username = route_parameters-&gt;get('username');
           };

       You can even use type constraints to add a regexp check:

           get '/book/:date[StrMatch[qr{\d\d\d\d-\d\d-\d\d}]]' =&gt; sub {
               # matches /book/2014-02-04
               my $date = route_parameters-&gt;get('date');
           };

       The  default  type  library  is  Dancer2::Core::Types  but  any  type  library  built  using Type::Tiny's
       Type::Library can be used instead.  If you'd like to use  a  different  default  type  library  you  must
       declare it in the configuration file, for example:

           type_library: My::Type::Library

       Alternatively  you  can  specify  the  type  library  in  which  the type is defined as part of the route
       definition:

           get '/user/:username[My::Type::Library::Username]' =&gt; sub {
               my $username = route_parameters-&gt;get('username');
           };

       This will load "My::Type::Library" and from it use the type "Username". This allows types to be used that
       are not part of the type library defined by config's "type_library".

       More complex constructs are allowed such as:

           get '/some/:thing[Int|MyDate]' =&gt; sub {
               ...;
           };

       See "lookup($name)" in Type::Registry for more details.

       <u>Wildcard</u> <u>Matching</u>

       A route can contain a wildcard (represented by a "*"). Each wildcard match will  be  placed  in  a  list,
       which the "splat" keyword returns.

           get '/download/*.*' =&gt; sub {
               my ($file, $ext) = splat;
               # do something with $file.$ext here
           };

       An  extensive,  greedier wildcard represented by "**" (A.K.A. "megasplat") can be used to define a route.
       The additional path is broken down and returned as an arrayref:

           get '/entry/*/tags/**' =&gt; sub {
               my ( $entry_id, $tags ) = splat;
               my @tags = @{$tags};
           };

       The "splat" keyword in the above example for the route <u>/entry/1/tags/one/two</u> would set $entry_id to 1 and
       $tags to "['one', 'two']".

       <u>Mixed</u> <u>named</u> <u>and</u> <u>wildcard</u> <u>matching</u>

       A route can combine named (token) matching and wildcard matching.  This is useful when chaining actions:

           get '/team/:team/**' =&gt; sub {
               var team =&gt; route_parameters-&gt;get('team');
               pass;
           };

           prefix '/team/:team';

           get '/player/*' =&gt; sub {
               my ($player) = splat;

               # etc...
           };

           get '/score' =&gt; sub {
               return score_for( vars-&gt;{'team'} );
           };

       <u>Regular</u> <u>Expression</u> <u>Matching</u>

       A route can be defined with a Perl regular expression.

       In order to tell Dancer2 to consider the route as a real regexp, the route  must  be  defined  explicitly
       with "qr{}", like the following:

           get qr{/hello/([\w]+)} =&gt; sub {
               my ($name) = splat;
               return "Hello $name";
           };

       A  route  regex may use named capture groups. The "captures" keyword will return a reference to a copy of
       "%+".

       <u>Conditional</u> <u>Matching</u>

       Routes may include some matching conditions  (on  content_type,  agent,  user_agent,  content_length  and
       path_info):

           get '/foo', {agent =&gt; 'Songbird (\d\.\d)[\d\/]*?'} =&gt; sub {
             'foo method for songbird'
           }

           get '/foo' =&gt; sub {
             'all browsers except songbird'
           }

   <b>Prefix</b>
       A prefix can be defined for each route handler, like this:

           prefix '<a href="file:/home">/home</a>';

       From here, any route handler is defined to <a href="file:/home/">/home/</a>*

           get '/page1' =&gt; sub {}; # will match '/home/page1'

       You can unset the prefix value

           prefix '/'; # or: prefix undef;
           get '/page1' =&gt; sub {}; # will match /page1

       Alternatively,  to  prevent you from ever forgetting to undef the prefix, you can use lexical prefix like
       this:

           prefix '<a href="file:/home">/home</a>' =&gt; sub {
             get '/page1' =&gt; sub {}; # will match '/home/page1'
           }; ## prefix reset to previous value on exit

           get '/page1' =&gt; sub {}; # will match /page1

   <b>Delayed</b> <b>responses</b> <b>(Async/Streaming)</b>
       Dancer2 can provide delayed (otherwise known as <u>asynchronous</u>)  responses  using  the  "delayed"  keyword.
       These responses are streamed, although you can set the content all at once, if you prefer.

           get '/status' =&gt; sub {
               delayed {
                   response_header 'X-Foo' =&gt; 'Bar';

                   # flush headers (in case of streaming)
                   flush;

                   # send content to the user
                   content 'Hello, world!';

                   # you can write more content
                   # all streaming
                   content 'Hello, again!';

                   # when done, close the connection
                   done;

                   # do whatever you want else, asynchronously
                   # the user socket closed by now
                   ...
               };
           };

       If  you  are  streaming (calling "content" several times), you must call "flush" first. If you're sending
       only once, you don't need to call "flush".

       Here is an example of using delayed responses with AnyEvent:

           use Dancer2;
           use AnyEvent;

           my %timers;
           my $count = 5;
           get '/drums' =&gt; sub {
               delayed {
                   print "Stretching...\n";
                   flush; # necessary, since we're streaming

                   $timers{'Snare'} = AE::timer 1, 1, delayed {
                       $timers{'HiHat'} ||= AE::timer 0, 0.5, delayed {
                           content "Tss...\n";
                       };

                       content "Bap!\n";

                       if ( $count-- == 0 ) {
                           %timers = ();
                           content "Tugu tugu tugu dum!\n";
                           done;

                           print "&lt;enter sound of applause&gt;\n\n";
                           $timers{'Applause'} = AE::timer 3, 0, sub {
                               # the DSL will not available here
                               # because we didn't call the "delayed" keyword
                               print "&lt;applause dies out&gt;\n";
                           };
                       }
                   };
               };
           };

       If an error happens during a write operation, a warning will be issued to the logger.

       You can handle the error yourself by providing an "on_error" handler:

           get '/' =&gt; sub {
               delayed {
                   flush;
                   content "works";

                   # ... user disconnected here ...

                   content "fails";

                   # ... error triggered ...

                   done; # doesn't even get run
               } on_error =&gt; sub {
                   # delayed{} not needed, DSL already available
                   my ($error) = @_;
                   # do something with $error
               };
           };

       Here is an example that asynchronously streams the contents of a CSV file:

           use Dancer2;
           use Text::CSV_XS  qw&lt; csv &gt;;
           use Path::Tiny    qw&lt; path &gt;;
           use JSON::MaybeXS qw&lt; encode_json &gt;;
           # Create CSV parser
           my $csv = Text::CSV_XS-&gt;new({
               binary    =&gt; 1,
               auto_diag =&gt; 1,
           });
           get '/' =&gt; sub {
               # delayed response:
               delayed {
                   # streaming content
                   flush;
                   # Read each row and stream it in JSON
                   my $fh = path('filename.csv')-&gt;openr_utf8;
                   while ( my $row = $csv-&gt;getline($fh) ) {
                       content encode_json $row;
                   }
                   # close user connection
                   done;
               } on_error =&gt; sub {
                   my ($error) = @_;
                   warning 'Failed to stream to user: ' . request-&gt;remote_address;
               };
           };

       <b>NOTE:</b> If you just want to send a file's contents  asynchronously,  use  send_file($filename)  instead  of
       "delayed", as it will automatically take advantage of any asynchronous capability.

   <b>Action</b> <b>Skipping</b>
       An  action  can  choose  not to serve the current request and ask Dancer2 to process the request with the
       next matching route.

       This is done with the <b>pass</b> keyword, like in the following example

           get '/say/:word' =&gt; sub {
               pass if route_parameters-&gt;get('word') =~ /^\d+$/;
               "I say a word: " . route_parameters-&gt;get('word');
           };

           get '/say/:number' =&gt; sub {
               "I say a number: " . route_parameters-&gt;get('number');
           };

</pre><h4><b>HOOKS</b></h4><pre>
       Hooks are code references (or anonymous subroutines) that are triggered at specific  moments  during  the
       resolution of a request.  They are set up using the hook keyword.

       Many of them are provided by Dancer2's core, but plugins and engines can also define their own.

       •   "before" hooks

           "before"  hooks  are  evaluated before each request within the context of the request and receives as
           argument the app (a Dancer2::Core::App object).

           It's possible to define variables which will be accessible in the action blocks with the var keyword.

               hook before =&gt; sub {
                   var note =&gt; 'Hi there';
               };

               get '/foo/*' =&gt; sub {
                   my ($match) = splat; # 'oversee';
                   vars-&gt;{note};        # 'Hi there'
               };

           For another example, this can be used along with session support to easily give non-logged-in users a
           login page:

               hook before =&gt; sub {
                   if (!session('user') &amp;&amp; request-&gt;path !~ m{^/login}) {
                       # Pass the original path requested along to the handler:
                       forward '/login', { requested_path =&gt; request-&gt;path };
                   }
               };

           The request keyword returns the  current  Dancer2::Core::Request  object  representing  the  incoming
           request.

       •   "after" hooks

           "after"  hooks  are evaluated after the response has been built by a route handler, and can alter the
           response itself, just before it's sent to the client.

           This hook runs after a request has been processed, but before the response is sent.

           It receives a Dancer2::Core::Response object, which it can modify if it needs to make changes to  the
           response which is about to be sent.

           The hook can use other keywords in order to do whatever it wants.

               hook after =&gt; sub {
                   response-&gt;content(
                       q{The "after" hook can alter the response's content here!}
                   );
               };

   <b>Templates</b>
       •   "before_template_render"

           "before_template_render"  hooks  are  called  whenever  a template is going to be processed, they are
           passed the tokens hash which they can alter.

               hook before_template_render =&gt; sub {
                   my $tokens = shift;
                   $tokens-&gt;{foo} = 'bar';
               };

           The tokens hash will then be passed to the template with all the modifications performed by the hook.
           This is a good way to setup some global vars you like to have in all your templates, like the name of
           the user logged in or a section name.

       •   "after_template_render"

           "after_template_render" hooks are called after the view has been rendered.   They  receive  as  their
           first  argument the reference to the content that has been produced. This can be used to post-process
           the content rendered by the template engine.

               hook after_template_render =&gt; sub {
                   my $ref_content = shift;
                   my $content     = ${$ref_content};

                   # do something with $content
                   ${$ref_content} = $content;
               };

       •   "before_layout_render"

           "before_layout_render" hooks are called whenever the layout is going to be  applied  to  the  current
           content.  The  arguments  received  by the hook are the current tokens hashref and a reference to the
           current content.

               hook before_layout_render =&gt; sub {
                   my ($tokens, $ref_content) = @_;
                   $tokens-&gt;{new_stuff} = 42;
                   $ref_content = \"new content";
               };

       •   "after_layout_render"

           "after_layout_render" hooks are called once the complete content of the view has been produced, after
           the layout has been applied to the content.  The argument received by the hook is a reference to  the
           complete content string.

               hook after_layout_render =&gt; sub {
                   my $ref_content = shift;
                   # do something with ${ $ref_content }, which reflects directly
                   #   in the caller
               };

   <b>Error</b> <b>Handling</b>
       Refer to Error Hooks for details about the following hooks:

       •   "init_error"

       •   "before_error"

       •   "after_error"

       •   "on_route_exception"

   <b>File</b> <b>Rendering</b>
       Refer to File Handler for details on the following hooks:

       •   "before_file_render"

       •   "after_file_render"

   <b>Logging</b>
       Logging  hooks  do  not  allow  you to alter log message content, but they do give you a place to perform
       extra actions. For example, if you want to send an email for error messages, but you don't want to use  a
       heavier logger such as Log::Any or Log::Log4perl:

           hook 'engine.logger.after' =&gt; sub {
               my ( $logger, $level, $message ) = @_;

               if( $level eq 'error' ) {
                   # Send an email with the message content
               }
           };

       There are two hooks available for logging:

       •   engine.logger.before

           This hook is called before a log message is produced.

       •   engine.logger.after

           This hook is called after a log message is produced.

   <b>Serializers</b>
       •   "before_serializer"  is  called before serializing the content, and receives the content to serialize
           as an argument.

             hook before_serializer =&gt; sub {
               my $content = shift;
               ...
             };

       •   "after_serializer" is called after the payload has  been  serialized,  and  receives  the  serialized
           content as an argument.

             hook after_serializer =&gt; sub {
               my $serialized_content = shift;
               ...
             };

</pre><h4><b>HANDLERS</b></h4><pre>
   <b>File</b> <b>Handler</b>
       Whenever  a content is produced out of the parsing of a static file, the Dancer2::Handler::File component
       is used. This component provides two hooks, "before_file_render" and "after_file_render".

       "before_file_render" hooks are called just before starting to parse the file, the hook  receives  as  its
       first argument the file path that is going to be processed.

           hook before_file_render =&gt; sub {
               my $path = shift;
           };

       "after_file_render" hooks are called after the file has been parsed and the response content produced. It
       receives the response object (Dancer2::Core::Response) produced.

           hook after_file_render =&gt; sub {
              my $response = shift;
           };

   <b>Auto</b> <b>page</b>
       Whenever  a  page  that  matches  an existing template needs to be served, the Dancer2::Handler::AutoPage
       component is used.

   <b>Writing</b> <b>your</b> <b>own</b>
       A route handler is a class that consumes the Dancer2::Core::Role::Handler role. The class must  implement
       a set of methods: "methods", "regexp" and "code" which will be used to declare the route.

       Let's look at Dancer2::Handler::AutoPage for example.

       First, the matching methods are "get" and "head":

           sub methods { qw(head get) }

       Then, the "regexp" or the <u>path</u> we want to match:

           sub regexp { '/:page' }

       Anything  will be matched by this route, since we want to check if there's a view named with the value of
       the "page" token. If not, the route needs to "pass", letting the dispatching flow to proceed further.

           sub code {
               sub {
                   my $app = shift;
                   my $prefix = shift;

                   my $template = $app-&gt;template_engine;
                   if ( !defined $template ) {
                       $app-&gt;response-&gt;<a href="../man1/has_passed.1.html">has_passed</a>(1);
                       return;
                   }

                   my $page       = $app-&gt;request-&gt;path;
                   my $layout_dir = $template-&gt;layout_dir;
                   if ( $page =~ m{^/\Q$layout_dir\E/} ) {
                       $app-&gt;response-&gt;<a href="../man1/has_passed.1.html">has_passed</a>(1);
                       return;
                   }

                   # remove leading '/', ensuring paths relative to the view
                   $page =~ s{^/}{};
                   my $view_path = $template-&gt;view_pathname($page);

                   if ( ! $template-&gt;pathname_exists( $view_path ) ) {
                       $app-&gt;response-&gt;<a href="../man1/has_passed.1.html">has_passed</a>(1);
                       return;
                   }

                   my $ct = $template-&gt;process( $page );
                   return ( $app-&gt;request-&gt;method eq 'GET' ) ? $ct : '';
               };
           }

       The "code" method passed the Dancer2::Core::App object  which  provides  access  to  anything  needed  to
       process the request.

       A  "register" is then implemented to add the route to the registry and if the "auto_page setting" is off,
       it does nothing.

           sub register {
               my ($self, $app) = @_;

               return unless $app-&gt;config-&gt;{auto_page};

               $app-&gt;add_route(
                   method =&gt; $_,
                   regexp =&gt; $self-&gt;regexp,
                   code   =&gt; $self-&gt;code,
               ) for $self-&gt;methods;
           }

       The config parser looks for a "route_handlers" section and any handler defined there is loaded. Thus, any
       random handler can be added to  your  app.   For  example,  the  default  config  file  for  any  Dancer2
       application is as follows:

           route_handlers:
             File:
               public_dir: /path/to/public
             AutoPage: 1

</pre><h4><b>ERRORS</b></h4><pre>
   <b>Error</b> <b>Pages</b>
       When  an  HTTP  error  occurs  (i.e.  the action responds with a status code other than 200), this is how
       Dancer2 determines what page to display.

       •   Looks in the "views/" directory for a corresponding template  file  matching  the  error  code  (e.g.
           "500.tt" or "404.tt"). If such a file exists, it's used to report the error.

       •   Next,  looks  in  the "public/" directory for a corresponding HTML file matching the error code (e.g.
           "500.html" or "404.html"). If such a file exists, it's used to report the error. (Note, however, that
           if <b>show_stacktrace</b> is set to true, in the case of a 500 error the static HTML page will not be shown,
           but will be replaced with a default error page containing  more  informative  diagnostics.  For  more
           information see Dancer2::Config.)

           (In  older  versions,  <b>show_errors</b>  was  used  instead  of  <b>show_stacktrace</b>.  Both are supported, but
           <b>show_errors</b> is deprecated.)

       •   As default, render a generic error page on the fly.

   <b>Execution</b> <b>Errors</b>
       When an error occurs during the route execution, Dancer2 will render an error page with the  HTTP  status
       code 500.

       It's possible either to display the content of the error message or to hide it with a generic error page.
       This is a choice left to the end-user and can be controlled with the <b>show_stacktrace</b> setting (see above).

   <b>Error</b> <b>Hooks</b>
       When   an   error   is   caught   by  Dancer2's  core,  an  exception  object  is  built  (of  the  class
       Dancer2::Core::Error). This class provides a hook to let the user alter the error workflow if needed.

       "init_error" hooks are called whenever an error object is built, the object is passed to the hook.

           hook init_error =&gt; sub {
               my $error = shift;
               # do something with $error
           };

       <u>This</u> <u>hook</u> <u>was</u> <u>named</u> <u><b>before_error_init</b></u>  <u>in</u>  <u>Dancer,</u>  <u>both</u>  <u>names</u>  <u>currently</u>  <u>are</u>  <u>synonyms</u>  <u>for</u>  <u>backward-</u>
       <u>compatibility.</u>

       "before_error"  hooks are called whenever an error is going to be thrown, it receives the error object as
       its sole argument.

           hook before_error =&gt; sub {
               my $error = shift;
               # do something with $error
           };

       <u>This</u> <u>hook</u> <u>was</u> <u>named</u> <u><b>before_error_render</b></u> <u>in</u> <u>Dancer,</u>  <u>both</u>  <u>names</u>  <u>currently</u>  <u>are</u>  <u>synonyms</u>  <u>for</u>  <u>backward-</u>
       <u>compatibility.</u>

       "after_error"   hooks   are   called   whenever   an   error  object  has  been  thrown,  it  receives  a
       Dancer2::Core::Response object as its sole argument.

           hook after_error =&gt; sub {
               my $response = shift;
           };

       <u>This</u> <u>hook</u> <u>was</u> <u>named</u> <u><b>after_error_render</b></u> <u>in</u>  <u>Dancer,</u>  <u>both</u>  <u>names</u>  <u>currently</u>  <u>are</u>  <u>synonyms</u>  <u>for</u>  <u>backward-</u>
       <u>compatibility.</u>

       "on_route_exception"  is  called  when  an  exception  has  been  caught, at the route level, just before
       rethrowing it higher. This hook receives a Dancer2::Core::App and the error as arguments.

         hook on_route_exception =&gt; sub {
           my ($app, $error) = @_;
         };

</pre><h4><b>SESSIONS</b></h4><pre>
   <b>Handling</b> <b>sessions</b>
       It's common to want to use sessions to give your web applications state; for instance, allowing a user to
       log in, creating a session, and checking that session on subsequent requests.

       By default Dancer 2 has Simple sessions enabled.  It implements a very simple in-memory session  storage.
       This  will  be  fast  and useful for testing, but such sessions will not persist between restarts of your
       app.

       If you'd like to use a different session engine you must declare it in the configuration file.

       For example to use YAML file base sessions you need to add the following to your <u>config.yml</u>:

           session: YAML

       Or, to enable session support from within your code,

           set session =&gt; 'YAML';

       (However, controlling settings is best done from your config file.)

       The Dancer2::Session::YAML backend implements a file-based YAML session storage to help  with  debugging,
       but shouldn't be used on production systems.

       There  are  other  session  backends,  such  as  Dancer2::Session::Memcached,  which  are recommended for
       production use.

       You can then use the session keyword to manipulate the session:

       <u>Storing</u> <u>data</u> <u>in</u> <u>the</u> <u>session</u>

       Storing data in the session is as easy as:

           session varname =&gt; 'value';

       <u>Retrieving</u> <u>data</u> <u>from</u> <u>the</u> <u>session</u>

       Retrieving data from the session is as easy as:

           session('varname')

       Or, alternatively,

           session-&gt;read("varname")

       <u>Controlling</u> <u>where</u> <u>sessions</u> <u>are</u> <u>stored</u>

       For disc-based session backends like Dancer2::Session::YAML, session files are written to the session dir
       specified by the "session_dir" setting, which defaults to "./sessions" if not specifically set.

       If you need to control where session files are created, you can do so  quickly  and  easily  within  your
       config file, for example:

           session: YAML
           engines:
             session:
               YAML:
                 session_dir: /tmp/dancer-sessions

       If the directory you specify does not exist, Dancer2 will attempt to create it for you.

       <u>Changing</u> <u>session</u> <u>ID</u>

       If you wish to change the session ID (for example on privilege level change):

           my $new_session_id = app-&gt;change_session_id

       <u>Destroying</u> <u>a</u> <u>session</u>

       When you're done with your session, you can destroy it:

           app-&gt;destroy_session

   <b>Sessions</b> <b>and</b> <b>logging</b> <b>in</b>
       A  common  requirement  is  to  check  the  user is logged in, and, if not, require them to log in before
       continuing.

       This can easily be handled using a before hook to check their session:

           use Dancer2;
           set session =&gt; "Simple";

           hook before =&gt; sub {
               if (!session('user') &amp;&amp; request-&gt;path !~ m{^/login}) {
                   forward '/login', { requested_path =&gt; request-&gt;path };
               }
           };

           get '/' =&gt; sub { return "Home Page"; };

           get '/secret' =&gt; sub { return "Top Secret Stuff here"; };

           get '/login' =&gt; sub {
               # Display a login page; the original URL they requested is available as
               # query_parameters-&gt;get('requested_path'), so could be put in a hidden field in the form
               template 'login', { path =&gt; query_parameters-&gt;get('requested_path') };
           };

           post '/login' =&gt; sub {
               # Validate the username and password they supplied
               if (body_parameters-&gt;get('user') eq 'bob' &amp;&amp; body_parameters-&gt;get('pass') eq 'letmein') {
                   session user =&gt; body_parameters-&gt;get('user');
                   redirect body_parameters-&gt;get('path') || '/';
               } else {
                   redirect '/login?failed=1';
               }
           };

           dance();

       Here is what the corresponding "login.tt" file should look like. You  should  place  it  in  a  directory
       called "views/":

           &lt;html&gt;
             &lt;head&gt;
               &lt;title&gt;Session and logging in&lt;/title&gt;
             &lt;/head&gt;
             &lt;body&gt;
               &lt;form action='/login' method='POST'&gt;
                   User Name : &lt;input type='text' name='user'/&gt;
                   Password: &lt;input type='password' name='pass' /&gt;

                   &lt;!-- Put the original path requested into a hidden
                              field so it's sent back in the POST and can be
                              used to redirect to the right page after login --&gt;
                   &lt;input type='hidden' name='path' value='&lt;% path %&gt;'/&gt;

                   &lt;input type='submit' value='Login' /&gt;
               &lt;/form&gt;
             &lt;/body&gt;
           &lt;/html&gt;

       Of  course,  you'll  probably  want  to  validate  your  users  against  a  database  table, or maybe via
       IMAP/LDAP/SSH/POP3/local system accounts via PAM etc.  Authen::Simple is probably a good  starting  point
       here!

       A   simple  working  example  of  handling  authentication  against  a  database  table  yourself  (using
       Dancer2::Plugin::Database which provides the "database" keyword, and Crypt::SaltedHash to  handle  salted
       hashed passwords (well, you wouldn't store your users passwords in the clear, would you?)) follows:

           post '/login' =&gt; sub {
               my $user_value = body_parameters-&gt;get('user');
               my $pass_value = body_parameters-&gt;get('pass');

               my $user = database-&gt;quick_select('users',
                   { username =&gt; $user_value }
               );
               if (!$user) {
                   warning "Failed login for unrecognised user $user_value";
                   redirect '/login?failed=1';
               } else {
                   if (Crypt::SaltedHash-&gt;validate($user-&gt;{password}, $pass_value))
                   {
                       debug "Password correct";
                       # Logged in successfully
                       session user =&gt; $user;
                       redirect body_parameters-&gt;get('path') || '/';
                   } else {
                       debug("Login failed - password incorrect for " . $user_value);
                       redirect '/login?failed=1';
                   }
               }
           };

       <u>Retrieve</u> <u>complete</u> <u>hash</u> <u>stored</u> <u>in</u> <u>session</u>

       Get complete hash stored in session:

           my $hash = session;

   <b>Writing</b> <b>a</b> <b>session</b> <b>engine</b>
       In Dancer 2, a session backend consumes the role Dancer2::Core::Role::SessionFactory.

       The following example using the Redis session demonstrates how session engines are written in Dancer 2.

       First thing to do is to create the class for the session engine, we'll name it "Dancer2::Session::Redis":

            package Dancer2::Session::Redis;
            use Moo;
            with 'Dancer2::Core::Role::SessionFactory';

       we  want  our  backend  to  have a handle over a Redis connection.  To do that, we'll create an attribute
       "redis"

            use JSON;
            use Redis;
            use Dancer2::Core::Types; # brings helper for types

            has redis =&gt; (
                is =&gt; 'rw',
                isa =&gt; InstanceOf['Redis'],
                lazy =&gt; 1,
                builder =&gt; '_build_redis',
            );

       The lazy attribute says to Moo that this attribute will be built (initialized) only when called the first
       time. It means that the connection to Redis won't be opened until necessary.

            sub _build_redis {
                my ($self) = @_;
                Redis-&gt;new(
                    server =&gt; $self-&gt;server,
                    password =&gt; $self-&gt;password,
                    encoding =&gt; undef,
                );
            }

       Two more attributes, "server" and "password" need to be created.  We do this  by  defining  them  in  the
       config file. Dancer2 passes anything defined in the config to the engine creation.

            # config.yml
            ...
            engines:
              session:
                Redis:
                  server: foo.mydomain.com
                  password: S3Cr3t

       The  server and password entries are now passed to the constructor of the Redis session engine and can be
       accessed from there.

            has server =&gt; (is =&gt; 'ro', required =&gt; 1);
            has password =&gt; (is =&gt; 'ro');

       Next, we define the subroutine "_retrieve" which will return a session object for a  session  ID  it  has
       passed. Since in this case, sessions are going to be stored in Redis, the session ID will be the key, the
       session the value.  So retrieving is as easy as doing a get and decoding the JSON string returned:

            sub _retrieve {
                my ($self, $session_id) = @_;
                my $json = $self-&gt;redis-&gt;get($session_id);
                my $hash = from_json( $json );
                return bless $hash, 'Dancer2::Core::Session';
            }

       The  "_flush"  method  is  called  by  Dancer when the session needs to be stored in the backend. That is
       actually a write to Redis. The method receives a "Dancer2::Core::Session" object and is supposed to store
       it.

            sub _flush {
                my ($self, $session) = @_;
                my $json = encode_json( { %{ $session } } );
                $self-&gt;redis-&gt;set($session-&gt;id, $json);
            }

       For the "_destroy" method which is supposed to remove a session from the backend, deleting the  key  from
       Redis is enough.

            sub _destroy {
                my ($self, $session_id) = @_;
                $self-&gt;redis-&gt;del($session_id);
            }

       The  "_sessions"  method which is supposed to list all the session IDs currently stored in the backend is
       done by listing all the keys that Redis has.

            sub _sessions {
                my ($self) = @_;
                my @keys = $self-&gt;redis-&gt;keys('*');
                return \@keys;
            }

       The session engine is now ready.

       <u>The</u> <u>Session</u> <u>keyword</u>

       Dancer2 maintains two session layers.

       The first layer, Dancer2::Core::Session provides a session object which represents the  current  session.
       You can read from it as many times as you want, and write to it as many times as you want.

       The  second layer is the session engine (Dancer2::Session::Simple is one example), which is used in order
       to implement the reading and writing from the actual storage. This is read  only  once,  when  a  request
       comes  in  (using a cookie whose value is "dancer.session" by default).  At the end of a request, all the
       data you've written will be flushed to the engine itself, which will do the actual write to  the  storage
       (whether it's in a hash in memory, in Memcache, or in a database).

</pre><h4><b>TEMPLATES</b></h4><pre>
       Returning  plain  content  is all well and good for examples or trivial apps, but soon you'll want to use
       templates to maintain separation between your code and your content. Dancer2 makes this easy.

       Your route handlers can use the template keyword to render templates.

   <b>Views</b>
       In Dancer2, a file which holds a template is called a <u>view</u>.  Views  are  located  in  the  "appdir/views"
       directory.

       You  can change this location by changing the setting 'views'. For instance if your templates are located
       in the 'templates' directory, do the following:

           set views =&gt; path( app-&gt;location , 'templates' );

       By default, the internal template engine Dancer2::Template::Simple is used, but you may want  to  upgrade
       to  Template  Toolkit &lt;<a href="http://www.template-toolkit.org/">http://www.template-toolkit.org/</a>&gt;. If you do so, you have to enable this engine in
       your settings as explained in Dancer2::Template::TemplateToolkit and you'll  also  have  to  install  the
       Template module.

       In  order  to  render  a view, just call the template keyword at the end of the action by giving the view
       name and the HASHREF of tokens to interpolate in the  view  (note  that  for  convenience,  the  request,
       session,  params and vars are automatically accessible in the view, named "request", "session", "params",
       and "vars") - for example:

           hook before =&gt; sub { var time =&gt; scalar(localtime) };

           get '/hello/:name' =&gt; sub {
               my $name = route_parameters-&gt;get('name');
               template 'hello.tt', { name =&gt; $name };
           };

       The template "hello.tt" could contain, for example:

           &lt;p&gt;Hi there, [% name %]!&lt;/p&gt;
           &lt;p&gt;You're using [% request.user_agent %]&lt;/p&gt;
           [% IF session.username %]
               &lt;p&gt;You're logged in as [% session.username %]&lt;/p&gt;
           [% END %]
           It's currently [% vars.time %]

       For a full list of the tokens automatically added  to  your  template  (like  "session",  "request",  and
       "vars", refer to Dancer2::Core::Role::Template).

       By default, views use a <u>.tt</u> extension. This can be overridden by setting the "extension" attribute in the
       template engine configuration:

           set engines =&gt; {
               template =&gt; {
                   template_toolkit =&gt; {
                       extension =&gt; 'foo',
                   },
               },
           };

   <b>Layouts</b>
       A layout is a special view, located in the <u>layouts</u> directory (inside the views directory) which must have
       a token named "content". That token marks the place where to render the action view. This lets you define
       a  global layout for your actions, and have each individual view contain only specific content. This is a
       good thing and helps avoid lots of needless duplication of HTML. :)

       For example, the layout <u>views/layouts/main.tt</u>:

           &lt;html&gt;
               &lt;head&gt;...&lt;/head&gt;
               &lt;body&gt;
               &lt;div id="header"&gt;
               ...
               &lt;/div&gt;

               &lt;div id="content"&gt;
               [% content %]
               &lt;/div&gt;

               &lt;/body&gt;
           &lt;/html&gt;

       You can tell your app which layout to use with "layout: name" in the config file, or within your code:

           set layout =&gt; 'main';

       You can control which layout to use (or whether to use a layout at all) for a  specific  request  without
       altering the layout setting by passing an options hashref as the third param to the template keyword:

           template 'index.tt', {}, { layout =&gt; undef };

       If  your application is not mounted under root ("/"), you can use a "before_template_render" hook instead
       of hardcoding the path into your application for your CSS, images and JavaScript:

           hook before_template_render =&gt; sub {
               my $tokens = shift;
               $tokens-&gt;{uri_base} = request-&gt;base-&gt;path;
           };

       Then in your layout, modify your CSS inclusion as follows:

           &lt;link rel="stylesheet" href="[% uri_base %]/css/style.css" /&gt;

       From now on you can mount your application wherever you want, without any further modification of the CSS
       inclusion.

   <b>Encoding</b>
       If you use Plack and have a Unicode problem with your Dancer2 application, don't forget to check  if  you
       have  set your template engine to use Unicode, and set the default charset to UTF-8. So, if you are using
       template toolkit, your config file will look like this:

           charset: UTF-8
           engines:
             template:
               template_toolkit:
                 ENCODING: utf8

   <b>Default</b> <b>Template</b> <b>Variables</b>
       Every template knows about the following variables, which are provided by  Dancer2::Core::Role::Template.
       Some are similar to the keywords you can use in the Perl part of your Dancer2 application.

       •   <b>perl_version</b>

           Current version of perl, effectively $^V &lt;<a href="http://perldoc.perl.org/perlvar.html">http://perldoc.perl.org/perlvar.html</a>#%24%5eV&gt;.

       •   <b>dancer_version</b>

           Current version of Dancer2, effectively "Dancer2-&gt;VERSION".

       •   <b>settings</b>

           A hash of the application configuration. This is like the config keyword.

       •   <b>request</b>

           The current request object. This is like the request keyword.

       •   <b>params</b>

           A hash reference of all the parameters.

           Currently the equivalent of "$request-&gt;params", and like the params keyword.

       •   <b>vars</b>

           The list of request variables, which is what you would get if you called the vars keyword.

       •   <b>session</b>

           The current session data, if a session exists. This is like the session keyword.

</pre><h4><b>STATIC</b> <b>FILES</b></h4><pre>
   <b>Static</b> <b>Directory</b>
       Static  files are served from the <u>./public</u> directory. You can specify a different location by setting the
       "public_dir" option:

           set public_dir =&gt; path( app-&gt;location , 'static' );

       When you modify default public_dir you have to set "static_handler" option.

           set static_handler =&gt; true;

       Note that the public directory name is not included in the URL. A  file  <u>./public/css/style.css</u>  is  made
       available as &lt;<a href="http://example.com/css/style.css">http://example.com/css/style.css</a>&gt;.

   <b>Static</b> <b>File</b> <b>from</b> <b>a</b> <b>Route</b> <b>Handler</b>
       It's possible for a route handler to send a static file, as follows:

           get '/download/*' =&gt; sub {
               my ($file) = splat;

               send_file $file;
           };

       Or even if you want your index page to be a plain old <u>index.html</u> file, just do:

           get '/' =&gt; sub {
               send_file '/index.html'
           };

</pre><h4><b>FILE</b> <b>UPLOADS</b></h4><pre>
       Files are uploaded in Dancer2 using the class Dancer2::Core::Request::Upload.  The objects are accessible
       within the route handlers using the "upload" keyword:

           post '/upload' =&gt; sub {
               my $upload     = upload('file_input_name');    # upload object
               $upload-&gt;copy_to('Uploads/');
           };

</pre><h4><b>CONFIGURATION</b></h4><pre>
   <b>Configuration</b> <b>and</b> <b>environments</b>
       Configuring  a  Dancer2 application can be done in many ways. The easiest one (and maybe the dirtiest) is
       to put all your settings statements at the top of your script, before calling the dance() method.

       Other ways are possible: for example, you can define all your settings in the  file  "appdir/config.yml".
       For this, you must have installed the YAML module, and of course, write the config file in YAML.

       That's  better  than  the  first  option,  but  it's still not perfect as you can't switch easily from an
       environment to another without rewriting the config file.

       A better solution is to have one <u>config.yml</u> file with default global settings, like the following:

           # appdir/config.yml
           logger: 'file'
           layout: 'main'

       And then write as many environment files as you like in "appdir/environments". That way, the  appropriate
       environment  config  file  will  be loaded according to the running environment (if none is specified, it
       will be 'development').

       You can change the running environment when starting your app using the "plackup"  command's  "--env"  or
       "--E" switch:

           plackup -E production bin/app.psgi

       Altenatively,            you            can            set            the            "DANCER_ENVIRONMENT"
       &lt;https://metacpan.org/pod/Dancer2::Config#DANCER_ENVIRONMENT&gt; environment variable in  the  shell  or  in
       your web server's configuration file.

       Typically, you'll want to set the following values in a development config file:

           # appdir/environments/development.yml
           log: 'debug'
           startup_info: 1
           show_stacktrace:  1

       And in a production one:

           # appdir/environments/production.yml
           log: 'warning'
           startup_info: 0
           show_stacktrace:  0

       Please  note  that you are not limited to writing configuration files in YAML.  Dancer2 supports any file
       format that is supported by Config::Any, such as JSON, XML, INI files, and Apache-style config files. See
       the  Dancer2  configuration  guide   &lt;https://metacpan.org/pod/Dancer2::Config#MANIPULATING-SETTINGS-VIA-
       CONFIGURATION-FILES&gt; for more information.

   <b>Accessing</b> <b>configuration</b> <b>information</b>
       A  Dancer2 application can use the "config" keyword to easily access the settings within its config file,
       for instance:

           get '/appname' =&gt; sub {
               return "This is " . config-&gt;{appname};
           };

       This makes keeping your application's settings all in one place simple and easy - you shouldn't  need  to
       worry about implementing all that yourself. :)

   <b>Settings</b>
       It's possible to change almost every parameter of the application via the settings mechanism.

       A setting is a key/value pair assigned by the keyword <b>set</b>:

           set setting_name =&gt; 'setting_value';

       More  usefully,  settings can be defined in a configuration file.  Environment-specific settings can also
       be defined in environment-specific files (for instance, you do not want  to  show  error  stacktraces  in
       production, and might want extra logging in development).

   <b>Serializers</b>
       When writing a webservice, data serialization/deserialization is a common issue to deal with. Dancer2 can
       automatically handle that for you, via a serializer.

       When  setting  up  a serializer, a new behaviour is authorized for any route handler you define: any non-
       scalar response will be rendered as a serialized string, via the current serializer.

       Here is an example of a route handler that will return a hashref:

           use Dancer2;
           set serializer =&gt; 'JSON';

           get '/user/:id/' =&gt; sub {
               { foo =&gt; 42,
                 number =&gt; 100234,
                 list =&gt; [qw(one two three)],
               }
           };

       Dancer2 will render the response via the current serializer.

       Hence, with the JSON serializer set, the  route  handler  above  would  result  in  a  content  like  the
       following:

           {"number":100234,"foo":42,"list":["one","two","three"]}

       If you send a value which is validated serialized data, but is not in the form a key and value pair (such
       as a serialized string or a JSON array), the data will not be available in "params" but will be available
       in "request-&gt;data".

       The  following  serializers  are  available, be aware they dynamically depend on Perl modules you may not
       have on your system.

       •   <b>JSON</b>

           Requires JSON.

       •   <b>YAML</b>

           Requires YAML,

       •   <b>XML</b>

           Requires XML::Simple.

       •   <b>Mutable</b>

           Will try to find the appropriate serializer using the <b>Content-Type</b>  and  <b>Accept-type</b>  header  of  the
           request.

   <b>Importing</b> <b>using</b> <b>Appname</b>
       An  app  in  Dancer2 uses the class name (defined by the "package" function) to define the App name. Thus
       separating the App to multiple files, actually means creating multiple applications. This means that  any
       engine  defined  in  an  application,  because  the application is a complete separate scope, will not be
       available to a different application:

            package MyApp::User {
                use Dancer2;
                set serializer =&gt; 'JSON';
                get '/view' =&gt; sub {...};
            }

            package MyApp::User::Edit {
                use Dancer2;
                get '/edit' =&gt; sub {...};
            }

       These are two different Dancer2 Apps. They have different scopes, contexts, and thus  different  engines.
       While "MyApp::User" has a serializer defined, "MyApp::User::Edit" will not have that configuration.

       By using the import option "appname", we can ask Dancer2 to extend an App without creating a new one:

            package MyApp::User {
                use Dancer2;
                set serializer =&gt; 'JSON';
                get '/view' =&gt; sub {...};
            }

            package MyApp::User::Edit {
                use Dancer2 appname =&gt; 'MyApp::User'; # extending MyApp::User
                get '/edit' =&gt; sub {...};
            }

       The  import  option  "appname"  allows you to seamlessly extend Dancer2 Apps without creating unnecessary
       additional applications or repeat any definitions.  This allows you to  spread  your  application  routes
       across  multiple  files  and  allow  ease of mind when developing it, and accommodate multiple developers
       working on the same codebase.

            # app.pl
            use MyApp::User;
            use MyApp::User::Edit;

            # single application composed of routes provided in multiple files
            MyApp::User-&gt;to_app;

       This way only one class needs to be loaded while creating an app:

            # app.pl:
            use MyApp::User;
            MyApp::User-&gt;to_app;

</pre><h4><b>LOGGING</b></h4><pre>
   <b>Configuring</b> <b>logging</b>
       It's possible to log messages generated by the application and by Dancer2 itself.

       To start logging, select the logging engine you wish to use with the "logger" setting;  Dancer2  includes
       built-in log engines named "file" and "console", which log to a logfile and to the console respectively.

       To enable logging to a file, add the following to your config file:

           logger: 'file'

       Then you can choose which kind of messages you want to actually log:

           log: 'core'      # will log debug, info, warnings, errors,
                            #   and messages from Dancer2 itself
           log: 'debug'     # will log debug, info, warning and errors
           log: 'info'      # will log info, warning and errors
           log: 'warning'   # will log warning and errors
           log: 'error'     # will log only errors

       If  you're  using  the "file" logging engine, a directory "appdir/logs" will be created and will host one
       logfile per environment. The log message contains the time  it  was  written,  the  PID  of  the  current
       process, the message and the caller information (file and line).

   <b>Logging</b> <b>your</b> <b>own</b> <b>messages</b>
       Just          call          debug          &lt;https://metacpan.org/pod/Dancer2::Manual#debug&gt;,         info
       &lt;https://metacpan.org/pod/Dancer2::Manual#info&gt;,                                                  warning
       &lt;https://metacpan.org/pod/Dancer2::Manual#warning&gt;                        or                        error
       &lt;https://metacpan.org/pod/Dancer2::Manual#error&gt; with your message:

           debug "This is a debug message from my app.";

</pre><h4><b>TESTING</b></h4><pre>
   <b>Using</b> <b>Plack::Test</b>
       Plack::Test receives a common web request (using standard HTTP::Request objects), fakes a web  server  in
       order  to  create  a  proper  PSGI request, and sends it to the web application. When the web application
       returns a PSGI response (which Dancer applications do), it will then convert it to a common web  response
       (as a standard HTTP::Response object).

       This allows you to then create requests in your test, create the code reference for your web application,
       call them, and receive a response object, which can then be tested.

       <u>Basic</u> <u>Example</u>

       Assuming there is a web application:

            # MyApp.pm
            package MyApp;
            use Dancer2;
            get '/' =&gt; sub {'OK'};
            1;

       The following test <u>base.t</u> is created:

            # base.t
            use strict;
            use warnings;
            use Test::More tests =&gt; 2;
            use Plack::Test;
            use HTTP::Request;
            use MyApp;

       Creating a coderef for the application using the "to_app" keyword:

            my $app = MyApp-&gt;to_app;

       Creating a test object from Plack::Test for the application:

            my $test = Plack::Test-&gt;create($app);

       Creating the first request object and sending it to the test object to receive a response:

            my $request  = HTTP::Request-&gt;new( GET =&gt; '/' );
            my $response = $test-&gt;request($request);

       It can now be tested:

            ok( $response-&gt;is_success, '[GET /] Successful request' );
            is( $response-&gt;content, 'OK', '[GET /] Correct content' );

       <u>Putting</u> <u>it</u> <u>together</u>

            # base.t
            use strict;
            use warnings;
            use Test::More;
            use Plack::Test;
            use HTTP::Request::Common;
            use MyApp;

            my $test     = Plack::Test-&gt;create( MyApp-&gt;to_app );
            my $response = $test-&gt;request( GET '/' );

            ok( $response-&gt;is_success, '[GET /] Successful request' );
            is( $response-&gt;content, 'OK', '[GET /] Correct content' );

            done_testing();

       <u>Subtests</u>

       Tests  can be separated using Test::More's "subtest" functionality, thus creating multiple self-contained
       tests that don't overwrite each other.

       Assuming we have a different app that has two states we want to test:

            # MyApp.pm
            package MyApp;
            use Dancer2;
            set serializer =&gt; 'JSON';

            get '/:user' =&gt; sub {
                my $user = route_parameters-&gt;get('user');

                $user and return { user =&gt; $user };

                return {};
            };

            1;

       This is a contrived example of a route that checks for a user parameter. If it exists, it returns it in a
       hash with the key 'user'. If not, it returns an empty hash

            # param.t
            use strict;
            use warnings;
            use Test::More;
            use Plack::Test;
            use HTTP::Request::Common;
            use MyApp;

            my $test = Plack::Test-&gt;create( MyApp-&gt;to_app );

            subtest 'A empty request' =&gt; sub {
                my $res = $test-&gt;request( GET '/' );
                ok( $res-&gt;is_success, 'Successful request' );
                is( $res-&gt;content '{}', 'Empty response back' );
            };

            subtest 'Request with user' =&gt; sub {
                my $res = $test-&gt;request( GET '/?user=sawyer_x' );
                ok( $res-&gt;is_success, 'Successful request' );
                is( $res-&gt;content '{"user":"sawyer_x"}', 'Empty response back' );
            };

            done_testing();

       <u>Cookies</u>

       To handle cookies, which are mostly used for maintaining sessions, the following modules can be used:

       •   Test::WWW::Mechanize::PSGI

       •   LWP::Protocol::PSGI

       •   HTTP::Cookies

       Taking the previous test, assuming it actually creates and uses cookies for sessions:

            # ... all the use statements
            use HTTP::Cookies;

            my $jar  = HTTP::Cookies-&gt;new;
            my $test = Plack::Test-&gt;create( MyApp-&gt;to_app );

            subtest 'A empty request' =&gt; sub {
                my $res = $test-&gt;request( GET '/' );
                ok( $res-&gt;is_success, 'Successful request' );
                is( $res-&gt;content '{}', 'Empty response back' );
                $jar-&gt;extract_cookies($res);
                ok( $jar-&gt;as_string, 'We have cookies!' );
            };

            subtest 'Request with user' =&gt; sub {
                my $req = GET '/?user=sawyer_x';
                $jar-&gt;add_cookie_header($req);
                my $res = $test-&gt;request($req);
                ok( $res-&gt;is_success, 'Successful request' );
                is( $res-&gt;content '{"user":"sawyer_x"}', 'Empty response back' );
                $jar-&gt;extract_cookies($res);

                ok( ! $jar-&gt;as_string, 'All cookies deleted' );
            };

            done_testing();

       Here a cookie jar is created, all requests and responses, existing cookies, as well as cookies that  were
       deleted by the response, are checked.

       <u>Accessing</u> <u>the</u> <u>configuration</u> <u>file</u>

       By  importing  Dancer2  in  the command line scripts, there is full access to the configuration using the
       imported keywords:

            use strict;
            use warnings;
            use Test::More;
            use Plack::Test;
            use HTTP::Request::Common;
            use MyApp;
            use Dancer2;

            my $appname = config-&gt;{'appname'};
            diag "Testing $appname";

            # ...

</pre><h4><b>PACKAGING</b></h4><pre>
   <b>Carton</b>
       <u>What</u> <u>it</u> <u>does</u>

       Carton sets up a local copy of your project prerequisites. You only need to define them in a file and ask
       Carton to download all of them and set them up.  When you want to deploy your app, you just carry the git
       clone and ask Carton to set up the environment again and you will then be able to run it.

       The benefits are multifold:

       •   Local Directory copy

           By putting all the dependencies in a local directory, you  can  make  sure  they  aren't  updated  by
           someone else by accident and their versions locked to the version you picked.

       •   Sync versions

           Deciding  which  versions  of  the  dependent modules your project needs allows you to sync this with
           other developers as well. Now you're all using the same version and they don't change unless you want
           update the versions you want. When updated everyone again uses the same new version of everything.

       •   Carry only the requirement, not bundled modules

           Instead of bundling the modules, you only actually bundle the requirements.  Carton builds  them  for
           you when you need it.

       <u>Setting</u> <u>it</u> <u>up</u>

       First set up a new app:

            $ dancer2 gen -a MyApp
            ...

       Delete the files that are not needed:

            $ rm -f Makefile.PL MANIFEST MANIFEST.SKIP

       Create a git repo:

            $ git init &amp;&amp; git add . &amp;&amp; git commit -m "initial commit"

       Add a requirement using the cpanfile format:

            $ cat &gt; cpanfile
            requires 'Dancer2' =&gt; 0.155000;
            requires 'Template' =&gt; 0;
            recommends 'URL::Encode::XS' =&gt; 0;
            recommends 'CGI::Deurl::XS' =&gt; 0;
            recommends 'HTTP::Parser::XS' =&gt; 0;

       Ask carton to set it up:

            $ carton install
            Installing modules using [...]
            Successfully installed [...]
            ...
            Complete! Modules were install into [...]/local

       Now  we  have two files: <u>cpanfile</u> and <u>cpanfile.snapshot</u>. We add both of them to our Git repository and we
       make sure we don't accidentally add the <u>local/</u> directory  Carton  created  which  holds  the  modules  it
       installed:

            $ echo local/ &gt;&gt; .gitignore
            $ git add .gitignore cpanfile cpanfile.snapshot
            $ git commit -m "Start using carton"

       When we want to update the versions on the production machine, we simply call:

            $ carton install --deployment

       By  using --deployment we make sure we only install the modules we have in our cpanfile.snapshot file and
       do not fallback to querying the CPAN.

   <b>FatPacker</b>
       App::FatPacker (using its command line  interface,  fatpack)  packs  dependencies  into  a  single  file,
       allowing you to carry a single file instead of a directory tree.

       As long as your application is pure-Perl, you could create a single file with your application and all of
       Dancer2 in it.

       The following example will demonstrate how this can be done:

       Assuming we have an application in <u>lib/MyApp.pm</u>:

            package MyApp;
            use Dancer2;
            get '/' =&gt; sub {'OK'};
            1;

       And we have a handler in <u>bin/app.pl</u>:

            use strict;
            use warnings;
            use FindBin;
            use lib "$FindBin::Bin/..<a href="file:/lib">/lib</a>";
            use MyApp;

            MyApp-&gt;to_app;

       To fatpack it, we begin by tracing the script:

            $ fatpack trace bin/app.pl

       This creates a <u>fatpacker.trace</u> file. From this we create the packlists:

            $ fatpack packlists-for `cat fatpacker.trace` &gt; packlists

       The packlists are stored in a file called <u>packlists</u>.

       Now we create the tree using the following command:

            $ fatpack tree `cat packlists`

       The tree is created under the directory <u>fatlib</u>.

       Now  we  create  a  file  containing  the  dependency tree, and add our script to it, using the following
       command:

            $ (fatpack file; cat bin/app.pl) &gt; myapp.pl

       This creates a file called <u>myapp.pl</u> with everything in it. Dancer2 uses MIME::Types which has a  database
       of  all MIME types and helps translate those.  The small database file containing all of these types is a
       binary and therefore cannot be fatpacked. Hence, it needs to be copied to the current  directory  so  our
       script can find it:

            $ cp fatlib/MIME/types.db .

</pre><h4><b>MIDDLEWARES</b></h4><pre>
   <b>Plack</b> <b>middlewares</b>
       If you want to use Plack middlewares, you need to enable them using Plack::Builder as such:

           # in app.psgi or any other handler
           use MyApp;
           use Plack::Builder;

           builder {
               enable 'Deflater';
               enable 'Session', store =&gt; 'File';
               enable 'Debug', panels =&gt; [ qw&lt;DBITrace Memory Timer&gt; ];
               MyApp-&gt;to_app;
           };

       The nice thing about this setup is that it will work seamlessly through Plack or through the internal web
       server.

           # load dev web server (without middlewares)
           perl -Ilib app.psgi

           # load plack web server (with middlewares)
           plackup -I lib app.psgi

       You do not need to provide different files for either server.

       <u>Path-based</u> <u>middlewares</u>

       If  you  want to set up a middleware for a specific path, you can do that using Plack::Builder which uses
       Plack::App::URLMap:

           # in your app.psgi or any other handler
           use MyApp;
           use Plack::Builder;

           my $special_handler = sub { ... };

           builder {
               mount '/special' =&gt; $special_handler;
               mount '/'        =&gt; MyApp-&gt;to_app;
           };

       <u>Removing</u> <u>default</u> <u>middlewares</u>

       By default, a Dancer2 app is automatically wrapped with the following middleware

       •   Plack::Middleware::FixMissingBodyInRedirect

       •   Plack::Middleware::Head

       You can configure the setting "no_default_middleware" to a true value to  stop  your  Dancer2  app  being
       wrapped with these default middleware layers.

           # in you Dancer2 app or config.yml
           package MyApp;
           use Dancer2

           set no_default_middleware =&gt; true;

       This  is  necessary  if  you  need  to  add  eTag  or  ContentMD5 headers to "HEAD" requests, and you are
       encouraged to manually add those default middleware back into your PSGI stack.

       <u>Running</u> <u>on</u> <u>Perl</u> <u>web</u> <u>servers</u> <u>with</u> <u>plackup</u>

       A number of Perl web servers supporting PSGI are available on CPAN:

       •   Starman

           "Starman" is  a  high  performance  web  server,  with  support  for  preforking,  signals,  multiple
           interfaces, graceful restarts and dynamic worker pool configuration.

       •   Twiggy

           "Twiggy" is an "AnyEvent" web server, it's light and fast.

       •   Corona

           "Corona" is a "Coro" based web server.

       To  start  your  application,  just  run  plackup (see Plack and specific servers above for all available
       options):

          $ plackup bin/app.psgi
          $ plackup -E deployment -s Starman --workers=10 -p 5001 -a bin/app.psgi

       As you can see, the scaffolded Perl script for your app can be used as a PSGI startup file.

       Enabling content compression

       Content compression (gzip, deflate) can be easily enabled via a Plack middleware (see "Plack::Middleware"
       in Plack): Plack::Middleware::Deflater.  It's a middleware  to  encode  the  response  body  in  gzip  or
       deflate, based on the "Accept-Encoding" HTTP request header.

       Enable    it    as   you   would   enable   any   Plack   middleware.   First   you   need   to   install
       Plack::Middleware::Deflater, then in the handler (usually <u>app.psgi</u>) edit it  to  use  Plack::Builder,  as
       described above:

           use Dancer2;
           use MyApp;
           use Plack::Builder;

           builder {
               enable 'Deflater';
               MyApp-&gt;to_app;
           };

       To  test if content compression works, trace the HTTP request and response before and after enabling this
       middleware. Among other things, you should notice that the response  is  gzip  or  deflate  encoded,  and
       contains a header "Content-Encoding" set to "gzip" or "deflate".

       <u>Running</u> <u>multiple</u> <u>apps</u> <u>with</u> <u>Plack::Builder</u>

       You can use Plack::Builder to mount multiple Dancer2 applications on a PSGI webserver like Starman.

       Start by creating a simple app.psgi file:

           use OurWiki;  # first app
           use OurForum; # second app
           use Plack::Builder;

           builder {
               mount '/wiki'  =&gt; OurWiki-&gt;to_app;
               mount '/forum' =&gt; OurForum-&gt;to_app;
           };

       and now use Starman

           plackup -a app.psgi -s Starman

       Currently this still demands the same appdir for both (default circumstance) but in a future version this
       will be easier to change while staying very simple to mount.

       <u>Running</u> <u>from</u> <u>Apache</u> <u>with</u> <u>Plack</u>

       You can run your app from Apache using PSGI (Plack), with a config like the following:

           &lt;VirtualHost myapp.example.com&gt;
               ServerName www.myapp.example.com
               ServerAlias myapp.example.com
               DocumentRoot /websites/myapp.example.com

               &lt;Directory /home/myapp/myapp&gt;
                   AllowOverride None
                   Order allow,deny
                   Allow from all
               &lt;/Directory&gt;

               &lt;Location /&gt;
                   SetHandler perl-script
                   PerlResponseHandler Plack::Handler::Apache2
                   PerlSetVar psgi_app /websites/myapp.example.com/app.psgi
               &lt;/Location&gt;

               ErrorLog  /websites/myapp.example.com/logs/error_log
               CustomLog /websites/myapp.example.com/logs/access_log common
           &lt;/VirtualHost&gt;

       To  set  the environment you want to use for your application (production or development), you can set it
       this way:

           &lt;VirtualHost&gt;
               ...
               SetEnv DANCER_ENVIRONMENT "production"
               ...
           &lt;/VirtualHost&gt;

</pre><h4><b>PLUGINS</b></h4><pre>
   <b>Writing</b> <b>a</b> <b>plugin</b>
       See "Writing the plugin" in Dancer2::Plugin for information on how to author a new plugin for Dancer2.

</pre><h4><b>EXPORTS</b></h4><pre>
       By default, "use Dancer2" exports all the DSL keywords and sets up the  webapp  under  the  name  of  the
       current package. The following tags control exports and webapp namespace.

       •   <b>!keyword</b>

           If  you  want to prevent Dancer2 from exporting specific keywords (perhaps you plan to implement them
           yourself in a different way, or they clash with  another  module  you're  loading),  you  can  simply
           exclude them:

               use Test::More;
               use Dancer2 qw(!pass);

           The above would import all keywords as usual, with the exception of "pass".

       •   <b>appname</b>

           A  larger  application  may split its source between several packages to aid maintainability. Dancer2
           will create a separate application for each  package,  each  having  separate  hooks,  config  and/or
           engines.  You  can  force  Dancer2  to collect the route and hooks into a single application with the
           "appname" tag; e.g.

               package MyApp;
               use Dancer2;
               get '/foo' =&gt; sub {...};

               package MyApp::Private;
               use Dancer2 appname =&gt; MyApp;
               get '/bar' =&gt; sub {...};

           The above would add the "bar" route to the MyApp application. Dancer2 will <u>not</u> create an  application
           with the name "MyApp::Private".

       •   <b>:nopragmas</b>

           By default Dancer2 will import three pragmas: strict, warnings, and utf8. If you require control over
           the  imported  pragmas, you can add <b>:nopragmas</b> to the importing flags, in which case Dancer2 will not
           import any pragmas:

               use strict;
               use warnings;
               no warnings 'experimental::smartmatch'; # for example...
               use Dancer2 ':nopragmas'; # do not touch the existing pragmas

           This way importing "Dancer2" does not change the existing pragmas setup you have.

       When you "use Dancer2", you get an "import" method added into the current  package.  This  <b>will</b>  override
       previously declared import methods from other sources, such as Exporter. Dancer2 applications support the
       following tags on import:

       •   <b>with</b>

           The "with" tag allows an app to pass one or more config entries to another app, when it "use"s it.

               package MyApp;
               use Dancer2;

               BEGIN { set session =&gt; 'YAML' };
               use Blog with =&gt; { session =&gt; engine('session') };

           In  this  example,  the  session  engine  is passed to the "Blog" app. That way, anything done in the
           session will be shared between both apps.

           Anything that is defined in the config entry can be passed that way. If we want  to  pass  the  whole
           config object, it can be done like so:

               use SomeApp with =&gt; { %{config()} };

</pre><h4><b>DSL</b> <b>KEYWORDS</b></h4><pre>
       Dancer2  provides you with a DSL (Domain-Specific Language) which makes implementing your web application
       trivial.

       For example, take the following example:

           use Dancer2;

           get '/hello/:name' =&gt; sub {
               my $name = route_parameters-&gt;get('name');
           };
           dance;

       "get" and "route_parameters" are keywords provided by Dancer2.

       See "DSL Keywords manual" in Dancer2::Manual::Keywords for  a  complete  list  of  keywords  provided  by
       Dancer2.

</pre><h4><b>AUTHOR</b></h4><pre>
       Dancer Core Developers

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2024 by Alexis Sukrieh.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.0                                       2024-12-08                               <u>Dancer2::<a href="../man3pm/Manual.3pm.html">Manual</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>