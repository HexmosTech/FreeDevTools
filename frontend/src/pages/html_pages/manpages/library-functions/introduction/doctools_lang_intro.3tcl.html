<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>doctools_lang_intro - doctools language introduction</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       doctools_lang_intro - doctools language introduction

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  document  is  an  informal  introduction  to  version  1 of the doctools markup language based on a
       multitude of examples. After reading this a writer should be ready to understand the  two  parts  of  the
       formal  specification,  i.e. the <u>doctools</u> <u>language</u> <u>syntax</u> specification and the <u>doctools</u> <u>language</u> <u>command</u>
       <u>reference</u>.

   <b>FUNDAMENTALS</b>
       In the broadest terms possible the <u>doctools</u> <u>markup</u> <u>language</u> is  LaTeX-like,  instead  of  like  SGML  and
       similar  languages.  A document written in this language consists primarily of text, with markup commands
       embedded into it.

       Each markup command is a Tcl command surrounded by a matching pair of <b>[</b> and <b>]</b>. Inside of these delimiters
       the usual rules for a Tcl command apply with regard to  word  quotation,  nested  commands,  continuation
       lines, etc. I.e.

                ... [list_begin enumerated] ...

                ... [call [cmd foo] \
                        [arg bar]] ...

                ... [term {complex concept}] ...

                ... [opt "[arg key] [arg value]"] ...

   <b>BASIC</b> <b>STRUCTURE</b>
       The most simple document which can be written in doctools is

                  [manpage_begin NAME SECTION VERSION]
              [see_also doctools_intro]
              [see_also doctools_lang_cmdref]
              [see_also doctools_lang_faq]
              [see_also doctools_lang_syntax]
              [keywords {doctools commands}]
              [keywords {doctools language}]
              [keywords {doctools markup}]
              [keywords {doctools syntax}]
              [keywords markup]
              [keywords {semantic markup}]
                  [description]
                  [vset CATEGORY doctools]
              [include ../common-text/feedback.inc]
              [manpage_end]

       This  also  shows  us  that  all  doctools  documents  are split into two parts, the <u>header</u> and the <u>body</u>.
       Everything coming before [<b>description</b>] belongs to the header, and everything coming after belongs to  the
       body, with the whole document bracketed by the two <b>manpage_*</b> commands. Before and after these opening and
       closing commands we have only <u>whitespace</u>.

       In  the  remainder  of this section we will discuss only the contents of the header, the structure of the
       body will be discussed in the section <b>Text</b> <b>structure</b>.

       The header section can be empty, and otherwise may contain only an arbitrary sequence  of  the  four  so-
       called <u>header</u> commands, plus <u>whitespace</u>. These commands are

       <b>titledesc</b>

       <b>moddesc</b>

       <b>require</b>

       <b>copyright</b>

       They  provide,  through  their  arguments, additional information about the document, like its title, the
       title of the larger group the document belongs to (if applicable), the  requirements  of  the  documented
       packages  (if  applicable),  and  copyright  assignments. All of them can occur multiple times, including
       none, and they can be used in any order.  However for <b>titledesc</b> and <b>moddesc</b> only the last  occurrence  is
       taken.  For  the  other two the specified information is accumulated, in the given order. Regular text is
       not allowed within the header.

       Given the above a less minimal example of a document is

              [manpage_begin NAME SECTION VERSION]
              [<b>copyright</b> <b>{YEAR</b> <b>AUTHOR}</b>]
              [<b>titledesc</b> <b>TITLE</b>]
              [<b>moddesc</b>   <b>MODULE_TITLE</b>]
              [<b>require</b>   <b>PACKAGE</b> <b>VERSION</b>]
              [<b>require</b>   <b>PACKAGE</b>]
              [description]
              [manpage_end]

       Remember that the whitespace is optional. The document

                  [manpage_begin NAME SECTION VERSION]
                  [copyright {YEAR AUTHOR}][titledesc TITLE][moddesc MODULE_TITLE]
                  [require PACKAGE VERSION][require PACKAGE][description]
                  [vset CATEGORY doctools]
              [include ../common-text/feedback.inc]
              [manpage_end]

       has the same meaning as the example before.

       On the other hand, if <u>whitespace</u> is present it consists not only of any sequence of characters containing
       the space character, horizontal and vertical tabs, carriage return,  and  newline,  but  it  may  contain
       comment markup as well, in the form of the <b>comment</b> command.

              [<b>comment</b> <b>{</b> <b>...</b> <b>}</b>]
              [manpage_begin NAME SECTION VERSION]
              [copyright {YEAR AUTHOR}]
              [titledesc TITLE]
              [moddesc   MODULE_TITLE][<b>comment</b> <b>{</b> <b>...</b> <b>}</b>]
              [require   PACKAGE VERSION]
              [require   PACKAGE]
              [description]
              [manpage_end]
              [<b>comment</b> <b>{</b> <b>...</b> <b>}</b>]

   <b>ADVANCED</b> <b>STRUCTURE</b>
       In  the  simple  examples of the last section we fudged a bit regarding the markup actually allowed to be
       used before the <b>manpage_begin</b> command opening the document.

       Instead of only whitespace the two templating commands <b>include</b> and <b>vset</b> are also allowed, to  enable  the
       writer  to  either set and/or import configuration settings relevant to the document. I.e. it is possible
       to write

              [<b>include</b> <b>FILE</b>]
              [<b>vset</b> <b>VAR</b> <b>VALUE</b>]
              [manpage_begin NAME SECTION VERSION]
              [description]
              [manpage_end]

       Even more important, these two commands are allowed anywhere where a markup command is  allowed,  without
       regard for any other structure. I.e. for example in the header as well.

              [manpage_begin NAME SECTION VERSION]
              [<b>include</b> <b>FILE</b>]
              [<b>vset</b> <b>VAR</b> <b>VALUE</b>]
              [description]
              [manpage_end]

       The  only  restriction <b>include</b> has to obey is that the contents of the included file must be valid at the
       place of the inclusion. I.e. a file  included  before  <b>manpage_begin</b>  may  contain  only  the  templating
       commands <b>vset</b> and <b>include</b>, a file included in the header may contain only header commands, etc.

   <b>TEXT</b> <b>STRUCTURE</b>
       The  body  of  the  document  consists  mainly  of  text,  possibly split into sections, subsections, and
       paragraphs, with parts marked up to  highlight  various  semantic  categories  of  text,  and  additional
       structure through the use of examples and (nested) lists.

       This  section explains the high-level structural commands, with everything else deferred to the following
       sections.

       The simplest way of structuring the body is through the introduction of paragraphs. The command for doing
       so is <b>para</b>. Each occurrence of this command closes the previous paragraph  and  automatically  opens  the
       next.  The  first  paragraph is automatically opened at the beginning of the body, by <b>description</b>. In the
       same manner the last paragraph automatically ends at <b>manpage_end</b>.

              [manpage_begin NAME SECTION VERSION]
              [description]
               ...
              [<b>para</b>]
               ...
              [<b>para</b>]
               ...
              [manpage_end]

       Empty paragraphs are ignored.

       A structure coarser than paragraphs are sections, which allow the writer to split a document into larger,
       and labeled, pieces. The command for doing so is <b>section</b>. Each occurrence  of  this  command  closes  the
       previous  section  and  automatically opens the next, including its first paragraph. The first section is
       automatically  opened  at  the  beginning  of  the  body,  by  <b>description</b>  (This  section   is   labeled
       "DESCRIPTION"). In the same manner the last section automatically ends at <b>manpage_end</b>.

       Empty sections are <u>not</u> ignored. We are free to (not) use paragraphs within sections.

              [manpage_begin NAME SECTION VERSION]
              [description]
               ...
              [<b>section</b> <b>{Section</b> <b>A}</b>]
               ...
              [para]
               ...
              [<b>section</b> <b>{Section</b> <b>B}</b>]
               ...
              [manpage_end]

       Between  sections  and  paragraphs  we  have subsections, to split sections.  The command for doing so is
       <b>subsection</b>. Each occurrence of this command closes the previous subsection and  automatically  opens  the
       next,  including  its first paragraph. A subsection is automatically opened at the beginning of the body,
       by <b>description</b>, and  at  the  beginning  of  each  section.  In  the  same  manner  the  last  subsection
       automatically ends at <b>manpage_end</b>.

       Empty subsections are <u>not</u> ignored. We are free to (not) use paragraphs within subsections.

              [manpage_begin NAME SECTION VERSION]
              [description]
               ...
              [section {Section A}]
               ...
              [<b>subsection</b> <b>{Sub</b> <b>1}</b>]
               ...
              [para]
               ...
              [<b>subsection</b> <b>{Sub</b> <b>2}</b>]
               ...
              [section {Section B}]
               ...
              [manpage_end]

   <b>TEXT</b> <b>MARKUP</b>
       Having handled the overall structure a writer can impose on the document we now take a closer at the text
       in a paragraph.

       While  most  often this is just the unadorned content of the document we do have situations where we wish
       to highlight parts of it as some type of thing or other, like command arguments, command names, concepts,
       uris, etc.

       For this we have a series of markup commands which take the text to highlight as their  single  argument.
       It  should be noted that while their predominant use is the highlighting of parts of a paragraph they can
       also be used to mark up the arguments of list item commands, and of other markup commands.

       The commands available to us are

       <b>arg</b>    Its argument is a the name of a command argument.

       <b>class</b>  Its argument is a class name.

       <b>cmd</b>    Its argument is a command name (Tcl command).

       <b>const</b>  Its argument is a constant.

       <b>emph</b>   General, non-semantic emphasis.

       <b>file</b>   Its argument is a filename / path.

       <b>fun</b>    Its argument is a function name.

       <b>method</b> Its argument is a method name

       <b>namespace</b>
              Its argument is namespace name.

       <b>opt</b>    Its argument is some optional syntax element.

       <b>option</b> Its argument is a command line switch / widget option.

       <b>package</b>
              Its argument is a package name.

       <b>sectref</b>
              Its argument is the title of a section or subsection, i.e. a section reference.

       <b>syscmd</b> Its argument is a command name (external, system command).

       <b>term</b>   Its argument is a concept, or general terminology.

       <b>type</b>   Its argument is a type name.

       <b>uri</b>    Its argument is a uniform resource identifier, i.e an external reference. A second argument can be
              used to specify an explicit label for the reference in question.

       <b>usage</b>  The arguments describe the syntax of a Tcl command.

       <b>var</b>    Its argument is a variable.

       <b>widget</b> Its argument is a widget name.

       The example demonstrating the use of text markup  is  an  excerpt  from  the  <u>doctools</u>  <u>language</u>  <u>command</u>
       <u>reference</u>,  with some highlighting added.  It shows their use within a block of text, as the arguments of
       a list item command (<b>call</b>), and our ability to nest them.

                ...
                [call [<b>cmd</b> <b>arg_def</b>] [<b>arg</b> <b>type</b>] [<b>arg</b> <b>name</b>] [<b>opt</b> [<b>arg</b> <b>mode</b>]]]

                Text structure. List element. Argument list. Automatically closes the
                previous list element. Specifies the data-[<b>arg</b> <b>type</b>] of the described
                argument of a command, its [<b>arg</b> <b>name</b>] and its i/o-[<b>arg</b> <b>mode</b>]. The
                latter is optional.
                ...

   <b>ESCAPES</b>
       Beyond the 20 commands for simple markup shown in the previous section we have two more  available  which
       are technically simple markup.  However their function is not the marking up of phrases as specific types
       of  things, but the insertion of characters, namely <b>[</b> and <b>]</b>.  These commands, <b>lb</b> and <b>rb</b> respectively, are
       required because our use of [ and ] to bracket markup commands makes it impossible to directly use [  and
       ] within the text.

       Our  example  of  their  use  are  the  sources of the last sentence in the previous paragraph, with some
       highlighting added.

                ...
                These commands, [cmd lb] and [cmd lb] respectively, are required
                because our use of [<b>lb</b>] and [<b>rb</b>] to bracket markup commands makes it
                impossible to directly use [<b>lb</b>] and [<b>rb</b>] within the text.
                ...

   <b>CROSS-REFERENCES</b>
       The last two commands we have to discuss are for the declaration of cross-references  between  documents,
       explicit and implicit. They are <b>keywords</b> and <b>see_also</b>. Both take an arbitrary number of arguments, all of
       which  have to be plain unmarked text. I.e. it is not allowed to use markup on them. Both commands can be
       used multiple times in a document. If that is done all arguments of all occurrences of one  of  them  are
       put together into a single set.

       <b>keywords</b>
              The arguments of this command are interpreted as keywords describing the document. A processor can
              use  this  information  to  create  an  index  indirectly  linking  the containing document to all
              documents with the same keywords.

       <b>see_also</b>
              The arguments of this command are interpreted as references to other documents.  A  processor  can
              format them as direct links to these documents.

       All  the  cross-reference  commands  can  occur  anywhere  in  the  document  between  <b>manpage_begin</b>  and
       <b>manpage_end</b>. As such the writer can choose whether she wants to have them at the beginning of  the  body,
       or  at its end, maybe near the place a keyword is actually defined by the main content, or considers them
       as meta data which should be in the header, etc.

       Our example shows the sources for the cross-references of this document, with  some  highlighting  added.
       Incidentally they are found at the end of the body.

                ...
                [<b>see_also</b> <b>doctools_intro</b>]
                [<b>see_also</b> <b>doctools_lang_syntax</b>]
                [<b>see_also</b> <b>doctools_lang_cmdref</b>]
                [<b>keywords</b> <b>markup</b> <b>{semantic</b> <b>markup}</b>]
                [<b>keywords</b> <b>{doctools</b> <b>markup}</b> <b>{doctools</b> <b>language}</b>]
                [<b>keywords</b> <b>{doctools</b> <b>syntax}</b> <b>{doctools</b> <b>commands}</b>]
                [manpage_end]

   <b>EXAMPLES</b>
       Where  ever  we  can  write plain text we can write examples too. For simple examples we have the command
       <b>example</b> which takes a single argument, the text of the  argument.  The  example  text  must  not  contain
       markup.  If  we  wish  to  have  markup  within  an  example  we  have  to  use the 2-command combination
       <b>example_begin</b> / <b>example_end</b> instead.

       The first opens an example block, the other closes it, and in between we can write plain text and use all
       the regular text markup commands.  Note that text structure commands are not  allowed.  This  also  means
       that  it  is  not  possible to embed examples and lists within an example.  On the other hand, we <u>can</u> use
       templating commands within example blocks to read their contents from a file (Remember  section  <b>Advanced</b>
       <b>structure</b>).

       The source for the very first example in this document (see section <b>Fundamentals</b>), with some highlighting
       added, is

                [<b>example</b> {
                  ... [list_begin enumerated] ...
                }]

       Using <b>example_begin</b> / <b>example_end</b> this would look like

                [<b>example_begin</b>]
                  ... [list_begin enumerated] ...
                [<b>example_end</b>]

   <b>LISTS</b>
       Where  ever  we  can write plain text we can write lists too. The main commands are <b>list_begin</b> to start a
       list, and <b>list_end</b> to close one. The opening command takes  an  argument  specifying  the  type  of  list
       started it, and this in turn determines which of the eight existing list item commands are allowed within
       the list to start list items.

       After  the  opening command only whitespace is allowed, until the first list item command opens the first
       item of the list. Each item is a regular series of paragraphs and is closed by either the next list  item
       command,  or  the  end of the list. If closed by a list item command this command automatically opens the
       next list item. A consequence of a list item being a series of paragraphs is that all regular text markup
       can be used within a list item, including examples and other lists.

       The list types recognized by <b>list_begin</b> and their associated list item commands are:

       <b>arguments</b>
              (<b>arg_def</b>) This opens an <u>argument</u> <u>(declaration)</u> <u>list</u>. It is a specialized form of a term definition
              list where the term is an argument name, with its type and i/o-mode.

       <b>commands</b>
              (<b>cmd_def</b>) This opens a <u>command</u> <u>(declaration)</u> <u>list</u>. It is a specialized form of a  term  definition
              list where the term is a command name.

       <b>definitions</b>
              (<b>def</b>  and <b>call</b>) This opens a general <u>term</u> <u>definition</u> <u>list</u>. The terms defined by the list items are
              specified through the argument(s) of the list item commands, either general terms,  possibly  with
              markup (<b>def</b>), or Tcl commands with their syntax (<b>call</b>).

       <b>enumerated</b>
              (<b>enum</b>) This opens a general <u>enumerated</u> <u>list</u>.

       <b>itemized</b>
              (<b>item</b>) This opens a general <u>itemized</u> <u>list</u>.

       <b>options</b>
              (<b>opt_def</b>)  This  opens an <u>option</u> <u>(declaration)</u> <u>list</u>. It is a specialized form of a term definition
              list where the term is an option name, possibly with the option's arguments.

       <b>tkoptions</b>
              (<b>tkoption_def</b>) This opens a <u>widget</u> <u>option</u> <u>(declaration)</u> <u>list</u>. It is a specialized form of  a  term
              definition  list  where the term is the name of a configuration option for a widget, with its name
              and class in the option database.

       Our example is the source of the definition list in the previous paragraph, with most of the  content  in
       the middle removed.

                ...
                [<b>list_begin</b> definitions]
                [<b>def</b> [const arg]]

                ([cmd arg_def]) This opens an argument (declaration) list. It is a
                specialized form of a definition list where the term is an argument
                name, with its type and i/o-mode.

                [<b>def</b> [const itemized]]

                ([cmd item])
                This opens a general itemized list.

                ...
                [<b>def</b> [const tkoption]]

                ([cmd tkoption_def]) This opens a widget option (declaration) list. It
                is a specialized form of a definition list where the term is the name
                of a configuration option for a widget, with its name and class in the
                option database.

                [<b>list_end</b>]
                ...

       Note  that  a  list  cannot  begin in one (sub)section and end in another. Differently said, (sub)section
       breaks are not allowed within lists and list items. An example of this <u>illegal</u> construct is

                ...
                [list_begin itemized]
                [item]
                ...
                [<b>section</b> <b>{ILLEGAL</b> <b>WITHIN</b> <b>THE</b> <b>LIST}</b>]
                ...
                [list_end]
                ...

</pre><h4><b>FURTHER</b> <b>READING</b></h4><pre>
       Now that this document has been digested the reader, assumed to be a <u>writer</u> of  documentation  should  be
       fortified enough to be able to understand the formal <u>doctools</u> <u>language</u> <u>syntax</u> specification as well. From
       here  on  out  the  <u>doctools</u> <u>language</u> <u>command</u> <u>reference</u> will also serve as the detailed specification and
       cheat sheet for all available commands and their syntax.

       To be able to validate a document while writing it, it is also recommended to  familiarize  oneself  with
       one  of  the  applications  for the processing and conversion of doctools documents, i.e. either Tcllib's
       easy and simple <b>dtplite</b>, or Tclapps' ultra-configurable <b>dtp</b>.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category  <u>doctools</u>  of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       doctools_intro, doctools_lang_cmdref, doctools_lang_faq, doctools_lang_syntax

</pre><h4><b>KEYWORDS</b></h4><pre>
       doctools commands, doctools language, doctools markup, doctools syntax, markup, semantic markup

</pre><h4><b>CATEGORY</b></h4><pre>
       Documentation tools

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2007 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 1.0                             <u><a href="../man3tcl/doctools_lang_intro.3tcl.html">doctools_lang_intro</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>