<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pt::pegrammar - Introduction to Parsing Expression Grammars</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pt::pegrammar - Introduction to Parsing Expression Grammars

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Are  you lost ?  Do you have trouble understanding this document ?  In that case please read the overview
       provided by the <u>Introduction</u> <u>to</u> <u>Parser</u> <u>Tools</u>. This document is the entrypoint to  the  whole  system  the
       current package is a part of.

       Welcome to the introduction to <u>Parsing</u> <u>Expression</u> <u>Grammar</u>s (short: <u>PEG</u>), the formalism used by the Parser
       Tools.  It is assumed that the reader has a basic knowledge of parsing theory, i.e. <u>Context-Free</u> <u>Grammars</u>
       (short:  <u>CFG</u>),  <u>languages</u>, and associated terms like <u>LL(k)</u>, <u>LR(k)</u>, <u>terminal</u> and <u>nonterminal</u> <u>symbols</u>, etc.
       We do not intend to recapitulate such basic definitions or terms  like  <u>useful</u>,  <u>reachable</u>,  (left/right)
       <u>recursive</u>,  <u>nullable</u>,  first/last/follow  sets, etc.  Please see the <b>References</b> at the end instead if you
       are in need of places and books which provide such background information.

       PEGs are formally very similar to CFGs, with terminal and nonterminal symbols, start  symbol,  and  rules
       defining  the  structure  of  each  nonterminal  symbol.  The main difference lies in the choice(sic!) of
       <u>choice</u> operators. Where CFGs use an <u>unordered</u> <u>choice</u>  to  represent  alternatives  PEGs  use  <u>prioritized</u>
       <u>choice</u>. Which is fancy way of saying that a parser has to try the first alternative first and can try the
       other alternatives if only if it fails for the first, and so on.

       On  the  CFG  side  this gives rise to LL(k) and LR(k) for making the choice <u>deterministic</u> with a bounded
       <u>lookahead</u> of k terminal symbols, where LL is in essence <u>topdown</u> aka <u>recursive</u>  <u>descent</u>  parsing,  and  LR
       <u>bottomup</u> aka <u>shift</u> <u>reduce</u> parsing.

       On  the PEG side we can parse input with recursive descent and <u>backtracking</u> of failed choices, the latter
       of which  amounts  to  unlimited  lookahead.   By  additionally  recording  the  success  or  failure  of
       nonterminals at the specific locations they were tried at and reusing this information after backtracking
       we  can  avoid  the  exponential blowup of running time usually associated with backtracking and keep the
       parsing linear. The memory requirements are of course higher due to this cache, as we are  trading  space
       for time.

       This is the basic concept behind <u>packrat</u> <u>parsers</u>.

       A  limitation  pure PEGs share with LL(k) CFGs is that <u>left-recursive</u> grammars cannot be parsed, with the
       associated recursive descent parser entering an infinite recursion.  This limitation is usually  overcome
       by  extending pure PEGs with explicit operators to specify repetition, zero or more, and one or more, or,
       formally spoken, for the <u>kleene</u> <u>closure</u> and <u>positive</u> <u>kleene</u> <u>closure</u>.  This is what the Parser  Tools  are
       doing.

       Another  extension,  specific  to  Parser Tools, is a set of operators which map more or less directly to
       various character classes built into Tcl, i.e. the classes reachable via <b>string</b> <b>is</b>.

       The remainder of this document consists of the formal definition of PEGs for the mathematically inclined,
       and an appendix listing references to places with more information on PEGs specifically, and  parsing  in
       general.

</pre><h4><b>FORMAL</b> <b>DEFINITION</b></h4><pre>
       For the mathematically inclined, a Parsing Expression Grammar is a 4-tuple (VN,VT,R,eS) where

       •      VN is a set of <u>nonterminal</u> <u>symbols</u>,

       •      VT is a set of <u>terminal</u> <u>symbols</u>,

       •      R is a finite set of rules, where each rule is a pair (A,e), A in VN, and <u>e</u> a <u>parsing</u> <u>expression</u>.

       •      eS is a parsing expression, the <u>start</u> <u>expression</u>.

       Further constraints are

       •      The intersection of VN and VT is empty.

       •      For  all  A  in  VT  exists  exactly  one  pair  (A,e)  in R. In other words, R is a function from
              nonterminal symbols to parsing expressions.

       Parsing expressions are inductively defined via

       •      The empty string (epsilon) is a parsing expression.

       •      A terminal symbol <u>a</u> is a parsing expression.

       •      A nonterminal symbol <u>A</u> is a parsing expression.

       •      <u>e1e2</u> is a parsing expression for parsing expressions <u>e1</u> and <u>2</u>. This is called <u>sequence</u>.

       •      <u>e1</u>/<u>e2</u> is a parsing expression for parsing expressions <u>e1</u> and <u>2</u>. This is called <u>ordered</u> <u>choice</u>.

       •      <u>e</u>* is a parsing expression for parsing expression <u>e</u>. This is called <u>zero-or-more</u> <u>repetitions</u>, also
              known as <u>kleene</u> <u>closure</u>.

       •      <u>e</u>+ is a parsing expression for parsing expression <u>e</u>. This is called <u>one-or-more</u> <u>repetitions</u>,  also
              known as <u>positive</u> <u>kleene</u> <u>closure</u>.

       •      !<u>e</u> is a parsing expression for parsing expression <u>e1</u>. This is called a <u>not</u> <u>lookahead</u> <u>predicate</u>.

       •      &amp;<u>e</u> is a parsing expression for parsing expression <u>e1</u>. This is called an <u>and</u> <u>lookahead</u> <u>predicate</u>.

       PEGs  are  used  to  define  a  grammatical  structure  for streams of symbols over VT. They are a modern
       phrasing of older formalisms  invented  by  Alexander  Birham.  These  formalisms  were  called  TS  (TMG
       recognition  scheme),  and  gTS  (generalized  TS).  Later  they  were  renamed to TPDL (Top-Down Parsing
       Languages) and gTPDL (generalized TPDL).

       They can be easily implemented by recursive descent parsers with backtracking. This makes them  relatives
       of LL(k) Context-Free Grammars.

</pre><h4><b>REFERENCES</b></h4><pre>
       [1]    <u>The</u>       <u>Packrat</u>       <u>Parsing</u>       <u>and</u>       <u>Parsing</u>       <u>Expression</u>       <u>Grammars</u>       <u>Page</u>
              [<a href="http://www.pdos.lcs.mit.edu/~baford/packrat/">http://www.pdos.lcs.mit.edu/~baford/packrat/</a>],  by  Bryan  Ford,   Massachusetts   Institute   of
              Technology. This is the main entry page to PEGs, and their realization through Packrat Parsers.

       [2]    <u><a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar">http://en.wikipedia.org/wiki/Parsing_expression_grammar</a></u> Wikipedia's entry about Parsing Expression
              Grammars.

       [3]    <u>Parsing</u>  <u>Techniques</u>  <u>-</u>  <u>A</u>  <u>Practical</u> <u>Guide</u>  [<a href="http://www.cs.vu.nl/~dick/PTAPG.html">http://www.cs.vu.nl/~dick/PTAPG.html</a>], an online book
              offering a clear, accessible, and thorough discussion of many different  parsing  techniques  with
              their interrelations and applicabilities, including error recovery techniques.

       [4]    <u>Compilers</u>  <u>and</u>  <u>Compiler</u>  <u>Generators</u>  [<a href="http://scifac.ru.ac.za/compilers/">http://scifac.ru.ac.za/compilers/</a>],  an  online  book using
              CoCo/R, a generator for recursive descent parsers.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category <u>pt</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       EBNF,  LL(k),  PEG,  TDPL,  context-free  languages,  expression,  grammar,  matching,  parser,   parsing
       expression,  parsing  expression grammar, push down automaton, recursive descent, state, top-down parsing
       languages, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Parsing and Grammars

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 1.1                                   <u>pt::<a href="../man3tcl/pegrammar.3tcl.html">pegrammar</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>