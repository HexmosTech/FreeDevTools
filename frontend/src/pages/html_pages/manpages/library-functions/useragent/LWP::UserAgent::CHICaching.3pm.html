<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LWP::UserAgent::CHICaching - LWP::UserAgent with caching based on CHI</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblwp-useragent-chicaching-perl">liblwp-useragent-chicaching-perl_0.04-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       LWP::UserAgent::CHICaching - LWP::UserAgent with caching based on CHI

</pre><h4><b>SYNOPSIS</b></h4><pre>
       The usual way of using LWP::UserAgent, really, just pass a "cache" parameter with a CHI object to the
       constructor:

         my $cache = CHI-&gt;new( driver =&gt; 'Memory', global =&gt; 1 );
         my $ua = LWP::UserAgent::CHICaching-&gt;new(cache =&gt; $cache);
         my $res1 = $ua-&gt;get("<a href="http://localhost">http://localhost</a>:3000/?query=DAHUT");

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is YA caching user agent. When the client makes a request to the server, sometimes the response
       should be cached, so that no actual request has to be sent at all, or possibly just a request to validate
       the cache. HTTP 1.1 defines how to do this. This class simply extends LWP::UserAgent with
       LWP::UserAgent::Role::CHICaching (also in this distribution) which is doing the real work to make it
       possible to use the very flexible CHI module to manage such a cache.

       But why? Mainly because I wanted to use CHI facilities, and partly because I wanted to focus on HTTP 1.1
       features.

</pre><h4><b>TODO</b></h4><pre>
       This is an early release, but it supports RFC7234 quite well already. Much work remains though. These are
       the things that I'd like to do:

       •   Enable  smarter  generation of keys, so that semantically identical content can be cached efficiently
           even though they may have different URIs. This can be done in a separate role with the current code.

       •   Support      all      of      RFC7234      &lt;<a href="http://tools.ietf.org/html/rfc7234">http://tools.ietf.org/html/rfc7234</a>&gt;      and      RFC7232
           &lt;<a href="http://tools.ietf.org/html/rfc7232">http://tools.ietf.org/html/rfc7232</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Kjetil Kjernsmo &lt;<a href="mailto:kjetilk@cpan.org">kjetilk@cpan.org</a>&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2015, 2016 by Kjetil Kjernsmo.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTIES</b></h4><pre>
       THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  WITHOUT
       LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

perl v5.34.0                                       2022-05-28                    <u>LWP::UserAgent::<a href="../man3pm/CHICaching.3pm.html">CHICaching</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>