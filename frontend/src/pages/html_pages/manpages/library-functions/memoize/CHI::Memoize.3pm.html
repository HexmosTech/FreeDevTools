<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHI::Memoize - Make functions faster with memoization, via CHI</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libchi-memoize-perl">libchi-memoize-perl_0.07-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CHI::Memoize - Make functions faster with memoization, via CHI

</pre><h4><b>VERSION</b></h4><pre>
       version 0.07

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use CHI::Memoize qw(:all);

           # Straight memoization in memory
           memoize('func');
           memoize('Some::Package::func');

           # Memoize to a file or to memcached
           memoize( 'func', driver =&gt; 'File', root_dir =&gt; '/path/to/cache' );
           memoize( 'func', driver =&gt; 'Memcached', servers =&gt; ["127.0.0.1:11211"] );

           # Expire after one hour
           memoize('func', expires_in =&gt; '1h');

           # Memoize based on the second and third argument to func
           memoize('func', key =&gt; sub { $_[1], $_[2] });

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "`Memoizing' a function makes it faster by trading space for time.  It does this by caching the return
       values of the function in a table.  If you call the function again with the same arguments, "memoize"
       jumps in and gives you the value out of the table, instead of letting the function compute the value all
       over again." -- quoted from the original Memoize

       For a bit of history and motivation, see

           <a href="http://www.openswartz.com/2012/05/06/memoize-revisiting-a-twelve-year-old-api/">http://www.openswartz.com/2012/05/06/memoize-revisiting-a-twelve-year-old-api/</a>

       "CHI::Memoize" provides the same facility as Memoize, but backed by CHI. This means, among other things,
       that you can

       •   specify expiration times (expires_in) and conditions (expire_if)

       •   memoize to different backends, e.g. File, Memcached, DBI, or to multilevel caches

       •   handle arbitrarily complex function arguments (via CHI key serialization)

   <b>FUNCTIONS</b>
       All  of  these  are importable; only "memoize" is imported by default. "use Memoize qw(:all)" will import
       them all as well as the "NO_MEMOIZE" constant.

       memoize ($func, %options)
           Creates a new function wrapped around <u>$func</u> that caches results based on passed arguments.

           <u>$func</u> can be a function name (with or without a package prefix) or  an  anonymous  function.  In  the
           former  case,  the  name is rebound to the new function. In either case a code ref to the new wrapper
           function is returned.

               # Memoize a named function
               memoize('func');
               memoize('Some::Package::func');

               # Memoize an anonymous function
               $anon = memoize($anon);

           By default, the cache key is formed from combining the full function name, the calling  context  ("L"
           or "S"), and all the function arguments with canonical JSON (sorted hash keys). e.g. these calls will
           be memoized together:

               memoized_function({a =&gt; 5, b =&gt; 6, c =&gt; { d =&gt; 7, e =&gt; 8 }});
               memoized_function({b =&gt; 6, c =&gt; { e =&gt; 8, d =&gt; 7 }, a =&gt; 5});

           because  the  two hashes being passed are canonically the same. But these will be memoized separately
           because of context:

                my $scalar = <a href="../man5/memoized_function.5.html">memoized_function</a>(5);
                my @list = <a href="../man5/memoized_function.5.html">memoized_function</a>(5);

           By default, the cache namespace is formed from  the  full  function  name  or  the  stringified  code
           reference.  This allows you to introspect and clear the memoized results for a particular function.

           "memoize" throws an error if <u>$func</u> is already memoized.

           See OPTIONS below for what can go in the options hash.

       memoized ($func)
           Returns a CHI::Memoize::Info object if <u>$func</u> has been memoized, or undef if it has not been memoized.

               # The CHI cache where memoize results are stored
               #
               my $cache = memoized($func)-&gt;cache;
               $cache-&gt;clear;

               # Code references to the original function and to the new wrapped function
               #
               my $orig = memoized($func)-&gt;orig;
               my $wrapped = memoized($func)-&gt;wrapped;

       unmemoize ($func)
           Removes  the  wrapper  around  <u>$func</u>, restoring it to its original unmemoized state.  Also clears the
           memoize cache if possible (not supported by all drivers, particularly memcached). Throws an error  if
           <u>$func</u> has not been memoized.

               memoize('Some::Package::func');
               ...
               unmemoize('Some::Package::func');

   <b>OPTIONS</b>
       The following options can be passed to "memoize".

       key Specifies  a  code reference that takes arguments passed to the function and returns a cache key. The
           key may be returned as a list, list reference or hash reference; it will automatically be  serialized
           to JSON in canonical mode (sorted hash keys).

           For example, this uses the second and third argument to the function as a key:

               memoize('func', key =&gt; sub { @_[1..2] });

           and this is useful for functions that accept a list of key/value pairs:

               # Ignore order of key/value pairs
               memoize('func', key =&gt; sub { %@_ });

           Regardless of what key you specify, it will automatically be prefixed with the full function name and
           the calling context ("L" or "S").

           If the coderef returns "CHI::Memoize::NO_MEMOIZE" (or "NO_MEMOIZE" if you import it), this call won't
           be memoized. This is useful if you have a cache of limited size or if you know certain arguments will
           yield nondeterministic results. e.g.

               memoize('func', key =&gt; sub { $is_worth_caching ? @_ : NO_MEMOIZE });

       set and get options
           You  can  pass  any  of  CHI's  set options (e.g.  expires_in, expires_variance) or get options (e.g.
           expire_if, busy_lock). e.g.

               # Expire after one hour
               memoize('func', expires_in =&gt; '1h');

               # Expire when a particular condition occurs
               memoize('func', expire_if =&gt; sub { ... });

       cache options
           Any remaining options will be passed to the CHI constructor to generate the cache:

               # Store in file instead of memory
               memoize( 'func', driver =&gt; 'File', root_dir =&gt; '/path/to/cache' );

               # Store in memcached instead of memory
               memoize('func', driver =&gt; 'Memcached', servers =&gt; ["127.0.0.1:11211"]);

           Unless specified, the namespace is generated from the full name of the function being memoized.

           You can also specify an existing cache object:

               # Store in memcached instead of memory
               my $cache = CHI-&gt;new(driver =&gt; 'Memcached', servers =&gt; ["127.0.0.1:11211"]);
               memoize('func', cache =&gt; $cache);

</pre><h4><b>CLONED</b> <b>VS</b> <b>RAW</b> <b>REFERENCES</b></h4><pre>
       By default "CHI", and thus "CHI::Memoize", returns a deep clone of the stored value <u>even</u> when caching  in
       memory. e.g. in this code

           # func returns a list reference
           memoize('func');
           my $ref1 = func();
           my $ref2 = func();

       $ref1  and  $ref2  will  be  references  to  two completely different lists which have the same contained
       values. More specifically, the value is serialized by Storable on "set" and deserialized  (hence  cloned)
       on "get".

       The  advantage  here  is  that  it  is safe to modify a reference returned from a memoized function; your
       modifications won't affect the cached value.

           my $ref1 = func();
           push(@$ref1, 3, 4, 5);
           my $ref2 = func();
           # $ref2 does not have 3, 4, 5

       The disadvantage is that it takes extra time to serialize and deserialize the value, and that some values
       like code references may be more difficult to store. And cloning may not be what you want at all, e.g. if
       you are returning objects.

       Alternatively you can use CHI::Driver::RawMemory, which will store raw references the way "Memoize" does.
       Now, however, any modifications to the contents of a returned reference will affect the cached value.

           memoize('func', driver =&gt; 'RawMemory');
           my $ref1 = func();
           push(@$ref1, 3, 4, 5);
           my $ref2 = func();
           # $ref1 eq $ref2
           # $ref2 has 3, 4, 5

</pre><h4><b>CAVEATS</b></h4><pre>
       The caveats of Memoize apply here as well.  To summarize:

       •   Do not memoize a function whose behavior depends on program  state  other  than  its  own  arguments,
           unless you explicitly capture that state in your computed key.

       •   Do not memoize a function with side effects, as the side effects won't happen on a cache hit.

       •   Do  not  memoize  a  very  simple  function,  as  the costs of caching will outweigh the costs of the
           function itself.

</pre><h4><b>KNOWN</b> <b>BUGS</b></h4><pre>
       •   Memoizing a function will affect its call stack and its prototype.

</pre><h4><b>RELATED</b> <b>MODULES</b></h4><pre>
       A number of modules address a subset of the problems addressed by this module, including:

       •   Memoize::Expire - pluggable expiration of memoized values

       •   Memoize::ExpireLRU - provides LRU expiration for Memoize

       •   Memoize::Memcached - use a memcached cache to memoize functions

</pre><h4><b>SUPPORT</b></h4><pre>
       Questions and feedback are welcome, and should be directed to the perl-cache mailing list:

           <a href="http://groups.google.com/group/perl-cache-discuss">http://groups.google.com/group/perl-cache-discuss</a>

       Bugs and feature requests will be tracked at RT:

           <a href="http://rt.cpan.org/NoAuth/Bugs.html">http://rt.cpan.org/NoAuth/Bugs.html</a>?Dist=CHI-Memoize
           <a href="mailto:bug-chi-memoize@rt.cpan.org">bug-chi-memoize@rt.cpan.org</a>

       The latest source code can be browsed and fetched at:

           <a href="http://github.com/jonswar/perl-chi-memoize">http://github.com/jonswar/perl-chi-memoize</a>
           git clone git://github.com/jonswar/perl-chi-memoize.git

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       CHI, Memoize

</pre><h4><b>AUTHOR</b></h4><pre>
       Jonathan Swartz &lt;<a href="mailto:swartz@pobox.com">swartz@pobox.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2011 by Jonathan Swartz.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.28.0                                       2018-10-03                                  <u>CHI::<a href="../man3pm/Memoize.3pm.html">Memoize</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>