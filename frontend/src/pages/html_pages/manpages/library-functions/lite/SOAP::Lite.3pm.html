<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOAP::Lite - Perl's Web Services Toolkit</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsoap-lite-perl">libsoap-lite-perl_1.27-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SOAP::Lite - Perl's Web Services Toolkit

</pre><h4><b>DESCRIPTION</b></h4><pre>
       SOAP::Lite is a collection of Perl modules which provides a simple and lightweight interface to the
       Simple Object Access Protocol (SOAP) both on client and server side.

</pre><h4><b>PERL</b> <b>VERSION</b> <b>WARNING</b></h4><pre>
       As of version SOAP::Lite version 1.05, no perl versions before 5.8 will be supported.

       SOAP::Lite 0.71 will be the last version of SOAP::Lite running on perl 5.005

       Future versions of SOAP::Lite will require at least perl 5.6.0

       If you have not had the time to upgrade your perl, you should consider this now.

</pre><h4><b>OVERVIEW</b> <b>OF</b> <b>CLASSES</b> <b>AND</b> <b>PACKAGES</b></h4><pre>
       <u>lib/SOAP/Lite.pm</u>
           SOAP::Lite - Main class provides all logic

           SOAP::Transport - Transport backend

           SOAP::Data - Data objects

           SOAP::Header - Header Data Objects

           SOAP::Serializer - Serializes data structures to SOAP messages

           SOAP::Deserializer - Deserializes SOAP messages into SOAP::SOM objects

           SOAP::SOM - SOAP Message objects

           SOAP::Constants - Provides access to common constants and defaults

           SOAP::Trace - Tracing facilities

           SOAP::Schema - Provides access and stub(s) for schema(s)

           SOAP::Schema::WSDL - WSDL implementation for SOAP::Schema

           SOAP::Server - Handles requests on server side

           SOAP::Server::Object - Handles objects-by-reference

           SOAP::Fault - Provides support for Faults on server side

           SOAP::Utils - A set of private and public utility subroutines

       <u>lib/SOAP/Packager.pm</u>
           SOAP::Packager - Provides an abstract class for implementing custom packagers.

           SOAP::Packager::MIME - Provides MIME support to SOAP::Lite

           SOAP::Packager::DIME - Provides DIME support to SOAP::Lite

       <u>lib/SOAP/Transport/HTTP.pm</u>
           SOAP::Transport::HTTP::Client - Client interface to HTTP transport

           SOAP::Transport::HTTP::Server - Server interface to HTTP transport

           SOAP::Transport::HTTP::CGI - CGI implementation of server interface

           SOAP::Transport::HTTP::Daemon - Daemon implementation of server interface

           SOAP::Transport::HTTP::Apache - mod_perl implementation of server interface

       <u>lib/SOAP/Transport/POP3.pm</u>
           SOAP::Transport::POP3::Server - Server interface to POP3 protocol

       <u>lib/SOAP/Transport/MAILTO.pm</u>
           SOAP::Transport::MAILTO::Client - Client interface to SMTP/sendmail

       <u>lib/SOAP/Transport/LOCAL.pm</u>
           SOAP::Transport::LOCAL::Client - Client interface to local transport

       <u>lib/SOAP/Transport/TCP.pm</u>
           SOAP::Transport::TCP::Server - Server interface to TCP protocol

           SOAP::Transport::TCP::Client - Client interface to TCP protocol

       <u>lib/SOAP/Transport/IO.pm</u>
           SOAP::Transport::IO::Server - Server interface to IO transport

</pre><h4><b>METHODS</b></h4><pre>
       All  accessor  methods return the current value when called with no arguments, while returning the object
       reference itself when called with a new value.   This  allows  the  set-attribute  calls  to  be  chained
       together.

       new(optional key/value pairs)
               $client = SOAP::Lite-&gt;new(proxy =&gt; $endpoint)

           Constructor.  Many  of  the accessor methods defined here may be initialized at creation by providing
           their name as a key, followed by the desired value.  The example provides the  value  for  the  proxy
           element of the client.

       transport(optional transport object)
               $transp = $client-&gt;transport( );

           Gets or sets the transport object used for sending/receiving SOAP messages.

           See SOAP::Transport for details.

       serializer(optional serializer object)
               $serial = $client-&gt;serializer( )

           Gets or sets the serializer object used for creating XML messages.

           See SOAP::Serializer for details.

       packager(optional packager object)
               $packager = $client-&gt;packager( )

           Provides access to the "SOAP::Packager" object that the client uses to manage the use of attachments.
           The  default  packager  is  a MIME packager, but unless you specify parts to send, no MIME formatting
           will be done.

           See also: SOAP::Packager.

       proxy(endpoint, optional extra arguments)
               $client-&gt;proxy('<a href="http://soap.xml.info/">http://soap.xml.info/</a> endPoint');

           The proxy is the server or endpoint to which the client is going to connect.  This method allows  the
           setting  of  the  endpoint,  along with any extra information that the transport object may need when
           communicating the request.

           This method is actually an alias to the proxy method of SOAP::Transport.  It is the same as typing:

               $client-&gt;transport( )-&gt;proxy(...arguments);

           Extra parameters can be passed to <b>proxy()</b> - see below.

           compress_threshold
               See COMPRESSION in HTTP::Transport.

           All initialization options from the underlying transport layer
               The options for HTTP(S) are the same as for LWP::UserAgent's <b>new()</b> method.

               A common option is to create a instance of HTTP::Cookies and pass it as cookie_jar option:

                my $cookie_jar = HTTP::Cookies-&gt;new()
                $client-&gt;proxy('<a href="http://www.example.org/webservice">http://www.example.org/webservice</a>',
                   cookie_jar =&gt; $cookie_jar,
                );

           For example, if you wish to set the HTTP timeout for a  SOAP::Lite  client  to  5  seconds,  use  the
           following code:

             my $soap = SOAP::Lite
              -&gt;uri($uri)
              -&gt;proxy($proxyUrl, timeout =&gt; 5 );

           See LWP::UserAgent.

       endpoint(optional new endpoint address)
               $client-&gt;endpoint('<a href="http://soap.xml.info/">http://soap.xml.info/</a> newPoint')

           It  may  be preferable to set a new endpoint without the additional work of examining the new address
           for protocol information and checking to ensure the support code is loaded and available. This method
           allows the caller to change the endpoint that the client is currently  set  to  connect  to,  without
           reloading  the  relevant transport code. Note that the proxy method must have been called before this
           method is used.

       service(service URL)
               $client-&gt;service('<a href="http://svc.perl.org/Svc.wsdl">http://svc.perl.org/Svc.wsdl</a>');

           "SOAP::Lite" offers some support for creating method stubs from  service  descriptions.  At  present,
           only  WSDL  support is in place. This method loads the specified WSDL schema and uses it as the basis
           for generating stubs.

       outputxml(boolean)
               $client-&gt;outputxml('true');

           When set to a true value, the raw XML is returned by the call to a remote method.

           The default is to return a SOAP::SOM object (false).

       autotype(boolean)
               $client-&gt;<a href="../man0/autotype.0.html">autotype</a>(0);

           This method is a shortcut for:

               $client-&gt;serializer-&gt;autotype(boolean);

           By default, the serializer tries to automatically deduce types for the data being sent in a  message.
           Setting a false value with this method disables the behavior.

       readable(boolean)
               $client-&gt;<a href="../man1/readable.1.html">readable</a>(1);

           This method is a shortcut for:

               $client-&gt;serializer-&gt;readable(boolean);

           When  this  is used to set a true value for this property, the generated XML sent to the endpoint has
           extra characters (spaces and new lines) added in to make the XML itself more readable to  human  eyes
           (presumably for debugging).  The default is to not send any additional characters.

       headerattr(hash reference of attributes)
               $obj-&gt;headerattr({ attr1 =&gt; 'value' });

           Allows  for  the  setting  of arbitrary attributes on the header object. Keep in mind the requirement
           that
            any attributes not natively known to SOAP must  be  namespace-qualified.   If  using  $session-&gt;call
           ($method, $callData, $callHeader), SOAP::Lite serializes information as

             &lt;soap:Envelope&gt;
               &lt;soap:Header&gt;
                 &lt;userId&gt;xxxxx&lt;/userId&gt;
                 &lt;password&gt;yyyyy&lt;/password&gt;
               &lt;/soap:Header&gt;
               &lt;soap:Body&gt;
                 &lt;myMethod xmlns="<a href="http://www.someuri.com">http://www.someuri.com</a>"&gt;
                   &lt;foo /&gt;
                 &lt;/myMethod&gt;
               &lt;/soap:Body&gt;
             &lt;/soap:Envelope&gt;

           The attributes, given to headerattr are placed into the Header as

               &lt;soap:Header attr1="value"&gt;

       bodyattr(hash reference of attributes)
               $obj-&gt;bodyattr({ attr1 =&gt; 'value' });

           Allows for the setting of arbitrary attributes on the body object. Keep in mind the requirement that
            any attributes not natively known to SOAP must be namespace-qualified.  See headerattr

       default_ns($uri)
           Sets  the  default  namespace  for  the  request  to  the  specified uri. This overrides any previous
           namespace declaration that may have been set using a  previous  call  to  "ns()"  or  "default_ns()".
           Setting the default namespace causes elements to be serialized without a namespace prefix, like this:

             &lt;soap:Envelope&gt;
               &lt;soap:Body&gt;
                 &lt;myMethod xmlns="<a href="http://www.someuri.com">http://www.someuri.com</a>"&gt;
                   &lt;foo /&gt;
                 &lt;/myMethod&gt;
               &lt;/soap:Body&gt;
             &lt;/soap:Envelope&gt;

           Some .NET web services have been reported to require this XML namespace idiom.

       ns($uri,$prefix=undef)
           Sets  the  namespace uri and optionally the namespace prefix for the request to the specified values.
           This overrides any previous namespace declaration that may have been set using  a  previous  call  to
           "ns()" or "default_ns()".

           If  a  prefix  is  not specified, one will be generated for you automatically.  Setting the namespace
           causes elements to be serialized with a declared namespace prefix, like this:

             &lt;soap:Envelope&gt;
               &lt;soap:Body&gt;
                 &lt;my:myMethod xmlns:my="<a href="http://www.someuri.com">http://www.someuri.com</a>"&gt;
                   &lt;my:foo /&gt;
                 &lt;/my:myMethod&gt;
               &lt;/soap:Body&gt;
             &lt;/soap:Envelope&gt;

       use_prefix(boolean)
           Deprecated. Use the "ns()" and "default_ns" methods described above.

           Shortcut for "serializer-&gt;use_prefix()". This lets you turn on/off the use of a namespace prefix  for
           the children of the /Envelope/Body element.  Default is 'true'.

           When use_prefix is set to 'true', serialized XML will look like this:

             &lt;SOAP-ENV:Envelope ...attributes skipped&gt;
               &lt;SOAP-ENV:Body&gt;
                 &lt;namesp1:mymethod xmlns:namesp1="urn:MyURI" /&gt;
               &lt;/SOAP-ENV:Body&gt;
             &lt;/SOAP-ENV:Envelope&gt;

           When use_prefix is set to 'false', serialized XML will look like this:

             &lt;SOAP-ENV:Envelope ...attributes skipped&gt;
               &lt;SOAP-ENV:Body&gt;
                 &lt;mymethod xmlns="urn:MyURI" /&gt;
               &lt;/SOAP-ENV:Body&gt;
             &lt;/SOAP-ENV:Envelope&gt;

           Some .NET web services have been reported to require this XML namespace idiom.

       soapversion(optional value)
               $client-&gt;soapversion('1.2');

           If no parameter is given, returns the current version of SOAP that is being used by the client object
           to  encode  requests. If a parameter is given, the method attempts to set that as the version of SOAP
           being used.

           The value should be either 1.1 or 1.2.

       envprefix(QName)
               $client-&gt;envprefix('env');

           This method is a shortcut for:

               $client-&gt;serializer-&gt;envprefix(QName);

           Gets or sets the namespace prefix for the SOAP namespace. The default is SOAP.

           The prefix itself has no meaning, but applications  may  wish  to  chose  one  explicitly  to  denote
           different versions of SOAP or the like.

       encprefix(QName)
               $client-&gt;encprefix('enc');

           This method is a shortcut for:

               $client-&gt;serializer-&gt;encprefix(QName);

           Gets or sets the namespace prefix for the encoding rules namespace.  The default value is SOAP-ENC.

       While  it may seem to be an unnecessary operation to set a value that isn't relevant to the message, such
       as the namespace labels for the envelope and encoding URNs, the ability to set  these  labels  explicitly
       can prove to be a great aid in distinguishing and debugging messages on the server side of operations.

       encoding(encoding URN)
               $client-&gt;encoding($soap_12_encoding_URN);

           This method is a shortcut for:

               $client-&gt;serializer-&gt;encoding(args);

           Where  the  earlier  method dealt with the label used for the attributes related to the SOAP encoding
           scheme, this method actually sets the URN to be specified as the encoding scheme for the message. The
           default is to specify the encoding for SOAP 1.1, so this is  handy  for  applications  that  need  to
           encode according to SOAP 1.2 rules.

       typelookup
               $client-&gt;typelookup;

           This method is a shortcut for:

               $client-&gt;serializer-&gt;typelookup;

           Gives  the application access to the type-lookup table from the serializer object. See the section on
           SOAP::Serializer.

       uri(service specifier)
           Deprecated - the "uri" subroutine is deprecated in order to provide a more  intuitive  naming  scheme
           for  subroutines that set namespaces. In the future, you will be required to use either the "ns()" or
           "default_ns()" subroutines instead of "uri()".

               $client-&gt;uri($service_uri);

           This method is a shortcut for:

               $client-&gt;serializer-&gt;uri(service);

           The URI associated with this accessor on a client object is the service-specifier  for  the  request,
           often  encoded  for HTTP-based requests as the SOAPAction header. While the names may seem confusing,
           this method doesn't specify the endpoint itself. In most  circumstances,  the  "uri"  refers  to  the
           namespace used for the request.

           Often  times,  the  value  may  look  like  a valid URL. Despite this, it doesn't have to point to an
           existing resource (and often doesn't). This method sets and retrieves this  value  from  the  object.
           Note  that no transport code is triggered by this because it has no direct effect on the transport of
           the object.

       multirefinplace(boolean)
               $client-&gt;<a href="../man1/multirefinplace.1.html">multirefinplace</a>(1);

           This method is a shortcut for:

               $client-&gt;serializer-&gt;multirefinplace(boolean);

           Controls how the serializer handles values  that  have  multiple  references  to  them.  Recall  from
           previous  SOAP  chapters  that  a value may be tagged with an identifier, then referred to in several
           places. When this is the case for a value, the  serializer  defaults  to  putting  the  data  element
           towards  the  top  of  the  message,  right  after the opening tag of the method-specification. It is
           serialized as a standalone entity with an ID that is then referenced at the relevant places later on.
           If this method is used to set a true value, the  behavior  is  different.  When  the  multirefinplace
           attribute  is  true,  the  data is serialized at the first place that references it, rather than as a
           separate element higher up in the body. This is more compact but may be harder to read or trace in  a
           debugging environment.

       parts( ARRAY )
           Used  to  specify  an  array  of  MIME::Entity's  to  be  attached  to  the transmitted SOAP message.
           Attachments that are returned in a response can be accessed by "SOAP::SOM::parts()".

       self
               $ref = SOAP::Lite-&gt;self;

           Returns an object reference to the default global object the "SOAP::Lite" package maintains. This  is
           the object that processes many of the arguments when provided on the use line.

       The  following  method  isn't  an  accessor  style  of method but neither does it fit with the group that
       immediately follows it:

       call(arguments)
               $client-&gt;call($method =&gt; @arguments);

           As has been illustrated in previous chapters, the "SOAP::Lite" client objects can manage remote calls
           with auto-dispatching using some of Perl's more elaborate features. call is used when the application
           wants a greater degree of control over the details of the call itself. The method  may  be  built  up
           from  a SOAP::Data object, so as to allow full control over the namespace associated with the tag, as
           well as other attributes like encoding. This is also  important  for  calling  methods  that  contain
           characters not allowable in Perl function names, such as A.B.C.

       The next four methods used in the "SOAP::Lite" class are geared towards handling the types of events than
       can occur during the message lifecycle. Each of these sets up a callback for the event in question:

       on_action(callback)
               $client-&gt;on_action(sub { qq("$_[0]") });

           Triggered when the transport object sets up the SOAPAction header for an HTTP-based call. The default
           is  to  set  the  header  to  the string, uri#method, in which URI is the value set by the uri method
           described earlier, and method is the name of the  method  being  called.  When  called,  the  routine
           referenced  (or  the closure, if specified as in the example) is given two arguments, uri and method,
           in that order.

           .NET web services usually expect "/" as separator for "uri" and  "method".   To  change  SOAP::Lite's
           behaviour to use uri/method as SOAPAction header, use the following code:

               $client-&gt;on_action( sub { join '/', @_ } );

       on_fault(callback)
               $client-&gt;on_fault(sub { popup_dialog($_[1]) });

           Triggered  when  a  method  call results in a fault response from the server.  When it is called, the
           argument list is first the client object itself, followed by the object that encapsulates the  fault.
           In the example, the fault object is passed (without the client object) to a hypothetical GUI function
           that  presents  an  error  dialog  with the text of fault extracted from the object (which is covered
           shortly under the SOAP::SOM methods).

       on_nonserialized(callback)
               $client-&gt;on_nonserialized(sub { die "$_[0]?!?" });

           Occasionally, the serializer may be given data it can't turn into SOAP-savvy XML; for example,  if  a
           program bug results in a code reference or something similar being passed in as a parameter to method
           call.  When  that  happens,  this callback is activated, with one argument. That argument is the data
           item that could not be understood. It will be the only argument. If the routine returns,  the  return
           value  is  pasted  into  the  message as the serialization. Generally, an error is in order, and this
           callback allows for control over signaling that error.

       on_debug(callback)
               $client-&gt;on_debug(sub { print @_ });

           Deprecated. Use the global +debug and +trace facilities described in SOAP::Trace

           Note that this method will not work as expected: Instead of affecting the debugging behaviour of  the
           object called on, it will globally affect the debugging behaviour for all objects of that class.

</pre><h4><b>WRITING</b> <b>A</b> <b>SOAP</b> <b>CLIENT</b></h4><pre>
       This chapter guides you to writing a SOAP client by example.

       The  SOAP  service to be accessed is a simple variation of the well-known hello world program. It accepts
       two parameters, a name and a given name, and returns "Hello $given_name $name".

       We will use "Martin Kutter" as the name for the call, so all variants will print the following message on
       success:

        Hello Martin Kutter!

   <b>SOAP</b> <b>message</b> <b>styles</b>
       There are three common (and one less common) variants of SOAP messages.

       These address the message style (positional parameters vs. specified message documents) and encoding (as-
       is vs. typed).

       The different message styles are:

       •   rpc/encoded

           Typed, positional parameters. Widely used in scripting languages.   The  type  of  the  arguments  is
           included in the message.  Arrays and the like may be encoded using SOAP encoding rules (or others).

       •   rpc/literal

           As-is,  positional  parameters.  The  type  of  arguments  is defined by some pre-exchanged interface
           definition.

       •   document/encoded

           Specified message with typed elements. Rarely used.

       •   document/literal

           Specified message with as-is elements. The message specification and element  types  are  defined  by
           some pre-exchanged interface definition.

       As of 2008, document/literal has become the predominant SOAP message variant. rpc/literal and rpc/encoded
       are still in use, mainly with scripting languages, while document/encoded is hardly used at all.

       You will see clients for the rpc/encoded and document/literal SOAP variants in this section.

   <b>Example</b> <b>implementations</b>
       <u>RPC/ENCODED</u>

       Rpc/encoded is most popular with scripting languages like perl, php and python without the use of a WSDL.
       Usual method descriptions look like this:

        Method: sayHello(string, string)
        Parameters:
           name: string
           givenName: string

       Such  a  description  usually  means  that  you  can  call  a method named "sayHello" with two positional
       parameters, "name" and "givenName", which both are strings.

       The message corresponding to this description looks somewhat like this:

        &lt;sayHello xmlns="urn:HelloWorld"&gt;
          &lt;s-gensym01 xsi:type="xsd:string"&gt;Kutter&lt;/s-gensym01&gt;
          &lt;s-gensym02 xsi:type="xsd:string"&gt;Martin&lt;/s-gensym02&gt;
        &lt;/sayHello&gt;

       Any XML tag names may be used instead of the "s-gensym01" stuff -  parameters  are  positional,  the  tag
       names have no meaning.

       A client producing such a call is implemented like this:

        use SOAP::Lite;
        my $soap = SOAP::Lite-&gt;new( proxy =&gt; '<a href="http://localhost">http://localhost</a>:81/soap-wsdl-test/helloworld.pl');
        $soap-&gt;default_ns('urn:HelloWorld');
        my $som = $soap-&gt;call('sayHello', 'Kutter', 'Martin');
        die $som-&gt;faultstring if ($som-&gt;fault);
        print $som-&gt;result, "\n";

       You can of course use a one-liner, too...

       Sometimes,  rpc/encoded  interfaces  are  described  with  WSDL  definitions.   A  WSDL accepting "named"
       parameters with rpc/encoded looks like this:

        &lt;definitions xmlns:soap="<a href="http://schemas.xmlsoap.org/wsdl/soap/">http://schemas.xmlsoap.org/wsdl/soap/</a>"
          xmlns:s="<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a>"
          xmlns:s0="urn:HelloWorld"
          targetNamespace="urn:HelloWorld"
          xmlns="<a href="http://schemas.xmlsoap.org/wsdl/">http://schemas.xmlsoap.org/wsdl/</a>"&gt;
          &lt;types&gt;
            &lt;s:schema targetNamespace="urn:HelloWorld"&gt;
            &lt;/s:schema&gt;
          &lt;/types&gt;
          &lt;message name="sayHello"&gt;
            &lt;part name="name" type="s:string" /&gt;
            &lt;part name="givenName" type="s:string" /&gt;
          &lt;/message&gt;
          &lt;message name="sayHelloResponse"&gt;
            &lt;part name="sayHelloResult" type="s:string" /&gt;
          &lt;/message&gt;

          &lt;portType name="Service1Soap"&gt;
            &lt;operation name="sayHello"&gt;
              &lt;input message="s0:sayHello" /&gt;
              &lt;output message="s0:sayHelloResponse" /&gt;
            &lt;/operation&gt;
          &lt;/portType&gt;

          &lt;binding name="Service1Soap" type="s0:Service1Soap"&gt;
            &lt;soap:binding transport="<a href="http://schemas.xmlsoap.org/soap/http">http://schemas.xmlsoap.org/soap/http</a>"
                style="rpc" /&gt;
            &lt;operation name="sayHello"&gt;
              &lt;soap:operation soapAction="urn:HelloWorld#sayHello"/&gt;
              &lt;input&gt;
                &lt;soap:body use="encoded"
                  encodingStyle="<a href="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</a>"/&gt;
              &lt;/input&gt;
              &lt;output&gt;
                &lt;soap:body use="encoded"
                  encodingStyle="<a href="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</a>"/&gt;
              &lt;/output&gt;
            &lt;/operation&gt;
          &lt;/binding&gt;
          &lt;service name="HelloWorld"&gt;
            &lt;port name="HelloWorldSoap" binding="s0:Service1Soap"&gt;
              &lt;soap:address location="<a href="http://localhost">http://localhost</a>:81/soap-wsdl-test/helloworld.pl" /&gt;
            &lt;/port&gt;
          &lt;/service&gt;
        &lt;/definitions&gt;

       The message corresponding to this schema looks like this:

        &lt;sayHello xmlns="urn:HelloWorld"&gt;
          &lt;name xsi:type="xsd:string"&gt;Kutter&lt;/name&gt;
          &lt;givenName xsi:type="xsd:string"&gt;Martin&lt;/givenName&gt;
        &lt;/sayHello&gt;

       A web service client using this schema looks like this:

        use SOAP::Lite;
        my $soap = SOAP::Lite-&gt;service("file:say_hello_rpcenc.wsdl");
        eval { my $result = $soap-&gt;sayHello('Kutter', 'Martin'); };
        if ($@) {
            die $@;
        }
        print $som-&gt;result();

       You may of course also use the following one-liner:

        perl -MSOAP::Lite -e 'print SOAP::Lite-&gt;service("file:say_hello_rpcenc.wsdl")\
          -&gt;sayHello('Kutter', 'Martin'), "\n";'

       A web service client (without a service description) looks like this.

        use SOAP::Lite;
        my $soap = SOAP::Lite-&gt;new( proxy =&gt; '<a href="http://localhost">http://localhost</a>:81/soap-wsdl-test/helloworld.pl');
        $soap-&gt;default_ns('urn:HelloWorld');
        my $som = $soap-&gt;call('sayHello',
           SOAP::Data-&gt;name('name')-&gt;value('Kutter'),
           SOAP::Data-&gt;name('givenName')-&gt;value('Martin')
        );
        die $som-&gt;faultstring if ($som-&gt;fault);
        print $som-&gt;result, "\n";

       <u>RPC/LITERAL</u>

       SOAP web services using the document/literal message encoding are usually described by some  Web  Service
       Definition. Our web service has the following WSDL description:

        &lt;definitions xmlns:soap="<a href="http://schemas.xmlsoap.org/wsdl/soap/">http://schemas.xmlsoap.org/wsdl/soap/</a>"
          xmlns:s="<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a>"
          xmlns:s0="urn:HelloWorld"
          targetNamespace="urn:HelloWorld"
          xmlns="<a href="http://schemas.xmlsoap.org/wsdl/">http://schemas.xmlsoap.org/wsdl/</a>"&gt;
          &lt;types&gt;
            &lt;s:schema targetNamespace="urn:HelloWorld"&gt;
              &lt;s:complexType name="sayHello"&gt;
                &lt;s:sequence&gt;
                  &lt;s:element minOccurs="0" maxOccurs="1" name="name"
                     type="s:string" /&gt;
                  &lt;s:element minOccurs="0" maxOccurs="1" name="givenName"
                     type="s:string" nillable="1" /&gt;
                &lt;/s:sequence&gt;
              &lt;/s:complexType&gt;

              &lt;s:complexType name="sayHelloResponse"&gt;
                &lt;s:sequence&gt;
                  &lt;s:element minOccurs="0" maxOccurs="1" name="sayHelloResult"
                     type="s:string" /&gt;
                &lt;/s:sequence&gt;
              &lt;/s:complexType&gt;
            &lt;/s:schema&gt;
          &lt;/types&gt;
          &lt;message name="sayHello"&gt;
            &lt;part name="parameters" type="s0:sayHello" /&gt;
          &lt;/message&gt;
          &lt;message name="sayHelloResponse"&gt;
            &lt;part name="parameters" type="s0:sayHelloResponse" /&gt;
          &lt;/message&gt;

          &lt;portType name="Service1Soap"&gt;
            &lt;operation name="sayHello"&gt;
              &lt;input message="s0:sayHello" /&gt;
              &lt;output message="s0:sayHelloResponse" /&gt;
            &lt;/operation&gt;
          &lt;/portType&gt;

          &lt;binding name="Service1Soap" type="s0:Service1Soap"&gt;
            &lt;soap:binding transport="<a href="http://schemas.xmlsoap.org/soap/http">http://schemas.xmlsoap.org/soap/http</a>"
                style="rpc" /&gt;
            &lt;operation name="sayHello"&gt;
              &lt;soap:operation soapAction="urn:HelloWorld#sayHello"/&gt;
              &lt;input&gt;
                &lt;soap:body use="literal" namespace="urn:HelloWorld"/&gt;
              &lt;/input&gt;
              &lt;output&gt;
                &lt;soap:body use="literal" namespace="urn:HelloWorld"/&gt;
              &lt;/output&gt;
            &lt;/operation&gt;
          &lt;/binding&gt;
          &lt;service name="HelloWorld"&gt;
            &lt;port name="HelloWorldSoap" binding="s0:Service1Soap"&gt;
              &lt;soap:address location="<a href="http://localhost">http://localhost</a>:80//helloworld.pl" /&gt;
            &lt;/port&gt;
          &lt;/service&gt;
         &lt;/definitions&gt;

       The XML message (inside the SOAP Envelope) look like this:

        &lt;ns0:sayHello xmlns:ns0="urn:HelloWorld"&gt;
           &lt;parameters&gt;
             &lt;name&gt;Kutter&lt;/name&gt;
             &lt;givenName&gt;Martin&lt;/givenName&gt;
           &lt;/parameters&gt;
        &lt;/ns0:sayHello&gt;

        &lt;sayHelloResponse xmlns:ns0="urn:HelloWorld"&gt;
           &lt;parameters&gt;
               &lt;sayHelloResult&gt;Hello Martin Kutter!&lt;/sayHelloResult&gt;
           &lt;/parameters&gt;
        &lt;/sayHelloResponse&gt;

       This is the SOAP::Lite implementation for the web service client:

        use SOAP::Lite +trace;
        my $soap = SOAP::Lite-&gt;new( proxy =&gt; '<a href="http://localhost">http://localhost</a>:80/helloworld.pl');

        $soap-&gt;on_action( sub { "urn:HelloWorld#sayHello" });
        $soap-&gt;<a href="../man0/autotype.0.html">autotype</a>(0)-&gt;<a href="../man1/readable.1.html">readable</a>(1);
        $soap-&gt;default_ns('urn:HelloWorld');

        my $som = $soap-&gt;call('sayHello', SOAP::Data-&gt;name('parameters')-&gt;value(
           \SOAP::Data-&gt;value([
               SOAP::Data-&gt;name('name')-&gt;value( 'Kutter' ),
               SOAP::Data-&gt;name('givenName')-&gt;value('Martin'),
           ]))
       );

        die $som-&gt;fault-&gt;{ faultstring } if ($som-&gt;fault);
        print $som-&gt;result, "\n";

       <u>DOCUMENT/LITERAL</u>

       SOAP  web  services using the document/literal message encoding are usually described by some Web Service
       Definition. Our web service has the following WSDL description:

        &lt;definitions xmlns:soap="<a href="http://schemas.xmlsoap.org/wsdl/soap/">http://schemas.xmlsoap.org/wsdl/soap/</a>"
           xmlns:s="<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a>"
           xmlns:s0="urn:HelloWorld"
           targetNamespace="urn:HelloWorld"
           xmlns="<a href="http://schemas.xmlsoap.org/wsdl/">http://schemas.xmlsoap.org/wsdl/</a>"&gt;
          &lt;types&gt;
            &lt;s:schema targetNamespace="urn:HelloWorld"&gt;
              &lt;s:element name="sayHello"&gt;
                &lt;s:complexType&gt;
                  &lt;s:sequence&gt;
                     &lt;s:element minOccurs="0" maxOccurs="1" name="name" type="s:string" /&gt;
                      &lt;s:element minOccurs="0" maxOccurs="1" name="givenName" type="s:string" nillable="1" /&gt;
                  &lt;/s:sequence&gt;
                 &lt;/s:complexType&gt;
               &lt;/s:element&gt;

               &lt;s:element name="sayHelloResponse"&gt;
                 &lt;s:complexType&gt;
                   &lt;s:sequence&gt;
                     &lt;s:element minOccurs="0" maxOccurs="1" name="sayHelloResult" type="s:string" /&gt;
                   &lt;/s:sequence&gt;
               &lt;/s:complexType&gt;
             &lt;/s:element&gt;
           &lt;/types&gt;
           &lt;message name="sayHelloSoapIn"&gt;
             &lt;part name="parameters" element="s0:sayHello" /&gt;
           &lt;/message&gt;
           &lt;message name="sayHelloSoapOut"&gt;
             &lt;part name="parameters" element="s0:sayHelloResponse" /&gt;
           &lt;/message&gt;

           &lt;portType name="Service1Soap"&gt;
             &lt;operation name="sayHello"&gt;
               &lt;input message="s0:sayHelloSoapIn" /&gt;
               &lt;output message="s0:sayHelloSoapOut" /&gt;
             &lt;/operation&gt;
           &lt;/portType&gt;

           &lt;binding name="Service1Soap" type="s0:Service1Soap"&gt;
             &lt;soap:binding transport="<a href="http://schemas.xmlsoap.org/soap/http">http://schemas.xmlsoap.org/soap/http</a>"
                 style="document" /&gt;
             &lt;operation name="sayHello"&gt;
               &lt;soap:operation soapAction="urn:HelloWorld#sayHello"/&gt;
               &lt;input&gt;
                 &lt;soap:body use="literal" /&gt;
               &lt;/input&gt;
               &lt;output&gt;
                 &lt;soap:body use="literal" /&gt;
               &lt;/output&gt;
             &lt;/operation&gt;
           &lt;/binding&gt;
           &lt;service name="HelloWorld"&gt;
             &lt;port name="HelloWorldSoap" binding="s0:Service1Soap"&gt;
               &lt;soap:address location="<a href="http://localhost">http://localhost</a>:80//helloworld.pl" /&gt;
             &lt;/port&gt;
           &lt;/service&gt;
        &lt;/definitions&gt;

       The XML message (inside the SOAP Envelope) look like this:

        &lt;sayHello xmlns="urn:HelloWorld"&gt;
          &lt;name&gt;Kutter&lt;/name&gt;
          &lt;givenName&gt;Martin&lt;/givenName&gt;
        &lt;/sayHello&gt;

        &lt;sayHelloResponse&gt;
          &lt;sayHelloResult&gt;Hello Martin Kutter!&lt;/sayHelloResult&gt;
        &lt;/sayHelloResponse&gt;

       You can call this web service with the following client code:

        use SOAP::Lite;
        my $soap = SOAP::Lite-&gt;new( proxy =&gt; '<a href="http://localhost">http://localhost</a>:80/helloworld.pl');

        $soap-&gt;on_action( sub { "urn:HelloWorld#sayHello" });
        $soap-&gt;<a href="../man0/autotype.0.html">autotype</a>(0);
        $soap-&gt;default_ns('urn:HelloWorld');

        my $som = $soap-&gt;call("sayHello",
           SOAP::Data-&gt;name('name')-&gt;value( 'Kutter' ),
           SOAP::Data-&gt;name('givenName')-&gt;value('Martin'),
       );

        die $som-&gt;fault-&gt;{ faultstring } if ($som-&gt;fault);
        print $som-&gt;result, "\n";

   <b>Differences</b> <b>between</b> <b>the</b> <b>implementations</b>
       You may have noticed that  there's  little  difference  between  the  rpc/encoded,  rpc/literal  and  the
       document/literal example's implementation. In fact, from SOAP::Lite's point of view, the only differences
       between rpc/literal and document/literal that parameters are always named.

       In our example, the rpc/encoded variant already used named parameters (by using two messages), so there's
       no difference at all.

       You may have noticed the somewhat strange idiom for passing a list of named parameters in the rpc/literal
       example:

        my $som = $soap-&gt;call('sayHello', SOAP::Data-&gt;name('parameters')-&gt;value(
           \SOAP::Data-&gt;value([
               SOAP::Data-&gt;name('name')-&gt;value( 'Kutter' ),
               SOAP::Data-&gt;name('givenName')-&gt;value('Martin'),
           ]))
        );

       While  SOAP::Data  provides  full  control  over  the XML generated, passing hash-like structures require
       additional coding.

</pre><h4><b>WRITING</b> <b>A</b> <b>SOAP</b> <b>SERVER</b></h4><pre>
       See SOAP::Server, or SOAP::Transport.

</pre><h4><b>FEATURES</b></h4><pre>
   <b>ATTACHMENTS</b>
       "SOAP::Lite" features support for the SOAP with Attachments specification.   Currently,  SOAP::Lite  only
       supports MIME based attachments. DIME based attachments are yet to be fully functional.

       <u>EXAMPLES</u>

       Client sending an attachment

       "SOAP::Lite"   clients   can  specify  attachments  to  be  sent  along  with  a  request  by  using  the
       "SOAP::Lite::parts()" method, which takes as an argument an ARRAY of "MIME::Entity"'s.

         use SOAP::Lite;
         use MIME::Entity;
         my $ent = build MIME::Entity
           Type        =&gt; "image/gif",
           Encoding    =&gt; "base64",
           Path        =&gt; "somefile.gif",
           Filename    =&gt; "saveme.gif",
           Disposition =&gt; "attachment";
         my $som = SOAP::Lite
           -&gt;uri($SOME_NAMESPACE)
           -&gt;parts([ $ent ])
           -&gt;proxy($SOME_HOST)
           -&gt;some_method(SOAP::Data-&gt;name("foo" =&gt; "bar"));

       Client retrieving an attachment

       A client accessing attachments that were  returned  in  a  response  by  using  the  "SOAP::SOM::parts()"
       accessor.

         use SOAP::Lite;
         use MIME::Entity;
         my $soap = SOAP::Lite
           -&gt;uri($NS)
           -&gt;proxy($HOST);
         my $som = $soap-&gt;foo();
         foreach my $part (${$som-&gt;parts}) {
           print $part-&gt;stringify;
         }

       Server receiving an attachment

       Servers, like clients, use the SOAP::SOM module to access attachments transmitted to it.

         package Attachment;
         use SOAP::Lite;
         use MIME::Entity;
         use strict;
         use vars qw(@ISA);
         @ISA = qw(SOAP::Server::Parameters);
         sub someMethod {
           my $self = shift;
           my $envelope = pop;
           foreach my $part (@{$envelope-&gt;parts}) {
             print "AttachmentService: attachment found! (".ref($part).")\n";
           }
           # do something
         }

       Server responding with an attachment

       Servers  wishing  to  return  an attachment to the calling client need only return "MIME::Entity" objects
       along with SOAP::Data elements, or any other data intended for the response.

         package Attachment;
         use SOAP::Lite;
         use MIME::Entity;
         use strict;
         use vars qw(@ISA);
         @ISA = qw(SOAP::Server::Parameters);
         sub someMethod {
           my $self = shift;
           my $envelope = pop;
           my $ent = build MIME::Entity
           'Id'          =&gt; "&lt;1234&gt;",
           'Type'        =&gt; "text/xml",
           'Path'        =&gt; "some.xml",
           'Filename'    =&gt; "some.xml",
           'Disposition' =&gt; "attachment";
           return SOAP::Data-&gt;name("foo" =&gt; "blah blah blah"),$ent;
         }

   <b>DEFAULT</b> <b>SETTINGS</b>
       Though this feature looks similar to autodispatch they have (almost) nothing in common.  This  capability
       allows  you  specify default settings so that all objects created after that will be initialized with the
       proper default settings.

       If you wish to provide common "proxy()"  or  "uri()"  settings  for  all  "SOAP::Lite"  objects  in  your
       application you may do:

         use SOAP::Lite
           proxy =&gt; '<a href="http://localhost/cgi-bin/soap.cgi">http://localhost/cgi-bin/soap.cgi</a>',
           uri =&gt; '<a href="http://my.own.com/My/Examples">http://my.own.com/My/Examples</a>';

         my $soap1 = new SOAP::Lite; # will get the same proxy()/uri() as above
         print $soap1-&gt;<a href="../man1/getStateName.1.html">getStateName</a>(1)-&gt;result;

         my $soap2 = SOAP::Lite-&gt;new; # same thing as above
         print $soap2-&gt;<a href="../man2/getStateName.2.html">getStateName</a>(2)-&gt;result;

         # or you may override any settings you want
         my $soap3 = SOAP::Lite-&gt;proxy('<a href="http://localhost/">http://localhost/</a>');
         print $soap3-&gt;<a href="../man1/getStateName.1.html">getStateName</a>(1)-&gt;result;

       <b>Any</b>  "SOAP::Lite"  properties can be propagated this way. Changes in object copies will not affect global
       settings and you may still change global settings with "SOAP::Lite-&gt;self" call which returns reference to
       global object. Provided parameter will update this object and you can even set it to "undef":

         SOAP::Lite-&gt;self(undef);

       The "use SOAP::Lite" syntax also lets you specify default event handlers  for  your  code.  If  you  have
       different  SOAP  objects  and  want  to  share  the  same "on_action()" (or "on_fault()" for that matter)
       handler. You can specify "on_action()" during initialization for every object, but you may also do:

         use SOAP::Lite
           on_action =&gt; sub {sprintf '%s#%s', @_};

       and this handler will be the default handler for all your SOAP  objects.  You  can  override  it  if  you
       specify a handler for a particular object. See <u>t/*.t</u> for example of <b>on_fault()</b> handler.

       Be  warned, that since "use ..." is executed at compile time <b>all</b> "use" statements will be executed <b>before</b>
       script execution that can make unexpected results. Consider code:

         use SOAP::Lite proxy =&gt; '<a href="http://localhost/">http://localhost/</a>';
         print SOAP::Lite-&gt;<a href="../man1/getStateName.1.html">getStateName</a>(1)-&gt;result;

         use SOAP::Lite proxy =&gt; '<a href="http://localhost/cgi-bin/soap.cgi">http://localhost/cgi-bin/soap.cgi</a>';
         print SOAP::Lite-&gt;<a href="../man1/getStateName.1.html">getStateName</a>(1)-&gt;result;

       <b>Both</b> SOAP calls will go to '<a href="http://localhost/cgi-bin/soap.cgi">http://localhost/cgi-bin/soap.cgi</a>'. If you want to execute "use" at run-time,
       put it in "eval":

         eval "use SOAP::Lite proxy =&gt; '<a href="http://localhost/cgi-bin/soap.cgi">http://localhost/cgi-bin/soap.cgi</a>'; 1" or die;

       Or alternatively,

         SOAP::Lite-&gt;self-&gt;proxy('<a href="http://localhost/cgi-bin/soap.cgi">http://localhost/cgi-bin/soap.cgi</a>');

   <b>SETTING</b> <b>MAXIMUM</b> <b>MESSAGE</b> <b>SIZE</b>
       One feature of "SOAP::Lite" is the ability to control the maximum size of a message a  SOAP::Lite  server
       will  be  allowed to process. To control this feature simply define $SOAP::Constants::MAX_CONTENT_SIZE in
       your code like so:

         use SOAP::Transport::HTTP;
         use MIME::Entity;
         $SOAP::Constants::MAX_CONTENT_SIZE = 10000;
         SOAP::Transport::HTTP::CGI
           -&gt;dispatch_to('TemperatureService')
           -&gt;handle;

   <b>IN/OUT,</b> <b>OUT</b> <b>PARAMETERS</b> <b>AND</b> <b>AUTOBINDING</b>
       "SOAP::Lite" gives you access to all parameters (both in/out and out) and also does some additional  work
       for you. Lets consider following example:

         &lt;mehodResponse&gt;
           &lt;res1&gt;name1&lt;/res1&gt;
           &lt;res2&gt;name2&lt;/res2&gt;
           &lt;res3&gt;name3&lt;/res3&gt;
         &lt;/mehodResponse&gt;

       In that case:

         $result = $r-&gt;result; # gives you 'name1'
         $paramout1 = $r-&gt;paramsout;      # gives you 'name2', because of scalar context
         $paramout1 = ($r-&gt;paramsout)[0]; # gives you 'name2' also
         $paramout2 = ($r-&gt;paramsout)[1]; # gives you 'name3'

       or

         @paramsout = $r-&gt;paramsout; # gives you ARRAY of out parameters
         $paramout1 = $paramsout[0]; # gives you 'res2', same as ($r-&gt;paramsout)[0]
         $paramout2 = $paramsout[1]; # gives you 'res3', same as ($r-&gt;paramsout)[1]

       Generally, if server returns "return (1,2,3)" you will get 1 as the result and 2 and 3 as out parameters.

       If  the  server returns "return [1,2,3]" you will get an ARRAY reference from "result()" and "undef" from
       "paramsout()".

       Results can be arbitrary complex: they can be an array references, they  can  be  objects,  they  can  be
       anything  and  still  be  returned  by "result()" . If only one parameter is returned, "paramsout()" will
       return "undef".

       Furthermore, if you have in your output parameters a parameter with the same signature (name+type) as  in
       the input parameters this parameter will be mapped into your input automatically. For example:

       <b>Server</b> <b>Code</b>:

         sub mymethod {
           shift; # object/class reference
           my $param1 = shift;
           my $param2 = SOAP::Data-&gt;name('myparam' =&gt; shift() * 2);
           return $param1, $param2;
         }

       <b>Client</b> <b>Code</b>:

         $a = 10;
         $b = SOAP::Data-&gt;name('myparam' =&gt; 12);
         $result = $soap-&gt;mymethod($a, $b);

       After that, "$result == 10 and $b-&gt;value == 24"! Magic? Sort of.

       Autobinding  gives  it  to  you. That will work with objects also with one difference: you do not need to
       worry  about  the  name  and  the  type  of   object   parameter.   Consider   the   "PingPong"   example
       (<u>examples/My/PingPong.pm</u> and <u>examples/pingpong.pl</u>):

       <b>Server</b> <b>Code</b>:

         package My::PingPong;

         sub new {
           my $self = shift;
           my $class = ref($self) || $self;
           bless {_num=&gt;shift} =&gt; $class;
         }

         sub next {
           my $self = shift;
           $self-&gt;{_num}++;
         }

       <b>Client</b> <b>Code</b>:

         use SOAP::Lite +autodispatch =&gt;
           uri =&gt; 'urn:',
           proxy =&gt; '<a href="http://localhost/">http://localhost/</a>';

         my $p = My::PingPong-&gt;<a href="../man10/new.10.html">new</a>(10); # $p-&gt;{_num} is 10 now, real object returned
         print $p-&gt;next, "\n";          # $p-&gt;{_num} is 11 now!, object autobinded

   <b>STATIC</b> <b>AND</b> <b>DYNAMIC</b> <b>SERVICE</b> <b>DEPLOYMENT</b>
       Let  us  scrutinize  the deployment process. When designing your SOAP server you can consider two kind of
       deployment:  <b>static</b>  and  <b>dynamic</b>.  For  both,  static  and  dynamic,   you  should   specify   "MODULE",
       "MODULE::method",  "method"  or  "PATH/"  when  creating  "use"ing  the SOAP::Lite module. The difference
       between static and dynamic deployment is that in case of 'dynamic', any module which is not present  will
       be loaded on demand. See the "SECURITY" section for detailed description.

       When statically deploying a SOAP Server, you need to know all modules handling SOAP requests before.

       Dynamic  deployment  allows extending your SOAP Server's interface by just installing another module into
       the dispatch_to path (see below).

       <u>STATIC</u> <u>DEPLOYMENT</u> <u>EXAMPLE</u>

         use SOAP::Transport::HTTP;
         use My::Examples;           # module is preloaded

         SOAP::Transport::HTTP::CGI
            # deployed module should be present here or client will get
            # 'access denied'
           -&gt; dispatch_to('My::Examples')
           -&gt; handle;

       For static deployment you should specify the MODULE name directly.

       You should also use static binding when you have several different classes in one file and want  to  make
       them available for SOAP calls.

       <u>DYNAMIC</u> <u>DEPLOYMENT</u> <u>EXAMPLE</u>

         use SOAP::Transport::HTTP;
         # name is unknown, module will be loaded on demand

         SOAP::Transport::HTTP::CGI
           # deployed module should be present here or client will get 'access denied'
           -&gt; dispatch_to('/Your/Path/To/Deployed/Modules', 'My::Examples')
           -&gt; handle;

       For  dynamic  deployment  you  can  specify  the name either directly (in that case it will be "require"d
       without any restriction) or indirectly, with a PATH. In that case, the ONLY path that will  be  available
       will  be  the  PATH  given to the <b>dispatch_to()</b> method). For information how to handle this situation see
       "SECURITY" section.

       <u>SUMMARY</u>

         dispatch_to(
           # dynamic dispatch that allows access to ALL modules in specified directory
           PATH/TO/MODULES
           # 1. specifies directory
           # -- AND --
           # 2. gives access to ALL modules in this directory without limits

           # static dispatch that allows access to ALL methods in particular MODULE
           MODULE
           #  1. gives access to particular module (all available methods)
           #  PREREQUISITES:
           #    module should be loaded manually (for example with 'use ...')
           #    -- OR --
           #    you can still specify it in PATH/TO/MODULES

           # static dispatch that allows access to particular method ONLY
           MODULE::method
           # same as MODULE, but gives access to ONLY particular method,
           # so there is not much sense to use both MODULE and MODULE::method
           # for the same MODULE
         );

       In addition to this "SOAP::Lite" also supports an experimental syntax that allows you to bind a  specific
       URL or SOAPAction to a CLASS/MODULE or object.

       For example:

         dispatch_with({
           URI =&gt; MODULE,        # '<a href="http://www.soaplite.com/">http://www.soaplite.com/</a>' =&gt; 'My::Class',
           SOAPAction =&gt; MODULE, # '<a href="http://www.soaplite.com/method">http://www.soaplite.com/method</a>' =&gt; 'Another::Class',
           URI =&gt; object,        # '<a href="http://www.soaplite.com/obj">http://www.soaplite.com/obj</a>' =&gt; My::Class-&gt;new,
         })

       "URI"  is checked before "SOAPAction". You may use both the "dispatch_to()" and "dispatch_with()" methods
       in the same server, but note that "dispatch_with()" has a higher  order  of  precedence.  "dispatch_to()"
       will be checked only after "URI" and "SOAPAction" has been checked.

       See also: EXAMPLE APACHE::REGISTRY USAGE, "SECURITY"

   <b>COMPRESSION</b>
       "SOAP::Lite"  provides  you  option  to  enable transparent compression over the wire. Compression can be
       enabled by specifying a threshold value (in the form of kilobytes) for compression on both the client and
       server sides:

       <u>Note:</u> <u>Compression</u> <u>currently</u> <u>only</u> <u>works</u> <u>for</u> <u>HTTP</u> <u>based</u> <u>servers</u> <u>and</u> <u>clients.</u>

       <b>Client</b> <b>Code</b>

         print SOAP::Lite
           -&gt;uri('<a href="http://localhost/My/Parameters">http://localhost/My/Parameters</a>')
           -&gt;proxy('<a href="http://localhost/">http://localhost/</a>', options =&gt; {compress_threshold =&gt; 10000})
           -&gt;echo(1 x 10000)
           -&gt;result;

       <b>Server</b> <b>Code</b>

         my $server = SOAP::Transport::HTTP::CGI
           -&gt;dispatch_to('My::Parameters')
           -&gt;options({compress_threshold =&gt; 10000})
           -&gt;handle;

       For more information see COMPRESSION in HTTP::Transport.

</pre><h4><b>SECURITY</b></h4><pre>
       For security reasons, the existing path for Perl modules (@INC) will be disabled  once  you  have  chosen
       dynamic  deployment  and specified your own "PATH/". If you wish to access other modules in your included
       package you have several options:

       1.  Switch to static linking:

              use MODULE;
              $server-&gt;dispatch_to('MODULE');

           Which can also be useful when you want to import something specific from the deployed modules:

              use MODULE qw(import_list);

       2.  Change "use" to "require". The path is only  unavailable  during  the  initialization  phase.  It  is
           available  once more during execution. Therefore, if you utilize "require" somewhere in your package,
           it will work.

       3.  Wrap "use" in an "eval" block:

              eval 'use MODULE qw(import_list)'; die if $@;

       4.  Set your include path in your package and then specify "use". Don't forget to put @INC in a "BEGIN{}"
           block or it won't work. For example,

              BEGIN { @INC = <a href="../manmy_directory/qw.my_directory.html">qw</a>(my_directory); use MODULE }

</pre><h4><b>INTEROPERABILITY</b></h4><pre>
   <b>Microsoft</b> <b>.NET</b> <b>client</b> <b>with</b> <b>SOAP::Lite</b> <b>Server</b>
       In order to use a .NET client with a SOAP::Lite server, be sure you use fully qualified  names  for  your
       return values. For example:

         return SOAP::Data-&gt;name('myname')
                          -&gt;type('string')
                          -&gt;uri($MY_NAMESPACE)
                          -&gt;value($output);

       In addition see comment about default encoding in .NET Web Services below.

   <b>SOAP::Lite</b> <b>client</b> <b>with</b> <b>a</b> <b>.NET</b> <b>server</b>
       If experiencing problems when using a SOAP::Lite client to call a .NET Web service, it is recommended you
       check, or adhere to all of the following recommendations:

       Declare a proper soapAction in your call
           For example, use "on_action( sub { '<a href="http://www.myuri.com/WebService.aspx">http://www.myuri.com/WebService.aspx</a>#someMethod'; } )".

       Disable charset definition in Content-type header
           Some  users  have  said  that  Microsoft  .NET  prefers  the value of the Content-type header to be a
           mimetype exclusively, but SOAP::Lite specifies a character set in  addition  to  the  mimetype.  This
           results in an error similar to:

             Server found request content type to be 'text/xml; charset=utf-8',
             but expected 'text/xml'

           To turn off this behavior specify use the following code:

             use SOAP::Lite;
             $SOAP::Constants::DO_NOT_USE_CHARSET = 1;
             # The rest of your code

       Use fully qualified name for method parameters
           For example, the following code is preferred:

             SOAP::Data-&gt;name(Query  =&gt; 'biztalk')
                       -&gt;uri('<a href="http://tempuri.org/">http://tempuri.org/</a>')

           As opposed to:

             SOAP::Data-&gt;name('Query'  =&gt; 'biztalk')

       Place method in default namespace
           For example, the following code is preferred:

             my $method = SOAP::Data-&gt;name('add')
                                    -&gt;attr({xmlns =&gt; '<a href="http://tempuri.org/">http://tempuri.org/</a>'});
             my @rc = $soap-&gt;call($method =&gt; @parms)-&gt;result;

           As opposed to:

             my @rc = $soap-&gt;call(add =&gt; @parms)-&gt;result;
             # -- OR --
             my @rc = $soap-&gt;add(@parms)-&gt;result;

       Disable use of explicit namespace prefixes
           Some  user's  have  reported  that .NET will simply not parse messages that use namespace prefixes on
           anything but SOAP elements themselves. For example, the following XML would not be parsed:

             &lt;SOAP-ENV:Envelope ...attributes skipped&gt;
               &lt;SOAP-ENV:Body&gt;
                 &lt;namesp1:mymethod xmlns:namesp1="urn:MyURI" /&gt;
               &lt;/SOAP-ENV:Body&gt;
             &lt;/SOAP-ENV:Envelope&gt;

           SOAP::Lite allows users to disable the use of explicit namespaces through the "use_prefix()"  method.
           For example, the following code:

             $som = SOAP::Lite-&gt;uri('urn:MyURI')
                              -&gt;proxy($HOST)
                              -&gt;<a href="../man0/use_prefix.0.html">use_prefix</a>(0)
                              -&gt;myMethod();

           Will result in the following XML, which is more palatable by .NET:

             &lt;SOAP-ENV:Envelope ...attributes skipped&gt;
               &lt;SOAP-ENV:Body&gt;
                 &lt;mymethod xmlns="urn:MyURI" /&gt;
               &lt;/SOAP-ENV:Body&gt;
             &lt;/SOAP-ENV:Envelope&gt;

       Modify your .NET server, if possible
           Stefan Pharies &lt;<a href="mailto:stefanph@microsoft.com">stefanph@microsoft.com</a>&gt;:

           SOAP::Lite  uses  the  SOAP  encoding  (section 5 of the soap 1.1 spec), and the default for .NET Web
           Services is to use a literal encoding. So elements in the request are unqualified, but  your  service
           expects  them  to  be  qualified.  .Net Web Services has a way for you to change the expected message
           format, which should allow you to get your interop working.  At the top of your class  in  the  asmx,
           add this attribute (for Beta 1):

             [SoapService(Style=SoapServiceStyle.RPC)]

           Another source said it might be this attribute (for Beta 2):

             [SoapRpcService]

           Full Web Service text may look like:

             &lt;%@ WebService Language="C#" Class="Test" %&gt;
             using System;
             using System.Web.Services;
             using System.Xml.Serialization;

             [SoapService(Style=SoapServiceStyle.RPC)]
             public class Test : WebService {
               [WebMethod]
               public int add(int a, int b) {
                 return a + b;
               }
             }

           Another example from Kirill Gavrylyuk &lt;<a href="mailto:kirillg@microsoft.com">kirillg@microsoft.com</a>&gt;:

           "You can insert [<b>SoapRpcService()</b>] attribute either on your class or on operation level".

             &lt;%@ WebService Language=CS class="DataType.StringTest"%&gt;

             namespace DataType {

               using System;
               using System.Web.Services;
               using System.Web.Services.Protocols;
               using System.Web.Services.Description;

              [SoapRpcService()]
              public class StringTest: WebService {
                [WebMethod]
                [SoapRpcMethod()]
                public string RetString(string x) {
                  return(x);
                }
              }
            }

           Example from Yann Christensen &lt;<a href="mailto:yannc@microsoft.com">yannc@microsoft.com</a>&gt;:

             using System;
             using System.Web.Services;
             using System.Web.Services.Protocols;

             namespace Currency {
               [WebService(Namespace="<a href="http://www.yourdomain.com/example">http://www.yourdomain.com/example</a>")]
               [SoapRpcService]
               public class Exchange {
                 [WebMethod]
                 public double getRate(String country, String country2) {
                   return 122.69;
                 }
               }
             }

       Special  thanks  goes  to  the  following  people for providing the above description and details on .NET
       interoperability issues:

       Petr Janata &lt;<a href="mailto:petr.janata@i.cz">petr.janata@i.cz</a>&gt;,

       Stefan Pharies &lt;<a href="mailto:stefanph@microsoft.com">stefanph@microsoft.com</a>&gt;,

       Brian Jepson &lt;<a href="mailto:bjepson@jepstone.net">bjepson@jepstone.net</a>&gt;, and others

</pre><h4><b>TROUBLESHOOTING</b></h4><pre>
       SOAP::Lite serializes "18373" as an integer, but I want it to be a string!
           SOAP::Lite guesses datatypes from the content provided, using a  set  of  common-sense  rules.  These
           rules are not 100% reliable, though they fit for most data.

           You may force the type by passing a SOAP::Data object with a type specified:

            my $proxy = SOAP::Lite-&gt;proxy('<a href="http://www.example.org/soapservice">http://www.example.org/soapservice</a>');
            my $som = $proxy-&gt;myMethod(
                SOAP::Data-&gt;name('foo')-&gt;<a href="../man12345/value.12345.html">value</a>(12345)-&gt;type('string')
            );

           You  may  also  change  the precedence of the type-guessing rules. Note that this means fiddling with
           SOAP::Lite's internals - this may not work as expected in future versions.

           The example above forces everything to be encoded as string (this  is  because  the  string  test  is
           normally last and always returns true):

             my @list = qw(-1 45 foo bar 3838);
             my $proxy = SOAP::Lite-&gt;uri($uri)-&gt;proxy($proxyUrl);
             my $lookup = $proxy-&gt;serializer-&gt;typelookup;
             $lookup-&gt;{string}-&gt;[0] = 0;
             $proxy-&gt;serializer-&gt;typelookup($lookup);
             $proxy-&gt;myMethod(\@list);

           See SOAP::Serializer for more details.

       "+autodispatch" doesn't work in Perl 5.8
           There  is  a  bug in Perl 5.8's "UNIVERSAL::AUTOLOAD" functionality that prevents the "+autodispatch"
           functionality from working properly. The workaround is to  use  "dispatch_from"  instead.  Where  you
           might normally do something like this:

              use Some::Module;
              use SOAP::Lite +autodispatch =&gt;
                  uri =&gt; 'urn:Foo'
                  proxy =&gt; 'http://...';

           You would do something like this:

              use SOAP::Lite dispatch_from(Some::Module) =&gt;
                  uri =&gt; 'urn:Foo'
                  proxy =&gt; 'http://...';

       Problems using SOAP::Lite's COM Interface
           Can't call method "server" on undefined value
               You probably did not register <u>Lite.dll</u> using "regsvr32 Lite.dll"

           Failed to load PerlCtrl Runtime
               It  is  likely  that  you  have  install  Perl  in  two  different  locations and the location of
               ActiveState's Perl is not the first instance of Perl specified in your PATH. To  rectify,  rename
               the  directory  in  which  the  non-ActiveState  Perl  is  installed,  or  be  sure  the  path to
               ActiveState's Perl is specified prior to any other instance of Perl in your PATH.

       Dynamic libraries are not found
           If you are using the Apache web server, and you are seeing  something  like  the  following  in  your
           webserver log file:

             Can't load '/usr/local/lib/perl5/site_perl/.../XML/Parser/Expat/Expat.so'
               for module XML::Parser::Expat: dynamic linker: /usr/local/bin/perl:
               libexpat.so.0 is NEEDED, but object does not exist at
               /usr/local/lib/perl5/.../DynaLoader.pm line 200.

           Then try placing the following into your <u>httpd.conf</u> file and see if it fixes your problem.

            &lt;IfModule mod_env.c&gt;
                PassEnv LD_LIBRARY_PATH
            &lt;/IfModule&gt;

       SOAP client reports "500 unexpected EOF before status line seen
           See "Apache is crashing with segfaults"

       Apache is crashing with segfaults
           Using  "SOAP::Lite"  (or  XML::Parser::Expat) in combination with mod_perl causes random segmentation
           faults in httpd processes. To fix, try configuring Apache with the following:

            RULE_EXPAT=no

           If you are using Apache 1.3.20 and later, try configuring Apache with the following option:

            ./configure --disable-rule=EXPAT

           See <a href="http://archive.covalent.net/modperl/2000/04/0185.xml">http://archive.covalent.net/modperl/2000/04/0185.xml</a> for more details and lot of thanks to Robert
           Barta &lt;<a href="mailto:rho@bigpond.net.au">rho@bigpond.net.au</a>&gt; for explaining this weird behavior.

           If this doesn't address the problem, you may wish to try "-Uusemymalloc",  or  a  similar  option  in
           order to instruct Perl to use the system's own "malloc".

           Thanks to Tim Bunce &lt;<a href="mailto:Tim.Bunce@pobox.com">Tim.Bunce@pobox.com</a>&gt;.

       CGI scripts do not work under Microsoft Internet Information Server (IIS)
           CGI scripts may not work under IIS unless scripts use the ".pl" extension, opposed to ".cgi".

       Java SAX parser unable to parse message composed by SOAP::Lite
           In  some  cases  SOAP  messages created by "SOAP::Lite" may not be parsed properly by a SAX2/Java XML
           parser. This is due to a known bug in "org.xml.sax.helpers.ParserAdapter". This bug manifests  itself
           when  an  attribute  in  an  XML  element  occurs  prior to the XML namespace declaration on which it
           depends. However, according  to  the  XML  specification,  the  order  of  these  attributes  is  not
           significant.

           <a href="http://www.megginson.com/SAX/index.html">http://www.megginson.com/SAX/index.html</a>

           Thanks to Steve Alpert (<a href="mailto:Steve_Alpert@idx.com">Steve_Alpert@idx.com</a>) for pointing on it.

</pre><h4><b>PERFORMANCE</b></h4><pre>
       Processing of XML encoded fragments
           "SOAP::Lite"  is  based  on XML::Parser which is basically wrapper around James Clark's expat parser.
           Expat's behavior for parsing XML encoded string can affect  processing  messages  that  have  lot  of
           encoded  entities,  like  XML fragments, encoded as strings. Providing low-level details, parser will
           call <b>char()</b> callback for every portion of processed stream,  but  individually  for  every  processed
           entity  or newline. It can lead to lot of calls and additional memory manager expenses even for small
           messages. By contrast, XML messages which are encoded as base64Binary, don't have  this  problem  and
           difference  in processing time can be significant. For XML encoded string that has about 20 lines and
           30 tags, number of call  could  be  about  100  instead  of  one  for  the  same  string  encoded  as
           base64Binary.

           Since  it  is  parser's  feature  there  is  NO  fix for this behavior (let me know if you find one),
           especially because you need to parse message you already got (and you cannot control content of  this
           message),  however,  if  your  are  in  charge for both ends of processing you can switch encoding to
           base64 on sender's side. It will  definitely  work  with  SOAP::Lite  and  it  <b>may</b>  work  with  other
           toolkits/implementations also, but obviously I cannot guarantee that.

           If you want to encode specific string as base64, just do "SOAP::Data-&gt;type(base64 =&gt; $string)" either
           on client or on server side. If you want change behavior for specific instance of SOAP::Lite, you may
           subclass  "SOAP::Serializer",  override  "as_string()" method that is responsible for string encoding
           (take a look into "as_base64Binary()") and specify <b>new</b> serializer class for  your  SOAP::Lite  object
           with:

             my $soap = new SOAP::Lite
               serializer =&gt; My::Serializer-&gt;new,
               ..... other parameters

           or on server side:

             my $server = new SOAP::Transport::HTTP::Daemon # or any other server
               serializer =&gt; My::Serializer-&gt;new,
               ..... other parameters

           If  you  want  to change this behavior for <b>all</b> instances of SOAP::Lite, just substitute "as_string()"
           method with "as_base64Binary()" somewhere in your code  <b>after</b>  "use  SOAP::Lite"  and  <b>before</b>  actual
           processing/sending:

             *SOAP::Serializer::as_string = \&amp;SOAP::XMLSchema2001::Serializer::as_base64Binary;

           Be  warned  that  last  two  methods will affect <b>all</b> strings and convert them into base64 encoded. It
           doesn't make any difference for SOAP::Lite, but it <b>may</b> make a difference for other toolkits.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       •   No support for multidimensional, partially transmitted and sparse arrays (however  arrays  of  arrays
           are  supported,  as  well  as any other data structures, and you can add your own implementation with
           SOAP::Data).

       •   Limited support for WSDL schema.

       •   XML::Parser::Lite relies on Unicode support in Perl and doesn't do entity decoding.

       •   Limited support for mustUnderstand and Actor attributes.

</pre><h4><b>PLATFORM</b> <b>SPECIFICS</b></h4><pre>
       MacOS
           Information about XML::Parser for MacPerl could be found here:

           <a href="http://bumppo.net/lists/macperl-modules/1999/07/msg00047.html">http://bumppo.net/lists/macperl-modules/1999/07/msg00047.html</a>

           Compiled XML::Parser for MacOS could be found here:

           <a href="http://www.perl.com/CPAN-local/authors/id/A/AS/ASANDSTRM/XML-Parser-2.27-bin-1-MacOS.tgz">http://www.perl.com/CPAN-local/authors/id/A/AS/ASANDSTRM/XML-Parser-2.27-bin-1-MacOS.tgz</a>

</pre><h4><b>RELATED</b> <b>MODULES</b></h4><pre>
   <b>Transport</b> <b>Modules</b>
       SOAP::Lite allows one to add support for additional transport protocols, or server handlers, via separate
       modules implementing the SOAP::Transport::* interface. The following modules are available from CPAN:

       •   SOAP-Transport-HTTP-Nginx

           SOAP::Transport::HTTP::Nginx provides a transport module for nginx (&lt;<a href="http://nginx.net/">http://nginx.net/</a>&gt;)

</pre><h4><b>AVAILABILITY</b></h4><pre>
       You can download the latest version SOAP::Lite for Unix  or  SOAP::Lite  for  Win32  from  the  following
       sources:

        * CPAN:                <a href="http://search.cpan.org/search">http://search.cpan.org/search</a>?dist=SOAP-Lite

       You  are  welcome  to  send  e-mail to the maintainers of SOAP::Lite with your comments, suggestions, bug
       reports and complaints.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Special thanks to Randy J. Ray, author of <u>Programming</u> <u>Web</u> <u>Services</u> <u>with</u> <u>Perl</u>, who has contributed greatly
       to the documentation effort of SOAP::Lite.

       Special thanks  to  O'Reilly  publishing  which  has  graciously  allowed  SOAP::Lite  to  republish  and
       redistribute the SOAP::Lite reference manual found in Appendix B of <u>Programming</u> <u>Web</u> <u>Services</u> <u>with</u> <u>Perl</u>.

       And  special  gratitude to all the developers who have contributed patches, ideas, time, energy, and help
       in a million different forms to the development of this software.

</pre><h4><b>HACKING</b></h4><pre>
       Latest development takes place on GitHub.com. Come on by and fork it.

       <a href="mailto:git@github.com">git@github.com</a>:redhotpenguin/perl-soaplite.git

       Also see the HACKING file.

       Actively recruiting maintainers for this module. Come and get it on!

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Please use rt.cpan.org or github to report bugs. Pull requests are preferred.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2000-2007 Paul Kulchenko. All rights reserved.

       Copyright (C) 2007-2008 Martin Kutter

       Copyright (C) 2013 Fred Moyer

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

       This  text and all associated documentation for this library is made available under the Creative Commons
       Attribution-NoDerivs 2.0 license.  <a href="http://creativecommons.org/licenses/by-nd/2.0/">http://creativecommons.org/licenses/by-nd/2.0/</a>

</pre><h4><b>AUTHORS</b></h4><pre>
       Paul Kulchenko (<a href="mailto:paulclinger@yahoo.com">paulclinger@yahoo.com</a>)

       Randy J. Ray (<a href="mailto:rjray@blackperl.com">rjray@blackperl.com</a>)

       Byrne Reese (<a href="mailto:byrne@majordojo.com">byrne@majordojo.com</a>)

       Martin Kutter (<a href="mailto:martin.kutter@fen-net.de">martin.kutter@fen-net.de</a>)

       Fred Moyer (<a href="mailto:fred@redhotpenguin.com">fred@redhotpenguin.com</a>)

perl v5.36.0                                       2023-03-01                                    <u>SOAP::<a href="../man3pm/Lite.3pm.html">Lite</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>