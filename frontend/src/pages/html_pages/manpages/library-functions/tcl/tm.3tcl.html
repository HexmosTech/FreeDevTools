<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tm - Facilities for locating and loading of Tcl Modules</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tm - Facilities for locating and loading of Tcl Modules

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>::tcl::tm::path</b> <b>add</b> ?<u>path</u>...?
       <b>::tcl::tm::path</b> <b>remove</b> ?<u>path</u>...?
       <b>::tcl::tm::path</b> <b>list</b>
       <b>::tcl::tm::roots</b> <u>paths</u>
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  document  describes  the facilities for locating and loading Tcl Modules (see <b>MODULE</b> <b>DEFINITION</b> for
       the definition of a Tcl Module).  The following commands are supported:

       <b>::tcl::tm::path</b> <b>add</b> ?<u>path</u>...?
              The paths are added at the head to the list of module paths, in order of  appearance.  This  means
              that the last argument ends up as the new head of the list.

              The  command  enforces the restriction that no path may be an ancestor directory of any other path
              on the list. If any of the new paths violates this restriction an error will be raised, before any
              of the paths have been added. In other words, if only one path argument violates  the  restriction
              then none will be added.

              If a path is already present as is, no error will be raised and no action will be taken.

              Paths  are  searched  later in the order of their appearance in the list. As they are added to the
              front of the list they are searched in reverse order of addition. In other words, the paths  added
              last are looked at first.

       <b>::tcl::tm::path</b> <b>remove</b> ?<u>path</u>...?
              Removes  the paths from the list of module paths. The command silently ignores all paths which are
              not on the list.

       <b>::tcl::tm::path</b> <b>list</b>
              Returns a list containing all registered module paths, in the order that  they  are  searched  for
              modules.

       <b>::tcl::tm::roots</b> <u>paths</u>
              Similar  to  <b>path</b> <b>add</b>, and layered on top of it. This command takes a single argument containing a
              list of paths, extends each with “<b>tcl</b><u>X</u><b>/site-tcl</b>”, and “<b>tcl</b><u>X</u><b>/</b><u>X</u><b>.</b><u>y</u>”, for major version <u>X</u> of  the  Tcl
              interpreter  and  minor  version <u>y</u> less than or equal to the minor version of the interpreter, and
              adds the resulting set of paths to the list of paths to search.

              This command is used internally by the system to set up the system-specific default paths.

              The command has been exposed to allow a build system to define additional root paths beyond  those
              described by this document.

</pre><h4><b>MODULE</b> <b>DEFINITION</b></h4><pre>
       A  Tcl  Module  is a Tcl Package contained in a single file, and no other files required by it. This file
       has to be <b>source</b>able. In other words, a Tcl Module is always imported via:

              source module_file

       The <b>load</b> command is not directly used. This restriction is not an actual limitation, as some may believe.
       Ever since 8.4 the Tcl <b>source</b> command reads only until the first ^Z character. This allows us to  combine
       an arbitrary Tcl script with arbitrary binary data into one file, where the script processes the attached
       data in any it chooses to fully import and activate the package.

       The name of a module file has to match the regular expression:

              ([_[:alpha:]][:_[:alnum:]]*)-([[:digit:]].*)\.tm

       The  first  capturing  parentheses  provides  the  name of the package, the second clause its version. In
       addition to matching the pattern, the extracted version number must not raise an error when used  in  the
       command:

              package vcompare $version 0

</pre><h4><b>FINDING</b> <b>MODULES</b></h4><pre>
       The directory tree for storing Tcl modules is separate from other parts of the filesystem and independent
       of <b>auto_path</b>.

       Tcl Modules are searched for in all directories listed in the result of the command <b>::tcl::tm::path</b> <b>list</b>.
       This  is  called  the  <u>Module</u>  <u>path</u>.  Neither  the <b>auto_path</b> nor the <b>tcl_pkgPath</b> variables are used.  All
       directories on the module path have to obey one restriction:

              For any two directories, neither is an ancestor directory of the other.

       This is required to avoid ambiguities in package naming. If for example the two  directories  “<u>foo/</u>”  and
       “<u>foo/cool</u>”  were on the path a package named <b>cool::ice</b> could be found via the names <b>cool::ice</b> or <b>ice</b>, the
       latter potentially obscuring a package named <b>ice</b>, unqualified.

       Before the search is started, the name of the requested package is translated into a partial path,  using
       the following algorithm:

              All  occurrences  of  “<b>::</b>” in the package name are replaced by the appropriate directory separator
              character for the platform we are on. On Unix, for example, this is “<b>/</b>”.

       Example:

              The requested package is <b>encoding::base64</b>. The generated partial path is “<u>encoding/base64</u>”.

       After this translation the package is looked for in all module paths, by combining them one-by-one, first
       to last with the partial path to form a complete search pattern. Note that the search  algorithm  rejects
       all  files  where  the  filename  does  not  match  the  regular  expression  given in the section <b>MODULE</b>
       <b>DEFINITION</b>. For the remaining files <u>provide</u> <u>scripts</u> are generated  and  added  to  the  package  ifneeded
       database.

       The  algorithm falls back to the previous unknown handler when none of the found module files satisfy the
       request. If the request was satisfied the fall-back is ignored.

       Note that packages in module form have <u>no</u> control over the <u>index</u> and <u>provide</u>  <u>script</u>s  entered  into  the
       package database for them.  For a module file <b>MF</b> the <u>index</u> <u>script</u> is always:

              package ifneeded <b>PNAME</b> <b>PVERSION</b> [list source <b>MF</b>]

       and the <u>provide</u> <u>script</u> embedded in the above is:

              source <b>MF</b>

       Both  package name <b>PNAME</b> and package version <b>PVERSION</b> are extracted from the filename <b>MF</b> according to the
       definition below:

              <b>MF</b> = /module_path/<b>PNAME′</b>-<b>PVERSION</b>.tm

       Where <b>PNAME′</b> is the partial path of the module as defined in section <b>FINDING</b> <b>MODULES</b>, and translated into
       <b>PNAME</b> by changing all directory separators to “<b>::</b>”, and <b>module_path</b> is the path (from the list  of  paths
       to search) that we found the module file under.

       Note  also  that we are here creating a connection between package names and paths. Tcl is case-sensitive
       when it comes to comparing package names, but there are filesystems which are  not,  like  NTFS.  Luckily
       these filesystems do store the case of the name, despite not using the information when comparing.

       Given  the above we allow the names for packages in Tcl modules to have mixed-case, but also require that
       there are no collisions when comparing names in a case-insensitive manner. In other words, if  a  package
       <b>Foo</b> is deployed in the form of a Tcl Module, packages like <b>foo</b>, <b>fOo</b>, etc. are not allowed anymore.

</pre><h4><b>DEFAULT</b> <b>PATHS</b></h4><pre>
       The  default  list  of  paths  on the module path is computed by a <b>tclsh</b> as follows, where <u>X</u> is the major
       version of the Tcl interpreter and <u>y</u> is less than or equal to the minor version of the Tcl interpreter.

       All the default paths are added to the module path, even those paths which  do  not  exist.  Non-existent
       paths  are  filtered  out during actual searches. This enables a user to create one of the paths searched
       when needed and all running applications will automatically pick up any modules placed in them.

       The paths are added in the order as they are  listed  below,  and  for  lists  of  paths  defined  by  an
       environment variable in the order they are found in the variable.

   <b>SYSTEM</b> <b>SPECIFIC</b> <b>PATHS</b>
       <b>file</b> <b>normalize</b> <b>[info</b> <b>library]/../tcl</b><u>X</u><b>/</b><u>X</u><b>.</b><u>y</u>
              In  other  words,  the  interpreter  will look into a directory specified by its major version and
              whose minor versions are less than or equal to the minor version of the interpreter.

              For example for Tcl 8.4 the paths searched are:

                     <b>[info</b> <b>library]/../tcl8/8.4</b>
                     <b>[info</b> <b>library]/../tcl8/8.3</b>
                     <b>[info</b> <b>library]/../tcl8/8.2</b>
                     <b>[info</b> <b>library]/../tcl8/8.1</b>
                     <b>[info</b> <b>library]/../tcl8/8.0</b>

              This definition assumes that a package defined for Tcl <u>X</u><b>.</b><u>y</u> can also be used  by  all  interpreters
              which have the same major number <u>X</u> and a minor number greater than <u>y</u>.

       <b>file</b> <b>normalize</b> <b>EXEC/tcl</b><u>X</u><b>/</b><u>X</u><b>.</b><u>y</u>
              Where  <b>EXEC</b>  is  <b>file</b> <b>normalize</b> <b>[info</b> <b>nameofexecutable]<a href="file:/../lib">/../lib</a></b> or <b>file</b> <b>normalize</b> <b>[::tcl::pkgconfig</b>
              <b>get</b> <b>libdir,runtime]</b>

              This sets of paths is handled equivalently to the set coming before, except that it is anchored in
              <b>EXEC_PREFIX</b>.  For a build with <b>PREFIX</b> = <b>EXEC_PREFIX</b> the two sets are identical.

   <b>SITE</b> <b>SPECIFIC</b> <b>PATHS</b>
       <b>file</b> <b>normalize</b> <b>[info</b> <b>library]/../tcl</b><u>X</u><b>/site-tcl</b>
              Note that this is always a single entry because <u>X</u> is always a specific value  (the  current  major
              version of Tcl).

   <b>USER</b> <b>SPECIFIC</b> <b>PATHS</b>
       <b>$::env(TCL</b><u>X_y</u><b>_TM_PATH)</b>
              A  list  of  paths, separated by either <b>:</b> (Unix) or <b>;</b> (Windows). This is user and site specific as
              this environment variable can be set not only by the user's profile, but by  system  configuration
              scripts as well.

       <b>$::env(TCL</b><u>X</u><b>.</b><u>y</u><b>_TM_PATH)</b>
              Same  meaning  and  content as the previous variable. However the use of dot '.' to separate major
              and minor version number makes this name less to non-portable and its use is discouraged.  Support
              of  this  variable  has been kept only for backward compatibility with the original specification,
              i.e. TIP 189.

       These paths are seen and therefore shared by all Tcl shells in the <b>$::env(PATH)</b> of the user.

       Note that <u>X</u> and <u>y</u> follow the general rules set out above. In other words, Tcl 9.1, for example, will look
       at these 4 environment variables:

              <b>$::env(TCL9.1_TM_PATH)</b>  <b>$::env(TCL9_1_TM_PATH)</b>
              <b>$::env(TCL9.0_TM_PATH)</b>  <b>$::env(TCL9_0_TM_PATH)</b>

       Paths initialized from the environment variables undergo tilde  substitution  (see  <b>filename</b>).  Any  path
       whose tilde substitution fails because the user is unknown will be omitted from search paths.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/package.3tcl.html">package</a>(3tcl), Tcl Improvement Proposal #189 “<u>Tcl</u> <u>Modules</u>” (online at https://tip.tcl-lang.org/189.html),
       Tcl  Improvement  Proposal  #190  “<u>Implementation</u>  <u>Choices</u>  <u>for</u>  <u>Tcl</u> <u>Modules</u>” (online at https://tip.tcl-
       lang.org/190.html)

</pre><h4><b>KEYWORDS</b></h4><pre>
       modules, package

Tcl                                                    8.5                                              <u><a href="../man3tcl/tm.3tcl.html">tm</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>