<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_NRCreateCommand,    Tcl_NRCreateCommand2,   Tcl_NRCallObjProc,   Tcl_NRCallObjProc2,   Tcl_NREvalObj,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_NRCreateCommand,    Tcl_NRCreateCommand2,   Tcl_NRCallObjProc,   Tcl_NRCallObjProc2,   Tcl_NREvalObj,
       Tcl_NREvalObjv, Tcl_NRCmdSwap, Tcl_NRExprObj, Tcl_NRAddCallback - Non-Recursive (stackless) evaluation of
       Tcl scripts.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       Tcl_Command
       <b>Tcl_NRCreateCommand</b>(<u>interp,</u> <u>cmdName,</u> <u>proc,</u> <u>nreProc,</u> <u>clientData,</u>
                           <u>deleteProc</u>)

       Tcl_Command
       <b>Tcl_NRCreateCommand2</b>(<u>interp,</u> <u>cmdName,</u> <u>proc2,</u> <u>nreProc2,</u> <u>clientData,</u>
                           <u>deleteProc</u>)

       int
       <b>Tcl_NRCallObjProc</b>(<u>interp,</u> <u>nreProc,</u> <u>clientData,</u> <u>objc,</u> <u>objv</u>)

       int
       <b>Tcl_NRCallObjProc2</b>(<u>interp,</u> <u>nreProc2,</u> <u>clientData,</u> <u>objc,</u> <u>objv</u>)

       int
       <b>Tcl_NREvalObj</b>(<u>interp,</u> <u>objPtr,</u> <u>flags</u>)

       int
       <b>Tcl_NREvalObjv</b>(<u>interp,</u> <u>objc,</u> <u>objv,</u> <u>flags</u>)

       int
       <b>Tcl_NRCmdSwap</b>(<u>interp,</u> <u>cmd,</u> <u>objc,</u> <u>objv,</u> <u>flags</u>)

       int
       <b>Tcl_NRExprObj</b>(<u>interp,</u> <u>objPtr,</u> <u>resultPtr</u>)

       <b>Tcl_NRAddCallback</b>(<u>interp,</u> <u>postProcPtr,</u> <u>data0,</u> <u>data1,</u> <u>data2,</u> <u>data3</u>)

</pre><h4><b>ARGUMENTS</b></h4><pre>
       Tcl_Interp <u>*interp</u> (in)                 The relevant Interpreter.

       const char <u>*cmdName</u> (in)                Name of the command to create.

       Tcl_ObjCmdProc <u>*proc</u> (in)               Called in order to evaluate a command.  Is  often  just  a  small
                                               wrapper  that  uses <b>Tcl_NRCallObjProc</b> to call <u>nreProc</u> using a new
                                               trampoline.  Behaves in the same way  as  the  <u>proc</u>  argument  to
                                               <b><a href="../man3tcl/Tcl_CreateObjCommand.3tcl.html">Tcl_CreateObjCommand</a></b>(3tcl) (<u>q.v.</u>).

       Tcl_ObjCmdProc2 <u>*proc2</u> (in)             Called  in  order  to  evaluate a command.  Is often just a small
                                               wrapper that uses <b>Tcl_NRCallObjProc2</b> to call <u>nreProc2</u> using a new
                                               trampoline.  Behaves in the same way as  the  <u>proc2</u>  argument  to
                                               <b><a href="../man3tcl/Tcl_CreateObjCommand2.3tcl.html">Tcl_CreateObjCommand2</a></b>(3tcl) (<u>q.v.</u>).

       Tcl_ObjCmdProc <u>*nreProc</u> (in)            Called instead of <u>proc</u> when a trampoline is already in use.

       Tcl_ObjCmdProc2 <u>*nreProc2</u> (in)          Called instead of <u>proc2</u> when a trampoline is already in use.

       void <u>*clientData</u> (in)                   Arbitrary  one-word value passed to <u>proc</u>, <u>nreProc</u>, <u>deleteProc</u> and
                                               <u>objProc</u>.

       Tcl_CmdDeleteProc <u>*deleteProc</u> (in/out)  Called before <u>cmdName</u> is deleted from the  interpreter,  allowing
                                               for command-specific cleanup. May be NULL.

       Tcl_Size <u>objc</u> (in)                      Number of items in <u>objv</u>.

       Tcl_Obj <u>**objv</u> (in)                     Words in the command.

       Tcl_Obj <u>*objPtr</u> (in)                    A script or expression to evaluate.

       int <u>flags</u> (in)                          As described for <u>Tcl_EvalObjv</u>.

       Tcl_Command <u>cmd</u> (in)                    Token  to  use instead of one derived from the first word of <u>objv</u>
                                               in order to evaluate a command.

       Tcl_Obj <u>*resultPtr</u> (out)                Pointer to an unshared Tcl_Obj where the result of the evaluation
                                               is stored if the return code is TCL_OK.

       Tcl_NRPostProc <u>*postProcPtr</u> (in)        A function to push.

       void <u>*data0</u> (in)

       void <u>*data1</u> (in)

       void <u>*data2</u> (in)

       void <u>*data3</u> (in)                        <u>data0</u> through <u>data3</u> are four one-word values that will be  passed
                                               to the function designated by <u>postProcPtr</u> when it is invoked.
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  functions  provide  an  interface  to  the  function stack that an interpreter iterates through to
       evaluate commands.  The routine behind a command is implemented by an initial function and any additional
       functions that the routine pushes onto the  stack  as  it  progresses.   The  interpreter  itself  pushes
       functions  onto the stack to react to the end of a routine and to exercise other forms of control such as
       switching between in-progress stacks and the evaluation of other scripts  at  additional  levels  without
       adding  frames  to the C stack.  To execute a routine, the initial function for the routine is called and
       then a small bit of code called a <u>trampoline</u> iteratively takes functions off the stack  and  calls  them,
       using the value of the last call as the value of the routine.

       <b>Tcl_NRCallObjProc</b> calls <u>nreProc</u> using a new trampoline.

       <b>Tcl_NRCreateCommand</b>,  an  alternative  to  <b>Tcl_CreateObjCommand</b>,  resolves  <u>cmdName</u>,  which  may  contain
       namespace qualifiers, relative to the current namespace, creates a command by that name,  and  returns  a
       token  for  the  command  which  may be used in subsequent calls to <b>Tcl_GetCommandName</b>.  Except for a few
       cases noted below any existing command by the same name is first deleted.  If <u>interp</u> is in the process of
       being deleted <b>Tcl_NRCreateCommand</b> does not create any command, does not delete any command,  and  returns
       NULL.

       <b>Tcl_NRCreateCommand2</b>, is an alternative to <b>Tcl_NRCreateCommand</b> in the same way as <b>Tcl_CreateObjCommand2</b>.

       <b>Tcl_NREvalObj</b> pushes a function that is like <b>Tcl_EvalObjEx</b> but consumes no space on the C stack.

       <b>Tcl_NREvalObjv</b> pushes a function that is like <b>Tcl_EvalObjv</b> but consumes no space on the C stack.

       <b>Tcl_NRCmdSwap</b>  is  like <b>Tcl_NREvalObjv</b>, but uses <u>cmd</u>, a token previously returned by <b>Tcl_CreateObjCommand</b>
       or <b>Tcl_GetCommandFromObj</b>, instead of resolving the first word of <u>objv</u>.

       <b>Tcl_NRExprObj</b> pushes a function that evaluates <u>objPtr</u> as an expression in the same manner as  <b>Tcl_ExprObj</b>
       but without consuming space on the C stack.

       All  of  the  functions  return  <b>TCL_OK</b>  if the evaluation of the script, command, or expression has been
       scheduled successfully.  Otherwise (for example if the command name  cannot  be  resolved),  they  return
       <b>TCL_ERROR</b> and store a message as the interpreter's result.

       <b>Tcl_NRAddCallback</b> pushes <u>postProcPtr</u>.  The signature for <b>Tcl_NRPostProc</b> is:

              typedef int
              <b>Tcl_NRPostProc</b>(
                      <b>void</b> <b>*</b> <u>data</u>[],
                      <b>Tcl_Interp</b> *<u>interp</u>,
                      int <u>result</u>);

       <u>data</u>  is  a  pointer  to  an  array  containing <u>data0</u> through <u>data3</u>.  <u>result</u> is the value returned by the
       previous function implementing part the routine.

</pre><h4><b>EXAMPLE</b></h4><pre>
       The following command uses <b>Tcl_EvalObjEx</b>, which consumes space on the C stack, to evaluate a script:

              int
              <u>TheCmdOldObjProc</u>(
                  void *clientData,
                  Tcl_Interp *interp,
                  int objc,
                  Tcl_Obj *const objv[])
              {
                  int result;
                  Tcl_Obj *objPtr;

                  <u>...</u> <u>preparation</u> <u>...</u>

                  result = <b>Tcl_EvalObjEx</b>(interp, objPtr, 0);

                  <u>...</u> <u>postprocessing</u> <u>...</u>

                  return result;
              }
              <b>Tcl_CreateObjCommand</b>(interp, "theCommand",
                      <u>TheCmdOldObjProc</u>, clientData, TheCmdDeleteProc);

       To avoid consuming space on  the  C  stack,  <u>TheCmdOldObjProc</u>  is  renamed  to  <u>TheCmdNRObjProc</u>  and  the
       postprocessing  step is split into a separate function, <u>TheCmdPostProc</u>, which is pushed onto the function
       stack.  <u>Tcl_EvalObjEx</u> is replaced with <u>Tcl_NREvalObj</u>, which uses a trampoline instead of consuming  space
       on  the  C  stack.   A new version of <u>TheCmdOldObjProc</u> is just a a wrapper that uses <b>Tcl_NRCallObjProc</b> to
       call <u>TheCmdNRObjProc</u>:

              int
              <u>TheCmdOldObjProc</u>(
                  void *clientData,
                  Tcl_Interp *interp,
                  int objc,
                  Tcl_Obj *const objv[])
              {
                  return <b>Tcl_NRCallObjProc</b>(interp, <u>TheCmdNRObjProc</u>,
                          clientData, objc, objv);
              }

              int
              <u>TheCmdNRObjProc</u>
                  void *clientData,
                  Tcl_Interp *interp,
                  int objc,
                  Tcl_Obj *const objv[])
              {
                  Tcl_Obj *objPtr;

                  <u>...</u> <u>preparation</u> <u>...</u>

                  <b>Tcl_NRAddCallback</b>(interp, <u>TheCmdPostProc</u>,
                          data0, data1, data2, data3);
                  /* <u>data0</u> <u>..</u> <u>data3</u> are up to four one-word items to
                   * pass to the postprocessing procedure */

                  return <b>Tcl_NREvalObj</b>(interp, objPtr, 0);
              }

              int
              <u>TheCmdNRPostProc</u>(
                  void *data[],
                  Tcl_Interp *interp,
                  int result)
              {
                  /* <u>data[0]</u> <u>..</u> <u>data[3]</u> are the four words of data
                   * passed to <b>Tcl_NRAddCallback</b> */

                  <u>...</u> <u>postprocessing</u> <u>...</u>

                  return result;
              }

       Any function comprising a routine can push other functions, making  it  possible  implement  looping  and
       sequencing constructs using the function stack.

</pre><h4><b>REFERENCE</b> <b>COUNT</b> <b>MANAGEMENT</b></h4><pre>
       The  first  <u>objc</u>  values in the <u>objv</u> array passed to the functions <b>Tcl_NRCallObjProc</b>, <b>Tcl_NREvalObjv</b>, and
       <b>Tcl_NRCmdSwap</b> should have a reference count of at least 1; they  may  have  additional  references  taken
       during the execution.

       The  <u>objPtr</u>  argument to <b>Tcl_NREvalObj</b> and <b>Tcl_NRExprObj</b> should have a reference count of at least 1, and
       may have additional references taken to it during execution.

       The <u>resultObj</u> argument to <b>Tcl_NRExprObj</b> should be an unshared object.

       Use <b>Tcl_NRAddCallback</b> to schedule any required final decrementing of the reference counts of arguments to
       any of the other functions on this page, as with any other  post-processing  step  in  the  non-recursive
       execution engine.

       The

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/Tcl_CreateCommand.3tcl.html">Tcl_CreateCommand</a>(3tcl),  <a href="../man3tcl/Tcl_CreateObjCommand.3tcl.html">Tcl_CreateObjCommand</a>(3tcl),  <a href="../man3tcl/Tcl_EvalObjEx.3tcl.html">Tcl_EvalObjEx</a>(3tcl),  <a href="../man3tcl/Tcl_GetCommandFromObj.3tcl.html">Tcl_GetCommandFromObj</a>(3tcl),
       <a href="../man3tcl/Tcl_ExprObj.3tcl.html">Tcl_ExprObj</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       stackless, nonrecursive, execute, command, global, value, result, script

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2008 Kevin B. Kenny.  Copyright © 2018 Nathan Coulter.

Tcl                                                    8.6                                             <u><a href="../man3tcl/NRE.3tcl.html">NRE</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>