<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_RegisterObjType,   Tcl_GetObjType,   Tcl_AppendAllObjTypes,  Tcl_ConvertToType,  Tcl_FreeInternalRep,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_RegisterObjType,   Tcl_GetObjType,   Tcl_AppendAllObjTypes,  Tcl_ConvertToType,  Tcl_FreeInternalRep,
       Tcl_InitStringRep, Tcl_HasStringRep, Tcl_StoreInternalRep, Tcl_FetchInternalRep  - manipulate  Tcl  value
       types

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       <b>Tcl_RegisterObjType</b>(<u>typePtr</u>)

       const Tcl_ObjType *
       <b>Tcl_GetObjType</b>(<u>typeName</u>)

       int
       <b>Tcl_AppendAllObjTypes</b>(<u>interp,</u> <u>objPtr</u>)

       int
       <b>Tcl_ConvertToType</b>(<u>interp,</u> <u>objPtr,</u> <u>typePtr</u>)

       void
       <b>Tcl_FreeInternalRep</b>(<u>objPtr</u>)

       char *
       <b>Tcl_InitStringRep</b>(<u>objPtr,</u> <u>bytes,</u> <u>numBytes</u>)

       int
       <b>Tcl_HasStringRep</b>(<u>objPtr</u>)

       void
       <b>Tcl_StoreInternalRep</b>(<u>objPtr,</u> <u>typePtr,</u> <u>irPtr</u>)

       Tcl_ObjInternalRep *
       <b>Tcl_FetchInternalRep</b>(<u>objPtr,</u> <u>typePtr</u>)

</pre><h4><b>ARGUMENTS</b></h4><pre>
       const Tcl_ObjType <u>*typePtr</u> (in)    Points  to  the  structure  containing information about the Tcl value
                                          type.  This storage must live forever, typically by  being  statically
                                          allocated.

       const char <u>*typeName</u> (in)          The name of a Tcl value type that <b>Tcl_GetObjType</b> should look up.

       Tcl_Interp <u>*interp</u> (in)            Interpreter to use for error reporting.

       Tcl_Obj <u>*objPtr</u> (in)               For  <b>Tcl_AppendAllObjTypes</b>,  this  points  to  the value onto which it
                                          appends  the  name  of  each  value  type  as  a  list  element.   For
                                          <b>Tcl_ConvertToType</b>,  this  points  to  a  value that must have been the
                                          result of a previous call to <b>Tcl_NewObj</b>.

       const char* <u>bytes</u> (in)             String representation.

       unsigned int <u>numBytes</u> (in)         Length of the string representation in bytes.

       const Tcl_ObjInternalRep* <u>irPtr</u> (in)
                                          Internal object representation.

       const Tcl_ObjType* <u>typePtr</u> (in)    Requested internal representation type.
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The procedures in this man page manage Tcl  value  types  (sometimes  referred  to  as  object  types  or
       <b>Tcl_ObjType</b>s  for  historical  reasons).   They  are used to register new value types, look up types, and
       force conversions from one type to another.

       <b>Tcl_RegisterObjType</b> registers a new Tcl value type in the table of all value  types  that  <b>Tcl_GetObjType</b>
       can  look  up  by  name.   There are other value types supported by Tcl as well, which Tcl chooses not to
       register.  Extensions can likewise choose to register the value types they create or not.   The  argument
       <u>typePtr</u> points to a Tcl_ObjType structure that describes the new type by giving its name and by supplying
       pointers  to four procedures that implement the type.  If the type table already contains a type with the
       same name as in <u>typePtr</u>, it is replaced with the new type.  The Tcl_ObjType structure is described in the
       section <b>THE</b> <b>TCL_OBJTYPE</b> <b>STRUCTURE</b> below.

       <b>Tcl_GetObjType</b> returns a pointer to the registered Tcl_ObjType with name <u>typeName</u>.  It returns NULL if no
       type with that name is registered.

       <b>Tcl_AppendAllObjTypes</b> appends the name of each registered value type as a list element onto the Tcl value
       referenced by <u>objPtr</u>.  The return value is <b>TCL_OK</b> unless there was an error converting <u>objPtr</u> to  a  list
       value; in that case <b>TCL_ERROR</b> is returned.

       <b>Tcl_ConvertToType</b>  converts  a  value  from  one  type to another if possible.  It creates a new internal
       representation for <u>objPtr</u> appropriate for the  target  type  <u>typePtr</u>  and  sets  its  <u>typePtr</u>  member  as
       determined  by calling the <u>typePtr-&gt;setFromAnyProc</u> routine.  Any internal representation for <u>objPtr</u>'s old
       type is freed.  If an error occurs during conversion, it returns <b>TCL_ERROR</b> and leaves an error message in
       the result value for <u>interp</u> unless <u>interp</u> is NULL.  Otherwise, it returns <b>TCL_OK</b>.  Passing a NULL  <u>interp</u>
       allows this procedure to be used as a test whether the conversion can be done (and in fact was done).

       In  many  cases,  the  <u>typePtr-&gt;setFromAnyProc</u>  routine  will  set  <u>objPtr-&gt;typePtr</u> to the argument value
       <u>typePtr</u>, but that is no longer guaranteed.  The <u>setFromAnyProc</u> is free to set the internal representation
       for <u>objPtr</u> to make use of another related Tcl_ObjType, if it sees fit.

       <b>Tcl_FreeInternalRep</b> performs the function  of  the  existing  internal  macro  <b>TclInitStringRep</b>,  but  is
       extended  to  return a pointer to the string rep, and to accept <u>NULL</u> as a value for bytes.  When bytes is
       <u>NULL</u> and <u>objPtr</u> has no string rep, an uninitialzed buffer of <u>numBytes</u> bytes is created for filling by the
       caller.  When <u>bytes</u> is <u>NULL</u> and <u>objPtr</u> has a string rep, the string rep will be truncated to a length  of
       <u>numBytes</u>  bytes.   When <u>numBytes</u> is greater than zero, and the returned pointer is <u>NULL</u>, that indicates a
       failure to allocate memory for the string representation.  The caller may then choose whether to raise an
       error or panic.

       <b>Tcl_HasStringRep</b> returns a boolean indicating whether or not a string rep is currently stored in  <u>objPtr</u>.
       This  is used when the caller wants to act on <u>objPtr</u> differently depending on whether or not it is a pure
       value.  Typically this only makes sense in an extension if it is already known that <u>objPtr</u>  possesses  an
       internal type that is managed by the extension.

       <b>Tcl_StoreInternalRep</b>  stores in <u>objPtr</u> a copy of the internal representation pointed to by <u>irPtr</u> and sets
       its type to <u>typePtr</u>.  When <u>irPtr</u> is <u>NULL</u>, this leaves <u>objPtr</u> without a representation for type <u>typePtr</u>.

       <b>Tcl_FetchInternalRep</b> returns a pointer to the internal representation stored in <u>objPtr</u> that  matches  the
       requested type <u>typePtr</u>.  If no such internal representation is in <u>objPtr</u>, return <u>NULL</u>.

       This returns a public type
              typedef union Tcl_ObjInternalRep {...} Tcl_ObjInternalRep
       where the contents are exactly the existing contents of the union in the <u>internalRep</u> field of the <u>Tcl_Obj</u>
       struct.   This  definition  permits us to pass internal representations and pointers to them as arguments
       and results in public routines.

</pre><h4><b>THE</b> <b>TCL_OBJTYPE</b> <b>STRUCTURE</b></h4><pre>
       Extension writers can define new value types by defining four to twelve  procedures  and  initializing  a
       Tcl_ObjType  structure  to  describe  the  type.   Extension  writers  may  also  pass a pointer to their
       Tcl_ObjType structure to <b>Tcl_RegisterObjType</b> if they wish to permit other extensions  to  look  up  their
       Tcl_ObjType by name with the <b>Tcl_GetObjType</b> routine.  The <b>Tcl_ObjType</b> structure is defined as follows:

              typedef struct {
                  const char *<u>name</u>;
                  Tcl_FreeInternalRepProc *<u>freeIntRepProc</u>;
                  Tcl_DupInternalRepProc *<u>dupIntRepProc</u>;
                  Tcl_UpdateStringProc *<u>updateStringProc</u>;
                  Tcl_SetFromAnyProc *<u>setFromAnyProc</u>;
                  size_t <u>version</u>;
                  /* List emulation functions - ObjType Version 1 &amp; 2 */
                  Tcl_ObjTypeLengthProc *lengthProc;
                  /* List emulation functions - ObjType Version 2 */
                  Tcl_ObjTypeIndexProc *<u>indexProc</u>;
                  Tcl_ObjTypeSliceProc *<u>sliceProc</u>;
                  Tcl_ObjTypeReverseProc *<u>reverseProc</u>;
                  Tcl_ObjTypeGetElements *<u>getElementsProc</u>;
                  Tcl_ObjTypeSetElement *<u>setElementProc</u>;
                  Tcl_ObjTypeReplaceProc *<u>replaceProc</u>;
                  Tcl_ObjTypeInOperatorProc *<u>inOperProc</u>;
              } <b>Tcl_ObjType</b>;

   <b>THE</b> <b>NAME</b> <b>FIELD</b>
       The  <u>name</u>  member  describes the name of the type, e.g. <b>int</b>.  When a type is registered, this is the name
       used by callers of <b>Tcl_GetObjType</b> to lookup  the  type.   For  unregistered  types,  the  <u>name</u>  field  is
       primarily  of  value  for debugging.  The remaining four members are pointers to procedures called by the
       generic Tcl value code:

   <b>THE</b> <b>SETFROMANYPROC</b> <b>FIELD</b>
       The <u>setFromAnyProc</u> member contains  the  address  of  a  function  called  to  create  a  valid  internal
       representation from a value's string representation.

              typedef int <b>Tcl_SetFromAnyProc</b>(
                      Tcl_Interp *<u>interp</u>,
                      Tcl_Obj *<u>objPtr</u>);

       If  an internal representation cannot be created from the string, it returns <b>TCL_ERROR</b> and puts a message
       describing the error in the result value  for  <u>interp</u>  unless  <u>interp</u>  is  NULL.   If  <u>setFromAnyProc</u>  is
       successful,  it  stores  the  new  internal  representation, sets <u>objPtr</u>'s <u>typePtr</u> member to point to the
       <b>Tcl_ObjType</b> struct corresponding to the new internal representation, and returns <b>TCL_OK</b>.  Before  setting
       the new internal representation, the <u>setFromAnyProc</u> must free any internal representation of <u>objPtr</u>'s old
       type; it does this by calling the old type's <u>freeIntRepProc</u> if it is not NULL.

       As an example, the <u>setFromAnyProc</u> for the built-in Tcl list type gets an up-to-date string representation
       for  <u>objPtr</u> by calling <b>Tcl_GetStringFromObj</b>.  It parses the string to verify it is in a valid list format
       and to obtain each element value in the list, and, if this succeeds, stores the list elements in <u>objPtr</u>'s
       internal representation and sets <u>objPtr</u>'s  <u>typePtr</u>  member  to  point  to  the  list  type's  Tcl_ObjType
       structure.

       Do  not  release  <u>objPtr</u>'s  old internal representation unless you replace it with a new one or reset the
       <u>typePtr</u> member to NULL.

       The <u>setFromAnyProc</u> member may be set to NULL, if the routines making use of the  internal  representation
       have  no  need  to  derive that internal representation from an arbitrary string value.  However, in this
       case, passing a pointer to the type to  <b>Tcl_ConvertToType</b>  will  lead  to  a  panic,  so  to  avoid  this
       possibility, the type should <u>not</u> be registered.

   <b>THE</b> <b>UPDATESTRINGPROC</b> <b>FIELD</b>
       The  <u>updateStringProc</u>  member  contains  the  address  of  a  function  called  to  create a valid string
       representation from a value's internal representation.

              typedef void <b>Tcl_UpdateStringProc</b>(
                      Tcl_Obj *<u>objPtr</u>);

       <u>objPtr</u>'s <u>bytes</u> member is always NULL when it is  called.   It  must  always  set  <u>bytes</u>  non-NULL  before
       returning.   We  require  the  string  representation's byte array to have a null after the last byte, at
       offset <u>length</u>, and to have no null bytes before that; this allows string representations to be treated as
       conventional null character-terminated C strings.  These restrictions  are  easily  met  by  using  Tcl's
       internal  UTF  encoding  for  the  string  representation,  same  as  one would do for other Tcl routines
       accepting string values as arguments.  Storage for the byte array  must  be  allocated  in  the  heap  by
       <b>Tcl_Alloc</b>.   Note  that  <u>updateStringProc</u>s  must  allocate  enough storage for the string's bytes and the
       terminating null byte.

       The <u>updateStringProc</u> for Tcl's built-in double type, for example, calls Tcl_PrintDouble  to  write  to  a
       buffer of size TCL_DOUBLE_SPACE, then allocates and copies the string representation to just enough space
       to hold it.  A pointer to the allocated space is stored in the <u>bytes</u> member.

       The <u>updateStringProc</u> member may be set to NULL, if the routines making use of the internal representation
       are written so that the string representation is never invalidated.  Failure to meet this obligation will
       lead  to  panics  or  crashes  when  <b>Tcl_GetStringFromObj</b>  or  other  similar routines ask for the string
       representation.

   <b>THE</b> <b>DUPINTREPPROC</b> <b>FIELD</b>
       The <u>dupIntRepProc</u> member contains the address of a function called to  copy  an  internal  representation
       from one value to another.

              typedef void <b>Tcl_DupInternalRepProc</b>(
                      Tcl_Obj *<u>srcPtr</u>,
                      Tcl_Obj *<u>dupPtr</u>);

       <u>dupPtr</u>'s  internal  representation  is made a copy of <u>srcPtr</u>'s internal representation.  Before the call,
       <u>srcPtr</u>'s internal representation is valid and <u>dupPtr</u>'s is  not.   <u>srcPtr</u>'s  value  type  determines  what
       copying its internal representation means.

       For  example,  the  <u>dupIntRepProc</u>  for  the Tcl integer type simply copies an integer.  The built-in list
       type's <u>dupIntRepProc</u> uses a far more sophisticated scheme to continue  sharing  storage  as  much  as  it
       reasonably can.

   <b>THE</b> <b>FREEINTREPPROC</b> <b>FIELD</b>
       The <u>freeIntRepProc</u> member contains the address of a function that is called when a value is freed.

              typedef void <b>Tcl_FreeInternalRepProc</b>(
                      Tcl_Obj *<u>objPtr</u>);

       The  <u>freeIntRepProc</u>  function  can  deallocate the storage for the value's internal representation and do
       other type-specific processing necessary when a value is freed.

       For example, the list type's <u>freeIntRepProc</u> respects  the  storage  sharing  scheme  established  by  the
       <u>dupIntRepProc</u> so that it only frees storage when the last value sharing it is being freed.

       The  <u>freeIntRepProc</u>  member  can  be  set  to  NULL to indicate that the internal representation does not
       require freeing.  The <u>freeIntRepProc</u> implementation must not access the <u>bytes</u> member of the value,  since
       Tcl  makes  its  own  internal  uses  of  that  field  during  value deletion.  The defined tasks for the
       <u>freeIntRepProc</u> have no need to consult the <u>bytes</u> member.

       Note that if a subsidiary value has its  reference  count  reduced  to  zero  during  the  running  of  a
       <u>freeIntRepProc</u>,  that  value  may  be  not freed immediately, in order to limit stack usage. However, the
       value will be freed before the outermost current <b>Tcl_DecrRefCount</b> returns.

   <b>THE</b> <b>VERSION</b> <b>FIELD</b>
       The <u>version</u> member provides for future extensibility of the structure and should be set to <b>TCL_OBJTYPE_V0</b>
       for compatibility of ObjType definitions prior to version 9.0. Specifics about versions will be described
       further in the sections below.

</pre><h4><b>ABSTRACT</b> <b>LIST</b> <b>TYPES</b></h4><pre>
       Additional fields in the Tcl_ObjType descriptor allow for control over how  custom  data  values  can  be
       manipulated  using  Tcl's  List  commands  without converting the value to a List type. This requires the
       custom type to provide functions that will perform the given operation on the custom data representation.
       Not all functions are required. In the absence of a particular function (set to NULL), the fallback is to
       allow the internal List operation to perform the operation, most likely causing  the  value  type  to  be
       converted to a traditional list.

   <b>SCALAR</b> <b>VALUE</b> <b>TYPES</b>
       For  a  custom  value  type that is scalar or atomic in nature, i.e., not a divisible collection, version
       <b>TCL_OBJTYPE_V1</b> is recommended. In this case, List commands will treat the scalar value as if it  where  a
       list of length 1, and not convert the value to a List type.

   <b>VERSION</b> <b>2:</b> <b>ABSTRACT</b> <b>LISTS</b>
       Version  2,  <b>TCL_OBJTYPE_V2</b>,  allows  full  List support when the functions described below are provided.
       This allows for script level use of the List commands without causing the type of the Tcl_Obj value to be
       converted to a list.

   <b>THE</b> <b>LENGTHPROC</b> <b>FIELD</b>
       The <b>LengthProc</b> function correlates with the <b>Tcl_ListObjLength</b> C API. The function returns the  number  of
       elements  in  the  list.  It  is  used  in  every  List  operation  and is required for all Abstract List
       implementations.
              typedef Tcl_Size
              (Tcl_ObjTypeLengthProc) (Tcl_Obj *listPtr);

   <b>THE</b> <b>INDEXPROC</b> <b>FIELD</b>
       The <b>IndexProc</b> function correlates with with the <b>Tcl_ListObjIndex</b> C API. The function  returns  a  Tcl_Obj
       value for the element at the specified index.
              typedef int (<b>Tcl_ObjTypeIndexProc</b>) (
                  Tcl_Interp *interp,
                  Tcl_Obj *listPtr,
                  Tcl_Size index,
                  Tcl_Obj** elemObj);

   <b>THE</b> <b>SLICEPROC</b> <b>FIELD</b>
       The  <b>SliceProc</b>  correlates with the <b>lrange</b> command, returning a new List or Abstract List for the portion
       of the original list specified.
              typedef int (<b>Tcl_ObjTypeSliceProc</b>) (
                  Tcl_Interp *interp,
                  Tcl_Obj *listPtr,
                  Tcl_Size fromIdx,
                  Tcl_Size toIdx,
                  Tcl_Obj **newObjPtr);

   <b>THE</b> <b>REVERSEPROC</b> <b>FIELD</b>
       The <b>ReverseProc</b> correlates with the <b>lreverse</b> command, returning a List or Abstract List that has the same
       elements as the input Abstract List, with the elements in the reverse order.
              typedef int (<b>Tcl_ObjTypeReverseProc</b>) (
                  Tcl_Interp *interp,
                  Tcl_Obj *listPtr,
                  Tcl_Obj **newObjPtr);

   <b>THE</b> <b>GETELEMENTS</b> <b>FIELD</b>
       The <b>GetElements</b> function returns a count and a pointer to an array  of  Tcl_Obj  values  for  the  entire
       Abstract List. This correlates to the <b>Tcl_ListObjGetElements</b> C API call.
              typedef int (<b>Tcl_ObjTypeGetElements</b>) (
                  Tcl_Interp *interp,
                  Tcl_Obj *listPtr,
                  Tcl_Size *objcptr,
                  Tcl_Obj ***objvptr);

   <b>THE</b> <b>SETELEMENT</b> <b>FIELD</b>
       The  <b>SetElement</b>  function replaces the element within the specified list at the give index. This function
       correlates to the <b>lset</b> command.
              typedef Tcl_Obj *(<b>Tcl_ObjTypeSetElement</b>) (
                  Tcl_Interp *interp,
                  Tcl_Obj *listPtr,
                  Tcl_Size indexCount,
                  Tcl_Obj *const indexArray[],
                  Tcl_Obj *valueObj);

   <b>REPLACEPROC</b> <b>FIELD</b>
       The <b>ReplaceProc</b> returns a new list after modifying the list replacing the elements  to  be  deleted,  and
       adding the elements to be inserted. This function correlates to the <b>Tcl_ListObjReplace</b> C API.
              typedef int (<b>Tcl_ObjTypeReplaceProc</b>) (
                  Tcl_Interp *interp,
                  Tcl_Obj *listObj,
                  Tcl_Size first,
                  Tcl_Size numToDelete,
                  Tcl_Size numToInsert,
                  Tcl_Obj *const insertObjs[]);

   <b>THE</b> <b>INOPERPROC</b> <b>FIELD</b>
       The  <b>InOperProc</b>  function  determines  whether  the  value  is  present  in  the given list, according to
       equivalent string comparison of elements. The <b>boolResult</b> is set to 1 (true) if the value is present,  and
       0 (false) if it is not present. This function implements the "in" and "ni" math operators for an abstract
       list.
              typedef int (<b>Tcl_ObjTypeInOperatorProc</b>) (
                  Tcl_Interp *interp,
                  Tcl_Obj *valueObj,
                  Tcl_Obj *listObj,
                  int *boolResult);

</pre><h4><b>REFERENCE</b> <b>COUNT</b> <b>MANAGEMENT</b></h4><pre>
       The  <u>objPtr</u>  argument to <b>Tcl_AppendAllObjTypes</b> should be an unshared value; this function will not modify
       the reference count of that value, but will modify its contents. If <u>objPtr</u> is not  (interpretable  as)  a
       list,  this  function will set the interpreter result and produce an error; using an unshared empty value
       is strongly recommended.

       The <u>objPtr</u> argument to <b>Tcl_ConvertToType</b> can have any non-zero reference count; this  function  will  not
       modify  the  reference  count,  but may write to the interpreter result on error so values that originate
       from there should have an additional reference made before calling this.

       None of the callback functions in the <b>Tcl_ObjType</b> structure should modify the reference  count  of  their
       arguments,  but  if  the  values contain subsidiary values (e.g., the elements of a list or the keys of a
       dictionary) then those subsidiary values may have their reference counts modified.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/Tcl_NewObj.3tcl.html">Tcl_NewObj</a>(3tcl), <a href="../man3tcl/Tcl_DecrRefCount.3tcl.html">Tcl_DecrRefCount</a>(3tcl), <a href="../man3tcl/Tcl_IncrRefCount.3tcl.html">Tcl_IncrRefCount</a>(3tcl), <a href="../man3tcl/Tcl_BounceRefCount.3tcl.html">Tcl_BounceRefCount</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       internal representation, value, value type, string representation, type conversion

Tcl                                                    9.0                                     <u><a href="../man3tcl/Tcl_ObjType.3tcl.html">Tcl_ObjType</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>