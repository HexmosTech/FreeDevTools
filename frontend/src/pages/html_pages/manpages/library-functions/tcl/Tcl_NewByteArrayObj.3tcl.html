<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_NewByteArrayObj,       Tcl_SetByteArrayObj,       Tcl_GetBytesFromObj,       Tcl_GetByteArrayFromObj,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_NewByteArrayObj,       Tcl_SetByteArrayObj,       Tcl_GetBytesFromObj,       Tcl_GetByteArrayFromObj,
       Tcl_SetByteArrayLength - manipulate a Tcl value as an array of bytes

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       Tcl_Obj *
       <b>Tcl_NewByteArrayObj</b>(<u>bytes,</u> <u>numBytes</u>)

       <b>Tcl_SetByteArrayObj</b>(<u>objPtr,</u> <u>bytes,</u> <u>numBytes</u>)

       unsigned char *                                                                                           2
       <b>Tcl_GetBytesFromObj</b>(<u>interp,</u> <u>objPtr,</u> <u>numBytesPtr</u>)                                                          2

       unsigned char *
       <b>Tcl_GetByteArrayFromObj</b>(<u>objPtr,</u> <u>numBytesPtr</u>)

       unsigned char *
       <b>Tcl_SetByteArrayLength</b>(<u>objPtr,</u> <u>numBytes</u>)

</pre><h4><b>ARGUMENTS</b></h4><pre>
       const unsigned char <u>*bytes</u> (in)                The array of bytes used to initialize or set a  byte-array
                                                      value. May be NULL even if <u>numBytes</u> is non-zero.

       Tcl_Size <u>numBytes</u> (in)                         The number of bytes in the array.

       Tcl_Obj <u>*objPtr</u> (in/out)                       For  <b>Tcl_SetByteArrayObj</b>, this points to an unshared value
                                                      to  be   overwritten   by   a   byte-array   value.    For
                                                      <b>Tcl_GetBytesFromObj</b>,      <b>Tcl_GetByteArrayFromObj</b>      and
                                                      <b>Tcl_SetByteArrayLength</b>, this  points  to  the  value  from
                                                      which to extract an array of bytes.

       Tcl_Interp <u>*interp</u> (in)                        Interpreter to use for error reporting.

       Tcl_Size | int <u>*numBytesPtr</u> (out)              Points to space where the number of bytes in the array may
                                                      be  written.  May be (Tcl_Size *)NULL when not used. If it
                                                      points to  a  variable  which  type  is  not  <b>Tcl_Size</b>,  a
                                                      compiler warning will be generated.  If your extensions is
                                                      compiled  with -DTCL_8_API, this function will return NULL
                                                      for byte arrays larger than INT_MAX (which should  trigger
                                                      proper error-handling), otherwise expect it to crash.
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  routines  are  used  to create, modify, store, transfer, and retrieve arbitrary binary data in Tcl
       values.  Specifically, data that can be represented as a sequence of arbitrary byte values is  supported.
       This  includes  data  read from binary channels, values created by the <b>binary</b> command, encrypted data, or
       other information representable as a finite byte sequence.

       A byte is an 8-bit quantity with no inherent meaning.  When the 8 bits  are  interpreted  as  an  integer
       value,  the  range of possible values is (0-255).  The C type best suited to store a byte is the <b>unsigned</b>
       <b>char</b>.  An <b>unsigned</b> <b>char</b> array of size <u>N</u> stores an arbitrary binary value of size <u>N</u> bytes.  We  call  this
       representation  a  byte-array.   Here  we document the routines that allow us to operate on Tcl values as
       byte-arrays.

       All Tcl values must correspond to a string representation.  When a byte-array value must be processed  as
       a  string,  the sequence of <u>N</u> bytes is transformed into the corresponding sequence of <u>N</u> characters, where
       each byte value transforms to the same  character  codepoint  value  in  the  range  (U+0000  -  U+00FF).
       Obtaining the string representation of a byte-array value (by calling <b>Tcl_GetStringFromObj</b>) produces this
       string in Tcl's usual Modified UTF-8 encoding.

       <b>Tcl_NewByteArrayObj</b>  and  <b>Tcl_SetByteArrayObj</b> create a new value or overwrite an existing unshared value,
       respectively, to hold a byte-array value of <u>numBytes</u> bytes.  When a caller passes  a  non-NULL  value  of
       <u>bytes</u>,  it  must point to memory from which <u>numBytes</u> bytes can be read.  These routines allocate <u>numBytes</u>
       bytes of memory, copy  <u>numBytes</u>  bytes  from  <u>bytes</u>  into  it,  and  keep  the  result  in  the  internal
       representation  of  the new or overwritten value.  When the caller passes a NULL value of <u>bytes</u>, the data
       copying step is skipped, and the bytes stored in the value are undefined.   A  <u>bytes</u>  value  of  NULL  is
       useful  only  when  the caller will arrange to write known contents into the byte-array through a pointer
       retrieved by a call to one of the routines explained below.  <b>Tcl_NewByteArrayObj</b> returns a pointer to the
       created value with a reference count of zero.  <b>Tcl_SetByteArrayObj</b> overwrites  and  invalidates  any  old
       contents  of  the  unshared <u>objPtr</u> as appropriate, and keeps its reference count (0 or 1) unchanged.  The
       value produced by these routines has no string representation.  Any memory allocation failure may cause a
       panic.

       <b>Tcl_GetBytesFromObj</b> performs the opposite function of <b>Tcl_SetByteArrayObj</b>, providing  access  to  read  a
       byte-array  from  a  Tcl  value  that  was previously written into it.  When <u>objPtr</u> is a value previously
       produced by <b>Tcl_NewByteArrayObj</b> or <b>Tcl_SetByteArrayObj</b>, then <b>Tcl_GetBytesFromObj</b> returns a pointer to the
       byte-array kept in the value's internal representation.  If the caller  provides  a  non-NULL  value  for
       <u>numBytesPtr</u>,  it  must  point  to  memory  where <b>Tcl_GetBytesFromObj</b> can write the number of bytes in the
       value's internal byte-array.  With both pieces of  information,  the  caller  is  able  to  retrieve  any
       information about the contents of that byte-array that it seeks.  When <u>objPtr</u> does not already contain an
       internal  byte-array,  <b>Tcl_GetBytesFromObj</b> will try to create one from the value's string representation.
       Any string value that does not include any character codepoints outside the range (U+0000 - U+00FF)  will
       successfully translate to a unique byte-array value.  With the created byte-array, the routine returns as
       before.  For any string representation which does contain a forbidden character codepoint, the conversion
       fails,  and <b>Tcl_GetBytesFromObj</b> returns NULL to signal that failure.  On failure, nothing will be written
       to <u>numBytesPtr</u>, and if the <u>interp</u> argument is non-NULL, then error messages and  codes  are  left  in  it
       recording the error.

       <b>Tcl_GetByteArrayFromObj</b>  performs  exactly the same function as <b>Tcl_GetBytesFromObj</b> does when called with
       the <u>interp</u> argument passed the value NULL.  This is incompatible  with  the  way  <b>Tcl_GetByteArrayFromObj</b>
       functioned in Tcl 8.  <b>Tcl_GetBytesFromObj</b> is the more capable interface and should usually be favored for
       use over <b>Tcl_GetByteArrayFromObj</b>.

       On  success,  both  <b>Tcl_GetBytesFromObj</b>  and  <b>Tcl_GetByteArrayFromObj</b>  return a pointer into the internal
       representation of a <b>Tcl_Obj</b>.  That pointer must not be freed by the caller, and should  not  be  retained
       for  use  beyond  the  known  time  the internal representation of the value has not been disturbed.  The
       pointer may be used to overwrite the byte contents of the internal representation, so long as  the  value
       is unshared and any string representation is invalidated.

       On  success,  both <b>Tcl_GetBytesFromObj</b> and <b>Tcl_GetByteArrayFromObj</b> write the number of bytes in the byte-
       array value of <u>objPtr</u> to the space pointed to by <u>numBytesPtr</u>.  This space may be of type <b>Tcl_Size</b>  or  of
       type  <b>int</b>.   It  is  recommended  that  callers provide a <b>Tcl_Size</b> space for this purpose.  If the caller
       provides only an <b>int</b> space and the number of bytes in the byte-array value  of  <u>objPtr</u>  is  greater  than
       <b>INT_MAX</b>, the routine will fail due to being unable to correctly report the byte-array size to the caller.
       The  ability  to  provide  an  <b>int</b>  space is best considered a migration aid for codebases constrained to
       continue operating with Tcl releases older than 9.0.

       <b>Tcl_SetByteArrayLength</b> enables a caller to change the size of a byte-array in the internal representation
       of an unshared <u>objPtr</u> to become <u>numBytes</u> bytes.  This is  most  often  useful  after  the  bytes  of  the
       internal  byte-array  have  been  directly  overwritten and it has been discovered that the required size
       differs from the first estimate used in the allocation. <b>Tcl_SetByteArrayLength</b> returns a pointer  to  the
       resized   byte-array.    Because   resizing   the   byte-array   changes   the  internal  representation,
       <b>Tcl_SetByteArrayLength</b> also invalidates any string representation in <u>objPtr</u>.  If resizing grows the byte-
       array, the new byte values are undefined.  If <u>objPtr</u> does not already possess an internal byte-array, one
       is produced in the same way that <b>Tcl_GetBytesFromObj</b> does, also returning NULL when any characters of the
       value in <u>objPtr</u> (up to <u>numBytes</u> of them) are not valid bytes.

</pre><h4><b>REFERENCE</b> <b>COUNT</b> <b>MANAGEMENT</b></h4><pre>
       <b>Tcl_NewByteArrayObj</b> always returns a zero-reference object, much like <b>Tcl_NewObj</b>.

       <b>Tcl_SetByteArrayObj</b> and <b>Tcl_SetByteArrayLength</b>  do  not  modify  the  reference  count  of  their  <u>objPtr</u>
       arguments, but do require that the object be unshared.

       <b>Tcl_GetBytesFromObj</b>  and  <b>Tcl_GetByteArrayFromObj</b>  do not modify the reference count of <u>objPtr</u>; they only
       read.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Tcl_GetStringFromObj, Tcl_NewObj, Tcl_IncrRefCount, Tcl_DecrRefCount

</pre><h4><b>KEYWORDS</b></h4><pre>
       value, binary data, byte array, utf, unicode

Tcl                                                    9.0                                <u><a href="../man3tcl/Tcl_ByteArrayObj.3tcl.html">Tcl_ByteArrayObj</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>