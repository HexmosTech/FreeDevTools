<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl - Tcl extension module for Perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtcl-perl">libtcl-perl_1.32+ds-1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl - Tcl extension module for Perl

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Tcl;

           $interp = Tcl-&gt;new;
           $interp-&gt;Eval('puts "Hello world"');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The Tcl extension module gives access to the Tcl library with functionality and interface similar to the
       C functions of Tcl.  In other words, you can

       •   create Tcl interpreters

           The  Tcl  interpreters  so created are Perl objects whose destructors delete the interpreters cleanly
           when appropriate.

       •   execute Tcl code in an interpreter

           The code can come from strings, files or Perl filehandles.

       •   bind in new Tcl procedures

           The new procedures can be either C  code  (with  addresses  presumably  obtained  using  <u>dl_open</u>  and
           <u>dl_find_symbol</u>)  or  Perl  subroutines  (by  name,  reference  or  as anonymous subs). The (optional)
           deleteProc callback in the latter case is another perl subroutine which is called when the command is
           explicitly deleted by name or else when the destructor for the interpreter object  is  explicitly  or
           implicitly called.

       •   Manipulate the result field of a Tcl interpreter

       •   Set and get values of variables in a Tcl interpreter

       •   Tie perl variables to variables in a Tcl interpreter

           The variables can be either scalars or hashes.

   <b>Methods</b> <b>in</b> <b>class</b> <b>Tcl</b>
       To create a new Tcl interpreter, use

           $interp = Tcl-&gt;new;

       The  following  methods  and  routines  can then be used on the Perl object returned (the object argument
       omitted in each case).

       $interp-&gt;Init ()
           Invoke <u>Tcl_Init</u> on the interpreter.

       $interp-&gt;CreateSlave (NAME, SAFE)
           Invoke <u>Tcl_CreateSlave</u> on the interpreter.  Name is arbitrary.  The safe variable, if true, creates a
           safe sandbox interpreter.
            See: <a href="http://www.tcl.tk/software/plugin/safetcl.html">http://www.tcl.tk/software/plugin/safetcl.html</a>
                 <a href="http://www.tcl.tk/man/tcl8.4/TclCmd/safe.htm">http://www.tcl.tk/man/tcl8.4/TclCmd/safe.htm</a>

           This command returns a new interpreter.

       $interp-&gt;Eval (STRING, FLAGS)
           Evaluate script STRING in the interpreter. If the script returns successfully (TCL_OK) then the  Perl
           return  value corresponds to Tcl interpreter's result otherwise a <u>die</u> exception is raised with the $@
           variable corresponding to Tcl's interpreter result object. In each case, <u>corresponds</u>  means  that  if
           the method is called in scalar context then the string result is returned but if the method is called
           in  list context then the result is split as a Tcl list and returned as a Perl list.  The FLAGS field
           is optional and can be a bitwise OR of the constants Tcl::EVAL_GLOBAL or Tcl::EVAL_DIRECT.

       $interp-&gt;GlobalEval (STRING)
           REMOVED.  Evaluate script STRING at global level.  Call <u>Eval</u>(STRING, Tcl::EVAL_GLOBAL) instead.

       $interp-&gt;EvalFile (FILENAME)
           Evaluate the contents of the file with name FILENAME. Otherwise, the same as <u>Eval</u>() above.

       $interp-&gt;EvalFileHandle (FILEHANDLE)
           Evaluate the contents of the Perl filehandle FILEHANDLE. Otherwise, the same as <u>Eval</u>() above.  Useful
           when using the filehandle DATA to tack on a Tcl script following an __END__ token.

       $interp-&gt;call (PROC, ARG, ...)
           Looks  up  procedure  PROC  in  the  interpreter  and invokes it using Tcl's eval semantics that does
           command tracing and will use the ::unknown (AUTOLOAD) mechanism.  The arguments (ARG,  ...)  are  not
           passed through the Tcl parser.  For example, spaces embedded in any ARG will not cause it to be split
           into two Tcl arguments before being passed to PROC.

           Before invoking procedure PROC special processing is performed on ARG list:

           1.   All  subroutine  references within ARG will be substituted with Tcl name which is responsible to
           invoke this subroutine. This Tcl name will be created using CreateCommand subroutine (see below).

           2.  All  references  to  scalars  will  be  substituted  with  names  of  Tcl  variables  transformed
           appropriately.

           These first two items allow one to write and expect it to work properly such code as:

             my $r = 'aaaa';
             button(".d", -textvariable =&gt; \$r, -command=&gt;sub {$r++});

           3.  All  references  to  hashes  will  be  substituted  with names of Tcl array variables transformed
           appropriately.

           4.  As a special case, there is a mechanism to deal with  Tk's  special  event  variables  (they  are
           mentioned  as  '%x',  '%y' and so on throughout Tcl).  When creating a subroutine reference that uses
           such variables, you must declare the desired variables using Tcl::Ev as the  first  argument  to  the
           subroutine.  Example:

             sub textPaste {
                 my ($x,$y,$w) = @_;
                 widget($w)-&gt;insert("\@$x,$y", $interp-&gt;Eval('selection get'));
             }
             $widget-&gt;bind('&lt;2&gt;', [\&amp;textPaste, Tcl::Ev('%x', '%y'), $widget] );

       $interp-&gt;return_ref (NAME)
           returns   a   reference  corresponding  to  NAME,  which  was  associated  during  previously  called
           "$interpnt-&gt;call(...)" preprocessing. As a typical example this could be variable associated  with  a
           widget.

       $interp-&gt;delete_ref (NAME)
           deletes  and returns a reference corresponding to NAME, which was associated during previously called
           "$interpnt-&gt;call(...)" preprocessing.  this follows _code_dispose about if NAME is  a  TClNAME  or  a
           DESCNAME.  if NAME is a VARNAME then it is just deleted and returned.

       $interp-&gt;icall (PROC, ARG, ...)
           Looks  up  procedure  PROC  in  the  interpreter  and invokes it using Tcl's eval semantics that does
           command tracing and will use the ::unknown (AUTOLOAD) mechanism.  The arguments (ARG,  ...)  are  not
           passed through the Tcl parser.  For example, spaces embedded in any ARG will not cause it to be split
           into two Tcl arguments before being passed to PROC.

           This  is  the lower-level procedure that the 'call' method uses.  Arguments are converted efficiently
           from Perl SVs to Tcl_Objs.  A Perl AV array becomes a Tcl_ListObj, an SvIV becomes a Tcl_IntObj, etc.
           The reverse conversion is done to the result.

       $interp-&gt;invoke (PROC, ARG, ...)
           Looks up procedure PROC in the interpreter and invokes it directly with arguments (ARG, ...)  without
           passing through the Tcl parser. For example, spaces embedded in any ARG will not cause it to be split
           into two Tcl arguments before being passed to PROC.  This differs from icall/call in that it directly
           invokes  the  command  name  without  allowing  for  command  tracing  or making use of Tcl's unknown
           (AUTOLOAD) mechanism.  If the command does not already exist in the interpreter,  an  error  will  be
           thrown.

           Arguments  are  converted  efficiently  from  Perl  SVs  to  Tcl_Objs.   A  Perl  AV  array becomes a
           Tcl_ListObj, an SvIV becomes a Tcl_IntObj, etc.  The reverse conversion is done to the result.

       Tcl::Ev (FIELD, ...)
           Used to declare %-substitution variables of interest to a subroutine callback.  FIELD is expected  to
           be  of  the form "%#" where # is a single character, and multiple fields may be specified.  Returns a
           blessed object that the 'call' method will recognize when it is passed as the  first  argument  to  a
           subroutine in a callback.  See description of 'call' method for details.

       $interp-&gt;result ()
           Returns the current Tcl interpreter result. List v. scalar context is handled as in <u>Eval</u>() above.

       $interp-&gt;CreateCommand (CMDNAME, CMDPROC, CLIENTDATA, DELETEPROC, FLAGS)
           Binds a new procedure named CMDNAME into the interpreter. The CLIENTDATA and DELETEPROC arguments are
           optional. There are two cases:

           (1) CMDPROC is the address of a C function

           (presumably  obtained  using  <u>dl_open</u>  and <u>dl_find_symbol</u>. In this case CLIENTDATA and DELETEPROC are
           taken to be raw data of the ClientData and deleteProc field presumably obtained in a similar way.

           (2) CMDPROC is a Perl subroutine

           (either a sub name, a sub reference or an anonymous sub). In this case CLIENTDATA  can  be  any  perl
           scalar (e.g. a ref to some other data) and DELETEPROC must be a perl sub too. When CMDNAME is invoked
           in the Tcl interpreter, the arguments passed to the Perl sub CMDPROC are

               (CLIENTDATA, INTERP, LIST)

           where INTERP is a Perl object for the Tcl interpreter which called out and LIST is a Perl list of the
           arguments  CMDNAME  was  called with.  If the 1-bit of FLAGS is set then the 3 first arguments on the
           call to CMDPROC are suppressed.  As usual in Tcl, the first element of the list  is  CMDNAME  itself.
           When  CMDNAME  is  deleted  from the interpreter (either explicitly with <u>DeleteCommand</u> or because the
           destructor for the interpreter object is called), it is passed the single argument CLIENTDATA.

       $interp-&gt;DeleteCommand (CMDNAME)
           Deletes command CMDNAME from the interpreter. If the command  was  created  with  a  DELETEPROC  (see
           <u>CreateCommand</u>  above),  then  it is invoked at this point. When a Tcl interpreter object is destroyed
           either explicitly or implicitly, an implicit <u>DeleteCommand</u> happens on all  its  currently  registered
           commands.

       (TCLNAME,GENCODE) = $interp-&gt;create_tcl_sub(CODEREF, EVENTS, TCLNAME, DESCRNAME)
           Creates  a  COMMAND  called  TCLNAME  calling  CODEREF in the interpreter $interp, and adds it to the
           internal tracking structure.  DESCRNAME and TCLNAME should not begin with "=" or "@" or "::perl::" to
           avoid collisions.  If TCLNAME IS blank or undef, it is constructed from the CODEREF address.  GENCODE
           starts as TCLNAME but gets @$EVENTS which can contain %vars joined to it.

           TCLNAME and DESCRNAME get stored in an internal structure, and can be used to purge things  from  the
           command table via code_destroy or $interp-&gt;delete_ref;

           Returns  (TCLNAME,GENCODE).  if you are creating code refs with this you can continue to use the same
           coderef and it will be converted on each call.  but if you save GENCODE, you can  replace  the  anon-
           coderef call in the tcl command with GENCODE.

           for instance

             $interp-&gt;call('FILEEVENT',$fileref,WRITABLE=&gt;sub {...});

           can be replaced by

             my ($tclcode,$gencode)=$interp-&gt;create_tcl_sub(sub{...}, EVENTS, TCLNAME, DESCRNAME);
             $interp-&gt;call('FILEEVENT',$gencode,WRITABLE=&gt;$gencode);

           or

             my $sub=sub{....};
             $interp-&gt;call('FILEEVENT',$fileref,WRITABLE=&gt;$sub);

           can be replaced by

             my ($tclcode,$gencode)=$interp-&gt;create_tcl_sub($sub, EVENTS, TCLNAME, DESCRNAME);
             $interp-&gt;call('FILEEVENT',$gencode,WRITABLE=&gt;$gencode);

           although

             $interp-&gt;call('FILEEVENT',$fileref,WRITABLE=&gt;$sub);

           will still work fine, too.

           Then you later call

             $interp-&gt;delete_ref($tclname);

           when  you  are finished with that sub to clean it from the internal tracking and command table.  This
           means no automatic cleanup will occur on the sub{...} or $sub

           And after the destroy inside Tcl any triggering writable on $fileref will fail as well.  so it should
           be replaced first via
             $interp-&gt;call('FILEEVENT',$fileref,WRITABLE=&gt;'');

       (CODEREF) = Tcl::_code_dispose(NAME)
           Purges the internal table of a NAME and may initiate destruction of something created  thru  call  or
           create_tcl_sub

           TCLNAME  and  DESCRNAME get stored in an internal structure, and can be used to purge things form the
           command table.  calling _code_dispose on a TCLNAME  returned  from  create_tcl_sub  removes  all  use
           instances   and   purges  the  command  table.   calling  _code_dispose  on  a  DESCRNAME  passed  to
           create_tcl_sub removes only that instance Code used in a DESCRNAME may be used  in  other  places  as
           well, only when the last usage is purged does the entry get purged from the command table

           While the internal tracking structure saves the INTERP the code was added to, it itself does not keep
           things  separated  by  INTERP, A TCLNAME or DESCRNAME can only exist in one INTERP at a time, using a
           new INTERP just causes the one in the last INTERP to disappear, and probably end up with the Tcl code
           getting deleted

           Returns (CODEREF), this is the original coderef

       $interp-&gt;SetResult (STRING)
           Sets Tcl interpreter result to STRING.

       $interp-&gt;AppendResult (LIST)
           Appends each element of LIST to Tcl's interpreter result object.

       $interp-&gt;AppendElement (STRING)
           Appends STRING to Tcl interpreter result object as an extra Tcl list element.

       $interp-&gt;ResetResult ()
           Resets Tcl interpreter result.

       $interp-&gt;SplitList (STRING)
           Splits STRING as a Tcl list. Returns a Perl list or the empty list if there was an error (i.e. STRING
           was not a properly formed Tcl list).  In the  latter  case,  the  error  message  is  left  in  Tcl's
           interpreter result object.

       $interp-&gt;SetVar (VARNAME, VALUE, FLAGS)
           The  FLAGS  field  is  optional.  Sets  Tcl  variable  VARNAME in the interpreter to VALUE. The FLAGS
           argument is the  usual  Tcl  one  and  can  be  a  bitwise  OR  of  the  constants  Tcl::GLOBAL_ONLY,
           Tcl::LEAVE_ERR_MSG, Tcl::APPEND_VALUE, Tcl::LIST_ELEMENT.

       $interp-&gt;SetVar2 (VARNAME1, VARNAME2, VALUE, FLAGS)
           Sets  the  element VARNAME1(VARNAME2) of a Tcl array to VALUE. The optional argument FLAGS behaves as
           in <u>SetVar</u> above.

       $interp-&gt;GetVar (VARNAME, FLAGS)
           Returns the value of Tcl variable VARNAME. The optional argument FLAGS behaves as in <u>SetVar</u> above.

       $interp-&gt;GetVar2 (VARNAME1, VARNAME2, FLAGS)
           Returns the value of the element VARNAME1(VARNAME2) of a Tcl  array.   The  optional  argument  FLAGS
           behaves as in <u>SetVar</u> above.

       $interp-&gt;UnsetVar (VARNAME, FLAGS)
           Unsets Tcl variable VARNAME. The optional argument FLAGS behaves as in <u>SetVar</u> above.

       $interp-&gt;UnsetVar2 (VARNAME1, VARNAME2, FLAGS)
           Unsets  the  element  VARNAME1(VARNAME2)  of  a Tcl array.  The optional argument FLAGS behaves as in
           <u>SetVar</u> above.

       $interp-&gt;InterpDeleted ()
           See Tcl C API documentation for <u>Tcl_InterpDeleted</u>().

   <b>Linking</b> <b>Perl</b> <b>and</b> <b>Tcl</b> <b>variables</b>
       You can <u>tie</u> a Perl variable (scalar or hash) into class Tcl::Var  so  that  changes  to  a  Tcl  variable
       automatically  "change"  the  value of the Perl variable. In fact, as usual with Perl tied variables, its
       current value is just fetched from the Tcl variable when needed and setting the  Perl  variable  triggers
       the setting of the Tcl variable.

       To  tie  a  Perl  scalar <u>$scalar</u> to the Tcl variable <u>tclscalar</u> in interpreter <u>$interp</u> with optional flags
       <u>$flags</u> (see <u>SetVar</u> above), use

               tie $scalar, "Tcl::Var", $interp, "tclscalar", $flags;

       Omit the <u>$flags</u> argument if not wanted.

       To tie a Perl hash <u>%hash</u> to the Tcl array variable <u>array</u>  in  interpreter  <u>$interp</u>  with  optional  flags
       <u>$flags</u> (see <u>SetVar</u> above), use

               tie %hash, "Tcl::Var", $interp, "array", $flags;

       Omit  the  <u>$flags</u>  argument  if  not wanted. Any alteration to Perl variable <u>$hash{"key"}</u> affects the Tcl
       variable <u>array(key)</u> and <u>vice</u> <u>versa</u>.

   <b>Accessing</b> <b>Perl</b> <b>from</b> <b>within</b> <b>Tcl</b>
       After creation of Tcl interpreter, in addition to evaluation of Tcl/Tk commands within  Perl,  other  way
       round also instantiated. Within a special namespace " ::perl " following objects are created:

          ::perl::Eval

       So it is possible to use Perl objects from within Tcl.

</pre><h4><b>Other</b> <b>Tcl</b> <b>interpreter</b> <b>methods</b></h4><pre>
       export_to_tcl method
         An  interpreter method, export_to_tcl, is used to expose a number of perl subroutines and variables all
         at once into tcl/tk.

         <b>export_to_tcl</b> takes a hash as arguments, which represents  named  parameters,  with  following  allowed
         values:

         <b>namespace</b> =&gt; '...'
             tcl  namespace,  where  commands  and  variables  are  to  be created, defaults to 'perl'. If '' is
             specified - then global namespace is used. A possible '::' at end is stripped.

         <b>subs</b> =&gt; { ... }
             anonymous hash of subs to be created in Tcl, in the form /tcl name/ =&gt; /code ref/

         <b>vars</b> =&gt; { ... }
             anonymous hash of vars to be created in Tcl, in the form /tcl name/ =&gt; /code ref/

         <b>subs_from</b> =&gt; '...'
             a name of Perl namespace, from where all existing subroutines will be searched and Tcl command will
             be created for each of them.

         <b>vars_from</b> =&gt; '...'
             a name of Perl namespace, from where all  existing  variables  will  be  searched,  and  each  such
             variable will be tied to Tcl.

         An example:

           use strict;
           use Tcl;

           my $int = Tcl-&gt;new;

           $tcl::foo = 'qwerty';
           $int-&gt;export_to_tcl(subs_from=&gt;'tcl',vars_from=&gt;'tcl');

           $int-&gt;Eval(&lt;&lt;'EOS');
           package require Tk

           button .b1 -text {a fluffy button} -command perl::fluffy_sub
           button .b2 -text {a foo button} -command perl::foo
           entry .e -textvariable perl::foo
           pack .b1 .b2 .e
           focus .b2

           tkwait window .
           EOS

           sub tcl::fluffy_sub {
               print "Hi, I am a fluffy sub\n";
           }
           sub tcl::foo {
               print "Hi, I am foo\n";
               $tcl::foo++;
           }

       <b>export_tcl_namespace</b>
         extra convenience sub, binds to tcl all subs and vars from perl <b>tcl::</b> namespace

</pre><h4><b>AUTHORS</b></h4><pre>
        Malcolm Beattie, 23 Oct 1994
        Vadim Konovalov, 19 May 2003
        Jeff Hobbs, jeff (a) activestate . com, 22 Mar 2004
        Gisle Aas, gisle (a) activestate . com, 14 Apr 2004

       Special  thanks  for  contributions  to  Jan  Dubois, Slaven Rezic, Paul Cochrane, Huck Finn, Christopher
       Chavez, SJ Luo.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

       See <a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a>

perl v5.40.0                                       2024-10-20                                           <u><a href="../man3pm/Tcl.3pm.html">Tcl</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>