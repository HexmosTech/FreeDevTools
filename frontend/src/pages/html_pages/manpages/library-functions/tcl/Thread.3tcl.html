<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_ConditionNotify,    Tcl_ConditionWait,   Tcl_ConditionFinalize,   Tcl_GetThreadData,   Tcl_MutexLock,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_ConditionNotify,    Tcl_ConditionWait,   Tcl_ConditionFinalize,   Tcl_GetThreadData,   Tcl_MutexLock,
       Tcl_MutexUnlock, Tcl_MutexFinalize, Tcl_CreateThread, Tcl_JoinThread - Tcl thread support

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       <b>Tcl_ConditionNotify</b>(<u>condPtr</u>)

       <b>Tcl_ConditionWait</b>(<u>condPtr,</u> <u>mutexPtr,</u> <u>timePtr</u>)

       <b>Tcl_ConditionFinalize</b>(<u>condPtr</u>)

       void *
       <b>Tcl_GetThreadData</b>(<u>keyPtr,</u> <u>size</u>)

       <b>Tcl_MutexLock</b>(<u>mutexPtr</u>)

       <b>Tcl_MutexUnlock</b>(<u>mutexPtr</u>)

       <b>Tcl_MutexFinalize</b>(<u>mutexPtr</u>)

       int
       <b>Tcl_CreateThread</b>(<u>idPtr,</u> <u>proc,</u> <u>clientData,</u> <u>stackSize,</u> <u>flags</u>)

       int
       <b>Tcl_JoinThread</b>(<u>id,</u> <u>result</u>)

</pre><h4><b>ARGUMENTS</b></h4><pre>
       Tcl_Condition <u>*condPtr</u> (in)             A condition variable, which must be associated with a mutex lock.

       Tcl_Mutex <u>*mutexPtr</u> (in)                A recursive mutex lock.                                           2

       const Tcl_Time <u>*timePtr</u> (in)            A time limit on the condition wait.  NULL to wait forever.   Note
                                               that a polling value of 0 seconds does not make much sense.

       Tcl_ThreadDataKey <u>*keyPtr</u> (in)          This  identifies a block of thread local storage.  The key should
                                               be  static  and  process-wide,  yet  each  thread  will  end   up
                                               associating a different block of storage with this key.

       int <u>*size</u> (in)                          The  size of the thread local storage block.  This amount of data
                                               is allocated and initialized to zero the first time  each  thread
                                               calls <b>Tcl_GetThreadData</b>.

       Tcl_ThreadId <u>*idPtr</u> (out)               The  referred  storage  will  contain the id of the newly created
                                               thread as returned by the operating system.

       Tcl_ThreadId <u>id</u> (in)                    Id of the thread waited upon.

       Tcl_ThreadCreateProc <u>*proc</u> (in)         This procedure will act  as  the  <b>main()</b>  of  the  newly  created
                                               thread. The specified <u>clientData</u> will be its sole argument.

       void <u>*clientData</u> (in)                   Arbitrary information. Passed as sole argument to the <u>proc</u>.

       size_t <u>stackSize</u> (in)                   The size of the stack given to the new thread.

       int <u>flags</u> (in)                          Bitmask  containing  flags allowing the caller to modify behavior
                                               of the new thread.

       int <u>*result</u> (out)                       The referred storage is used to place the exit code of the thread
                                               waited upon into it.
________________________________________________________________________________________________________________

</pre><h4><b>INTRODUCTION</b></h4><pre>
       Beginning with the 8.1 release, the Tcl core is thread safe, which allows you  to  incorporate  Tcl  into
       multithreaded applications without customizing the Tcl core.

       An  important  constraint  of  the  Tcl threads implementation is that <u>only</u> <u>the</u> <u>thread</u> <u>that</u> <u>created</u> <u>a</u> <u>Tcl</u>
       <u>interpreter</u> <u>can</u> <u>use</u> <u>that</u> <u>interpreter</u>.  In other words, multiple threads  can  not  access  the  same  Tcl
       interpreter.  (However, a single thread can safely create and use multiple interpreters.)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Tcl  provides <b>Tcl_CreateThread</b> for creating threads. The caller can determine the size of the stack given
       to the new thread and modify the behavior through the supplied <u>flags</u>. The value  <b>TCL_THREAD_STACK_DEFAULT</b>
       for  the <u>stackSize</u> indicates that the default size as specified by the operating system is to be used for
       the new thread. As for the flags, currently only the values  <b>TCL_THREAD_NOFLAGS</b>  and  <b>TCL_THREAD_JOINABLE</b>
       are  defined.  The first of them invokes the default behavior with no special settings.  Using the second
       value marks the new thread as <u>joinable</u>. This means that another thread  can  wait  for  the  such  marked
       thread to exit and join it.

       Restrictions:  On some UNIX systems the pthread-library does not contain the functionality to specify the
       stack size of a thread. The specified value for the stack size is  ignored  on  these  systems.   Windows
       currently does not support joinable threads. This flag value is therefore ignored on this platform.

       Tcl  provides  the  <b>Tcl_ExitThread</b>  and <b>Tcl_FinalizeThread</b> functions for terminating threads and invoking
       optional per-thread exit handlers.  See the <b>Tcl_Exit</b> page for more information on these procedures.

       The <b>Tcl_JoinThread</b> function is provided to allow threads to wait upon the exit of another  thread,  which
       must  have  been marked as joinable through usage of the <b>TCL_THREAD_JOINABLE</b>-flag during its creation via
       <b>Tcl_CreateThread</b>.

       Trying to wait for the exit of a non-joinable thread or a thread which is already waited upon will result
       in an error. Waiting for a joinable thread which already exited is possible, the system will  retain  the
       necessary information until after the call to <b>Tcl_JoinThread</b>.  This means that not calling <b>Tcl_JoinThread</b>
       for a joinable thread will cause a memory leak.

       The  <b>Tcl_GetThreadData</b>  call  returns a pointer to a block of thread-private data.  Its argument is a key
       that is shared by all threads and a size  for  the  block  of  storage.   The  storage  is  automatically
       allocated  and  initialized  to  all  zeros  the  first  time  each  thread  asks for it.  The storage is
       automatically deallocated by <b>Tcl_FinalizeThread</b>.

   <b>SYNCHRONIZATION</b> <b>AND</b> <b>COMMUNICATION</b>
       Tcl provides <b>Tcl_ThreadQueueEvent</b>  and  <b>Tcl_ThreadAlert</b>  for  handling  event  queuing  in  multithreaded
       applications.  See the <b>Notifier</b> manual page for more information on these procedures.

       A  mutex is a lock that is used to serialize all threads through a piece of code by calling <b>Tcl_MutexLock</b>
       and <b>Tcl_MutexUnlock</b>.  If one thread holds a mutex, any other  thread  calling  <b>Tcl_MutexLock</b>  will  block
       until  <b>Tcl_MutexUnlock</b>  is  called.  A mutex can be destroyed after its use by calling <b>Tcl_MutexFinalize</b>. 2
       Mutexes are reentrant: they can be locked several times from the  same  thread.  However  there  must  be 2
       exactly  one  call  to  <b>Tcl_MutexUnlock</b> for each call to <b>Tcl_MutexLock</b> in order for a thread to release a 2
       mutex completely.  The <b>Tcl_MutexLock</b>, <b>Tcl_MutexUnlock</b> and <b>Tcl_MutexFinalize</b>  procedures  are  defined  as
       empty  macros  if  not  compiling with threads enabled.  For declaration of mutexes the <b>TCL_DECLARE_MUTEX</b>
       macro should be used.  This macro assures correct mutex handling even when the core is  compiled  without
       threads enabled.

       A  condition  variable  is  used  as  a signaling mechanism: a thread can lock a mutex and then wait on a
       condition variable with <b>Tcl_ConditionWait</b>.  This atomically  releases  the  mutex  lock  and  blocks  the
       waiting  thread until another thread calls <b>Tcl_ConditionNotify</b>.  The caller of <b>Tcl_ConditionNotify</b> should
       have the associated mutex held by previously calling <b>Tcl_MutexLock</b>, but this is not enforced.   Notifying
       the  condition  variable  unblocks all threads waiting on the condition variable, but they do not proceed
       until the mutex is released with <b>Tcl_MutexUnlock</b>.  The implementation of <b>Tcl_ConditionWait</b>  automatically
       locks the mutex before returning.

       The   caller   of   <b>Tcl_ConditionWait</b>   should   be   prepared  for  spurious  notifications  by  calling
       <b>Tcl_ConditionWait</b> within a while loop that tests some invariant.

       A condition variable can be destroyed after its use by calling <b>Tcl_ConditionFinalize</b>.

       The <b>Tcl_ConditionNotify</b>, <b>Tcl_ConditionWait</b> and <b>Tcl_ConditionFinalize</b>  procedures  are  defined  as  empty
       macros if not compiling with threads enabled.

   <b>INITIALIZATION</b>
       All of these synchronization objects are self-initializing.  They are implemented as opaque pointers that
       should be NULL upon first use.  The mutexes and condition variables are either cleaned up by process exit
       handlers  (if  living  that  long)  or explicitly by calls to <b>Tcl_MutexFinalize</b> or <b>Tcl_ConditionFinalize</b>.
       Thread local storage is reclaimed during <b>Tcl_FinalizeThread</b>.

</pre><h4><b>SCRIPT-LEVEL</b> <b>ACCESS</b> <b>TO</b> <b>THREADS</b></h4><pre>
       Tcl provides no built-in commands for scripts to use to create, manage, or join threads, nor any  script-
       level  access  to  mutex  or condition variables.  It provides such facilities only via C interfaces, and
       leaves it up to packages to expose these matters to the script level.  One such  package  is  the  <b>Thread</b>
       package.

</pre><h4><b>EXAMPLE</b></h4><pre>
       To create a thread with portable code, its implementation function should be declared as follows:

              static <b>Tcl_ThreadCreateProc</b> MyThreadImplFunc;

       It should then be defined like this example, which just counts up to a given value and then finishes.

              static <b>Tcl_ThreadCreateType</b>
              MyThreadImplFunc(
                  void *clientData)
              {
                  int i, limit = (int) clientData;
                  for (i=0 ; i&lt;limit ; i++) {
                      /* doing nothing at all here */
                  }
                  <b>TCL_THREAD_CREATE_RETURN</b>;
              }

       To create the above thread, make it execute, and wait for it to finish, we would do this:

              int limit = 1000000000;
              void *limitData = (void*)((intptr_t) limit);
              Tcl_ThreadId id;    <u>/*</u> <u>holds</u> <u>identity</u> <u>of</u> <u>thread</u> <u>created</u> <u>*/</u>
              int result;

              if (<b>Tcl_CreateThread</b>(&amp;id, MyThreadImplFunc, limitData,
                      <b>TCL_THREAD_STACK_DEFAULT</b>,
                      <b>TCL_THREAD_JOINABLE</b>) != TCL_OK) {
                  <u>/*</u> <u>Thread</u> <u>did</u> <u>not</u> <u>create</u> <u>correctly</u> <u>*/</u>
                  return;
              }
              <u>/*</u> <u>Do</u> <u>something</u> <u>else</u> <u>for</u> <u>a</u> <u>while</u> <u>here</u> <u>*/</u>
              if (<b>Tcl_JoinThread</b>(id, &amp;result) != TCL_OK) {
                  <u>/*</u> <u>Thread</u> <u>did</u> <u>not</u> <u>finish</u> <u>properly</u> <u>*/</u>
                  return;
              }
              <u>/*</u> <u>All</u> <u>cleaned</u> <u>up</u> <u>nicely</u> <u>*/</u>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/Tcl_GetCurrentThread.3tcl.html">Tcl_GetCurrentThread</a>(3tcl),   <a href="../man3tcl/Tcl_ThreadQueueEvent.3tcl.html">Tcl_ThreadQueueEvent</a>(3tcl),   <a href="../man3tcl/Tcl_ThreadAlert.3tcl.html">Tcl_ThreadAlert</a>(3tcl),  <a href="../man3tcl/Tcl_ExitThread.3tcl.html">Tcl_ExitThread</a>(3tcl),
       <a href="../man3tcl/Tcl_FinalizeThread.3tcl.html">Tcl_FinalizeThread</a>(3tcl), <a href="../man3tcl/Tcl_CreateThreadExitHandler.3tcl.html">Tcl_CreateThreadExitHandler</a>(3tcl), <a href="../man3tcl/Tcl_DeleteThreadExitHandler.3tcl.html">Tcl_DeleteThreadExitHandler</a>(3tcl), Thread

</pre><h4><b>KEYWORDS</b></h4><pre>
       thread, mutex, condition variable, thread local storage

Tcl                                                    8.1                                         <u><a href="../man3tcl/Threads.3tcl.html">Threads</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>