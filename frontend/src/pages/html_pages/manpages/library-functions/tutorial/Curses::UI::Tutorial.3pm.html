<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curses::UI::Tutorial - Tutorial for the Curses::UI framework</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurses-ui-perl">libcurses-ui-perl_0.9609-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Curses::UI::Tutorial - Tutorial for the Curses::UI framework

</pre><h4><b>Introduction</b></h4><pre>
       The intention of this tutorial is a quick overview of Curses::UI and it's widgets. The target of this
       example is to write a simple text editor using the Curses::UI framework.

</pre><h4><b>First</b> <b>requirements</b></h4><pre>
       In order to use Curses::UI start your program with "use Curses::UI;" and, as it is always a good idea,
        add "use strict" and the -w switch too.  After that an instance of Curses::UI must be created. From now
       on, this instance will be called "the UI". You  also want to redirect STDERR to a file (e.g. perl
       myscript.pl 2&gt; debug.out), so output that does not come from Curses::UI doesn't clobber your display.
       You want fancy colors, so the option -color_support is set to a true value.

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           use strict;
           use Curses::UI;
           my $cui = new Curses::UI( -color_support =&gt; 1 );

</pre><h4><b>Create</b> <b>a</b> <b>menu</b></h4><pre>
               my @menu = (
                 { -label =&gt; 'File',
                   -submenu =&gt; [
                  { -label =&gt; 'Exit      ^Q', -value =&gt; \&amp;exit_dialog  }
                               ]
                  },
               );

       In order to describe the structure of a menu Curses::UI uses a rather ugly construct out of hash and
       arrayrefs. See Curses::UI::Menubar for details. What you do at this point is to create a Menubar with
       just one entry and one submenu. The entry is 'File' and the submenu is 'Exit'.  The value of this menu
       item is a reference to a sub called exit_dialog.

</pre><h4><b>Dialogs</b></h4><pre>
               sub exit_dialog()
               {
                       my $return = $cui-&gt;dialog(
                               -message   =&gt; "Do you really want to quit?",
                               -title     =&gt; "Are you sure???",
                               -buttons   =&gt; ['yes', 'no'],

                       );

               <a href="../man0/exit.0.html">exit</a>(0) if $return;
               }

       The dialog method of Curses::UI gives us an easy and convenient way to create dialogs on the main screen.
       A dialog is a way to interact with the user in order to ask him a question or give him important
       information.  This dialog is a more complex one, which asks the question whether or not you really want
       to exit. As the button for "yes" would return us a true value, you can easily exit on this return value.

</pre><h4><b>Add</b> <b>the</b> <b>Menubar</b></h4><pre>
               my $menu = $cui-&gt;add(
                       'menu','Menubar',
                       -menu =&gt; \@menu,
                       -fg  =&gt; "blue",
               );

       To finally add the Menubar to our root object, you have to call the add method on the Curses UI object.
       You specify the internal name of the widget as the first argument, the widget type as the second argument
       (like Label, TextViewer, etc.) and the menu structure you created at the beginning as an array reference
       as third object. Because you want the Menubar to have a blue theme, you give him the -fg option "blue".
       There are a couple of colors you can use, see Curses::UI::Color for details.

</pre><h4><b>Add</b> <b>a</b> <b>window</b></h4><pre>
               my $win1 = $cui-&gt;add(
                                    'win1', 'Window',
                                    -border =&gt; 1,
                                    -y    =&gt; 1,
                                    -bfg  =&gt; 'red',
                            );

       There are only two types of object you can add to the Curses::UI root object: Menubars and Windows. All
       other widgets have to be inserted into a window. Of course you can add a Menubar to a window, but not
       vice versa ;-).  The add method always has the same two first arguments: the internal name and the widget
       type. The internal name can be used to find an object. The method getobj takes this name and returns us
       the corresponding object out of the hierarchy. See Curses::UI for details.  Again you want some fancy
       colors, so you tell the window to have a border, leave some space for the Menubar (-y =&gt; 1) and set the
       border foreground color to red.

</pre><h4><b>Add</b> <b>a</b> <b>widget</b></h4><pre>
               my $texteditor = $win1-&gt;add("text", "TextEditor",
                                        -text =&gt; "Here is some text\n"
                                               . "And some more");

       The next step is to add a useful widget to our new small Curses::UI app. Here you take a TextEditor
       widget which performs basic tasks as a text editor. You add some initial text to the widget to make it
       not seem that empty.

</pre><h4><b>Making</b> <b>keybindings</b></h4><pre>
               $cui-&gt;set_binding(sub {$menu-&gt;focus()}, "\cX");
               $cui-&gt;set_binding( \&amp;exit_dialog , "\cQ");

       You want to be able to focus the Menubar if you finished editing in the TextEditor widget. Therefore you
       set a binding to the focus function of the menu and the key sequence Control (specified by \c) combined
       with X. Now you can easily return to the menu after editing.  Because it is easier to have a shortcut for
       closing the application you add a binding for the sequence Control-Q to our nice exit_dialog method.

</pre><h4><b>The</b> <b>final</b> <b>steps</b></h4><pre>
               $texteditor-&gt;focus();
               $cui-&gt;mainloop();

       You want to start editing directly. Therefore you set the initial focus on the TextEditor by calling it's
       focus method directly.  The last thing you got to do is to tell Curses that it now contoles the program
       flow by starting it's MainLoop.

</pre><h4><b>You're</b> <b>done!</b></h4><pre>
       You have built a genuine Curses::UI application! Not that it is a very useful one, but who cares? Now try
       out if it works like you think it should. The complete source code of this application is located in the
       examples directory of the distribution (examples/tutorial.pl).

       Now you can enhance this application to become a full featured editor like Emacs :-)

</pre><h4><b>Author</b></h4><pre>
       2003-2004 (c) by Marcus Thiesen (<a href="mailto:marcus@cpan.org">marcus@cpan.org</a>) All rights reserved This Tutorial is licensed under the
       same terms as perl itself.

       If you have some additions to this tutorial feel free to send me a mail.

perl v5.40.1                                       2025-06-14                          <u>Curses::UI::<a href="../man3pm/Tutorial.3pm.html">Tutorial</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>