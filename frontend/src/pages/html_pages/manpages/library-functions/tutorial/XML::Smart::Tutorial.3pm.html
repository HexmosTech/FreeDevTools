<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Smart::Tutorial - Tutorial and examples for XML::Smart.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-smart-perl">libxml-smart-perl_1.78-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Smart::Tutorial - Tutorial and examples for XML::Smart.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       This document is a tutorial for <u>XML::Smart</u> and shows some examples of usual things.

</pre><h4><b>Working</b> <b>with</b> <b>contents:</b></h4><pre>
       In <u>XML::Smart</u> the key <u>CONTENT</u> is reserved and shouldn't be used directly, since <u>XML::Smart</u> will deal with
       the convertion of arguments to node contents, including multiple node contents autimatically.

   <b>What</b> <b>happens</b> <b>when</b> <b>you</b> <b>set</b> <b>a</b> <b>value:</b>
         $xml-&gt;{root}{foo} = 'simple value' ;

       Here foo will be a normal argument/attribute value, and will generate this XML data:

         &lt;root foo="simple value"/&gt;

       But if you insert some tag or lines in the values by default <u>XML::Smart</u> will convert it to a node
       content:

         $xml-&gt;{root}{foo} = "line0\nlien1\nline2\n" ;

       And will generate that XML data:

         &lt;root&gt;
         &lt;foo&gt;line0
         lien1
         line2
         &lt;/foo&gt;
         &lt;<a href="file:/root">/root</a>&gt;

       But what you can do if you want to force some type, let's say, have a node content with a simple value:

         $xml-&gt;{root}{foo} = 'simple value' ;
         $xml-&gt;{root}{foo}-&gt;<a href="../man1/set_node.1.html">set_node</a>(1) ;

       And will generate that XML data:

         &lt;root&gt;
           &lt;foo&gt;simple value&lt;/foo&gt;
         &lt;<a href="file:/root">/root</a>&gt;

   <b>Multiple</b> <b>contents:</b>
       When you have interpolated content/data you need to work in a different. Let's say that you load this XML
       data:

         &lt;root&gt;
         content0
         &lt;tag1 arg="1"/&gt;
         content1
         &lt;<a href="file:/root">/root</a>&gt;

       If you access directly the root key as string you will get all the content parts grouped.  So, this code:

         my $xml = new XML::Smart(q`
         &lt;root&gt;
         content0
         &lt;tag1 arg="1"/&gt;
         content1
         &lt;<a href="file:/root">/root</a>&gt;
         `,'smart') ;

         print "#$xml-&gt;{root}#" ;

       Will print that:

         #
         content0

         content1
         #

       <b>To</b> <b>access</b> <b>each</b> <b>part</b> <b>of</b> <b>the</b> <b>content</b> <b>independently</b> <b>you</b> <b>should</b> <b>use</b> <b>an</b> <b>array</b> <b>that</b> <b>receive</b> <b>the</b> <b>method</b>
       <u><b>content()</b></u><b>:</b>

         my @content = $xml-&gt;{root}-&gt;content ;

         print "#$content[0]#\n" ;

       And this will print that:

         #
         content0
         #

       <b>Now</b> <b>to</b> <b>set</b> <b>the</b> <b>multiple</b> <b>content</b> <b>values</b> <b>you</b> <b>should</b> <b>use</b> <b>the</b> <b>method</b> <u><b>content()</b></u> <b>with</b> <b>2</b> <b>arguments:</b>

         $xml-&gt;{root}-&gt;content(0,'new content') ;

       And now the XML data produced will be:

         &lt;root&gt;new content&lt;tag1 arg="1"/&gt;
         content1
         &lt;<a href="file:/root">/root</a>&gt;

       If you use the method <u><b>content()</b></u> with only one argument it will remove all the multiple contents and will
       set the new value in the place of the 1st content.

</pre><h4><b>Setting</b> <b>the</b> <b>XML</b> <b>Parser.</b></h4><pre>
       By defaul <u>XML::Smart</u> will use XML::Parser or XML::Smart::Parser (in this order of preference) to load a
       XML data.

       To force or define by your self the parser you can use the 2nd argument option when creating a <u>XML::Smart</u>
       object:

         my $xml = new XML::Smart( 'some.xml' , 'XML::Parser' ) ;

         ## and

         my $xml = new XML::Smart( 'some.xml' , 'XML::Smart::Parser' ) ;

       <u>XML::Smart</u> also has an extra parser, <u>XML::Smart::HTMLParser</u>, that can be used to load HTML as XML, or to
       load wild XML data:

         my $xml = new XML::Smart( 'some.xml' , 'XML::Smart::HTMLParser' ) ;

       Aliases for the parser options:

         SMART|REGEXP   =&gt; XML::Smart::Parser
         HTML           =&gt; XML::Smart::HTMLParser

       So, you can use as:

         my $xml = new XML::Smart( 'some.xml' , 'smart' ) ;
         my $xml = new XML::Smart( 'some.xml' , 'html' ) ;

</pre><h4><b>Customizing</b> <b>the</b> <b>Parser.</b></h4><pre>
       You can customize the way that the parser will treat the XML data:

   <b>Forcing</b> <b>nodes/tags</b> <b>and</b> <b>arguments/attributes</b> <b>to</b> <b>lowercase</b> <b>or</b> <b>upercase:</b>
         ## For lower case:

         my $xml = new XML::Smart( 'some.xml' ,
         lowtag =&gt; 1 ,
         lowarg =&gt; 1 ,
         ) ;

         ## For uper case:

         my $xml = new XML::Smart( 'some.xml' ,
         upertag =&gt; 1 ,
         uperarg =&gt; 1 ,
         ) ;

   <b>Loading</b> <b>arguments</b> <b>without</b> <b>values</b> <b>(flags)</b> <b>as</b> <b>a</b> <b>TRUE</b> <b>boolean:</b>
       <u>**</u> <u>Note,</u> <u>this</u> <u>option</u> <u>will</u> <u>work</u> <u>only</u> <u>when</u> <u>the</u> <u>XML</u> <u>is</u> <u>parsed</u> <u>by</u> <u>XML::Smart::HTMLParser,</u> <u>since</u> <u>only</u> <u>it</u>
       <u>accept</u> <u>arguments</u> <u>without</u> <u>values!</u>

         my $xml = new XML::Smart(
         '&lt;root&gt;&lt;foo arg1="" flag&gt;&lt;<a href="file:/root">/root</a>&gt;' ,
         'XML::Smart::HTMLParser' ,
         arg_single =&gt; 1 ,
         ) ;

       Here's the tree of the example above:

         'root' =&gt; {
                     'foo' =&gt; {
                                'flag' =&gt; 1,
                                'arg1' =&gt; ''
                              },
                   },

   <b>Customizing</b> <b>the</b> <b>parse</b> <b>events:</b>
       <u>XML::Smart</u> can redirect the parsing process to personalized functions:

         my $xml = XML::Smart-&gt;new( 'some.xml' ,
         on_start =&gt; \&amp;on_start ,
         on_char  =&gt; \&amp;on_char ,
         on_end   =&gt; \&amp;on_end ,
         ) ;

         sub on_start {
           my ( $tag , $pointer , $pointer_back ) = @_ ;
           $pointer-&gt;{$tag}{type_user} = 1 if $tag =~ /(?:name|age)/ ;
         }

         sub on_char {
           my ( $tag , $pointer , $pointer_back , $content) = @_ ;
           $$content =~ s/\s+/ /gs ;
         }

         sub on_end {
           my ( $tag , $pointer , $pointer_back ) = @_ ;
           $pointer-&gt;{$tag}{type_extra} = 1 if $tag =~ /(?:more|tel|address)/ ;
         }

</pre><h4><b>AUTHOR</b></h4><pre>
       Graciliano M. P. &lt;<a href="mailto:gm@virtuasites.com.br">gm@virtuasites.com.br</a>&gt;

       I will appreciate any type of feedback (include your opinions and/or suggestions). ;-P

       Enjoy and thanks for who are enjoying this tool and have sent e-mails! ;-P

</pre><h4><b>ePod</b></h4><pre>
       This document was written in ePod (easy-POD), than converted to POD, and from here you know the way.

perl v5.36.0                                       2022-11-19                          <u>XML::Smart::<a href="../man3pm/Tutorial.3pm.html">Tutorial</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>