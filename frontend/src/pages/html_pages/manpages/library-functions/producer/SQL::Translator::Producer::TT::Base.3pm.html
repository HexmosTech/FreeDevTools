<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL::Translator::Producer::TT::Base - TT (Template Toolkit) based Producer base class.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsql-translator-perl">libsql-translator-perl_1.66-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SQL::Translator::Producer::TT::Base - TT (Template Toolkit) based Producer base class.

</pre><h4><b>SYNOPSIS</b></h4><pre>
        # Create a producer using a template in the __DATA__ section.
        package SQL::Translator::Producer::Foo;

        use base qw/SQL::Translator::Producer::TT::Base/;

        # Convert produce call into a method call on our new class
        sub produce { return __PACKAGE__-&gt;new( translator =&gt; shift )-&gt;run; };

        # Configure the Template object.
        sub tt_config { ( INTERPOLATE =&gt; 1 ); }

        # Extra vars to add to the template
        sub tt_vars { ( foo =&gt; "bar" ); }

        # Put template in DATA section (or use file with ttfile producer arg)
        __DATA__
        Schema

        Database: [% schema.database %]
        Foo: $foo
        ...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A base class producer designed to be sub-classed to create new TT based producers cheaply - by simply
       giving the template to use and sprinkling in some extra template variables and config.

       You can find an introduction to this module in SQL::Translator::Manual.

       The 1st thing the module does is convert the produce sub routine call we get from SQL::Translator into a
       method call on an object, which we can then sub-class. This is done with the following code which needs
       to appear in <b>all</b> sub classes.

        # Convert produce call into an object method call
        sub produce { return __PACKAGE__-&gt;new( translator =&gt; shift )-&gt;run; };

       See "PRODUCER OBJECT" below for details.

       The upshot of this is we can make new template producers by sub classing this base class, adding the
       above snippet and a template.  The module also provides a number of hooks into the templating process,
       see "SUB CLASS HOOKS" for details.

       See the "SYNOPSIS" above for an example of creating a simple producer using a single template stored in
       the producers DATA section.

</pre><h4><b>SUB</b> <b>CLASS</b> <b>HOOKS</b></h4><pre>
       Sub-classes can override these methods to control the templating by giving the template source, adding
       variables and giving config to the Tempate object.

   <b>tt_config</b>
        sub tt_config { ( INTERPOLATE =&gt; 1 ); }

       Return hash of Template config to add to that given to the Template "new" method.

   <b>tt_schema</b>
        sub tt_schema { "foo.tt"; }
        sub tt_schema { local $/ = undef; \&lt;DATA&gt;; }

       The template to use, return a file name or a scalar ref of TT source, or an IO::Handle. See Template for
       details, as the return from this is passed on to it's "produce" method.

       The default implementation uses the producer arg "ttfile" as a filename to read the template from. If the
       arg isn't there it will look for a "__DATA__" section in the class, reading it as template source if
       found. Returns undef if both these fail, causing the produce call to fail with a 'no template!' error.

   <b>tt_vars</b>
        sub tt_vars { ( foo =&gt; "bar" ); }

       Return hash of template vars to use in the template. Nothing added here by default, but see
       "tt_default_vars" for the variables you get for free.

   <b>tt_default_vars</b>
       Return a hash-ref of the default vars given to the template.  You wouldn't normally over-ride this, just
       inherit the default implementation, to get the "translator" &amp; "schema" variables, then over-ride
       "tt_vars" to add your own.

       The current default variables are:

       schema
           The schema to template.

       translator
           The SQL::Translator object.

   <b>pre_process_schema</b>
       WARNING: This method is Experimental so may change!

       Called with the SQL::Translator::Schema object and should return one (it doesn't have to be the same one)
       that will become the "schema" variable used in the template.

       Gets called from tt_default_vars.

</pre><h4><b>PRODUCER</b> <b>OBJECT</b></h4><pre>
       The  rest  of the methods in the class set up a sub-classable producer object.  You normally just inherit
       them.

   <b>new</b>
        my $tt_producer = TT::Base-&gt;new( translator =&gt; $translator );

       Construct a new TT Producer object. Takes a single, named arg of the SQL::Translator object  running  the
       translation. Dies if this is not given.

   <b>translator</b>
       Return the SQL::Translator object.

   <b>schema</b>
       Return     the     SQL::Translator::Schema    we    are    translating.    This    is    equivalent    to
       "$tt_producer-&gt;translator-&gt;schema".

   <b>run</b>
       Called to actually produce the output, calling the sub class hooks. Returns the produced text.

   <b>args</b>
       Util wrapper method around "TT::Base-&gt;translator-&gt;producer_args" for  (mostly)  readonly  access  to  the
       producer args. How it works depends on the number of arguments you give it and the context.

        No args - Return hashref (the actual hash in Translator) or hash of args.
        1 arg   - Return value of the arg with the passed name.
        2+ args - List of names. In list context returns values of the given arg
                  names, returns as a hashref in scalar context. Any names given
                  that don't exist in the args are returned as undef.

       This  is  still a bit messy but is a handy way to access the producer args when you use your own to drive
       the templating.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       perl, SQL::Translator, Template.

</pre><h4><b>TODO</b></h4><pre>
       - Add support for a sqlf template repository, set as an INCLUDE_PATH,  so  that  sub-classes  can  easily
       include file based templates using relative paths.

       - Pass in template vars from the producer args and command line.

       - Merge in TT::Table.

       - Hooks to pre-process the schema and post-process the output.

</pre><h4><b>AUTHOR</b></h4><pre>
       Mark Addison &lt;<a href="mailto:grommit@users.sourceforge.net">grommit@users.sourceforge.net</a>&gt;.

perl v5.40.0                                       2024-11-23              <u>SQL::Translato...ducer::TT::<a href="../man3pm/Base.3pm.html">Base</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>