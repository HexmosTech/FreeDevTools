<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>guestfs-lua - How to use libguestfs from Lua</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/lua-guestfs">lua-guestfs_1.54.1-2ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       guestfs-lua - How to use libguestfs from Lua

</pre><h4><b>SYNOPSIS</b></h4><pre>
        local G = require "guestfs"
        g = G.create ()
        g:add_drive ("test.img", { format = "raw", readonly = true })
        g:launch ()
        devices = g:list_devices ()
        g:close ()

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This manual page documents how to call libguestfs from the Lua programming language.  This page just
       documents the differences from the C API and gives some examples.  If you are not familiar with using
       libguestfs, you also need to read <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3).

   <b>REQUIRING</b> <b>THE</b> <b>MODULE</b>
       "require "guestfs"" returns the module, so you have to assign it to a local variable.  Typical usage is:

        local G = require "guestfs"

       (you can use any name you want instead of "G", but in the examples in this man page we always use "G").

   <b>OPENING</b> <b>AND</b> <b>CLOSING</b> <b>THE</b> <b>HANDLE</b>
       To create a new handle, call:

        g = G.create ()

       You can also use the optional arguments:

        g = G.create { environment = 0, close_on_exit = 0 }

       to set the flags "GUESTFS_CREATE_NO_ENVIRONMENT" and/or "GUESTFS_CREATE_NO_CLOSE_ON_EXIT".

       The handle will be closed by the garbage collector, but you can also close it explicitly by doing:

        g:close ()

   <b>CALLING</b> <b>METHODS</b>
       Use the ordinary Lua convention for calling methods on the handle.  For example:

        g:set_verbose (true)

   <b>FUNCTIONS</b> <b>WITH</b> <b>OPTIONAL</b> <b>ARGUMENTS</b>
       For functions that take optional arguments, the first arguments are the non-optional ones.  The optional
       final argument is a table supplying the optional arguments.

        g:add_drive ("test.img")

       or:

        g:add_drive ("test.img", { format = "raw", readonly = true })

   <b>64</b> <b>BIT</b> <b>VALUES</b>
       Currently 64 bit values must be passed as strings, and are returned as strings.  This is because 32 bit
       Lua cannot handle 64 bit integers properly.  We hope to come up with a better solution later.

   <b>ERRORS</b>
       Most (but not all) errors are converted into objects (ie. tables) containing the following fields:

       msg The error message (corresponding to "guestfs_last_error" in <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3)).

       code
           The "errno" (corresponding to "guestfs_last_errno" in <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3)).

       These  objects  also  have "__tostring" functions attached to them so you can use "tostring" (or implicit
       conversion) to convert them into printable strings.

       Note that the library also throws some errors as plain strings.  You may need to check the type.

   <b>EVENTS</b>
       Events can be registered by calling "set_event_callback":

        eh = g:set_event_callback (cb, "close")

       or to register a single callback for multiple events make the second argument a list:

        eh = g:set_event_callback (cb, { "appliance", "library", "trace" })

       A list of all valid event types (strings) is in the global variable "G.event_all".

       The callback ("cb") is called with the following parameters:

        function cb (g, event, eh, flags, buf, array)
          -- g is the guestfs handle
          -- event is a string which is the name of the event that fired
          -- flags is always zero
          -- buf is the data buffer (eg. log message etc)
          -- array is the array of 64 bit ints (eg. progress bar status etc)
          ...
        end

       You can also remove a callback using the event handle ("eh") that was returned when  you  registered  the
       callback:

        g:delete_event_callback (eh)

</pre><h4><b>EXAMPLE</b> <b>1:</b> <b>CREATE</b> <b>A</b> <b>DISK</b> <b>IMAGE</b></h4><pre>
        -- Example showing how to create a disk image.

        local G = require "guestfs"

        local output = "disk.img"

        local g = G.create ()

        -- Create a raw-format sparse disk image, 512 MB in size.
        file = io.open (output, "w")
        file:seek ("set", 512 * 1024 * 1024)
        file:write (' ')
        file:close ()

        -- Set the trace flag so that we can see each libguestfs call.
        g:set_trace (true)

        -- Attach the disk image to libguestfs.
        g:add_drive (output, { format = "raw", readonly = false })

        -- Run the libguestfs back-end.
        g:launch ()

        -- Get the list of devices.  Because we only added one drive
        -- above, we expect that this list should contain a single
        -- element.
        devices = g:list_devices ()
        if table.getn (devices) ~= 1 then
           error "expected a single device from list-devices"
        end

        -- Partition the disk as one single MBR partition.
        g:part_disk (devices[1], "mbr")

        -- Get the list of partitions.  We expect a single element, which
        -- is the partition we have just created.
        partitions = g:list_partitions ()
        if table.getn (partitions) ~= 1 then
           error "expected a single partition from list-partitions"
        end

        -- Create a filesystem on the partition.
        g:mkfs ("ext4", partitions[1])

        -- Now mount the filesystem so that we can add files.
        g:mount (partitions[1], "/")

        -- Create some files and directories.
        g:touch ("/empty")
        message = "Hello, world\n"
        g:write ("/hello", message)
        g:mkdir ("/foo")

        -- This one uploads the local file <a href="file:/etc/resolv.conf">/etc/resolv.conf</a> into
        -- the disk image.
        g:upload ("<a href="file:/etc/resolv.conf">/etc/resolv.conf</a>", "/foo/resolv.conf")

        -- Because we wrote to the disk and we want to detect write
        -- errors, call g:shutdown.  You don't need to do this:
        -- g:close will do it implicitly.
        g:shutdown ()

        -- Note also that handles are automatically closed if they are
        -- reaped by the garbage collector.  You only need to call close
        -- if you want to close the handle right away.
        g:close ()

</pre><h4><b>EXAMPLE</b> <b>2:</b> <b>INSPECT</b> <b>A</b> <b>VIRTUAL</b> <b>MACHINE</b> <b>DISK</b> <b>IMAGE</b></h4><pre>
        -- Example showing how to inspect a virtual machine disk.

        local G = require "guestfs"

        if table.getn (arg) == 1 then
           disk = arg[1]
        else
           error ("usage: inspect_vm disk.img")
        end

        local g = G.create ()

        -- Attach the disk image read-only to libguestfs.
        g:add_drive (disk, { -- format:"raw"
                             readonly = true })

        -- Run the libguestfs back-end.
        g:launch ()

        -- Ask libguestfs to inspect for operating systems.
        local roots = g:inspect_os ()
        if table.getn (roots) == 0 then
           error ("inspect_vm: no operating systems found")
        end

        for _, root in ipairs (roots) do
           print ("Root device: ", root)

           -- Print basic information about the operating system.
           print ("  Product name: ", g:inspect_get_product_name (root))
           print ("  Version:      ",
                  g:inspect_get_major_version (root),
                  g:inspect_get_minor_version (root))
           print ("  Type:         ", g:inspect_get_type (root))
           print ("  Distro:       ", g:inspect_get_distro (root))

           -- Mount up the disks, like guestfish -i.
           --
           -- Sort keys by length, shortest first, so that we end up
           -- mounting the filesystems in the correct order.
           mps = g:inspect_get_mountpoints (root)
           table.sort (mps,
                       function (a, b)
                          return string.len (a) &lt; string.len (b)
                       end)
           for mp,dev in pairs (mps) do
              pcall (function () g:mount_ro (dev, mp) end)
           end

           -- If <a href="file:/etc/issue.net">/etc/issue.net</a> file exists, print up to 3 lines.
           filename = "<a href="file:/etc/issue.net">/etc/issue.net</a>"
           if g:is_file (filename) then
              print ("--- ", filename, " ---")
              lines = g:head_n (3, filename)
              for _, line in ipairs (lines) do
                 print (line)
              end
           end

           -- Unmount everything.
           g:umount_all ()
        end

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3),     <b><a href="../man3/guestfs-examples.3.html">guestfs-examples</a></b>(3),     <b><a href="../man3/guestfs-erlang.3.html">guestfs-erlang</a></b>(3),     <b><a href="../man3/guestfs-gobject.3.html">guestfs-gobject</a></b>(3),    <b><a href="../man3/guestfs-golang.3.html">guestfs-golang</a></b>(3),
       <b><a href="../man3/guestfs-java.3.html">guestfs-java</a></b>(3),    <b><a href="../man3/guestfs-ocaml.3.html">guestfs-ocaml</a></b>(3),     <b><a href="../man3/guestfs-perl.3.html">guestfs-perl</a></b>(3),     <b><a href="../man3/guestfs-python.3.html">guestfs-python</a></b>(3),     <b><a href="../man1/guestfs-recipes.1.html">guestfs-recipes</a></b>(1),
       <b><a href="../man3/guestfs-ruby.3.html">guestfs-ruby</a></b>(3), <a href="http://www.lua.org/">http://www.lua.org/</a>, <a href="http://libguestfs.org/">http://libguestfs.org/</a>.

</pre><h4><b>AUTHORS</b></h4><pre>
       Richard W.M. Jones ("rjones at redhat dot com")

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2012 Red Hat Inc.

</pre><h4><b>LICENSE</b></h4><pre>
       This  manual  page  contains  examples  which we hope you will use in your programs.  The examples may be
       freely copied, modified and distributed for any purpose without any restrictions.

</pre><h4><b>BUGS</b></h4><pre>
       To     get      a      list      of      bugs      against      libguestfs,      use      this      link:
       https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools

       To       report       a       new       bug       against       libguestfs,      use      this      link:
       https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools

       When reporting a bug, please supply:

       •   The version of libguestfs.

       •   Where you got libguestfs (eg. which Linux distro, compiled from source, etc)

       •   Describe the bug accurately and give a way to reproduce it.

       •   Run <b><a href="../man1/libguestfs-test-tool.1.html">libguestfs-test-tool</a></b>(1) and paste the <b>complete,</b> <b>unedited</b> output into the bug report.

libguestfs-1.54.1                                  2025-02-18                                     <u><a href="../man3/guestfs-lua.3.html">guestfs-lua</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>