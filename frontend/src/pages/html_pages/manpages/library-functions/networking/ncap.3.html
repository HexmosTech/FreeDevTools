<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ncap — network data capture</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libncap44t64">libncap44t64_1.9.2-8.1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ncap — network data capture

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;ncap.h&gt;</b>

       <u>ncap_t</u>
       <b>ncap_create</b>(<u>int</u> <u>maxmsgsize</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>ncap</b>  library is a high level interface for network data capture.  The source of network data can be
       either live traffic or files containing previously captured or generated data.   Files  can  be  in  <b>ncap</b>
       format, as defined below, or in <u><a href="../man3/pcap.3.html">pcap</a></u>(3) format, and can be either normal binary files or network sockets.

       The  <b>ncap_create</b>()  function  returns  a  new  <b>ncap</b>  object  (structure) having various methods (function
       pointers) which can be referenced to add data sources, poll for data, loop while collecting data, and  so
       on.   <u>maxmsgsize</u>  is the size of the largest message (in portable binary export format) you are expecting
       to handle, usually this is 70000, to allow for a 64Kbyte  payload  plus  <b>ncap</b>  message  header  overhead.
       <b>ncap_create</b>()  returns  NULL  if  an  error occurs, in which case <u>errno</u> will be set to indicate the error
       cause.

       The <u>ncap_t</u> data structure is defined in the &lt;<u>ncap.h</u>&gt; include file, which defines at least  the  following
       symbols:

             typedef enum { ncap_success = 0, ncap_failure } ncap_result_e;
             typedef void (*ncap_callback_t)(ncap_t, void *, ncap_msg_ct);
             typedef struct ncap *ncap_t;
             struct ncap {
                     char *          errstr;
                     ncap_result_e   (*add_if)(ncap_t, const char *name,
                                               const char *bpf, int promisc,
                                               const int vlans[], int nvlan,
                                               int *fdes);
                     ncap_result_e   (*drop_if)(ncap_t, int fdes);
                     ncap_result_e   (*add_nf)(ncap_t, int fdes, const char *);
                     ncap_result_e   (*drop_nf)(ncap_t, int fdes);
                     ncap_result_e   (*add_pf)(ncap_t, FILE *, const char *);
                     ncap_result_e   (*drop_pf)(ncap_t, FILE *);
                     ncap_result_e   (*add_dg)(ncap_t, int fdes);
                     ncap_result_e   (*drop_dg)(ncap_t, int fdes);
                     ncap_result_e   (*filter)(ncap_t, const char *);
                     ncap_result_e   (*collect)(ncap_t, int polling,
                                                ncap_callback_t,
                                                void *closure);
                     void            (*stop)(ncap_t);
                     struct ncap_msg (*cons)(ncap_t, struct timespec,
                                             unsigned, unsigned,
                                             ncap_np_e, ncap_np_ct,
                                             ncap_tp_e, ncap_tp_ct,
                                             size_t, const u_char *);
                     int             (*match)(ncap_t, ncap_msg_ct);
                     ncap_result_e   (*write)(ncap_t, ncap_msg_ct, int fdes);
                     ncap_result_e   (*fwrite)(ncap_t, ncap_msg_ct, FILE *);
                     ncap_result_e   (*send)(ncap_t, ncap_msg_ct, int fdes,
                                             int flags);
                     void            (*destroy)(ncap_t);
             };

       The elements of <u>ncap_t</u> are defined as follows:

       <u>errstr</u>    A  pointer  to  a  text  string  describing  the  most recent error condition.  If no error has
                 occurred, this string will be empty, but never NULL.

       <u>add_if</u>    Adds a network interface as a data source.  Interface naming rules are as in <u><a href="../man3/pcap.3.html">pcap</a></u>(3).  A <u><a href="../man4/bpf.4.html">bpf</a></u>(4)
                 program (in text form) can be provided in order to filter the data source  in  the  kernel  and
                 thus  reduce the amount of data collected by this object.  It is an error to specify a non-NULL
                 bpf program if an NCAP <u>filter</u> has been installed.  The interface can be  made  promiscuous,  in
                 which  case  it  is  eligible  to  receive  data for which this system is neither the source or
                 destination, if the attached network and interface support this mode.  A list of VLANs  can  be
                 provided  in  which  case  tagged 802.1Q frames are eligible and will be collected if their tag
                 number is on the provided list.  If the list contains only VLAN tag number zero  (0)  then  all
                 tagged  frames will be eligible.  The file descriptor opened for this interface can be returned
                 in order to be used by <u><a href="../man2/select.2.html">select</a></u>(2) or in <u>drop_if</u> as defined below.

       <u>drop_if</u>   Removes the designated interface from further consideration or data collection.

       <u>add_nf</u>    Adds a previously opened NCAP file as a data source.

       <u>drop_nf</u>   Drops an NCAP file as a data source.

       <u>add_pf</u>    Adds a previously opened PCAP file as a data source.

       <u>drop_pf</u>   Drops an PCAP file as a data source.

       <u>add_dg</u>    Adds a previously opened datagram socket as a data source.

       <u>drop_dg</u>   Drops a datagram socket as a data source.

       <u>watch_fd</u>  Adds a file descriptor to the set watched by <u>collect</u>, such that a  readability  event  on  this
                 descriptor  will  result  in  the designated <u>watcher</u> callback being activated with the supplied
                 <u>closure</u>.

       <u>drop_fd</u>   Removes a file descriptor from the set being watched by <u>collect</u>.

       <u>filter</u>    Installs an NCAP filter, specified as ASCII text.  It is an error to install a  filter  if  any
                 interface has been added with a supplied BPF program.

       <u>collect</u>   Run  the  data  collection  engine,  either  once (if polling) or continuously (until <b>stop</b>() is
                 called).  Each collected message will be formatted into an <u>ncap_msg</u> structure and, if no filter
                 has been installed or if the message matches the  installed  filter,  passed  to  the  supplied
                 callback along with the supplied <u>closure</u>.

       <u>stop</u>      Can  be  called  from  within  a  <b>collect</b>()  <u>callback</u> or from within an operating system signal
                 handler, this will end the loop inside <b>collect</b>().

       <u>cons</u>      Returns a <u>ncap_msg</u> structure filled in according to the  arguments.   It's  wise  to  use  this
                 rather  than doing inline initialization in case new fields are added to the <u>ncap_msg</u> structure
                 later on.

       <u>match</u>     Tests a supplied message against any installed filter.  Returns TRUE if no filter is  installed
                 or if the message matches the installed filter, else FALSE.

       <u>write</u>, <u>fwrite</u>, <u>send</u>
                 Exports  an  <u>ncap_msg</u>  structure  to  a  file  descriptor,  file pointer, or datagram socket in
                 portable binary format.  If no message is supplied (e.g., NULL) , a "file  header"  is  output,
                 containing a magic number and the <b>ncap</b> library version number.  A file header must be the first
                 thing in an <b>ncap</b> file, and should be sent periodically on a datagram socket.  If the result is

       <u>ncap_failure</u>
                 then <u>errno</u> will have been set by an underlying failed system call.

       <u>destroy</u>   Release  all  resources  held by this <b>ncap</b> object, including heap memory and underlying <u><a href="../man3/pcap.3.html">pcap</a></u>(3)
                 objects.  Standard I/O files  as  provided  to  <b>add_pf</b>()  are  not  closed  here  and  are  the
                 responsibility of the caller.

</pre><h4><b>Message</b> <b>Formats</b></h4><pre>
       An in-memory <b>ncap</b> message has the following structure:

             typedef enum { ncap_ip4 = 0, ncap_ip6 } ncap_np_e;
             typedef union ncap_np *ncap_np_t;
             typedef const union ncap_np *ncap_np_ct;
             union ncap_np {
                     struct {
                             struct in_addr src, dst;
                     } ip4;
                     struct {
                             struct in6_addr src, dst;
                     } ip6;
             };

             typedef enum { ncap_udp = 0, ncap_tcp } ncap_tp_e;
             typedef union ncap_tp *ncap_tp_t;
             typedef const union ncap_tp *ncap_tp_ct;
             union ncap_tp {
                     struct {
                             unsigned        sport, dport;
                     } udp;
                     struct {
                             unsigned        sport, dport;
                             unsigned        offset;
                             unsigned        flags;
                     } tcp;
             };
             #define ncap_tcp_syn    0x0001  /* first segment */
             #define ncap_tcp_fin    0x0002  /* last segment */
             #define ncap_tcp_rst    0x0004  /* session reset */
             #define ncap_tcp_sum    0x0008  /* checksum failed */

             typedef struct ncap_msg *ncap_msg_t;
             typedef const struct ncap_msg *ncap_msg_ct;
             struct ncap_msg {
                     /* Fixed part. */
                     struct timespec ts;
                     unsigned        user1, user2;
                     ncap_np_e       np;
                     ncap_tp_e       tp;
                     size_t          paylen;
                     /* Variable part. */
                     union ncap_np   npu;
                     union ncap_tp   tpu;
                     const u_char *  payload;
             };

       The portable binary export format of an <b>ncap</b> message is as follows:

             Fixed part (size is 28):
                     uint32_t        message length (includes self, padding)
                     uint32_t        sec, nsec
                     uint32_t        user1, user2
                     uint16_t        network union type (includes padding)
                     uint16_t        transport union type (includes padding)
                     uint32_t        payload length (no padding)

             Variable part (size is always evenly divisible by 4):
                     u_char []       network union
                     u_char []       transport union
                     u_char []       payload

       Reliable  streams of portable binary format <b>ncap</b> messages should begin with a "file header", and datagram
       streams should include a "file header" every so often for receiver synchronization.  A "file header"  has
       the following structure:

             <u>magic</u>   4 octets having the value of ASCII "NCAP".

             <u>vers</u>    4 octets having the network byte order of the <b>ncap</b> version (currently 0x00 0x00 0x00 0x2a).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/select.2.html">select</a></u>(2), <u><a href="../man2/sendmsg.2.html">sendmsg</a></u>(2), <u><a href="../man2/writev.2.html">writev</a></u>(2), <u><a href="../man3/pcap.3.html">pcap</a></u>(3), <u><a href="../man3/fdopen.3.html">fdopen</a></u>(3), <u><a href="../man4/bpf.4.html">bpf</a></u>(4)

</pre><h4><b>BUGS</b></h4><pre>
       <b>ncap</b> filters are not implemented yet, so for now, use <u><a href="../man3/bpf.3.html">bpf</a></u>(3) filters in <b>add_if</b>().

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright (c) 2007 by Internet Systems Consortium, Inc. ("ISC")

       Permission  to  use, copy, modify, and/or distribute this software for any purpose with or without fee is
       hereby granted, provided that the above copyright notice and this permission notice appear in all copies.

       THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE  INCLUDING
       ALL  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL,
       DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA  OR
       PROFITS,  WHETHER  IN  AN  ACTION  OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
       CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

Debian                                            August, 2007                                           <u><a href="../man3/NCAP.3.html">NCAP</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>