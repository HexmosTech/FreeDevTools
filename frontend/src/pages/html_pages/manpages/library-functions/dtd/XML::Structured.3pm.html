<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Structured - simple conversion API from XML to perl structures and back</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-structured-perl">libxml-structured-perl_1.3+git20220429-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Structured - simple conversion API from XML to perl structures and back

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use XML::Structured;

           $dtd = [
               'element' =&gt;
                   'attribute1',
                   'attribute2',
                   [],
                   'element1',
                   [ 'element2' ],
                   [ 'element3' =&gt;
                       ...
                   ],
                   [[ 'element4' =&gt;
                       ...
                   ]],
           ];

           $hashref = XMLin($dtd, $xmlstring);
           $hashref = XMLinfile($dtd, $filename_or_handle);
           $xmlstring = XMLout($dtd, $hashref);
           XMLoutfile($dtd, $hashref, $filename_or_handle);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The XML::Structured module provides a way to convert xml data into a predefined perl data structure and
       back to xml. Unlike with modules like XML::Simple it is an error if the xml data does not match the
       provided skeleton (the "dtd"). Another advantage is that the order of the attributes and elements is
       taken from the dtd when converting back to xml.

   <b>XMLin()</b>
       The <b>XMLin()</b> function takes the dtd and a string as arguments and returns a hash reference containing the
       data.

   <b>XMLinfile()</b>
       This function works like XMLin(), but takes a filename or a file handle as second argument.

   <b>XMLout()</b>
       XMLout() provides the reverse operation to XMLin(), it takes a dtd and a hash reference as arguments and
       returns an XML string.

   <b>XMLoutfile()</b> <b>This</b> <b>function</b> <b>works</b> <b>like</b> <b>XMLout(),</b> <b>but</b> <b>takes</b> <b>a</b> <b>filename</b> <b>or</b> <b>a</b> <b>file</b> <b>handle</b> <b>as</b> <b>third</b> <b>argument.</b>
</pre><h4><b>The</b> <b>DTD</b></h4><pre>
       The dtd parameter specifies the structure of the allowed xml data.  It consists of nested perl arrays.

   <b>simple</b> <b>attributes</b> <b>and</b> <b>elements</b>
       The very simple example for a dtd is:

           $dtd = [ 'user' =&gt;
                        'login',
                        'password',
                  ];

       This dtd will accept/create XML like:

           &lt;user login="foo" password="bar"/&gt;

       XMLin doesn't care if "login" or "password" are attributes or elements, so

           &lt;user&gt;
             &lt;login&gt;foo&lt;/login&gt;
             &lt;password&gt;bar&lt;/password&gt;
           &lt;/user&gt;

       is also valid input (but doesn't get re-created by XMLout()).

   <b>multiple</b> <b>elements</b> <b>of</b> <b>the</b> <b>same</b> <b>name</b>
       If an element may appear multiple times, it must be declared as an array in the dtd:

           $dtd = [ 'user' =&gt;
                        'login',
                        [ 'favorite_fruits' ],
                  ];

       XMLin will create an array reference as value in this case, even if the xml data contains only one
       element. Valid XML looks like:

           &lt;user login="foo"&gt;
             &lt;favorite_fruits&gt;apple&lt;/favorite_fruits&gt;
             &lt;favorite_fruits&gt;peach&lt;/favorite_fruits&gt;
           &lt;/user&gt;

       As attributes may not appear multiple times, XMLout will create elements for this case. Note also that
       all attributes must come before the first element, thus the first array in the dtd ends the attribute
       list. As an example, the following dtd

           $dtd = [ 'user' =&gt;
                        'login',
                        [ 'favorite_fruits' ],
                        'password',
                  ];

       will create xml like:

           &lt;user login="foo"&gt;
             &lt;favorite_fruits&gt;apple&lt;/favorite_fruits&gt;
             &lt;favorite_fruits&gt;peach&lt;/favorite_fruits&gt;
             &lt;password&gt;bar&lt;/password&gt;
           &lt;/user&gt;

       "login" is translated to an attribute and "password" to an element.

       You can use an empty array reference to force the end of the attribute list, e.g.:

           $dtd = [ 'user' =&gt;
                        [],
                        'login',
                        'password',
                  ];

       will translate to

           &lt;user&gt;
             &lt;login&gt;foo&lt;/login&gt;
             &lt;password&gt;bar&lt;/password&gt;
           &lt;/user&gt;

       instead of

           &lt;user login="foo" password="bar"/&gt;

   <b>sub-elements</b>
       sub-elements are elements that also contain attributes or other elements. They are specified in the dtd
       as arrays with more than one element. Here is an example:

           $dtd = [ 'user' =&gt;
                        'login',
                        [ 'address' =&gt;
                            'street',
                            'city',
                        ],
                  ];

       Valid xml for this dtd looks like:

           &lt;user login="foo"&gt;
             &lt;address street="broadway 7" city="new york"/&gt;
           &lt;/user&gt;

       It is sometimes useful to specify such dtds in multiple steps:

           $addressdtd = [ 'address' =&gt;
                                'street',
                                'city',
                         ];

           $dtd = [ 'user' =&gt;
                        'login',
                        $addressdtd,
                  ];

   <b>multiple</b> <b>sub-elements</b> <b>with</b> <b>the</b> <b>same</b> <b>name</b>
       As with simple elements, one can allow sub-elements to occur multiple times. XMLin() creates an array of
       hash references in this case.  The dtd specification uses an array reference to an array for this case,
       for example:

           $dtd = [ 'user' =&gt;
                        'login',
                        [[ 'address' =&gt;
                            'street',
                            'city',
                        ]],
                  ];
       Or, with the $addressdtd definition used in the previous example:

           $dtd = [ 'user' =&gt;
                        'login',
                        [ $addressdtd ],
                  ];

       Accepted XML is:

           &lt;user login="foo"&gt;
             &lt;address street="broadway 7" city="new york"/&gt;
             &lt;address street="rural road 12" city="tempe"/&gt;
           &lt;/user&gt;

   <b>the</b> <b>_content</b> <b>pseudo-element</b>
       All of the non-whitespace parts between elements get collected into a single "_content" element. As
       example,

           &lt;user login="foo"&gt;
             &lt;address street="broadway 7" city="new york"/&gt;hello
             &lt;address street="rural road 12" city="tempe"/&gt;world
           &lt;/user&gt;

       would set the _content element to "hello world\n" (the dtd must allow a _content element, of course). If
       the dtd is

           $dtd = [ 'user' =&gt;
                        'login',
                        [ $addressdtd ],
                        '_content',
                  ];

       the xml string created by <b>XMLout()</b> will be:

           &lt;user login="foo"&gt;
             &lt;address street="broadway 7" city="new york"/&gt;
             &lt;address street="rural road 12" city="tempe"/&gt;
           hello world
           &lt;/user&gt;

       The exact input cannot be re-created, as the positions and the fragmentation of the content data is lost.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>XML::Structured</b> requires either XML::Parser or XML::SAX.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2006-2019 Michael Schroeder &lt;<a href="mailto:mls@suse.de">mls@suse.de</a>&gt;

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.1                                       2025-04-15                                    <u><a href="../man3pm/Structured.3pm.html">Structured</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>