<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time::ParseDate -- date parsing both relative and absolute</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtime-parsedate-perl">libtime-parsedate-perl_2015.103-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Time::ParseDate -- date parsing both relative and absolute

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use Time::ParseDate;
               $seconds_since_jan1_1970 = parsedate("12/11/94 2pm", NO_RELATIVE =&gt; 1)
               $seconds_since_jan1_1970 = parsedate("12/11/94 2pm", %options)

</pre><h4><b>OPTIONS</b></h4><pre>
       Date parsing can also use options.  The options are as follows:

               FUZZY   -&gt; it's okay not to parse the entire date string
               NOW     -&gt; the "current" time for relative times (defaults to time())
               ZONE    -&gt; local timezone (defaults to $ENV{TZ})
               WHOLE   -&gt; the whole input string must be parsed
               GMT     -&gt; input time is assumed to be GMT, not localtime
               UK      -&gt; prefer UK style dates (dd/mm over mm/dd)
               DATE_REQUIRED -&gt; do not default the date
               TIME_REQUIRED -&gt; do not default the time
               NO_RELATIVE -&gt; input time is not relative to NOW
               TIMEFIRST -&gt; try parsing time before date [not default]
               PREFER_PAST -&gt; when year or day of week is ambiguous, assume past
               PREFER_FUTURE -&gt; when year or day of week is ambiguous, assume future
               SUBSECOND -&gt; parse fraction seconds
               VALIDATE -&gt; only accept normal values for HHMMSS, YYMMDD.  Otherwise
                       days like -1 might give the last day of the previous month.

</pre><h4><b>DATE</b> <b>FORMATS</b> <b>RECOGNIZED</b></h4><pre>
   <b>Absolute</b> <b>date</b> <b>formats</b>
               Dow, dd Mon yy
               Dow, dd Mon yyyy
               Dow, dd Mon
               dd Mon yy
               dd Mon yyyy
               Month day{st,nd,rd,th}, year
               Month day{st,nd,rd,th}
               Mon dd yyyy
               yyyy/mm/dd
               yyyy-mm-dd      (usually the best date specification syntax)
               yyyy/mm
               mm/dd/yy
               mm/dd/yyyy
               mm/yy
               yy/mm      (only if year &gt; 12, or &gt; 31 if UK)
               yy/mm/dd   (only if year &gt; 12 and day &lt; 32, or year &gt; 31 if UK)
               dd/mm/yy   (only if UK, or an invalid mm/dd/yy or yy/mm/dd)
               dd/mm/yyyy (only if UK, or an invalid mm/dd/yyyy)
               dd/mm      (only if UK, or an invalid mm/dd)

   <b>Relative</b> <b>date</b> <b>formats:</b>
               count "days"
               count "weeks"
               count "months"
               count "years"
               Dow "after next"
               Dow "before last"
               Dow                     (requires PREFER_PAST or PREFER_FUTURE)
               "next" Dow
               "tomorrow"
               "today"
               "yesterday"
               "last" dow
               "last week"
               "now"
               "now" "+" count units
               "now" "-" count units
               "+" count units
               "-" count units
               count units "ago"

   <b>Absolute</b> <b>time</b> <b>formats:</b>
               hh:mm:ss[.ddd]
               hh:mm
               hh:mm[AP]M
               hh[AP]M
               hhmmss[[AP]M]
               "noon"
               "midnight"

   <b>Relative</b> <b>time</b> <b>formats:</b>
               count "minutes"         (count can be franctional "1.5" or "1 1/2")
               count "seconds"
               count "hours"
               "+" count units
               "+" count
               "-" count units
               "-" count
               count units "ago"

   <b>Timezone</b> <b>formats:</b>
               [+-]dddd
               GMT[+-]d+
               [+-]dddd (TZN)
               TZN

   <b>Special</b> <b>formats:</b>
               [ d]d/Mon/yyyy:hh:mm:ss [[+-]dddd]
               yy/mm/dd.hh:mm

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module recognizes the above date/time formats.   Usually a date and a time are specified.  There are
       numerous options for controlling what is recognized and what is not.

       The return code is always the time in seconds since January 1st, 1970 or undef if it was unable to parse
       the time.

       If a timezone is specified it must be after the time.  Year specifications can be tacked onto the end of
       absolute times.

       If parsedate() is called from array context, then it will return two elements.  On successful parses, it
       will return the seconds and what remains of its input string.  On unsuccessful parses, it will return
       "undef" and an error string.

</pre><h4><b>EXAMPLES</b></h4><pre>
               $seconds = parsedate("Mon Jan  2 04:24:27 1995");
               $seconds = parsedate("Tue Apr 4 00:22:12 PDT 1995");
               $seconds = parsedate("04.04.95 00:22", ZONE =&gt; PDT);
               $seconds = parsedate("Jan 1 1999 11:23:34.578", SUBSECOND =&gt; 1);
               $seconds = parsedate("122212 950404", ZONE =&gt; PDT, TIMEFIRST =&gt; 1);
               $seconds = parsedate("+3 secs", NOW =&gt; 796978800);
               $seconds = parsedate("2 months", NOW =&gt; 796720932);
               $seconds = parsedate("last Tuesday");
               $seconds = parsedate("Sunday before last");

               ($seconds, $remaining) = parsedate("today is the day");
               ($seconds, $error) = parsedate("today is", WHOLE=&gt;1);

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright (C) 1996-2010 David Muir Sharnoff.  Copyright (C) 2011 Google, Inc.  License hereby granted for
       anyone to use, modify or redistribute this module at their own risk.  Please feed useful changes back to
       <a href="mailto:cpan@dave.sharnoff.org">cpan@dave.sharnoff.org</a>.

perl v5.40.0                                       2024-10-29                               <u>Time::<a href="../man3pm/ParseDate.3pm.html">ParseDate</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>