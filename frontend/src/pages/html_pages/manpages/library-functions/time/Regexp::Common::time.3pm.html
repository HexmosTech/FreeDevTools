<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regexp::Common::time - Date and time regexps.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libregexp-common-time-perl">libregexp-common-time-perl_0.16-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Regexp::Common::time - Date and time regexps.

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Regexp::Common qw(time);

        # Piecemeal, Time::Format-like patterns
        $RE{time}{tf}{-pat =&gt; 'pattern'}

        # Piecemeal, strftime-like patterns
        $RE{time}{strftime}{-pat =&gt; 'pattern'}

        # Match ISO8601-style date/time strings
        $RE{time}{iso}

        # Match RFC2822-style date/time strings
        $RE{time}{mail}
        $RE{time}{MAIL}    # more-strict matching

        # Match informal American date strings
        $RE{time}{american}

        # Fuzzy date patterns
        #               YEAR/MONTH/DAY
        $RE{time}{ymd}         # Most flexible
        $RE{time}{YMD}         # Strictest (equivalent to y4m2d2)
                        # Other available patterns: y2md, y4md, y2m2d2, y4m2d2

        #               MONTH/DAY/YEAR  (American style)
        $RE{time}{mdy}         # Most flexible
        $RE{time}{MDY}         # Strictest (equivalent to m2d2y4)
                        # Other available patterns: mdy2, mdy4, m2d2y2, m2d2y4

        #               DAY/MONTH/YEAR  (European style)
        $RE{time}{mdy}         # Most flexible
        $RE{time}{MDY}         # Strictest (equivalent to d2m2y4)
                        # Other available patterns: dmy2, dmy4, d2m2y2, d2m2y4

        # Fuzzy time pattern
        #               HOUR/MINUTE/SECOND
        $RE{time}{hms}    # H: matches 1 or 2 digits; 12 or 24 hours
                          # M: matches 2 digits.
                          # S: matches 2 digits; may be omitted
                          # May be followed by "a", "am", "p.m.", etc.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module creates regular expressions that can be used for parsing dates and times.  See Regexp::Common
       for a general description of how to use this interface.

       Parsing dates is a dirty business. Dates are generally specified in one of three possible orders:
       year/month/day, month/day/year, or day/month/year.  Years can be specified with four digits or with two
       digits (with assumptions made about the century).  Months can be specified as one digit, two digits, as a
       spelled-out name, or as a three-letter abbreviation.  Day numbers can be one digit or two digits, with
       limits depending on the month (and, in the case of February, even the year).  Also, different people use
       different punctuation for separating the various elements.

       A human can easily recognize that "October 21, 2005" and "21.10.05" refer to the same date, but it's
       tricky to get a program to come to the same conclusion.  This module attempts to make it possible to do
       so, with a minimum of difficulty.

       •   If  you  know  the exact format of the data to be matched, use one of the specific, piecemeal pattern
           builders: "tf" or "strftime".

       •   If you are parsing RFC-2822 mail headers, use the "mail" pattern.

       •   If you are parsing informal American dates, use the "american" pattern.

       •   If there is some variability in your input data, use one of the fuzzy-matching patterns in the "dmy",
           "mdy", or "ymd" families.

       •   If the data are wildly variable, such as raw  user  input,  you  should  probably  give  up  and  use
           Date::Manip or Date::Parse.

       Time  values  are  generally much simpler to parse than date values.  Only one fuzzy pattern is provided,
       and it should suffice for most needs.

</pre><h4><b>Time::Format</b> <b>PATTERNS</b></h4><pre>
       The Time::Format module uses simple, intuitive strings for specifying date and time formats.  You can use
       these patterns here as well.  See Time::Format for details about its format specifiers.

       <u>Example:</u>

           $str = 'Thu November 2, 2005';
           $str =~ $RE{time}{tf}{-pat =&gt; 'Day Month d, yyyy'};

       The patterns can contain more complex regexp expressions as well:

           $str =~ $RE{time}{tf}{-pat =&gt; '(Weekday|Day) (Month|Mon) d, yyyy'};

       Time zone matching (the "tz" format code) attempts to adhere to RFC2822 and ISO8601 as much as  possible.
       The following time zones are matched:

           Z
           UT        UTC
           +hh:mm    -hh:mm
           +hhmm     -hhmm
           +hh       -hh
           GMT   EST EDT   CST CDT   MST MDT   PST PDT

</pre><h4><b>strftime</b> <b>PATTERNS</b></h4><pre>
       The  POSIX "strftime" function is a long-recognized standard for formatting dates and times.  This module
       supports most of "stftime"'s codes for  matching;  specifically,  the  "aAbBcCDdeHIjmMnprRSTtuUVwWyxXYZ%"
       codes.   The  %Z  format  matches  time  zones  in the same manner as described above under "Time::Format
       PATTERNS".

       Also, this module provides the following nonstandard codes:

       "   %_d  -" 1- or 2-digit day number (1-31)

       "   %_H  -" 1- or 2-digit hour (0-23)

       "   %_I  -" 1- or 2-digit hour (1-12)

       "   %_m  -" 1- or 2-digit month number (1-12)

       "   %_M  -" 1- or 2-digit minute (0-59)

       <u>Example:</u>

           $str = 'Thu November 2, 2005';
           $str =~ $RE{time}{strftime}{-pat =&gt; '%a %B %_d, %Y'};

       The patterns can contain more complex regexp expressions as well:

           $str =~ $RE{time}{strftime}{-pat =&gt; '(%A|%a)? (%B|%b) ?%_d, %Y'};

</pre><h4><b>ISO-8601</b> <b>DATE/TIME</b> <b>MATCHING</b></h4><pre>
       The $RE{time}{iso} pattern will match most (all?) strings formatted  as  recommended  by  ISO-8601.   The
       canonical ISO-8601 form is:

           YYYY-MM-DDTHH:MM:SS

       (where  ""T""  is  a  literal  T  character).   The $RE{time}{iso} pattern will match this form, and some
       variants:

       •   The date separator character may be a hyphen, slash ("/"), period, or empty  string  (omitted).   The
           two date separators must match.

       •   The  time  separator character may be a colon, a period, a space, or empty string (omitted).  The two
           time separators must match.

       •   The date-time separator may be a "T", an underscore, a space, or empty string (omitted).

       •   Either the date or the time may be omitted.  But at least one must be there.

       •   If the date is not omitted, all three of its components must be present.

       •   If the time is not omitted, all three of its components must be present.

</pre><h4><b>RFC</b> <b>2822</b> <b>MATCHING</b></h4><pre>
       RFC 2822 specifies the format of date/time values in e-mail message headers.  In a nutshell,  the  format
       is:

           dd Mon yyyy hh:mm:ss +zzzz

       where  "dd"  is the day of the month; "Mon" is the abbreviated month name (apparently always in English);
       "yyyy" is the year; "hh:mm:ss" is the time; and "+zzzz" is the  time  zone,  generally  specified  as  an
       offset from GMT.

       RFC  2822  requires  that  the  weekday  also be specified, but this module ignores the weekday, as it is
       redundant and only supplied for human readability.

       RFC 2822 requires that older, obsolete date forms be allowed as well; for example, alphanumeric time zone
       codes (e.g. EDT).  This module's "mail" allows for these obsolete date forms.  If you want to match  only
       the proper date forms recommended by RFC 2822, you can use the "MAIL" pattern instead.

       In  either  case,  "mail"  or  "MAIL", the pattern generated is very flexible about whitespace.  The main
       differences are: with "MAIL", two-digit years are not permitted, and the time zone must  be  four  digits
       preceded by a + or - sign.

</pre><h4><b>INFORMAL</b> <b>AMERICAN</b> <b>MATCHING</b></h4><pre>
       People  in  North  America, particularly in the United States, are fond of specifying dates as "Month dd,
       yyyy", or sometimes with a two-digit year and  apostrophe:  "Month  dd,  'yy".   The  "american"  pattern
       matches  this style of date.  It allows either a month name or abbreviation, and is flexible with respect
       to commas and whitespace.

</pre><h4><b>FUZZY</b> <b>PATTERN</b> <b>OVERVIEW</b></h4><pre>
       Fuzzy date patterns have the following properties in common:

       •   The pattern names consist of the letters "y", "m", and "d", each optionally followed by  a  digit  (2
           for "m" and "d"; 2 or 4 for "y").

       •   If a "y" is followed by a 2 or a 4, it must match that many digits.

       •   If a "y" has no trailing digit, it can match <u>either</u> 2 or 4 digits, trying 4 first.

       •   If  an  "m"  is  followed by a 2, then only two-digit matches for the month are considered, and month
           names are not matched.

       •   If an "m" is not followed by a 2, then the month may be 1 or 2 digits, or a spelled-out name.

       •   Just like for months, if a "d" is followed by a 2, then  only  two-digit  matches  for  the  day  are
           considered.

       •   Just  like  for  months,  if  a  "d"  has no trailing digit, then the day may be 1 or 2 digits, and a
           1-digit match may not have any adjacent digits.

       •   The uppercase "DMY", "MDY", and "YMD" patterns are synonyms for the strict  "d2m2y4",  "m2d2y4",  and
           "y4m2d2" patterns, respectively.

       •   If  a  one-digit  match  is  considered  for  the month, then no adjacent digits are allowed.  (e.g.:
           "1/23/45" in M/D/Y format has a valid  one-digit  month  match,  but  "12345"  does  not.   Nor  does
           "91/23/45").

       •   If  a  pattern  begins  with  an  digitless  "d", "m", or "y", then, in the string to be matched, any
           leading  digits  will  cause  the  pattern  to  fail.   For  example:  "012/23/45"  will  <u>not</u>   match
           $RE{time}{mdy}.   However, it <u>will</u> match $RE{time}{m2d2y2}.  If you specify an exact pattern by using
           "m2" instead of "m", this module assumes you know what you're doing.

       •   Likewise, a pattern ending with a digitless "d" or "y" will not match if there are trailing digits in
           the string.

</pre><h4><b>FUZZY</b> <b>PATTERN</b> <b>DETAILS</b></h4><pre>
   <b>Year-Month-Day</b> <b>order</b>
       $RE{time}{ymd}
            "05/4/2"      =~ $RE{time}{ymd};
            "2005-APR-02" =~ $RE{time}{ymd};

           This is the most flexible of the numeric-only year/month/day formats.  It matches a date of the  form
           "year/month/day",  where  the year may be 2 or 4 digits; the month may be 1 or 2 digits or a spelled-
           out name or name abbreviation, and the day may be 1 or 2 digits.  The year/month/day elements may  be
           directly adjacent to each other, or may be separated by a space, period, slash ("/"), or hyphen.

       $RE{time}{y4md}
            "2005/4/2"    =~ $RE{time}{y4md};
            "2005 APR 02" =~ $RE{time}{y4md};

           This works as $RE{time}{ymd}, except that the year is restricted to be exactly 4 digits.

       $RE{time}{y4m2d2}
            "2005/04/02" =~ $RE{time}{y4m2d2};

           This  works  as  $RE{time}{ymd},  except  that the year is restricted to be exactly 4 digits, and the
           month and day must be exactly 2 digits each.

       $RE{time}{y2md}
            "05/4/2"    =~ $RE{time}{y2md};
            "05.APR.02" =~ $RE{time}{y2md};

           This works as $RE{time}{ymd}, except that the year is restricted to be exactly 2 digits.

       $RE{time}{y2m2d2}
            "05/04/02" =~ $RE{time}{y2m2d2};

           This works as $RE{time}{ymd}, except that the year is restricted to be  exactly  2  digits,  and  the
           month and day must be exactly 2 digits each.

       $RE{time}{YMD}
            "2005/04/02" =~ $RE{time}{YMD};

           This is a shorthand for the "canonical" year/month/day format, "y4m2d2".

   <b>Month-Day-Year</b> <b>(American)</b> <b>order</b>
       $RE{time}{mdy}
       $RE{time}{mdy4}
       $RE{time}{m2d2y4}
       $RE{time}{mdy2}
       $RE{time}{m2d2y2}
       $RE{time}{MDY}
           These  patterns function as the equivalent year/month/day patterns, above; the only difference is the
           order of the elements.  "MDY" is a synonym for "m2d2y4".

   <b>Day-Month-Year</b> <b>(European)</b> <b>order</b>
       $RE{time}{dmy}
       $RE{time}{dmy4}
       $RE{time}{d2m2y4}
       $RE{time}{dmy2}
       $RE{time}{d2m2y2}
       $RE{time}{DMY}
           These patterns function as the equivalent year/month/day patterns, above; the only difference is  the
           order of the elements.  "DMY" is a synonym for "d2m2y4".

</pre><h4><b>Time</b> <b>pattern</b> <b>(Hour-minute-second)</b></h4><pre>
       $RE{time}{hms}
            "10:06:12a" =~ /$RE{time}{hms}/;
            "9:00 p.m." =~ /$RE{time}{hms}/;

           Matches a time value in a string.

           The  hour  must  be in the range 0 to 24.  The minute and second values must be in the range 0 to 59,
           and must be two digits (i.e., they must have leading zeroes if less than 10).

           The hour, minute, and second components may be separated by colons (":"), periods, or spaces.

           The "seconds" value may be omitted.

           The time may be followed by an "am/pm" indicator; that is, one of the following values:

             a   am   a.m.  p   pm   p.m.   A   AM   A.M.  P   PM   P.M.

           There may be a space between the time and the am/pm indicator.

</pre><h4><b>CAPTURES</b> <b>(-keep)</b></h4><pre>
       Under "-keep", the "tf" and "strftime" patterns capture the entire match as $1, plus one capture variable
       for each format specifier.  However, if your pattern contains any parentheses, "tf" and  "strftime"  will
       <u>not</u>  capture  anything  additional  beyond  what you specify, "-keep" or not.  In other words: if you use
       parentheses, you are responsible for all capturing.

       The "iso" pattern captures:

       "  $1  -" the entire match

       "  $2  -" the year

       "  $3  -" the month

       "  $4  -" the day

       "  $5  -" the hour

       "  $6  -" the minute

       "  $7  -" the second

       The year, month, and day ($2, $3, and $4) will be "undef" if the matched  string  contains  only  a  time
       value  (e.g.,  "12:34:56").  The hour, minute, and second ($5, $6, and $7) will be "undef" if the matched
       string contains only a date value (e.g., "2005-01-23").

       The "mail" and "MAIL" patterns capture:

       "  $1  -" the entire match

       "  $2  -" the day

       "  $3  -" the month

       "  $4  -" the year

       "  $5  -" the hour

       "  $6  -" the minute

       "  $7  -" the second

       "  $8  -" the time zone

       The "american" pattern captures:

       "  $1  -" the entire match

       "  $2  -" the month

       "  $3  -" the day

       "  $4  -" the year

       The fuzzy y/m/d patterns capture

       "  $1  -" the entire match

       "  $2  -" the year

       "  $3  -" the month

       "  $4  -" the day

       The fuzzy m/d/y patterns capture

       "  $1  -" the entire match

       "  $2  -" the month

       "  $3  -" the day

       "  $4  -" the year

       The fuzzy d/m/y patterns capture

       "  $1  -" the entire match

       "  $2  -" the day

       "  $3  -" the month

       "  $4  -" the year

       The fuzzy h/m/s pattern captures

       "  $1  -" the entire match

       "  $2  -" the hour

       "  $3  -" the minute

       "  $4  -" the second  ("undef" if omitted)

       "  $5  -" the am/pm indicator ("undef" if omitted)

</pre><h4><b>EXAMPLES</b></h4><pre>
        # Typical usage: parsing a data record.
        #
        $rec = "blah blah 2005/10/21 blah blarrrrrgh";
        @date = $rec =~ m{^blah blah $RE{time}{YMD}{-keep}};
        # or
        @date = $rec =~ m{^blah blah $RE{time}{tf}{-pat=&gt;'yyyy/mm/dd'}{-keep}};
        # or
        @date = $rec =~ m{^blah blah $RE{time}{strftime}{-pat=&gt;'%Y/%m/%d'}{-keep}};

        # Typical usage: parsing variable-format data.
        #
        use Time::Normalize;

        $record = "10-SEP-2005";

        # This block tries M-D-Y first, then D-M-Y, then Y-M-D
        my $matched;
        foreach my $pattern (qw(mdy dmy ymd))
        {
            @values = $record =~ /^$RE{time}{$pattern}{-keep}/
                or next;

            $matched = $pattern;
        }
        if ($matched)
        {
            eval{ ($year, $month, $day) = normalize_rct($matched, @values) };
            if ($@)
            {
                .... # handle erroneous data
            }
        }
        else
        {
            .... # no match
        }
        #
        # $day is now 10; $month is now 09; $year is now 2005.

        # Time examples

        $time = '9:10pm';

        @time_data = $time =~ /$RE{time}{hms}{-keep}/;
        # captures '9:10pm', '9', '10', undef, 'pm'

        @time_data = $time =~ /$RE{time}{tf}{-pat =&gt; '(h):(mm)(:ss)?(am)?'}{-keep}/;
        # captures '9', '10', undef, 'pm'

</pre><h4><b>EXPORTS</b></h4><pre>
       This module exports no symbols to the caller's namespace.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       It's not enough that the date regexps can match various formats.  You then have to  parse  those  matched
       data  values and translate them into useful values.  The Time::Normalize module is highly recommended for
       performing this repetitive, error-prone task.

</pre><h4><b>REQUIREMENTS</b></h4><pre>
       Requires Regexp::Common, of course.

       If POSIX and I18N::Langinfo are available, this module will use them; otherwise, it  will  use  hardcoded
       English values for month and weekday names.

       Test::More is required for the test suite.

</pre><h4><b>AUTHOR</b></h4><pre>
       Eric J. Roode, ROODE <u>-at-</u> cpan <u>-dot-</u> org

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2005-2008 by Eric J. Roode, ROODE <u>-at-</u> cpan <u>-dot-</u> org

       All rights reserved.

       To  avoid my spam filter, please include "Perl", "module", or this module's name in the message's subject
       line, and/or GPG-sign your message.

       This module is copyrighted only to ensure proper attribution of authorship and to ensure that it  remains
       available  to  all.   This  module is free, open-source software.  This module may be freely used for any
       purpose, commercial, public, or private, provided  that  proper  credit  is  given,  and  that  no  more-
       restrictive license is applied to derivative (not dependent) works.

       Substantial efforts have been made to ensure that this software meets high quality standards; however, no
       guarantee  can  be made that there are no undiscovered bugs, and no warranty is made as to suitability to
       any given use, including merchantability.  Should this module cause your house to burn down, your dog  to
       collapse,  your heart-lung machine to fail, your spouse to desert you, or George Bush to be re-elected, I
       can offer only my sincere sympathy and apologies, and promise to endeavor to improve the software.

perl v5.36.0                                       2022-12-06                          <u>Regexp::Common::<a href="../man3pm/time.3pm.html">time</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>