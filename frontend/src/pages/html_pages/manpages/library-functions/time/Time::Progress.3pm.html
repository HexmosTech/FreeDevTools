<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time::Progress - Elapsed and estimated finish time reporting.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtime-progress-perl">libtime-progress-perl_2.15-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Time::Progress - Elapsed and estimated finish time reporting.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Time::Progress;

         my ($min, $max) = (0, 4);
         my $p = Time::Progress-&gt;new(min =&gt; $min, max =&gt; $max);

         for (my $c = $min; $c &lt;= $max; $c++) {
           print STDERR $p-&gt;report("\r%20b  ETA: %E", $c);
           # do some work
         }
         print STDERR "\n";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module displays progress information for long-running processes.  This can be percentage complete,
       time elapsed, estimated time remaining, an ASCII progress bar, or any combination of those.

       It is useful for code where you perform a number of steps, or iterations of a loop, where the number of
       iterations is known before you start the loop.

       The typical usage of this module is:

       •   Create an instance of "Time::Progress", specifying min and max count values.

       •   At  the  head  of  the  loop,  you call the report() method with a format specifier and the iteration
           count, and get back a string that should be displayed.

       If you include a carriage return character (\r) in the format string, then  the  message  will  be  over-
       written  at  each step.  Putting \r at the start of the format string, as in the SYNOPSIS, results in the
       cursor sitting at the end of the message.

       If you display to STDOUT, then remember to enable auto-flushing:

        use IO::Handle;
        STDOUT-&gt;<a href="../man1/autoflush.1.html">autoflush</a>(1);

       The shortest time interval that can be measured is 1 second.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
         my $p = Time::Progress-&gt;new(%options);

       Returns new object of Time::Progress class and starts the timer.  It also sets min and max  values  to  0
       and 100, so the next <b>report</b> calls will default to percents range.

       You can configure the instance with the following parameters:

       min Sets the <b>min</b> attribute, as described in the "attr" section below.

       max Sets the <b>max</b> attribute, as described in the "attr" section below.

       smoothing
           If  set  to  a  true value, then the estimated time remaining is smoothed in a simplistic way: if the
           time remaining ever goes up, by less than 10% of the previous estimate, then we just stick  with  the
           previous estimate. This prevents flickering estimates.  By default this feature is turned off.

       smoothing_delta
           Sets  smoothing delta parameter. Default value is 0.1 (i.e. 10%).  See 'smoothing' parameter for more
           details.

   <b>restart</b>
       Restarts the timer and clears the stop mark.  Optionally <b>restart()</b> may act also  as  <b>attr()</b>  for  setting
       attributes:

         $p-&gt;restart( min =&gt; 1, max =&gt; 5 );

       is the same as:

         $p-&gt;attr( min =&gt; 1, max =&gt; 5 );
         $p-&gt;restart();

       If you need to count things, you can set just 'max' attribute since 'min' is already set to 0 when object
       is constructed by <b>new()</b>:

         $p-&gt;restart( max =&gt; 42 );

   <b>stop</b>
       Sets  the  stop  mark.  This  is  only  useful  if  you do some work, then finish, then do some work that
       shouldn't be timed and finally report. Something like:

         $p-&gt;restart;
         # do some work here...
         $p-&gt;stop;
         # do some post-work here
         print $p-&gt;report;
         # `post-work' will not be timed

       Stop is useless if you want to report time as soon as work is finished like:

         $p-&gt;restart;
         # do some work here...
         print $p-&gt;report;

   <b>continue</b>
       Clears the stop mark. (mostly useless, perhaps you need to <b>restart</b>?)

   <b>attr</b>
       Sets and returns internal values for attributes. Available attributes are:

       min This is the min value of the items that will follow (used to calculate estimated finish time)

       max This is the max value of all items in the even (also used to calculate estimated finish time)

       format
           This is the default <b>report</b> format. It is used if <b>report</b> is called without parameters.

       <b>attr</b> returns array of the set attributes:

         my ( $new_min, $new_max ) = $p-&gt;attr( min =&gt; 1, max =&gt; 5 );

       If you want just to get values use undef:

         my $old_format = $p-&gt;attr( format =&gt; undef );

       This way of handling attributes is a bit heavy but saves a lot of attribute handling functions. <b>attr</b> will
       complain if you pass odd number of parameters.

   <b>report</b>
       This is the most complex method in this package :)

       The expected arguments are:

         $p-&gt;report( format, [current_item] );

       <u>format</u> is string that will be used for the result string. Recognized special sequences are:

       %l  elapsed seconds

       %L  elapsed time in minutes in format MM:SS

       %e  remaining seconds

       %E  remaining time in minutes in format MM:SS

       %p  percentage done in format PPP.P%

       %f  estimated finish time in format returned by <b>localtime()</b>

       %b
       %B  progress bar which looks like:

             ##############......................

           %b takes optional width:

             %40b -- 40-chars wide bar
             %9b  --  9-chars wide bar
             %b   -- 79-chars wide bar (default)

       %s  current speed in items per second

       %S  current min/max speeds (calculated after first 1% of the progress)

       Parameters can be omitted and then default format set with <b>attr</b> will be used.

       Sequences 'L', 'l', 'E' and 'e' can have width also:

         %10e
         %5l
         ...

       Estimate time calculations can be used only if min and max values are set (see <b>attr</b> method)  and  current
       item  is  passed  to  <b>report</b>!  if you want to use the default format but still have estimates use it like
       this:

         $p-&gt;format( undef, 45 );

       If you don't give current item (step) or didn't set proper min/max value then all estimate sequences will
       have value `n/a'.

       You can freely mix reports during the same event.

   <b>elapsed($item)</b>
       Returns the time elapsed, in seconds.  This help function, and those described below, take one  argument:
       the current item number.

   <b>estimate($item)</b>
       Returns an estimate of the time remaining, in seconds.

   <b>elapsed_str($item)</b>
       Returns elapsed time as a formatted string:

         "elapsed time is MM:SS min.\n"

   <b>estimate_str($item)</b>
       Returns estimated remaining time, as a formatted string:

         "remaining time is MM:SS min.\n"

</pre><h4><b>FORMAT</b> <b>EXAMPLES</b></h4><pre>
        # $c is current element (step) reached
        # for the examples: min = 0, max = 100, $c = 33.3

        print $p-&gt;report( "done %p elapsed: %L (%l sec), ETA %E (%e sec)\n", $c );
        # prints:
        # done  33.3% elapsed time   0:05 (5 sec), ETA   0:07 (7 sec)

        print $p-&gt;report( "%45b %p\r", $c );
        # prints:
        # ###############..............................  33.3%

        print $p-&gt;report( "done %p ETA %f\n", $c );
        # prints:
        # done  33.3% ETA Sun Oct 21 16:50:57 2001

        print $p-&gt;report( "%30b %p %s/sec (%S) %L ETA: %E" );
        # ..............................   0.7% 924/sec (938/951)   1:13 ETA: 173:35

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The  first  thing  you need to know about Smart::Comments is that it was written by Damian Conway, so you
       should expect to be a little bit freaked out by it. It looks for certain format comments  in  your  code,
       and uses them to display progress messages. Includes support for progress meters.

       Progress::Any  separates  the  calculation  of  stats  from  the  display of those stats, so you can have
       different back-ends which display progress is different ways. There are a number of separate back-ends on
       CPAN.

       Term::ProgressBar displays a progress meter to a standard terminal.

       Term::ProgressBar::Quiet uses "Term::ProgressBar" if your code is running in a terminal. If  not  running
       interactively, then no progress bar is shown.

       Term::ProgressBar::Simple  provides a simple interface where you get a $progress object that you can just
       increment in a long-running loop.  It builds on "Term::ProgressBar::Quiet", so displays nothing when  not
       running interactively.

       Term::Activity displays a progress meter with timing information, and two different skins.

       Text::ProgressBar  is  another  customisable  progress  meter, which comes with a number of 'widgets' for
       display progress information in different ways.

       ProgressBar::Stack handles the case where a long-running process has a number of sub-processes,  and  you
       want to record progress of those too.

       String::ProgressBar provides a simple progress bar, which shows progress using a bar of ASCII characters,
       and the percentage complete.

       Term::Spinner  is  simpler than most of the other modules listed here, as it just displays a 'spinner' to
       the terminal. This is useful if you just want to show that something is happening, but can't predict  how
       many more operations will be required.

       Term::Pulse shows a pulsed progress bar in your terminal, using a child process to pulse the progress bar
       until your job is complete.

       Term::YAP a fork of "Term::Pulse".

       Term::StatusBar is another progress bar module, but it hasn't seen a release in the last 12 years.

</pre><h4><b>GITHUB</b> <b>REPOSITORY</b></h4><pre>
         https://github.com/cade-vs/perl-time-progress

         git clone https://github.com/cade-vs/perl-time-progress

</pre><h4><b>AUTHOR</b></h4><pre>
         Vladi Belperchinov-Shabanski "Cade"

         &lt;<a href="mailto:cade@bis.bg">cade@bis.bg</a>&gt; &lt;<a href="mailto:cade@cpan.org">cade@cpan.org</a>&gt;

         <a href="http://cade.datamax.bg">http://cade.datamax.bg</a>

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is (c) 2001-2019 by Vladi Belperchinov-Shabanski &lt;<a href="mailto:cade@bis.bg">cade@bis.bg</a>&gt; &lt;<a href="mailto:cade@cpan.org">cade@cpan.org</a>&gt;.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.1                                       2025-03-29                                <u>Time::<a href="../man3pm/Progress.3pm.html">Progress</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>