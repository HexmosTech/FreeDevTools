<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time::Piece - Object Oriented time objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Time::Piece - Object Oriented time objects

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Time::Piece;

           my $t = localtime;
           print "Time is $t\n";
           print "Year is ", $t-&gt;year, "\n";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module replaces the standard "localtime" and "gmtime" functions with implementations that return
       objects. It does so in a backwards compatible manner, so that using localtime/gmtime in the way
       documented in perlfunc will still return what you expect.

       The module actually implements most of an interface described by Larry Wall on the perl5-porters mailing
       list here: &lt;https://www.nntp.perl.org/group/perl.perl5.porters/2000/01/msg5283.html&gt;

</pre><h4><b>USAGE</b></h4><pre>
       After importing this module, when you use localtime or gmtime in a scalar context, rather than getting an
       ordinary scalar string representing the date and time, you get a Time::Piece object, whose
       stringification happens to produce the same effect as the localtime and gmtime functions. There is also a
       <b>new()</b> constructor provided, which is the same as <b>localtime()</b>, except when passed a Time::Piece object, in
       which case it's a copy constructor. The following methods are available on the object:

           $t-&gt;sec                 # also available as $t-&gt;second
           $t-&gt;min                 # also available as $t-&gt;minute
           $t-&gt;hour                # 24 hour
           $t-&gt;mday                # also available as $t-&gt;day_of_month
           $t-&gt;mon                 # 1 = January
           $t-&gt;_mon                # 0 = January
           $t-&gt;monname             # Feb
           $t-&gt;month               # same as $t-&gt;monname
           $t-&gt;fullmonth           # February
           $t-&gt;year                # based at 0 (year 0 AD is, of course 1 BC)
           $t-&gt;_year               # year minus 1900
           $t-&gt;yy                  # 2 digit year
           $t-&gt;wday                # 1 = Sunday
           $t-&gt;_wday               # 0 = Sunday
           $t-&gt;day_of_week         # 0 = Sunday
           $t-&gt;wdayname            # Tue
           $t-&gt;day                 # same as wdayname
           $t-&gt;fullday             # Tuesday
           $t-&gt;yday                # also available as $t-&gt;day_of_year, 0 = Jan 01
           $t-&gt;isdst               # also available as $t-&gt;daylight_savings

           $t-&gt;hms                 # 12:34:56
           $t-&gt;hms(".")            # 12.34.56
           $t-&gt;time                # same as $t-&gt;hms

           $t-&gt;ymd                 # 2000-02-29
           $t-&gt;date                # same as $t-&gt;ymd
           $t-&gt;mdy                 # 02-29-2000
           $t-&gt;mdy("/")            # 02/29/2000
           $t-&gt;dmy                 # 29-02-2000
           $t-&gt;dmy(".")            # 29.02.2000
           $t-&gt;datetime            # 2000-02-29T12:34:56 (ISO 8601)
           $t-&gt;cdate               # Tue Feb 29 12:34:56 2000
           "$t"                    # same as $t-&gt;cdate

           $t-&gt;epoch               # seconds since the epoch
           $t-&gt;tzoffset            # timezone offset in a Time::Seconds object

           $t-&gt;julian_day          # number of days since Julian period began
           $t-&gt;mjd                 # modified Julian date (JD-2400000.5 days)

           $t-&gt;week                # week number (ISO 8601)

           $t-&gt;is_leap_year        # true if it's a leap year
           $t-&gt;month_last_day      # 28-31

           $t-&gt;time_separator($s)  # set the default separator (default ":")
           $t-&gt;date_separator($s)  # set the default separator (default "-")
           $t-&gt;day_list(@days)     # set the default weekdays
           $t-&gt;mon_list(@days)     # set the default months

           $t-&gt;strftime(FORMAT)    # same as POSIX::strftime (without the overhead
                                   # of the full POSIX extension)
           $t-&gt;strftime()          # "Tue, 29 Feb 2000 12:34:56 GMT"

           Time::Piece-&gt;strptime(STRING, FORMAT)
                                   # see strptime man page. Creates a new
                                   # Time::Piece object

       Note that "localtime" and "gmtime" are not listed above.  If called as methods on a Time::Piece object,
       they act as constructors, returning a new Time::Piece object for the current time.  In other words:
       they're not useful as methods.

   <b>Local</b> <b>Locales</b>
       Both wdayname (day) and monname (month) allow passing in a list to use to index the name of the days
       against. This can be useful if you need to implement some form of localisation without actually
       installing or using locales. Note that this is a global override and will affect all Time::Piece
       instances.

         my @days = qw( Dimanche Lundi Merdi Mercredi Jeudi Vendredi Samedi );

         my $french_day = localtime-&gt;day(@days);

       These settings can be overridden globally too:

         Time::Piece::day_list(@days);

       Or for months:

         Time::Piece::mon_list(@months);

       And locally for months:

         print localtime-&gt;month(@months);

       Or to populate with your current system locale call:
           Time::Piece-&gt;<b>use_locale()</b>;

   <b>Date</b> <b>Calculations</b>
       It's possible to use simple addition and subtraction of objects:

           use Time::Seconds;

           my $seconds = $t1 - $t2;
           $t1 += ONE_DAY; # add 1 day (constant from Time::Seconds)

       The following are valid ($t1 and $t2 are Time::Piece objects):

           $t1 - $t2; # returns Time::Seconds object
           $t1 - 42; # returns Time::Piece object
           $t1 + 533; # returns Time::Piece object

       However adding a Time::Piece object to another Time::Piece object will cause a runtime error.

       Note that the first of the above returns a Time::Seconds object, so while examining the object will print
       the number of seconds (because of the overloading), you can also get the number of minutes, hours, days,
       weeks and years in that delta, using the Time::Seconds API.

       In addition to adding seconds, there are two APIs for adding months and years:

           $t = $t-&gt;<a href="../man6/add_months.6.html">add_months</a>(6);
           $t = $t-&gt;<a href="../man5/add_years.5.html">add_years</a>(5);

       The months and years can be negative for subtractions. Note that there is some "strange" behaviour when
       adding and subtracting months at the ends of months. Generally when the resulting month is shorter than
       the starting month then the number of overlap days is added. For example subtracting a month from
       2008-03-31 will not result in 2008-02-31 as this is an impossible date. Instead you will get 2008-03-02.
       This appears to be consistent with other date manipulation tools.

   <b>Truncation</b>
       Calling the "truncate" method returns a copy of the object but with the time truncated to the start of
       the supplied unit.

           $t = $t-&gt;truncate(to =&gt; 'day');

       This example will set the time to midnight on the same date which $t had previously. Allowed values for
       the "to" parameter are: "year", "quarter", "month", "day", "hour", "minute" and "second".

   <b>Date</b> <b>Comparisons</b>
       Date comparisons are also possible, using the full suite of "&lt;", "&gt;", "&lt;=", "&gt;=", "&lt;=&gt;", "==" and "!=".

   <b>Date</b> <b>Parsing</b>
       Time::Piece has a built-in <b>strptime()</b> function (from FreeBSD), allowing you incredibly flexible date
       parsing routines. For example:

         my $t = Time::Piece-&gt;strptime("Sunday 3rd Nov, 1943",
                                       "%A %drd %b, %Y");

         print $t-&gt;strftime("%a, %d %b %Y");

       Outputs:

         Wed, 03 Nov 1943

       (see, it's even smart enough to fix my obvious date bug)

       For more information see "man strptime", which should be on all unix systems.

       Alternatively look here: &lt;<a href="http://www.unix.com/man-page/FreeBSD/3/strftime/">http://www.unix.com/man-page/FreeBSD/3/strftime/</a>&gt;

       <u>CAVEAT</u> <u>%A,</u> <u>%a,</u> <u>%B,</u> <u>%b,</u> <u>and</u> <u>friends</u>

       Time::Piece::strptime by default can only parse American English date names.  Meanwhile,
       Time::Piece-&gt;<b>strftime()</b> will return date names that use the current configured system locale. This means
       dates returned by strftime might not be able to be parsed by strptime. This is the default behavior and
       can be overridden by calling Time::Piece-&gt;<b>use_locale()</b>. This builds a list of the current locale's day
       and month names which strptime will use to parse with.  Note this is a global override and will affect
       all Time::Piece instances.

       For instance with a German locale:

           localtime-&gt;day_list();

       Returns

           ( 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' )

       While:

           Time::Piece-&gt;use_locale();
           localtime-&gt;day_list();

       Returns

           ( 'So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa' )

   <b>YYYY-MM-DDThh:mm:ss</b>
       The ISO 8601 standard defines the date format to be YYYY-MM-DD, and the time format to be hh:mm:ss (24
       hour clock), and if combined, they should be concatenated with date first and with a capital 'T' in front
       of the time.

   <b>Week</b> <b>Number</b>
       The <u>week</u> <u>number</u> may be an unknown concept to some readers.  The ISO 8601 standard defines that weeks
       begin on a Monday and week 1 of the year is the week that includes both January 4th and the first
       Thursday of the year.  In other words, if the first Monday of January is the 2nd, 3rd, or 4th, the
       preceding days of the January are part of the last week of the preceding year.  Week numbers range from 1
       to 53.

   <b>Global</b> <b>Overriding</b>
       Finally, it's possible to override localtime and gmtime everywhere, by including the ':override' tag in
       the import list:

           use Time::Piece ':override';

</pre><h4><b>CAVEATS</b></h4><pre>
   <b>Setting</b> <b>$ENV{TZ}</b> <b>in</b> <b>Threads</b> <b>on</b> <b>Win32</b>
       Note that when using perl in the default build configuration on Win32 (specifically, when perl is built
       with PERL_IMPLICIT_SYS), each perl interpreter maintains its own copy of the environment and only the
       main interpreter will update the process environment seen by strftime.

       Therefore, if you make changes to $ENV{TZ} from inside a thread other than the main thread then those
       changes will not be seen by strftime if you subsequently call that with the %Z formatting code. You must
       change $ENV{TZ} in the main thread to have the desired effect in this case (and you must also call
       <b>_tzset()</b> in the main thread to register the environment change).

       Furthermore, remember that this caveat also applies to <b>fork()</b>, which is emulated by threads on Win32.

   <b>Use</b> <b>of</b> <b>epoch</b> <b>seconds</b>
       This module internally uses the epoch seconds system that is provided via the perl time() function and
       supported by gmtime() and localtime().

       If your perl does not support times larger than "2^31" seconds then this module is likely to fail at
       processing dates beyond the year 2038. There are moves afoot to fix that in perl. Alternatively use 64
       bit perl. Or if none of those are options, use the DateTime module which has support for years well into
       the future and past.

       Also, the internal representation of Time::Piece-&gt;strftime deviates from the standard POSIX
       implementation in that is uses the epoch (instead of separate year, month, day parts). This change was
       added in version 1.30. If you must have a more traditional strftime (which will normally never calculate
       day light saving times correctly), you can pass the date parts from Time::Piece into the strftime
       function provided by the POSIX module (see strftime in POSIX ).

</pre><h4><b>AUTHOR</b></h4><pre>
       Matt Sergeant, <a href="mailto:matt@sergeant.org">matt@sergeant.org</a> Jarkko Hietaniemi, <a href="mailto:jhi@iki.fi">jhi@iki.fi</a> (while creating Time::Piece for core perl)

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2001, Larry Wall.

       This module is free software, you may distribute it under the same terms as Perl.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The excellent Calendar FAQ at &lt;<a href="http://www.tondering.dk/claus/calendar.html">http://www.tondering.dk/claus/calendar.html</a>&gt;

</pre><h4><b>BUGS</b></h4><pre>
       The test harness leaves much to be desired. Patches welcome.

perl v5.40.1                                       2025-07-03                                 <u>Time::<a href="../man3perl/Piece.3perl.html">Piece</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>