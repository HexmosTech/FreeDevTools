<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
                             clock_gettime clock_getres clock_nanosleep clock
                             stat lstat utime);

         usleep ($microseconds);
         nanosleep ($nanoseconds);

         ualarm ($microseconds);
         ualarm ($microseconds, $interval_microseconds);

         $t0 = [gettimeofday];
         ($seconds, $microseconds) = gettimeofday;

         $elapsed = tv_interval ( $t0, [$seconds, $microseconds]);
         $elapsed = tv_interval ( $t0, [gettimeofday]);
         $elapsed = tv_interval ( $t0 );

         use Time::HiRes qw ( time alarm sleep );

         $now_fractions = time;
         sleep ($floating_seconds);
         alarm ($floating_seconds);
         alarm ($floating_seconds, $floating_interval);

         use Time::HiRes qw( setitimer getitimer );

         setitimer ($which, $floating_seconds, $floating_interval );
         getitimer ($which);

         use Time::HiRes qw( clock_gettime clock_getres clock_nanosleep
                   CLOCK_REALTIME ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF
                   ITIMER_REALPROF );

         $realtime   = clock_gettime(CLOCK_REALTIME);
         $resolution = clock_getres(CLOCK_REALTIME);

         clock_nanosleep(CLOCK_REALTIME, 1.5e9);
         clock_nanosleep(CLOCK_REALTIME, time()*1e9 + 10e9, TIMER_ABSTIME);

         my $ticktock = clock();

         use Time::HiRes qw( stat lstat );

         my @stat = stat("file");
         my @stat = stat(FH);
         my @stat = lstat("file");

         use Time::HiRes qw( utime );
         utime $floating_seconds, $floating_seconds, file...;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The "Time::HiRes" module implements a Perl interface to the "usleep", "nanosleep", "ualarm",
       "gettimeofday", and "setitimer"/"getitimer" system calls, in other words, high resolution time and
       timers. See the "EXAMPLES" section below and the test scripts for usage; see your system documentation
       for the description of the underlying "nanosleep" or "usleep", "ualarm", "gettimeofday", and
       "setitimer"/"getitimer" calls.

       If your system lacks gettimeofday() or an emulation of it you don't get gettimeofday() or the one-
       argument form of tv_interval().  If your system lacks all of nanosleep(), usleep(), select(), and "poll",
       you don't get Time::HiRes::usleep(), Time::HiRes::nanosleep(), or Time::HiRes::sleep().  If your system
       lacks both ualarm() and setitimer() you don't get Time::HiRes::ualarm() or Time::HiRes::alarm().

       If you try to import an unimplemented function in the "use" statement it will fail at compile time.

       If your subsecond sleeping is implemented with nanosleep() instead of usleep(), you can mix subsecond
       sleeping with signals since nanosleep() does not use signals.  This, however, is not portable, and you
       should first check for the truth value of &amp;Time::HiRes::d_nanosleep to see whether you have nanosleep,
       and then carefully read your nanosleep() C API documentation for any peculiarities.

       If you are using "nanosleep" for something else than mixing sleeping with signals, give some thought to
       whether Perl is the tool you should be using for work requiring nanosecond accuracies.

       Remember that unless you are working on a <u>hard</u> <u>realtime</u> system, any clocks and timers will be imprecise,
       especially so if you are working in a pre-emptive multiuser system.  Understand the difference between
       <u>wallclock</u> <u>time</u> and process time (in UNIX-like systems the sum of <u>user</u> and <u>system</u> times).  Any attempt to
       sleep for X seconds will most probably end up sleeping <b>more</b> than that, but don't be surprised if you end
       up sleeping slightly <b>less</b>.

       The following functions can be imported from this module.  No functions are exported by default.

       gettimeofday ()
           In  array  context returns a two-element array with the seconds and microseconds since the epoch.  In
           scalar context returns floating seconds like Time::HiRes::time() (see below).

       usleep ( $useconds )
           Sleeps for the number of microseconds (millionths of a second)  specified.   Returns  the  number  of
           microseconds  actually  slept.   Can sleep for more than one second, unlike the "usleep" system call.
           Can  also  sleep  for  zero  seconds,  which  often  works   like   a   <u>thread</u>   <u>yield</u>.    See   also
           Time::HiRes::sleep(), and clock_nanosleep().

           Do not expect <b>usleep()</b> to be exact down to one microsecond.

       nanosleep ( $nanoseconds )
           Sleeps  for  the  number  of  nanoseconds  (1e9ths  of  a  second)  specified.  Returns the number of
           nanoseconds actually slept (accurate only to microseconds, the nearest thousand of them).  Can  sleep
           for  more  than  one second.  Can also sleep for zero seconds, which often works like a <u>thread</u> <u>yield</u>.
           See also Time::HiRes::sleep(), Time::HiRes::usleep(), and clock_nanosleep().

           Do not expect <b>nanosleep()</b> to be exact down to one nanosecond.  Getting even accuracy of one  thousand
           nanoseconds is good.

       ualarm ( $useconds [, $interval_useconds ] )
           Issues a "ualarm" call; the $interval_useconds is optional and will be zero if unspecified, resulting
           in "alarm"-like behaviour.

           Returns the remaining time in the alarm in microseconds, or "undef" if an error occurred.

           <b><a href="../man0/ualarm.0.html">ualarm</a></b>(0) will cancel an outstanding <b>ualarm()</b>.

           Note that the interaction between alarms and sleeps is unspecified.

       tv_interval
           tv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )

           Returns   the   floating  seconds  between  the  two  times,  which  should  have  been  returned  by
           gettimeofday(). If the second argument is omitted, then the current time is used.

       time ()
           Returns a floating seconds since the epoch. This function can be imported, resulting in a nice  drop-
           in replacement for the "time" provided with core Perl; see the "EXAMPLES" below.

           <b>NOTE</b>  <b>1</b>:  This  higher  resolution  timer can return values either less or more than the core time(),
           depending on whether your platform rounds the higher resolution timer values  up,  down,  or  to  the
           nearest  second to get the core time(), but naturally the difference should be never more than half a
           second.  See also "clock_getres", if available in your system.

           <b>NOTE</b> <b>2</b>: Since Sunday, September 9th, 2001 at 01:46:40 AM GMT, when the  time()  seconds  since  epoch
           rolled  over  to 1_000_000_000, the default floating point format of Perl and the seconds since epoch
           have conspired to produce an apparent bug: if you print the value of Time::HiRes::time() you seem  to
           be  getting  only  five decimals, not six as promised (microseconds).  Not to worry, the microseconds
           are there (assuming your platform supports such granularity in the first place).  What is going on is
           that the default floating point format of Perl only outputs 15 digits.  In this case that  means  ten
           digits  before  the  decimal  separator  and  five after.  To see the microseconds you can use either
           "printf"/"sprintf" with "%.6f", or the gettimeofday() function in list context, which will  give  you
           the seconds and microseconds as two separate values.

       sleep ( $floating_seconds )
           Sleeps for the specified amount of seconds.  Returns the number of seconds actually slept (a floating
           point value).  This function can be imported, resulting in a nice drop-in replacement for the "sleep"
           provided with perl, see the "EXAMPLES" below.

           Note that the interaction between alarms and sleeps is unspecified.

       alarm ( $floating_seconds [, $interval_floating_seconds ] )
           The "SIGALRM" signal is sent after the specified number of seconds.  Implemented using setitimer() if
           available,  ualarm() if not.  The $interval_floating_seconds argument is optional and will be zero if
           unspecified, resulting in alarm()-like behaviour.  This function can be imported, resulting in a nice
           drop-in replacement for the "alarm" provided with perl, see the "EXAMPLES" below.

           Returns the remaining time in the alarm in seconds, or "undef" if an error occurred.

           <b>NOTE</b> <b>1</b>: With some combinations of operating systems and Perl releases  "SIGALRM"  restarts  select(),
           instead  of interrupting it.  This means that an alarm() followed by a select() may together take the
           sum of the times specified for the alarm() and the select(), not just the time of the alarm().

           Note that the interaction between alarms and sleeps is unspecified.

       setitimer ( $which, $floating_seconds [, $interval_floating_seconds ] )
           Start up an interval timer: after a certain time, a signal ($which) arrives,  and  more  signals  may
           keep  arriving  at certain intervals.  To disable an "itimer", use $floating_seconds of zero.  If the
           $interval_floating_seconds is set to zero (or unspecified), the timer  is  disabled  <b>after</b>  the  next
           delivered signal.

           Use  of  interval  timers  may  interfere with alarm(), sleep(), and usleep().  In standard-speak the
           "interaction is unspecified", which means that <u>anything</u> may happen: it may work, it may not.

           In scalar context, the remaining time in the timer is returned.

           In list context, both the remaining time and the interval are returned.

           There are usually three or four interval timers (signals) available: the $which can be "ITIMER_REAL",
           "ITIMER_VIRTUAL", "ITIMER_PROF", or "ITIMER_REALPROF".  Note that which ones are  available  depends:
           true  UNIX  platforms  usually have the first three, but only Solaris seems to have "ITIMER_REALPROF"
           (which is used to profile multithreaded  programs).   Win32  unfortunately  does  not  have  interval
           timers.

           "ITIMER_REAL"  results  in  alarm()-like behaviour.  Time is counted in <u>real</u> <u>time</u>; that is, wallclock
           time.  "SIGALRM" is delivered when the timer expires.

           "ITIMER_VIRTUAL" counts time in (process) <u>virtual</u> <u>time</u>; that is, only when the  process  is  running.
           In  multiprocessor/user/CPU systems this may be more or less than real or wallclock time.  (This time
           is also known as the <u>user</u> <u>time</u>.)  "SIGVTALRM" is delivered when the timer expires.

           "ITIMER_PROF" counts time when either the process virtual  time  or  when  the  operating  system  is
           running  on behalf of the process (such as I/O).  (This time is also known as the <u>system</u> <u>time</u>.)  (The
           sum of user time and system time is known as the <u>CPU</u> <u>time</u>.)  "SIGPROF" is delivered  when  the  timer
           expires.  "SIGPROF" can interrupt system calls.

           The semantics of interval timers for multithreaded programs are system-specific, and some systems may
           support  additional  interval  timers.  For example, it is unspecified which thread gets the signals.
           See your <a href="../man2/setitimer.2.html">setitimer</a>(2) documentation.

       getitimer ( $which )
           Return the remaining time in the interval timer specified by $which.

           In scalar context, the remaining time is returned.

           In list context, both the remaining time and the interval are returned.  The interval is always  what
           you put in using setitimer().

       clock_gettime ( $which )
           Return  as  seconds  the  current  value of the POSIX high resolution timer specified by $which.  All
           implementations that support POSIX high resolution timers are supposed to support at least the $which
           value  of  "CLOCK_REALTIME",  which  is  supposed  to  return  results  close  to  the   results   of
           "gettimeofday", or the number of seconds since 00:00:00:00 January 1, 1970 Greenwich Mean Time (GMT).
           Do  not  assume that CLOCK_REALTIME is zero, it might be one, or something else.  Another potentially
           useful (but not available everywhere) value is "CLOCK_MONOTONIC", which  guarantees  a  monotonically
           increasing  time  value  (unlike  <b>time()</b>  or <b>gettimeofday()</b>, which can be adjusted).  See your system
           documentation for other possibly supported values.

       clock_getres ( $which )
           Return as seconds the resolution of the  POSIX  high  resolution  timer  specified  by  $which.   All
           implementations that support POSIX high resolution timers are supposed to support at least the $which
           value of "CLOCK_REALTIME", see "clock_gettime".

           <b>NOTE</b>:  the  resolution  returned  may  be highly optimistic.  Even if the resolution is high (a small
           number), all it means is that you'll  be  able  to  specify  the  arguments  to  <b>clock_gettime()</b>  and
           <b>clock_nanosleep()</b>  with  that resolution.  The system might not actually be able to measure events at
           that resolution, and the various overheads and the overall system load  are  certain  to  affect  any
           timings.

       clock_nanosleep ( $which, $nanoseconds, $flags = 0)
           Sleeps  for  the  number  of  nanoseconds  (1e9ths  of  a  second)  specified.  Returns the number of
           nanoseconds  actually  slept.   The  $which  is  the  "clock  id",  as   with   <b>clock_gettime()</b>   and
           <b>clock_getres()</b>.   The  flags  default  to  zero  but  "TIMER_ABSTIME" can specified (must be exported
           explicitly) which means that $nanoseconds is not a time interval (as is the default) but  instead  an
           absolute  time.   Can  sleep  for more than one second.  Can also sleep for zero seconds, which often
           works  like  a   <u>thread</u>   <u>yield</u>.    See   also   Time::HiRes::sleep(),   Time::HiRes::usleep(),   and
           Time::HiRes::nanosleep().

           Do  not  expect  <b>clock_nanosleep()</b>  to be exact down to one nanosecond.  Getting even accuracy of one
           thousand nanoseconds is good.

       <b>clock()</b>
           Return as seconds the <u>process</u> <u>time</u> (user + system time) spent by the process since the first call  to
           <b>clock()</b>  (the definition is <b>not</b> "since the start of the process", though if you are lucky these times
           may be quite close to each other, depending on the system).  What this means  is  that  you  probably
           need  to  store  the result of your first call to <b>clock()</b>, and subtract that value from the following
           results of <b>clock()</b>.

           The time returned also includes the process times of the terminated child processes for which  <b>wait()</b>
           has  been  executed.   This  value  is somewhat like the second value returned by the <b>times()</b> of core
           Perl, but not necessarily identical.   Note  that  due  to  backward  compatibility  limitations  the
           returned value may wrap around at about 2147 seconds or at about 36 minutes.

       stat
       stat FH
       stat EXPR
       lstat
       lstat FH
       lstat EXPR
           As  "stat"  in  perlfunc  or "lstat" in perlfunc but with the access/modify/change file timestamps in
           subsecond resolution, if the operating system and the filesystem both support  such  timestamps.   To
           override the standard <b>stat()</b>:

               use Time::HiRes qw(stat);

           Test  for  the  value of &amp;Time::HiRes::d_hires_stat to find out whether the operating system supports
           subsecond file timestamps: a value larger than zero means yes. There are unfortunately no  easy  ways
           to  find  out whether the filesystem supports such timestamps.  UNIX filesystems often do; NTFS does;
           FAT doesn't (FAT timestamp granularity is <b>two</b> seconds).

           A zero return value of &amp;Time::HiRes::d_hires_stat means that Time::HiRes::stat is a no-op passthrough
           for <b>CORE::stat()</b> (and likewise for lstat), and therefore the timestamps will stay integers.  The same
           thing  will  happen  if  the  filesystem  does   not   do   subsecond   timestamps,   even   if   the
           &amp;Time::HiRes::d_hires_stat is non-zero.

           In  any  case  do not expect nanosecond resolution, or even a microsecond resolution.  Also note that
           the  modify/access  timestamps  might  have  different  resolutions,  and  that  they  need  not   be
           synchronized, e.g.  if the operations are

               write
               stat # t1
               read
               stat # t2

           the access time stamp from t2 need not be greater-than the modify time stamp from t1: it may be equal
           or <u>less</u>.

       utime LIST
           As  "utime"  in  perlfunc  but with the ability to set the access/modify file timestamps in subsecond
           resolution, if the operating system and the filesystem, and the mount options of the filesystem,  all
           support such timestamps.

           To override the standard <b>utime()</b>:

               use Time::HiRes qw(utime);

           Test  for  the value of &amp;Time::HiRes::d_hires_utime to find out whether the operating system supports
           setting subsecond file timestamps.

           As with <b>CORE::utime()</b>, passing undef as both the atime and mtime will call the syscall  with  a  NULL
           argument.

           The actual achievable subsecond resolution depends on the combination of the operating system and the
           filesystem.

           Modifying  the  timestamps  may  not  be possible at all: for example, the "noatime" filesystem mount
           option may prohibit you from changing the access time timestamp.

           Returns the number of files successfully changed.

</pre><h4><b>EXAMPLES</b></h4><pre>
         use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);

         $microseconds = 750_000;
         usleep($microseconds);

         # signal alarm in 2.5s &amp; every .1s thereafter
         ualarm(2_500_000, 100_000);
         # cancel that ualarm
         <a href="../man0/ualarm.0.html">ualarm</a>(0);

         # get seconds and microseconds since the epoch
         ($s, $usec) = gettimeofday();

         # measure elapsed time
         # (could also do by subtracting 2 gettimeofday return values)
         $t0 = [gettimeofday];
         # do bunch of stuff here
         $t1 = [gettimeofday];
         # do more stuff here
         $t0_t1 = tv_interval $t0, $t1;

         $elapsed = tv_interval ($t0, [gettimeofday]);
         $elapsed = tv_interval ($t0); # equivalent code

         #
         # replacements for time, alarm and sleep that know about
         # floating seconds
         #
         use Time::HiRes;
         $now_fractions = Time::HiRes::time;
         Time::HiRes::sleep (2.5);
         Time::HiRes::alarm (10.6666666);

         use Time::HiRes qw ( time alarm sleep );
         $now_fractions = time;
         sleep (2.5);
         alarm (10.6666666);

         # Arm an interval timer to go off first at 10 seconds and
         # after that every 2.5 seconds, in process virtual time

         use Time::HiRes qw ( setitimer ITIMER_VIRTUAL time );

         $SIG{VTALRM} = sub { print time, "\n" };
         setitimer(ITIMER_VIRTUAL, 10, 2.5);

         use Time::HiRes qw( clock_gettime clock_getres CLOCK_REALTIME );
         # Read the POSIX high resolution timer.
         my $high = clock_gettime(CLOCK_REALTIME);
         # But how accurate we can be, really?
         my $reso = clock_getres(CLOCK_REALTIME);

         use Time::HiRes qw( clock_nanosleep TIMER_ABSTIME );
         clock_nanosleep(CLOCK_REALTIME, 1e6);
         clock_nanosleep(CLOCK_REALTIME, 2e9, TIMER_ABSTIME);

         use Time::HiRes qw( clock );
         my $clock0 = clock();
         ... # Do something.
         my $clock1 = clock();
         my $clockd = $clock1 - $clock0;

         use Time::HiRes qw( stat );
         my ($atime, $mtime, $ctime) = (stat("istics"))[8, 9, 10];

</pre><h4><b>C</b> <b>API</b></h4><pre>
       In addition to the perl API described above, a C API is available for extension writers.  The following C
       functions are available in the modglobal hash:

         name             C prototype
         ---------------  ----------------------
         Time::NVtime     NV (*)()
         Time::U2time     void (*)(pTHX_ UV ret[2])

       Both functions return equivalent information (like "gettimeofday") but  with  different  representations.
       The  names  "NVtime"  and  "U2time"  were  selected mainly because they are operating system independent.
       ("gettimeofday" is Unix-centric, though some platforms like Win32 and VMS have emulations for it.)

       Here is an example of using "NVtime" from C:

         NV (*myNVtime)(); /* Returns -1 on failure. */
         SV **svp = hv_fetchs(PL_modglobal, "Time::NVtime", 0);
         if (!svp)         croak("Time::HiRes is required");
         if (!SvIOK(*svp)) croak("Time::NVtime isn't a function pointer");
         myNVtime = INT2PTR(NV(*)(), SvIV(*svp));
         printf("The current time is: %" NVff "\n", (*myNVtime)());

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
   <b>useconds</b> <b>or</b> <b>interval</b> <b>more</b> <b>than</b> <b>...</b>
       In <b>ualarm()</b> you tried to use number  of  microseconds  or  interval  (also  in  microseconds)  more  than
       1_000_000 and <b>setitimer()</b> is not available in your system to emulate that case.

   <b>negative</b> <b>time</b> <b>not</b> <b>invented</b> <b>yet</b>
       You tried to use a negative time argument.

   <b>internal</b> <b>error:</b> <b>useconds</b> <b>&lt;</b> <b>0</b> <b>(unsigned</b> <b>...</b> <b>signed</b> <b>...)</b>
       Something  went  horribly  wrong--  the  number  of  microseconds that cannot become negative just became
       negative.  Maybe your compiler is broken?

   <b>useconds</b> <b>or</b> <b>uinterval</b> <b>equal</b> <b>to</b> <b>or</b> <b>more</b> <b>than</b> <b>1000000</b>
       In some platforms it is not possible to get an alarm with subsecond resolution and later than one second.

   <b>unimplemented</b> <b>in</b> <b>this</b> <b>platform</b>
       Some calls simply aren't available, real or emulated, on every platform.

</pre><h4><b>CAVEATS</b></h4><pre>
       Notice that the core time() maybe rounding rather than truncating.  What this  means  is  that  the  core
       time() may be reporting the time as one second later than gettimeofday() and Time::HiRes::time().

       Adjusting  the  system clock (either manually or by services like ntp) may cause problems, especially for
       long running programs that assume a monotonously increasing time (note that all platforms do  not  adjust
       time as gracefully as UNIX ntp does).  For example in Win32 (and derived platforms like Cygwin and MinGW)
       the  <b>Time::HiRes::time()</b> may temporarily drift off from the system clock (and the original <b>time()</b>)  by up
       to 0.5 seconds. Time::HiRes will notice this eventually and recalibrate.   Note  that  since  Time::HiRes
       1.77   the   clock_gettime(CLOCK_MONOTONIC)   might   help   in   this  (in  case  your  system  supports
       CLOCK_MONOTONIC).

       Some systems have APIs but not implementations: for example QNX and Haiku have the  interval  timer  APIs
       but not the functionality.

       In  pre-Sierra macOS (pre-10.12, OS X) <b>clock_getres()</b>, <b>clock_gettime()</b> and <b>clock_nanosleep()</b> are emulated
       using the Mach timers; as a side effect of being emulated the CLOCK_REALTIME and CLOCK_MONOTONIC are  the
       same timer.

       gnukfreebsd  seems to have non-functional <b>futimens()</b> and <b>utimensat()</b> (at least as of 10.1): therefore the
       hires <b>utime()</b> does not work.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Perl modules BSD::Resource, Time::TAI64.

       Your  system  documentation  for   <a href="../man3/clock.3.html">clock</a>(3),   <a href="../man2/clock_gettime.2.html">clock_gettime</a>(2),   <a href="../man3/clock_getres.3.html">clock_getres</a>(3),   <a href="../man3/clock_nanosleep.3.html">clock_nanosleep</a>(3),
       <a href="../man2/clock_settime.2.html">clock_settime</a>(2), <a href="../man2/getitimer.2.html">getitimer</a>(2), <a href="../man2/gettimeofday.2.html">gettimeofday</a>(2), <a href="../man2/setitimer.2.html">setitimer</a>(2), <a href="../man3/sleep.3.html">sleep</a>(3), <a href="../man2/stat.2.html">stat</a>(2), <a href="../man3/ualarm.3.html">ualarm</a>(3).

</pre><h4><b>AUTHORS</b></h4><pre>
       D.  Wegscheid  &lt;<a href="mailto:wegscd@whirlpool.com">wegscd@whirlpool.com</a>&gt; R. Schertler &lt;<a href="mailto:roderick@argon.org">roderick@argon.org</a>&gt; J. Hietaniemi &lt;<a href="mailto:jhi@iki.fi">jhi@iki.fi</a>&gt; G. Aas
       &lt;<a href="mailto:gisle@aas.no">gisle@aas.no</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 1996-2002 Douglas E. Wegscheid.  All rights reserved.

       Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Jarkko Hietaniemi.  All rights reserved.

       Copyright (C) 2011, 2012, 2013 Andrew Main (Zefram) &lt;<a href="mailto:zefram@fysh.org">zefram@fysh.org</a>&gt;

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.40.1                                       2025-07-03                                 <u>Time::<a href="../man3perl/HiRes.3perl.html">HiRes</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>