<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gedmd - DMD driver, Dynamic Mode Decomposition</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gedmd - DMD driver, Dynamic Mode Decomposition

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>cgedmd</b> (jobs, jobz, jobr, jobf, whtsvd, m, n, x, ldx, y, ldy, nrnk, tol, k, eigs, z, ldz, res,
           b, ldb, w, ldw, s, lds, zwork, lzwork, rwork, lrwork, iwork, liwork, info)
           <b>CGEDMD</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.
       subroutine <b>cgedmdq</b> (jobs, jobz, jobr, jobq, jobt, jobf, whtsvd, m, n, f, ldf, x, ldx, y, ldy, nrnk, tol,
           k, eigs, z, ldz, res, b, ldb, v, ldv, s, lds, zwork, lzwork, work, lwork, iwork, liwork, info)
           <b>CGEDMDQ</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.
       subroutine <b>dgedmd</b> (jobs, jobz, jobr, jobf, whtsvd, m, n, x, ldx, y, ldy, nrnk, tol, k, reig, imeig, z,
           ldz, res, b, ldb, w, ldw, s, lds, work, lwork, iwork, liwork, info)
           <b>DGEDMD</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.
       subroutine <b>dgedmdq</b> (jobs, jobz, jobr, jobq, jobt, jobf, whtsvd, m, n, f, ldf, x, ldx, y, ldy, nrnk, tol,
           k, reig, imeig, z, ldz, res, b, ldb, v, ldv, s, lds, work, lwork, iwork, liwork, info)
           <b>DGEDMDQ</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.
       subroutine <b>sgedmd</b> (jobs, jobz, jobr, jobf, whtsvd, m, n, x, ldx, y, ldy, nrnk, tol, k, reig, imeig, z,
           ldz, res, b, ldb, w, ldw, s, lds, work, lwork, iwork, liwork, info)
           <b>SGEDMD</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.
       subroutine <b>sgedmdq</b> (jobs, jobz, jobr, jobq, jobt, jobf, whtsvd, m, n, f, ldf, x, ldx, y, ldy, nrnk, tol,
           k, reig, imeig, z, ldz, res, b, ldb, v, ldv, s, lds, work, lwork, iwork, liwork, info)
           <b>SGEDMDQ</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.
       subroutine <b>zgedmd</b> (jobs, jobz, jobr, jobf, whtsvd, m, n, x, ldx, y, ldy, nrnk, tol, k, eigs, z, ldz, res,
           b, ldb, w, ldw, s, lds, zwork, lzwork, rwork, lrwork, iwork, liwork, info)
           <b>ZGEDMD</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.
       subroutine <b>zgedmdq</b> (jobs, jobz, jobr, jobq, jobt, jobf, whtsvd, m, n, f, ldf, x, ldx, y, ldy, nrnk, tol,
           k, eigs, z, ldz, res, b, ldb, v, ldv, s, lds, zwork, lzwork, work, lwork, iwork, liwork, info)
           <b>ZGEDMDQ</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>cgedmd</b> <b>(character,</b> <b>intent(in)</b> <b>jobs,</b> <b>character,</b> <b>intent(in)</b> <b>jobz,</b> <b>character,</b> <b>intent(in)</b> <b>jobr,</b>
       <b>character,</b> <b>intent(in)</b> <b>jobf,</b> <b>integer,</b> <b>intent(in)</b> <b>whtsvd,</b> <b>integer,</b> <b>intent(in)</b> <b>m,</b> <b>integer,</b> <b>intent(in)</b> <b>n,</b>
       <b>complex(kind=wp),</b> <b>dimension(ldx,*),</b> <b>intent(inout)</b> <b>x,</b> <b>integer,</b> <b>intent(in)</b> <b>ldx,</b> <b>complex(kind=wp),</b>
       <b>dimension(ldy,*),</b> <b>intent(inout)</b> <b>y,</b> <b>integer,</b> <b>intent(in)</b> <b>ldy,</b> <b>integer,</b> <b>intent(in)</b> <b>nrnk,</b> <b>real(kind=wp),</b>
       <b>intent(in)</b> <b>tol,</b> <b>integer,</b> <b>intent(out)</b> <b>k,</b> <b>complex(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>eigs,</b>
       <b>complex(kind=wp),</b> <b>dimension(ldz,*),</b> <b>intent(out)</b> <b>z,</b> <b>integer,</b> <b>intent(in)</b> <b>ldz,</b> <b>real(kind=wp),</b> <b>dimension(*),</b>
       <b>intent(out)</b> <b>res,</b> <b>complex(kind=wp),</b> <b>dimension(ldb,*),</b> <b>intent(out)</b> <b>b,</b> <b>integer,</b> <b>intent(in)</b> <b>ldb,</b>
       <b>complex(kind=wp),</b> <b>dimension(ldw,*),</b> <b>intent(out)</b> <b>w,</b> <b>integer,</b> <b>intent(in)</b> <b>ldw,</b> <b>complex(kind=wp),</b>
       <b>dimension(lds,*),</b> <b>intent(out)</b> <b>s,</b> <b>integer,</b> <b>intent(in)</b> <b>lds,</b> <b>complex(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b>
       <b>zwork,</b> <b>integer,</b> <b>intent(in)</b> <b>lzwork,</b> <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>rwork,</b> <b>integer,</b> <b>intent(in)</b>
       <b>lrwork,</b> <b>integer,</b> <b>dimension(*),</b> <b>intent(out)</b> <b>iwork,</b> <b>integer,</b> <b>intent(in)</b> <b>liwork,</b> <b>integer,</b> <b>intent(out)</b> <b>info)</b>
       <b>CGEDMD</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.

       <b>Purpose:</b>

               CGEDMD computes the Dynamic Mode Decomposition (DMD) for
               a pair of data snapshot matrices. For the input matrices
               X and Y such that Y = A*X with an unaccessible matrix
               A, CGEDMD computes a certain number of Ritz pairs of A using
               the standard Rayleigh-Ritz extraction from a subspace of
               range(X) that is determined using the leading left singular
               vectors of X. Optionally, CGEDMD returns the residuals
               of the computed Ritz pairs, the information needed for
               a refinement of the Ritz vectors, or the eigenvectors of
               the Exact DMD.
               For further details see the references listed
               below. For more details of the implementation see [3].

       <b>References:</b>

               [1] P. Schmid: Dynamic mode decomposition of numerical
                   and experimental data,
                   Journal of Fluid Mechanics 656, 5-28, 2010.
               [2] Z. Drmac, I. Mezic, R. Mohr: Data driven modal
                   decompositions: analysis and enhancements,
                   SIAM J. on Sci. Comp. 40 (4), A2253-A2285, 2018.
               [3] Z. Drmac: A LAPACK implementation of the Dynamic
                   Mode Decomposition I. Technical report. AIMDyn Inc.
                   and LAPACK Working Note 298.
               [4] J. Tu, C. W. Rowley, D. M. Luchtenburg, S. L.
                   Brunton, N. Kutz: On Dynamic Mode Decomposition:
                   Theory and Applications, Journal of Computational
                   Dynamics <a href="../man2/1.2.html">1</a>(2), 391 -421, 2014.

       <b>Developed</b> <b>and</b> <b>supported</b> <b>by:</b>

               Developed and coded by Zlatko Drmac, Faculty of Science,
               University of Zagreb;  <a href="mailto:drmac@math.hr">drmac@math.hr</a>
               In cooperation with
               AIMdyn Inc., Santa Barbara, CA.
               and supported by
               - DARPA SBIR project 'Koopman Operator-Based Forecasting
               for Nonstationary Processes from Near-Term, Limited
               Observational Data' Contract No: W31P4Q-21-C-0007
               - DARPA PAI project 'Physics-Informed Machine Learning
               Methodologies' Contract No: HR0011-18-9-0033
               - DARPA MoDyL project 'A Data-Driven, Operator-Theoretic
               Framework for Space-Time Analysis of Process Dynamics'
               Contract No: HR0011-16-C-0116
               Any opinions, findings and conclusions or recommendations
               expressed in this material are those of the author and
               do not necessarily reflect the views of the DARPA SBIR
               Program Office

       <b>Distribution</b> <b>Statement</b> <b>A:</b>

               Approved for Public Release, Distribution Unlimited.
               Cleared by DARPA on September 29, 2022

       <b>Parameters</b>
           <u>JOBS</u>

               JOBS (input) CHARACTER*1
               Determines whether the initial data snapshots are scaled
               by a diagonal matrix.
               'S' :: The data snapshots matrices X and Y are multiplied
                      with a diagonal matrix D so that X*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'C' :: The snapshots are scaled as with the 'S' option.
                      If it is found that an i-th column of X is zero
                      vector and the corresponding i-th column of Y is
                      non-zero, then the i-th column of Y is set to
                      zero and a warning flag is raised.
               'Y' :: The data snapshots matrices X and Y are multiplied
                      by a diagonal matrix D so that Y*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'N' :: No data scaling.

           <u>JOBZ</u>

               JOBZ (input) CHARACTER*1
               Determines whether the eigenvectors (Koopman modes) will
               be computed.
               'V' :: The eigenvectors (Koopman modes) will be computed
                      and returned in the matrix Z.
                      See the description of Z.
               'F' :: The eigenvectors (Koopman modes) will be returned
                      in factored form as the product X(:,1:K)*W, where X
                      contains a POD basis (leading left singular vectors
                      of the data matrix X) and W contains the eigenvectors
                      of the corresponding Rayleigh quotient.
                      See the descriptions of K, X, W, Z.
               'N' :: The eigenvectors are not computed.

           <u>JOBR</u>

               JOBR (input) CHARACTER*1
               Determines whether to compute the residuals.
               'R' :: The residuals for the computed eigenpairs will be
                      computed and stored in the array RES.
                      See the description of RES.
                      For this option to be legal, JOBZ must be 'V'.
               'N' :: The residuals are not computed.

           <u>JOBF</u>

               JOBF (input) CHARACTER*1
               Specifies whether to store information needed for post-
               processing (e.g. computing refined Ritz vectors)
               'R' :: The matrix needed for the refinement of the Ritz
                      vectors is computed and stored in the array B.
                      See the description of B.
               'E' :: The unscaled eigenvectors of the Exact DMD are
                      computed and returned in the array B. See the
                      description of B.
               'N' :: No eigenvector refinement data is computed.

           <u>WHTSVD</u>

               WHTSVD (input) INTEGER, WHSTVD in { 1, 2, 3, 4 }
               Allows for a selection of the SVD algorithm from the
               LAPACK library.
               1 :: CGESVD (the QR SVD algorithm)
               2 :: CGESDD (the Divide and Conquer algorithm; if enough
                    workspace available, this is the fastest option)
               3 :: CGESVDQ (the preconditioned QR SVD  ; this and 4
                    are the most accurate options)
               4 :: CGEJSV (the preconditioned Jacobi SVD; this and 3
                    are the most accurate options)
               For the four methods above, a significant difference in
               the accuracy of small singular values is possible if
               the snapshots vary in norm so that X is severely
               ill-conditioned. If small (smaller than EPS*||X||)
               singular values are of interest and JOBS=='N',  then
               the options (3, 4) give the most accurate results, where
               the option 4 is slightly better and with stronger
               theoretical background.
               If JOBS=='S', i.e. the columns of X will be normalized,
               then all methods give nearly equally accurate results.

           <u>M</u>

               M (input) INTEGER, M&gt;= 0
               The state space dimension (the row dimension of X, Y).

           <u>N</u>

               N (input) INTEGER, 0 &lt;= N &lt;= M
               The number of data snapshot pairs
               (the number of columns of X and Y).

           <u>X</u>

               X (input/output) COMPLEX(KIND=WP) M-by-N array
               &gt; On entry, X contains the data snapshot matrix X. It is
               assumed that the column norms of X are in the range of
               the normalized floating point numbers.
               &lt; On exit, the leading K columns of X contain a POD basis,
               i.e. the leading K left singular vectors of the input
               data matrix X, U(:,1:K). All N columns of X contain all
               left singular vectors of the input matrix X.
               See the descriptions of K, Z and W.

           <u>LDX</u>

               LDX (input) INTEGER, LDX &gt;= M
               The leading dimension of the array X.

           <u>Y</u>

               Y (input/workspace/output) COMPLEX(KIND=WP) M-by-N array
               &gt; On entry, Y contains the data snapshot matrix Y
               &lt; On exit,
               If JOBR == 'R', the leading K columns of Y  contain
               the residual vectors for the computed Ritz pairs.
               See the description of RES.
               If JOBR == 'N', Y contains the original input data,
                               scaled according to the value of JOBS.

           <u>LDY</u>

               LDY (input) INTEGER , LDY &gt;= M
               The leading dimension of the array Y.

           <u>NRNK</u>

               NRNK (input) INTEGER
               Determines the mode how to compute the numerical rank,
               i.e. how to truncate small singular values of the input
               matrix X. On input, if
               NRNK = -1 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*<a href="../man1/sigma.1.html">sigma</a>(1)
                            This option is recommended.
               NRNK = -2 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*sigma(i-1)
                            This option is included for R&amp;D purposes.
                            It requires highly accurate SVD, which
                            may not be feasible.
               The numerical rank can be enforced by using positive
               value of NRNK as follows:
               0 &lt; NRNK &lt;= N :: at most NRNK largest singular values
               will be used. If the number of the computed nonzero
               singular values is less than NRNK, then only those
               nonzero values will be used and the actually used
               dimension is less than NRNK. The actual number of
               the nonzero singular values is returned in the variable
               K. See the descriptions of TOL and  K.

           <u>TOL</u>

               TOL (input) REAL(KIND=WP), 0 &lt;= TOL &lt; 1
               The tolerance for truncating small singular values.
               See the description of NRNK.

           <u>K</u>

               K (output) INTEGER,  0 &lt;= K &lt;= N
               The dimension of the POD basis for the data snapshot
               matrix X and the number of the computed Ritz pairs.
               The value of K is determined according to the rule set
               by the parameters NRNK and TOL.
               See the descriptions of NRNK and TOL.

           <u>EIGS</u>

               EIGS (output) COMPLEX(KIND=WP) N-by-1 array
               The leading K (K&lt;=N) entries of EIGS contain
               the computed eigenvalues (Ritz values).
               See the descriptions of K, and Z.

           <u>Z</u>

               Z (workspace/output) COMPLEX(KIND=WP)  M-by-N array
               If JOBZ =='V' then Z contains the  Ritz vectors.  Z(:,i)
               is an eigenvector of the i-th Ritz value; ||Z(:,i)||_2=1.
               If JOBZ == 'F', then the Z(:,i)'s are given implicitly as
               the columns of X(:,1:K)*W(1:K,1:K), i.e. X(:,1:K)*W(:,i)
               is an eigenvector corresponding to EIGS(i). The columns
               of W(1:k,1:K) are the computed eigenvectors of the
               K-by-K Rayleigh quotient.
               See the descriptions of EIGS, X and W.

           <u>LDZ</u>

               LDZ (input) INTEGER , LDZ &gt;= M
               The leading dimension of the array Z.

           <u>RES</u>

               RES (output) REAL(KIND=WP) N-by-1 array
               RES(1:K) contains the residuals for the K computed
               Ritz pairs,
               RES(i) = || A * Z(:,i) - EIGS(i)*Z(:,i))||_2.
               See the description of EIGS and Z.

           <u>B</u>

               B (output) COMPLEX(KIND=WP)  M-by-N array.
               IF JOBF =='R', B(1:M,1:K) contains A*U(:,1:K), and can
               be used for computing the refined vectors; see further
               details in the provided references.
               If JOBF == 'E', B(1:M,1:K) contains
               A*U(:,1:K)*W(1:K,1:K), which are the vectors from the
               Exact DMD, up to scaling by the inverse eigenvalues.
               If JOBF =='N', then B is not referenced.
               See the descriptions of X, W, K.

           <u>LDB</u>

               LDB (input) INTEGER, LDB &gt;= M
               The leading dimension of the array B.

           <u>W</u>

               W (workspace/output) COMPLEX(KIND=WP) N-by-N array
               On exit, W(1:K,1:K) contains the K computed
               eigenvectors of the matrix Rayleigh quotient.
               The Ritz vectors (returned in Z) are the
               product of X (containing a POD basis for the input
               matrix X) and W. See the descriptions of K, S, X and Z.
               W is also used as a workspace to temporarily store the
               right singular vectors of X.

           <u>LDW</u>

               LDW (input) INTEGER, LDW &gt;= N
               The leading dimension of the array W.

           <u>S</u>

               S (workspace/output) COMPLEX(KIND=WP) N-by-N array
               The array S(1:K,1:K) is used for the matrix Rayleigh
               quotient. This content is overwritten during
               the eigenvalue decomposition by CGEEV.
               See the description of K.

           <u>LDS</u>

               LDS (input) INTEGER, LDS &gt;= N
               The leading dimension of the array S.

           <u>ZWORK</u>

               ZWORK (workspace/output) COMPLEX(KIND=WP) LZWORK-by-1 array
               ZWORK is used as complex workspace in the complex SVD, as
               specified by WHTSVD (1,2, 3 or 4) and for CGEEV for computing
               the eigenvalues of a Rayleigh quotient.
               If the call to CGEDMD is only workspace query, then
               <a href="../man1/ZWORK.1.html">ZWORK</a>(1) contains the minimal complex workspace length and
               <a href="../man2/ZWORK.2.html">ZWORK</a>(2) is the optimal complex workspace length.
               Hence, the length of work is at least 2.
               See the description of LZWORK.

           <u>LZWORK</u>

               LZWORK (input) INTEGER
               The minimal length of the workspace vector ZWORK.
               LZWORK is calculated as MAX(LZWORK_SVD, LZWORK_CGEEV),
               where LZWORK_CGEEV = MAX( 1, 2*N )  and the minimal
               LZWORK_SVD is calculated as follows
               If WHTSVD == 1 :: CGESVD ::
                  LZWORK_SVD = MAX(1,2*MIN(M,N)+MAX(M,N))
               If WHTSVD == 2 :: CGESDD ::
                  LZWORK_SVD = 2*MIN(M,N)*MIN(M,N)+2*MIN(M,N)+MAX(M,N)
               If WHTSVD == 3 :: CGESVDQ ::
                  LZWORK_SVD = obtainable by a query
               If WHTSVD == 4 :: CGEJSV ::
                  LZWORK_SVD = obtainable by a query
               If on entry LZWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths and returns them in
               <a href="../man1/LZWORK.1.html">LZWORK</a>(1) and <a href="../man2/LZWORK.2.html">LZWORK</a>(2), respectively.

           <u>RWORK</u>

               RWORK (workspace/output) REAL(KIND=WP) LRWORK-by-1 array
               On exit, RWORK(1:N) contains the singular values of
               X (for JOBS=='N') or column scaled X (JOBS=='S', 'C').
               If WHTSVD==4, then RWORK(N+1) and RWORK(N+2) contain
               scaling factor RWORK(N+2)/RWORK(N+1) used to scale X
               and Y to avoid overflow in the SVD of X.
               This may be of interest if the scaling option is off
               and as many as possible smallest eigenvalues are
               desired to the highest feasible accuracy.
               If the call to CGEDMD is only workspace query, then
               <a href="../man1/RWORK.1.html">RWORK</a>(1) contains the minimal workspace length.
               See the description of LRWORK.

           <u>LRWORK</u>

               LRWORK (input) INTEGER
               The minimal length of the workspace vector RWORK.
               LRWORK is calculated as follows:
               LRWORK = MAX(1, N+LRWORK_SVD,N+LRWORK_CGEEV), where
               LRWORK_CGEEV = MAX(1,2*N) and RWORK_SVD is the real workspace
               for the SVD subroutine determined by the input parameter
               WHTSVD.
               If WHTSVD == 1 :: CGESVD ::
                  LRWORK_SVD = 5*MIN(M,N)
               If WHTSVD == 2 :: CGESDD ::
                  LRWORK_SVD =  MAX(5*MIN(M,N)*MIN(M,N)+7*MIN(M,N),
                  2*MAX(M,N)*MIN(M,N)+2*MIN(M,N)*MIN(M,N)+MIN(M,N) ) )
               If WHTSVD == 3 :: CGESVDQ ::
                  LRWORK_SVD = obtainable by a query
               If WHTSVD == 4 :: CGEJSV ::
                  LRWORK_SVD = obtainable by a query
               If on entry LRWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               real workspace length and returns it in <a href="../man1/RWORK.1.html">RWORK</a>(1).

           <u>IWORK</u>

               IWORK (workspace/output) INTEGER LIWORK-by-1 array
               Workspace that is required only if WHTSVD equals
               2 , 3 or 4. (See the description of WHTSVD).
               If on entry LWORK =-1 or LIWORK=-1, then the
               minimal length of IWORK is computed and returned in
               <a href="../man1/IWORK.1.html">IWORK</a>(1). See the description of LIWORK.

           <u>LIWORK</u>

               LIWORK (input) INTEGER
               The minimal length of the workspace vector IWORK.
               If WHTSVD == 1, then only <a href="../man1/IWORK.1.html">IWORK</a>(1) is used; LIWORK &gt;=1
               If WHTSVD == 2, then LIWORK &gt;= MAX(1,8*MIN(M,N))
               If WHTSVD == 3, then LIWORK &gt;= MAX(1,M+N-1)
               If WHTSVD == 4, then LIWORK &gt;= MAX(3,M+3*N)
               If on entry LIWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths for  ZWORK, RWORK and
               IWORK. See the descriptions of ZWORK, RWORK and IWORK.

           <u>INFO</u>

               INFO (output) INTEGER
               -i &lt; 0 :: On entry, the i-th argument had an
                         illegal value
                  = 0 :: Successful return.
                  = 1 :: Void input. Quick exit (M=0 or N=0).
                  = 2 :: The SVD computation of X did not converge.
                         Suggestion: Check the input data and/or
                         repeat with different WHTSVD.
                  = 3 :: The computation of the eigenvalues did not
                         converge.
                  = 4 :: If data scaling was requested on input and
                         the procedure found inconsistency in the data
                         such that for some column index i,
                         X(:,i) = 0 but Y(:,i) /= 0, then Y(:,i) is set
                         to zero if JOBS=='C'. The computation proceeds
                         with original or modified data and warning
                         flag is set with INFO=4.

       <b>Author</b>
           Zlatko Drmac

   <b>subroutine</b> <b>cgedmdq</b> <b>(character,</b> <b>intent(in)</b> <b>jobs,</b> <b>character,</b> <b>intent(in)</b> <b>jobz,</b> <b>character,</b> <b>intent(in)</b> <b>jobr,</b>
       <b>character,</b> <b>intent(in)</b> <b>jobq,</b> <b>character,</b> <b>intent(in)</b> <b>jobt,</b> <b>character,</b> <b>intent(in)</b> <b>jobf,</b> <b>integer,</b> <b>intent(in)</b>
       <b>whtsvd,</b> <b>integer,</b> <b>intent(in)</b> <b>m,</b> <b>integer,</b> <b>intent(in)</b> <b>n,</b> <b>complex(kind=wp),</b> <b>dimension(ldf,*),</b> <b>intent(inout)</b>
       <b>f,</b> <b>integer,</b> <b>intent(in)</b> <b>ldf,</b> <b>complex(kind=wp),</b> <b>dimension(ldx,*),</b> <b>intent(out)</b> <b>x,</b> <b>integer,</b> <b>intent(in)</b> <b>ldx,</b>
       <b>complex(kind=wp),</b> <b>dimension(ldy,*),</b> <b>intent(out)</b> <b>y,</b> <b>integer,</b> <b>intent(in)</b> <b>ldy,</b> <b>integer,</b> <b>intent(in)</b> <b>nrnk,</b>
       <b>real(kind=wp),</b> <b>intent(in)</b> <b>tol,</b> <b>integer,</b> <b>intent(out)</b> <b>k,</b> <b>complex(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>eigs,</b>
       <b>complex(kind=wp),</b> <b>dimension(ldz,*),</b> <b>intent(out)</b> <b>z,</b> <b>integer,</b> <b>intent(in)</b> <b>ldz,</b> <b>real(kind=wp),</b> <b>dimension(*),</b>
       <b>intent(out)</b> <b>res,</b> <b>complex(kind=wp),</b> <b>dimension(ldb,*),</b> <b>intent(out)</b> <b>b,</b> <b>integer,</b> <b>intent(in)</b> <b>ldb,</b>
       <b>complex(kind=wp),</b> <b>dimension(ldv,*),</b> <b>intent(out)</b> <b>v,</b> <b>integer,</b> <b>intent(in)</b> <b>ldv,</b> <b>complex(kind=wp),</b>
       <b>dimension(lds,*),</b> <b>intent(out)</b> <b>s,</b> <b>integer,</b> <b>intent(in)</b> <b>lds,</b> <b>complex(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b>
       <b>zwork,</b> <b>integer,</b> <b>intent(in)</b> <b>lzwork,</b> <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>work,</b> <b>integer,</b> <b>intent(in)</b>
       <b>lwork,</b> <b>integer,</b> <b>dimension(*),</b> <b>intent(out)</b> <b>iwork,</b> <b>integer,</b> <b>intent(in)</b> <b>liwork,</b> <b>integer,</b> <b>intent(out)</b> <b>info)</b>
       <b>CGEDMDQ</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.

       <b>Purpose:</b>

               CGEDMDQ computes the Dynamic Mode Decomposition (DMD) for
               a pair of data snapshot matrices, using a QR factorization
               based compression of the data. For the input matrices
               X and Y such that Y = A*X with an unaccessible matrix
               A, CGEDMDQ computes a certain number of Ritz pairs of A using
               the standard Rayleigh-Ritz extraction from a subspace of
               range(X) that is determined using the leading left singular
               vectors of X. Optionally, CGEDMDQ returns the residuals
               of the computed Ritz pairs, the information needed for
               a refinement of the Ritz vectors, or the eigenvectors of
               the Exact DMD.
               For further details see the references listed
               below. For more details of the implementation see [3].

       <b>References:</b>

               [1] P. Schmid: Dynamic mode decomposition of numerical
                   and experimental data,
                   Journal of Fluid Mechanics 656, 5-28, 2010.
               [2] Z. Drmac, I. Mezic, R. Mohr: Data driven modal
                   decompositions: analysis and enhancements,
                   SIAM J. on Sci. Comp. 40 (4), A2253-A2285, 2018.
               [3] Z. Drmac: A LAPACK implementation of the Dynamic
                   Mode Decomposition I. Technical report. AIMDyn Inc.
                   and LAPACK Working Note 298.
               [4] J. Tu, C. W. Rowley, D. M. Luchtenburg, S. L.
                   Brunton, N. Kutz: On Dynamic Mode Decomposition:
                   Theory and Applications, Journal of Computational
                   Dynamics <a href="../man2/1.2.html">1</a>(2), 391 -421, 2014.

       <b>Developed</b> <b>and</b> <b>supported</b> <b>by:</b>

               Developed and coded by Zlatko Drmac, Faculty of Science,
               University of Zagreb;  <a href="mailto:drmac@math.hr">drmac@math.hr</a>
               In cooperation with
               AIMdyn Inc., Santa Barbara, CA.
               and supported by
               - DARPA SBIR project 'Koopman Operator-Based Forecasting
               for Nonstationary Processes from Near-Term, Limited
               Observational Data' Contract No: W31P4Q-21-C-0007
               - DARPA PAI project 'Physics-Informed Machine Learning
               Methodologies' Contract No: HR0011-18-9-0033
               - DARPA MoDyL project 'A Data-Driven, Operator-Theoretic
               Framework for Space-Time Analysis of Process Dynamics'
               Contract No: HR0011-16-C-0116
               Any opinions, findings and conclusions or recommendations
               expressed in this material are those of the author and
               do not necessarily reflect the views of the DARPA SBIR
               Program Office.

       <b>Developed</b> <b>and</b> <b>supported</b> <b>by:</b>

               Approved for Public Release, Distribution Unlimited.
               Cleared by DARPA on September 29, 2022

       <b>Parameters</b>
           <u>JOBS</u>

               JOBS (input) CHARACTER*1
               Determines whether the initial data snapshots are scaled
               by a diagonal matrix. The data snapshots are the columns
               of F. The leading N-1 columns of F are denoted X and the
               trailing N-1 columns are denoted Y.
               'S' :: The data snapshots matrices X and Y are multiplied
                      with a diagonal matrix D so that X*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'C' :: The snapshots are scaled as with the 'S' option.
                      If it is found that an i-th column of X is zero
                      vector and the corresponding i-th column of Y is
                      non-zero, then the i-th column of Y is set to
                      zero and a warning flag is raised.
               'Y' :: The data snapshots matrices X and Y are multiplied
                      by a diagonal matrix D so that Y*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'N' :: No data scaling.

           <u>JOBZ</u>

               JOBZ (input) CHARACTER*1
               Determines whether the eigenvectors (Koopman modes) will
               be computed.
               'V' :: The eigenvectors (Koopman modes) will be computed
                      and returned in the matrix Z.
                      See the description of Z.
               'F' :: The eigenvectors (Koopman modes) will be returned
                      in factored form as the product Z*V, where Z
                      is orthonormal and V contains the eigenvectors
                      of the corresponding Rayleigh quotient.
                      See the descriptions of F, V, Z.
               'Q' :: The eigenvectors (Koopman modes) will be returned
                      in factored form as the product Q*Z, where Z
                      contains the eigenvectors of the compression of the
                      underlying discretised operator onto the span of
                      the data snapshots. See the descriptions of F, V, Z.
                      Q is from the inital QR facorization.
               'N' :: The eigenvectors are not computed.

           <u>JOBR</u>

               JOBR (input) CHARACTER*1
               Determines whether to compute the residuals.
               'R' :: The residuals for the computed eigenpairs will
                      be computed and stored in the array RES.
                      See the description of RES.
                      For this option to be legal, JOBZ must be 'V'.
               'N' :: The residuals are not computed.

           <u>JOBQ</u>

               JOBQ (input) CHARACTER*1
               Specifies whether to explicitly compute and return the
               unitary matrix from the QR factorization.
               'Q' :: The matrix Q of the QR factorization of the data
                      snapshot matrix is computed and stored in the
                      array F. See the description of F.
               'N' :: The matrix Q is not explicitly computed.

           <u>JOBT</u>

               JOBT (input) CHARACTER*1
               Specifies whether to return the upper triangular factor
               from the QR factorization.
               'R' :: The matrix R of the QR factorization of the data
                      snapshot matrix F is returned in the array Y.
                      See the description of Y and Further details.
               'N' :: The matrix R is not returned.

           <u>JOBF</u>

               JOBF (input) CHARACTER*1
               Specifies whether to store information needed for post-
               processing (e.g. computing refined Ritz vectors)
               'R' :: The matrix needed for the refinement of the Ritz
                      vectors is computed and stored in the array B.
                      See the description of B.
               'E' :: The unscaled eigenvectors of the Exact DMD are
                      computed and returned in the array B. See the
                      description of B.
               'N' :: No eigenvector refinement data is computed.
               To be useful on exit, this option needs JOBQ='Q'.

           <u>WHTSVD</u>

               WHTSVD (input) INTEGER, WHSTVD in { 1, 2, 3, 4 }
               Allows for a selection of the SVD algorithm from the
               LAPACK library.
               1 :: CGESVD (the QR SVD algorithm)
               2 :: CGESDD (the Divide and Conquer algorithm; if enough
                    workspace available, this is the fastest option)
               3 :: CGESVDQ (the preconditioned QR SVD  ; this and 4
                    are the most accurate options)
               4 :: CGEJSV (the preconditioned Jacobi SVD; this and 3
                    are the most accurate options)
               For the four methods above, a significant difference in
               the accuracy of small singular values is possible if
               the snapshots vary in norm so that X is severely
               ill-conditioned. If small (smaller than EPS*||X||)
               singular values are of interest and JOBS=='N',  then
               the options (3, 4) give the most accurate results, where
               the option 4 is slightly better and with stronger
               theoretical background.
               If JOBS=='S', i.e. the columns of X will be normalized,
               then all methods give nearly equally accurate results.

           <u>M</u>

               M (input) INTEGER, M &gt;= 0
               The state space dimension (the number of rows of F).

           <u>N</u>

               N (input) INTEGER, 0 &lt;= N &lt;= M
               The number of data snapshots from a single trajectory,
               taken at equidistant discrete times. This is the
               number of columns of F.

           <u>F</u>

               F (input/output) COMPLEX(KIND=WP) M-by-N array
               &gt; On entry,
               the columns of F are the sequence of data snapshots
               from a single trajectory, taken at equidistant discrete
               times. It is assumed that the column norms of F are
               in the range of the normalized floating point numbers.
               &lt; On exit,
               If JOBQ == 'Q', the array F contains the orthogonal
               matrix/factor of the QR factorization of the initial
               data snapshots matrix F. See the description of JOBQ.
               If JOBQ == 'N', the entries in F strictly below the main
               diagonal contain, column-wise, the information on the
               Householder vectors, as returned by CGEQRF. The
               remaining information to restore the orthogonal matrix
               of the initial QR factorization is stored in ZWORK(1:MIN(M,N)).
               See the description of ZWORK.

           <u>LDF</u>

               LDF (input) INTEGER, LDF &gt;= M
               The leading dimension of the array F.

           <u>X</u>

               X (workspace/output) COMPLEX(KIND=WP) MIN(M,N)-by-(N-1) array
               X is used as workspace to hold representations of the
               leading N-1 snapshots in the orthonormal basis computed
               in the QR factorization of F.
               On exit, the leading K columns of X contain the leading
               K left singular vectors of the above described content
               of X. To lift them to the space of the left singular
               vectors U(:,1:K) of the input data, pre-multiply with the
               Q factor from the initial QR factorization.
               See the descriptions of F, K, V  and Z.

           <u>LDX</u>

               LDX (input) INTEGER, LDX &gt;= N
               The leading dimension of the array X.

           <u>Y</u>

               Y (workspace/output) COMPLEX(KIND=WP) MIN(M,N)-by-(N) array
               Y is used as workspace to hold representations of the
               trailing N-1 snapshots in the orthonormal basis computed
               in the QR factorization of F.
               On exit,
               If JOBT == 'R', Y contains the MIN(M,N)-by-N upper
               triangular factor from the QR factorization of the data
               snapshot matrix F.

           <u>LDY</u>

               LDY (input) INTEGER , LDY &gt;= N
               The leading dimension of the array Y.

           <u>NRNK</u>

               NRNK (input) INTEGER
               Determines the mode how to compute the numerical rank,
               i.e. how to truncate small singular values of the input
               matrix X. On input, if
               NRNK = -1 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*<a href="../man1/sigma.1.html">sigma</a>(1)
                            This option is recommended.
               NRNK = -2 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*sigma(i-1)
                            This option is included for R&amp;D purposes.
                            It requires highly accurate SVD, which
                            may not be feasible.
               The numerical rank can be enforced by using positive
               value of NRNK as follows:
               0 &lt; NRNK &lt;= N-1 :: at most NRNK largest singular values
               will be used. If the number of the computed nonzero
               singular values is less than NRNK, then only those
               nonzero values will be used and the actually used
               dimension is less than NRNK. The actual number of
               the nonzero singular values is returned in the variable
               K. See the description of K.

           <u>TOL</u>

               TOL (input) REAL(KIND=WP), 0 &lt;= TOL &lt; 1
               The tolerance for truncating small singular values.
               See the description of NRNK.

           <u>K</u>

               K (output) INTEGER,  0 &lt;= K &lt;= N
               The dimension of the SVD/POD basis for the leading N-1
               data snapshots (columns of F) and the number of the
               computed Ritz pairs. The value of K is determined
               according to the rule set by the parameters NRNK and
               TOL. See the descriptions of NRNK and TOL.

           <u>EIGS</u>

               EIGS (output) COMPLEX(KIND=WP) (N-1)-by-1 array
               The leading K (K&lt;=N-1) entries of EIGS contain
               the computed eigenvalues (Ritz values).
               See the descriptions of K, and Z.

           <u>Z</u>

               Z (workspace/output) COMPLEX(KIND=WP)  M-by-(N-1) array
               If JOBZ =='V' then Z contains the Ritz vectors. Z(:,i)
               is an eigenvector of the i-th Ritz value; ||Z(:,i)||_2=1.
               If JOBZ == 'F', then the Z(:,i)'s are given implicitly as
               Z*V, where Z contains orthonormal matrix (the product of
               Q from the initial QR factorization and the SVD/POD_basis
               returned by CGEDMD in X) and the second factor (the
               eigenvectors of the Rayleigh quotient) is in the array V,
               as returned by CGEDMD. That is,  X(:,1:K)*V(:,i)
               is an eigenvector corresponding to EIGS(i). The columns
               of V(1:K,1:K) are the computed eigenvectors of the
               K-by-K Rayleigh quotient.
               See the descriptions of EIGS, X and V.

           <u>LDZ</u>

               LDZ (input) INTEGER , LDZ &gt;= M
               The leading dimension of the array Z.

           <u>RES</u>

               RES (output) REAL(KIND=WP) (N-1)-by-1 array
               RES(1:K) contains the residuals for the K computed
               Ritz pairs,
               RES(i) = || A * Z(:,i) - EIGS(i)*Z(:,i))||_2.
               See the description of EIGS and Z.

           <u>B</u>

               B (output) COMPLEX(KIND=WP)  MIN(M,N)-by-(N-1) array.
               IF JOBF =='R', B(1:N,1:K) contains A*U(:,1:K), and can
               be used for computing the refined vectors; see further
               details in the provided references.
               If JOBF == 'E', B(1:N,1;K) contains
               A*U(:,1:K)*W(1:K,1:K), which are the vectors from the
               Exact DMD, up to scaling by the inverse eigenvalues.
               In both cases, the content of B can be lifted to the
               original dimension of the input data by pre-multiplying
               with the Q factor from the initial QR factorization.
               Here A denotes a compression of the underlying operator.
               See the descriptions of F and X.
               If JOBF =='N', then B is not referenced.

           <u>LDB</u>

               LDB (input) INTEGER, LDB &gt;= MIN(M,N)
               The leading dimension of the array B.

           <u>V</u>

               V (workspace/output) COMPLEX(KIND=WP) (N-1)-by-(N-1) array
               On exit, V(1:K,1:K) V contains the K eigenvectors of
               the Rayleigh quotient. The Ritz vectors
               (returned in Z) are the product of Q from the initial QR
               factorization (see the description of F) X (see the
               description of X) and V.

           <u>LDV</u>

               LDV (input) INTEGER, LDV &gt;= N-1
               The leading dimension of the array V.

           <u>S</u>

               S (output) COMPLEX(KIND=WP) (N-1)-by-(N-1) array
               The array S(1:K,1:K) is used for the matrix Rayleigh
               quotient. This content is overwritten during
               the eigenvalue decomposition by CGEEV.
               See the description of K.

           <u>LDS</u>

               LDS (input) INTEGER, LDS &gt;= N-1
               The leading dimension of the array S.

           <u>ZWORK</u>

               ZWORK (workspace/output) COMPLEX(KIND=WP) LWORK-by-1 array
               On exit,
               ZWORK(1:MIN(M,N)) contains the scalar factors of the
               elementary reflectors as returned by CGEQRF of the
               M-by-N input matrix F.
               If the call to CGEDMDQ is only workspace query, then
               <a href="../man1/ZWORK.1.html">ZWORK</a>(1) contains the minimal complex workspace length and
               <a href="../man2/ZWORK.2.html">ZWORK</a>(2) is the optimal complex workspace length.
               Hence, the length of work is at least 2.
               See the description of LZWORK.

           <u>LZWORK</u>

               LZWORK (input) INTEGER
               The minimal length of the  workspace vector ZWORK.
               LZWORK is calculated as follows:
               Let MLWQR  = N (minimal workspace for CGEQRF[M,N])
                   MLWDMD = minimal workspace for CGEDMD (see the
                            description of LWORK in CGEDMD)
                   MLWMQR = N (minimal workspace for
                              ZUNMQR['L','N',M,N,N])
                   MLWGQR = N (minimal workspace for ZUNGQR[M,N,N])
                   MINMN  = MIN(M,N)
               Then
               LZWORK = MAX(2, MIN(M,N)+MLWQR, MINMN+MLWDMD)
               is further updated as follows:
                  if   JOBZ == 'V' or JOBZ == 'F' THEN
                       LZWORK = MAX( LZWORK, MINMN+MLWMQR )
                  if   JOBQ == 'Q' THEN
                       LZWORK = MAX( ZLWORK, MINMN+MLWGQR)

           <u>WORK</u>

               WORK (workspace/output) REAL(KIND=WP) LWORK-by-1 array
               On exit,
               WORK(1:N-1) contains the singular values of
               the input submatrix F(1:M,1:N-1).
               If the call to CGEDMDQ is only workspace query, then
               <a href="../man1/WORK.1.html">WORK</a>(1) contains the minimal workspace length and
               <a href="../man2/WORK.2.html">WORK</a>(2) is the optimal workspace length. hence, the
               length of work is at least 2.
               See the description of LWORK.

           <u>LWORK</u>

               LWORK (input) INTEGER
               The minimal length of the  workspace vector WORK.
               LWORK is the same as in CGEDMD, because in CGEDMDQ
               only CGEDMD requires real workspace for snapshots
               of dimensions MIN(M,N)-by-(N-1).
               If on entry LWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths for both WORK and
               IWORK. See the descriptions of WORK and IWORK.

           <u>IWORK</u>

               IWORK (workspace/output) INTEGER LIWORK-by-1 array
               Workspace that is required only if WHTSVD equals
               2 , 3 or 4. (See the description of WHTSVD).
               If on entry LWORK =-1 or LIWORK=-1, then the
               minimal length of IWORK is computed and returned in
               <a href="../man1/IWORK.1.html">IWORK</a>(1). See the description of LIWORK.

           <u>LIWORK</u>

               LIWORK (input) INTEGER
               The minimal length of the workspace vector IWORK.
               If WHTSVD == 1, then only <a href="../man1/IWORK.1.html">IWORK</a>(1) is used; LIWORK &gt;=1
               Let M1=MIN(M,N), N1=N-1. Then
               If WHTSVD == 2, then LIWORK &gt;= MAX(1,8*MIN(M,N))
               If WHTSVD == 3, then LIWORK &gt;= MAX(1,M+N-1)
               If WHTSVD == 4, then LIWORK &gt;= MAX(3,M+3*N)
               If on entry LIWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths for both WORK and
               IWORK. See the descriptions of WORK and IWORK.

           <u>INFO</u>

               INFO (output) INTEGER
               -i &lt; 0 :: On entry, the i-th argument had an
                         illegal value
                  = 0 :: Successful return.
                  = 1 :: Void input. Quick exit (M=0 or N=0).
                  = 2 :: The SVD computation of X did not converge.
                         Suggestion: Check the input data and/or
                         repeat with different WHTSVD.
                  = 3 :: The computation of the eigenvalues did not
                         converge.
                  = 4 :: If data scaling was requested on input and
                         the procedure found inconsistency in the data
                         such that for some column index i,
                         X(:,i) = 0 but Y(:,i) /= 0, then Y(:,i) is set
                         to zero if JOBS=='C'. The computation proceeds
                         with original or modified data and warning
                         flag is set with INFO=4.

       <b>Author</b>
           Zlatko Drmac

   <b>subroutine</b> <b>dgedmd</b> <b>(character,</b> <b>intent(in)</b> <b>jobs,</b> <b>character,</b> <b>intent(in)</b> <b>jobz,</b> <b>character,</b> <b>intent(in)</b> <b>jobr,</b>
       <b>character,</b> <b>intent(in)</b> <b>jobf,</b> <b>integer,</b> <b>intent(in)</b> <b>whtsvd,</b> <b>integer,</b> <b>intent(in)</b> <b>m,</b> <b>integer,</b> <b>intent(in)</b> <b>n,</b>
       <b>real(kind=wp),</b> <b>dimension(ldx,*),</b> <b>intent(inout)</b> <b>x,</b> <b>integer,</b> <b>intent(in)</b> <b>ldx,</b> <b>real(kind=wp),</b>
       <b>dimension(ldy,*),</b> <b>intent(inout)</b> <b>y,</b> <b>integer,</b> <b>intent(in)</b> <b>ldy,</b> <b>integer,</b> <b>intent(in)</b> <b>nrnk,</b> <b>real(kind=wp),</b>
       <b>intent(in)</b> <b>tol,</b> <b>integer,</b> <b>intent(out)</b> <b>k,</b> <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>reig,</b> <b>real(kind=wp),</b>
       <b>dimension(*),</b> <b>intent(out)</b> <b>imeig,</b> <b>real(kind=wp),</b> <b>dimension(ldz,*),</b> <b>intent(out)</b> <b>z,</b> <b>integer,</b> <b>intent(in)</b> <b>ldz,</b>
       <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>res,</b> <b>real(kind=wp),</b> <b>dimension(ldb,*),</b> <b>intent(out)</b> <b>b,</b> <b>integer,</b>
       <b>intent(in)</b> <b>ldb,</b> <b>real(kind=wp),</b> <b>dimension(ldw,*),</b> <b>intent(out)</b> <b>w,</b> <b>integer,</b> <b>intent(in)</b> <b>ldw,</b> <b>real(kind=wp),</b>
       <b>dimension(lds,*),</b> <b>intent(out)</b> <b>s,</b> <b>integer,</b> <b>intent(in)</b> <b>lds,</b> <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>work,</b>
       <b>integer,</b> <b>intent(in)</b> <b>lwork,</b> <b>integer,</b> <b>dimension(*),</b> <b>intent(out)</b> <b>iwork,</b> <b>integer,</b> <b>intent(in)</b> <b>liwork,</b> <b>integer,</b>
       <b>intent(out)</b> <b>info)</b>
       <b>DGEDMD</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.

       <b>Purpose:</b>

               DGEDMD computes the Dynamic Mode Decomposition (DMD) for
               a pair of data snapshot matrices. For the input matrices
               X and Y such that Y = A*X with an unaccessible matrix
               A, DGEDMD computes a certain number of Ritz pairs of A using
               the standard Rayleigh-Ritz extraction from a subspace of
               range(X) that is determined using the leading left singular
               vectors of X. Optionally, DGEDMD returns the residuals
               of the computed Ritz pairs, the information needed for
               a refinement of the Ritz vectors, or the eigenvectors of
               the Exact DMD.
               For further details see the references listed
               below. For more details of the implementation see [3].

       <b>References:</b>

               [1] P. Schmid: Dynamic mode decomposition of numerical
                   and experimental data,
                   Journal of Fluid Mechanics 656, 5-28, 2010.
               [2] Z. Drmac, I. Mezic, R. Mohr: Data driven modal
                   decompositions: analysis and enhancements,
                   SIAM J. on Sci. Comp. 40 (4), A2253-A2285, 2018.
               [3] Z. Drmac: A LAPACK implementation of the Dynamic
                   Mode Decomposition I. Technical report. AIMDyn Inc.
                   and LAPACK Working Note 298.
               [4] J. Tu, C. W. Rowley, D. M. Luchtenburg, S. L.
                   Brunton, N. Kutz: On Dynamic Mode Decomposition:
                   Theory and Applications, Journal of Computational
                   Dynamics <a href="../man2/1.2.html">1</a>(2), 391 -421, 2014.

       <b>Developed</b> <b>and</b> <b>supported</b> <b>by:</b>

               Developed and coded by Zlatko Drmac, Faculty of Science,
               University of Zagreb;  <a href="mailto:drmac@math.hr">drmac@math.hr</a>
               In cooperation with
               AIMdyn Inc., Santa Barbara, CA.
               and supported by
               - DARPA SBIR project 'Koopman Operator-Based Forecasting
               for Nonstationary Processes from Near-Term, Limited
               Observational Data' Contract No: W31P4Q-21-C-0007
               - DARPA PAI project 'Physics-Informed Machine Learning
               Methodologies' Contract No: HR0011-18-9-0033
               - DARPA MoDyL project 'A Data-Driven, Operator-Theoretic
               Framework for Space-Time Analysis of Process Dynamics'
               Contract No: HR0011-16-C-0116
               Any opinions, findings and conclusions or recommendations
               expressed in this material are those of the author and
               do not necessarily reflect the views of the DARPA SBIR
               Program Office

       <b>Distribution</b> <b>Statement</b> <b>A:</b>

               Approved for Public Release, Distribution Unlimited.
               Cleared by DARPA on September 29, 2022

       <b>Parameters</b>
           <u>JOBS</u>

               JOBS (input) is CHARACTER*1
               Determines whether the initial data snapshots are scaled
               by a diagonal matrix.
               'S' :: The data snapshots matrices X and Y are multiplied
                      with a diagonal matrix D so that X*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'C' :: The snapshots are scaled as with the 'S' option.
                      If it is found that an i-th column of X is zero
                      vector and the corresponding i-th column of Y is
                      non-zero, then the i-th column of Y is set to
                      zero and a warning flag is raised.
               'Y' :: The data snapshots matrices X and Y are multiplied
                      by a diagonal matrix D so that Y*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'N' :: No data scaling.

           <u>JOBZ</u>

               JOBZ (input) CHARACTER*1
               Determines whether the eigenvectors (Koopman modes) will
               be computed.
               'V' :: The eigenvectors (Koopman modes) will be computed
                      and returned in the matrix Z.
                      See the description of Z.
               'F' :: The eigenvectors (Koopman modes) will be returned
                      in factored form as the product X(:,1:K)*W, where X
                      contains a POD basis (leading left singular vectors
                      of the data matrix X) and W contains the eigenvectors
                      of the corresponding Rayleigh quotient.
                      See the descriptions of K, X, W, Z.
               'N' :: The eigenvectors are not computed.

           <u>JOBR</u>

               JOBR (input) CHARACTER*1
               Determines whether to compute the residuals.
               'R' :: The residuals for the computed eigenpairs will be
                      computed and stored in the array RES.
                      See the description of RES.
                      For this option to be legal, JOBZ must be 'V'.
               'N' :: The residuals are not computed.

           <u>JOBF</u>

               JOBF (input) CHARACTER*1
               Specifies whether to store information needed for post-
               processing (e.g. computing refined Ritz vectors)
               'R' :: The matrix needed for the refinement of the Ritz
                      vectors is computed and stored in the array B.
                      See the description of B.
               'E' :: The unscaled eigenvectors of the Exact DMD are
                      computed and returned in the array B. See the
                      description of B.
               'N' :: No eigenvector refinement data is computed.

           <u>WHTSVD</u>

               WHTSVD (input) INTEGER, WHSTVD in { 1, 2, 3, 4 }
               Allows for a selection of the SVD algorithm from the
               LAPACK library.
               1 :: DGESVD (the QR SVD algorithm)
               2 :: DGESDD (the Divide and Conquer algorithm; if enough
                    workspace available, this is the fastest option)
               3 :: DGESVDQ (the preconditioned QR SVD  ; this and 4
                    are the most accurate options)
               4 :: DGEJSV (the preconditioned Jacobi SVD; this and 3
                    are the most accurate options)
               For the four methods above, a significant difference in
               the accuracy of small singular values is possible if
               the snapshots vary in norm so that X is severely
               ill-conditioned. If small (smaller than EPS*||X||)
               singular values are of interest and JOBS=='N',  then
               the options (3, 4) give the most accurate results, where
               the option 4 is slightly better and with stronger
               theoretical background.
               If JOBS=='S', i.e. the columns of X will be normalized,
               then all methods give nearly equally accurate results.

           <u>M</u>

               M (input) INTEGER, M&gt;= 0
               The state space dimension (the row dimension of X, Y).

           <u>N</u>

               N (input) INTEGER, 0 &lt;= N &lt;= M
               The number of data snapshot pairs
               (the number of columns of X and Y).

           <u>X</u>

               X (input/output) REAL(KIND=WP) M-by-N array
               &gt; On entry, X contains the data snapshot matrix X. It is
               assumed that the column norms of X are in the range of
               the normalized floating point numbers.
               &lt; On exit, the leading K columns of X contain a POD basis,
               i.e. the leading K left singular vectors of the input
               data matrix X, U(:,1:K). All N columns of X contain all
               left singular vectors of the input matrix X.
               See the descriptions of K, Z and W.

           <u>LDX</u>

               LDX (input) INTEGER, LDX &gt;= M
               The leading dimension of the array X.

           <u>Y</u>

               Y (input/workspace/output) REAL(KIND=WP) M-by-N array
               &gt; On entry, Y contains the data snapshot matrix Y
               &lt; On exit,
               If JOBR == 'R', the leading K columns of Y  contain
               the residual vectors for the computed Ritz pairs.
               See the description of RES.
               If JOBR == 'N', Y contains the original input data,
                               scaled according to the value of JOBS.

           <u>LDY</u>

               LDY (input) INTEGER , LDY &gt;= M
               The leading dimension of the array Y.

           <u>NRNK</u>

               NRNK (input) INTEGER
               Determines the mode how to compute the numerical rank,
               i.e. how to truncate small singular values of the input
               matrix X. On input, if
               NRNK = -1 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*<a href="../man1/sigma.1.html">sigma</a>(1).
                            This option is recommended.
               NRNK = -2 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*sigma(i-1)
                            This option is included for R&amp;D purposes.
                            It requires highly accurate SVD, which
                            may not be feasible.

               The numerical rank can be enforced by using positive
               value of NRNK as follows:
               0 &lt; NRNK &lt;= N :: at most NRNK largest singular values
               will be used. If the number of the computed nonzero
               singular values is less than NRNK, then only those
               nonzero values will be used and the actually used
               dimension is less than NRNK. The actual number of
               the nonzero singular values is returned in the variable
               K. See the descriptions of TOL and  K.

           <u>TOL</u>

               TOL (input) REAL(KIND=WP), 0 &lt;= TOL &lt; 1
               The tolerance for truncating small singular values.
               See the description of NRNK.

           <u>K</u>

               K (output) INTEGER,  0 &lt;= K &lt;= N
               The dimension of the POD basis for the data snapshot
               matrix X and the number of the computed Ritz pairs.
               The value of K is determined according to the rule set
               by the parameters NRNK and TOL.
               See the descriptions of NRNK and TOL.

           <u>REIG</u>

               REIG (output) REAL(KIND=WP) N-by-1 array
               The leading K (K&lt;=N) entries of REIG contain
               the real parts of the computed eigenvalues
               REIG(1:K) + sqrt(-1)*IMEIG(1:K).
               See the descriptions of K, IMEIG, and Z.

           <u>IMEIG</u>

               IMEIG (output) REAL(KIND=WP) N-by-1 array
               The leading K (K&lt;=N) entries of IMEIG contain
               the imaginary parts of the computed eigenvalues
               REIG(1:K) + sqrt(-1)*IMEIG(1:K).
               The eigenvalues are determined as follows:
               If IMEIG(i) == 0, then the corresponding eigenvalue is
               real, LAMBDA(i) = REIG(i).
               If IMEIG(i)&gt;0, then the corresponding complex
               conjugate pair of eigenvalues reads
               LAMBDA(i)   = REIG(i) + sqrt(-1)*IMAG(i)
               LAMBDA(i+1) = REIG(i) - sqrt(-1)*IMAG(i)
               That is, complex conjugate pairs have consecutive
               indices (i,i+1), with the positive imaginary part
               listed first.
               See the descriptions of K, REIG, and Z.

           <u>Z</u>

               Z (workspace/output) REAL(KIND=WP)  M-by-N array
               If JOBZ =='V' then
                  Z contains real Ritz vectors as follows:
                  If IMEIG(i)=0, then Z(:,i) is an eigenvector of
                  the i-th Ritz value; ||Z(:,i)||_2=1.
                  If IMEIG(i) &gt; 0 (and IMEIG(i+1) &lt; 0) then
                  [Z(:,i) Z(:,i+1)] span an invariant subspace and
                  the Ritz values extracted from this subspace are
                  REIG(i) + sqrt(-1)*IMEIG(i) and
                  REIG(i) - sqrt(-1)*IMEIG(i).
                  The corresponding eigenvectors are
                  Z(:,i) + sqrt(-1)*Z(:,i+1) and
                  Z(:,i) - sqrt(-1)*Z(:,i+1), respectively.
                  || Z(:,i:i+1)||_F = 1.
               If JOBZ == 'F', then the above descriptions hold for
               the columns of X(:,1:K)*W(1:K,1:K), where the columns
               of W(1:k,1:K) are the computed eigenvectors of the
               K-by-K Rayleigh quotient. The columns of W(1:K,1:K)
               are similarly structured: If IMEIG(i) == 0 then
               X(:,1:K)*W(:,i) is an eigenvector, and if IMEIG(i)&gt;0
               then X(:,1:K)*W(:,i)+sqrt(-1)*X(:,1:K)*W(:,i+1) and
                    X(:,1:K)*W(:,i)-sqrt(-1)*X(:,1:K)*W(:,i+1)
               are the eigenvectors of LAMBDA(i), LAMBDA(i+1).
               See the descriptions of REIG, IMEIG, X and W.

           <u>LDZ</u>

               LDZ (input) INTEGER , LDZ &gt;= M
               The leading dimension of the array Z.

           <u>RES</u>

               RES (output) REAL(KIND=WP) N-by-1 array
               RES(1:K) contains the residuals for the K computed
               Ritz pairs.
               If LAMBDA(i) is real, then
                  RES(i) = || A * Z(:,i) - LAMBDA(i)*Z(:,i))||_2.
               If [LAMBDA(i), LAMBDA(i+1)] is a complex conjugate pair
               then
               RES(i)=RES(i+1) = || A * Z(:,i:i+1) - Z(:,i:i+1) *B||_F
               where B = [ real(LAMBDA(i)) imag(LAMBDA(i)) ]
                         [-imag(LAMBDA(i)) real(LAMBDA(i)) ].
               It holds that
               RES(i)   = || A*ZC(:,i)   - LAMBDA(i)  *ZC(:,i)   ||_2
               RES(i+1) = || A*ZC(:,i+1) - LAMBDA(i+1)*ZC(:,i+1) ||_2
               where ZC(:,i)   =  Z(:,i) + sqrt(-1)*Z(:,i+1)
                     ZC(:,i+1) =  Z(:,i) - sqrt(-1)*Z(:,i+1)
               See the description of REIG, IMEIG and Z.

           <u>B</u>

               B (output) REAL(KIND=WP)  M-by-N array.
               IF JOBF =='R', B(1:M,1:K) contains A*U(:,1:K), and can
               be used for computing the refined vectors; see further
               details in the provided references.
               If JOBF == 'E', B(1:M,1;K) contains
               A*U(:,1:K)*W(1:K,1:K), which are the vectors from the
               Exact DMD, up to scaling by the inverse eigenvalues.
               If JOBF =='N', then B is not referenced.
               See the descriptions of X, W, K.

           <u>LDB</u>

               LDB (input) INTEGER, LDB &gt;= M
               The leading dimension of the array B.

           <u>W</u>

               W (workspace/output) REAL(KIND=WP) N-by-N array
               On exit, W(1:K,1:K) contains the K computed
               eigenvectors of the matrix Rayleigh quotient (real and
               imaginary parts for each complex conjugate pair of the
               eigenvalues). The Ritz vectors (returned in Z) are the
               product of X (containing a POD basis for the input
               matrix X) and W. See the descriptions of K, S, X and Z.
               W is also used as a workspace to temporarily store the
               right singular vectors of X.

           <u>LDW</u>

               LDW (input) INTEGER, LDW &gt;= N
               The leading dimension of the array W.

           <u>S</u>

               S (workspace/output) REAL(KIND=WP) N-by-N array
               The array S(1:K,1:K) is used for the matrix Rayleigh
               quotient. This content is overwritten during
               the eigenvalue decomposition by DGEEV.
               See the description of K.

           <u>LDS</u>

               LDS (input) INTEGER, LDS &gt;= N
               The leading dimension of the array S.

           <u>WORK</u>

               WORK (workspace/output) REAL(KIND=WP) LWORK-by-1 array
               On exit, WORK(1:N) contains the singular values of
               X (for JOBS=='N') or column scaled X (JOBS=='S', 'C').
               If WHTSVD==4, then WORK(N+1) and WORK(N+2) contain
               scaling factor WORK(N+2)/WORK(N+1) used to scale X
               and Y to avoid overflow in the SVD of X.
               This may be of interest if the scaling option is off
               and as many as possible smallest eigenvalues are
               desired to the highest feasible accuracy.
               If the call to DGEDMD is only workspace query, then
               <a href="../man1/WORK.1.html">WORK</a>(1) contains the minimal workspace length and
               <a href="../man2/WORK.2.html">WORK</a>(2) is the optimal workspace length. Hence, the
               leng of work is at least 2.
               See the description of LWORK.

           <u>LWORK</u>

               LWORK (input) INTEGER
               The minimal length of the workspace vector WORK.
               LWORK is calculated as follows:
               If WHTSVD == 1 ::
                  If JOBZ == 'V', then
                  LWORK &gt;= MAX(2, N + LWORK_SVD, N+MAX(1,4*N)).
                  If JOBZ == 'N'  then
                  LWORK &gt;= MAX(2, N + LWORK_SVD, N+MAX(1,3*N)).
                  Here LWORK_SVD = MAX(1,3*N+M,5*N) is the minimal
                  workspace length of DGESVD.
               If WHTSVD == 2 ::
                  If JOBZ == 'V', then
                  LWORK &gt;= MAX(2, N + LWORK_SVD, N+MAX(1,4*N))
                  If JOBZ == 'N', then
                  LWORK &gt;= MAX(2, N + LWORK_SVD, N+MAX(1,3*N))
                  Here LWORK_SVD = MAX(M, 5*N*N+4*N)+3*N*N is the
                  minimal workspace length of DGESDD.
               If WHTSVD == 3 ::
                  If JOBZ == 'V', then
                  LWORK &gt;= MAX(2, N+LWORK_SVD,N+MAX(1,4*N))
                  If JOBZ == 'N', then
                  LWORK &gt;= MAX(2, N+LWORK_SVD,N+MAX(1,3*N))
                  Here LWORK_SVD = N+M+MAX(3*N+1,
                                  MAX(1,3*N+M,5*N),MAX(1,N))
                  is the minimal workspace length of DGESVDQ.
               If WHTSVD == 4 ::
                  If JOBZ == 'V', then
                  LWORK &gt;= MAX(2, N+LWORK_SVD,N+MAX(1,4*N))
                  If JOBZ == 'N', then
                  LWORK &gt;= MAX(2, N+LWORK_SVD,N+MAX(1,3*N))
                  Here LWORK_SVD = MAX(7,2*M+N,6*N+2*N*N) is the
                  minimal workspace length of DGEJSV.
               The above expressions are not simplified in order to
               make the usage of WORK more transparent, and for
               easier checking. In any case, LWORK &gt;= 2.
               If on entry LWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths for both WORK and
               IWORK. See the descriptions of WORK and IWORK.

           <u>IWORK</u>

               IWORK (workspace/output) INTEGER LIWORK-by-1 array
               Workspace that is required only if WHTSVD equals
               2 , 3 or 4. (See the description of WHTSVD).
               If on entry LWORK =-1 or LIWORK=-1, then the
               minimal length of IWORK is computed and returned in
               <a href="../man1/IWORK.1.html">IWORK</a>(1). See the description of LIWORK.

           <u>LIWORK</u>

               LIWORK (input) INTEGER
               The minimal length of the workspace vector IWORK.
               If WHTSVD == 1, then only <a href="../man1/IWORK.1.html">IWORK</a>(1) is used; LIWORK &gt;=1
               If WHTSVD == 2, then LIWORK &gt;= MAX(1,8*MIN(M,N))
               If WHTSVD == 3, then LIWORK &gt;= MAX(1,M+N-1)
               If WHTSVD == 4, then LIWORK &gt;= MAX(3,M+3*N)
               If on entry LIWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths for both WORK and
               IWORK. See the descriptions of WORK and IWORK.

           <u>INFO</u>

               INFO (output) INTEGER
               -i &lt; 0 :: On entry, the i-th argument had an
                         illegal value
                  = 0 :: Successful return.
                  = 1 :: Void input. Quick exit (M=0 or N=0).
                  = 2 :: The SVD computation of X did not converge.
                         Suggestion: Check the input data and/or
                         repeat with different WHTSVD.
                  = 3 :: The computation of the eigenvalues did not
                         converge.
                  = 4 :: If data scaling was requested on input and
                         the procedure found inconsistency in the data
                         such that for some column index i,
                         X(:,i) = 0 but Y(:,i) /= 0, then Y(:,i) is set
                         to zero if JOBS=='C'. The computation proceeds
                         with original or modified data and warning
                         flag is set with INFO=4.

       <b>Author</b>
           Zlatko Drmac

   <b>subroutine</b> <b>dgedmdq</b> <b>(character,</b> <b>intent(in)</b> <b>jobs,</b> <b>character,</b> <b>intent(in)</b> <b>jobz,</b> <b>character,</b> <b>intent(in)</b> <b>jobr,</b>
       <b>character,</b> <b>intent(in)</b> <b>jobq,</b> <b>character,</b> <b>intent(in)</b> <b>jobt,</b> <b>character,</b> <b>intent(in)</b> <b>jobf,</b> <b>integer,</b> <b>intent(in)</b>
       <b>whtsvd,</b> <b>integer,</b> <b>intent(in)</b> <b>m,</b> <b>integer,</b> <b>intent(in)</b> <b>n,</b> <b>real(kind=wp),</b> <b>dimension(ldf,*),</b> <b>intent(inout)</b> <b>f,</b>
       <b>integer,</b> <b>intent(in)</b> <b>ldf,</b> <b>real(kind=wp),</b> <b>dimension(ldx,*),</b> <b>intent(out)</b> <b>x,</b> <b>integer,</b> <b>intent(in)</b> <b>ldx,</b>
       <b>real(kind=wp),</b> <b>dimension(ldy,*),</b> <b>intent(out)</b> <b>y,</b> <b>integer,</b> <b>intent(in)</b> <b>ldy,</b> <b>integer,</b> <b>intent(in)</b> <b>nrnk,</b>
       <b>real(kind=wp),</b> <b>intent(in)</b> <b>tol,</b> <b>integer,</b> <b>intent(out)</b> <b>k,</b> <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>reig,</b>
       <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>imeig,</b> <b>real(kind=wp),</b> <b>dimension(ldz,*),</b> <b>intent(out)</b> <b>z,</b> <b>integer,</b>
       <b>intent(in)</b> <b>ldz,</b> <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>res,</b> <b>real(kind=wp),</b> <b>dimension(ldb,*),</b>
       <b>intent(out)</b> <b>b,</b> <b>integer,</b> <b>intent(in)</b> <b>ldb,</b> <b>real(kind=wp),</b> <b>dimension(ldv,*),</b> <b>intent(out)</b> <b>v,</b> <b>integer,</b>
       <b>intent(in)</b> <b>ldv,</b> <b>real(kind=wp),</b> <b>dimension(lds,*),</b> <b>intent(out)</b> <b>s,</b> <b>integer,</b> <b>intent(in)</b> <b>lds,</b> <b>real(kind=wp),</b>
       <b>dimension(*),</b> <b>intent(out)</b> <b>work,</b> <b>integer,</b> <b>intent(in)</b> <b>lwork,</b> <b>integer,</b> <b>dimension(*),</b> <b>intent(out)</b> <b>iwork,</b>
       <b>integer,</b> <b>intent(in)</b> <b>liwork,</b> <b>integer,</b> <b>intent(out)</b> <b>info)</b>
       <b>DGEDMDQ</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.

       <b>Purpose:</b>

                DGEDMDQ computes the Dynamic Mode Decomposition (DMD) for
                a pair of data snapshot matrices, using a QR factorization
                based compression of the data. For the input matrices
                X and Y such that Y = A*X with an unaccessible matrix
                A, DGEDMDQ computes a certain number of Ritz pairs of A using
                the standard Rayleigh-Ritz extraction from a subspace of
                range(X) that is determined using the leading left singular
                vectors of X. Optionally, DGEDMDQ returns the residuals
                of the computed Ritz pairs, the information needed for
                a refinement of the Ritz vectors, or the eigenvectors of
                the Exact DMD.
                For further details see the references listed
                below. For more details of the implementation see [3].

       <b>References:</b>

               [1] P. Schmid: Dynamic mode decomposition of numerical
                   and experimental data,
                   Journal of Fluid Mechanics 656, 5-28, 2010.
               [2] Z. Drmac, I. Mezic, R. Mohr: Data driven modal
                   decompositions: analysis and enhancements,
                   SIAM J. on Sci. Comp. 40 (4), A2253-A2285, 2018.
               [3] Z. Drmac: A LAPACK implementation of the Dynamic
                   Mode Decomposition I. Technical report. AIMDyn Inc.
                   and LAPACK Working Note 298.
               [4] J. Tu, C. W. Rowley, D. M. Luchtenburg, S. L.
                   Brunton, N. Kutz: On Dynamic Mode Decomposition:
                   Theory and Applications, Journal of Computational
                   Dynamics <a href="../man2/1.2.html">1</a>(2), 391 -421, 2014.

       <b>Developed</b> <b>and</b> <b>supported</b> <b>by:</b>

               Developed and coded by Zlatko Drmac, Faculty of Science,
               University of Zagreb;  <a href="mailto:drmac@math.hr">drmac@math.hr</a>
               In cooperation with
               AIMdyn Inc., Santa Barbara, CA.
               and supported by
               - DARPA SBIR project 'Koopman Operator-Based Forecasting
               for Nonstationary Processes from Near-Term, Limited
               Observational Data' Contract No: W31P4Q-21-C-0007
               - DARPA PAI project 'Physics-Informed Machine Learning
               Methodologies' Contract No: HR0011-18-9-0033
               - DARPA MoDyL project 'A Data-Driven, Operator-Theoretic
               Framework for Space-Time Analysis of Process Dynamics'
               Contract No: HR0011-16-C-0116
               Any opinions, findings and conclusions or recommendations
               expressed in this material are those of the author and
               do not necessarily reflect the views of the DARPA SBIR
               Program Office.

       <b>Distribution</b> <b>Statement</b> <b>A:</b>

               Approved for Public Release, Distribution Unlimited.
               Cleared by DARPA on September 29, 2022

       <b>Parameters</b>
           <u>JOBS</u>

               JOBS (input) CHARACTER*1
               Determines whether the initial data snapshots are scaled
               by a diagonal matrix. The data snapshots are the columns
               of F. The leading N-1 columns of F are denoted X and the
               trailing N-1 columns are denoted Y.
               'S' :: The data snapshots matrices X and Y are multiplied
                      with a diagonal matrix D so that X*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'C' :: The snapshots are scaled as with the 'S' option.
                      If it is found that an i-th column of X is zero
                      vector and the corresponding i-th column of Y is
                      non-zero, then the i-th column of Y is set to
                      zero and a warning flag is raised.
               'Y' :: The data snapshots matrices X and Y are multiplied
                      by a diagonal matrix D so that Y*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'N' :: No data scaling.

           <u>JOBZ</u>

               JOBZ (input) CHARACTER*1
               Determines whether the eigenvectors (Koopman modes) will
               be computed.
               'V' :: The eigenvectors (Koopman modes) will be computed
                      and returned in the matrix Z.
                      See the description of Z.
               'F' :: The eigenvectors (Koopman modes) will be returned
                      in factored form as the product Z*V, where Z
                      is orthonormal and V contains the eigenvectors
                      of the corresponding Rayleigh quotient.
                      See the descriptions of F, V, Z.
               'Q' :: The eigenvectors (Koopman modes) will be returned
                      in factored form as the product Q*Z, where Z
                      contains the eigenvectors of the compression of the
                      underlying discretized operator onto the span of
                      the data snapshots. See the descriptions of F, V, Z.
                      Q is from the initial QR factorization.
               'N' :: The eigenvectors are not computed.

           <u>JOBR</u>

               JOBR (input) CHARACTER*1
               Determines whether to compute the residuals.
               'R' :: The residuals for the computed eigenpairs will
                      be computed and stored in the array RES.
                      See the description of RES.
                      For this option to be legal, JOBZ must be 'V'.
               'N' :: The residuals are not computed.

           <u>JOBQ</u>

               JOBQ (input) CHARACTER*1
               Specifies whether to explicitly compute and return the
               orthogonal matrix from the QR factorization.
               'Q' :: The matrix Q of the QR factorization of the data
                      snapshot matrix is computed and stored in the
                      array F. See the description of F.
               'N' :: The matrix Q is not explicitly computed.

           <u>JOBT</u>

               JOBT (input) CHARACTER*1
               Specifies whether to return the upper triangular factor
               from the QR factorization.
               'R' :: The matrix R of the QR factorization of the data
                      snapshot matrix F is returned in the array Y.
                      See the description of Y and Further details.
               'N' :: The matrix R is not returned.

           <u>JOBF</u>

               JOBF (input) CHARACTER*1
               Specifies whether to store information needed for post-
               processing (e.g. computing refined Ritz vectors)
               'R' :: The matrix needed for the refinement of the Ritz
                      vectors is computed and stored in the array B.
                      See the description of B.
               'E' :: The unscaled eigenvectors of the Exact DMD are
                      computed and returned in the array B. See the
                      description of B.
               'N' :: No eigenvector refinement data is computed.
               To be useful on exit, this option needs JOBQ='Q'.

           <u>WHTSVD</u>

               WHTSVD (input) INTEGER, WHSTVD in { 1, 2, 3, 4 }
               Allows for a selection of the SVD algorithm from the
               LAPACK library.
               1 :: DGESVD (the QR SVD algorithm)
               2 :: DGESDD (the Divide and Conquer algorithm; if enough
                    workspace available, this is the fastest option)
               3 :: DGESVDQ (the preconditioned QR SVD  ; this and 4
                    are the most accurate options)
               4 :: DGEJSV (the preconditioned Jacobi SVD; this and 3
                    are the most accurate options)
               For the four methods above, a significant difference in
               the accuracy of small singular values is possible if
               the snapshots vary in norm so that X is severely
               ill-conditioned. If small (smaller than EPS*||X||)
               singular values are of interest and JOBS=='N',  then
               the options (3, 4) give the most accurate results, where
               the option 4 is slightly better and with stronger
               theoretical background.
               If JOBS=='S', i.e. the columns of X will be normalized,
               then all methods give nearly equally accurate results.

           <u>M</u>

               M (input) INTEGER, M &gt;= 0
               The state space dimension (the number of rows of F).

           <u>N</u>

               N (input) INTEGER, 0 &lt;= N &lt;= M
               The number of data snapshots from a single trajectory,
               taken at equidistant discrete times. This is the
               number of columns of F.

           <u>F</u>

               F (input/output) REAL(KIND=WP) M-by-N array
               &gt; On entry,
               the columns of F are the sequence of data snapshots
               from a single trajectory, taken at equidistant discrete
               times. It is assumed that the column norms of F are
               in the range of the normalized floating point numbers.
               &lt; On exit,
               If JOBQ == 'Q', the array F contains the orthogonal
               matrix/factor of the QR factorization of the initial
               data snapshots matrix F. See the description of JOBQ.
               If JOBQ == 'N', the entries in F strictly below the main
               diagonal contain, column-wise, the information on the
               Householder vectors, as returned by DGEQRF. The
               remaining information to restore the orthogonal matrix
               of the initial QR factorization is stored in WORK(1:N).
               See the description of WORK.

           <u>LDF</u>

               LDF (input) INTEGER, LDF &gt;= M
               The leading dimension of the array F.

           <u>X</u>

               X (workspace/output) REAL(KIND=WP) MIN(M,N)-by-(N-1) array
               X is used as workspace to hold representations of the
               leading N-1 snapshots in the orthonormal basis computed
               in the QR factorization of F.
               On exit, the leading K columns of X contain the leading
               K left singular vectors of the above described content
               of X. To lift them to the space of the left singular
               vectors U(:,1:K)of the input data, pre-multiply with the
               Q factor from the initial QR factorization.
               See the descriptions of F, K, V  and Z.

           <u>LDX</u>

               LDX (input) INTEGER, LDX &gt;= N
               The leading dimension of the array X.

           <u>Y</u>

               Y (workspace/output) REAL(KIND=WP) MIN(M,N)-by-(N-1) array
               Y is used as workspace to hold representations of the
               trailing N-1 snapshots in the orthonormal basis computed
               in the QR factorization of F.
               On exit,
               If JOBT == 'R', Y contains the MIN(M,N)-by-N upper
               triangular factor from the QR factorization of the data
               snapshot matrix F.

           <u>LDY</u>

               LDY (input) INTEGER , LDY &gt;= N
               The leading dimension of the array Y.

           <u>NRNK</u>

               NRNK (input) INTEGER
               Determines the mode how to compute the numerical rank,
               i.e. how to truncate small singular values of the input
               matrix X. On input, if
               NRNK = -1 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*<a href="../man1/sigma.1.html">sigma</a>(1)
                            This option is recommended.
               NRNK = -2 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*sigma(i-1)
                            This option is included for R&amp;D purposes.
                            It requires highly accurate SVD, which
                            may not be feasible.
               The numerical rank can be enforced by using positive
               value of NRNK as follows:
               0 &lt; NRNK &lt;= N-1 :: at most NRNK largest singular values
               will be used. If the number of the computed nonzero
               singular values is less than NRNK, then only those
               nonzero values will be used and the actually used
               dimension is less than NRNK. The actual number of
               the nonzero singular values is returned in the variable
               K. See the description of K.

           <u>TOL</u>

                TOL (input) REAL(KIND=WP), 0 &lt;= TOL &lt; 1
                The tolerance for truncating small singular values.
                See the description of NRNK.

           <u>K</u>

                K (output) INTEGER,  0 &lt;= K &lt;= N
                The dimension of the SVD/POD basis for the leading N-1
                data snapshots (columns of F) and the number of the
                computed Ritz pairs. The value of K is determined
                according to the rule set by the parameters NRNK and
                TOL. See the descriptions of NRNK and TOL.

           <u>REIG</u>

               REIG (output) REAL(KIND=WP) (N-1)-by-1 array
               The leading K (K&lt;=N) entries of REIG contain
               the real parts of the computed eigenvalues
               REIG(1:K) + sqrt(-1)*IMEIG(1:K).
               See the descriptions of K, IMEIG, Z.

           <u>IMEIG</u>

               IMEIG (output) REAL(KIND=WP) (N-1)-by-1 array
               The leading K (K&lt;N) entries of REIG contain
               the imaginary parts of the computed eigenvalues
               REIG(1:K) + sqrt(-1)*IMEIG(1:K).
               The eigenvalues are determined as follows:
               If IMEIG(i) == 0, then the corresponding eigenvalue is
               real, LAMBDA(i) = REIG(i).
               If IMEIG(i)&gt;0, then the corresponding complex
               conjugate pair of eigenvalues reads
               LAMBDA(i)   = REIG(i) + sqrt(-1)*IMAG(i)
               LAMBDA(i+1) = REIG(i) - sqrt(-1)*IMAG(i)
               That is, complex conjugate pairs have consequtive
               indices (i,i+1), with the positive imaginary part
               listed first.
               See the descriptions of K, REIG, Z.

           <u>Z</u>

               Z (workspace/output) REAL(KIND=WP)  M-by-(N-1) array
               If JOBZ =='V' then
                  Z contains real Ritz vectors as follows:
                  If IMEIG(i)=0, then Z(:,i) is an eigenvector of
                  the i-th Ritz value.
                  If IMEIG(i) &gt; 0 (and IMEIG(i+1) &lt; 0) then
                  [Z(:,i) Z(:,i+1)] span an invariant subspace and
                  the Ritz values extracted from this subspace are
                  REIG(i) + sqrt(-1)*IMEIG(i) and
                  REIG(i) - sqrt(-1)*IMEIG(i).
                  The corresponding eigenvectors are
                  Z(:,i) + sqrt(-1)*Z(:,i+1) and
                  Z(:,i) - sqrt(-1)*Z(:,i+1), respectively.
               If JOBZ == 'F', then the above descriptions hold for
               the columns of Z*V, where the columns of V are the
               eigenvectors of the K-by-K Rayleigh quotient, and Z is
               orthonormal. The columns of V are similarly structured:
               If IMEIG(i) == 0 then Z*V(:,i) is an eigenvector, and if
               IMEIG(i) &gt; 0 then Z*V(:,i)+sqrt(-1)*Z*V(:,i+1) and
                                 Z*V(:,i)-sqrt(-1)*Z*V(:,i+1)
               are the eigenvectors of LAMBDA(i), LAMBDA(i+1).
               See the descriptions of REIG, IMEIG, X and V.

           <u>LDZ</u>

               LDZ (input) INTEGER , LDZ &gt;= M
               The leading dimension of the array Z.

           <u>RES</u>

               RES (output) REAL(KIND=WP) (N-1)-by-1 array
               RES(1:K) contains the residuals for the K computed
               Ritz pairs.
               If LAMBDA(i) is real, then
                  RES(i) = || A * Z(:,i) - LAMBDA(i)*Z(:,i))||_2.
               If [LAMBDA(i), LAMBDA(i+1)] is a complex conjugate pair
               then
               RES(i)=RES(i+1) = || A * Z(:,i:i+1) - Z(:,i:i+1) *B||_F
               where B = [ real(LAMBDA(i)) imag(LAMBDA(i)) ]
                         [-imag(LAMBDA(i)) real(LAMBDA(i)) ].
               It holds that
               RES(i)   = || A*ZC(:,i)   - LAMBDA(i)  *ZC(:,i)   ||_2
               RES(i+1) = || A*ZC(:,i+1) - LAMBDA(i+1)*ZC(:,i+1) ||_2
               where ZC(:,i)   =  Z(:,i) + sqrt(-1)*Z(:,i+1)
                     ZC(:,i+1) =  Z(:,i) - sqrt(-1)*Z(:,i+1)
               See the description of Z.

           <u>B</u>

               B (output) REAL(KIND=WP)  MIN(M,N)-by-(N-1) array.
               IF JOBF =='R', B(1:N,1:K) contains A*U(:,1:K), and can
               be used for computing the refined vectors; see further
               details in the provided references.
               If JOBF == 'E', B(1:N,1;K) contains
               A*U(:,1:K)*W(1:K,1:K), which are the vectors from the
               Exact DMD, up to scaling by the inverse eigenvalues.
               In both cases, the content of B can be lifted to the
               original dimension of the input data by pre-multiplying
               with the Q factor from the initial QR factorization.
               Here A denotes a compression of the underlying operator.
               See the descriptions of F and X.
               If JOBF =='N', then B is not referenced.

           <u>LDB</u>

               LDB (input) INTEGER, LDB &gt;= MIN(M,N)
               The leading dimension of the array B.

           <u>V</u>

               V (workspace/output) REAL(KIND=WP) (N-1)-by-(N-1) array
               On exit, V(1:K,1:K) contains the K eigenvectors of
               the Rayleigh quotient. The eigenvectors of a complex
               conjugate pair of eigenvalues are returned in real form
               as explained in the description of Z. The Ritz vectors
               (returned in Z) are the product of X and V; see
               the descriptions of X and Z.

           <u>LDV</u>

               LDV (input) INTEGER, LDV &gt;= N-1
               The leading dimension of the array V.

           <u>S</u>

               S (output) REAL(KIND=WP) (N-1)-by-(N-1) array
               The array S(1:K,1:K) is used for the matrix Rayleigh
               quotient. This content is overwritten during
               the eigenvalue decomposition by DGEEV.
               See the description of K.

           <u>LDS</u>

               LDS (input) INTEGER, LDS &gt;= N-1
               The leading dimension of the array S.

           <u>WORK</u>

               WORK (workspace/output) REAL(KIND=WP) LWORK-by-1 array
               On exit,
               WORK(1:MIN(M,N)) contains the scalar factors of the
               elementary reflectors as returned by DGEQRF of the
               M-by-N input matrix F.
               WORK(MIN(M,N)+1:MIN(M,N)+N-1) contains the singular values of
               the input submatrix F(1:M,1:N-1).
               If the call to DGEDMDQ is only workspace query, then
               <a href="../man1/WORK.1.html">WORK</a>(1) contains the minimal workspace length and
               <a href="../man2/WORK.2.html">WORK</a>(2) is the optimal workspace length. Hence, the
               length of work is at least 2.
               See the description of LWORK.

           <u>LWORK</u>

               LWORK (input) INTEGER
               The minimal length of the  workspace vector WORK.
               LWORK is calculated as follows:
               Let MLWQR  = N (minimal workspace for DGEQRF[M,N])
                   MLWDMD = minimal workspace for DGEDMD (see the
                            description of LWORK in DGEDMD) for
                            snapshots of dimensions MIN(M,N)-by-(N-1)
                   MLWMQR = N (minimal workspace for
                              DORMQR['L','N',M,N,N])
                   MLWGQR = N (minimal workspace for DORGQR[M,N,N])
               Then
               LWORK = MAX(N+MLWQR, N+MLWDMD)
               is updated as follows:
                  if   JOBZ == 'V' or JOBZ == 'F' THEN
                       LWORK = MAX( LWORK, MIN(M,N)+N-1+MLWMQR )
                  if   JOBQ == 'Q' THEN
                       LWORK = MAX( LWORK, MIN(M,N)+N-1+MLWGQR)
               If on entry LWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths for both WORK and
               IWORK. See the descriptions of WORK and IWORK.

           <u>IWORK</u>

               IWORK (workspace/output) INTEGER LIWORK-by-1 array
               Workspace that is required only if WHTSVD equals
               2 , 3 or 4. (See the description of WHTSVD).
               If on entry LWORK =-1 or LIWORK=-1, then the
               minimal length of IWORK is computed and returned in
               <a href="../man1/IWORK.1.html">IWORK</a>(1). See the description of LIWORK.

           <u>LIWORK</u>

               LIWORK (input) INTEGER
               The minimal length of the workspace vector IWORK.
               If WHTSVD == 1, then only <a href="../man1/IWORK.1.html">IWORK</a>(1) is used; LIWORK &gt;=1
               Let M1=MIN(M,N), N1=N-1. Then
               If WHTSVD == 2, then LIWORK &gt;= MAX(1,8*MIN(M1,N1))
               If WHTSVD == 3, then LIWORK &gt;= MAX(1,M1+N1-1)
               If WHTSVD == 4, then LIWORK &gt;= MAX(3,M1+3*N1)
               If on entry LIWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths for both WORK and
               IWORK. See the descriptions of WORK and IWORK.

           <u>INFO</u>

               INFO (output) INTEGER
               -i &lt; 0 :: On entry, the i-th argument had an
                         illegal value
                  = 0 :: Successful return.
                  = 1 :: Void input. Quick exit (M=0 or N=0).
                  = 2 :: The SVD computation of X did not converge.
                         Suggestion: Check the input data and/or
                         repeat with different WHTSVD.
                  = 3 :: The computation of the eigenvalues did not
                         converge.
                  = 4 :: If data scaling was requested on input and
                         the procedure found inconsistency in the data
                         such that for some column index i,
                         X(:,i) = 0 but Y(:,i) /= 0, then Y(:,i) is set
                         to zero if JOBS=='C'. The computation proceeds
                         with original or modified data and warning
                         flag is set with INFO=4.

       <b>Author</b>
           Zlatko Drmac

   <b>subroutine</b> <b>sgedmd</b> <b>(character,</b> <b>intent(in)</b> <b>jobs,</b> <b>character,</b> <b>intent(in)</b> <b>jobz,</b> <b>character,</b> <b>intent(in)</b> <b>jobr,</b>
       <b>character,</b> <b>intent(in)</b> <b>jobf,</b> <b>integer,</b> <b>intent(in)</b> <b>whtsvd,</b> <b>integer,</b> <b>intent(in)</b> <b>m,</b> <b>integer,</b> <b>intent(in)</b> <b>n,</b>
       <b>real(kind=wp),</b> <b>dimension(ldx,*),</b> <b>intent(inout)</b> <b>x,</b> <b>integer,</b> <b>intent(in)</b> <b>ldx,</b> <b>real(kind=wp),</b>
       <b>dimension(ldy,*),</b> <b>intent(inout)</b> <b>y,</b> <b>integer,</b> <b>intent(in)</b> <b>ldy,</b> <b>integer,</b> <b>intent(in)</b> <b>nrnk,</b> <b>real(kind=wp),</b>
       <b>intent(in)</b> <b>tol,</b> <b>integer,</b> <b>intent(out)</b> <b>k,</b> <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>reig,</b> <b>real(kind=wp),</b>
       <b>dimension(*),</b> <b>intent(out)</b> <b>imeig,</b> <b>real(kind=wp),</b> <b>dimension(ldz,*),</b> <b>intent(out)</b> <b>z,</b> <b>integer,</b> <b>intent(in)</b> <b>ldz,</b>
       <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>res,</b> <b>real(kind=wp),</b> <b>dimension(ldb,*),</b> <b>intent(out)</b> <b>b,</b> <b>integer,</b>
       <b>intent(in)</b> <b>ldb,</b> <b>real(kind=wp),</b> <b>dimension(ldw,*),</b> <b>intent(out)</b> <b>w,</b> <b>integer,</b> <b>intent(in)</b> <b>ldw,</b> <b>real(kind=wp),</b>
       <b>dimension(lds,*),</b> <b>intent(out)</b> <b>s,</b> <b>integer,</b> <b>intent(in)</b> <b>lds,</b> <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>work,</b>
       <b>integer,</b> <b>intent(in)</b> <b>lwork,</b> <b>integer,</b> <b>dimension(*),</b> <b>intent(out)</b> <b>iwork,</b> <b>integer,</b> <b>intent(in)</b> <b>liwork,</b> <b>integer,</b>
       <b>intent(out)</b> <b>info)</b>
       <b>SGEDMD</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.

       <b>Purpose:</b>

               SGEDMD computes the Dynamic Mode Decomposition (DMD) for
               a pair of data snapshot matrices. For the input matrices
               X and Y such that Y = A*X with an unaccessible matrix
               A, SGEDMD computes a certain number of Ritz pairs of A using
               the standard Rayleigh-Ritz extraction from a subspace of
               range(X) that is determined using the leading left singular
               vectors of X. Optionally, SGEDMD returns the residuals
               of the computed Ritz pairs, the information needed for
               a refinement of the Ritz vectors, or the eigenvectors of
               the Exact DMD.
               For further details see the references listed
               below. For more details of the implementation see [3].

       <b>References:</b>

               [1] P. Schmid: Dynamic mode decomposition of numerical
                   and experimental data,
                   Journal of Fluid Mechanics 656, 5-28, 2010.
               [2] Z. Drmac, I. Mezic, R. Mohr: Data driven modal
                   decompositions: analysis and enhancements,
                   SIAM J. on Sci. Comp. 40 (4), A2253-A2285, 2018.
               [3] Z. Drmac: A LAPACK implementation of the Dynamic
                   Mode Decomposition I. Technical report. AIMDyn Inc.
                   and LAPACK Working Note 298.
               [4] J. Tu, C. W. Rowley, D. M. Luchtenburg, S. L.
                   Brunton, N. Kutz: On Dynamic Mode Decomposition:
                   Theory and Applications, Journal of Computational
                   Dynamics <a href="../man2/1.2.html">1</a>(2), 391 -421, 2014.

       <b>Developed</b> <b>and</b> <b>supported</b> <b>by:</b>

               Developed and coded by Zlatko Drmac, Faculty of Science,
               University of Zagreb;  <a href="mailto:drmac@math.hr">drmac@math.hr</a>
               In cooperation with
               AIMdyn Inc., Santa Barbara, CA.
               and supported by
               - DARPA SBIR project 'Koopman Operator-Based Forecasting
               for Nonstationary Processes from Near-Term, Limited
               Observational Data' Contract No: W31P4Q-21-C-0007
               - DARPA PAI project 'Physics-Informed Machine Learning
               Methodologies' Contract No: HR0011-18-9-0033
               - DARPA MoDyL project 'A Data-Driven, Operator-Theoretic
               Framework for Space-Time Analysis of Process Dynamics'
               Contract No: HR0011-16-C-0116
               Any opinions, findings and conclusions or recommendations
               expressed in this material are those of the author and
               do not necessarily reflect the views of the DARPA SBIR
               Program Office

       <b>Distribution</b> <b>Statement</b> <b>A:</b>

               Distribution Statement A:
               Approved for Public Release, Distribution Unlimited.
               Cleared by DARPA on September 29, 2022

       <b>Parameters</b>
           <u>JOBS</u>

               JOBS (input) CHARACTER*1
               Determines whether the initial data snapshots are scaled
               by a diagonal matrix.
               'S' :: The data snapshots matrices X and Y are multiplied
                      with a diagonal matrix D so that X*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'C' :: The snapshots are scaled as with the 'S' option.
                      If it is found that an i-th column of X is zero
                      vector and the corresponding i-th column of Y is
                      non-zero, then the i-th column of Y is set to
                      zero and a warning flag is raised.
               'Y' :: The data snapshots matrices X and Y are multiplied
                      by a diagonal matrix D so that Y*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'N' :: No data scaling.

           <u>JOBZ</u>

               JOBZ (input) CHARACTER*1
               Determines whether the eigenvectors (Koopman modes) will
               be computed.
               'V' :: The eigenvectors (Koopman modes) will be computed
                      and returned in the matrix Z.
                      See the description of Z.
               'F' :: The eigenvectors (Koopman modes) will be returned
                      in factored form as the product X(:,1:K)*W, where X
                      contains a POD basis (leading left singular vectors
                      of the data matrix X) and W contains the eigenvectors
                      of the corresponding Rayleigh quotient.
                      See the descriptions of K, X, W, Z.
               'N' :: The eigenvectors are not computed.

           <u>JOBR</u>

               JOBR (input) CHARACTER*1
               Determines whether to compute the residuals.
               'R' :: The residuals for the computed eigenpairs will be
                      computed and stored in the array RES.
                      See the description of RES.
                      For this option to be legal, JOBZ must be 'V'.
               'N' :: The residuals are not computed.

           <u>JOBF</u>

               JOBF (input) CHARACTER*1
               Specifies whether to store information needed for post-
               processing (e.g. computing refined Ritz vectors)
               'R' :: The matrix needed for the refinement of the Ritz
                      vectors is computed and stored in the array B.
                      See the description of B.
               'E' :: The unscaled eigenvectors of the Exact DMD are
                      computed and returned in the array B. See the
                      description of B.
               'N' :: No eigenvector refinement data is computed.

           <u>WHTSVD</u>

               WHTSVD (input) INTEGER, WHSTVD in { 1, 2, 3, 4 }
               Allows for a selection of the SVD algorithm from the
               LAPACK library.
               1 :: SGESVD (the QR SVD algorithm)
               2 :: SGESDD (the Divide and Conquer algorithm; if enough
                    workspace available, this is the fastest option)
               3 :: SGESVDQ (the preconditioned QR SVD  ; this and 4
                    are the most accurate options)
               4 :: SGEJSV (the preconditioned Jacobi SVD; this and 3
                    are the most accurate options)
               For the four methods above, a significant difference in
               the accuracy of small singular values is possible if
               the snapshots vary in norm so that X is severely
               ill-conditioned. If small (smaller than EPS*||X||)
               singular values are of interest and JOBS=='N',  then
               the options (3, 4) give the most accurate results, where
               the option 4 is slightly better and with stronger
               theoretical background.
               If JOBS=='S', i.e. the columns of X will be normalized,
               then all methods give nearly equally accurate results.

           <u>M</u>

               M (input) INTEGER, M&gt;= 0
               The state space dimension (the row dimension of X, Y).

           <u>N</u>

               N (input) INTEGER, 0 &lt;= N &lt;= M
               The number of data snapshot pairs
               (the number of columns of X and Y).

           <u>X</u>

               X (input/output) REAL(KIND=WP) M-by-N array
               &gt; On entry, X contains the data snapshot matrix X. It is
               assumed that the column norms of X are in the range of
               the normalized floating point numbers.
               &lt; On exit, the leading K columns of X contain a POD basis,
               i.e. the leading K left singular vectors of the input
               data matrix X, U(:,1:K). All N columns of X contain all
               left singular vectors of the input matrix X.
               See the descriptions of K, Z and W.

           <u>LDX</u>

               LDX (input) INTEGER, LDX &gt;= M
               The leading dimension of the array X.

           <u>Y</u>

               Y (input/workspace/output) REAL(KIND=WP) M-by-N array
               &gt; On entry, Y contains the data snapshot matrix Y
               &lt; On exit,
               If JOBR == 'R', the leading K columns of Y  contain
               the residual vectors for the computed Ritz pairs.
               See the description of RES.
               If JOBR == 'N', Y contains the original input data,
                               scaled according to the value of JOBS.

           <u>LDY</u>

               LDY (input) INTEGER , LDY &gt;= M
               The leading dimension of the array Y.

           <u>NRNK</u>

               NRNK (input) INTEGER
               Determines the mode how to compute the numerical rank,
               i.e. how to truncate small singular values of the input
               matrix X. On input, if
               NRNK = -1 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*<a href="../man1/sigma.1.html">sigma</a>(1)
                            This option is recommended.
               NRNK = -2 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*sigma(i-1)
                            This option is included for R&amp;D purposes.
                            It requires highly accurate SVD, which
                            may not be feasible.
               The numerical rank can be enforced by using positive
               value of NRNK as follows:
               0 &lt; NRNK &lt;= N :: at most NRNK largest singular values
               will be used. If the number of the computed nonzero
               singular values is less than NRNK, then only those
               nonzero values will be used and the actually used
               dimension is less than NRNK. The actual number of
               the nonzero singular values is returned in the variable
               K. See the descriptions of TOL and  K.

           <u>TOL</u>

               TOL (input) REAL(KIND=WP), 0 &lt;= TOL &lt; 1
               The tolerance for truncating small singular values.
               See the description of NRNK.

           <u>K</u>

               K (output) INTEGER,  0 &lt;= K &lt;= N
               The dimension of the POD basis for the data snapshot
               matrix X and the number of the computed Ritz pairs.
               The value of K is determined according to the rule set
               by the parameters NRNK and TOL.
               See the descriptions of NRNK and TOL.

           <u>REIG</u>

               REIG (output) REAL(KIND=WP) N-by-1 array
               The leading K (K&lt;=N) entries of REIG contain
               the real parts of the computed eigenvalues
               REIG(1:K) + sqrt(-1)*IMEIG(1:K).
               See the descriptions of K, IMEIG, and Z.

           <u>IMEIG</u>

               IMEIG (output) REAL(KIND=WP) N-by-1 array
               The leading K (K&lt;=N) entries of IMEIG contain
               the imaginary parts of the computed eigenvalues
               REIG(1:K) + sqrt(-1)*IMEIG(1:K).
               The eigenvalues are determined as follows:
               If IMEIG(i) == 0, then the corresponding eigenvalue is
               real, LAMBDA(i) = REIG(i).
               If IMEIG(i)&gt;0, then the corresponding complex
               conjugate pair of eigenvalues reads
               LAMBDA(i)   = REIG(i) + sqrt(-1)*IMAG(i)
               LAMBDA(i+1) = REIG(i) - sqrt(-1)*IMAG(i)
               That is, complex conjugate pairs have consecutive
               indices (i,i+1), with the positive imaginary part
               listed first.
               See the descriptions of K, REIG, and Z.

           <u>Z</u>

               Z (workspace/output) REAL(KIND=WP)  M-by-N array
               If JOBZ =='V' then
                  Z contains real Ritz vectors as follows:
                  If IMEIG(i)=0, then Z(:,i) is an eigenvector of
                  the i-th Ritz value; ||Z(:,i)||_2=1.
                  If IMEIG(i) &gt; 0 (and IMEIG(i+1) &lt; 0) then
                  [Z(:,i) Z(:,i+1)] span an invariant subspace and
                  the Ritz values extracted from this subspace are
                  REIG(i) + sqrt(-1)*IMEIG(i) and
                  REIG(i) - sqrt(-1)*IMEIG(i).
                  The corresponding eigenvectors are
                  Z(:,i) + sqrt(-1)*Z(:,i+1) and
                  Z(:,i) - sqrt(-1)*Z(:,i+1), respectively.
                  || Z(:,i:i+1)||_F = 1.
               If JOBZ == 'F', then the above descriptions hold for
               the columns of X(:,1:K)*W(1:K,1:K), where the columns
               of W(1:k,1:K) are the computed eigenvectors of the
               K-by-K Rayleigh quotient. The columns of W(1:K,1:K)
               are similarly structured: If IMEIG(i) == 0 then
               X(:,1:K)*W(:,i) is an eigenvector, and if IMEIG(i)&gt;0
               then X(:,1:K)*W(:,i)+sqrt(-1)*X(:,1:K)*W(:,i+1) and
                    X(:,1:K)*W(:,i)-sqrt(-1)*X(:,1:K)*W(:,i+1)
               are the eigenvectors of LAMBDA(i), LAMBDA(i+1).
               See the descriptions of REIG, IMEIG, X and W.

           <u>LDZ</u>

               LDZ (input) INTEGER , LDZ &gt;= M
               The leading dimension of the array Z.

           <u>RES</u>

               RES (output) REAL(KIND=WP) N-by-1 array
               RES(1:K) contains the residuals for the K computed
               Ritz pairs.
               If LAMBDA(i) is real, then
                  RES(i) = || A * Z(:,i) - LAMBDA(i)*Z(:,i))||_2.
               If [LAMBDA(i), LAMBDA(i+1)] is a complex conjugate pair
               then
               RES(i)=RES(i+1) = || A * Z(:,i:i+1) - Z(:,i:i+1) *B||_F
               where B = [ real(LAMBDA(i)) imag(LAMBDA(i)) ]
                         [-imag(LAMBDA(i)) real(LAMBDA(i)) ].
               It holds that
               RES(i)   = || A*ZC(:,i)   - LAMBDA(i)  *ZC(:,i)   ||_2
               RES(i+1) = || A*ZC(:,i+1) - LAMBDA(i+1)*ZC(:,i+1) ||_2
               where ZC(:,i)   =  Z(:,i) + sqrt(-1)*Z(:,i+1)
                     ZC(:,i+1) =  Z(:,i) - sqrt(-1)*Z(:,i+1)
               See the description of REIG, IMEIG and Z.

           <u>B</u>

               B (output) REAL(KIND=WP)  M-by-N array.
               IF JOBF =='R', B(1:M,1:K) contains A*U(:,1:K), and can
               be used for computing the refined vectors; see further
               details in the provided references.
               If JOBF == 'E', B(1:M,1;K) contains
               A*U(:,1:K)*W(1:K,1:K), which are the vectors from the
               Exact DMD, up to scaling by the inverse eigenvalues.
               If JOBF =='N', then B is not referenced.
               See the descriptions of X, W, K.

           <u>LDB</u>

               LDB (input) INTEGER, LDB &gt;= M
               The leading dimension of the array B.

           <u>W</u>

               W (workspace/output) REAL(KIND=WP) N-by-N array
               On exit, W(1:K,1:K) contains the K computed
               eigenvectors of the matrix Rayleigh quotient (real and
               imaginary parts for each complex conjugate pair of the
               eigenvalues). The Ritz vectors (returned in Z) are the
               product of X (containing a POD basis for the input
               matrix X) and W. See the descriptions of K, S, X and Z.
               W is also used as a workspace to temporarily store the
               left singular vectors of X.

           <u>LDW</u>

               LDW (input) INTEGER, LDW &gt;= N
               The leading dimension of the array W.

           <u>S</u>

               S (workspace/output) REAL(KIND=WP) N-by-N array
               The array S(1:K,1:K) is used for the matrix Rayleigh
               quotient. This content is overwritten during
               the eigenvalue decomposition by SGEEV.
               See the description of K.

           <u>LDS</u>

               LDS (input) INTEGER, LDS &gt;= N
               The leading dimension of the array S.

           <u>WORK</u>

               WORK (workspace/output) REAL(KIND=WP) LWORK-by-1 array
               On exit, WORK(1:N) contains the singular values of
               X (for JOBS=='N') or column scaled X (JOBS=='S', 'C').
               If WHTSVD==4, then WORK(N+1) and WORK(N+2) contain
               scaling factor WORK(N+2)/WORK(N+1) used to scale X
               and Y to avoid overflow in the SVD of X.
               This may be of interest if the scaling option is off
               and as many as possible smallest eigenvalues are
               desired to the highest feasible accuracy.
               If the call to SGEDMD is only workspace query, then
               <a href="../man1/WORK.1.html">WORK</a>(1) contains the minimal workspace length and
               <a href="../man2/WORK.2.html">WORK</a>(2) is the optimal workspace length. Hence, the
               length of work is at least 2.
               See the description of LWORK.

           <u>LWORK</u>

               LWORK (input) INTEGER
               The minimal length of the workspace vector WORK.
               LWORK is calculated as follows:
               If WHTSVD == 1 ::
                  If JOBZ == 'V', then
                  LWORK &gt;= MAX(2, N + LWORK_SVD, N+MAX(1,4*N)).
                  If JOBZ == 'N'  then
                  LWORK &gt;= MAX(2, N + LWORK_SVD, N+MAX(1,3*N)).
                  Here LWORK_SVD = MAX(1,3*N+M,5*N) is the minimal
                  workspace length of SGESVD.
               If WHTSVD == 2 ::
                  If JOBZ == 'V', then
                  LWORK &gt;= MAX(2, N + LWORK_SVD, N+MAX(1,4*N))
                  If JOBZ == 'N', then
                  LWORK &gt;= MAX(2, N + LWORK_SVD, N+MAX(1,3*N))
                  Here LWORK_SVD = MAX(M, 5*N*N+4*N)+3*N*N is the
                  minimal workspace length of SGESDD.
               If WHTSVD == 3 ::
                  If JOBZ == 'V', then
                  LWORK &gt;= MAX(2, N+LWORK_SVD,N+MAX(1,4*N))
                  If JOBZ == 'N', then
                  LWORK &gt;= MAX(2, N+LWORK_SVD,N+MAX(1,3*N))
                  Here LWORK_SVD = N+M+MAX(3*N+1,
                                  MAX(1,3*N+M,5*N),MAX(1,N))
                  is the minimal workspace length of SGESVDQ.
               If WHTSVD == 4 ::
                  If JOBZ == 'V', then
                  LWORK &gt;= MAX(2, N+LWORK_SVD,N+MAX(1,4*N))
                  If JOBZ == 'N', then
                  LWORK &gt;= MAX(2, N+LWORK_SVD,N+MAX(1,3*N))
                  Here LWORK_SVD = MAX(7,2*M+N,6*N+2*N*N) is the
                  minimal workspace length of SGEJSV.
               The above expressions are not simplified in order to
               make the usage of WORK more transparent, and for
               easier checking. In any case, LWORK &gt;= 2.
               If on entry LWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths for both WORK and
               IWORK. See the descriptions of WORK and IWORK.

           <u>IWORK</u>

               IWORK (workspace/output) INTEGER LIWORK-by-1 array
               Workspace that is required only if WHTSVD equals
               2 , 3 or 4. (See the description of WHTSVD).
               If on entry LWORK =-1 or LIWORK=-1, then the
               minimal length of IWORK is computed and returned in
               <a href="../man1/IWORK.1.html">IWORK</a>(1). See the description of LIWORK.

           <u>LIWORK</u>

               LIWORK (input) INTEGER
               The minimal length of the workspace vector IWORK.
               If WHTSVD == 1, then only <a href="../man1/IWORK.1.html">IWORK</a>(1) is used; LIWORK &gt;=1
               If WHTSVD == 2, then LIWORK &gt;= MAX(1,8*MIN(M,N))
               If WHTSVD == 3, then LIWORK &gt;= MAX(1,M+N-1)
               If WHTSVD == 4, then LIWORK &gt;= MAX(3,M+3*N)
               If on entry LIWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths for both WORK and
               IWORK. See the descriptions of WORK and IWORK.

           <u>INFO</u>

               INFO (output) INTEGER
               -i &lt; 0 :: On entry, the i-th argument had an
                         illegal value
                  = 0 :: Successful return.
                  = 1 :: Void input. Quick exit (M=0 or N=0).
                  = 2 :: The SVD computation of X did not converge.
                         Suggestion: Check the input data and/or
                         repeat with different WHTSVD.
                  = 3 :: The computation of the eigenvalues did not
                         converge.
                  = 4 :: If data scaling was requested on input and
                         the procedure found inconsistency in the data
                         such that for some column index i,
                         X(:,i) = 0 but Y(:,i) /= 0, then Y(:,i) is set
                         to zero if JOBS=='C'. The computation proceeds
                         with original or modified data and warning
                         flag is set with INFO=4.

       <b>Author</b>
           Zlatko Drmac

   <b>subroutine</b> <b>sgedmdq</b> <b>(character,</b> <b>intent(in)</b> <b>jobs,</b> <b>character,</b> <b>intent(in)</b> <b>jobz,</b> <b>character,</b> <b>intent(in)</b> <b>jobr,</b>
       <b>character,</b> <b>intent(in)</b> <b>jobq,</b> <b>character,</b> <b>intent(in)</b> <b>jobt,</b> <b>character,</b> <b>intent(in)</b> <b>jobf,</b> <b>integer,</b> <b>intent(in)</b>
       <b>whtsvd,</b> <b>integer,</b> <b>intent(in)</b> <b>m,</b> <b>integer,</b> <b>intent(in)</b> <b>n,</b> <b>real(kind=wp),</b> <b>dimension(ldf,*),</b> <b>intent(inout)</b> <b>f,</b>
       <b>integer,</b> <b>intent(in)</b> <b>ldf,</b> <b>real(kind=wp),</b> <b>dimension(ldx,*),</b> <b>intent(out)</b> <b>x,</b> <b>integer,</b> <b>intent(in)</b> <b>ldx,</b>
       <b>real(kind=wp),</b> <b>dimension(ldy,*),</b> <b>intent(out)</b> <b>y,</b> <b>integer,</b> <b>intent(in)</b> <b>ldy,</b> <b>integer,</b> <b>intent(in)</b> <b>nrnk,</b>
       <b>real(kind=wp),</b> <b>intent(in)</b> <b>tol,</b> <b>integer,</b> <b>intent(out)</b> <b>k,</b> <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>reig,</b>
       <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>imeig,</b> <b>real(kind=wp),</b> <b>dimension(ldz,*),</b> <b>intent(out)</b> <b>z,</b> <b>integer,</b>
       <b>intent(in)</b> <b>ldz,</b> <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>res,</b> <b>real(kind=wp),</b> <b>dimension(ldb,*),</b>
       <b>intent(out)</b> <b>b,</b> <b>integer,</b> <b>intent(in)</b> <b>ldb,</b> <b>real(kind=wp),</b> <b>dimension(ldv,*),</b> <b>intent(out)</b> <b>v,</b> <b>integer,</b>
       <b>intent(in)</b> <b>ldv,</b> <b>real(kind=wp),</b> <b>dimension(lds,*),</b> <b>intent(out)</b> <b>s,</b> <b>integer,</b> <b>intent(in)</b> <b>lds,</b> <b>real(kind=wp),</b>
       <b>dimension(*),</b> <b>intent(out)</b> <b>work,</b> <b>integer,</b> <b>intent(in)</b> <b>lwork,</b> <b>integer,</b> <b>dimension(*),</b> <b>intent(out)</b> <b>iwork,</b>
       <b>integer,</b> <b>intent(in)</b> <b>liwork,</b> <b>integer,</b> <b>intent(out)</b> <b>info)</b>
       <b>SGEDMDQ</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.

       <b>Purpose:</b>

               SGEDMDQ computes the Dynamic Mode Decomposition (DMD) for
               a pair of data snapshot matrices, using a QR factorization
               based compression of the data. For the input matrices
               X and Y such that Y = A*X with an unaccessible matrix
               A, SGEDMDQ computes a certain number of Ritz pairs of A using
               the standard Rayleigh-Ritz extraction from a subspace of
               range(X) that is determined using the leading left singular
               vectors of X. Optionally, SGEDMDQ returns the residuals
               of the computed Ritz pairs, the information needed for
               a refinement of the Ritz vectors, or the eigenvectors of
               the Exact DMD.
               For further details see the references listed
               below. For more details of the implementation see [3].

       <b>References:</b>

               [1] P. Schmid: Dynamic mode decomposition of numerical
                   and experimental data,
                   Journal of Fluid Mechanics 656, 5-28, 2010.
               [2] Z. Drmac, I. Mezic, R. Mohr: Data driven modal
                   decompositions: analysis and enhancements,
                   SIAM J. on Sci. Comp. 40 (4), A2253-A2285, 2018.
               [3] Z. Drmac: A LAPACK implementation of the Dynamic
                   Mode Decomposition I. Technical report. AIMDyn Inc.
                   and LAPACK Working Note 298.
               [4] J. Tu, C. W. Rowley, D. M. Luchtenburg, S. L.
                   Brunton, N. Kutz: On Dynamic Mode Decomposition:
                   Theory and Applications, Journal of Computational
                   Dynamics <a href="../man2/1.2.html">1</a>(2), 391 -421, 2014.

       <b>Developed</b> <b>and</b> <b>supported</b> <b>by:</b>

               Developed and coded by Zlatko Drmac, Faculty of Science,
               University of Zagreb;  <a href="mailto:drmac@math.hr">drmac@math.hr</a>
               In cooperation with
               AIMdyn Inc., Santa Barbara, CA.
               and supported by
               - DARPA SBIR project 'Koopman Operator-Based Forecasting
               for Nonstationary Processes from Near-Term, Limited
               Observational Data' Contract No: W31P4Q-21-C-0007
               - DARPA PAI project 'Physics-Informed Machine Learning
               Methodologies' Contract No: HR0011-18-9-0033
               - DARPA MoDyL project 'A Data-Driven, Operator-Theoretic
               Framework for Space-Time Analysis of Process Dynamics'
               Contract No: HR0011-16-C-0116
               Any opinions, findings and conclusions or recommendations
               expressed in this material are those of the author and
               do not necessarily reflect the views of the DARPA SBIR
               Program Office.

       <b>Distribution</b> <b>Statement</b> <b>A:</b>

               Approved for Public Release, Distribution Unlimited.
               Cleared by DARPA on September 29, 2022

       <b>Parameters</b>
           <u>JOBS</u>

               JOBS (input) CHARACTER*1
               Determines whether the initial data snapshots are scaled
               by a diagonal matrix. The data snapshots are the columns
               of F. The leading N-1 columns of F are denoted X and the
               trailing N-1 columns are denoted Y.
               'S' :: The data snapshots matrices X and Y are multiplied
                      with a diagonal matrix D so that X*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'C' :: The snapshots are scaled as with the 'S' option.
                      If it is found that an i-th column of X is zero
                      vector and the corresponding i-th column of Y is
                      non-zero, then the i-th column of Y is set to
                      zero and a warning flag is raised.
               'Y' :: The data snapshots matrices X and Y are multiplied
                      by a diagonal matrix D so that Y*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'N' :: No data scaling.

           <u>JOBZ</u>

               JOBZ (input) CHARACTER*1
               Determines whether the eigenvectors (Koopman modes) will
               be computed.
               'V' :: The eigenvectors (Koopman modes) will be computed
                      and returned in the matrix Z.
                      See the description of Z.
               'F' :: The eigenvectors (Koopman modes) will be returned
                      in factored form as the product Z*V, where Z
                      is orthonormal and V contains the eigenvectors
                      of the corresponding Rayleigh quotient.
                      See the descriptions of F, V, Z.
               'Q' :: The eigenvectors (Koopman modes) will be returned
                      in factored form as the product Q*Z, where Z
                      contains the eigenvectors of the compression of the
                      underlying discretized operator onto the span of
                      the data snapshots. See the descriptions of F, V, Z.
                      Q is from the initial QR factorization.
               'N' :: The eigenvectors are not computed.

           <u>JOBR</u>

               JOBR (input) CHARACTER*1
               Determines whether to compute the residuals.
               'R' :: The residuals for the computed eigenpairs will
                      be computed and stored in the array RES.
                      See the description of RES.
                      For this option to be legal, JOBZ must be 'V'.
               'N' :: The residuals are not computed.

           <u>JOBQ</u>

               JOBQ (input) CHARACTER*1
               Specifies whether to explicitly compute and return the
               orthogonal matrix from the QR factorization.
               'Q' :: The matrix Q of the QR factorization of the data
                      snapshot matrix is computed and stored in the
                      array F. See the description of F.
               'N' :: The matrix Q is not explicitly computed.

           <u>JOBT</u>

               JOBT (input) CHARACTER*1
               Specifies whether to return the upper triangular factor
               from the QR factorization.
               'R' :: The matrix R of the QR factorization of the data
                      snapshot matrix F is returned in the array Y.
                      See the description of Y and Further details.
               'N' :: The matrix R is not returned.

           <u>JOBF</u>

               JOBF (input) CHARACTER*1
               Specifies whether to store information needed for post-
               processing (e.g. computing refined Ritz vectors)
               'R' :: The matrix needed for the refinement of the Ritz
                      vectors is computed and stored in the array B.
                      See the description of B.
               'E' :: The unscaled eigenvectors of the Exact DMD are
                      computed and returned in the array B. See the
                      description of B.
               'N' :: No eigenvector refinement data is computed.
               To be useful on exit, this option needs JOBQ='Q'.

           <u>WHTSVD</u>

               WHTSVD (input) INTEGER, WHSTVD in { 1, 2, 3, 4 }
               Allows for a selection of the SVD algorithm from the
               LAPACK library.
               1 :: SGESVD (the QR SVD algorithm)
               2 :: SGESDD (the Divide and Conquer algorithm; if enough
                    workspace available, this is the fastest option)
               3 :: SGESVDQ (the preconditioned QR SVD  ; this and 4
                    are the most accurate options)
               4 :: SGEJSV (the preconditioned Jacobi SVD; this and 3
                    are the most accurate options)
               For the four methods above, a significant difference in
               the accuracy of small singular values is possible if
               the snapshots vary in norm so that X is severely
               ill-conditioned. If small (smaller than EPS*||X||)
               singular values are of interest and JOBS=='N',  then
               the options (3, 4) give the most accurate results, where
               the option 4 is slightly better and with stronger
               theoretical background.
               If JOBS=='S', i.e. the columns of X will be normalized,
               then all methods give nearly equally accurate results.

           <u>M</u>

               M (input) INTEGER, M &gt;= 0
               The state space dimension (the number of rows of F)

           <u>N</u>

               N (input) INTEGER, 0 &lt;= N &lt;= M
               The number of data snapshots from a single trajectory,
               taken at equidistant discrete times. This is the
               number of columns of F.

           <u>F</u>

               F (input/output) REAL(KIND=WP) M-by-N array
               &gt; On entry,
               the columns of F are the sequence of data snapshots
               from a single trajectory, taken at equidistant discrete
               times. It is assumed that the column norms of F are
               in the range of the normalized floating point numbers.
               &lt; On exit,
               If JOBQ == 'Q', the array F contains the orthogonal
               matrix/factor of the QR factorization of the initial
               data snapshots matrix F. See the description of JOBQ.
               If JOBQ == 'N', the entries in F strictly below the main
               diagonal contain, column-wise, the information on the
               Householder vectors, as returned by SGEQRF. The
               remaining information to restore the orthogonal matrix
               of the initial QR factorization is stored in WORK(1:N).
               See the description of WORK.

           <u>LDF</u>

               LDF (input) INTEGER, LDF &gt;= M
               The leading dimension of the array F.

           <u>X</u>

               X (workspace/output) REAL(KIND=WP) MIN(M,N)-by-(N-1) array
               X is used as workspace to hold representations of the
               leading N-1 snapshots in the orthonormal basis computed
               in the QR factorization of F.
               On exit, the leading K columns of X contain the leading
               K left singular vectors of the above described content
               of X. To lift them to the space of the left singular
               vectors U(:,1:K)of the input data, pre-multiply with the
               Q factor from the initial QR factorization.
               See the descriptions of F, K, V  and Z.

           <u>LDX</u>

               LDX (input) INTEGER, LDX &gt;= N
               The leading dimension of the array X

           <u>Y</u>

               Y (workspace/output) REAL(KIND=WP) MIN(M,N)-by-(N-1) array
               Y is used as workspace to hold representations of the
               trailing N-1 snapshots in the orthonormal basis computed
               in the QR factorization of F.
               On exit,
               If JOBT == 'R', Y contains the MIN(M,N)-by-N upper
               triangular factor from the QR factorization of the data
               snapshot matrix F.

           <u>LDY</u>

               LDY (input) INTEGER , LDY &gt;= N
               The leading dimension of the array Y

           <u>NRNK</u>

               NRNK (input) INTEGER
               Determines the mode how to compute the numerical rank,
               i.e. how to truncate small singular values of the input
               matrix X. On input, if
               NRNK = -1 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*<a href="../man1/sigma.1.html">sigma</a>(1)
                            This option is recommended.
               NRNK = -2 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*sigma(i-1)
                            This option is included for R&amp;D purposes.
                            It requires highly accurate SVD, which
                            may not be feasible.
               The numerical rank can be enforced by using positive
               value of NRNK as follows:
               0 &lt; NRNK &lt;= N-1 :: at most NRNK largest singular values
               will be used. If the number of the computed nonzero
               singular values is less than NRNK, then only those
               nonzero values will be used and the actually used
               dimension is less than NRNK. The actual number of
               the nonzero singular values is returned in the variable
               K. See the description of K.

           <u>TOL</u>

               TOL (input) REAL(KIND=WP), 0 &lt;= TOL &lt; 1
               The tolerance for truncating small singular values.
               See the description of NRNK.

           <u>K</u>

               K (output) INTEGER,  0 &lt;= K &lt;= N
               The dimension of the SVD/POD basis for the leading N-1
               data snapshots (columns of F) and the number of the
               computed Ritz pairs. The value of K is determined
               according to the rule set by the parameters NRNK and
               TOL. See the descriptions of NRNK and TOL.

           <u>REIG</u>

               REIG (output) REAL(KIND=WP) (N-1)-by-1 array
               The leading K (K&lt;=N) entries of REIG contain
               the real parts of the computed eigenvalues
               REIG(1:K) + sqrt(-1)*IMEIG(1:K).
               See the descriptions of K, IMEIG, Z.

           <u>IMEIG</u>

               IMEIG (output) REAL(KIND=WP) (N-1)-by-1 array
               The leading K (K&lt;N) entries of REIG contain
               the imaginary parts of the computed eigenvalues
               REIG(1:K) + sqrt(-1)*IMEIG(1:K).
               The eigenvalues are determined as follows:
               If IMEIG(i) == 0, then the corresponding eigenvalue is
               real, LAMBDA(i) = REIG(i).
               If IMEIG(i)&gt;0, then the corresponding complex
               conjugate pair of eigenvalues reads
               LAMBDA(i)   = REIG(i) + sqrt(-1)*IMAG(i)
               LAMBDA(i+1) = REIG(i) - sqrt(-1)*IMAG(i)
               That is, complex conjugate pairs have consecutive
               indices (i,i+1), with the positive imaginary part
               listed first.
               See the descriptions of K, REIG, Z.

           <u>Z</u>

               Z (workspace/output) REAL(KIND=WP)  M-by-(N-1) array
               If JOBZ =='V' then
                  Z contains real Ritz vectors as follows:
                  If IMEIG(i)=0, then Z(:,i) is an eigenvector of
                  the i-th Ritz value.
                  If IMEIG(i) &gt; 0 (and IMEIG(i+1) &lt; 0) then
                  [Z(:,i) Z(:,i+1)] span an invariant subspace and
                  the Ritz values extracted from this subspace are
                  REIG(i) + sqrt(-1)*IMEIG(i) and
                  REIG(i) - sqrt(-1)*IMEIG(i).
                  The corresponding eigenvectors are
                  Z(:,i) + sqrt(-1)*Z(:,i+1) and
                  Z(:,i) - sqrt(-1)*Z(:,i+1), respectively.
               If JOBZ == 'F', then the above descriptions hold for
               the columns of Z*V, where the columns of V are the
               eigenvectors of the K-by-K Rayleigh quotient, and Z is
               orthonormal. The columns of V are similarly structured:
               If IMEIG(i) == 0 then Z*V(:,i) is an eigenvector, and if
               IMEIG(i) &gt; 0 then Z*V(:,i)+sqrt(-1)*Z*V(:,i+1) and
                                 Z*V(:,i)-sqrt(-1)*Z*V(:,i+1)
               are the eigenvectors of LAMBDA(i), LAMBDA(i+1).
               See the descriptions of REIG, IMEIG, X and V.

           <u>LDZ</u>

               LDZ (input) INTEGER , LDZ &gt;= M
               The leading dimension of the array Z.

           <u>RES</u>

               RES (output) REAL(KIND=WP) (N-1)-by-1 array
               RES(1:K) contains the residuals for the K computed
               Ritz pairs.
               If LAMBDA(i) is real, then
                  RES(i) = || A * Z(:,i) - LAMBDA(i)*Z(:,i))||_2.
               If [LAMBDA(i), LAMBDA(i+1)] is a complex conjugate pair
               then
               RES(i)=RES(i+1) = || A * Z(:,i:i+1) - Z(:,i:i+1) *B||_F
               where B = [ real(LAMBDA(i)) imag(LAMBDA(i)) ]
                         [-imag(LAMBDA(i)) real(LAMBDA(i)) ].
               It holds that
               RES(i)   = || A*ZC(:,i)   - LAMBDA(i)  *ZC(:,i)   ||_2
               RES(i+1) = || A*ZC(:,i+1) - LAMBDA(i+1)*ZC(:,i+1) ||_2
               where ZC(:,i)   =  Z(:,i) + sqrt(-1)*Z(:,i+1)
                     ZC(:,i+1) =  Z(:,i) - sqrt(-1)*Z(:,i+1)
               See the description of Z.

           <u>B</u>

               B (output) REAL(KIND=WP)  MIN(M,N)-by-(N-1) array.
               IF JOBF =='R', B(1:N,1:K) contains A*U(:,1:K), and can
               be used for computing the refined vectors; see further
               details in the provided references.
               If JOBF == 'E', B(1:N,1;K) contains
               A*U(:,1:K)*W(1:K,1:K), which are the vectors from the
               Exact DMD, up to scaling by the inverse eigenvalues.
               In both cases, the content of B can be lifted to the
               original dimension of the input data by pre-multiplying
               with the Q factor from the initial QR factorization.
               Here A denotes a compression of the underlying operator.
               See the descriptions of F and X.
               If JOBF =='N', then B is not referenced.

           <u>LDB</u>

               LDB (input) INTEGER, LDB &gt;= MIN(M,N)
               The leading dimension of the array B.

           <u>V</u>

               V (workspace/output) REAL(KIND=WP) (N-1)-by-(N-1) array
               On exit, V(1:K,1:K) contains the K eigenvectors of
               the Rayleigh quotient. The eigenvectors of a complex
               conjugate pair of eigenvalues are returned in real form
               as explained in the description of Z. The Ritz vectors
               (returned in Z) are the product of X and V; see
               the descriptions of X and Z.

           <u>LDV</u>

               LDV (input) INTEGER, LDV &gt;= N-1
               The leading dimension of the array V.

           <u>S</u>

               S (output) REAL(KIND=WP) (N-1)-by-(N-1) array
               The array S(1:K,1:K) is used for the matrix Rayleigh
               quotient. This content is overwritten during
               the eigenvalue decomposition by SGEEV.
               See the description of K.

           <u>LDS</u>

               LDS (input) INTEGER, LDS &gt;= N-1
               The leading dimension of the array S.

           <u>WORK</u>

               WORK (workspace/output) REAL(KIND=WP) LWORK-by-1 array
               On exit,
               WORK(1:MIN(M,N)) contains the scalar factors of the
               elementary reflectors as returned by SGEQRF of the
               M-by-N input matrix F.
               WORK(MIN(M,N)+1:MIN(M,N)+N-1) contains the singular values of
               the input submatrix F(1:M,1:N-1).
               If the call to SGEDMDQ is only workspace query, then
               <a href="../man1/WORK.1.html">WORK</a>(1) contains the minimal workspace length and
               <a href="../man2/WORK.2.html">WORK</a>(2) is the optimal workspace length. Hence, the
               length of work is at least 2.
               See the description of LWORK.

           <u>LWORK</u>

               LWORK (input) INTEGER
               The minimal length of the  workspace vector WORK.
               LWORK is calculated as follows:
               Let MLWQR  = N (minimal workspace for SGEQRF[M,N])
                   MLWDMD = minimal workspace for SGEDMD (see the
                            description of LWORK in SGEDMD) for
                            snapshots of dimensions MIN(M,N)-by-(N-1)
                   MLWMQR = N (minimal workspace for
                              SORMQR['L','N',M,N,N])
                   MLWGQR = N (minimal workspace for SORGQR[M,N,N])
               Then
               LWORK = MAX(N+MLWQR, N+MLWDMD)
               is updated as follows:
                  if   JOBZ == 'V' or JOBZ == 'F' THEN
                       LWORK = MAX( LWORK,MIN(M,N)+N-1 +MLWMQR )
                  if   JOBQ == 'Q' THEN
                       LWORK = MAX( LWORK,MIN(M,N)+N-1+MLWGQR)
               If on entry LWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths for both WORK and
               IWORK. See the descriptions of WORK and IWORK.

           <u>IWORK</u>

               IWORK (workspace/output) INTEGER LIWORK-by-1 array
               Workspace that is required only if WHTSVD equals
               2 , 3 or 4. (See the description of WHTSVD).
               If on entry LWORK =-1 or LIWORK=-1, then the
               minimal length of IWORK is computed and returned in
               <a href="../man1/IWORK.1.html">IWORK</a>(1). See the description of LIWORK.

           <u>LIWORK</u>

               LIWORK (input) INTEGER
               The minimal length of the workspace vector IWORK.
               If WHTSVD == 1, then only <a href="../man1/IWORK.1.html">IWORK</a>(1) is used; LIWORK &gt;=1
               Let M1=MIN(M,N), N1=N-1. Then
               If WHTSVD == 2, then LIWORK &gt;= MAX(1,8*MIN(M1,N1))
               If WHTSVD == 3, then LIWORK &gt;= MAX(1,M1+N1-1)
               If WHTSVD == 4, then LIWORK &gt;= MAX(3,M1+3*N1)
               If on entry LIWORK = -1, then a worskpace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths for both WORK and
               IWORK. See the descriptions of WORK and IWORK.

           <u>INFO</u>

               INFO (output) INTEGER
               -i &lt; 0 :: On entry, the i-th argument had an
                         illegal value
                  = 0 :: Successful return.
                  = 1 :: Void input. Quick exit (M=0 or N=0).
                  = 2 :: The SVD computation of X did not converge.
                         Suggestion: Check the input data and/or
                         repeat with different WHTSVD.
                  = 3 :: The computation of the eigenvalues did not
                         converge.
                  = 4 :: If data scaling was requested on input and
                         the procedure found inconsistency in the data
                         such that for some column index i,
                         X(:,i) = 0 but Y(:,i) /= 0, then Y(:,i) is set
                         to zero if JOBS=='C'. The computation proceeds
                         with original or modified data and warning
                         flag is set with INFO=4.

       <b>Author</b>
           Zlatko Drmac

   <b>subroutine</b> <b>zgedmd</b> <b>(character,</b> <b>intent(in)</b> <b>jobs,</b> <b>character,</b> <b>intent(in)</b> <b>jobz,</b> <b>character,</b> <b>intent(in)</b> <b>jobr,</b>
       <b>character,</b> <b>intent(in)</b> <b>jobf,</b> <b>integer,</b> <b>intent(in)</b> <b>whtsvd,</b> <b>integer,</b> <b>intent(in)</b> <b>m,</b> <b>integer,</b> <b>intent(in)</b> <b>n,</b>
       <b>complex(kind=wp),</b> <b>dimension(ldx,*),</b> <b>intent(inout)</b> <b>x,</b> <b>integer,</b> <b>intent(in)</b> <b>ldx,</b> <b>complex(kind=wp),</b>
       <b>dimension(ldy,*),</b> <b>intent(inout)</b> <b>y,</b> <b>integer,</b> <b>intent(in)</b> <b>ldy,</b> <b>integer,</b> <b>intent(in)</b> <b>nrnk,</b> <b>real(kind=wp),</b>
       <b>intent(in)</b> <b>tol,</b> <b>integer,</b> <b>intent(out)</b> <b>k,</b> <b>complex(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>eigs,</b>
       <b>complex(kind=wp),</b> <b>dimension(ldz,*),</b> <b>intent(out)</b> <b>z,</b> <b>integer,</b> <b>intent(in)</b> <b>ldz,</b> <b>real(kind=wp),</b> <b>dimension(*),</b>
       <b>intent(out)</b> <b>res,</b> <b>complex(kind=wp),</b> <b>dimension(ldb,*),</b> <b>intent(out)</b> <b>b,</b> <b>integer,</b> <b>intent(in)</b> <b>ldb,</b>
       <b>complex(kind=wp),</b> <b>dimension(ldw,*),</b> <b>intent(out)</b> <b>w,</b> <b>integer,</b> <b>intent(in)</b> <b>ldw,</b> <b>complex(kind=wp),</b>
       <b>dimension(lds,*),</b> <b>intent(out)</b> <b>s,</b> <b>integer,</b> <b>intent(in)</b> <b>lds,</b> <b>complex(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b>
       <b>zwork,</b> <b>integer,</b> <b>intent(in)</b> <b>lzwork,</b> <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>rwork,</b> <b>integer,</b> <b>intent(in)</b>
       <b>lrwork,</b> <b>integer,</b> <b>dimension(*),</b> <b>intent(out)</b> <b>iwork,</b> <b>integer,</b> <b>intent(in)</b> <b>liwork,</b> <b>integer,</b> <b>intent(out)</b> <b>info)</b>
       <b>ZGEDMD</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.

       <b>Purpose:</b>

               ZGEDMD computes the Dynamic Mode Decomposition (DMD) for
               a pair of data snapshot matrices. For the input matrices
               X and Y such that Y = A*X with an unaccessible matrix
               A, ZGEDMD computes a certain number of Ritz pairs of A using
               the standard Rayleigh-Ritz extraction from a subspace of
               range(X) that is determined using the leading left singular
               vectors of X. Optionally, ZGEDMD returns the residuals
               of the computed Ritz pairs, the information needed for
               a refinement of the Ritz vectors, or the eigenvectors of
               the Exact DMD.
               For further details see the references listed
               below. For more details of the implementation see [3].

       <b>References:</b>

               [1] P. Schmid: Dynamic mode decomposition of numerical
                   and experimental data,
                   Journal of Fluid Mechanics 656, 5-28, 2010.
               [2] Z. Drmac, I. Mezic, R. Mohr: Data driven modal
                   decompositions: analysis and enhancements,
                   SIAM J. on Sci. Comp. 40 (4), A2253-A2285, 2018.
               [3] Z. Drmac: A LAPACK implementation of the Dynamic
                   Mode Decomposition I. Technical report. AIMDyn Inc.
                   and LAPACK Working Note 298.
               [4] J. Tu, C. W. Rowley, D. M. Luchtenburg, S. L.
                   Brunton, N. Kutz: On Dynamic Mode Decomposition:
                   Theory and Applications, Journal of Computational
                   Dynamics <a href="../man2/1.2.html">1</a>(2), 391 -421, 2014.

       <b>Developed</b> <b>and</b> <b>supported</b> <b>by:</b>

               Developed and coded by Zlatko Drmac, Faculty of Science,
               University of Zagreb;  <a href="mailto:drmac@math.hr">drmac@math.hr</a>
               In cooperation with
               AIMdyn Inc., Santa Barbara, CA.
               and supported by
               - DARPA SBIR project 'Koopman Operator-Based Forecasting
               for Nonstationary Processes from Near-Term, Limited
               Observational Data' Contract No: W31P4Q-21-C-0007
               - DARPA PAI project 'Physics-Informed Machine Learning
               Methodologies' Contract No: HR0011-18-9-0033
               - DARPA MoDyL project 'A Data-Driven, Operator-Theoretic
               Framework for Space-Time Analysis of Process Dynamics'
               Contract No: HR0011-16-C-0116
               Any opinions, findings and conclusions or recommendations
               expressed in this material are those of the author and
               do not necessarily reflect the views of the DARPA SBIR
               Program Office

       <b>Distribution</b> <b>Statement</b> <b>A:</b>

               Approved for Public Release, Distribution Unlimited.
               Cleared by DARPA on September 29, 2022

       <b>Parameters</b>
           <u>JOBS</u>

               JOBS (input) CHARACTER*1
               Determines whether the initial data snapshots are scaled
               by a diagonal matrix.
               'S' :: The data snapshots matrices X and Y are multiplied
                      with a diagonal matrix D so that X*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'C' :: The snapshots are scaled as with the 'S' option.
                      If it is found that an i-th column of X is zero
                      vector and the corresponding i-th column of Y is
                      non-zero, then the i-th column of Y is set to
                      zero and a warning flag is raised.
               'Y' :: The data snapshots matrices X and Y are multiplied
                      by a diagonal matrix D so that Y*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'N' :: No data scaling.

           <u>JOBZ</u>

               JOBZ (input) CHARACTER*1
               Determines whether the eigenvectors (Koopman modes) will
               be computed.
               'V' :: The eigenvectors (Koopman modes) will be computed
                      and returned in the matrix Z.
                      See the description of Z.
               'F' :: The eigenvectors (Koopman modes) will be returned
                      in factored form as the product X(:,1:K)*W, where X
                      contains a POD basis (leading left singular vectors
                      of the data matrix X) and W contains the eigenvectors
                      of the corresponding Rayleigh quotient.
                      See the descriptions of K, X, W, Z.
               'N' :: The eigenvectors are not computed.

           <u>JOBR</u>

               JOBR (input) CHARACTER*1
               Determines whether to compute the residuals.
               'R' :: The residuals for the computed eigenpairs will be
                      computed and stored in the array RES.
                      See the description of RES.
                      For this option to be legal, JOBZ must be 'V'.
               'N' :: The residuals are not computed.

           <u>JOBF</u>

               JOBF (input) CHARACTER*1
               Specifies whether to store information needed for post-
               processing (e.g. computing refined Ritz vectors)
               'R' :: The matrix needed for the refinement of the Ritz
                      vectors is computed and stored in the array B.
                      See the description of B.
               'E' :: The unscaled eigenvectors of the Exact DMD are
                      computed and returned in the array B. See the
                      description of B.
               'N' :: No eigenvector refinement data is computed.

           <u>WHTSVD</u>

               WHTSVD (input) INTEGER, WHSTVD in { 1, 2, 3, 4 }
               Allows for a selection of the SVD algorithm from the
               LAPACK library.
               1 :: ZGESVD (the QR SVD algorithm)
               2 :: ZGESDD (the Divide and Conquer algorithm; if enough
                    workspace available, this is the fastest option)
               3 :: ZGESVDQ (the preconditioned QR SVD  ; this and 4
                    are the most accurate options)
               4 :: ZGEJSV (the preconditioned Jacobi SVD; this and 3
                    are the most accurate options)
               For the four methods above, a significant difference in
               the accuracy of small singular values is possible if
               the snapshots vary in norm so that X is severely
               ill-conditioned. If small (smaller than EPS*||X||)
               singular values are of interest and JOBS=='N',  then
               the options (3, 4) give the most accurate results, where
               the option 4 is slightly better and with stronger
               theoretical background.
               If JOBS=='S', i.e. the columns of X will be normalized,
               then all methods give nearly equally accurate results.

           <u>M</u>

               M (input) INTEGER, M&gt;= 0
               The state space dimension (the row dimension of X, Y).

           <u>N</u>

               N (input) INTEGER, 0 &lt;= N &lt;= M
               The number of data snapshot pairs
               (the number of columns of X and Y).

           <u>X</u>

               X (input/output) COMPLEX(KIND=WP) M-by-N array
               &gt; On entry, X contains the data snapshot matrix X. It is
               assumed that the column norms of X are in the range of
               the normalized floating point numbers.
               &lt; On exit, the leading K columns of X contain a POD basis,
               i.e. the leading K left singular vectors of the input
               data matrix X, U(:,1:K). All N columns of X contain all
               left singular vectors of the input matrix X.
               See the descriptions of K, Z and W.

           <u>LDX</u>

               LDX (input) INTEGER, LDX &gt;= M
               The leading dimension of the array X.

           <u>Y</u>

               Y (input/workspace/output) COMPLEX(KIND=WP) M-by-N array
               &gt; On entry, Y contains the data snapshot matrix Y
               &lt; On exit,
               If JOBR == 'R', the leading K columns of Y  contain
               the residual vectors for the computed Ritz pairs.
               See the description of RES.
               If JOBR == 'N', Y contains the original input data,
                               scaled according to the value of JOBS.

           <u>LDY</u>

               LDY (input) INTEGER , LDY &gt;= M
               The leading dimension of the array Y.

           <u>NRNK</u>

               NRNK (input) INTEGER
               Determines the mode how to compute the numerical rank,
               i.e. how to truncate small singular values of the input
               matrix X. On input, if
               NRNK = -1 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*<a href="../man1/sigma.1.html">sigma</a>(1)
                            This option is recommended.
               NRNK = -2 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*sigma(i-1)
                            This option is included for R&amp;D purposes.
                            It requires highly accurate SVD, which
                            may not be feasible.
               The numerical rank can be enforced by using positive
               value of NRNK as follows:
               0 &lt; NRNK &lt;= N :: at most NRNK largest singular values
               will be used. If the number of the computed nonzero
               singular values is less than NRNK, then only those
               nonzero values will be used and the actually used
               dimension is less than NRNK. The actual number of
               the nonzero singular values is returned in the variable
               K. See the descriptions of TOL and  K.

           <u>TOL</u>

               TOL (input) REAL(KIND=WP), 0 &lt;= TOL &lt; 1
               The tolerance for truncating small singular values.
               See the description of NRNK.

           <u>K</u>

               K (output) INTEGER,  0 &lt;= K &lt;= N
               The dimension of the POD basis for the data snapshot
               matrix X and the number of the computed Ritz pairs.
               The value of K is determined according to the rule set
               by the parameters NRNK and TOL.
               See the descriptions of NRNK and TOL.

           <u>EIGS</u>

               EIGS (output) COMPLEX(KIND=WP) N-by-1 array
               The leading K (K&lt;=N) entries of EIGS contain
               the computed eigenvalues (Ritz values).
               See the descriptions of K, and Z.

           <u>Z</u>

               Z (workspace/output) COMPLEX(KIND=WP)  M-by-N array
               If JOBZ =='V' then Z contains the  Ritz vectors.  Z(:,i)
               is an eigenvector of the i-th Ritz value; ||Z(:,i)||_2=1.
               If JOBZ == 'F', then the Z(:,i)'s are given implicitly as
               the columns of X(:,1:K)*W(1:K,1:K), i.e. X(:,1:K)*W(:,i)
               is an eigenvector corresponding to EIGS(i). The columns
               of W(1:k,1:K) are the computed eigenvectors of the
               K-by-K Rayleigh quotient.
               See the descriptions of EIGS, X and W.

           <u>LDZ</u>

               LDZ (input) INTEGER , LDZ &gt;= M
               The leading dimension of the array Z.

           <u>RES</u>

               RES (output) REAL(KIND=WP) N-by-1 array
               RES(1:K) contains the residuals for the K computed
               Ritz pairs,
               RES(i) = || A * Z(:,i) - EIGS(i)*Z(:,i))||_2.
               See the description of EIGS and Z.

           <u>B</u>

               B (output) COMPLEX(KIND=WP)  M-by-N array.
               IF JOBF =='R', B(1:M,1:K) contains A*U(:,1:K), and can
               be used for computing the refined vectors; see further
               details in the provided references.
               If JOBF == 'E', B(1:M,1:K) contains
               A*U(:,1:K)*W(1:K,1:K), which are the vectors from the
               Exact DMD, up to scaling by the inverse eigenvalues.
               If JOBF =='N', then B is not referenced.
               See the descriptions of X, W, K.

           <u>LDB</u>

               LDB (input) INTEGER, LDB &gt;= M
               The leading dimension of the array B.

           <u>W</u>

               W (workspace/output) COMPLEX(KIND=WP) N-by-N array
               On exit, W(1:K,1:K) contains the K computed
               eigenvectors of the matrix Rayleigh quotient.
               The Ritz vectors (returned in Z) are the
               product of X (containing a POD basis for the input
               matrix X) and W. See the descriptions of K, S, X and Z.
               W is also used as a workspace to temporarily store the
               right singular vectors of X.

           <u>LDW</u>

               LDW (input) INTEGER, LDW &gt;= N
               The leading dimension of the array W.

           <u>S</u>

               S (workspace/output) COMPLEX(KIND=WP) N-by-N array
               The array S(1:K,1:K) is used for the matrix Rayleigh
               quotient. This content is overwritten during
               the eigenvalue decomposition by ZGEEV.
               See the description of K.

           <u>LDS</u>

               LDS (input) INTEGER, LDS &gt;= N
               The leading dimension of the array S.

           <u>ZWORK</u>

               ZWORK (workspace/output) COMPLEX(KIND=WP) LZWORK-by-1 array
               ZWORK is used as complex workspace in the complex SVD, as
               specified by WHTSVD (1,2, 3 or 4) and for ZGEEV for computing
               the eigenvalues of a Rayleigh quotient.
               If the call to ZGEDMD is only workspace query, then
               <a href="../man1/ZWORK.1.html">ZWORK</a>(1) contains the minimal complex workspace length and
               <a href="../man2/ZWORK.2.html">ZWORK</a>(2) is the optimal complex workspace length.
               Hence, the length of work is at least 2.
               See the description of LZWORK.

           <u>LZWORK</u>

               LZWORK (input) INTEGER
               The minimal length of the workspace vector ZWORK.
               LZWORK is calculated as MAX(LZWORK_SVD, LZWORK_ZGEEV),
               where LZWORK_ZGEEV = MAX( 1, 2*N )  and the minimal
               LZWORK_SVD is calculated as follows
               If WHTSVD == 1 :: ZGESVD ::
                  LZWORK_SVD = MAX(1,2*MIN(M,N)+MAX(M,N))
               If WHTSVD == 2 :: ZGESDD ::
                  LZWORK_SVD = 2*MIN(M,N)*MIN(M,N)+2*MIN(M,N)+MAX(M,N)
               If WHTSVD == 3 :: ZGESVDQ ::
                  LZWORK_SVD = obtainable by a query
               If WHTSVD == 4 :: ZGEJSV ::
                  LZWORK_SVD = obtainable by a query
               If on entry LZWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths and returns them in
               <a href="../man1/LZWORK.1.html">LZWORK</a>(1) and <a href="../man2/LZWORK.2.html">LZWORK</a>(2), respectively.

           <u>RWORK</u>

               RWORK (workspace/output) REAL(KIND=WP) LRWORK-by-1 array
               On exit, RWORK(1:N) contains the singular values of
               X (for JOBS=='N') or column scaled X (JOBS=='S', 'C').
               If WHTSVD==4, then RWORK(N+1) and RWORK(N+2) contain
               scaling factor RWORK(N+2)/RWORK(N+1) used to scale X
               and Y to avoid overflow in the SVD of X.
               This may be of interest if the scaling option is off
               and as many as possible smallest eigenvalues are
               desired to the highest feasible accuracy.
               If the call to ZGEDMD is only workspace query, then
               <a href="../man1/RWORK.1.html">RWORK</a>(1) contains the minimal workspace length.
               See the description of LRWORK.

           <u>LRWORK</u>

               LRWORK (input) INTEGER
               The minimal length of the workspace vector RWORK.
               LRWORK is calculated as follows:
               LRWORK = MAX(1, N+LRWORK_SVD,N+LRWORK_ZGEEV), where
               LRWORK_ZGEEV = MAX(1,2*N) and RWORK_SVD is the real workspace
               for the SVD subroutine determined by the input parameter
               WHTSVD.
               If WHTSVD == 1 :: ZGESVD ::
                  LRWORK_SVD = 5*MIN(M,N)
               If WHTSVD == 2 :: ZGESDD ::
                  LRWORK_SVD =  MAX(5*MIN(M,N)*MIN(M,N)+7*MIN(M,N),
                  2*MAX(M,N)*MIN(M,N)+2*MIN(M,N)*MIN(M,N)+MIN(M,N) ) )
               If WHTSVD == 3 :: ZGESVDQ ::
                  LRWORK_SVD = obtainable by a query
               If WHTSVD == 4 :: ZGEJSV ::
                  LRWORK_SVD = obtainable by a query
               If on entry LRWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               real workspace length and returns it in <a href="../man1/RWORK.1.html">RWORK</a>(1).

           <u>IWORK</u>

               IWORK (workspace/output) INTEGER LIWORK-by-1 array
               Workspace that is required only if WHTSVD equals
               2 , 3 or 4. (See the description of WHTSVD).
               If on entry LWORK =-1 or LIWORK=-1, then the
               minimal length of IWORK is computed and returned in
               <a href="../man1/IWORK.1.html">IWORK</a>(1). See the description of LIWORK.

           <u>LIWORK</u>

               LIWORK (input) INTEGER
               The minimal length of the workspace vector IWORK.
               If WHTSVD == 1, then only <a href="../man1/IWORK.1.html">IWORK</a>(1) is used; LIWORK &gt;=1
               If WHTSVD == 2, then LIWORK &gt;= MAX(1,8*MIN(M,N))
               If WHTSVD == 3, then LIWORK &gt;= MAX(1,M+N-1)
               If WHTSVD == 4, then LIWORK &gt;= MAX(3,M+3*N)
               If on entry LIWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths for  ZWORK, RWORK and
               IWORK. See the descriptions of ZWORK, RWORK and IWORK.

           <u>INFO</u>

               INFO (output) INTEGER
               -i &lt; 0 :: On entry, the i-th argument had an
                         illegal value
                  = 0 :: Successful return.
                  = 1 :: Void input. Quick exit (M=0 or N=0).
                  = 2 :: The SVD computation of X did not converge.
                         Suggestion: Check the input data and/or
                         repeat with different WHTSVD.
                  = 3 :: The computation of the eigenvalues did not
                         converge.
                  = 4 :: If data scaling was requested on input and
                         the procedure found inconsistency in the data
                         such that for some column index i,
                         X(:,i) = 0 but Y(:,i) /= 0, then Y(:,i) is set
                         to zero if JOBS=='C'. The computation proceeds
                         with original or modified data and warning
                         flag is set with INFO=4.

       <b>Author</b>
           Zlatko Drmac

   <b>subroutine</b> <b>zgedmdq</b> <b>(character,</b> <b>intent(in)</b> <b>jobs,</b> <b>character,</b> <b>intent(in)</b> <b>jobz,</b> <b>character,</b> <b>intent(in)</b> <b>jobr,</b>
       <b>character,</b> <b>intent(in)</b> <b>jobq,</b> <b>character,</b> <b>intent(in)</b> <b>jobt,</b> <b>character,</b> <b>intent(in)</b> <b>jobf,</b> <b>integer,</b> <b>intent(in)</b>
       <b>whtsvd,</b> <b>integer,</b> <b>intent(in)</b> <b>m,</b> <b>integer,</b> <b>intent(in)</b> <b>n,</b> <b>complex(kind=wp),</b> <b>dimension(ldf,*),</b> <b>intent(inout)</b>
       <b>f,</b> <b>integer,</b> <b>intent(in)</b> <b>ldf,</b> <b>complex(kind=wp),</b> <b>dimension(ldx,*),</b> <b>intent(out)</b> <b>x,</b> <b>integer,</b> <b>intent(in)</b> <b>ldx,</b>
       <b>complex(kind=wp),</b> <b>dimension(ldy,*),</b> <b>intent(out)</b> <b>y,</b> <b>integer,</b> <b>intent(in)</b> <b>ldy,</b> <b>integer,</b> <b>intent(in)</b> <b>nrnk,</b>
       <b>real(kind=wp),</b> <b>intent(in)</b> <b>tol,</b> <b>integer,</b> <b>intent(out)</b> <b>k,</b> <b>complex(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>eigs,</b>
       <b>complex(kind=wp),</b> <b>dimension(ldz,*),</b> <b>intent(out)</b> <b>z,</b> <b>integer,</b> <b>intent(in)</b> <b>ldz,</b> <b>real(kind=wp),</b> <b>dimension(*),</b>
       <b>intent(out)</b> <b>res,</b> <b>complex(kind=wp),</b> <b>dimension(ldb,*),</b> <b>intent(out)</b> <b>b,</b> <b>integer,</b> <b>intent(in)</b> <b>ldb,</b>
       <b>complex(kind=wp),</b> <b>dimension(ldv,*),</b> <b>intent(out)</b> <b>v,</b> <b>integer,</b> <b>intent(in)</b> <b>ldv,</b> <b>complex(kind=wp),</b>
       <b>dimension(lds,*),</b> <b>intent(out)</b> <b>s,</b> <b>integer,</b> <b>intent(in)</b> <b>lds,</b> <b>complex(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b>
       <b>zwork,</b> <b>integer,</b> <b>intent(in)</b> <b>lzwork,</b> <b>real(kind=wp),</b> <b>dimension(*),</b> <b>intent(out)</b> <b>work,</b> <b>integer,</b> <b>intent(in)</b>
       <b>lwork,</b> <b>integer,</b> <b>dimension(*),</b> <b>intent(out)</b> <b>iwork,</b> <b>integer,</b> <b>intent(in)</b> <b>liwork,</b> <b>integer,</b> <b>intent(out)</b> <b>info)</b>
       <b>ZGEDMDQ</b> computes the Dynamic Mode Decomposition (DMD) for a pair of data snapshot matrices.

       <b>Purpose:</b>

               ZGEDMDQ computes the Dynamic Mode Decomposition (DMD) for
               a pair of data snapshot matrices, using a QR factorization
               based compression of the data. For the input matrices
               X and Y such that Y = A*X with an unaccessible matrix
               A, ZGEDMDQ computes a certain number of Ritz pairs of A using
               the standard Rayleigh-Ritz extraction from a subspace of
               range(X) that is determined using the leading left singular
               vectors of X. Optionally, ZGEDMDQ returns the residuals
               of the computed Ritz pairs, the information needed for
               a refinement of the Ritz vectors, or the eigenvectors of
               the Exact DMD.
               For further details see the references listed
               below. For more details of the implementation see [3].

       <b>References:</b>

               [1] P. Schmid: Dynamic mode decomposition of numerical
                   and experimental data,
                   Journal of Fluid Mechanics 656, 5-28, 2010.
               [2] Z. Drmac, I. Mezic, R. Mohr: Data driven modal
                   decompositions: analysis and enhancements,
                   SIAM J. on Sci. Comp. 40 (4), A2253-A2285, 2018.
               [3] Z. Drmac: A LAPACK implementation of the Dynamic
                   Mode Decomposition I. Technical report. AIMDyn Inc.
                   and LAPACK Working Note 298.
               [4] J. Tu, C. W. Rowley, D. M. Luchtenburg, S. L.
                   Brunton, N. Kutz: On Dynamic Mode Decomposition:
                   Theory and Applications, Journal of Computational
                   Dynamics <a href="../man2/1.2.html">1</a>(2), 391 -421, 2014.

       <b>Developed</b> <b>and</b> <b>supported</b> <b>by:</b>

               Developed and coded by Zlatko Drmac, Faculty of Science,
               University of Zagreb;  <a href="mailto:drmac@math.hr">drmac@math.hr</a>
               In cooperation with
               AIMdyn Inc., Santa Barbara, CA.
               and supported by
               - DARPA SBIR project 'Koopman Operator-Based Forecasting
               for Nonstationary Processes from Near-Term, Limited
               Observational Data' Contract No: W31P4Q-21-C-0007
               - DARPA PAI project 'Physics-Informed Machine Learning
               Methodologies' Contract No: HR0011-18-9-0033
               - DARPA MoDyL project 'A Data-Driven, Operator-Theoretic
               Framework for Space-Time Analysis of Process Dynamics'
               Contract No: HR0011-16-C-0116
               Any opinions, findings and conclusions or recommendations
               expressed in this material are those of the author and
               do not necessarily reflect the views of the DARPA SBIR
               Program Office.

       <b>Developed</b> <b>and</b> <b>supported</b> <b>by:</b>

               Distribution Statement A:
               Approved for Public Release, Distribution Unlimited.
               Cleared by DARPA on September 29, 2022

       <b>Parameters</b>
           <u>JOBS</u>

               JOBS (input) CHARACTER*1
               Determines whether the initial data snapshots are scaled
               by a diagonal matrix. The data snapshots are the columns
               of F. The leading N-1 columns of F are denoted X and the
               trailing N-1 columns are denoted Y.
               'S' :: The data snapshots matrices X and Y are multiplied
                      with a diagonal matrix D so that X*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'C' :: The snapshots are scaled as with the 'S' option.
                      If it is found that an i-th column of X is zero
                      vector and the corresponding i-th column of Y is
                      non-zero, then the i-th column of Y is set to
                      zero and a warning flag is raised.
               'Y' :: The data snapshots matrices X and Y are multiplied
                      by a diagonal matrix D so that Y*D has unit
                      nonzero columns (in the Euclidean 2-norm)
               'N' :: No data scaling.

           <u>JOBZ</u>

               JOBZ (input) CHARACTER*1
               Determines whether the eigenvectors (Koopman modes) will
               be computed.
               'V' :: The eigenvectors (Koopman modes) will be computed
                      and returned in the matrix Z.
                      See the description of Z.
               'F' :: The eigenvectors (Koopman modes) will be returned
                      in factored form as the product Z*V, where Z
                      is orthonormal and V contains the eigenvectors
                      of the corresponding Rayleigh quotient.
                      See the descriptions of F, V, Z.
               'Q' :: The eigenvectors (Koopman modes) will be returned
                      in factored form as the product Q*Z, where Z
                      contains the eigenvectors of the compression of the
                      underlying discretized operator onto the span of
                      the data snapshots. See the descriptions of F, V, Z.
                      Q is from the initial QR factorization.
               'N' :: The eigenvectors are not computed.

           <u>JOBR</u>

               JOBR (input) CHARACTER*1
               Determines whether to compute the residuals.
               'R' :: The residuals for the computed eigenpairs will
                      be computed and stored in the array RES.
                      See the description of RES.
                      For this option to be legal, JOBZ must be 'V'.
               'N' :: The residuals are not computed.

           <u>JOBQ</u>

               JOBQ (input) CHARACTER*1
               Specifies whether to explicitly compute and return the
               unitary matrix from the QR factorization.
               'Q' :: The matrix Q of the QR factorization of the data
                      snapshot matrix is computed and stored in the
                      array F. See the description of F.
               'N' :: The matrix Q is not explicitly computed.

           <u>JOBT</u>

               JOBT (input) CHARACTER*1
               Specifies whether to return the upper triangular factor
               from the QR factorization.
               'R' :: The matrix R of the QR factorization of the data
                      snapshot matrix F is returned in the array Y.
                      See the description of Y and Further details.
               'N' :: The matrix R is not returned.

           <u>JOBF</u>

               JOBF (input) CHARACTER*1
               Specifies whether to store information needed for post-
               processing (e.g. computing refined Ritz vectors)
               'R' :: The matrix needed for the refinement of the Ritz
                      vectors is computed and stored in the array B.
                      See the description of B.
               'E' :: The unscaled eigenvectors of the Exact DMD are
                      computed and returned in the array B. See the
                      description of B.
               'N' :: No eigenvector refinement data is computed.
               To be useful on exit, this option needs JOBQ='Q'.

           <u>WHTSVD</u>

               WHTSVD (input) INTEGER, WHSTVD in { 1, 2, 3, 4 }
               Allows for a selection of the SVD algorithm from the
               LAPACK library.
               1 :: ZGESVD (the QR SVD algorithm)
               2 :: ZGESDD (the Divide and Conquer algorithm; if enough
                    workspace available, this is the fastest option)
               3 :: ZGESVDQ (the preconditioned QR SVD  ; this and 4
                    are the most accurate options)
               4 :: ZGEJSV (the preconditioned Jacobi SVD; this and 3
                    are the most accurate options)
               For the four methods above, a significant difference in
               the accuracy of small singular values is possible if
               the snapshots vary in norm so that X is severely
               ill-conditioned. If small (smaller than EPS*||X||)
               singular values are of interest and JOBS=='N',  then
               the options (3, 4) give the most accurate results, where
               the option 4 is slightly better and with stronger
               theoretical background.
               If JOBS=='S', i.e. the columns of X will be normalized,
               then all methods give nearly equally accurate results.

           <u>M</u>

               M (input) INTEGER, M &gt;= 0
               The state space dimension (the number of rows of F).

           <u>N</u>

               N (input) INTEGER, 0 &lt;= N &lt;= M
               The number of data snapshots from a single trajectory,
               taken at equidistant discrete times. This is the
               number of columns of F.

           <u>F</u>

               F (input/output) COMPLEX(KIND=WP) M-by-N array
               &gt; On entry,
               the columns of F are the sequence of data snapshots
               from a single trajectory, taken at equidistant discrete
               times. It is assumed that the column norms of F are
               in the range of the normalized floating point numbers.
               &lt; On exit,
               If JOBQ == 'Q', the array F contains the orthogonal
               matrix/factor of the QR factorization of the initial
               data snapshots matrix F. See the description of JOBQ.
               If JOBQ == 'N', the entries in F strictly below the main
               diagonal contain, column-wise, the information on the
               Householder vectors, as returned by ZGEQRF. The
               remaining information to restore the orthogonal matrix
               of the initial QR factorization is stored in ZWORK(1:MIN(M,N)).
               See the description of ZWORK.

           <u>LDF</u>

               LDF (input) INTEGER, LDF &gt;= M
               The leading dimension of the array F.

           <u>X</u>

               X (workspace/output) COMPLEX(KIND=WP) MIN(M,N)-by-(N-1) array
               X is used as workspace to hold representations of the
               leading N-1 snapshots in the orthonormal basis computed
               in the QR factorization of F.
               On exit, the leading K columns of X contain the leading
               K left singular vectors of the above described content
               of X. To lift them to the space of the left singular
               vectors U(:,1:K) of the input data, pre-multiply with the
               Q factor from the initial QR factorization.
               See the descriptions of F, K, V  and Z.

           <u>LDX</u>

               LDX (input) INTEGER, LDX &gt;= N
               The leading dimension of the array X.

           <u>Y</u>

               Y (workspace/output) COMPLEX(KIND=WP) MIN(M,N)-by-(N) array
               Y is used as workspace to hold representations of the
               trailing N-1 snapshots in the orthonormal basis computed
               in the QR factorization of F.
               On exit,
               If JOBT == 'R', Y contains the MIN(M,N)-by-N upper
               triangular factor from the QR factorization of the data
               snapshot matrix F.

           <u>LDY</u>

               LDY (input) INTEGER , LDY &gt;= N
               The leading dimension of the array Y.

           <u>NRNK</u>

               NRNK (input) INTEGER
               Determines the mode how to compute the numerical rank,
               i.e. how to truncate small singular values of the input
               matrix X. On input, if
               NRNK = -1 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*<a href="../man1/sigma.1.html">sigma</a>(1)
                            This option is recommended.
               NRNK = -2 :: i-th singular value sigma(i) is truncated
                            if sigma(i) &lt;= TOL*sigma(i-1)
                            This option is included for R&amp;D purposes.
                            It requires highly accurate SVD, which
                            may not be feasible.
               The numerical rank can be enforced by using positive
               value of NRNK as follows:
               0 &lt; NRNK &lt;= N-1 :: at most NRNK largest singular values
               will be used. If the number of the computed nonzero
               singular values is less than NRNK, then only those
               nonzero values will be used and the actually used
               dimension is less than NRNK. The actual number of
               the nonzero singular values is returned in the variable
               K. See the description of K.

           <u>TOL</u>

               TOL (input) REAL(KIND=WP), 0 &lt;= TOL &lt; 1
               The tolerance for truncating small singular values.
               See the description of NRNK.

           <u>K</u>

               K (output) INTEGER,  0 &lt;= K &lt;= N
               The dimension of the SVD/POD basis for the leading N-1
               data snapshots (columns of F) and the number of the
               computed Ritz pairs. The value of K is determined
               according to the rule set by the parameters NRNK and
               TOL. See the descriptions of NRNK and TOL.

           <u>EIGS</u>

               EIGS (output) COMPLEX(KIND=WP) (N-1)-by-1 array
               The leading K (K&lt;=N-1) entries of EIGS contain
               the computed eigenvalues (Ritz values).
               See the descriptions of K, and Z.

           <u>Z</u>

               Z (workspace/output) COMPLEX(KIND=WP)  M-by-(N-1) array
               If JOBZ =='V' then Z contains the Ritz vectors. Z(:,i)
               is an eigenvector of the i-th Ritz value; ||Z(:,i)||_2=1.
               If JOBZ == 'F', then the Z(:,i)'s are given implicitly as
               Z*V, where Z contains orthonormal matrix (the product of
               Q from the initial QR factorization and the SVD/POD_basis
               returned by ZGEDMD in X) and the second factor (the
               eigenvectors of the Rayleigh quotient) is in the array V,
               as returned by ZGEDMD. That is,  X(:,1:K)*V(:,i)
               is an eigenvector corresponding to EIGS(i). The columns
               of V(1:K,1:K) are the computed eigenvectors of the
               K-by-K Rayleigh quotient.
               See the descriptions of EIGS, X and V.

           <u>LDZ</u>

               LDZ (input) INTEGER , LDZ &gt;= M
               The leading dimension of the array Z.

           <u>RES</u>

               RES (output) REAL(KIND=WP) (N-1)-by-1 array
               RES(1:K) contains the residuals for the K computed
               Ritz pairs,
               RES(i) = || A * Z(:,i) - EIGS(i)*Z(:,i))||_2.
               See the description of EIGS and Z.

           <u>B</u>

               B (output) COMPLEX(KIND=WP)  MIN(M,N)-by-(N-1) array.
               IF JOBF =='R', B(1:N,1:K) contains A*U(:,1:K), and can
               be used for computing the refined vectors; see further
               details in the provided references.
               If JOBF == 'E', B(1:N,1;K) contains
               A*U(:,1:K)*W(1:K,1:K), which are the vectors from the
               Exact DMD, up to scaling by the inverse eigenvalues.
               In both cases, the content of B can be lifted to the
               original dimension of the input data by pre-multiplying
               with the Q factor from the initial QR factorization.
               Here A denotes a compression of the underlying operator.
               See the descriptions of F and X.
               If JOBF =='N', then B is not referenced.

           <u>LDB</u>

               LDB (input) INTEGER, LDB &gt;= MIN(M,N)
               The leading dimension of the array B.

           <u>V</u>

               V (workspace/output) COMPLEX(KIND=WP) (N-1)-by-(N-1) array
               On exit, V(1:K,1:K) V contains the K eigenvectors of
               the Rayleigh quotient. The Ritz vectors
               (returned in Z) are the product of Q from the initial QR
               factorization (see the description of F) X (see the
               description of X) and V.

           <u>LDV</u>

               LDV (input) INTEGER, LDV &gt;= N-1
               The leading dimension of the array V.

           <u>S</u>

               S (output) COMPLEX(KIND=WP) (N-1)-by-(N-1) array
               The array S(1:K,1:K) is used for the matrix Rayleigh
               quotient. This content is overwritten during
               the eigenvalue decomposition by ZGEEV.
               See the description of K.

           <u>LDS</u>

               LDS (input) INTEGER, LDS &gt;= N-1
               The leading dimension of the array S.

           <u>ZWORK</u>

               ZWORK (workspace/output) COMPLEX(KIND=WP) LWORK-by-1 array
               On exit,
               ZWORK(1:MIN(M,N)) contains the scalar factors of the
               elementary reflectors as returned by ZGEQRF of the
               M-by-N input matrix F.
               If the call to ZGEDMDQ is only workspace query, then
               <a href="../man1/ZWORK.1.html">ZWORK</a>(1) contains the minimal complex workspace length and
               <a href="../man2/ZWORK.2.html">ZWORK</a>(2) is the optimal complex workspace length.
               Hence, the length of work is at least 2.
               See the description of LZWORK.

           <u>LZWORK</u>

               LZWORK (input) INTEGER
               The minimal length of the  workspace vector ZWORK.
               LZWORK is calculated as follows:
               Let MLWQR  = N (minimal workspace for ZGEQRF[M,N])
                   MLWDMD = minimal workspace for ZGEDMD (see the
                            description of LWORK in ZGEDMD)
                   MLWMQR = N (minimal workspace for
                              ZUNMQR['L','N',M,N,N])
                   MLWGQR = N (minimal workspace for ZUNGQR[M,N,N])
                   MINMN  = MIN(M,N)
               Then
               LZWORK = MAX(2, MIN(M,N)+MLWQR, MINMN+MLWDMD)
               is further updated as follows:
                  if   JOBZ == 'V' or JOBZ == 'F' THEN
                       LZWORK = MAX(LZWORK, MINMN+MLWMQR)
                  if   JOBQ == 'Q' THEN
                       LZWORK = MAX(ZLWORK, MINMN+MLWGQR)

           <u>WORK</u>

               WORK (workspace/output) REAL(KIND=WP) LWORK-by-1 array
               On exit,
               WORK(1:N-1) contains the singular values of
               the input submatrix F(1:M,1:N-1).
               If the call to ZGEDMDQ is only workspace query, then
               <a href="../man1/WORK.1.html">WORK</a>(1) contains the minimal workspace length and
               <a href="../man2/WORK.2.html">WORK</a>(2) is the optimal workspace length. hence, the
               length of work is at least 2.
               See the description of LWORK.

           <u>LWORK</u>

               LWORK (input) INTEGER
               The minimal length of the  workspace vector WORK.
               LWORK is the same as in ZGEDMD, because in ZGEDMDQ
               only ZGEDMD requires real workspace for snapshots
               of dimensions MIN(M,N)-by-(N-1).
               If on entry LWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace length for WORK.

           <u>IWORK</u>

               IWORK (workspace/output) INTEGER LIWORK-by-1 array
               Workspace that is required only if WHTSVD equals
               2 , 3 or 4. (See the description of WHTSVD).
               If on entry LWORK =-1 or LIWORK=-1, then the
               minimal length of IWORK is computed and returned in
               <a href="../man1/IWORK.1.html">IWORK</a>(1). See the description of LIWORK.

           <u>LIWORK</u>

               LIWORK (input) INTEGER
               The minimal length of the workspace vector IWORK.
               If WHTSVD == 1, then only <a href="../man1/IWORK.1.html">IWORK</a>(1) is used; LIWORK &gt;=1
               Let M1=MIN(M,N), N1=N-1. Then
               If WHTSVD == 2, then LIWORK &gt;= MAX(1,8*MIN(M1,N1))
               If WHTSVD == 3, then LIWORK &gt;= MAX(1,M1+N1-1)
               If WHTSVD == 4, then LIWORK &gt;= MAX(3,M1+3*N1)
               If on entry LIWORK = -1, then a workspace query is
               assumed and the procedure only computes the minimal
               and the optimal workspace lengths for both WORK and
               IWORK. See the descriptions of WORK and IWORK.

           <u>INFO</u>

               INFO (output) INTEGER
               -i &lt; 0 :: On entry, the i-th argument had an
                         illegal value
                  = 0 :: Successful return.
                  = 1 :: Void input. Quick exit (M=0 or N=0).
                  = 2 :: The SVD computation of X did not converge.
                         Suggestion: Check the input data and/or
                         repeat with different WHTSVD.
                  = 3 :: The computation of the eigenvalues did not
                         converge.
                  = 4 :: If data scaling was requested on input and
                         the procedure found inconsistency in the data
                         such that for some column index i,
                         X(:,i) = 0 but Y(:,i) /= 0, then Y(:,i) is set
                         to zero if JOBS=='C'. The computation proceeds
                         with original or modified data and warning
                         flag is set with INFO=4.

       <b>Author</b>
           Zlatko Drmac

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                               Thu Aug 7 2025 17:26:25                                    <u><a href="../man3/gedmd.3.html">gedmd</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>