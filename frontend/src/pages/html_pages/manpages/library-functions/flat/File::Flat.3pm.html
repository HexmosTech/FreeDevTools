<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File::Flat - Implements a flat filesystem</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfile-flat-perl">libfile-flat-perl_1.07-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       File::Flat - Implements a flat filesystem

</pre><h4><b>VERSION</b></h4><pre>
       version 1.07

</pre><h4><b>DESCRIPTION</b></h4><pre>
       File::Flat implements a flat filesystem. A flat filesystem is a filesystem in which directories do not
       exist. It provides an abstraction over any normal filesystem which makes it appear as if directories do
       not exist. In effect, it will automatically create directories as needed. This is create for things like
       install scripts and such, as you never need to worry about the existence of directories, just write to a
       file, no matter where it is.

   <b>Comprehensive</b> <b>Implementation</b>
       The implementation of File::Flat is extremely comprehensive in scope. It has methods for all standard
       file interaction tasks, the -X series of tests, and some other things, such as slurp.

       All methods are statically called, for example, to write some stuff to a file.

         use File::Flat;
         File::Flat-&gt;write( 'filename', 'file contents' );

   <b>Use</b> <b>of</b> <b>other</b> <b>modules</b>
       File::Flat tries to use more task orientated modules wherever possible. This includes the use of
       File::Copy, File::Copy::Recursive, File::Remove and others. These are mostly loaded on-demand.

   <b>Pruning</b> <b>and</b> <b>$AUTO_PRUNE</b>
       "Pruning" is a technique where empty directories are assumed to be useless, and thus empty removed
       whenever one is created. Thus, when some other task has the potential to leave an empty directory, it is
       checked and deleted if it is empty.

       By default File::Flat does not prune, and pruning must be done explicitly, via either the "prune" in
       File::Flat method, or by setting the second argument to the "remove" in File::Flat method to be true.

       However by setting the global $AUTO_PRUNE variable to true, File::Flat will automatically prune
       directories at all times. You should generally use this locally, such as in the following example.

         #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>

         use strict;
         use File::Flat;

         delete_files(@ARGV);
         exit();

         # Recursively delete and prune all files provided on the command line
         sub delete_files {
               local $File::Flat::AUTO_PRUNE = 1;
               foreach my $file ( @_ ) {
                       File::Flat-&gt;remove( $file ) or die "Failed to delete $file";
               }
         }

   <b>Non-Unix</b> <b>platforms</b>
       As of version 0.97 File::Flat should work correctly on Win32. Other platforms (such as VMS) are believed
       to work, but require confirmation.

</pre><h4><b>METHODS</b></h4><pre>
   <b>exists</b> <b>$filename</b>
       Tests for the existence of the file.  This is an exact duplicate of the -e function.

   <b>isaFile</b> <b>$filename</b>
       Tests whether "filename" is a file.  This is an exact duplicate of the -f function.

   <b>isaDirectory</b> <b>$filename</b>
       Test whether "filename" is a directory.  This is an exact duplicate of the -d function.

   <b>canRead</b> <b>$filename</b>
       Does the file or directory exist, and can we read from it.

   <b>canWrite</b> <b>$filename</b>
       Does the file or directory exist, and can we write to it <b>OR</b> can we create the file or directory.

   <b>canReadWrite</b> <b>$filename</b>
       Does a file or directory exist, and can we both read and write it.

   <b>canExecute</b> <b>$filename</b>
       Does a file or directory exist, and can we execute it.

   <b>canOpen</b> <b>$filename</b>
       Is this something we can open a filehandle to. Returns true if filename exists, is a file, and we can
       read from it.

   <b>canRemove</b> <b>$filename</b>
       Can we remove the file or directory.

   <b>isaText</b> <b>$filename</b>
       Does the file "filename" exist, and is it a text file.

   <b>isaBinary</b> <b>$filename</b>
       Does the file "filename" exist, and is it a binary file.

   <b>fileSize</b> <b>$filename</b>
       If the file exists, returns its size in bytes.  Returns undef if the file does not exist.

   <b>open</b> <b>[</b> <b>$mode,</b> <b>]</b> <b>$filename</b>
       Rough analogue of the open function, but creates directories on demand as needed. Supports most of the
       normal options to the normal open function.

       In the single argument form, it takes modes in the form [mode]filename. For example, all the following
       are valid.

         File::Flat-&gt;open( 'filename' );
         File::Flat-&gt;open( '&lt;filename' );
         File::Flat-&gt;open( '&gt;filename' );
         File::Flat-&gt;open( '&gt;&gt;filename' );
         File::Flat-&gt;open( '+&lt;filename' );

       In the two argument form, it takes the following

         File::Flat-&gt;open( '&lt;', 'filename' );
         File::Flat-&gt;open( '&gt;', 'filename' );
         File::Flat-&gt;open( '&gt;&gt;', 'filename' );
         File::Flat-&gt;open( '+&lt;', 'filename' );

       It does not support the more esoteric forms of open, such us opening to a pipe or other such things.

       On successfully opening the file, it returns it as an IO::File object.  Returns undef on error.

   <b>getReadHandle</b> <b>$filename</b>
       The same as File::Flat-&gt;open( '&lt;', 'filename' )

   <b>getWriteHandle</b> <b>$filename</b>
       The same as File::Flat-&gt;open( '&gt;', 'filename' )

   <b>getAppendHandle</b> <b>$filename</b>
       The same as File::Flat-&gt;open( '&gt;&gt;', 'filename' )

   <b>getReadWriteHandle</b> <b>$filename</b>
       The same as File::Flat-&gt;open( '+&lt;', 'filename' )

   <b>read</b> <b>$filename</b>
       Opens and reads in an entire file, chomping as needed.

       In array context, it returns an array containing each line of the file.  In scalar context, it returns a
       reference to an array containing each line of the file. It returns undef on error.

   <b>slurp</b> <b>$filename</b>
       The "slurp" method 'slurps' a file in. That is it attempts to read the entire file into a variable in as
       quick and memory efficient method as possible.

       On success, returns a reference to a scalar, containing the entire file.  Returns undef on error.

   <b>write</b> <b>$filename,</b> <b>(</b> <b>$content</b> <b>|</b> <b>\$content</b> <b>|</b> <b>\@content</b> <b>)</b>
       The "write" method is the main method for writing content to a file.  It takes two arguments, the
       location to write to, and the content to write, in several forms.

       If the file already exists, it will be clobbered before writing starts.  If the file doesn't exists, the
       file and any directories will be created as needed.

       Content can be provided in three forms. The contents of a scalar argument will be written directly to the
       file. You can optionally pass a reference to the scalar. This is recommended when the file size is bigger
       than a few thousand characters, is it does not duplicate the file contents in memory.  Alternatively, you
       can pass the content as a reference to an array containing the contents. To ensure uniformity, "write"
       will add a newline to each line, replacing any existing newline as needed.

       Returns true on success, and undef on error.

   <b>append</b> <b>$filename,</b> <b>(</b> <b>$content</b> <b>|</b> <b>\$content</b> <b>|</b> <b>\@content</b> <b>)</b>
       This method is the same as "write", except that it appends to the end of an existing file ( or creates
       the file as needed ).

       This is the method you should be using to write to log files, etc.

   <b>overwrite</b> <b>$filename,</b> <b>(</b> <b>$content</b> <b>|</b> <b>\$content</b> <b>|</b> <b>\@content</b> <b>)</b>
       Performs an atomic write over a file. It does this by writing to a temporary file, and moving the
       completed file over the top of the existing file ( or creating a new file as needed ). When writing to a
       file that is on the same partition as <a href="file:/tmp">/tmp</a>, this should always be atomic.

       This method otherwise acts the same as "write".

   <b>copy</b> <b>$source,</b> <b>$target</b>
       The "copy" method attempts to copy a file or directory from the source to the target. New directories to
       contain the target will be created as needed.

       For example "&lt;File::Flat-"( './this', './a/b/c/d/that' );&gt;&gt; will create the directory structure required
       as needed.

       In the file copy case, if the target already exists, and is a writable file, we replace the existing
       file, retaining file mode and owners. If the target is a directory, we do NOT copy into that directory,
       unlike with the 'cp' unix command. And error is instead returned.

       "copy" will also do limited recursive copying or directories. If source is a directory, and target does
       not exists, a recursive copy of source will be made to target. If target already exists ( file or
       directory ), "copy" will returns with an error.

   <b>move</b> <b>$source,</b> <b>$target</b>
       The "move" method follows the conventions of the 'mv' command, with the exception that the directories
       containing target will of course be created on demand.

   <b>remove</b> <b>$filename</b> <b>[,</b> <b>$prune</b> <b>]</b>
       The "remove" method will remove a file, or recursively remove a directory.

       If a second (true) argument is provided, then once the file or directory has been deleted, the method
       will the automatically work its way upwards pruning (deleting) empty and thus presumably useless
       directories.

       Returns true if the deletion (and pruning if requested) was a success, or "undef" otherwise.

   <b>prune</b> <b>$filename</b>
       For a file that has already been delete, "prune" will work upwards, removing any empty directories it
       finds.

       For anyone familiar with CVS, it is similar to the "update -P" flag.

       Returns true, or "undef" on error.

   <b>truncate</b> <b>$filename</b> <b>[,</b> <b>$size</b> <b>]</b>
       The "truncate" method will truncate an existing file to a particular size.  A size of 0 ( zero ) is used
       if no size is provided. If the file does not exists, it will be created, and set to 0. Attempting to
       truncate a directory will fail.

       Returns true on success, or undef on error.

   <b>makeDirectory</b> <b>$directory</b> <b>[,</b> <b>mode</b> <b>]</b>
       In the case where you do actually have to create a directory only, the "makeDirectory" method can be used
       to create a directory or any depth.

       An optional file mode ( default 0755 ) can be provided.

       Returns true on success, returns undef on error.

</pre><h4><b>TO</b> <b>DO</b></h4><pre>
       Function interface to be written, like File::Spec::Functions, to provide importable functions.

       There's something bigger here too, I'm not exactly sure what it is, but I think there might be the
       beginnings of a unified filesystem interface here... FSI.pm

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       File::Spec, &lt;<a href="http://ali.as/">http://ali.as/</a>&gt;

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs may be submitted through the RT bug tracker &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=File-
       Flat&gt; (or <a href="mailto:bug-File-Flat@rt.cpan.org">bug-File-Flat@rt.cpan.org</a> &lt;<a href="mailto:bug-File-Flat@rt.cpan.org">mailto:bug-File-Flat@rt.cpan.org</a>&gt;).

</pre><h4><b>AUTHOR</b></h4><pre>
       Adam Kennedy &lt;<a href="mailto:adamk@cpan.org">adamk@cpan.org</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Adam Kennedy &lt;<a href="mailto:adam@ali.as">adam@ali.as</a>&gt;

       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2002 by Adam Kennedy.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.30.3                                       2020-08-25                                    <u>File::<a href="../man3pm/Flat.3pm.html">Flat</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>