<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVP_PKEY_verify_init, EVP_PKEY_verify_init_ex, EVP_PKEY_verify_init_ex2, EVP_PKEY_verify,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       EVP_PKEY_verify_init, EVP_PKEY_verify_init_ex, EVP_PKEY_verify_init_ex2, EVP_PKEY_verify,
       EVP_PKEY_verify_message_init, EVP_PKEY_verify_message_update, EVP_PKEY_verify_message_final,
       EVP_PKEY_CTX_set_signature - signature verification using a public key algorithm

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/evp.h&gt;

        int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);
        int EVP_PKEY_verify_init_ex(EVP_PKEY_CTX *ctx, const OSSL_PARAM params[]);
        int EVP_PKEY_verify_init_ex2(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *algo,
                                     const OSSL_PARAM params[]);
        int EVP_PKEY_verify_message_init(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *algo,
                                         const OSSL_PARAM params[]);
        int EVP_PKEY_CTX_set_signature(EVP_PKEY_CTX *pctx,
                                       const unsigned char *sig, size_t siglen);
        int EVP_PKEY_verify_message_update(EVP_PKEY_CTX *ctx,
                                           unsigned char *in, size_t inlen);
        int EVP_PKEY_verify_message_final(EVP_PKEY_CTX *ctx);
        int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,
                            const unsigned char *sig, size_t siglen,
                            const unsigned char *tbs, size_t tbslen);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>EVP_PKEY_verify_init()</b> initializes a public key algorithm context <u>ctx</u> for verification using the
       algorithm given when the context was created using <b><a href="../man3/EVP_PKEY_CTX_new.3.html">EVP_PKEY_CTX_new</a></b>(3) or variants thereof.  The
       algorithm is used to fetch a <b>EVP_SIGNATURE</b> method implicitly, see "Implicit fetch" in <b><a href="../man7/provider.7.html">provider</a></b>(7) for
       more information about implicit fetches.

       <b>EVP_PKEY_verify_init_ex()</b> is the same as <b>EVP_PKEY_verify_init()</b> but additionally sets the passed
       parameters <u>params</u> on the context before returning.

       <b>EVP_PKEY_verify_init_ex2()</b> is the same as <b>EVP_PKEY_verify_init_ex()</b>, but works with an explicitly fetched
       <b>EVP_SIGNATURE</b> <u>algo</u>.  A context <u>ctx</u> without a pre-loaded key cannot be used with this function.  Depending
       on what algorithm was fetched, certain details revolving around the treatment of the input to
       <b>EVP_PKEY_verify()</b> may be pre-determined, and in that case, those details may normally not be changed.
       See "NOTES" below for a deeper explanation.

       <b>EVP_PKEY_verify_message_init()</b> initializes a public key algorithm context <u>ctx</u> for verifying an unlimited
       size message using the algorithm given by <u>algo</u> and the key given through <b><a href="../man3/EVP_PKEY_CTX_new.3.html">EVP_PKEY_CTX_new</a></b>(3) or
       <b><a href="../man3/EVP_PKEY_CTX_new_from_pkey.3.html">EVP_PKEY_CTX_new_from_pkey</a></b>(3).  Passing the message is supported both in a one-shot fashion using
       <b>EVP_PKEY_verify()</b>, and through the combination of <b>EVP_PKEY_verify_update()</b> and <b>EVP_PKEY_verify_final()</b>.
       This function enables using algorithms that can process input of arbitrary length, such as ED25519,
       RSA-SHA256 and similar.

       <b>EVP_PKEY_CTX_set_signature()</b> specifies the <u>siglen</u> bytes long signature <u>sig</u> to be verified against by
       <b>EVP_PKEY_verify_final()</b>.  It <u>must</u> be used together with <b>EVP_PKEY_verify_update()</b> and
       <b>EVP_PKEY_verify_final()</b>.  See "NOTES" below for a deeper explanation.

       <b>EVP_PKEY_verify_update()</b> adds <u>inlen</u> bytes from <u>in</u> to the data to be processed for verification.  The
       signature algorithm specification and implementation determine how the input bytes are processed and if
       there's a limit on the total size of the input.  See "NOTES" below for a deeper explanation.

       <b>EVP_PKEY_verify_final()</b> verifies the processed data, given only <u>ctx</u>.  The signature to verify against
       must have been given with <b>EVP_PKEY_CTX_set_signature()</b>.

       <b>EVP_PKEY_verify()</b> is a one-shot function that performs the same thing as <b>EVP_PKEY_CTX_set_signature()</b>
       call with <u>sig</u> and <u>siglen</u> as parameters, followed by a single <b>EVP_PKEY_verify_update()</b> call with <u>tbs</u> and
       <u>tbslen</u>, followed by <b>EVP_PKEY_verify_final()</b> call.

</pre><h4><b>NOTES</b></h4><pre>
   <b>General</b>
       Some signature implementations only accumulate the input data and do no further processing before
       verifying it (they expect the input to be a digest), while others compress the data, typically by
       internally producing a digest, and signing the result, which is then verified against a given signature.
       Some of them support both modes of operation at the same time.  The caller is expected to know how the
       chosen algorithm is supposed to behave and under what conditions.

       For example, an RSA implementation can be expected to only expect a digest as input, while ED25519 can be
       expected to process the input with a hash, i.e.  to produce the digest internally, and while RSA-SHA256
       can be expected to handle either mode of operation, depending on if the operation was initialized with
       <b>EVP_PKEY_verify_init_ex2()</b> or with <b>EVP_PKEY_verify_message_init()</b>.

       Similarly, an RSA implementation usually expects additional details to be set, like the message digest
       algorithm that the input is supposed to be digested with, as well as the padding mode (see
       <b><a href="../man3/EVP_PKEY_CTX_set_signature_md.3.html">EVP_PKEY_CTX_set_signature_md</a></b>(3) and <b><a href="../man3/EVP_PKEY_CTX_set_rsa_padding.3.html">EVP_PKEY_CTX_set_rsa_padding</a></b>(3) and similar others), while an
       RSA-SHA256 implementation usually has these details pre-set and immutable.

       The functions described here can't be used to combine separate algorithms.  In particular, neither
       <b><a href="../man3/EVP_PKEY_CTX_set_signature_md.3.html">EVP_PKEY_CTX_set_signature_md</a></b>(3) nor the <b>OSSL_PARAM</b> parameter "digest" (<b>OSSL_SIGNATURE_PARAM_DIGEST</b>) can
       be used to combine a signature algorithm with a hash algorithm to process the input.  In other words,
       it's not possible to specify a <u>ctx</u> pre-loaded with an RSA pkey, or an <u>algo</u> that fetched "RSA" and try to
       specify SHA256 separately to get the functionality of RSA-SHA256.  If combining algorithms in that manner
       is desired, please use <b><a href="../man3/EVP_DigestVerifyInit.3.html">EVP_DigestVerifyInit</a></b>(3) and associated functions, or <b><a href="../man3/EVP_VerifyInit.3.html">EVP_VerifyInit</a></b>(3) and
       associated functions.

   <b>Performing</b> <b>multiple</b> <b>verifications</b>
       When initialized using <b>EVP_PKEY_verify_init_ex()</b> or  <b>EVP_PKEY_verify_init_ex2()</b>, <b>EVP_PKEY_verify()</b> can be
       called more than once on the same context to have several one-shot operations performed using the same
       parameters.

       When initialized using <b>EVP_PKEY_verify_message_init()</b>, it's not possible to call <b>EVP_PKEY_verify()</b>
       multiple times.

   <b>On</b> <b>EVP_PKEY_CTX_set_signature()</b>
       Some signature algorithms (such as LMS) require the signature verification data be specified before
       verifying the message.  Other algorithms allow the signature to be specified late.  To allow either way
       (which may depend on the application's flow of input), the signature to be verified against <u>must</u> be
       specified using this function when using <b>EVP_PKEY_verify_message_update()</b> and
       <b>EVP_PKEY_verify_message_final()</b> to perform the verification.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       All functions return 1 for success and 0 or a negative value for failure.  However, unlike other
       functions, the return value 0 from <b>EVP_PKEY_verify()</b>, <b>EVP_PKEY_verify_recover()</b> and
       <b>EVP_PKEY_verify_message_final()</b> only indicates that the signature did not verify successfully (that is
       tbs did not match the original data or the signature was of invalid form) it is not an indication of a
       more serious error.

       A negative value indicates an error other that signature verification failure.  In particular a return
       value of -2 indicates the operation is not supported by the public key algorithm.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>RSA</b> <b>with</b> <b>PKCS#1</b> <b>padding</b> <b>for</b> <b>SHA256</b>
       Verify signature using PKCS#1 padding and a SHA256 digest as input:

        #include &lt;openssl/evp.h&gt;
        #include &lt;openssl/rsa.h&gt;

        EVP_PKEY_CTX *ctx;
        unsigned char *md, *sig;
        size_t mdlen, siglen;
        EVP_PKEY *verify_key;

        /*
         * NB: assumes verify_key, sig, siglen md and mdlen are already set up
         * and that verify_key is an RSA public key
         */
        ctx = EVP_PKEY_CTX_new(verify_key, NULL /* no engine */);
        if (ctx == NULL)
            /* Error occurred */
        if (EVP_PKEY_verify_init(ctx) &lt;= 0)
            /* Error */
        if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) &lt;= 0)
            /* Error */
        if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) &lt;= 0)
            /* Error */

        /* Perform operation */
        ret = EVP_PKEY_verify(ctx, sig, siglen, md, mdlen);

        /*
         * ret == 1 indicates success, 0 verify failure and &lt; 0 for some
         * other error.
         */

   <b>RSA-SHA256</b> <b>with</b> <b>a</b> <b>pre-computed</b> <b>digest</b>
       Verify a digest with RSA-SHA256 using one-shot functions.  To be noted is that RSA-SHA256 is assumed to
       be an implementation of "sha256WithRSAEncryption", for which the padding is pre-determined to be
       <b>RSA_PKCS1_PADDING</b>, and the input digest is assumed to have been computed using SHA256.

        #include &lt;openssl/evp.h&gt;
        #include &lt;openssl/rsa.h&gt;

        EVP_PKEY_CTX *ctx;
        /* md is a SHA-256 digest in this example. */
        unsigned char *md, *sig;
        size_t mdlen = 32, siglen;
        EVP_PKEY *signing_key;

        /*
         * NB: assumes verify_key, sig, siglen, md and mdlen are already set up
         * and that verify_key is an RSA public key
         */
        ctx = EVP_PKEY_CTX_new(signing_key, NULL /* no engine */);
        alg = EVP_SIGNATURE_fetch(NULL, "RSA-SHA256", NULL);

        if (ctx == NULL)
            /* Error occurred */
        if (EVP_PKEY_verify_init_ex2(ctx, alg, NULL) &lt;= 0)
            /* Error */

        /* Determine buffer length */
        if (EVP_PKEY_verify(ctx, sig, siglen, md, mdlen) &lt;= 0)
            /* Error or signature doesn't verify */

        /* Perform operation */
        ret = EVP_PKEY_verify(ctx, sig, siglen, md, mdlen);

        /*
         * ret == 1 indicates success, 0 verify failure and &lt; 0 for some
         * other error.
         */

   <b>RSA-SHA256,</b> <b>one-shot</b>
       Verify a document with RSA-SHA256 using one-shot functions.  To be noted is that RSA-SHA256 is assumed to
       be an implementation of "sha256WithRSAEncryption", for which the padding is pre-determined to be
       <b>RSA_PKCS1_PADDING</b>.

        #include &lt;openssl/evp.h&gt;
        #include &lt;openssl/rsa.h&gt;

        EVP_PKEY_CTX *ctx;
        /* in the input in this example. */
        unsigned char *in, *sig;
        /* inlen is the length of the input in this example. */
        size_t inlen, siglen;
        EVP_PKEY *signing_key;
        EVP_SIGNATURE *alg;

        /*
         * NB: assumes signing_key, in and inlen are set up before
         * the next step. signing_key must be an RSA private key,
         * in must point to data to be digested and signed, and
         * inlen must be the size of the data in bytes.
         */
        ctx = EVP_PKEY_CTX_new(signing_key, NULL /* no engine */);
        alg = EVP_SIGNATURE_fetch(NULL, "RSA-SHA256", NULL);

        if (ctx == NULL || alg == NULL)
            /* Error occurred */
        if (EVP_PKEY_verify_message_init(ctx, alg, NULL) &lt;= 0)
            /* Error */

        /* Perform operation */
        ret = EVP_PKEY_verify(ctx, sig, siglen, in, inlen);

        /*
         * ret == 1 indicates success, 0 verify failure and &lt; 0 for some
         * other error.
         */

   <b>RSA-SHA256,</b> <b>using</b> <b>update</b> <b>and</b> <b>final</b>
       This is the same as the previous example, but allowing stream-like functionality.

        #include &lt;openssl/evp.h&gt;
        #include &lt;openssl/rsa.h&gt;

        EVP_PKEY_CTX *ctx;
        /* in is the input in this example. */
        unsigned char *in, *sig;
        /* inlen is the length of the input in this example. */
        size_t inlen, siglen;
        EVP_PKEY *signing_key;
        EVP_SIGNATURE *alg;

        /*
         * NB: assumes signing_key, in and inlen are set up before
         * the next step. signing_key must be an RSA private key,
         * in must point to data to be digested and signed, and
         * inlen must be the size of the data in bytes.
         */
        ctx = EVP_PKEY_CTX_new(signing_key, NULL /* no engine */);
        alg = EVP_SIGNATURE_fetch(NULL, "RSA-SHA256", NULL);

        if (ctx == NULL || alg == NULL)
            /* Error occurred */
        if (EVP_PKEY_verify_message_init(ctx, alg, NULL) &lt;= 0)
            /* Error */

        /* We have the signature, specify it early */
        EVP_PKEY_CTX_set_signature(ctx, sig, siglen);

        /* Perform operation */
        while (inlen &gt; 0) {
            if (EVP_PKEY_verify_message_update(ctx, in, inlen)) &lt;= 0)
                /* Error */
            if (inlen &gt; 256) {
                inlen -= 256;
                in += 256;
            } else {
                inlen = 0;
            }
        }
        ret = EVP_PKEY_verify_message_final(ctx);

        /*
         * ret == 1 indicates success, 0 verify failure and &lt; 0 for some
         * other error.
         */

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/EVP_PKEY_CTX_new.3.html">EVP_PKEY_CTX_new</a></b>(3), <b><a href="../man3/EVP_PKEY_encrypt.3.html">EVP_PKEY_encrypt</a></b>(3), <b><a href="../man3/EVP_PKEY_decrypt.3.html">EVP_PKEY_decrypt</a></b>(3), <b><a href="../man3/EVP_PKEY_sign.3.html">EVP_PKEY_sign</a></b>(3),
       <b><a href="../man3/EVP_PKEY_verify_recover.3.html">EVP_PKEY_verify_recover</a></b>(3), <b><a href="../man3/EVP_PKEY_derive.3.html">EVP_PKEY_derive</a></b>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>EVP_PKEY_verify_init()</b> and <b>EVP_PKEY_verify()</b> functions were added in OpenSSL 1.0.0.

       The <b>EVP_PKEY_verify_init_ex()</b> function was added in OpenSSL 3.0.

       The <b>EVP_PKEY_verify_init_ex2()</b>, <b>EVP_PKEY_verify_message_init()</b>, <b>EVP_PKEY_verify_message_update()</b>,
       <b>EVP_PKEY_verify_message_final()</b> and <b>EVP_PKEY_CTX_set_signature()</b> functions where added in OpenSSL 3.4.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2006-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                              <u><a href="../man3SSL/EVP_PKEY_VERIFY.3SSL.html">EVP_PKEY_VERIFY</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>