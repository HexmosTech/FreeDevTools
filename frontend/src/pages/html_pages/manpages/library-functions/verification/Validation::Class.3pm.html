<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Validation::Class - Powerful Data Validation Framework</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libvalidation-class-perl">libvalidation-class-perl_7.900059-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Validation::Class - Powerful Data Validation Framework

</pre><h4><b>VERSION</b></h4><pre>
       version 7.900059

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Validation::Class::Simple::Streamer;

           my  $params = {username =&gt; 'admin', password =&gt; 's3cret'};
           my  $input  = Validation::Class::Simple::Streamer-&gt;new(params =&gt; $params);

           # check username parameter
           $input-&gt;check('username')-&gt;required-&gt;between('5-255');
           $input-&gt;filters([qw/trim strip/]);

           # check password parameter
           $input-&gt;check('password')-&gt;required-&gt;between('5-255')-&gt;<a href="../man1/min_symbols.1.html">min_symbols</a>(1);
           $input-&gt;filters([qw/trim strip/]);

           # run validate
           $input-&gt;validate or die $input-&gt;errors_to_string;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Validation::Class is a scalable data validation library with interfaces for applications of all sizes.
       The most common usage of Validation::Class is to transform class namespaces into data validation domains
       where consistency and reuse are primary concerns. Validation::Class provides an extensible framework for
       defining reusable data validation rules. It ships with a complete set of pre-defined validations and
       filters referred to as "directives".

       The core feature-set consist of self-validating methods, validation profiles, reusable validation rules
       and templates, pre and post input filtering, class inheritance, automatic array handling, and
       extensibility (e.g. overriding default error messages, creating custom validators, creating custom input
       filters and much more). Validation::Class promotes DRY (don't repeat yourself) code. The main benefit in
       using Validation::Class is that the architecture is designed to increase the consistency of data input
       handling. The following is a more traditional usage of Validation::Class, using the DSL to construct a
       validator class:

           package MyApp::Person;

           use Validation::Class;

           # data validation template
           mixin basic     =&gt; {
               required    =&gt; 1,
               max_length  =&gt; 255,
               filters     =&gt; [qw/trim strip/]
           };

           # data validation rules for the username parameter
           field username  =&gt; {
               mixin       =&gt; 'basic',
               min_length  =&gt; 5
           };

           # data validation rules for the password parameter
           field password  =&gt; {
               mixin       =&gt; 'basic',
               min_length  =&gt; 5,
               min_symbols =&gt; 1
           };

           package main;

           my $person = MyApp::Person-&gt;new(username =&gt; 'admin', password =&gt; 'secr3t');

           # validate rules on the person object
           unless ($person-&gt;validates) {
               # handle the failures
               warn $person-&gt;errors_to_string;
           }

           1;

</pre><h4><b>QUICKSTART</b></h4><pre>
       If you are looking for a simple in-line data validation module built using the same tenets and principles
       as Validation::Class, please review Validation::Class::Simple or Validation::Class::Simple::Streamer. If
       you are new to Validation::Class, or would like more information on the underpinnings of this library and
       how it views and approaches data validation, please review Validation::Class::Whitepaper. Please review
       the "GUIDED-TOUR" in Validation::Class::Cookbook for a detailed step-by-step look into how
       Validation::Class works.

</pre><h4><b>KEYWORDS</b></h4><pre>
   <b>adopt</b>
       The adopt keyword (or adt) copies configuration and functionality from other Validation::Class classes.
       The adopt keyword takes three arguments, the name of the class to be introspected, and the configuration
       type and name to be recreated. Basically, anything you can configure using a Validation::Class keyword
       can be adopted into other classes using this keyword with the exception of coderefs registered using the
       build keyword. Please note! If you are adopting a field declaration which has an associated mixin
       directive defined on the target class, you must adopt the mixin explicitly if you wish it's values to be
       interpolated.

           package MyApp::Exployee;

           use Validate::Class;
           use MyApp::Person;

           adopt MyApp::Person, mixin   =&gt; 'basic';
           adopt MyApp::Person, field   =&gt; 'first_name';
           adopt MyApp::Person, field   =&gt; 'last_name';
           adopt MyApp::Person, profile =&gt; 'has_fullname';

           1;

   <b>attribute</b>
       The attribute keyword (or has) registers a class attribute, i.e. it creates an accessor (getter and
       setter) on the class. Attribute declaration is flexible and only requires an attribute name to be
       configured. Additionally, the attribute keyword can takes two arguments, the attribute's name and a
       scalar or coderef to be used as it's default value.

           package MyApp::Person;

           use Validate::Class;

           attribute 'first_name' =&gt; 'Peter';
           attribute 'last_name'  =&gt; 'Venkman';
           attribute 'full_name'  =&gt; sub {
               join ', ', $_[0]-&gt;last_name, $_[0]-&gt;first_name
           };

           attribute 'email_address';

           1;

   <b>build</b>
       The build keyword (or bld) registers a coderef to be run at instantiation much in the same way the common
       BUILD routine is used in modern OO frameworks.

           package MyApp::Person;

           use Validation::Class;

           build sub {

               my ($self, $args) = @_;

               # run after instantiation in the order defined

           };

           1;

       The build keyword takes one argument, a coderef which is passed the instantiated class object.

   <b>directive</b>
       The directive keyword (or dir) registers custom validator directives to be used in your field
       definitions. Please note that custom directives can only be used with field definitions. This is a means
       of extending the list of directives per instance. See the list of core directives,
       Validation::Class::Directives, or review Validation::Class::Directive for insight into creating your own
       CPAN installable directives.

           package MyApp::Person;

           use Validate::Class;

           # define a custom class-level directive
           directive 'blacklisted' =&gt; sub {

               my ($self, $field, $param) = @_;

               if (defined $field-&gt;{blacklisted} &amp;&amp; defined $param) {
                   if ($field-&gt;{required} || $param) {
                       if (exists_in_blacklist($field-&gt;{blacklisted}, $param)) {
                           my $handle = $field-&gt;label || $field-&gt;name;
                           $field-&gt;errors-&gt;add("$handle has been blacklisted");
                           return 0;
                       }
                   }
               }

               return 1;

           };

           field 'email_address' =&gt; {
               blacklisted =&gt; '/path/to/blacklist'
               email =&gt; 1,
           };

           1;

       The directive keyword takes two arguments, the name of the directive and a coderef which will be used to
       validate the associated field. The coderef is passed four ordered parameters; a directive object, the
       class prototype object, the current field object, and the matching parameter's value. The validator
       (coderef) is evaluated by its return value as well as whether it altered any error containers.

   <b>document</b>
       The document keyword (or doc) registers a data matching profile which can be used to validate heiarchal
       data. It will store a hashref with pre-define path matching rules for the data structures you wish to
       validate. The "path matching rules", which use a specialized object notation, referred to as the document
       notation, can be thought of as a kind-of simplified regular expression which is executed against the
       flattened data structure. The following are a few general use-cases:

           package MyApp::Person;

           use Validation::Class;

           field  'string' =&gt; {
               mixin =&gt; [':str']
           };

           # given this JSON data structure
           {
               "id": "1234-A",
               "name": {
                   "first_name" : "Bob",
                   "last_name"  : "Smith",
                },
               "title": "CIO",
               "friends" : [],
           }

           # select id to validate against the string rule
           document 'foobar'  =&gt;
               { 'id' =&gt; 'string' };

           # select name -&gt; first_name/last_name to validate against the string rule
           document 'foobar'  =&gt;
               {'name.first_name' =&gt; 'string', 'name.last_name' =&gt; 'string'};

           # or
           document 'foobar'  =&gt;
               {'name.*_name' =&gt; 'string'};

           # select each element in friends to validate against the string rule
           document 'foobar'  =&gt;
               { 'friends.@'  =&gt; 'string' };

           # or select an element of a hashref in each element in friends to validate
           # against the string rule
           document 'foobar'  =&gt;
               { 'friends.@.name' =&gt; 'string' };

       The document declaration's keys should follow the aforementioned document notation schema and it's values
       should be strings which correspond to the names of fields (or other document declarations) that will be
       used to preform the data validation. It is possible to combine document declarations to validate
       hierarchical data that contains data structures matching one or more document patterns. The following is
       an example of what that might look like.

           package MyApp::Person;

           use Validation::Class;

           # data validation rule
           field  'name' =&gt; {
               mixin      =&gt; [':str'],
               pattern    =&gt; qr/^[A-Za-z ]+$/,
               max_length =&gt; 20,
           };

           # data validation map / document notation schema
           document 'friend' =&gt; {
               'name' =&gt; 'name'
           };

           # data validation map / document notation schema
           document 'person' =&gt; {
               'name' =&gt; 'name',
               'friends.@' =&gt; 'friend'
           };

           package main;

           my $data = {
               "name"   =&gt; "Anita Campbell-Green",
               "friends" =&gt; [
                   { "name" =&gt; "Horace" },
                   { "name" =&gt; "Skinner" },
                   { "name" =&gt; "Alonzo" },
                   { "name" =&gt; "Frederick" },
               ],
           };

           my $person = MyApp::Person-&gt;new;

           unless ($person-&gt;validate_document(person =&gt; $data)) {
               warn $person-&gt;errors_to_string if $person-&gt;error_count;
           }

           1;

       Alternatively, the following is a more verbose data validation class using traditional styling and
       configuration.

           package MyApp::Person;

           use Validation::Class;

           field  'id' =&gt; {
               mixin      =&gt; [':str'],
               filters    =&gt; ['numeric'],
               max_length =&gt; 2,
           };

           field  'name' =&gt; {
               mixin      =&gt; [':str'],
               pattern    =&gt; qr/^[A-Za-z ]+$/,
               max_length =&gt; 20,
           };

           field  'rating' =&gt; {
               mixin      =&gt; [':str'],
               pattern    =&gt; qr/^\-?\d+$/,
           };

           field  'tag' =&gt; {
               mixin      =&gt; [':str'],
               pattern    =&gt; qr/^(?!evil)\w+/,
               max_length =&gt; 20,
           };

           document 'person' =&gt; {
               'id'                             =&gt; 'id',
               'name'                           =&gt; 'name',
               'company.name'                   =&gt; 'name',
               'company.supervisor.name'        =&gt; 'name',
               'company.supervisor.rating.@.*'  =&gt; 'rating',
               'company.tags.@'                 =&gt; 'name'
           };

           package main;

           my $data = {
               "id"      =&gt; "1234-ABC",
               "name"    =&gt; "Anita Campbell-Green",
               "title"   =&gt; "Designer",
               "company" =&gt; {
                   "name"       =&gt; "House of de Vil",
                   "supervisor" =&gt; {
                       "name"   =&gt; "Cruella de Vil",
                       "rating" =&gt; [
                           {   "support"  =&gt; -9,
                               "guidance" =&gt; -9
                           }
                       ]
                   },
                   "tags" =&gt; [
                       "evil",
                       "cruelty",
                       "dogs"
                   ]
               },
           };

           my $person = MyApp::Person-&gt;new;

           unless ($person-&gt;validate_document(person =&gt; $data)) {
               warn $person-&gt;errors_to_string if $person-&gt;error_count;
           }

           1;

       Additionally, the following is yet another way to validate a document by passing the document
       specification directly instead of by name.

           package MyApp::Person;

           use Validation::Class;

           package main;

           my $data = {
               "id"      =&gt; "1234-ABC",
               "name"    =&gt; "Anita Campbell-Green",
               "title"   =&gt; "Designer",
               "company" =&gt; {
                   "name"       =&gt; "House of de Vil",
                   "supervisor" =&gt; {
                       "name"   =&gt; "Cruella de Vil",
                       "rating" =&gt; [
                           {   "support"  =&gt; -9,
                               "guidance" =&gt; -9
                           }
                       ]
                   },
                   "tags" =&gt; [
                       "evil",
                       "cruelty",
                       "dogs"
                   ]
               },
           };

           my $spec = {
               'id'                            =&gt; { max_length =&gt; 2 },
               'name'                          =&gt; { mixin      =&gt; ':str' },
               'company.name'                  =&gt; { mixin      =&gt; ':str' },
               'company.supervisor.name'       =&gt; { mixin      =&gt; ':str' },
               'company.supervisor.rating.@.*' =&gt; { pattern    =&gt; qr/^(?!evil)\w+/ },
               'company.tags.@'                =&gt; { max_length =&gt; 20 },
           };

           my $person = MyApp::Person-&gt;new;

           unless ($person-&gt;validate_document($spec =&gt; $data)) {
               warn $person-&gt;errors_to_string if $person-&gt;error_count;
           }

           1;

   <b>ensure</b>
       The ensure keyword (or ens) is used to convert a pre-existing method into an auto-validating method. The
       auto-validating method will be registered and function as if it was created using the method keyword.
       The original pre-existing method will be overridden with a modified version which performs the pre and/or
       post validation routines.

           package MyApp::Person;

           use Validation::Class;

           sub register {
               ...
           }

           ensure register =&gt; {
               input  =&gt; ['name', '+email', 'username', '+password', '+password2'],
               output =&gt; ['+id'], # optional output validation, dies on failure
           };

           package main;

           my $person = MyApp::Person-&gt;new(params =&gt; $params);

           if ($person-&gt;register) {
               # handle the successful registration
           }

           1;

       The ensure keyword takes two arguments, the name of the method to be overridden and a hashref of required
       key/value pairs. The hashref may have an input key (e.g. input, input_document, input_profile, or
       input_method).  The `input` key (specifically) must have a value which must be either an arrayref of
       fields to be validated, or a scalar value which matches (a validation profile or auto-validating method
       name). The hashref may also have an output key (e.g. output, output_document, output_profile, or
       output_method).  The `output` key (specifically) must have a value which must be either an arrayref of
       fields to be validated, or a scalar value which matches (a validation profile or auto-validating method
       name). Whether and what the method returns is yours to decide. The method will return undefined if
       validation fails. The ensure keyword wraps and functions much in the same way as the method keyword.

   <b>field</b>
       The field keyword (or fld) registers a data validation rule for reuse and validation in code. The field
       name should correspond with the parameter name expected to be passed to your validation class or
       validated against.

           package MyApp::Person;

           use Validation::Class;

           field 'username' =&gt; {
               required   =&gt; 1,
               min_length =&gt; 1,
               max_length =&gt; 255
           };

       The field keyword takes two arguments, the field name and a hashref of key/values pairs known as
       directives. For more information on pre-defined directives, please review the "list of core directives".

       The field keyword also creates accessors which provide easy access to the field's corresponding parameter
       value(s). Accessors will be created using the field's name as a label having any special characters
       replaced with an underscore.

           # accessor will be created as send_reminders
           field 'send-reminders' =&gt; {
               length =&gt; 1
           };

       Please note that prefixing field names with a double plus-symbol instructs the register to merge your
       declaration with any pre-existing declarations within the same scope (e.g. fields imported via loading
       roles), whereas prefixing field names with a single plus-symbol instructs the register to overwrite any
       pre-existing declarations.

           package MyApp::Person;

           use Validation::Class;

           set role =&gt; 'MyApp::User';

           # append existing field and overwrite directives
           field '++email_address' =&gt; {
               required =&gt; 1
           };

           # redefine existing field
           field '+login' =&gt; {
               required =&gt; 1
           };

           1;

   <b>filter</b>
       The filter keyword (or flt) registers custom filters to be used in your field definitions. It is a means
       of extending the pre-existing filters declared by the "filters directive" before instantiation.

           package MyApp::Person;

           use Validate::Class;

           filter 'flatten' =&gt; sub {
               $_[0] =~ s/[\t\r\n]+/ /g;
               return $_[0];
           };

           field 'biography' =&gt; {
               filters =&gt; ['trim', 'strip', 'flatten']
           };

           1;

       The filter keyword takes two arguments, the name of the filter and a coderef which will be used to filter
       the value the associated field. The coderef is passed the value of the field and that value MUST be
       operated on directly.  The coderef should also return the transformed value.

   <b>load</b>
       The load keyword (or set), which can also be used as a class method, provides options for extending the
       current class by declaring roles, requirements, etc.

       The process of applying roles, requirement, and other settings to the current class mainly involves
       introspecting the namespace's methods and merging relevant parts of the prototype configuration.

   <b>load-classes</b>
       The `classes` (or class) option uses Module::Find to load all child classes (in-all-subdirectories) for
       convenient access through the "class" in Validation::Class::Prototype method, and when introspecting a
       larger application. This option accepts an arrayref or single argument.

           package MyApp;

           use Validation::Class;

           load classes =&gt; ['MyApp::Domain1', 'MyApp::Domain2'];

           package main;

           my $app = MyApp-&gt;new;

           my $person = $app-&gt;class('person'); # return a new MyApp::Person object

           1;

   <b>load-requirements</b>
           package MyApp::User;

           use Validate::Class;

           load requirements =&gt; 'activate';

           package MyApp::Person;

           use Validation::Class;

           load role =&gt; 'MyApp::User';

           sub activate {}

           1;

       The `requirements` (or required) option is used to ensure that if/when the class is used as a role the
       calling class has specific pre-existing methods. This option accepts an arrayref or single argument.

           package MyApp::User;

           use Validate::Class;

           load requirements =&gt; ['activate', 'deactivate'];

           1;

   <b>load-roles</b>
           package MyApp::Person;

           use Validation::Class;

           load role =&gt; 'MyApp::User';

           1;

       The `roles` (or role) option is used to load and inherit functionality from other validation classes.
       These classes should be used and thought-of as roles although they can also be fully-functioning
       validation classes. This option accepts an arrayref or single argument.

           package MyApp::Person;

           use Validation::Class;

           load roles =&gt; ['MyApp::User', 'MyApp::Visitor'];

           1;

   <b>message</b>
       The message keyword (or msg) registers a class-level error message template that will be used in place of
       the error message defined in the corresponding directive class if defined. Error messages can also be
       overridden at the individual field-level as well. See the Validation::Class::Directive::Messages for
       instructions on how to override error messages at the field-level.

           package MyApp::Person;

           use Validation::Class;

           field email_address =&gt; {
               required   =&gt; 1,
               min_length =&gt; 3,
               messages   =&gt; {
                   # field-level error message override
                   min_length =&gt; '%s is not even close to being a valid email address'
               }
           };

           # class-level error message overrides
           message required   =&gt; '%s is needed to proceed';
           message min_length =&gt; '%s needs more characters';

           1;

       The message keyword takes two arguments, the name of the directive whose error message you wish to
       override and a string which will be used to as a template which is feed to sprintf to format the message.

   <b>method</b>
       The method keyword (or mth) is used to register an auto-validating method.  Similar to method signatures,
       an auto-validating method can leverage pre-existing validation rules and profiles to ensure a method has
       the required pre/post-conditions and data necessary for execution.

           package MyApp::Person;

           use Validation::Class;

           method 'register' =&gt; {

               input  =&gt; ['name', '+email', 'username', '+password', '+password2'],
               output =&gt; ['+id'], # optional output validation, dies on failure
               using  =&gt; sub {

                   my ($self, @args) = @_;

                   # do something registrationy
                   $self-&gt;id(...); # set the ID field for output validation

                   return $self;

               }

           };

           package main;

           my $person = MyApp::Person-&gt;new(params =&gt; $params);

           if ($person-&gt;register) {

               # handle the successful registration

           }

           1;

       The method keyword takes two arguments, the name of the method to be created and a hashref of required
       key/value pairs. The hashref may have a `using` key whose value is the coderef to be executed upon
       successful validation. The `using` key is only optional when a pre-existing subroutine has the same name
       or the method being declared prefixed with a dash or dash-process-dash. The following are valid
       subroutine names to be called by the method declaration in absence of a `using` key. Please note, unlike
       the ensure keyword, any pre-existing subroutines will not be wrapped-and-replaced and can be executed
       without validation if called directly.

           sub _name {
               ...
           }

           sub _process_name {
               ...
           }

       The hashref may have an input key (e.g. input, input_document, input_profile, or input_method). The
       `input` key (specifically) must have a value which must be either an arrayref of fields to be validated,
       or a scalar value which matches (a validation profile or auto-validating method name), which will be used
       to perform data validation <b>before</b> the aforementioned coderef has been executed. Whether and what the
       method returns is yours to decide. The method will return undefined if validation fails.

           # alternate usage

           method 'registration' =&gt; {
               input  =&gt; ['name', '+email', 'username', '+password', '+password2'],
               output =&gt; ['+id'], # optional output validation, dies on failure
           };

           sub _process_registration {
               my ($self, @args) = @_;
                   $self-&gt;id(...); # set the ID field for output validation
               return $self;
           }

       Optionally the hashref may also have an output key (e.g. output, output_document, output_profile, or
       output_method). The `output` key (specifically) must have a value which must be either an arrayref of
       fields to be validated, or a scalar value which matches (a validation profile or auto-validating method
       name), which will be used to perform data validation <b>after</b> the aforementioned coderef has been executed.

       Please note that output validation failure will cause the program to die, the premise behind this
       decision is based on the assumption that given successfully validated input a routine's output should be
       predictable and if an error occurs it is most-likely a program error as opposed to a user error.

       See the ignore_failure and report_failure attributes on the prototype to control how method validation
       failures are handled.

   <b>mixin</b>
       The mixin keyword (or mxn) registers a validation rule template that can be applied (or "mixed-in") to
       any field by specifying the mixin directive. Mixin directives are processed first so existing field
       directives will override any directives created by the mixin directive.

           package MyApp::Person;

           use Validation::Class;

           mixin 'boilerplate' =&gt; {
               required   =&gt; 1,
               min_length =&gt; 1,
               max_length =&gt; 255
           };

           field 'username' =&gt; {
               # min_length, max_length, .. required will be overridden
               mixin    =&gt; 'boilerplate',
               required =&gt; 0
           };

       Since version 7.900015, all classes are automatically configured with the following default mixins for
       the sake of convenience:

           mixin ':flg' =&gt; {
               required   =&gt; 1,
               min_length =&gt; 1,
               filters    =&gt; [qw/trim strip numeric/],
               between    =&gt; [0, 1]
           };

           mixin ':num' =&gt; {
               required   =&gt; 1,
               min_length =&gt; 1,
               filters    =&gt; [qw/trim strip numeric/]
           };

           mixin ':str' =&gt; {
               required   =&gt; 1,
               min_length =&gt; 1,
               filters    =&gt; [qw/trim strip/]
           };

       Please note that the aforementioned mixin names are prefixed with a semi-colon but are treated as an
       exception to the rule. Prefixing mixin names with a double plus-symbol instructs the register to merge
       your declaration with any pre-existing declarations within the same scope (e.g. mixins imported via
       loading roles), whereas prefixing mixin names with a single plus-symbol instructs the register to
       overwrite any pre-existing declarations.

           package MyApp::Moderator;

           use Validation::Class;

           set role =&gt; 'MyApp::Person';

           # overwrite and append existing mixin
           mixin '++boilerplate' =&gt; {
               min_symbols =&gt; 1
           };

           # redefine existing mixin
           mixin '+username' =&gt; {
               required =&gt; 1
           };

           1;

       The mixin keyword takes two arguments, the mixin name and a hashref of key/values pairs known as
       directives.

   <b>profile</b>
       The profile keyword (or pro) registers a validation profile (coderef) which as in the traditional use of
       the term is a sequence of validation routines that validates data relevant to a specific action.

           package MyApp::Person;

           use Validation::Class;

           profile 'check_email' =&gt; sub {

               my ($self, @args) = @_;

               if ($self-&gt;email_exists) {
                   my $email = $self-&gt;fields-&gt;get('email');
                   $email-&gt;errors-&gt;add('Email already exists');
                   return 0;
               }

               return 1;

           };

           package main;

           my $user = MyApp::Person-&gt;new(params =&gt; $params);

           unless ($user-&gt;validate_profile('check_email')) {
               # handle failures
           }

           1;

       The profile keyword takes two arguments, a profile name and coderef which will be used to execute a
       sequence of actions for validation purposes.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       The new method instantiates a new class object, it performs a series of actions (magic) required for the
       class to function properly, and for that reason, this method should never be overridden. Use the build
       keyword for hooking into the instantiation process.

       In the event a foreign (pre-existing) `new` method is detected, an `initialize_validator` method will be
       injected into the class containing the code (magic) necessary to normalize your environment.

           package MyApp::Person;

           use Validation::Class;

           # hook
           build sub {

               my ($self, @args) = @_; # on instantiation

           };

           sub new {

               # rolled my own
               my $self = bless {}, shift;

               # execute magic
               $self-&gt;initialize_validator;

           }

           1;

   <b>prototype</b>
       The prototype method (or proto) returns an instance of the associated class prototype. The class
       prototype is responsible for manipulating and validating the data model (the class). It is not likely
       that you'll need to access this method directly, see Validation::Class::Prototype.

           package MyApp::Person;

           use Validation::Class;

           package main;

           my $person = MyApp::Person-&gt;new;

           my $prototype = $person-&gt;prototype;

           1;

</pre><h4><b>PROXY</b> <b>METHODS</b></h4><pre>
       Validation::Class mostly provides sugar functions for modeling your data validation requirements. Each
       class you create is associated with a prototype class which provides the data validation engine and keeps
       your class namespace free from pollution, please see Validation::Class::Prototype for more information on
       specific methods and attributes. Validation::Class injects a few proxy methods into your class which are
       basically aliases to the corresponding prototype class methods, however it is possible to access the
       prototype directly using the proto/prototype methods.

   <b>class</b>
           $self-&gt;class;

       See "class" in Validation::Class::Prototype for full documentation.

   <b>clear_queue</b>
           $self-&gt;clear_queue;

       See "clear_queue" in Validation::Class::Prototype for full documentation.

   <b>error_count</b>
           $self-&gt;error_count;

       See "error_count" in Validation::Class::Prototype for full documentation.

   <b>error_fields</b>
           $self-&gt;error_fields;

       See "error_fields" in Validation::Class::Prototype for full documentation.

   <b>errors</b>
           $self-&gt;errors;

       See "errors" in Validation::Class::Prototype for full documentation.

   <b>errors_to_string</b>
           $self-&gt;errors_to_string;

       See "errors_to_string" in Validation::Class::Prototype for full documentation.

   <b>get_errors</b>
           $self-&gt;get_errors;

       See "get_errors" in Validation::Class::Prototype for full documentation.

   <b>get_fields</b>
           $self-&gt;get_fields;

       See "get_fields" in Validation::Class::Prototype for full documentation.

   <b>get_hash</b>
           $self-&gt;get_hash;

       See "get_hash" in Validation::Class::Prototype for full documentation.

   <b>get_params</b>
           $self-&gt;get_params;

       See "get_params" in Validation::Class::Prototype for full documentation.

   <b>get_values</b>
           $self-&gt;get_values;

       See "get_values" in Validation::Class::Prototype for full documentation.

   <b>fields</b>
           $self-&gt;fields;

       See "fields" in Validation::Class::Prototype for full documentation.

   <b>filtering</b>
           $self-&gt;filtering;

       See "filtering" in Validation::Class::Prototype for full documentation.

   <b>ignore_failure</b>
           $self-&gt;ignore_failure;

       See "ignore_failure" in Validation::Class::Prototype for full documentation.

   <b>ignore_intervention</b>
           $self-&gt;ignore_intervention;

       See "ignore_intervention" in Validation::Class::Prototype for full documentation.

   <b>ignore_unknown</b>
           $self-&gt;ignore_unknown;

       See "ignore_unknown" in Validation::Class::Prototype for full documentation.

   <b>is_valid</b>
           $self-&gt;is_valid;

       See "is_valid" in Validation::Class::Prototype for full documentation.

   <b>param</b>
           $self-&gt;param;

       See "param" in Validation::Class::Prototype for full documentation.

   <b>params</b>
           $self-&gt;params;

       See "params" in Validation::Class::Prototype for full documentation.

   <b>plugin</b>
           $self-&gt;plugin;

       See "plugin" in Validation::Class::Prototype for full documentation.

   <b>queue</b>
           $self-&gt;queue;

       See "queue" in Validation::Class::Prototype for full documentation.

   <b>report_failure</b>
           $self-&gt;report_failure;

       See "report_failure" in Validation::Class::Prototype for full documentation.

   <b>report_unknown</b>
           $self-&gt;report_unknown;

       See "report_unknown" in Validation::Class::Prototype for full documentation.

   <b>reset_errors</b>
           $self-&gt;reset_errors;

       See "reset_errors" in Validation::Class::Prototype for full documentation.

   <b>reset_fields</b>
           $self-&gt;reset_fields;

       See "reset_fields" in Validation::Class::Prototype for full documentation.

   <b>reset_params</b>
           $self-&gt;reset_params;

       See "reset_params" in Validation::Class::Prototype for full documentation.

   <b>set_errors</b>
           $self-&gt;set_errors;

       See "set_errors" in Validation::Class::Prototype for full documentation.

   <b>set_fields</b>
           $self-&gt;set_fields;

       See "set_fields" in Validation::Class::Prototype for full documentation.

   <b>set_params</b>
           $self-&gt;set_params;

       See "set_params" in Validation::Class::Prototype for full documentation.

   <b>set_method</b>
           $self-&gt;set_method;

       See "set_method" in Validation::Class::Prototype for full documentation.

   <b>stash</b>
           $self-&gt;stash;

       See "stash" in Validation::Class::Prototype for full documentation.

   <b>validate</b>
           $self-&gt;validate;

       See "validate" in Validation::Class::Prototype for full documentation.

   <b>validate_document</b>
           $self-&gt;validate_document;

       See "validate_document" in Validation::Class::Prototype for full documentation.

   <b>validate_method</b>
           $self-&gt;validate_method;

       See "validate_method" in Validation::Class::Prototype for full documentation.

   <b>validate_profile</b>
           $self-&gt;validate_profile;

       See "validate_profile" in Validation::Class::Prototype for full documentation.

</pre><h4><b>UPGRADE</b></h4><pre>
       Validation::Class is stable, its feature-set is complete, and is currently in maintenance-only mode, i.e.
       Validation::Class will only be updated with minor enhancements and bug fixes. However, the lessons
       learned will be incorporated into a compelete rewrite uploaded under the namespace Validation::Interface.
       The Validation::Interface fork is designed to have a much simpler API with less options and better
       execution, focused on validating hierarchical data as its primarily objective.

</pre><h4><b>EXTENSIBILITY</b></h4><pre>
       Validation::Class does NOT provide method modifiers but can be easily extended with
       Class::Method::Modifiers.

   <b>before</b>
           before foo =&gt; sub { ... };

       See "before method(s) =&gt; sub { ... }" in Class::Method::Modifiers for full documentation.

   <b>around</b>
           around foo =&gt; sub { ... };

       See "around method(s) =&gt; sub { ... }" in Class::Method::Modifiers for full documentation.

   <b>after</b>
           after foo =&gt; sub { ... };

       See "after method(s) =&gt; sub { ... }" in Class::Method::Modifiers for full documentation.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Validation::Class does not validate blessed objects. If you need a means for validating object types you
       should use a modern object system like Moo, Mouse, or Moose. Alternatively, you could use decoupled
       object validators like Type::Tiny, Params::Validate or Specio.

</pre><h4><b>AUTHOR</b></h4><pre>
       Al Newkirk &lt;<a href="mailto:anewkirk@ana.io">anewkirk@ana.io</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2011 by Al Newkirk.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.36.0                                       2023-06-11                             <u>Validation::<a href="../man3pm/Class.3pm.html">Class</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>