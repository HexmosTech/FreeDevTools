<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X509_STORE_CTX_get_cleanup, X509_STORE_CTX_get_lookup_crls, X509_STORE_CTX_get_lookup_certs,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       X509_STORE_CTX_get_cleanup, X509_STORE_CTX_get_lookup_crls, X509_STORE_CTX_get_lookup_certs,
       X509_STORE_CTX_get_check_policy, X509_STORE_CTX_get_cert_crl, X509_STORE_CTX_get_check_crl,
       X509_STORE_CTX_get_get_crl, X509_STORE_CTX_set_get_crl, X509_STORE_CTX_get_check_revocation,
       X509_STORE_CTX_get_check_issued, X509_STORE_CTX_get_get_issuer, X509_STORE_CTX_get_verify_cb,
       X509_STORE_CTX_set_verify_cb, X509_STORE_CTX_verify_cb, X509_STORE_CTX_print_verify_cb,
       X509_STORE_CTX_set_current_reasons - get and set X509_STORE_CTX components such as verification callback

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/x509_vfy.h&gt;

        typedef int (*X509_STORE_CTX_verify_cb)(int, X509_STORE_CTX *);
        int X509_STORE_CTX_print_verify_cb(int ok, X509_STORE_CTX *ctx);

        X509_STORE_CTX_verify_cb X509_STORE_CTX_get_verify_cb(X509_STORE_CTX *ctx);

        void X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,
                                          X509_STORE_CTX_verify_cb verify_cb);

        X509_STORE_CTX_get_issuer_fn X509_STORE_CTX_get_get_issuer(X509_STORE_CTX *ctx);
        X509_STORE_CTX_check_issued_fn X509_STORE_CTX_get_check_issued(X509_STORE_CTX *ctx);
        X509_STORE_CTX_check_revocation_fn X509_STORE_CTX_get_check_revocation(X509_STORE_CTX *ctx);

        X509_STORE_CTX_get_crl_fn X509_STORE_CTX_get_get_crl(X509_STORE_CTX *ctx);

        void X509_STORE_CTX_set_get_crl(X509_STORE_CTX *ctx,
                                        X509_STORE_CTX_get_crl_fn get_crl);

        X509_STORE_CTX_check_crl_fn X509_STORE_CTX_get_check_crl(X509_STORE_CTX *ctx);
        X509_STORE_CTX_cert_crl_fn X509_STORE_CTX_get_cert_crl(X509_STORE_CTX *ctx);
        X509_STORE_CTX_check_policy_fn X509_STORE_CTX_get_check_policy(X509_STORE_CTX *ctx);
        X509_STORE_CTX_lookup_certs_fn X509_STORE_CTX_get_lookup_certs(X509_STORE_CTX *ctx);
        X509_STORE_CTX_lookup_crls_fn X509_STORE_CTX_get_lookup_crls(X509_STORE_CTX *ctx);
        X509_STORE_CTX_cleanup_fn X509_STORE_CTX_get_cleanup(X509_STORE_CTX *ctx);
        void X509_STORE_CTX_set_current_reasons(X509_STORE_CTX *ctx,
                                                unsigned int current_reasons);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>X509_STORE_CTX_set_verify_cb()</b> sets the verification callback of <b>ctx</b> to <b>verify_cb</b> overwriting any
       existing callback.

       The verification callback can be used to customise the operation of certificate verification, for
       instance by overriding error conditions or logging errors for debugging purposes.

       However, a verification callback is <b>not</b> essential and the default operation is often sufficient.

       The <b>ok</b> parameter to the callback indicates the value the callback should return to retain the default
       behaviour. If it is zero then an error condition is indicated. If it is 1 then no error occurred. If the
       flag <b>X509_V_FLAG_NOTIFY_POLICY</b> is set then <b>ok</b> is set to 2 to indicate the policy checking is complete.

       The <b>ctx</b> parameter to the callback is the <b>X509_STORE_CTX</b> structure that is performing the verification
       operation. A callback can examine this structure and receive additional information about the error, for
       example by calling <b>X509_STORE_CTX_get_current_cert()</b>. Additional application data can be passed to the
       callback via the <b>ex_data</b> mechanism.

       <b>X509_STORE_CTX_print_verify_cb()</b> is a verification callback function that, when a certificate
       verification has failed, adds an entry to the error queue with code
       <b>X509_R_CERTIFICATE_VERIFICATION_FAILED</b> and with diagnostic details, including the most relevant fields of
       the target certificate that failed to verify and, if appropriate, of the available untrusted and trusted
       certificates.

       <b>X509_STORE_CTX_get_verify_cb()</b> returns the value of the current callback for the specific <b>ctx</b>.

       <b>X509_STORE_CTX_get_get_issuer()</b>, <b>X509_STORE_CTX_get_check_issued()</b>,
       <b>X509_STORE_CTX_get_check_revocation()</b>, <b>X509_STORE_CTX_get_get_crl()</b>, <b>X509_STORE_CTX_get_check_crl()</b>,
       <b>X509_STORE_CTX_get_cert_crl()</b>, <b>X509_STORE_CTX_get_check_policy()</b>, <b>X509_STORE_CTX_get_lookup_certs()</b>,
       <b>X509_STORE_CTX_get_lookup_crls()</b> and <b>X509_STORE_CTX_get_cleanup()</b> return the function pointers cached
       from the corresponding <b>X509_STORE</b>, please see <b><a href="../man3/X509_STORE_set_verify.3.html">X509_STORE_set_verify</a></b>(3) for more information.

       <b>X509_STORE_CTX_set_get_crl()</b> sets the function to get the crl for a given certificate <u>x</u>.  When found, the
       crl must be assigned to <u>*crl</u>.  This function must return 0 on failure and 1 on success.  <u>If</u> <u>no</u> <u>function</u>
       <u>to</u> <u>get</u> <u>the</u> <u>issuer</u> <u>is</u> <u>provided,</u> <u>the</u> <u>internal</u> <u>default</u> <u>function</u> <u>will</u> <u>be</u> <u>used</u> <u>instead.</u>

       <b>X509_STORE_CTX_set_current_reasons()</b> is used in conjunction with X509_STORE_CTX_get_crl_fn. The
       X509_STORE_CTX_get_crl_fn callback must use this method to set the reason why the certificate is invalid.

</pre><h4><b>WARNINGS</b></h4><pre>
       In general a verification callback should <b>NOT</b> unconditionally return 1 in all circumstances because this
       will allow verification to succeed no matter what the error. This effectively removes all security from
       the application because <b>any</b> certificate (including untrusted generated ones) will be accepted.

</pre><h4><b>NOTES</b></h4><pre>
       The verification callback can be set and inherited from the parent structure performing the operation. In
       some cases (such as S/MIME verification) the <b>X509_STORE_CTX</b> structure is created and destroyed internally
       and the only way to set a custom verification callback is by inheriting it from the associated
       <b>X509_STORE</b>.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>X509_STORE_CTX_set_verify_cb()</b> does not return a value.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Default callback operation:

        int verify_callback(int ok, X509_STORE_CTX *ctx) {
            return ok;
        }

       Simple example, suppose a certificate in the chain is expired and we wish to continue after this error:

        int verify_callback(int ok, X509_STORE_CTX *ctx) {
            /* Tolerate certificate expiration */
            if (X509_STORE_CTX_get_error(ctx) == X509_V_ERR_CERT_HAS_EXPIRED)
                return 1;
            /* Otherwise don't override */
            return ok;
        }

       More complex example, we don't wish to continue after <b>any</b> certificate has expired just one specific case:

        int verify_callback(int ok, X509_STORE_CTX *ctx)
        {
            int err = X509_STORE_CTX_get_error(ctx);
            X509 *err_cert = X509_STORE_CTX_get_current_cert(ctx);

            if (err == X509_V_ERR_CERT_HAS_EXPIRED) {
                if (check_is_acceptable_expired_cert(err_cert)
                    return 1;
            }
            return ok;
        }

       Full featured logging callback. In this case the <b>bio_err</b> is assumed to be a global logging <b>BIO</b>, an
       alternative would to store a BIO in <b>ctx</b> using <b>ex_data</b>.

        int verify_callback(int ok, X509_STORE_CTX *ctx)
        {
            X509 *err_cert;
            int err, depth;

            err_cert = X509_STORE_CTX_get_current_cert(ctx);
            err = X509_STORE_CTX_get_error(ctx);
            depth = X509_STORE_CTX_get_error_depth(ctx);

            BIO_printf(bio_err, "depth=%d ", depth);
            if (err_cert) {
                X509_NAME_print_ex(bio_err, X509_get_subject_name(err_cert),
                                   0, XN_FLAG_ONELINE);
                BIO_puts(bio_err, "\n");
            }
            else
                BIO_puts(bio_err, "&lt;no cert&gt;\n");
            if (!ok)
                BIO_printf(bio_err, "verify error:num=%d:%s\n", err,
                           X509_verify_cert_error_string(err));
            switch (err) {
            case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:
                BIO_puts(bio_err, "issuer= ");
                X509_NAME_print_ex(bio_err, X509_get_issuer_name(err_cert),
                                   0, XN_FLAG_ONELINE);
                BIO_puts(bio_err, "\n");
                break;
            case X509_V_ERR_CERT_NOT_YET_VALID:
            case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:
                BIO_printf(bio_err, "notBefore=");
                ASN1_TIME_print(bio_err, X509_get_notBefore(err_cert));
                BIO_printf(bio_err, "\n");
                break;
            case X509_V_ERR_CERT_HAS_EXPIRED:
            case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:
                BIO_printf(bio_err, "notAfter=");
                ASN1_TIME_print(bio_err, X509_get_notAfter(err_cert));
                BIO_printf(bio_err, "\n");
                break;
            case X509_V_ERR_NO_EXPLICIT_POLICY:
                policies_print(bio_err, ctx);
                break;
            }
            if (err == X509_V_OK &amp;&amp; ok == 2)
                /* print out policies */

            BIO_printf(bio_err, "verify return:%d\n", ok);
            return(ok);
        }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/X509_STORE_CTX_get_error.3.html">X509_STORE_CTX_get_error</a></b>(3) <b><a href="../man3/X509_STORE_set_verify_cb_func.3.html">X509_STORE_set_verify_cb_func</a></b>(3) <b><a href="../man3/X509_STORE_CTX_get_ex_new_index.3.html">X509_STORE_CTX_get_ex_new_index</a></b>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>X509_STORE_CTX_get_get_issuer()</b>, <b>X509_STORE_CTX_get_check_issued()</b>,
       <b>X509_STORE_CTX_get_check_revocation()</b>, <b>X509_STORE_CTX_get_get_crl()</b>, <b>X509_STORE_CTX_get_check_crl()</b>,
       <b>X509_STORE_CTX_get_cert_crl()</b>, <b>X509_STORE_CTX_get_check_policy()</b>, <b>X509_STORE_CTX_get_lookup_certs()</b>,
       <b>X509_STORE_CTX_get_lookup_crls()</b> and <b>X509_STORE_CTX_get_cleanup()</b> functions were added in OpenSSL 1.1.0.

       <b>X509_STORE_CTX_print_verify_cb()</b> was added in OpenSSL 3.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2009-2023 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                 <u><a href="../man3SSL/X509_STORE_CTX_SET_VERIFY_CB.3SSL.html">X509_STORE_CTX_SET_VERIFY_CB</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>