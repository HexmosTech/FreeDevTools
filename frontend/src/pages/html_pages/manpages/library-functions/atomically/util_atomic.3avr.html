<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>util_atomic - <util/atomic.h> Atomically and Non-Atomically Executed Code Blocks</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/avr-libc">avr-libc_2.2.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       util_atomic - &lt;util/atomic.h&gt; Atomically and Non-Atomically Executed Code Blocks

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Macros</b>
       #define <b>ATOMIC_BLOCK</b>(type)
       #define <b>NONATOMIC_BLOCK</b>(type)
       #define <b>ATOMIC_RESTORESTATE</b>
       #define <b>ATOMIC_FORCEON</b>
       #define <b>NONATOMIC_RESTORESTATE</b>
       #define <b>NONATOMIC_FORCEOFF</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       #include &lt;util/atomic.h&gt;

       <b>Note</b>
           The macros in this header file require the ISO/IEC 9899:1999 ('ISO C99') feature of for loop
           variables that are declared inside the for loop itself. For that reason, this header file can only be
           used if the standard level of the compiler (option --std=) is set to either c99, gnu99 or higher.

       The macros in this header file deal with code blocks that are guaranteed to be executed Atomically or
       Non-Atomically. The term 'Atomic' in this context refers to the inability of the respective code to be
       interrupted.

       These macros operate via automatic manipulation of the Global Interrupt Status (I) bit of the SREG
       register. Exit paths from both block types are all managed automatically without the need for special
       considerations, i.e. the interrupt status will be restored to the same value it had when entering the
       respective block (unless ATOMIC_FORCEON or NONATOMIC_FORCEOFF are used).

       <b>Warning</b>
           The features in this header are implemented by means of a for loop. This means that commands like
           break and continue that are located in an atomic block refer to the atomic for loop, not to a loop
           construct that hosts the atomic block.

       A typical example that requires atomic access is a 16 (or more) bit variable that is shared between the
       main execution path and an ISR. While declaring such a variable as volatile ensures that the compiler
       will not optimize accesses to it away, it does not guarantee atomic access to it. Assuming the following
       example:

       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;avr/interrupt.h&gt;
       #include &lt;avr/io.h&gt;

       volatile uint16_t ctr;

       ISR(TIMER1_OVF_vect)
       {
         ctr--;
       }

       ...
       int
       main(void)
       {
          ...
          ctr = 0x200;
          start_timer();
          while (ctr != 0)
            // wait
              ;
          ...
       }

       There is a chance where the main context will exit its wait loop when the variable ctr just reached the
       value 0xFF. This happens because the compiler cannot natively access a 16-bit variable atomically in an
       8-bit CPU. So the variable is for example at 0x100, the compiler then tests the low byte for 0, which
       succeeds. It then proceeds to test the high byte, but that moment the ISR triggers, and the main context
       is interrupted. The ISR will decrement the variable from 0x100 to 0xFF, and the main context proceeds. It
       now tests the high byte of the variable which is (now) also 0, so it concludes the variable has reached
       0, and terminates the loop.

       Using the macros from this header file, the above code can be rewritten like:

       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;avr/interrupt.h&gt;
       #include &lt;avr/io.h&gt;
       #include &lt;util/atomic.h&gt;

       volatile uint16_t ctr;

       ISR(TIMER1_OVF_vect)
       {
         ctr--;
       }

       ...
       int
       main(void)
       {
          ...
          ctr = 0x200;
          start_timer();
          sei();
          uint16_t ctr_copy;
          do
          {
            ATOMIC_BLOCK(ATOMIC_FORCEON)
            {
              ctr_copy = ctr;
            }
          }
          while (ctr_copy != 0);
          ...
       }

       This will install the appropriate interrupt protection before accessing variable ctr, so it is guaranteed
       to be consistently tested. If the global interrupt state were uncertain before entering the <b>ATOMIC_BLOCK</b>,
       it should be executed with the parameter <b>ATOMIC_RESTORESTATE</b> rather than <b>ATOMIC_FORCEON</b>.

       See <b>Problems</b> <b>with</b> <b>reordering</b> <b>code</b> for things to be taken into account with respect to compiler
       optimizations.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>ATOMIC_BLOCK(type)</b>
       Creates a block of code that is guaranteed to be executed atomically. Upon entering the block the Global
       Interrupt Status flag in SREG is disabled, and re-enabled upon exiting the block from any exit path.

       Two possible macro parameters are permitted, <b>ATOMIC_RESTORESTATE</b> and <b>ATOMIC_FORCEON</b>.

   <b>#define</b> <b>ATOMIC_FORCEON</b>
       This is a possible parameter for <b>ATOMIC_BLOCK</b>. When used, it will cause the ATOMIC_BLOCK to force the
       state of the SREG register on exit, enabling the Global Interrupt Status flag bit. This saves a small
       amount of flash space, a register, and one or more processor cycles, since the previous value of the SREG
       register does not need to be saved at the start of the block.

       Care should be taken that ATOMIC_FORCEON is only used when it is known that interrupts are enabled before
       the block's execution or when the side effects of enabling global interrupts at the block's completion
       are known and understood.

   <b>#define</b> <b>ATOMIC_RESTORESTATE</b>
       This is a possible parameter for <b>ATOMIC_BLOCK</b>. When used, it will cause the ATOMIC_BLOCK to restore the
       previous state of the SREG register, saved before the Global Interrupt Status flag bit was disabled. The
       net effect of this is to make the ATOMIC_BLOCK's contents guaranteed atomic, without changing the state
       of the Global Interrupt Status flag when execution of the block completes.

   <b>#define</b> <b>NONATOMIC_BLOCK(type)</b>
       Creates a block of code that is executed non-atomically. Upon entering the block the Global Interrupt
       Status flag in SREG is enabled, and disabled upon exiting the block from any exit path. This is useful
       when nested inside ATOMIC_BLOCK sections, allowing for non-atomic execution of small blocks of code while
       maintaining the atomic access of the other sections of the parent ATOMIC_BLOCK.

       Two possible macro parameters are permitted, <b>NONATOMIC_RESTORESTATE</b> and <b>NONATOMIC_FORCEOFF</b>.

   <b>#define</b> <b>NONATOMIC_FORCEOFF</b>
       This is a possible parameter for <b>NONATOMIC_BLOCK</b>. When used, it will cause the NONATOMIC_BLOCK to force
       the state of the SREG register on exit, disabling the Global Interrupt Status flag bit. This saves a
       small amout of flash space, a register, and one or more processor cycles, since the previous value of the
       SREG register does not need to be saved at the start of the block.

       Care should be taken that NONATOMIC_FORCEOFF is only used when it is known that interrupts are disabled
       before the block's execution or when the side effects of disabling global interrupts at the block's
       completion are known and understood.

   <b>#define</b> <b>NONATOMIC_RESTORESTATE</b>
       This is a possible parameter for <b>NONATOMIC_BLOCK</b>. When used, it will cause the NONATOMIC_BLOCK to restore
       the previous state of the SREG register, saved before the Global Interrupt Status flag bit was enabled.
       The net effect of this is to make the NONATOMIC_BLOCK's contents guaranteed non-atomic, without changing
       the state of the Global Interrupt Status flag when execution of the block completes.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for AVR-LibC from the source code.

AVR-LibC                                          Version 2.2.1                                <u><a href="../man3avr/util_atomic.3avr.html">util_atomic</a></u>(3avr)
</pre>
 </div>
</div></section>
</div>
</body>
</html>