<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP::DAV::Response - represents a WebDAV HTTP Response (ala HTTP::Response)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhttp-dav-perl">libhttp-dav-perl_0.50-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTTP::DAV::Response - represents a WebDAV HTTP Response (ala HTTP::Response)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       require HTTP::DAV::Response;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The HTTP::DAV::Response class encapsulates HTTP style responses.  A response consists of a response line,
       some headers, and (potentially empty) content.

       HTTP::DAV::Response is a subclass of "HTTP::Response" and therefore inherits its methods.
       (HTTP::Response in turn inherits it's methods from "HTTP::Message").

       Therefore, this class actually inherits a rich library of functions. You are more likely wanting to read
       the "HTTP::Response" class as opposed to this class.

       Instances of this class are usually created by a "HTTP::DAV::Resource" object after it has performed some
       request (such as get, lock, delete, etc). You use the object to analyse the success or otherwise of the
       request.

       HTTP::DAV::Response was created to handle two extra functions that normal HTTP Responses don't require:

        - WebDAV responses have 6 extra error codes: 102, 207, 422, 423, 424 and 507. Older versions of the LWP's C&lt;HTTP::Status&gt; class did not have these extra codes. These were added.

        - WebDAV responses can actually contain more than one response (and often DO contain more than one) in the form of a "Multistatus". These multistatus responses come in the form of an XML document. HTTP::DAV::Response can accurately parse these XML responses and emulate the normal of the C&lt;HTTP::Response&gt;.

       HTTP::DAV::Response transparently implements these extra features without the user having to be aware, so
       you really should be reading the "HTTP::Response" documentation for most of the things you want to do
       (have I already said that?).

       There are only a handful of custom functions that HTTP::DAV::Response returns and those are to handle
       multistatus requests, messages() and codes().

       The six extra status codes that DAV servers can be returned in an HTTP Response are:
         102 =&gt; "Processing. Server has accepted the request, but has not yet completed it",
         207 =&gt; "Multistatus",
         422 =&gt; "Unprocessable Entity. Bad client XML sent?",
         423 =&gt; "Locked. The source or destination resource is locked",
         424 =&gt; "Failed Dependency",
         507 =&gt; "Insufficient Storage. The server is unable to store the request",

       See "HTTP::Status" for the rest.

</pre><h4><b>HANDLING</b> <b>A</b> <b>MULTISTATUS</b></h4><pre>
       So, many DAV requests may return a multistatus ("207 multistatus") instead of, say, "200 OK" or "403
       Forbidden".

       The HTTP::DAV::Response object stores each "response" sent back in the multistatus. You access them by
       array number.

       The following code snippet shows what you will normally want to do:

       ...  $response = $resource-&gt;<b>lock()</b>;

       if ( $response-&gt;<b>is_multistatus()</b> ) {

          foreach $num ( 0 .. $response-&gt;response_count() ) {
             ($err_code,$mesg,$url,$desc) =
                $response-&gt;response_bynum($num);
             print "$mesg ($err_code) for $url\n";
          }
       }

       Would produce something like this:
          Failed Dependency (424) for /test/directory
          Locked (423) for /test/directory/file3

       This says that we couldn't lock /test/directory because file3 which exists inside is already locked by
       somebody else.

</pre><h4><b>METHODS</b></h4><pre>
       <b>is_multistatus</b>
           This function takes no arguments and returns a 1 or a 0.

           For example: if ($response-&gt;<b>is_multistatus()</b> ) { }

           If  the  HTTP  reply  had "207 Multistatus" in the header then that indicates that there are multiple
           status messages in the XML content that was returned.

           In this event, you may be interested in knowing what the individual messages were.  To  do  this  you
           would then use "messages".

       <b>response_count</b>
           Takes  no  arguments  and  returns  "the  number of error responses -1" that we got.  Why -1? Because
           usually you will want to use this like an array operator:

           foreach $num ( 0 .. $response-&gt;<b>response_count()</b> ) {
              print $response-&gt;<b>message_bynum()</b>; }

       <b>response_bynum</b>
           Takes one argument, the "response number" that you're interested in. And returns an array of details:

              ($code,$message,$url,$description) = <a href="../man2/response_bynum.2.html">response_bynum</a>(2);

           where
              $code - is the HTTP error code (e.g. 403, 423, etc).
              $message - is the associated message for that error code.
              $url - is the url that this error applies to (recall that there can be multiple  responses  within
           one response and they all relate to one URL)
              $description - is server's attempt at an english description of what happened.

       <b>code_bynum</b>
           Takes one argument, the "response number" that you're interested in, and returns it's code. E.g:

             $code = $response-&gt;<a href="../man1/code_bynum.1.html">code_bynum</a>(1);

           See response_bynum()

       <b>message_bynum</b>
           Takes one argument, the "response number" that you're interested in, and returns it's message. E.g:

             $code = $response-&gt;<a href="../man1/message_bynum.1.html">message_bynum</a>(1);

           See response_bynum()

       <b>url_bynum</b>
           Takes one argument, the "response number" that you're interested in, and returns it's url. E.g:

             $code = $response-&gt;<a href="../man1/message_bynum.1.html">message_bynum</a>(1);

           See response_bynum()

       <b>description_bynum</b>
           Takes  one  argument,  the "response number" that you're interested in, and returns it's description.
           E.g:

             $code = $response-&gt;<a href="../man1/message_description.1.html">message_description</a>(1);

           See response_bynum()

       <b>messages</b>
           Takes no arguments and returns all of the messages returned in a multistatus response. If called in a
           scalar context then all of the messages will be returned joined together by newlines. If called in an
           array context the messages will be returned as an array.

           $messages = $response-&gt;<b>messages()</b>; e.g. $messages eq "Forbidden\nLocked";

           @messages = $response-&gt;<b>messages()</b>; e.g. @messages eq ["Forbidden", "Locked"];

           This routine is a variant on the standard "HTTP::Response" message().

perl v5.40.0                                       2024-10-28                           <u>HTTP::DAV::<a href="../man3pm/Response.3pm.html">Response</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>