<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSSP sa - Socket Abstraction</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libossp-sa-dev">libossp-sa-dev_1.2.6-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>OSSP</b> <b>sa</b> - Socket Abstraction

</pre><h4><b>VERSION</b></h4><pre>
       <b>OSSP</b> <b>sa</b> <b>1.2.5</b> <b>(02-Oct-2005)</b>

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>Abstract</b> <b>Data</b> <b>Types</b>:
           sa_rc_t, sa_addr_t, sa_t.

       <b>Address</b> <b>Object</b> <b>Operations</b>:
           sa_addr_create, sa_addr_destroy.

       <b>Address</b> <b>Operations</b>:
           sa_addr_u2a, sa_addr_s2a, sa_addr_a2u, sa_addr_a2s, sa_addr_match.

       <b>Socket</b> <b>Object</b> <b>Operations</b>:
           sa_create, sa_destroy.

       <b>Socket</b> <b>Parameter</b> <b>Operations</b>:
           sa_type, sa_timeout, sa_buffer, sa_option, sa_syscall.

       <b>Socket</b> <b>Connection</b> <b>Operations</b>:
           sa_bind, sa_connect, sa_listen, sa_accept, sa_getremote, sa_getlocal, sa_shutdown.

       <b>Socket</b> <b>Input/Output</b> <b>Operations</b> <b>(Stream</b> <b>Communication)</b>:
           sa_getfd, sa_read, sa_readln, sa_write, sa_writef, sa_flush.

       <b>Socket</b> <b>Input/Output</b> <b>Operations</b> <b>(Datagram</b> <b>Communication)</b>:
           sa_recv, sa_send, sa_sendf.

       <b>Socket</b> <b>Error</b> <b>Handling</b>:
           sa_error.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>OSSP</b> <b>sa</b> is an abstraction library for the Unix <u>Socket</u> networking application programming interface (API),
       featuring  stream  and datagram oriented communication over <u>Unix</u> <u>Domain</u> and <u>Internet</u> <u>Domain</u> (TCP and UDP)
       sockets.

       It provides the following key features:

       <b>Stand-Alone,</b> <b>Self-Contained,</b> <b>Embeddable</b>
           Although there are various Open Source  libraries  available  which  provide  a  similar  abstraction
           approach,  they  all  either  lack  important  features  or  unfortunately  depend on other companion
           libraries. <b>OSSP</b> <b>sa</b> fills this gap by providing all important features (see  following  points)  as  a
           stand-alone  and  fully  self-contained library. This way <b>OSSP</b> <b>sa</b> can be trivially embedded as a sub-
           library into other libraries. It especially provides additional support for namespace-safe  embedding
           of its API in order to avoid symbol conflicts (see SA_PREFIX in <u>sa.h</u>).

       <b>Address</b> <b>Abstraction</b>
           Most of the ugliness in the Unix <u>Socket</u> API is the necessity to have to deal with the various address
           structures  (struct  sockaddr_xx)  which  exist because of both the different communication types and
           addressing schemes. <b>OSSP</b> <b>sa</b> fully hides this  by  providing  an  abstract  and  opaque  address  type
           (sa_addr_t)  together  with  utility functions which allow one to convert from the traditional struct
           sockaddr or URI specification to the sa_addr_t and vice versa without having  to  deal  with  special
           cases  related  to the underlying particular struct sockaddr_xx. <b>OSSP</b> <b>sa</b> support <u>Unix</u> <u>Domain</u> and both
           IPv4 and IPv6 <u>Internet</u> <u>Domain</u> addressing.

       <b>Type</b> <b>Abstraction</b>
           Some other subtle details in the Unix <u>Socket</u> API make  the  life  hard  in  practice:  socklen_t  and
           ssize_t. These two types originally were (and on some platforms still are) plain integers or unsigned
           integers  while  POSIX  later  introduced own types for them (and even revised these types after some
           time again). This is nasty, because for 100% type-correct API usage (especially important  on  64-bit
           machines  where  pointers  to  different  integer types make trouble), every application has to check
           whether the newer types exists, and if not provide own definitions which map to  the  still  actually
           used integer type on the underlying platform. <b>OSSP</b> <b>sa</b> hides most of this in its API and for socklen_t
           provides  a  backward-compatibility definition.  Instead of ssize_t it can use size_t because <b>OSSP</b> <b>sa</b>
           does not use traditional Unix return code semantics.

       <b>I/O</b> <b>Timeouts</b>
           Each I/O function in <b>OSSP</b> <b>sa</b> is aware of timeouts (set by <u><a href="../man3/sa_timeout.3.html">sa_timeout</a></u>(3)), i.e.,  all  I/O  operations
           return  SA_ERR_TMT  if the timeout expired before the I/O operation was able to succeed.  This allows
           one to easily program less-blocking network services.  <b>OSSP</b> <b>sa</b> internally implements  these  timeouts
           either  through  the  SO_{SND,RCV}TIMEO  feature  on  more  modern  <u>Socket</u> implementations or through
           traditional <u><a href="../man2/select.2.html">select</a></u>(2). This way high performance is achieved  on  modern  platforms  while  the  full
           functionality still is available on older platforms.

       <b>I/O</b> <b>Stream</b> <b>Buffering</b>
           If  <b>OSSP</b>  <b>sa</b> is used for stream communication, internally all I/O operations can be performed through
           input and/or output buffers (set by <u><a href="../man3/sa_buffer.3.html">sa_buffer</a></u>(3)) for achieving higher I/O performance by  doing  I/O
           operations on larger aggregated messages and with less required system calls. Additionally if <b>OSSP</b> <b>sa</b>
           is  used  for  stream communication, for convenience reasons line-oriented reading (<u><a href="../man3/sa_readln.3.html">sa_readln</a></u>(3)) and
           formatted writing (see <u><a href="../man3/sa_writef.3.html">sa_writef</a></u>(3)) is provided, modelled after  STDIO's  <u><a href="../man3/fgets.3.html">fgets</a></u>(3)  and  <u><a href="../man3/fprintf.3.html">fprintf</a></u>(3).
           Both features fully leverage from the I/O buffering.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>OSSP</b> <b>sa</b> uses three data types in its API:

       <b>sa_rc_t</b> (Return Code Type)
           This is an exported enumerated integer type with the following possible values:

            SA_OK       Everything Ok
            SA_ERR_ARG  Invalid Argument
            SA_ERR_USE  Invalid Use Or Context
            SA_ERR_MEM  Not Enough Memory
            SA_ERR_MTC  Matching Failed
            SA_ERR_EOF  End Of Communication
            SA_ERR_TMT  Communication Timeout
            SA_ERR_SYS  Operating System Error (see errno)
            SA_ERR_IMP  Implementation Not Available
            SA_ERR_INT  Internal Error

       <b>sa_addr_t</b> (Socket Address Abstraction Type)
           This  is an opaque data type representing a socket address.  Only pointers to this abstract data type
           are used in the API.

       <b>sa_t</b> (Socket Abstraction Type)
           This is an opaque data type representing a socket.  Only pointers to this abstract data type are used
           in the API.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       <b>OSSP</b> <b>sa</b> provides a bunch of API functions, all modelled after the same prototype:

       sa_rc_t <b>sa_</b><u>name</u>(sa_[addr_]_t *, ...)

       This means, every function returns sa_rc_t to indicate its success (SA_OK)  or  failure  (SA_ERR_<u>XXX</u>)  by
       returning  a return code (the corresponding describing text can be determined by passing this return code
       to <u><a href="../man3/sa_error.3.html">sa_error</a></u>(3)). Each function name starts with the common prefix sa_ and receives a sa_t (or  sa_addr_t)
       object handle on which it operates as its first argument.

       <b>Address</b> <b>Object</b> <b>Operations</b>

       This API part provides operations for the creation and destruction of address abstraction sa_addr_t.

       sa_rc_t <b>sa_addr_create</b>(sa_addr_t **<u>saa</u>);
           Create a socket address abstraction object.  The object is stored in <u>saa</u> on success.

           Example: sa_addr_t *saa; sa_addr_create(&amp;saa);

       sa_rc_t <b>sa_addr_destroy</b>(sa_addr_t *<u>saa</u>);
           Destroy a socket address abstraction object.  The object <u>saa</u> is invalid after this call succeeded.

           Example: sa_addr_destroy(saa);

       <b>Address</b> <b>Operations</b>

       This API part provides operations for working with the address abstraction sa_addr_t.

       sa_rc_t <b>sa_addr_u2a</b>(sa_addr_t *<u>saa</u>, const char *<u>uri</u>, ...);
           Import  an  address  into  by  converting  from  an  URI  specification  to the corresponding address
           abstraction.

           The   supported   syntax   for   <u>uri</u>   is:   "unix:<u>path</u>"    for    <u>Unix</u>    <u>Domain</u>    addresses    and
           "inet://<u>addr</u>:<u>port</u>[#<u>protocol</u>]" for <u>Internet</u> <u>Domain</u> addresses.

           In  the URI, <u>path</u> can be an absolute or relative filesystem path to an existing or not-existing file.
           <u>addr</u> can be an IPv4 address in dotted decimal notation  ("127.0.0.1"),  an  IPv6  address  in  colon-
           separated  (optionally  abbreviated)  hexadecimal  notation  ("::1")  or  a  to-be-resolved  hostname
           ("localhost.example.com"). <u>port</u> has to be either a decimal port in the range 1...65535 or a port name
           ("smtp"). If <u>port</u> is specified as a name, it is resolved as a TCP port by default. To force resolving
           a <u>port</u> name via a particular protocol, <u>protocol</u> can be specified as either "tcp" or "udp".

           The result is stored in <u>saa</u> on success.

           Example: sa_addr_u2a(saa, "inet://192.168.0.1:smtp");

       sa_rc_t <b>sa_addr_s2a</b>(sa_addr_t *<u>saa</u>, const struct sockaddr *<u>sabuf</u>, socklen_t <u>salen</u>);
           Import an address by converting from a  traditional  struct  sockaddr  object  to  the  corresponding
           address abstraction.

           The accepted addresses for <u>sabuf</u> are: struct sockaddr_un (AF_LOCAL), struct sockaddr_in (AF_INET) and
           struct  sockaddr_in6  (AF_INET6).  The  <u>salen</u>  is  the  corresponding  sizeof(...)  of the particular
           underyling structure.

           The result is stored in <u>saa</u> on success.

           Example: sockaddr_in in; sa_addr_s2a(saa, (struct sockaddr *)&amp;in, (socklen_t)sizeof(in));

       sa_rc_t <b>sa_addr_a2u</b>(sa_addr_t *<u>saa</u>, char **<u>uri</u>);
           Export an address by converting from the address abstraction to the corresponding URI specification.

           The result is a string of the form "unix:<u>path</u>" for <u>Unix</u> <u>Domain</u> addresses and  "inet://<u>addr</u>:<u>port</u>"  for
           <u>Internet</u>  <u>Domain</u>  addresses.  Notice  that  <u>addr</u> and <u>port</u> are returned in numerical (unresolved) way.
           Additionally, because usually one cannot map bidirectionally between TCP or UDP port  names  and  the
           numerical value, there is no distinction between TCP and UDP here.

           The result is stored in <u>uri</u> on success.  The caller has to <u><a href="../man3/free.3.html">free</a></u>(3) the <u>uri</u> buffer later.

           Example: char *uri; sa_addr_a2u(saa, &amp;uri);

       sa_rc_t <b>sa_addr_a2s</b>(sa_addr_t *<u>saa</u>, struct sockaddr **<u>sabuf</u>, socklen_t *<u>salen</u>);
           Export  an address by converting from the address abstraction to the corresponding traditional struct
           sockaddr object.

           The result is one of the following  particular  underlying  address  structures:  struct  sockaddr_un
           (AF_LOCAL), struct sockaddr_in (AF_INET) and struct sockaddr_in6 (AF_INET6).

           The  result  is  stored  in  <u>sabuf</u>  and <u>salen</u> on success.  The caller has to <u><a href="../man3/free.3.html">free</a></u>(3) the <u>sabuf</u> buffer
           later.

           Example: struct sockaddr sabuf, socklen_t salen; sa_addr_a2s(saa, &amp;sa, &amp;salen);

       sa_rc_t <b>sa_addr_match</b>(sa_addr_t *<u>saa1</u>, sa_addr_t *<u>saa2</u>, size_t <u>prefixlen</u>);
           Match two address abstractions up to a specified prefix.

           This compares the addresses <u>saa1</u> and <u>saa2</u> by only taking the prefix part  of  length  <u>prefixlen</u>  into
           account.  <u>prefixlen</u>  is  number of filesystem path characters for <u>Unix</u> <u>Domain</u> addresses and number of
           bits for <u>Internet</u> <u>Domain</u> addresses. In case of <u>Internet</u> <u>Domain</u> addresses, the addresses  are  matched
           in  network  byte  order  and  the port (counting as an additional bit/item of length 1) is virtually
           appended to the address for matching. Specifying <u>prefixlen</u> as -1 means  matching  the  whole  address
           (but  without  the  virtually  appended  port) without having to know how long the underlying address
           representation (length of path for Unix Domain addresses, 32+1 [IPv4] or 128+1  [IPv6]  for  Internet
           Domain addresses) is. Specifying <u>prefixlen</u> as -2 is equal to -1 but additionally the port is matched,
           too.

           This  especially  can be used to implement Access Control Lists (ACL) without having to fiddle around
           with the underlying representation.  For this, make <u>saa1</u> the to be  checked  address  and  <u>saa2</u>  plus
           <u>prefixlen</u> the ACL pattern as shown in the following example.

           Example:

            sa_addr_t *srv_sa;
            sa_addr_t *clt_saa;
            sa_t      *clt_sa;
            sa_addr_t *acl_saa;
            char      *acl_addr = "192.168.0.0";
            int        acl_len  = 24;
            ...
            sa_addr_u2a(&amp;acl_saa, "inet://%s:0", acl_addr);
            ...
            while (sa_accept(srv_sa, &amp;clt_saa, &amp;clt_sa) == SA_OK) {
                if (sa_addr_match(clt_saa, acl_saa, acl_len) != SA_OK) {
                    /* connection refused */
                    ...
                    sa_addr_destroy(clt_saa);
                    sa_destroy(clt_sa);
                    continue;
                }
                ...
            }
            ...

       <b>Socket</b> <b>Object</b> <b>Operations</b>

       This API part provides operations for the creation and destruction of socket abstraction sa_t.

       sa_rc_t <b>sa_create</b>(sa_t **<u>sa</u>);
           Create a socket abstraction object.  The object is stored in <u>sa</u> on success.

           Example: sa_t *sa; sa_create(&amp;sa);

       sa_rc_t <b>sa_destroy</b>(sa_t *<u>sa</u>);
           Destroy a socket abstraction object.  The object <u>sa</u> is invalid after this call succeeded.

           Example: sa_destroy(sa);

       <b>Socket</b> <b>Parameter</b> <b>Operations</b>

       This API part provides operations for parameterizing the socket abstraction sa_t.

       sa_rc_t <b>sa_type</b>(sa_t *<u>sa</u>, sa_type_t <u>type</u>);
           Assign a particular communication protocol type to the socket abstraction object.

           A  socket  can  only be assigned a single protocol type at any time.  Nevertheless one can switch the
           type of a socket abstraction object at any time in order to reuse it for a  different  communication.
           Just  keep  in  mind  that  switching the type will stop a still ongoing communication by closing the
           underlying socket.

           Possible values for <u>type</u> are SA_TYPE_STREAM (stream  communication)  and  SA_TYPE_DATAGRAM  (datagram
           communication). The default communication protocol type is SA_TYPE_STREAM.

           Example: sa_type(sa, SA_TYPE_STREAM);

       sa_rc_t <b>sa_timeout</b>(sa_t *<u>sa</u>, sa_timeout_t <u>id</u>, long <u>sec</u>, long <u>usec</u>);
           Assign one or more communication timeouts to the socket abstraction object.

           Possible values for <u>id</u> are: SA_TIMEOUT_ACCEPT (affecting <u><a href="../man3/sa_accept.3.html">sa_accept</a></u>(3)), SA_TIMEOUT_CONNECT (affecting
           <u><a href="../man3/sa_connect.3.html">sa_connect</a></u>(3)),   SA_TIMEOUT_READ   (affecting   <u><a href="../man3/sa_read.3.html">sa_read</a></u>(3),   <u><a href="../man3/sa_readln.3.html">sa_readln</a></u>(3)   and   <u><a href="../man3/sa_recv.3.html">sa_recv</a></u>(3))   and
           SA_TIMEOUT_WRITE (affecting <u><a href="../man3/sa_write.3.html">sa_write</a></u>(3), <u><a href="../man3/sa_writef.3.html">sa_writef</a></u>(3), <u><a href="../man3/sa_send.3.html">sa_send</a></u>(3), and <u><a href="../man3/sa_sendf.3.html">sa_sendf</a></u>(3)). Additionally you
           can set all four timeouts at once by using SA_TIMEOUT_ALL.  The  default  is  that  no  communication
           timeouts are used which is equal to <u>sec</u>=0/<u>usec</u>=0.

           Example: sa_timeout(sa, SA_TIMEOUT_ALL, 30, 0);

       sa_rc_t <b>sa_buffer</b>(sa_t *<u>sa</u>, sa_buffer_t <u>id</u>, size_t <u>size</u>);
           Assign I/O communication buffers to the socket abstraction object.

           Possible   values   for   <u>id</u>   are:   SA_BUFFER_READ  (affecting  <u><a href="../man3/sa_read.3.html">sa_read</a></u>(3)  and  <u><a href="../man3/sa_readln.3.html">sa_readln</a></u>(3))  and
           SA_BUFFER_WRITE (affecting <u><a href="../man3/sa_write.3.html">sa_write</a></u>(3) and  <u><a href="../man3/sa_writef.3.html">sa_writef</a></u>(3)).  The  default  is  that  no  communication
           buffers are used which is equal to <u>size</u>=0.

           Example: sa_buffer(sa, SA_BUFFER_READ, 16384);

       sa_rc_t <b>sa_option</b>(sa_t *<u>sa</u>, sa_option_t <u>id</u>, ...);
           Adjust various options of the socket abstraction object.

           The  adjusted  option  is controlled by <u>id</u>. The number and type of the expected following argument(s)
           are dependent on the particular option.  Currently the  following  options  are  implemented  (option
           arguments in parenthesis):

           SA_OPTION_NAGLE  (int  <u>yesno</u>) for enabling (<u>yesno</u>=1) or disabling (<u>yesno</u> == 0) Nagle's Algorithm (see
           RFC898 and TCP_NODELAY of <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2)).

           SA_OPTION_LINGER (int <u>amount</u>) for enabling (<u>amount</u> == <u>seconds</u>  !=  0)  or  disabling  (<u>amount</u>  ==  0)
           lingering  on  close (see SO_LINGER of <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2)). Notice: using <u>seconds</u> &gt; 0 results in a regular
           (maximum of <u>seconds</u> lasting) lingering on close while using <u>seconds</u> &lt; 0 results in the  special  case
           of a TCP RST based connection termination on close.

           SA_OPTION_REUSEADDR  (int  <u>yesno</u>) for enabling (<u>yesno</u> == 1) or disabling (<u>yesno</u> == 0) the reusability
           of the address on binding via <u><a href="../man3/sa_bind.3.html">sa_bind</a></u>(3) (see SO_REUSEADDR of <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2)).

           SA_OPTION_REUSEPORT (int <u>yesno</u>) for enabling (<u>yesno</u> == 1) or disabling (<u>yesno</u> == 0)  the  reusability
           of the port on binding via <u><a href="../man3/sa_bind.3.html">sa_bind</a></u>(3) (see SO_REUSEPORT of <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2)).

           SA_OPTION_NONBLOCK  (int  <u>yesno</u>) for enabling (<u>yesno</u> == 1) or disabling (<u>yesno</u> == 0) non-blocking I/O
           mode (see O_NONBLOCK of <u><a href="../man2/fcntl.2.html">fcntl</a></u>(2)).

           Example: sa_option(sa, SA_OPTION_NONBLOCK, 1);

       sa_rc_t <b>sa_syscall</b>(sa_t *<u>sa</u>, sa_syscall_t <u>id</u>, void (*<u>fptr</u>)(), void *<u>fctx</u>);
           Divert I/O communication related system calls to user supplied callback functions.

           This allows you to override mostly all I/O related system calls <b>OSSP</b>  <b>sa</b>  internally  performs  while
           communicating.  This can be used to adapt <b>OSSP</b> <b>sa</b> to different run-time environments and requirements
           without having to change the source code. Usually this is used to divert  the  system  calls  to  the
           variants of a user-land multithreading facility like <b>GNU</b> <b>Pth</b>.

           The  function  supplied  as <u>fptr</u> is required to fulfill the API of the replaced system call, i.e., it
           has to have the same prototype (if <u>fctx</u> is NULL). If <u>fctx</u> is not  NULL,  this  prototype  has  to  be
           extended  to  accept an additional first argument of type void * which receives the value of <u>fctx</u>. It
           is up to the callback function whether to pass the call through to the replaced actual system call or
           not.

           Possible values for <u>id</u> are (expected prototypes behind <u>fptr</u> are given in parenthesis):

           <b>SA_SYSCALL_CONNECT</b>: "int (*)([void *,] int, const struct sockaddr *, socklen_t)", see <u><a href="../man2/connect.2.html">connect</a></u>(2).

           <b>SA_SYSCALL_ACCEPT</b>: "int (*)([void *,] int, struct sockaddr *, socklen_t *)", see <u><a href="../man2/accept.2.html">accept</a></u>(2).

           <b>SA_SYSCALL_SELECT</b>: "int (*)([void *,] int, fd_set *, fd_set *, fd_set  *,  struct  timeval  *)",  see
           <u><a href="../man2/select.2.html">select</a></u>(2).

           <b>SA_SYSCALL_READ</b>: "ssize_t (*)([void *,] int, void *, size_t)", see <u><a href="../man2/read.2.html">read</a></u>(2).

           <b>SA_SYSCALL_WRITE</b>: "ssize_t (*)([void *,] int, const void *, size_t)", see <u><a href="../man2/write.2.html">write</a></u>(2).

           <b>SA_SYSCALL_RECVFROM</b>:  "ssize_t  (*)([void  *,] int, void *, size_t, int, struct sockaddr *, socklen_t
           *)", see <u><a href="../man2/recvfrom.2.html">recvfrom</a></u>(2).

           <b>SA_SYSCALL_SENDTO</b>: "ssize_t (*)([void *,] int, const void *, size_t, int, const  struct  sockaddr  *,
           socklen_t)", see <u><a href="../man2/sendto.2.html">sendto</a></u>(2).

           Example:

            ssize_t
            trace_read(void *ctx, int fd, void *buf, size_t len)
            {
                FILE *fp = (FILE *)ctx;
                ssize_t rv;
                int errno_saved;

                rv = read(fd, buf, len);
                errno_saved = errno;
                fprintf(fp, "read(%d, %lx, %d) = %d\n",
                        fd, (long)buf, len, rv);
                errno = errno_saved;
                return rv;
            }

            ...
            FILE *trace_fp = ...;
            sa_syscall(sa, SA_SC_READ, trace_read, trace_fp);
            ...

       <b>Socket</b> <b>Connection</b> <b>Operations</b>

       This  API  part  provides connection operations for stream-oriented data communication through the socket
       abstraction sa_t.

       sa_rc_t <b>sa_bind</b>(sa_t *<u>sa</u>, sa_addr_t *<u>laddr</u>);
           Bind socket abstraction object to a local protocol address.

           This assigns the local protocol address <u>laddr</u>. When a socket is created,  it  exists  in  an  address
           family space but has no protocol address assigned. This call requests that <u>laddr</u> be used as the local
           address.  For  servers  this  is  the  address  they  later listen on (see <u><a href="../man3/sa_listen.3.html">sa_listen</a></u>(3)) for incoming
           connections, for clients this is the address  used  for  outgoing  connections  (see  <u><a href="../man3/sa_connect.3.html">sa_connect</a></u>(3)).
           Internally this directly maps to <u><a href="../man2/bind.2.html">bind</a></u>(2).

           Example: sa_bind(sa, laddr);

       sa_rc_t <b>sa_connect</b>(sa_t *<u>sa</u>, sa_addr_t *<u>raddr</u>);
           Initiate an outgoing connection on a socket abstraction object.

           This  performs a connect to the remote address <u>raddr</u>. If the socket is of type SA_TYPE_DATAGRAM, this
           call specifies the peer with which the socket is to be associated; this  address  is  that  to  which
           datagrams are to be sent, and the only address from which datagrams are to be received. If the socket
           is  of  type SA_TYPE_STREAM, this call attempts to make a connection to the remote socket. Internally
           this directly maps to <u><a href="../man2/connect.2.html">connect</a></u>(2).

           Example: sa_connect(sa, raddr);

       sa_rc_t <b>sa_listen</b>(sa_t *<u>sa</u>, int <u>backlog</u>);
           Listen for incoming connections on a socket abstraction object.

           A willingness to accept incoming connections and a queue limit for incoming connections are specified
           by this call. The <u>backlog</u> argument defines the maximum length the queue of  pending  connections  may
           grow to.  Internally this directly maps to <u><a href="../man2/listen.2.html">listen</a></u>(2).

           Example: sa_listen(sa, 128);

       sa_rc_t <b>sa_accept</b>(sa_t *<u>sa</u>, sa_addr_t **<u>caddr</u>, sa_t **<u>csa</u>);
           Accept incoming connection on a socket abstraction object.

           This  accepts  an  incoming  connection  by  extracting  the first connection request on the queue of
           pending connections. It creates a new socket abstraction object (returned in <u>csa</u>) and  a  new  socket
           address  abstraction  object (returned in <u>caddr</u>) describing the connection. The caller has to destroy
           these objects later. If no pending connections are present on the queue, it blocks the caller until a
           connection is present.

           Example:

            sa_addr_t *clt_saa;
            sa_t      *clt_sa;
            ...
            while (sa_accept(srv_sa, &amp;clt_saa, &amp;clt_sa) == SA_OK) {
                ...
            }

       sa_rc_t <b>sa_getremote</b>(sa_t *<u>sa</u>, sa_addr_t **<u>raddr</u>);
           Get address abstraction of remote side of communication.

           This determines the address of the communication peer and creates a new  socket  address  abstraction
           object  (returned  in  <u>raddr</u>) describing the peer address. The application has to destroy <u>raddr</u> later
           with <u><a href="../man3/sa_addr_destroy.3.html">sa_addr_destroy</a></u>(3). Internally this maps to <u><a href="../man2/getpeername.2.html">getpeername</a></u>(2).

           Example: sa_addr_t *raddr; sa_getremote(sa, &amp;raddr);

       sa_rc_t <b>sa_getlocal</b>(sa_t *<u>sa</u>, sa_addr_t **<u>laddr</u>);
           Get address abstraction of local side of communication.

           This determines the address of the  local  communication  side  and  creates  a  new  socket  address
           abstraction  object  (returned in <u>laddr</u>) describing the local address. The application has to destroy
           <u>laddr</u> later with <u><a href="../man3/sa_addr_destroy.3.html">sa_addr_destroy</a></u>(3). Internally this maps to <u><a href="../man2/getsockname.2.html">getsockname</a></u>(2).

           Example: sa_addr_t *laddr; sa_getlocal(sa, &amp;laddr);

       sa_rc_t <b>sa_shutdown</b>(sa_t *<u>sa</u>, char *<u>flags</u>);
           Shut down part of the full-duplex connection.

           This performs a shut down of the connection described in <u>sa</u>. The  flags  string  can  be  either  "r"
           (indicating  the  read  channel  of  the  communication is shut down only), "w" (indicating the write
           channel of the communication is shut down only), or "rw" (indicating both the read and write channels
           of the communication are shut down). Internally this directly maps to <u><a href="../man2/shutdown.2.html">shutdown</a></u>(2).

           Example: sa_shutdown(sa, "w");

       <b>Socket</b> <b>Input/Output</b> <b>Operations</b> <b>(Stream</b> <b>Communication)</b>

       This API part  provides  I/O  operations  for  stream-oriented  data  communication  through  the  socket
       abstraction sa_t.

       sa_rc_t <b>sa_getfd</b>(sa_t *<u>sa</u>, int *<u>fd</u>);
           Get underlying socket filedescriptor.

           This  peeks  into  the  underlying  socket  filedescriptor  <b>OSSP</b>  <b>sa</b>  allocated  internally  for  the
           communication. This can be used for adjusting the socket communication (via <u><a href="../man2/fcntl.2.html">fcntl</a></u>(2),  <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2),
           etc) directly.

           Think  twice  before  using  this,  then  think  once  more. After all that, think again. With enough
           thought, the need for directly manipulating the underlying socket can often be eliminated.  At  least
           remember that all your direct socket operations fully by-pass <b>OSSP</b> <b>sa</b> and this way can leads to nasty
           side-effects.

           Example: int fd; sa_getfd(sa, &amp;fd);

       sa_rc_t <b>sa_read</b>(sa_t *<u>sa</u>, char *<u>buf</u>, size_t <u>buflen</u>, size_t *<u>bufdone</u>);
           Read a chunk of data from socket into own buffer.

           This  reads  from  the socket (optionally through the internal read buffer) up to a maximum of <u>buflen</u>
           bytes into buffer <u>buf</u>. The actual number of read bytes is stored in <u>bufdone</u>. This internally maps  to
           <u><a href="../man2/read.2.html">read</a></u>(2).

           Example: char buf[1024]; size_t n; sa_read(sa, buf, sizeof(buf), &amp;n);

       sa_rc_t <b>sa_readln</b>(sa_t *<u>sa</u>, char *<u>buf</u>, size_t <u>buflen</u>, size_t *<u>bufdone</u>);
           Read a line of data from socket into own buffer.

           This  reads  from  the socket (optionally through the internal read buffer) up to a maximum of <u>buflen</u>
           bytes into buffer <u>buf</u>, but only as long as no line terminating newline character  (0x0a)  was  found.
           The  line  terminating newline character is stored in the buffer plus a (not counted) terminating NUL
           character ('\0'), too. The actual number of read bytes is stored in <u>bufdone</u>. This internally maps  to
           <u><a href="../man3/sa_read.3.html">sa_read</a></u>(3).

           Keep  in  mind that for efficiency reasons, line-oriented I/O usually always should be performed with
           read buffer (see <u><a href="../man3/sa_option.3.html">sa_option</a></u>(3) and SA_BUFFER_READ). Without such a read  buffer,  the  performance  is
           cruel, because single character <u><a href="../man2/read.2.html">read</a></u>(2) operations would be performed on the underlying socket.

           Example: char buf[1024]; size_t n; sa_readln(sa, buf, sizeof(buf), &amp;n);

       sa_rc_t <b>sa_write</b>(sa_t *<u>sa</u>, const char *<u>buf</u>, size_t <u>buflen</u>, size_t *<u>bufdone</u>);
           Write a chunk of data to socket from own buffer.

           This  writes  to  the  socket (optionally through the internal write buffer) <u>buflen</u> bytes from buffer
           <u>buf</u>. In case of a partial write, the actual number of  written  bytes  is  stored  in  <u>bufdone</u>.  This
           internally maps to <u><a href="../man2/write.2.html">write</a></u>(2).

           Example: sa_write(sa, cp, strlen(cp), NULL);

       sa_rc_t <b>sa_writef</b>(sa_t *<u>sa</u>, const char *<u>fmt</u>, ...);
           Write formatted data data to socket.

           This  formats a string according to the <u><a href="../man3/printf.3.html">printf</a></u>(3)-style format specification <u>fmt</u> and sends the result
           to the socket (optionally through the internal write buffer). In case of a partial socket write,  the
           not  written  data  of  the  formatted  string is internally discarded. Hence using a write buffer is
           strongly  recommended  here  (see  <u><a href="../man3/sa_option.3.html">sa_option</a></u>(3)  and  SA_BUFFER_WRITE).  This  internally   maps   to
           <u><a href="../man3/sa_write.3.html">sa_write</a></u>(3).

           The  underlying  string  formatting  engine  is  just a minimal one and for security and independence
           reasons intentionally not directly based on s[n]<u><a href="../man3/printf.3.html">printf</a></u>(3). It understands only the  following  format
           specifications:  "%%",  "%c"  (char),  "%s" (char *) and "%d" (int) without any precision and padding
           possibilities. It is intended for minimal formatting only. If you need more sophisticated formatting,
           you have to format first into an own buffer via s[n]<u><a href="../man3/printf.3.html">printf</a></u>(3) and then write this to the  socket  via
           <u><a href="../man3/sa_write.3.html">sa_write</a></u>(3) instead.

           Example: sa_writef(sa, "%s=%d\n", cp, i);

       sa_rc_t <b>sa_flush</b>(sa_t *<u>sa</u>);
           Flush still pending outgoing data to socket.

           This  writes  all  still  pending  outgoing  data for the internal write buffer (see <u><a href="../man3/sa_option.3.html">sa_option</a></u>(3) and
           SA_BUFFER_WRITE) to the socket. This internally maps to <u><a href="../man2/write.2.html">write</a></u>(2).

           Example: sa_flush(sa);

       <b>Socket</b> <b>Input/Output</b> <b>Operations</b> <b>(Datagram</b> <b>Communication)</b>

       This API part provides I/O  operations  for  datagram-oriented  data  communication  through  the  socket
       abstraction sa_t.

       sa_rc_t <b>sa_recv</b>(sa_t *<u>sa</u>, sa_addr_t **<u>raddr</u>, char *<u>buf</u>, size_t <u>buflen</u>, size_t *<u>bufdone</u>);
           Receive a chunk of data from remote address via socket into own buffer.

           This  receives  from  the  remote address specified in <u>raddr</u> via the socket up to a maximum of <u>buflen</u>
           bytes into buffer <u>buf</u>. The actual number of received bytes is stored in <u>bufdone</u>. This internally maps
           to <u><a href="../man2/recvfrom.2.html">recvfrom</a></u>(2).

           Example: char buf[1024]; size_t n; sa_recv(sa, buf, sizeof(buf), &amp;n, saa);

       sa_rc_t <b>sa_send</b>(sa_t *<u>sa</u>, sa_addr_t *<u>raddr</u>, const char *<u>buf</u>, size_t <u>buflen</u>, size_t *<u>bufdone</u>);
           Send a chunk of data to remote address via socket from own buffer.

           This sends to the remote address specified in <u>raddr</u> via the socket <u>buflen</u> bytes from buffer <u>buf</u>.  The
           actual number of sent bytes is stored in <u>bufdone</u>. This internally maps to <u><a href="../man2/sendto.2.html">sendto</a></u>(2).

           Example: sa_send(sa, buf, strlen(buf), NULL, saa);

       sa_rc_t <b>sa_sendf</b>(sa_t *<u>sa</u>, sa_addr_t *<u>raddr</u>, const char *<u>fmt</u>, ...);
           Send formatted data data to remote address via socket.

           This  formats a string according to the <u><a href="../man3/printf.3.html">printf</a></u>(3)-style format specification <u>fmt</u> and sends the result
           to the socket as a single piece of data chunk. In case of a partial socket  write,  the  not  written
           data of the formatted string is internally discarded.

           The  underlying  string  formatting  engine  is  just a minimal one and for security and independence
           reasons intentionally not directly based on s[n]<u><a href="../man3/printf.3.html">printf</a></u>(3). It understands only the  following  format
           specifications:  "%%",  "%c"  (char),  "%s" (char *) and "%d" (int) without any precision and padding
           possibilities. It is intended for minimal formatting only. If you need more sophisticated formatting,
           you have to format first into an own buffer via s[n]<u><a href="../man3/printf.3.html">printf</a></u>(3)  and  then  send  this  to  the  remote
           address via <u><a href="../man3/sa_send.3.html">sa_send</a></u>(3) instead.

           Example: sa_sendf(sa, saa, "%s=%d\n", cp, i);

       <b>Socket</b> <b>Error</b> <b>Handling</b>

       This API part provides error handling operations only.

       char *<b>sa_error</b>(sa_rc_t <u>rv</u>);
           Return  the  string representation corresponding to the return code value <u>rv</u>. The returned string has
           to be treated read-only by the application and is not required to be deallocated.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>Standards</b>

       R. Gilligan, S. Thomson, J. Bound, W. Stevens: <u>"Basic</u> <u>Socket</u> <u>Interface</u> <u>Extensions</u> <u>for</u>  <u>IPv6"</u>,  <b>RFC</b>  <b>2553</b>,
       March 1999.

       W. Stevens: <u>"Advanced</u> <u>Sockets</u> <u>API</u> <u>for</u> <u>IPv6"</u>, <b>RFC</b> <b>2292</b>, February 1998.

       R.  Fielding,  L.  Masinter,  T.  Berners-Lee:  <u>"Uniform</u> <u>Resource</u> <u>Identifiers:</u> <u>Generic</u> <u>Syntax"</u>, <b>RFC</b> <b>2396</b>,
       August 1998.

       R. Hinden, S. Deering: <u>"IP</u> <u>Version</u> <u>6</u> <u>Addressing</u> <u>Architecture"</u>, <b>RFC</b> <b>2373</b>, July 1998.

       R. Hinden, B. Carpenter, L. Masinter: <u>"Format</u> <u>for</u> <u>Literal</u> <u>IPv6</u> <u>Addresses</u> <u>in</u> <u>URL's"</u>,  <b>RFC</b>  <b>2732</b>,  December
       1999.

       <b>Papers</b>

       Stuart   Sechrest:   <u>"An</u>   <u>Introductory</u>   <u>4.4BSD</u>   <u>Interprocess</u>   <u>Communication</u>  <u>Tutorial"</u>,  FreeBSD  4.4
       (/usr/share/doc/psd/20.ipctut/).

       Samuel J. Leffler, Robert S. Fabry, William N.  Joy,  Phil  Lapsley:  <u>"An</u>  <u>Advanced</u>  <u>4.4BSD</u>  <u>Interprocess</u>
       <u>Communication</u> <u>Tutorial"</u>, FreeBSD 4.4 (/usr/share/doc/psd/21.ipc/).

       Craig        Metz:        <u>"Protocol</u>        <u>Independence</u>        <u>Using</u>        <u>the</u>       <u>Sockets</u>       <u>API"</u>,
       <a href="http://www.usenix.org/publications/library/proceedings/usenix2000/freenix/metzprotocol.html">http://www.usenix.org/publications/library/proceedings/usenix2000/freenix/metzprotocol.html</a>,       USENIX
       Annual Technical Conference, June 2000.

       <b>Manual</b> <b>Pages</b>

       <u><a href="../man2/socket.2.html">socket</a></u>(2),  <u><a href="../man2/accept.2.html">accept</a></u>(2),  <u><a href="../man2/bind.2.html">bind</a></u>(2),  <u><a href="../man2/connect.2.html">connect</a></u>(2),  <u><a href="../man2/getpeername.2.html">getpeername</a></u>(2),  <u><a href="../man2/getsockname.2.html">getsockname</a></u>(2),  <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2), <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2),
       <u><a href="../man2/listen.2.html">listen</a></u>(2), <u><a href="../man2/read.2.html">read</a></u>(2), <u><a href="../man2/recv.2.html">recv</a></u>(2), <u><a href="../man2/select.2.html">select</a></u>(2), <u><a href="../man2/send.2.html">send</a></u>(2), <u><a href="../man2/shutdown.2.html">shutdown</a></u>(2),  <u><a href="../man2/socketpair.2.html">socketpair</a></u>(2),  <u><a href="../man2/write.2.html">write</a></u>(2),  <u><a href="../man3/getprotoent.3.html">getprotoent</a></u>(3),
       <u><a href="../man4/protocols.4.html">protocols</a></u>(4).

</pre><h4><b>HISTORY</b></h4><pre>
       <b>OSSP</b>  <b>sa</b>  was  invented  in  August 2001 by Ralf S. Engelschall &lt;<a href="mailto:rse@engelschall.com">rse@engelschall.com</a>&gt; under contract with
       Cable &amp; Wireless &lt;<a href="http://www.cw.com/">http://www.cw.com/</a>&gt; for use inside the OSSP project. Its creation was prompted  by  the
       requirement  to  implement  an SMTP logging channel for the <b>OSSP</b> <b>l2</b> library. Its initial code was derived
       from a predecessor sub-library  originally  written  for  socket  address  abstraction  inside  the  <b>OSSP</b>
       <b>lmtp2nntp</b> tool.

</pre><h4><b>AUTHOR</b></h4><pre>
        Ralf S. Engelschall
        <a href="mailto:rse@engelschall.com">rse@engelschall.com</a>
        www.engelschall.com

02-Oct-2005                                       OSSP sa 1.2.5                                            <u><a href="../man3/sa.3.html">sa</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>