<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::IO::Misc - misc IO routines for PDL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/pdl">pdl_2.074-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::IO::Misc - misc IO routines for PDL

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Some basic I/O functionality: FITS, tables, byte-swapping

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use PDL::IO::Misc;

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>bswap2</b>
         Signature: (x(); )

       Swaps pairs of bytes in argument x()

       bswap2 does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>bswap4</b>
         Signature: (x(); )

       Swaps quads of bytes in argument x()

       bswap4 does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>bswap8</b>
         Signature: (x(); )

       Swaps octets of bytes in argument x()

       bswap8 does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>rcols</b>
       Read specified ASCII cols from a file into ndarrays and perl arrays (also see "rgrep").

         Usage:
           ($x,$y,...) = rcols( *HANDLE|"filename", { EXCLUDE =&gt; '/^!/' }, $col1, $col2, ... )
                    $x = rcols( *HANDLE|"filename", { EXCLUDE =&gt; '/^!/' }, [] )
           ($x,$y,...) = rcols( *HANDLE|"filename", $col1, $col2, ..., { EXCLUDE =&gt; '/^!/' } )
           ($x,$y,...) = rcols( *HANDLE|"filename", "/foo/", $col1, $col2, ... )

       For each column number specified, a 1D output PDL will be generated.  Anonymous arrays of column numbers
       generate 2D output ndarrays with dim0 for the column data and dim1 equal to the number of columns in the
       anonymous array(s).

       An empty anonymous array as column specification will produce a single output data ndarray with <b><a href="../man1/dim.1.html">dim</a></b>(1)
       equal to the number of columns available.

       There are two calling conventions - the old version, where a pattern can be specified after the
       filename/handle, and the new version where options are given as as hash reference.  This reference can be
       given as either the second or last argument.

       The default behaviour is to ignore lines beginning with a # character and lines that only consist of
       whitespace.  Options exist to only read from lines that match, or do not match, supplied patterns, and to
       set the types of the created ndarrays.

       Can take file name or *HANDLE, and if no explicit column numbers are specified, all are assumed. For the
       allowed types, see "Datatype_conversions" in PDL::Core.

       Options (case insensitive):

         EXCLUDE or IGNORE
         - ignore lines matching this pattern (default B&lt;'/^#/'&gt;).

         INCLUDE or KEEP
         - only use lines which match this pattern (default B&lt;''&gt;).

         LINES
         - a string pattern specifying which line numbers to use.
         Line numbers start at 0 and the syntax is 'a:b:c' to use
         every c'th matching line between a and b (default B&lt;''&gt;).

         DEFTYPE
         - default data type for stored data (if not specified, use the type
         stored in C&lt;$PDL::IO::Misc::deftype&gt;, which starts off as B&lt;double&gt;).

         TYPES
         - reference to an array of data types, one element for each column
         to be read in.  Any missing columns use the DEFTYPE value (default B&lt;[]&gt;).

         COLSEP
         - splits on this string/pattern/qr{} between columns of data. Defaults to
         $PDL::IO::Misc::defcolsep.

         PERLCOLS
         - an array of column numbers which are to be read into perl arrays
         rather than ndarrays.  Any columns not specified in the explicit list
         of columns to read will be returned after the explicit columns.
         (default B&lt;undef&gt;).

         COLIDS
         - if defined to an array reference, it will be assigned the column
         ID values obtained by splitting the first line of the file in the
         identical fashion to the column data.

         CHUNKSIZE
         - the number of input data elements to batch together before appending
         to each output data ndarray (Default value is 100).  If CHUNKSIZE is
         greater than the number of lines of data to read, the entire file is
         slurped in, lines split, and perl lists of column data are generated.
         At the end, effectively pdl(@column_data) produces any result ndarrays.

         VERBOSE
         - be verbose about IO processing (default C&lt;$PDL::vebose&gt;)

       For example:

         $x      = PDL-&gt;rcols 'file1';         # file1 has only one column of data
         $x      = PDL-&gt;rcols 'file2', [];     # file2 can have multiple columns, still 1 ndarray output
                                               # (empty array ref spec means all possible data fields)

         ($x,$y) = rcols 'table.csv', { COLSEP =&gt; ',' };  # read CSV data file
         ($x,$y) = rcols *STDOUT;  # default separator for lines like '32 24'

         # read in lines containing the string foo, where the first
         # example also ignores lines that begin with a # character.
         ($x,$y,$z) = rcols 'file2', 0,4,5, { INCLUDE =&gt; '/foo/' };
         ($x,$y,$z) = rcols 'file2', 0,4,5, { INCLUDE =&gt; '/foo/', EXCLUDE =&gt; '' };

         # ignore the first 27 lines of the file, reading in as ushort's
         ($x,$y) = rcols 'file3', { LINES =&gt; '27:-1', DEFTYPE =&gt; ushort };
         ($x,$y) = rcols 'file3', { LINES =&gt; '27:', TYPES =&gt; [ ushort, ushort ] };

         # read in the first column as a perl array and the next two as ndarrays
         # with the perl column returned after the ndarray outputs
         ($x,$y,$name) = rcols 'file4', 1, 2   , { PERLCOLS =&gt; [ 0 ] };
         printf "Number of names read in = %d\n", 1 + $#$name;

         # read in the first column as a perl array and the next two as ndarrays
         # with PERLCOLS changing the type of the first returned value to perl list ref
         ($name,$x,$y) = rcols 'file4', 0, 1, 2, { PERLCOLS =&gt; [ 0 ] };

         # read in the first column as a perl array returned first followed by the
         # the next two data columns in the file as a single Nx2 ndarray
         ($name,$xy) = rcols 'file4', 0, [1, 2], { PERLCOLS =&gt; [ 0 ] };

         NOTES:

         1. Quotes are required on patterns or use the qr{} quote regexp syntax.

         2. Columns are separated by whitespace by default, use the COLSEP option
            separator to specify an alternate split pattern or string or specify an
            alternate default separator by setting C&lt;$PDL::IO::Misc::defcolsep&gt; .

         3. Legacy support is present to use C&lt;$PDL::IO::Misc::colsep&gt; to set the
            column separator but C&lt;$PDL::IO::Misc::colsep&gt; is not defined by default.
            If you set the variable to a defined value it will get picked up.

         4. LINES =&gt; '-1:0:3' may not work as you expect, since lines are skipped
            when read in, then the whole array reversed.

         5. For consistency with wcols and rcols 1D usage, column data is loaded
            into the rows of the pdls (i.e., <a href="../man0/dim.0.html">dim</a>(0) is the elements read per column
            in the file and <a href="../man1/dim.1.html">dim</a>(1) is the number of columns of data read.

   <b>wcols</b>
         Write ASCII columns into file from 1D or 2D ndarrays and/or 1D listrefs efficiently.

       Can take file name or *HANDLE, and if no file/filehandle is given defaults to STDOUT.

         Options (case insensitive):

           HEADER - prints this string before the data. If the string
                    is not terminated by a newline, one is added. (default B&lt;''&gt;).

           COLSEP - prints this string between columns of data. Defaults to
                    $PDL::IO::Misc::defcolsep.

           FORMAT - A printf-style format string that is cycled through
                    column output for user controlled formatting.

        Usage: wcols $data1, $data2, $data3,..., *HANDLE|"outfile", [\%options];  # or
               wcols $format_string, $data1, $data2, $data3,..., *HANDLE|"outfile", [\%options];

          where the $dataN args are either 1D ndarrays, 1D perl array refs,
          or 2D ndarrays (as might be returned from rcols() with the [] column
          syntax and/or using the PERLCOLS option).  <a href="../man0/dim.0.html">dim</a>(0) of all ndarrays
          written must be the same size.  The printf-style $format_string,
          if given, overrides any FORMAT key settings in the option hash.

       e.g.,

         $x = <a href="../man4/random.4.html">random</a>(4); $y = <a href="../man4/ones.4.html">ones</a>(4);
         wcols $x, $y+2, 'foo.dat';
         wcols $x, $y+2, *STDERR;
         wcols $x, $y+2, '|wc';

         $x = <a href="../man3/sequence.3.html">sequence</a>(3); $y = <a href="../man3/zeros.3.html">zeros</a>(3); $c = <a href="../man3/random.3.html">random</a>(3);
         wcols $x,$y,$c; # Orthogonal version of 'print $x,$y,$c' :-)

         wcols "%10.3f", $x,$y; # Formatted
         wcols "%10.3f %10.5g", $x,$y; # Individual column formatting

         $x = <a href="../man3/sequence.3.html">sequence</a>(3); $y = <a href="../man3/zeros.3.html">zeros</a>(3); $units = [ 'm/sec', 'kg', 'MPH' ];
         wcols $x,$y, { HEADER =&gt; "#   x   y" };
         wcols $x,$y, { Header =&gt; "#   x   y", Colsep =&gt; ', ' };  # case insensitive option names!
         wcols " %4.1f  %4.1f  %s",$x,$y,$units, { header =&gt; "# Day  Time  Units" };

         $a52 = sequence(5,2); $y = <a href="../man5/ones.5.html">ones</a>(5); $c = [ 1, 2, 4 ];
         wcols $a52;         # now can write out 2D pdls (2 columns data in output)
         wcols $y, $a52, $c  # ...and mix and match with 1D listrefs as well

         NOTES:

         1. Columns are separated by whitespace by default, use
            C&lt;$PDL::IO::Misc::defcolsep&gt; to modify the default value or
            the COLSEP option

         2. Support for the C&lt;$PDL::IO::Misc::colsep&gt; global value
            of PDL-2.4.6 and earlier is maintained but the initial value
            of the global is undef until you set it.  The value will be
            then be picked up and used as if defcolsep were specified.

         3. Dim 0 corresponds to the column data dimension for both
            rcols and wcols.  This makes wcols the reverse operation
            of rcols.

   <b>swcols</b>
       generate string list from "sprintf" format specifier and a list of ndarrays

       "swcols" takes an (optional) format specifier of the printf sort and a list of 1D ndarrays as input. It
       returns a perl array (or array reference if called in scalar context) where each element of the array is
       the string generated by printing the corresponding element of the ndarray(s) using the format specified.
       If no format is specified it uses the default print format.

        Usage: @str = swcols format, pdl1,pdl2,pdl3,...;
           or  $str = swcols format, pdl1,pdl2,pdl3,...;

   <b>rgrep</b>
         Read columns into ndarrays using full regexp pattern matching.

         Options:

         UNDEFINED: This option determines what will be done for undefined
         values. For instance when reading a comma-separated file of the type
         C&lt;1,2,,4&gt; where the C&lt;,,&gt; indicates a missing value.

         The default value is to assign C&lt;$PDL::undefval&gt; to undefined values,
         but if C&lt;UNDEFINED&gt; is set this is used instead. This would normally
         be set to a number, but if it is set to C&lt;Bad&gt; and PDL is compiled
         with Badvalue support (see L&lt;PDL::Bad/&gt;) then undefined values are set to
         the appropriate badvalue and the column is marked as bad.

         DEFTYPE: Sets the default type of the columns - see the documentation for
          L&lt;/rcols()&gt;

         TYPES:   A reference to a Perl array with types for each column - see
         the documentation for L&lt;/rcols()&gt;

         BUFFERSIZE: The number of lines to extend the ndarray by. It might speed
         up the reading a little bit by setting this to the number of lines in the
         file, but in general L&lt;/rasc()&gt; is a better choice

       Usage

        ($x,$y,...) = rgrep(sub, *HANDLE|"filename")

       e.g.

        ($x,$y) = rgrep {/Foo (.*) Bar (.*) Mumble/} $file;

       i.e. the vectors $x and $y get the progressive values of $1, $2 etc.

   <b>isbigendian</b>
         Determine endianness of machine - returns 0 or 1 accordingly

   <b>rasc</b>
         Simple function to slurp in ASCII numbers quite quickly,
         although error handling is marginal (to nonexistent).

         $pdl-&gt;rasc("filename"|FILEHANDLE [,$noElements]);

             Where:
               filename is the name of the ASCII file to read or open file handle
               $noElements is the optional number of elements in the file to read.
                   (If not present, all of the file will be read to fill up $pdl).
               $pdl can be of type float or double (for more precision).

         #  (test.num is an ascii file with 20 numbers. One number per line.)
         $in = PDL-&gt;null;
         $num = 20;
         $in-&gt;rasc('test.num',20);
         $imm = zeroes(float,20,2);
         $imm-&gt;rasc('test.num');

   <b>rcube</b>
        Read list of files directly into a large data cube (for efficiency)

        $cube = rcube \&amp;reader_function, @files;

        $cube = rcube \&amp;rfits, glob("*.fits");

       This IO function allows direct reading of files into a large data cube, Obviously one could use <b>cat()</b> but
       this is more memory efficient.

       The reading function (e.g. rfits, readfraw) (passed as a reference) and files are the arguments.

       The cube is created as the same X,Y dims and datatype as the first image specified. The Z dim is simply
       the number of images.

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) Karl Glazebrook 1997, Craig DeForest 2001, 2003, and Chris Marshall 2010. All rights
       reserved. There is no warranty. You are allowed to redistribute this software / documentation under
       certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated
       from the PDL distribution, the copyright notice should be included in the file.

perl v5.34.0                                       2022-02-08                                          <u><a href="../man3pm/Misc.3pm.html">Misc</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>