<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mojolicious::Controller - Controller base class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmojolicious-perl">libmojolicious-perl_9.39+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mojolicious::Controller - Controller base class

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # Controller
         package MyApp::Controller::Foo;
         use Mojo::Base 'Mojolicious::Controller', -signatures;

         # Action
         sub bar ($self) {
           my $name = $self-&gt;param('name');
           $self-&gt;res-&gt;headers-&gt;cache_control('max-age=1, no-cache');
           $self-&gt;render(json =&gt; {hello =&gt; $name});
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mojolicious::Controller is the base class for your Mojolicious controllers. It is also the default
       controller class unless you set "controller_class" in Mojolicious.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       Mojolicious::Controller implements the following attributes.

   <b>app</b>
         my $app = $c-&gt;app;
         $c      = $c-&gt;app(Mojolicious-&gt;new);

       A reference back to the application that dispatched to this controller, usually a Mojolicious object.
       Note that this attribute is weakened.

         # Use application logger
         $c-&gt;app-&gt;log-&gt;debug('Hello Mojo');

         # Generate path
         my $path = $c-&gt;app-&gt;home-&gt;child('templates', 'foo', 'bar.html.ep');

   <b>match</b>
         my $m = $c-&gt;match;
         $c    = $c-&gt;match(Mojolicious::Routes::Match-&gt;new);

       Router results for the current request, defaults to a Mojolicious::Routes::Match object.

         # Introspect
         my $name   = $c-&gt;match-&gt;endpoint-&gt;name;
         my $foo    = $c-&gt;match-&gt;endpoint-&gt;pattern-&gt;defaults-&gt;{foo};
         my $action = $c-&gt;match-&gt;stack-&gt;[-1]{action};

   <b>tx</b>
         my $tx = $c-&gt;tx;
         $c     = $c-&gt;tx(Mojo::Transaction::HTTP-&gt;new);

       The transaction that is currently being processed, usually a Mojo::Transaction::HTTP or
       Mojo::Transaction::WebSocket object. Note that this attribute is weakened. So the object needs to be
       referenced elsewhere as well when you're performing non-blocking operations and the underlying connection
       might get closed early.

         # Check peer information
         my $address = $c-&gt;tx-&gt;remote_address;
         my $port    = $c-&gt;tx-&gt;remote_port;

         # Increase size limit for WebSocket messages to 16MiB
         $c-&gt;tx-&gt;<a href="../man16777216/max_websocket_size.16777216.html">max_websocket_size</a>(16777216) if $c-&gt;tx-&gt;is_websocket;

         # Perform non-blocking operation without knowing the connection status
         my $tx = $c-&gt;tx;
         Mojo::IOLoop-&gt;timer(2 =&gt; sub {
           $c-&gt;app-&gt;log-&gt;debug($tx-&gt;is_finished ? 'Finished' : 'In progress');
         });

</pre><h4><b>METHODS</b></h4><pre>
       Mojolicious::Controller inherits all methods from Mojo::Base and implements the following new ones.

   <b>continue</b>
         $c-&gt;continue;

       Continue dispatch chain from an intermediate destination with "continue" in Mojolicious::Routes.

   <b>cookie</b>
         my $value = $c-&gt;cookie('foo');
         $c        = $c-&gt;cookie(foo =&gt; 'bar');
         $c        = $c-&gt;cookie(foo =&gt; 'bar', {path =&gt; '/'});

       Access request cookie values and create new response cookies. If there are multiple values sharing the
       same name, and you want to access more than just the last one, you can use "every_cookie".

         # Create response cookie with domain and expiration date
         $c-&gt;cookie(user =&gt; 'sri', {domain =&gt; 'example.com', expires =&gt; time + 60});

         # Create secure response cookie
         $c-&gt;cookie(secret =&gt; 'I &lt;3 Mojolicious', {secure =&gt; 1, httponly =&gt; 1});

   <b>encrypted_cookie</b>
         my $value = $c-&gt;encrypted_cookie('foo');
         $c        = $c-&gt;encrypted_cookie(foo =&gt; 'bar');
         $c        = $c-&gt;encrypted_cookie(foo =&gt; 'bar', {path =&gt; '/'});

       Access encrypted request cookie values and create new encrypted response cookies. If there are multiple
       values sharing the same name, and you want to access more than just the last one, you can use
       "every_encrypted_cookie". Cookies are encrypted with ChaCha20-Poly1305, to prevent tampering, and the
       ones failing decryption will be automatically discarded. Note that this method is <b>EXPERIMENTAL</b> and might
       change without warning!

   <b>every_cookie</b>
         my $values = $c-&gt;every_cookie('foo');

       Similar to "cookie", but returns all request cookie values sharing the same name as an array reference.

         $ Get first cookie value
         my $first = $c-&gt;every_cookie('foo')-&gt;[0];

   <b>every_encrypted_cookie</b>
         my $values = $c-&gt;every_encrypted_cookie('foo');

       Similar to "encrypted_cookie", but returns all encrypted request cookie values sharing the same name as
       an array reference. Note that this method is <b>EXPERIMENTAL</b> and might change without warning!

         # Get first encrypted cookie value
         my $first = $c-&gt;every_encrypted_cookie('foo')-&gt;[0];

   <b>every_param</b>
         my $values = $c-&gt;every_param('foo');

       Similar to "param", but returns all values sharing the same name as an array reference.

         # Get first value
         my $first = $c-&gt;every_param('foo')-&gt;[0];

   <b>every_signed_cookie</b>
         my $values = $c-&gt;every_signed_cookie('foo');

       Similar to "signed_cookie", but returns all signed request cookie values sharing the same name as an
       array reference.

         # Get first signed cookie value
         my $first = $c-&gt;every_signed_cookie('foo')-&gt;[0];

   <b>finish</b>
         $c = $c-&gt;finish;
         $c = $c-&gt;<a href="../man1000/finish.1000.html">finish</a>(1000);
         $c = $c-&gt;finish(1003 =&gt; 'Cannot accept data!');
         $c = $c-&gt;finish('Bye!');

       Close WebSocket connection or long poll stream gracefully. This method will automatically respond to
       WebSocket handshake requests with a 101 response status, to establish the WebSocket connection.

   <b>helpers</b>
         my $helpers = $c-&gt;helpers;

       Return a proxy object containing the current controller object and on which helpers provided by "app" can
       be called. This includes all helpers from Mojolicious::Plugin::DefaultHelpers and
       Mojolicious::Plugin::TagHelpers.

         # Make sure to use the "title" helper and not the controller method
         $c-&gt;helpers-&gt;title('Welcome!');

         # Use a nested helper instead of the "reply" controller method
         $c-&gt;helpers-&gt;reply-&gt;not_found;

   <b>on</b>
         my $cb = $c-&gt;on(finish =&gt; sub {...});

       Subscribe to events of "tx", which is usually a Mojo::Transaction::HTTP or Mojo::Transaction::WebSocket
       object. This method will automatically respond to WebSocket handshake requests with a 101 response
       status, to establish the WebSocket connection.

         # Do something after the transaction has been finished
         $c-&gt;on(finish =&gt; sub ($c) {
           $c-&gt;app-&gt;log-&gt;debug('All data has been sent');
         });

         # Receive WebSocket message
         $c-&gt;on(message =&gt; sub ($c, $msg) {
           $c-&gt;app-&gt;log-&gt;debug("Message: $msg");
         });

         # Receive JSON object via WebSocket message
         $c-&gt;on(json =&gt; sub ($c, $hash) {
           $c-&gt;app-&gt;log-&gt;debug("Test: $hash-&gt;{test}");
         });

         # Receive WebSocket "Binary" message
         $c-&gt;on(binary =&gt; sub ($c, $bytes) {
           my $len = length $bytes;
           $c-&gt;app-&gt;log-&gt;debug("Received $len bytes");
         });

   <b>param</b>
         my $value = $c-&gt;param('foo');
         $c        = $c-&gt;param(foo =&gt; 'ba;r');
         $c        = $c-&gt;param(foo =&gt; 'ba;r', 'baz');
         $c        = $c-&gt;param(foo =&gt; ['ba;r', 'baz']);

       Access route placeholder values that are not reserved stash values, file uploads as well as "GET" and
       "POST" parameters extracted from the query string and "application/x-www-form-urlencoded" or
       "multipart/form-data" message body, in that order. If there are multiple values sharing the same name,
       and you want to access more than just the last one, you can use "every_param". Parts of the request body
       need to be loaded into memory to parse "POST" parameters, so you have to make sure it is not excessively
       large. There's a 16MiB limit for requests by default.

         # Get first value
         my $first = $c-&gt;every_param('foo')-&gt;[0];

       For more control you can also access request information directly.

         # Only GET parameters
         my $foo = $c-&gt;req-&gt;query_params-&gt;param('foo');

         # Only POST parameters
         my $foo = $c-&gt;req-&gt;body_params-&gt;param('foo');

         # Only GET and POST parameters
         my $foo = $c-&gt;req-&gt;param('foo');

         # Only file uploads
         my $foo = $c-&gt;req-&gt;upload('foo');

   <b>render</b>
         my $bool = $c-&gt;render;
         my $bool = $c-&gt;render(foo =&gt; 'bar', baz =&gt; 23);
         my $bool = $c-&gt;render(template =&gt; 'foo/index');
         my $bool = $c-&gt;render(template =&gt; 'index', format =&gt; 'html');
         my $bool = $c-&gt;render(data =&gt; $bytes);
         my $bool = $c-&gt;render(text =&gt; 'Hello!');
         my $bool = $c-&gt;render(json =&gt; {foo =&gt; 'bar'});
         my $bool = $c-&gt;render(handler =&gt; 'something');
         my $bool = $c-&gt;render('foo/index');

       Render content with "renderer" in Mojolicious and emit hooks "before_render" in Mojolicious as well as
       "after_render" in Mojolicious, or dies if no response could be generated. All additional key/value pairs
       get merged into the "stash".

         # Render characters
         $c-&gt;render(text =&gt; 'I ♥ Mojolicious!');

         # Render characters (alternative)
         $c-&gt;stash(text =&gt; 'I ♥ Mojolicious!')-&gt;render;

         # Render binary data
         use Mojo::JSON qw(encode_json);
         $c-&gt;render(data =&gt; encode_json({test =&gt; 'I ♥ Mojolicious!'}));

         # Render JSON
         $c-&gt;render(json =&gt; {test =&gt; 'I ♥ Mojolicious!'});

         # Render inline template
         $c-&gt;render(inline =&gt; '&lt;%= 1 + 1 %&gt;');

         # Render template "foo/bar.html.ep"
         $c-&gt;render(template =&gt; 'foo/bar', format =&gt; 'html', handler =&gt; 'ep');

         # Render template "test.*.*" with arbitrary values "foo" and "bar"
         $c-&gt;render(template =&gt; 'test', foo =&gt; 'test', bar =&gt; 23);

         # Render template "test.xml.*"
         $c-&gt;render(template =&gt; 'test', format =&gt; 'xml');

         # Render template "test.xml.*" (alternative)
         $c-&gt;render('test', format =&gt; 'xml');

   <b>render_later</b>
         $c = $c-&gt;render_later;

       Disable automatic rendering to delay response generation, only necessary if automatic rendering would
       result in a response.

         # Delayed rendering
         $c-&gt;render_later;
         Mojo::IOLoop-&gt;timer(2 =&gt; sub { $c-&gt;render(text =&gt; 'Delayed by 2 seconds!') });

   <b>render_maybe</b>
         my $bool = $c-&gt;render_maybe;
         my $bool = $c-&gt;render_maybe(foo =&gt; 'bar', baz =&gt; 23);
         my $bool = $c-&gt;render_maybe('foo/index', format =&gt; 'html');

       Try to render content, but do not call "reply-&gt;not_found" in Mojolicious::Plugin::DefaultHelpers if no
       response could be generated, all arguments get localized automatically and are only available during this
       render operation, takes the same arguments as "render".

         # Render template "index_local" only if it exists
         $c-&gt;render_maybe('index_local') or $c-&gt;render('index');

   <b>render_to_string</b>
         my $output = $c-&gt;render_to_string('foo/index', format =&gt; 'pdf');

       Try to render content and return it wrapped in a Mojo::ByteStream object or return "undef", all arguments
       get localized automatically and are only available during this render operation, takes the same arguments
       as "render".

         # Render inline template
         my $two = $c-&gt;render_to_string(inline =&gt; '&lt;%= 1 + 1 %&gt;');

   <b>rendered</b>
         $c = $c-&gt;rendered;
         $c = $c-&gt;<a href="../man302/rendered.302.html">rendered</a>(302);

       Finalize response and emit hook "after_dispatch" in Mojolicious, defaults to using a 200 response code.

         # Custom response
         $c-&gt;res-&gt;headers-&gt;content_type('text/plain');
         $c-&gt;res-&gt;body('Hello World!');
         $c-&gt;<a href="../man200/rendered.200.html">rendered</a>(200);

   <b>req</b>
         my $req = $c-&gt;req;

       Get Mojo::Message::Request object from "tx".

         # Longer version
         my $req = $c-&gt;tx-&gt;req;

         # Extract request information
         my $id     = $c-&gt;req-&gt;request_id;
         my $method = $c-&gt;req-&gt;method;
         my $url    = $c-&gt;req-&gt;url-&gt;to_abs;
         my $info   = $c-&gt;req-&gt;url-&gt;to_abs-&gt;userinfo;
         my $host   = $c-&gt;req-&gt;url-&gt;to_abs-&gt;host;
         my $agent  = $c-&gt;req-&gt;headers-&gt;user_agent;
         my $custom = $c-&gt;req-&gt;headers-&gt;header('Custom-Header');
         my $bytes  = $c-&gt;req-&gt;body;
         my $str    = $c-&gt;req-&gt;text;
         my $hash   = $c-&gt;req-&gt;params-&gt;to_hash;
         my $all    = $c-&gt;req-&gt;uploads;
         my $value  = $c-&gt;req-&gt;json;
         my $foo    = $c-&gt;req-&gt;json('/23/foo');
         my $dom    = $c-&gt;req-&gt;dom;
         my $bar    = $c-&gt;req-&gt;dom('div.bar')-&gt;first-&gt;text;

   <b>res</b>
         my $res = $c-&gt;res;

       Get Mojo::Message::Response object from "tx".

         # Longer version
         my $res = $c-&gt;tx-&gt;res;

         # Force file download by setting a response header
         $c-&gt;res-&gt;headers-&gt;content_disposition('attachment; filename=foo.png;');

         # Use a custom response header
         $c-&gt;res-&gt;headers-&gt;header('Custom-Header' =&gt; 'whatever');

         # Make sure response is cached correctly
         $c-&gt;res-&gt;headers-&gt;cache_control('public, max-age=300');
         $c-&gt;res-&gt;headers-&gt;append(Vary =&gt; 'Accept-Encoding');

   <b>send</b>
         $c = $c-&gt;send({binary =&gt; $bytes});
         $c = $c-&gt;send({text   =&gt; $bytes});
         $c = $c-&gt;send({json   =&gt; {test =&gt; [1, 2, 3]}});
         $c = $c-&gt;send([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
         $c = $c-&gt;send($chars);
         $c = $c-&gt;send($chars =&gt; sub ($c) {...});

       Send message or frame non-blocking via WebSocket, the optional drain callback will be executed once all
       data has been written. This method will automatically respond to WebSocket handshake requests with a 101
       response status, to establish the WebSocket connection.

         # Send "Text" message
         $c-&gt;send('I ♥ Mojolicious!');

         # Send JSON object as "Text" message
         $c-&gt;send({json =&gt; {test =&gt; 'I ♥ Mojolicious!'}});

         # Send JSON object as "Binary" message
         use Mojo::JSON qw(encode_json);
         $c-&gt;send({binary =&gt; encode_json({test =&gt; 'I ♥ Mojolicious!'})});

         # Send "Ping" frame
         use Mojo::WebSocket qw(WS_PING);
         $c-&gt;send([1, 0, 0, 0, WS_PING, 'Hello World!']);

         # Make sure the first message has been written before continuing
         $c-&gt;send('First message!' =&gt; sub ($c) { $c-&gt;send('Second message!') });

       For mostly idle WebSockets you might also want to increase the inactivity timeout with
       "inactivity_timeout" in Mojolicious::Plugin::DefaultHelpers, which usually defaults to 30 seconds.

         # Increase inactivity timeout for connection to 300 seconds
         $c-&gt;<a href="../man300/inactivity_timeout.300.html">inactivity_timeout</a>(300);

   <b>session</b>
         my $session = $c-&gt;session;
         my $foo     = $c-&gt;session('foo');
         $c          = $c-&gt;session({foo =&gt; 'bar'});
         $c          = $c-&gt;session(foo =&gt; 'bar');

       Persistent data storage for the next few requests, all session data gets serialized with Mojo::JSON and
       stored Base64 encoded in HMAC-SHA256 signed cookies, to prevent tampering. Note that cookies usually have
       a 4096 byte (4KiB) limit, depending on browser.

         # Manipulate session
         $c-&gt;session-&gt;{foo} = 'bar';
         my $foo = $c-&gt;session-&gt;{foo};
         delete $c-&gt;session-&gt;{foo};

         # Expiration date in seconds from now (persists between requests)
         $c-&gt;session(expiration =&gt; 604800);

         # Expiration date as absolute epoch time (only valid for one request)
         $c-&gt;session(expires =&gt; time + 604800);

         # Delete whole session by setting an expiration date in the past
         $c-&gt;session(expires =&gt; 1);

   <b>signed_cookie</b>
         my $value = $c-&gt;signed_cookie('foo');
         $c        = $c-&gt;signed_cookie(foo =&gt; 'bar');
         $c        = $c-&gt;signed_cookie(foo =&gt; 'bar', {path =&gt; '/'});

       Access signed request cookie values and create new signed response cookies. If there are multiple values
       sharing the same name, and you want to access more than just the last one, you can use
       "every_signed_cookie". Cookies are cryptographically signed with HMAC-SHA256, to prevent tampering, and
       the ones failing signature verification will be automatically discarded.

   <b>stash</b>
         my $hash = $c-&gt;stash;
         my $foo  = $c-&gt;stash('foo');
         $c       = $c-&gt;stash({foo =&gt; 'bar', baz =&gt; 23});
         $c       = $c-&gt;stash(foo =&gt; 'bar', baz =&gt; 23);

       Non-persistent data storage and exchange for the current request, application wide default values can be
       set with "defaults" in Mojolicious. Some stash values have a special meaning and are reserved, the full
       list is currently "action", "app", "cb", "controller", "data", "extends", "format", "handler", "inline",
       "json", "layout", "namespace", "path", "status", "template", "text" and "variant". Note that all stash
       values with a "mojo.*"  prefix are reserved for internal use.

         # Remove value
         my $foo = delete $c-&gt;stash-&gt;{foo};

         # Assign multiple values at once
         $c-&gt;stash(foo =&gt; 'test', bar =&gt; 23);

   <b>url_for</b>
         my $url = $c-&gt;url_for;
         my $url = $c-&gt;url_for(name =&gt; 'sebastian');
         my $url = $c-&gt;url_for({name =&gt; 'sebastian'});
         my $url = $c-&gt;url_for('test', name =&gt; 'sebastian');
         my $url = $c-&gt;url_for('test', {name =&gt; 'sebastian'});
         my $url = $c-&gt;url_for('/index.html');
         my $url = $c-&gt;url_for('//example.com/index.html');
         my $url = $c-&gt;url_for('<a href="http://example.com/index.html">http://example.com/index.html</a>');
         my $url = $c-&gt;url_for('<a href="mailto:sri@example.com">mailto:sri@example.com</a>');
         my $url = $c-&gt;url_for('#whatever');

       Generate a portable Mojo::URL object with base for a path, URL or route.

         # Rebuild URL for the current route
         $c-&gt;url_for;

         # Rebuild URL for the current route, but replace the "name" placeholder value
         $c-&gt;url_for(name =&gt; 'sebastian');

         # Absolute URL for the current route
         $c-&gt;url_for-&gt;to_abs;

         # Build URL for route "test" with two placeholder values
         $c-&gt;url_for('test', name =&gt; 'sebastian', foo =&gt; 'bar');

         # "<a href="http://127.0.0.1">http://127.0.0.1</a>:3000/index.html" if application was started with Morbo
         $c-&gt;url_for('/index.html')-&gt;to_abs;

         # "https://127.0.0.1:443/index.html" if application was started with Morbo
         $c-&gt;url_for('/index.html')-&gt;to_abs-&gt;scheme('https')-&gt;<a href="../man443/port.443.html">port</a>(443);

         # "/index.html?foo=bar" if application is deployed under "/"
         $c-&gt;url_for('/index.html')-&gt;query(foo =&gt; 'bar');

         # "/myapp/index.html?foo=bar" if application is deployed under "/myapp"
         $c-&gt;url_for('/index.html')-&gt;query(foo =&gt; 'bar');

       You can also use the helper "url_with" in Mojolicious::Plugin::DefaultHelpers to inherit query parameters
       from the current request.

         # "/list?q=mojo&amp;page=2" if current request was for "/list?q=mojo&amp;page=1"
         $c-&gt;url_with-&gt;query({page =&gt; 2});

   <b>url_for_asset</b>
         my $url = $c-&gt;url_for_asset('/app.js');

       Generate a portable Mojo::URL object with base for a static asset.

   <b>url_for_file</b>
         my $url = $c-&gt;url_for_file('/index.html');

       Generate a portable Mojo::URL object with base for a static file.

   <b>write</b>
         $c = $c-&gt;write;
         $c = $c-&gt;write('');
         $c = $c-&gt;write($bytes);
         $c = $c-&gt;write($bytes =&gt; sub ($c) {...});

       Write dynamic content non-blocking, the optional drain callback will be executed once all data has been
       written.  Calling this method without a chunk of data will finalize the response headers and allow for
       dynamic content to be written later.

         # Keep connection alive (with Content-Length header)
         $c-&gt;res-&gt;headers-&gt;<a href="../man6/content_length.6.html">content_length</a>(6);
         $c-&gt;write('Hel' =&gt; sub ($c) { $c-&gt;write('lo!') });

         # Close connection when finished (without Content-Length header)
         $c-&gt;write('Hel' =&gt; sub ($c) {
           $c-&gt;write('lo!' =&gt; sub ($c) { $c-&gt;finish });
         });

       You can call "finish" or write an empty chunk of data at any time to end the stream.

         HTTP/1.1 200 OK
         Date: Sat, 13 Sep 2014 16:48:29 GMT
         Content-Length: 6
         Server: Mojolicious (Perl)

         Hello!

         HTTP/1.1 200 OK
         Connection: close
         Date: Sat, 13 Sep 2014 16:48:29 GMT
         Server: Mojolicious (Perl)

         Hello!

       For Comet (long polling) you might also want to increase the inactivity timeout with "inactivity_timeout"
       in Mojolicious::Plugin::DefaultHelpers, which usually defaults to 30 seconds.

         # Increase inactivity timeout for connection to 300 seconds
         $c-&gt;<a href="../man300/inactivity_timeout.300.html">inactivity_timeout</a>(300);

   <b>write_chunk</b>
         $c = $c-&gt;write_chunk;
         $c = $c-&gt;write_chunk('');
         $c = $c-&gt;write_chunk($bytes);
         $c = $c-&gt;write_chunk($bytes =&gt; sub ($c) {...});

       Write dynamic content non-blocking with chunked transfer encoding, the optional drain callback will be
       executed once all data has been written. Calling this method without a chunk of data will finalize the
       response headers and allow for dynamic content to be written later.

         # Make sure previous chunk has been written before continuing
         $c-&gt;write_chunk('H' =&gt; sub ($c) {
           $c-&gt;write_chunk('ell' =&gt; sub ($c) { $c-&gt;finish('o!') });
         });

       You can call "finish" or write an empty chunk of data at any time to end the stream.

         HTTP/1.1 200 OK
         Date: Sat, 13 Sep 2014 16:48:29 GMT
         Transfer-Encoding: chunked
         Server: Mojolicious (Perl)

         1
         H
         3
         ell
         2
         o!
         0

</pre><h4><b>HELPERS</b></h4><pre>
       In addition to the "ATTRIBUTES" and "METHODS" above you can also call helpers provided by "app" on
       Mojolicious::Controller objects. This includes all helpers from Mojolicious::Plugin::DefaultHelpers and
       Mojolicious::Plugin::TagHelpers.

         # Call helpers
         $c-&gt;layout('green');
         $c-&gt;title('Welcome!');

         # Longer version
         $c-&gt;helpers-&gt;layout('green');

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mojolicious, Mojolicious::Guides, &lt;https://mojolicious.org&gt;.

perl v5.40.0                                       2024-12-07                       <u>Mojolicious::<a href="../man3pm/Controller.3pm.html">Controller</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>