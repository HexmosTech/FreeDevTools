<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dancer::Introduction - A gentle introduction to Dancer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdancer-perl">libdancer-perl_1.3521+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Dancer::Introduction - A gentle introduction to Dancer

</pre><h4><b>VERSION</b></h4><pre>
       version 1.3521

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Dancer is a free and open source micro web application framework written in Perl.

</pre><h4><b>INSTALL</b></h4><pre>
       Installation of Dancer is simple:

           perl -MCPAN -e 'install Dancer'

       Thanks to the magic of cpanminus, if you do not have CPAN.pm configured, or just want a quickfire way to
       get running, the following should work, at least on Unix-like systems:

           wget -O - <a href="http://cpanmin.us">http://cpanmin.us</a> | sudo perl - Dancer

       (If you don't have root access, omit the 'sudo', and cpanminus will install Dancer and prereqs into
       "<a href="file:~/perl5">~/perl5</a>".)

</pre><h4><b>SETUP</b></h4><pre>
       Create a web application using the dancer script:

           dancer -a MyApp

       Run the web application:

           cd MyApp
           bin/app.pl

       You can read the output of "bin/app.pl --help" to change any settings such as the port number.

       View the web application at:

           <a href="http://localhost">http://localhost</a>:3000

</pre><h4><b>USAGE</b></h4><pre>
       When Dancer is imported to a script, that script becomes a webapp, and at this point, all the script has
       to do is declare a list of <b>routes</b>.  A route handler is composed by an HTTP method, a path pattern and a
       code block.  "strict" and "warnings" pragmas are also imported with Dancer.

       The code block given to the route handler has to return a string which will be used as the content to
       render to the client.

       Routes are defined for a given HTTP method. For each method supported, a keyword is exported by the
       module.

       The following is an example of a route definition. The route is defined for the method 'get', so only GET
       requests will be honoured by that route:

           get '/hello/:name' =&gt; sub {
               # do something

               return "Hello ".param('name');
           };

   <b>HTTP</b> <b>METHODS</b>
       Here are some of the standard HTTP methods which you can use to define your route handlers.

       <b>GET</b>     The  GET  method  retrieves information (when defining a route handler for the GET method, Dancer
               automatically defines a route handler for the HEAD method, in order to honour HEAD  requests  for
               each of your GET route handlers).  To define a GET action, use the <b>get</b> keyword.

       <b>POST</b>    The  POST  method  is  used to create a resource on the server.  To define a POST action, use the
               <b>post</b> keyword.

       <b>PUT</b>     The PUT method is used to update an existing resource.  To define  a  PUT  action,  use  the  <b>put</b>
               keyword.

       <b>DELETE</b>  The  DELETE method requests that the origin server delete the resource identified by the Request-
               URI.  To define a DELETE action, use the <b>del</b> keyword.

       To define a route for multiple methods you can also use the special keyword <b>any</b>. This example illustrates
       how to define a route for both GET and POST methods:

           any ['get', 'post'] =&gt; '/myaction' =&gt; sub {
               # code
           };

       Or even, a route handler that would match any HTTP methods:

           any '/myaction' =&gt; sub {
               # code
           };

   <b>ROUTE</b> <b>HANDLERS</b>
       The route action is the code reference declared. It can access parameters through the  `params'  keyword,
       which returns a hashref.  This hashref is a merge of the route pattern matches and the request params.

       You  can  have  more  details  about  how  params are built and how to access them in the Dancer::Request
       documentation.

   <b>NAMED</b> <b>MATCHING</b>
       A route pattern can contain one or more tokens (a word prefixed with ':'). Each token found  in  a  route
       pattern is used as a named-pattern match. Any match will be set in the params hashref.

           get '/hello/:name' =&gt; sub {
               "Hey ".param('name').", welcome here!";
           };

       Tokens can be optional, for example:

           get '/hello/:name?' =&gt; sub {
               "Hello there " . (param('name') || "whoever you are!");
           };

   <b>WILDCARDS</b> <b>MATCHING</b>
       A  route  can  contain  a  wildcard  (represented  by  a '*'). Each wildcard match will be returned in an
       arrayref, accessible via the `splat' keyword.

           get '/download/*.*' =&gt; sub {
               my ($file, $ext) = splat;
               # do something with $file.$ext here
           };

   <b>REGULAR</b> <b>EXPRESSION</b> <b>MATCHING</b>
       A route can be defined with a Perl regular expression.

       In order to tell Dancer to consider the route as a real regexp, the route must be defined explicitly with
       "qr{}", like the following:

           get qr{/hello/([\w]+)} =&gt; sub {
               my ($name) = splat;
               return "Hello $name";
           };

   <b>CONDITIONAL</b> <b>MATCHING</b>
       Routes may include some matching conditions (on the useragent and the hostname at the moment):

           get '/foo', {agent =&gt; 'Songbird (\d\.\d)[\d\/]*?'} =&gt; sub {
             'foo method for songbird'
           }

           get '/foo' =&gt; sub {
             'all browsers except songbird'
           }

   <b>PREFIX</b>
       A prefix can be defined for each route handler, like this:

           prefix '<a href="file:/home">/home</a>';

       From here, any route handler is defined to <a href="file:/home/">/home/</a>*

           get '/page1' =&gt; sub {}; # will match '/home/page1'

       You can unset the prefix value

           prefix '/'; # or: prefix undef;
           get '/page1' =&gt; sub {}; # will match '/page1'

       Alternatively, to prevent you from ever forgetting to undef the prefix, you can use lexical  prefix  like
       this:

           prefix '<a href="file:/home">/home</a>' =&gt; sub {
             get '/page1' =&gt; sub {}; # will match '/home/page1'
           }; ## prefix reset to previous value on exit

           get '/page1' =&gt; sub {}; # will match '/page1'

</pre><h4><b>ACTION</b> <b>SKIPPING</b></h4><pre>
       An action can choose not to serve the current request and ask Dancer to process the request with the next
       matching route.

       This is done with the <b>pass</b> keyword, like in the following example

           get '/say/:word' =&gt; sub {
               return pass if (params-&gt;{word} =~ /^\d+$/);
               "I say a word: ".params-&gt;{word};
           };

           get '/say/:number' =&gt; sub {
               "I say a number: ".params-&gt;{number};
           };

   <b>DEFAULT</b> <b>ERROR</b> <b>PAGES</b>
       When  an  error  is  rendered  (the action responded with a status code different than 200), Dancer first
       looks in the public directory for an HTML file matching the error code (eg: 500.html or 404.html).

       If such a file exists, it's used to render the error, otherwise, a default error page will be rendered on
       the fly.

   <b>EXECUTION</b> <b>ERRORS</b>
       When an error occurs during the route execution, Dancer will render an error page with  the  HTTP  status
       code 500.

       It's possible either to display the content of the error message or to hide it with a generic error page.

       This is a choice left to the end-user and can be set with the <b>show_errors</b> setting.

       Note  that you can also choose to consider all warnings in your route handlers as errors when the setting
       <b>warnings</b> is set to 1.

</pre><h4><b>HOOKS</b></h4><pre>
   <b>Before</b> <b>hooks</b>
       Before hooks are evaluated before each request within the context of  the  request  and  can  modify  the
       request  and  response.  It's  possible to define variables which will be accessible in the action blocks
       with the keyword 'var'.

           hook 'before' =&gt; sub {
               var note =&gt; 'Hi there';
               request-&gt;path_info('/foo/oversee')
           };

           get '/foo/*' =&gt; sub {
               my ($match) = splat; # 'oversee';
               vars-&gt;{note}; # 'Hi there'
           };

       For another example, this can be used along with session support to easily  give  non-logged-in  users  a
       login page:

           hook 'before' =&gt; sub {
               if (!session('user') &amp;&amp; request-&gt;path_info !~ m{^/login}) {
                   # Pass the original path requested along to the handler:
                   var requested_path =&gt; request-&gt;path_info;
                   request-&gt;path_info('/login');
               }
           };

       The request keyword returns the current Dancer::Request object representing the incoming request. See the
       documentation of the Dancer::Request module for details.

   <b>After</b> <b>hooks</b>
       "after"  hooks  are  evaluated  after  the  response has been built by a route handler, and can alter the
       response itself, just before it's sent to the client.

       The hook is given the response object as its first argument:

           hook 'after' =&gt; sub {
               my $response = shift;
               $response-&gt;{content} = 'after hook got here!';
           };

   <b>Before</b> <b>template</b> <b>hook</b>
       "before_template_render" hooks are called whenever a template is going to be processed, they  are  passed
       the tokens hash which they can alter.

           hook 'before_template_render' =&gt; sub {
               my $tokens = shift;
               $tokens-&gt;{foo} = 'bar';
           };

       The  tokens  hash  will  then be passed to the template with all the modifications performed by the hook.
       This is a good way to setup some global vars you like to have in all your templates, like the name of the
       user logged in or a section name.

</pre><h4><b>CONFIGURATION</b> <b>AND</b> <b>ENVIRONMENTS</b></h4><pre>
       Configuring a Dancer application can be done in many ways. The easiest one (and maybe the dirtiest) is to
       put all your settings statements at the top of your script, before calling the <b>dance()</b> method.

       Other ways are possible, you can write all your setting calls in the file `appdir/config.yml'. For  this,
       you must have installed the YAML module, and of course, write the conffile in YAML.

       That's  better  than  the  first  option,  but  it's still not perfect as you can't switch easily from an
       environment to another without rewriting the config.yml file.

       The better way is to have one config.yml file with default global settings, like the following:

           # appdir/config.yml
           logger: 'file'
           layout: 'main'

       And then write as many environment files as you like in appdir/environments.  That way,  the  appropriate
       environment  config  file  will  be loaded according to the running environment (if none is specified, it
       will be 'development').

       Note that you can change the running environment using the --environment command line switch.

       Typically, you'll want to set the following values in a development config file:

           # appdir/environments/development.yml
           log: 'debug'
           startup_info: 1
           show_errors:  1

       And in a production one:

           # appdir/environments/production.yml
           log: 'warning'
           startup_info: 0
           show_errors:  0

   <b>load</b>
       You can use the load method to include additional routes into your application:

           get '/go/:value', sub {
               # foo
           };

           load 'more_routes.pl';

           # then, in the file more_routes.pl:
           get '/yes', sub {
               'orly?';
           };

       <b>load</b> is just a wrapper for <b>require</b>, but you can also specify a list of routes files:

           load 'login_routes.pl', 'session_routes.pl', 'misc_routes.pl';

   <b>Accessing</b> <b>configuration</b> <b>data</b>
       A Dancer application can access the information from its config file easily with the config keyword:

           get '/appname' =&gt; sub {
               return "This is " . config-&gt;{appname};
           };

</pre><h4><b>Importing</b> <b>just</b> <b>the</b> <b>syntax</b></h4><pre>
       If you want to use more complex file hierarchies, you can import just the syntax of Dancer.

           package App;

           use Dancer;            # App may contain generic routes
           use App::User::Routes; # user-related routes

       Then in App/User/Routes.pm:

           use Dancer ':syntax';

           get '/user/view/:id' =&gt; sub {
               ...
           };

</pre><h4><b>LOGGING</b></h4><pre>
       It's possible to log messages sent by the application.  In  the  current  version,  only  one  method  is
       possible  for  logging  messages  but  future  releases  may add additional logging methods, for instance
       logging to syslog.

       In order to enable the logging system for your application, you first have to start the logger engine  in
       your config.yml

           logger: 'file'

       Then you can choose which kind of messages you want to actually log:

           log: 'debug'     # will log debug, warning, error and info messages
           log: 'info'      # will log info, warning and error messages
           log: 'warning'   # will log warning and error messages
           log: 'error'     # will log error messages

       A  directory  appdir/logs  will  be  created  and  will host one logfile per environment. The log message
       contains the time it was written, the PID of the current process, the message and the caller  information
       (file and line).

       To log messages, use the debug, info, warning and error functions. For instance:

           debug "This is a debug message";

</pre><h4><b>USING</b> <b>TEMPLATES</b></h4><pre>
</pre><h4><b>VIEWS</b></h4><pre>
       It's  possible  to render the action's content with a template; this is called a view. The `appdir/views'
       directory is the place where views are located.

       You can change this location by changing the setting 'views', for instance if your templates are  located
       in the 'templates' directory, do the following:

           set views =&gt; path(dirname(__FILE__), 'templates');

       By  default,  the internal template engine is used (Dancer::Template::Simple) but you may want to upgrade
       to Template::Toolkit. If you do so, you have to enable this engine  in  your  settings  as  explained  in
       Dancer::Template::TemplateToolkit.  If  you do so, you'll also have to import the Template module in your
       application code. Note that Dancer configures the Template::Toolkit engine to use &lt;% %&gt; brackets  instead
       of its default [% %] brackets, although you can change this in your config file.

       All views must have a '.tt' extension. This may change in the future.

       In  order  to render a view, just call the 'template' keyword at the end of the action by giving the view
       name and the HASHREF of tokens to interpolate in the view (note  that  the  request,  session  and  route
       params are automatically accessible in the view, named request, session and params):

           use Dancer;
           use Template;

           get '/hello/:name' =&gt; sub {
               template 'hello' =&gt; { number =&gt; 42 };
           };

       And the appdir/views/hello.tt view can contain the following code:

          &lt;html&gt;
           &lt;head&gt;&lt;/head&gt;
           &lt;body&gt;
               &lt;h1&gt;Hello &lt;% params.name %&gt;&lt;/h1&gt;
               &lt;p&gt;Your lucky number is &lt;% number %&gt;&lt;/p&gt;
               &lt;p&gt;You are using &lt;% request.user_agent %&gt;&lt;/p&gt;
               &lt;% IF session.user %&gt;
                   &lt;p&gt;You're logged in as &lt;% session.user %&gt;&lt;/p&gt;
               &lt;% END %&gt;
           &lt;/body&gt;
          &lt;/html&gt;

   <b>LAYOUTS</b>
       A  layout  is  a special view, located in the 'layouts' directory (inside the views directory) which must
       have a token named `content'. That token marks the place where to render the action view. This  lets  you
       define  a  global  layout  for  your  actions. Any tokens that you defined when you called the 'template'
       keyword are available in the layouts, as well as the standard session, request, and params  tokens.  This
       allows  you  to insert per-page content into the HTML boilerplate, such as page titles, current-page tags
       for navigation, etc.

       Here is an example of a layout: views/layouts/main.tt:

           &lt;html&gt;
               &lt;head&gt;&lt;% page_title %&gt;&lt;/head&gt;
               &lt;body&gt;
               &lt;div id="header"&gt;
               ...
               &lt;/div&gt;

               &lt;div id="content"&gt;
               &lt;% content %&gt;
               &lt;/div&gt;

               &lt;/body&gt;
           &lt;/html&gt;

       This layout can be used like the following:

           use Dancer;
           set layout =&gt; 'main';

           get '/' =&gt; sub {
               template 'index' =&gt; { page_title =&gt; "Your website Homepage" };
           };

       Of course, if a layout is set, it can also be disabled for a specific action, like the following:

           use Dancer;
           set layout =&gt; 'main';

           get '/nolayout' =&gt; sub {
               template 'some_ajax_view',
                   { tokens_var =&gt; "42" },
                   { layout =&gt; 0 };
           };

</pre><h4><b>STATIC</b> <b>FILES</b></h4><pre>
   <b>STATIC</b> <b>DIRECTORY</b>
       Static files are served from the ./public directory. You can specify a different location by setting  the
       'public' option:

           set public =&gt; path(dirname(__FILE__), 'static');

       Note  that  the  public  directory name is not included in the URL. A file ./public/css/style.css is made
       available as example.com/css/style.css.

   <b>STATIC</b> <b>FILE</b> <b>FROM</b> <b>A</b> <b>ROUTE</b> <b>HANDLER</b>
       It's possible for a route handler to send a static file, as follows:

           get '/download/*' =&gt; sub {
               my $params = shift;
               my ($file) = @{ $params-&gt;{splat} };

               send_file $file;
           };

       Or even if you want your index page to be a plain old index.html file, just do:

           get '/' =&gt; sub {
               send_file '/index.html'
           };

</pre><h4><b>SETTINGS</b></h4><pre>
       It's possible to change quite every parameter of the application via the settings mechanism.

       A setting is key/value pair assigned by the keyword <b>set</b>:

           set setting_name =&gt; 'setting_value';

       More usefully, settings can be defined in a YAML configuration file.  Environment-specific  settings  can
       also  be  defined  in  environment-specific  files  (for  instance,  you  might  want  extra  logging  in
       development).  See the cookbook for examples.

       See Dancer::Config for complete details about supported settings.

</pre><h4><b>SERIALIZERS</b></h4><pre>
       When writing a webservice, data serialization/deserialization is a common issue to deal with. Dancer  can
       automatically handle that for you, via a serializer.

       When  setting  up  a  serializer,  a  new  behaviour  is authorized for any route handler you define: any
       response that is a reference will be rendered as a serialized string, via the current serializer.

       Here is an example of a route handler that will return a HashRef

           use Dancer;
           set serializer =&gt; 'JSON';

           get '/user/:id/' =&gt; sub {
               { foo =&gt; 42,
                 number =&gt; 100234,
                 list =&gt; [qw(one two three)],
               }
           };

       As soon as the content is a reference - and a serializer is set, which is  not  the  case  by  default  -
       Dancer renders the response via the current serializer.

       Hence,  with  the  JSON  serializer  set,  the  route  handler  above  would result in a content like the
       following:

           {"number":100234,"foo":42,"list":["one","two","three"]}

       The following serializers are available, be aware they dynamically depend on Perl  modules  you  may  not
       have on your system.

       <b>JSON</b>
           requires JSON

       <b>YAML</b>
           requires YAML

       <b>XML</b> requires XML::Simple

       <b>Mutable</b>
           will  try  to  find  the  appropriate serializer using the <b>Content-Type</b> and <b>Accept-type</b> header of the
           request.

</pre><h4><b>EXAMPLE</b></h4><pre>
       This is a possible webapp created with Dancer:

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>

           # make this script a webapp
           use Dancer;

           # declare routes/actions
           get '/' =&gt; sub {
               "Hello World";
           };

           get '/hello/:name' =&gt; sub {
               "Hello ".param('name');
           };

           # run the webserver
           Dancer-&gt;dance;

</pre><h4><b>AUTHOR</b></h4><pre>
       Dancer Core Developers

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2010 by Alexis Sukrieh.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.36.0                                       2023-02-10                          <u>Dancer::<a href="../man3pm/Introduction.3pm.html">Introduction</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>