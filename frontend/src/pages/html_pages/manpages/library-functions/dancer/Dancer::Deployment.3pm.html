<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dancer::Deployment - common ways to put your Dancer app into use</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdancer-perl">libdancer-perl_1.3521+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Dancer::Deployment - common ways to put your Dancer app into use

</pre><h4><b>VERSION</b></h4><pre>
       version 1.3521

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Dancer has been designed to be flexible, and this flexibility extends to your choices when deploying your
       Dancer app.

   <b>Running</b> <b>as</b> <b>a</b> <b>cgi-script</b> <b>(or</b> <b>fast-cgi)</b> <b>under</b> <b>Apache</b>
       In providing ultimate flexibility in terms of deployment, your Dancer app can be run as a simple cgi-
       script out-of-the-box with no additional web server configuration needed. Your web server should
       recognize .cgi files and be able to serve Perl scripts. The Perl module Plack::Runner is required.

       Start by adding the following to your apache configuration (httpd.conf or sites-available/*site*):

           &lt;VirtualHost *:80&gt;
               ServerName www.example.com

               # /srv/www.example.com is the root of your
               # dancer application
               DocumentRoot /srv/www.example.com/public

               ServerAdmin <a href="mailto:you@example.com">you@example.com</a>

               &lt;Directory "/srv/www.example.com/public"&gt;
                  AllowOverride None
                  Options +ExecCGI -MultiViews +SymLinksIfOwnerMatch
                  Order allow,deny
                  Allow from all
                  AddHandler cgi-script .cgi
               &lt;/Directory&gt;

               ScriptAlias / /srv/www.example.com/public/dispatch.cgi/

               ErrorLog  /var/log/apache2/www.example.com-error.log
               CustomLog /var/log/apache2/www.example.com-access_log common
           &lt;/VirtualHost&gt;

       Now you can access your dancer application URLs as if you were using the embedded web server.

           <a href="http://localhost/">http://localhost/</a>

       This option is a no-brainer, easy to setup, low maintenance but serves requests slower than all other
       options.

       You can use the same technique to deploy with FastCGI, by just changing the lines:

           AddHandler cgi-script .cgi

           ...

           ScriptAlias / /srv/www.example.com/public/dispatch.cgi

       To:

           AddHandler fastcgi-script .fcgi

           ...

           ScriptAlias / /srv/www.example.com/public/dispatch.fcgi

   <b>Running</b> <b>stand-alone</b>
       At the simplest, your Dancer app can run standalone, operating as its own webserver using
       HTTP::Server::Simple::PSGI.

       Simply fire up your app:

           $ perl bin/app.pl
           &gt;&gt; Listening on 0.0.0.0:3000
           == Entering the dance floor ...

       Point your browser at it, and away you go!

       This option can be useful for small personal web apps or internal apps, but if you want to make your app
       available to the world, it probably won't suit you.

       <u>Running</u> <u>on</u> <u>Perl</u> <u>webservers</u> <u>with</u> <u>plackup</u>

       A number of Perl web servers supporting PSGI are available on cpan:

       Starman
           "Starman" is a high performance web server, with support for preforking, signals and more.

       Twiggy
           "Twiggy" is an "AnyEvent" web server, it's light and fast.

       Corona
           "Corona" is a "Coro" based web server.

           <b>WARNING</b>: "Dancer"'s use of global variables and "Coro"'s threaded behaviors can cause some unexpected
           behaviors.  See this GitHub issue &lt;https://github.com/PerlDancer/Dancer/issues/929&gt; for more details.
           Unless you have really, really strongly compelling reasons to use Corona, consider using "Twiggy"  or
           "Starman" instead.

       To  start  your  application,  just  run  plackup (see Plack and specific servers above for all available
       options):

          $ plackup bin/app.pl
          $ plackup -E deployment -s Starman --workers=10 -p 5001 -a bin/app.pl

       As you can see, the scaffolded Perl script for your app can be used as a PSGI startup file.

       Enabling content compression

       Content  compression  (gzip,  deflate)  can   be   easily   enabled   via   a   Plack   middleware   (see
       Plack#Plack::Middleware):  Plack::Middleware::Deflater.  It's a middleware to encode the response body in
       gzip or deflate, based on Accept-Encoding HTTP request header.

       Enable   it   as   you   would   enable   any   Plack   middleware.   First   you   need    to    install
       Plack::Middleware::Deflater,  then  in the configuration file (usually <u>environments/development.yml</u>), add
       these lines:

         plack_middlewares:
           -
             - Plack::Middleware::Deflater
             - ...

       These lines tell Dancer to add  Plack::Middleware::Deflater  to  the  list  of  middlewares  to  pass  to
       Plack::Builder, when wrapping the Dancer app. The syntax is :

       •   as key: the name of the Plack middleware to use

       •   as  value:  the  options  to  pass  it  as  a  list.  In  our  case, there is no option to specify to
           Plack::Middleware::Deflater, so we use an empty YAML list.

       To test if content compression works, trace the HTTP request and response before and after enabling  this
       middleware.  Among  other  things,  you  should  notice that the response is gzip or deflate encoded, and
       contains a header "Content-Encoding" set to "gzip" or "deflate"

       <u>Hosting</u> <u>on</u> <u>DotCloud</u>

       The simplest way to achieve this is to push  your  main  application  directory  to  dotcloud  with  your
       "bin/app.pl" file copied to (or symlinked from) "app.psgi".

       Beware  that the dotcloud service enforces one environment only, named "deployment". So instead of having
       "environments/development.yml"  or   "environments/production.yml"   you   <u>must</u>   have   a   file   named
       "environments/deployment.yml".

       Also  make  sure  that  your  "Makefile.PL"  (or  other  dependency  mechanism)  includes both Dancer and
       Plack::Request.

       The default in-memory session handler won't work, and instead you should switch to something  persistent.
       Edit "config.yml" to change "session: 'Simple'" to (for example) "session: 'YAML'".

       In case you have issues with Template::Toolkit on Dotcloud

       If  you  use  the  Template::Toolkit and its "INCLUDE" or "PROCESS" directives, you might need to add the
       search path of your view files to the config. This is probably going to be something like  "INCLUDE_PATH:
       '/home/dotcloud/current/views'" in "config.yml".

       An alternative implementation is to use a variation of the above Plack::Builder template:

        use Plack::Builder;
        use Dancer ':syntax';
        use Dancer::Handler;
        use lib 'lib';

        my $app1 = sub {
            setting appdir =&gt; '/home/dotcloud/current';
            load_app "My::App";
            Dancer::App-&gt;set_running_app("My::App");
            my $env = shift;
            Dancer::Handler-&gt;init_request_headers($env);
            my $req = Dancer::Request-&gt;new(env =&gt; $env);
            Dancer-&gt;dance($req);
        };

        builder {
            mount "/app1" =&gt; $app1;
        };

       This  also supports hosting multiple apps, but you probably also need to specify the specific Environment
       configuration to use in your application.

       When mounting under a path on  dotcloud,  as  in  the  above  example,  always  create  links  using  the
       "uri_for()"  method  for  Dancer  routes,  and  a  "uri_base"  variable  for  static  content as shown in
       Dancer::Cookbook. This means whatever base path your app is mounted under,  links  and  form  submissions
       will continue to work.

       <u>Creating</u> <u>a</u> <u>service</u>

       You can turn your app into proper service running in background using one of the following examples:

       Using Ubic

       Ubic is a polymorphic service manager. You can use it to start and stop any services, automatically start
       them on reboots or daemon failures, and implement custom status checks.

       A basic PSGI service description (usually in /etc/ubic/service/application):

           use parent qw(Ubic::Service::Plack);

           __PACKAGE__-&gt;new(
               server =&gt; 'Starman',
               app =&gt; '/path/to/your/application/app.pl',
               port =&gt; 5000,
               user =&gt; 'www-data',
           );

       Run "ubic start application" to start the service.

       Using daemontools

       daemontools   is  a  collection  of  tools  for  managing  UNIX  services.  You  can  use  it  to  easily
       start/restart/stop services.

       A basic script to start an application: (in /service/application/run)

           #!<a href="file:/bin/sh">/bin/sh</a>

           # if your application is not installed in @INC path:
           export PERL5LIB='/path/to/your/application/lib'

           exec 2&gt;&amp;1 \
           /usr/local/bin/plackup -s Starman -a /path/to/your/application/app.pl -p 5000

       <u>Running</u> <u>stand-alone</u> <u>behind</u> <u>a</u> <u>proxy</u> <u>/</u> <u>load</u> <u>balancer</u>

       Another option would be to run your app stand-alone as described above, but then  use  a  proxy  or  load
       balancer to accept incoming requests (on the standard port 80, say) and feed them to your Dancer app.

       This could be achieved using various software; examples would include:

       Using Apache's mod_proxy

       You could set up a VirtualHost for your web app, and proxy all requests through to it:

           &lt;VirtualHost mywebapp.example.com:80&gt;
           ProxyPass / <a href="http://localhost">http://localhost</a>:3000/
           ProxyPassReverse / <a href="http://localhost">http://localhost</a>:3000/
           &lt;/VirtualHost&gt;

       Or, if you want your webapp to share an existing VirtualHost, you could have it under a specified dir:

           ProxyPass /mywebapp/ <a href="http://localhost">http://localhost</a>:3000/
           &lt;Location /mywebapp/&gt;
               RequestHeader set Request-Base /mywebapp
           &lt;/Location&gt;

       HTTP  header  "Request-Base"  is taken into account by Dancer, only when "behind_proxy" setting is set to
       true.

       It is important for you to note that the Apache2 modules mod_headers, mod_proxy and  mod_proxy_http  must
       be enabled.

           a2enmod headers
           a2enmod proxy
           a2enmod proxy_http

       Note that Apache does not pass protocol information when proxying, so if needed then you will need to set
       it manually in your Apache config:

           RequestHeader set X_FORWARDED_PROTO "https"

       It is also important to set permissions for proxying for security purposes, below is an example.

           &lt;Proxy *&gt;
             Order allow,deny
             Allow from all
           &lt;/Proxy&gt;

       Using perlbal

       "Perlbal"  is  a  single-threaded  event-based server written in Perl supporting HTTP load balancing, web
       serving, and a mix of the two, available from &lt;<a href="http://www.danga.com/perlbal/">http://www.danga.com/perlbal/</a>&gt;

       It processes hundreds of millions of requests a day just for LiveJournal, Vox and TypePad and  dozens  of
       other "Web 2.0" applications.

       It can also provide a management interface to let you see various information on requests handled etc.

       It could easily be used to handle requests for your Dancer apps, too.

       It can be easily installed from CPAN:

           perl -MCPAN -e 'install Perlbal'

       Once  installed,  you'll need to write a configuration file.  See the examples provided with perlbal, but
       you'll probably want something like:

           CREATE POOL my_dancers
           POOL my_dancers ADD 10.0.0.10:3030
           POOL my_dancers ADD 10.0.0.11:3030
           POOL my_dancers ADD 10.0.0.12:3030
           POOL my_dancers ADD 10.0.0.13:3030

           CREATE SERVICE my_webapp
           SET listen          = 0.0.0.0:80
           SET role            = reverse_proxy
           SET pool            = my_dancers
           SET persist_client  = on
           SET persist_backend = on
           SET verify_backend  = on
           ENABLE my_webapp

       Using balance

       "balance"    is    a     simple     load-balancer     from     Inlab     Software,     available     from
       &lt;<a href="http://www.inlab.de/balance.html">http://www.inlab.de/balance.html</a>&gt;.

       It could be used simply to hand requests to a standalone Dancer app. You could even run several instances
       of  your  Dancer  app,  on  the same machine or on several machines, and use a machine running balance to
       distribute the requests between them, for some serious heavy traffic handling!

       To listen on port 80, and send requests to a Dancer app on port 3000:

           balance http localhost:3000

       To listen on a specified IP only on port 80, and distribute requests  between  multiple  Dancer  apps  on
       multiple other machines:

           balance -b 10.0.0.1 80 10.0.0.2:3000 10.0.0.3:3000 10.0.0.4:3000

       Using Lighttpd

       You can use Lighttp's mod_proxy:

           $HTTP["url"] =~ "/application" {
               proxy.server = (
                   "/" =&gt; (
                       "application" =&gt; ( "host" =&gt; "127.0.0.1", "port" =&gt; 3000 )
                   )
               )
           }

       This configuration will proxy all request to the <b>/application</b> path to the path <b>/</b> on localhost:3000.

       Using Nginx

       with Nginx:

           upstream backendurl {
               server unix:THE_PATH_OF_YOUR_PLACKUP_SOCKET_HERE.sock;
           }

           server {
             listen       80;
             server_name YOUR_HOST_HERE;

             access_log /var/log/YOUR_ACCESS_LOG_HERE.log;
             error_log  /var/log/YOUR_ERROR_LOG_HERE.log info;

             root YOUR_ROOT_PROJECT/public;
             location / {
               try_files $uri @proxy;
               access_log off;
               expires max;
             }

             location @proxy {
                   proxy_set_header Host $http_host;
                   proxy_set_header X-Forwarded-Host $host;
                   proxy_set_header X-Real-IP $remote_addr;
                   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                   proxy_set_header X-Forwarded-Proto $scheme;
                   proxy_pass       <a href="http://backendurl">http://backendurl</a>;
             }

           }

       You will need plackup to start a worker listening on a socket :

           cd YOUR_PROJECT_PATH
           sudo -u www plackup -E production -s Starman --workers=2 -l THE_PATH_OF_YOUR_PLACKUP_SOCKET_HERE.sock -a bin/app.pl

       A  good  way to start this is to use "daemontools" and place this line with all environments variables in
       the "run" file.

       Using HAProxy

       "HAProxy"  is  a  reliable  high-performance  TCP/HTTP  load  balancer  written  in  C   available   from
       &lt;<a href="http://haproxy.1wt.eu/">http://haproxy.1wt.eu/</a>&gt;.

       Suppose  we  want  to  run an application at "app.example.com:80" and would to use two backends listen on
       hosts "app-be1.example.com:3000" and "app-be2.example.com:3000".

       Here is HAProxy configuration file (haproxy.conf):

           global
               nbproc  1
               maxconn 4096
               user    nobody
               group   nobody
               # haproxy logs will be collected by syslog
               # syslog: unix socket path or tcp pair (ipaddress:port)
               log     <a href="file:/var/run/log">/var/run/log</a> local0
               daemon
               # enable compression (haproxy v1.5-dev13 and above required)
               tune.comp.maxlevel  5

           defaults
               log     global
               option  httpclose
               option  httplog
               option  dontlognull
               option  forwardfor
               option  abortonclose
               mode    http
               balance roundrobin
               retries 3
               timeout connect         5s
               timeout server          30s
               timeout client          30s
               timeout http-keep-alive 200m
               # enable compression (haproxy v1.5-dev13 and above required)
               compression algo gzip
               compression type text/html application/javascript text/css application/x-javascript text/javascript

           # application frontend (available at <a href="http://app.example.com">http://app.example.com</a>)
           frontend app.example.com
               bind                  :80
               # modify request headers
               reqadd                X-Forwarded-Proto:\ http
               reqadd                X-Forwarded-Port:\ 80
               # modify response headers
               rspdel                ^Server:.*
               rspdel                ^X-Powered-By:.*
               rspadd                Server:\ Dethklok\ (Unix/0.2.3)
               rate-limit sessions   1024
               acl is-haproxy-stats  path_beg /stats
               # uncomment if you'd like to get haproxy usage statistics
               # use_backend haproxy   if is-haproxy-stats
               default_backend       dynamic

           # haproxy statistics (available at <a href="http://app.example.com/stats">http://app.example.com/stats</a>)
           backend haproxy
               stats uri             /stats
               stats refresh         180s
               stats realm           app.example.com\ haproxy\ statistics
               # change credentials
               stats auth            admin1:password1
               stats auth            admin2:password2
               stats hide-version
               stats show-legends

           # application backends
           backend dynamic
               # change path_info to check and value of the Host header sent to application server
               option httpchk HEAD / HTTP/1.1\r\nHost:\ app.example.com
               server app1 app-be1.example.com:3000 check inter 30s
               server app2 app-be2.example.com:3000 check inter 30s

       We will need to start the workers on each backend of  our  application.  This  can  be  done  by  starman
       utility:

           # on app-be1.example.com
           $ starman --workers=2 --listen :3000 /path/to/app.pl
           # on app-be2.example.com
           $ starman --workers=2 --listen :3000 /path/to/app.pl

       Then start the haproxy itself:

           # check the configuration..
           $ sudo haproxy -c -f haproxy.conf
           # now really start it..
           $ sudo haproxy -f haproxy.conf

       <u>Plackup</u> <u>Chef</u> <u>Cookbook</u>

       A  psgi  chef cookbook supporting Dancer (as well as <u>Catalyst</u>) written by Alexey Melezhik is available at
       &lt;<a href="http://community.opscode.com/cookbooks/psgi">http://community.opscode.com/cookbooks/psgi</a>&gt;.

   <b>Running</b> <b>from</b> <b>Apache</b>
       You can run your Dancer app from Apache using the following examples:

       <u>Running</u> <u>from</u> <u>Apache</u> <u>with</u> <u>Plack</u>

       You can run your app from Apache using PSGI (Plack), with a config like the following:

           &lt;VirtualHost myapp.example.com&gt;
               ServerName www.myapp.example.com
               ServerAlias myapp.example.com
               DocumentRoot /websites/myapp.example.com

               &lt;Directory /websites/myapp.example.com&gt;
                   AllowOverride None
                   Order allow,deny
                   Allow from all
               &lt;/Directory&gt;

               &lt;Location /&gt;
                   SetHandler perl-script
                   PerlResponseHandler Plack::Handler::Apache2
                   PerlSetVar psgi_app /websites/myapp.example.com/app.pl
               &lt;/Location&gt;

               ErrorLog  /websites/myapp.example.com/logs/error_log
               CustomLog /websites/myapp.example.com/logs/access_log common
           &lt;/VirtualHost&gt;

       To set the environment you want to use for your application (production or development), you can  set  it
       this way:

           &lt;VirtualHost&gt;
               ...
               SetEnv DANCER_ENVIRONMENT "production"
               ...
           &lt;/VirtualHost&gt;

       <b>NOTE:</b>  Only  a  single  Dancer  application  can  be deployed using the "Plack::Handler::Apache2" method.
       Multiple  Dancer  applications  <b>will</b>  <b>not</b>  <b>work</b>  <b>properly</b>  (The  routes  will  be  mixed-up  between  the
       applications).

       It's  recommended  to start each app with "plackup" using your favorite server (Starman, for example) and
       then put a web server (Apache, Nginx, Perlbal, etc.) as a frontend server for  both  apps  using  reverse
       proxy (HTTP based, no fastcgi).

       <u>Running</u> <u>from</u> <u>Apache</u> <u>under</u> <u>appdir</u>

       If  you  want  to  deploy  multiple  applications  under  the same VirtualHost, using one application per
       directory for example, you can do the following.

       This example uses the FastCGI dispatcher that comes with Dancer, but you should be able to adapt this  to
       use  any other way of deployment described in this guide. The only purpose of this example is to show how
       to deploy multiple applications under the same base directory/virtualhost.

           &lt;VirtualHost *:80&gt;
               ServerName localhost
               DocumentRoot "/path/to/rootdir"
               RewriteEngine On
               RewriteCond %{REQUEST_FILENAME} !-f

               &lt;Directory "/path/to/rootdir"&gt;
                   AllowOverride None
                   Options +ExecCGI -MultiViews +SymLinksIfOwnerMatch
                   Order allow,deny
                   Allow from all
                   AddHandler fastcgi-script .fcgi
               &lt;/Directory&gt;

               RewriteRule /App1(.*)$ /App1/public/dispatch.fcgi$1 [QSA,L]
               RewriteRule /App2(.*)$ /App2/public/dispatch.fcgi$1 [QSA,L]
               ...
               RewriteRule /AppN(.*)$ /AppN/public/dispatch.fcgi$1 [QSA,L]
           &lt;/VirtualHost&gt;

       Of course, if your Apache configuration allows that, you can put the RewriteRules  in  a  .htaccess  file
       directly  within  the  application's directory, which lets you add a new application without changing the
       Apache configuration.

   <b>Running</b> <b>on</b> <b>lighttpd</b> <b>(CGI)</b>
       To run as a CGI app on lighttpd, just create a soft link to the dispatch.cgi script (created when you run
       dancer -a MyApp) inside your system's cgi-bin folder. Make sure mod_cgi is enabled.

           ln -s /path/to/MyApp/public/dispatch.cgi /usr/lib/cgi-bin/mycoolapp.cgi

   <b>Running</b> <b>on</b> <b>lighttpd</b> <b>(FastCGI)</b>
       Make sure mod_fcgi is enabled. You also must have FCGI installed.

       This example configuration uses TCP/IP:

           $HTTP["url"] == "^<a href="file:/app">/app</a>" {
               fastcgi.server += (
                   "<a href="file:/app">/app</a>" =&gt; (
                       "" =&gt; (
                           "host" =&gt; "127.0.0.1",
                           "port" =&gt; "5000",
                           "check-local" =&gt; "disable",
                       )
                   )
               )
           }

       Launch your application:

           plackup -s FCGI --port 5000 bin/app.pl

       This example configuration uses a socket:

           $HTTP["url"] =~ "^<a href="file:/app">/app</a>" {
               fastcgi.server += (
                   "<a href="file:/app">/app</a>" =&gt; (
                       "" =&gt; (
                           "socket" =&gt; "/tmp/fcgi.sock",
                           "check-local" =&gt; "disable",
                       )
                   )
               )
           }

       Launch your application:

           plackup -s FCGI --listen /tmp/fcgi.sock bin/app.pl

</pre><h4><b>AUTHOR</b></h4><pre>
       Dancer Core Developers

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2010 by Alexis Sukrieh.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.36.0                                       2023-02-10                            <u>Dancer::<a href="../man3pm/Deployment.3pm.html">Deployment</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>