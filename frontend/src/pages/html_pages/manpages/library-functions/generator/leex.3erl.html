<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>leex - Lexical analyzer generator for Erlang</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       leex - Lexical analyzer generator for Erlang

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A regular expression based lexical analyzer generator for Erlang, similar to lex or flex.

   <b>Note:</b>
       The Leex module should be considered experimental as it will be subject to changes in future releases.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>error_info()</b> =
           {erl_anno:line() | none, module(), ErrorDescriptor :: term()}

              The  standard  <u>error_info()</u>  structure  that  is returned from all I/O modules. <u>ErrorDescriptor</u> is
              formattable by <u>format_error/1</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>file(FileName)</b> <b>-&gt;</b> <b>leex_ret()</b>

       <b>file(FileName,</b> <b>Options)</b> <b>-&gt;</b> <b>leex_ret()</b>

              Types:

                 FileName = file:filename()
                 Options = Option | [Option]
                 Option =
                     {dfa_graph, boolean()} |
                     {includefile, Includefile :: file:filename()} |
                     {report_errors, boolean()} |
                     {report_warnings, boolean()} |
                     {report, boolean()} |
                     {return_errors, boolean()} |
                     {return_warnings, boolean()} |
                     {return, boolean()} |
                     {scannerfile, Scannerfile :: file:filename()} |
                     {verbose, boolean()} |
                     {warnings_as_errors, boolean()} |
                     dfa_graph | report_errors | report_warnings | report |
                     return_errors | return_warnings | return | verbose |
                     warnings_as_errors
                 <b>leex_ret()</b> = ok_ret() | error_ret()
                 <b>ok_ret()</b> =
                     {ok, Scannerfile :: file:filename()} |
                     {ok, Scannerfile :: file:filename(), warnings()}
                 <b>error_ret()</b> =
                     error | {error, Errors :: errors(), Warnings :: warnings()}
                 <b>errors()</b> = [{file:filename(), [error_info()]}]
                 <b>warnings()</b> = [{file:filename(), [error_info()]}]

              Generates a lexical analyzer from the definition in  the  input  file.  The  input  file  has  the
              extension  <u>.xrl</u>. This is added to the filename if it is not given. The resulting module is the Xrl
              filename without the <u>.xrl</u> extension.

              The current options are:

                <u>dfa_graph</u>:
                  Generates a <u>.dot</u> file which contains a description of the DFA in a format which can be  viewed
                  with Graphviz, <u>www.graphviz.com</u>.

                <u>{includefile,Includefile}</u>:
                  Uses     a     specific     or     customised     prologue    file    instead    of    default
                  <u>lib/parsetools/include/leexinc.hrl</u> which is otherwise included.

                <u>{report_errors,</u> <u>boolean()}</u>:
                  Causes errors to be printed as they occur. Default is <u>true</u>.

                <u>{report_warnings,</u> <u>boolean()}</u>:
                  Causes warnings to be printed as they occur. Default is <u>true</u>.

                <u>{report,</u> <u>boolean()}</u>:
                  This is a short form for both <u>report_errors</u> and <u>report_warnings</u>.

                <u>{return_errors,</u> <u>boolean()}</u>:
                  If this flag is set, <u>{error,</u> <u>Errors,</u> <u>Warnings}</u> is returned when there are errors.  Default  is
                  <u>false</u>.

                <u>{return_warnings,</u> <u>boolean()}</u>:
                  If  this  flag  is set, an extra field containing <u>Warnings</u> is added to the tuple returned upon
                  success. Default is <u>false</u>.

                <u>{return,</u> <u>boolean()}</u>:
                  This is a short form for both <u>return_errors</u> and <u>return_warnings</u>.

                <u>{scannerfile,</u> <u>Scannerfile}</u>:
                  <u>Scannerfile</u> is the name of the file  that  will  contain  the  Erlang  scanner  code  that  is
                  generated.  The  default  (<u>""</u>)  is  to add the extension <u>.erl</u> to <u>FileName</u> stripped of the <u>.xrl</u>
                  extension.

                <u>{verbose,</u> <u>boolean()}</u>:
                  Outputs information from parsing the input file and generating the internal tables.

                <u>{warnings_as_errors,</u> <u>boolean()}</u>:
                  Causes warnings to be treated as errors.

              Any of the Boolean options can be set to <u>true</u> by stating the name  of  the  option.  For  example,
              <u>verbose</u> is equivalent to <u>{verbose,</u> <u>true}</u>.

              Leex will add the extension <u>.hrl</u> to the <u>Includefile</u> name and the extension <u>.erl</u> to the <u>Scannerfile</u>
              name, unless the extension is already there.

       <b>format_error(ErrorDescriptor)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

              Types:

                 ErrorDescriptor = term()

              Returns  a  descriptive  string  in  English  of  an  error  reason  <u>ErrorDescriptor</u>  returned  by
              <u>leex:file/1,2</u> when there is an error in a regular expression.

</pre><h4><b>GENERATED</b> <b>SCANNER</b> <b>EXPORTS</b></h4><pre>
       The following functions are exported by the generated scanner.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>Module:string(String)</b> <b>-&gt;</b> <b>StringRet</b>
       <b>Module:string(String,</b> <b>StartLine)</b> <b>-&gt;</b> <b>StringRet</b>

              Types:

                 String = string()
                 StringRet = {ok,Tokens,EndLine} | ErrorInfo
                 Tokens = [Token]
                 EndLine = StartLine = erl_anno:line()

              Scans <u>String</u> and returns all the tokens in it, or an error.

          <b>Note:</b>
              It is an error if not all of the characters in <u>String</u> are consumed.

       <b>Module:token(Cont,</b> <b>Chars)</b> <b>-&gt;</b> <b>{more,Cont1}</b> <b>|</b> <b>{done,TokenRet,RestChars}</b>
       <b>Module:token(Cont,</b> <b>Chars,</b> <b>StartLine)</b> <b>-&gt;</b> <b>{more,Cont1}</b> <b>|</b> <b>{done,TokenRet,RestChars}</b>

              Types:

                 Cont = [] | Cont1
                 Cont1 = tuple()
                 Chars = RestChars = string() | eof
                 TokenRet = {ok, Token, EndLine} | {eof, EndLine} | ErrorInfo
                 StartLine = EndLine = erl_anno:line()

              This is a re-entrant call to try and scan one token from <u>Chars</u>. If there are enough characters  in
              <u>Chars</u>  to  either  scan  a  token  or  detect an error then this will be returned with <u>{done,...}</u>.
              Otherwise <u>{cont,Cont}</u> will be returned where <u>Cont</u> is used in the next call to  <u>token()</u>  with  more
              characters  to  try  an  scan the token. This is continued until a token has been scanned. <u>Cont</u> is
              initially <u>[]</u>.

              It is not designed to be called directly by an application but used through the i/o  system  where
              it can typically be called in an application by:

              io:request(InFile, {get_until,unicode,Prompt,Module,token,[Line]})
                -&gt; TokenRet

       <b>Module:tokens(Cont,</b> <b>Chars)</b> <b>-&gt;</b> <b>{more,Cont1}</b> <b>|</b> <b>{done,TokensRet,RestChars}</b>
       <b>Module:tokens(Cont,</b> <b>Chars,</b> <b>StartLine)</b> <b>-&gt;</b> <b>{more,Cont1}</b> <b>|</b> <b>{done,TokensRet,RestChars}</b>

              Types:

                 Cont = [] | Cont1
                 Cont1 = tuple()
                 Chars = RestChars = string() | eof
                 TokensRet = {ok, Tokens, EndLine} | {eof, EndLine} | ErrorInfo
                 Tokens = [Token]
                 StartLine = EndLine = erl_anno:line()

              This  is  a  re-entrant  call to try and scan tokens from <u>Chars</u>. If there are enough characters in
              <u>Chars</u> to either scan tokens or detect an  error  then  this  will  be  returned  with  <u>{done,...}</u>.
              Otherwise  <u>{cont,Cont}</u>  will be returned where <u>Cont</u> is used in the next call to <u>tokens()</u> with more
              characters to try an scan the tokens. This is continued until all tokens have been  scanned.  <u>Cont</u>
              is initially <u>[]</u>.

              This  functions  differs  from <u>token</u> in that it will continue to scan tokens upto and including an
              <u>{end_token,Token}</u> has been scanned (see next section). It will then return all the tokens. This is
              typically used for scanning grammars like Erlang where there is an explicit end token, <u>'.'</u>. If  no
              end  token  is found then the whole file will be scanned and returned. If an error occurs then all
              tokens upto and including the next end token will be skipped.

              It is not designed to be called directly by an application but used through the i/o  system  where
              it can typically be called in an application by:

              io:request(InFile, {get_until,unicode,Prompt,Module,tokens,[Line]})
                -&gt; TokensRet

</pre><h4><b>DEFAULT</b> <b>LEEX</b> <b>OPTIONS</b></h4><pre>
       The  (host  operating  system) environment variable <u>ERL_COMPILER_OPTIONS</u> can be used to give default Leex
       options. Its value must be a valid Erlang term. If the value is a list, it is used as is. If it is not  a
       list, it is put into a list.

       The list is appended to any options given to file/2.

       The list can be retrieved with  compile:env_compiler_options/0.

</pre><h4><b>INPUT</b> <b>FILE</b> <b>FORMAT</b></h4><pre>
       Erlang style comments starting with a <u>%</u> are allowed in scanner files. A definition file has the following
       format:

       &lt;Header&gt;

       Definitions.

       &lt;Macro Definitions&gt;

       Rules.

       &lt;Token Rules&gt;

       Erlang code.

       &lt;Erlang code&gt;

       The "Definitions.", "Rules." and "Erlang code." headings are mandatory and must occur at the beginning of
       a  source  line. The &lt;Header&gt;, &lt;Macro Definitions&gt; and &lt;Erlang code&gt; sections may be empty but there must
       be at least one rule.

       Macro definitions have the following format:

       NAME = VALUE

       and there must be spaces around <u>=</u>. Macros can be used in the regular  expressions  of  rules  by  writing
       <u>{NAME}</u>.

   <b>Note:</b>
       When  macros are expanded in expressions the macro calls are replaced by the macro value without any form
       of quoting or enclosing in parentheses.

       Rules have the following format:

       &lt;Regexp&gt; : &lt;Erlang code&gt;.

       The &lt;Regexp&gt; must occur at the start of a line and not include any blanks; use <u>\t</u> and <u>\s</u> to  include  TAB
       and  SPACE characters in the regular expression. If &lt;Regexp&gt; matches then the corresponding &lt;Erlang code&gt;
       is evaluated to generate a token. With the Erlang code the following predefined variables are available:

         <u>TokenChars</u>:
           A list of the characters in the matched token.

         <u>TokenLen</u>:
           The number of characters in the matched token.

         <u>TokenLine</u>:
           The line number where the token occurred.

       The code must return:

         <u>{token,Token}</u>:
           Return <u>Token</u> to the caller.

         <u>{end_token,Token}</u>:
           Return <u>Token</u> and is last token in a tokens call.

         <u>skip_token</u>:
           Skip this token completely.

         <u>{error,ErrString}</u>:
           An error in the token, <u>ErrString</u> is a string describing the error.

       It is also possible to push back characters into the input characters with the following returns:

         * <u>{token,Token,PushBackList}</u>

         * <u>{end_token,Token,PushBackList}</u>

         * <u>{skip_token,PushBackList}</u>

       These have the same meanings as the normal returns but the characters in <u>PushBackList</u> will  be  prepended
       to  the  input  characters and scanned for the next token. Note that pushing back a newline will mean the
       line numbering will no longer be correct.

   <b>Note:</b>
       Pushing back characters gives you unexpected possibilities to cause the scanner to loop!

       The following example would match a simple Erlang integer or float and return a token which could be sent
       to the Erlang parser:

       D = [0-9]

       {D}+ :
         {token,{integer,TokenLine,list_to_integer(TokenChars)}}.

       {D}+\.{D}+((E|e)(\+|\-)?{D}+)? :
         {token,{float,TokenLine,list_to_float(TokenChars)}}.

       The Erlang code in the "Erlang code." section is written into the output file directly after  the  module
       declaration and predefined exports declaration so it is possible to add extra exports, define imports and
       other attributes which are then visible in the whole file.

</pre><h4><b>REGULAR</b> <b>EXPRESSIONS</b></h4><pre>
       The  regular  expressions  allowed  here is a subset of the set found in <u>egrep</u> and in the AWK programming
       language, as defined in the book, The AWK Programming Language, by A. V. Aho,  B.  W.  Kernighan,  P.  J.
       Weinberger. They are composed of the following characters:

         <u>c</u>:
           Matches the non-metacharacter c.

         <u>\c</u>:
           Matches the escape sequence or literal character c.

         <u>.</u>:
           Matches any character.

         <u>^</u>:
           Matches the beginning of a string.

         <u>$</u>:
           Matches the end of a string.

         <u>[abc...]</u>:
           Character class, which matches any of the characters <u>abc...</u>. Character ranges are specified by a pair
           of characters separated by a <u>-</u>.

         <u>[^abc...]</u>:
           Negated character class, which matches any character except <u>abc...</u>.

         <u>r1</u> <u>|</u> <u>r2</u>:
           Alternation. It matches either <u>r1</u> or <u>r2</u>.

         <u>r1r2</u>:
           Concatenation. It matches <u>r1</u> and then <u>r2</u>.

         <u>r+</u>:
           Matches one or more <u>rs</u>.

         <u>r*</u>:
           Matches zero or more <u>rs</u>.

         <u>r?</u>:
           Matches zero or one <u>rs</u>.

         <u>(r)</u>:
           Grouping. It matches <u>r</u>.

       The escape sequences allowed are the same as for Erlang strings:

         <u>\b</u>:
           Backspace.

         <u>\f</u>:
           Form feed.

         <u>\n</u>:
           Newline (line feed).

         <u>\r</u>:
           Carriage return.

         <u>\t</u>:
           Tab.

         <u>\e</u>:
           Escape.

         <u>\v</u>:
           Vertical tab.

         <u>\s</u>:
           Space.

         <u>\d</u>:
           Delete.

         <u>\ddd</u>:
           The octal value <u>ddd</u>.

         <u>\xhh</u>:
           The hexadecimal value <u>hh</u>.

         <u>\x{h...}</u>:
           The hexadecimal value <u>h...</u>.

         <u>\c</u>:
           Any other character literally, for example <u>\\</u> for backslash, <u>\"</u> for <u>"</u>.

       The following examples define simplified versions of a few Erlang data types:

       Atoms [a-z][0-9a-zA-Z_]*

       Variables [A-Z_][0-9a-zA-Z_]*

       Floats (\+|-)?[0-9]+\.[0-9]+((E|e)(\+|-)?[0-9]+)?

   <b>Note:</b>
       Anchoring  a  regular  expression with <u>^</u> and <u>$</u> is not implemented in the current version of Leex and just
       generates a parse error.

Ericsson AB                                     parsetools 2.3.2                                      <u><a href="../man3erl/leex.3erl.html">leex</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>