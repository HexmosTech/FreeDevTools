<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Compare - compare perl data structures</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-compare-perl">libdata-compare-perl_1.29-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Compare - compare perl data structures

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Data::Compare;

           my $h1 = { 'foo' =&gt; [ 'bar', 'baz' ],  'FOO' =&gt; [ 'one', 'two' ] };
           my $h2 = { 'foo' =&gt; [ 'bar', 'barf' ], 'FOO' =&gt; [ 'one', 'two' ] };
           my @a1 = ('one', 'two');
           my @a2 = ('bar', 'baz');
           my %v = ( 'FOO', \@a1, 'foo', \@a2 );

           # simple procedural interface
           print 'structures of $h1 and \%v are ',
             Compare($h1, \%v) ? "" : "not ", "identical.\n";

           print 'structures of $h1 and $h2 are ',
             Compare($h1, $h2, { ignore_hash_keys =&gt; [qw(foo)] }) ? '' : 'not ',
             "close enough to identical.\n";

           # OO usage
           my $c = new Data::Compare($h1, \%v);
           print 'structures of $h1 and \%v are ',
             $c-&gt;Cmp ? "" : "not ", "identical.\n";
           # or
           my $c = new Data::Compare;
           print 'structures of $h and \%v are ',
             $c-&gt;Cmp($h1, \%v) ? "" : "not ", "identical.\n";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Compare two perl data structures recursively. Returns 0 if the structures differ, else returns 1.

       A few data types are treated as special cases:

       Scalar::Properties objects
           This  has  been  moved  into  a  plugin, although functionality remains the same as with the previous
           version.  Full documentation is in Data::Compare::Plugins::Scalar::Properties.

       Compiled regular expressions, eg qr/foo/
           These are stringified before comparison, so the following will match:

               $r = qr/abc/i;
               $s = qr/abc/i;
               Compare($r, $s);

           and the following won't, despite them matching *exactly* the same text:

               $r = qr/abc/i;
               $s = qr/[aA][bB][cC]/;
               Compare($r, $s);

           Sorry, that's the best we can do.

       CODE and GLOB references
           These are assumed not to match unless the references are identical - ie, both are references  to  the
           same thing.

       You  may  also customise how we compare structures by supplying options in a hashref as a third parameter
       to the "Compare()" function.  This is not yet available through the OO-ish interface.  These options will
       be in force for the *whole* of your comparison, so will apply to structures that are lurking deep down in
       your data as well as at the top level, so beware!

       ignore_hash_keys
           an arrayref of strings. When comparing two hashes, any keys mentioned in this list will be ignored.

</pre><h4><b>CIRCULAR</b> <b>STRUCTURES</b></h4><pre>
       Comparing a circular structure to itself returns true:

           $x = \$y;
           $y = \$x;
           Compare([$x, $y], [$x, $y]);

       And on a sort-of-related note, if you try to compare insanely deeply nested structures, the  module  will
       spit  a  warning.  For this to affect you, you need to go around a hundred levels deep though, and if you
       do that you have bigger problems which I can't help you with ;-)

</pre><h4><b>PLUGINS</b></h4><pre>
       The module takes plug-ins so you can provide specialised routines for  comparing  your  own  objects  and
       data-types.  For details see Data::Compare::Plugins.

       Plugins  are  *not*  available  when  running  in "taint" mode.  You may also make it not load plugins by
       providing an empty list as the argument to <b>import()</b> - ie, by doing this:

           use Data::Compare ();

       A couple of functions are provided to examine what goodies have been made available through plugins:

       plugins
           Returns a structure (a hash ref) describing all the comparisons made available through plugins.  This
           function is *not* exported, so should be called as <b>Data::Compare::plugins()</b>.  It takes no parameters.

       plugins_printable
           Returns formatted text

</pre><h4><b>EXPORTS</b></h4><pre>
       For historical reasons, the <b>Compare()</b> function is exported.  If you don't want this, then pass  an  empty
       list  to  <b>import()</b>  as explained under PLUGINS.  If you want no export but do want plugins, then pass the
       empty list, and then call the register_plugins class method:

           use Data::Compare ();
           Data::Compare-&gt;register_plugins;

       or you could call it as a function if that floats your boat.

</pre><h4><b>SOURCE</b> <b>CODE</b> <b>REPOSITORY</b></h4><pre>
       &lt;git://github.com/DrHyde/perl-modules-Data-Compare.git&gt;

</pre><h4><b>BUGS</b></h4><pre>
       Plugin support is not quite finished (see the the Github issue #5 &lt;<a href="http://github.com/DrHyde/perl-modules">http://github.com/DrHyde/perl-modules</a>-
       Data-Compare/issues/5&gt; for details) but is usable. The missing bits are bells and  whistles  rather  than
       core functionality.

       Plugins  are  unavailable if you can't change to the current directory.  This might happen if you started
       your process as a priveleged user and then dropped priveleges.  If this  affects  you,  please  supply  a
       portable patch with tests.

       Bug reports should be made on Github or by email.

</pre><h4><b>AUTHOR</b></h4><pre>
       Fabien Tassin &lt;<a href="mailto:fta@sofaraway.org">fta@sofaraway.org</a>&gt;

       Portions by David Cantrell &lt;<a href="mailto:david@cantrell.org.uk">david@cantrell.org.uk</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>and</b> <b>LICENCE</b></h4><pre>
       Copyright  (c)  1999-2001  Fabien  Tassin.  All  rights reserved.  This program is free software; you can
       redistribute it and/or modify it under the same terms as Perl itself.

       Some parts copyright 2003 - 2023 David Cantrell.

       Seeing that Fabien seems to have disappeared, David Cantrell has become a co-maintainer so he  can  apply
       needed  patches.   The  licence, of course, remains the same.  As the "perl licence" is "Artistic or GPL,
       your choice", you can find them as the files ARTISTIC.txt and GPL2.txt in the distribution.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Test::Deep::NoTest

       <b><a href="../man1/perl.1.html">perl</a></b>(1), <b><a href="../man1/perlref.1.html">perlref</a></b>(1)

perl v5.36.0                                       2023-06-11                                 <u>Data::<a href="../man3pm/Compare.3pm.html">Compare</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>