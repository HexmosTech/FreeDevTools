<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::__detail - Implementation details not part of the namespace std interface.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::__detail - Implementation details not part of the namespace std interface.

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Classes</b>
       struct <b>_BracketMatcher</b>
           Matches a character range (bracket expression)
       class <b>_Compiler</b>
           Builds an NFA from an input iterator range.
       class <b>_Executor</b>
           Takes a regex and an input string and does the matching.
       struct <b>_List_node_base</b>
           Common part of a node in the list.
       struct <b>_List_node_header</b>
           The list node header.
       struct <b>_Quoted_string</b>
           Struct for delimited strings.
       class <b>_Scanner</b>
           Scans an input range for regex tokens.
       class <b>_StateSeq</b>
           Describes a sequence of one or more _State, its current start and end(s). This structure contains
           fragments of an NFA during construction.

   <b>Typedefs</b>
       <b>using</b> <b>__bare_timed_wait</b> = __timed_waiter&lt; <b>std::false_type</b> &gt;
       <b>using</b> <b>__bare_wait</b> = __waiter&lt; <b>std::false_type</b> &gt;
       template&lt;<b>typename</b> <b>_Cat</b> , <b>typename</b> <b>_Limit</b> , <b>typename</b> <b>_Otherwise</b>  = _Cat&gt; <b>using</b> <b>__clamp_iter_cat</b> =
           __conditional_t&lt; derived_from&lt; <b>_Cat</b>, <b>_Limit</b> &gt;, <b>_Limit</b>, <b>_Otherwise</b> &gt;
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; <b>using</b> <b>__cmp3way_res_t</b> = <b>decltype</b>(<b>std::declval</b>&lt; _Tp &gt;()&lt;=&gt;
           <b>std::declval</b>&lt; _Up &gt;())
       template&lt;<b>typename</b> _Tp &gt; <b>using</b> <b>__cref</b> = const <b>remove_reference_t</b>&lt; _Tp &gt; &amp;
       <b>using</b> <b>__enters_timed_wait</b> = __timed_waiter&lt; <b>std::true_type</b> &gt;
       <b>using</b> <b>__enters_wait</b> = __waiter&lt; <b>std::true_type</b> &gt;
       template&lt;<b>typename</b> _Tp &gt; <b>using</b> <b>__integer_from_chars_result_type</b> = <b>enable_if_t</b>&lt; __or_&lt; <b>__is_signed_integer</b>&lt;
           _Tp &gt;, <b>__is_unsigned_integer</b>&lt; _Tp &gt;, <b>is_same</b>&lt; char, <b>remove_cv_t</b>&lt; _Tp &gt; &gt; &gt;::value, <b>from_chars_result</b>
           &gt;
       template&lt;<b>typename</b> _Tp &gt; <b>using</b> <b>__integer_to_chars_result_type</b> = <b>enable_if_t</b>&lt; __or_&lt; <b>__is_signed_integer</b>&lt;
           _Tp &gt;, <b>__is_unsigned_integer</b>&lt; _Tp &gt;, <b>is_same</b>&lt; char, <b>remove_cv_t</b>&lt; _Tp &gt; &gt; &gt;::value, <b>to_chars_result</b> &gt;
       template&lt;<b>typename</b> _Iter &gt; <b>using</b> <b>__iter_concept</b> = <b>typename</b> __iter_concept_impl&lt; _Iter &gt;::type
       template&lt;<b>typename</b> _Tp &gt; <b>using</b> <b>__iter_diff_t</b> = <b>typename</b> __iter_traits&lt; _Tp, incrementable_traits&lt; _Tp &gt;
           &gt;::difference_type
       template&lt;<b>typename</b> _Iter , <b>typename</b> _Tp  = _Iter&gt; <b>using</b> <b>__iter_traits</b> = <b>typename</b> __iter_traits_impl&lt;
           _Iter, _Tp &gt;::type
       template&lt;<b>typename</b> _Tp &gt; <b>using</b> <b>__iter_value_t</b> = <b>typename</b> __iter_traits&lt; _Tp, indirectly_readable_traits&lt;
           _Tp &gt; &gt;::value_type
       <b>using</b> <b>__platform_wait_t</b> = unsigned int
       template&lt;<b>typename</b> _Tp &gt; <b>using</b> <b>__range_iter_t</b> = <b>decltype</b>(ranges::__cust_access::__begin(<b>std::declval</b>&lt; _Tp
           &amp; &gt;()))
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up  = _Tp&gt; <b>using</b> <b>__synth3way_t</b> =
           <b>decltype</b>(__detail::__synth3way(<b>std::declval</b>&lt; _Tp &amp; &gt;(), <b>std::declval</b>&lt; _Up &amp; &gt;()))
       template&lt;<b>typename</b> _Tp &gt; <b>using</b> <b>__unsigned_least_t</b> = <b>typename</b> __to_chars_unsigned_type&lt; _Tp &gt;::type
       <b>using</b> <b>__wait_clock_t</b> = <b>chrono::steady_clock</b>
       template&lt;<b>typename</b> _Tp &gt; <b>using</b> <b>__with_ref</b> = _Tp &amp;
       template&lt;<b>typename</b> _CharT &gt; <b>using</b> <b>_Matcher</b> = std::function&lt; bool(_CharT)&gt;
       <b>typedef</b> long <b>_StateIdT</b>

   <b>Enumerations</b>
       enum <b>_Opcode</b> : int { <b>_S_opcode_unknown</b>, <b>_S_opcode_alternative</b>, <b>_S_opcode_repeat</b>, <b>_S_opcode_backref</b>,
           <b>_S_opcode_line_begin_assertion</b>, <b>_S_opcode_line_end_assertion</b>, <b>_S_opcode_word_boundary</b>,
           <b>_S_opcode_subexpr_lookahead</b>, <b>_S_opcode_subexpr_begin</b>, <b>_S_opcode_subexpr_end</b>, <b>_S_opcode_dummy</b>,
           <b>_S_opcode_match</b>, <b>_S_opcode_accept</b> }
           Operation codes that define the type of transitions within the base NFA that represents the regular
           expression.
       enum class <b>_RegexExecutorPolicy</b> : int { <b>_S_auto</b>, <b>_S_alternate</b> }

   <b>Functions</b>
       template&lt;<b>typename</b> <b>_Res</b> , <b>typename</b> _Tp &gt; constexpr <b>_Res</b> <b>__abs_r</b> (_Tp __val)
       template&lt;<b>typename</b> &gt; <b>void</b> <b>__abs_r</b> (bool)=<b>delete</b>
       template&lt;<b>typename</b> _Tp &gt; bool <b>__atomic_compare</b> (const _Tp &amp;__a, const _Tp &amp;__b)
       template&lt;<b>typename</b> <b>_Pred</b> , <b>typename</b> <b>_Spin</b>  = __default_spin_policy&gt; bool <b>__atomic_spin</b> (<b>_Pred</b> &amp;<b>__pred</b>,
           <b>_Spin</b> <b>__spin</b>=<b>_Spin</b>{ }) noexcept
       template&lt;typename... _Ts&gt; constexpr <b>auto</b> <b>__common_cmp_cat</b> ()
       template&lt;<b>typename</b> <b>_Clock</b> , <b>typename</b> _Dur &gt; bool <b>__cond_wait_until</b> (__condvar &amp;<b>__cv</b>, <b>mutex</b> &amp;<b>__mx</b>, const
           <b>chrono::time_point</b>&lt; <b>_Clock</b>, _Dur &gt; &amp;<b>__atime</b>)
       template&lt;<b>typename</b> <b>_Clock</b> , <b>typename</b> _Dur &gt; bool <b>__cond_wait_until_impl</b> (__condvar &amp;<b>__cv</b>, <b>mutex</b> &amp;<b>__mx</b>,
           const <b>chrono::time_point</b>&lt; <b>_Clock</b>, _Dur &gt; &amp;<b>__atime</b>)
       template&lt;<b>typename</b> _Container , <b>typename</b> <b>_UnsafeContainer</b> , <b>typename</b> _Predicate &gt; _Container::size_type
           <b>__erase_nodes_if</b> (_Container &amp;<b>__cont</b>, <b>_UnsafeContainer</b> &amp;<b>__ucont</b>, _Predicate <b>__pred</b>)
       template&lt;<b>typename</b> <b>_ValT</b> , <b>typename</b> _CharT , <b>typename</b> _Traits &gt; <b>basic_istream</b>&lt; _CharT, _Traits &gt; &amp;
           <b>__extract_params</b> (<b>basic_istream</b>&lt; _CharT, _Traits &gt; &amp;<b>__is</b>, <b>vector</b>&lt; <b>_ValT</b> &gt; &amp;<b>__vals</b>, size_t __n)
       template&lt;bool _DecOnly, <b>typename</b> _Tp &gt; constexpr bool <b>__from_chars_alnum</b> (const char *&amp;__first, const
           char *__last, _Tp &amp;__val, int __base)
           std::from_chars implementation for integers in any base. If _DecOnly is true, then we may assume
           __base is at most 10.
       template&lt;bool _DecOnly = false&gt; constexpr unsigned char <b>__from_chars_alnum_to_val</b> (unsigned char __c)
       template&lt;bool _DecOnly, <b>typename</b> _Tp &gt; constexpr bool <b>__from_chars_pow2_base</b> (const char *&amp;__first, const
           char *__last, _Tp &amp;__val, int __base)
           std::from_chars implementation for integers in a power-of-two base. If _DecOnly is true, then we may
           assume __base is at most 8.
       template&lt;<b>typename</b> _Tp &gt; constexpr _Tp <b>__gcd</b> (_Tp <b>__m</b>, _Tp __n)
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>__p1_representable_as_double</b> (_Tp __x) noexcept
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>__raise_and_add</b> (_Tp &amp;__val, int __base, unsigned char __c)
       template&lt;<b>typename</b> _BiIter , <b>typename</b> _Alloc , <b>typename</b> _CharT , <b>typename</b> _TraitsT &gt; bool
           <b>__regex_algo_impl</b> (_BiIter <b>__s</b>, _BiIter __e, <b>match_results</b>&lt; _BiIter, _Alloc &gt; &amp;<b>__m</b>, const
           <b>basic_regex</b>&lt; _CharT, _TraitsT &gt; &amp;<b>__re</b>, <b>regex_constants::match_flag_type</b> __flags, _RegexExecutorPolicy
           <b>__policy</b>, bool <b>__match_mode</b>)
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>__representable_as_double</b> (_Tp __x) noexcept
       template&lt;<b>typename</b> _Tp &gt; <b>void</b> <b>__return_temporary_buffer</b> (_Tp *__p, size_t <b>__len</b>)
       <b>void</b> <b>__thread_relax</b> () noexcept
       <b>void</b> <b>__thread_yield</b> () noexcept
       template&lt;<b>typename</b> _Tp &gt; constexpr <b>to_chars_result</b> <b>__to_chars</b> (char *__first, char *__last, _Tp __val, int
           __base) noexcept
       template&lt;<b>typename</b> _Tp &gt; constexpr <b>__integer_to_chars_result_type</b>&lt; _Tp &gt; <b>__to_chars_10</b> (char *__first,
           char *__last, _Tp __val) noexcept
       template&lt;<b>typename</b> _Tp &gt; constexpr <b>void</b> <b>__to_chars_10_impl</b> (char *__first, unsigned <b>__len</b>, _Tp __val)
           noexcept
       template&lt;<b>typename</b> _Tp &gt; constexpr <b>__integer_to_chars_result_type</b>&lt; _Tp &gt; <b>__to_chars_16</b> (char *__first,
           char *__last, _Tp __val) noexcept
       template&lt;<b>typename</b> _Tp &gt; constexpr <b>__integer_to_chars_result_type</b>&lt; _Tp &gt; <b>__to_chars_2</b> (char *__first, char
           *__last, _Tp __val) noexcept
       template&lt;<b>typename</b> _Tp &gt; constexpr <b>__integer_to_chars_result_type</b>&lt; _Tp &gt; <b>__to_chars_8</b> (char *__first, char
           *__last, _Tp __val) noexcept
       template&lt;<b>typename</b> _Tp &gt; constexpr unsigned <b>__to_chars_len</b> (_Tp __value, int __base) noexcept
       template&lt;<b>typename</b> _Tp &gt; constexpr unsigned <b>__to_chars_len_2</b> (_Tp __value) noexcept
       template&lt;<b>typename</b> _Dur &gt; <b>__wait_clock_t::time_point</b> <b>__to_wait_clock</b> (const <b>chrono::time_point</b>&lt;
           <b>__wait_clock_t</b>, _Dur &gt; &amp;<b>__atime</b>) noexcept
       template&lt;<b>typename</b> <b>_Clock</b> , <b>typename</b> _Dur &gt; <b>__wait_clock_t::time_point</b> <b>__to_wait_clock</b> (const
           <b>chrono::time_point</b>&lt; <b>_Clock</b>, _Dur &gt; &amp;<b>__atime</b>) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits , <b>typename</b> _String &gt; <b>std::basic_ostream</b>&lt; _CharT, _Traits &gt; &amp;
           <b>operator&lt;&lt;</b> (<b>std::basic_ostream</b>&lt; _CharT, _Traits &gt; &amp;<b>__os</b>, const <b>_Quoted_string</b>&lt; _String, _CharT &gt;
           &amp;<b>__str</b>)
           Inserter for quoted strings.
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; <b>std::basic_ostream</b>&lt; _CharT, _Traits &gt; &amp; <b>operator&lt;&lt;</b>
           (<b>std::basic_ostream</b>&lt; _CharT, _Traits &gt; &amp;<b>__os</b>, const <b>_Quoted_string</b>&lt; const _CharT *, _CharT &gt; &amp;<b>__str</b>)
           Inserter for quoted strings.
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits , <b>typename</b> _Alloc &gt; <b>std::basic_istream</b>&lt; _CharT, _Traits &gt; &amp;
           <b>operator&gt;&gt;</b> (<b>std::basic_istream</b>&lt; _CharT, _Traits &gt; &amp;<b>__is</b>, const <b>_Quoted_string</b>&lt; <b>basic_string</b>&lt; _CharT,
           _Traits, _Alloc &gt; &amp;, _CharT &gt; &amp;<b>__str</b>)
           Extractor for delimited strings. The left and right delimiters can be different.

   <b>Variables</b>
       constexpr <b>auto</b> <b>__atomic_spin_count</b>
       constexpr <b>auto</b> <b>__atomic_spin_count_relax</b>
       template&lt;<b>typename</b> _Tp &gt; constexpr unsigned <b>__cmp_cat_id</b>
       template&lt;&gt; constexpr unsigned <b>__cmp_cat_id&lt;</b> <b>partial_ordering</b> <b>&gt;</b>
       template&lt;&gt; constexpr unsigned <b>__cmp_cat_id&lt;</b> <b>strong_ordering</b> <b>&gt;</b>
       template&lt;&gt; constexpr unsigned <b>__cmp_cat_id&lt;</b> <b>weak_ordering</b> <b>&gt;</b>
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>__destructible</b>
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>__destructible&lt;</b> <b>_Tp</b> <b>&amp;</b> <b>&gt;</b>
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>__destructible&lt;</b> <b>_Tp</b> <b>&amp;&amp;</b> <b>&gt;</b>
       template&lt;<b>typename</b> _Tp , size_t _Nm&gt; constexpr bool <b>__destructible&lt;</b> <b>_Tp[_Nm]&gt;</b>
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>__destructible_impl</b>
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>__destructible_impl&lt;</b> <b>_Tp</b> <b>&gt;</b>
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>__is_span</b>
       template&lt;<b>typename</b> _Tp , size_t _Num&gt; constexpr bool <b>__is_span&lt;</b> <b>span&lt;</b> <b>_Tp,</b> <b>_Num</b> <b>&gt;</b> <b>&gt;</b>
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>__is_std_array</b>
       constexpr size_t <b>__platform_wait_alignment</b>
       constexpr <b>struct</b> std::__detail::_Synth3way <b>__synth3way</b>
       constexpr _StateIdT <b>_S_invalid_state_id</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Implementation details not part of the namespace std interface.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;bool</b> <b>_DecOnly,</b> <b>typename</b> <b>_Tp</b> <b>&gt;</b> <b>constexpr</b> <b>bool</b> <b>std::__detail::__from_chars_alnum</b> <b>(const</b> <b>char</b> <b>*&amp;</b>
       <b>__first,</b> <b>const</b> <b>char</b> <b>*</b> <b>__last,</b> <b>_Tp</b> <b>&amp;</b> <b>__val,</b> <b>int</b> <b>__base)</b> <b>[constexpr]</b>
       std::from_chars implementation for integers in any base. If _DecOnly is true, then we may assume __base
       is at most 10.

   <b>template&lt;bool</b> <b>_DecOnly,</b> <b>typename</b> <b>_Tp</b> <b>&gt;</b> <b>constexpr</b> <b>bool</b> <b>std::__detail::__from_chars_pow2_base</b> <b>(const</b> <b>char</b> <b>*&amp;</b>
       <b>__first,</b> <b>const</b> <b>char</b> <b>*</b> <b>__last,</b> <b>_Tp</b> <b>&amp;</b> <b>__val,</b> <b>int</b> <b>__base)</b> <b>[constexpr]</b>
       std::from_chars implementation for integers in a power-of-two base. If _DecOnly is true, then we may
       assume __base is at most 8.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>,</b> <b>typename</b> <b>_String</b> <b>&gt;</b> <b>std::basic_ostream&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b> <b>&amp;</b>
       <b>std::__detail::operator&lt;&lt;</b> <b>(std::basic_ostream&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b> <b>&amp;</b> <b>__os,</b> <b>const</b> <b>_Quoted_string&lt;</b> <b>_String,</b>
       <b>_CharT</b> <b>&gt;</b> <b>&amp;</b> <b>__str)</b>
       Inserter for quoted strings.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>std::basic_ostream&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b> <b>&amp;</b>
       <b>std::__detail::operator&lt;&lt;</b> <b>(std::basic_ostream&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b> <b>&amp;</b> <b>__os,</b> <b>const</b> <b>_Quoted_string&lt;</b> <b>const</b>
       <b>_CharT</b> <b>*,</b> <b>_CharT</b> <b>&gt;</b> <b>&amp;</b> <b>__str)</b>
       Inserter for quoted strings.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>&gt;</b> <b>std::basic_istream&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b> <b>&amp;</b>
       <b>std::__detail::operator&gt;&gt;</b> <b>(std::basic_istream&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b> <b>&amp;</b> <b>__is,</b> <b>const</b> <b>_Quoted_string&lt;</b>
       <b>basic_string&lt;</b> <b>_CharT,</b> <b>_Traits,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;,</b> <b>_CharT</b> <b>&gt;</b> <b>&amp;</b> <b>__str)</b>
       Extractor for delimited strings. The left and right delimiters can be different.

       References <b>std::ios_base::skipws</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++                                <u>std::</u><b>__</b><u><a href="../man3cxx/detail.3cxx.html">detail</a></u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>