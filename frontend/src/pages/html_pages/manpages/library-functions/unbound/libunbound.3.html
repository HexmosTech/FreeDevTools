<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libunbound,    unbound.h,    ub_ctx,    ub_result,    ub_callback_type,   ub_ctx_create,   ub_ctx_delete,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libunbound-dev">libunbound-dev_1.22.0-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>libunbound,</b>    <b>unbound.h,</b>    <b>ub_ctx,</b>    <b>ub_result,</b>    <b>ub_callback_type,</b>   <b>ub_ctx_create,</b>   <b>ub_ctx_delete,</b>
       <b>ub_ctx_set_option,</b> <b>ub_ctx_get_option,</b>  <b>ub_ctx_config,</b>  <b>ub_ctx_set_fwd,</b>  <b>ub_ctx_set_stub,</b>  <b>ub_ctx_set_tls,</b>
       <b>ub_ctx_resolvconf,</b>      <b>ub_ctx_hosts,</b>      <b>ub_ctx_add_ta,</b>     <b>ub_ctx_add_ta_autr,</b>     <b>ub_ctx_add_ta_file,</b>
       <b>ub_ctx_trustedkeys,</b>  <b>ub_ctx_debugout,</b>   <b>ub_ctx_debuglevel,</b>   <b>ub_ctx_async,</b>   <b>ub_poll,</b>   <b>ub_wait,</b>   <b>ub_fd,</b>
       <b>ub_process,</b>      <b>ub_resolve,</b>      <b>ub_resolve_async,</b>      <b>ub_cancel,</b>     <b>ub_resolve_free,</b>     <b>ub_strerror,</b>
       <b>ub_ctx_print_local_zones,</b>  <b>ub_ctx_zone_add,</b>  <b>ub_ctx_zone_remove,</b>  <b>ub_ctx_data_add,</b>  <b>ub_ctx_data_remove</b>  -
       Unbound DNS validating resolver 1.22.0 functions.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;unbound.h&gt;</b>

       <u>struct</u> <u>ub_ctx</u> <u>*</u> <b>ub_ctx_create</b>(<u>void</u>);

       <u>void</u> <b>ub_ctx_delete</b>(<u>struct</u> <u>ub_ctx*</u> ctx);

       <u>int</u> <b>ub_ctx_set_option</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> opt, <u>char*</u> val);

       <u>int</u> <b>ub_ctx_get_option</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> opt, <u>char**</u> val);

       <u>int</u> <b>ub_ctx_config</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> fname);

       <u>int</u> <b>ub_ctx_set_fwd</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> addr);

       <u>int</u> <b>ub_ctx_set_stub</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> zone, <u>char*</u> addr,
                 <u>int</u> isprime);

       <u>int</u> <b>ub_ctx_set_tls</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>int</u> tls);

       <u>int</u> <b>ub_ctx_resolvconf</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> fname);

       <u>int</u> <b>ub_ctx_hosts</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> fname);

       <u>int</u> <b>ub_ctx_add_ta</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> ta);

       <u>int</u> <b>ub_ctx_add_ta_autr</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> fname);

       <u>int</u> <b>ub_ctx_add_ta_file</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> fname);

       <u>int</u> <b>ub_ctx_trustedkeys</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> fname);

       <u>int</u> <b>ub_ctx_debugout</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>FILE*</u> out);

       <u>int</u> <b>ub_ctx_debuglevel</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>int</u> d);

       <u>int</u> <b>ub_ctx_async</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>int</u> dothread);

       <u>int</u> <b>ub_poll</b>(<u>struct</u> <u>ub_ctx*</u> ctx);

       <u>int</u> <b>ub_wait</b>(<u>struct</u> <u>ub_ctx*</u> ctx);

       <u>int</u> <b>ub_fd</b>(<u>struct</u> <u>ub_ctx*</u> ctx);

       <u>int</u> <b>ub_process</b>(<u>struct</u> <u>ub_ctx*</u> ctx);

       <u>int</u> <b>ub_resolve</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> name,
                  <u>int</u> rrtype, <u>int</u> rrclass, <u>struct</u> <u>ub_result**</u> result);

       <u>int</u> <b>ub_resolve_async</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> name,
                        <u>int</u> rrtype, <u>int</u> rrclass, <u>void*</u> mydata,
                        <u>ub_callback_type</u> callback, <u>int*</u> async_id);

       <u>int</u> <b>ub_cancel</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>int</u> async_id);

       <u>void</u> <b>ub_resolve_free</b>(<u>struct</u> <u>ub_result*</u> result);

       <u>const</u> <u>char</u> <u>*</u> <b>ub_strerror</b>(<u>int</u> err);

       <u>int</u> <b>ub_ctx_print_local_zones</b>(<u>struct</u> <u>ub_ctx*</u> ctx);

       <u>int</u> <b>ub_ctx_zone_add</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> zone_name, <u>char*</u> zone_type);

       <u>int</u> <b>ub_ctx_zone_remove</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> zone_name);

       <u>int</u> <b>ub_ctx_data_add</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> data);

       <u>int</u> <b>ub_ctx_data_remove</b>(<u>struct</u> <u>ub_ctx*</u> ctx, <u>char*</u> data);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Unbound</b>  is  an  implementation  of  a DNS resolver, that does caching and DNSSEC validation. This is the
       library API, for using the -lunbound library.  The server daemon is described in <u><a href="../man8/unbound.8.html">unbound</a></u>(8).  The library
       works independent from a running unbound server, and can be used to convert hostnames  to  ip  addresses,
       and  back,  and  obtain  other  information  from  the DNS. The library performs public-key validation of
       results with DNSSEC.

       The library uses a variable of type <u>struct</u> <u>ub_ctx</u> to keep context between calls. The user  must  maintain
       it,  creating it with <b>ub_ctx_create</b> and deleting it with <b>ub_ctx_delete</b>.  It can be created and deleted at
       any time. Creating it anew removes any previous configuration (such  as  trusted  keys)  and  clears  any
       cached results.

       The  functions  are  thread-safe,  and a context can be used in a threaded (as well as in a non-threaded)
       environment. Also resolution (and validation) can be performed blocking  and  non-blocking  (also  called
       asynchronous).   The  async method returns from the call immediately, so that processing can go on, while
       the results become available later.

       The functions are discussed in turn below.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       <b>ub_ctx_create</b>
              Create a new context, initialised  with  defaults.   The  information  from  <a href="file:/etc/resolv.conf">/etc/resolv.conf</a>  and
              <a href="file:/etc/hosts">/etc/hosts</a>  is  not  utilised  by  default.  Use  <b>ub_ctx_resolvconf</b> and <b>ub_ctx_hosts</b> to read them.
              Before   you   call   this,    use    the    openssl    functions    CRYPTO_set_id_callback    and
              CRYPTO_set_locking_callback  to  set  up  asynchronous  operation  if  you  use  lib  openssl (the
              application calls these functions once for initialisation).   Openssl  1.0.0  or  later  uses  the
              CRYPTO_THREADID_set_callback function.

       <b>ub_ctx_delete</b>
              Delete validation context and free associated resources.  Outstanding async queries are killed and
              callbacks are not called for them.

       <b>ub_ctx_set_option</b>
              A  power-user  interface that lets you specify one of the options from the config file format, see
              <u><a href="../man5/unbound.conf.5.html">unbound.conf</a></u>(5). Not all options are relevant. For some specific options,  such  as  adding  trust
              anchors, special routines exist. Pass the option name with the trailing ':'.

       <b>ub_ctx_get_option</b>
              A  power-user  interface  that  gets  an  option value.  Some options cannot be gotten, and others
              return a newline separated list.  Pass the option name without trailing ':'.  The  returned  value
              must be <a href="../man2/free.2.html">free</a>(2)d by the caller.

       <b>ub_ctx_config</b>
              A power-user interface that lets you specify an unbound config file, see <u><a href="../man5/unbound.conf.5.html">unbound.conf</a></u>(5), which is
              read  for  configuration.  Not all options are relevant. For some specific options, such as adding
              trust anchors, special routines exist.  This function is thread-safe only if a single instance  of
              ub_ctx*  exists in the application.  If several instances exist the application has to ensure that
              ub_ctx_config is not called in parallel by the different instances.

       <b>ub_ctx_set_fwd</b>
              Set machine to forward DNS queries to, the caching resolver to use.  IP4 or IP6 address.  Forwards
              all  DNS  requests to that machine, which is expected to run a recursive resolver. If the proxy is
              not DNSSEC capable, validation may fail. Can be called several times, in that case  the  addresses
              are  used  as  backup  servers.   At this time it is only possible to set configuration before the
              first resolve is done.

       <b>ub_ctx_set_stub</b>
              Set a stub zone, authoritative dns servers to use for a particular zone.  IP4 or IP6 address.   If
              the  address is NULL the stub entry is removed.  Set isprime true if you configure root hints with
              it.  Otherwise similar to the stub zone item from unbound's config file.  Can  be  called  several
              times,  for  different zones, or to add multiple addresses for a particular zone.  At this time it
              is only possible to set configuration before the first resolve is done.

       <b>ub_ctx_set_tls</b>
              Enable DNS over TLS (DoT) for machines set with <b>ub_ctx_set_fwd.</b>  At this time it is only  possible
              to set configuration before the first resolve is done.

       <b>ub_ctx_resolvconf</b>
              By  default the root servers are queried and full resolver mode is used, but you can use this call
              to read the list of nameservers to use from the filename given.  Usually "<a href="file:/etc/resolv.conf">/etc/resolv.conf</a>".  Uses
              those  nameservers  as caching proxies.  If they do not support DNSSEC, validation may fail.  Only
              nameservers are picked up, the searchdomain, ndots and  other  settings  from  <u><a href="../man5/resolv.conf.5.html">resolv.conf</a></u>(5)  are
              ignored.   If  fname  NULL  is  passed, "<a href="file:/etc/resolv.conf">/etc/resolv.conf</a>" is used (if on Windows, the system-wide
              configured nameserver is picked instead).  At this time it is only possible to  set  configuration
              before the first resolve is done.

       <b>ub_ctx_hosts</b>
              Read  list  of  hosts  from  the  filename  given.   Usually "<a href="file:/etc/hosts">/etc/hosts</a>". When queried for, these
              addresses are not marked DNSSEC secure. If fname NULL is  passed,  "<a href="file:/etc/hosts">/etc/hosts</a>"  is  used  (if  on
              Windows,  etc/hosts  from  WINDIR  is  picked  instead).   At this time it is only possible to set
              configuration before the first resolve is done.

       <b>ub_ctx_add_ta</b>
              Add a trust anchor to the given context.  At this time it is only possible  to  add  trusted  keys
              before  the  first  resolve  is  done.   The  format is a string, similar to the zone-file format,
              [domainname] [type] [rdata contents]. Both DS and DNSKEY records are accepted.

       <b>ub_ctx_add_ta_autr</b>
              Add filename with automatically tracked trust anchor to the given context.  Pass name  of  a  file
              with  the  managed  trust  anchor.   You  can create this file with <u><a href="../man8/unbound-anchor.8.html">unbound-anchor</a></u>(8) for the root
              anchor.  You can also create it with an initial file with one line with a DNSKEY or DS record.  If
              the file is writable, it is updated when the trust anchor  changes.   At  this  time  it  is  only
              possible to add trusted keys before the first resolve is done.

       <b>ub_ctx_add_ta_file</b>
              Add  trust  anchors  to the given context.  Pass name of a file with DS and DNSKEY records in zone
              file format.  At this time it is only possible to add trusted keys before  the  first  resolve  is
              done.

       <b>ub_ctx_trustedkeys</b>
              Add  trust  anchors  to  the  given  context.   Pass  the  name  of  a bind-style config file with
              trusted-keys{}.  At this time it is only possible to add trusted keys before the first resolve  is
              done.

       <b>ub_ctx_debugout</b>
              Set  debug  and  error  log  output  to  the given stream. Pass NULL to disable output. Default is
              stderr. File-names or using syslog can be enabled using config options, this routine is for  using
              your own stream.

       <b>ub_ctx_debuglevel</b>
              Set  debug verbosity for the context. Output is directed to stderr.  Higher debug level gives more
              output.

       <b>ub_ctx_async</b>
              Set a context behaviour for asynchronous action.  if set to true, enables threading and a call  to
              <b>ub_resolve_async</b> creates a thread to handle work in the background.  If false, a process is forked
              to  handle work in the background.  Changes to this setting after <b>ub_resolve_async</b> calls have been
              made have no effect (delete and re-create the context to change).

       <b>ub_poll</b>
              Poll a context to see if it has any new results.  Do not poll in a loop, instead  extract  the  fd
              below to poll for readiness, and then check, or wait using the wait routine.  Returns 0 if nothing
              to read, or nonzero if a result is available.  If nonzero, call <b>ub_process</b> to do callbacks.

       <b>ub_wait</b>
              Wait  for  a  context  to  finish with results. Calls <b>ub_process</b> after the wait for you. After the
              wait, there are no more outstanding asynchronous queries.

       <b>ub_fd</b>  Get file descriptor. Wait for it to become readable, at this point answers are returned  from  the
              asynchronous validating resolver.  Then call the <b>ub_process</b> to continue processing.

       <b>ub_process</b>
              Call this routine to continue processing results from the validating resolver (when the fd becomes
              readable).  Will perform necessary callbacks.

       <b>ub_resolve</b>
              Perform  resolution  and  validation  of  the  target  name.   The name is a domain name in a zero
              terminated text string.  The rrtype and  rrclass  are  DNS  type  and  class  codes.   The  result
              structure is newly allocated with the resulting data.

       <b>ub_resolve_async</b>
              Perform asynchronous resolution and validation of the target name.  Arguments mean the same as for
              <b>ub_resolve</b>  except  no  data  is  returned  immediately,  instead a callback is called later.  The
              callback receives a copy of the mydata pointer, that you  can  use  to  pass  information  to  the
              callback. The callback type is a function pointer to a function declared as

              void my_callback_function(void* my_arg, int err,
                                struct ub_result* result);

              The  async_id is returned so you can (at your option) decide to track it and cancel the request if
              needed.  If you pass a NULL pointer the async_id is not returned.

       <b>ub_cancel</b>
              Cancel an async query in progress.  This may return an error if the query does not exist,  or  the
              query is already being delivered, in that case you may still get a callback for the query.

       <b>ub_resolve_free</b>
              Free struct ub_result contents after use.

       <b>ub_strerror</b>
              Convert error value from one of the unbound library functions to a human readable string.

       <b>ub_ctx_print_local_zones</b>
              Debug printout the local authority information to debug output.

       <b>ub_ctx_zone_add</b>
              Add new zone to local authority info, like local-zone <u><a href="../man5/unbound.conf.5.html">unbound.conf</a></u>(5) statement.

       <b>ub_ctx_zone_remove</b>
              Delete zone from local authority info.

       <b>ub_ctx_data_add</b>
              Add resource record data to local authority info, like local-data <u><a href="../man5/unbound.conf.5.html">unbound.conf</a></u>(5) statement.

       <b>ub_ctx_data_remove</b>
              Delete local authority data from the name given.

</pre><h4><b>RESULT</b> <b>DATA</b> <b>STRUCTURE</b></h4><pre>
       The  result  of  the  DNS resolution and validation is returned as <u>struct</u> <u>ub_result</u>. The result structure
       contains the following entries.

            struct ub_result {
                 char* qname; /* text string, original question */
                 int qtype;   /* type code asked for */
                 int qclass;  /* class code asked for */
                 char** data; /* array of rdata items, NULL terminated*/
                 int* len;    /* array with lengths of rdata items */
                 char* canonname; /* canonical name of result */
                 int rcode;   /* additional error code in case of no data */
                 void* answer_packet; /* full network format answer packet */
                 int answer_len;  /* length of packet in octets */
                 int havedata; /* true if there is data */
                 int nxdomain; /* true if nodata because name does not exist */
                 int secure;   /* true if result is secure */
                 int bogus;    /* true if a security failure happened */
                 char* why_bogus; /* string with error if bogus */
                 int was_ratelimited; /* true if the query was ratelimited (SERVFAIL) by unbound */
                 int ttl;     /* number of seconds the result is valid */
            };

       If both secure and bogus are false, security was not enabled for the domain of the query.  Else, they are
       not both true, one of them is true.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       Many routines return an error code. The value 0 (zero) denotes no error happened.  Other  values  can  be
       passed  to  <b>ub_strerror</b> to obtain a readable error string.  <b>ub_strerror</b> returns a zero terminated string.
       <b>ub_ctx_create</b> returns NULL on an error (a malloc failure).  <b>ub_poll</b> returns true if some information  may
       be  available,  false  otherwise.   <b>ub_fd</b>  returns  a  file descriptor or -1 on error.  <b>ub_ctx_config</b> and
       <b>ub_ctx_resolvconf</b> attempt to leave errno informative on a function return with file read failure.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man5/unbound.conf.5.html">unbound.conf</a></u>(5), <u><a href="../man8/unbound.8.html">unbound</a></u>(8).

</pre><h4><b>AUTHORS</b></h4><pre>
       <b>Unbound</b> developers are mentioned in the CREDITS file in the distribution.

NLnet Labs                                        Oct 17, 2024                                     <u><a href="../man3/libunbound.3.html">libunbound</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>