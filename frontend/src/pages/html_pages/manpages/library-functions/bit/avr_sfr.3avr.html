<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>avr_sfr - <avr/sfr_defs.h>: Special function registers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/avr-libc">avr-libc_2.2.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       avr_sfr - &lt;avr/sfr_defs.h&gt;: Special function registers

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Modules</b>
       <b>Additional</b> <b>notes</b> <b>from</b> <b>&lt;avr/sfr_defs.h&gt;</b>

   <b>Bit</b> <b>manipulation</b>
       #define <b>_BV</b>(bit)   (1 &lt;&lt; (bit))

   <b>IO</b> <b>register</b> <b>bit</b> <b>manipulation</b>
       #define <b>bit_is_set</b>(sfr,  bit)   (_SFR_BYTE(sfr) &amp; <b>_BV</b>(bit))
       #define <b>bit_is_clear</b>(sfr,  bit)   (!(_SFR_BYTE(sfr) &amp; <b>_BV</b>(bit)))
       #define <b>loop_until_bit_is_set</b>(sfr,  bit)   do { } while (<b>bit_is_clear</b>(sfr, bit))
       #define <b>loop_until_bit_is_clear</b>(sfr,  bit)   do { } while (<b>bit_is_set</b>(sfr, bit))

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       When working with microcontrollers, many tasks usually consist of controlling internal peripherals, or
       external peripherals that are connected to the device. The entire IO address space is made available as
       <u>memory-mapped</u> <u>IO</u>, i.e. it can be accessed using all the MCU instructions that are applicable to normal
       data memory. For most AVR devices, the IO register space is mapped into the data memory address space
       with an offset of 0x20 since the bottom of this space is reserved for direct access to the MCU registers.
       (Actual SRAM is available only behind the IO register area, starting at some specific address depending
       on the device.)

       For example the user can access memory-mapped IO registers as if they were globally defined variables
       like this:

       PORTA = 0x33;
       unsigned char foo = PINA;

       The compiler will choose the correct instruction sequence to generate based on the address of the
       register being accessed.

       The advantage of using the memory-mapped registers in C programs is that it makes the programs more
       portable to other C compilers for the AVR platform.

       Note that special care must be taken when accessing some of the 16-bit timer IO registers where access
       from both the main program and within an interrupt context can happen. See <b>Why</b> <b>do</b> <b>some</b> <b>16-bit</b> <b>timer</b>
       <b>registers</b> <b>sometimes</b> <b>get</b> <b>trashed?</b>.

       <b>Porting</b> <b>programs</b> <b>that</b> <b>use</b> <b>the</b> <b>deprecated</b> <b>sbi/cbi</b> <b>macros</b>

       Access to the AVR single bit set and clear instructions are provided via the standard C bit manipulation
       commands. The sbi and cbi macros are no longer directly supported. sbi (sfr,bit) can be replaced by sfr
       |= <b>_BV(bit)</b> .

       i.e.: <b>sbi(PORTB,</b> <b>PB1)</b>; is now PORTB |= <b>_BV(PB1)</b>;

       This actually is more flexible than having sbi directly, as the optimizer will use a hardware sbi if
       appropriate, or a read/or/write operation if not appropriate. You do not need to keep track of which
       registers sbi/cbi will operate on.

       Likewise, cbi (sfr,bit) is now sfr &amp;= ~(<b>_BV(bit)</b>);

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>_BV(bit)</b>   <b>(1</b> <b>&lt;&lt;</b> <b>(bit))</b>
       #include &lt;avr/io.h&gt;

       Converts a bit number into a byte value.

       <b>Note</b>
           The bit shift is performed by the compiler which then inserts the result into the code. Thus, there
           is no run-time overhead when using <b>_BV()</b>.

   <b>#define</b> <b>bit_is_clear(sfr,</b> <b>bit)</b>   <b>(!(_SFR_BYTE(sfr)</b> <b>&amp;</b> <b>_BV(bit)))</b>
       #include &lt;avr/io.h&gt;

       Test whether bit bit in IO register sfr is clear. This will return non-zero if the bit is clear, and a 0
       if the bit is set.

   <b>#define</b> <b>bit_is_set(sfr,</b> <b>bit)</b>   <b>(_SFR_BYTE(sfr)</b> <b>&amp;</b> <b>_BV(bit))</b>
       #include &lt;avr/io.h&gt;

       Test whether bit bit in IO register sfr is set. This will return a 0 if the bit is clear, and non-zero if
       the bit is set.

   <b>#define</b> <b>loop_until_bit_is_clear(sfr,</b> <b>bit)</b>   <b>do</b> <b>{</b> <b>}</b> <b>while</b> <b>(bit_is_set(sfr,</b> <b>bit))</b>
       #include &lt;avr/io.h&gt;

       Wait until bit bit in IO register sfr is clear.

   <b>#define</b> <b>loop_until_bit_is_set(sfr,</b> <b>bit)</b>   <b>do</b> <b>{</b> <b>}</b> <b>while</b> <b>(bit_is_clear(sfr,</b> <b>bit))</b>
       #include &lt;avr/io.h&gt;

       Wait until bit bit in IO register sfr is set.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for AVR-LibC from the source code.

AVR-LibC                                          Version 2.2.1                                    <u><a href="../man3avr/avr_sfr.3avr.html">avr_sfr</a></u>(3avr)
</pre>
 </div>
</div></section>
</div>
</body>
</html>