<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libpbm - libnetpbm functions to read and write PBM image files</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnetpbm-dev">libnetpbm-dev_11.10.02-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libpbm - libnetpbm functions to read and write PBM image files

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;netpbm/pbm.h&gt;</b>

       <b>bit</b> <b>**pbm_allocarray(int</b> <u>cols</u><b>,</b>  <b>int</b> <u>rows</u><b>);</b>

       <b>bit</b> <b>*pbm_allocrow(int</b> <u>cols</u><b>);</b>

       <b>pbm_freearray(bit</b> <b>**</b><u>bits</u><b>,</b> <b>int</b> <u>rows</u><b>);</b>

       <b>pbm_freerow(bit</b> <b>*</b><u>bitrow</u><b>);</b>

       <b>void</b> <b>pbm_readpbminit(FILE</b> <b>*</b> <u>fp</u><b>,</b> <b>int</b> <b>*</b><u>colsP</u><b>,</b> <b>int</b> <b>*</b><u>rowsP</u><b>,</b> <b>int</b> <b>*</b><u>formatP</u><b>);</b>

       <b>void</b> <b>pbm_readpbmrow(FILE</b> <b>*</b> <u>fp</u><b>,</b> <b>bit</b> <b>*</b><u>bitrow</u><b>,</b> <b>int</b> <u>cols</u><b>,</b> <b>int</b> <u>format</u><b>);</b>

       <b>void</b>  <b>pbm_readpbmrow_packed(FILE</b>  <b>*</b>  <u>fp</u><b>,</b>  <b>unsigned</b>  <b>char</b>  <b>*</b>  <b>const</b> <u>packed_bits</u><b>,</b> <b>const</b> <b>int</b> <u>cols</u><b>,</b> <b>const</b> <b>int</b>
       <u>format</u><b>);</b>

       <b>void</b> <b>bit**</b> <b>pbm_readpbm(FILE</b> <b>*</b> <u>fp</u><b>,</b> <b>int</b> <b>*</b><u>colsP</u><b>,</b> <b>int</b> <b>*</b><u>rowsP</u><b>);</b>

       <b>void</b> <b>pbm_writepbminit(FILE</b> <b>*</b> <u>fp</u><b>,</b> <b>int</b> <u>cols</u><b>,</b> <b>int</b> <u>rows</u><b>,</b> <b>int</b> <u>forceplain</u><b>);</b>

       <b>void</b> <b>pbm_writepbmrow(FILE</b> <b>*</b> <u>fp</u><b>,</b> <b>bit</b> <b>*</b><u>bitrow</u><b>,</b> <b>int</b> <u>cols</u><b>,</b> <b>int</b> <u>forceplain</u><b>);</b>

       <b>void</b> <b>pbm_writepbmrow_packed(FILE</b> <b>*</b> <u>fp</u><b>,</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>const</b>  <u>packed_bits</u><b>,</b>  <b>const</b>  <b>int</b>  <u>cols</u><b>,</b>  <b>const</b>  <b>int</b>
       <u>forceplain</u><b>);</b>

       <b>void</b> <b>pbm_writepbm(FILE</b> <b>*</b> <u>fp</u><b>,</b> <b>bit</b> <b>**</b><u>bits</u><b>,</b> <b>int</b> <u>cols</u><b>,</b> <b>int</b> <u>rows</u><b>,</b> <b>int</b> <u>forceplain</u><b>);</b>

       <b>#define</b> <b>pbm_packed_bytes(</b><u>cols</u><b>)</b> <b>...</b>

       <b>void</b> <b>pbm_nextimage(</b> <b>FILE</b> <b>*</b><u>file</u><b>,</b> <b>int</b> <b>*</b> <b>const</b> <u>eofP</u><b>);</b>

       <b>void</b> <b>pbm_check(</b> <b>FILE</b> <b>*</b> <u>file</u><b>,</b> <b>const</b> <b>enum</b> <b>pm_check_type</b> <u>check_type</u><b>,</b> <b>const</b> <b>int</b> <u>format</u><b>,</b> <b>const</b> <b>int</b> <u>cols</u><b>,</b> <b>const</b>
       <b>int</b> <u>rows</u><b>,</b> <b>enum</b> <b>pm_check_code</b> <b>*</b> <b>const</b> <u>retval</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These library functions are part of <b><a href="../man1/Netpbm.1.html">Netpbm</a></b>(1).

   <b>TYPES</b> <b>AND</b> <b>CONSTANTS</b>
       <b>typedef</b> <b>...</b> <b>bit;</b>

       <b>#define</b> <b>PBM_WHITE</b> <b>...</b>

       <b>#define</b> <b>PBM_BLACK</b> <b>...</b>

       Each <b>bit</b> should contain only the values of <b>PBM_WHITE</b> or <b>PBM_BLACK</b>.

       <b>#define</b> <b>PBM_FORMAT</b> <b>...</b>

       <b>#define</b> <b>RPBM_FORMAT</b> <b>...</b>

       <b>#define</b> <b>PBM_TYPE</b> <b>PBM_FORMAT</b>

       <b>#define</b> <b>PBM_FORMAT_TYPE(</b><u>f</u><b>)</b> <b>...</b>

       These are for distinguishing different file formats and types.

   <b>INITIALIZATION</b>
       <b>pbm_init()</b> is obsolete (at least since Netpbm 9.25 (March 2002)).  Use <b>pm_proginit()</b>  instead.

       <b>pbm_init()</b> is identical to <b>pm_proginit</b>.

   <b>MEMORY</b> <b>MANAGEMENT</b>
       <b>pbm_allocarray()</b> allocates an array of bits.  <b>pbm_allocrow()</b> allocates a row of the given number of bits.
       <b>pbm_freearray()</b>  frees  the  array  allocated  with <b>pbm_allocarray()</b> containing the given number of rows.
       <b>pbm_freerow()</b> frees a row of bits.

   <b>READING</b> <b>PBM</b> <b>IMAGE</b> <b>FILES</b>
       <b>pbm_readpbminit()</b> reads the header from a PBM image in a PBM file, filling in the rows, cols  and  format
       variables.   <b>pbm_readpbmrow()</b>  reads a row of bits into the <u>bitrow</u> array.  Format and cols were filled in
       by <b>pbm_readpbminit()</b>.

       <b>pbm_readpbmrow_packed()</b> is like <b>pbm_readpbmrow()</b> except instead of returning a <b>bits</b> array, it returns  an
       array  <u>packed_bits</u>  of  bytes with the pixels of the image row packed into them.  The pixels are in order
       from left to right across the row and from the beginning of the array to the end.   Within  a  byte,  the
       bits are in order from the most significant bit to the least significant bit.  If the number of pixels in
       the  row  is not a multiple of 8, the last byte returned is padded on the least significant bit side with
       undefined bits.  White is represented by a <b>PBM_WHITE</b> bit; black by <b>PBM_BLACK</b>.

       <b>pbm_readpbm()</b> reads an entire bitmap file into memory, returning the allocated array and filling  in  the
       rows   and   cols   variables.    This   function   combines   <b>pbm_readpbminit()</b>,   <b>pbm_allocarray()</b>  and
       <b>pbm_readpbmrow()</b>.

       <b>pbm_readpbminit()</b> and <b>pbm_readpbm</b> abort the program with a message to Standard Error  if  the  PBM  image
       header  is not syntactically valid, including if it contains a number too large to be processed using the
       system's normal data structures (to wit, a number that won't fit in a C 'int').

       <b>ppm_readppminit()</b> and <b>ppm_readppm</b> abort the program with a message to Standard Error  if  the  PPM  image
       header  is not syntactically valid, including if it contains a number too large to be processed using the
       system's normal data structures (to wit, a number that won't fit in a C 'int').

   <b>WRITING</b> <b>PBM</b> <b>IMAGE</b> <b>FILES</b>
       <b>pbm_writepbminit()</b> writes the header for a PBM image in a  PBM  file.   <u>forceplain</u>  is  a  boolean  value
       specifying  that  a  plain  format  (text)  file  to be written, as opposed to a raw format (binary) one.
       <b>pbm_writepbmrow()</b> writes a row to a PBM file.  <b>pbm_writepbmrow_packed()</b> is the same as  <b>pbm_writepbmrow()</b>
       except that you supply the row to write as an array of bytes packed with bits instead of as a <b>bits</b> array.
       The format of <u>packed_bits</u>  is the same as that returned by <b>pbm_readpbmrow()</b>.

       <b>pbm_writepbm()</b>  writes  the  header  and  all data for a PBM image to a PBM file.  This function combines
       <b>pbm_writepbminit()</b> and <b>pbm_writepbmrow()</b>.

   <b>MISCELLANEOUS</b>
       <b>pbm_nextimage()</b>  positions  a  PBM  input  file  to  the  next  image  in  it  (so  that   a   subsequent
       <b>pbm_readpbminit()</b> reads its header).

       Immediately  before  a call to <b>pbm_nextimage()</b>, the file must be positioned either at its beginning (i.e.
       nothing has been read from the file yet) or just after an image (i.e. as left by a  <b>pbm_readpbmrow()</b>   of
       the last row in the image).

       Note  that  in  the  raw  PNM and PAM format, the next image always starts immediately after the previous
       image, so all <b>pbm_nextimage()</b> really does is test whether there is a next image or the file is positioned
       at end-of-file.  In plain PNM, though, there may be white space between images.

       If <b>pbm_nextimage()</b>  successfully positions to the next image, it returns <b>*</b><u>eofP</u> false (0).  If there is no
       next image in the file, it returns <b>*</b><u>eofP</u> true .  If it  can't  position  or  determine  the  file  status
       because of a file error, it throws an error .

       <b>pbm_check()</b>  checks  for  the common file integrity error where the file is the wrong size to contain all
       the  image  data.   <b>pbm_check()</b>  assumes  the  file  is  positioned  after  an  image   header   (as   if
       <b>pbm_readpbminit()</b>   was the last operation on the file).  It checks the file size to see if the number of
       bytes left in the file are the number required to contain the image raster.  If the file  is  too  short,
       <b>pbm_check()</b>  causes  the  program  t throws an error .  Otherwise, it returns one of the following values
       (enumerations of the <b>enum</b> <b>pm_check_code</b> type) as <b>*</b><u>retval</u>:

       <b>PM_CHECK_OK</b>
              The file's size is exactly what is required to hold the image raster.

       <b>PM_CHECK_UNKNOWN_TYPE</b>
              <u>format</u> is not a format whose  size  <b>pbm_check()</b>  can  anticipate.   The  only  format  with  which
              <b>pbm_check()</b> can deal is raw PBM format.

       <b>PM_CHECK_TOO_LONG</b>
              The  file  is  longer  than  it  needs to be to contain the image raster.  The extra data might be
              another image.

       <b>PM_CHECK_UNCHECKABLE</b>
              The file is not a kind that has a predictable size, so there is no simple way for  <b>pbm_check()</b>  to
              know  if  it  is  the  right  size.  Only a regular file has predictable size.  A pipe is a common
              example of a file that does not.

       <u>check_type</u> must have the value <b>PM_CHECK_BASIC</b>  (an  enumerated  value  of  the  <b>pm_check_type</b>  enumerated
       type).   Otherwise, the effect of <b>pbm_check()</b> is unpredictable.  This argument exists for future backward
       compatible expansion of the function of <b>pbm_check()</b>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/libpgm.1.html">libpgm</a></b>(1), <b><a href="../man1/libppm.1.html">libppm</a></b>(1), <b><a href="../man1/libpnm.1.html">libpnm</a></b>(1), <b><a href="../man1/pbm.1.html">pbm</a></b>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) 1989, 1991 by Tony Hansen and Jef Poskanzer.

</pre><h4><b>DOCUMENT</b> <b>SOURCE</b></h4><pre>
       This manual page was generated by the Netpbm tool 'makeman' from HTML source.  The  master  documentation
       is at

              <b><a href="http://netpbm.sourceforge.net/doc/libpbm.html">http://netpbm.sourceforge.net/doc/libpbm.html</a></b>

netpbm documentation                            08 September 2007           <u>User</u> <u>manual</u> <u>for</u> <u>old</u> <u>pbm</u> <u><a href="../man3/functions.3.html">functions</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>