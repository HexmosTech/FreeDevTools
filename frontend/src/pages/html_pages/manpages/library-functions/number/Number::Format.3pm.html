<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number::Format - Perl extension for formatting numbers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnumber-format-perl">libnumber-format-perl_1.76-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Number::Format - Perl extension for formatting numbers

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Number::Format;
         my $x = new Number::Format %args;
         $formatted = $x-&gt;round($number, $precision);
         $formatted = $x-&gt;format_number($number, $precision, $trailing_zeroes);
         $formatted = $x-&gt;format_negative($number, $picture);
         $formatted = $x-&gt;format_picture($number, $picture);
         $formatted = $x-&gt;format_price($number, $precision, $symbol);
         $formatted = $x-&gt;format_bytes($number, $precision);
         $number    = $x-&gt;unformat_number($formatted);

         use Number::Format qw(:subs);
         $formatted = round($number, $precision);
         $formatted = format_number($number, $precision, $trailing_zeroes);
         $formatted = format_negative($number, $picture);
         $formatted = format_picture($number, $picture);
         $formatted = format_price($number, $precision, $symbol);
         $formatted = format_bytes($number, $precision);
         $number    = unformat_number($formatted);

</pre><h4><b>REQUIRES</b></h4><pre>
       Perl, version 5.8 or higher.

       POSIX.pm to determine locale settings.

       Carp.pm is used for some error reporting.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These functions provide an easy means of formatting numbers in a manner suitable for displaying to the
       user.

       There are two ways to use this package.  One is to declare an object of type Number::Format, which you
       can think of as a formatting engine.  The various functions defined here are provided as object methods.
       The constructor "new()" can be used to set the parameters of the formatting engine.  Valid parameters
       are:

         THOUSANDS_SEP     - character inserted between groups of 3 digits
         DECIMAL_POINT     - character separating integer and fractional parts
         MON_THOUSANDS_SEP - like THOUSANDS_SEP, but used for format_price
         MON_DECIMAL_POINT - like DECIMAL_POINT, but used for format_price
         INT_CURR_SYMBOL   - character(s) denoting currency (see format_price())
         DECIMAL_DIGITS    - number of digits to the right of dec point (def 2)
         DECIMAL_FILL      - boolean; whether to add zeroes to fill out decimal
         NEG_FORMAT        - format to display negative numbers (def ``-x'')
         KILO_SUFFIX       - suffix to add when format_bytes formats kilobytes (trad)
         MEGA_SUFFIX       -    "    "  "    "        "         "    megabytes (trad)
         GIGA_SUFFIX       -    "    "  "    "        "         "    gigabytes (trad)
         KIBI_SUFFIX       - suffix to add when format_bytes formats kibibytes (iec)
         MEBI_SUFFIX       -    "    "  "    "        "         "    mebibytes (iec)
         GIBI_SUFFIX       -    "    "  "    "        "         "    gibibytes (iec)

       They may be specified in upper or lower case, with or without a leading hyphen ( - ).

       If "THOUSANDS_SEP" is set to the empty string, format_number will not insert any separators.

       The defaults for "THOUSANDS_SEP", "DECIMAL_POINT", "MON_THOUSANDS_SEP", "MON_DECIMAL_POINT", and
       "INT_CURR_SYMBOL" come from the POSIX locale information (see perllocale).  If your POSIX locale does not
       provide "MON_THOUSANDS_SEP" and/or "MON_DECIMAL_POINT" fields, then the "THOUSANDS_SEP" and/or
       "DECIMAL_POINT" values are used for those parameters.  Formerly, POSIX was optional but this caused
       problems in some cases, so it is now required.  If this causes you hardship, please contact the author of
       this package at &lt;<a href="mailto:SwPrAwM@cpan.org">SwPrAwM@cpan.org</a>&gt; (remove "SPAM" to get correct email address) for help.

       If any of the above parameters are not specified when you invoke "new()", then the values are taken from
       package global variables of the same name (e.g.  $DECIMAL_POINT is the default for the "DECIMAL_POINT"
       parameter).  If you use the ":vars" keyword on your "use Number::Format" line (see non-object-oriented
       example below) you will import those variables into your namesapce and can assign values as if they were
       your own local variables.  The default values for all the parameters are:

         THOUSANDS_SEP     = ','
         DECIMAL_POINT     = '.'
         MON_THOUSANDS_SEP = ','
         MON_DECIMAL_POINT = '.'
         INT_CURR_SYMBOL   = 'USD'
         DECIMAL_DIGITS    = 2
         DECIMAL_FILL      = 0
         NEG_FORMAT        = '-x'
         KILO_SUFFIX       = 'K'
         MEGA_SUFFIX       = 'M'
         GIGA_SUFFIX       = 'G'
         KIBI_SUFFIX       = 'KiB'
         MEBI_SUFFIX       = 'MiB'
         GIBI_SUFFIX       = 'GiB'

       Note however that when you first call one of the functions in this module <u>without</u> using the object-
       oriented interface, further setting of those global variables will have no effect on non-OO calls.  It is
       recommended that you use the object-oriented interface instead for fewer headaches and a cleaner design.

       The "DECIMAL_FILL" and "DECIMAL_DIGITS" values are not set by the Locale system, but are definable by the
       user.  They affect the output of "format_number()".  Setting "DECIMAL_DIGITS" is like giving that value
       as the $precision argument to that function.  Setting "DECIMAL_FILL" to a true value causes
       "format_number()" to append zeroes to the right of the decimal digits until the length is the specified
       number of digits.

       "NEG_FORMAT" is only used by "format_negative()" and is a string containing the letter 'x', where that
       letter will be replaced by a positive representation of the number being passed to that function.
       "format_number()" and "format_price()" utilize this feature by calling "format_negative()" if the number
       was less than 0.

       "KILO_SUFFIX", "MEGA_SUFFIX", and "GIGA_SUFFIX" are used by "format_bytes()" when the value is over 1024,
       1024*1024, or 1024*1024*1024, respectively.  The default values are "K", "M", and "G".  These apply in
       the default "traditional" mode only.  Note: TERA or higher are not implemented because of integer
       overflows on 32-bit systems.

       "KIBI_SUFFIX", "MEBI_SUFFIX", and "GIBI_SUFFIX" are used by "format_bytes()" when the value is over 1024,
       1024*1024, or 1024*1024*1024, respectively.  The default values are "KiB", "MiB", and "GiB".  These apply
       in the "iso60027"" mode only.  Note: TEBI or higher are not implemented because of integer overflows on
       32-bit systems.

       The only restrictions on "DECIMAL_POINT" and "THOUSANDS_SEP" are that they must not be digits and must
       not be identical.  There are no restrictions on "INT_CURR_SYMBOL".

       For example, a German user might include this in their code:

         use Number::Format;
         my $de = new Number::Format(-thousands_sep   =&gt; '.',
                                     -decimal_point   =&gt; ',',
                                     -int_curr_symbol =&gt; 'DEM');
         my $formatted = $de-&gt;format_number($number);

       Or, if you prefer not to use the object oriented interface, you can do this instead:

         use Number::Format qw(:subs :vars);
         $THOUSANDS_SEP   = '.';
         $DECIMAL_POINT   = ',';
         $INT_CURR_SYMBOL = 'DEM';
         my $formatted = format_number($number);

</pre><h4><b>EXPORTS</b></h4><pre>
       Nothing is exported by default.  To export the functions or the global variables defined herein, specify
       the function name(s) on the import list of the "use Number::Format" statement.  To export all functions
       defined herein, use the special tag ":subs".  To export the variables, use the special tag ":vars"; to
       export both subs and vars you can use the tag ":all".

</pre><h4><b>METHODS</b></h4><pre>
       new( %args )
           Creates a new Number::Format object.  Valid keys for %args are any of the parameters described above.
           Keys  may  be  in  all  uppercase  or  all  lowercase, and may optionally be preceded by a hyphen (-)
           character.  Example:

             my $de = new Number::Format(-thousands_sep   =&gt; '.',
                                         -decimal_point   =&gt; ',',
                                         -int_curr_symbol =&gt; 'DEM');

       round($number, $precision)
           Rounds the number  to  the  specified  precision.   If  $precision  is  omitted,  the  value  of  the
           "DECIMAL_DIGITS"  parameter  is  used  (default  value  2).   Both  input and output are numeric (the
           function uses math operators rather than string manipulation to do its job), The value of  $precision
           may be any integer, positive or negative. Examples:

             round(3.14159)       yields    3.14
             round(3.14159, 4)    yields    3.1416
             round(42.00, 4)      yields    42
             round(1234, -2)      yields    1200

           Since  this  is a mathematical rather than string oriented function, there will be no trailing zeroes
           to the right of the decimal point, and the "DECIMAL_POINT" and "THOUSANDS_SEP" variables are ignored.
           To format your number using the "DECIMAL_POINT" and "THOUSANDS_SEP" variables, use  "format_number()"
           instead.

       format_number($number, $precision, $trailing_zeroes)
           Formats  a  number  by adding "THOUSANDS_SEP" between each set of 3 digits to the left of the decimal
           point, substituting "DECIMAL_POINT" for the decimal point, and rounding to  the  specified  precision
           using  "round()".   Note  that $precision is a <u>maximum</u> precision specifier; trailing zeroes will only
           appear in the output if $trailing_zeroes is provided, or the parameter "DECIMAL_FILL" is set, with  a
           value  that  is  true (not zero, undef, or the empty string).  If $precision is omitted, the value of
           the "DECIMAL_DIGITS" parameter (default value of 2) is used.

           If the value is too large or great to work with as a regular number, but instead  must  be  shown  in
           scientific notation, returns that number in scientific notation without further formatting.

           Examples:

             format_number(12345.6789)             yields   '12,345.68'
             format_number(123456.789, 2)          yields   '123,456.79'
             format_number(1234567.89, 2)          yields   '1,234,567.89'
             format_number(1234567.8, 2)           yields   '1,234,567.8'
             format_number(1234567.8, 2, 1)        yields   '1,234,567.80'
             format_number(1.23456789, 6)          yields   '1.234568'
             format_number("0.000020000E+00", 7);' yields   '2e-05'

           Of course the output would have your values of "THOUSANDS_SEP" and "DECIMAL_POINT" instead of ',' and
           '.' respectively.

       format_negative($number, $picture)
           Formats  a negative number.  Picture should be a string that contains the letter "x" where the number
           should be inserted.  For example, for standard negative numbers you might  use  ``"-x"'',  while  for
           accounting  purposes you might use ``"(x)"''.  If the specified number begins with a ``-'' character,
           that will be removed before formatting, but formatting will  occur  whether  or  not  the  number  is
           negative.

       format_picture($number, $picture)
           Returns  a  string based on $picture with the "#" characters replaced by digits from $number.  If the
           length of the integer part of $number is too large to fit,  the  "#"  characters  are  replaced  with
           asterisks ("*") instead.  Examples:

             format_picture(100.023, 'USD ##,###.##')   yields   'USD    100.02'
             format_picture(1000.23, 'USD ##,###.##')   yields   'USD  1,000.23'
             format_picture(10002.3, 'USD ##,###.##')   yields   'USD 10,002.30'
             format_picture(100023,  'USD ##,###.##')   yields   'USD **,***.**'
             format_picture(1.00023, 'USD #.###,###')   yields   'USD 1.002,300'

           The  comma  (,)  and  period  (.)  you  see  in  the  picture  examples  should  match  the values of
           "THOUSANDS_SEP"  and   "DECIMAL_POINT",   respectively,   for   proper   operation.    However,   the
           "THOUSANDS_SEP"  characters  in  $picture  need  not  occur  every three digits; the <u>only</u> use of that
           variable by this function is to remove leading commas (see the first example above).  There  may  not
           be more than one instance of "DECIMAL_POINT" in $picture.

           The  value  of  "NEG_FORMAT"  is used to determine how negative numbers are displayed.  The result of
           this is that the output of this function my have unexpected spaces before and/or  after  the  number.
           This is necessary so that positive and negative numbers are formatted into a space the same size.  If
           you are only using positive numbers and want to avoid this problem, set NEG_FORMAT to "x".

       format_price($number, $precision, $symbol)
           Returns a string containing $number formatted similarly to "format_number()", except that the decimal
           portion  may  have  trailing  zeroes  added to make it be exactly $precision characters long, and the
           currency string will be prefixed.

           The $symbol attribute may be one of "INT_CURR_SYMBOL" or "CURRENCY_SYMBOL" (case insensitive) to  use
           the value of that attribute of the object, or a string containing the symbol to be used.  The default
           is  "INT_CURR_SYMBOL"  if  this argument is undefined or not given; if set to the empty string, or if
           set to undef and the "INT_CURR_SYMBOL" attribute of the object is the empty string, no currency  will
           be added.

           If $precision is not provided, the default of 2 will be used.  Examples:

             format_price(12.95)   yields   'USD 12.95'
             <a href="../man12/format_price.12.html">format_price</a>(12)      yields   'USD 12.00'
             format_price(12, 3)   yields   '12.000'

           The third example assumes that "INT_CURR_SYMBOL" is the empty string.

       format_bytes($number, %options)
       format_bytes($number, $precision)  # deprecated
           Returns  a  string  containing  $number  formatted  similarly to "format_number()", except that large
           numbers may be abbreviated by adding a suffix to indicate 1024, 1,048,576,  or  1,073,741,824  bytes.
           Suffix  may be the traditional K, M, or G (default); or the IEC standard 60027 "KiB," "MiB," or "GiB"
           depending on the "mode" option.

           Negative values will result in an error.

           The second parameter can be either a hash that sets options, or a number.  Using  a  number  here  is
           deprecated  and  will  generate  a  warning;  early versions of Number::Format only allowed a numeric
           value.  A future release of Number::Format will change this warning to an error.  New code should use
           a hash instead to set options.  If it is a number this sets the value of the "precision" option.

           Valid options are:

           precision
               Set the precision for displaying numbers.  If  not  provided,  a  default  of  2  will  be  used.
               Examples:

                 format_bytes(12.95)                   yields   '12.95'
                 format_bytes(12.95, precision =&gt; 0)   yields   '13'
                 <a href="../man2048/format_bytes.2048.html">format_bytes</a>(2048)                    yields   '2K'
                 format_bytes(2048, mode =&gt; "iec")     yields   '2KiB'
                 <a href="../man9999999/format_bytes.9999999.html">format_bytes</a>(9999999)                 yields   '9.54M'
                 format_bytes(9999999, precision =&gt; 1) yields   '9.5M'

           unit
               Sets  the  default units used for the results.  The default is to determine this automatically in
               order to minimize the length of the string.  In other words, numbers greater  than  or  equal  to
               1024  (or other number given by the 'base' option, q.v.) will be divided by 1024 and $KILO_SUFFIX
               or $KIBI_SUFFIX added; if greater than or equal to 1048576 (1024*1024), it  will  be  divided  by
               1048576 and $MEGA_SUFFIX or $MEBI_SUFFIX appended to the end; etc.

               However  if  a value is given for "unit" it will use that value instead.  The first letter (case-
               insensitive) of the value given indicates the threshhold for conversion; acceptable values are  G
               (for  giga/gibi),  M  (for mega/mebi), K (for kilo/kibi), or A (for automatic, the default).  For
               example:

                 format_bytes(1048576, unit =&gt; 'K') yields     '1,024K'
                                                    instead of '1M'

               Note that the valid values to this  option  do  not  vary  even  when  the  suffix  configuration
               variables have been changed.

           base
               Sets the number at which the $KILO_SUFFIX is added.  Default is 1024.  Set to any value; the only
               other  useful  value  is  probably 1000, as hard disk manufacturers use that number to make their
               disks sound bigger than they really are.

               If the mode (see below) is set to "iec" or "iec60027" then setting the base option results in  an
               error.

           mode
               Traditionally,  bytes  have been given in SI (metric) units such as "kilo" and "mega" even though
               they represent powers of 2 (1024, etc.)  rather than powers of  10  (1000,  etc.)   This  "binary
               prefix"  causes  much  confusion  in  consumer  products  where "GB" may mean either 1,048,576 or
               1,000,000, for example.  The International Electrotechnical Commission has created  standard  IEC
               60027  to  introduce  prefixes  Ki, Mi, Gi, etc. ("kibibytes," "mebibytes," "gibibytes," etc.) to
               remove this confusion.  Specify a  mode  option  with  either  "traditional"  or  "iec60027"  (or
               abbreviate  as  "trad" or "iec") to indicate which type of binary prefix you want format_bytes to
               use.     For    backward    compatibility,     "traditional"     is     the     default.      See
               <a href="http://en.wikipedia.org/wiki/Binary_prefix">http://en.wikipedia.org/wiki/Binary_prefix</a> for more information.

       unformat_number($formatted)
           Converts  a  string  as  returned  by "format_number()", "format_price()", or "format_picture()", and
           returns the corresponding value as a numeric scalar.  Returns "undef" if the number does not  contain
           any digits.  Examples:

             unformat_number('USD 12.95')   yields   12.95
             unformat_number('USD 12.00')   yields   12
             unformat_number('foobar')      yields   undef
             unformat_number('1234-567@.8') yields   1234567.8

           The  value of "DECIMAL_POINT" is used to determine where to separate the integer and decimal portions
           of the input.  All other non-digit characters, including but not  limited  to  "INT_CURR_SYMBOL"  and
           "THOUSANDS_SEP", are removed.

           If  the  number  matches  the pattern of "NEG_FORMAT" <u>or</u> there is a ``-'' character before any of the
           digits, then a negative number is returned.

           If  the  number  ends  with   the   "KILO_SUFFIX",   "KIBI_SUFFIX",   "MEGA_SUFFIX",   "MEBI_SUFFIX",
           "GIGA_SUFFIX",  or  "GIBI_SUFFIX"  characters,  then  the  number  returned will be multiplied by the
           appropriate multiple of 1024 (or if the base option is given, by  the  multiple  of  that  value)  as
           appropriate.  Examples:

             unformat_number("4K", base =&gt; 1024)   yields  4096
             unformat_number("4K", base =&gt; 1000)   yields  4000
             unformat_number("4KiB", base =&gt; 1024) yields  4096
             unformat_number("4G")                 yields  4294967296

</pre><h4><b>CAVEATS</b></h4><pre>
       Some  systems,  notably  OpenBSD,  may  have  incomplete locale support.  Using this module together with
       <b><a href="../man3/setlocale.3.html">setlocale</a></b>(3) in OpenBSD may therefore not produce the intended results.

</pre><h4><b>BUGS</b></h4><pre>
       No   known   bugs   at   this   time.    Report   bugs   using    the    CPAN    request    tracker    at
       &lt;https://rt.cpan.org/NoAuth/Bugs.html?Dist=Number-Format&gt; or by email to the author.

</pre><h4><b>AUTHOR</b></h4><pre>
       William R. Ward, <a href="mailto:SwPrAwM@cpan.org">SwPrAwM@cpan.org</a> (remove "SPAM" before sending email, leaving only my initials)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1).

perl v5.36.0                                       2023-07-05                                        <u><a href="../man3pm/Format.3pm.html">Format</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>