<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>atf_add_test_case,   atf_check,  atf_check_equal,  atf_check_not_equal,  atf_config_get,  atf_config_has,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libatf-dev">libatf-dev_0.22-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       atf_add_test_case,   atf_check,  atf_check_equal,  atf_check_not_equal,  atf_config_get,  atf_config_has,
       atf_expect_death,     atf_expect_exit,     atf_expect_fail,      atf_expect_pass,      atf_expect_signal,
       atf_expect_timeout,  atf_fail,  atf_get,  atf_get_srcdir,  atf_pass, atf_require_prog, atf_set, atf_skip,
       atf_test_case — POSIX shell API to write ATF-based test programs

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>atf_add_test_case</b> "name"
       <b>atf_check</b> "command"
       <b>atf_check_equal</b> "expected_expression" "actual_expression"
       <b>atf_check_not_equal</b> "expected_expression" "actual_expression"
       <b>atf_config_get</b> "var_name"
       <b>atf_config_has</b> "var_name"
       <b>atf_expect_death</b> "reason" "..."
       <b>atf_expect_exit</b> "exitcode" "reason" "..."
       <b>atf_expect_fail</b> "reason" "..."
       <b>atf_expect_pass</b> ""
       <b>atf_expect_signal</b> "signo" "reason" "..."
       <b>atf_expect_timeout</b> "reason" "..."
       <b>atf_fail</b> "reason"
       <b>atf_get</b> "var_name"
       <b>atf_get_srcdir</b>
       <b>atf_pass</b>
       <b>atf_require_prog</b> "prog_name"
       <b>atf_set</b> "var_name" "value"
       <b>atf_skip</b> "reason"
       <b>atf_test_case</b> "name" "cleanup"

</pre><h4><b>DESCRIPTION</b></h4><pre>
       ATF provides a simple but powerful interface to easily write test programs in the POSIX  shell  language.
       These  are  extremely helpful given that they are trivial to write due to the language simplicity and the
       great deal of available external tools, so they are often ideal to test other applications  at  the  user
       level.

       Test  programs  written  using  this  library  must be run using the <u><a href="../man1/atf-sh.1.html">atf-sh</a></u>(1) interpreter by putting the
       following on their very first line:

             #! <a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?env">/usr/bin/env</a> atf-sh

       Shell-based test programs always follow this template:

             atf_test_case tc1
             tc1_head() {
                 ... first test case's header ...
             }
             tc1_body() {
                 ... first test case's body ...
             }

             atf_test_case tc2 cleanup
             tc2_head() {
                 ... second test case's header ...
             }
             tc2_body() {
                 ... second test case's body ...
             }
             tc2_cleanup() {
                 ... second test case's cleanup ...
             }

             ... additional test cases ...

             atf_init_test_cases() {
                 atf_add_test_case tc1
                 atf_add_test_case tc2
                 ... add additional test cases ...
             }

   <b>Definition</b> <b>of</b> <b>test</b> <b>cases</b>
       Test cases have an identifier and are composed of three different parts: the  header,  the  body  and  an
       optional  cleanup routine, all of which are described in <u><a href="../man4/atf-test-case.4.html">atf-test-case</a></u>(4).  To define test cases, one can
       use the <b>atf_test_case</b> function, which takes a  first  parameter  specifying  the  test  case's  name  and
       instructs  the  library  to  set  things  up  to accept it as a valid test case.  The second parameter is
       optional and, if provided, must be ‘cleanup’; providing this parameter allows defining a cleanup  routine
       for  the  test  case.   It  is  important  to  note  that this function <u>does</u> <u>not</u> set the test case up for
       execution when the program is run.  In order to do  so,  a  later  registration  is  needed  through  the
       <b>atf_add_test_case</b> function detailed in “Program initialization”.

       Later  on, one must define the three parts of the body by providing two or three functions (remember that
       the cleanup routine is optional).  These functions are named after the test case's  identifier,  and  are
       <b>&lt;id&gt;_head</b>, <b>&lt;id&gt;_body</b> and <b>&lt;id&gt;_cleanup</b>.  None of these take parameters when executed.

   <b>Program</b> <b>initialization</b>
       The  test program must define an <b>atf_init_test_cases</b> function, which is in charge of registering the test
       cases that will be executed at run time by using the <b>atf_add_test_case</b> function, which takes the name  of
       a  test  case  as  its  single  parameter.   This main function should not do anything else, except maybe
       sourcing auxiliary source files that define extra variables and functions.

   <b>Configuration</b> <b>variables</b>
       The test case has read-only access to the current configuration variables through the <b>atf_config_has</b>  and
       <b>atf_config_get</b>  methods.   The  former  takes a single parameter specifying a variable name and returns a
       boolean indicating whether the variable is defined or not.  The latter can take one  or  two  parameters.
       If  it  takes  only one, it specifies the variable from which to get the value, and this variable must be
       defined.  If it takes two, the second one specifies a default value to be returned if the variable is not
       available.

   <b>Access</b> <b>to</b> <b>the</b> <b>source</b> <b>directory</b>
       It is possible to get the path to the test case's source directory from anywhere in the test  program  by
       using   the  <b>atf_get_srcdir</b>  function.   It  is  interesting  to  note  that  this  can  be  used  inside
       <b>atf_init_test_cases</b> to silently include additional helper files from the source directory.

   <b>Requiring</b> <b>programs</b>
       Aside from the <u>require.progs</u> meta-data variable available in the header only,  one  can  also  check  for
       additional  programs in the test case's body by using the <b>atf_require_prog</b> function, which takes the base
       name or full path of a single binary.  Relative paths are forbidden.  If it is not found, the  test  case
       will be automatically skipped.

   <b>Test</b> <b>case</b> <b>finalization</b>
       The  test case finalizes either when the body reaches its end, at which point the test is assumed to have
       <u>passed</u>, or at any explicit call to <b>atf_pass</b>, <b>atf_fail</b> or <b>atf_skip</b>.  These three functions  terminate  the
       execution of the test case immediately.  The cleanup routine will be processed afterwards in a completely
       automated way, regardless of the test case's termination reason.

       <b>atf_pass</b>  does  not  take  any  parameters.   <b>atf_fail</b>  and  <b>atf_skip</b> take a single string parameter that
       describes why the test case failed or was skipped, respectively.  It is very important to provide a clear
       error message in both cases so that the user can quickly know why the test did not pass.

   <b>Expectations</b>
       Everything explained in the previous section changes when the test case expectations are redefined by the
       programmer.

       Each test case has an internal state called ‘expect’ that describes what the test case  expectations  are
       at any point in time.  The value of this property can change during execution by any of:

       <b>atf_expect_death</b> "reason" "..."
               Expects the test case to exit prematurely regardless of the nature of the exit.

       <b>atf_expect_exit</b> "exitcode" "reason" "..."
               Expects the test case to exit cleanly.  If <u>exitcode</u> is not ‘-1’, the runtime engine will validate
               that  the exit code of the test case matches the one provided in this call.  Otherwise, the exact
               value will be ignored.

       <b>atf_expect_fail</b> "reason"
               Any failure raised in this mode is recorded, but such failures do not report  the  test  case  as
               failed;  instead,  the  test  case  finalizes cleanly and is reported as ‘expected failure’; this
               report includes the provided <u>reason</u> as part of it.  If no error is raised while running  in  this
               mode, then the test case is reported as ‘failed’.

               This  mode  is  useful to reproduce actual known bugs in tests.  Whenever the developer fixes the
               bug later on, the test case will start reporting a failure, signaling the developer that the test
               case must be adjusted to the new conditions.  In this situation, it is useful,  for  example,  to
               set <u>reason</u> as the bug number for tracking purposes.

       <b>atf_expect_pass</b>
               This  is the normal mode of execution.  In this mode, any failure is reported as such to the user
               and the test case is marked as ‘failed’.

       <b>atf_expect_signal</b> "signo" "reason" "..."
               Expects the test case to terminate due to the reception of a signal.  If <u>signo</u> is not  ‘-1’,  the
               runtime  engine  will  validate  that  the  signal  that terminated the test case matches the one
               provided in this call.  Otherwise, the exact value will be ignored.

       <b>atf_expect_timeout</b> "reason" "..."
               Expects the test case to execute for longer than its timeout.

   <b>Helper</b> <b>functions</b> <b>for</b> <b>common</b> <b>checks</b>
       <b>atf_check</b> "[options]" "command" "[args]"
               Executes a command, performs checks on its exit code and its output, and fails the test  case  if
               any  of  the checks is not successful.  This function is particularly useful in integration tests
               that verify the correct functioning of a binary.

               Internally, this function is just a  wrapper  over  the  <u><a href="../man1/atf-check.1.html">atf-check</a></u>(1)  tool  (whose  manual  page
               provides  all  details  on  the  calling  syntax).   You should always use the <b>atf_check</b> function
               instead of the <u><a href="../man1/atf-check.1.html">atf-check</a></u>(1) tool in your scripts; the latter is not even in the path.

       <b>atf_check_equal</b> "expected_expression" "actual_expression"
               This function takes two expressions, evaluates them and, if their results differ, aborts the test
               case with an appropriate failure message.  The common style is to put the expected value  in  the
               first parameter and the actual value in the second parameter.

       <b>atf_check_not_equal</b> "expected_expression" "actual_expression"
               This  function  takes two expressions, evaluates them and, if their results are equal, aborts the
               test case with an appropriate failure message.  The common style is to put the expected value  in
               the first parameter and the actual value in the second parameter.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following shows a complete test program with a single test case that validates the addition operator:

             atf_test_case addition
             addition_head() {
                 atf_set "descr" "Sample tests for the addition operator"
             }
             addition_body() {
                 atf_check_equal 0 $((0 + 0))
                 atf_check_equal 1 $((0 + 1))
                 atf_check_equal 1 $((1 + 0))

                 atf_check_equal 2 $((1 + 1))

                 atf_check_equal 300 $((100 + 200))
             }

             atf_init_test_cases() {
                 atf_add_test_case addition
             }

       This other example shows how to include a file with extra helper functions in the test program:

             ... definition of test cases ...

             atf_init_test_cases() {
                 . $(atf_get_srcdir)/helper_functions.sh

                 atf_add_test_case foo1
                 atf_add_test_case foo2
             }

       This example demonstrates the use of the very useful <b>atf_check</b> function:

             # Check for silent output
             atf_check -s exit:0 -o empty -e empty true

             # Check for silent output and failure
             atf_check -s exit:1 -o empty -e empty false

             # Check for known stdout and silent stderr
             echo foo &gt;expout
             atf_check -s exit:0 -o file:expout -e empty echo foo

             # Generate a file for later inspection
             atf_check -s exit:0 -o save:stdout -e empty ls
             grep foo stdout || atf_fail "foo file not found in listing"

             # Or just do the match along the way
             atf_check -s exit:0 -o match:"^foo$" -e empty ls

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/atf-check.1.html">atf-check</a></u>(1), <u><a href="../man1/atf-sh.1.html">atf-sh</a></u>(1), <u><a href="../man1/atf-test-program.1.html">atf-test-program</a></u>(1), <u><a href="../man4/atf-test-case.4.html">atf-test-case</a></u>(4)

Debian                                          January 27, 2021                                       <u><a href="../man3/ATF-SH.3.html">ATF-SH</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>