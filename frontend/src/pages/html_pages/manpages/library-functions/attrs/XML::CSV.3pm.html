<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::CSV - Perl extension converting CSV files to XML</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-csv-perl">libxml-csv-perl_0.15-10_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::CSV - Perl extension converting CSV files to XML

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use XML::CSV;
         $csv_obj = XML::CSV-&gt;new();
         $csv_obj = XML::CSV-&gt;new(\%attr);

         $status = $csv_obj-&gt;parse_doc(file_name);
         $status = $csv_obj-&gt;parse_doc(file_name, \%attr);

         $csv_obj-&gt;declare_xml(\%attr);
         $csv_obj-&gt;declare_doctype(\%attr);

         $csv_obj-&gt;print_xml(file_name, \%attr);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       XML::CSV is a new module in is going to be upgraded very often as my time permits.  For the time being it
       uses CSV_XS module object default values to parse the (*.csv) document and then creates a perl data
       structure with xml tags names and data.  At this point it does not allow for a write as you parse
       interface but is the first upgrade for the next release.  I will also allow more access to the data
       structures and more documentation.  I will also put in more support for XML, since currently it only
       allows a simple XML structure.  Currently you can modify the tag structure to allow for attributes.  No
       DTD support is currently available, but will be implemented in a soon coming release.  As the module will
       provide both: object and event interfaces, it will be used upon individual needs, system resources, and
       required performance.  Ofcourse the DOM implementation takes up more resources and in some instances
       timing, it's the easiest to use.

</pre><h4><b>ATTRIBUTES</b> <b>new()</b></h4><pre>
       error_out - Turn on the error handling which will die on all errors and assign the error message to
       $XML::CSV::csvxml_error.

       column_headings - Specifies the column heading to use.  Passed as an array reference.  Can be used as a
       supplement to using the first column in the file as the XML tag names.  Since XML::CSV does not require
       you to parse the CSV file, you can provide your own data structure to parse.

       column_data - Specifies the CSV data in a two dimensional array.  Passed as an array reference.

       csv_xs - Specifies the CSV_XS object to use.  This is used to create custom CSV_XS object and override
       the default one created by XML::CSV.

</pre><h4><b>ATTRIBUTES</b> <b>parse_doc()</b></h4><pre>
       headings - Specifies the number of rows to use as tag names.  Defaults to 0.  Ex.  {headings =&gt; 1} (This
       will use the first row of data as xml tags)

       sub_char - Specifies the character with which the illegal tag characters will be replaced with.  Defaults
       to undef meaning no substitution is done.  To eliminate characters use "" (empty string) or to replace
       with another see below.  Ex.  {sub_char =&gt; "_"} or {sub_char =&gt; ""}

</pre><h4><b>ATTRIBUTES</b> <b>declare_xml()</b></h4><pre>
       version - Specifies the xml version.  Ex.  {version =&gt; '1.0'}

       encoding - Specifies the type of encoding.  XML standard defaults encoding to 'UTF-8' if notspecifically
                  set.  Ex.  {encoding =&gt; 'ISO-8859_1'}

       standalone - Specifies the the document as standalone (yes|no).  If the document is does not rely on an
                    external DTD, DTD is internal, or the external DTD does not effect the contents of the
       document,
                    the standalone attribute should be set to 'yes', otherwise 'no' should be used.  For more
       info
                    see XML declaration documentation.  Ex.  {standalone =&gt; 'yes'}

</pre><h4><b>ATTRIBUTES</b> <b>declare_doctype()</b></h4><pre>
       source - Specifies the source of the DTD (SYSTEM|PUBLIC) Ex. {source =&gt; 'SYSTEM'}

       location1 - URI to the DTD file.  Public ID may be used if source is PUBLIC.  Ex. {location1 =&gt;
       '<a href="http://www.xmlproj.com/dtd/index_dtd.dtd">http://www.xmlproj.com/dtd/index_dtd.dtd</a>'} or {location1 =&gt; '-//Netscape Communications//DTD RSS
       0.90//EN'}

       location2 - Optional second URI.  Usually used if the location1 public ID is not found by the
                   validating parser.  Ex. {location2 =&gt; '<a href="http://www.xmlproj.com/file.dtd">http://www.xmlproj.com/file.dtd</a>'}

       subset - Any other information that proceedes the DTD declaration.  Usually includes internal DTD if any.
       Ex. {subset =&gt; 'ELEMENT first_name (#PCDATA)&gt;\n&lt;!ELEMENT last_name (#PCDATA)&gt;'} You can even enterpolate
       the string with $obj-&gt;{column_headings} to dynamically build the DTD.  Ex. {subset =&gt; "ELEMENT
       $obj-&gt;{columnt_headings}[0] (#PCDATA)&gt;"}

</pre><h4><b>ATTRIBUTES</b> <b>print_xml()</b></h4><pre>
       file_tag - Specifies the file parent tag.  Defaults to "records".  Ex. {file_tag =&gt; "file_data"} (Do not
       use &lt; and &gt; when specifying)

       parent_tag - Specifies the record parent tag.  Defaults to "record".  Ex. {parent_tag =&gt; "record_data"}
       (Do not use &lt; and &gt; when specifying)

       format - Specifies the character to use to indent nodes.  Defaults to "\t" (tab).  Ex. {format =&gt; " "} or
       {format =&gt; "\t\t"}

</pre><h4><b>PUBLIC</b> <b>VARIABLES</b></h4><pre>
       $csv_obj-&gt;{column_headings} $csv_obj-&gt;{column_data}

</pre><h4><b>EXAMPLES</b></h4><pre>
       Example #1:

       This is a simple implementation which uses defaults

       use XML::CSV; $csv_obj = XML::CSV-&gt;<b>new()</b>; $csv_obj-&gt;parse_doc("in_file.csv", {headings =&gt; 1});

       $csv_obj-&gt;print_xml("out.xml");

       Example #2:

       This example uses a passed headings array reference which is used along with the parsed data.

       use XML::CSV; $csv_obj = XML::CSV-&gt;<b>new()</b>;

       $csv_obj-&gt;{column_headings} = \@arr_of_headings;

       $csv_obj-&gt;parse_doc("in_file.csv"); $csv_obj-&gt;print_xml("out.xml", {format =&gt; " ", file_tag = "xml_file",
       parent_tag =&gt; "record"});

       Example #3:

       First it passes a reference to a array with column headings and then a reference to two dimensional array
       of data where the first index represents the row number and the second column number.  We also pass a
       custom Text::CSV_XS object to overwrite the default object.  This is useful for creating your own CSV_XS
       object's args before using the <b>parse_doc()</b> method.  See 'perldoc Text::CSV_XS' for different <b>new()</b>
       attributes.

       use XML::CSV;

       $default_obj_xs = Text::CSV_XS-&gt;new({quote_char =&gt; '"'}); $csv_obj = XML::CSV-&gt;new({csv_xs =&gt;
       $default_obj_xs}); $csv_obj-&gt;{column_headings} = \@arr_of_headings;

       $csv_obj-&gt;{column_data} = \@arr_of_data;

       $csv_obj-&gt;print_xml("out.xml");

</pre><h4><b>AUTHOR</b></h4><pre>
       Ilya Sterin, <a href="mailto:isterin@mail.com">isterin@mail.com</a>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Text::CSV_XS

perl v5.34.0                                       2022-05-27                                           <u><a href="../man3pm/CSV.3pm.html">CSV</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>