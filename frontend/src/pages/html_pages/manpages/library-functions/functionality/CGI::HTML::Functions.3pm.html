<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGI::HTML::Functions - Documentation for CGI.pm Legacy HTML Functionality</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcgi-pm-perl">libcgi-pm-perl_4.68-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CGI::HTML::Functions - Documentation for CGI.pm Legacy HTML Functionality

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Nothing here - please do not use this functionality, it is considered to be legacy and essentially
       deprecated. This documentation exists solely to aid in maintenance and migration of legacy code using
       this functionality and you are strongly encouraged to migrate away from it. If you are working on new
       code you should be using a template engine. For more information see CGI::Alternatives.

       If you really want to continue using the HTML generation functionality of CGI.pm then you should take a
       look at HTML::Tiny instead, which may give you a migration path away from CGI.pm's html generation
       functions; i strongly encourage you to move towards template driven page generation for anything
       involving markup as it will make porting your app to other frameworks much easier in the long run.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The documentation here should be considered an addendum to the sections in the CGI documentation - the
       sections here are named the same as those within the CGI perldoc.

</pre><h4><b>Calling</b> <b>CGI.pm</b> <b>routines</b></h4><pre>
       HTML tag functions have both attributes (the attribute="value" pairs within the tag itself) and contents
       (the part between the opening and closing pairs). To distinguish between attributes and contents, CGI.pm
       uses the convention of passing HTML attributes as a hash reference as the first argument, and the
       contents, if any, as any subsequent arguments.  It works out like this:

           Code                           Generated HTML
           ----                           --------------
           h1()                           &lt;h1 /&gt;
           h1('some','contents');         &lt;h1&gt;some contents&lt;/h1&gt;
           h1({-align=&gt;left});            &lt;h1 align="LEFT"&gt;
           h1({-align=&gt;left},'contents'); &lt;h1 align="LEFT"&gt;contents&lt;/h1&gt;

       Many newcomers to CGI.pm are puzzled by the difference between the calling conventions for the HTML
       shortcuts, which require curly braces around the HTML tag attributes, and the calling conventions for
       other routines, which manage to generate attributes without the curly brackets. Don't be confused. As a
       convenience the curly braces are optional in all but the HTML shortcuts. If you like, you can use curly
       braces when calling any routine that takes named arguments. For example:

           print $q-&gt;header( { -type =&gt; 'image/gif', -expires =&gt; '+3d' } );

       If you use warnings, you will be warned that some CGI.pm argument names conflict with built-in perl
       functions. The most frequent of these is the -values argument, used to create multi-valued menus, radio
       button clusters and the like. To get around this warning, you have several choices:

       1.  Use another name for the argument, if one is available.  For example, -value is an alias for -values.

       2.  Change the capitalization, e.g. -Values

       3.  Put quotes around the argument name, e.g. '-values'

   <b>Function-oriented</b> <b>interface</b> <b>HTML</b> <b>exports</b>
       Here is a list of the HTML related function sets you can import:

       <b>:form</b>
           Import all fill-out form generating methods, such as <b>textfield()</b>.

       <b>:html2</b>
           Import all methods that generate HTML 2.0 standard elements.

       <b>:html3</b>
           Import all methods that generate HTML 3.0 elements (such as &lt;table&gt;, &lt;super&gt; and &lt;sub&gt;).

       <b>:html4</b>
           Import all methods that generate HTML 4 elements (such as &lt;abbrev&gt;, &lt;acronym&gt; and &lt;thead&gt;).

       <b>:netscape</b>
           Import the &lt;blink&gt;, &lt;fontsize&gt; and &lt;center&gt; tags.

       <b>:html</b>
           Import all HTML-generating shortcuts (i.e. 'html2', 'html3', 'html4' and 'netscape')

       <b>:standard</b>
           Import "standard" features, 'html2', 'html3', 'html4', 'ssl', 'form' and 'cgi'.

       If  you  import any of the state-maintaining CGI or form-generating methods, a default CGI object will be
       created and initialized automatically the first time you use any of the methods that require  one  to  be
       present. This includes <b>param()</b>, <b>textfield()</b>, <b>submit()</b> and the like. (If you need direct access to the CGI
       object, you can find it in the global variable <b>$CGI::Q</b>).

   <b>Pragmas</b>
       Additional HTML generation related pragms:

       -nosticky
           By default the CGI module implements a state-preserving behavior called "sticky" fields. The way this
           works  is  that  if you are regenerating a form, the methods that generate the form field values will
           interrogate <b>param()</b> to see if similarly-named parameters are present in the  query  string.  If  they
           find a like-named parameter, they will use it to set their default values.

           Sometimes  this  isn't  what  you  want.  The  <b>-nosticky</b>  pragma prevents this behavior. You can also
           selectively change the sticky behavior in each element that you generate.

       -tabindex
           Automatically add tab index attributes to each form field. With this option turned off, you can still
           add tab indexes manually by passing a -tabindex option to each field-generating method.

       -no_xhtml
           By default, CGI.pm versions 2.69 and higher emit XHTML (<a href="http://www.w3.org/TR/xhtml1/">http://www.w3.org/TR/xhtml1/</a>). The  -no_xhtml
           pragma disables this feature.  Thanks to Michalis Kabrianis &lt;<a href="mailto:kabrianis@hellug.gr">kabrianis@hellug.gr</a>&gt; for this feature.

           If  <b>start_html()</b>'s  -dtd  parameter  specifies  an  HTML  2.0,  3.2,  4.0  or  4.01  DTD,  XHTML will
           automatically be disabled without needing to use this pragma.

   <b>Special</b> <b>forms</b> <b>for</b> <b>importing</b> <b>HTML-tag</b> <b>functions</b>
       Many of the methods generate HTML tags. As described below, tag functions automatically generate both the
       opening and closing tags. For example:

           print h1('Level 1 Header');

       produces

           &lt;h1&gt;Level 1 Header&lt;/h1&gt;

       There will be some times when you want to produce the start and end tags yourself. In this case, you  can
       use the form start_<u>tag_name</u> and end_<u>tag_name</u>, as in:

           print start_h1,'Level 1 Header',end_h1;

   <b>Creating</b> <b>the</b> <b>HTML</b> <b>document</b> <b>header</b>
           print start_html(
               -title      =&gt; 'Secrets of the Pyramids',
               -author     =&gt; '<a href="mailto:fred@capricorn.org">fred@capricorn.org</a>',
               -base       =&gt; 'true',
               -target     =&gt; '_blank',
               -meta       =&gt; {'keywords'=&gt;'pharaoh secret mummy',
               'copyright' =&gt; 'copyright 1996 King Tut'},
               -style      =&gt; {'src'=&gt;'/styles/style1.css'},
               -BGCOLOR    =&gt; 'blue'
           );

       The  <b>start_html()</b>  routine  creates  the  top  of the page, along with a lot of optional information that
       controls the page's appearance and behavior.

       This method returns a canned HTML header and the opening &lt;body&gt; tag. All parameters are optional. In  the
       named  parameter  form, recognized parameters are -title, -author, -base, -xbase, -dtd, -lang and -target
       (see below for the explanation). Any additional parameters you provide, such as  the  unofficial  BGCOLOR
       attribute, are added to the &lt;body&gt; tag. Additional parameters must be proceeded by a hyphen.

       The argument <b>-xbase</b> allows you to provide an HREF for the &lt;base&gt; tag different from the current location,
       as in

           -xbase =&gt; "<a href="http://home.mcom.com/">http://home.mcom.com/</a>"

       All relative links will be interpreted relative to this tag.

       The argument <b>-target</b> allows you to provide a default target frame for all the links and fill-out forms on
       the page. <b>This</b> <b>is</b> <b>a</b> <b>non-standard</b> <b>HTTP</b> <b>feature</b> <b>which</b> <b>only</b> <b>works</b> <b>with</b> <b>some</b> <b>browsers!</b>

           -target =&gt; "answer_window"

       All  relative  links will be interpreted relative to this tag.  You add arbitrary meta information to the
       header with the <b>-meta</b> argument. This argument expects a reference to a hash containing  name/value  pairs
       of  meta  information.  These will be turned into a series of header &lt;meta&gt; tags that look something like
       this:

           &lt;meta name="keywords" content="pharaoh secret mummy"&gt;
           &lt;meta name="description" content="copyright 1996 King Tut"&gt;

       To create an HTTP-EQUIV type of &lt;meta&gt; tag, use <b>-head</b>, described below.

       The <b>-style</b> argument is used to incorporate cascading stylesheets into  your  code.  See  the  section  on
       CASCADING STYLESHEETS for more information.

       The <b>-lang</b> argument is used to incorporate a language attribute into the &lt;html&gt; tag. For example:

           print $q-&gt;start_html( -lang =&gt; 'fr-CA' );

       The  default  if not specified is "en-US" for US English, unless the -dtd parameter specifies an HTML 2.0
       or 3.2 DTD, in which case the lang attribute is left off.  You can force the lang attribute to  left  off
       in other cases by passing an empty string (-lang=&gt;'').

       The  <b>-encoding</b>  argument can be used to specify the character set for XHTML. It defaults to iso-8859-1 if
       not specified.

       The <b>-dtd</b> argument can be used to specify a public DTD identifier string. For example:

           -dtd =&gt; '-//W3C//DTD HTML 4.01 Transitional//EN')

       Alternatively, it can take public and system DTD identifiers as an array:

           -dtd =&gt; [
               '-//W3C//DTD HTML 4.01 Transitional//EN',
               '<a href="http://www.w3.org/TR/html4/loose.dtd">http://www.w3.org/TR/html4/loose.dtd</a>'
           ]

       For the public DTD identifier to be considered, it must be valid. Otherwise it will be  replaced  by  the
       default DTD. If the public DTD contains 'XHTML', CGI.pm will emit XML.

       The  <b>-declare_xml</b> argument, when used in conjunction with XHTML, will put a &lt;?xml&gt; declaration at the top
       of the HTML header. The sole purpose of this declaration is to declare the character set encoding. In the
       absence of -declare_xml, the output HTML will contain a &lt;meta&gt; tag that specifies the encoding,  allowing
       the HTML to pass most validators. The default for -declare_xml is false.

       You  can  place  other arbitrary HTML elements to the &lt;head&gt; section with the <b>-head</b> tag.  For example, to
       place a &lt;link&gt; element in the head section, use this:

           print start_html(
               -head =&gt; Link({
                   -rel  =&gt; 'shortcut icon',
                   -href =&gt; 'favicon.ico'
               })
           );

       To incorporate multiple HTML elements into the &lt;head&gt; section, just pass an array reference:

           print start_html(
               -head =&gt; [
                   Link({
                       -rel  =&gt; 'next',
                       -href =&gt; '<a href="http://www.capricorn.com/s2.html">http://www.capricorn.com/s2.html</a>'
                   }),
                   Link({
                       -rel  =&gt; 'previous',
                       -href =&gt; '<a href="http://www.capricorn.com/s1.html">http://www.capricorn.com/s1.html</a>'
                   })
               ]
           );

       And here's how to create an HTTP-EQUIV &lt;meta&gt; tag:

           print start_html(
               -head =&gt; meta({
                   -http_equiv =&gt; 'Content-Type',
                   -content    =&gt; 'text/html'
               })
           );

       JAVASCRIPTING: The <b>-script</b>, <b>-noScript</b>, <b>-onLoad</b>, <b>-onMouseOver</b>, <b>-onMouseOut</b> and  <b>-onUnload</b>  parameters  are
       used to add JavaScript calls to your pages. <b>-script</b> should point to a block of text containing JavaScript
       function  definitions.  This  block  will  be  placed  within a &lt;script&gt; block inside the HTML (not HTTP)
       header. The block is placed in the header in order to give your page a fighting chance of having all  its
       JavaScript  functions  in  place  even  if  the  user  presses the stop button before the page has loaded
       completely. CGI.pm attempts to format the script in such a way that JavaScript-naive  browsers  will  not
       choke on the code: unfortunately there are some browsers that get confused by it nevertheless.

       The  <b>-onLoad</b>  and  <b>-onUnload</b> parameters point to fragments of JavaScript code to execute when the page is
       respectively opened and closed by the browser.  Usually these parameters are calls to  functions  defined
       in the <b>-script</b> field:

           $q = CGI-&gt;new;
           print header;
           $JSCRIPT = &lt;&lt;END;
               // Ask a silly question
               function riddle_me_this() {
                   var r = prompt(
                       "What walks on four legs in the morning, " +
                       "two legs in the afternoon, " +
                       "and three legs in the evening?"
                   );
                   response(r);
               }
               // Get a silly answer
               function response(answer) {
                   if (answer == "man")
                       alert("Right you are!");
                   else
                       alert("Wrong!  Guess again.");
               }
           END
           print start_html(
               -title  =&gt; 'The Riddle of the Sphinx',
               -script =&gt; $JSCRIPT
           );

       Use  the  <b>-noScript</b>  parameter to pass some HTML text that will be displayed on browsers that do not have
       JavaScript (or browsers where JavaScript is turned off).

       The &lt;script&gt; tag, has several attributes including "type", "charset" and "src".  "src" allows you to keep
       JavaScript code in an external file. To use these  attributes  pass  a  HASH  reference  in  the  <b>-script</b>
       parameter containing one or more of -type, -src, or -code:

           print $q-&gt;start_html(
               -title  =&gt; 'The Riddle of the Sphinx',
               -script =&gt; {
                   -type =&gt; 'JAVASCRIPT',
                   -src  =&gt; '/javascript/sphinx.js'}
               );

           print $q-&gt;(
               -title  =&gt; 'The Riddle of the Sphinx',
               -script =&gt; {
                   -type =&gt; 'PERLSCRIPT',
                   -code =&gt; 'print "hello world!\n;"'
               }
           );

       A  final feature allows you to incorporate multiple &lt;script&gt; sections into the header. Just pass the list
       of script sections as an array reference. This allows you to specify different source files for different
       dialects of JavaScript.  Example:

           print $q-&gt;start_html(
               -title  =&gt; 'The Riddle of the Sphinx',
               -script =&gt; [
                   {
                       -type =&gt; 'text/javascript',
                       -src  =&gt; '/javascript/utilities10.js'
                   },
                   {
                       -type =&gt; 'text/javascript',
                       -src  =&gt; '/javascript/utilities11.js'
                   },
                   {
                       -type =&gt; 'text/jscript',
                       -src  =&gt; '/javascript/utilities12.js'
                   },
                   {
                       -type =&gt; 'text/ecmascript',
                       -src  =&gt; '/javascript/utilities219.js'
                   }
               ]
           );

       The option "-language" is a synonym for -type, and is supported for backwards compatibility.

       The old-style positional parameters are as follows:

       <b>Parameters:</b>

       1.  The title

       2.  The author's e-mail address (will create a &lt;link rev="MADE"&gt; tag if present

       3.  A 'true' flag if you want to include a  &lt;base&gt;  tag  in  the  header.  This  helps  resolve  relative
           addresses to absolute ones when the document is moved, but makes the document hierarchy non-portable.
           Use with care!

       Other parameters you want to include in the &lt;body&gt; tag may be appended to these.  This is a good place to
       put HTML extensions, such as colors and wallpaper patterns.

   <b>Ending</b> <b>the</b> <b>Html</b> <b>document:</b>
           print $q-&gt;end_html;

       This ends an HTML document by printing the &lt;/body&gt;&lt;/html&gt; tags.

</pre><h4><b>CREATING</b> <b>STANDARD</b> <b>HTML</b> <b>ELEMENTS:</b></h4><pre>
       CGI.pm defines general HTML shortcut methods for many HTML tags.  HTML shortcuts are named after a single
       HTML element and return a fragment of HTML text. Example:

          print $q-&gt;blockquote(
                            "Many years ago on the island of",
                            $q-&gt;a({href=&gt;"<a href="http://crete.org/">http://crete.org/</a>"},"Crete"),
                            "there lived a Minotaur named",
                            $q-&gt;strong("Fred."),
                           ),
              $q-&gt;hr;

       This results in the following HTML code (extra newlines have been added for readability):

          &lt;blockquote&gt;
          Many years ago on the island of
          &lt;a href="<a href="http://crete.org/">http://crete.org/</a>"&gt;Crete&lt;/a&gt; there lived
          a minotaur named &lt;strong&gt;Fred.&lt;/strong&gt;
          &lt;/blockquote&gt;
          &lt;hr&gt;

       If  you  find  the syntax for calling the HTML shortcuts awkward, you can import them into your namespace
       and dispense with the object syntax completely (see the next section for more details):

          use CGI ':standard';
          print blockquote(
             "Many years ago on the island of",
             a({href=&gt;"<a href="http://crete.org/">http://crete.org/</a>"},"Crete"),
             "there lived a minotaur named",
             strong("Fred."),
             ),
             hr;

   <b>Providing</b> <b>arguments</b> <b>to</b> <b>HTML</b> <b>shortcuts</b>
       The HTML methods will accept zero, one or multiple arguments.  If you provide no  arguments,  you  get  a
       single tag:

          print hr;    #  &lt;hr&gt;

       If  you  provide  one  or  more  string  arguments, they are concatenated together with spaces and placed
       between opening and closing tags:

          print h1("Chapter","1"); # &lt;h1&gt;Chapter 1&lt;/h1&gt;"

       If the first argument is a hash reference, then the keys and values of the hash  become  the  HTML  tag's
       attributes:

          print a({-href=&gt;'fred.html',-target=&gt;'_new'},
             "Open a new frame");

                   &lt;a href="fred.html",target="_new"&gt;Open a new frame&lt;/a&gt;

       You may dispense with the dashes in front of the attribute names if you prefer:

          print img {src=&gt;'fred.gif',align=&gt;'LEFT'};

                  &lt;img align="LEFT" src="fred.gif"&gt;

       Sometimes  an  HTML  tag attribute has no argument.  For example, ordered lists can be marked as COMPACT.
       The syntax for this is an argument that that points to an undef string:

          print ol({compact=&gt;undef},li('one'),li('two'),li('three'));

       Prior to CGI.pm version 2.41, providing an empty ('') string as an attribute argument  was  the  same  as
       providing  undef.  However, this has changed in order to accommodate those who want to create tags of the
       form &lt;img alt=""&gt;.  The difference is shown in these two pieces of code:

          CODE                   RESULT
          img({alt=&gt;undef})      &lt;img alt&gt;
          img({alt=&gt;''})         &lt;img alt=""&gt;

   <b>The</b> <b>distributive</b> <b>property</b> <b>of</b> <b>HTML</b> <b>shortcuts</b>
       One of the cool features of the HTML shortcuts is that they  are  distributive.   If  you  give  them  an
       argument  consisting  of  a  <b>reference</b>  to a list, the tag will be distributed across each element of the
       list.  For example, here's one way to make an ordered list:

          print ul(
                    li({-type=&gt;'disc'},['Sneezy','Doc','Sleepy','Happy'])
                  );

       This example will result in HTML output that looks like this:

          &lt;ul&gt;
            &lt;li type="disc"&gt;Sneezy&lt;/li&gt;
            &lt;li type="disc"&gt;Doc&lt;/li&gt;
            &lt;li type="disc"&gt;Sleepy&lt;/li&gt;
            &lt;li type="disc"&gt;Happy&lt;/li&gt;
          &lt;/ul&gt;

       This is extremely useful for creating tables.  For example:

          print table({-border=&gt;undef},
                  caption('When Should You Eat Your Vegetables?'),
                  Tr({-align=&gt;'CENTER',-valign=&gt;'TOP'},
                  [
                     th(['Vegetable', 'Breakfast','Lunch','Dinner']),
                     td(['Tomatoes' , 'no', 'yes', 'yes']),
                     td(['Broccoli' , 'no', 'no',  'yes']),
                     td(['Onions'   , 'yes','yes', 'yes'])
                  ]
                  )
               );

   <b>HTML</b> <b>shortcuts</b> <b>and</b> <b>list</b> <b>interpolation</b>
       Consider this bit of code:

          print blockquote(em('Hi'),'mom!'));

       It will ordinarily return the string that you probably expect, namely:

          &lt;blockquote&gt;&lt;em&gt;Hi&lt;/em&gt; mom!&lt;/blockquote&gt;

       Note the space between the element "Hi" and the element "mom!".  CGI.pm puts the extra space there  using
       array  interpolation,  which  is  controlled by the magic $" variable.  Sometimes this extra space is not
       what you want, for example, when you are trying to align a series of  images.   In  this  case,  you  can
       simply change the value of $" to an empty string.

          {
             local($") = '';
             print blockquote(em('Hi'),'mom!'));
           }

       I  suggest  you  put  the  code  in  a  block  as shown here.  Otherwise the change to $" will affect all
       subsequent code until you explicitly reset it.

   <b>Non-standard</b> <b>HTML</b> <b>shortcuts</b>
       A few HTML tags don't follow the standard pattern for various reasons.

       <b>comment()</b> generates an HTML comment (&lt;!-- comment --&gt;).  Call it like

           print comment('here is my comment');

       Because of conflicts with built-in perl functions, the following functions begin with initial caps:

           Select
           Tr
           Link
           Delete
           Accept
           Sub

       In addition, <b>start_html()</b>, <b>end_html()</b>, <b>start_form()</b>, <b>end_form()</b>, <b>start_multipart_form()</b> and all the fill-
       out form tags are special.  See their respective sections.

   <b>Autoescaping</b> <b>HTML</b>
       By default, all HTML that is emitted by the form-generating functions is passed through a function called
       <b>escapeHTML()</b>:

       $escaped_string = escapeHTML("unescaped string");
           Escape HTML formatting characters in a string. Internally this calls HTML::Entities (encode_entities)
           so really you should just use that instead - the default list of chars that will be  encoded  (passed
           to the HTML::Entities encode_entities method) is:

               &amp; &lt; &gt; " \x8b \x9b '

           you can control this list by setting the value of $CGI::ENCODE_ENTITIES:

               # only encode &lt; &gt;
               $CGI::ENCODE_ENTITIES = q{&lt;&gt;}

           if you want to encode <b>all</b> entities then undef $CGI::ENCODE_ENTITIES:

               # encode all entities
               $CGI::ENCODE_ENTITIES = undef;

       The  automatic  escaping  does  not apply to other shortcuts, such as <b>h1()</b>.  You should call <b>escapeHTML()</b>
       yourself on untrusted data in order to protect your pages against nasty tricks that people may enter into
       guestbooks, etc..  To change the character set, use <b>charset()</b>.  To turn autoescaping off completely,  use
       <b><a href="../man0/autoEscape.0.html">autoEscape</a></b>(0):

       $charset = charset([$charset]);
           Get or set the current character set.

       $flag = autoEscape([$flag]);
           Get or set the value of the autoescape flag.

</pre><h4><b>CREATING</b> <b>FILL-OUT</b> <b>FORMS:</b></h4><pre>
       <u>General</u>  <u>note</u>   The various form-creating methods all return strings to the caller, containing the tag or
       tags that will create the requested form element.  You are responsible for actually  printing  out  these
       strings.  It's set up this way so that you can place formatting tags around the form elements.

       <u>Another</u> <u>note</u> The default values that you specify for the forms are only used the <b>first</b> time the script is
       invoked  (when there is no query string).  On subsequent invocations of the script (when there is a query
       string), the former values are used even if they are blank.

       If you want to change the value of a field from its previous value, you have two choices:

       (1) call the <b>param()</b> method to set it.

       (2) use the -override (alias -force) parameter (a new feature in version 2.15).  This forces the  default
       value to be used, regardless of the previous value:

          print textfield(-name=&gt;'field_name',
                                  -default=&gt;'starting value',
                                  -override=&gt;1,
                                  -size=&gt;50,
                                  -maxlength=&gt;80);

       <u>Yet</u>  <u>another</u>  <u>note</u>  By default, the text and labels of form elements are escaped according to HTML rules.
       This means that you can safely use "&lt;CLICK ME&gt;" as the label for a button.  However, it  also  interferes
       with  your  ability  to incorporate special HTML character sequences, such as &amp;Aacute;, into your fields.
       If you wish to turn off automatic escaping, call the <b>autoEscape()</b> method with a false  value  immediately
       after creating the CGI object:

          $q = CGI-&gt;new;
          $q-&gt;<a href="../man0/autoEscape.0.html">autoEscape</a>(0);

       Note  that  <b>autoEscape()</b>  is  exclusively  used to effect the behavior of how some CGI.pm HTML generation
       functions handle escaping. Calling <b>escapeHTML()</b> explicitly will always escape the HTML.

       <u>A</u> <u>Lurking</u> <u>Trap!</u> Some of the form-element generating methods return multiple tags.  In a  scalar  context,
       the  tags  will  be concatenated together with spaces, or whatever is the current value of the $" global.
       In a list context, the methods will return a list of elements, allowing you to modify them if  you  wish.
       Usually you will not notice this behavior, but beware of this:

           printf("%s\n",end_form())

       <b>end_form()</b>  produces  several  tags,  and  only the first of them will be printed because the format only
       expects one value.

       &lt;p&gt;

   <b>Creating</b> <b>an</b> <b>isindex</b> <b>tag</b>
          print isindex(-action=&gt;$action);


                -or-
          print isindex($action);

       Prints out an &lt;isindex&gt; tag.  Not very exciting.  The parameter -action specifies the URL of  the  script
       to process the query.  The default is to process the query with the current script.

   <b>Starting</b> <b>and</b> <b>ending</b> <b>a</b> <b>form</b>
           print start_form(-method=&gt;$method,
                           -action=&gt;$action,
                           -enctype=&gt;$encoding);
             &lt;... various form stuff ...&gt;
           print end_form;


               -or-
           print start_form($method,$action,$encoding);
             &lt;... various form stuff ...&gt;
           print end_form;

       <b>start_form()</b>  will  return  a  &lt;form&gt;  tag  with  the  optional method, action and form encoding that you
       specify.  The defaults are:

           method: POST
           action: this script
           enctype: application/x-www-form-urlencoded for non-XHTML
                    multipart/form-data for XHTML, see multipart/form-data below.

       <b>end_form()</b> returns the closing &lt;/form&gt; tag.

       <b>start_form()</b>'s enctype argument tells the browser how to package the various fields of  the  form  before
       sending the form to the server.  Two values are possible:

       <b>application/x-www-form-urlencoded</b>
           This is the older type of encoding.  It is compatible with many CGI scripts and is suitable for short
           fields  containing  text data.  For your convenience, CGI.pm stores the name of this encoding type in
           <b>&amp;CGI::URL_ENCODED</b>.

       <b>multipart/form-data</b>
           This is the newer type of encoding.  It is suitable for forms that contain very large fields or  that
           are  intended  for transferring binary data.  Most importantly, it enables the "file upload" feature.
           For your convenience, CGI.pm stores the name of this encoding type in <b>&amp;CGI::MULTIPART</b>

           Forms that use this type of encoding are not easily interpreted by CGI scripts unless they use CGI.pm
           or another library designed to handle them.

           If XHTML is activated (the default), then forms will be automatically  created  using  this  type  of
           encoding.

       The  <b>start_form()</b>  method  uses  the older form of encoding by default unless XHTML is requested.  If you
       want to use the newer form of encoding  by  default,  you  can  call  <b>start_multipart_form()</b>  instead  of
       <b>start_form()</b>.  The method <b>end_multipart_form()</b> is an alias to <b>end_form()</b>.

       JAVASCRIPTING:  The  <b>-name</b>  and  <b>-onSubmit</b>  parameters  are  provided for use with JavaScript.  The -name
       parameter gives the form a name so that it can be identified and  manipulated  by  JavaScript  functions.
       -onSubmit  should  point to a JavaScript function that will be executed just before the form is submitted
       to your server.  You can use this opportunity to check the contents  of  the  form  for  consistency  and
       completeness.   If you find something wrong, you can put up an alert box or maybe fix things up yourself.
       You can abort the submission by returning false from this function.

       Usually the bulk of JavaScript functions are defined in a &lt;script&gt; block in the HTML header and -onSubmit
       points to one of these function call.  See <b>start_html()</b> for details.

   <b>Form</b> <b>elements</b>
       After starting a form, you will typically create one or more textfields, popup menus,  radio  groups  and
       other form elements.  Each of these elements takes a standard set of named arguments.  Some elements also
       have optional arguments.  The standard arguments are as follows:

       <b>-name</b>
           The name of the field. After submission this name can be used to retrieve the field's value using the
           <b>param()</b> method.

       <b>-value</b>, <b>-values</b>
           The initial value of the field which will be returned to the script after form submission.  Some form
           elements,  such  as  text  fields, take a single scalar -value argument. Others, such as popup menus,
           take a reference to an array of values. The two arguments are synonyms.

       <b>-tabindex</b>
           A numeric value that sets the order in which the form element receives focus when  the  user  presses
           the tab key. Elements with lower values receive focus first.

       <b>-id</b> A string identifier that can be used to identify this element to JavaScript and DHTML.

       <b>-override</b>
           A  boolean,  which,  if true, forces the element to take on the value specified by <b>-value</b>, overriding
           the sticky behavior described earlier for the <b>-nosticky</b> pragma.

       <b>-onChange</b>, <b>-onFocus</b>, <b>-onBlur</b>, <b>-onMouseOver</b>, <b>-onMouseOut</b>, <b>-onSelect</b>
           These are used to assign JavaScript event handlers. See the JavaScripting section for more details.

       Other common arguments are described in the next section. In addition to these, all attributes  described
       in the HTML specifications are supported.

   <b>Creating</b> <b>a</b> <b>text</b> <b>field</b>
           print textfield(-name=&gt;'field_name',
                           -value=&gt;'starting value',
                           -size=&gt;50,
                           -maxlength=&gt;80);

               -or-
           print textfield('field_name','starting value',50,80);

       <b>textfield()</b> will return a text input field.

       <b>Parameters</b>

       1.  The first parameter is the required name for the field (-name).

       2.  The  optional second parameter is the default starting value for the field contents (-value, formerly
           known as -default).

       3.  The optional third parameter is the size of the field in
                 characters (-size).

       4.  The optional fourth parameter is the maximum number of characters the
                 field will accept (-maxlength).

       As with all these methods, the field  will  be  initialized  with  its  previous  contents  from  earlier
       invocations  of  the  script.   When  the form is processed, the value of the text field can be retrieved
       with:

              $value = param('foo');

       If you want to reset it from its initial value after the script has been called once, you can do so  like
       this:

              param('foo',"I'm taking over this value!");

   <b>Creating</b> <b>a</b> <b>big</b> <b>text</b> <b>field</b>
          print textarea(-name=&gt;'foo',
                                 -default=&gt;'starting value',
                                 -rows=&gt;10,
                                 -columns=&gt;50);

               -or

          print textarea('foo','starting value',10,50);

       <b>textarea()</b>  is  just  like  textfield, but it allows you to specify rows and columns for a multiline text
       entry box.  You can provide a starting value for the field, which can be long and contain multiple lines.

   <b>Creating</b> <b>a</b> <b>password</b> <b>field</b>
          print password_field(-name=&gt;'secret',
                                       -value=&gt;'starting value',
                                       -size=&gt;50,
                                       -maxlength=&gt;80);

               -or-
          print password_field('secret','starting value',50,80);

       <b>password_field()</b> is identical to <b>textfield()</b>, except that its contents will be starred  out  on  the  web
       page.

   <b>Creating</b> <b>a</b> <b>file</b> <b>upload</b> <b>field</b>
           print filefield(-name=&gt;'uploaded_file',
                                   -default=&gt;'starting value',
                                   -size=&gt;50,
                                   -maxlength=&gt;80);

               -or-
           print filefield('uploaded_file','starting value',50,80);

       <b>filefield()</b>  will  return  a file upload field.  In order to take full advantage of this <u>you</u> <u>must</u> <u>use</u> <u>the</u>
       <u>new</u> <u>multipart</u> <u>encoding</u> <u>scheme</u> for the form.  You can do this  either  by  calling  <b>start_form()</b>  with  an
       encoding  type of <b>&amp;CGI::MULTIPART</b>, or by calling the new method <b>start_multipart_form()</b> instead of vanilla
       <b>start_form()</b>.

       <b>Parameters</b>

       1.  The first parameter is the required name for the field (-name).

       2.  The optional second parameter is the starting value for the field contents to be used as the  default
           file name (-default).

           For  security reasons, browsers don't pay any attention to this field, and so the starting value will
           always be blank.  Worse, the field loses its "sticky" behavior and  forgets  its  previous  contents.
           The  starting value field is called for in the HTML specification, however, and possibly some browser
           will eventually provide support for it.

       3.  The optional third parameter is the size of the field in characters (-size).

       4.  The optional fourth parameter is the maximum number of characters the field will accept (-maxlength).

       JAVASCRIPTING: The <b>-onChange</b>, <b>-onFocus</b>, <b>-onBlur</b>, <b>-onMouseOver</b>, <b>-onMouseOut</b> and <b>-onSelect</b>  parameters  are
       recognized.  See <b>textfield()</b> for details.

   <b>Creating</b> <b>a</b> <b>popup</b> <b>menu</b>
          print popup_menu('menu_name',
                                   ['eenie','meenie','minie'],
                                   'meenie');


             -or-
          %labels = ('eenie'=&gt;'your first choice',
                     'meenie'=&gt;'your second choice',
                     'minie'=&gt;'your third choice');
          %attributes = ('eenie'=&gt;{'class'=&gt;'class of first choice'});
          print popup_menu('menu_name',
                                   ['eenie','meenie','minie'],
                 'meenie',\%labels,\%attributes);

               -or (named parameter style)-

          print popup_menu(-name=&gt;'menu_name',
                                   -values=&gt;['eenie','meenie','minie'],
                                   -default=&gt;['meenie','minie'],
                 -labels=&gt;\%labels,
                 -attributes=&gt;\%attributes);

       <b>popup_menu()</b>  creates  a  menu.  Please  note  that  the -multiple option will be ignored if passed - use
       <b>scrolling_list()</b> if you want to create a menu that supports multiple selections

       1.  The required first argument is the menu's name (-name).

       2.  The required second argument (-values) is an array <b>reference</b> containing the list of menu items in the
           menu.  You can pass the method an anonymous array, as shown in the example, or a reference to a named
           array, such as "\@foo".

       3.  The optional third parameter (-default) is the name of the default menu choice.   If  not  specified,
           the  first  item  will  be  the default.  The values of the previous choice will be maintained across
           queries. Pass an array reference to select multiple defaults.

       4.  The optional fourth parameter (-labels) is provided for people who want to use different  values  for
           the  user-visible  label inside the popup menu and the value returned to your script.  It's a pointer
           to an hash relating menu values to user-visible labels.  If you leave this parameter blank, the  menu
           values will be displayed by default.  (You can also leave a label undefined if you want to).

       5.  The optional fifth parameter (-attributes) is provided to assign any of the common HTML attributes to
           an  individual  menu  item.  It's  a  pointer to a hash relating menu values to another hash with the
           attribute's name as the key and the attribute's value as the value.

       When the form is processed, the selected value of the popup menu can be retrieved using:

             $popup_menu_value = param('menu_name');

   <b>Creating</b> <b>an</b> <b>option</b> <b>group</b>
       Named parameter style

         print popup_menu(-name=&gt;'menu_name',
                         -values=&gt;[qw/eenie meenie minie/,
                                   optgroup(-name=&gt;'optgroup_name',
                                                    -values =&gt; ['moe','catch'],
                                                    -attributes=&gt;{'catch'=&gt;{'class'=&gt;'red'}})],
                         -labels=&gt;{'eenie'=&gt;'one',
                                   'meenie'=&gt;'two',
                                   'minie'=&gt;'three'},
                         -default=&gt;'meenie');

         Old style
         print popup_menu('menu_name',
                         ['eenie','meenie','minie',
                          optgroup('optgroup_name', ['moe', 'catch'],
                                          {'catch'=&gt;{'class'=&gt;'red'}})],'meenie',
                         {'eenie'=&gt;'one','meenie'=&gt;'two','minie'=&gt;'three'});

       <b>optgroup()</b> creates an option group within a popup menu.

       1.  The required first argument (<b>-name</b>) is the label attribute of the optgroup and is <b>not</b> inserted in the
           parameter list of the query.

       2.  The required second argument (<b>-values</b>)  is an array reference containing the list of  menu  items  in
           the  menu.   You can pass the method an anonymous array, as shown in the example, or a reference to a
           named array, such as \@foo.  If you pass a HASH reference, the keys will be used for the menu values,
           and the values will be used for the menu labels (see -labels below).

       3.  The optional third parameter (<b>-labels</b>) allows you to pass a reference  to  a  hash  containing  user-
           visible labels for one or more of the menu items.  You can use this when you want the user to see one
           menu  string,  but  have the browser return your program a different one.  If you don't specify this,
           the value string will be used instead ("eenie", "meenie" and  "minie"  in  this  example).   This  is
           equivalent to using a hash reference for the -values parameter.

       4.  An  optional  fourth  parameter  (<b>-labeled</b>)  can be set to a true value and indicates that the values
           should be used as the label attribute for each option element within the optgroup.

       5.  An optional fifth parameter (-novals) can be set to a true value and indicates to  suppress  the  val
           attribute in each option element within the optgroup.

           See            the            discussion            on            optgroup           at           W3C
           (<a href="http://www.w3.org/TR/REC-html40/interact/forms.html">http://www.w3.org/TR/REC-html40/interact/forms.html</a>#edef-OPTGROUP) for details.

       6.  An optional sixth parameter (-attributes) is provided to assign any of the common HTML attributes  to
           an  individual  menu  item.  It's  a  pointer to a hash relating menu values to another hash with the
           attribute's name as the key and the attribute's value as the value.

   <b>Creating</b> <b>a</b> <b>scrolling</b> <b>list</b>
          print scrolling_list('list_name',
                                       ['eenie','meenie','minie','moe'],
               ['eenie','moe'],5,'true',{'moe'=&gt;{'class'=&gt;'red'}});

             -or-
          print scrolling_list('list_name',
                                       ['eenie','meenie','minie','moe'],
                                       ['eenie','moe'],5,'true',
               \%labels,%attributes);


               -or-
          print scrolling_list(-name=&gt;'list_name',
                                       -values=&gt;['eenie','meenie','minie','moe'],
                                       -default=&gt;['eenie','moe'],
                                       -size=&gt;5,
                                       -multiple=&gt;'true',
               -labels=&gt;\%labels,
               -attributes=&gt;\%attributes);

       <b>scrolling_list()</b> creates a scrolling list.

       <b>Parameters:</b>

       1.  The first and second arguments are the list name (-name) and values (-values).  As in the popup menu,
           the second argument should be an array reference.

       2.  The optional third argument (-default) can be either a reference to a list containing the  values  to
           be  selected  by  default,  or  can  be  a  single  value  to select.  If this argument is missing or
           undefined, then nothing is selected when the list first appears.  In the named parameter version, you
           can use the synonym "-defaults" for this parameter.

       3.  The optional fourth argument is the size of the list (-size).

       4.  The optional fifth argument can be set to true to allow multiple simultaneous selections (-multiple).
           Otherwise only one selection will be allowed at a time.

       5.  The optional sixth argument is a pointer to a hash containing long user-visible labels for  the  list
           items (-labels).  If not provided, the values will be displayed.

       6.  The optional sixth parameter (-attributes) is provided to assign any of the common HTML attributes to
           an  individual  menu  item.  It's  a  pointer to a hash relating menu values to another hash with the
           attribute's name as the key and the attribute's value as the value.

           When this form is processed, all selected list items will be returned as a list under  the  parameter
           name 'list_name'.  The values of the selected items can be retrieved with:

                 @selected = param('list_name');

   <b>Creating</b> <b>a</b> <b>group</b> <b>of</b> <b>related</b> <b>checkboxes</b>
          print checkbox_group(-name=&gt;'group_name',
                                       -values=&gt;['eenie','meenie','minie','moe'],
                                       -default=&gt;['eenie','moe'],
                                       -linebreak=&gt;'true',
                                       -disabled =&gt; ['moe'],
               -labels=&gt;\%labels,
               -attributes=&gt;\%attributes);

          print checkbox_group('group_name',
                                       ['eenie','meenie','minie','moe'],
               ['eenie','moe'],'true',\%labels,
               {'moe'=&gt;{'class'=&gt;'red'}});

          HTML3-COMPATIBLE BROWSERS ONLY:

          print checkbox_group(-name=&gt;'group_name',
                                       -values=&gt;['eenie','meenie','minie','moe'],
                                       -rows=2,-columns=&gt;2);

       <b>checkbox_group()</b> creates a list of checkboxes that are related by the same name.

       <b>Parameters:</b>

       1.  The  first  and  second arguments are the checkbox name and values, respectively (-name and -values).
           As in the popup menu, the second argument should be an array reference.  These values  are  used  for
           the  user-readable  labels  printed  next  to the checkboxes as well as for the values passed to your
           script in the query string.

       2.  The optional third argument (-default) can be either a reference to a list containing the  values  to
           be  checked  by  default,  or  can  be  a  single  value  to checked.  If this argument is missing or
           undefined, then nothing is selected when the list first appears.

       3.  The optional fourth argument (-linebreak) can be set  to  true  to  place  line  breaks  between  the
           checkboxes  so  that  they  appear  as a vertical list.  Otherwise, they will be strung together on a
           horizontal line.

       The optional <b>-labels</b> argument is a pointer to a hash relating the checkbox  values  to  the  user-visible
       labels that will be printed next to them.  If not provided, the values will be used as the default.

       The  optional  parameters  <b>-rows</b>, and <b>-columns</b> cause <b>checkbox_group()</b> to return an HTML3 compatible table
       containing the checkbox group formatted with the specified number of rows and columns.  You  can  provide
       just  the  -columns  parameter  if you wish; checkbox_group will calculate the correct number of rows for
       you.

       The option <b>-disabled</b> takes an array of checkbox values and disables them by greying them  out  (this  may
       not be supported by all browsers).

       The  optional  <b>-attributes</b>  argument  is  provided  to  assign  any  of  the common HTML attributes to an
       individual menu item. It's a pointer to a hash relating menu values to another hash with the  attribute's
       name as the key and the attribute's value as the value.

       The  optional  <b>-tabindex</b>  argument  can be used to control the order in which radio buttons receive focus
       when the user presses the tab button.  If passed a scalar numeric value, the first element in  the  group
       will  receive this tab index and subsequent elements will be incremented by one.  If given a reference to
       an array of radio button values, then the indexes will be jiggered so that the  order  specified  in  the
       array  will  correspond to the tab order.  You can also pass a reference to a hash in which the hash keys
       are the radio button values and the values are the tab indexes of each button.  Examples:

         -tabindex =&gt; 100    #  this group starts at index 100 and counts up
         -tabindex =&gt; ['moe','minie','eenie','meenie']  # tab in this order
         -tabindex =&gt; {meenie=&gt;100,moe=&gt;101,minie=&gt;102,eenie=&gt;200} # tab in this order

       The optional <b>-labelattributes</b> argument will contain attributes  attached  to  the  &lt;label&gt;  element  that
       surrounds each button.

       When  the  form  is  processed,  all  checked  boxes  will be returned as a list under the parameter name
       'group_name'.  The values of the "on" checkboxes can be retrieved with:

             @turned_on = param('group_name');

       The value returned by <b>checkbox_group()</b> is actually an array of button elements.  You can capture them and
       use them within tables, lists, or in other creative ways:

           @h = checkbox_group(-name=&gt;'group_name',-values=&gt;\@values);
           &amp;use_in_creative_way(@h);

   <b>Creating</b> <b>a</b> <b>standalone</b> <b>checkbox</b>
           print checkbox(-name=&gt;'checkbox_name',
                                  -checked=&gt;1,
                                  -value=&gt;'ON',
                                  -label=&gt;'CLICK ME');


               -or-
           print checkbox('checkbox_name','checked','ON','CLICK ME');

       <b>checkbox()</b> is used to create an isolated checkbox that isn't logically related to any others.

       <b>Parameters:</b>

       1.  The first parameter is the required name for the checkbox (-name).  It will  also  be  used  for  the
           user-readable label printed next to the checkbox.

       2.  The  optional  second  parameter  (-checked)  specifies  that  the  checkbox is turned on by default.
           Synonyms are -selected and -on.

       3.  The optional third parameter (-value) specifies the value of the checkbox when it is checked.  If not
           provided, the word "on" is assumed.

       4.  The optional fourth parameter (-label) is the user-readable label to be attached to the checkbox.  If
           not provided, the checkbox name is used.

       The value of the checkbox can be retrieved using:

           $turned_on = param('checkbox_name');

   <b>Creating</b> <b>a</b> <b>radio</b> <b>button</b> <b>group</b>
          print radio_group(-name=&gt;'group_name',
                                    -values=&gt;['eenie','meenie','minie'],
                                    -default=&gt;'meenie',
                                    -linebreak=&gt;'true',
                  -labels=&gt;\%labels,
                  -attributes=&gt;\%attributes);


               -or-
          print radio_group('group_name',['eenie','meenie','minie'],
                   'meenie','true',\%labels,\%attributes);

          HTML3-COMPATIBLE BROWSERS ONLY:

          print radio_group(-name=&gt;'group_name',
                                    -values=&gt;['eenie','meenie','minie','moe'],
                                    -rows=2,-columns=&gt;2);

       <b>radio_group()</b> creates a set of logically-related radio buttons (turning one member of the group on  turns
       the others off)

       <b>Parameters:</b>

       1.  The first argument is the name of the group and is required (-name).

       2.  The second argument (-values) is the list of values for the radio buttons.  The values and the labels
           that  appear on the page are identical.  Pass an array <u>reference</u> in the second argument, either using
           an anonymous array, as shown, or by referencing a named array as in "\@foo".

       3.  The optional third parameter (-default) is the name  of  the  default  button  to  turn  on.  If  not
           specified,  the  first  item will be the default.  You can provide a nonexistent button name, such as
           "-" to start up with no buttons selected.

       4.  The optional fourth parameter (-linebreak) can be set to  'true'  to  put  line  breaks  between  the
           buttons, creating a vertical list.

       5.  The optional fifth parameter (-labels) is a pointer to an associative array relating the radio button
           values  to user-visible labels to be used in the display.  If not provided, the values themselves are
           displayed.

       All modern browsers can take advantage of the optional parameters <b>-rows</b>, and <b>-columns</b>.  These  parameters
       cause  <b>radio_group()</b>  to  return  an HTML3 compatible table containing the radio group formatted with the
       specified number of rows and columns.   You  can  provide  just  the  -columns  parameter  if  you  wish;
       radio_group will calculate the correct number of rows for you.

       To  include  row  and  column headings in the returned table, you can use the <b>-rowheaders</b> and <b>-colheaders</b>
       parameters.  Both of these accept a pointer to an array of  headings  to  use.   The  headings  are  just
       decorative.   They  don't  reorganize  the  interpretation of the radio buttons -- they're still a single
       named unit.

       The optional <b>-tabindex</b> argument can be used to control the order in which  radio  buttons  receive  focus
       when  the  user presses the tab button.  If passed a scalar numeric value, the first element in the group
       will receive this tab index and subsequent elements will be incremented by one.  If given a reference  to
       an  array  of  radio  button values, then the indexes will be jiggered so that the order specified in the
       array will correspond to the tab order.  You can also pass a reference to a hash in which the  hash  keys
       are the radio button values and the values are the tab indexes of each button.  Examples:

         -tabindex =&gt; 100    #  this group starts at index 100 and counts up
         -tabindex =&gt; ['moe','minie','eenie','meenie']  # tab in this order
         -tabindex =&gt; {meenie=&gt;100,moe=&gt;101,minie=&gt;102,eenie=&gt;200} # tab in this order

       The  optional  <b>-attributes</b>  argument  is  provided  to  assign  any  of  the common HTML attributes to an
       individual menu item. It's a pointer to a hash relating menu values to another hash with the  attribute's
       name as the key and the attribute's value as the value.

       The  optional  <b>-labelattributes</b>  argument  will  contain  attributes attached to the &lt;label&gt; element that
       surrounds each button.

       When the form is processed, the selected radio button can be retrieved using:

             $which_radio_button = param('group_name');

       The value returned by <b>radio_group()</b> is actually an array of button elements.  You can  capture  them  and
       use them within tables, lists, or in other creative ways:

           @h = radio_group(-name=&gt;'group_name',-values=&gt;\@values);
           &amp;use_in_creative_way(@h);

   <b>Creating</b> <b>a</b> <b>submit</b> <b>button</b>
          print submit(-name=&gt;'button_name',
                               -value=&gt;'value');


               -or-
          print submit('button_name','value');

       <b>submit()</b> will create the query submission button.  Every form should have one of these.

       <b>Parameters:</b>

       1.  The  first  argument  (-name)  is  optional.   You  can  give  the  button a name if you have several
           submission buttons in your form and you want to distinguish between them.

       2.  The second argument (-value) is also optional.  This gives the button a value that will be passed  to
           your script in the query string. The name will also be used as the user-visible label.

       3.  You  can  use  -label  as an alias for -value.  I always get confused about which of -name and -value
           changes the user-visible label on the button.

       You can figure out which button was pressed by using different values for each one:

            $which_one = param('button_name');

   <b>Creating</b> <b>a</b> <b>reset</b> <b>button</b>
          print reset

       <b>reset()</b> creates the "reset" button.  Note that it restores the form to its value from the last  time  the
       script was called, NOT necessarily to the defaults.

       Note  that  this  conflicts  with the perl <b>reset()</b> built-in.  Use <b>CORE::reset()</b> to get the original reset
       function.

   <b>Creating</b> <b>a</b> <b>default</b> <b>button</b>
          print defaults('button_label')

       <b>defaults()</b> creates a button that, when invoked, will cause  the  form  to  be  completely  reset  to  its
       defaults, wiping out all the changes the user ever made.

   <b>Creating</b> <b>a</b> <b>hidden</b> <b>field</b>
               print hidden(-name=&gt;'hidden_name',
                                    -default=&gt;['value1','value2'...]);


                       -or-
               print hidden('hidden_name','value1','value2'...);

       <b>hidden()</b>  produces  a text field that can't be seen by the user.  It is useful for passing state variable
       information from one invocation of the script to the next.

       <b>Parameters:</b>

       1.  The first argument is required and specifies the name of this field (-name).

       2.  The second argument is also required and specifies its value  (-default).   In  the  named  parameter
           style of calling, you can provide a single value here or a reference to a whole list

       Fetch the value of a hidden field this way:

            $hidden_value = param('hidden_name');

       Note,  that  just like all the other form elements, the value of a hidden field is "sticky".  If you want
       to replace a hidden field with some other values after the script has been called once you'll have to  do
       it manually:

            param('hidden_name','new','values','here');

   <b>Creating</b> <b>a</b> <b>clickable</b> <b>image</b> <b>button</b>
            print image_button(-name=&gt;'button_name',
                                       -src=&gt;'/source/URL',
                                       -align=&gt;'MIDDLE');


               -or-
            print image_button('button_name','/source/URL','MIDDLE');

       <b>image_button()</b> produces a clickable image.  When it's clicked on the position of the click is returned to
       your  script  as  "button_name.x" and "button_name.y", where "button_name" is the name you've assigned to
       it.

       <b>Parameters:</b>

       1.  The first argument (-name) is required and specifies the name of this field.

       2.  The second argument (-src) is also required and specifies the URL

       3.  The third option (-align, optional) is an alignment type, and may be TOP, BOTTOM or MIDDLE

       Fetch the value of the button this way:
            $x = param('button_name.x');
            $y = param('button_name.y');

   <b>Creating</b> <b>a</b> <b>javascript</b> <b>action</b> <b>button</b>
            print button(-name=&gt;'button_name',
                                 -value=&gt;'user visible label',
                                 -onClick=&gt;"do_something()");


               -or-
            print button('button_name',"user visible value","do_something()");

       <b>button()</b> produces an "&lt;input&gt;" tag with "type="button"".  When it's pressed the  fragment  of  JavaScript
       code pointed to by the <b>-onClick</b> parameter will be executed.

</pre><h4><b>WORKING</b> <b>WITH</b> <b>FRAMES</b></h4><pre>
       It's  possible for CGI.pm scripts to write into several browser panels and windows using the HTML 4 frame
       mechanism.  There are three techniques for defining new frames programmatically:

       1. Create a &lt;Frameset&gt; document
           After writing out  the  HTTP  header,  instead  of  creating  a  standard  HTML  document  using  the
           <b>start_html()</b>  call,  create  a &lt;frameset&gt; document that defines the frames on the page.  Specify your
           script(s) (with appropriate parameters) as the SRC for each of the frames.

           There is no specific support for creating &lt;frameset&gt; sections in CGI.pm, but the HTML is very  simple
           to write.

       2. Specify the destination for the document in the HTTP header
           You may provide a <b>-target</b> parameter to the <b>header()</b> method:

               print header(-target=&gt;'ResultsWindow');

           This  will  tell  the browser to load the output of your script into the frame named "ResultsWindow".
           If a frame of that name doesn't already exist, the browser will pop up a new  window  and  load  your
           script's  document  into  that.  There are a number of magic names that you can use for targets.  See
           the HTML "&lt;frame&gt;" documentation for details.

       3. Specify the destination for the document in the &lt;form&gt; tag
           You can specify the frame to load in the FORM tag itself.  With CGI.pm it looks like this:

               print start_form(-target=&gt;'ResultsWindow');

           When your script is reinvoked  by  the  form,  its  output  will  be  loaded  into  the  frame  named
           "ResultsWindow".  If one doesn't already exist a new window will be created.

       The  script  "frameset.cgi" in the examples directory shows one way to create pages in which the fill-out
       form and the response live in side-by-side frames.

</pre><h4><b>SUPPORT</b> <b>FOR</b> <b>JAVASCRIPT</b></h4><pre>
       The usual way to use JavaScript is to define a set of functions in  a  &lt;SCRIPT&gt;  block  inside  the  HTML
       header  and  then  to  register  event  handlers in the various elements of the page. Events include such
       things as the mouse passing over a form element, a button being clicked, the contents  of  a  text  field
       changing, or a form being submitted. When an event occurs that involves an element that has registered an
       event handler, its associated JavaScript code gets called.

       The  elements  that  can register event handlers include the &lt;BODY&gt; of an HTML document, hypertext links,
       all the various elements of a fill-out form, and the form itself. There are a large number of events, and
       each applies only to the elements for which it is relevant. Here is a partial list:

       <b>onLoad</b>
           The browser is loading the current document. Valid in:

                + The HTML &lt;BODY&gt; section only.

       <b>onUnload</b>
           The browser is closing the current page or frame. Valid for:

                + The HTML &lt;BODY&gt; section only.

       <b>onSubmit</b>
           The user has pressed the submit button of a  form.  This  event  happens  just  before  the  form  is
           submitted,  and  your  function  can return a value of false in order to abort the submission.  Valid
           for:

                + Forms only.

       <b>onClick</b>
           The mouse has clicked on an item in a fill-out form. Valid for:

                + Buttons (including submit, reset, and image buttons)
                + Checkboxes
                + Radio buttons

       <b>onChange</b>
           The user has changed the contents of a field. Valid for:

                + Text fields
                + Text areas
                + Password fields
                + File fields
                + Popup Menus
                + Scrolling lists

       <b>onFocus</b>
           The user has selected a field to work with. Valid for:

                + Text fields
                + Text areas
                + Password fields
                + File fields
                + Popup Menus
                + Scrolling lists

       <b>onBlur</b>
           The user has deselected a field (gone to work somewhere else).  Valid for:

                + Text fields
                + Text areas
                + Password fields
                + File fields
                + Popup Menus
                + Scrolling lists

       <b>onSelect</b>
           The user has changed the part of a text field that is selected.  Valid for:

                + Text fields
                + Text areas
                + Password fields
                + File fields

       <b>onMouseOver</b>
           The mouse has moved over an element.

                + Text fields
                + Text areas
                + Password fields
                + File fields
                + Popup Menus
                + Scrolling lists

       <b>onMouseOut</b>
           The mouse has moved off an element.

                + Text fields
                + Text areas
                + Password fields
                + File fields
                + Popup Menus
                + Scrolling lists

       In order to register a JavaScript event handler with an HTML element,  just  use  the  event  name  as  a
       parameter  when you call the corresponding CGI method. For example, to have your <b>validateAge()</b> JavaScript
       code executed every time the textfield named "age" changes, generate the field like this:

        print textfield(-name=&gt;'age',-onChange=&gt;"validateAge(this)");

       This example assumes that you've already declared the <b>validateAge()</b> function by incorporating it  into  a
       &lt;SCRIPT&gt; block. The CGI.pm <b>start_html()</b> method provides a convenient way to create this section.

       Similarly,  you  can  create  a  form that checks itself over for consistency and alerts the user if some
       essential value is missing by creating it this way:
         print start_form(-onSubmit=&gt;"validateMe(this)");

       See the javascript.cgi script for a demonstration of how this all works.

</pre><h4><b>LIMITED</b> <b>SUPPORT</b> <b>FOR</b> <b>CASCADING</b> <b>STYLE</b> <b>SHEETS</b></h4><pre>
       CGI.pm has limited support for HTML3's cascading style sheets (css).  To incorporate  a  stylesheet  into
       your  document,  pass  the  <b>start_html()</b> method a <b>-style</b> parameter.  The value of this parameter may be a
       scalar, in which case it is treated as the source URL for the stylesheet, or it may be a hash  reference.
       In  the  latter case you should provide the hash with one or more of <b>-src</b> or <b>-code</b>.  <b>-src</b> points to a URL
       where an externally-defined stylesheet can be found.  <b>-code</b> points to a scalar value to  be  incorporated
       into a &lt;style&gt; section.  Style definitions in <b>-code</b> override similarly-named ones in <b>-src</b>, hence the name
       "cascading."

       You  may  also  specify  the  type  of  the stylesheet by adding the optional <b>-type</b> parameter to the hash
       pointed to by <b>-style</b>.  If not specified, the style defaults to 'text/css'.

       To refer to a style within the body of your document, add the <b>-class</b> parameter to any HTML element:

           print h1({-class=&gt;'Fancy'},'Welcome to the Party');

       Or define styles on the fly with the <b>-style</b> parameter:

           print h1({-style=&gt;'Color: red;'},'Welcome to Hell');

       You may also use the new <b>span()</b> element to apply a style to a section of text:

           print span({-style=&gt;'Color: red;'},
                      h1('Welcome to Hell'),
                      "Where did that handbasket get to?"
                      );

       Note that you must import the ":html3" definitions to have the <b>span()</b> method available.  Here's  a  quick
       and  dirty  example  of  using CSS's.  See the CSS specification at <a href="http://www.w3.org/Style/CSS/">http://www.w3.org/Style/CSS/</a> for more
       information.

           use CGI qw/:standard :html3/;

           #here's a stylesheet incorporated directly into the page
           $newStyle=&lt;&lt;END;
           &lt;!--
           P.Tip {
               margin-right: 50pt;
               margin-left: 50pt;
               color: red;
           }
           P.Alert {
               font-size: 30pt;
               font-family: sans-serif;
             color: red;
           }
           --&gt;
           END
           print header();
           print start_html( -title=&gt;'CGI with Style',
                             -style=&gt;{-src=&gt;'<a href="http://www.capricorn.com/style/st1.css">http://www.capricorn.com/style/st1.css</a>',
                                      -code=&gt;$newStyle}
                            );
           print h1('CGI with Style'),
                 p({-class=&gt;'Tip'},
                   "Better read the cascading style sheet spec before playing with this!"),
                 span({-style=&gt;'color: magenta'},
                      "Look Mom, no hands!",
                      p(),
                      "Whooo wee!"
                      );
           print end_html;

       Pass an array reference to <b>-code</b> or <b>-src</b> in order to incorporate multiple stylesheets into your document.

       Should you wish to incorporate a verbatim stylesheet that includes arbitrary formatting  in  the  header,
       you may pass a -verbatim tag to the -style hash, as follows:

       print start_html (-style  =&gt;  {-verbatim =&gt; '@import url("/server-common/css/'.$cssFile.'");',
                         -src    =&gt;  '/server-common/css/core.css'});

       This will generate an HTML header that contains this:

        &lt;link rel="stylesheet" type="text/css"  href="/server-common/css/core.css"&gt;
          &lt;style type="text/css"&gt;
          @import url("/server-common/css/main.css");
          &lt;/style&gt;

       Any  additional  arguments  passed  in  the  -style  value will be incorporated into the &lt;link&gt; tag.  For
       example:

        start_html(-style=&gt;{-src=&gt;['/styles/print.css','/styles/layout.css'],
                                 -media =&gt; 'all'});

       This will give:

        &lt;link rel="stylesheet" type="text/css" href="/styles/print.css" media="all"/&gt;
        &lt;link rel="stylesheet" type="text/css" href="/styles/layout.css" media="all"/&gt;

       &lt;p&gt;

       To make more complicated &lt;link&gt; tags, use the <b>Link()</b> function and pass it to <b>start_html()</b>  in  the  -head
       argument, as in:

         @h = (Link({-rel=&gt;'stylesheet',-type=&gt;'text/css',-src=&gt;'/ss/ss.css',-media=&gt;'all'}),
               Link({-rel=&gt;'stylesheet',-type=&gt;'text/css',-src=&gt;'/ss/fred.css',-media=&gt;'paper'}));
         print start_html({-head=&gt;\@h})

       To create primary and  "alternate" stylesheet, use the <b>-alternate</b> option:

        start_html(-style=&gt;{-src=&gt;[
                                  {-src=&gt;'/styles/print.css'},
                                  {-src=&gt;'/styles/alt.css',-alternate=&gt;1}
                                  ]
                           });

   <b>Dumping</b> <b>out</b> <b>all</b> <b>the</b> <b>name/value</b> <b>pairs</b>
       The  <b>Dump()</b> method produces a string consisting of all the query's name/value pairs formatted nicely as a
       nested list. This is useful for debugging purposes:

           print Dump

       Produces something that looks like:

           &lt;ul&gt;
           &lt;li&gt;name1
               &lt;ul&gt;
               &lt;li&gt;value1
               &lt;li&gt;value2
               &lt;/ul&gt;
           &lt;li&gt;name2
               &lt;ul&gt;
               &lt;li&gt;value1
               &lt;/ul&gt;
           &lt;/ul&gt;

       As a shortcut, you can interpolate the entire CGI object into a string and it will be replaced with the a
       nice HTML dump shown above:

           $q=CGI-&gt;new;
           print "&lt;h2&gt;Current Values&lt;/h2&gt; $q\n";

</pre><h4><b>BUGS</b></h4><pre>
       Address bug reports and comments to: &lt;https://github.com/leejo/CGI.pm/issues&gt;

       See the &lt;https://github.com/leejo/CGI.pm/blob/master/CONTRIBUTING.md&gt; file  for  information  on  raising
       issues and contributing

       The original bug tracker can be found at: &lt;https://rt.cpan.org/Public/Dist/Display.html?Queue=CGI.pm&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       CGI - The original source of this documentation / functionality

perl v5.40.1                                       2025-04-12                          <u>CGI::HTML::<a href="../man3pm/Functions.3pm.html">Functions</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>