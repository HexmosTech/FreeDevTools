<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Type::Tiny::Manual::UsingWithMouse - how to use Type::Tiny with Mouse</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtype-tiny-perl">libtype-tiny-perl_2.004000-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Type::Tiny::Manual::UsingWithMouse - how to use Type::Tiny with Mouse

</pre><h4><b>MANUAL</b></h4><pre>
       First read Type::Tiny::Manual::Moo, Type::Tiny::Manual::Moo2, and Type::Tiny::Manual::Moo3. Everything in
       those parts of the manual should work exactly the same in Mouse.

       This part of the manual will focus on Mouse-specifics.

       Overall, Type::Tiny is less well-tested with Mouse than it is with Moose and Moo, but there are still a
       good number of test cases for using Type::Tiny with Mouse, and there are no known major issues with
       Type::Tiny's Mouse support.

   <b>Why</b> <b>Use</b> <b>Type::Tiny</b> <b>At</b> <b>All?</b>
       Mouse does have a built-in type constraint system which is fairly convenient to use, but there are
       several reasons you should consider using Type::Tiny instead.

       •   Type::Tiny provides helpful methods like "where" and "plus_coercions" that allow type constraints and
           coercions to be easily tweaked on a per-attribute basis.

           Something like this is much harder to do with plain Mouse types:

             has name =&gt; (
               is      =&gt; "ro",
               isa     =&gt; Str-&gt;plus_coercions(
                 ArrayRef[Str], sub { join " ", @$_ },
               ),
               coerce  =&gt; 1,
             );

           Mouse  tends  to encourage defining coercions globally, so if you wanted one <b>Str</b> attribute to be able
           to coerce from <b>ArrayRef[Str]</b>, then <u>all</u> <b>Str</b> attributes would coerce from <b>ArrayRef[Str]</b>, and they'd all
           do that coercion in the same way. (Even if it might make sense to join by a space in some  places,  a
           comma in others, and a line break in others!)

       •   Type::Tiny  provides  automatic  deep  coercions, so if type <b>Xyz</b> has a coercion, the following should
           "just work":

             has xyzlist =&gt; ( is =&gt; 'ro', isa =&gt; ArrayRef[Xyz], coerce =&gt; 1 );

       •   Type::Tiny offers a wider selection of built-in types.

       •   By using Type::Tiny, you can use the same type constraints and coercions for  attributes  and  method
           parameters, in Mouse and non-Mouse code.

   <b>Type::Utils</b>
       If  you've  used  Mouse::Util::TypeConstraints,  you  may be accustomed to using a DSL for declaring type
       constraints:

         use Mouse::Util::TypeConstraints;

         subtype 'Natural',
           as 'Int',
           where { $_ &gt; 0 };

       There's  a  module  called  Type::Utils  that  provides  a  very  similar  DSL  for  declaring  types  in
       Type::Library-based type libraries.

         package My::Types {
           use Type::Library -base;
           use Type::Utils;
           use Types::Standard qw( Int );

           declare 'Natural',
             as Int,
             where { $_ &gt; 0 };
         }

       Personally I prefer the more object-oriented way to declare types though.

       In  Mouse  you might also declare types like this within classes and roles too.  Unlike Mouse, Type::Tiny
       doesn't keep types in a single  global  flat  namespace,  so  this  doesn't  work  quite  the  same  with
       Type::Utils.  It  still  creates  the  type,  but  it  doesn't  store it in any type library; the type is
       returned.

         package My::Class {
           use Mouse;
           use Type::Utils;
           use Types::Standard qw( Int );

           my $Natural =          # store type in a variable
             declare 'Natural',
             as Int,
             where { $_ &gt; 0 };

           has number =&gt; ( is =&gt; 'ro', isa =&gt; $Natural );
         }

       But really, isn't the object-oriented way cleaner?

         package My::Class {
           use Mouse;
           use Types::Standard qw( Int );

           has number =&gt; (
             is   =&gt; 'ro',
             isa  =&gt; Int-&gt;where('$_ &gt; 0'),
           );
         }

   <b>Type::Tiny</b> <b>and</b> <b>MouseX::Types</b>
       Types::Standard should be a  drop-in  replacement  for  MooseX::Types.   And  Types::Common::Numeric  and
       Types::Common::String       should       easily      replace      MouseX::Types::Common::Numeric      and
       MouseX::Types::Common::String.

       That said, if you do with to use a mixture of Type::Tiny and  MouseX::Types,  they  should  fit  together
       pretty seamlessly.

         use Types::Standard qw( ArrayRef );
         use MouseX::Types::Mouse qw( Int );

         # this should just work
         my $list_of_nums = ArrayRef[Int];

         # and this
         my $list_or_num = ArrayRef | Int;

   <b>"-mouse"</b> <b>Import</b> <b>Parameter</b>
       If  you  have  read  this  far  in  the  manual,  you will know that this is the usual way to import type
       constraints:

         use Types::Standard qw( Int );

       And the "Int" which is imported is  a  function  that  takes  no  arguments  and  returns  the  <b>Int</b>  type
       constraint, which is a blessed object in the Type::Tiny class.

       Type::Tiny  mocks the Mouse::Meta::TypeConstraint API so well that most Mouse and MouseX code will not be
       able to tell the difference.

       But what if you need a real Mouse::Meta::TypeConstraint object?

         use Types::Standard -mouse, qw( Int );

       Now the "Int" function imported will return a genuine native Mouse type constraint.

       This flag is mostly a throwback from when Type::Tiny native objects <u>didn't</u> directly  work  in  Mouse.  In
       99.9% of cases, there is no reason to use it and plenty of reasons not to. (Mouse native type constraints
       don't offer helpful methods like "plus_coercions" and "where".)

   <b>"mouse_type"</b> <b>Method</b>
       Another  quick  way  to get a native Mouse type constraint object from a Type::Tiny object is to call the
       "mouse_type" method:

         use Types::Standard qw( Int );

         my $tiny_type   = Int;
         my $mouse_type  = $tiny_type-&gt;mouse_type;

       Internally, this is what the "-mouse" flag makes imported functions do.

   <b>Type::Tiny</b> <b>Performance</b>
       Type::Tiny should run pretty much as fast as Mouse types do. This is because, when possible, it will  use
       Mouse's XS implementations of type checks to do the heavy lifting.

       There  are  a few type constraints where Type::Tiny prefers to do things without Mouse's help though, for
       consistency and correctness. For example, the Mouse XS implementation of <b>Bool</b> is... strange... it accepts
       blessed objects that overload "bool", but only if they return false. If they return  true,  it's  a  type
       constraint error.

       Using  Type::Tiny  instead  of  Mouse's  type  constraints shouldn't make a significant difference to the
       performance of your code.

</pre><h4><b>NEXT</b> <b>STEPS</b></h4><pre>
       Here's your next step:

       •   Type::Tiny::Manual::UsingWithMite

           How to use Type::Tiny with Mite, including how to write an entire Perl project using clean Moose-like
           code and no non-core dependencies.  (Not even dependencies on Mite or Type::Tiny!)

</pre><h4><b>AUTHOR</b></h4><pre>
       Toby Inkster &lt;<a href="mailto:tobyink@cpan.org">tobyink@cpan.org</a>&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2013-2014, 2017-2023 by Toby Inkster.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTIES</b></h4><pre>
       THIS  PACKAGE  IS  PROVIDED  "AS  IS"  AND  WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
       LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

perl v5.40.1                                       2025-05-06             <u>Type::Tiny::Man...:<a href="../man3pm/UsingWithMouse.3pm.html">UsingWithMouse</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>