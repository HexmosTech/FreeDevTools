<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::__debug::unordered_multiset< _Value, _Hash, _Pred, _Alloc > - Class std::unordered_multiset with</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::__debug::unordered_multiset&lt; _Value, _Hash, _Pred, _Alloc &gt; - Class std::unordered_multiset with
       safety/checking/debug instrumentation.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;unordered_set&gt;

       Inherits <b>__gnu_debug::_Safe_container&lt;</b> <b>_SafeContainer,</b> <b>_Alloc,</b> <b>_SafeBase,</b> <b>_IsCxx11AllocatorAware</b> <b>&gt;</b>, and
       unordered_multiset&lt; _Value, std::hash&lt; _Value &gt;, std::equal_to&lt; _Value &gt;, std::allocator&lt; _Value &gt; &gt;.

   <b>Public</b> <b>Types</b>
       <b>typedef</b> _Base::allocator_type <b>allocator_type</b>
       <b>typedef</b> <b>__gnu_debug::_Safe_iterator</b>&lt; <b>_Base_const_iterator</b>, <b>unordered_multiset</b> &gt; <b>const_iterator</b>
       <b>typedef</b> <b>__gnu_debug::_Safe_local_iterator</b>&lt; <b>_Base_const_local_iterator</b>, <b>unordered_multiset</b> &gt;
           <b>const_local_iterator</b>
       <b>typedef</b> _Base::const_pointer <b>const_pointer</b>
       <b>typedef</b> _Base::const_reference <b>const_reference</b>
       <b>typedef</b> _Base::difference_type <b>difference_type</b>
       <b>typedef</b> _Base::hasher <b>hasher</b>
       <b>typedef</b> <b>__gnu_debug::_Safe_iterator</b>&lt; <b>_Base_iterator</b>, <b>unordered_multiset</b> &gt; <b>iterator</b>
       <b>typedef</b> _Base::key_equal <b>key_equal</b>
       <b>typedef</b> _Base::key_type <b>key_type</b>
       <b>typedef</b> <b>__gnu_debug::_Safe_local_iterator</b>&lt; <b>_Base_local_iterator</b>, <b>unordered_multiset</b> &gt; <b>local_iterator</b>
       <b>using</b> <b>node_type</b> = <b>typename</b> _Base::node_type
       <b>typedef</b> _Base::pointer <b>pointer</b>
       <b>typedef</b> _Base::reference <b>reference</b>
       <b>typedef</b> _Base::size_type <b>size_type</b>
       <b>typedef</b> _Base::value_type <b>value_type</b>

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>unordered_multiset</b> (_Base_ref __x)
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>unordered_multiset</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last,
           size_type __n, const allocator_type &amp;__a)
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>unordered_multiset</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last,
           size_type __n, const hasher &amp;<b>__hf</b>, const allocator_type &amp;__a)
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>unordered_multiset</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last,
           size_type __n=0, const hasher &amp;<b>__hf</b>=hasher(), const key_equal &amp;<b>__eql</b>=key_equal(), const
           allocator_type &amp;__a=allocator_type())
       <b>unordered_multiset</b> (const allocator_type &amp;__a)
       <b>unordered_multiset</b> (const <b>unordered_multiset</b> &amp;)=<b>default</b>
       <b>unordered_multiset</b> (const <b>unordered_multiset</b> &amp;<b>__uset</b>, const allocator_type &amp;__a)
       <b>unordered_multiset</b> (<b>initializer_list</b>&lt; value_type &gt; <b>__l</b>, size_type __n, const allocator_type &amp;__a)
       <b>unordered_multiset</b> (<b>initializer_list</b>&lt; value_type &gt; <b>__l</b>, size_type __n, const hasher &amp;<b>__hf</b>, const
           allocator_type &amp;__a)
       <b>unordered_multiset</b> (<b>initializer_list</b>&lt; value_type &gt; <b>__l</b>, size_type __n=0, const hasher &amp;<b>__hf</b>=hasher(),
           const key_equal &amp;<b>__eql</b>=key_equal(), const allocator_type &amp;__a=allocator_type())
       <b>unordered_multiset</b> (size_type __n, const allocator_type &amp;__a)
       <b>unordered_multiset</b> (size_type __n, const hasher &amp;<b>__hf</b>, const allocator_type &amp;__a)
       <b>unordered_multiset</b> (size_type __n, const hasher &amp;<b>__hf</b>=hasher(), const key_equal &amp;<b>__eql</b>=key_equal(), const
           allocator_type &amp;__a=allocator_type())
       <b>unordered_multiset</b> (<b>unordered_multiset</b> &amp;&amp;)=<b>default</b>
       <b>unordered_multiset</b> (<b>unordered_multiset</b> &amp;&amp;<b>__uset</b>, const allocator_type &amp;__a)
           noexcept(noexcept(<b>_Base</b>(<b>std::move</b>(<b>__uset</b>), __a)))
       const <b>_Base</b> &amp; <b>_M_base</b> () const noexcept
       <b>_Base</b> &amp; <b>_M_base</b> () noexcept
       <b>const_iterator</b> <b>begin</b> () const noexcept
       <b>iterator</b> <b>begin</b> () noexcept
       <b>local_iterator</b> <b>begin</b> (size_type __b)
       <b>const_local_iterator</b> <b>begin</b> (size_type __b) const
       size_type <b>bucket_size</b> (size_type __b) const
       <b>const_iterator</b> <b>cbegin</b> () const noexcept
       <b>const_local_iterator</b> <b>cbegin</b> (size_type __b) const
       <b>const_iterator</b> <b>cend</b> () const noexcept
       <b>const_local_iterator</b> <b>cend</b> (size_type __b) const
       <b>void</b> <b>clear</b> () noexcept
       template&lt;typename... _Args&gt; <b>iterator</b> <b>emplace</b> (<b>_Args</b> &amp;&amp;... <b>__args</b>)
       template&lt;typename... _Args&gt; <b>iterator</b> <b>emplace_hint</b> (<b>const_iterator</b> <b>__hint</b>, <b>_Args</b> &amp;&amp;... <b>__args</b>)
       <b>const_iterator</b> <b>end</b> () const noexcept
       <b>iterator</b> <b>end</b> () noexcept
       <b>local_iterator</b> <b>end</b> (size_type __b)
       <b>const_local_iterator</b> <b>end</b> (size_type __b) const
       template&lt;<b>typename</b> <b>_Kt</b> , <b>typename</b>  = std::__has_is_transparent_t&lt;_Hash, _Kt&gt;, <b>typename</b>  =
           std::__has_is_transparent_t&lt;_Pred, _Kt&gt;&gt; <b>std::pair</b>&lt; <b>iterator</b>, <b>iterator</b> &gt; <b>equal_range</b> (const <b>_Kt</b> &amp;<b>__k</b>)
       template&lt;<b>typename</b> <b>_Kt</b> , <b>typename</b>  = std::__has_is_transparent_t&lt;_Hash, _Kt&gt;, <b>typename</b>  =
           std::__has_is_transparent_t&lt;_Pred, _Kt&gt;&gt; <b>std::pair</b>&lt; <b>const_iterator</b>, <b>const_iterator</b> &gt; <b>equal_range</b>
           (const <b>_Kt</b> &amp;<b>__k</b>) const
       <b>std::pair</b>&lt; <b>iterator</b>, <b>iterator</b> &gt; <b>equal_range</b> (const key_type &amp;<b>__key</b>)
       <b>std::pair</b>&lt; <b>const_iterator</b>, <b>const_iterator</b> &gt; <b>equal_range</b> (const key_type &amp;<b>__key</b>) const
       <b>_Base_iterator</b> <b>erase</b> (<b>_Base_const_iterator</b> <b>__it</b>)
       size_type <b>erase</b> (const key_type &amp;<b>__key</b>)
       <b>iterator</b> <b>erase</b> (<b>const_iterator</b> __first, <b>const_iterator</b> __last)
       <b>iterator</b> <b>erase</b> (<b>const_iterator</b> <b>__it</b>)
       <b>iterator</b> <b>erase</b> (<b>iterator</b> <b>__it</b>)
       node_type <b>extract</b> (const key_type &amp;<b>__key</b>)
       node_type <b>extract</b> (<b>const_iterator</b> <b>__position</b>)
       template&lt;<b>typename</b> <b>_Kt</b> , <b>typename</b>  = std::__has_is_transparent_t&lt;_Hash, _Kt&gt;, <b>typename</b>  =
           std::__has_is_transparent_t&lt;_Pred, _Kt&gt;&gt; <b>iterator</b> <b>find</b> (const <b>_Kt</b> &amp;<b>__k</b>)
       template&lt;<b>typename</b> <b>_Kt</b> , <b>typename</b>  = std::__has_is_transparent_t&lt;_Hash, _Kt&gt;, <b>typename</b>  =
           std::__has_is_transparent_t&lt;_Pred, _Kt&gt;&gt; <b>const_iterator</b> <b>find</b> (const <b>_Kt</b> &amp;<b>__k</b>) const
       <b>iterator</b> <b>find</b> (const key_type &amp;<b>__key</b>)
       <b>const_iterator</b> <b>find</b> (const key_type &amp;<b>__key</b>) const
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>void</b> <b>insert</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last)
       <b>iterator</b> <b>insert</b> (const value_type &amp;<b>__obj</b>)
       <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__hint</b>, const value_type &amp;<b>__obj</b>)
       <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__hint</b>, node_type &amp;&amp;<b>__nh</b>)
       <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__hint</b>, value_type &amp;&amp;<b>__obj</b>)
       <b>iterator</b> <b>insert</b> (node_type &amp;&amp;<b>__nh</b>)
       <b>void</b> <b>insert</b> (<b>std::initializer_list</b>&lt; value_type &gt; <b>__l</b>)
       <b>iterator</b> <b>insert</b> (value_type &amp;&amp;<b>__obj</b>)
       float <b>max_load_factor</b> () const noexcept
       <b>void</b> <b>max_load_factor</b> (float __f)
       template&lt;<b>typename</b> <b>_H2</b> , <b>typename</b> <b>_P2</b> &gt; <b>void</b> <b>merge</b> (<b>unordered_multiset</b>&lt; _Value, <b>_H2</b>, <b>_P2</b>, _Alloc &gt;
           &amp;&amp;<b>__source</b>)
       template&lt;<b>typename</b> <b>_H2</b> , <b>typename</b> <b>_P2</b> &gt; <b>void</b> <b>merge</b> (<b>unordered_multiset</b>&lt; _Value, <b>_H2</b>, <b>_P2</b>, _Alloc &gt;
           &amp;<b>__source</b>)
       template&lt;<b>typename</b> <b>_H2</b> , <b>typename</b> <b>_P2</b> &gt; <b>void</b> <b>merge</b> (<b>unordered_set</b>&lt; _Value, <b>_H2</b>, <b>_P2</b>, _Alloc &gt; &amp;&amp;<b>__source</b>)
       template&lt;<b>typename</b> <b>_H2</b> , <b>typename</b> <b>_P2</b> &gt; <b>void</b> <b>merge</b> (<b>unordered_set</b>&lt; _Value, <b>_H2</b>, <b>_P2</b>, _Alloc &gt; &amp;<b>__source</b>)
       <b>unordered_multiset</b> &amp; <b>operator=</b> (const <b>unordered_multiset</b> &amp;)=<b>default</b>
       <b>unordered_multiset</b> &amp; <b>operator=</b> (<b>initializer_list</b>&lt; value_type &gt; <b>__l</b>)
       <b>unordered_multiset</b> &amp; <b>operator=</b> (<b>unordered_multiset</b> &amp;&amp;)=<b>default</b>
       <b>void</b> <b>swap</b> (<b>unordered_multiset</b> &amp;__x) noexcept(noexcept(<b>declval</b>&lt; <b>_Base</b> &amp; &gt;().swap(__x)))

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       <b>void</b> <b>_M_swap</b> (_Safe_container &amp;__x) noexcept

   <b>Friends</b>
       template&lt;<b>typename</b> <b>_ItT</b> , <b>typename</b> <b>_SeqT</b> , <b>typename</b> <b>_CatT</b> &gt; <b>class</b> <b>::__gnu_debug::_Safe_iterator</b>
       template&lt;<b>typename</b> <b>_ItT</b> , <b>typename</b> <b>_SeqT</b> &gt; <b>class</b> <b>::__gnu_debug::_Safe_local_iterator</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_Value,</b> <b>typename</b> <b>_Hash</b> <b>=</b> <b>std::hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b> <b>=</b> <b>std::equal_to&lt;_Value&gt;,</b>
       <b>typename</b> <b>_Alloc</b> <b>=</b> <b>std::allocator&lt;_Value&gt;&gt;</b>
       class std::__debug::unordered_multiset&lt; _Value, _Hash, _Pred, _Alloc &gt;"Class std::unordered_multiset with
       safety/checking/debug instrumentation.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libst<u>std::</u><b>__</b><u>debug::unordered...</u> <b>_</b><u>Hash,</u> <b>_</b><u>Pred,</u> <b>_</b><u>Alloc</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>