<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>beam_lib - An interface to the BEAM file format.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       beam_lib - An interface to the BEAM file format.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module provides an interface to files created by the BEAM Compiler ("BEAM files"). The format used,
       a variant of "EA IFF 1985" Standard for Interchange Format Files, divides data into chunks.

       Chunk data can be returned as binaries or as compound terms. Compound terms are returned when chunks  are
       referenced by names (atoms) rather than identifiers (strings). The recognized names and the corresponding
       identifiers are as follows:

         * <u>atoms</u> <u>("Atom")</u>

         * <u>attributes</u> <u>("Attr")</u>

         * <u>compile_info</u> <u>("CInf")</u>

         * <u>debug_info</u> <u>("Dbgi")</u>

         * <u>exports</u> <u>("ExpT")</u>

         * <u>imports</u> <u>("ImpT")</u>

         * <u>indexed_imports</u> <u>("ImpT")</u>

         * <u>labeled_exports</u> <u>("ExpT")</u>

         * <u>labeled_locals</u> <u>("LocT")</u>

         * <u>locals</u> <u>("LocT")</u>

</pre><h4><b>DEBUG</b> <b>INFORMATION/ABSTRACT</b> <b>CODE</b></h4><pre>
       Option <u>debug_info</u> can be specified to the Compiler (see <u><a href="../man3erl/compile.3erl.html">compile</a>(3erl)</u>) to have debug information, such as
       Erlang Abstract Format, stored in the <u>debug_info</u> chunk. Tools such as Debugger and Xref require the debug
       information to be included.

   <b>Warning:</b>
       Source  code  can  be  reconstructed  from  the  debug  information. To prevent this, use encrypted debug
       information (see below).

       The debug information  can  also  be  removed  from  BEAM  files  using  <u>strip/1</u>,  <u>strip_files/1</u>,  and/or
       <u>strip_release/1</u>.

</pre><h4><b>RECONSTRUCT</b> <b>SOURCE</b> <b>CODE</b></h4><pre>
       The  following  example  shows how to reconstruct Erlang source code from the debug information in a BEAM
       file <u>Beam</u>:

       {ok,{_,[{abstract_code,{_,AC}}]}} = beam_lib:chunks(Beam,[abstract_code]).
       io:fwrite("~s~n", [erl_prettypr:format(erl_syntax:form_list(AC))]).

</pre><h4><b>ENCRYPTED</b> <b>DEBUG</b> <b>INFORMATION</b></h4><pre>
       The debug information can be encrypted to keep the source code secret, but still be  able  to  use  tools
       such as Debugger or Xref.

       To  use  encrypted  debug  information,  a  key must be provided to the compiler and <u>beam_lib</u>. The key is
       specified as a string. It is recommended that the string contains at least 32 characters  and  that  both
       upper and lower case letters as well as digits and special characters are used.

       The  default type (and currently the only type) of crypto algorithm is <u>des3_cbc</u>, three rounds of DES. The
       key string is scrambled using <u>erlang:md5/1</u> to generate the keys used for <u>des3_cbc</u>.

   <b>Note:</b>
       As far as we know by the time of writing, it is infeasible  to  break  <u>des3_cbc</u>  encryption  without  any
       knowledge  of the key. Therefore, as long as the key is kept safe and is unguessable, the encrypted debug
       information <u>should</u> be safe from intruders.

       The key can be provided in the following two ways:

         * Use Compiler option <u>{debug_info_key,Key}</u>, see <u><a href="../man3erl/compile.3erl.html">compile</a>(3erl)</u> and function <u>crypto_key_fun/1</u> to register
           a fun that returns the key whenever <u>beam_lib</u> must decrypt the debug information.

           If no such fun is registered, <u>beam_lib</u> instead searches for  an  <u>.erlang.crypt</u>  file,  see  the  next
           section.

         * Store the key in a text file named <u>.erlang.crypt</u>.

           In this case, Compiler option <u>encrypt_debug_info</u> can be used, see <u><a href="../man3erl/compile.3erl.html">compile</a>(3erl)</u>.

</pre><h4><b>.ERLANG.CRYPT</b></h4><pre>
       <u>beam_lib</u>  searches for <u>.erlang.crypt</u> in the current directory and then the home directory for the current
       user. If the file is found and contains a key, <u>beam_lib</u> implicitly creates a crypto key fun and registers
       it.

       File <u>.erlang.crypt</u> is to contain a single list of tuples:

       {debug_info, Mode, Module, Key}

       <u>Mode</u> is the type of crypto algorithm; currently, the only allowed value is <u>des3_cbc</u>. <u>Module</u> is either  an
       atom,  in  which  case  <u>Key</u>  is only used for the module <u>Module</u>, or <u>[]</u>, in which case <u>Key</u> is used for all
       modules. <u>Key</u> is the non-empty key string.

       <u>Key</u> in the first tuple where both <u>Mode</u> and <u>Module</u> match is used.

       The following is an example of an <u>.erlang.crypt</u> file that returns the same key for all modules:

       [{debug_info, des3_cbc, [], "%&gt;7}|pc/DM6Cga*68$Mw]L#&amp;_Gejr]G^"}].

       The following is a slightly more complicated example of an <u>.erlang.crypt</u> providing one key for  module  <u>t</u>
       and another key for all other modules:

       [{debug_info, des3_cbc, t, "My KEY"},
        {debug_info, des3_cbc, [], "%&gt;7}|pc/DM6Cga*68$Mw]L#&amp;_Gejr]G^"}].

   <b>Note:</b>
       Do not use any of the keys in these examples. Use your own keys.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>beam()</b> = file:filename() | binary()

              Each  of  the  functions  described  below  accept  either  the filename (as a string) or a binary
              containing the BEAM module.

       <b>chunkdata()</b> =
           {chunkid(), dataB()} |
           {abstract_code, abst_code()} |
           {debug_info, debug_info()} |
           {attributes, [attrib_entry()]} |
           {compile_info, [compinfo_entry()]} |
           {exports, [{atom(), arity()}]} |
           {labeled_exports, [labeled_entry()]} |
           {imports, [mfa()]} |
           {indexed_imports,
            [{index(), module(), Function :: atom(), arity()}]} |
           {locals, [{atom(), arity()}]} |
           {labeled_locals, [labeled_entry()]} |
           {atoms, [{integer(), atom()}]}

              The list of attributes is sorted on <u>Attribute</u> (in <u>attrib_entry()</u>) and each attribute  name  occurs
              once  in  the  list.  The  attribute  values  occur in the same order as in the file. The lists of
              functions are also sorted.

       <b>chunkid()</b> = nonempty_string()

              "Attr" | "CInf" | "Dbgi" | "ExpT" | "ImpT" | "LocT" | "AtU8"

       <b>dataB()</b> = binary()

       <b>debug_info()</b> =
           {DbgiVersion :: atom(), Backend :: module(), Data :: term()} |
           no_debug_info

              The format stored in the <u>debug_info</u> chunk. To retrieve particular  code  representation  from  the
              backend,  <u>Backend:debug_info(Format,</u>  <u>Module,</u> <u>Data,</u> <u>Opts)</u> must be invoked. <u>Format</u> is an atom, such
              as <u>erlang_v1</u> for the Erlang Abstract Format or <u>core_v1</u> for  Core  Erlang.  <u>Module</u>  is  the  module
              represented  by  the  beam  file and <u>Data</u> is the value stored in the debug info chunk. <u>Opts</u> is any
              list of values supported by the <u>Backend</u>. <u>Backend:debug_info/4</u> must return <u>{ok,</u>  <u>Code}</u>  or  <u>{error,</u>
              <u>Term}</u>.

              Developers  must  always invoke the <u>debug_info/4</u> function and never rely on the <u>Data</u> stored in the
              <u>debug_info</u> chunk, as it is opaque and may change at any moment.  <u>no_debug_info</u>  means  that  chunk
              <u>"Dbgi"</u> is present, but empty.

       <b>abst_code()</b> =
           {AbstVersion :: atom(), forms()} | no_abstract_code

              It  is  not  checked  that  the  forms  conform  to  the abstract format indicated by <u>AbstVersion</u>.
              <u>no_abstract_code</u> means that chunk <u>"Abst"</u> is present, but empty.

              For modules compiled with OTP 20 onwards, the <u>abst_code</u> chunk is automatically computed  from  the
              <u>debug_info</u> chunk.

       <b>forms()</b> = [erl_parse:abstract_form() | erl_parse:form_info()]

       <b>compinfo_entry()</b> = {InfoKey :: atom(), term()}

       <b>attrib_entry()</b> =
           {Attribute :: atom(), [AttributeValue :: term()]}

       <b>labeled_entry()</b> = {Function :: atom(), arity(), label()}

       <b>index()</b> = integer() &gt;= 0

       <b>label()</b> = integer()

       <b>chunkref()</b> = chunkname() | chunkid()

       <b>chunkname()</b> =
           abstract_code | debug_info | attributes | compile_info |
           exports | labeled_exports | imports | indexed_imports |
           locals | labeled_locals | atoms

       <b>chnk_rsn()</b> =
           {unknown_chunk, file:filename(), atom()} |
           {key_missing_or_invalid,
            file:filename(),
            abstract_code | debug_info} |
           {missing_backend, file:filename(), module()} |
           info_rsn()

       <b>info_rsn()</b> =
           {chunk_too_big,
            file:filename(),
            chunkid(),
            ChunkSize :: integer() &gt;= 0,
            FileSize :: integer() &gt;= 0} |
           {invalid_beam_file,
            file:filename(),
            Position :: integer() &gt;= 0} |
           {invalid_chunk, file:filename(), chunkid()} |
           {missing_chunk, file:filename(), chunkid()} |
           {not_a_beam_file, file:filename()} |
           {file_error, file:filename(), file:posix()}

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>all_chunks(File</b> <b>::</b> <b>beam())</b> <b>-&gt;</b>
                     {ok, beam_lib, [{chunkid(), dataB()}]} |
                     {error, beam_lib, info_rsn()}

              Reads chunk data for all chunks.

       <b>build_module(Chunks)</b> <b>-&gt;</b> <b>{ok,</b> <b>Binary}</b>

              Types:

                 Chunks = [{chunkid(), dataB()}]
                 Binary = binary()

              Builds a BEAM module (as a binary) from a list of chunks.

       <b>chunks(Beam,</b> <b>ChunkRefs)</b> <b>-&gt;</b>
                 {ok, {module(), [chunkdata()]}} |
                 {error, beam_lib, chnk_rsn()}

              Types:

                 Beam = beam()
                 ChunkRefs = [chunkref()]

              Reads  chunk  data for selected chunks references. The order of the returned list of chunk data is
              determined by the order of the list of chunks references.

       <b>chunks(Beam,</b> <b>ChunkRefs,</b> <b>Options)</b> <b>-&gt;</b>
                 {ok, {module(), [ChunkResult]}} |
                 {error, beam_lib, chnk_rsn()}

              Types:

                 Beam = beam()
                 ChunkRefs = [chunkref()]
                 Options = [allow_missing_chunks]
                 ChunkResult =
                     chunkdata() | {ChunkRef :: chunkref(), missing_chunk}

              Reads chunk data for selected chunks references. The order of the returned list of chunk  data  is
              determined by the order of the list of chunks references.

              By  default,  if  any  requested chunk is missing in <u>Beam</u>, an <u>error</u> tuple is returned. However, if
              option <u>allow_missing_chunks</u> is specified, a result is returned even if chunks are missing. In  the
              result  list,  any missing chunks are represented as <u>{ChunkRef,missing_chunk}</u>. Notice however that
              if chunk <u>"Atom"</u> is missing, that is considered a fatal error and the  return  value  is  an  <u>error</u>
              tuple.

       <b>clear_crypto_key_fun()</b> <b>-&gt;</b> <b>undefined</b> <b>|</b> <b>{ok,</b> <b>Result}</b>

              Types:

                 Result = undefined | term()

              Unregisters the crypto key fun and terminates the process holding it, started by <u>crypto_key_fun/1</u>.

              Returns  either  <u>{ok,</u>  <u>undefined}</u> if no crypto key fun is registered, or <u>{ok,</u> <u>Term}</u>, where <u>Term</u> is
              the return value from <u>CryptoKeyFun(clear)</u>, see <u>crypto_key_fun/1</u>.

       <b>cmp(Beam1,</b> <b>Beam2)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>beam_lib,</b> <b>cmp_rsn()}</b>

              Types:

                 Beam1 = Beam2 = beam()
                 <b>cmp_rsn()</b> =
                     {modules_different, module(), module()} |
                     {chunks_different, chunkid()} |
                     different_chunks |
                     info_rsn()

              Compares the contents of two BEAM files. If the module names are the same, and all  chunks  except
              for  chunk  <u>"CInf"</u>  (the  chunk  containing  the  compilation  information  that  is  returned  by
              <u>Module:module_info(compile)</u>) have the same contents in both files, <u>ok</u> is  returned.  Otherwise  an
              error message is returned.

       <b>cmp_dirs(Dir1,</b> <b>Dir2)</b> <b>-&gt;</b>
                   {Only1, Only2, Different} | {error, beam_lib, Reason}

              Types:

                 Dir1 = Dir2 = atom() | file:filename()
                 Only1 = Only2 = [file:filename()]
                 Different =
                     [{Filename1 :: file:filename(), Filename2 :: file:filename()}]
                 Reason = {not_a_directory, term()} | info_rsn()

              Compares  the  BEAM files in two directories. Only files with extension <u>".beam"</u> are compared. BEAM
              files that exist only in directory <u>Dir1</u> (<u>Dir2</u>) are returned in  <u>Only1</u>  (<u>Only2</u>).  BEAM  files  that
              exist  in both directories but are considered different by <u>cmp/2</u> are returned as pairs {<u>Filename1</u>,
              <u>Filename2</u>}, where <u>Filename1</u> (<u>Filename2</u>) exists in directory <u>Dir1</u> (<u>Dir2</u>).

       <b>crypto_key_fun(CryptoKeyFun)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 CryptoKeyFun = crypto_fun()
                 Reason = badfun | exists | term()
                 <b>crypto_fun()</b> = fun((crypto_fun_arg()) -&gt; term())
                 <b>crypto_fun_arg()</b> =
                     init | clear | {debug_info, mode(), module(), file:filename()}
                 <b>mode()</b> = des3_cbc

              Registers an unary fun that is called if <u>beam_lib</u> must read an  <u>debug_info</u>  chunk  that  has  been
              encrypted. The fun is held in a process that is started by the function.

              If a fun is already registered when attempting to register a fun, <u>{error,</u> <u>exists}</u> is returned.

              The fun must handle the following arguments:

              CryptoKeyFun(init) -&gt; ok | {ok, NewCryptoKeyFun} | {error, Term}

              Called  when the fun is registered, in the process that holds the fun. Here the crypto key fun can
              do any necessary  initializations.  If  <u>{ok,</u>  <u>NewCryptoKeyFun}</u>  is  returned,  <u>NewCryptoKeyFun</u>  is
              registered  instead of <u>CryptoKeyFun</u>. If <u>{error,</u> <u>Term}</u> is returned, the registration is aborted and
              <u>crypto_key_fun/1</u> also returns <u>{error,</u> <u>Term}</u>.

              CryptoKeyFun({debug_info, Mode, Module, Filename}) -&gt; Key

              Called when the key is needed for module <u>Module</u> in the file named <u>Filename</u>. <u>Mode</u> is  the  type  of
              crypto  algorithm;  currently,  the only possible value is <u>des3_cbc</u>. The call is to fail (raise an
              exception) if no key is available.

              CryptoKeyFun(clear) -&gt; term()

              Called before the fun is unregistered. Here any cleaning up can be done. The return value  is  not
              important, but is passed back to the caller of <u>clear_crypto_key_fun/0</u> as part of its return value.

       <b>diff_dirs(Dir1,</b> <b>Dir2)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>beam_lib,</b> <b>Reason}</b>

              Types:

                 Dir1 = Dir2 = atom() | file:filename()
                 Reason = {not_a_directory, term()} | info_rsn()

              Compares  the  BEAM  files  in two directories as <u>cmp_dirs/2</u>, but the names of files that exist in
              only one directory or are different are presented on standard output.

       <b>format_error(Reason)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

              Types:

                 Reason = term()

              For a specified error returned by any function in this module, this function returns a descriptive
              string of the error in English. For  file  errors,  function  <u>file:format_error(Posix)</u>  is  to  be
              called.

       <b>info(Beam)</b> <b>-&gt;</b> <b>[InfoPair]</b> <b>|</b> <b>{error,</b> <b>beam_lib,</b> <b>info_rsn()}</b>

              Types:

                 Beam = beam()
                 InfoPair =
                     {file, Filename :: file:filename()} |
                     {binary, Binary :: binary()} |
                     {module, Module :: module()} |
                     {chunks,
                      [{ChunkId :: chunkid(),
                        Pos :: integer() &gt;= 0,
                        Size :: integer() &gt;= 0}]}

              Returns a list containing some information about a BEAM file as tuples <u>{Item,</u> <u>Info}</u>:

                <u>{file,</u> <u>Filename}</u> <u>|</u> <u>{binary,</u> <u>Binary}</u>:
                  The name (string) of the BEAM file, or the binary from which the information was extracted.

                <u>{module,</u> <u>Module}</u>:
                  The name (atom) of the module.

                <u>{chunks,</u> <u>[{ChunkId,</u> <u>Pos,</u> <u>Size}]}</u>:
                  For each chunk, the identifier (string) and the position and size of the chunk data, in bytes.

       <b>md5(Beam)</b> <b>-&gt;</b> <b>{ok,</b> <b>{module(),</b> <b>MD5}}</b> <b>|</b> <b>{error,</b> <b>beam_lib,</b> <b>chnk_rsn()}</b>

              Types:

                 Beam = beam()
                 MD5 = binary()

              Calculates  an  MD5  redundancy  check  for  the  code  of  the module (compilation date and other
              attributes are not included).

       <b>strip(Beam1)</b> <b>-&gt;</b>
                {ok, {module(), Beam2}} | {error, beam_lib, info_rsn()}

              Types:

                 Beam1 = Beam2 = beam()

              Removes all chunks from a BEAM file except those needed by the loader. In  particular,  the  debug
              information (chunk <u>debug_info</u> and <u>abstract_code</u>) is removed.

       <b>strip(Beam1,</b> <b>AdditionalChunks)</b> <b>-&gt;</b>
                {ok, {module(), Beam2}} | {error, beam_lib, info_rsn()}

              Types:

                 Beam1 = beam()
                 AdditionalChunks = [chunkid()]
                 Beam2 = beam()

              Removes all chunks from a BEAM file except those needed by the loader or passed in. In particular,
              the debug information (chunk <u>debug_info</u> and <u>abstract_code</u>) is removed.

       <b>strip_files(Files)</b> <b>-&gt;</b>
                      {ok, [{module(), Beam}]} |
                      {error, beam_lib, info_rsn()}

              Types:

                 Files = [beam()]
                 Beam = beam()

              Removes  all  chunks  except  those needed by the loader from BEAM files. In particular, the debug
              information (chunk <u>debug_info</u> and <u>abstract_code</u>)  is  removed.  The  returned  list  contains  one
              element for each specified filename, in the same order as in <u>Files</u>.

       <b>strip_files(Files,</b> <b>AdditionalChunks)</b> <b>-&gt;</b>
                      {ok, [{module(), Beam}]} |
                      {error, beam_lib, info_rsn()}

              Types:

                 Files = [beam()]
                 AdditionalChunks = [chunkid()]
                 Beam = beam()

              Removes  all chunks except those needed by the loader or passed in from BEAM files. In particular,
              the debug information (chunk <u>debug_info</u> and <u>abstract_code</u>) is removed. The returned list  contains
              one element for each specified filename, in the same order as in <u>Files</u>.

       <b>strip_release(Dir)</b> <b>-&gt;</b>
                        {ok, [{module(), file:filename()}]} |
                        {error, beam_lib, Reason}

              Types:

                 Dir = atom() | file:filename()
                 Reason = {not_a_directory, term()} | info_rsn()

              Removes  all  chunks except those needed by the loader from the BEAM files of a release. <u>Dir</u> is to
              be the installation root directory. For example, the current OTP release can be stripped with  the
              call <u>beam_lib:strip_release(code:root_dir())</u>.

       <b>strip_release(Dir,</b> <b>AdditionalChunks)</b> <b>-&gt;</b>
                        {ok, [{module(), file:filename()}]} |
                        {error, beam_lib, Reason}

              Types:

                 Dir = atom() | file:filename()
                 AdditionalChunks = [chunkid()]
                 Reason = {not_a_directory, term()} | info_rsn()

              Removes  all  chunks  except  those  needed  by  the  loader or passed in from the BEAM files of a
              release. <u>Dir</u> is to be the installation root directory. For example, the current OTP release can be
              stripped with the call <u>beam_lib:strip_release(code:root_dir())</u>.

       <b>version(Beam)</b> <b>-&gt;</b>
                  {ok, {module(), [Version :: term()]}} |
                  {error, beam_lib, chnk_rsn()}

              Types:

                 Beam = beam()

              Returns the module version or versions. A version is defined by  module  attribute  <u>-vsn(Vsn)</u>.  If
              this  attribute  is not specified, the version defaults to the checksum of the module. Notice that
              if version <u>Vsn</u> is not a list, it is made into one, that is  <u>{ok,{Module,[Vsn]}}</u>  is  returned.  If
              there are many <u>-vsn</u> module attributes, the result is the concatenated list of versions.

              <u>Examples:</u>

              1&gt; beam_lib:version(a). % -<a href="../man1/vsn.1.html">vsn</a>(1).
              {ok,{a,[1]}}
              2&gt; beam_lib:version(b). % -vsn([1]).
              {ok,{b,[1]}}
              3&gt; beam_lib:version(c). % -vsn([1]). -<a href="../man2/vsn.2.html">vsn</a>(2).
              {ok,{c,[1,2]}}
              4&gt; beam_lib:version(d). % no -vsn attribute
              {ok,{d,[275613208176997377698094100858909383631]}}

Ericsson AB                                        stdlib 3.17                                    <u><a href="../man3erl/beam_lib.3erl.html">beam_lib</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>