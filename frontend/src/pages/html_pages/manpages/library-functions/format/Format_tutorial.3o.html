<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Format_tutorial -  Using the Format module</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Format_tutorial -  Using the Format module

</pre><h4><b>Module</b></h4><pre>
       Module   Format_tutorial

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Format_tutorial</b>
        : <b>sig</b> <b>end</b>

   <b>Using</b> <b>the</b> <b>Format</b> <b>module</b>
   <b>Principles</b>
       Line breaking is based on three concepts:

       -boxes : a box is a logical pretty-printing unit, which defines a behaviour of the pretty-printing engine
       to display the material inside the box.

       -break  hints:  a break hint is a directive to the pretty-printing engine that proposes to break the line
       here, if it is necessary to properly print the rest of  the  material.   Otherwise,  the  pretty-printing
       engine  never  break  lines  (except "in case of emergency" to avoid very bad output).  In short, a break
       hint tells the pretty printer that a line break here may be appropriate.

       -indentation rules: When a line break occurs, the  pretty-printing  engines  fixes  the  indentation  (or
       amount of leading spaces) of the new line using indentation rules, as follows:

       -A  box  can state the extra indentation of every new line opened in its scope. This extra indentation is
       named box breaking indentation.

       -A break hint can also set the additional indentation of the new line it may fire. This extra indentation
       is named hint breaking indentation.

       - If break hint <b>bh</b> fires a new line within box <b>b</b> , then the indentation of the new line is simply the sum
       of: the current indentation of box <b>b</b> + the additional box breaking indentation, as defined by box <b>b</b> + the
       additional hint breaking indentation, as defined by break hint <b>bh</b> .

   <b>Boxes</b>
       There are 4 types of boxes. (The most often used is the "hov"  box  type,  so  skip  the  rest  at  first
       reading).

       -horizontal  box  (h box, as obtained by the <b>Format.open_hbox</b> procedure): within this box, break hints do
       not lead to line breaks.

       -vertical box (v box, as obtained by the <b>Format.open_vbox</b> procedure): within this box, every  break  hint
       lead to a new line.

       -vertical/horizontal box (hv box, as obtained by the <b>Format.open_hvbox</b> procedure): if it is possible, the
       entire box is written on a single line; otherwise, every break hint within the box leads to a new line.

       -vertical  or  horizontal  box  (hov  box,  as  obtained  by  the  <b>Format.open_box</b>  or <b>Format.open_hovbox</b>
       procedures): within this box, break hints are used to cut the line when there is  no  more  room  on  the
       line. There are two kinds of "hov" boxes, you can find the details below.  In first approximation, let me
       consider  these  two  kinds  of  "hov"  boxes  as  equivalent and obtained by calling the <b>Format.open_box</b>
       procedure.

       Let me give an example. Suppose we can write 10 chars before the right margin  (that  indicates  no  more
       room).  We  represent any char as a <b>-</b> sign; characters <b>[</b> and <b>]</b> indicates the opening and closing of a box
       and <b>b</b> stands for a break hint given to the pretty-printing engine.

       The output "--b--b--" is displayed like this (the <b>b</b> symbol stands for the value  of  the  break  that  is
       explained below):

       Within a "h" box:


       <b>--b--b--</b>
       Within a "v" box:

       <b>--b</b>
       <b>--b</b>
       <b>--</b>

       Within a "hv" box:

       If there is enough room to print the box on the line:


       <b>--b--b--</b>
       But "---b---b---" that cannot fit on the line is written

       <b>---b</b>
       <b>---b</b>
       <b>---</b>

       Within a "hov" box:

       If there is enough room to print the box on the line:


       <b>--b--b--</b>
       But if "---b---b---" cannot fit on the line, it is written as

       <b>---b---b</b>
       <b>---</b>

       The  first break hint does not lead to a new line, since there is enough room on the line. The second one
       leads to a new line since there is no more room to print the material following it. If the room  left  on
       the line were even shorter, the first break hint may lead to a new line and "---b---b---" is written as:

       <b>---b</b>
       <b>---b</b>
       <b>---</b>

   <b>Printing</b> <b>spaces</b>
       Break  hints  are  also  used  to  output spaces (if the line is not split when the break is encountered,
       otherwise the new line indicates properly the separation between printing items). You output a break hint
       using <b>print_break</b> <b>sp</b> <b>indent</b> , and this sp integer is used to print "sp" spaces. Thus <b>print_break</b>  <b>sp</b>  <b>...</b>
       may be thought as: print <b>sp</b> spaces or output a new line.

       For instance, if b is <b>break</b> <b>1</b> <b>0</b> in the output "--b--b--", we get

       within a "h" box:

       <b>--</b> <b>--</b> <b>--</b>

       within a "v" box:

       <b>--</b>
       <b>--</b>
       <b>--</b>

       within a "hv" box:
       <b>--</b> <b>--</b> <b>--</b>

       or, according to the remaining room on the line:

       <b>--</b>
       <b>--</b>
       <b>--</b>

       and similarly for "hov" boxes.

       Generally  speaking,  a  printing  routine  using  "format", should not directly output white spaces: the
       routine should use break hints instead. (For instance <b>print_space</b> <b>()</b> that is  a  convenient  abbreviation
       for <b>print_break</b> <b>1</b> <b>0</b> and outputs a single space or break the line.)

   <b>Indentation</b> <b>of</b> <b>new</b> <b>lines</b>
       The user gets 2 ways to fix the indentation of new lines:

       When  defining  the  box:  when you open a box, you can fix the indentation added to each new line opened
       within that box.

       For instance: <b>open_hovbox</b> <b>1</b> opens a "hov" box with new lines indented 1 more than the initial indentation
       of the box. With output "---[--b--b--b--", we get:

       <b>---[--b--b</b>

            <b>--b--</b>
       with open_hovbox 2, we get

       <b>---[--b--b</b>

             <b>--b--</b>
       Note: the [ sign in the display is not visible on the  screen,  it  is  just  there  to  materialise  the
       aperture of the pretty-printing box. Last "screen" stands for:

       <b>-----b--b</b>

            <b>--b--</b>
       When defining the break that makes the new line. As said above, you output a break hint using <b>print_break</b>
       <b>sp</b>  <b>indent</b>  . The <b>indent</b> integer is used to fix the additional indentation of the new line. Namely, it is
       added to the default indentation offset of the box where the break occurs.

       For instance, if [ stands for the opening of a "hov" box with 1 as  extra  indentation  (as  obtained  by
       <b>open_hovbox</b> <b>1</b> ), and b is <b>print_break</b> <b>1</b> <b>2</b> , then from output "---[--b--b--b--", we get:

          <b>---[--</b> <b>--</b>
                <b>--</b>
                <b>--</b>

   <b>Refinement</b> <b>on</b> <b>hov</b> <b>boxes</b>
       The "hov" box type is refined into two categories.

       -the  vertical  or  horizontal packing box (as obtained by the <b>Format.open_hovbox</b> procedure): break hints
       are used to cut the line when there is no more room on the line; no new line occurs if  there  is  enough
       room on the line.

       -vertical  or  horizontal  structural  box (as obtained by the <b>Format.open_box</b> procedure): similar to the
       "hov" packing box, the break hints are used to cut the line when there is no more room on  the  line;  in
       addition,  break  hints that can show the box structure lead to new lines even if there is enough room on
       the current line.

       The difference between a packing and a structural "hov" box is shown by a routine that closes  boxes  and
       parentheses  at the end of printing: with packing boxes, the closure of boxes and parentheses do not lead
       to new lines if there is enough room on the line, whereas with structural boxes each break hint will lead
       to a new line. For instance, when printing "[(---[(----[(---b)]b)]b)]", where "b" is a break hint without
       extra indentation ( <b>print_cut</b> <b>()</b> ). If "[" means opening of a packing "hov" box ( <b>Format.open_hovbox</b>  1),
       "[(---[(----[(---b)]b)]b)]" is printed as follows:

       <b>(---</b>
        <b>(----</b>
         <b>(---)))</b>

       If we replace the packing boxes by structural boxes ( <b>Format.open_box</b> 1), each break hint that precedes a
       closing   parenthesis   can   show   the   boxes   structure,   if   it   leads  to  a  new  line;  hence
       "[(---[(----[(---b)]b)]b)]" is printed like this:

       <b>(---</b>
        <b>(----</b>
         <b>(---</b>
          <b>)</b>
         <b>)</b>
        <b>)</b>

       Each break hint increases indentation by one, both for  opening  and  closing  parenthesis,  because  the
       parenthesis  are  just  characters  and  don't  have  special meaning for the formatter.  Notice that the
       closing parenthesis is not vertically aligned with the opening parenthesis.

       We can line up the opening and closing parenthesis vertically in two ways:

       -by using a break hint "b" with negative indentation that matches the  opening  indentation  of  the  box
       `@;&lt;0 -1&gt;`, canceling it.

       -by   using   an   additional   box,   and   making  all  boxes  and  break  hints  use  no  indentation:
       "[([---[([----[([---]b)]]b)]]b)]"

       In both cases the output would be this:

       <b>(---</b>
        <b>(----</b>
         <b>(---</b>
         <b>)</b>
        <b>)</b>
       <b>)</b>

   <b>Practical</b> <b>advice</b>
       When writing a pretty-printing routine, follow these simple rules:

       -Boxes must be opened and  closed  consistently  (  <b>open_*</b>  and  <b>Format.close_box</b>  must  be  nested  like
       parentheses).

       -Never hesitate to open a box.

       -Output  many  break  hints,  otherwise the pretty-printer is in a bad situation where it tries to do its
       best, which is always "worse than your bad".

       -Break hints with negative indentation should only be used when you are sure that you  don't  exceed  the
       indentation  of  the  opening box (e.g. both part of the same function and an exact match). Exceeding the
       indentation of the opening box is not compositional.

       -Do not try to force spacing using explicit spaces in the character strings.  For each space you want  in
       the  output  emit a break hint ( <b>print_space</b> <b>()</b> ), unless you explicitly don't want the line to be broken
       here. For instance, imagine you want to pretty print an OCaml definition, more precisely a <b>let</b> <b>rec</b>
       <b>ident</b> <b>=</b> <b>expression</b> value definition. You will probably treat  the  first  three  spaces  as  "unbreakable
       spaces"  and  write  them  directly  in the string constants for keywords, and print <b>"let</b> <b>rec"</b> before the
       identifier, and similarly write <b>=</b> to get an unbreakable space after  the  identifier;  in  contrast,  the
       space  after  the  <b>=</b>  sign  is  certainly  a  break hint, since breaking the line after <b>=</b> is a usual (and
       elegant) way to indent the expression part of a definition.  In short, it is  often  necessary  to  print
       unbreakable spaces; however, most of the time a space should be considered a break hint.

       -Do  not  try  to  force  new  lines,  let  the  pretty-printer  do  it for you: that's its only job.  In
       particular, do not use <b>Format.force_newline</b> : this procedure effectively leads to a newline, but it  also
       as  the unfortunate side effect to partially reinitialise the pretty-printing engine, so that the rest of
       the printing material is noticeably messed up.

       -Never put newline characters directly in the strings to be printed: pretty printing engine will consider
       this newline character as any other character written on the current line and this will  completely  mess
       up  the  output.   Instead  of new line characters use line break hints: if those break hints must always
       result in new lines, it just means that the surrounding box must be a vertical box!

       -End your main program by a <b>print_newline</b> <b>()</b> call, that flushes  the  pretty-printer  tables  (hence  the
       output).   (Note  that  the  top-level  loop of the interactive system does it as well, just before a new
       input.)

   <b>Printing</b> <b>to</b> <b>stdout:</b> <b>using</b> <b>printf</b>
       The format module provides a general printing facility "a la" printf. In addition to the usual conversion
       facility provided by printf, you can write pretty-printing indications directly inside the format  string
       (opening and closing boxes, indicating breaking hints, etc).

       Pretty-printing  annotations  are introduced by the <b>@</b> symbol, directly into the string format. Almost any
       function of the <b>Format</b> module can be called from within a <b>printf</b> format string. For instance

       -" <b>@[</b> " open a box (open_box 0).  You may precise the type as an extra argument. For instance  <b>@[&lt;hov</b>  <b>n&gt;</b>
       is equivalent to <b>open_hovbox</b> <b>n</b> .

       -" <b>@]</b> " close a box ( <b>close_box</b> <b>()</b> ).

       -" <b>@</b> " output a breakable space ( <b>print_space</b> <b>()</b> ).

       -" <b>@,</b> " output a break hint ( <b>print_cut</b> <b>()</b> ).

       -" <b>@;&lt;n</b> <b>m&gt;</b> " emit a "full" break hint ( <b>print_break</b> <b>n</b> <b>m</b> ).

       -" <b>@.</b>  " end the pretty-printing, closing all the boxes still opened ( <b>print_newline</b> <b>()</b> ).

       For instance

       printf "@[&lt;1&gt;%s@ =@ %d@ %s@]@." "Prix TTC" 100 "Euros";; Prix TTC = 100 Euros - : unit = ()

   <b>A</b> <b>concrete</b> <b>example</b>
       Let  me  give  a  full  example:  the  shortest non trivial example you could imagine, that is the lambda
       calculus :)

       Thus the problem is to pretty-print the values of  a  concrete  data  type  that  models  a  language  of
       expressions that defines functions and their applications to arguments.

       First, I give the abstract syntax of lambda-terms:

       type lambda = | Lambda of string * lambda | Var of string | Apply of lambda * lambda ;;

       I use the format library to print the lambda-terms:

       open  Format;; let ident = print_string;; let kwd = print_string;; val ident : string -&gt; unit = &lt;fun&gt; val
       kwd : string -&gt; unit = &lt;fun&gt; let rec print_exp0 = function | Var s -&gt;  ident s | lam  -&gt;  open_hovbox  1;
       kwd  "(";  print_lambda  lam;  kwd  ")";  close_box  ()  and  print_app  = function | e -&gt; open_hovbox 2;
       print_other_applications e; close_box () and print_other_applications f = match f with | Apply  (f,  arg)
       -&gt;  print_app  f; print_space (); print_exp0 arg | f -&gt; print_exp0 f and print_lambda = function | Lambda
       (s, lam) -&gt; open_hovbox 1; kwd "\\"; ident s; kwd "."; print_space(); print_lambda lam; close_box()  |  e
       -&gt;  print_app  e;; val print_app : lambda -&gt; unit = &lt;fun&gt; val print_other_applications : lambda -&gt; unit =
       &lt;fun&gt; val print_lambda : lambda -&gt; unit = &lt;fun&gt;

   <b>Most</b> <b>general</b> <b>pretty-printing:</b> <b>using</b> <b>fprintf</b>
       We use the <b>fprintf</b> function to write the most versatile version  of  the  pretty-printing  functions  for
       lambda-terms.   Now,  the  functions  get  an extra argument, namely a pretty-printing formatter (the ppf
       argument) where printing will occur. This way the printing routines are  more  general,  since  they  can
       print  on  any formatter defined in the program (either printing to a file, or to <b>stdout</b> , to <b>stderr</b> , or
       even to a string).  Furthermore, the pretty-printing functions are now compositional, since they  may  be
       used in conjunction with the special <b>%a</b> conversion, that prints a <b>fprintf</b> argument with a user's supplied
       function (these user's supplied functions also have a formatter as first argument).

       Using <b>fprintf</b> , the lambda-terms printing routines can be written as follows:

       open  Format;;  let  ident  ppf s = fprintf ppf "%s" s;; let kwd ppf s = fprintf ppf "%s" s;; val ident :
       Format.formatter -&gt; string -&gt; unit val kwd : Format.formatter -&gt; string -&gt; unit let  rec  pr_exp0  ppf  =
       function  | Var s -&gt; fprintf ppf "%a" ident s | lam -&gt; fprintf ppf "@[&lt;1&gt;(%a)@]" pr_lambda lam and pr_app
       ppf = function | e -&gt; fprintf ppf "@[&lt;2&gt;%a@]" pr_other_applications e and pr_other_applications ppf  f  =
       match  f  with  |  Apply  (f,  arg) -&gt; fprintf ppf "%a@ %a" pr_app f pr_exp0 arg | f -&gt; pr_exp0 ppf f and
       pr_lambda ppf = function | Lambda (s, lam) -&gt; fprintf ppf "@[&lt;1&gt;%a%a%a@ %a@]" kwd "\\" ident  s  kwd  "."
       pr_lambda  lam  |  e  -&gt;  pr_app  ppf  e  ;;  val  pr_app  :  Format.formatter  -&gt;  lambda  -&gt;  unit  val
       pr_other_applications : Format.formatter -&gt; lambda -&gt; unit val pr_lambda : Format.formatter -&gt; lambda  -&gt;
       unit

       Given  those  general  printing  routines,  procedures  to  print to <b>stdout</b> or <b>stderr</b> is just a matter of
       partial application:

       let  print_lambda  =  pr_lambda  std_formatter;;  let  eprint_lambda  =  pr_lambda  err_formatter;;   val
       print_lambda : lambda -&gt; unit val eprint_lambda : lambda -&gt; unit

OCamldoc                                           2025-06-12                                <u><a href="../man3o/Format_tutorial.3o.html">Format_tutorial</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>