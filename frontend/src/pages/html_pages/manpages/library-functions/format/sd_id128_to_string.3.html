<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sd_id128_to_string, SD_ID128_TO_STRING, SD_ID128_STRING_MAX, sd_id128_to_uuid_string,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsystemd-dev">libsystemd-dev_257.7-1ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sd_id128_to_string, SD_ID128_TO_STRING, SD_ID128_STRING_MAX, sd_id128_to_uuid_string,
       SD_ID128_TO_UUID_STRING, SD_ID128_UUID_STRING_MAX, sd_id128_from_string - Format or parse 128-bit IDs as
       strings

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;systemd/sd-id128.h&gt;</b>

       <b>#define</b> <b>SD_ID128_STRING_MAX</b> <b>33U</b>

       <b>#define</b> <b>SD_ID128_UUID_STRING_MAX</b> <b>37U</b>

       <b>#define</b> <b>SD_ID128_TO_STRING(id)</b> <b>...</b>

       <b>#define</b> <b>SD_ID128_TO_UUID_STRING(id)</b> <b>...</b>

       <b>char</b> <b>*sd_id128_to_string(sd_id128_t</b> <u>id</u><b>,</b> <b>char</b> <u>s</u><b>[static</b> <b>SD_ID128_STRING_MAX]);</b>

       <b>char</b> <b>*sd_id128_uuid_string(sd_id128_t</b> <u>id</u><b>,</b> <b>char</b> <u>s</u><b>[static</b> <b>SD_ID128_UUID_STRING_MAX]);</b>

       <b>int</b> <b>sd_id128_from_string(const</b> <b>char</b> <b>*</b><u>s</u><b>,</b> <b>sd_id128_t</b> <b>*</b><u>ret</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>sd_id128_to_string()</b> formats a 128-bit ID as a character string. It expects the ID and a string array
       capable of storing 33 characters (<b>SD_ID128_STRING_MAX</b>). The ID will be formatted as 32 lowercase
       hexadecimal digits and be terminated by a <b>NUL</b> byte.

       <b>SD_ID128_TO_STRING()</b> is a macro that wraps <b>sd_id128_to_string()</b> and passes an appropriately sized buffer
       as second argument, allocated as C99 compound literal. Each use will thus implicitly acquire a suitable
       buffer on the stack which remains valid until the end of the current code block. This is usually the
       simplest way to acquire a string representation of a 128-bit ID in a buffer that is valid in the current
       code block.

       <b>sd_id128_to_uuid_string()</b> and <b>SD_ID128_TO_UUID_STRING()</b> are similar to these two functions/macros, but
       format the 128-bit values as RFC4122 UUIDs, i.e. a series of 36 lowercase hexadeciaml digits and dashes,
       terminated by a <b>NUL</b> byte.

       <b>sd_id128_from_string()</b> implements the reverse operation: it takes a 33 character string with 32
       hexadecimal digits (either lowercase or uppercase, terminated by <b>NUL</b>) and parses them back into a 128-bit
       ID returned in <u>ret</u>. Alternatively, this call can also parse a 37-character string with a 128-bit ID
       formatted as RFC UUID. If <u>ret</u> is passed as <b>NULL</b> the function will validate the passed ID string, but not
       actually return it in parsed form.

       Note that when formatting and parsing 36 character UUIDs this is done strictly in Big Endian byte order,
       i.e. according to <b>RFC4122</b>[1] Variant 1 rules, even if the UUID encodes a different variant. This matches
       behaviour in various other Linux userspace tools. It's probably wise to avoid UUIDs of other variant
       types.

       For more information about the "sd_id128_t" type see <b><a href="../man3/sd-id128.3.html">sd-id128</a></b>(3). Note that these calls operate the same
       way on all architectures, i.e. the results do not depend on endianness.

       When formatting a 128-bit ID into a string, it is often easier to use a format string for <b><a href="../man3/printf.3.html">printf</a></b>(3). This
       is easily done using the <b>SD_ID128_FORMAT_STR</b> and <b>SD_ID128_FORMAT_VAL()</b> macros. For more information see
       <b><a href="../man3/sd-id128.3.html">sd-id128</a></b>(3).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>sd_id128_to_string()</b> always succeeds and returns a pointer to the string array passed in.
       <b>sd_id128_from_string()</b> returns 0 on success, in which case <u>ret</u> is filled in, or a negative errno-style
       error code.

</pre><h4><b>NOTES</b></h4><pre>
       Functions described here are available as a shared library, which can be compiled against and linked to
       with the <b>libsystemd</b> <b><a href="../man1/pkg-config.1.html">pkg-config</a></b>(1) file.

       The code described here uses <b><a href="../man3/getenv.3.html">getenv</a></b>(3), which is declared to be not multi-thread-safe. This means that
       the code calling the functions described here must not call <b><a href="../man3/setenv.3.html">setenv</a></b>(3) from a parallel thread. It is
       recommended to only do calls to <b>setenv()</b> from an early phase of the program when no other threads have
       been started.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>sd_id128_to_string()</b> and <b>sd_id128_from_string()</b> were added in version 187.

       <b>sd_id128_uuid_string()</b> was added in version 251.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/systemd.1.html">systemd</a></b>(1), <b><a href="../man3/sd-id128.3.html">sd-id128</a></b>(3), <b><a href="../man3/printf.3.html">printf</a></b>(3)

</pre><h4><b>NOTES</b></h4><pre>
        1. RFC4122
           https://tools.ietf.org/html/rfc4122

systemd 257.7                                                                              <u><a href="../man3/SD_ID128_TO_STRING.3.html">SD_ID128_TO_STRING</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>