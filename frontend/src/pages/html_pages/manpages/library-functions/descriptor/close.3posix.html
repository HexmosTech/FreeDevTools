<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       close — close a file descriptor

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       int close(int <u>fildes</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>close</u>()  function  shall deallocate the file descriptor indicated by <u>fildes</u>.  To deallocate means to
       make the file descriptor available for return by subsequent calls  to  <u>open</u>()  or  other  functions  that
       allocate  file descriptors. All outstanding record locks owned by the process on the file associated with
       the file descriptor shall be removed (that is, unlocked).

       If <u>close</u>() is interrupted by a signal that is to be caught, it shall return -1 with <u>errno</u> set to  <b>[EINTR]</b>
       and  the  state  of  <u>fildes</u> is unspecified. If an I/O error occurred while reading from or writing to the
       file system during <u>close</u>(), it may return -1 with <u>errno</u> set to <b>[EIO]</b>; if  this  error  is  returned,  the
       state of <u>fildes</u> is unspecified.

       When  all  file descriptors associated with a pipe or FIFO special file are closed, any data remaining in
       the pipe or FIFO shall be discarded.

       When all file descriptors associated with an open file  description  have  been  closed,  the  open  file
       description shall be freed.

       If  the  link  count of the file is 0, when all file descriptors associated with the file are closed, the
       space occupied by the file shall be freed and the file shall no longer be accessible.

       If a STREAMS-based <u>fildes</u> is closed and the calling  process  was  previously  registered  to  receive  a
       SIGPOLL  signal  for  events  associated  with that STREAM, the calling process shall be unregistered for
       events associated with the STREAM. The last <u>close</u>() for a STREAM shall cause the STREAM  associated  with
       <u>fildes</u>  to  be dismantled. If O_NONBLOCK is not set and there have been no signals posted for the STREAM,
       and if there is data on the module's write queue, <u>close</u>() shall wait for an unspecified  time  (for  each
       module  and  driver) for any output to drain before dismantling the STREAM. The time delay can be changed
       via an I_SETCLTIME <u>ioctl</u>() request. If the O_NONBLOCK flag is set, or if there are any  pending  signals,
       <u>close</u>() shall not wait for output to drain, and shall dismantle the STREAM immediately.

       If  the implementation supports STREAMS-based pipes, and <u>fildes</u> is associated with one end of a pipe, the
       last <u>close</u>() shall cause a hangup to occur on the other end of the pipe. In addition, if the other end of
       the pipe has been named by <u>fattach</u>(), then the last <u>close</u>() shall force the named end to be  detached  by
       <u>fdetach</u>().   If  the  named  end  has  no open file descriptors associated with it and gets detached, the
       STREAM associated with that end shall also be dismantled.

       If <u>fildes</u> refers to the master side of a pseudo-terminal, and this is the last  close,  a  SIGHUP  signal
       shall  be sent to the controlling process, if any, for which the slave side of the pseudo-terminal is the
       controlling terminal. It is unspecified whether closing the master side of  the  pseudo-terminal  flushes
       all queued input and output.

       If  <u>fildes</u> refers to the slave side of a STREAMS-based pseudo-terminal, a zero-length message may be sent
       to the master.

       When there is an outstanding cancelable asynchronous I/O operation against <u>fildes</u> when <u>close</u>() is called,
       that I/O operation may be canceled. An I/O operation that is not canceled completes  as  if  the  <u>close</u>()
       operation  had  not  yet  occurred. All operations that are not canceled shall complete as if the <u>close</u>()
       blocked until the operations completed. The <u>close</u>() operation itself need not  block  awaiting  such  I/O
       completion.  Whether any I/O operation is canceled, and which I/O operation may be canceled upon <u>close</u>(),
       is implementation-defined.

       If a memory mapped file or a shared memory object remains referenced  at  the  last  close  (that  is,  a
       process  has  it  mapped),  then  the entire contents of the memory object shall persist until the memory
       object becomes unreferenced.  If this is the last close of a memory mapped file or a shared memory object
       and the close results in the memory  object  becoming  unreferenced,  and  the  memory  object  has  been
       unlinked, then the memory object shall be removed.

       If  <u>fildes</u>  refers  to  a  socket,  <u>close</u>()  shall  cause the socket to be destroyed. If the socket is in
       connection-mode, and the SO_LINGER option is set for the socket with non-zero linger time, and the socket
       has untransmitted data, then <u>close</u>() shall block for up to the current linger interval until all data  is
       transmitted.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon  successful  completion,  0  shall  be  returned;  otherwise,  -1 shall be returned and <u>errno</u> set to
       indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>close</u>() function shall fail if:

       <b>EBADF</b>  The <u>fildes</u> argument is not a open file descriptor.

       <b>EINTR</b>  The <u>close</u>() function was interrupted by a signal.

       The <u>close</u>() function may fail if:

       <b>EIO</b>    An I/O error occurred while reading from or writing to the file system.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Reassigning</b> <b>a</b> <b>File</b> <b>Descriptor</b>
       The following example closes the file descriptor associated with standard output for the current process,
       re-assigns standard output to a new file descriptor, and closes the original file descriptor to clean up.
       This example assumes that the file descriptor 0 (which is the  descriptor  for  standard  input)  is  not
       closed.

           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           ...
           int pfd;
           ...
           <a href="../man1/close.1.html">close</a>(1);
           dup(pfd);
           close(pfd);
           ...

       Incidentally, this is exactly what could be achieved using:

           dup2(pfd, 1);
           close(pfd);

   <b>Closing</b> <b>a</b> <b>File</b> <b>Descriptor</b>
       In  the  following  example,  <u>close</u>() is used to close a file descriptor after an unsuccessful attempt is
       made to associate that file descriptor with a stream.

           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

           #define LOCKFILE "/etc/ptmp"
           ...
           int pfd;
           FILE *fpfd;
           ...
           if ((fpfd = fdopen (pfd, "w")) == NULL) {
               close(pfd);
               unlink(LOCKFILE);
               <a href="../man1/exit.1.html">exit</a>(1);
           }
           ...

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       An application that had used the <u>stdio</u> routine <u>fopen</u>() to  open  a  file  should  use  the  corresponding
       <u>fclose</u>() routine rather than <u>close</u>().  Once a file is closed, the file descriptor no longer exists, since
       the integer corresponding to it no longer refers to a file.

       Implementations  may  use  file  descriptors  that  must  be inherited into child processes for the child
       process to remain conforming, such as for message catalog or tracing purposes. Therefore, an  application
       that  calls  <u>close</u>() on an arbitrary integer risks non-conforming behavior, and <u>close</u>() can only portably
       be used on file descriptor values that the application has obtained through explicit actions, as well  as
       the  three  file  descriptors  corresponding  to  the  standard  file  streams.  In multi-threaded parent
       applications, the practice of calling <u>close</u>() in a loop after <u>fork</u>() and before an <u>exec</u> call in order  to
       avoid  a  race  condition  of  leaking  an  unintended file descriptor into a child process, is therefore
       unsafe, and the race should instead be combatted by opening all file descriptors with the FD_CLOEXEC  bit
       set unless the file descriptor is intended to be inherited across <u>exec</u>.

       Usage  of <u>close</u>() on file descriptors STDIN_FILENO, STDOUT_FILENO, or STDERR_FILENO should immediately be
       followed by an operation to reopen these file descriptors. Unexpected behavior  will  result  if  any  of
       these  file  descriptors is left in a closed state (for example, an <b>[EBADF]</b> error from <u>perror</u>()) or if an
       unrelated <u>open</u>() or similar call later in the application accidentally allocates a file to one  of  these
       well-known  file descriptors. Furthermore, a <u>close</u>() followed by a reopen operation (e.g., <u>open</u>(), <u>dup</u>(),
       etc.) is not atomic; <u>dup2</u>() should be used to change standard file descriptors.

</pre><h4><b>RATIONALE</b></h4><pre>
       The use of interruptible device close routines should be discouraged to avoid problems with the  implicit
       closes  of  file descriptors by <u>exec</u> and <u>exit</u>().  This volume of POSIX.1‐2017 only intends to permit such
       behavior by specifying the <b>[EINTR]</b> error condition.

       Note that the requirement for <u>close</u>() on a socket to block for up to the current linger interval  is  not
       conditional on the O_NONBLOCK setting.

       The  standard  developers  rejected  a  proposal to add <u>closefrom</u>() to the standard. Because the standard
       permits implementations to  use  inherited  file  descriptors  as  a  means  of  providing  a  conforming
       environment  for  the child process, it is not possible to standardize an interface that closes arbitrary
       file descriptors above a certain value while still guaranteeing a conforming environment.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u> <u>2.6</u>, <u>STREAMS</u>, <u>dup</u>(), <u>exec</u>, <u>exit</u>(), <u>fattach</u>(),  <u>fclose</u>(),  <u>fdetach</u>(),  <u>fopen</u>(),  <u>fork</u>(),  <u>ioctl</u>(),
       <u>open</u>(), <u>perror</u>(), <u>unlink</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;unistd.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                         <u><a href="../man3POSIX/CLOSE.3POSIX.html">CLOSE</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>