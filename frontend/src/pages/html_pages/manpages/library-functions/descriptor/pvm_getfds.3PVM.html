<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pvm_getfds - Get file descriptors in use by PVM.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/pvm-dev">pvm-dev_3.4.6-3.2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pvm_getfds - Get file descriptors in use by PVM.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>C</b>    <b>int</b> <b>nfds</b> <b>=</b> <b>pvm_getfds(</b> <b>int</b> <b>**fds</b> <b>)</b>

       <b>Fortran</b>   <b>Not</b> <b>Available</b>

</pre><h4><b>PARAMETERS</b></h4><pre>
       fds     Returns integer array of file descriptors.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A  PVM  task  uses  sockets  to  communicate between libpvm and other tasks or the pvmd.  It is sometimes
       useful to know the file descriptor numbers of the sockets in order to wait from  input  from  either  PVM
       messages  or  an  external  source.  For example, the PVM console waits on both keyboard input and notify
       messages.  Input can be multiplexed by polling all sources, but this wastes  cpu  cycles.   Instead,  the
       select() system call can be used to wait until one or more sources of input are ready.

       If  it  completes  successfully, pvm_getfds returns the number of sockets in use, and the file descriptor
       numbers in an array (allocated and freed by libpvm).  At least one socket always  exists  (from  task  to
       pvmd),  and  its  descriptor  is  always  fds[0].   The  number  of  sockets  varies as direct routes are
       established to other tasks.

       It can be difficult to track the set of file descriptors if direct routing is enabled, because routes are
       created as messages are either sent or received.  The simplest approach is to disable direct routing.

       When select returns with a PVM file descriptor ready, a complete message may be ready to be received,  or
       instead only a fragment may be waiting.  pvm_nrecv or pvm_probe should be used test without blocking.

</pre><h4><b>RESTRICTIONS</b></h4><pre>
       pvm_getfds is only available when running PVM on a Unix or similar system.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following  program  fragment  waits  until  either keyboard input is available, or a PVM message has
       arrived.

            int *d;
            fd_set r;

            pvm_setopt(PvmRoute, PvmDontRoute);
            pvm_getfds(&amp;d);

            FD_ZERO(&amp;r);
            FD_SET(0, &amp;r);
            FD_SET(d[0], &amp;r);
            while (1) {
                 if (select(d[0] + 1, &amp;r, (fd_set*)0, (fd_set*)0,
                            (struct timeval*)0) &gt; 0) {
                      if (FD_ISSET(0, &amp;r))
                           ...    /* read keyboard input */
                      if (FD_ISSET(d[0], &amp;r) &amp;&amp; pvm_nrecv(-1, -1) &gt; 0)
                           ...    /* got a PVM message */
                 }
            }

</pre><h4><b>ERRORS</b></h4><pre>
       The following error condition can be returned by pvm_getfds:

       PvmSysErr
              pvmd not responding.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3PVM/pvm_notify.3PVM.html">pvm_notify</a>(3PVM), <a href="../man3PVM/pvm_trecv.3PVM.html">pvm_trecv</a>(3PVM)

                                                  22 Nov, 1994                                      <u><a href="../man3PVM/GETFDS.3PVM.html">GETFDS</a></u>(3PVM)
</pre>
 </div>
</div></section>
</div>
</body>
</html>