<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>io_trywrite - write to a descriptor without blocking</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libowfat-dev">libowfat-dev_0.32-5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       io_trywrite - write to a descriptor without blocking

</pre><h4><b>SYNTAX</b></h4><pre>
       <b>#include</b> <b>&lt;libowfat/io.h&gt;</b>

       int <b>io_trywrite</b>(int64 fd,const char* buf,int64 len);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       io_trywrite  tries to write <u>len</u> bytes of data from buf[0], buf[1], ..., buf[len-1] to descriptor <u>fd</u>. (The
       effects are undefined if <u>len</u> is 0 or smaller.) There are several possible results:

       •  o_trywrite returns an integer between 1 and <u>len</u>: This number of bytes was immediately written from the
          beginning of <u>buf</u>.  Note that this number can be, and often is, smaller than <u>len</u>; you must  not  assume
          that io_trywrite always succeeds in writing exactly <u>len</u> bytes.

       •  io_trywrite  returns -1, setting <u>errno</u> to EAGAIN: No bytes were written, because the descriptor is not
          ready. For example, the descriptor is writing to a full pipe that could still be read.

       •  io_trywrite returns -3, setting <u>errno</u> to something other than EAGAIN: No bytes were  written,  because
          the write attempt encountered a persistent error, such as a serious disk failure (EIO), an unreachable
          network (ENETUNREACH), or an invalid descriptor number (EBADF).

       io_trywrite  does  not  pause  waiting  for  a  descriptor  that is not ready.  If you want to pause, use
       io_waitread or io_wait.

       You can make io_trywrite faster and more efficient by making the socket non-blocking with io_nonblock().

       Once upon a time, many UNIX programs neglected to check the success of their  writes.  They  would  often
       encounter  EPIPE, and would blithely continue writing, rather than exiting with an appropriate exit code.
       The UNIX kernel developers decided to send a SIGPIPE signal, which terminates  the  process  by  default,
       along  with  returning  EPIPE.  This  papers over the problem without fixing it: the same programs ignore
       other errors such as EIO. One hopes that the programs  have  been  fixed  by  now;  kernels  nevertheless
       continue  to  generate  the  SIGPIPE  signal.  The  first  time io_trywrite or io_waitwrite is called, it
       arranges for SIGPIPE to be ignored.  (Technically, for SIGPIPE to be caught by an empty  signal  handler,
       so this doesn't affect child processes.) Do not use SIGPIPE elsewhere in the program.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/io_nonblock.3.html">io_nonblock</a>(3), <a href="../man3/io_waitread.3.html">io_waitread</a>(3), <a href="../man3/io_trywritetimeout.3.html">io_trywritetimeout</a>(3)

                                                                                                  <u><a href="../man3/io_trywrite.3.html">io_trywrite</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>