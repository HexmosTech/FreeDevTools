<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unicode::linebreak_callback_base, unicode::linebreak_callback_save_buf,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcourier-unicode-dev">libcourier-unicode-dev_2.3.2-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unicode::linebreak_callback_base, unicode::linebreak_callback_save_buf,
       unicode::linebreakc_callback_base, unicode::linebreak_iter, unicode::linebreakc_iter - unicode
       line-breaking rules

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;courier-unicode.h&gt;

       class linebreak : public unicode::linebreak_callback_base {

       public:

           using unicode::linebreak_callback_base::operator&lt;&lt;;
           using unicode::linebreak_callback_base::operator();
           int callback(int linebreak_code)
           {
               // ...
           }
       };

       char32_t c;
       std::u32string buf;

       linebreak compute_linebreak;

       compute_linebreak.set_opts(UNICODE_LB_OPT_SYBREAK);
       compute_linebreak &lt;&lt; c;

       compute_linebreak(buf);
       compute_linebreak(buf.begin(), buf.end());

       compute_linebreak.finish();

       // ...

       unicode::linebreak_callback_save_buf linebreaks;

       std::list&lt;int&gt; lb=linebreaks.lb_buf;

       class linebreakc : public unicode::linebreakc_callback_base {

       public:

           using unicode::linebreak_callback_base::operator&lt;&lt;;
           using unicode::linebreak_callback_base::operator();
           int callback(int linebreak_code, char32_t ch)
           {
               // ...
           }
       };

       // ...

       std::u32string buf;

       typedef unicode::linebreak_iter&lt;std::u32string::const_iterator&gt; iter_t;

       iter_t beg_iter(buf.begin(), buf.end()), end_iter;

       beg_iter.set_opts(UNICODE_LB_OPT_SYBREAK);

       std::vector&lt;int&gt; linebreaks;

       std::copy(beg_iter, end_iter, std::back_insert_iterator&lt;std::vector&lt;int&gt;&gt;(linebreaks));

       // ...

       typedef unicode::linebreakc_iter&lt;std::u32string::const_iterator&gt; iter_t;

       iter_t beg_iter(buf.begin(), buf.end()), end_iter;

       beg_iter.set_opts(UNICODE_LB_OPT_SYBREAK);

       std::vector&lt;std::pair&lt;int, char32_t&gt;&gt; linebreaks;

       std::copy(beg_iter, end_iter, std::back_insert_iterator&lt;std::vector&lt;int&gt;&gt;(linebreaks));

</pre><h4><b>DESCRIPTION</b></h4><pre>
       unicode::linebreak_callback_base is a C++ binding for the unicode line-breaking rule implementation
       described in <b><a href="../man3/unicode_line_break.3.html">unicode_line_break</a></b>(3).

       Subclass unicode::linebreak_callback_base and implement callback() that's virtually inherited from
       unicode::linebreak_callback_base. The callback() callback function receives the output values from the
       line-breaking algorithm, the UNICODE_LB_MANDATORY, UNICODE_LB_NONE, or the UNICODE_LB_ALLOWED value, for
       each unicode character.

       callback() should return 0. A non-zero return reports an error, that stops the line-breaking algorithm.
       See <b><a href="../man3/unicode_line_break.3.html">unicode_line_break</a></b>(3) for more information.

       The alternate unicode::linebreakc_callback_base interface uses a virtually inherited callback() that
       receives two parameters, the line-break code value, and the corresponding unicode character.

       The input unicode characters for the line-breaking algorithm are provided by the &lt;&lt; operator, one unicode
       character at a time; or by the () operator, passing either a container, or a beginning and an ending
       iterator value for an input sequence of unicode characters.  finish() indicates the end of the unicode
       character sequence.

       set_opts sets line-breaking options (see unicode_lb_set_opts() for more information).

       unicode::linebreak_callback_save_buf is a subclass that implements callback() by saving the linebreaks
       codes into a std::list.

       The linebreak_iter template implements an input iterator over ints. The template parameter is an input
       iterator over unicode chars. The constructor's parameters are a beginning and an ending iterator value
       for a sequence of char32_t. This constructs the beginning iterator value for a sequence of ints
       consisting of line-break values (UNICODE_LB_MANDATORY, UNICODE_LB_NONE, or UNICODE_LB_ALLOWED)
       corresponding to each char32_t in the underlying sequence. The default constructor creates the ending
       iterator value for the sequence.

       The iterator implements a set_opts() methods that sets the options for the line-breaking algorithm.

       The linebreakc_iter template implements a similar input iterator, with the difference that it ends up
       iterating over a std::pair of line-breaking values and the corresponding char32_t from the underlying
       input sequence.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/courier-unicode.7.html">courier-unicode</a></b>(7), <b><a href="../man3/unicode_line_break.3.html">unicode_line_break</a></b>(3).

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>Sam</b> <b>Varshavchik</b>
           Author

Courier Unicode Library                            05/18/2024                              <u>UNICODE::<a href="../man3/LINEBREAK.3.html">LINEBREAK</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>