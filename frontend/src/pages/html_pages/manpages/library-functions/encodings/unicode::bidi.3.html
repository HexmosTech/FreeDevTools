<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unicode::bidi, unicode::bidi_calc, unicode::bidi_calc_types, unicode::bidi_reorder,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcourier-unicode-dev">libcourier-unicode-dev_2.3.2-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unicode::bidi, unicode::bidi_calc, unicode::bidi_calc_types, unicode::bidi_reorder,
       unicode::bidi_cleanup, unicode::bidi_logical_order, unicode::bidi_combinings, unicode::bidi_needs_embed,
       unicode::bidi_embed, unicode::bidi_embed_paragraph_level, unicode::bidi_get_direction,
       unicode::bidi_override - unicode bi-directional algorithm

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;courier-unicode.h&gt;

       struct unicode::bidi_calc_types {
         bidi_calc_types(const std::u32string &amp; string);
         std::vector&lt;unicode_bidi_type_t&gt; types ;
         void setbnl(std::u32string &amp; string);
       }.fi

       <b>std::tuple&lt;std::vector&lt;unicode_bidi_level_t&gt;,</b> <b>struct</b> <b>unicode_bidi_direction&gt;</b> <b>unicode::bidi_calc(const</b> <b>unicode::bidi_calc_types</b> <b>&amp;</b><u>ustring</u><b>);</b>

       <b>std::tuple&lt;std::vector&lt;unicode_bidi_level_t&gt;,</b> <b>struct</b> <b>unicode_bidi_direction&gt;</b> <b>unicode::bidi_calc(const</b> <b>unicode::bidi_calc_types</b> <b>&amp;</b><u>ustring</u><b>,</b> <b>unicode_bidi_level_t</b> <u>embedding_level</u><b>);</b>

       <b>int</b> <b>unicode::bidi_reorder(std::u32string</b> <b>&amp;</b><u>string</u><b>,</b> <b>std::vector&lt;unicode_bidi_level_t&gt;</b> <b>&amp;</b><u>embedding_level</u><b>,</b> <b>const</b> <b>std::function&lt;void</b> <b>(size_t,</b> <b>size_t)&gt;</b> <b>&amp;</b><u>reorder_callback</u><b>=[](size_t,</b> <b>size_t){},</b> <b>size_t</b> <u>starting_pos</u><b>=0,</b> <b>size_t</b> <u>n</u><b>=(size_t)-1);</b>

       <b>void</b> <b>unicode::bidi_reorder(std::vector&lt;unicode_bidi_level_t&gt;</b> <b>&amp;</b><u>embedding_level</u><b>,</b> <b>const</b> <b>std::function&lt;void</b> <b>(size_t,</b> <b>size_t)&gt;</b> <b>&amp;</b><u>reorder_callback</u><b>=[](size_t,</b> <b>size_t){},</b> <b>size_t</b> <u>starting_pos</u><b>=0,</b> <b>size_t</b> <u>n</u><b>=(size_t)-1);</b>

       <b>void</b> <b>unicode::bidi_cleanup(std::u32string</b> <b>&amp;</b><u>string</u><b>,</b> <b>const</b> <b>std::function&lt;void</b> <b>(size_t)&gt;</b> <b>&amp;</b><u>removed_callback</u><b>=[](size_t){},</b> <b>int</b> <u>cleanup_options</u><b>);</b>

       <b>int</b> <b>unicode::bidi_cleanup(std::u32string</b> <b>&amp;</b><u>string</u><b>,</b> <b>std::vector</b> <b>&lt;unicode_bidi_level_t&gt;</b> <b>&amp;</b><u>levels</u><b>,</b> <b>const</b> <b>std::function&lt;void</b> <b>(size_t)&gt;</b> <b>&amp;</b><u>removed_callback</u><b>=[](size_t){},</b> <b>int</b> <u>cleanup_options</u><b>=0);</b>

       <b>int</b> <b>unicode::bidi_cleanup(std::u32string</b> <b>&amp;</b><u>string</u><b>,</b> <b>std::vector</b> <b>&lt;unicode_bidi_level_t&gt;</b> <b>&amp;</b><u>levels</u><b>,</b> <b>const</b> <b>std::function&lt;void</b> <b>(size_t)&gt;</b> <b>&amp;</b><u>removed_callback</u><b>,</b> <b>int</b> <u>cleanup_options</u><b>,</b> <b>size_t</b> <u>starting_pos</u><b>,</b> <b>size_t</b> <u>n</u><b>);</b>

       <b>int</b> <b>unicode::bidi_logical_order(std::u32string</b> <b>&amp;</b><u>string</u><b>,</b> <b>std::vector</b> <b>&lt;unicode_bidi_level_t&gt;</b> <b>&amp;</b><u>levels</u><b>,</b> <b>unicode_bidi_level_t</b> <u>paragraph_embedding</u><b>,</b> <b>const</b> <b>std::function&lt;void</b> <b>(size_t,</b> <b>size_t)&gt;</b> <b>&amp;</b><u>reorder_callback</u><b>=[](size_t,</b> <b>size_t){},</b> <b>size_t</b> <u>starting_pos</u><b>=0,</b> <b>size_t</b> <u>n</u><b>=(size_t)-1);</b>

       <b>void</b> <b>unicode::bidi_combinings(const</b> <b>std::u32string</b> <b>&amp;</b><u>string</u><b>,</b> <b>const</b> <b>std::vector</b> <b>&lt;unicode_bidi_level_t&gt;</b> <b>&amp;</b><u>levels</u><b>,</b> <b>const</b> <b>std::function</b> <b>&lt;void</b> <b>(unicode_bidi_level_t</b> <b>level,</b> <b>size_t</b> <b>level_start,</b> <b>size_t</b> <b>n_chars,</b> <b>size_t</b> <b>comb_start,</b> <b>size_t</b> <b>n_comb_chars)&gt;</b> <b>&amp;</b><u>callback</u><b>);</b>

       <b>void</b> <b>unicode::bidi_combinings(const</b> <b>std::u32string</b> <b>&amp;</b><u>string</u><b>,</b> <b>const</b> <b>std::function</b> <b>&lt;void</b> <b>(unicode_bidi_level_t</b> <b>level,</b> <b>size_t</b> <b>level_start,</b> <b>size_t</b> <b>n_chars,</b> <b>size_t</b> <b>comb_start,</b> <b>size_t</b> <b>n_comb_chars)&gt;</b> <b>&amp;</b><u>callback</u><b>);</b>

       <b>void</b> <b>unicode::bidi_logical_order(std::vector</b> <b>&lt;unicode_bidi_level_t&gt;</b> <b>&amp;</b><u>levels</u><b>,</b> <b>unicode_bidi_level_t</b> <u>paragraph_embedding</u><b>,</b> <b>const</b> <b>std::function&lt;void</b> <b>(size_t,</b> <b>size_t)&gt;</b> <b>&amp;</b><u>reorder_callback</u><b>,</b> <b>size_t</b> <u>starting_pos</u><b>=0,</b> <b>size_t</b> <u>n</u><b>=(size_t)-1);</b>

       <b>bool</b> <b>unicode::bidi_needs_embed(const</b> <b>std::u32string</b> <b>&amp;</b><u>string</u><b>,</b> <b>const</b> <b>std::vector</b> <b>&lt;unicode_bidi_level_t&gt;</b> <b>&amp;</b><u>levels</u><b>,</b> <b>const</b> <b>unicode_bidi_level_t</b> <b>(</b><u>paragraph_embedding</u><b>=NULL,</b> <b>size_t</b> <u>starting_pos</u><b>=0,</b> <b>size_t</b> <u>n</u><b>=(size_t)-1);</b>

       <b>int</b> <b>unicode::bidi_embed(const</b> <b>std::u32string</b> <b>&amp;</b><u>string</u><b>,</b> <b>const</b> <b>std::vector</b> <b>&lt;unicode_bidi_level_t&gt;</b> <b>&amp;</b><u>levels</u><b>,</b> <b>unicode_bidi_level_t</b> <u>paragraph_embedding</u><b>,</b> <b>const</b> <b>std::function&lt;void</b> <b>(const</b> <b>char32_t</b> <b>*,</b> <b>size_t,</b> <b>bool)&gt;</b> <b>&amp;</b><u>callback</u><b>);</b>

       <b>std::u32string</b> <b>unicode::bidi_embed(const</b> <b>std::u32string</b> <b>&amp;</b><u>string</u><b>,</b> <b>const</b> <b>std::vector</b> <b>&lt;unicode_bidi_level_t&gt;</b> <b>&amp;</b><u>levels</u><b>,</b> <b>unicode_bidi_level_t</b> <u>paragraph_embedding</u><b>);</b>

       <b>char32_t</b> <b>unicode_bidi_embed_paragraph_level(const</b> <b>std::u32string</b> <b>&amp;</b><u>string</u><b>,</b> <b>unicode_bidi_level_t</b> <u>paragraph_embedding</u><b>);</b>

       <b>unicode_bidi_direction</b> <b>bidi_get_direction(const</b> <b>std::u32string</b> <b>&amp;</b><u>string</u><b>,</b> <b>size_t</b> <u>starting_pos</u><b>=0,</b> <b>size_t</b> <u>n</u><b>=(size_t)-1);</b>

       <b>std::u32string</b> <b>bidi_override(const</b> <b>std::u32string</b> <b>&amp;</b><u>string</u><b>,</b> <b>unicode_bidi_level_t</b> <u>direction</u><b>,</b> <b>int</b> <u>cleanup_options</u><b>=0);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These functions implement the C++ interface for the <b>Unicode</b> <b>Bi-Directional</b> <b>algorithm</b>[1]. See the
       description of the underlying <b><a href="../man3/unicode_bidi.3.html">unicode_bidi</a></b>(3) C library API for more information. C++ specific notes:

       •   <b>unicode::bidi_calc</b> returns the directional embedding value buffer and the calculated paragraph
           embedding level. Its <u>ustring</u> is implicitly converted from a std::u32string:

               std::u32string text;

               auto [levels, direction]=unicode::bidi_calc(text);

           Alternatively a unicode::bidi_calc_types objects gets constructed from the same std::u32string and
           then passed directly to <b>unicode::bidi_calc</b>:

               std::u32string text;

               unicode::bidi_calc_types types{text};

               types.setbnl(text); // Optional

               // types.types is a std::vector of enum_bidi_types_t values

               auto [levels, direction]=unicode::bidi_calc(types);

           This provides the means to access the intermediate enum_bidi_types_t values that get calculated from
           the Unicode text string.

               <b>Note</b>
               In all cases the std::u32string cannot be a temporary object, and it must remain in scope until
               <b>unicode::bidi_calc</b>() returns.
           The optional setbnl() method uses <b><a href="../man3/unicode_bidi_setbnl.3.html">unicode_bidi_setbnl</a></b>(3) to replace paragraph separators with newline
           characters, in the unicode string. It requires the same unicode string that was passed to the
           constructor as a parameter (because the constructor takes a constant reference, but this method
           modifies the string.

       •   Several C functions provide a “dry-run” mode by passing a NULL pointer. The C++ API provides separate
           overloads, with and without the nullable parameter.

       •   Several C functions accept a nullable function pointer, with the NULL function pointer specifying no
           callback. The C++ functions have a std::function parameter with a default do-nothing closure.

       •   Several C functions accept two parameters, a Unicode character pointer and the embedding level
           buffer, and a single parameter that specifies the size of both. The equivalent C++ function takes two
           discrete parameters, a std::u32string and a std::vector and returns an int; a negative value if their
           sizes differ, and 0 if their sizes match, and the requested function completes. The
           <b>unicode::bidi_embed</b> overload that returns a std::u32string returns an empty string in case of a
           mismatch.

       •   <b>unicode::bidi_reorder</b> reorders the entire <u>string</u> and its <u>embedding_level</u>s by default. The optional
           <u>starting_pos</u> and <u>n</u> parameters limit the reordering to the indicated subset of the original string
           (specified as the starting position offset index, and the number of characters).

       •   <b>unicode::bidi_reorder</b>, <b>unicode::bidi_cleanup</b>, <b>unicode::bidi_logical_order</b>, <b>unicode::bidi_needs_embed</b>
           and <b>unicode::bidi_get_direction</b> take two optional parameters (defaulted values or overloaded)
           specifying an optional starting position and number of characters that define a subset of the
           original string that gets reordered, cleaned up, or has its direction determined.

           This <b>unicode::bidi_cleanup</b> does not trim off the passed in string and embedding level buffer, since
           it affects only a subset of the string. The number of times the removed character callback gets
           invoked indicates how much the substring should be trimmed off.

       •   <b>unicode::bidi_override</b> modifies the passed-in <u>string</u> as follows:

           •   <b>unicode::bidi_cleanup</b>() is applied with the specified, or defaulted, <u>cleanup_options</u>

           •   Either the LRO or an RLO override marker gets prepended to the Unicode string, forcing the entire
               string to be interpreted in a single rendering direction, when processed by the Unicode
               bi-directional algorithm.

           <b>unicode::bidi_override</b> makes it possible to use a Unicode-aware application or algorithm in a context
           that only works with text that's always displayed in a fixed direction, allowing graceful handling of
           input containing bi-directional text.

   <b>unicode::literals</b> <b>namespace</b>
           using namespace unicode::literals;

           std::u32string foo(std::u32string bar)
           {
                return bar + LRO;
           }

       This namespace contains the following constexpr definitions:

       •   char32_t arrays with literal Unicode character strings containing Unicode directional, isolate, and
           override markers, like LRO, RLO and others.

       •   CLEANUP_EXTRA, CLEANUP_BNL, and CLEANUP_CANONICAL options for <b>unicode::bidi_cleanup</b>().

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/courier-unicode.7.html">courier-unicode</a></b>(7), <b><a href="../man3/unicode_bidi.3.html">unicode_bidi</a></b>(3).

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>Sam</b> <b>Varshavchik</b>
           Author

</pre><h4><b>NOTES</b></h4><pre>
        1. Unicode Bi-Directional algorithm
           https://www.unicode.org/reports/tr9/tr9-48.html

Courier Unicode Library                            05/18/2024                                   <u>UNICODE::<a href="../man3/BIDI.3.html">BIDI</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>