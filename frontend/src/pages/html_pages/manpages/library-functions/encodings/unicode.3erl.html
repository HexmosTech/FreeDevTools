<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unicode - Functions for converting Unicode characters.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unicode - Functions for converting Unicode characters.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  contains  functions for converting between different character representations. It converts
       between ISO Latin-1 characters and Unicode characters, but it can also convert between different  Unicode
       encodings (like UTF-8, UTF-16, and UTF-32).

       The  default  Unicode encoding in Erlang is in binaries UTF-8, which is also the format in which built-in
       functions and libraries in OTP expect to find binary Unicode data. In lists, Unicode data is  encoded  as
       integers,  each  integer  representing one character and encoded simply as the Unicode code point for the
       character.

       Other Unicode encodings than integers representing code points or UTF-8 in binaries are  referred  to  as
       "external encodings". The ISO Latin-1 encoding is in binaries and lists referred to as latin1-encoding.

       It  is  recommended to only use external encodings for communication with external entities where this is
       required. When working inside the Erlang/OTP environment, it is recommended to  keep  binaries  in  UTF-8
       when  representing  Unicode characters. ISO Latin-1 encoding is supported both for backward compatibility
       and for communication with external entities not supporting Unicode character sets.

       Programs should always operate on a normalized form and compare canonical-equivalent  Unicode  characters
       as  equal.  All  characters  should thus be normalized to one form once on the system borders. One of the
       following  functions  can  convert  characters  to  their  normalized   forms   <u>characters_to_nfc_list/1</u>,
       <u>characters_to_nfc_binary/1</u>,  <u>characters_to_nfd_list/1</u>  or  <u>characters_to_nfd_binary/1</u>.  For  general text
       <u>characters_to_nfc_list/1</u> or <u>characters_to_nfc_binary/1</u> is preferred,  and  for  identifiers  one  of  the
       compatibility  normalization  functions,  such  as  <u>characters_to_nfkc_list/1</u>,  is preferred for security
       reasons. The normalization functions where introduced in OTP 20. Additional information on  normalization
       can be found in the Unicode FAQ.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>encoding()</b> =
           latin1 | unicode | utf8 | utf16 |
           {utf16, endian()} |
           utf32 |
           {utf32, endian()}

       <b>endian()</b> = big | little

       <b>unicode_binary()</b> = binary()

              A <u>binary()</u> with characters encoded in the UTF-8 coding standard.

       <b>chardata()</b> = charlist() | unicode_binary()

       <b>charlist()</b> =
           maybe_improper_list(char() | unicode_binary() | charlist(),
                               unicode_binary() | [])

       <b>external_unicode_binary()</b> = binary()

              A  <u>binary()</u>  with characters coded in a user-specified Unicode encoding other than UTF-8 (that is,
              UTF-16 or UTF-32).

       <b>external_chardata()</b> =
           external_charlist() | external_unicode_binary()

       <b>external_charlist()</b> =
           maybe_improper_list(char() |
                               external_unicode_binary() |
                               external_charlist(),
                               external_unicode_binary() | [])

       <b>latin1_binary()</b> = binary()

              A <u>binary()</u> with characters coded in ISO Latin-1.

       <b>latin1_char()</b> = byte()

              An <u>integer()</u> representing a valid ISO Latin-1 character (0-255).

       <b>latin1_chardata()</b> = latin1_charlist() | latin1_binary()

              Same as <u>iodata()</u>.

       <b>latin1_charlist()</b> =
           maybe_improper_list(latin1_char() |
                               latin1_binary() |
                               latin1_charlist(),
                               latin1_binary() | [])

              Same as <u>iolist()</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>bom_to_encoding(Bin)</b> <b>-&gt;</b> <b>{Encoding,</b> <b>Length}</b>

              Types:

                 Bin = binary()
                    A <u>binary()</u> such that <u>byte_size(Bin)</u> <u>&gt;=</u> <u>4</u>.
                 Encoding =
                     latin1 | utf8 | {utf16, endian()} | {utf32, endian()}
                 Length = integer() &gt;= 0
                 <b>endian()</b> = big | little

              Checks for a UTF Byte Order Mark (BOM) in the beginning of a binary. If the  supplied  binary  <u>Bin</u>
              begins  with  a  valid  BOM for either UTF-8, UTF-16, or UTF-32, the function returns the encoding
              identified along with the BOM length in bytes.

              If no BOM is found, the function returns <u>{latin1,0}</u>.

       <b>characters_to_binary(Data)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Data = latin1_chardata() | chardata() | external_chardata()
                 Result =
                     binary() |
                     {error, binary(), RestData} |
                     {incomplete, binary(), binary()}
                 RestData = latin1_chardata() | chardata() | external_chardata()

              Same as <u>characters_to_binary(Data,</u> <u>unicode,</u> <u>unicode)</u>.

       <b>characters_to_binary(Data,</b> <b>InEncoding)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Data = latin1_chardata() | chardata() | external_chardata()
                 InEncoding = encoding()
                 Result =
                     binary() |
                     {error, binary(), RestData} |
                     {incomplete, binary(), binary()}
                 RestData = latin1_chardata() | chardata() | external_chardata()

              Same as <u>characters_to_binary(Data,</u> <u>InEncoding,</u> <u>unicode)</u>.

       <b>characters_to_binary(Data,</b> <b>InEncoding,</b> <b>OutEncoding)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Data = latin1_chardata() | chardata() | external_chardata()
                 InEncoding = OutEncoding = encoding()
                 Result =
                     binary() |
                     {error, binary(), RestData} |
                     {incomplete, binary(), binary()}
                 RestData = latin1_chardata() | chardata() | external_chardata()

              Behaves as <u>characters_to_list/2</u>, but produces a binary instead of a Unicode list.

              <u>InEncoding</u> defines how input is to be interpreted if binaries are present in <u>Data</u>

              <u>OutEncoding</u> defines in what format output is to be generated.

              Options:

                <u>unicode</u>:
                  An alias for <u>utf8</u>, as this is the preferred encoding for Unicode characters in binaries.

                <u>utf16</u>:
                  An alias for <u>{utf16,big}</u>.

                <u>utf32</u>:
                  An alias for <u>{utf32,big}</u>.

              The atoms <u>big</u> and <u>little</u> denote big- or little-endian encoding.

              Errors and exceptions occur as in <u>characters_to_list/2</u>, but the second element in tuple  <u>error</u>  or
              <u>incomplete</u> is a <u>binary()</u> and not a <u>list()</u>.

       <b>characters_to_list(Data)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Data = latin1_chardata() | chardata() | external_chardata()
                 Result =
                     list() |
                     {error, list(), RestData} |
                     {incomplete, list(), binary()}
                 RestData = latin1_chardata() | chardata() | external_chardata()

              Same as <u>characters_to_list(Data,</u> <u>unicode)</u>.

       <b>characters_to_list(Data,</b> <b>InEncoding)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Data = latin1_chardata() | chardata() | external_chardata()
                 InEncoding = encoding()
                 Result =
                     list() |
                     {error, list(), RestData} |
                     {incomplete, list(), binary()}
                 RestData = latin1_chardata() | chardata() | external_chardata()

              Converts  a  possibly  deep  list  of  integers  and binaries into a list of integers representing
              Unicode characters. The binaries in the input can have characters encoded as one of the following:

                * ISO Latin-1 (0-255, one character  per  byte).  Here,  case  parameter  <u>InEncoding</u>  is  to  be
                  specified as <u>latin1</u>.

                * One of the UTF-encodings, which is specified as parameter <u>InEncoding</u>.

              Note  that  integers  in the list always represent code points regardless of <u>InEncoding</u> passed. If
              <u>InEncoding</u> <u>latin1</u> is passed, only code points &lt; 256 are allowed; otherwise, all valid unicode code
              points are allowed.

              If <u>InEncoding</u> is <u>latin1</u>, parameter <u>Data</u>  corresponds  to  the  <u>iodata()</u>  type,  but  for  <u>unicode</u>,
              parameter <u>Data</u> can contain integers &gt; 255 (Unicode characters beyond the ISO Latin-1 range), which
              makes it invalid as <u>iodata()</u>.

              The  purpose  of  the function is mainly to convert combinations of Unicode characters into a pure
              Unicode string in list representation for further processing. For writing the data to an  external
              entity, the reverse function <u>characters_to_binary/3</u> comes in handy.

              Option  <u>unicode</u>  is an alias for <u>utf8</u>, as this is the preferred encoding for Unicode characters in
              binaries. <u>utf16</u> is an alias for <u>{utf16,big}</u> and <u>utf32</u> is an alias for <u>{utf32,big}</u>. The  atoms  <u>big</u>
              and <u>little</u> denote big- or little-endian encoding.

              If  the  data cannot be converted, either because of illegal Unicode/ISO Latin-1 characters in the
              list, or because of invalid UTF encoding in any binaries, an error tuple is  returned.  The  error
              tuple  contains  the  tag <u>error</u>, a list representing the characters that could be converted before
              the error occurred and a representation of  the  characters  including  and  after  the  offending
              integer/bytes.  The  last part is mostly for debugging, as it still constitutes a possibly deep or
              mixed list, or both, not necessarily of the same depth as the original data. The error occurs when
              traversing the list and whatever is left to decode is returned "as is".

              However, if the input <u>Data</u> is a pure binary, the third part of the error tuple is guaranteed to be
              a binary as well.

              Errors occur for the following reasons:

                * Integers out of range.

                  If <u>InEncoding</u> is <u>latin1</u>, an error occurs whenever an integer &gt; 255 is found in the lists.

                  If <u>InEncoding</u> is of a Unicode type, an error occurs whenever either of the following is found:

                  * An integer &gt; 16#10FFFF (the maximum Unicode character)

                  * An integer in the range 16#D800 to 16#DFFF (invalid  range  reserved  for  UTF-16  surrogate
                    pairs)

                * Incorrect UTF encoding.

                  If  <u>InEncoding</u>  is  one  of  the  UTF  types,  the bytes in any binaries must be valid in that
                  encoding.

                  Errors can occur for various reasons, including the following:

                  * "Pure" decoding errors (like the upper bits of the bytes being wrong).

                  * The bytes are decoded to a too large number.

                  * The bytes are decoded to a code point in the invalid Unicode range.

                  * Encoding is "overlong", meaning that a number should have been encoded in fewer bytes.

                  The case of a truncated UTF is handled specially, see the paragraph about incomplete  binaries
                  below.

                  If  <u>InEncoding</u>  is  <u>latin1</u>,  binaries are always valid as long as they contain whole bytes, as
                  each byte falls into the valid ISO Latin-1 range.

              A special type of error is when no actual invalid integers or bytes  are  found,  but  a  trailing
              <u>binary()</u> consists of too few bytes to decode the last character. This error can occur if bytes are
              read from a file in chunks or if binaries in other ways are split on non-UTF character boundaries.
              An  <u>incomplete</u> tuple is then returned instead of the <u>error</u> tuple. It consists of the same parts as
              the <u>error</u> tuple, but the tag is <u>incomplete</u> instead  of  <u>error</u>  and  the  last  element  is  always
              guaranteed to be a binary consisting of the first part of a (so far) valid UTF character.

              If  one UTF character is split over two consecutive binaries in the <u>Data</u>, the conversion succeeds.
              This means that a character can be decoded from a range of binaries as long as the whole range  is
              specified as input without errors occurring.

              <u>Example:</u>

              decode_data(Data) -&gt;
                 case unicode:characters_to_list(Data,unicode) of
                    {incomplete,Encoded, Rest} -&gt;
                          More = get_some_more_data(),
                          Encoded ++ decode_data([Rest, More]);
                    {error,Encoded,Rest} -&gt;
                          handle_error(Encoded,Rest);
                    List -&gt;
                          List
                 end.

              However,  bit  strings  that are not whole bytes are not allowed, so a UTF character must be split
              along 8-bit boundaries to ever be decoded.

              A <u>badarg</u> exception is thrown for the following cases:

                * Any parameters are of the wrong type.

                * The list structure is invalid (a number as tail).

                * The binaries do not contain whole bytes (bit strings).

       <b>characters_to_nfc_list(CD</b> <b>::</b> <b>chardata())</b> <b>-&gt;</b>
                                 [char()] | {error, [char()], chardata()}

              Converts a possibly deep list of characters and binaries  into  a  Normalized  Form  of  canonical
              equivalent Composed characters according to the Unicode standard.

              Any binaries in the input must be encoded with utf8 encoding.

              The result is a list of characters.

              3&gt; unicode:characters_to_nfc_list([&lt;&lt;"abc..a"&gt;&gt;,[778],$a,[776],$o,[776]]).
              "abc..åäö"

       <b>characters_to_nfc_binary(CD</b> <b>::</b> <b>chardata())</b> <b>-&gt;</b>
                                   unicode_binary() |
                                   {error, unicode_binary(), chardata()}

              Converts  a  possibly  deep  list  of  characters and binaries into a Normalized Form of canonical
              equivalent Composed characters according to the Unicode standard.

              Any binaries in the input must be encoded with utf8 encoding.

              The result is an utf8 encoded binary.

              4&gt; unicode:characters_to_nfc_binary([&lt;&lt;"abc..a"&gt;&gt;,[778],$a,[776],$o,[776]]).
              &lt;&lt;"abc..åäö"/utf8&gt;&gt;

       <b>characters_to_nfd_list(CD</b> <b>::</b> <b>chardata())</b> <b>-&gt;</b>
                                 [char()] | {error, [char()], chardata()}

              Converts a possibly deep list of characters and binaries  into  a  Normalized  Form  of  canonical
              equivalent Decomposed characters according to the Unicode standard.

              Any binaries in the input must be encoded with utf8 encoding.

              The result is a list of characters.

              1&gt; unicode:characters_to_nfd_list("abc..åäö").
              [97,98,99,46,46,97,778,97,776,111,776]

       <b>characters_to_nfd_binary(CD</b> <b>::</b> <b>chardata())</b> <b>-&gt;</b>
                                   unicode_binary() |
                                   {error, unicode_binary(), chardata()}

              Converts  a  possibly  deep  list  of  characters and binaries into a Normalized Form of canonical
              equivalent Decomposed characters according to the Unicode standard.

              Any binaries in the input must be encoded with utf8 encoding.

              The result is an utf8 encoded binary.

              2&gt; unicode:characters_to_nfd_binary("abc..åäö").
              &lt;&lt;97,98,99,46,46,97,204,138,97,204,136,111,204,136&gt;&gt;

       <b>characters_to_nfkc_list(CD</b> <b>::</b> <b>chardata())</b> <b>-&gt;</b>
                                  [char()] |
                                  {error, [char()], chardata()}

              Converts a possibly deep list of characters and binaries into  a  Normalized  Form  of  compatibly
              equivalent Composed characters according to the Unicode standard.

              Any binaries in the input must be encoded with utf8 encoding.

              The result is a list of characters.

              3&gt; unicode:characters_to_nfkc_list([&lt;&lt;"abc..a"&gt;&gt;,[778],$a,[776],$o,[776],[65299,65298]]).
              "abc..åäö32"

       <b>characters_to_nfkc_binary(CD</b> <b>::</b> <b>chardata())</b> <b>-&gt;</b>
                                    unicode_binary() |
                                    {error, unicode_binary(), chardata()}

              Converts  a  possibly  deep  list  of characters and binaries into a Normalized Form of compatibly
              equivalent Composed characters according to the Unicode standard.

              Any binaries in the input must be encoded with utf8 encoding.

              The result is an utf8 encoded binary.

              4&gt; unicode:characters_to_nfkc_binary([&lt;&lt;"abc..a"&gt;&gt;,[778],$a,[776],$o,[776],[65299,65298]]).
              &lt;&lt;"abc..åäö32"/utf8&gt;&gt;

       <b>characters_to_nfkd_list(CD</b> <b>::</b> <b>chardata())</b> <b>-&gt;</b>
                                  [char()] |
                                  {error, [char()], chardata()}

              Converts a possibly deep list of characters and binaries into  a  Normalized  Form  of  compatibly
              equivalent Decomposed characters according to the Unicode standard.

              Any binaries in the input must be encoded with utf8 encoding.

              The result is a list of characters.

              1&gt; unicode:characters_to_nfkd_list(["abc..åäö",[65299,65298]]).
              [97,98,99,46,46,97,778,97,776,111,776,51,50]

       <b>characters_to_nfkd_binary(CD</b> <b>::</b> <b>chardata())</b> <b>-&gt;</b>
                                    unicode_binary() |
                                    {error, unicode_binary(), chardata()}

              Converts  a  possibly  deep  list  of characters and binaries into a Normalized Form of compatibly
              equivalent Decomposed characters according to the Unicode standard.

              Any binaries in the input must be encoded with utf8 encoding.

              The result is an utf8 encoded binary.

              2&gt; unicode:characters_to_nfkd_binary(["abc..åäö",[65299,65298]]).
              &lt;&lt;97,98,99,46,46,97,204,138,97,204,136,111,204,136,51,50&gt;&gt;

       <b>encoding_to_bom(InEncoding)</b> <b>-&gt;</b> <b>Bin</b>

              Types:

                 Bin = binary()
                    A <u>binary()</u> such that <u>byte_size(Bin)</u> <u>&gt;=</u> <u>4</u>.
                 InEncoding = encoding()

              Creates a UTF Byte Order Mark (BOM) as a binary from the  supplied  <u>InEncoding</u>.  The  BOM  is,  if
              supported at all, expected to be placed first in UTF encoded files or messages.

              The function returns <u>&lt;&lt;&gt;&gt;</u> for <u>latin1</u> encoding, as there is no BOM for ISO Latin-1.

              Notice  that  the  BOM for UTF-8 is seldom used, and it is really not a <u>byte</u> <u>order</u> mark. There are
              obviously no byte order issues with UTF-8, so  the  BOM  is  only  there  to  differentiate  UTF-8
              encoding from other UTF formats.

Ericsson AB                                        stdlib 3.17                                     <u><a href="../man3erl/unicode.3erl.html">unicode</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>