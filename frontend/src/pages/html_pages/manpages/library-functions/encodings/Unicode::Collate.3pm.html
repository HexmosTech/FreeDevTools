<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unicode::Collate - Unicode Collation Algorithm</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libunicode-collate-perl">libunicode-collate-perl_1.31-1build6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Unicode::Collate - Unicode Collation Algorithm

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Unicode::Collate;

         #construct
         $Collator = Unicode::Collate-&gt;new(%tailoring);

         #sort
         @sorted = $Collator-&gt;sort(@not_sorted);

         #compare
         $result = $Collator-&gt;cmp($a, $b); # returns 1, 0, or -1.

       <b>Note:</b> Strings in @not_sorted, $a and $b are interpreted according to Perl's Unicode support. See
       perlunicode, perluniintro, perlunitut, perlunifaq, utf8.  Otherwise you can use "preprocess" or should
       decode them before.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is an implementation of Unicode Technical Standard #10 (a.k.a. UTS #10) - Unicode Collation
       Algorithm (a.k.a. UCA).

   <b>Constructor</b> <b>and</b> <b>Tailoring</b>
       The "new" method returns a collator object. If <b>new()</b> is called with no parameters, the collator should do
       the default collation.

          $Collator = Unicode::Collate-&gt;new(
             UCA_Version =&gt; $UCA_Version,
             alternate =&gt; $alternate, # alias for 'variable'
             backwards =&gt; $levelNumber, # or \@levelNumbers
             entry =&gt; $element,
             hangul_terminator =&gt; $term_primary_weight,
             highestFFFF =&gt; $bool,
             identical =&gt; $bool,
             ignoreName =&gt; qr/$ignoreName/,
             ignoreChar =&gt; qr/$ignoreChar/,
             ignore_level2 =&gt; $bool,
             katakana_before_hiragana =&gt; $bool,
             level =&gt; $collationLevel,
             long_contraction =&gt; $bool,
             minimalFFFE =&gt; $bool,
             normalization  =&gt; $normalization_form,
             overrideCJK =&gt; \&amp;overrideCJK,
             overrideHangul =&gt; \&amp;overrideHangul,
             preprocess =&gt; \&amp;preprocess,
             rearrange =&gt; \@charList,
             rewrite =&gt; \&amp;rewrite,
             suppress =&gt; \@charList,
             table =&gt; $filename,
             undefName =&gt; qr/$undefName/,
             undefChar =&gt; qr/$undefChar/,
             upper_before_lower =&gt; $bool,
             variable =&gt; $variable,
          );

       UCA_Version
           If  the revision (previously "tracking version") number of UCA is given, behavior of that revision is
           emulated on collating.  If omitted, the return value of UCA_Version() is used.

           The following revisions are supported.  The default is 43.

                UCA       Unicode Standard         DUCET (@version)
              -------------------------------------------------------
                 8              3.1                3.0.1 (3.0.1d9)
                 9     3.1 with Corrigendum 3      3.1.1
                11             4.0.0
                14             4.1.0
                16             5.0.0
                18             5.1.0
                20             5.2.0
                22             6.0.0
                24             6.1.0
                26             6.2.0
                28             6.3.0
                30             7.0.0
                32             8.0.0
                34             9.0.0
                36            10.0.0
                38            11.0.0
                40            12.0.0
                41            12.1.0
                43            13.0.0

           * See below for "long_contraction" with "UCA_Version" 22 and 24.

           * Noncharacters (e.g. U+FFFF) are not ignored, and can be overridden since "UCA_Version" 22.

           * Out-of-range codepoints (greater than U+10FFFF) are  not  ignored,  and  can  be  overridden  since
           "UCA_Version" 22.

           *  Fully ignorable characters were ignored, and would not interrupt contractions with "UCA_Version" 9
           and 11.

           * Treatment of ignorables after variables and some behaviors were changed at "UCA_Version" 9.

           * Characters regarded as CJK unified ideographs (cf. "overrideCJK") depend on "UCA_Version".

           * Many hangul jamo are assigned at "UCA_Version" 20, that will affect "hangul_terminator".

       alternate
           -- see 3.2.2 Alternate Weighting, version 8 of UTS #10

           For backward compatibility, "alternate" (old name) can be used as an alias for "variable".

       backwards
           -- see 3.4 Backward Accents, UTS #10.

                backwards =&gt; $levelNumber or \@levelNumbers

           Weights in reverse order; ex. level 2 (diacritic ordering) in French.  If omitted (or $levelNumber is
           "undef" or "\@levelNumbers" is "[]"), forwards at all the levels.

       entry
           -- see 5 Tailoring; 9.1 Allkeys File Format, UTS #10.

           If the same character (or a sequence of characters) exists in the  collation  element  table  through
           "table",  mapping  to collation elements is overridden.  If it does not exist, the mapping is defined
           additionally.

               entry =&gt; &lt;&lt;'ENTRY', # for DUCET v4.0.0 (allkeys-4.0.0.txt)
           0063 0068 ; [.0E6A.0020.0002.0063] # ch
           0043 0068 ; [.0E6A.0020.0007.0043] # Ch
           0043 0048 ; [.0E6A.0020.0008.0043] # CH
           006C 006C ; [.0F4C.0020.0002.006C] # ll
           004C 006C ; [.0F4C.0020.0007.004C] # Ll
           004C 004C ; [.0F4C.0020.0008.004C] # LL
           00F1      ; [.0F7B.0020.0002.00F1] # n-tilde
           006E 0303 ; [.0F7B.0020.0002.00F1] # n-tilde
           00D1      ; [.0F7B.0020.0008.00D1] # N-tilde
           004E 0303 ; [.0F7B.0020.0008.00D1] # N-tilde
           ENTRY

               entry =&gt; &lt;&lt;'ENTRY', # for DUCET v4.0.0 (allkeys-4.0.0.txt)
           00E6 ; [.0E33.0020.0002.00E6][.0E8B.0020.0002.00E6] # ae ligature as &lt;a&gt;&lt;e&gt;
           00C6 ; [.0E33.0020.0008.00C6][.0E8B.0020.0008.00C6] # AE ligature as &lt;A&gt;&lt;E&gt;
           ENTRY

           <b>NOTE:</b> The code point in the UCA file format (before ';') <b>must</b> be a Unicode  code  point  (defined  as
           hexadecimal),  but not a native code point.  So 0063 must always denote "U+0063", but not a character
           of "\x63".

           Weighting may vary depending on collation element table.  So ensure the weights  defined  in  "entry"
           will be consistent with those in the collation element table loaded via "table".

           In  DUCET  v4.0.0, primary weight of "C" is 0E60 and that of "D" is "0E6D". So setting primary weight
           of "CH" to "0E6A" (as a value between 0E60 and "0E6D") makes ordering as  "C  &lt;  CH  &lt;  D".   Exactly
           speaking  DUCET  already  has  some characters between "C" and "D": "small capital C" ("U+1D04") with
           primary weight 0E64, "c-hook/C-hook" ("U+0188/U+0187") with 0E65, and "c-curl" ("U+0255") with  0E69.
           Then primary weight "0E6A" for "CH" makes "CH" ordered between "c-curl" and "D".

       hangul_terminator
           -- see 7.1.4 Trailing Weights, UTS #10.

           If  a true value is given (non-zero but should be positive), it will be added as a terminator primary
           weight to the end of every standard Hangul syllable. Secondary and any higher weights for  terminator
           are  set  to  zero.   If  the  value is false or "hangul_terminator" key does not exist, insertion of
           terminator weights will not be performed.

           Boundaries of Hangul syllables are determined according to conjoining Jamo behavior  in  <u>the</u>  <u>Unicode</u>
           <u>Standard</u> and <u>HangulSyllableType.txt</u>.

           <b>Implementation</b>  <b>Note:</b>  (1) For expansion mapping (Unicode character mapped to a sequence of collation
           elements), a terminator will not be  added  between  collation  elements,  even  if  Hangul  syllable
           boundary  exists  there.   Addition  of  terminator  is  restricted  to the next position to the last
           collation element.

           (2) Non-conjoining Hangul letters (Compatibility Jamo, halfwidth Jamo, and enclosed letters) are  not
           automatically  terminated  with  a  terminator  primary weight.  These characters may need terminator
           included in a collation element table beforehand.

       highestFFFF
           -- see 2.4 Tailored noncharacter weights, UTS #35 (LDML) Part 5: Collation.

           If the parameter  is  made  true,  "U+FFFF"  has  a  highest  primary  weight.   When  a  boolean  of
           "$coll-&gt;ge($str,  "abc")"  and  "$coll-&gt;le($str,  "abc\x{FFFF}")"  is  true, it is expected that $str
           begins with "abc", or another primary equivalent.  $str may  be  "abcd",  "abc012",  but  should  not
           include "U+FFFF" such as "abc\x{FFFF}xyz".

           "$coll-&gt;le($str,  "abc\x{FFFF}")"  works  like  "$coll-&gt;lt($str, "abd")" almost, but the latter has a
           problem that you should know which letter is next to "c". For a certain language where  "ch"  as  the
           next letter, "abch" is greater than "abc\x{FFFF}", but less than "abd".

           Note:  This  is equivalent to "(entry =&gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')".  Any other character than
           "U+FFFF" can be tailored by "entry".

       identical
           -- see A.3 Deterministic Comparison, UTS #10.

           By default, strings whose weights are equal should be equal, even though their code  points  are  not
           equal.  Completely ignorable characters are ignored.

           If  the  parameter is made true, a final, tie-breaking level is used.  If no difference of weights is
           found after the comparison through all the level specified  by  "level",  the  comparison  with  code
           points  will  be  performed.   For  the  tie-breaking comparison, the sort key has code points of the
           original string appended.  Completely ignorable characters are not ignored.

           If "preprocess" and/or "normalization" is applied, the code points of the string after them  (in  NFD
           by default) are used.

       ignoreChar
       ignoreName
           -- see 3.6 Variable Weighting, UTS #10.

           Makes the entry in the table completely ignorable; i.e. as if the weights were zero at all level.

           Through "ignoreChar", any character matching "qr/$ignoreChar/" will be ignored. Through "ignoreName",
           any  character  whose name (given in the "table" file as a comment) matches "qr/$ignoreName/" will be
           ignored.

           E.g. when 'a' and 'e' are ignorable, 'element' is equal to 'lament' (or 'lmnt').

       ignore_level2
           -- see 5.1 Parametric Tailoring, UTS #10.

           By default, case-sensitive comparison (that is level 3 difference)  won't  ignore  accents  (that  is
           level 2 difference).

           If  the  parameter  is  made true, accents (and other primary ignorable characters) are ignored, even
           though cases are taken into account.

           <b>NOTE</b>: "level" should be 3 or greater.

       katakana_before_hiragana
           -- see 7.2 Tertiary Weight Table, UTS #10.

           By default, hiragana is before katakana.  If the parameter is made true, this is reversed.

           <b>NOTE</b>: This parameter simplemindedly assumes that any hiragana/katakana  distinctions  must  occur  in
           level  3,  and  their  weights  at level 3 must be same as those mentioned in 7.3.1, UTS #10.  If you
           define your collation elements which violate this requirement, this parameter does not work validly.

       level
           -- see 4.3 Form Sort Key, UTS #10.

           Set the maximum level.  Any higher levels than the specified one are ignored.

             Level 1: alphabetic ordering
             Level 2: diacritic ordering
             Level 3: case ordering
             Level 4: tie-breaking (e.g. in the case when variable is 'shifted')

             ex.level =&gt; 2,

           If omitted, the maximum is the 4th.

           <b>NOTE:</b> The DUCET includes weights over 0xFFFF at the 4th level.  But this  module  only  uses  weights
           within   0xFFFF.   When  "variable"  is  'blanked'  or  'non-ignorable'  (other  than  'shifted'  and
           'shift-trimmed'), the level 4 may be unreliable.

           See also "identical".

       long_contraction
           -- see 3.8.2 Well-Formedness of the DUCET, 4.2 Produce Array, UTS #10.

           If the parameter is made true, for a contraction with three or more characters (here nicknamed  "long
           contraction"),  initial  substrings  will  be  handled.  For example, a contraction ABC, where A is a
           starter, and B and C are non-starters (character with non-zero combining character  class),  will  be
           detected even if there is not AB as a contraction.

           <b>Default:</b>  Usually  false.   If  "UCA_Version" is 22 or 24, and the value of "long_contraction" is not
           specified in new(), a true value is set implicitly.  This is a workaround to pass  Conformance  Tests
           for Unicode 6.0.0 and 6.1.0.

           change()  handles  "long_contraction"  explicitly  only.   If  "long_contraction" is not specified in
           change(), even though "UCA_Version" is changed, "long_contraction" will not be changed.

           <b>Limitation:</b> Scanning non-starters is one-way (no back tracking).  If AB is found but not ABC  is  not
           found,  other  long  contraction  where  the  first character is A and the second is not B may not be
           found.

           Under "(normalization =&gt; undef)", detection step of discontiguous contractions will be skipped.

           <b>Note:</b> The following contractions in DUCET are not considered in steps S2.1.1 to  S2.1.3,  where  they
           are discontiguous.

               0FB2 0F71 0F80 (TIBETAN VOWEL SIGN VOCALIC RR)
               0FB3 0F71 0F80 (TIBETAN VOWEL SIGN VOCALIC LL)

           For  example  "TIBETAN VOWEL SIGN VOCALIC RR" with "COMBINING TILDE OVERLAY" ("U+0344") is "0FB2 0344
           0F71 0F80" in NFD.  In this case "0FB2 0F80" ("TIBETAN VOWEL SIGN VOCALIC R") is detected, instead of
           "0FB2 0F71 0F80".  Inserted 0344 makes "0FB2 0F71 0F80" discontiguous and lack of  contraction  "0FB2
           0F71" prohibits "0FB2 0F71 0F80" from being detected.

       minimalFFFE
           -- see 1.1.1 U+FFFE, UTS #35 (LDML) Part 5: Collation.

           If  the  parameter  is  made  true,  "U+FFFE"  has  a minimal primary weight.  The comparison between
           "$a1\x{FFFE}$a2" and "$b1\x{FFFE}$b2" first compares $a1 and $b1 at level 1, and then $a2 and $b2  at
           level 1, as followed.

                   "ab\x{FFFE}a"
                   "Ab\x{FFFE}a"
                   "ab\x{FFFE}c"
                   "Ab\x{FFFE}c"
                   "ab\x{FFFE}xyz"
                   "abc\x{FFFE}def"
                   "abc\x{FFFE}xYz"
                   "aBc\x{FFFE}xyz"
                   "abcX\x{FFFE}def"
                   "abcx\x{FFFE}xyz"
                   "b\x{FFFE}aaa"
                   "bbb\x{FFFE}a"

           Note:  This  is equivalent to "(entry =&gt; 'FFFE ; [.0001.0020.0005.FFFE]')".  Any other character than
           "U+FFFE" can be tailored by "entry".

       normalization
           -- see 4.1 Normalize, UTS #10.

           If specified, strings are normalized before preparation of sort keys (the normalization  is  executed
           after preprocess).

           A   form  name  Unicode::Normalize::normalize()  accepts  will  be  applied  as  $normalization_form.
           Acceptable names include 'NFD', 'NFC', 'NFKD', and 'NFKC'.  See  Unicode::Normalize::normalize()  for
           detail.  If omitted, 'NFD' is used.

           "normalization" is performed after "preprocess" (if defined).

           Furthermore,  special values, "undef" and "prenormalized", can be used, though they are not concerned
           with Unicode::Normalize::normalize().

           If "undef" (not a string "undef") is passed explicitly as the value for this key,  any  normalization
           is  not  carried  out  (this  may  make  tailoring easier if any normalization is not desired). Under
           "(normalization =&gt; undef)", only contiguous contractions are resolved; e.g.  even  if  "A-ring"  (and
           "A-ring-cedilla")  is  ordered  after  "Z",  "A-cedilla-ring" would be primary equal to "A".  In this
           point,  "(normalization  =&gt;  undef,  preprocess  =&gt;  sub  {  NFD(shift)  })"  <b>is</b>  <b>not</b>  equivalent  to
           "(normalization =&gt; 'NFD')".

           In  the  case  of  "(normalization  =&gt;  "prenormalized")",  any  normalization  is not performed, but
           discontiguous contractions with combining characters are  performed.   Therefore  "(normalization  =&gt;
           'prenormalized',  preprocess =&gt; sub { NFD(shift) })" <b>is</b> equivalent to "(normalization =&gt; 'NFD')".  If
           source strings are finely prenormalized, "(normalization  =&gt;  'prenormalized')"  may  save  time  for
           normalization.

           Except "(normalization =&gt; undef)", <b>Unicode::Normalize</b> is required (see also <b>CAVEAT</b>).

       overrideCJK
           -- see 7.1 Derived Collation Elements, UTS #10.

           By  default,  CJK  unified  ideographs  are  ordered in Unicode codepoint order, but those in the CJK
           Unified Ideographs block are less than those in the CJK Unified Ideographs Extension A etc.

               In the CJK Unified Ideographs block:
               U+4E00..U+9FA5 if UCA_Version is 8, 9 or 11.
               U+4E00..U+9FBB if UCA_Version is 14 or 16.
               U+4E00..U+9FC3 if UCA_Version is 18.
               U+4E00..U+9FCB if UCA_Version is 20 or 22.
               U+4E00..U+9FCC if UCA_Version is 24 to 30.
               U+4E00..U+9FD5 if UCA_Version is 32 or 34.
               U+4E00..U+9FEA if UCA_Version is 36.
               U+4E00..U+9FEF if UCA_Version is 38, 40 or 41.
               U+4E00..U+9FFC if UCA_Version is 43.

               In the CJK Unified Ideographs Extension blocks:
               Ext.A (U+3400..U+4DB5)   if UCA_Version is  8 to 41.
               Ext.A (U+3400..U+4DBF)   if UCA_Version is 43.
               Ext.B (U+20000..U+2A6D6) if UCA_Version is  8 to 41.
               Ext.B (U+20000..U+2A6DD) if UCA_Version is 43.
               Ext.C (U+2A700..U+2B734) if UCA_Version is 20 or later.
               Ext.D (U+2B740..U+2B81D) if UCA_Version is 22 or later.
               Ext.E (U+2B820..U+2CEA1) if UCA_Version is 32 or later.
               Ext.F (U+2CEB0..U+2EBE0) if UCA_Version is 36 or later.
               Ext.G (U+30000..U+3134A) if UCA_Version is 43.

           Through "overrideCJK", ordering of CJK unified ideographs (including extensions) can be overridden.

           ex. CJK unified ideographs in the JIS code point order.

             overrideCJK =&gt; sub {
                 my $u = shift;             # get a Unicode codepoint
                 my $b = pack('n', $u);     # to UTF-16BE
                 my $s = your_unicode_to_sjis_converter($b); # convert
                 my $n = unpack('n', $s);   # convert sjis to short
                 [ $n, 0x20, 0x2, $u ];     # return the collation element
             },

           The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be  an
           integer  as the primary weight as shown below.  If "undef" is returned, the default derived collation
           element will be used.

             overrideCJK =&gt; sub {
                 my $u = shift;             # get a Unicode codepoint
                 my $b = pack('n', $u);     # to UTF-16BE
                 my $s = your_unicode_to_sjis_converter($b); # convert
                 my $n = unpack('n', $s);   # convert sjis to short
                 return $n;                 # return the primary weight
             },

           The return value may be a list containing zero or more of an arrayref, an integer, or "undef".

           ex. ignores all CJK unified ideographs.

             overrideCJK =&gt; sub {()}, # CODEREF returning empty list

              # where -&gt;eq("Pe\x{4E00}rl", "Perl") is true
              # as U+4E00 is a CJK unified ideograph and to be ignorable.

           If   a   false   value   (including   "undef")   is   passed,   "overrideCJK"    has    no    effect.
           "$Collator-&gt;change(overrideCJK =&gt; 0)" resets the old one.

           But assignment of weight for CJK unified ideographs in "table" or "entry" is still valid.  If "undef"
           is  passed  explicitly  as  the value for this key, weights for CJK unified ideographs are treated as
           undefined.  However when "UCA_Version" &gt; 8, "(overrideCJK =&gt; undef)" has no special meaning.

           <b>Note:</b> In addition to them, 12 CJK compatibility ideographs ("U+FA0E", "U+FA0F",  "U+FA11",  "U+FA13",
           "U+FA14",  "U+FA1F",  "U+FA21", "U+FA23", "U+FA24", "U+FA27", "U+FA28", "U+FA29") are also treated as
           CJK unified ideographs. But they can't be overridden via "overrideCJK" when you  use  DUCET,  as  the
           table includes weights for them. "table" or "entry" has priority over "overrideCJK".

       overrideHangul
           -- see 7.1 Derived Collation Elements, UTS #10.

           By  default,  Hangul  syllables  are decomposed into Hangul Jamo, even if "(normalization =&gt; undef)".
           But the mapping of Hangul syllables may be overridden.

           This parameter works like "overrideCJK", so see there for examples.

           If you want to override the mapping of Hangul syllables, NFD and NFKD are not appropriate, since  NFD
           and NFKD will decompose Hangul syllables before overriding. FCD may decompose Hangul syllables as the
           case may be.

           If   a   false   value   (but   not   "undef")   is   passed,   "overrideHangul"   has   no   effect.
           "$Collator-&gt;change(overrideHangul =&gt; 0)" resets the old one.

           If "undef" is passed explicitly as the value for this key, weight for Hangul syllables is treated  as
           undefined  without  decomposition into Hangul Jamo.  But definition of weight for Hangul syllables in
           "table" or "entry" is still valid.

       overrideOut
           -- see 7.1.1 Handling Ill-Formed Code Unit Sequences, UTS #10.

           Perl seems to allow out-of-range values (greater than 0x10FFFF).  By default, out-of-range values are
           replaced  with  "U+FFFD"  (REPLACEMENT  CHARACTER)  when  "UCA_Version"  &gt;=  22,  or   ignored   when
           "UCA_Version" &lt;= 20.

           When  "UCA_Version"  &gt;=  22,  the weights of out-of-range values can be overridden. Though "table" or
           "entry" are available for them, out-of-range values are too many.

           "overrideOut" can perform it algorithmically.  This parameter works like "overrideCJK", so see  there
           for examples.

           ex. ignores all out-of-range values.

             overrideOut =&gt; sub {()}, # CODEREF returning empty list

           If    a    false    value   (including   "undef")   is   passed,   "overrideOut"   has   no   effect.
           "$Collator-&gt;change(overrideOut =&gt; 0)" resets the old one.

           <b>NOTE</b> <b>ABOUT</b> <b>U+FFFD:</b>

           UCA  recommends  that  out-of-range  values  should  not  be  ignored  for  security  reasons.   Say,
           "pe\x{110000}rl"  should  not  be equal to "perl".  However, "U+FFFD" is wrongly mapped to a variable
           collation element in DUCET for Unicode 6.0.0 to 6.2.0, that means out-of-range values will be ignored
           when "variable" isn't "Non-ignorable".

           The     mapping     of     "U+FFFD"      is      corrected      in      Unicode      6.3.0.       see
           &lt;<a href="http://www.unicode.org/reports/tr10/tr10-28.html">http://www.unicode.org/reports/tr10/tr10-28.html</a>#Trailing_Weights&gt;  (7.1.4 Trailing Weights). Such a
           correction is reproduced by this.

             overrideOut =&gt; sub { 0xFFFD }, # CODEREF returning a very large integer

           This workaround is unnecessary since Unicode 6.3.0.

       preprocess
           -- see 5.4 Preprocessing, UTS #10.

           If specified, the coderef is used to preprocess each string before the formation of sort keys.

           ex. dropping English articles, such as "a" or "the".  Then, "the pen" is before "a pencil".

                preprocess =&gt; sub {
                      my $str = shift;
                      $str =~ s/\b(?:an?|the)\s+//gi;
                      return $str;
                   },

           "preprocess" is performed before "normalization" (if defined).

           ex. decoding strings in a legacy encoding such as shift-jis:

               $sjis_collator = Unicode::Collate-&gt;new(
                   preprocess =&gt; \&amp;your_shiftjis_to_unicode_decoder,
               );
               @result = $sjis_collator-&gt;sort(@shiftjis_strings);

           <b>Note:</b> Strings returned from the coderef will be interpreted according to Perl's Unicode support.  See
           perlunicode, perluniintro, perlunitut, perlunifaq, utf8.

       rearrange
           -- see 3.5 Rearrangement, UTS #10.

           Characters that are not coded in logical order and to be rearranged.  If "UCA_Version" is equal to or
           less than 11, default is:

               rearrange =&gt; [ 0x0E40..0x0E44, 0x0EC0..0x0EC4 ],

           If  you  want  to disallow any rearrangement, pass "undef" or "[]" (a reference to empty list) as the
           value for this key.

           If "UCA_Version" is equal to or greater than 14, default is "[]" (i.e. no rearrangement).

           <b>According</b> <b>to</b> <b>the</b> <b>version</b> <b>9</b> <b>of</b> <b>UCA,</b> <b>this</b> <b>parameter</b> <b>shall</b> <b>not</b> <b>be</b> <b>used;</b> <b>but</b> <b>it</b> <b>is</b> <b>not</b> <b>warned</b> <b>at</b> <b>present.</b>

       rewrite
           If specified, the coderef is used to rewrite lines in "table" or "entry".  The coderef will get  each
           line,  and  then  should  return  a  rewritten line according to the UCA file format.  If the coderef
           returns an empty line, the line will be skipped.

           e.g. any primary ignorable characters into tertiary ignorable:

               rewrite =&gt; sub {
                   my $line = shift;
                   $line =~ s/\[\.0000\..{4}\..{4}\./[.0000.0000.0000./g;
                   return $line;
               },

           This example shows rewriting weights. "rewrite" is allowed to affect code points,  weights,  and  the
           name.

           <b>NOTE</b>:  "table"  is available to use another table file; preparing a modified table once would be more
           efficient than rewriting lines on reading an unmodified table every time.

       suppress
           -- see 3.12 Special-Purpose Commands, UTS #35 (LDML) Part 5: Collation.

           Contractions beginning with the specified characters are suppressed, even if those  contractions  are
           defined in "table".

           An example for Russian and some languages using the Cyrillic script:

               suppress =&gt; [0x0400..0x0417, 0x041A..0x0437, 0x043A..0x045F],

           where 0x0400 stands for "U+0400", CYRILLIC CAPITAL LETTER IE WITH GRAVE.

           <b>NOTE</b>: Contractions via "entry" will not be suppressed.

       table
           -- see 3.8 Default Unicode Collation Element Table, UTS #10.

           You can use another collation element table if desired.

           The  table  file  should  locate  in  the  <u>Unicode/Collate</u> directory on @INC. Say, if the filename is
           <u>Foo.txt</u>, the table file is searched as <u>Unicode/Collate/Foo.txt</u> in @INC.

           By default, <u>allkeys.txt</u> (as the filename of DUCET) is used.  If you will prepare your own table file,
           any name other than <u>allkeys.txt</u> may be better to avoid namespace conflict.

           <b>NOTE</b>: When XSUB is used, the DUCET is compiled on building this module, and it may save time  at  the
           run time.  Explicit saying "(table =&gt; 'allkeys.txt')", or using another table, or using "ignoreChar",
           "ignoreName",  "undefChar", "undefName" or "rewrite" will prevent this module from using the compiled
           DUCET.

           If "undef" is passed explicitly as the value for this key, no  file  is  read  (but  you  can  define
           collation elements via "entry").

           A typical way to define a collation element table without any file of table:

              $onlyABC = Unicode::Collate-&gt;new(
                  table =&gt; undef,
                  entry =&gt; &lt;&lt; 'ENTRIES',
           0061 ; [.0101.0020.0002.0061] # LATIN SMALL LETTER A
           0041 ; [.0101.0020.0008.0041] # LATIN CAPITAL LETTER A
           0062 ; [.0102.0020.0002.0062] # LATIN SMALL LETTER B
           0042 ; [.0102.0020.0008.0042] # LATIN CAPITAL LETTER B
           0063 ; [.0103.0020.0002.0063] # LATIN SMALL LETTER C
           0043 ; [.0103.0020.0008.0043] # LATIN CAPITAL LETTER C
           ENTRIES
               );

           If  "ignoreName"  or "undefName" is used, character names should be specified as a comment (following
           "#") on each line.

       undefChar
       undefName
           -- see 6.3.3 Reducing the Repertoire, UTS #10.

           Undefines the collation element as if it were unassigned in the "table".  This reduces  the  size  of
           the  table.   If  an  unassigned character appears in the string to be collated, the sort key is made
           from its codepoint as a single-character collation element, as it is greater than any other  assigned
           collation  elements (in the codepoint order among the unassigned characters).  But, it'd be better to
           ignore characters unfamiliar to you and maybe never used.

           Through "undefChar", any character matching "qr/$undefChar/" will be undefined. Through  "undefName",
           any  character  whose  name (given in the "table" file as a comment) matches "qr/$undefName/" will be
           undefined.

           ex. Collation weights for beyond-BMP characters are not stored in object:

               undefChar =&gt; qr/[^\0-\x{fffd}]/,

       upper_before_lower
           -- see 6.6 Case Comparisons, UTS #10.

           By default, lowercase is before uppercase.  If the parameter is made true, this is reversed.

           <b>NOTE</b>: This parameter simplemindedly assumes that any lowercase/uppercase distinctions must  occur  in
           level  3,  and  their  weights  at level 3 must be same as those mentioned in 7.3.1, UTS #10.  If you
           define your collation elements which differs from  this  requirement,  this  parameter  doesn't  work
           validly.

       variable
           -- see 3.6 Variable Weighting, UTS #10.

           This  key  allows  for  variable  weighting  of variable collation elements, which are marked with an
           ASTERISK in the table (NOTE: Many punctuation marks and symbols are variable in <u>allkeys.txt</u>).

              variable =&gt; 'blanked', 'non-ignorable', 'shifted', or 'shift-trimmed'.

           These names are case-insensitive.  By default (if specification is omitted), 'shifted' is adopted.

              'Blanked'        Variable elements are made ignorable at levels 1 through 3;
                               considered at the 4th level.

              'Non-Ignorable'  Variable elements are not reset to ignorable.

              'Shifted'        Variable elements are made ignorable at levels 1 through 3
                               their level 4 weight is replaced by the old level 1 weight.
                               Level 4 weight for Non-Variable elements is 0xFFFF.

              'Shift-Trimmed'  Same as 'shifted', but all FFFF's at the 4th level
                               are trimmed.

   <b>Methods</b> <b>for</b> <b>Collation</b>
       "@sorted = $Collator-&gt;sort(@not_sorted)"
           Sorts a list of strings.

       "$result = $Collator-&gt;cmp($a, $b)"
           Returns 1 (when $a is greater than $b) or 0 (when $a is equal to $b) or -1 (when $a is less than $b).

       "$result = $Collator-&gt;eq($a, $b)"
       "$result = $Collator-&gt;ne($a, $b)"
       "$result = $Collator-&gt;lt($a, $b)"
       "$result = $Collator-&gt;le($a, $b)"
       "$result = $Collator-&gt;gt($a, $b)"
       "$result = $Collator-&gt;ge($a, $b)"
           They works like the same name operators as theirs.

              eq : whether $a is equal to $b.
              ne : whether $a is not equal to $b.
              lt : whether $a is less than $b.
              le : whether $a is less than $b or equal to $b.
              gt : whether $a is greater than $b.
              ge : whether $a is greater than $b or equal to $b.

       "$sortKey = $Collator-&gt;getSortKey($string)"
           -- see 4.3 Form Sort Key, UTS #10.

           Returns a sort key.

           You compare the sort keys using a binary comparison and get the  result  of  the  comparison  of  the
           strings using UCA.

              $Collator-&gt;getSortKey($a) cmp $Collator-&gt;getSortKey($b)

                 is equivalent to

              $Collator-&gt;cmp($a, $b)

       "$sortKeyForm = $Collator-&gt;viewSortKey($string)"
           Converts  a  sorting key into its representation form.  If "UCA_Version" is 8, the output is slightly
           different.

              use Unicode::Collate;
              my $c = Unicode::Collate-&gt;new();
              print $c-&gt;viewSortKey("Perl"),"\n";

              # output:
              # [0B67 0A65 0B7F 0B03 | 0020 0020 0020 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF]
              #  Level 1               Level 2               Level 3               Level 4

   <b>Methods</b> <b>for</b> <b>Searching</b>
       The "match", "gmatch", "subst", "gsubst" methods work like "m//", "m//g", "s///", "s///g",  respectively,
       but they are not aware of any pattern, but only a literal substring.

       <b>DISCLAIMER:</b>  If  "preprocess"  or  "normalization" parameter is true for $Collator, calling these methods
       ("index", "match", "gmatch", "subst", "gsubst") is croaked, as the position and the length  might  differ
       from those on the specified string.

       "rearrange"   and   "hangul_terminator"   parameters   are   neglected.   "katakana_before_hiragana"  and
       "upper_before_lower" don't affect matching and searching, as it doesn't matter whether greater or less.

       "$position = $Collator-&gt;index($string, $substring[, $position])"
       "($position, $length) = $Collator-&gt;index($string, $substring[, $position])"
           If $substring matches a part of $string, returns the position of the first occurrence of the matching
           part in scalar context; in list context, returns a two-element list of the position and the length of
           the matching part.

           If $substring does not match any part of $string, returns -1 in scalar context and an empty  list  in
           list context.

           e.g.  when  the content of $str is ""Ich mu"ß" studieren Perl."", you say the following where $sub is
           ""M"ü"SS"",

             my $Collator = Unicode::Collate-&gt;new( normalization =&gt; undef, level =&gt; 1 );
                                                # (normalization =&gt; undef) is REQUIRED.
             my $match;
             if (my($pos,$len) = $Collator-&gt;index($str, $sub)) {
                 $match = substr($str, $pos, $len);
             }

           and get ""mu"ß""" in $match, since ""mu"ß""" is primary equal to ""M"ü"SS"".

       "$match_ref = $Collator-&gt;match($string, $substring)"
       "($match)   = $Collator-&gt;match($string, $substring)"
           If $substring matches a part of $string,  in  scalar  context,  returns  <b>a</b>  <b>reference</b>  <b>to</b>  the  first
           occurrence  of  the  matching  part  ($match_ref  is always true if matches, since every reference is
           <b>true</b>); in list context, returns the first occurrence of the matching part.

           If $substring does not match any part of $string, returns "undef" in scalar context and an empty list
           in list context.

           e.g.

               if ($match_ref = $Collator-&gt;match($str, $sub)) { # scalar context
                   print "matches [$$match_ref].\n";
               } else {
                   print "doesn't match.\n";
               }

                or

               if (($match) = $Collator-&gt;match($str, $sub)) { # list context
                   print "matches [$match].\n";
               } else {
                   print "doesn't match.\n";
               }

       "@match = $Collator-&gt;gmatch($string, $substring)"
           If $substring matches a part of $string, returns all the matching parts (or matching count in  scalar
           context).

           If $substring does not match any part of $string, returns an empty list.

       "$count = $Collator-&gt;subst($string, $substring, $replacement)"
           If  $substring  matches  a  part of $string, the first occurrence of the matching part is replaced by
           $replacement ($string is modified) and $count (always equals to 1) is returned.

           $replacement can be a "CODEREF", taking the matching part as an argument, and returning a  string  to
           replace the matching part (a bit similar to "s/(..)/$coderef-&gt;($1)/e").

       "$count = $Collator-&gt;gsubst($string, $substring, $replacement)"
           If  $substring  matches  a  part of $string, all the occurrences of the matching part are replaced by
           $replacement ($string is modified) and $count is returned.

           $replacement can be a "CODEREF", taking the matching part as an argument, and returning a  string  to
           replace the matching part (a bit similar to "s/(..)/$coderef-&gt;($1)/eg").

           e.g.

             my $Collator = Unicode::Collate-&gt;new( normalization =&gt; undef, level =&gt; 1 );
                                                # (normalization =&gt; undef) is REQUIRED.
             my $str = "Camel donkey zebra came\x{301}l CAMEL horse cam\0e\0l...";
             $Collator-&gt;gsubst($str, "camel", sub { "&lt;b&gt;$_[0]&lt;/b&gt;" });

             # now $str is "&lt;b&gt;Camel&lt;/b&gt; donkey zebra &lt;b&gt;came\x{301}l&lt;/b&gt; &lt;b&gt;CAMEL&lt;/b&gt; horse &lt;b&gt;cam\0e\0l&lt;/b&gt;...";
             # i.e., all the camels are made bold-faced.

              Examples: levels and ignore_level2 - what does camel match?
             ---------------------------------------------------------------------------
              level  ignore_level2  |  camel  Camel  came\x{301}l  c-a-m-e-l  cam\0e\0l
             -----------------------|---------------------------------------------------
                1        false      |   yes    yes      yes          yes        yes
                2        false      |   yes    yes      no           yes        yes
                3        false      |   yes    no       no           yes        yes
                4        false      |   yes    no       no           no         yes
             -----------------------|---------------------------------------------------
                1        true       |   yes    yes      yes          yes        yes
                2        true       |   yes    yes      yes          yes        yes
                3        true       |   yes    no       yes          yes        yes
                4        true       |   yes    no       yes          no         yes
             ---------------------------------------------------------------------------
              note: if variable =&gt; non-ignorable, camel doesn't match c-a-m-e-l
                    at any level.

   <b>Other</b> <b>Methods</b>
       "%old_tailoring = $Collator-&gt;change(%new_tailoring)"
       "$modified_collator = $Collator-&gt;change(%new_tailoring)"
           Changes the value of specified keys and returns the changed part.

               $Collator = Unicode::Collate-&gt;new(level =&gt; 4);

               $Collator-&gt;eq("perl", "PERL"); # false

               %old = $Collator-&gt;change(level =&gt; 2); # returns (level =&gt; 4).

               $Collator-&gt;eq("perl", "PERL"); # true

               $Collator-&gt;change(%old); # returns (level =&gt; 2).

               $Collator-&gt;eq("perl", "PERL"); # false

           Not  all  "(key,value)"s  are  allowed  to  be  changed.   See  also  @Unicode::Collate::ChangeOK and
           @Unicode::Collate::ChangeNG.

           In the scalar context, returns the modified collator (but it is <b>not</b> a clone from the original).

               $Collator-&gt;change(level =&gt; 2)-&gt;eq("perl", "PERL"); # true

               $Collator-&gt;eq("perl", "PERL"); # true; now max level is 2nd.

               $Collator-&gt;change(level =&gt; 4)-&gt;eq("perl", "PERL"); # false

       "$version = $Collator-&gt;version()"
           Returns the version number (a string) of the Unicode Standard which the  "table"  file  used  by  the
           collator  object is based on.  If the table does not include a version line (starting with @version),
           returns "unknown".

       UCA_Version()
           Returns the revision number of UTS #10 this module consults, that should correspond  with  the  DUCET
           incorporated.

       Base_Unicode_Version()
           Returns  the  version  number  of UTS #10 this module consults, that should correspond with the DUCET
           incorporated.

</pre><h4><b>EXPORT</b></h4><pre>
       No method will be exported.

</pre><h4><b>INSTALL</b></h4><pre>
       Though this module can be used without any "table" file, to use this module easily, it is recommended  to
       install   a   table   file   in  the  UCA  format,  by  copying  it  under  the  directory  &lt;a  place  in
       @INC&gt;/Unicode/Collate.

       The most preferable one is "The Default Unicode Collation Element Table" (aka DUCET), available from  the
       Unicode Consortium's website:

          <a href="http://www.unicode.org/Public/UCA/">http://www.unicode.org/Public/UCA/</a>

          <a href="http://www.unicode.org/Public/UCA/latest/allkeys.txt">http://www.unicode.org/Public/UCA/latest/allkeys.txt</a>
          (latest version)

       If     DUCET     is     not    installed,    it    is    recommended    to    copy    the    file    from
       <a href="http://www.unicode.org/Public/UCA/latest/allkeys.txt">http://www.unicode.org/Public/UCA/latest/allkeys.txt</a> to  &lt;a  place  in  @INC&gt;/Unicode/Collate/allkeys.txt
       manually.

</pre><h4><b>CAVEATS</b></h4><pre>
       Normalization
           Use of the "normalization" parameter requires the <b>Unicode::Normalize</b> module (see Unicode::Normalize).

           If  you  need  not  it  (say,  in the case when you need not handle any combining characters), assign
           "(normalization =&gt; undef)" explicitly.

           -- see 6.5 Avoiding Normalization, UTS #10.

       Conformance Test
           The Conformance Test for the UCA is available under &lt;<a href="http://www.unicode.org/Public/UCA/">http://www.unicode.org/Public/UCA/</a>&gt;.

           For <u>CollationTest_SHIFTED.txt</u>,  a  collator  via  "Unicode::Collate-&gt;new(  )"  should  be  used;  for
           <u>CollationTest_NON_IGNORABLE.txt</u>,  a  collator via "Unicode::Collate-&gt;new(variable =&gt; "non-ignorable",
           level =&gt; 3)".

           If "UCA_Version" is 26 or later, the "identical" level is preferred; "Unicode::Collate-&gt;new(identical
           =&gt; 1)" and "Unicode::Collate-&gt;new(identical =&gt; 1," "variable =&gt; "non-ignorable", level =&gt; 3)"  should
           be used.

           <b>Unicode::Normalize</b> <b>is</b> <b>required</b> <b>to</b> <b>try</b> <b>The</b> <b>Conformance</b> <b>Test.</b>

           <b>EBCDIC-SUPPORT</b> <b>IS</b> <b>EXPERIMENTAL.</b>

</pre><h4><b>AUTHOR,</b> <b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       The  Unicode::Collate  module for perl was written by SADAHIRO Tomoyuki, &lt;<a href="mailto:SADAHIRO@cpan.org">SADAHIRO@cpan.org</a>&gt;. This module
       is Copyright(C) 2001-2021, SADAHIRO Tomoyuki. Japan. All rights reserved.

       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself.

       The         file         Unicode/Collate/allkeys.txt        was        copied        verbatim        from
       &lt;<a href="http://www.unicode.org/Public/UCA/13.0.0/allkeys.txt">http://www.unicode.org/Public/UCA/13.0.0/allkeys.txt</a>&gt;.  For this file, Copyright (c) 2020 Unicode, Inc.;
       distributed under the Terms of Use in &lt;<a href="http://www.unicode.org/terms_of_use.html">http://www.unicode.org/terms_of_use.html</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Unicode Collation Algorithm - UTS #10
           &lt;<a href="http://www.unicode.org/reports/tr10/">http://www.unicode.org/reports/tr10/</a>&gt;

       The Default Unicode Collation Element Table (DUCET)
           &lt;<a href="http://www.unicode.org/Public/UCA/latest/allkeys.txt">http://www.unicode.org/Public/UCA/latest/allkeys.txt</a>&gt;

       The conformance test for the UCA
           &lt;<a href="http://www.unicode.org/Public/UCA/latest/CollationTest.html">http://www.unicode.org/Public/UCA/latest/CollationTest.html</a>&gt;

           &lt;<a href="http://www.unicode.org/Public/UCA/latest/CollationTest.zip">http://www.unicode.org/Public/UCA/latest/CollationTest.zip</a>&gt;

       Hangul Syllable Type
           &lt;<a href="http://www.unicode.org/Public/UNIDATA/HangulSyllableType.txt">http://www.unicode.org/Public/UNIDATA/HangulSyllableType.txt</a>&gt;

       Unicode Normalization Forms - UAX #15
           &lt;<a href="http://www.unicode.org/reports/tr15/">http://www.unicode.org/reports/tr15/</a>&gt;

       Unicode Locale Data Markup Language (LDML) - UTS #35
           &lt;<a href="http://www.unicode.org/reports/tr35/">http://www.unicode.org/reports/tr35/</a>&gt;

perl v5.40.0                                       2024-10-20                                       <u><a href="../man3pm/Collate.3pm.html">Collate</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>