<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hook - Hooks</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       hook - Hooks

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>hook</b> <b>?0.3?</b>

       <b>hook</b> <b>bind</b> ?<u>subject</u>? ?<u>hook</u>? ?<u>observer</u>? ?<u>cmdPrefix</u>?

       <b>hook</b> <b>call</b> <u>subject</u> <u>hook</u> ?<u>args</u>...?

       <b>hook</b> <b>forget</b> <u>object</u>

       <b>hook</b> <b>cget</b> <u>option</u>

       <b>hook</b> <b>configure</b> <b>option</b> <u>value</u> ...

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This package provides the <b>hook</b> ensemble command, which implements the Subject/Observer pattern. It allows
       <u>subjects</u>,  which may be <u>modules</u>, <u>objects</u>, <u>widgets</u>, and so forth, to synchronously call <u>hooks</u> which may be
       bound to an arbitrary number of subscribers, called <u>observers</u>. A subject may call any number of  distinct
       hooks,  and  any  number  of  observers  can  bind  callbacks to a particular hook called by a particular
       subject. Hook bindings can be queried and deleted.

       This man page is intended to be a reference only.

</pre><h4><b>CONCEPTS</b></h4><pre>
   <b>INTRODUCTION</b>
       Tcl modules usually send notifications to other modules in two ways: via  Tk  events,  and  via  callback
       options  like  the text widget's <b>-yscrollcommand</b> option. Tk events are available only in Tk, and callback
       options require tight coupling between the modules sending and receiving the notification.

       Loose coupling between sender and receiver is often desirable, however.  In Model/View/Controller  terms,
       a  View  can  send  a  command (stemming from user input) to the Controller, which updates the Model. The
       Model can then call a hook <u>to</u> <u>which</u> <u>all</u> <u>relevant</u> <u>Views</u> <u>subscribe.</u> The Model is decoupled from the  Views,
       and  indeed need not know whether any Views actually exist.  At present, Tcl/Tk has no standard mechanism
       for implementing loose coupling of this kind. This package defines a new command, <b>hook</b>, which  implements
       just such a mechanism.

   <b>BINDINGS</b>
       The <b>hook</b> command manages a collection of hook bindings. A hook binding has four elements:

       [1]    A <u>subject</u>: the name of the entity that will be calling the hook.

       [2]    The  <u>hook</u>  itself.  A  hook usually reflects some occurrence in the life of the <u>subject</u> that other
              entities might care to know about. A <u>hook</u> has a name, and may also have arguments. Hook names  are
              arbitrary strings. Each <u>subject</u> must document the names and arguments of the hooks it can call.

       [3]    The name of the <u>observer</u> that wishes to receive the <u>hook</u> from the <u>subject</u>.

       [4]    A command prefix to which the <u>hook</u> arguments will be appended when the binding is executed.

   <b>SUBJECTS</b> <b>AND</b> <b>OBSERVERS</b>
       For convenience, this document collectively refers to subjects and observers as <u>objects</u>, while placing no
       requirements  on  how  these  <u>objects</u> are actually implemented. An object can be a <b>TclOO</b> or <b>Snit</b> or <b>XOTcl</b>
       object, a Tcl command, a namespace, a module, a pseudo-object managed by some other object (as  tags  are
       managed by the Tk text widget) or simply a well-known name.

       Subject  and  observer  names are arbitrary strings; however, as <b>hook</b> might be used at the package level,
       it's necessary to have conventions that avoid name  collisions  between  packages  written  by  different
       people.

       Therefore, any subject or observer name used in core or package level code should look like a Tcl command
       name,  and  should  be  defined  in  a namespace owned by the package. Consider, for example, an ensemble
       command <b>::foo</b> that creates a set of pseudo-objects and uses  <b>hook</b>  to  send  notifications.  The  pseudo-
       objects  have  names that are not commands and exist in their own namespace, rather like file handles do.
       To avoid name collisions with subjects defined by other packages, users  of  <b>hook</b>,  these  <b>::foo</b>  handles
       should have names like <b>::foo::1</b>, <b>::foo::2</b>, and so on.

       Because  object names are arbitrary strings, application code can use whatever additional conventions are
       dictated by the needs of the application.

</pre><h4><b>REFERENCE</b></h4><pre>
       Hook provides the following commands:

       <b>hook</b> <b>bind</b> ?<u>subject</u>? ?<u>hook</u>? ?<u>observer</u>? ?<u>cmdPrefix</u>?
              This subcommand is used to create, update, delete, and query hook bindings.

              Called with no arguments it returns a list of the subjects  with  hooks  to  which  observers  are
              currently bound.

              Called  with  one argument, a <u>subject</u>, it returns a list of the subject's hooks to which observers
              are currently bound.

              Called with two arguments, a <u>subject</u> and a <u>hook</u>, it returns a list  of  the  observers  which  are
              currently bound to this <u>subject</u> and <u>hook</u>.

              Called  with  three  arguments, a <u>subject</u>, a <u>hook</u>, and an <u>observer</u>, it returns the binding proper,
              the command prefix to be called when the hook is called, or the empty string if there is  no  such
              binding.

              Called  with  four arguments, it creates, updates, or deletes a binding. If <u>cmdPrefix</u> is the empty
              string, it deletes any existing binding for the <u>subject</u>, <u>hook</u>, and <u>observer</u>; nothing is  returned.
              Otherwise,  <u>cmdPrefix</u>  must  be  a  command  prefix  taking  as  many  additional arguments as are
              documented for the <u>subject</u> and <u>hook</u>. The  binding  is  added  or  updated,  and  the  observer  is
              returned.

              If  the  <u>observer</u>  is  the  empty  string, "", it will create a new binding using an automatically
              generated observer name of the form <b>::hook::ob</b>&lt;<b>number</b>&gt;. The automatically generated name  will  be
              returned, and can be used to query, update, and delete the binding as usual. If automated observer
              names are always used, the observer name effectively becomes a unique binding ID.

              It  is  possible to call <b>hook</b> <b>bind</b> to create or delete a binding to a <u>subject</u> and <u>hook</u> while in an
              observer binding for that same <u>subject</u> and <u>hook</u>. The following rules determine what happens when

                  hook bind $s $h $o $binding

              is called during the execution of

                  hook call $s $h

              [1]    No binding is ever called after it is deleted.

              [2]    When a binding is called, the most recently given command prefix is always used.

              [3]    The set of observers whose bindings are to be called is determined when this method  begins
                     to execute, and does not change thereafter, except that deleted bindings are not called.

              In particular:

              [1]    If <b>$o</b>s binding to <b>$s</b> and <b>$h</b> is deleted, and <b>$o</b>s binding has not yet been called during this
                     execution of

                         hook call $s $h

                     it will not be called. (Note that it might already have been called; and in all likelihood,
                     it is probably deleting itself.)

              [2]    If  <b>$o</b> changes the command prefix that's bound to <b>$s</b> and <b>$h</b>, and if <b>$o</b>s binding has not yet
                     been called during this execution of

                         hook call $s $h

                     the new binding will be called when the time comes. (But again, it is probably <b>$o</b>s  binding
                     that is is making the change.)

              [3]    If  a  new  observer  is  bound to <b>$s</b> and <b>$h</b>, its binding will not be called until the next
                     invocation of

                         hook call $s $h

       <b>hook</b> <b>call</b> <u>subject</u> <u>hook</u> ?<u>args</u>...?
              This command is called when the named <u>subject</u> wishes to call the named <u>hook</u>. All relevant bindings
              are called with the specified arguments in the global namespace. Note that the bindings are called
              synchronously, before the command returns; this allows the <u>args</u> to include references to  entities
              that will be cleaned up as soon as the hook has been called.

              The  order in which the bindings are called is not guaranteed. If sequence among observers must be
              preserved, define one observer and have its bindings call the  other  callbacks  directly  in  the
              proper sequence.

              Because  the <b>hook</b> mechanism is intended to support loose coupling, it is presumed that the <u>subject</u>
              has no knowledge of the observers, nor any expectation regarding return values. This has a  number
              of implications:

              [1]    <b>hook</b> <b>call</b> returns the empty string.

              [2]    Normal return values from observer bindings are ignored.

              [3]    Errors  and  other  exceptional  returns propagate normally by default. This will rarely be
                     what is wanted, because the subjects usually have no knowledge of the  observers  and  will
                     therefore  have  no  particular  competence  at  handling  their  errors.  That makes it an
                     application issue, and so applications will usually want to define an <b>-errorcommand</b>.

              If the <b>-errorcommand</b> configuration option has a non-empty value, its value will be invoked for all
              errors and other exceptional returns in observer bindings. See <b>hook</b>  <b>configure</b>,  below,  for  more
              information on configuration options.

       <b>hook</b> <b>forget</b> <u>object</u>
              This command deletes any existing bindings in which the named <u>object</u> appears as either the <u>subject</u>
              or the <u>observer</u>.  Bindings deleted by this method will never be called again. In particular,

              [1]    If  an observer is forgotten during a call to <b>hook</b> <b>call</b>, any uncalled binding it might have
                     had to the relevant subject and hook will <u>not</u> be called subsequently.

              [2]    If a subject <b>$s</b> is forgotten during a call to

                     hook call $s $h

                     then <b>hook</b> <b>call</b> will return as soon as the current binding  returns.   No  further  bindings
                     will be called.

       <b>hook</b> <b>cget</b> <u>option</u>
              This command returns the value of one of the <b>hook</b> command's configuration options.

       <b>hook</b> <b>configure</b> <b>option</b> <u>value</u> ...
              This command sets the value of one or more of the <b>hook</b> command's configuration options:

              <b>-errorcommand</b> <u>cmdPrefix</u>
                     If  the  value  of  this  option  is  the empty string, "", then errors and other exception
                     returns in binding scripts are propagated normally. Otherwise, it must be a command  prefix
                     taking three additional arguments:

                     [1]    a 4-element list {subject hook arglist observer},

                     [2]    the result string, and

                     [3]    the return options dictionary.

                     Given this information, the <b>-errorcommand</b> can choose to log the error, call <b>interp</b> <b>bgerror</b>,
                     delete  the  errant  binding  (thus preventing the error from arising a second time) and so
                     forth.

              <b>-tracecommand</b> <u>cmdPrefix</u>
                     The option's value should be a command prefix taking four arguments:

                     [1]    a <u>subject</u>,

                     [2]    a <u>hook</u>,

                     [3]    a list of the hook's argument values, and

                     [4]    a list of <u>objects</u> the hook was called for.

                     The command will be called for each hook that is called. This  allows  the  application  to
                     trace hook execution for debugging purposes.

</pre><h4><b>EXAMPLE</b></h4><pre>
       The <b>::model</b> module calls the &lt;Update&gt; hook in response to commands that change the model's data:

                   hook call ::model &lt;Update&gt;

       The  <b>.view</b>  megawidget  displays the model state, and needs to know about model updates. Consequently, it
       subscribes to the ::model's &lt;Update&gt; hook.

                   hook bind ::model &lt;Update&gt; .view [list .view ModelUpdate]

       When the <b>::model</b> calls the hook, the <b>.view</b>s ModelUpdate subcommand will be called.

       Later the <b>.view</b> megawidget is destroyed. In its destructor, it tells the <u>hook</u> that it no longer exists:

                   hook forget .view

       All bindings involving <b>.view</b> are deleted.

</pre><h4><b>CREDITS</b></h4><pre>
       Hook has been designed and implemented by William H. Duquette.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in the category <u>hook</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/uevent.3tcl.html">uevent</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       callback, event, hook, observer, producer, publisher, subject, subscriber, uevent

</pre><h4><b>CATEGORY</b></h4><pre>
       Programming tools

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2010, by William H. Duquette

tcllib                                                 0.3                                            <u><a href="../man3tcl/hook.3tcl.html">hook</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>