<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>serd - A lightweight RDF syntax library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libserd-doc">libserd-doc_0.32.4-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       serd - A lightweight RDF syntax library

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Data</b> <b>Structures</b>
       struct <b>SerdNode</b>
       struct <b>SerdChunk</b>
       struct <b>SerdError</b>
       struct <b>SerdURI</b>

   <b>Typedefs</b>
       typedef struct SerdEnvImpl <b>SerdEnv</b>
       typedef struct SerdReaderImpl <b>SerdReader</b>
       typedef struct SerdWriterImpl <b>SerdWriter</b>
       typedef uint32_t <b>SerdStatementFlags</b>
       typedef uint32_t <b>SerdNodeFlags</b>

   <b>Enumerations</b>
       enum <b>SerdStatus</b>
       enum <b>SerdSyntax</b>
       enum <b>SerdStatementFlag</b>
       enum <b>SerdType</b>
       enum <b>SerdNodeFlag</b>
       enum <b>SerdStyle</b>

   <b>Functions</b>
       void <b>serd_free</b> (void *ptr)

   <b>String</b> <b>Utilities</b>
       const uint8_t * <b>serd_strerror</b> (<b>SerdStatus</b> status)
       size_t <b>serd_strlen</b> (const uint8_t *str, size_t *n_bytes, <b>SerdNodeFlags</b> *flags)
       double <b>serd_strtod</b> (const char *str, char **endptr)
       void * <b>serd_base64_decode</b> (const uint8_t *str, size_t len, size_t *size)

   <b>Byte</b> <b>Streams</b>
       typedef int(* <b>SerdStreamErrorFunc</b>) (void *stream)
       typedef size_t(* <b>SerdSource</b>) (void *buf, size_t size, size_t nmemb, void *stream)
       typedef size_t(* <b>SerdSink</b>) (const void *buf, size_t len, void *stream)

   <b>URI</b>
       static const <b>SerdURI</b> <b>SERD_URI_NULL</b>
       const uint8_t * <b>serd_uri_to_path</b> (const uint8_t *uri)
       uint8_t * <b>serd_file_uri_parse</b> (const uint8_t *uri, uint8_t **hostname)
       bool <b>serd_uri_string_has_scheme</b> (const uint8_t *utf8)
       <b>SerdStatus</b> <b>serd_uri_parse</b> (const uint8_t *utf8, <b>SerdURI</b> *out)
       void <b>serd_uri_resolve</b> (const <b>SerdURI</b> *r, const <b>SerdURI</b> *base, <b>SerdURI</b> *t)
       size_t <b>serd_uri_serialise</b> (const <b>SerdURI</b> *uri, <b>SerdSink</b> sink, void *stream)
       size_t  <b>serd_uri_serialise_relative</b>  (const  <b>SerdURI</b>  *uri,  const  <b>SerdURI</b>  *base,  const <b>SerdURI</b> *root,
           <b>SerdSink</b> sink, void *stream)

   <b>Node</b>
       static const <b>SerdNode</b> <b>SERD_NODE_NULL</b> = { NULL, 0, 0, 0, <b>SERD_NOTHING</b> }
       <b>SerdNode</b> <b>serd_node_from_string</b> (<b>SerdType</b> type, const uint8_t *str)
       <b>SerdNode</b> <b>serd_node_from_substring</b> (<b>SerdType</b> type, const uint8_t *str, size_t len)
       <b>SerdNode</b> <b>serd_node_copy</b> (const <b>SerdNode</b> *node)
       bool <b>serd_node_equals</b> (const <b>SerdNode</b> *a, const <b>SerdNode</b> *b)
       <b>SerdNode</b> <b>serd_node_new_uri_from_node</b> (const <b>SerdNode</b> *uri_node, const <b>SerdURI</b> *base, <b>SerdURI</b> *out)
       <b>SerdNode</b> <b>serd_node_new_uri_from_string</b> (const uint8_t *str, const <b>SerdURI</b> *base, <b>SerdURI</b> *out)
       <b>SerdNode</b> <b>serd_node_new_file_uri</b> (const uint8_t *path, const uint8_t *hostname, <b>SerdURI</b> *out, bool escape)
       <b>SerdNode</b> <b>serd_node_new_uri</b> (const <b>SerdURI</b> *uri, const <b>SerdURI</b> *base, <b>SerdURI</b> *out)
       <b>SerdNode</b> <b>serd_node_new_relative_uri</b> (const <b>SerdURI</b>  *uri,  const  <b>SerdURI</b>  *base,  const  <b>SerdURI</b>  *root,
           <b>SerdURI</b> *out)
       <b>SerdNode</b> <b>serd_node_new_decimal</b> (double d, unsigned frac_digits)
       <b>SerdNode</b> <b>serd_node_new_integer</b> (int64_t i)
       <b>SerdNode</b> <b>serd_node_new_blob</b> (const void *buf, size_t size, bool wrap_lines)
       void <b>serd_node_free</b> (<b>SerdNode</b> *node)

   <b>Event</b> <b>Handlers</b>
       typedef <b>SerdStatus</b>(* <b>SerdErrorSink</b>) (void *handle, const <b>SerdError</b> *error)
       typedef <b>SerdStatus</b>(* <b>SerdBaseSink</b>) (void *handle, const <b>SerdNode</b> *uri)
       typedef <b>SerdStatus</b>(* <b>SerdPrefixSink</b>) (void *handle, const <b>SerdNode</b> *name, const <b>SerdNode</b> *uri)
       typedef  <b>SerdStatus</b>(*  <b>SerdStatementSink</b>) (void *handle, <b>SerdStatementFlags</b> flags, const <b>SerdNode</b> *graph,
           const  <b>SerdNode</b>  *subject,  const  <b>SerdNode</b>  *predicate,  const  <b>SerdNode</b>  *object,  const   <b>SerdNode</b>
           *object_datatype, const <b>SerdNode</b> *object_lang)
       typedef <b>SerdStatus</b>(* <b>SerdEndSink</b>) (void *handle, const <b>SerdNode</b> *node)

   <b>Environment</b>
       <b>SerdEnv</b> * <b>serd_env_new</b> (const <b>SerdNode</b> *base_uri)
       void <b>serd_env_free</b> (<b>SerdEnv</b> *env)
       const <b>SerdNode</b> * <b>serd_env_get_base_uri</b> (const <b>SerdEnv</b> *env, <b>SerdURI</b> *out)
       <b>SerdStatus</b> <b>serd_env_set_base_uri</b> (<b>SerdEnv</b> *env, const <b>SerdNode</b> *uri)
       <b>SerdStatus</b> <b>serd_env_set_prefix</b> (<b>SerdEnv</b> *env, const <b>SerdNode</b> *name, const <b>SerdNode</b> *uri)
       <b>SerdStatus</b> <b>serd_env_set_prefix_from_strings</b> (<b>SerdEnv</b> *env, const uint8_t *name, const uint8_t *uri)
       bool <b>serd_env_qualify</b> (const <b>SerdEnv</b> *env, const <b>SerdNode</b> *uri, <b>SerdNode</b> *prefix, <b>SerdChunk</b> *suffix)
       <b>SerdStatus</b>  <b>serd_env_expand</b>  (const <b>SerdEnv</b> *env, const <b>SerdNode</b> *curie, <b>SerdChunk</b> *uri_prefix, <b>SerdChunk</b>
           *uri_suffix)
       <b>SerdNode</b> <b>serd_env_expand_node</b> (const <b>SerdEnv</b> *env, const <b>SerdNode</b> *node)
       void <b>serd_env_foreach</b> (const <b>SerdEnv</b> *env, <b>SerdPrefixSink</b> func, void *handle)

   <b>Reader</b>
       <b>SerdReader</b> * <b>serd_reader_new</b> (<b>SerdSyntax</b> syntax, void *handle, void(*free_handle)(void  *),  <b>SerdBaseSink</b>
           base_sink, <b>SerdPrefixSink</b> prefix_sink, <b>SerdStatementSink</b> statement_sink, <b>SerdEndSink</b> end_sink)
       void <b>serd_reader_set_strict</b> (<b>SerdReader</b> *reader, bool strict)
       void <b>serd_reader_set_error_sink</b> (<b>SerdReader</b> *reader, <b>SerdErrorSink</b> error_sink, void *error_handle)
       void * <b>serd_reader_get_handle</b> (const <b>SerdReader</b> *reader)
       void <b>serd_reader_add_blank_prefix</b> (<b>SerdReader</b> *reader, const uint8_t *prefix)
       void <b>serd_reader_set_default_graph</b> (<b>SerdReader</b> *reader, const <b>SerdNode</b> *graph)
       <b>SerdStatus</b> <b>serd_reader_read_file</b> (<b>SerdReader</b> *reader, const uint8_t *uri)
       <b>SerdStatus</b> <b>serd_reader_start_stream</b> (<b>SerdReader</b> *reader, FILE *file, const uint8_t *name, bool bulk)
       <b>SerdStatus</b> <b>serd_reader_start_source_stream</b> (<b>SerdReader</b> *reader, <b>SerdSource</b> read_func, <b>SerdStreamErrorFunc</b>
           error_func, void *stream, const uint8_t *name, size_t page_size)
       <b>SerdStatus</b> <b>serd_reader_read_chunk</b> (<b>SerdReader</b> *reader)
       <b>SerdStatus</b> <b>serd_reader_end_stream</b> (<b>SerdReader</b> *reader)
       <b>SerdStatus</b> <b>serd_reader_read_file_handle</b> (<b>SerdReader</b> *reader, FILE *file, const uint8_t *name)
       <b>SerdStatus</b>  <b>serd_reader_read_source</b>  (<b>SerdReader</b>  *reader,  <b>SerdSource</b> source, <b>SerdStreamErrorFunc</b> error,
           void *stream, const uint8_t *name, size_t page_size)
       <b>SerdStatus</b> <b>serd_reader_read_string</b> (<b>SerdReader</b> *reader, const uint8_t *utf8)
       void <b>serd_reader_free</b> (<b>SerdReader</b> *reader)

   <b>Writer</b>
       <b>SerdWriter</b> * <b>serd_writer_new</b> (<b>SerdSyntax</b> syntax, <b>SerdStyle</b> style, <b>SerdEnv</b> *env, const <b>SerdURI</b>  *base_uri,
           <b>SerdSink</b> ssink, void *stream)
       void <b>serd_writer_free</b> (<b>SerdWriter</b> *writer)
       <b>SerdEnv</b> * <b>serd_writer_get_env</b> (<b>SerdWriter</b> *writer)
       size_t <b>serd_file_sink</b> (const void *buf, size_t len, void *stream)
       size_t <b>serd_chunk_sink</b> (const void *buf, size_t len, void *stream)
       uint8_t * <b>serd_chunk_sink_finish</b> (<b>SerdChunk</b> *stream)
       void <b>serd_writer_set_error_sink</b> (<b>SerdWriter</b> *writer, <b>SerdErrorSink</b> error_sink, void *error_handle)
       void <b>serd_writer_chop_blank_prefix</b> (<b>SerdWriter</b> *writer, const uint8_t *prefix)
       <b>SerdStatus</b> <b>serd_writer_set_base_uri</b> (<b>SerdWriter</b> *writer, const <b>SerdNode</b> *uri)
       <b>SerdStatus</b> <b>serd_writer_set_root_uri</b> (<b>SerdWriter</b> *writer, const <b>SerdNode</b> *uri)
       <b>SerdStatus</b> <b>serd_writer_set_prefix</b> (<b>SerdWriter</b> *writer, const <b>SerdNode</b> *name, const <b>SerdNode</b> *uri)
       <b>SerdStatus</b>  <b>serd_writer_write_statement</b>  (<b>SerdWriter</b>  *writer,  <b>SerdStatementFlags</b>  flags, const <b>SerdNode</b>
           *graph, const <b>SerdNode</b> *subject, const <b>SerdNode</b> *predicate, const <b>SerdNode</b>  *object,  const  <b>SerdNode</b>
           *datatype, const <b>SerdNode</b> *lang)
       <b>SerdStatus</b> <b>serd_writer_end_anon</b> (<b>SerdWriter</b> *writer, const <b>SerdNode</b> *node)
       <b>SerdStatus</b> <b>serd_writer_finish</b> (<b>SerdWriter</b> *writer)

</pre><h4><b>Data</b> <b>Structure</b> <b>Documentation</b></h4><pre>
</pre><h4><b>struct</b> <b>SerdNode</b></h4><pre>
       A syntactic RDF node.

       <b>Data</b> <b>Fields:</b>
           const uint8_t * <u>buf</u> Value string.

           size_t <u>n_bytes</u> Size in bytes (not including null)

           size_t <u>n_chars</u> Length in characters (not including null)

           <b>SerdNodeFlags</b> <u>flags</u> Node flags (e.g. string properties)

           <b>SerdType</b> <u>type</u> Node type.

</pre><h4><b>struct</b> <b>SerdChunk</b></h4><pre>
       An unterminated string fragment.

       <b>Data</b> <b>Fields:</b>
           const uint8_t * <u>buf</u> Start of chunk.

           size_t <u>len</u> Length of chunk in bytes.

</pre><h4><b>struct</b> <b>SerdError</b></h4><pre>
       An error description.

       <b>Data</b> <b>Fields:</b>
           <b>SerdStatus</b> <u>status</u> Error code.

           const uint8_t * <u>filename</u> File where error was encountered, or NULL.

           unsigned <u>line</u> Line where error was encountered, or 0.

           unsigned <u>col</u> Column where error was encountered.

           const char * <u>fmt</u> Message format string (printf style)

           va_list * <u>args</u> Arguments for fmt.

</pre><h4><b>struct</b> <b>SerdURI</b></h4><pre>
       A parsed URI.

       This struct directly refers to chunks in other strings, it does not own any memory itself. Thus, URIs can
       be parsed and/or resolved against a base URI in-place without allocating memory.

       <b>Data</b> <b>Fields:</b>
           <b>SerdChunk</b> <u>scheme</u> Scheme.

           <b>SerdChunk</b> <u>authority</u> Authority.

           <b>SerdChunk</b> <u>path_base</u> Path prefix if relative.

           <b>SerdChunk</b> <u>path</u> Path suffix.

           <b>SerdChunk</b> <u>query</u> Query.

           <b>SerdChunk</b> <u>fragment</u> Fragment.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>struct</b> <b>SerdEnvImpl</b> <b>SerdEnv</b>
       Environment.  Represents the state required to resolve a CURIE or relative URI, e.g. the base URI and set
       of namespace prefixes at a particular point.

   <b>typedef</b> <b>struct</b> <b>SerdReaderImpl</b> <b>SerdReader</b>
       RDF reader. Parses RDF by calling user-provided sink functions as input is consumed (much like an XML SAX
       parser).

   <b>typedef</b> <b>struct</b> <b>SerdWriterImpl</b> <b>SerdWriter</b>
       RDF writer. Provides a number of functions to  allow  writing  RDF  syntax  out  to  some  stream.  These
       functions  are  deliberately  compatible  with  the sink functions used by SerdReader, so a reader can be
       directly connected to a writer to re-serialise a document with minimal overhead.

   <b>typedef</b> <b>uint32_t</b> <b>SerdStatementFlags</b>
       Bitwise OR of SerdStatementFlag values.

   <b>typedef</b> <b>uint32_t</b> <b>SerdNodeFlags</b>
       Bitwise OR of SerdNodeFlag values.

   <b>typedef</b> <b>int(*</b> <b>SerdStreamErrorFunc)</b> <b>(void</b> <b>*stream)</b>
       Function to detect I/O stream errors. Identical semantics to ferror.

       <b>Returns</b>
           Non-zero if stream has encountered an error.

   <b>typedef</b> <b>size_t(*</b> <b>SerdSource)</b> <b>(void</b> <b>*buf,</b> <b>size_t</b> <b>size,</b> <b>size_t</b> <b>nmemb,</b> <b>void</b> <b>*stream)</b>
       Source function for raw string  input.  Identical  semantics  to  fread,  but  may  set  errno  for  more
       informative error reporting than supported by SerdStreamErrorFunc.

       <b>Parameters</b>
           <u>buf</u> Output buffer.
           <u>size</u> Size of a single element of data in bytes (always 1).
           <u>nmemb</u> Number of elements to read.
           <u>stream</u> Stream to read from (FILE* for fread).

       <b>Returns</b>
           Number of elements (bytes) read.

   <b>typedef</b> <b>size_t(*</b> <b>SerdSink)</b> <b>(const</b> <b>void</b> <b>*buf,</b> <b>size_t</b> <b>len,</b> <b>void</b> <b>*stream)</b>
       Sink function for raw string output.

   <b>typedef</b> <b>SerdStatus(*</b> <b>SerdErrorSink)</b> <b>(void</b> <b>*handle,</b> <b>const</b> <b>SerdError</b> <b>*error)</b>
       Sink (callback) for errors.

       <b>Parameters</b>
           <u>handle</u> Handle for user data.
           <u>error</u> Error description.

   <b>typedef</b> <b>SerdStatus(*</b> <b>SerdBaseSink)</b> <b>(void</b> <b>*handle,</b> <b>const</b> <b>SerdNode</b> <b>*uri)</b>
       Sink (callback) for base URI changes. Called whenever the base URI of the serialisation changes.

   <b>typedef</b> <b>SerdStatus(*</b> <b>SerdPrefixSink)</b> <b>(void</b> <b>*handle,</b> <b>const</b> <b>SerdNode</b> <b>*name,</b> <b>const</b> <b>SerdNode</b> <b>*uri)</b>
       Sink (callback) for namespace definitions. Called whenever a prefix is defined in the serialisation.

   <b>typedef</b> <b>SerdStatus(*</b> <b>SerdStatementSink)</b> <b>(void</b> <b>*handle,</b> <b>SerdStatementFlags</b> <b>flags,</b> <b>const</b> <b>SerdNode</b> <b>*graph,</b> <b>const</b>
       <b>SerdNode</b>  <b>*subject,</b>  <b>const</b>  <b>SerdNode</b> <b>*predicate,</b> <b>const</b> <b>SerdNode</b> <b>*object,</b> <b>const</b> <b>SerdNode</b> <b>*object_datatype,</b>
       <b>const</b> <b>SerdNode</b> <b>*object_lang)</b>
       Sink (callback) for statements. Called for every RDF statement in the serialisation.

   <b>typedef</b> <b>SerdStatus(*</b> <b>SerdEndSink)</b> <b>(void</b> <b>*handle,</b> <b>const</b> <b>SerdNode</b> <b>*node)</b>
       Sink (callback) for anonymous node end markers. This is called to indicate that the anonymous  node  with
       the  given value will no longer be referred to by any future statements (i.e. the anonymous serialisation
       of the node is finished).

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>SerdStatus</b>
       Return status code.

       <b>Enumerator</b>

       <u>SERD_SUCCESS</u>
              No error.

       <u>SERD_FAILURE</u>
              Non-fatal failure.

       <u>SERD_ERR_UNKNOWN</u>
              Unknown error.

       <u>SERD_ERR_BAD_SYNTAX</u>
              Invalid syntax.

       <u>SERD_ERR_BAD_ARG</u>
              Invalid argument.

       <u>SERD_ERR_NOT_FOUND</u>
              Not found.

       <u>SERD_ERR_ID_CLASH</u>
              Encountered clashing blank node IDs.

       <u>SERD_ERR_BAD_CURIE</u>
              Invalid CURIE (e.g. prefix does not exist)

       <u>SERD_ERR_INTERNAL</u>
              Unexpected internal error (should not happen)

   <b>enum</b> <b>SerdSyntax</b>
       RDF syntax type.

       <b>Enumerator</b>

       <u>SERD_TURTLE</u>
              Turtle - Terse RDF Triple Language (UTF-8).

       <b>See</b> <b>also</b>
           Turtle

       <u>SERD_NTRIPLES</u>
              NTriples - Line-based RDF triples (ASCII).

       <b>See</b> <b>also</b>
           NTriples

       <u>SERD_NQUADS</u>
              NQuads - Line-based RDF quads (UTF-8).

       <b>See</b> <b>also</b>
           NQuads

       <u>SERD_TRIG</u>
              TriG - Terse RDF quads (UTF-8).

       <b>See</b> <b>also</b>
           Trig

   <b>enum</b> <b>SerdStatementFlag</b>
       Flags indicating inline abbreviation information for a statement.

       <b>Enumerator</b>

       <u>SERD_EMPTY_S</u>
              Empty blank node subject.

       <u>SERD_EMPTY_O</u>
              Empty blank node object.

       <u>SERD_ANON_S_BEGIN</u>
              Start of anonymous subject.

       <u>SERD_ANON_O_BEGIN</u>
              Start of anonymous object.

       <u>SERD_ANON_CONT</u>
              Continuation of anonymous node.

       <u>SERD_LIST_S_BEGIN</u>
              Start of list subject.

       <u>SERD_LIST_O_BEGIN</u>
              Start of list object.

       <u>SERD_LIST_CONT</u>
              Continuation of list.

   <b>enum</b> <b>SerdType</b>
       Type of a syntactic RDF node. This is more precise than the type of an abstract  RDF  node.  An  abstract
       node is either a resource, literal, or blank. In syntax there are two ways to refer to a resource (by URI
       or  CURIE)  and  two  ways to refer to a blank (by ID or anonymously). Anonymous (inline) blank nodes are
       expressed using SerdStatementFlags rather than this type.

       <b>Enumerator</b>

       <u>SERD_NOTHING</u>
              The type of a nonexistent node. This type is useful as a sentinel, but is  never  emitted  by  the
              reader.

       <u>SERD_LITERAL</u>
              Literal value. A literal optionally has either a language, or a datatype (not both).

       <u>SERD_URI</u>
              URI  (absolute or relative). Value is an unquoted URI string, which is either a relative reference
              with  respect  to  the  current  base  URI  (e.g.   'foo/bar'),   or   an   absolute   URI   (e.g.
              '<a href="http://example.org/foo">http://example.org/foo</a>').

       <b>See</b> <b>also</b>
           RFC3986.

       <u>SERD_CURIE</u>
              CURIE,  a  shortened  URI.  Value is an unquoted CURIE string relative to the current environment,
              e.g. 'rdf:type'.

       <b>See</b> <b>also</b>
           CURIE Syntax 1.0

       <u>SERD_BLANK</u>
              A blank node. Value is a blank  node  ID,  e.g.  'id3',  which  is  meaningful  only  within  this
              serialisation.

       <b>See</b> <b>also</b>
           Turtle nodeID

   <b>enum</b> <b>SerdNodeFlag</b>
       Flags indicating certain string properties relevant to serialisation.

       <b>Enumerator</b>

       <u>SERD_HAS_NEWLINE</u>
              Contains line breaks ('\n' or '\r')

       <u>SERD_HAS_QUOTE</u>
              Contains quotes (''')

   <b>enum</b> <b>SerdStyle</b>
       Syntax style options. The style of the writer output can be controlled by ORing together values from this
       enumeration.  Note that some options are only supported for some syntaxes (e.g. NTriples does not support
       abbreviation and is always ASCII).

       <b>Enumerator</b>

       <u>SERD_STYLE_ABBREVIATED</u>
              Abbreviate triples when possible.

       <u>SERD_STYLE_ASCII</u>
              Escape all non-ASCII characters.

       <u>SERD_STYLE_RESOLVED</u>
              Resolve URIs against base URI.

       <u>SERD_STYLE_CURIED</u>
              Shorten URIs into CURIEs.

       <u>SERD_STYLE_BULK</u>
              Write output in pages.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>serd_free</b> <b>(void</b> <b>*</b> <b>ptr)</b>
       Free memory allocated by Serd. This function exists because some systems require memory  allocated  by  a
       library  to  be  freed  by  code in the same library. It is otherwise equivalent to the standard C free()
       function.

   <b>const</b> <b>uint8_t*</b> <b>serd_strerror</b> <b>(SerdStatus</b> <b>status)</b>
       Return a string describing a status code.

   <b>size_t</b> <b>serd_strlen</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>str,</b> <b>size_t</b> <b>*</b> <b>n_bytes,</b> <b>SerdNodeFlags</b> <b>*</b> <b>flags)</b>
       Measure a UTF-8 string.

       <b>Returns</b>
           Length of str in characters (except NULL).

       <b>Parameters</b>
           <u>str</u> A null-terminated UTF-8 string.
           <u>n_bytes</u> (Output) Set to the size of str in bytes (except NULL).
           <u>flags</u> (Output) Set to the applicable flags.

   <b>double</b> <b>serd_strtod</b> <b>(const</b> <b>char</b> <b>*</b> <b>str,</b> <b>char</b> <b>**</b> <b>endptr)</b>
       Parse a string to a double. The API of this function is identical to  the  standard  C  strtod  function,
       except  this  function  is  locale-independent  and  always matches the lexical format used in the Turtle
       grammar (the decimal point is always '.').

   <b>void*</b> <b>serd_base64_decode</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>str,</b> <b>size_t</b> <b>len,</b> <b>size_t</b> <b>*</b> <b>size)</b>
       Decode  a  base64  string.  This  function  can  be  used  to  deserialise  a  blob  node  created   with
       <b>serd_node_new_blob()</b>.

       <b>Parameters</b>
           <u>str</u> Base64 string to decode.
           <u>len</u> The length of str.
           <u>size</u> Set to the size of the returned blob in bytes.

       <b>Returns</b>
           A newly allocated blob which must be freed with <b>serd_free()</b>.

   <b>const</b> <b>uint8_t*</b> <b>serd_uri_to_path</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>uri)</b>
       Return  the  local  path  for  uri,  or  NULL if uri is not a file URI. Note this (inappropriately named)
       function only removes the file scheme if necessary, and returns uri unmodified if it is an absolute path.
       Percent encoding and other issues are not handled, to  properly  convert  a  file  URI  to  a  path,  use
       <b>serd_file_uri_parse()</b>.

   <b>uint8_t*</b> <b>serd_file_uri_parse</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>uri,</b> <b>uint8_t</b> <b>**</b> <b>hostname)</b>
       Get the unescaped path and hostname from a file URI.

       <b>Parameters</b>
           <u>uri</u> A file URI.
           <u>hostname</u> If non-NULL, set to the hostname, if present.

       <b>Returns</b>
           The path component of the URI.

       The returned path and *hostname must be freed with <b>serd_free()</b>.

   <b>bool</b> <b>serd_uri_string_has_scheme</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>utf8)</b>
       Return true iff utf8 starts with a valid URI scheme.

   <b>SerdStatus</b> <b>serd_uri_parse</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>utf8,</b> <b>SerdURI</b> <b>*</b> <b>out)</b>
       Parse utf8, writing result to out.

   <b>void</b> <b>serd_uri_resolve</b> <b>(const</b> <b>SerdURI</b> <b>*</b> <b>r,</b> <b>const</b> <b>SerdURI</b> <b>*</b> <b>base,</b> <b>SerdURI</b> <b>*</b> <b>t)</b>
       Set target t to reference r resolved against base.

       <b>See</b> <b>also</b>
           <a href="http://tools.ietf.org/html/rfc3986">http://tools.ietf.org/html/rfc3986</a>#section-5.2.2

   <b>size_t</b> <b>serd_uri_serialise</b> <b>(const</b> <b>SerdURI</b> <b>*</b> <b>uri,</b> <b>SerdSink</b> <b>sink,</b> <b>void</b> <b>*</b> <b>stream)</b>
       Serialise uri with a series of calls to sink.

   <b>size_t</b> <b>serd_uri_serialise_relative</b> <b>(const</b> <b>SerdURI</b> <b>*</b> <b>uri,</b> <b>const</b> <b>SerdURI</b> <b>*</b> <b>base,</b> <b>const</b> <b>SerdURI</b> <b>*</b> <b>root,</b> <b>SerdSink</b>
       <b>sink,</b> <b>void</b> <b>*</b> <b>stream)</b>
       Serialise  uri  relative to base with a series of calls to sink. The uri is written as a relative URI iff
       if it a child of base and root. The optional root parameter must be a prefix of base and can be used keep
       up-references ('../') within a certain namespace.

   <b>SerdNode</b> <b>serd_node_from_string</b> <b>(SerdType</b> <b>type,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>str)</b>
       Make a (shallow) node from str. This measures, but does not copy, str. No memory is allocated.

   <b>SerdNode</b> <b>serd_node_from_substring</b> <b>(SerdType</b> <b>type,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>str,</b> <b>size_t</b> <b>len)</b>
       Make a (shallow) node from a prefix of str.  This  measures,  but  does  not  copy,  str.  No  memory  is
       allocated. Note that the returned node may not be null terminated.

   <b>SerdNode</b> <b>serd_node_copy</b> <b>(const</b> <b>SerdNode</b> <b>*</b> <b>node)</b>
       Make a deep copy of node.

       <b>Returns</b>
           a node that the caller must free with <b>serd_node_free()</b>.

   <b>bool</b> <b>serd_node_equals</b> <b>(const</b> <b>SerdNode</b> <b>*</b> <b>a,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>b)</b>
       Return true iff a is equal to b.

   <b>SerdNode</b> <b>serd_node_new_uri_from_node</b> <b>(const</b> <b>SerdNode</b> <b>*</b> <b>uri_node,</b> <b>const</b> <b>SerdURI</b> <b>*</b> <b>base,</b> <b>SerdURI</b> <b>*</b> <b>out)</b>
       Simple wrapper for <b>serd_node_new_uri()</b> to resolve a URI node.

   <b>SerdNode</b> <b>serd_node_new_uri_from_string</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>str,</b> <b>const</b> <b>SerdURI</b> <b>*</b> <b>base,</b> <b>SerdURI</b> <b>*</b> <b>out)</b>
       Simple wrapper for <b>serd_node_new_uri()</b> to resolve a URI string.

   <b>SerdNode</b> <b>serd_node_new_file_uri</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>path,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>hostname,</b> <b>SerdURI</b> <b>*</b> <b>out,</b> <b>bool</b> <b>escape)</b>
       Create  a  new  file URI node from a file system path and optional hostname. Backslashes in Windows paths
       will be converted and '' will always be percent encoded. If escape is true, all other invalid  characters
       will be percent encoded as well.

       If path is relative, hostname is ignored. If out is not NULL, it will be set to the parsed URI.

   <b>SerdNode</b> <b>serd_node_new_uri</b> <b>(const</b> <b>SerdURI</b> <b>*</b> <b>uri,</b> <b>const</b> <b>SerdURI</b> <b>*</b> <b>base,</b> <b>SerdURI</b> <b>*</b> <b>out)</b>
       Create a new node by serialising uri into a new string.

       <b>Parameters</b>
           <u>uri</u> The URI to serialise.
           <u>base</u> Base URI to resolve uri against (or NULL for no resolution).
           <u>out</u> Set to the parsing of the new URI (i.e. points only to memory owned by the new returned node).

   <b>SerdNode</b> <b>serd_node_new_relative_uri</b> <b>(const</b> <b>SerdURI</b> <b>*</b> <b>uri,</b> <b>const</b> <b>SerdURI</b> <b>*</b> <b>base,</b> <b>const</b> <b>SerdURI</b> <b>*</b> <b>root,</b> <b>SerdURI</b>
       <b>*</b> <b>out)</b>
       Create a new node by serialising uri into a new relative URI.

       <b>Parameters</b>
           <u>uri</u> The URI to serialise.
           <u>base</u> Base URI to make uri relative to, if possible.
           <u>root</u> Root URI for resolution (see <b>serd_uri_serialise_relative()</b>).
           <u>out</u> Set to the parsing of the new URI (i.e. points only to memory owned by the new returned node).

   <b>SerdNode</b> <b>serd_node_new_decimal</b> <b>(double</b> <b>d,</b> <b>unsigned</b> <b>frac_digits)</b>
       Create  a  new node by serialising d into an xsd:decimal string. The resulting node will always contain a
       `.', start with a digit, and end with  a  digit  (i.e.  will  have  a  leading  and/or  trailing  `0'  if
       necessary).  It  will  never  be  in scientific notation. A maximum of frac_digits digits will be written
       after the decimal point, but trailing zeros will automatically be omitted (except one if  d  is  a  round
       integer).

       Note  that  about  16  and  8  fractional  digits are required to precisely represent a double and float,
       respectively.

       <b>Parameters</b>
           <u>d</u> The value for the new node.
           <u>frac_digits</u> The maximum number of digits after the decimal place.

   <b>SerdNode</b> <b>serd_node_new_integer</b> <b>(int64_t</b> <b>i)</b>
       Create a new node by serialising i into an xsd:integer string.

   <b>SerdNode</b> <b>serd_node_new_blob</b> <b>(const</b> <b>void</b> <b>*</b> <b>buf,</b> <b>size_t</b> <b>size,</b> <b>bool</b> <b>wrap_lines)</b>
       Create a node by serialising buf into an xsd:base64Binary string. This function can be  used  to  make  a
       serialisable node out of arbitrary binary data, which can be decoded using <b>serd_base64_decode()</b>.

       <b>Parameters</b>
           <u>buf</u> Raw binary input data.
           <u>size</u> Size of buf.
           <u>wrap_lines</u> Wrap lines at 76 characters to conform to RFC 2045.

   <b>void</b> <b>serd_node_free</b> <b>(SerdNode</b> <b>*</b> <b>node)</b>
       Free any data owned by node. Note that if node is itself dynamically allocated (which is not the case for
       nodes created internally by serd), it will not be freed.

   <b>SerdEnv*</b> <b>serd_env_new</b> <b>(const</b> <b>SerdNode</b> <b>*</b> <b>base_uri)</b>
       Create a new environment.

   <b>void</b> <b>serd_env_free</b> <b>(SerdEnv</b> <b>*</b> <b>env)</b>
       Free ns.

   <b>const</b> <b>SerdNode*</b> <b>serd_env_get_base_uri</b> <b>(const</b> <b>SerdEnv</b> <b>*</b> <b>env,</b> <b>SerdURI</b> <b>*</b> <b>out)</b>
       Get the current base URI.

   <b>SerdStatus</b> <b>serd_env_set_base_uri</b> <b>(SerdEnv</b> <b>*</b> <b>env,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>uri)</b>
       Set the current base URI.

   <b>SerdStatus</b> <b>serd_env_set_prefix</b> <b>(SerdEnv</b> <b>*</b> <b>env,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>name,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>uri)</b>
       Set a namespace prefix.

   <b>SerdStatus</b> <b>serd_env_set_prefix_from_strings</b> <b>(SerdEnv</b> <b>*</b> <b>env,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>name,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>uri)</b>
       Set a namespace prefix.

   <b>bool</b> <b>serd_env_qualify</b> <b>(const</b> <b>SerdEnv</b> <b>*</b> <b>env,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>uri,</b> <b>SerdNode</b> <b>*</b> <b>prefix,</b> <b>SerdChunk</b> <b>*</b> <b>suffix)</b>
       Qualify uri into a CURIE if possible.

   <b>SerdStatus</b>  <b>serd_env_expand</b> <b>(const</b> <b>SerdEnv</b> <b>*</b> <b>env,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>curie,</b> <b>SerdChunk</b> <b>*</b> <b>uri_prefix,</b> <b>SerdChunk</b> <b>*</b>
       <b>uri_suffix)</b>
       Expand curie. Errors: SERD_ERR_BAD_ARG if curie is not valid, or  SERD_ERR_BAD_CURIE  if  prefix  is  not
       defined in env.

   <b>SerdNode</b> <b>serd_env_expand_node</b> <b>(const</b> <b>SerdEnv</b> <b>*</b> <b>env,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>node)</b>
       Expand node, which must be a CURIE or URI, to a full URI. Returns null if node can not be expanded.

   <b>void</b> <b>serd_env_foreach</b> <b>(const</b> <b>SerdEnv</b> <b>*</b> <b>env,</b> <b>SerdPrefixSink</b> <b>func,</b> <b>void</b> <b>*</b> <b>handle)</b>
       Call func for each prefix defined in env.

   <b>SerdReader*</b>  <b>serd_reader_new</b>  <b>(SerdSyntax</b>  <b>syntax,</b>  <b>void</b>  <b>*</b> <b>handle,</b> <b>void(*)(void</b> <b>*)</b> <b>free_handle,</b> <b>SerdBaseSink</b>
       <b>base_sink,</b> <b>SerdPrefixSink</b> <b>prefix_sink,</b> <b>SerdStatementSink</b> <b>statement_sink,</b> <b>SerdEndSink</b> <b>end_sink)</b>
       Create a new RDF reader.

   <b>void</b> <b>serd_reader_set_strict</b> <b>(SerdReader</b> <b>*</b> <b>reader,</b> <b>bool</b> <b>strict)</b>
       Enable or disable strict parsing. The reader is non-strict (lax) by default,  which  will  tolerate  URIs
       with  invalid  characters.  Setting  strict  will  fail  when parsing such files. An error is printed for
       invalid input in either case.

   <b>void</b> <b>serd_reader_set_error_sink</b> <b>(SerdReader</b> <b>*</b> <b>reader,</b> <b>SerdErrorSink</b> <b>error_sink,</b> <b>void</b> <b>*</b> <b>error_handle)</b>
       Set a function to be called when errors occur during reading. The error_sink will be called  with  handle
       as its first argument. If no error function is set, errors are printed to stderr in GCC style.

   <b>void*</b> <b>serd_reader_get_handle</b> <b>(const</b> <b>SerdReader</b> <b>*</b> <b>reader)</b>
       Return the handle passed to <b>serd_reader_new()</b>.

   <b>void</b> <b>serd_reader_add_blank_prefix</b> <b>(SerdReader</b> <b>*</b> <b>reader,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>prefix)</b>
       Set  a  prefix  to  be  added to all blank node identifiers. This is useful when multiple files are to be
       parsed into the same output (e.g. a store, or other files). Since Serd preserves  blank  node  IDs,  this
       could  cause  conflicts  where  two  non-equivalent blank nodes are merged, resulting in corrupt data. By
       setting a unique blank node prefix for each parsed file, this can be avoided, while preserving blank node
       names.

   <b>void</b> <b>serd_reader_set_default_graph</b> <b>(SerdReader</b> <b>*</b> <b>reader,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>graph)</b>
       Set the URI of the default graph. If this is set, the reader will emit quads with the graph  set  to  the
       given  node  for  any statements that are not in a named graph (which is currently all of them since Serd
       currently does not support any graph syntaxes).

   <b>SerdStatus</b> <b>serd_reader_read_file</b> <b>(SerdReader</b> <b>*</b> <b>reader,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>uri)</b>
       Read a file at a given uri.

   <b>SerdStatus</b> <b>serd_reader_start_stream</b> <b>(SerdReader</b> <b>*</b> <b>reader,</b> <b>FILE</b> <b>*</b> <b>file,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>name,</b> <b>bool</b> <b>bulk)</b>
       Start an incremental read from a file handle. Iff bulk is true, file will be read a page at a time.  This
       is  more efficient, but uses a page of memory and means that an entire page of input must be ready before
       any callbacks will fire. To react as soon as input arrives, set bulk to false.

   <b>SerdStatus</b> <b>serd_reader_start_source_stream</b> <b>(SerdReader</b> <b>*</b> <b>reader,</b>  <b>SerdSource</b>  <b>read_func,</b>  <b>SerdStreamErrorFunc</b>
       <b>error_func,</b> <b>void</b> <b>*</b> <b>stream,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>name,</b> <b>size_t</b> <b>page_size)</b>
       Start an incremental read from a user-specified source. The read_func is guaranteed to only be called for
       page_size elements with size 1 (i.e. page_size bytes).

   <b>SerdStatus</b> <b>serd_reader_read_chunk</b> <b>(SerdReader</b> <b>*</b> <b>reader)</b>
       Read  a  single  'chunk'  of  data during an incremental read. This function will read a single top level
       description, and return. This may be a directive, statement, or several statements; essentially it  reads
       until a '.' is encountered. This is particularly useful for reading directly from a pipe or socket.

   <b>SerdStatus</b> <b>serd_reader_end_stream</b> <b>(SerdReader</b> <b>*</b> <b>reader)</b>
       Finish an incremental read from a file handle.

   <b>SerdStatus</b> <b>serd_reader_read_file_handle</b> <b>(SerdReader</b> <b>*</b> <b>reader,</b> <b>FILE</b> <b>*</b> <b>file,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>name)</b>
       Read file.

   <b>SerdStatus</b> <b>serd_reader_read_source</b> <b>(SerdReader</b> <b>*</b> <b>reader,</b> <b>SerdSource</b> <b>source,</b> <b>SerdStreamErrorFunc</b> <b>error,</b> <b>void</b> <b>*</b>
       <b>stream,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>name,</b> <b>size_t</b> <b>page_size)</b>
       Read a user-specified byte source.

   <b>SerdStatus</b> <b>serd_reader_read_string</b> <b>(SerdReader</b> <b>*</b> <b>reader,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>utf8)</b>
       Read utf8.

   <b>void</b> <b>serd_reader_free</b> <b>(SerdReader</b> <b>*</b> <b>reader)</b>
       Free reader.

   <b>SerdWriter*</b>  <b>serd_writer_new</b>  <b>(SerdSyntax</b>  <b>syntax,</b>  <b>SerdStyle</b> <b>style,</b> <b>SerdEnv</b> <b>*</b> <b>env,</b> <b>const</b> <b>SerdURI</b> <b>*</b> <b>base_uri,</b>
       <b>SerdSink</b> <b>ssink,</b> <b>void</b> <b>*</b> <b>stream)</b>
       Create a new RDF writer.

   <b>void</b> <b>serd_writer_free</b> <b>(SerdWriter</b> <b>*</b> <b>writer)</b>
       Free writer.

   <b>SerdEnv*</b> <b>serd_writer_get_env</b> <b>(SerdWriter</b> <b>*</b> <b>writer)</b>
       Return the env used by writer.

   <b>size_t</b> <b>serd_file_sink</b> <b>(const</b> <b>void</b> <b>*</b> <b>buf,</b> <b>size_t</b> <b>len,</b> <b>void</b> <b>*</b> <b>stream)</b>
       A convenience sink function for writing to a FILE*. This function can be used as a SerdSink when  writing
       to a FILE*. The stream parameter must be a FILE* opened for writing.

   <b>size_t</b> <b>serd_chunk_sink</b> <b>(const</b> <b>void</b> <b>*</b> <b>buf,</b> <b>size_t</b> <b>len,</b> <b>void</b> <b>*</b> <b>stream)</b>
       A  convenience sink function for writing to a string. This function can be used as a SerdSink to write to
       a <b>SerdChunk</b> which is resized as  necessary  with  realloc().  The  stream  parameter  must  point  to  an
       initialized   <b>SerdChunk</b>.   When   the   write   is   finished,   the  string  should  be  retrieved  with
       <b>serd_chunk_sink_finish()</b>.

   <b>uint8_t*</b> <b>serd_chunk_sink_finish</b> <b>(SerdChunk</b> <b>*</b> <b>stream)</b>
       Finish a serialisation to a chunk with <b>serd_chunk_sink()</b>. The  returned  string  is  the  result  of  the
       serialisation, which is NULL terminated (by this function) and owned by the caller.

   <b>void</b> <b>serd_writer_set_error_sink</b> <b>(SerdWriter</b> <b>*</b> <b>writer,</b> <b>SerdErrorSink</b> <b>error_sink,</b> <b>void</b> <b>*</b> <b>error_handle)</b>
       Set  a  function to be called when errors occur during writing. The error_sink will be called with handle
       as its first argument. If no error function is set, errors are printed to stderr.

   <b>void</b> <b>serd_writer_chop_blank_prefix</b> <b>(SerdWriter</b> <b>*</b> <b>writer,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>prefix)</b>
       Set a prefix to be removed from matching blank node identifiers.

   <b>SerdStatus</b> <b>serd_writer_set_base_uri</b> <b>(SerdWriter</b> <b>*</b> <b>writer,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>uri)</b>
       Set the current output base URI (and emit directive if applicable). Note  this  function  can  be  safely
       casted to SerdBaseSink.

   <b>SerdStatus</b> <b>serd_writer_set_root_uri</b> <b>(SerdWriter</b> <b>*</b> <b>writer,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>uri)</b>
       Set  the  current  root URI. The root URI should be a prefix of the base URI. The path of the root URI is
       the highest path any relative up-reference can refer to. For example, with root file:///foo/root and base
       file:///foo/root/base, file:///foo/root will be written as &lt;../&gt;, but file:///foo will  be  written  non-
       relatively  as  file:///foo.  If  the  root is not explicitly set, it defaults to the base URI, so no up-
       references will be created at all.

   <b>SerdStatus</b> <b>serd_writer_set_prefix</b> <b>(SerdWriter</b> <b>*</b> <b>writer,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>name,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>uri)</b>
       Set a namespace prefix (and emit directive if applicable). Note this function can  be  safely  casted  to
       SerdPrefixSink.

   <b>SerdStatus</b>  <b>serd_writer_write_statement</b>  <b>(SerdWriter</b>  <b>*</b>  <b>writer,</b>  <b>SerdStatementFlags</b>  <b>flags,</b> <b>const</b> <b>SerdNode</b> <b>*</b>
       <b>graph,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>subject,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>predicate,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>object,</b>  <b>const</b>  <b>SerdNode</b>  <b>*</b>
       <b>datatype,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>lang)</b>
       Write a statement. Note this function can be safely casted to SerdStatementSink.

   <b>SerdStatus</b> <b>serd_writer_end_anon</b> <b>(SerdWriter</b> <b>*</b> <b>writer,</b> <b>const</b> <b>SerdNode</b> <b>*</b> <b>node)</b>
       Mark the end of an anonymous node's description. Note this function can be safely casted to SerdEndSink.

   <b>SerdStatus</b> <b>serd_writer_finish</b> <b>(SerdWriter</b> <b>*</b> <b>writer)</b>
       Finish a write.

</pre><h4><b>Variable</b> <b>Documentation</b></h4><pre>
   <b>const</b> <b>SerdURI</b> <b>SERD_URI_NULL</b> <b>[static]</b>
       <b>Initial</b> <b>value:</b>

       = {
           {NULL, 0}, {NULL, 0}, {NULL, 0}, {NULL, 0}, {NULL, 0}, {NULL, 0}
       }

   <b>const</b> <b>SerdNode</b> <b>SERD_NODE_NULL</b> <b>=</b> <b>{</b> <b>NULL,</b> <b>0,</b> <b>0,</b> <b>0,</b> <b>SERD_NOTHING</b> <b>}</b> <b>[static]</b>
</pre><h4><b>Author</b></h4><pre>
       Generated by Doxygen for Serd from the source code and modified by Dennis Braun &lt;<a href="mailto:d_braun@kabelmail.de">d_braun@kabelmail.de</a>&gt;.

                                                  '2020-04-28'                                           <u><a href="../man3/SERD.3.html">SERD</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>