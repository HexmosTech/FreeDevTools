<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::Autoformat - Automatic text wrapping and reformatting</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-autoformat-perl">libtext-autoformat-perl_1.750000-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::Autoformat - Automatic text wrapping and reformatting

</pre><h4><b>VERSION</b></h4><pre>
       This document describes version 1.72 of Text::Autoformat

</pre><h4><b>SYNOPSIS</b></h4><pre>
        # Minimal use: read from STDIN, format to STDOUT...

           use Text::Autoformat;
           autoformat;

        # In-memory formatting...

           $formatted = autoformat $rawtext;

        # Configuration...

           $formatted = autoformat $rawtext, { %options };

        # Margins (1..72 by default)...

           $formatted = autoformat $rawtext, { left=&gt;8, right=&gt;70 };

        # Justification (left by default)...

           $formatted = autoformat $rawtext, { justify =&gt; 'left' };
           $formatted = autoformat $rawtext, { justify =&gt; 'right' };
           $formatted = autoformat $rawtext, { justify =&gt; 'full' };
           $formatted = autoformat $rawtext, { justify =&gt; 'centre' };

        # Filling (does so by default)...

           $formatted = autoformat $rawtext, { fill=&gt;0 };

        # Squeezing whitespace (does so by default)...

           $formatted = autoformat $rawtext, { squeeze=&gt;0 };

        # Select appropriate tabspacing (default is 8 spaces per tab):

           $formatted = autoformat $rawtext, { tabspace=&gt;4 };

        # Case conversions...

           $formatted = autoformat $rawtext, { case =&gt; 'lower' };
           $formatted = autoformat $rawtext, { case =&gt; 'upper' };
           $formatted = autoformat $rawtext, { case =&gt; 'sentence' };
           $formatted = autoformat $rawtext, { case =&gt; 'title' };
           $formatted = autoformat $rawtext, { case =&gt; 'highlight' };
           $formatted = autoformat $rawtext, { case =&gt; \&amp;my_case_func };

        # Selective reformatting

           $formatted = autoformat $rawtext, { ignore=&gt;qr/^\t/ };

</pre><h4><b>BACKGROUND</b></h4><pre>
   <b>The</b> <b>problem</b>
       Perl plaintext formatters just aren't smart enough. Given a typical piece of plaintext in need of
       formatting:

               In comp.lang.perl.misc you wrote:
               : &gt; &lt;CN = Clooless Noobie&gt; writes:
               : &gt; CN&gt; PERL sux because:
               : &gt; CN&gt;    * It doesn't have a switch statement and you have to put $
               : &gt; CN&gt;signs in front of everything
               : &gt; CN&gt;    * There are too many OR operators: having |, || and 'or'
               : &gt; CN&gt;operators is confusing
               : &gt; CN&gt;    * VB rools, yeah!!!!!!!!!
               : &gt; CN&gt; So anyway, how can I stop reloads on a web page?
               : &gt; CN&gt; Email replies only, thanks - I don't read this newsgroup.
               : &gt;
               : &gt; Begone, sirrah! You are a pathetic, Bill-loving, microcephalic
               : &gt; script-infant.
               : Sheesh, what's with this group - ask a question, get toasted! And how
               : *dare* you accuse me of Ianuphilia!

       both the venerable Unix fmt tool and Perl's standard Text::Wrap module produce:

               In comp.lang.perl.misc you wrote:  : &gt; &lt;CN = Clooless Noobie&gt;
               writes:  : &gt; CN&gt; PERL sux because:  : &gt; CN&gt;    * It doesn't
               have a switch statement and you have to put $ : &gt; CN&gt;signs in
               front of everything : &gt; CN&gt;    * There are too many OR
               operators: having |, || and 'or' : &gt; CN&gt;operators is confusing
               : &gt; CN&gt;    * VB rools, yeah!!!!!!!!!  : &gt; CN&gt; So anyway, how
               can I stop reloads on a web page?  : &gt; CN&gt; Email replies only,
               thanks - I don't read this newsgroup.  : &gt; : &gt; Begone, sirrah!
               You are a pathetic, Bill-loving, microcephalic : &gt;
               script-infant.  : Sheesh, what's with this group - ask a
               question, get toasted! And how : *dare* you accuse me of
               Ianuphilia!

       Other formatting modules -- such as Text::Correct and Text::Format -- provide more control over their
       output, but produce equally poor results when applied to arbitrary input. They simply don't understand
       the structural conventions of the text they're reformatting.

   <b>The</b> <b>solution</b>
       The Text::Autoformat module provides a subroutine named "autoformat" that wraps text to specified
       margins. However, "autoformat" reformats its input by analysing the text's structure, so it wraps the
       above example like so:

               In comp.lang.perl.misc you wrote:
               : &gt; &lt;CN = Clooless Noobie&gt; writes:
               : &gt; CN&gt; PERL sux because:
               : &gt; CN&gt;    * It doesn't have a switch statement and you
               : &gt; CN&gt;      have to put $ signs in front of everything
               : &gt; CN&gt;    * There are too many OR operators: having |, ||
               : &gt; CN&gt;      and 'or' operators is confusing
               : &gt; CN&gt;    * VB rools, yeah!!!!!!!!! So anyway, how can I
               : &gt; CN&gt;      stop reloads on a web page? Email replies
               : &gt; CN&gt;      only, thanks - I don't read this newsgroup.
               : &gt;
               : &gt; Begone, sirrah! You are a pathetic, Bill-loving,
               : &gt; microcephalic script-infant.
               : Sheesh, what's with this group - ask a question, get toasted!
               : And how *dare* you accuse me of Ianuphilia!

       Note that the various quoting conventions have been observed. In fact, their structure has been used to
       determine where some paragraphs begin.  Furthermore "autoformat" correctly distinguished between the
       leading '*' bullets of the nested list (which were outdented) and the leading emphatic '*' of "*dare*"
       (which was inlined).

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>Paragraphs</b>
       The fundamental task of the "autoformat" subroutine is to identify and rearrange independent paragraphs
       in a text. Paragraphs typically consist of a series of lines containing at least one non-whitespace
       character, followed by one or more lines containing only optional whitespace.  This is a more liberal
       definition than many other formatters use: most require an empty line to terminate a paragraph.
       Paragraphs may also be denoted by bulleting, numbering, or quoting (see the following sections).

       Once a paragraph has been isolated, "autoformat" fills and re-wraps its lines according to the margins
       that are specified in its argument list.  These are placed after the text to be formatted, in a hash
       reference:

               $tidied = autoformat($messy, {left=&gt;20, right=&gt;60});

       By default, "autoformat" uses a left margin of 1 (first column) and a right margin of 72.

       You can also control whether (and how) "autoformat" breaks words at the end of a line, using the 'break'
       option:

           # Turn off all hyphenation
           use Text::Autoformat qw(autoformat break_wrap);
               $tidied = autoformat($messy, {break=&gt;break_wrap});

           # Default hyphenation
           use Text::Autoformat qw(autoformat break_at);
               $tidied = autoformat($messy, {break=&gt;break_at('-')});

           # Use TeX::Hyphen module's hyphenation (module must be installed)
           use Text::Autoformat qw(autoformat break_TeX);
               $tidied = autoformat($messy, {break=&gt;break_TeX});

       Normally, "autoformat" only reformats the first paragraph it encounters, and leaves the remainder of the
       text unaltered. This behaviour is useful because it allows a one-liner invoking the subroutine to be
       mapped onto a convenient keystroke in a text editor, to provide one-paragraph-at-a-time reformatting:

               % cat .exrc

               map f !Gperl -MText::Autoformat -e'autoformat'

       (Note that to facilitate such one-liners, if "autoformat" is called in a void context without any text
       data, it takes its text from "STDIN" and writes its result to "STDOUT").

       To enable "autoformat" to rearrange the entire input text at once, the "all" argument is used:

               $tidied_all = autoformat($messy, {left=&gt;20, right=&gt;60, all=&gt;1});

       "autoformat" can also be directed to selectively reformat paragraphs, using the "ignore" argument:

               $tidied_some = autoformat($messy, {ignore=&gt;qr/^[ \t]/});

       The value for "ignore" may be a "qr"'d regex, a subroutine reference, or the special string 'indented'.

       If a regex is specified, any paragraph whose original text matches that regex will not be reformatted
       (i.e. it will be printed verbatim).

       If a subroutine is specified, that subroutine will be called once for each paragraph (with $_ set to the
       paragraph's text). The subroutine is expected to return a true or false value. If it returns true, the
       paragraph will not be reformatted.

       If the value of the "ignore" option is the string 'indented', "autoformat" will ignore any paragraph in
       which <u>every</u> line begins with a whitespace.

       You may also specify multiple "ignore" options by including them in an array-ref:

               $tidied_mesg = autoformat($messy, {ignore=&gt;[qr/1/,'indented']});

       One other special case of ignorance is ignoring mail headers and signature.  This option is specified
       using the "mail" argument:

               $tidied_mesg = autoformat($messy_mesg, {mail=&gt;1});

       Note that the "ignore" or "mail" options automatically imply "all".

   <b>Bulleting</b> <b>and</b> <b>(re-)numbering</b>
       Often plaintext will include lists that are either:

               * bulleted,
               * simply numbered (i.e. 1., 2., 3., etc.), or
               * hierarchically numbered (1, 1.1, 1.2, 1.3, 2, 2.1. and so forth).

       In such lists, each bulleted item is implicitly a separate paragraph, and is formatted individually, with
       the appropriate indentation:

               * bulleted,
               * simply numbered (i.e. 1., 2., 3.,
                 etc.), or
               * hierarchically numbered (1, 1.1,
                 1.2, 1.3, 2, 2.1. and so forth).

       More importantly, if the points are numbered, the numbering is checked and reordered. For example, a list
       whose points have been rearranged:

               1. Analyze problem
               3. Design algorithm
               1. Code solution
               5. Test
               4. Ship

       would be renumbered automatically by "autoformat":

               1. Analyze problem
               2. Design algorithm
               3. Code solution
               4. Test
               5. Ship

       The same reordering would be performed if the "numbering" was by letters ("a." "b." "c." etc.) or Roman
       numerals ("i." "ii." "iii.)" or by some combination of these ("1a." "1b." "2a." "2b." etc.) Handling
       disordered lists of letters and Roman numerals presents an interesting challenge. A list such as:

               A. Put cat in box.
               D. Close lid.
               E. Activate Geiger counter.

       should be reordered as "A." "B." "C.," whereas:

               I. Put cat in box.
               D. Close lid.
               XLI. Activate Geiger counter.

       should be reordered "I." "II." "III."

       The "autoformat" subroutine solves this problem by always interpreting alphabetic bullets as being
       letters, unless the full list consists only of valid Roman numerals, at least one of which is two or more
       characters long.

       Note that renumbering starts at the first number actually given, rather than restarting at the first
       possible number. To renumber from 1 (or A.) you must change the first numbered bullet to that.

       If automatic renumbering isn't wanted, just specify the 'renumber' option with a false value.

       Note that normal numbers above 1000 at the start of a line are no longer considered to be paragraph
       numbering. Numbered paragraphs running that high are exceptionally rare, and much rarer than paragraphs
       that look like these:

               Although it has long been popular (especially in the year
               2001) to point out that we now live in the Future, many
               of the promised miracles of Future Life have failed to
               eventuate. This is a new phenomenon (it didn't happen in
               1001) because the idea that the future might be different
               is a new phenomenon.

       which the former numbering rules caused to be formatted like this:

               Although it has long been popular (especially in the year

               2001) to point out that we now live in the Future, many of the
                     promised miracles of Future Life have failed to eventuate.
                     This is a new phenomenon (it didn't happen in

               2002) because the idea that the future might be different is a
                     new phenomenon.

       but which are now formatted:

               Although it has long been popular (especially in the year 2001)
               to point out that we now live in the Future, many of the
               promised miracles of Future Life have failed to eventuate. This
               is a new phenomenon (it didn't happen in 1001) because the idea
               that the future might be different is a new phenomenon.

       If you want numbers less than 1000 (or other characters strings currently treated as bullets) to be
       ignored in this way, you can turn of list formatting entirely by setting the 'lists' option to a false
       value.

       You can also select which kinds of lists are recognized, by using a string as the value of lists:

           # Don't recognize Roman numerals or alphabetics as list markers...
           autoformat { lists =&gt; 'number, bullet' }, $text;

           # Don't recognize bullets or numbers as list markers...
           autoformat { lists =&gt; 'roman, alpha' }, $text;

           # Recognize everything except Roman numerals as list markers...
           autoformat { lists =&gt; 'number, bullet, alpha' }, $text;

       The string should contain one or more of the following words: "number", "bullet", "alpha", "roman".
       "autoformat()" will ignore any list type that doesn't appear in the 'lists' string.

   <b>Quoting</b>
       Another case in which contiguous lines may be interpreted as belonging to different paragraphs, is where
       they are quoted with distinct quoters.  For example:

               : &gt; CN&gt; So anyway, how can I stop reloads on a web page? Email
               : &gt; CN&gt; replies only, thanks - I don't read this newsgroup.
               : &gt; Begone, sirrah! You are a pathetic, Bill-loving,
               : &gt; microcephalic script-infant.
               : Sheesh, what's with this group - ask a question, get toasted!
               : And how *dare* you accuse me of Ianuphilia!

       "autoformat" recognizes the various quoting conventions used in this example and treats it as three
       paragraphs to be independently reformatted.

       You may also override the default set of recognized quoters by specifying a 'quoter' argument when
       calling "autoformat()". For example, to format lines such as:

               // This is a comment
               // in the standard C(++)
               // comment-to-EOL
               // format

       specify:

           autoformat($text, { quoter =E&lt;gt&gt; qr{//} })

       Instead of completely replacing the existing set of quoters, you can <u>extend</u> them by specifying a pattern
       that includes the metasequence "&lt;QUOTER&gt;", which is then replaced by the module's standard pattern for
       quoters. So, for example, to add "//" to the set of existing quoters:

           autoformat($text, { quoter =E&lt;gt&gt; qr{//|&lt;QUOTER&gt;} })

       Block quotations present a different challenge. A typical formatter would render the following quotation:

               "We are all of us in the gutter, but some of us are looking at
                the stars"
                                       -- Oscar Wilde

       like so:

               "We are all of us in the gutter, but some of us are looking at
               the stars" -- Oscar Wilde

       "autoformat" recognizes the quotation structure by matching the following regular expression against the
       text component of each paragraph:

               / \A(\s*) # leading whitespace for quotation (["']|``) # opening
               quotemark (.*) # quotation (''|\2) # closing quotemark \s*?\n #
               trailing whitespace after quotation (\1[ ]+) # leading
               whitespace for attribution
                                       #   (must be indented more than
                                       #   quotation)
                 (--|-) # attribution introducer ([^\n]*?\n) # first
                 attribution line ((\5[^\n]*?$)*) # other attribution lines
                                       #   (indented no less than first line)
                 \s*\Z # optional whitespace to end of paragraph /xsm

       When reformatted (see below), the indentation and the attribution structure will be preserved:

               "We are all of us in the gutter, but some of us are looking
                at the stars"
                                       -- Oscar Wilde

   <b>Widow</b> <b>control</b>
       Note that in the last example, "autoformat" broke the line at column 68, four characters earlier than it
       should have. It did so because, if the full margin width had been used, the formatting would have left
       the last two words by themselves on an oddly short last line:

               "We are all of us in the gutter, but some of us are looking at
               the stars"

       This phenomenon is known as "widowing" and is heavily frowned upon in typesetting circles. It looks ugly
       in plaintext too, so "autoformat" avoids it by stealing extra words from earlier lines in a paragraph, so
       as to leave enough for a reasonable last line. The heuristic used is that final lines must be at least 10
       characters long (though this number may be adjusted by passing a "widow =&gt; <u>minlength</u>" argument to
       "autoformat").

       If the last line is too short, the paragraph's right margin is reduced by one column, and the paragraph
       is reformatted. This process iterates until either the last line exceeds nine characters or the margins
       have been narrowed by 10% of their original separation. In the latter case, the reformatter gives up and
       uses its original formatting.

   <b>Justification</b>
       The "autoformat" subroutine also takes a named argument: "{justify =&gt; <u>type</u>}", which specifies how each
       paragraph is to be justified.  The options are: 'left' (the default), "'right'," 'centre' (or 'center'),
       and 'full'. These act on the complete paragraph text (but <u>not</u> on any quoters before that text). For
       example, with 'right' justification:

               R3&gt;     Now is the Winter of our discontent made
               R3&gt; glorious Summer by this son of York. And all
               R3&gt; the clouds that lour'd upon our house In the
               R3&gt;              deep bosom of the ocean buried.

       Full justification is interesting in a fixed-width medium like plaintext because it usually results in
       uneven spacing between words. Typically, formatters provide this by distributing the extra spaces into
       the first available gaps of each line:

               R3&gt; Now  is  the  Winter  of our discontent made
               R3&gt; glorious Summer by this son of York. And all
               R3&gt; the  clouds  that  lour'd  upon our house In
               R3&gt; the deep bosom of the ocean buried.

       This produces a rather jarring visual effect, so "autoformat" reverses the strategy and inserts extra
       spaces at the end of lines:

               R3&gt; Now is the  Winter of  our  discontent  made
               R3&gt; glorious Summer by this son of York. And all
               R3&gt; the clouds that lour'd  upon  our  house  In
               R3&gt; the deep bosom of the ocean buried.

       Most readers find this less disconcerting.

   <b>Implicit</b> <b>centring</b>
       Even if explicit centring is not specified, "autoformat" will attempt to automatically detect centred
       paragraphs and preserve their justification. It does this by examining each line of the paragraph and
       asking: "if this line were part of a centred paragraph, where would the centre line have been?"

       The answer can be determined by adding the length of leading whitespace before the first word, plus half
       the length of the full set of words on the line. That is, for a single line:

               $line =~ /^(\s*)(.*?)(\s*)$/ $centre =
               length($1)+0.5*length($2);

       By making the same estimate for every line, and then comparing the estimates, it is possible to deduce
       whether all the lines are centred with respect to the same axis of symmetry (with an allowance of ±1 to
       cater for the inevitable rounding when the centre positions of even-length rows were originally
       computed). If a common axis of symmetry is detected, "autoformat" assumes that the lines are supposed to
       be centred, and switches to centre-justification mode for that paragraph.

       Note that this behaviour can to switched off entirely by setting the "autocentre" argument false.

   <b>Case</b> <b>transformations</b>
       The "autoformat" subroutine can also optionally perform case conversions on the text it processes. The
       "{case =&gt; <u>type</u>}" argument allows the user to specify six different conversions:

       'upper'
           This mode unconditionally converts every letter in the reformatted text to upper-case;

       'lower'
           This mode unconditionally converts every letter in the reformatted text to lower-case;

       'sentence'
           This  mode  attempts  to  generate  correctly-cased sentences from the input text. That is, the first
           letter after a sentence-terminating punctuator is converted to upper-case. Then, each subsequent word
           in the sentence is converted to lower-case, unless that word is  originally  mixed-case  or  contains
           punctuation. For example, under "{case =&gt; 'sentence'}":

                   'POVERTY, MISERY, ETC. are the lot of the PhD candidate. alas!'

           becomes:

                   'Poverty, misery, etc. are the lot of the PhD candidate. Alas!'

           Note  that  "autoformat"  is  clever  enough to recognize that the period after abbreviations such as
           "etc." is not a sentence terminator.

           If the argument is specified as 'sentence ' (with one or more trailing whitespace  characters)  those
           characters are used to replace the single space that appears at the end of the sentence. For example,
           "autoformat($text, {case=&gt;'sentence '}") would produce:

                   'Poverty, misery, etc. are the lot of the PhD candidate. Alas!'

       'title'
           This mode behaves like 'sentence' except that the first letter of <u>every</u> word is capitalized:

                   'What I Did On My Summer Vacation In Monterey'

       'highlight'
           This mode behaves like 'title' except that trivial words are not capitalized:

                   'What I Did on my Summer Vacation in Monterey'

       "sub{...}"
           If the argument for 'case' is a subroutine reference, that subroutine is applied to each word and the
           result replaces the word in the text.

           For example, to convert a string to hostage-case:

               my $ransom_note = sub {
                   return join "",                    # ^  Reconcatenate
                          map {/[aeiou]/i ? lc : uc}  # |  uPPeR aND LoWeR each
                          split //,                   # |  Break into chars
                          shift;                      # |  Take argument
               };

               $text = autoformat($text, {case =&gt; $ransom_note });
               # "FoR eXaMPLe, To CoNVeRT a STRiNG To HoSTaGe-CaSe:"

           Or to highlight particular words:

               my @SPECIAL = qw( perl camel wall );
               sub highlight_specials {
                   my ($word) = @_;
                   return $word ~~ @SPECIAL ? uc($word) : $word;
               }

               $text = autoformat($text, {case =&gt; \&amp;highlight_specials});
               # "It is easier for a CAMEL to pass through a WALL of PERL..."

   <b>Selective</b> <b>reformatting</b>
       You  can  select which paragraphs "autoformat" actually reformats (or, rather, those it <u>doesn't</u> reformat)
       using the "ignore" flag.

       For example:

               # Reformat all paras except those containing "verbatim"...
               print autoformat { all =&gt; 1, ignore =&gt; qr/verbatim/i }, $text;

               # Reformat all paras except those less that 3 lines long...
               print autoformat { all =&gt; 1, ignore =&gt; sub { tr/\n/\n/ &lt; 3
               } }, $text;

               # Reformat all paras except those that are indented...
               print autoformat { all =&gt; 1, ignore =&gt; qr/^\s/m }, $text;

               # Reformat all paras except those that are indented (easier)...
               print autoformat { all =&gt; 1, ignore =&gt; 'indented' }, $text;

   <b>Handling</b> <b>tabs</b>
       Text::Autoformat replaces any tabs in the text it's formatting with  the  appropriate  number  of  spaces
       (using  Text::Tabs  to  do  its  dirty  work). It normally assumes that each tab is equivalent to 8 space
       characters, but you can change that default using the 'tabspace' option:

               print autoformat { tabspace =&gt; 4 }, $text;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Text::Reform - provides functions for manual text wrapping and reformatting.

       Text::Aligner - provides a single function for justifying strings according to various styles.

       Text::Format - a class that provides methods for formatting text in various ways.

       Data::Formatter::Text - format various Perl data structures as text, in different ways according  to  the
       type of data.

</pre><h4><b>REPOSITORY</b></h4><pre>
       &lt;https://github.com/neilb/Text-Autoformat&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Damian Conway (<a href="mailto:damian@conway.org">damian@conway.org</a>)

</pre><h4><b>BUGS</b></h4><pre>
       There  are  undoubtedly  serious  bugs  lurking  somewhere  in  code this funky :-) Bug reports and other
       feedback are most welcome.

</pre><h4><b>LICENCE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 1997-2007, Damian Conway "&lt;<a href="mailto:DCONWAY@CPAN.org">DCONWAY@CPAN.org</a>&gt;". All rights reserved.

       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself. See perlartistic.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       BECAUSE  THIS  SOFTWARE  IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE, TO THE EXTENT
       PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS  AND/OR  OTHER
       PARTIES  PROVIDE  THE  SOFTWARE  "AS  IS"  WITHOUT  WARRANTY  OF  ANY  KIND, EITHER EXPRESSED OR IMPLIED,
       INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS  FOR  A  PARTICULAR
       PURPOSE.  THE  ENTIRE  RISK  AS  TO  THE  QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE
       SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

       IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER,  OR  ANY
       OTHER  PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
       TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING  OUT  OF
       THE  USE  OR  INABILITY  TO  USE  THE  SOFTWARE  (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
       RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE  TO  OPERATE
       WITH  ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
       DAMAGES.

perl v5.36.0                                       2022-08-28                              <u>Text::<a href="../man3pm/Autoformat.3pm.html">Autoformat</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>