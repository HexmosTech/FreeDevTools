<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrappy - The All Powerful Web Spidering, Scraping, Creeping Crawling Framework</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libscrappy-perl">libscrappy-perl_0.94112090-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Scrappy - The All Powerful Web Spidering, Scraping, Creeping Crawling Framework

</pre><h4><b>VERSION</b></h4><pre>
       version 0.94112090

</pre><h4><b>SYNOPSIS</b></h4><pre>
           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>
           use Scrappy;

           my  $scraper = Scrappy-&gt;new;

               $scraper-&gt;crawl('<a href="http://search.cpan.org/recent">http://search.cpan.org/recent</a>',
                   '/recent' =&gt; {
                       '#cpansearch li a' =&gt; sub {
                           print $_[1]-&gt;{href}, "\n";
                       }
                   }
               );

       And now manually, ... without crawl, the above is similar to the following ...

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>
           use Scrappy;

           my  $scraper = Scrappy-&gt;new;

               if ($scraper-&gt;get($url)-&gt;page_loaded) {
                   $scraper-&gt;select('#cpansearch li a')-&gt;each(sub{
                       print shift-&gt;{href}, "\n";
                   });
               }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Scrappy is an easy (and hopefully fun) way of scraping, spidering, and/or harvesting information from web
       pages, web services, and more. Scrappy is a feature rich, flexible, intelligent web automation tool.

       Scrappy (pronounced Scrap+Pee) == 'Scraper Happy' or 'Happy Scraper'; If you like you may call it Scrapy
       (pronounced Scrape+Pee) although Python has a web scraping framework by that name and this module is not
       a port of that one.

   <b>FEATURES</b>
       Scrappy provides a framework containing all the tools necessary to create a simple yet powerful web
       scraper. At its core, Scrappy loads an array of features for access control, event logging, session
       handling, url matching, web request and response handling, proxy management, web scraping, and
       downloading.

       Furthermore, Scrappy provides a simple Moose-based plugin system that allows Scrappy to be easily
       extended.

           my  $scraper = Scrappy-&gt;new;

               $scraper-&gt;control;      # Scrappy::Scraper::Control (access control)
               $scraper-&gt;parser;       # Scrappy::Scraper::Parser (web scraper)
               $scraper-&gt;user_agent;   # Scrappy::Scraper::UserAgent (user-agent tools)
               $scraper-&gt;logger;       # Scrappy::Logger (event logger)
               $scraper-&gt;queue;        # Scrappy::Queue (flow control for loops)
               $scraper-&gt;session;      # Scrappy::Session (session management)

       Please see the METHODS section for a more in-depth look at all Scrappy functionality.

   <b>ATTRIBUTES</b>
       The following is a list of object attributes available with every Scrappy instance, attributes always
       return an instance of the class they represent.

       <u>content</u>

       The content attribute holds the HTTP::Response object of the current request.  Returns undef if no page
       has been successfully fetched.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;content;

       <u>control</u>

       The control attribute holds the Scrappy::Scraper::Control object which is used the provide access conrtol
       to the scraper.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;control;

               ... $scraper-&gt;control-&gt;restrict('google.com');
               ... $scraper-&gt;control-&gt;allow('cpan.org');
               ... if $scraper-&gt;control-&gt;is_allowed($url);

       <u>debug</u>

       The debug attribute holds a boolean which controls whether event logs are captured.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;<a href="../man1/debug.1.html">debug</a>(1);

       <u>logger</u>

       The logger attribute holds the Scrappy::Logger object which is used to provide event logging capabilities
       to the scraper.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;logger;

       <u>parser</u>

       The parser attribute holds the Scrappy::Scraper::Parser object which is used to scrape html data from the
       specified source material.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;parser;

       <u>plugins</u>

       The plugins attribute holds the Scrappy::Plugin object which is an interface used to load plugins.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;plugins;

       <u>queue</u>

       The queue attribute holds the Scrappy::Queue object which is used to provide flow-control for the
       standard loop approach to crawling.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;queue;

       <u>session</u>

       The session attribute holds the Scrappy::Session object which is used to provide session support and
       persistent data across executions.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;session;

       <u>user_agent</u>

       The user_agent attribute holds the Scrappy::Scraper::UserAgent object which is used to set and manipulate
       the user-agent header of the scraper.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;user_agent;

       <u>worker</u>

       The worker attribute holds the WWW::Mechanize object which is used navigate web pages and provide request
       and response header information.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;worker;

</pre><h4><b>METHODS</b></h4><pre>
   <b>back</b>
       The back method is the equivalent of hitting the "back" button in a browser, it returns the previous page
       (response) and returns that URL, it will not backtrack beyond the first request.

           my  $scraper = Scrappy-&gt;new;

               $scraper-&gt;get(...);
               ...
               $scraper-&gt;get(...);
               ...
               my $last_url = $scraper-&gt;back;

   <b>cookies</b>
       The cookies method returns an HTTP::Cookie object. Note! Cookies can be made persistent by enabling
       session-support. Session-support is enable by simply specifying a file to be used.

           my  $scraper = Scrappy-&gt;new;

               $scraper-&gt;session-&gt;write('session.yml'); # enable session support
               $scraper-&gt;get(...);
           my  $cookies = $scraper-&gt;cookies;

   <b>crawl</b>
       The crawl method is very useful when it is desired to crawl an entire website or at-least partially, it
       automates the tasks of creating a queue, fetching and parsing html pages, and establishing simple flow-
       control. See the SYNOPSIS for a simplified example, ... the following is a more complex example.

           my  $scrappy = Scrappy-&gt;new;

               $scrappy-&gt;crawl('<a href="http://search.cpan.org/recent">http://search.cpan.org/recent</a>',
                   '/recent' =&gt; {
                       '#cpansearch li a' =&gt; sub {
                           my ($self, $item) = @_;
                           # follow all recent modules from search.cpan.org
                           $self-&gt;queue-&gt;add($item-&gt;{href});
                       }
                   },
                   '/~:author/:name-:version/' =&gt; {
                       'body' =&gt; sub {
                           my ($self, $item, $args) = @_;

                           my $reviews = $self
                           -&gt;select('.box table tr')-&gt;<a href="../man3/focus.3.html">focus</a>(3)-&gt;select('td.cell small a')
                           -&gt;data-&gt;[0]-&gt;{text};

                           $reviews = $reviews =~ /\d+ Reviews/ ?
                               $reviews : '0 reviews';

                           print "found $args-&gt;{name} version $args-&gt;{version} ".
                               "[$reviews] by $args-&gt;{author}\n";
                       }
                   }
               );

   <b>domain</b>
       The domain method returns the domain host of the current page. Local pages, e.g.
       file:///this/that/the_other will return undef.

           my  $scraper = Scrappy-&gt;new;

               $scraper-&gt;get('<a href="http://www.google.com">http://www.google.com</a>');
               print $scraper-&gt;domain; # print www.google.com

   <b>download</b>
       The download method is passed a URL, a Download Directory Path and a optionally a File Path, then it will
       follow the link and store the response contents into the specified file without leaving the current page.
       Basically it downloads the contents of the request (especially when the request pushes a file download).
       If a File Path is not specified, Scrappy will attempt to name the file automatically resorting to a
       random 6-charater string only if all else fails, then returns to the originating page.

           my  $scaper = Scrappy-&gt;new;
           my  $requested_url = '...';

               $scraper-&gt;download($requested_url, '<a href="file:/tmp">/tmp</a>');

               # supply your own file name
               $scraper-&gt;download($requested_url, '<a href="file:/tmp">/tmp</a>', 'somefile.txt');

   <b>dumper</b>
       The dumper method is a convenience feature that passes the passed-in objects to Data::Dumper which in
       turn returns a stringified representation of that object/data-structure.

           my  $scaper = Scrappy-&gt;new;
           my  $requested_url = '...';

               $scraper-&gt;get($requested_url);

           my  $data = $scraper-&gt;select('//a[@href]')-&gt;data;

           # print out the scraped data
           print $scraper-&gt;dumper($data);

   <b>form</b>
       The form method is used to submit a form on the current page.

           my  $scraper = Scrappy-&gt;new;

               $scraper-&gt;form(fields =&gt; {
                   username =&gt; 'mrmagoo',
                   password =&gt; 'foobarbaz'
               });

               # or more specifically, for pages with multiple forms

               $scraper-&gt;form(form_name =&gt; 'login_form', fields =&gt; {
                   username =&gt; 'mrmagoo',
                   password =&gt; 'foobarbaz'
               });

               $scraper-&gt;form(form_number =&gt; 1, fields =&gt; {
                   username =&gt; 'mrmagoo',
                   password =&gt; 'foobarbaz'
               });

   <b>get</b>
       The get method takes a URL or URI object, fetches a web page and returns the Scrappy object.

           my  $scraper = Scrappy-&gt;new;

           if ($scraper-&gt;get($new_url)-&gt;page_loaded) {
               ...
           }

           # $self-&gt;content has the HTTP::Response object

   <b>log</b>
       The log method logs an event with the event logger.

           my  $scraper = Scrappy-&gt;new;

               $scraper-&gt;<a href="../man1/debug.1.html">debug</a>(1); # unnecessary, on by default
               $scraper-&gt;logger-&gt;<a href="../man1/verbose.1.html">verbose</a>(1); # more detailed log

               $scraper-&gt;log('error', 'Somthing bad happened');

               ...

               $scraper-&gt;log('info', 'Somthing happened');
               $scraper-&gt;log('warn', 'Somthing strange happened');
               $scraper-&gt;log('coolness', 'Somthing cool happened');

       Note! Event logs are always recorded but never automatically written to a file unless explicitly told to
       do so using the following:

               $scraper-&gt;logger-&gt;write('log.yml');

   <b>page_content_type</b>
       The page_content_type method returns the content_type of the current page.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;get('<a href="http://www.google.com/">http://www.google.com/</a>');
               print $scraper-&gt;page_content_type; # prints text/html

   <b>page_data</b>
       The page_data method returns the HTML content of the current page, additionally this method when passed a
       string with HTML markup, updates the content of the current page with that data and returns the modified
       content.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;get(...);
           my  $html = $scraper-&gt;page_data;

   <b>page_ishtml</b>
       The page_ishtml method returns true/false based on whether our content is HTML, according to the HTTP
       headers.

           my $scraper = Scrappy-&gt;new;

               $scraper-&gt;get($requested_url);
               if ($scraper-&gt;is_html) {
                   ...
               }

   <b>page_loaded</b>
       The page_loaded method returns true/false based on whether the last request was successful.

           my $scraper = Scrappy-&gt;new;

               $scraper-&gt;get($requested_url);
               if ($scraper-&gt;page_loaded) {
                   ...
               }

   <b>page_match</b>
       The page_match method checks the passed-in URL (or URL of the current page if left empty) against the URL
       pattern (route) defined. If URL is a match, it will return the parameters of that match much in the same
       way a modern web application framework processes URL routes.

           my $url = '<a href="http://somesite.com/tags/awesomeness">http://somesite.com/tags/awesomeness</a>';

           ...

           my $scraper = Scrappy-&gt;new;

           # match against the current page
           my $this = $scraper-&gt;page_match('/tags/:tag');
           if ($this) {
               print $this-&gt;{'tag'};
               # ... prints awesomeness
           }

           .. or ..

           # match against a passed url
           my $this = $scraper-&gt;page_match('/tags/:tag', $url, {
               host =&gt; 'somesite.com'
           });

           if ($this) {
               print "This is the ", $this-&gt;{tag}, " page";
               # ... prints this is the awesomeness page
           }

   <b>page_reload</b>
       The page_reload method acts like the refresh button in a browser, it simply repeats the current request.

           my  $scraper = Scrappy-&gt;new;

               $scraper-&gt;get(...);
               ...
               $scraper-&gt;reload;

   <b>page_status</b>
       The page_status method returns the 3-digit HTTP status code of the response.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;get(...);

               if ($scraper-&gt;page_status == 200) {
                   ...
               }

   <b>page_text</b>
       The page_text method returns a text representation of the last page having all HTML markup stripped.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;get(...);

           my  $text = $scraper-&gt;page_text;

   <b>page_title</b>
       The page_title method returns the content of the title tag if the current page is HTML, otherwise returns
       undef.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;get('<a href="http://www.google.com/">http://www.google.com/</a>');

           my  $title = $scraper-&gt;page_title;
               print $title; # print Google

   <b>pause</b>
       This method sets breaks between your requests in an attempt to simulate human interaction.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;<a href="../man20/pause.20.html">pause</a>(20);

               $scraper-&gt;get($request_1);
               $scraper-&gt;get($request_2);
               $scraper-&gt;get($request_3);

       Given the above example, there will be a 20 sencond break between each request made, get, post, request,
       etc., You can also specify a range to have the pause method select from at random...

               $scraper-&gt;pause(5,20);

               $scraper-&gt;get($request_1);
               $scraper-&gt;get($request_2);

               # reset/turn it off
               $scraper-&gt;<a href="../man0/pause.0.html">pause</a>(0);

               print "I slept for ", ($scraper-&gt;pause), " seconds";

       Note! The download method is exempt from any automatic pausing.

   <b>plugin</b>
       The plugin method allow you to load a plugin. Using the appropriate case is recommended but not
       necessary. See Scrappy::Plugin for more information.

           my $scraper = Scrappy-&gt;new;

           $scraper-&gt;plugin('foo_bar');    # will load Scrappy::Plugin::FooBar
           $scraper-&gt;plugin('foo-bar');    # will load Scrappy::Plugin::Foo::Bar
           $scraper-&gt;plugin('Foo::Bar');   # will load Scrappy::Plugin::Foo::Bar

           # more pratically
           $scraper-&gt;plugin('whois', 'spammer_check');

           ... somewhere in code

           my $var = $scraper-&gt;plugin_method();

           # example using core plugin Scrappy::Plugin::RandomProxy

           my  $s = Scrappy-&gt;new;

               $s-&gt;plugin('random_proxy');
               $s-&gt;use_random_proxy;

               $s-&gt;get(...);

   <b>post</b>
       The post method takes a URL, a hashref of key/value pairs, and optionally an array of key/value pairs,
       and posts that data to the specified URL, then returns an HTTP::Response object.

           my $scraper = Scrappy-&gt;new;

           $scraper-&gt;post($requested_url, {
               input_a =&gt; 'value_a',
               input_b =&gt; 'value_b'
           });

           # w/additional headers
           my %headers = ('Content-Type' =&gt; 'multipart/form-data');
           $scraper-&gt;post($requested_url, {
               input_a =&gt; 'value_a',
               input_b =&gt; 'value_b'
           },  %headers);

       Note! The most common post headers for content-type are application/x-www-form-urlencoded and
       multipart/form-data.

   <b>proxy</b>
       The proxy method will set the proxy for the next request to be tunneled through.

           my $scraper = Scrappy-&gt;new;

           $scraper-&gt;proxy('http', '<a href="http://proxy1.example.com">http://proxy1.example.com</a>:8000/');
           $scraper-&gt;get($requested_url);

           $scraper-&gt;proxy('http', 'ftp', '<a href="http://proxy2.example.com">http://proxy2.example.com</a>:8000/');
           $scraper-&gt;get($requested_url);

           # best practice when using proxies

           use Tiny::Try;

           my $proxie = Scrappy-&gt;new;

           $proxie-&gt;proxy('http', '<a href="http://proxy.example.com">http://proxy.example.com</a>:8000/');

           try {
               $proxie-&gt;get($requested_url);
           } catch {
               die "Proxy failed\n";
           };

       Note! When using a proxy to perform requests, be aware that if they fail your program will die unless you
       wrap your code in an eval statement or use a try/catch mechanism. In the example above we use Tiny::Try
       to trap any errors that might occur when using proxy.

   <b>request_denied</b>
       The request_denied method is a simple shortcut to determine if the page you requested got loaded or
       redirected. This method is very useful on systems that require authentication and redirect if not
       authorized. This function return boolean, 1 if the current page doesn't match the requested page.

           my $scraper = Scrappy-&gt;new;
           $scraper-&gt;get($url_to_dashboard);

           if ($scraper-&gt;request_denied) {
               # do login, again
           }
           else {
               # resume ...
           }

   <b>response</b>
       The response method returns the HTTP::Repsonse object of the current page.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;get(...);
           my  $res = $scraper-&gt;response;

   <b>select</b>
       The select method takes XPATH or CSS selectors and returns a Scrappy::Scraper::Parser object which
       contains the matching elements.

           my $scraper = Scrappy-&gt;new;

           # return a list of links
           my $list = $scraper-&gt;select('#profile li a')-&gt;data; # see Scrappy::Scraper::Parser

           foreach my $link (@{$list}) {
               print $link-&gt;{href}, "\n";
           }

           # Zoom in on specific chunks of html code using the following ...
           my $list = $scraper
           -&gt;select('#container table tr') # select all rows
           -&gt;<a href="../man4/focus.4.html">focus</a>(4) # focus on the 5th row
           -&gt;select('div div')-&gt;data;

           # The code above selects the div &gt; div inside of the 5th tr in #container table
           # Access attributes html, text and other attributes as follows...

           $element = $scraper-&gt;select('table')-&gt;data-&gt;[0];
           $element-&gt;{html}; # HTML representation of the table
           $element-&gt;{text}; # Table stripped of all HTML
           $element-&gt;{cellpadding}; # cellpadding
           $element-&gt;{height}; # ...

   <b>stash</b>
       The stash method sets a stash (shared) variable or returns a reference to the entire stash object.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;stash(age =&gt; 31);

               print 'stash access works'
                   if $scraper-&gt;stash('age') == $scraper-&gt;stash-&gt;{age};

           my  @array = (1..20);
               $scraper-&gt;stash(integers =&gt; [@array]);

   <b>store</b>
       The store method stores the contents of the current page into the specified file.  If the content-type
       does not begin with 'text', the content is saved as binary data.

           my  $scraper = Scrappy-&gt;new;

               $scraper-&gt;get($requested_url);
               $scraper-&gt;store('/tmp/foo.html');

   <b>url</b>
       The url method returns the complete URL for the current page.

           my  $scraper = Scrappy-&gt;new;
               $scraper-&gt;get('<a href="http://www.google.com/">http://www.google.com/</a>');
               print $scraper-&gt;url; # prints <a href="http://www.google.com/">http://www.google.com/</a>

</pre><h4><b>AUTHOR</b></h4><pre>
       Al Newkirk &lt;<a href="mailto:awncorp@cpan.org">awncorp@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2010 by awncorp.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.34.0                                       2022-06-17                                       <u><a href="../man3pm/Scrappy.3pm.html">Scrappy</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>