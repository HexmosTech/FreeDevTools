<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imager::ImageTypes - image models for Imager</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libimager-perl">libimager-perl_1.027+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Imager::ImageTypes - image models for Imager

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Imager;

         $img = Imager-&gt;new(); #  Empty image (size is 0 by 0)
         $img-&gt;open(file=&gt;'lena.png',type=&gt;'png'); # Read image from file

         $img = Imager-&gt;new(xsize=&gt;400, ysize=&gt;300); # RGB data

         $img = Imager-&gt;new(xsize=&gt;400, ysize=&gt;300,  # Grayscale
                            channels=&gt;1);            #

         $img = Imager-&gt;new(xsize=&gt;400, ysize=&gt;300,  # RGB with alpha
                            channels=&gt;4);            #

         $img = Imager-&gt;new(xsize=&gt;200, ysize=&gt;200,
                            type=&gt;'paletted');       # paletted image

         $img = Imager-&gt;new(xsize=&gt;200, ysize=&gt;200,
                            bits=&gt;16);               # 16 bits/channel rgb

         $img = Imager-&gt;new(xsize=&gt;200, ysize=&gt;200,
                            bits=&gt;'double');         # 'double' floating point
                                                     #  per channel

         $img-&gt;img_set(xsize=&gt;500, ysize=&gt;500,       # reset the image object
                       channels=&gt;4);

         # Example getting information about an Imager object

         print "Image information:\n";
         print "Width:        ", $img-&gt;getwidth(),    "\n";
         print "Height:       ", $img-&gt;getheight(),   "\n";
         print "Channels:     ", $img-&gt;getchannels(), "\n";
         print "Bits/Channel: ", $img-&gt;bits(),        "\n";
         print "Virtual:      ", $img-&gt;virtual() ? "Yes" : "No", "\n";
         my $colorcount = $img-&gt;getcolorcount(maxcolors=&gt;512);
               print "Actual number of colors in image: ";
         print defined($colorcount) ? $colorcount : "&gt;512", "\n";
         print "Type:         ", $img-&gt;type(),        "\n";

         if ($img-&gt;type() eq 'direct') {
           print "Modifiable Channels: ";
           print join " ", map {
             ($img-&gt;getmask() &amp; 1&lt;&lt;$_) ? $_ : ()
           } 0..$img-&gt;getchannels();
           print "\n";

         } else {
           # palette info
           my $count = $img-&gt;colorcount;
           @colors = $img-&gt;getcolors();
           print "Palette size: $count\n";
           my $mx = @colors &gt; 4 ? 4 : 0+@colors;
           print "First $mx entries:\n";
           for (@colors[0..$mx-1]) {
             my @res = $_-&gt;rgba();
             print "(", join(", ", @res[0..$img-&gt;getchannels()-1]), ")\n";
           }
         }

         my @tags = $img-&gt;tags();
         if (@tags) {
           print "Tags:\n";
           for(@tags) {
             print shift @$_, ": ", join " ", @$_, "\n";
           }
         } else {
           print "No tags in image\n";
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Imager supports two basic models of image:

       •   direct  color  -  all samples are stored for every pixel.  eg. for an 8-bit/sample RGB image, 24 bits
           are stored for each pixel.

       •   paletted - an index into a table of colors is stored for each pixel.

       Direct color or paletted images can have 1 to 4  samples  per  color  stored.   Imager  treats  these  as
       follows:

       •   1 sample per color - gray scale image.

       •   2 samples per color - gray scale image with alpha channel, allowing transparency.

       •   3 samples per color - RGB image.

       •   4 samples per color - RGB image with alpha channel, allowing transparency.

       Direct  color images can have sample sizes of 8-bits per sample, 16-bits per sample or a double precision
       floating point number per sample (64-bits on many systems).

       Paletted images are always 8-bits/sample.

       To query an existing image about  it's  parameters  see  the  bits(),  type(),  getwidth(),  getheight(),
       getchannels() and virtual() methods.

       The coordinate system in Imager has the origin in the upper left corner, see Imager::Draw for details.

       The  alpha channel when one is present is considered unassociated - ie the color data has not been scaled
       by the alpha channel.  Note that not all code follows this (recent) rule, but will over time.

   <b>Creating</b> <b>Imager</b> <b>Objects</b>
       <b>new()</b>
             $img = Imager-&gt;new();
             $img-&gt;read(file=&gt;"alligator.ppm") or die $img-&gt;errstr;

           Here new() creates an empty image with width and height of zero.  It's only useful  for  creating  an
           Imager object to call the <b>read()</b> method on later.

             %opts = (xsize=&gt;300, ysize=&gt;200);
             $img = Imager-&gt;new(%opts); # create direct mode RGBA image
             $img = Imager-&gt;new(%opts, channels=&gt;4); # create direct mode RGBA image

           You can also read a file from <b>new()</b>:

             $img = Imager-&gt;new(file =&gt; "someimage.png");

           The parameters for new are:

           •   "xsize", "ysize" - Defines the width and height in pixels of the image.  These must be positive.

               If  not  supplied then only placeholder object is created, which can be supplied to the read() or
               img_set() methods.

           •   "channels" - The number of channels for the image.  Default 3.  Valid values are from 1 to 4.

           •   "model" - this overrides the value, if any, supplied for "channels".  This can be one of  "gray",
               "graya", "rgb" or "rgba".

           •   "bits" - The storage type for samples in the image.  Default: 8.  Valid values are:

               •   8 - One byte per sample.  256 discrete values.

               •   16 - 16-bits per sample, 65536 discrete values.

               •   "double" - one C double per sample.

               Note: you can use any Imager function on any sample size image.

               Paletted images always use 8 bits/sample.

           •   "type" - either 'direct' or 'paletted'.  Default: 'direct'.

               Direct images store color values for each pixel.

               Paletted images keep a table of up to 256 colors called the palette, each pixel is represented as
               an index into that table.

               In most cases when working with Imager you will want to use the "direct" image type.

               If  you  draw  on  a  "paletted"  image  with a color not in the image's palette then Imager will
               transparently convert it to a "direct" image.

           •   "maxcolors" - the maximum number of colors in a paletted image.  Default: 256.  This must  be  in
               the range 1 through 256.

           •   "file",  "fh",  "fd",  "callback",  "readcb",  or  "io"  -  specify a file name, filehandle, file
               descriptor or callback to read image data from.  See Imager::Files for details.  The typical  use
               is:

                 my $im = Imager-&gt;new(file =&gt; $filename);

           •   "filetype" - treated as the file format parameter, as for "type" with the <b>read()</b> method, eg:

                 my $im = Imager-&gt;new(file =&gt; $filename, filetype =&gt; "gif");

               In most cases Imager will detect the file's format itself.

           In the simplest case just supply the width and height of the image:

             # 8 bit/sample, RGB image
             my $img = Imager-&gt;new(xsize =&gt; $width, ysize =&gt; $height);

           or if you want an alpha channel:

             # 8 bits/sample, RGBA image
             my $img = Imager-&gt;new(xsize =&gt; $width, ysize =&gt; $height, channels=&gt;4);

           Note  that  it <u>is</u> possible for image creation to fail, for example if channels is out of range, or if
           the image would take too much memory.

           To create paletted images, set the 'type' parameter to 'paletted':

             $img = Imager-&gt;new(xsize=&gt;200, ysize=&gt;200, type=&gt;'paletted');

           which creates an image with a  maximum  of  256  colors,  which  you  can  change  by  supplying  the
           "maxcolors" parameter.

           For improved color precision you can use the bits parameter to specify 16 bit per channel:

             $img = Imager-&gt;new(xsize=&gt;200, ysize=&gt;200,
                                channels=&gt;3, bits=&gt;16);

           or for even more precision:

             $img = Imager-&gt;new(xsize=&gt;200, ysize=&gt;200,
                                channels=&gt;3, bits=&gt;'double');

           to get an image that uses a double for each channel.

           Note  that  as of this writing all functions should work on images with more than 8-bits/channel, but
           many will only work at only 8-bit/channel precision.

           If you want an empty Imager object to call the <b>read()</b> method on, just call <b>new()</b> with no parameters:

             my $img = Imager-&gt;new;
             $img-&gt;read(file=&gt;$filename)
               or die $img-&gt;errstr;

           Though it's much easier now to just call <b>new()</b> with a "file" parameter:

             my $img = Imager-&gt;new(file =&gt; $filename)
               or die Imager-&gt;errstr;

           If none of "xsize", "ysize", "file", "fh", "fd", "callback", "readcb", "data", "io" is supplied,  and
           other  parameters <u>are</u> supplied "Imager-&gt;new" will return failure rather than returning an empty image
           object.

       <b>img_set()</b>
           img_set destroys the image data in the object and creates a new one with  the  given  dimensions  and
           channels.  For a way to convert image data between formats see the convert() method.

             $img-&gt;img_set(xsize=&gt;500, ysize=&gt;500, channels=&gt;4);

           This takes exactly the same parameters as the <b>new()</b> method, excluding those for reading from files.

   <b>Image</b> <b>Attribute</b> <b>functions</b>
       These return basic attributes of an image object.

       <b>getwidth()</b>
             print "Image width: ", $img-&gt;getwidth(), "\n";

           The  getwidth()  method  returns  the  width  of  the image.  This value comes either from new() with
           "xsize", "ysize" parameters or from reading data from a file with read().  If called on an image that
           has no valid data in it like "Imager-&gt;new()" returns, the return value of getwidth() is undef.

       <b>getheight()</b>
             print "Image height: ", $img-&gt;getheight(), "\n";

           Same details apply as for "<b>getwidth()</b>".

       <b>getchannels()</b>
             print "Image has ",$img-&gt;getchannels(), " channels\n";

           Returns the number of channels in an image.

           Note: previously the number of channels in an image mapped directly to the color model of the  image,
           ie a 4 channel image was always RGBA.  This may change in a future release of Imager.

           Returns an empty list if the image object is not initialized.

       <b>colorchannels()</b>
           Returns the number of color channels.

           Currently this is always 1 or 3, but may be 0 for some rare images in a future version of Imager.

           Returns an empty list if the image object is not initialized.

       <b>colormodel()</b>
           Returns the color model of the image, including whether there is an alpha channel.

           By default this is returned as a string, one of "unknown", "gray", "graya", "rgb" or "rgba".

           If you call colormodel() with a true numeric parameter:

             my $model = $img-&gt;colormodel(numeric =&gt; 1);

           then the color model is returned as a number, mapped as follows:

             Numeric  String
             -------  ------
                 0    unknown
                 1    gray
                 2    graya
                 3    rgb
                 4    rgba

       <b>alphachannel()</b>
           Returns the channel index of the alpha channel of the image.

           This  is  1  for grayscale images with alpha, 3 for RGB images with alpha and will return "undef" for
           all other images.

           Returns an empty list if the image object is not initialized.

       <b>bits()</b>
           The <b>bits()</b> method retrieves the number of bits used to represent each channel in a  pixel,  8  for  a
           normal image, 16 for 16-bit image and 'double' for a double/channel image.

             if ($img-&gt;bits eq 8) {
               # fast but limited to 8-bits/sample
             }
             else {
               # slower but more precise
             }

           Returns an empty list if the image object is not initialized.

       <b>type()</b>
           The <b>type()</b> method returns either 'direct' for direct color images or 'paletted' for paletted images.

             if ($img-&gt;type eq 'paletted') {
               # print the palette
               for my $color ($img-&gt;getcolors) {
                 print join(",", $color-&gt;rgba), "\n";
               }
             }

           Returns an empty list if the image object is not initialized.

       <b>virtual()</b>
           The  <b>virtual()</b>  method  returns  non-zero  if the image contains no actual pixels, for example masked
           images.

           This may also be used for non-native Imager images in the future, for example, for an  Imager  object
           that draws on an SDL surface.

       <b>is_bilevel()</b>
           Tests  if  the  image will be written as a monochrome or bi-level image for formats that support that
           image organization.

           In scalar context, returns true if the image is bi-level.

           In list context returns a list:

             ($is_bilevel, $zero_is_white) = $img-&gt;is_bilevel;

           An image is considered bi-level, if all of the following are true:

           •   the image is a paletted image

           •   the image has 1 or 3 channels

           •   the image has only 2 colors in the palette

           •   those 2 colors are black and white, in either order.

           If a real bi-level organization image is ever added to Imager, this function  will  return  true  for
           that too.

           Returns an empty list if the image object is not initialized.

   <b>Direct</b> <b>Type</b> <b>Images</b>
       Direct images store the color value directly for each pixel in the image.

       <b>getmask()</b>
             @rgbanames = qw( red green blue alpha );
             my $mask = $img-&gt;getmask();
             print "Modifiable channels:\n";
             for (0..$img-&gt;getchannels()-1) {
               print $rgbanames[$_],"\n" if $mask &amp; 1&lt;&lt;$_;
             }

           getmask() is used to fetch the current channel mask.  The mask determines what channels are currently
           modifiable  in  the image.  The channel mask is an integer value, if the "i-th" least significant bit
           is set the "i-th" channel is modifiable.  eg. a channel mask of 0x5 means only channels 0 and  2  are
           writable.

           Channel masks are deprecated.

       <b>setmask()</b>
             $mask = $img-&gt;getmask();
             $img-&gt;setmask(mask=&gt;8);     # modify alpha only

               ...

             $img-&gt;setmask(mask=&gt;$mask); # restore previous mask

           setmask() is used to set the channel mask of the image.  See "<b>getmask()</b>" for details.

           Channel masks are deprecated.

   <b>Palette</b> <b>Type</b> <b>Images</b>
       Paletted images keep an array of up to 256 colors, and each pixel is stored as an index into that array.

       In general you can work with paletted images in the same way as RGB images, except that if you attempt to
       draw  to a paletted image with a color that is not in the image's palette, the image will be converted to
       an RGB image.  This means that drawing on  a  paletted  image  with  anti-aliasing  enabled  will  almost
       certainly convert the image to RGB.

       Palette management takes place through addcolors(), setcolors(), getcolors() and findcolor():

       <b>addcolors()</b>
           You can add colors to a paletted image with the <b>addcolors()</b> method:

              my @colors = ( Imager::Color-&gt;new(255, 0, 0),
                             Imager::Color-&gt;new(0, 255, 0) );
              my $index = $img-&gt;addcolors(colors=&gt;\@colors);

           The  return value is the index of the first color added, or undef if adding the colors would overflow
           the palette.

           The only parameter is "colors" which must be a reference to an array of Imager::Color objects.

       <b>setcolors()</b>
             $img-&gt;setcolors(start=&gt;$start, colors=&gt;\@colors);

           Once you have colors in the palette you can overwrite them with the setcolors() method:   setcolors()
           returns true on success.

           Parameters:

           •   start - the first index to be set.  Default: 0

           •   colors - reference to an array of Imager::Color objects.

       <b>getcolors()</b>
           To retrieve existing colors from the palette use the <b>getcolors()</b> method:

             # get the whole palette
             my @colors = $img-&gt;getcolors();
             # get a single color
             my $color = $img-&gt;getcolors(start=&gt;$index);
             # get a range of colors
             my @colors = $img-&gt;getcolors(start=&gt;$index, count=&gt;$count);

       <b>findcolor()</b>
           To quickly find a color in the palette use <b>findcolor()</b>:

             my $index = $img-&gt;findcolor(color=&gt;$color);

           which returns undef on failure, or the index of the color.

           Parameter:

           •   color - an Imager::Color object.

       <b>colorcount()</b>
           Returns the number of colors in the image's palette:

             my $count = $img-&gt;colorcount;

       <b>maxcolors()</b>
           Returns the maximum size of the image's palette.

             my $maxcount = $img-&gt;maxcolors;

   <b>Color</b> <b>Distribution</b>
       <b>getcolorcount()</b>
           Calculates the number of colors in an image.

           The amount of memory used by this is proportional to the number of colors present in the image, so to
           avoid using too much memory you can supply a <b>maxcolors()</b> parameter to limit the memory used.

           Note: <b>getcolorcount()</b> treats the image as an 8-bit per sample image.

           •   "maxcolors" - the maximum number of colors to return.  Default: unlimited.

             if (defined($img-&gt;getcolorcount(maxcolors=&gt;512)) {
               print "Less than 512 colors in image\n";
             }

       <b>getcolorusagehash()</b>
           Calculates a histogram of colors used by the image.

           •   "maxcolors" - the maximum number of colors to return.  Default: unlimited.

           Returns  a  reference  to  a  hash  where the keys are the raw color as bytes, and the values are the
           counts for that color.

           The alpha channel of the image is ignored.  If the image is gray scale then the hash keys  will  each
           be a single character.

             my $colors = $img-&gt;getcolorusagehash;
             my $blue_count = $colors-&gt;{pack("CCC", 0, 0, 255)} || 0;
             print "#0000FF used $blue_count times\n";

       <b>getcolorusage()</b>
           Calculates color usage counts and returns just the counts.

           •   "maxcolors" - the maximum number of colors to return.  Default: unlimited.

           Returns a list of the color frequencies in ascending order.

             my @counts = $img-&gt;getcolorusage;
             print "The most common color is used $counts[0] times\n";

   <b>Conversion</b> <b>Between</b> <b>Image</b> <b>Types</b>
       Warning:  if  you  draw  on  a  paletted  image with colors that aren't in the palette, the image will be
       internally converted to a normal image.

       <b>to_paletted()</b>
           You can create a new paletted image from an existing image using the <b>to_paletted()</b> method:

            $palimg = $img-&gt;to_paletted(\%opts)

           where %opts contains the options specified under "Quantization options".

             # convert to a paletted image using the web palette
             # use the closest color to each pixel
             my $webimg = $img-&gt;to_paletted({ make_colors =&gt; 'webmap' });

             # convert to a paletted image using a fairly optimal palette
             # use an error diffusion dither to try to reduce the average error
             my $optimag = $img-&gt;to_paletted({ make_colors =&gt; 'mediancut',
                                               translate =&gt; 'errdiff' });

       <b>to_rgb8()</b>
           You can convert a paletted image (or any image) to an 8-bit/channel RGB image with:

             $rgbimg = $img-&gt;to_rgb8;

           No parameters.

       <b>to_rgb16()</b>
           Convert a paletted image (or any image) to a 16-bit/channel RGB image.

             $rgbimg = $img-&gt;to_rgb16;

           No parameters.

       <b>to_rgb_double()</b>
           Convert a paletted image (or any image) to an double/channel direct color image.

             $rgbimg = $img-&gt;to_rgb_double;

           No parameters.

       <b>masked()</b>
           Creates a masked image.  A masked image lets you create an image proxy object that protects parts  of
           the underlying target image.

           In the discussion below there are 3 image objects involved:

           •   the masked image - the return value of the <b>masked()</b> method.  Any writes to this image are written
               to the target image, assuming the mask image allows it.

           •   the  mask  image  -  the  image that protects writes to the target image.  Supplied as the "mask"
               parameter to the <b>masked()</b> method.

           •   the target image - the image you called the <b>masked()</b> method on.  Any writes to the  masked  image
               end up on this image.

           In terms of code:

             $masked = $target-&gt;masked(mask =&gt; $mask);

           Parameters:

           •   mask  -  the  mask  image.  If not supplied then all pixels in the target image are writable.  On
               each write to the masked image, only pixels that have non-zero in channel 0  of  the  mask  image
               will  be  written to the original image.  Default: none, if not supplied then no masking is done,
               but the other parameters are still honored.

           •   left, top - the offset of writes to the target image.  eg. if you attempt to set pixel  (x,y)  in
               the masked image, then pixel (x+left, y+top) will be written to in the original image.

           •   bottom, right - the bottom right of the area in the target available from the masked image.

           If "left" or "right" is negative, they are counted from the right of the target image.

           If "top" or "bottom" is negative, they are counted from the bottom of the target image.

           Masked  images  let  you  control  which pixels are modified in an underlying image.  Where the first
           channel is completely black in the mask image, writes to the underlying image are ignored.

           For example, given a base image called $img:

             my $mask = Imager-&gt;new(xsize=&gt;$img-&gt;getwidth, ysize=&gt;$img-&gt;getheight,
                                    channels=&gt;1);
             # ... draw something on the mask
             my $maskedimg = $img-&gt;masked(mask=&gt;$mask);

             # now draw on $maskedimg and it will only draw on areas of $img
             # where $mask is non-zero in channel 0.

           You can specify the region of the underlying image that is masked using  the  left,  top,  right  and
           bottom options.

           If you just want a subset of the image, without masking, just specify the region without specifying a
           mask.  For example:

             # just work with a 100x100 region of $img
             my $maskedimg = $img-&gt;masked(left =&gt; 100, top=&gt;100,
                                          right=&gt;200, bottom=&gt;200);

       <b>make_palette()</b>
           This doesn't perform an image conversion, but it can be used to construct a common palette for use in
           several images:

             my @colors = Imager-&gt;make_palette(\%opts, @images);

           You must supply at least one image, even if the "make_colors" parameter produces a fixed palette.

           On failure returns no colors and you can check "Imager-&gt;errstr".

   <b>Tags</b>
       Image tags contain meta-data about the image, ie. information not stored as pixels of the image.

       At  the  perl  level each tag has a name or code and a value, which is an integer or an arbitrary string.
       An image can contain more than one tag with the same name or code, but having more than one tag with  the
       same name is discouraged.

       You  can retrieve tags from an image using the <b>tags()</b> method, you can get all of the tags in an image, as
       a list of array references, with the code or name of the tag followed by the value of the tag.

       Imager's support for fairly limited, for access to pretty much all image metadata you  may  want  to  try
       Image::ExifTool.

       <b>tags()</b>
           Retrieve tags from the image.

           With  no parameters, retrieves a list array references, each containing a name and value: all tags in
           the image:

             # get a list of ( [ name1 =&gt; value1 ], [ name2 =&gt; value2 ] ... )
             my @alltags = $img-&gt;tags;
             print $_-&gt;[0], ":", $_-&gt;[1], "\n" for @all_tags;

             # or put it in a hash, but this will lose duplicates
             my %alltags = map @$_, $img-&gt;tags;

           in scalar context this returns the number of tags:

             my $num_tags = $img-&gt;tags;

           or you can get all tags values for the given name:

             my @namedtags = $img-&gt;tags(name =&gt; $name);

           in scalar context this returns the first tag of that name:

             my $firstnamed = $img-&gt;tags(name =&gt; $name);

           or a given code:

             my @tags = $img-&gt;tags(code=&gt;$code);

       <b>addtag()</b>
           You can add tags using the <b>addtag()</b> method, either by name:

             my $index = $img-&gt;addtag(name=&gt;$name, value=&gt;$value);

           or by code:

             my $index = $img-&gt;addtag(code=&gt;$code, value=&gt;$value);

           Setting tags by "code" is deprecated.  If you have a use for this please open an issue.

       <b>deltag()</b>
           You can remove tags with the <b>deltag()</b> method, either by index:

             $img-&gt;deltag(index=&gt;$index);

           or by name:

             $img-&gt;deltag(name=&gt;$name);

           or by code:

             $img-&gt;deltag(code=&gt;$code);

           In each case <b>deltag()</b> returns the number of tags deleted.

           Setting or deleting tags by "code" is deprecated.  If you have a use for this please open an issue.

       <b>settag()</b>
           <b>settag()</b> replaces any existing tags with a new tag.  This is  equivalent  to  calling  <b>deltag()</b>  then
           <b>addtag()</b>.

   <b>Common</b> <b>Tags</b>
       Many  tags  are  only  meaningful for one format.  GIF looping information is pretty useless for JPEG for
       example.  Thus, many tags are set by only a single reader or used by a single  writer.   For  a  complete
       list of format specific tags see Imager::Files.

       Since  tags are a relatively new addition their use is not wide spread but eventually we hope to have all
       the readers for various formats set some standard information.

       •
               "i_xres", "i_yres" - The spatial resolution of the image in pixels per inch.  If the image format
           uses a different scale, eg. pixels per meter, then this value is converted.  A floating point  number
           stored as a string.

             # our image was generated as a 300 dpi image
             $img-&gt;settag(name =&gt; 'i_xres', value =&gt; 300);
             $img-&gt;settag(name =&gt; 'i_yres', value =&gt; 300);

             # 100 pixel/cm for a TIFF image
             $img-&gt;settag(name =&gt; 'tiff_resolutionunit', value =&gt; 3); # RESUNIT_CENTIMETER
             # convert to pixels per inch, Imager will convert it back
             $img-&gt;settag(name =&gt; 'i_xres', value =&gt; 100 * 2.54);
             $img-&gt;settag(name =&gt; 'i_yres', value =&gt; 100 * 2.54);

       •
             "i_aspect_only"  -  If this is non-zero then the values in i_xres and i_yres are treated as a ratio
           only.  If the image format does not support aspect ratios then this is scaled so the smaller value is
           72 DPI.

       •
             "i_incomplete" - If this tag is present then the  whole  image  could  not  be  read.   This  isn't
           implemented for all images yet, and may not be.

       •
             "i_lines_read"  -  If  "i_incomplete"  is  set then this tag may be set to the number of scan lines
           successfully read from the file.  This can be used to decide whether an image is worth processing.

       •
            i_format - The file format this file was read from.

       •
             i_background - used when writing an image with an alpha channel  to  a  file  format  that  doesn't
           support  alpha channels.  The "write" method will convert a normal color specification like "#FF0000"
           into a color object for you, but if you  set  this  as  a  tag  you  will  need  to  format  it  like
           "color("<u>red</u>","<u>green</u>","<u>blue</u>")", eg color(255,0,0).

       •   "i_comment"  -  used  when reading or writing several image formats.  If the format has only one text
           field it will be read into the "i_comment" tag or written to the file.

   <b>Quantization</b> <b>options</b>
       These options can be specified when calling "<b>to_paletted()</b>" in Imager::ImageTypes, <b>write_multi()</b> for  GIF
       files,  when  writing  a  single  image  with  the "gifquant" option set to "gen", or for direct calls to
       <b>i_writegif_gen()</b> and <b>i_writegif_callback()</b>.

       •   "colors" - An arrayref of colors that are fixed.  Note that some color generators will  ignore  this.
           If this is supplied it will be filled with the color table generated for the image.

       •   "transp"  - The type of transparency processing to perform for images with an alpha channel where the
           output format does not have a proper alpha channel (eg. GIF).  This can be any of:

           •   "none" - No transparency processing is done. (default)

           •   "threshold" - pixels more transparent than "tr_threshold" are rendered as transparent.

           •   "errdiff" - An error diffusion  dither  is  done  on  the  alpha  channel.   Note  that  this  is
               independent  of  the  translation performed on the color channels, so some combinations may cause
               undesired artifacts.

           •   "ordered" - the ordered dither specified by tr_orddith is performed on the alpha channel.

           This will only be used if the image has an alpha channel, and if there is space in the palette for  a
           transparency color.

       •   "tr_threshold"  -  the highest alpha value at which a pixel will be made transparent when "transp" is
           'threshold'. (0-255, default 127)

       •   "tr_errdiff" - The type of error  diffusion  to  perform  on  the  alpha  channel  when  "transp"  is
           "errdiff".  This can be any defined error diffusion type except for custom (see "errdiff" below).

       •   "tr_orddith" - The type of ordered dither to perform on the alpha channel when "transp" is 'ordered'.
           Possible values are:

           •   "random" - A semi-random map is used.  The map is the same each time.

           •   "dot8" - 8x8 dot dither.

           •   "dot4" - 4x4 dot dither

           •   "hline" - horizontal line dither.

           •   "vline" - vertical line dither.

           •   "/line", "slashline" - diagonal line dither

           •   "\line", "backline" - diagonal line dither

           •   "tiny" - dot matrix dither (currently the default).  This is probably the best for displays (like
               web pages).

           •   "custom" - A custom dither matrix is used - see "tr_map".

       •   "tr_map"  -  When  tr_orddith  is  custom  this  defines an 8 x 8 matrix of integers representing the
           transparency threshold for pixels corresponding to each position.  This should be a 64 element  array
           where  the first 8 entries correspond to the first row of the matrix.  Values should be between 0 and
           255.

       •   "make_colors" - Defines how the quantization engine will build the  palette(s).   Currently  this  is
           ignored if "translate" is "giflib", but that may change.  Possible values are:

           •   "none" - only colors supplied in 'colors' are used.

           •   "webmap" - the web color map is used (need URL here.)

           •   "addi" - The original code for generating the color map (Addi's code) is used.

           •   "mediancut" - Uses a median-cut algorithm, faster than "addi", but not as good a result.

           •   "mono",  "monochrome"  -  a fixed black and white palette, suitable for producing bi-level images
               (eg. facsimile)

           •   "gray", "gray4", "gray16" - make fixed gray palette with 256, 4 or 16 entries respectively.

           Other methods may be added in the future.

       •   "colors" - an arrayref containing Imager::Color objects, which represents the starting set of  colors
           to  use  in  translating the images.  "webmap" will ignore this.  On return the final colors used are
           copied back into this array (which is expanded if necessary.)

       •   "max_colors" - the maximum number of colors to use in the image.

       •   "translate" - The method used to translate the RGB  values  in  the  source  image  into  the  colors
           selected by make_colors.  Note that make_colors is ignored when "translate" is "giflib".

           Possible values are:

           •   "giflib"  -  this  is  a  historical  equivalent  for "closest" that also forces "make_colors" to
               "mediancut".

           •   "closest" - the closest color available is used.

           •   "perturb" - the pixel color is modified by "perturb", and the closest color is chosen.

           •   "errdiff" - an error diffusion dither is performed.   If  the  supplied  (or  generated)  palette
               contains only grays the source colors are converted to gray before error diffusion is performed.

           It's possible other "translate" values will be added.

       •   "errdiff" - The type of error diffusion dither to perform.  These values (except for custom) can also
           be used in tr_errdif.

           •   "floyd" - Floyd-Steinberg dither

           •   "jarvis" - Jarvis, Judice and Ninke dither

           •   "stucki" - Stucki dither

           •   "custom"  -  custom.   If  you  use  this you must also set "errdiff_width", "errdiff_height" and
               "errdiff_map".

       •   "errdiff_width", "errdiff_height", "errdiff_orig", "errdiff_map" - When "translate" is "errdiff"  and
           "errdiff"   is   "custom"   these   define   a  custom  error  diffusion  map.   "errdiff_width"  and
           "errdiff_height" define the size of the map in the arrayref in "errdiff_map".  "errdiff_orig"  is  an
           integer which indicates the current pixel position in the top row of the map.

       •   "perturb"  -  When  translate  is  "perturb" this is the magnitude of the random bias applied to each
           channel of the pixel before it is looked up in the color table.

</pre><h4><b>INITIALIZATION</b></h4><pre>
       This documents the Imager initialization function, which you will almost never need to call.

       <b>init()</b>
           This is a function, not a method.

           This function is a mess, it can take the following named parameters:

           •   "log" - name of a log file to log Imager's actions to.  Not  all  actions  are  logged,  but  the
               debugging  memory  allocator does log allocations here.  Ignored if Imager has been built without
               logging support.  Preferably use the <b>open_log()</b> method instead.

           •   "loglevel" - the maximum level of message to log.  Default: 1.

           •   "warn_obsolete" - if this is non-zero then Imager will warn when you  attempt  to  use  obsoleted
               parameters  or functionality.  This currently only includes the old GIF output options instead of
               tags.

           •   "t1log" - if non-zero then T1lib will be configured to produce a log file.   This  will  fail  if
               there are any existing T1lib font objects.

           Example:

             Imager::init(log =&gt; 'trace.log', loglevel =&gt; 9);

</pre><h4><b>LOGGING</b> <b>METHODS</b></h4><pre>
       Imager  can  open  an  internal  log  to  send debugging information to.  This log is extensively used in
       Imager's tests, but you're unlikely to use it otherwise.

       If Imager has been built with logging disabled, the methods fail quietly.

       <b>open_log()</b>
           Open the Imager debugging log file.

           •   "log" - the file name to log to.  If this is undef logging information is sent  to  the  standard
               error stream.

           •   "loglevel" the level of logging to produce.  Default: 1.

           Returns a true value if the log file was opened successfully.

             # send debug output to test.log
             Imager-&gt;open_log(log =&gt; "test.log");

             # send debug output to stderr
             Imager-&gt;open_log();

       <b>close_log()</b>
           Close the Imager debugging log file and disable debug logging.

           No parameters.

             Imager-&gt;close_log();

       <b>log()</b>
            Imager-&gt;log($message)
            Imager-&gt;log($message, $level)

           This method does not use named parameters.

           The default for $level is 1.

           Send a message to the debug log.

             Imager-&gt;log("My code got here!");

       <b>is_logging()</b>
           Returns a true value if logging is enabled.

</pre><h4><b>AUTHOR</b></h4><pre>
       Tony Cook &lt;<a href="mailto:tonyc@cpan.org">tonyc@cpan.org</a>&gt;, Arnar M. Hrafnkelsson

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/Imager.3.html">Imager</a></b>(3),   <b>Imager::<a href="../man3/Files.3.html">Files</a></b>(3),   <b>Imager::<a href="../man3/Draw.3.html">Draw</a></b>(3),   <b>Imager::<a href="../man3/Color.3.html">Color</a></b>(3),  <b>Imager::<a href="../man3/Fill.3.html">Fill</a></b>(3),  <b>Imager::<a href="../man3/Font.3.html">Font</a></b>(3),
       <b>Imager::<a href="../man3/Transformations.3.html">Transformations</a></b>(3), <b>Imager::<a href="../man3/Engines.3.html">Engines</a></b>(3), <b>Imager::<a href="../man3/Filters.3.html">Filters</a></b>(3), <b>Imager::<a href="../man3/Expr.3.html">Expr</a></b>(3), <b>Imager::<a href="../man3/Matrix2d.3.html">Matrix2d</a></b>(3),
       <b>Imager::<a href="../man3/Fountain.3.html">Fountain</a></b>(3)

perl v5.40.1                                       2025-03-16                            <u>Imager::<a href="../man3pm/ImageTypes.3pm.html">ImageTypes</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>