<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imager::Expr - implements expression parsing and compilation for the expression evaluation engine used by</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libimager-perl">libimager-perl_1.027+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Imager::Expr - implements expression parsing and compilation for the expression evaluation engine used by
       Imager::transform2()

</pre><h4><b>SYNOPSIS</b></h4><pre>
       my $code = Imager::Expr-&gt;new({rpnexpr=&gt;$someexpr})
         or die "Cannot compile $someexpr: ",<b>Imager::Expr::error()</b>;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is used internally by the <b>Imager::transform2()</b> function.  You shouldn't have much need to use
       it directly, but you may want to extend it.

       To create a new Imager::Expr object, call:

        my %options;
        my $expr = Imager::Expr-&gt;new(\%options)
          or die Imager::Expr::error();

       You will need to set an expression value and you may set any of the following:

       •   constants

           A  hashref defining extra constants for expression parsing.  The names of the constants must be valid
           identifiers (/[^\W\d]\w*/) and the values must be valid numeric constants (that  Perl  recognizes  in
           scalars).

           Imager::Expr may define it's own constants (currently just pi.)

       •   variables

           A  reference  to  an  array  of  variable names.  These are allocated numeric registers starting from
           register zero.

       By default you can define a "rpnexpr" key (which emulates RPN) or "expr"  (an  infix  expression).   It's
       also possible to write other expression parsers that will use other keys.  Only one expression key should
       be defined.

   <b>Instance</b> <b>methods</b>
       The  <b>Imager::Expr::error()</b>  method  is  used  to  retrieve  the  error if the expression object cannot be
       created.

   <b>Methods</b>
       Imager::Expr provides only a few simple methods meant for external use:

       Imager::Expr-&gt;type_registered($keyword)
           Returns true if the given expression type is available.  The parameter is the  key  supplied  to  the
           <b>new()</b> method.

             if (Imager::Expr-&gt;type_registered('expr')) {
               # use infix expressions
             }

       $expr-&gt;<b>code()</b>
           Returns the compiled code.

       $expr-&gt;<b>nregs()</b>
           Returns a reference to the array of numeric registers.

       $expr-&gt;<b>cregs()</b>
           Returns a reference to the array of color registers.

       $expr-&gt;<b>dumpops()</b>
           Returns a string with the generated VM "machine code".

       $expr-&gt;<b>dumpcode()</b>
           Returns a string with the disassembled VM "machine code".

   <b>Creating</b> <b>a</b> <b>new</b> <b>parser</b>
       I'll write this one day.

       Methods used by parsers:

       compile
           This is the main method you'll need to implement in a parser.  See the existing parsers for a guide.

           It's supplied the following parameters:

           •   $expr - the expression to be parsed

           •   $options - the options hash supplied to transform2.

           Return an array ref of array refs containing opcodes and operands.

       @vars = $self-&gt;<b>_variables()</b>
           A  list  (not a reference) of the input variables.  This should be used to allocate as many registers
           as there are variable as input registers.

       $self-&gt;error($message)
           Set the return value of <b>Imager::Expr::error()</b>

       @ops = $self-&gt;stack_to_reg(@stack_ops)
           Converts marginally parsed RPN to register code.

       <b>assemble()</b>
           Called to convert op codes into byte code.

       <b>numre()</b>
           Returns a regular expression that matches floating point numbers.

       <b>optimize()</b>
           Optimizes the assembly code, including  attempting  common  subexpression  elimination  and  strength
           reducing division by a constant into multiplication by a constant.

       <b>register_type()</b>
           Called by a new expression parser implementation to register itself, call as:

             YourClassName-&gt;register_type('type code');

           where type code is the parameter that will accept the expression.

   <b>Future</b> <b>compatibility</b>
       Try  to  avoid  doing  your  own  optimization  beyond literal folding - if we add some sort of jump, the
       existing optimizer will need to be rewritten, and any optimization you perform may  well  be  broken  too
       (well, your code generation will probably be broken anyway &lt;sigh&gt;).

</pre><h4><b>AUTHOR</b></h4><pre>
       Tony Cook &lt;<a href="mailto:tonyc@cpan.org">tonyc@cpan.org</a>&gt;, Arnar M. Hrafnkelsson

perl v5.40.1                                       2025-03-16                                  <u>Imager::<a href="../man3pm/Expr.3pm.html">Expr</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>