<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imager::Cookbook - recipes working with Imager</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libimager-perl">libimager-perl_1.027+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Imager::Cookbook - recipes working with Imager

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Various simple and not so simple ways to do things with Imager.

</pre><h4><b>FILES</b></h4><pre>
       This is described in detail in Imager::Files.

   <b>Reading</b> <b>an</b> <b>image</b> <b>from</b> <b>a</b> <b>file</b>
         my $image = Imager-&gt;new;

         $image-&gt;read(file=&gt;$filename) or die $image-&gt;errstr;

       Or:

         my $image = Imager-&gt;new(file =&gt; $filename)
           or die Imager-&gt;errstr;

       See Imager::Files.

   <b>Writing</b> <b>an</b> <b>image</b> <b>to</b> <b>a</b> <b>file</b>
         $image-&gt;write(file=&gt;$filename) or die $image-&gt;errstr;

   <b>Write</b> <b>an</b> <b>animated</b> <b>GIF</b>
         # build an array of images to use in the gif
         my  @images;
         # synthesize the images or read them from files, it doesn't matter
         ...

         # write the gif
         Imager-&gt;write_multi({ file=&gt;$filename, type=&gt;'gif' }, @images)
           or die Imager-&gt;errstr;

       See "Writing an animated GIF" in Imager::Files for a more detailed example.

   <b>Reading</b> <b>multiple</b> <b>images</b> <b>from</b> <b>one</b> <b>file</b>
       Some formats, like GIF and TIFF support multiple images per file.  Use the <b>read_multi()</b> method to read
       them:

         my @images = Imager-&gt;read_multi(file=&gt;$filename)
           or die Imager-&gt;errstr;

   <b>Converting</b> <b>from</b> <b>one</b> <b>file</b> <b>format</b> <b>to</b> <b>another</b>
       This is as simple as reading the original file and writing the new file, for single images:

         my $image = Imager-&gt;new;
         # Imager auto-detects the input file type
         $image-&gt;read(file =&gt; $input_filename)
           or die $image-&gt;errstr;
         # Imager derives the output file format from the filename
         $image-&gt;write(file =&gt; $output_filename)
           or die $image-&gt;errstr;

         # or you can supply a type parameter:
         $image-&gt;write(file =&gt; $output_filename, type =&gt; 'gif')
           or die $image-&gt;errstr;

       The main issue that can occur with this is if the input file has transparency and the output file format
       doesn't support that.  This can be a problem when converting from GIF files to JPEG files for example.

       By default, if the output format doesn't support transparency, Imager will compose the image onto a black
       background.  You can override that by supplying an "i_background" option to write() or write_multi():

         $image-&gt;write(file =&gt; "foo.jpg", i_background =&gt; "#808080")
           or die $image-&gt;errstr;

       Some formats support multiple files, so if you want to convert from say TIFF to JPEG, you'll need
       multiple output files:

         my @images = Imager-&gt;read_multi(file =&gt; 'input.tif')
           or die Imager-&gt;errstr;
         my $index = 1;
         for my $image (@images) {
           $image-&gt;write(file =&gt; sprintf('output%02d.jpg', $index++))
             or die $image-&gt;errstr;
         }

   <b>Transparent</b> <b>PNG</b>
       To save to a transparent PNG (or GIF or TIFF) you need to start with an image with transparency.

       To make a transparent image, create an image object with 2 or 4 channels:

         # RGB with alpha channel
         my $rgba = Imager-&gt;new(xsize =&gt; $width, ysize =&gt; $height, channels =&gt; 4);

         # Gray with alpha channel
         my $graya = Imager-&gt;new(xsize =&gt; $width, ysize =&gt; $height, channels =&gt; 2);

       By default, the created image will be transparent.

       Otherwise, if you have an existing image file with transparency, simply read it, and the transparency
       will be preserved.

</pre><h4><b>IMAGE</b> <b>SYNTHESIS</b></h4><pre>
   <b>Creating</b> <b>an</b> <b>image</b>
       To create a simple RGB image, supply the image width and height to the <b>new()</b> method:

         my $rgb = Imager-&gt;new(xsize=&gt;$width, ysize=&gt;$height);

       If you also want an alpha channel:

         my $rgb_alpha = Imager-&gt;new(xsize=&gt;$width, ysize=&gt;$height, channels=&gt;4);

       To make a gray-scale image:

         my $gray = Imager-&gt;new(xsize=&gt;$width, ysize=&gt;$height, channels=&gt;1);

       and a gray-scale image with an alpha channel:

         my $gray_alpha = Imager-&gt;new(xsize=&gt;$width, ysize=&gt;$height, channels=&gt;2);

       When a new image is created this way all samples are set to zero - black for 1 or 3 channel images,
       transparent black for 2 or 4 channel images.

       You can also create paletted images and images with more than 8-bits per channel, see Imager::ImageTypes
       for more details.

   <b>Setting</b> <b>the</b> <b>background</b> <b>of</b> <b>a</b> <b>new</b> <b>image</b>
       To set the background of a new image to a solid color, use the <b>box()</b> method with no limits, and
       "filled=&gt;1":

         $image-&gt;box(filled=&gt;1, color=&gt;$color);

       As always, a color can be specified as an Imager::Color object:

         my $white = Imager::Color-&gt;new(255, 255, 255);
         $image-&gt;box(filled=&gt;1, color=&gt;$white);

       or you supply any single scalar that Imager::Color's <b>new()</b> method accepts as a color description:

         $image-&gt;box(filled=&gt;1, color=&gt;'white');
         $image-&gt;box(filled=&gt;1, color=&gt;'#FF0000');
         $image-&gt;box(filled=&gt;1, color=&gt;[ 255, 255, 255 ]);

       You can also fill the image with a fill object:

         use Imager::Fill;
         # create the fill object
         my $fill = Imager::Fill-&gt;new(hatch=&gt;'check1x1')
         $image-&gt;box(fill=&gt;$fill);

         # let Imager create one automatically
         $image-&gt;box(fill=&gt;{ hatch=&gt;'check1x1' });

       See Imager::Fill for information on Imager's fill objects.

   <b>Create</b> <b>an</b> <b>image</b> <b>from</b> <b>raw</b> <b>RGB</b> <b>data</b>
       If your data matches the layout supported by Imager's "RAW" in Imager::Files file support closely enough,
       you can simply read the data as if it was a raw file:

         my $img = Imager-&gt;new(
           (
            filetype =&gt; "raw",
            xsize =&gt; $width,
            ysize =&gt; $height,
            # stored as RGBXRGBX where X is dropped
            raw_interleave =&gt; 0,
            raw_datachannels =&gt; 4,
            raw_storechannels =&gt; 3,
           );

       If the channel order doesn't match you can further use the "<b>combine()</b>" in Imager::Transformations method
       to extract the channels in the correct order, eg. if the source data above was in "BGRX" format instead
       of "RGBX":

         my $img2 = $im-&gt;combine(src      =&gt; [ $img, $img, $img ],
                                 channels =&gt; [ 2,    1,    0    ]);

       Adapted from perl monks &lt;https://perlmonks.org/?node_id=11139983&gt;.

       For more control you can use the <b>setsamples()</b> method to set pixels directly to the image:

         # for AGBR data in $data
         my $img = Imager-&gt;new(xsize =&gt; $width, ysize =&gt; $height, channels =&gt; 4);
         my $rowbytes = $width * 4;
         my @chans = [ 3, 1, 2, 0 ];
         for my $row (0 .. $height) {
           $img-&gt;setsamples
             (
             y =&gt; $row,
             data =&gt; $data,
             offset =&gt; $rowbytes * $row,
             channels =&gt; \@chans,
             type =&gt; '8bit',
             );
         }

</pre><h4><b>WORLD</b> <b>WIDE</b> <b>WEB</b></h4><pre>
       As with any CGI script it's up to you to validate data and set limits on any parameters supplied to
       Imager.

       For example, if you allow the caller to set the size of an output image you should limit the size to
       prevent the client from specifying an image size that will consume all available memory.

       This is beside any other controls you need over access to data.

       See CGI for a module useful for processing CGI submitted data.

   <b>Returning</b> <b>an</b> <b>image</b> <b>from</b> <b>a</b> <b>CGI</b> <b>script</b>
       This is similar to writing to a file, but you also need to supply the information needed by the web
       browser to identify the file format:

         my $img = ....; # create the image and generate the contents
         ++$|; # make sure the content type isn't buffered
         print "Content-Type: image/png\n\n";
         binmode STDOUT;
         $img-&gt;write(fd=&gt;fileno(STDOUT), type=&gt;'png')
           or die $img-&gt;errstr;

       You need to set the Content-Type header depending on the file format you send to the web browser.

       If you want to supply a content-length header, write the image to a scalar as a buffer:

         my $img = ....; # create the image and generate the contents
         my $data;
         $img-&gt;write(type=&gt;'png', data=&gt;\$data)
           or die $img-&gt;errstr;
         print "Content-Type: image/png\n";
         print "Content-Length: ",length($data),"\n\n";
         binmode STDOUT;
         print $data;

       See "samples/samp-scale.cgi" and "samples/samp-image.cgi" for a couple of simple examples of producing an
       image from CGI.

   <b>Inserting</b> <b>a</b> <b>CGI</b> <b>image</b> <b>in</b> <b>a</b> <b>page</b>
       There's occasionally confusion on how to display an image generated by Imager in a page generated by a
       CGI.

       Your web browser handles this process as two requests, one for the HTML page, and another for the image
       itself.

       Each request needs to perform validation since an attacker can control the values supplied to both
       requests.

       How you make the data available to the image generation code depends on your application.

       See "samples/samp-form.cgi" and "samples/samp-image.cgi" in the Imager distribution for one approach.
       The POD in "samp-form.cgi" also discusses some of the issues involved.

   <b>Parsing</b> <b>an</b> <b>image</b> <b>posted</b> <b>via</b> <b>CGI</b>
       "WARNING": file format attacks have become a common attack vector, make sure you have up to date image
       file format libraries, otherwise trying to parse uploaded files, whether with Imager or some other tool,
       may result in a remote attacker being able to run their own code on your system.

       If your HTML form uses the correct magic, it can upload files to your CGI script, in particular, you need
       to use " method="post" " and "enctype="multipart/form-data"" in the "form" tag, and use "type="file"" in
       the "input", for example:

         &lt;form action="/cgi-bin/yourprogram" method="post"
               enctype="multipart/form-data"&gt;
           &lt;input type="file" name="myimage" /&gt;
           &lt;input type="submit value="Upload Image" /&gt;
         &lt;/form&gt;

       To process the form:

       1.  first check that the user supplied a file

       2.  get the file handle

       3.  have Imager read the image

         # returns the client's name for the file, don't open this locally
         my $cgi = CGI-&gt;new;
         # 1. check the user supplied a file
         my $filename = $cgi-&gt;param('myimage');
         if ($filename) {
           # 2. get the file handle
           my $fh = $cgi-&gt;upload('myimage');
           if ($fh) {
             binmode $fh;

             # 3. have Imager read the image
             my $img = Imager-&gt;new;
             if ($img-&gt;read(fh=&gt;$fh)) {
               # we can now process the image
             }
           }
           # else, you probably have an incorrect form or input tag
         }
         # else, the user didn't select a file

       See "samples/samp-scale.cgi" and "samples/samp-tags.cgi" in the Imager distribution for example code.

       You  may  also want to set limits on the size of the image read, using Imager's "set_file_limits" method,
       documented in "<b>set_file_limits()</b>" in Imager::Files.  For example:

         # limit to 10 million bytes of memory usage
         Imager-&gt;set_file_limits(bytes =&gt; 10_000_000);

         # limit to 1024 x 1024
         Imager-&gt;set_file_limits(width =&gt; 1024, height =&gt; 1024);

</pre><h4><b>DRAWING</b></h4><pre>
   <b>Adding</b> <b>a</b> <b>border</b> <b>to</b> <b>an</b> <b>image</b>
       First make a new image with space for the border:

         my $border_width = ...;
         my $border_height = ...;
         my $out = Imager-&gt;new(xsize =&gt; $source-&gt;getwidth() + 2 * $border_width,
                               ysize =&gt; $source-&gt;getheight() + 2 * $border_height,
                               bits =&gt; $source-&gt;bits,
                               channels =&gt; $source-&gt;getchannels);

       Then paste the source image into the new image:

         $out-&gt;paste(left =&gt; $border_width,
                     top =&gt; $border_height,
                     img =&gt; $source);

       Whether you draw the border before or after pasting the original image depends on whether  you  want  the
       border  to  overlap the image, for example a semi-transparent border drawn after pasting the source image
       could overlap the edge without hiding it.

       If you want a solid border you could just fill the image before pasting the source for simplicity:

         $out-&gt;box(filled=&gt;1, color=&gt;'red');
         $out-&gt;paste(left =&gt; $border_width,
                     top =&gt; $border_height,
                     img =&gt; $source);

</pre><h4><b>TEXT</b></h4><pre>
   <b>Drawing</b> <b>text</b>
   <b>Aligning</b> <b>text</b>
   <b>Measuring</b> <b>text</b>
   <b>Word</b> <b>wrapping</b> <b>text</b>
   <b>Shearing</b> <b>(slanting)</b> <b>or</b> <b>Rotating</b> <b>text</b>
       This requires that you have Imager installed with FreeType 2.x support installed, and that  the  font  be
       created using the FreeType 2.x driver, for example:

         my $font = Imager::Font-&gt;new(file=&gt;$fontfile, type=&gt;'ft2');

       First you need a transformation matrix, for shearing that could be:

         my $angle_in_radians = ...;
         my $tan_angle = sin($angle_rads) / cos($angle_rads);
         # shear horizontally, supply this as y instead to do it vertically
         my $matrix = Imager::Matrix2d-&gt;shear(x=&gt;$tan_angle);

       For rotation that would be:

         my $matrix = Imager::Matrix2d-&gt;rotate(radians =&gt; $angle_in_radians);

       or:

         my $matrix = Imager::Matrix2d-&gt;rotate(degrees =&gt; $angle_in_degrees);

       Feed that to the font object:

         $font-&gt;transform(matrix =&gt; $matrix);

       and draw the text as normal:

         $image-&gt;string(string =&gt; $text,
                        x =&gt; $where_x,
                        y =&gt; $where_y,
                        color =&gt; $color,
                        font =&gt; $font);

       See samples/slant_text.pl for a comprehensive example, including calculating the transformed bounding box
       to create an image to fit the transformed text into.

</pre><h4><b>IMAGE</b> <b>TRANSFORMATION</b></h4><pre>
   <b>Shearing</b> <b>an</b> <b>image</b>
   <b>Convert</b> <b>to</b> <b>gray-scale</b>
       To convert an RGB image to a gray-scale image, use the convert method:

         my $grey = $image-&gt;convert(preset =&gt; 'gray');

       <b>convert()</b> returns a new image.

       See: "Color transformations" in Imager::Transformations

</pre><h4><b>METADATA</b></h4><pre>
   <b>Image</b> <b>format</b>
       When  Imager  reads  a  file  it does a magic number check to determine the file type, so "foo.png" could
       actually be a GIF image, and Imager will read it anyway.

       You can check the actual format of the image by looking at the "i_format" tag.

         my $format = $image-&gt;tags(name=&gt;'i_format');

   <b>Image</b> <b>spatial</b> <b>resolution</b>
       Most image file formats store information about the physical size of the pixels,  though  in  some  cases
       that information isn't useful.

       Imager  stores  this information in the tags "i_xres" and "i_yres", and this is always stored in dots per
       inch.

       Some formats, including TIFF and JPEG allow you to change the units  spatial  resolution  information  is
       stored  in,  if  you set the tag that changes this the Imager will convert "i_xres" and "i_yres" to those
       units when it writes the file.

       For example to set the resolution to 300 dpi:

         $image-&gt;settag(name =&gt; 'i_xres', value =&gt; 300);
         $image-&gt;settag(name =&gt; 'i_yres', value =&gt; 300);

       If you want the file format to store the resolution in some other unit, for example you can write a  TIFF
       file that stores the resolution in pixels per centimeter, you would do:

         # 150 pixels/cm
         $image-&gt;settag(name =&gt; 'i_xres', value =&gt; 150 * 2.54);
         $image-&gt;settag(name =&gt; 'i_yres', value =&gt; 150 * 2.54);
         $image-&gt;settag(name =&gt; 'tiff_resolutionunit', value =&gt; 3);

       Keywords: DPI

</pre><h4><b>IMAGE</b> <b>MANIPULATION</b></h4><pre>
   <b>Replacing</b> <b>a</b> <b>color</b> <b>with</b> <b>transparency</b>
       To replace a color with transparency you can use the "<b>difference()</b>" in Imager::Filters method.

         # make a work image the same size as our input
         my $work = Imager-&gt;new(xsize =&gt; $in-&gt;getwidth, ysize =&gt; $in-&gt;getheight,
                                channels =&gt; $in-&gt;getchannels);
         # and fill it with the color we want transparent
         $work-&gt;box(filled =&gt; 1, color =&gt; $color);

         # get an image with that color replaced with transparent black
         my $out = $work-&gt;difference(other =&gt; $in);

</pre><h4><b>SPECIAL</b> <b>EFFECTS</b></h4><pre>
   <b>Drop</b> <b>Shadows</b>
       This can be used for a glow effect as well.

       First  create  a  new image, either with an alpha channel (if you want transparency behind the shadow) or
       without, if you want a background color:

         my $out = Imager-&gt;new
            (
            xsize =&gt; $shadow_size * 2 + $src-&gt;getwidth,
            ysize =&gt; $shadow_size * 2 + $src-&gt;getheight,
            channels =&gt; 4,
            );
         # fill it with your background color, if you want one
         # $out-&gt;box(filled =&gt; 1, color =&gt; $back_color);

       Make a work image to render the shadow on:

         my $shadow_work = Imager-&gt;new
           (
           xsize =&gt; $back-&gt;getwidth,
           ysize =&gt; $back-&gt;getheight,
           channels =&gt; 1,
           );

       Extract the alpha channel from the source image, first the alpha version:

         my $alpha = $src-&gt;convert(preset =&gt; "alpha");

       and draw that on the work shadow:

         $shadow_work-&gt;paste
           (
           src =&gt; $slpha,
           left =&gt; $shadow_size,
           top =&gt; $shadow_size,
           );

       otherwise just draw a box for the non-alpha source:

         $shadow_work-&gt;box
           (
           filled =&gt; 1,
           color =&gt; [ 255 ],
           xmin =&gt; $shadow_size,
           ymin =&gt; $shadow_size,
           xmax =&gt; $shadow_size + $src-&gt;getwidth() - 1,
           ymax =&gt; $shadow_size + $src-&gt;getheight() - 1,
           );

       Blur the work shadow:

         $shadow_work-&gt;filter(type =&gt; "gaussian", stddev =&gt; $shadow_size);

       Convert it to an RGB image with alpha:

         $shadow_work = $shadow_work-&gt;convert
            (
             matrix =&gt; [ [ 0, $red / 255 ],
                          [ 0, $green / 255 ],
                          [ 0, $blue / 255 ],
                          [ 1 ] ]
            );

       Draw that on the output image:

         $out-&gt;rubthrough(src =&gt; $shadow_work);

       Draw our original image on the output image, perhaps with an offset:

         $out-&gt;rubthrough
           (
           src =&gt; $src,
           tx =&gt; $shadow_size + $x_offset,
           ty =&gt; $shadow_size + $y_offset,
           );

       See <u>samples/drop_shadow.pl</u> for an example of this recipe.

</pre><h4><b>AUTHOR</b></h4><pre>
       Tony Cook &lt;<a href="mailto:tony@develop-help.com">tony@develop-help.com</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Imager, Imager::Files, Imager::Draw.

perl v5.40.1                                       2025-03-16                              <u>Imager::<a href="../man3pm/Cookbook.3pm.html">Cookbook</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>