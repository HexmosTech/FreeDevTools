<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imager::Font - Font handling for Imager.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libimager-perl">libimager-perl_1.027+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Imager::Font - Font handling for Imager.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Imager;

         $t1font = Imager::Font-&gt;new(file =&gt; 'pathtofont.pfb');
         $ttfont = Imager::Font-&gt;new(file =&gt; 'pathtofont.ttf');
         $w32font = Imager::Font-&gt;new(face =&gt; 'Times New Roman');

         $blue = Imager::Color-&gt;new("#0000FF");
         $font = Imager::Font-&gt;new(file  =&gt; 'pathtofont.ttf',
                                   color =&gt; $blue,
                                   size  =&gt; 30);

         ($neg_width,
          $global_descent,
          $pos_width,
          $global_ascent,
          $descent,
          $ascent,
          $advance_width,
          $right_bearing) = $font-&gt;bounding_box(string=&gt;"Foo");

         my $bbox_object = $font-&gt;bounding_box(string=&gt;"Foo");

         # documented in Imager::Draw
         $img-&gt;string(font  =&gt; $font,
                    text  =&gt; "Model-XYZ",
                    x     =&gt; 15,
                    y     =&gt; 40,
                    size  =&gt; 40,
                    color =&gt; $red,
                    aa    =&gt; 1);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module manages, the font object returned by Imager::Font-&gt;new will typically be of a class derived
       from Imager::Font.

       new This creates a font object to pass to functions that take a font argument.

             $font = Imager::Font-&gt;new(file  =&gt; 'denmark.ttf',
                                       index =&gt; 0,
                                       color =&gt; $blue,
                                       size  =&gt; 30,
                                       aa    =&gt; 1);

           This  creates  a  font  which is the TrueType font <u>denmark.ttf</u>.  It's default color is $blue, default
           size is 30 pixels and it's rendered anti-aliased by default.  Imager can see which  type  of  font  a
           file is by looking at the suffix of the file name for the font.  A suffix of "ttf" is taken to mean a
           TrueType  font  while  a suffix of "pfb" is taken to mean a Type 1 Postscript font.  If Imager cannot
           tell which type a font is you can tell it explicitly by using the "type" parameter:

             $t1font = Imager::Font-&gt;new(file =&gt; 'fruitcase', type =&gt; 't1');
             $ttfont = Imager::Font-&gt;new(file =&gt; 'arglebarf', type =&gt; 'tt');

           The "index" parameter is used to select a single face from a font file containing more than one face,
           for example, from a Macintosh font suitcase or a ".dfont" file.

           If any of the "color", "size" or "aa" parameters are omitted when calling  "Imager::Font-&gt;new()"  the
           they take the following values:

             color =&gt; Imager::Color-&gt;new(255, 0, 0, 0);  # this default should be changed
             size  =&gt; 15
             aa    =&gt; 0
             index =&gt; 0

           To use Win32 fonts supply the face name of the font:

             $font = Imager::Font-&gt;new(face=&gt;'Arial Bold Italic');

           There isn't any access to other logical font attributes, but this typically isn't necessary for Win32
           TrueType fonts, since you can construct the full name of the font as above.

           Other logical font attributes may be added if there is sufficient demand.

           Parameters:

           •   "file" - name of the file to load the font from.

           •

               "face"  -  face name.  This is used only under Win32 to create a GDI based font.  This is ignored
               if the "file" parameter is supplied.

           •   "type" - font driver to use.  Currently the permitted values for this are:

               •   "tt" - FreeType 1.x driver.  Supports TrueType (".ttf") fonts.

               •

                   "t1" - T1 Lib driver.  Supports Postscript Type 1 fonts.  Allows for synthesis of  underline,
                   strikethrough and overline.

               •   "ft2"  -  FreeType  2.x  driver.   Supports  many  different font formats.  Also supports the
                   <b>transform()</b> method.

           •   "color" - the default color used with this font.  Default: red.

           •   "size" - the default size used with this font.  Default: 15.

           •   "utf8" - if non-zero then text supplied  to  $img-&gt;string(...)  and  $font-&gt;bounding_box(...)  is
               assumed to be UTF-8 encoded by default.

           •   "align" - the default value for the $img-&gt;string(...) "align" parameter.  Default: 1.

           •   "vlayout" - the default value for the $img-&gt;string(...) "vlayout" parameter.  Default: 0.

           •   "aa" - the default value for the $im-&gt;string(...) "aa" parameter.  Default: 0.

           •   "index" - for font file containing multiple fonts this selects which font to use.  This is useful
               for Macintosh "DFON" (<u>.dfont</u>) and suitcase font files.

               If you want to use a suitcase font you will need to tell Imager to use the FreeType 2.x driver by
               setting "type" to 'ft2':

                 my $font = Imager::Font-&gt;new(file=&gt;$file, index =&gt; 1, type=&gt;'ft2')
                   or die Imager-&gt;errstr;

           Returns the new font object on success. Returns "undef" on failure and sets an error message readable
           with "Imager-&gt;errstr".

       <b>bounding_box()</b>
           Returns the bounding box for the specified string.  Example:

             my ($neg_width,
                 $global_descent,
                 $pos_width,
                 $global_ascent,
                 $descent,
                 $ascent,
                 $advance_width,
                 $right_bearing) = $font-&gt;bounding_box(string =&gt; "A Fool");

             my $bbox_object = $font-&gt;bounding_box(string =&gt; "A Fool");

           $neg_width
               the  relative  start  of a the string.  In some cases this can be a negative number, in that case
               the first letter stretches to the left of the starting position that is specified in  the  string
               method of the Imager class

           $global_descent
               how far down the lowest letter of the entire font reaches below the baseline (this is often j).

           $pos_width
               how  wide  the  string  from  the  starting  position  is.   The  total  width  of  the string is
               "$pos_width-$neg_width".

           $descent
           $ascent
               the same as &lt;$global_descent&gt; and &lt;$global_ascent&gt; except that they are only for  the  characters
               that appear in the string.

           $advance_width
               the  distance from the start point that the next string output should start at, this is often the
               same as $pos_width, but can be different if the final character overlaps the right  side  of  its
               character cell.

           $right_bearing
               The  distance  from  the  right  side of the final glyph to the end of the advance width.  If the
               final glyph overflows the advance width this value is negative.

           Obviously we can stuff all the results into an array just as well:

             @metrics = $font-&gt;bounding_box(string =&gt; "testing 123");

           Note that extra values may be added, so $metrics[-1] isn't supported.  It's possible to translate the
           output by a passing coordinate to the bounding box method:

             @metrics = $font-&gt;bounding_box(string =&gt; "testing 123", x=&gt;45, y=&gt;34);

           This gives the bounding box as if the string had been put down  at  "(x,y)"  By  giving  bounding_box
           'canon' as a true value it's possible to measure the space needed for the string:

             @metrics = $font-&gt;bounding_box(string=&gt;"testing",size=&gt;15,canon=&gt;1);

           This returns the same values in $metrics[0] and $metrics[1], but:

            $bbox[2] - horizontal space taken by glyphs
            $bbox[3] - vertical space taken by glyphs

           Returns an Imager::Font::BBox object in scalar context, so you can avoid all those confusing indexes.
           This has methods as named above, with some extra convenience methods.

           Parameters are:

           •   "string" - the string to calculate the bounding box for.  Required.

           •   "size" - the font size to use.  Default: value set in Imager::Font-&gt;<b>new()</b>, or 15.

           •   "sizew" - the font width to use.  Default to the value of the "size" parameter.

           •   "utf8"  -  For  drivers that support it, treat the string as UTF-8 encoded.  For versions of perl
               that support Unicode (5.6 and  later),  this  will  be  enabled  automatically  if  the  'string'
               parameter is already a UTF-8 string. See "UTF-8" for more information.  Default: the "utf8" value
               passed to Imager::Font-&gt;new(...) or 0.

           •   "x",  "y" - offsets applied to @box[0..3] to give you a adjusted bounding box.  Ignored in scalar
               context.

           •   "canon" - if non-zero and  the  "x",  "y"  parameters  are  not  supplied,  then  $pos_width  and
               $global_ascent values will returned as the width and height of the text instead.

           On success returns either the list of bounds, or a bounding box object in scalar context.  Returns an
           empty list or "undef" on failure and sets an error message readable with "Imager-&gt;errstr".

           The  transformation  matrix  set  by  "<b>transform()</b>"  has no effect on the result of this method - the
           bounds of the untransformed text is returned.

       <b>string()</b>
           The $img-&gt;string(...) method is now documented in "<b>string()</b>" in Imager::Draw

       align(string=&gt;$text,size=&gt;$size,x=&gt;...,y=&gt;...,valign =&gt; ...,halign=&gt;...)
           Higher level text output - outputs the text aligned as specified around the given point (x,y).

             # "Hello" centered at 100, 100 in the image.
             my ($left, $top, $right, $bottom) =
               $font-&gt;align(string=&gt;"Hello",
                            x=&gt;100, y=&gt;100,
                            halign=&gt;'center', valign=&gt;'center',
                            image=&gt;$image);

           Takes the same parameters as $font-&gt;<b>draw()</b>, and the following extra parameters:

           •   "valign" - Possible values are:

               "top"
                   Point is at the top of the text.

               "bottom"
                   Point is at the bottom of the text.

               "baseline"
                   Point is on the baseline of the text (default.)

               "center"
                   Point is vertically centered within the text.

           •   "halign"

               •   "left" - the point is at the left of the text.

               •   "start" - the point is at the start point of the text.

               •   "center" - the point is horizontally centered within the text.

               •   "right" - the point is at the right end of the text.

               •   "end" - the point is at the end point of the text.

           •   "image" - The image to draw to.  Set to "undef" to avoid drawing but still calculate the bounding
               box.

           Returns a list specifying the bounds of the drawn text on success.  Returns an empty list on failure,
           if an "image" parameter was supplied the error message can be read with  "$image-&gt;errstr",  otherwise
           it's available as "Imager-&gt;errstr".

       <b>dpi()</b>
       dpi(xdpi=&gt;$xdpi, ydpi=&gt;$ydpi)
       dpi(dpi=&gt;$dpi)
           Set or retrieve the spatial resolution of the image in dots per inch.  The default is 72 dpi.

           This isn't implemented for all font types yet.

           Possible parameters are:

           •   "xdpi", "ydpi" - set the horizontal and vertical resolution in dots per inch.

           •   "dpi" - set both horizontal and vertical resolution to this value.

           Returns  a  list  containing the previous "xdpi", "ydpi" values on success.  Returns an empty list on
           failure, with an error message returned in "Imager-&gt;errstr".

       <b>transform()</b>
             $font-&gt;transform(matrix=&gt;$matrix);

           Applies a transformation to the font, where matrix is an array ref of numbers representing a  2  x  3
           matrix:

             [  $matrix-&gt;[0],  $matrix-&gt;[1],  $matrix-&gt;[2],
                $matrix-&gt;[3],  $matrix-&gt;[4],  $matrix-&gt;[5]   ]

           Not all font types support transformations, these will return false.

           It's  possible  that  a  driver  will  disable  hinting  if  you  use  a  transformation,  to prevent
           discontinuities in the transformations.  See the  end  of  the  test  script  t/t38ft2font.t  for  an
           example.

           Currently only the ft2 (FreeType 2.x) driver supports the <b>transform()</b> method.

           See samples/slant_text.pl for a sample using this function.

           Note that the transformation is done in font co-ordinates where y increases as you move up, not image
           co-ordinates where y decreases as you move up.

           transform() has no effect on the results of "<b>bounding_box()</b>".

           Returns true on success.  Returns false on failure with the cause readable from "Imager-&gt;errstr".

       has_chars(string=&gt;$text)
           Checks if the characters in $text are defined by the font.

           In  a  list  context  returns a list of true or false value corresponding to the characters in $text,
           true if the character is defined, false if not.  In scalar context  returns  a  string  of  "NUL"  or
           non-"NUL" characters.  Supports UTF-8 where the font driver supports UTF-8.

           Not all fonts support this method (use $font-&gt;can("has_chars") to check.)

           On  error,  returns an empty list or undef in scalar context, and sets an error message readable with
           "Imager-&gt;errstr".

           •   "string" - string of characters to check for.  Required.  Must contain at least one character.

           •   "utf8" - For drivers that support it, treat the string as UTF-8 encoded.  For  versions  of  perl
               that  support  Unicode  (5.6  and  later),  this  will  be  enabled automatically if the 'string'
               parameter is already a UTF-8 string. See "UTF-8" for more information.  Default: the "utf8" value
               passed to Imager::Font-&gt;new(...) or 0.

       <b>face_name()</b>
           Returns the internal name of the face.  Not all font types support this method  yet,  so  you  should
           check with "$font-&gt;can("face_name")" before calling "face_name".

       glyph_names(string=&gt;$string [, utf8=&gt;$utf8 ][, reliable_only=&gt;0 ] );
           Returns a list of glyph names for each of the characters in the string.  If the character has no name
           then "undef" is returned for the character.

           Some  font  files  do  not  include  glyph  names, in this case FreeType 2 will not return any names.
           FreeType 1 can return standard names even if there are no glyph names in the font.

           FreeType 2 has an API function that returns true  only  if  the  font  has  "reliable  glyph  names",
           unfortunately  this always returns false for TrueType fonts.  This can avoid the check of this API by
           supplying "reliable_only" as  0.   The  consequences  of  using  this  on  an  unknown  font  may  be
           unpredictable,  since the FreeType documentation doesn't say how those name tables are unreliable, or
           how FT2 handles them.

           Both FreeType 1.x and 2.x allow support for glyph names to not be included.

           If the supplied "string" is marked as UTF-8 or the "utf8" parameter is true and the  supplied  string
           does  not  contain  valid  UTF-8,  returns  an  empty  string  and set an error message readable from
           "Imager-&gt;errstr",

       <b>can_glyph_names()</b>
           As a class method, returns true if the underlying library supports returning glyph names.

           As an object method, returns true if the supplied font supports returning glyph names.

       draw
           This is used by Imager's <b>string()</b> method to implement drawing text.  See "<b>string()</b>" in Imager::Draw.

</pre><h4><b>MULTIPLE</b> <b>MASTER</b> <b>FONTS</b></h4><pre>
       The FreeType 2 driver supports multiple master fonts:

       <b>is_mm()</b>
           Test if the font is a multiple master font.

       <b>mm_axes()</b>
           Returns a list of the axes that can be changes in the font.  Each entry is an array  reference  which
           contains:

           1.  Name of the axis.

           2.  minimum value for this axis.

           3.  maximum value for this axis

       set_mm_coords(coords=&gt;\@values)
           Blends  an  interpolated  design from the master fonts.  @values must contain as many values as there
           are axes in the font.

       For example, to select the minimum value in each axis:

         my @axes = $font-&gt;mm_axes;
         my @coords = map $_-&gt;[1], @axes;
         $font-&gt;set_mm_coords(coords=&gt;\@coords);

       It's possible other drivers will support multiple master fonts in the future, check if your selected font
       object supports the <b>is_mm()</b> method using the <b>can()</b> method.

</pre><h4><b>UTF-8</b></h4><pre>
       There are 2 ways of rendering Unicode characters with Imager:

       •   For versions of perl that support it, use perl's native UTF-8 strings.  This is the simplest method.

       •   Hand build your own UTF-8 encoded strings.  Only recommended if your version of  perl  has  no  UTF-8
           support.

       Imager  won't  construct  characters  for you, so if want to output Unicode character 00C3 "LATIN CAPITAL
       LETTER A WITH DIAERESIS", and your font doesn't support it, Imager will <u>not</u> build  it  from  0041  "LATIN
       CAPITAL LETTER A" and 0308 "COMBINING DIAERESIS".

       To check if a driver supports UTF-8 call the <b>utf8()</b> method:

       <b>utf8()</b>
           Return true if the font supports UTF-8.

   <b>Native</b> <b>UTF-8</b> <b>Support</b>
       If  your version of perl supports UTF-8 and the driver supports UTF-8, just use the $im-&gt;<b>string()</b> method,
       and it should do the right thing.

   <b>Build</b> <b>your</b> <b>own</b>
       In this case you need to build your own UTF-8 encoded characters.

       For example:

        $x = pack("C*", 0xE2, 0x80, 0x90); # character code 0x2010 HYPHEN

       You need to be careful with versions of perl that have UTF-8 support, since your string may end up doubly
       UTF-8 encoded.

       For example:

        $x = "A\xE2\x80\x90\x41\x{2010}";
        substr($x, -1, 0) = "";
        # at this point $x is has the UTF-8 flag set, but has 5 characters,
        # none, of which is the constructed UTF-8 character

       The test script t/t38ft2font.t has a small example of this after the comment:

         # an attempt using emulation of UTF-8

</pre><h4><b>DRIVER</b> <b>CONTROL</b></h4><pre>
       If you don't supply a 'type' parameter to Imager::Font-&gt;<b>new()</b>, but you  do  supply  a  'file'  parameter,
       Imager will attempt to guess which font driver to used based on the extension of the font file.

       Since  some  formats  can be handled by more than one driver, a priority list is used to choose which one
       should be used, if a given format can be handled by more than one driver.

       priorities
           The current priorities can be retrieved with:

             @drivers = Imager::Font-&gt;priorities();

           You can set new priorities and save the old priorities with:

             @old = Imager::Font-&gt;priorities(@drivers);

           If you supply driver names that are not currently supported, they will be ignored.

           Note that by default the priority list no longer includes "tt" and "t1", so typically you  will  need
           to have Imager::Font::FT2 installed to create fonts with Imager.

             my @old = Imager::Font-&gt;priorities(qw(tt ft2 t1));

       register
           Registers an extra font driver.  Accepts the following parameters:

           •   type   -   a   brief   identifier   for   the   font  driver.   You  can  supply  this  value  to
               "Imager::Font-&gt;new()" to create fonts of this type.  Required.

           •   class - the font class name.  Imager will attempted to load this module by name.  Required.

           •   files - a regular expression to match against file names.  If supplied this must be a valid  perl
               regular  expression.   If  not  supplied  you can only create fonts of this type by supplying the
               "type" parameter to "Imager::Font-&gt;new()"

           •   description - a brief description of the font driver.  Defaults to the value supplied in "class".

</pre><h4><b>AUTHOR</b></h4><pre>
       Arnar M. Hrafnkelsson, <a href="mailto:addi@umich.edu">addi@umich.edu</a> And a great deal of help  from  others  -  see  the  <u>README</u>  for  a
       complete list.

</pre><h4><b>BUGS</b></h4><pre>
       The  $pos_width  member  returned by the <b>bounding_box()</b> method has historically returned different values
       from different drivers.  The FreeType 1.x and 2.x, and the Win32 drivers return the max  of  the  advance
       width and the right edge of the right-most glyph.  The Type 1 driver always returns the right edge of the
       right-most glyph.

       The newer advance_width and right_bearing values allow access to any of the above.

</pre><h4><b>REVISION</b></h4><pre>
       $Revision$

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/Imager.3.html">Imager</a></b>(3),        <b>Imager::Font::<a href="../man3/FreeType2.3.html">FreeType2</a></b>(3),       <b>Imager::Font::<a href="../man3/Type1.3.html">Type1</a></b>(3),       <b>Imager::Font::<a href="../man3/Win32.3.html">Win32</a></b>(3),
       <b>Imager::Font::<a href="../man3/Truetype.3.html">Truetype</a></b>(3), <b>Imager::Font::<a href="../man3/BBox.3.html">BBox</a></b>(3)

        <a href="http://imager.perl.org/">http://imager.perl.org/</a>

perl v5.40.1                                       2025-03-16                                  <u>Imager::<a href="../man3pm/Font.3pm.html">Font</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>