<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imager::IO - Imager's io_layer object.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libimager-perl">libimager-perl_1.027+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Imager::IO - Imager's io_layer object.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # Imager supplies Imager::IO objects to various callbacks
         my $IO = ...;

         my $count = $IO-&gt;write($data);
         my $count = $IO-&gt;read($buffer, $max_count);
         my $position = $IO-&gt;seek($offset, $whence);
         my $status = $IO-&gt;close;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Imager uses an abstraction when dealing with image files to allow the same code to work with disk files,
       in memory data and callbacks.

       If you're writing an Imager file handler your code will be passed an Imager::IO object to write to or
       read from.

         Note that Imager::IO can only work with collections of bytes - if you need to read UTF-8 data you will
       need to read the bytes and decode them.  If you want to write UTF-8 data you will need to encode your
       characters to bytes and write the bytes.

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
       new_fd($fd)
           Create a new I/O layer based on a file descriptor.

             my $io = Imager::IO-&gt;new(fileno($fh));

       new_buffer($data)
           Create a new I/O layer based on a memory buffer.

           Buffer I/O layers are read only.

           $data  can  either  a  simple  octet  string,  or  a reference to an octet string.  If $data contains
           characters with a code point above 0xFF an exception will be thrown.

       new_cb($writecb, $readcb, $seekcb, $closecb)
           Create a new I/O layer based on callbacks.  See "I/O Callbacks" in Imager::Files for details  on  the
           behavior of the callbacks.

       new_fh($fh)
           Create a new I/O layer based on a perl file handle.

       <b>new_bufchain()</b>
           Create  a  new  "bufchain"  based  I/O  layer.   This accumulates the file data as a chain of buffers
           starting from an empty stream.

           Use the "<b>slurp()</b>" method to retrieve the accumulated content into a perl string.

</pre><h4><b>BUFFERED</b> <b>I/O</b> <b>METHODS</b></h4><pre>
       These methods use buffered  I/O  to  improve  performance  unless  you  call  <b>set_buffered()</b>  to  disable
       buffering.

       Prior to Imager 0.86 the write and read methods performed raw I/O.

       write($data)
           Call  to write to the file.  Returns the number of bytes written.  The data provided may contain only
           characters \x00 to \xFF - characters outside this range will cause this method to <b>croak()</b>.

           If you supply a UTF-8 flagged string it will be  converted  to  a  byte  string,  which  may  have  a
           performance impact.

           Returns  -1  on  error,  though  in  most  cases if the result of the write isn't the number of bytes
           supplied you'll want to treat it as an error anyway.

       read($buffer, $size)
             my $buffer;
             my $count = $io-&gt;read($buffer, $max_bytes);

           Reads up to <u>$max_bytes</u> bytes from the current position in  the  file  and  stores  them  in  <u>$buffer</u>.
           Returns  the  number  of bytes read on success or an empty list on failure.  Note that a read of zero
           bytes is <b>not</b> a failure, this indicates end of file.

       read2($size)
             my $buffer = $io-&gt;read2($max_bytes);

           An alternative interface to read, that might be simpler to use in some cases.

           Returns the data read or an empty list.  At end of file the data read will be an empty string.

       seek($offset, $whence)
             my $new_position = $io-&gt;seek($offset, $whence);

           Seek to a new position in the file.  Possible values for <u>$whence</u> are:

           •   "SEEK_SET" - <u>$offset</u> is the new position in the file.

           •   "SEEK_CUR" - <u>$offset</u> is the offset from the current position in the file.

           •   "SEEK_END" - <u>$offset</u> is the offset relative to the end of the file.

           Note that seeking past the end of the file may or may not result in an error.

           Any buffered output will be flushed, if flushing fails, <b>seek()</b> will return -1.

           Returns the new position in the file, or -1 on error.

       <b>getc()</b>
           Return the next byte from the stream.

           Returns the ordinal of the byte or -1 on error or end of file.

             while ((my $c = $io-&gt;getc) != -1) {
               print chr($c);
             }

       <b>nextc()</b>
           Discard the next byte from the stream.

           Returns nothing.

       <b>gets()</b>
       gets($max_size)
       gets($max_size, $end_of_line)
           Returns the next line of input from the stream, as terminated by "end_of_line".

           The default "max_size" is 8192.

           The default "end_of_line" is "ord "\n"".

           Returns nothing if the stream is in error or at end of file.

           Returns the line as a string, including the line terminator (if one was found) on success.

             while (defined(my $line = $io-&gt;gets)) {
               # do something with $line
             }

       <b>peekc()</b>
           Return the buffered next character from the stream, loading the buffer if necessary.

           For an unbuffered stream a buffer will be setup and loaded with a single character.

           Returns the ordinal of the byte or -1 on error or end of file.

             my $c = $io-&gt;peekc;

       peekn($size)
           Returns up to the next "size" bytes from the file as a string.

           Only up to the stream buffer size bytes (currently 8192) can be peeked.

           This method ignores the buffering state of the stream.

           Returns nothing on EOF.

             my $s = $io-&gt;<a href="../man4/peekn.4.html">peekn</a>(4);
             if ($s =~ /^(II|MM)\*\0/) {
               print "TIFF image";
             }

       putc($code)
           Write a single character to the stream.

           Returns "code" on success, or -1 on failure.

       <b>close()</b>
             my $result = $io-&gt;close;

           Call when you're done with the file.  If the IO object is connected to a file this  won't  close  the
           file handle, but buffers may be flushed (if any).

           Returns 0 on success, -1 on failure.

       <b>eof()</b>
             $io-&gt;eof

           Test  if the stream is at end of file.  No further read requests will be passed to your read callback
           until you <b>seek()</b>.

       <b>error()</b>
           Test if the stream has encountered a read or write error.

             my $data = $io-&gt;<a href="../man100/read2.100.html">read2</a>(100);
             $io-&gt;error
                and die "Failed";

           When the stream has the error flag set no further read or write  requests  will  be  passed  to  your
           callbacks until you seek.

       <b>flush()</b>
             $io-&gt;flush
               or die "Flush error";

           Flush any buffered output.  This will not call lower write layers when the stream has it's error flag
           set.

           Returns a true value on success.

       <b>is_buffered()</b>
           Test if buffering is enabled for this stream.

           Returns a true value if the stream is buffered.

       set_buffered($enabled)
           If $enabled is a non-zero integer, enable buffering, other disable it.

           Disabling  buffering  will  flush  any  buffered  output, but any buffered input will be retained and
           consumed by input methods.

           Returns true if any buffered output was flushed successfully, false if there was  an  error  flushing
           output.

</pre><h4><b>RAW</b> <b>I/O</b> <b>METHODS</b></h4><pre>
       These call the underlying I/O abstraction directly.

       <b>raw_write()</b>
           Call  to write to the file.  Returns the number of bytes written.  The data provided may contain only
           characters \x00 to \xFF - characters outside this range will cause this method to <b>croak()</b>.

           If you supply a UTF-8 flagged string it will be  converted  to  a  byte  string,  which  may  have  a
           performance impact.

           Returns  -1  on  error,  though  in  most  cases if the result of the write isn't the number of bytes
           supplied you'll want to treat it as an error anyway.

       <b>raw_read()</b>
             my $buffer;
             my $count = $io-&gt;raw_read($buffer, $max_bytes);

           Reads up to <u>$max_bytes</u> bytes from the current position in  the  file  and  stores  them  in  <u>$buffer</u>.
           Returns  the  number  of bytes read on success or an empty list on failure.  Note that a read of zero
           bytes is <b>not</b> a failure, this indicates end of file.

       <b>raw_read2()</b>
             my $buffer = $io-&gt;raw_read2($max_bytes);

           An alternative interface to raw_read, that might be simpler to use in some cases.

           Returns the data read or an empty list.

       <b>raw_seek()</b>
             my $new_position = $io-&gt;raw_seek($offset, $whence);

           Seek to a new position in the file.  Possible values for <u>$whence</u> are:

           •   "SEEK_SET" - <u>$offset</u> is the new position in the file.

           •   "SEEK_CUR" - <u>$offset</u> is the offset from the current position in the file.

           •   "SEEK_END" - <u>$offset</u> is the offset relative to the end of the file.

           Note that seeking past the end of the file may or may not result in an error.

           Returns the new position in the file, or -1 on error.

       <b>raw_close()</b>
             my $result = $io-&gt;raw_close;

           Call when you're done with the file.  If the IO object is connected to a file this  won't  close  the
           file handle.

           Returns 0 on success, -1 on failure.

</pre><h4><b>UTILITY</b> <b>METHODS</b></h4><pre>
       <b>slurp()</b>
           Retrieve the data accumulated from an I/O layer object created with the <b>new_bufchain()</b> method.

             my $data = $io-&gt;slurp;

       <b>dump()</b>
           Dump the internal buffering state of the I/O object to "stderr".

             $io-&gt;dump();

</pre><h4><b>AUTHOR</b></h4><pre>
       Tony Cook &lt;<a href="mailto:tonyc@cpan.org">tonyc@cpan.org</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Imager, Imager::Files

perl v5.40.1                                       2025-03-16                                    <u>Imager::<a href="../man3pm/IO.3pm.html">IO</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>