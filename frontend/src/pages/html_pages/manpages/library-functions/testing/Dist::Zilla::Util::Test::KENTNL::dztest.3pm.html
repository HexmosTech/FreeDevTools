<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dist::Zilla::Util::Test::KENTNL::dztest - Shared dist testing logic for easy dzil things</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdist-zilla-util-test-kentnl-perl">libdist-zilla-util-test-kentnl-perl_1.005014-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Dist::Zilla::Util::Test::KENTNL::dztest - Shared dist testing logic for easy dzil things

</pre><h4><b>VERSION</b></h4><pre>
       version 1.005014

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Test::More;
         use Test::DZil qw( simple_ini );
         use Dist::Zilla::Util::Test::KENTNL qw( dztest );

         my $test = dztest;

         ## utility method.
         $test-&gt;add_file( 'dist.ini', simple_ini( .... ));

         ## build the dist
         # 1x subtest
         $test-&gt;build_ok;

         ## assert prereqs are identical to the hash
         ## extracting them from distmeta
         # 1x subtest
         $test-&gt;prereqs_deeply( { } );

         ## Test for specific log messages by regex
         # 1x subtest
         #  - tests there are messages
         #  - each regex must match a message
         my @list = (
           [ $regex, $indepdent_reason ],
           [ $regex ],
         );
         $test-&gt;has_messages( $reason, \@list );

         ## Test for any deep structure addressed
         ## By a Data::DPath expression
         # 1x subtest
         #   - asserts the expression returns a result
         #   - compares the structure against the expected one.
         $test-&gt;meta_path_deeply(
             '/author/*/[1]',
             [ 'E. Xavier Ample &lt;<a href="mailto:example@example.org">example@example.org</a>&gt;' ],
             'The 1st author is the example author emitted by simple_ini'
         );

         ## Test for a file existing on the build side
         ## and return it if it exists.
         my $file = $test-&gt;test_has_built_file('dist.ini');

</pre><h4><b>METHODS</b></h4><pre>
   <b>"add_file"</b>
       Add a file to the scratch directory to be built.

         # -&gt;add_file( $path, $string );
         # -&gt;add_file( \@path, $string );
         $test-&gt;add_file('dist.ini', simple_ini() );
         $test-&gt;add_file('lib/Foo.pm', $content );
         $test-&gt;add_file([ 'lib','Foo.pm' ], $content );

   <b>"build_ok"</b>
       Build the dist safely, and report "ok" if the dist builds "ok", spewing file listings via "note"

       "BAIL_OUT" is triggered if any of "add_file" don't arrive in the intended location.

   <b>"prereqs_deeply"</b>
       Demand "distmeta" "prereqs" exactly match those specified.

         $test-&gt;prereqs_deeply( { hash } );

       This is just a more memorable version of

         $test-&gt;meta_path_deeply('/prereqs/', { });

   <b>"has_messages"</b>
       Test that there are messages, and all the given rules match messages.

         $test-&gt;has_messages( 'Some descriptor', [
            [ $regex, $description ],
            [ $regex, $description ],
         ]);

   <b>"meta_path_deeply"</b>
         $test-&gt;meta_path_deeply( $expression, $expected_data, $reason );

       Uses $expression as a "Data::DPath" expression to pick a <u>LIST</u> of nodes from "distmeta", and compare that
       <u>LIST</u> vs $expected_data

         # Matches only the first author.
         $test-&gt;meta_path_deeply('/author/*/[1]', ['SomeAuthorName &lt;wadef@wath&gt;'], $reason );

         # Matches all authors
         $test-&gt;meta_path_deeply('/author/*/*', ['SomeAuthorName &lt;wadef@wath&gt;','Author2', ..], $reason );

   <b>"test_has_built_file"</b>
       Test ( as in, "Test::More::ok" ) that a file exists in the "dzil" build output directory.

       Also returns it if it exists.

         $test-&gt;test_has_built_file('dist.ini');  # ok/fail

         my $object = test-&gt;test_has_built_file('dist.ini'); # ok/fail + return

   <b>"create_plugin"</b>
       Create an instance of the named plugin and return it.

         my $t = dztest();
         $t-&gt;add_file('dist.ini', simple_ini( ... ));
         my $plugin = $t-&gt;create_plugin('GatherDir' =&gt; { ignore_dotfiles =&gt; 1 });
         # poke at $plugin here

       Note: This lets you test plugins outside the requirement of inter-operating with "dzil" phases, but has
       the downside of not interacting with "dzil" phases, or even being <u>*seen*</u> by "dzil" phases.

       But this is OK if you want to directly test a modules interface instead of doing it through the proxy of
       "dzil"

       You can also subsequently create many such objects without requiring a "dzil build" penalty.

   <b>"source_file"</b>
       Re-fetch content added with "add_file".

       You probably want "built_file".

         $test-&gt;source_file( $path  );
         $test-&gt;source_file( \@path );

       Returns "undef" if the file does not exist.

         if ( my $content = $test-&gt;source_file('dist.ini') ) {
           print $content-&gt;slurp_raw;
         }

   <b>"safe_build"</b>
       Ensure the distribution is built safely, returns exceptions or "undef".

         if ( $test-&gt;safe_build ) {
           say "Failed build";
         }

   <b>"safe_configure"</b>
       Construct the internal builder object safely. Returns exceptions or "undef".

         if( $test-&gt;configure ) { say "configure failed" }

   <b>"built_file"</b>
       Returns the named file if it exists in the build, "undef" otherwise.

         my $file = $test-&gt;built_file('dist.ini');

   <b>"note_tempdir_files"</b>
       Recursively walk "tempdir" and note its contents.

   <b>"note_builddir_files"</b>
       Recursively walk "builddir"(output) and note its contents.

   <b>"has_message"</b>
       Assert there are messages, and this single message exists:

         $test-&gt;has_message( $regex, $description );

   <b>"run_command"</b>
       Execute a Dist::Zilla command in the constructed scratch directory.

         $test-&gt;run_command(['build','foo']);

       The syntax is technically:

         $test-&gt;run_command( $argv, $arg );

       But I'm yet to work out the meaning of the latter.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
   <b>"configure"</b>
       Construct the internal builder object.

         $test-&gt;configure;

</pre><h4><b>AUTHOR</b></h4><pre>
       Kent Fredric &lt;<a href="mailto:kentnl@cpan.org">kentnl@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2017 by Kent Fredric &lt;<a href="mailto:kentnl@cpan.org">kentnl@cpan.org</a>&gt;.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.34.0                                       2022-06-13              <u>Dist::Zilla::U...:KENTNL::<a href="../man3pm/dztest.3pm.html">dztest</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>