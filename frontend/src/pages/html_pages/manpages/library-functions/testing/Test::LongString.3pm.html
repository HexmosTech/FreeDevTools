<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::LongString - tests strings for equality, with more helpful failures</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-longstring-perl">libtest-longstring-perl_0.17-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::LongString - tests strings for equality, with more helpful failures

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Test::More tests =&gt; 1;
           use Test::LongString;
           like_string( $html, qr/(perl|cpan)\.org/ );

           #     Failed test (html-test.t at line 12)
           #          got: "&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Trans"...
           #       length: 58930
           #     doesn't match '(?-xism:(perl|cpan)\.org)'

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides some drop-in replacements for the string comparison functions of Test::More, but
       which are more suitable when you test against long strings.  If you've ever had to search for text in a
       multi-line string like an HTML document, or find specific items in binary data, this is the module for
       you.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>is_string(</b> <b>$string,</b> <b>$expected</b> <b>[,</b> <b>$label</b> <b>]</b> <b>)</b>
       "is_string()" is equivalent to "Test::More::is()", but with more helpful diagnostics in case of failure.

       •   It doesn't print the entire strings in the failure message.

       •   It reports the lengths of the strings that have been compared.

       •   It reports the length of the common prefix of the strings.

       •   It reports the line and column the strings started to differ on.

       •   In the diagnostics, non-ASCII characters are escaped as "\x{xx}".

       For example:

           is_string( $soliloquy, $juliet );

           #     Failed test (soliloquy.t at line 15)
           #          got: "To be, or not to be: that is the question:\x{0a}Whether"...
           #       length: 1490
           #     expected: "O Romeo, Romeo,\x{0a}wherefore art thou Romeo?\x{0a}Deny thy"...
           #       length: 154
           #     strings begin to differ at char 1 (line 1 column 1)

   <b>is_string_nows(</b> <b>$string,</b> <b>$expected</b> <b>[,</b> <b>$label</b> <b>]</b> <b>)</b>
       Like "is_string()", but removes whitespace (in the "\s" sense) from the arguments before comparing them.

   <b>like_string(</b> <b>$string,</b> <b>qr/regex/</b> <b>[,</b> <b>$label</b> <b>]</b> <b>)</b>
   <b>unlike_string(</b> <b>$string,</b> <b>qr/regex/</b> <b>[,</b> <b>$label</b> <b>]</b> <b>)</b>
       "like_string()"  and  "unlike_string()" are replacements for "Test::More:like()" and "unlike()" that only
       print the beginning of the received string in the  output.   Unfortunately,  they  can't  print  out  the
       position where the regex failed to match.

           like_string( $soliloquy, qr/Romeo|Juliet|Mercutio|Tybalt/ );

           #     Failed test (soliloquy.t at line 15)
           #          got: "To be, or not to be: that is the question:\x{0a}Whether"...
           #       length: 1490
           #     doesn't match '(?-xism:Romeo|Juliet|Mercutio|Tybalt)'

   <b>contains_string(</b> <b>$string,</b> <b>$substring</b> <b>[,</b> <b>$label</b> <b>]</b> <b>)</b>
       "contains_string()"  searches  for  <u>$substring</u> in <u>$string</u>.  It's the same as "like_string()", except that
       it's not a regular expression search.

           contains_string( $soliloquy, "Romeo" );

           #     Failed test (soliloquy.t at line 10)
           #         searched: "To be, or not to be: that is the question:\x{0a}Whether"...
           #   and can't find: "Romeo"

       As of version 0.12, "contains_string()" will also report the Longest Common  SubString  (LCSS)  found  in
       <u>$string</u>  and,  if  the LCSS is short enough, the surroundings will also be shown under <u>LCSS</u> <u>Context</u>. This
       should help debug tests for really long strings like HTML output, so you'll get something like:

          contains_string( $html, '&lt;div id="MainContent"&gt;' );
          #   Failed test at t/foo.t line 10.
          #     searched: "&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Stric"...
          #   can't find: "&lt;div id="MainContent"&gt;"
          #         LCSS: "ainContent""
          # LCSS context: "dolor sit amet&lt;/span&gt;\x{0a}&lt;div id="mainContent" class="

       You can turn off LCSS reporting by setting $Test::LongString::LCSS to 0, or by specifying an argument  to
       "use":

           use Test::LongString lcss =&gt; 0;

   <b>lacks_string(</b> <b>$string,</b> <b>$substring</b> <b>[,</b> <b>$label</b> <b>]</b> <b>)</b>
       "lacks_string()" makes sure that <u>$substring</u> does NOT exist in <u>$string</u>.  It's the same as "like_string()",
       except that it's not a regular expression search.

           lacks_string( $soliloquy, "slings" );

           #     Failed test (soliloquy.t at line 10)
           #         searched: "To be, or not to be: that is the question:\x{0a}Whether"...
           #        and found: "slings"
           #      at position: 147 (line 3 column 4)

</pre><h4><b>CONTROLLING</b> <b>OUTPUT</b></h4><pre>
       By  default, only the first 50 characters of the compared strings are shown in the failure message.  This
       value is in $Test::LongString::Max, and can be set at run-time.

       You can also set it by specifying an argument to "use":

           use Test::LongString max =&gt; 100;

       When the compared strings begin to differ after a large prefix, Test::LongString will not print them from
       the beginning, but will start at the middle,  more  precisely  at  $Test::LongString::Context  characters
       before  the  first  difference.  By  default this value is 10 characters. If you want Test::LongString to
       always  print  the  beginning   of   compared   strings   no   matter   where   they   differ,   undefine
       $Test::LongString::Context.

       When  computing line numbers this module uses "\n" to count line endings. This may not be appropriate for
       strings on your platform, and can be overridden by  setting  the  $Test::LongString::EOL  variable  to  a
       suitable  regular  expression  (either  a  reference  to  a  regular  expression  or a string that can be
       interpolated into a regular expression.)

       You can also set it by specifying an argument to "use":

           use Test::LongString eol =&gt; "\x{0a}\x{0c}";

</pre><h4><b>AUTHOR</b></h4><pre>
       Written by Rafael Garcia-Suarez. Thanks to Mark  Fowler  (and  to  Joss  Whedon)  for  the  inspirational
       Acme::Test::Buffy. Thanks to Andy Lester for lots of patches.

       This  program  is  free  software;  you may redistribute it and/or modify it under the same terms as Perl
       itself.

       A git repository for this module is available at

           git://github.com/rgs/Test-LongString.git

       and the project page at

           <a href="http://github.com/rgs/Test-LongString">http://github.com/rgs/Test-LongString</a>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Test::Builder, Test::Builder::Tester, Test::More.

perl v5.36.0                                       2022-10-13                              <u>Test::<a href="../man3pm/LongString.3pm.html">LongString</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>