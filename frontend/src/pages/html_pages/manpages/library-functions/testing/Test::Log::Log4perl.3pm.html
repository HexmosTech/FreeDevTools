<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::Log::Log4perl - test log4perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-log-log4perl-perl">libtest-log-log4perl-perl_0.32-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::Log::Log4perl - test log4perl

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # setup l4p
         use Log::Log4Perl;
         # do your normal Log::Log4Perl setup here
         use Test::Log::Log4perl;

         # get the loggers
         my $logger  = Log::Log4perl-&gt;get_logger("Foo::Bar");
         my $tlogger = Test::Log::Log4perl-&gt;get_logger("Foo::Bar");

         # test l4p
         Test::Log::Log4perl-&gt;start();

         # declare we're going to log something
         $tlogger-&gt;error("This is a test");

         # log that something
         $logger-&gt;error("This is a test");

         # test that those things matched
         Test::Log::Log4perl-&gt;end("Test that that logs okay");

         # we also have a simplified version:
         {
           my $foo = Test::Log::Log4perl-&gt;expect(['foo.bar.quux', warn =&gt; qr/hello/ ]);
           # ... do something that should log 'hello'
         }
         # $foo goes out of scope; this triggers the test.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module can be used to test that you're logging the right thing with Log::Log4perl.  It checks that
       we get what, and only what, we expect logged by your code.

       The basic process is very simple.  Within your test script you get one or more loggers from
       <b>Test::Log::Log4perl</b> with the "get_logger" method just like you would with <b>Log::Log4perl</b>.  You're going to
       use these loggers to declare what you think the code you're going to test should be logging.

         # declare a bunch of test loggers
         my $tlogger = Test::Log::Log4perl-&gt;get_logger("Foo::Bar");

       Then, for each test you want to do you need to start up the module.

         # start the test
         Test::Log::Log4perl-&gt;start();

       This diverts all subsequent attempts <b>Log::Log4perl</b> makes to log stuff and records them internally rather
       than passing them though to the Log4perl appenders as normal.

       You then need to declare with the loggers we created earlier what we hope Log4perl will be asked to log.
       This is the same syntax as Test::Log::Log4perl uses, except if you want you can use regular expressions:

         $tlogger-&gt;debug("fish");
         $tlogger-&gt;warn(qr/bar/);

       You then need to run your code that you're testing.

         # call some code that hopefully will call the log4perl methods
         # 'debug' with "fish" and 'warn' with something that contains 'bar'
         some_code();

       We finally need to tell <b>Test::Log4Perl</b> that we're done and it should do the comparisons.

         # start the test
         Test::Log::Log4perl-&gt;end("test name");

   <b>Methods</b>
       get_logger($category)
           Returns  a  new  instance  of  Test::Log::Log4perl  that  can be used to log expected messages in the
           category passed.

       Test::Log::Log4perl-&gt;expect(%start_args, ['dotted.path', 'warn' =&gt; qr(this), 'warn' =&gt; qr(that)], ..)
           Class convenience method. Used like this:

             { # start local scope
               my $foo = Test::Log::Log4perl-&gt;expect(['foo.bar.quux', warn =&gt; qr/hello/ ]);
               # ... do something that should log 'hello'
             } # $foo goes out of scope; this triggers the test.

       start
           Class method.  Start logging.  When you call this method it temporarily redirects  all  logging  from
           the standard logging locations to the internal logging routine until end is called.  Takes parameters
           to change the behavior of this (and only this) test.  See below.

       debug(@what)
       info(@what)
       warn(@what)
       error(@what)
       fatal(@what)
           Instance methods.  String of things that you're expecting to log, at the level you're expecting them,
           in what class.

       <b>end()</b>
       end($name)
           Ends  the  test  and compares what we've got with what we expected.  Switches logging back from being
           captured to going to wherever it was originally directed in the config.

   <b>Ignoring</b> <b>All</b> <b>Logging</b> <b>Messages</b>
       Sometimes you're going to be testing something that generates a load of spurious log  messages  that  you
       simply  want to ignore without testing their contents, but you don't want to have to reconfigure your log
       file.  The simplest way to do this is to do:

         use Test::Log::Log4perl;
         Test::Log::Log4perl-&gt;suppress_logging;

       All logging functions stop working.  Do not alter the Logging  classes  (for  example,  by  changing  the
       config file and use Log4perl's "init_and_watch" functionality) after this call has been made.

       This function will be effectively a no-op if the environmental variable "NO_SUPPRESS_LOGGING" is set to a
       true  value  (so  if  your code is behaving weirdly you can turn all the logging back on from the command
       line without changing any of the code)

   <b>Selectively</b> <b>Ignoring</b> <b>Logging</b> <b>Messages</b> <b>By</b> <b>Priority</b>
       It's a bad idea to completely ignore all messages.  What you probably want to do is ignore  some  of  the
       trivial  messages that you don't care about, and just test that there aren't any unexpected messages of a
       set priority.

       You can temporarily ignore any logging messages that are  made  by  passing  parameters  to  the  "start"
       routine

         # for this test, just ignore DEBUG, INFO, and WARN
         Test::Log::Log4perl-&gt;start( ignore_priority =&gt; "warn" );

         # you can use the levels constants to do the same thing
         use Log::Log4perl qw(:levels);
         Test::Log::Log4perl-&gt;start( ignore_priority =&gt; $WARN );

       You  might want to ignore all logging events at all (this can be used as quick way to not test the actual
       log messages, but just ignore the output.

         # for this test, ignore everything
         Test::Log::Log4perl-&gt;start( ignore_priority =&gt; "everything" );

         # contary to readability, the same thing (try not to write this)
         use Log::Log4perl qw(:levels);
         Test::Log::Log4perl-&gt;start( ignore_priority =&gt; $OFF );

       Or you might want to not ignore anything (which is the default, unless  you've  played  with  the  method
       calls mentioned below:)

         # for this test, ignore nothing
         Test::Log::Log4perl-&gt;start( ignore_priority =&gt; "nothing" );

         # contary to readability, the same thing (try not to write this)
         use Log::Log4perl qw(:levels);
         Test::Log::Log4perl-&gt;start( ignore_priority =&gt; $ALL );

       You  can  also  permanently  effect what things are ignored with the "ignore_priority" method call.  This
       persists between tests and isn't automatically reset after each call to "start".

         # ignore DEBUG, INFO and WARN for all future tests
         Test::Log::Log4perl-&gt;ignore_priority("warn");

         # you can use the levels constants to do the same thing
         use Log::Log4perl qw(:levels);
         Test::Log::Log4perl-&gt;ignore_priority($WARN);

         # ignore everything (no log messages will be logged)
         Test::Log::Log4perl-&gt;ignore_priority("everything");

         # ignore nothing (messages will be logged reguardless of priority)
         Test::Log::Log4perl-&gt;ignore_priority("nothing");

       Obviously, you may temporarily override whatever permanent.

</pre><h4><b>BUGS</b></h4><pre>
       Logging methods don't return the number of appenders they've written to (or  rather,  they  do,  as  it's
       always zero.)

       Changing  the  config  file  (if  you're watching it) while this is testing / suppressing everything will
       probably break everything.  As will creating new appenders, etc...

</pre><h4><b>AUTHOR</b></h4><pre>
         Chia-liang Kao &lt;<a href="mailto:clkao@clkao.org">clkao@clkao.org</a>&gt;
         Mark Fowler &lt;<a href="mailto:mark@twoshortplanks.com">mark@twoshortplanks.com</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
         Copyright 2010 Chia-liang Kao all rights reserved.
         Copyright 2005 Fotango Ltd all rights reserved.

         Licensed under the same terms as Perl itself.

perl v5.36.0                                       2022-12-08                           <u>Test::Log::<a href="../man3pm/Log4perl.3pm.html">Log4perl</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>