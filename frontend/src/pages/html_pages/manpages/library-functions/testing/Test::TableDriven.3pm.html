<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::TableDriven - write tests, not scripts that run them</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-tabledriven-perl">libtest-tabledriven-perl_0.02-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::TableDriven - write tests, not scripts that run them

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use A::Module qw/or two!/;
          use Test::TableDriven (
            foo =&gt; { input   =&gt; 'expected output',
                     another =&gt; 'test',
                   },

            bar =&gt; [[some =&gt; 'more tests'],
                    [that =&gt; 'run in order'],
                    [refs =&gt; [qw/also work/]],
                    [[qw/this is also possible/] =&gt; { and =&gt; 'it works' }],
                   ],
          );

          runtests;

          sub foo {
             my $in  = shift;
             my $out = ...;
             return $out;
          }

          sub bar { same as foo }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Writing table-driven tests is usually a good idea.  Adding a test case doesn't require adding code, so
       it's easy to avoid fucking up the other tests.  However, actually going from a table of tests to a test
       that runs is non-trivial.

       "Test::TableDriven" makes writing the test drivers trivial.  You simply define your test cases and write
       a function that turns the input data into output data to compare against.  "Test::TableDriven" will
       compute how many tests need to be run, and then run the tests.

       Concentrate on your data and what you're testing, not "plan tests =" scalar keys %test_cases&gt; and a big
       foreach loop.

</pre><h4><b>WHAT</b> <b>DO</b> <b>I</b> <b>DO</b></h4><pre>
       Start by using the modules that you need for your tests:

          use strict;
          use warnings;
          use String::Length; # the module you're testing

       Then write some code to test the module:

          sub strlen {
              my $in  = shift;
              my $out = String::Length-&gt;strlen($in);
              return $out;
          }

       This "strlen" function will accept a test case (as $in) and turns it into something to compare against
       your test cases:

       Oh yeah, you need some test cases:

          use Test::TableDriven (
              strlen =&gt; { foo =&gt; 3,
                          bar =&gt; 3,
                          ...,
                        },
          );

       And you'll want those test to run somehow:

          runtests;

       Now execute the test file.  The output will look like:

          1..2
          ok 1 - strlen: bar =&gt; 3
          ok 2 - strlen: foo =&gt; 3

       Add another test case:

              strlen =&gt; { foo  =&gt; 3,
                          bar  =&gt; 3,
                          quux =&gt; 4,
                          ...,
                        },

       And your test still works:

          1..3
          ok 1 - strlen: bar =&gt; 3
          ok 2 - strlen: quux =&gt; 4
          ok 3 - strlen: foo =&gt; 3

       Yay.

</pre><h4><b>DETAILS</b></h4><pre>
       I'm not in a prose-generation mood right now, so here's a list of things to keep in mind:

       •   Don't forget to "runtests".  Just loading the module doesn't do a whole lot.

       •   If a subtest is not a subroutine name in the current package, runtests will die.

       •   If  a  subtest  definition  is  a  hashref,  the tests won't be run in order.  If it's an arrayref of
           arrayrefs, then the tests are run in order.

       •   If a test case "expects" a reference, "is_deeply" is used to compare the  expected  result  and  what
           your test returned.  If it's just a string, "is" is used.

       •   Feel free to use "Test::More::diag" and friends, if you like.

       •   Don't print to STDOUT.

       •   Especially don't print TAP to STDOUT :)

</pre><h4><b>EXPORT</b></h4><pre>
   <b>runtests</b>
       Run the tests.  Only call this once.

</pre><h4><b>BUGS</b></h4><pre>
       Report them to RT, or patch them against the git repository at:

          git clone git://git.jrock.us/Test-TableDriven

       (or &lt;<a href="http://git.jrock.us/">http://git.jrock.us/</a>&gt;).

</pre><h4><b>AUTHOR</b></h4><pre>
       Jonathan Rockway "&lt;jrockway AT cpan.org&gt;".

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This  module  is copyright (c) 2007 Jonathan Rockway.  You may use, modify, and redistribute it under the
       same terms as Perl itself.

perl v5.38.2                                       2024-03-07                             <u>Test::<a href="../man3pm/TableDriven.3pm.html">TableDriven</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>