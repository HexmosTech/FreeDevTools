<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::WWW::Mechanize::PSGI - Test PSGI programs using WWW::Mechanize</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-www-mechanize-psgi-perl">libtest-www-mechanize-psgi-perl_0.39-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::WWW::Mechanize::PSGI - Test PSGI programs using WWW::Mechanize

</pre><h4><b>VERSION</b></h4><pre>
       version 0.39

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # We're in a t/*.t test script...
         use Test::WWW::Mechanize::PSGI;

         my $mech = Test::WWW::Mechanize::PSGI-&gt;new(
             app =&gt; sub {
                 my $env = shift;
                 return [
                     200,
                     [ 'Content-Type' =&gt; 'text/html' ],
                     [ '&lt;html&gt;&lt;head&gt;&lt;title&gt;Hi&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;'
                     ]
                 ];
             },
         );
         $mech-&gt;get_ok('/');
         is( $mech-&gt;ct, 'text/html', 'Is text/html' );
         $mech-&gt;title_is('Hi');
         $mech-&gt;content_contains('Hello World');
         # ... and all other Test::WWW::Mechanize methods

</pre><h4><b>DESCRIPTION</b></h4><pre>
       PSGI is a specification to decouple web server environments from web application framework code.
       Test::WWW::Mechanize is a subclass of WWW::Mechanize that incorporates features for web application
       testing. The Test::WWW::Mechanize::PSGI module meshes the two to allow easy testing of PSGI applications.

       Testing web applications has always been a bit tricky, normally requiring starting a web server for your
       application and making real HTTP requests to it. This module allows you to test PSGI web applications but
       does not require a server or issue HTTP requests. Instead, it passes the HTTP request object directly to
       PSGI. Thus you do not need to use a real hostname: "<a href="http://localhost/">http://localhost/</a>" will do. However, this is
       optional. The following two lines of code do exactly the same thing:

         $mech-&gt;get_ok('/action');
         $mech-&gt;get_ok('<a href="http://localhost/action">http://localhost/action</a>');

       This makes testing fast and easy. Test::WWW::Mechanize provides functions for common web testing
       scenarios. For example:

         $mech-&gt;get_ok( $page );
         $mech-&gt;title_is( "Invoice Status", "Make sure we're on the invoice page" );
         $mech-&gt;content_contains( "Andy Lester", "My name somewhere" );
         $mech-&gt;content_like( qr/(cpan|perl)\.org/, "Link to perl.org or CPAN" );

       An alternative to this module is Plack::Test.

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
   <b>new</b>
       Behaves like, and calls, WWW::Mechanize's "new" method. You should pass in your application:

         my $mech = Test::WWW::Mechanize::PSGI-&gt;new(
             app =&gt; sub {
                 my $env = shift;
                 return [ 200, [ 'Content-Type' =&gt; 'text/plain' ], ['Hello World'] ],;
             },
             env =&gt; { REMOTE_USER =&gt; 'Foo Bar' },
         );

</pre><h4><b>METHODS:</b> <b>HTTP</b> <b>VERBS</b></h4><pre>
   <b>$mech-&gt;get_ok($url,</b> <b>[</b> <b>\%LWP_options</b> <b>,]</b> <b>$desc)</b>
       A wrapper around WWW::Mechanize's <b>get()</b>, with similar options, except the second argument needs to be a
       hash reference, not a hash. Like well-behaved "*_ok()" functions, it returns true if the test passed, or
       false if not.

       A default description of "GET $url" is used if none if provided.

   <b>$mech-&gt;head_ok($url,</b> <b>[</b> <b>\%LWP_options</b> <b>,]</b> <b>$desc)</b>
       A wrapper around WWW::Mechanize's <b>head()</b>, with similar options, except the second argument needs to be a
       hash reference, not a hash. Like well-behaved "*_ok()" functions, it returns true if the test passed, or
       false if not.

       A default description of "HEAD $url" is used if none if provided.

   <b>$mech-&gt;post_ok(</b> <b>$url,</b> <b>[</b> <b>\%LWP_options</b> <b>,]</b> <b>$desc</b> <b>)</b>
       A wrapper around WWW::Mechanize's <b>post()</b>, with similar options, except the second argument needs to be a
       hash reference, not a hash. Like well-behaved "*_ok()" functions, it returns true if the test passed, or
       false if not.

       A default description of "POST to $url" is used if none if provided.

   <b>$mech-&gt;put_ok(</b> <b>$url,</b> <b>[</b> <b>\%LWP_options</b> <b>,]</b> <b>$desc</b> <b>)</b>
       A wrapper around WWW::Mechanize's <b>put()</b>, with similar options, except the second argument needs to be a
       hash reference, not a hash. Like well-behaved "*_ok()" functions, it returns true if the test passed, or
       false if not.

       A default description of "PUT to $url" is used if none if provided.

   <b>$mech-&gt;submit_form_ok(</b> <b>\%params</b> <b>[,</b> <b>$desc]</b> <b>)</b>
       Makes a "submit_form()" call and executes tests on the results.  The form must be found, and then
       submitted successfully.  Otherwise, this test fails.

       <u>%params</u> is a hashref containing the params to pass to "submit_form()".  Note that the params to
       "submit_form()" are a hash whereas the params to this function are a hashref.  You have to call this
       function like:

           $agent-&gt;submit_form_ok({
               form_number =&gt; 3,
               fields      =&gt; {
                   username    =&gt; 'mungo',
                   password    =&gt; 'lost-and-alone',
               }
           }, "looking for 3rd form" );

       As with other test functions, $desc is optional.  If it is supplied then it will display when running the
       test harness in verbose mode.

       Returns true value if the specified link was found and followed successfully.  The HTTP::Response object
       returned by <b>submit_form()</b> is not available.

   <b>$mech-&gt;follow_link_ok(</b> <b>\%params</b> <b>[,</b> <b>$desc]</b> <b>)</b>
       Makes a "follow_link()" call and executes tests on the results.  The link must be found, and then
       followed successfully.  Otherwise, this test fails.

       <u>%params</u> is a hashref containing the params to pass to "follow_link()".  Note that the params to
       "follow_link()" are a hash whereas the params to this function are a hashref.  You have to call this
       function like:

           $mech-&gt;follow_link_ok( {n=&gt;3}, "looking for 3rd link" );

       As with other test functions, $desc is optional.  If it is supplied then it will display when running the
       test harness in verbose mode.

       Returns a true value if the specified link was found and followed successfully.  The HTTP::Response
       object returned by <b>follow_link()</b> is not available.

   <b>click_ok(</b> <b>$button[,</b> <b>$desc]</b> <b>)</b>
       Clicks the button named by $button.  An optional $desc can be given for the test.

</pre><h4><b>METHODS:</b> <b>CONTENT</b> <b>CHECKING</b></h4><pre>
   <b>$mech-&gt;html_lint_ok(</b> <b>[$desc]</b> <b>)</b>
       Checks the validity of the HTML on the current page.  If the page is not HTML, then it fails.  The URI is
       automatically appended to the <u>$desc</u>.

       Note that HTML::Lint must be installed for this to work.  Otherwise, it will blow up.

   <b>$mech-&gt;title_is(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the title of the page is the given string.

           $mech-&gt;title_is( "Invoice Summary" );

   <b>$mech-&gt;title_like(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the title of the page matches the given regex.

           $mech-&gt;title_like( qr/Invoices for (.+)/

   <b>$mech-&gt;title_unlike(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the title of the page matches the given regex.

           $mech-&gt;title_unlike( qr/Invoices for (.+)/

   <b>$mech-&gt;base_is(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the base of the page is the given string.

           $mech-&gt;base_is( "<a href="http://example.com/">http://example.com/</a>" );

   <b>$mech-&gt;base_like(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the base of the page matches the given regex.

           $mech-&gt;base_like( qr{<a href="http://example.com/index.php">http://example.com/index.php</a>?PHPSESSID=(.+)});

   <b>$mech-&gt;base_unlike(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the base of the page matches the given regex.

           $mech-&gt;base_unlike( qr{<a href="http://example.com/index.php">http://example.com/index.php</a>?PHPSESSID=(.+)});

   <b>$mech-&gt;content_is(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page matches the given string

   <b>$mech-&gt;content_contains(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page contains <u>$str</u>.

   <b>$mech-&gt;content_lacks(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page lacks <u>$str</u>.

   <b>$mech-&gt;content_like(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page matches <u>$regex</u>.

   <b>$mech-&gt;content_unlike(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page does NOT match <u>$regex</u>.

   <b>$mech-&gt;has_tag(</b> <b>$tag,</b> <b>$text</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the page has a $tag tag with the given content in its text.

   <b>$mech-&gt;has_tag_like(</b> <b>$tag,</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the page has a $tag tag with the given content in its text.

   <b>$mech-&gt;followable_links()</b>
       Returns a list of links that WWW::Mechanize can follow.  This is only http and https links.

   <b>$mech-&gt;page_links_ok(</b> <b>[</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow all links on the current page and test for HTTP status 200

           $mech-&gt;page_links_ok('Check all links');

   <b>$mech-&gt;page_links_content_like(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow all links on the current page and test their contents for <u>$regex</u>.

           $mech-&gt;page_links_content_like( qr/foo/,
             'Check all links contain "foo"' );

   <b>$mech-&gt;links_ok(</b> <b>$links</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow specified links on the current page and test for HTTP status 200.  The links may be specified as a
       reference to an array containing WWW::Mechanize::Link objects, an array of URLs, or a scalar URL name.

           my @links = $mech-&gt;find_all_links( url_regex =&gt; qr/cnn\.com$/ );
           $mech-&gt;links_ok( \@links, 'Check all links for cnn.com' );

           my @links = qw( index.html search.html about.html );
           $mech-&gt;links_ok( \@links, 'Check main links' );

           $mech-&gt;links_ok( 'index.html', 'Check link to index' );

   <b>$mech-&gt;link_status_is(</b> <b>$links,</b> <b>$status</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow specified links on the current page and test for HTTP status passed.  The links may be specified
       as a reference to an array containing WWW::Mechanize::Link objects, an array of URLs, or a scalar URL
       name.

           my @links = $mech-&gt;followable_links();
           $mech-&gt;link_status_is( \@links, 403,
             'Check all links are restricted' );

   <b>$mech-&gt;link_status_isnt(</b> <b>$links,</b> <b>$status</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow specified links on the current page and test for HTTP status passed.  The links may be specified
       as a reference to an array containing WWW::Mechanize::Link objects, an array of URLs, or a scalar URL
       name.

           my @links = $mech-&gt;followable_links();
           $mech-&gt;link_status_isnt( \@links, 404,
             'Check all links are not 404' );

   <b>$mech-&gt;link_content_like(</b> <b>$links,</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow specified links on the current page and test the resulting content of each against <u>$regex</u>.  The
       links may be specified as a reference to an array containing WWW::Mechanize::Link objects, an array of
       URLs, or a scalar URL name.

           my @links = $mech-&gt;followable_links();
           $mech-&gt;link_content_like( \@links, qr/Restricted/,
               'Check all links are restricted' );

   <b>$mech-&gt;link_content_unlike(</b> <b>$links,</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow specified links on the current page and test that the resulting content of each does not match
       <u>$regex</u>.  The links may be specified as a reference to an array containing WWW::Mechanize::Link objects,
       an array of URLs, or a scalar URL name.

           my @links = $mech-&gt;followable_links();
           $mech-&gt;link_content_unlike( \@links, qr/Restricted/,
             'No restricted links' );

   <b>$mech-&gt;stuff_inputs(</b> <b>[\%options]</b> <b>)</b>
       Finds all free-text input fields (text, textarea, and password) in the current form and fills them to
       their maximum length in hopes of finding application code that can't handle it.  Fields with no maximum
       length and all textarea fields are set to 66000 bytes, which will often be enough to overflow the data's
       eventual receptacle.

       There is no return value.

       If there is no current form then nothing is done.

       The hashref $options can contain the following keys:

       •   ignore

           hash value is arrayref of field names to not touch, e.g.:

               $mech-&gt;stuff_inputs( {
                   ignore =&gt; [qw( specialfield1 specialfield2 )],
               } );

       •   fill

           hash  value  is  default string to use when stuffing fields.  Copies of the string are repeated up to
           the max length of each field.  E.g.:

               $mech-&gt;stuff_inputs( {
                   fill =&gt; '@'  # stuff all fields with something easy to recognize
               } );

       •   specs

           hash value is arrayref of hashrefs with which you can pass detailed instructions about how to stuff a
           given field.  E.g.:

               $mech-&gt;stuff_inputs( {
                   specs=&gt;{
                       # Some fields are datatype-constrained.  It's most common to
                       # want the field stuffed with valid data.
                       widget_quantity =&gt; { fill=&gt;'9' },
                       notes =&gt; { maxlength=&gt;2000 },
                   }
               } );

           The specs allowed are <u>fill</u> (use this fill for the field rather than the default) and  <u>maxlength</u>  (use
           this as the field's maxlength instead of any maxlength specified in the HTML).

</pre><h4><b>AUTHOR</b></h4><pre>
       Leon Brocard &lt;<a href="mailto:acme@astray.com">acme@astray.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2009 by Leon Brocard.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.36.0                                       2022-08-28                    <u>Test::WWW::Mechanize::<a href="../man3pm/PSGI.3pm.html">PSGI</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>