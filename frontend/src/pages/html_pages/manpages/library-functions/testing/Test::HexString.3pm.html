<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>"Test::HexString" - test binary strings with hex dump diagnostics</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-hexstring-perl">libtest-hexstring-perl_0.03-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       "Test::HexString" - test binary strings with hex dump diagnostics

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Test::More tests =&gt; 1;
        use Test::HexString;

        my $data = generate_some_output;

        is_hexstr( $data, "\x01\x02\x03\x04", 'Generated output' );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This testing module provides a single function, "is_hexstr()", which asserts that the given string
       matches what was expected. When the strings match (i.e.  compare equal using the "eq" operator), the
       behaviour is identical to the usual "is()" function provided by "Test::More".

       When the strings are different, a hex dump is produced as diagnostic, rather than the string values being
       printed raw. This may be beneficial if the string contains largely binary data, such as may be produced
       by binary file or network protocol modules.

       To print the hex dump when it fails, each string is broken into 16 byte chunks. The first pair of chunks
       that fail to match are then printed, in both hexadecimal and character form, in a message in the
       following format:

        #   Failed test at -e line 1.
        #   at bytes 0-0xf (0-15)
        #   got: | 61 20 6c 6f 6e 67 20 73 74 72 69 6e 67 20 68 65 |a long string he|
        #   exp: | 61 20 6c 6f 6e 67 20 53 74 72 69 6e 67 20 68 65 |a long String he|
        # Looks like you failed 1 test of 1.

       Only bytes in the range "0x20-0x7e" are printed as literal characters. Any other byte is rendered as ".":

        #   Failed test at -e line 1.
        #   at bytes 0-0xf (0-15)
        #   got: | 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
        #   exp: | 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 |................|
        # Looks like you failed 1 test of 1.

       Only the first differing line is printed; because otherwise it may result in a long output because of
       misaligned bytes.

       If STDOUT is a terminal, then different bytes are printed in bold for visibility.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>is_hexstr(</b> <b>$got,</b> <b>$expect,</b> <b>$name</b> <b>)</b>
       Test that the string $got is what was expected by $expect. If the strings are not equal, a hex dump is
       printed showing the region where they first start to differ.

</pre><h4><b>AUTHOR</b></h4><pre>
       Paul Evans &lt;<a href="mailto:leonerd@leonerd.org.uk">leonerd@leonerd.org.uk</a>&gt;

perl v5.36.0                                       2022-11-20                               <u>Test::<a href="../man3pm/HexString.3pm.html">HexString</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>