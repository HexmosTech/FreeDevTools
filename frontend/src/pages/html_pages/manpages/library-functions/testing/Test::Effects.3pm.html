<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::Effects - Test all effects at once (return value, I/O, warnings, exceptions, etc.)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-effects-perl">libtest-effects-perl_0.002000-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::Effects - Test all effects at once (return value, I/O, warnings, exceptions, etc.)

</pre><h4><b>VERSION</b></h4><pre>
       This document describes Test::Effects version 0.002000

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Test::Effects;

           # Test all possible detectable side-effects of some code...
           effects_ok { your_code_here() }
                  {
                      return =&gt; $expected_scalar_context_return_value,
                      warn   =&gt; qr/match expected warning text/,
                      stdout =&gt; '',  # i.e. Doesn't print anything.
                  }
                  =&gt; 'Description of test';

           # Test only specifically requested side-effects of some code...
           effects_ok { your_code_here() }
                  ONLY {
                      return =&gt; \@expected_list_context_return_values,
                      stderr =&gt; 'Expected output to STDERR',
                      die    =&gt; undef,  # i.e. Doesn't die.
                      exit   =&gt; undef,  # i.e. Doesn't exit either.
                  }
                  =&gt; 'Description of test';

           # Test that some code has no detectable side-effects...
           effects_ok { your_code_here() };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Test::Effects provides a single exported subroutine: "effects_ok"

       This sub expects a block of code (or sub ref) as its first argument, followed by an optional hash ref as
       its second, and an optional string as its third.

       The first argument specifies some code to be tested. This code is run in void context by default, but may
       instead be called in either list or scalar context, depending on the test specification provided by the
       second argument. The block is run within a call to "Test::Trap::trap()", so all warnings, exceptions,
       output, and exit attempts are trapped.  The block may contain calls to other Test::Builder-based testing
       modules; these are handled correctly within the overall test.

       The second argument is a hash reference, whose entries specify the expected side-effects of executing the
       block. You specify the name of the side-effect you're interested in as the key, and the "effect" you
       expected as the value. Side-effects that are not explicitly specified are automatically tested for
       default behaviour (e.g. no warnings, no exceptions, no output, not call to "exit()", etc. If the entire
       hash is omitted, all possible side-effects are tested for default behaviour (in other words, did the
       block of code have <u>no</u> side-effects whatsoever?)

       The third argument is the overall description of the test (i.e. the usual final argument for Perl tests).
       If omitted, "effects_ok()" generates a description based on the line number at which it was called.

</pre><h4><b>INTERFACE</b></h4><pre>
   <b>"use</b> <b>Test::Effects;"</b>
       Loads the module, and exports the "effects_ok()", "VERBOSE()", "ONLY()", and "TIME()" subroutines (see
       below). Also exports the standard interface from the Test::More module.

   <b>"use</b> <b>Test::Effects</b> <b>tests</b> <b>=&gt;</b> <b>$N;"</b>
       Exactly the same as:

           use Test::More tests =&gt; $N;

       In fact, "use Test::Effects" can take all the same arguments as "use Test::More".

   <b>"use</b> <b>Test::Effects</b> <b>import</b> <b>=&gt;</b> <b>[':minimal'];"</b>
       Only export the "effects_ok()" subroutine.

       Do not export "VERBOSE()", "ONLY()", "TIME()", or any of the Test::More interface.

   <b>"use</b> <b>Test::Effects</b> <b>import</b> <b>=&gt;</b> <b>[':more'];"</b>
       Only export the "effects_ok()" subroutine and the Test::More interface

       Do not export "VERBOSE()", "ONLY()", or "TIME()".

   <b>"effects_ok</b> <b>{BLOCK}</b> <b>{EFFECTS_HASH}</b> <b>=&gt;</b> <b>'TEST_DESCRIPTION';"</b>
       Test the code in the block, ensuring that the side-effects named by the keys of the hash match the
       corresponding hash values. Both the hash and the description arguments are optional.

       The effects that can be specified as key/value pairs in the hash are:

       "void_return =&gt; undef"
           Call the block in void context.

       "return      =&gt; $ARRAY_REFERENCE"
       "list_return =&gt; $ANY_SCALAR_VALUE"
           Call  the  block  in  list  context. The final value evaluated in the block should (deeply) match the
           specified array ref or scalar value of the option.

       "return        =&gt; $NON_ARRAYREF"
       "scalar_return =&gt; $ANY_SCALAR_VALUE"
           Call the block in scalar context. The final value evaluated  in  block  should  match  the  specified
           scalar value of the option.

       "stdout =&gt; $STRING"
           What the block wrote to "STDOUT" should be "eq" to $STRING.

       "stdout =&gt; $REGEX"
           What the block wrote to "STDOUT" should be match $REGEX.

       "stdout =&gt; $CODE_REF"
           The  subroutine  specified  by  the  code  ref should return true when passed what the block wrote to
           "STDOUT".

           The subroutine can call nested tests (such as Test::More's "is") or  Test::Tolerant's  "is_tol")  and
           these will be correctly handled.

       "stderr =&gt; $STRING"
       "stderr =&gt; $REGEX"
       "stderr =&gt; $CODE_REF"
           What the block writes to "STDERR" should "match" the specified value (either "eq", or "=~", or return
           true when passed as an argument).

           Note that, if this option is not specified, but the 'warn' option (see below) <u>is</u> specified, then this
           option defaults to the value of the 'warn' option.

       "warn =&gt; $STRING"
       "warn =&gt; $REGEX"
       "warn =&gt; $CODE_REF"
       "warn =&gt; [ $STRING1, $REGEX2, $CODE_REF3, $ETC ]"
           The  block should issue the specified number of warnings, and each of these warnings should match the
           corresponding value specified, in the order specified.

       "die =&gt; $STRING"
       "die =&gt; $REGEX"
       "die =&gt; $CODE_REF"
           The block should raise an exception, which should match the value specified.

           Note: when using OO exceptions, use a code ref to test them:

               die =&gt; sub { shift-&gt;isa('X::BadData') }

           You can also use Test::More-ish tests, if you prefer:

               die =&gt; sub { isa_ok(shift, 'X::BadData') }

       "exit =&gt; $NUMBER"
       "exit =&gt; $REGEX"
       "exit =&gt; $CODE_REF"
           The block should call "exit()" and the exit code should match the value specified.

       "timing =&gt; { min =&gt; $MIN_SEC, max =&gt; $MAX_SEC }"
       "timing =&gt; [$MIN_SEC, $MAX_SEC]"
       "timing =&gt; $MAX_SEC"
           This option performs a separate timing measurment for the block, by running it multiple times over at
           least 1 cpu-second and averaging the times required for each run  (i.e.  like  the  Benchmark  module
           does).

           When  passed a hash reference, the 'min' and 'max' entries specify the range of allowable timings (in
           seconds) for the block.  For example:

               # Test our new snooze() function...
               effects_ok { snooze(1.5, plus_or_minus=&gt;0.2); }
                          {
                               timing =&gt; { min =&gt; 1.3, max =&gt; 1.7 },
                          }
                          =&gt; 'snooze() slept about the right amount of time';

           The default for 'min' is zero seconds; the default for 'max' is eternity.

           If you use an array reference instead of a hash reference, the first value in the array is  taken  as
           the  minimum  time,  and  the  final value is taken as the maximum allowed time. Hence the above time
           specification could also be written:

               timing =&gt; [ 1.3, 1.7 ],

           But don't write:

               timing =&gt; [ 1.3 .. 1.7 ],

           (unless your limits are integers), because Perl truncates the bounds of a range, so it  treats  "[1.3
           .. 1.7]" as "[1 .. 1]".

           If you use a number instead of a reference, then number is taken as the maximum time allowed:

               timing =&gt; 3.2,    # Same as: timing =&gt; { min =&gt; 0, max =&gt; 3.2 }

           If you do not specify either time limit:

               timing =&gt; {},

           or:

               timing =&gt; [],

           then  the  "zero-to-eternity" defaults are used and "effects_ok()" simply times the block and reports
           the timing (as a success).

           Note that the timings measured using this option are considerably more accurate than  those  produced
           by the "TIME =&gt; 1" option (see below), but also take significantly longer to measure.

       Other configuration options that can be specified as key/value pairs in the hash are:

       "VERBOSE =&gt; $BOOLEAN"
           If the value is true, all side-effect tests are reported individually (running them in a subtest).

           When  this  option  is  false (or omitted) only the overall result, plus any individual failures, are
           reported.

       "ONLY =&gt; $BOOLEAN"
           If the value is true, only the effects explicitly requested by the other keys of this hash are tested
           for. In other words, this option causes "effects_ok()" to omit the "default" tests for unnamed  side-
           effects.

           When  this  option  is  false  (or omitted) unspecified options are tested for their expected default
           behaviour.

       "TIME =&gt; $BOOLEAN"
           If the value is true, the block is timed as it is executed.  The timing is reported in the final  TAP
           line.

           Note  that  this  option  is  entirely  independent  of  the  'timing'  option (which times the block
           repeatedly and then tests it against specified limits).

           In contrast, the 'TIME' option merely times the block once, while it is being evaluated for the other
           tests. This is much less accurate, but also much faster and much less intrusive, when you merely want
           an rough indication of performance.

       "WITHOUT =&gt; 'Module::Name'"
       "WITHOUT =&gt; qr/Module::.*/"
           Execute the block as if the specified module (or all modules matching the specified pattern) were not
           installed.

       "WITHOUT =&gt; 'lib/path/'"
       "WITHOUT =&gt; qr{lib/*}"
           Execute the block as if the specified library directory (or all directories  matching  the  specified
           pattern) were not accessible.

           The  specified  patch  <u>must</u>  include  at least one slash ("/"), otherwise it will be interpreted as a
           module name (see above). You can always add a redundant slash at the end of the path, if necessary:

               WITHOUT =&gt; 'lib',     # Test without the C&lt;lib.pm&gt; module

               WITHOUT =&gt; 'lib/',    # Test without the C&lt;lib&gt; directory

   <b>"VERBOSE</b> <u>$HASH_REF</u><b>"</b>
       A call to:

           effects_ok { BLOCK }
                      VERBOSE { return =&gt; 0, stdout =&gt; 'ok' }

       is just a shorthand for:

           effects_ok { BLOCK }
                      { return =&gt; 0, stdout =&gt; 'ok', VERBOSE =&gt; 1 }

   <b>"ONLY</b> <u>$HASH_REF</u><b>"</b>
       A call such as:

           effects_ok { BLOCK }
                      ONLY { return =&gt; 0, stdout =&gt; 'ok' }

       is just a shorthand for:

           effects_ok { BLOCK }
                      { return =&gt; 0, stdout =&gt; 'ok', ONLY =&gt; 1 }

   <b>"TIME</b> <u>$HASH_REF</u><b>"</b>
       A call such as:

           effects_ok { BLOCK }
                      TIME { return =&gt; 0, stdout =&gt; 'ok' }

       is just a shorthand for:

           effects_ok { BLOCK }
                      { return =&gt; 0, stdout =&gt; 'ok', TIME =&gt; 1 }

       Note that the "VERBOSE", "ONLY", and "TIME" subs can be "stacked" (in any combination and order):

           effects_ok { BLOCK }
                      TIME ONLY VERBOSE { return =&gt; 0, stdout =&gt; 'ok' }

           effects_ok { BLOCK }
                      VERBOSE ONLY { return =&gt; 0, stdout =&gt; 'ok' }

   <b>"use</b> <b>Test::Effects::VERBOSE;"</b>
       This causes every subsequent call to "effects_ok()" in the current lexical scope to act as if  it  had  a
       "VERBOSE =&gt; 1" option set.

       Note, however, that an explicit "VERBOSE =&gt; 0" in any call in the scope overrides this default.

   <b>"no</b> <b>Test::Effects::VERBOSE;"</b>
       This  causes  every  subsequent call to "effects_ok()" in the current lexical scope to act as if it had a
       "VERBOSE =&gt; 0" option set. Again, however, an explicit "VERBOSE =&gt; 1" in any call in the scope  overrides
       this default.

   <b>"use</b> <b>Test::Effects::ONLY;"</b>
       This  causes  every  subsequent call to "effects_ok()" in the current lexical scope to act as if it had a
       "ONLY =&gt; 1" option set.

       Note, however, that an explicit "ONLY =&gt; 0" in any call in the scope overrides this default.

   <b>"no</b> <b>Test::Effects::ONLY;"</b>
       This causes every subsequent call to "effects_ok()" in the current lexical scope to act as if  it  had  a
       "ONLY  =&gt;  0" option set. Again, however, an explicit "ONLY =&gt; 1" in any call in the scope overrides this
       default.

   <b>"use</b> <b>Test::Effects::TIME;"</b>
       This causes every subsequent call to "effects_ok()" in the current lexical scope to act as if  it  had  a
       "TIME =&gt; 1" option set.

       Note, however, that an explicit "TIME =&gt; 0" in any call in the scope overrides this default.

   <b>"no</b> <b>Test::Effects::TIME;"</b>
       This  causes  every subsequent call to "effects_ok()" in the current lexical scope to act as if it had <u>no</u>
       "TIME =&gt; 0" option set. Again, however, an explicit "TIME =&gt; 1" in any call in the scope  overrides  this
       default.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       "Second argument to effects_ok() must be hash or hash reference, not %s"
           "effects_ok()"  expects a hash as its second argument, but you passed something else. This can happen
           if you forget to put braces around a single option, such as:

               effects_ok { test_code() }
                          warn =&gt; qr/Missing arg/;

           That needs to be:

               effects_ok { test_code() }
                          { warn =&gt; qr/Missing arg };

           Or you may have accidentally used an array instead of a hash:

               effects_ok { test_code() }
                          [ warn =&gt; qr/Missing arg ];

           That is not supported, as it is being reserved for a future feature.

       "Invalid timing specification: timing =&gt; %s"
           The 'timing' option expects a hash reference, array reference, or a single number as its  value.  You
           specified some value that was something else (and which "effects_ok()" therefore didn't understand).

</pre><h4><b>CONFIGURATION</b> <b>AND</b> <b>ENVIRONMENT</b></h4><pre>
       Test::Effects requires no configuration files or environment variables.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       Requires Perl 5.14 (or better).

       Requires the Test::Trap module, v0.2.1 (or better).

</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
       None reported.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       Ironically,  the test suite for this module is as yet unsatisfactory.  (T.D.D. Barbie says: "Testing test
       modules is <u><b>HARD!</b></u>")

       No other bugs have been reported.

       Please report any bugs  or  feature  requests  to  "<a href="mailto:bug-test-effects@rt.cpan.org">bug-test-effects@rt.cpan.org</a>",  or  through  the  web
       interface at &lt;<a href="http://rt.cpan.org">http://rt.cpan.org</a>&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       Damian Conway  "&lt;<a href="mailto:DCONWAY@CPAN.org">DCONWAY@CPAN.org</a>&gt;"

</pre><h4><b>LICENCE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2012, Damian Conway "&lt;<a href="mailto:DCONWAY@CPAN.org">DCONWAY@CPAN.org</a>&gt;". All rights reserved.

       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself. See perlartistic.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE,  TO  THE  EXTENT
       PERMITTED  BY  APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
       PARTIES PROVIDE THE SOFTWARE "AS  IS"  WITHOUT  WARRANTY  OF  ANY  KIND,  EITHER  EXPRESSED  OR  IMPLIED,
       INCLUDING,  BUT  NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
       PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF  THE  SOFTWARE  IS  WITH  YOU.  SHOULD  THE
       SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

       IN  NO  EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY
       OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE  LIABLE
       TO  YOU  FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF
       THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING BUT NOT  LIMITED  TO  LOSS  OF  DATA  OR  DATA  BEING
       RENDERED  INACCURATE  OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE TO OPERATE
       WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF  SUCH
       DAMAGES.

perl v5.36.0                                       2023-07-17                                 <u>Test::<a href="../man3pm/Effects.3pm.html">Effects</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>