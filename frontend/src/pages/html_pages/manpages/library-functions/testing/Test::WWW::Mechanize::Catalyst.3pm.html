<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::WWW::Mechanize::Catalyst - Test::WWW::Mechanize for Catalyst</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-www-mechanize-catalyst-perl">libtest-www-mechanize-catalyst-perl_0.62-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::WWW::Mechanize::Catalyst - Test::WWW::Mechanize for Catalyst

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # We're in a t/*.t test script...
         use Test::WWW::Mechanize::Catalyst;

         # To test a Catalyst application named 'Catty':
         my $mech = Test::WWW::Mechanize::Catalyst-&gt;new(catalyst_app =&gt; 'Catty');

         $mech-&gt;get_ok("/"); # no hostname needed
         is($mech-&gt;ct, "text/html");
         $mech-&gt;title_is("Root", "On the root page");
         $mech-&gt;content_contains("This is the root page", "Correct content");
         $mech-&gt;follow_link_ok({text =&gt; 'Hello'}, "Click on Hello");
         # ... and all other Test::WWW::Mechanize methods

         # White label site testing
         $mech-&gt;host("foo.com");
         $mech-&gt;get_ok("/");

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Catalyst is an elegant MVC Web Application Framework.  Test::WWW::Mechanize is a subclass of
       WWW::Mechanize that incorporates features for web application testing. The Test::WWW::Mechanize::Catalyst
       module meshes the two to allow easy testing of Catalyst applications without needing to start up a web
       server.

       Testing web applications has always been a bit tricky, normally requiring starting a web server for your
       application and making real HTTP requests to it. This module allows you to test Catalyst web applications
       but does not require a server or issue HTTP requests. Instead, it passes the HTTP request object directly
       to Catalyst. Thus you do not need to use a real hostname: "<a href="http://localhost/">http://localhost/</a>" will do. However, this is
       optional. The following two lines of code do exactly the same thing:

         $mech-&gt;get_ok('/action');
         $mech-&gt;get_ok('<a href="http://localhost/action">http://localhost/action</a>');

       Links which do not begin with / or are not for localhost can be handled as normal Web requests - this is
       handy if you have an external single sign-on system. You must set allow_external to true for this:

         $mech-&gt;<a href="../man1/allow_external.1.html">allow_external</a>(1);

       You can also test a remote server by setting the environment variable CATALYST_SERVER; for example:

         $ CATALYST_SERVER=<a href="http://example.com/myapp">http://example.com/myapp</a> prove -l t

       will run the same tests on the application running at <a href="http://example.com/myapp">http://example.com/myapp</a> regardless of whether or
       not you specify http:://localhost for Test::WWW::Mechanize::Catalyst.

       Furthermore, if you set CATALYST_SERVER, the server will be regarded as a remote server even if your
       links point to localhost. Thus, you can use Test::WWW::Mechanize::Catalyst to test your live webserver
       running on your local machine, if you need to test aspects of your deployment environment (for example,
       configuration options in an http.conf file) instead of just the Catalyst request handling.

       This makes testing fast and easy. Test::WWW::Mechanize provides functions for common web testing
       scenarios. For example:

         $mech-&gt;get_ok( $page );
         $mech-&gt;title_is( "Invoice Status", "Make sure we're on the invoice page" );
         $mech-&gt;content_contains( "Andy Lester", "My name somewhere" );
         $mech-&gt;content_like( qr/(cpan|perl)\.org/, "Link to perl.org or CPAN" );

       This module supports cookies automatically.

       To use this module you must pass it the name of the application. See the SYNOPSIS above.

       Note that Catalyst has a special development feature: the debug screen. By default this module will treat
       responses which are the debug screen as failures. If you actually want to test debug screens, please use:

         $mech-&gt;{catalyst_debug} = 1;

       An alternative to this module is Catalyst::Test.

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
   <b>new</b>
       Behaves like, and calls, WWW::Mechanize's "new" method.  Any params passed in get passed to
       WWW::Mechanize's constructor. Note that we need to pass the name of the Catalyst application to the
       "use":

         use Test::WWW::Mechanize::Catalyst 'Catty';
         my $mech = Test::WWW::Mechanize::Catalyst-&gt;new;

</pre><h4><b>METHODS</b></h4><pre>
   <b>allow_external</b>
       Links which do not begin with / or are not for localhost can be handled as normal Web requests - this is
       handy if you have an external single sign-on system. You must set allow_external to true for this:

         $mech-&gt;<a href="../man1/allow_external.1.html">allow_external</a>(1);

       head2 catalyst_app

       The name of the Catalyst app which we are testing against. Read-only.

   <b>host</b>
       The host value to set the "Host:" HTTP header to, if none is present already in the request. If not set
       (default) then Catalyst::Test will set this to localhost:80

   <b>clear_host</b>
       Unset the host attribute.

   <b>has_host</b>
       Do we have a value set for the host attribute

   <b>$mech-&gt;get_ok($url,</b> <b>[</b> <b>\%LWP_options</b> <b>,]</b> <b>$desc)</b>
       A wrapper around WWW::Mechanize's <b>get()</b>, with similar options, except the second argument needs to be a
       hash reference, not a hash. Returns true or false.

   <b>$mech-&gt;title_is(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the title of the page is the given string.

           $mech-&gt;title_is( "Invoice Summary" );

   <b>$mech-&gt;title_like(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the title of the page matches the given regex.

           $mech-&gt;title_like( qr/Invoices for (.+)/

   <b>$mech-&gt;title_unlike(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the title of the page does NOT match the given regex.

           $mech-&gt;title_unlike( qr/Invoices for (.+)/

   <b>$mech-&gt;content_is(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page matches the given string.

   <b>$mech-&gt;content_contains(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page contains <u>$str</u>.

   <b>$mech-&gt;content_lacks(</b> <b>$str</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page lacks <u>$str</u>.

   <b>$mech-&gt;content_like(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page matches <u>$regex</u>.

   <b>$mech-&gt;content_unlike(</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Tells if the content of the page does NOT match <u>$regex</u>.

   <b>$mech-&gt;page_links_ok(</b> <b>[</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow all links on the current page and test for HTTP status 200

           $mech-&gt;page_links_ok('Check all links');

   <b>$mech-&gt;page_links_content_like(</b> <b>$regex,[</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow all links on the current page and test their contents for <u>$regex</u>.

           $mech-&gt;page_links_content_like( qr/foo/,
             'Check all links contain "foo"' );

   <b>$mech-&gt;page_links_content_unlike(</b> <b>$regex,[</b> <b>$desc</b> <b>]</b> <b>)</b>
       Follow all links on the current page and test their contents do not contain the specified regex.

           $mech-&gt;page_links_content_unlike(qr/Restricted/,
             'Check all links do not contain Restricted');

   <b>$mech-&gt;links_ok(</b> <b>$links</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Check the current page for specified links and test for HTTP status 200.  The links may be specified as a
       reference to an array containing WWW::Mechanize::Link objects, an array of URLs, or a scalar URL name.

           my @links = $mech-&gt;find_all_links( url_regex =&gt; qr/cnn\.com$/ );
           $mech-&gt;links_ok( \@links, 'Check all links for cnn.com' );

           my @links = qw( index.html search.html about.html );
           $mech-&gt;links_ok( \@links, 'Check main links' );

           $mech-&gt;links_ok( 'index.html', 'Check link to index' );

   <b>$mech-&gt;link_status_is(</b> <b>$links,</b> <b>$status</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Check the current page for specified links and test for HTTP status passed.  The links may be specified
       as a reference to an array containing WWW::Mechanize::Link objects, an array of URLs, or a scalar URL
       name.

           my @links = $mech-&gt;links();
           $mech-&gt;link_status_is( \@links, 403,
             'Check all links are restricted' );

   <b>$mech-&gt;link_status_isnt(</b> <b>$links,</b> <b>$status</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Check the current page for specified links and test for HTTP status passed.  The links may be specified
       as a reference to an array containing WWW::Mechanize::Link objects, an array of URLs, or a scalar URL
       name.

           my @links = $mech-&gt;links();
           $mech-&gt;link_status_isnt( \@links, 404,
             'Check all links are not 404' );

   <b>$mech-&gt;link_content_like(</b> <b>$links,</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Check the current page for specified links and test the content of each against <u>$regex</u>.  The links may be
       specified as a reference to an array containing WWW::Mechanize::Link objects, an array of URLs, or a
       scalar URL name.

           my @links = $mech-&gt;links();
           $mech-&gt;link_content_like( \@links, qr/Restricted/,
               'Check all links are restricted' );

   <b>$mech-&gt;link_content_unlike(</b> <b>$links,</b> <b>$regex</b> <b>[,</b> <b>$desc</b> <b>]</b> <b>)</b>
       Check the current page for specified links and test that the content of each does not match <u>$regex</u>.  The
       links may be specified as a reference to an array containing WWW::Mechanize::Link objects, an array of
       URLs, or a scalar URL name.

           my @links = $mech-&gt;links();
           $mech-&gt;link_content_like( \@links, qr/Restricted/,
             'Check all links are restricted' );

   <b>follow_link_ok(</b> <b>\%parms</b> <b>[,</b> <b>$comment]</b> <b>)</b>
       Makes a "follow_link()" call and executes tests on the results.  The link must be found, and then
       followed successfully.  Otherwise, this test fails.

       <u>%parms</u> is a hashref containing the params to pass to "follow_link()".  Note that the params to
       "follow_link()" are a hash whereas the parms to this function are a hashref.  You have to call this
       function like:

           $agent-&gt;follow_link_ok( {n=&gt;3}, "looking for 3rd link" );

       As with other test functions, $comment is optional.  If it is supplied then it will display when running
       the test harness in verbose mode.

       Returns true value if the specified link was found and followed successfully.  The HTTP::Response object
       returned by <b>follow_link()</b> is not available.

</pre><h4><b>CAVEATS</b></h4><pre>
   <b>External</b> <b>Redirects</b> <b>and</b> <b>allow_external</b>
       If you use non-fully qualified urls in your test scripts (i.e. anything without a host, such as
       "-&gt;get_ok( "/foo")" ) and your app redirects to an external URL, expect to be bitten once you come back
       to your application's urls (it will try to request them on the remote server). This is due to a
       limitation in WWW::Mechanize.

       One workaround for this is that if you are expecting to redirect to an external site, clone the TWMC
       object and use the cloned object for the external redirect.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Related modules which may be of interest: Catalyst, Test::WWW::Mechanize, WWW::Mechanize.

</pre><h4><b>AUTHOR</b></h4><pre>
       Ash Berlin "&lt;<a href="mailto:ash@cpan.org">ash@cpan.org</a>&gt;" (current maintainer)

       Original Author: Leon Brocard, "&lt;<a href="mailto:acme@astray.com">acme@astray.com</a>&gt;"

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2005-9, Leon Brocard

</pre><h4><b>LICENSE</b></h4><pre>
       This module is free software; you can redistribute it or modify it under the same terms as Perl itself.

perl v5.28.1                                       2019-02-21                <u>Test::WWW::Mechanize::<a href="../man3pm/Catalyst.3pm.html">Catalyst</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>