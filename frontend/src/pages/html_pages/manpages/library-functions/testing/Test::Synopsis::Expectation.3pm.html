<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::Synopsis::Expectation - Test that SYNOPSIS code produces expected results</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-synopsis-expectation-perl">libtest-synopsis-expectation-perl_0.12-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::Synopsis::Expectation - Test that SYNOPSIS code produces expected results

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Test::Synopsis::Expectation;

           synopsis_ok('eg/sample.pod');
           done_testing;

       Following, SYNOPSIS of <u>eg/sample.pod</u>

           my $num;
           $num = 1; # =&gt; 1
           ++$num;   # =&gt; is 2

           use PPI::Tokenizer;
           my $tokenizer = PPI::Tokenizer-&gt;new(\'code'); # =&gt; isa 'PPI::Tokenizer'

           my $str = 'Hello, I love you'; # =&gt; like qr/ove/

           my $obj = {
               foo =&gt; ["bar", "baz"],
           }; # =&gt; is_deeply { foo =&gt; ["bar", "baz"] }

           my $bool = 1; # =&gt; success

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module checks that a module's SYNOPSIS section is syntactically correct, and will also check that it
       produces the expected results, based on annotations you add in comments.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       •   synopsis_ok($files)

           This function tests SYNOPSIS codes of each files.  This function expects file names as an argument as
           ARRAYREF or SCALAR.  (This function is exported)

       •   <b>all_synopsis_ok()</b>

           This  function tests SYNOPSIS codes of the all of library files.  This function uses <u>MANIFEST</u> to list
           up the target files of testing.  (This function is exported)

       •   prepare($code_str)

           Register the executable codes to prepare for evaluation.

           If you use like;

               use Test::Synopsis::Expectation;
               Test::Synopsis::Expectation::prepare('my $foo = 1;');
               synopsis_ok('path/to/target.pm');
               done_testing;

               ### Following, SYNOPSIS of `target.pm`
               $foo; # =&gt; 1

           Then, SYNOPSIS of <u>target.pm</u> is the same as;

               my $foo = 1;
               $foo; # =&gt; 1

           (This function is not exported)

       •   set_ignorings

           Set the procedures which would like to ignore.

               use Test::Synopsis::Expectation;
               Test::Synopsis::Expectation::set_ignorings(['++$num;']);
               synopsis_ok(*DATA);
               done_testing;

               __DATA__
               =head1 SYNOPSIS

                   my $num;
                   $num = 1; # =&gt; 1
                   ++$num;
                   $num; # =&gt; 1

           In the above example, "++$num;" will be ignored.

</pre><h4><b>NOTATION</b> <b>OF</b> <b>EXPECTATION</b></h4><pre>
       Comment that starts at "# =&gt;" then this module treats the comment as test statement.

       •   # =&gt; is

               my $foo = 1; # =&gt; is 1

           This way is equivalent to the next.

               my $foo = 1;
               is $foo, 1;

           This carries out the same behavior as "Test::More::is".

       •   # =&gt;

               my $foo = 1; # =&gt; 1

           This notation is the same as "# =&gt; is"

       •   # =&gt; isa

               use Foo::Bar;
               my $instance = Foo::Bar-&gt;new; # =&gt; isa 'Foo::Bar'

           This way is equivalent to the next.

               use Foo::Bar;
               my $instance = Foo::Bar-&gt;new;
               isa_ok $instance, 'Foo::Bar';

           This carries out the same behavior as "Test::More::isa_ok".

       •   # =&gt; like

               my $str = 'Hello, I love you'; # =&gt; like qr/ove/

           This way is equivalent to the next.

               my $str = 'Hello, I love you';
               like $str, qr/ove/;

           This carries out the same behavior as "Test::More::like".

       •   # =&gt; is_deeply

               my $obj = {
                   foo =&gt; ["bar", "baz"],
               }; # =&gt; is_deeply { foo =&gt; ["bar", "baz"] }

           This way is equivalent to the next.

               my $obj = {
                   foo =&gt; ["bar", "baz"],
               };
               is_deeply $obj, { foo =&gt; ["bar", "baz"] };

           This carries out the same behavior as "Test::More::is_deeply".

       •   # =&gt; success

               my $bool = 1;
               $bool; # =&gt; success

           This way checks value as boolean.  If target value  of  testing  is  0  then  this  test  will  fail.
           Otherwise, it will pass.

</pre><h4><b>ANNOTATIONS</b></h4><pre>
       •   =for test_synopsis_expectation_no_test

           The code block behind this annotation will not be tested.

                   my $sum;
                   $sum = 1; # =&gt; 1

               =for test_synopsis_expectation_no_test

                   my $sum;
                   $sum = 1; # =&gt; 2

           In this example, the first code block will be tested, but the second will not.

</pre><h4><b>RESTRICTION</b></h4><pre>
   <b>Test</b> <b>case</b> <b>must</b> <b>be</b> <b>one</b> <b>line</b>
       The following is valid;

           my $obj = {
               foo =&gt; ["bar", "baz"],
           }; # =&gt; is_deeply { foo =&gt; ["bar", "baz"] }

       However, the following is invalid;

           my $obj = {
               foo =&gt; ["bar", "baz"],
           }; # =&gt; is_deeply {
              #        foo =&gt; ["bar", "baz"]
              #    }

       So test case must be one line.

   <b>Not</b> <b>put</b> <b>test</b> <b>cases</b> <b>inside</b> <b>of</b> <b>for(each)</b>
           # Example of not working
           for (1..10) {
               my $foo = $_; # =&gt; 10
           }

       This  example doesn't work. On the contrary, it will be error (Probably nobody uses such as this way... I
       think).

</pre><h4><b>NOTES</b></h4><pre>
   <b>yada-yada</b> <b>operator</b>
       This module ignores yada-yada operators that is in SYNOPSIS code.  Thus, following code is runnable.

           my $foo;
           ...
           $foo = 1; # =&gt; 1

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Test::Synopsis - simpler module, which just checks the syntax of your SYNOPSIS section.

       Dist::Zilla::Plugin::Test::Synopsis - a plugin for Dist::Zilla users, which adds a release test  to  your
       distribution, based on Test::Synopsis.

</pre><h4><b>REPOSITORY</b></h4><pre>
       &lt;https://github.com/moznion/Test-Synopsis-Expectation&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright (C) moznion.

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>AUTHOR</b></h4><pre>
       moznion &lt;<a href="mailto:moznion@gmail.com">moznion@gmail.com</a>&gt;

perl v5.36.0                                       2022-10-14                   <u>Test::Synopsis::<a href="../man3pm/Expectation.3pm.html">Expectation</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>