<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::Warn - Perl extension to test methods for warnings</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-warn-perl">libtest-warn-perl_0.37-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::Warn - Perl extension to test methods for warnings

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Test::Warn;

         warning_is    {foo(-dri =&gt; "/")} "Unknown Parameter 'dri'", "dri != dir gives warning";
         warnings_are  {bar(1,1)} ["Width very small", "Height very small"];

         warning_is    {add(2,2)} undef, "No warnings for calc 2+2"; # or
         warnings_are  {add(2,2)} [],    "No warnings for calc 2+2"; # whichever reads better :-)

         warning_like  {foo(-dri =&gt; "/")} qr/unknown param/i, "an unknown parameter test";
         warnings_like {bar(1,1)} [qr/width.*small/i, qr/height.*small/i];

         warning_is    {foo()} {carped =&gt; "didn't find the right parameters"};
         warnings_like {foo()} [qr/undefined/,qr/undefined/,{carped =&gt; qr/no result/i}];

         warning_like {foo(undef)}                 'uninitialized';
         warning_like {bar(file =&gt; '<a href="file:/etc/passwd">/etc/passwd</a>')} 'io';

         warning_like {eval q/"$x"; $x;/}
                      [qw/void uninitialized/],
                      "some warnings at compile time";

         warnings_exist {...} [qr/expected warning/], "Expected warning is thrown";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A good style of Perl programming calls for a lot of diverse regression tests.

       This module provides a few convenience methods for testing warning based-code.

       If you are not already familiar with the Test::More manpage now would be the time to go take a look.

   <b>FUNCTIONS</b>
       <b>warning_is</b> <u>BLOCK</u> <u>STRING,</u> <u>TEST_NAME</u>
           Tests that BLOCK gives the specified warning exactly once.

           The  test  fails  if the BLOCK warns more than once or does not warn at all.  If the string is undef,
           then the test succeeds if the BLOCK doesn't give any warning.

           Another way to say that there are no warnings in the block is:

             warnings_are {foo()} [], "no warnings"

           If you want to test for a warning given by Carp you have to write something like:

             warning_is {carp "msg"} {carped =&gt; 'msg'}, "Test for a carped warning";

           The test will fail if a "normal" warning is found instead of a "carped" one.

           Note: "warn "foo"" would print something like "foo at -e line 1".   This  method  ignores  everything
           after  the  "at".  Thus  to match this warning you would have to call "warning_is {warn "foo"} "foo",
           "Foo succeeded"".  If you need to test for a warning at an exact line, try something like:

             warning_like {warn "foo"} qr/at XYZ.dat line 5/

           Warn messages with a trailing newline (like "warn "foo\n"") don't produce the "at -e line 1"  message
           by  Perl.   Up  to  Test::Warn  0.30  such  warning  weren't  supported by "warning_is {warn "foo\n"}
           "foo\n"".  Starting with version 0.31 they are supported, but also marked as experimental.

           "warning_is()" and "warnings_are()" are only aliases to the same method.  So  you  also  could  write
           "warning_is {foo()} [], "no warning"" or something similar.

           I decided to give two methods the same name to improve readability.

           A true value is returned if the test succeeds, false otherwise.

           The test name is optional, but recommended.

       <b>warnings_are</b> <u>BLOCK</u> <u>ARRAYREF,</u> <u>TEST_NAME</u>
           Tests  to  see  that BLOCK gives exactly the specified warnings.  The test fails if the warnings from
           BLOCK are not exactly the ones in ARRAYREF.  If the ARRAYREF is equal to "[]", then the test succeeds
           if the BLOCK doesn't give any warning.

           Please read also the notes to "warning_is()" as these methods are only aliases.

           If you want more than one test for carped warnings, try this:

             warnings_are {carp "c1"; carp "c2"} {carped =&gt; ['c1','c2'];

           or

             warnings_are {foo()} ["Warning 1", {carped =&gt; ["Carp 1", "Carp 2"]}, "Warning 2"];

           Note that "{carped =&gt; ...}" must always be a hash ref.

       <b>warning_like</b> <u>BLOCK</u> <u>REGEXP,</u> <u>TEST_NAME</u>
           Tests that BLOCK gives exactly one warning and it can be matched by the given regexp.

           If the string is undef, then the tests succeeds if the BLOCK doesn't give any warning.

           The REGEXP is matched against the whole warning line, which in  general  has  the  form  "WARNING  at
           __FILE__ line __LINE__".  So you can check for a warning in the file "Foo.pm" on line 5 with:

             warning_like {bar()} qr/at Foo.pm line 5/, "Testname"

           I don't know whether it makes sense to do such a test :-(

           However, you should be prepared as a matching with 'at', 'file', '\d' or similar will always pass.

           Consider "qr/^foo/" if you want to test for warning "foo something" in file <u>foo.pl</u>.

           You can also write the regexp in a string as "/.../" instead of using the "qr/.../" syntax.

           Note  that  the  slashes  are  important  in  the string, as strings without slashes are reserved for
           warning categories (to match warning categories as can be seen in the perllexwarn man page).

           Similar to "warning_is()" and "warnings_are()" you can test for warnings via "carp" with:

             warning_like {bar()} {carped =&gt; qr/bar called too early/i};

           Similar to "warning_is()" and "warnings_are()",

           "warning_like()" and "warnings_like()" are only aliases to the same methods.

           A true value is returned if the test succeeds, false otherwise.

           The test name is optional, but recommended.

       <b>warning_like</b> <u>BLOCK</u> <u>STRING,</u> <u>TEST_NAME</u>
           Tests whether a BLOCK gives exactly one warning of the passed category.

           The categories are grouped in a tree, like it is  expressed  in  perllexwarn.   Also  see  "BUGS  AND
           LIMITATIONS".

           Thanks  to  the  grouping  in  a  tree,  it's possible to test simply for an 'io' warning, instead of
           testing for a 'closed|exec|layer|newline|pipe|unopened' warning.

           Note, that warnings occurring at compile time can only be caught in an eval block. So

             warning_like {eval q/"$x"; $x;/}
                           [qw/void uninitialized/],
                           "some warnings at compile time";

           will work, while it wouldn't work without the eval.

           Note, that it isn't possible yet, to test for own categories, created with warnings::register.

       <b>warnings_like</b> <u>BLOCK</u> <u>ARRAYREF,</u> <u>TEST_NAME</u>
           Tests to see that BLOCK gives exactly the number of the specified warnings, in the defined order.

           Please read also the notes to "warning_like()" as these methods are only aliases.

           Similar to "warnings_are()",  you  can  test  for  multiple  warnings  via  "carp"  and  for  warning
           categories, too:

             warnings_like {foo()}
                           [qr/bar warning/,
                            qr/bar warning/,
                            {carped =&gt; qr/bar warning/i},
                            'io'
                           ],
                           "I hope you'll never have to write a test for so many warnings :-)";

       <b>warnings_exist</b> <u>BLOCK</u> <u>STRING|ARRAYREF,</u> <u>TEST_NAME</u>
           Same  as  warning_like, but will "warn()" all warnings that do not match the supplied regex/category,
           instead of registering an error. Use this test when you just want to make sure that specific warnings
           were generated, and couldn't care less if other warnings happened in the same block of code.

             warnings_exist {...} [qr/expected warning/], "Expected warning is thrown";

             warnings_exist {...} ['uninitialized'], "Expected warning is thrown";

   <b>EXPORT</b>
       "warning_is", "warnings_are", "warning_like", "warnings_like", "warnings_exist" by default.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       Category  check  is  done  as  "qr/category_name/".  In  some  case  this  works,   like   for   category
       'uninitialized'.  For  'utf8'  it  does  not  work.  Perl  does not have a list of warnings, so it is not
       possible to generate one for "Test::Warn".

       If you want to add a warning to a category,  send  a  pull  request.  Modifications  should  be  done  to
       %warnings_in_category. You should look into perl source to check how warning is looking exactly.

       Please note that warnings with newlines inside are very awkward.  The only sensible way to handle them is
       to  use the "warning_like" or "warnings_like" methods. The background is that there is no really safe way
       to distinguish between warnings with newlines and a stacktrace.

       If a method has its own warn handler, overwriting $SIG{__WARN__}, my test warning methods won't get these
       warnings.

       The "warning_like BLOCK CATEGORY, TEST_NAME" method isn't fully tested.  Please take note if you use this
       this calling style, and report any bugs you find.

   <b>XS</b> <b>warnings</b>
       As described in https://rt.cpan.org/Ticket/Display.html?id=42070&amp;results=3c71d1b101a730e185691657f3b02f21
       or https://github.com/hanfried/test-warn/issues/1 XS warnings might not be caught.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Have a look to the similar Test::Exception module. Test::Trap

</pre><h4><b>THANKS</b></h4><pre>
       Many thanks to Adrian Howard, chromatic and Michael G. Schwern, who have given me a lot of ideas.

</pre><h4><b>AUTHOR</b></h4><pre>
       Janek Schleicher, &lt;bigj AT kamelfreund.de&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2002 by Janek Schleicher

       Copyright 2007-2014 by Alexandr Ciornii, &lt;<a href="http://chorny.net/">http://chorny.net/</a>&gt;

       Copyright 2015-2018 by Janek Schleicher

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2022-11-19                                          <u><a href="../man3pm/Warn.3pm.html">Warn</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>