<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::Cmd - Perl module for portable testing of commands and scripts</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-cmd-perl">libtest-cmd-perl_1.09-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::Cmd - Perl module for portable testing of commands and scripts

</pre><h4><b>SYNOPSIS</b></h4><pre>
       An example using Test::More with this module to run a command and then test the exit code, standard out,
       and standard error:

         use Test::Cmd;
         use Test::More tests =&gt; 3;

         my $test = Test::Cmd-&gt;new( prog =&gt; 'outerr', workdir =&gt; '' );
         $test-&gt;run();

         is( $test-&gt;stdout, "out\n", 'standard out' );
         is( $test-&gt;stderr, "err\n", 'standard error' );
         is( $? &gt;&gt; 8,       1,       'exit status' );

       Where "outerr" is the shell script:

         $ cat outerr
         #!<a href="file:/bin/sh">/bin/sh</a>
         echo out
         echo &gt;&amp;2 err
         exit 1
         $ chmod +x outerr

       See below for other examples. Otherwise, the full list of available methods is:

         use Test::Cmd;

         $test = Test::Cmd-&gt;new(prog =&gt; 'program_or_script_to_test',
                               interpreter =&gt; 'script_interpreter',
                               string =&gt; 'identifier_string',
                               workdir =&gt; '',
                               subdir =&gt; 'dir',
                               match_sub =&gt; $code_ref,
                               verbose =&gt; 1);

         $test-&gt;<a href="../man1/verbose.1.html">verbose</a>(1);

         $test-&gt;prog('program_or_script_to_test');

         $test-&gt;basename(@suffixlist);

         $test-&gt;interpreter('script_interpreter');

         $test-&gt;string('identifier string');

         $test-&gt;workdir('prefix');

         $test-&gt;workpath('subdir', 'file');

         $test-&gt;subdir('subdir', ...);
         $test-&gt;subdir(['sub', 'dir'], ...);

         $test-&gt;write('file', &lt;&lt;'EOF');
         contents of file
         EOF
         $test-&gt;write(['subdir', 'file'], &lt;&lt;'EOF');
         contents of file
         EOF

         $test-&gt;read(\$contents, 'file');
         $test-&gt;read(\@lines, 'file');
         $test-&gt;read(\$contents, ['subdir', 'file']);
         $test-&gt;read(\@lines, ['subdir', 'file']);

         $test-&gt;writable('dir');
         $test-&gt;writable('dir', $rwflag);
         $test-&gt;writable('dir', $rwflag, \%errors);

         $test-&gt;preserve(condition, ...);

         $test-&gt;cleanup(condition);

         $test-&gt;run(prog =&gt; 'program_or_script_to_test',
                       interpreter =&gt; 'script_interpreter',
                       chdir =&gt; 'dir', args =&gt; 'arguments', stdin =&gt; &lt;&lt;'EOF');
         input to program
         EOF

         $test-&gt;pass(condition);
         $test-&gt;pass(condition, \&amp;func);

         $test-&gt;fail(condition);
         $test-&gt;fail(condition, \&amp;func);
         $test-&gt;fail(condition, \&amp;func, $caller);

         $test-&gt;no_result(condition);
         $test-&gt;no_result(condition, \&amp;func);
         $test-&gt;no_result(condition, \&amp;func, $caller);

         $test-&gt;stdout;
         $test-&gt;stdout($run_number);

         $test-&gt;stderr;
         $test-&gt;stderr($run_number);

         $test-&gt;match(\@lines, \@matches);
         $test-&gt;match($lines, $matches);

         $test-&gt;match_exact(\@lines, \@matches);
         $test-&gt;match_exact($lines, $matches);

         $test-&gt;match_regex(\@lines, \@regexes);
         $test-&gt;match_regex($lines, $regexes);

         $test-&gt;diff_exact(\@lines, \@matches, \@output);
         $test-&gt;diff_exact($lines, $matches, \@output);

         $test-&gt;diff_regex(\@lines, \@regexes, \@output);
         $test-&gt;diff_regex($lines, $regexes, \@output);

         sub func {
               my ($self, $lines, $matches) = @_;
               # code to match $lines and $matches
         }
         $test-&gt;match_sub(\&amp;func);
         $test-&gt;match_sub(sub { code to match $_[1] and $_[2] });

         $test-&gt;here;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The "Test::Cmd" module provides a low-level framework for portable automated testing of executable
       commands and scripts (in any language, not just Perl), especially commands and scripts that interact with
       the file system.

       The "Test::Cmd" module makes no assumptions about what constitutes a successful or failed test.
       Attempting to read a file that doesn't exist, for example, may or may not be an error, depending on the
       software being tested.

       Consequently, no "Test::Cmd" methods (including the "new()" method) exit, die or throw any other sorts of
       exceptions (but they all do return useful error indications).  Exceptions or other error status should be
       handled by a higher layer: a subclass of Test::Cmd, or another testing framework such as the Test or
       Test::Simple Perl modules, or by the test itself.

       (That said, see the Test::Cmd::Common module if you want a similar module that provides exception
       handling, either to use directly in your own tests, or as an example of how to use "Test::Cmd".)

       In addition to running tests and evaluating conditions, the "Test::Cmd" module manages and cleans up one
       or more temporary workspace directories, and provides methods for creating files and directories in those
       workspace directories from in-line data (that is, here-documents), allowing tests to be completely self-
       contained.  When used in conjunction with another testing framework, the "Test::Cmd" module can function
       as a <u>fixture</u> (common startup code for multiple tests) for simple management of command execution and
       temporary workspaces.

       The "Test::Cmd" module inherits File::Spec methods ("file_name_is_absolute()", "catfile()", etc.) to
       support writing tests portably across a variety of operating and file systems.

       A "Test::Cmd" environment object is created via the usual invocation:

           $test = Test::Cmd-&gt;new();

       Arguments to the "Test::Cmd::new" method are keyword-value pairs that may be used to initialize the
       object, typically by invoking the same-named method as the keyword.

</pre><h4><b>TESTING</b> <b>FRAMEWORKS</b></h4><pre>
       As mentioned, because the "Test::Cmd" module makes no assumptions about what constitutes success or
       failure of a test, it can be used to provide temporary workspaces, other file system interaction, or
       command execution for a variety of testing frameworks.  This section describes how to use the "Test::Cmd"
       with several different higher-layer testing frameworks.

       Note that you should <u>not</u> intermix multiple testing frameworks in a single testing script.

   <b>"Test::Harness"</b>
       The "Test::Cmd" module may be used in tests that print results in a format suitable for the standard Perl
       Test::Harness module:

           use Test::Cmd;

           print "1..5\n";

           $test = Test::Cmd-&gt;new(prog =&gt; 'test_program', workdir =&gt; '');
           if ($test) { print "ok 1\n"; } else { print "not ok 1\n"; }

           $input = &lt;&lt;_EOF;
           test_program should process this input
           and exit successfully (status 0).
           _EOF_

           $wrote_file = $test-&gt;write('input_file', $input);
           if ($wrote_file) { print "ok 2\n"; } else { print "not ok 2\n"; }

           $test-&gt;run(args =&gt; '-x input_file');
           if ($? == 0) { print "ok 3\n"; } else { print "not ok 3\n"; }

           $wrote_file = $test-&gt;write('input_file', $input);
           if ($wrote_file) { print "ok 4\n"; } else { print "not ok 4\n"; }

           $test-&gt;run(args =&gt; '-y input_file');
           if ($? == 0) { print "ok 5\n"; } else { print "not ok 5\n"; }

       Several other Perl modules simplify the use of Test::Harness by eliminating the need to hand-code the
       "print" statements and test numbers.  The Test module, the Test::Simple module, and the Test::More module
       all export an "ok()" subroutine to test conditions.  Here is how the above example would look rewritten
       to use Test::Simple:

           use Test::Simple tests =&gt; 5;
           use Test::Cmd;

           $test = Test::Cmd-&gt;new(prog =&gt; 'test_program', workdir =&gt; '');
           ok($test, "creating Test::Cmd object");

           $input = &lt;&lt;_EOF;
           test_program should process this input
           and exit successfully (status 0).
           _EOF_

           $wrote_file = $test-&gt;write('input_file', $input);
           ok($wrote_file, "writing input_file");

           $test-&gt;run(args =&gt; '-x input_file');
           ok($? == 0, "executing test_program -x input_file");

           $wrote_file = $test-&gt;write('input_file', $input);
           ok($wrote_file, "writing input_file");

           $test-&gt;run(args =&gt; '-y input_file');
           ok($? == 0, "executing test_program -y input_file");

   <b>"Test::Unit"</b>
       The Perl Test::Unit package provides a procedural testing interface modeled after a testing framework
       widely used in the eXtreme Programming development methodology.  The "Test::Cmd" module can function as
       part of a Test::Unit fixture that can set up workspaces as needed for a set of tests.  This avoids having
       to repeat code to re-initialize an input file multiple times:

           use Test::Unit;
           use Test::Cmd;

           my $test;

           $input = &lt;&lt;'EOF';
           test_program should process this input
           and exit successfully (status 0).
           EOF

           sub set_up {
               $test = Test::Cmd-&gt;new(prog =&gt; 'test_program', workdir =&gt; '');
               $test-&gt;write('input_file', $input);
           }

           sub test_x {
               my $result = $test-&gt;run(args =&gt; '-x input_file');
               assert($result == 0, "failed test_x\n");
           }

           sub test_y {
               my $result = $test-&gt;run(args =&gt; '-y input_file');
               assert($result == 0, "failed test_y\n");
           }

           create_suite();
           run_suite;

       Note that, because the "Test::Cmd" module takes care of cleaning up temporary workspaces on exit, there
       is no need to remove explicitly the workspace in a "tear_down" subroutine.  (There may, of course, be
       other things in the test that need a "tear_down" subroutine.)

   <b>Aegis</b>
       Alternatively, the "Test::Cmd" module provides "pass()", "fail()", and "no_result()" methods that can be
       used to provide an appropriate exit status and simple printed indication for a test.  These methods
       terminate the test immediately, reporting "PASSED", "FAILED", or "NO RESULT" respectively, and exiting
       with status 0 (success), 1 or 2 respectively.

       The separate "fail()" and "no_result()" methods allow for a distinction between an actual failed test and
       a test that could not be properly evaluated because of an external condition (such as a full file system
       or incorrect permissions).

       The exit status values happen to match the requirements of the Aegis change management system, and the
       printed strings are based on existing Aegis conventions.  They are not really Aegis-specific, however,
       and provide a simple, useful starting point if you don't already have another testing framework:

           use Test::Cmd;

           $test = Test::Cmd-&gt;new(prog =&gt; 'test_program', workdir =&gt; '');
           Test::Cmd-&gt;no_result(! $test);

           $input = &lt;&lt;EOF;
           test_program should process this input
           and exit successfully (status 0).
           EOF

           $wrote_file = $test-&gt;write('input_file', $input);
           $test-&gt;no_result(! $wrote_file);

           $test-&gt;run(args =&gt; '-x input_file');
           $test-&gt;fail($? != 0);

           $wrote_file = $test-&gt;write('input_file', $input);
           $test-&gt;no_result(! $wrote_file);

           $test-&gt;run(args =&gt; '-y input_file');
           $test-&gt;fail($? != 0);

           $test-&gt;pass;

       Note that the separate Test::Cmd::Common wrapper module can simplify the above example even further by
       taking care of common exception handling cases within the testing object itself.

           use Test::Cmd::Common;

           $test = Test::Cmd::Common-&gt;new(prog =&gt; 'test_program', workdir =&gt; '');

           $input = &lt;&lt;EOF;
           test_program should process this input
           and exit successfully (status 0).
           EOF

           $wrote_file = $test-&gt;write('input_file', $input);

           $test-&gt;run(args =&gt; '-x input_file');

           $wrote_file = $test-&gt;write('input_file', $input);

           $test-&gt;run(args =&gt; '-y input_file');

           $test-&gt;pass;

       See the Test::Cmd::Common module for details.

</pre><h4><b>METHODS</b></h4><pre>
       Methods supported by the "Test::Cmd" module include:

       "new"
           Create  a new "Test::Cmd" environment.  Arguments with which to initialize the environment are passed
           in as keyword-value pairs.  Fails if a specified temporary working directory or  subdirectory  cannot
           be  created.   Does  NOT  die  or exit on failure, but returns "undef" if the test environment object
           cannot be created.

       "verbose"
           Sets the verbose level for the environment object to the specified value.

       "prog"
           Specifies the executable program or script to be tested.  Returns  the  absolute  path  name  of  the
           current program or script.

       "basename"
           Returns  the  basename  of the current program or script.  Any specified arguments are a list of file
           suffixes that may be stripped from the basename.

       "interpreter"
           Specifies the program to be used to interpret "prog" as a  script.   Returns  the  current  value  of
           "interpreter".

       "string"
           Specifies  an  identifier  string  for  the functionality being tested to be printed on failure or no
           result.

       "workdir"
           When an argument is specified, creates a temporary working directory with the specified name.  If the
           argument is a NULL string (''), the directory is named "testcmd" by default, followed by  the  unique
           ID of the executing process.

           Returns the absolute pathname to the temporary working directory, or FALSE if the directory could not
           be created.

       "workpath"
           Returns  the  absolute  path  name  to  a  subdirectory  or  file under the current temporary working
           directory by concatenating the temporary working directory name with the specified arguments.

       "subdir"
           Creates new subdirectories under the temporary working dir, one for each argument.  An  argument  may
           be  an  array  reference,  in  which  case  the  array  elements  are concatenated together using the
           "File::Spec-&amp;"catfile&gt; method.  Subdirectories multiple levels deep must be created  via  a  separate
           argument for each level:

               $test-&gt;subdir('sub', ['sub', 'dir'], [qw(sub dir ectory)]);

           Returns the number of subdirectories actually created.

       "write"
           Writes  the  specified  text (second argument) to the specified file name (first argument).  The file
           name may be an array reference, in which case all the array elements except the last are subdirectory
           names to be concatenated together.  The file is created under the temporary working  directory.   Any
           subdirectories in the path must already exist.

       "read"
           Reads  the contents of the specified file name (second argument) into the scalar or array referred to
           by the first argument.  The file name may be an array reference, in which case all the array elements
           except the last are subdirectory names to be concatenated together.  The file is assumed to be  under
           the temporary working directory unless it is an absolute path name.

           Returns TRUE on successfully opening and reading the file, FALSE otherwise.

       "writable"
           Makes every file and directory within the specified directory tree writable ("rwflag" == TRUE) or not
           writable  ("rwflag" == FALSE).  The default is to make the directory tree writable.  Optionally fills
           in the supplied hash reference with a hash of path names that could not have  their  permissions  set
           appropriately, with the reason why each could not be set.

       "preserve"
           Arranges  for  the  temporary  working  directories  for  the specified "Test::Cmd" environment to be
           preserved for one or more conditions.  If no conditions are specified,  arranges  for  the  temporary
           working directories to be preserved for all conditions.

       "cleanup"
           Removes  any  temporary  working  directories  for  the  specified  "Test::Cmd"  environment.  If the
           environment variable "PRESERVE" was set when the "Test::Cmd" module  was  loaded,  temporary  working
           directories  are  not removed.  If any of the environment variables "PRESERVE_PASS", "PRESERVE_FAIL",
           or "PRESERVE_NO_RESULT" were set when the "Test::Cmd"  module  was  loaded,  then  temporary  working
           directories  are  not  removed if the test passed, failed, or had no result, respectively.  Temporary
           working directories are also preserved for conditions specified via the "preserve" method.

           Typically, this method is not called directly, but  is  used  when  the  script  exits  to  clean  up
           temporary working directories as appropriate for the exit status.

       "run"
           Runs  a test of the program or script for the test environment.  Standard output and error output are
           saved for future retrieval via the "stdout" and "stderr" methods.

           Arguments are supplied as keyword-value pairs:

           "args"
               Specifies the command-line arguments to be supplied to the program or script under test for  this
               run:

                       $test-&gt;run(args =&gt; 'arg1 arg2');

           "chdir"
               Changes directory to the path specified as the value argument:

                       $test-&gt;run(chdir =&gt; 'xyzzy');

               If  the  specified  path is not an absolute path name (begins with '/' on Unix systems), then the
               subdirectory  is  relative   to   the   temporary   working   directory   for   the   environment
               ("$test-&amp;"workdir&gt;).   Note  that,  by  default,  the  "Test::Cmd"  module  does NOT chdir to the
               temporary working directory, so to execute the test under the temporary  working  directory,  you
               must specify an explicit "chdir" to the current directory:

                       $test-&gt;run(chdir =&gt; '.');               # Unix-specific

                       $test-&gt;run(chdir =&gt; $test-&gt;curdir);     # portable

           "interpreter"
               Specifies  the  program to be used to interpret "prog" as a script, for this run only.  This does
               not change the "$test-&amp;"interpreter&gt; value of the test environment.

           "prog"
               Specifies the executable program or script to be run, for this run only.  This  does  not  change
               the "$test-&amp;"prog&gt; value of the test environment.

           "stdin"
               Pipes the specified value (string or array ref) to the program or script under test for this run:

                       $test-&gt;run(stdin =&gt; &lt;&lt;_EOF_);
                       input to the program under test
                       _EOF_

           Returns the exit status of the program or script.

       "pass"
           Exits  the test successfully.  Reports "PASSED" on the error output and exits with a status of 0.  If
           a condition is supplied, only exits the  test  if  the  condition  evaluates  TRUE.   If  a  function
           reference is supplied, executes the function before reporting and exiting.

       "fail"
           Exits  the  test  unsuccessfully.  Reports "FAILED test of {string} at line {line} of {file}." on the
           error output and exits with a status of 1.  If a condition is supplied, only exits the  test  if  the
           condition  evaluates  TRUE.   If  a  function  reference  is  supplied,  executes the function before
           reporting and exiting.  If a caller level is supplied, prints a simple calling trace N levels deep as
           part of reporting the failure.

       "no_result"
           Exits the test with an indeterminate result  (the  test  could  not  be  performed  due  to  external
           conditions  such  as,  for  example, a full file system).  Reports "NO RESULT for test of {string} at
           line {line} of {file}." on the error output and exits  with  a  status  of  2.   If  a  condition  is
           supplied,  only exits the test if the condition evaluates TRUE.  If a function reference is supplied,
           executes the function before reporting and exiting.  If a caller level is supplied, prints  a  simple
           calling trace N levels deep as part of reporting the failure.

       "stdout"
           Returns the standard output from the specified run number.  If there is no specified run number, then
           returns  the  standard  output of the last run.  Returns the standard output as either a scalar or an
           array of output lines, as appropriate for the calling context.  Returns "undef" if there has been  no
           test run.

       "stderr"
           Returns  the  error  output from the specified run number.  If there is no specified run number, then
           returns the error output of the last run.  Returns the error output as either a scalar or an array of
           output lines, as apporpriate for the calling context.  Returns "undef" if there has been no test run.

       "match"
           Matches one or more input lines against an equal  number  of  expected  lines  using  the  currently-
           registered  line-matching  function.  The default line-matching function is the "match_regex" method,
           which means that the default is to match lines against regular expressions.

       "match_exact"
           Compares two arrays of lines for exact matches.  The arguments are passed in as  either  scalars,  in
           which  case  each is split on newline boundaries, or as array references.  An unequal number of lines
           in the two arrays fails immediately and returns FALSE before any comparisons are performed.

           Returns TRUE if each line matched its corresponding line in the other array, FALSE otherwise.

       "match_regex"
           Matches one or more input lines against an equal number of regular expressions.   The  arguments  are
           passed  in  as  either  scalars,  in  which  case  each  is  split on newline boundaries, or as array
           references.  Trailing newlines are stripped from each line and regular expression.  An unequal number
           of lines and regular expressions fails immediately and  returns  FALSE  before  any  comparisons  are
           performed.   Comparison  is  performed  for  each  entire line, that is, with each regular expression
           anchored at both the start of line (^) and end of line ($).

           Returns TRUE if each line matched each regular expression, FALSE otherwise.

       "diff_exact"
           Diffs two arrays of lines in a manner similar to the UNIX <b><a href="../man1/diff.1.html">diff</a></b>(1) utility.

           If the Algorithm::DiffOld package is installed on the local system, output describing the differences
           between the input lines and the matching lines, in <b><a href="../man1/diff.1.html">diff</a></b>(1) format, is  saved  to  the  $output  array
           reference.   In the diff output, the expected output lines are considered the "old" (left-hand) file,
           and the actual output is considered the "new" (right-hand) file.

           If the Algorithm::DiffOld package is <u>not</u> installed on the  local  system,  the  Expected  and  Actual
           contents are saved as-is to the $output array reference.

           The  "lines"  and "matches" arguments are passed in as either scalars, in which case each is split on
           newline boundaries, or as array references.  Trailing  newlines  are  stripped  from  each  line  and
           regular expression.

           Returns TRUE if each line matched its corresponding line in the expected matches, FALSE otherwise, in
           order to conform to the conventions of the "match" method.

           Typical invocation:

                   if (! $test-&gt;diff_exact($test-&gt;stdout,
                                           \@expected_lines,
                                           \@diff)) {
                           print @diff;
                   }

       "diff_regex"
           Diffs one or more input lines against one or more regular expressions in a manner similar to the UNIX
           <b><a href="../man1/diff.1.html">diff</a></b>(1) utility.

           If the Algorithm::DiffOld package is installed on the local system, output describing the differences
           between  the  input  lines  and  the matching lines, in <b><a href="../man1/diff.1.html">diff</a></b>(1) format, is saved to the $output array
           reference.  In the diff output, the expected output lines are considered the "old" (left-hand)  file,
           and the actual output is considered the "new" (right-hand) file.

           If  the  Algorithm::DiffOld  package  is  <u>not</u>  installed on the local system, the Expected and Actual
           contents are saved as-is to the $output array reference.

           The "lines" and "regexes" arguments are passed in as either scalars, in which case each is  split  on
           newline  boundaries,  or  as  array  references.   Trailing  newlines are stripped from each line and
           regular expression.  Comparison is performed for  each  entire  line,  that  is,  with  each  regular
           expression anchored at both the start of line (^) and end of line ($).

           Returns  TRUE  if  each line matched each regular expression, FALSE otherwise, in order to conform to
           the conventions of the "match" method.

           Typical invocation:

                   if (! $test-&gt;diff_regex($test-&gt;stdout,
                                           \@expected_lines,
                                           \@diff)) {
                           print @diff;
                   }

       "match_sub"
           Registers the specified code reference as the line-matching function to  be  called  by  the  "match"
           method.   This  can be a user-supplied subroutine, or the "match_exact", "match_regex", "diff_exact",
           or "diff_regex" methods supplied by the "Test::Cmd" module:

                   $test-&gt;match_sub(\&amp;Test::Cmd::match_exact);

                   $test-&gt;match_sub(\&amp;Test::Cmd::match_regex);

                   $test-&gt;match_sub(\&amp;Test::Cmd::diff_exact);

                   $test-&gt;match_sub(\&amp;Test::Cmd::diff_regex);

           The "match_exact", "match_regex", "diff_exact" and "diff_regex" subroutine names are exportable  from
           the "Test::Cmd" module, and may be specified at object initialization:

                   use Test::Cmd qw(match_exact match_regex diff_exact diff_regex);
                   $test_exact = Test::Cmd-&gt;new(match_sub =&gt; \&amp;match_exact);
                   $test_regex = Test::Cmd-&gt;new(match_sub =&gt; \&amp;match_regex);
                   $test_exact = Test::Cmd-&gt;new(match_sub =&gt; \&amp;diff_exact);
                   $test_regex = Test::Cmd-&gt;new(match_sub =&gt; \&amp;diff_regex);

       "here"
           Returns  the  absolute  path name of the current working directory.  (This is essentially the same as
           the "Cwd::cwd" method, except that the "Test::Cmd::here" method preserves  the  directory  separators
           exactly  as  returned  by  the  underlying  operating-system-dependent method.  The "Cwd::cwd" method
           canonicalizes all directory separators to '/', which makes for consistent path  name  representations
           within Perl, but may mess up another program or script to which you try to pass the path name.)

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       Several  environment  variables  affect  the  default  values  in a newly created "Test::Cmd" environment
       object.  These environment variables must be set when the module  is  loaded,  not  when  the  object  is
       created.

       "PRESERVE"
           If  set  to  a true value, all temporary working directories will be preserved on exit, regardless of
           success or failure of the test.  The full path names of all temporary  working  directories  will  be
           reported on error output.

       "PRESERVE_FAIL"
           If  set  to  a  true value, all temporary working directories will be preserved on exit from a failed
           test.  The full path names of all temporary working directories will be reported on error output.

       "PRESERVE_NO_RESULT"
           If set to a true value, all temporary working directories will be preserved on exit from a  test  for
           which  there is no result.  The full path names of all temporary working directories will be reported
           on error output.

       "PRESERVE_PASS"
           If set to a true value, all temporary working directories will be preserved on exit from a successful
           test.  The full path names of all temporary working directories will be reported on error output.

       "VERBOSE"
           When set to a true value, enables verbose reporting of various internal  things  (path  names,  exact
           command line being executed, etc.).

</pre><h4><b>PORTABLE</b> <b>TESTS</b></h4><pre>
       Although  the  "Test::Cmd"  module  is  intended  to  make it easier to write portable tests for portable
       utilities that interact with file systems, it is still very easy to write non-portable  tests  if  you're
       not careful.

       The  best  and  most  comprehensive set of portability guidelines is the standard "Writing portable Perl"
       document at:

               <a href="http://www.perl.com/pub/doc/manual/html/pod/perlport.html">http://www.perl.com/pub/doc/manual/html/pod/perlport.html</a>

       To reiterate one important point from the "WpP" document:  Not all Perl programs have to be portable.  If
       the program or script you're testing is UNIX-specific, you can (and should) use the "Test::Cmd" module to
       write UNIX-specific tests.

       That having been said, here are some  hints  that  may  help  keep  your  tests  portable,  if  that's  a
       requirement.

       Use the "Test::Cmd-&amp;"here&gt; method for current directory path.
           The  normal  Perl  way  to  fetch  the  current  working  directory  is to use the "Cwd::cwd" method.
           Unfortunately, the "Cwd::cwd" method canonicalizes the path name  it  returns,  changing  the  native
           directory  separators into the forward slashes favored by Perl and UNIX.  For most Perl scripts, this
           makes a great deal of sense and keeps code uncluttered.

           Passing in a file name that has had its  directory  separators  altered,  however,  may  confuse  the
           command  or script under test, or make it difficult to compare output from the command or script with
           an expected result.  The "Test::Cmd::here" method returns the  absolute  path  name  of  the  current
           working directory, like "Cwd::cwd", but does not manipulate the returned path in any way.

       Use "File::Spec" methods for manipulating path names.
           The  File::Spec  module provides a system-independent interface for manipulating path names.  Because
           the "Test::Cmd" class is a sub-class of the File::Spec class, you can use these methods  directly  as
           follows:

                   if (! Test::Cmd-&gt;file_name_is_absolute($prog)) {
                           my $prog = Test::Cmd-&gt;catfile(Test::Cmd-&gt;here, $prog);
                   }

           For  details  about  the  available  methods  and their use, see the documentation for the File::Spec
           module and its sub-modules, especially the File::Spec::Unix modules.

       Use "Config" for file-name suffixes, where possible.
           The standard Config module provides values that reflect the file-name  suffixes  on  the  system  for
           which  the  Perl  executable  was built.  This provides convenient portability for situations where a
           file name may have different extensions on different systems:

                   $foo_exe = "foo$Config{_exe}";
                   ok(-f $foo_exe);

           (Unfortunately, there is no existing  $Config  value  that  specifies  the  suffix  for  a  directly-
           executable Perl script.)

       Avoid generating executable programs or scripts.
           How  to make a file or script executable varies widely from system to system, some systems using file
           name extensions to indicate executability, others using a file permission bit.  The  differences  are
           complicated  to  accommodate in a portable test script.  The easiest way to deal with this complexity
           is to avoid it if you can.

           If your test somehow requires executing a script that you generate from the test itself, the best way
           is to generate the script in Perl and then explicitly feed it to the Perl  executable  on  the  local
           system.  To be maximally portable, use the $^X variable instead of hard-coding "perl" into the string
           you execute:

                   $line = "This is output from the generated perl script.";
                   $test-&gt;write('script', &lt;&lt;EOF);
                   print STDOUT "$line\\n";
                   EOF
                   $output = `$^X script`;
                   ok($output eq "$line\n");

           This  completely  avoids  having  to make the "script" file itself executable.  (Since you're writing
           your test in Perl, it's safe to assume that Perl itself is executable.)

           If you must generate a directly-executable script, then use the $Config{'startperl'} variable at  the
           start of the script to generate the appropriate magic that will execute it as a Perl script:

                   use Config;
                   $line = "This is output from the generated perl script.";
                   $test-&gt;write('script', &lt;&lt;EOF);
                   $Config{'startperl'};
                   print STDOUT "$line\\n";
                   EOF
                   chdir($test-&gt;workdir);
                   chmod(0755, 'script');  # POSIX-SPECIFIC
                   $output = `script`;
                   ok($output eq "$line\n");

       Addtional hints on writing portable tests are welcome.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1),  Algorithm::DiffOld, File::Find, File::Spec, Test, Test::Cmd::Common, Test::Harness, Test::More,
       Test::Simple, Test::Unit.

       Alternative command-testing modules include:

       Test::Exit, Test::Output, or using Capture::Tiny  with  one  of  the  above  test  modules,  for  example
       Test::More.

       A rudimentary page for the "Test::Cmd" module is available at:

               <a href="http://www.baldmt.com/Test-Cmd/">http://www.baldmt.com/Test-Cmd/</a>

       The  most  involved  example  of  using  the  "Test::Cmd" package to test a real-world application is the
       "cons-test" testing suite for the Cons software construction utility.  The  suite  uses  a  sub-class  of
       Test::Cmd::Common  (which  in turn is a sub-class of "Test::Cmd") to provide common, application-specific
       infrastructure across a large number of end-to-end application tests.  The suite, and  other  information
       about Cons, is available at:

               <a href="http://www.dsmit.com/cons">http://www.dsmit.com/cons</a>

</pre><h4><b>REPOSITORY</b></h4><pre>
       &lt;https://github.com/neilb/Test-Cmd&gt;

</pre><h4><b>AUTHORS</b></h4><pre>
       Steven Knight, <a href="mailto:knight@baldmt.com">knight@baldmt.com</a>

       This module is now being maintained by Neil Bowers &lt;<a href="mailto:neilb@cpan.org">neilb@cpan.org</a>&gt;.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright  1999-2001  Steven  Knight.   All  rights  reserved.   This  program  is free software; you can
       redistribute it and/or modify it under the same terms as Perl itself.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to Greg Spencer for the  inspiration  to  create  this  package  and  the  initial  draft  of  its
       implementation  as  a  specific  testing package for the Cons software construction utility.  Information
       about Cons is available at:

               <a href="http://www.dsmit.com/cons/">http://www.dsmit.com/cons/</a>

       The general idea of managing temporary working directories in this way, as well as the test reporting  of
       the  "pass", "fail" and "no_result" methods, come from the testing framework invented by Peter Miller for
       his Aegis project change supervisor.  Aegis is an excellent bit of work  which  integrates  creation  and
       execution  of  regression  tests  into  the  software  development  process.   Information about Aegis is
       available at:

               <a href="http://www.tip.net.au/~millerp/aegis.html">http://www.tip.net.au/~millerp/aegis.html</a>

       Thanks to Michael Schwern for  all  of  the  thoughtful  work  he's  put  into  Perl's  standard  testing
       methodology,  including  the  Test::Simple and Test::More modules, and enhancement and maintenance of the
       Test and Test::Harness  modules.   Thanks  also  to  Christian  Lemburg  for  the  impressively  complete
       Test::Unit  framework  of  modules.   Ideas  from both have helped keep "Test::Cmd" flexible enough to be
       useful in multiple testing frameworks.

perl v5.36.0                                       2022-10-13                                     <u>Test::<a href="../man3pm/Cmd.3pm.html">Cmd</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>