<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::Output - Utilities to test STDOUT and STDERR messages.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-output-perl">libtest-output-perl_1.036-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::Output - Utilities to test STDOUT and STDERR messages.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Test::More tests =&gt; 4;
           use Test::Output;

           sub writer {
             print "Write out.\n";
             print STDERR "Error out.\n";
           }

           stdout_is(\&amp;writer,"Write out.\n",'Test STDOUT');

           stderr_isnt(\&amp;writer,"No error out.\n",'Test STDERR');

           combined_is(
                       \&amp;writer,
                       "Write out.\nError out.\n",
                       'Test STDOUT &amp; STDERR combined'
                      );

           output_is(
                     \&amp;writer,
                     "Write out.\n",
                     "Error out.\n",
                     'Test STDOUT &amp; STDERR'
                   );

          # Use bare blocks.

          stdout_is { print "test" } "test", "Test STDOUT";
          stderr_isnt { print "bad test" } "test", "Test STDERR";
          output_is { print 'STDOUT'; print STDERR 'STDERR' }
            "STDOUT", "STDERR", "Test output";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Test::Output provides a simple interface for testing output sent to "STDOUT" or "STDERR". A number of
       different utilities are included to try and be as flexible as possible to the tester.

       Likewise, Capture::Tiny provides a much more robust capture mechanism without than the original
       Test::Output::Tie.

</pre><h4><b>TESTS</b></h4><pre>
   <b>STDOUT</b>
       <b>stdout_is</b>
       <b>stdout_isnt</b>
              stdout_is  ( $coderef, $expected, 'description' );
              stdout_is    { ... } $expected, 'description';
              stdout_isnt( $coderef, $expected, 'description' );
              stdout_isnt  { ... } $expected, 'description';

           stdout_is()  captures  output  sent  to "STDOUT" from $coderef and compares it against $expected. The
           test passes if equal.

           stdout_isnt() passes if "STDOUT" is not equal to $expected.

       <b>stdout_like</b>
       <b>stdout_unlike</b>
              stdout_like  ( $coderef, qr/$expected/, 'description' );
              stdout_like    { ... } qr/$expected/, 'description';
              stdout_unlike( $coderef, qr/$expected/, 'description' );
              stdout_unlike  { ... } qr/$expected/, 'description';

           stdout_like() captures the output sent to "STDOUT" from $coderef and compares  it  to  the  regex  in
           $expected. The test passes if the regex matches.

           stdout_unlike() passes if STDOUT does not match the regex.

   <b>STDERR</b>
       <b>stderr_is</b>
       <b>stderr_isnt</b>
              stderr_is  ( $coderef, $expected, 'description' );
              stderr_is    {... } $expected, 'description';

              stderr_isnt( $coderef, $expected, 'description' );
              stderr_isnt  {... } $expected, 'description';

           stderr_is()  is similar to "stdout_is", except that it captures "STDERR". The test passes if "STDERR"
           from $coderef equals $expected.

           stderr_isnt() passes if "STDERR" is not equal to $expected.

       <b>stderr_like</b>
       <b>stderr_unlike</b>
              stderr_like  ( $coderef, qr/$expected/, 'description' );
              stderr_like   { ...} qr/$expected/, 'description';
              stderr_unlike( $coderef, qr/$expected/, 'description' );
              stderr_unlike  { ...} qr/$expected/, 'description';

           stderr_like() is similar to stdout_like() except that it compares the  regex  $expected  to  "STDERR"
           captured from $codref. The test passes if the regex matches.

           stderr_unlike() passes if "STDERR" does not match the regex.

   <b>COMBINED</b> <b>OUTPUT</b>
       <b>combined_is</b>
       <b>combined_isnt</b>
              combined_is   ( $coderef, $expected, 'description' );
              combined_is   {... } $expected, 'description';
              combined_isnt ( $coderef, $expected, 'description' );
              combined_isnt {... } $expected, 'description';

           combined_is()  directs  "STDERR"  to  "STDOUT"  then  captures  "STDOUT". This is equivalent to UNIXs
           "2&gt;&amp;1". The test passes if the combined "STDOUT" and "STDERR" from $coderef equals $expected.

           combined_isnt() passes if combined "STDOUT" and "STDERR" are not equal to $expected.

       <b>combined_like</b>
       <b>combined_unlike</b>
              combined_like   ( $coderef, qr/$expected/, 'description' );
              combined_like   { ...} qr/$expected/, 'description';
              combined_unlike ( $coderef, qr/$expected/, 'description' );
              combined_unlike { ...} qr/$expected/, 'description';

           combined_like() is similar to combined_is() except that it compares a regex ("$expected)" to "STDOUT"
           and "STDERR" captured from $codref. The test passes if the regex matches.

           combined_unlike() passes if the combined "STDOUT" and "STDERR" does not match the regex.

   <b>OUTPUT</b>
       <b>output_is</b>
       <b>output_isnt</b>
              output_is  ( $coderef, $expected_stdout, $expected_stderr, 'description' );
              output_is    {... } $expected_stdout, $expected_stderr, 'description';
              output_isnt( $coderef, $expected_stdout, $expected_stderr, 'description' );
              output_isnt  {... } $expected_stdout, $expected_stderr, 'description';

           The output_is() function is a combination of the stdout_is() and stderr_is() functions. For example:

             output_is(sub {print "foo"; print STDERR "bar";},'foo','bar');

           is functionally equivalent to

             stdout_is(sub {print "foo";},'foo')
               &amp;&amp; stderr_is(sub {print STDERR "bar";},'bar');

           except that $coderef is only executed once.

           Unlike stdout_is() and stderr_is() which ignore STDERR and STDOUT respectively, output_is()  requires
           both  "STDOUT"  and  "STDERR"  to  match  in  order  to  pass.  Setting  either  $expected_stdout  or
           $expected_stderr to "undef" ignores "STDOUT" or "STDERR" respectively.

             output_is(sub {print "foo"; print STDERR "bar";},'foo',undef);

           is the same as

             stdout_is(sub {print "foo";},'foo')

           output_isnt() provides the opposite function of output_is(). It is a combination of stdout_isnt() and
           stderr_isnt().

             output_isnt(sub {print "foo"; print STDERR "bar";},'bar','foo');

           is functionally equivalent to

             stdout_isnt(sub {print "foo";},'bar')
               &amp;&amp; stderr_isnt(sub {print STDERR "bar";},'foo');

           As with output_is(), setting either $expected_stdout  or  $expected_stderr  to  "undef"  ignores  the
           output to that facility.

             output_isnt(sub {print "foo"; print STDERR "bar";},undef,'foo');

           is the same as

             stderr_is(sub {print STDERR "bar";},'foo')

       <b>output_like</b>
       <b>output_unlike</b>
             output_like  ( $coderef, $regex_stdout, $regex_stderr, 'description' );
             output_like  { ... } $regex_stdout, $regex_stderr, 'description';
             output_unlike( $coderef, $regex_stdout, $regex_stderr, 'description' );
             output_unlike { ... } $regex_stdout, $regex_stderr, 'description';

           output_like()  and output_unlike() follow the same principles as output_is() and output_isnt() except
           they use a regular expression for matching.

           output_like() attempts to  match  $regex_stdout  and  $regex_stderr  against  "STDOUT"  and  "STDERR"
           produced by $coderef. The test passes if both match.

             output_like(sub {print "foo"; print STDERR "bar";},qr/foo/,qr/bar/);

           The above test is successful.

           Like output_is(), setting either $regex_stdout or $regex_stderr to "undef" ignores the output to that
           facility.

             output_like(sub {print "foo"; print STDERR "bar";},qr/foo/,undef);

           is the same as

             stdout_like(sub {print "foo"; print STDERR "bar";},qr/foo/);

           output_unlike() test pass if output from $coderef doesn't match $regex_stdout and $regex_stderr.

</pre><h4><b>EXPORTS</b></h4><pre>
       By default, all subroutines are exported by default.

       •   :stdout - the subs with "stdout" in the name.

       •   :stderr - the subs with "stderr" in the name.

       •   :functions - the subs with "_from" at the end.

       •   :output - the subs with "output" in the name.

       •   :combined - the subs with "combined" in the name.

       •   :tests - everything that outputs TAP

       •   :all - everything (which is the same as the default)

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>stdout_from</b>
         my $stdout = stdout_from($coderef)
         my $stdout = stdout_from { ... };

       <b>stdout_from()</b> executes $coderef and captures STDOUT.

   <b>stderr_from</b>
         my $stderr = stderr_from($coderef)
         my $stderr = stderr_from { ... };

       stderr_from() executes $coderef and captures "STDERR".

   <b>output_from</b>
         my ($stdout, $stderr) = output_from($coderef)
         my ($stdout, $stderr) = output_from {...};

       output_from() executes $coderef one time capturing both "STDOUT" and "STDERR".

   <b>combined_from</b>
         my $combined = combined_from($coderef);
         my $combined = combined_from {...};

       combined_from()   executes  $coderef  one  time  combines  "STDOUT"  and  "STDERR",  and  captures  them.
       combined_from() is equivalent to using "2&gt;&amp;1" in UNIX.

</pre><h4><b>AUTHOR</b></h4><pre>
       Currently maintained by brian d foy, "<a href="mailto:briandfoy@pobox.com">briandfoy@pobox.com</a>".

       Shawn Sorichetti, "&lt;<a href="mailto:ssoriche@cpan.org">ssoriche@cpan.org</a>&gt;"

</pre><h4><b>SOURCE</b> <b>AVAILABILITY</b></h4><pre>
       This module is in Github:

               <a href="http://github.com/briandfoy/test-output">http://github.com/briandfoy/test-output</a>

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests to "<a href="mailto:bug-test-output@rt.cpan.org">bug-test-output@rt.cpan.org</a>", or through the web interface
       at &lt;<a href="http://rt.cpan.org">http://rt.cpan.org</a>&gt;.  I will be notified, and then you'll automatically be notified  of  progress  on
       your bug as I make changes.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to chromatic whose TieOut.pm was the basis for capturing output.

       Also  thanks  to  rjbs  for  his  help cleaning the documentation, and pushing me to Sub::Exporter. (This
       feature has been removed since it uses none of Sub::Exporter's strengths).

       Thanks to David Wheeler for providing code block support and tests.

       Thanks to Michael G Schwern for the solution to combining "STDOUT" and "STDERR".

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2005-2021 Shawn Sorichetti, All Rights Reserved.

       This module is licensed under the Artistic License 2.0.

perl v5.40.1                                       2025-04-17                                  <u>Test::<a href="../man3pm/Output.3pm.html">Output</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>