<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dancer::Test - Test helpers to test a Dancer application</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdancer-perl">libdancer-perl_1.3521+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Dancer::Test - Test helpers to test a Dancer application

</pre><h4><b>VERSION</b></h4><pre>
       version 1.3521

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use strict;
           use warnings;
           use Test::More tests =&gt; 2;

           use MyWebApp;
           use Dancer::Test;

           response_status_is [GET =&gt; '/'], 200, "GET / is found";
           response_content_like [GET =&gt; '/'], qr/hello, world/, "content looks good for /";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides test helpers for testing Dancer apps.

       Be careful, the module loading order in the example above is very important.  Make sure to use
       "Dancer::Test" <b>after</b> importing the application package otherwise your appdir will be automatically set to
       "lib" and your test script won't be able to find views, conffiles and other application content.

       For all test methods, the first argument can be either an array ref of the method and route, or a scalar
       containing the route (in which case the method is assumed to be "GET"), or a Dancer::Response object.

           # all 3 are equivalent
           response_status_is [ GET =&gt; '/' ], 200, 'GET / status is ok';

           response_status_is '/', 200, 'GET / status is ok';

           my $resp = dancer_response GET =&gt; '/';
           response_status_is $resp =&gt; 200, 'GET / status is ok';

</pre><h4><b>METHODS</b></h4><pre>
   <b>route_exists([$method,</b> <b>$path],</b> <b>$test_name)</b>
       Asserts that the given request matches a route handler in Dancer's registry.

           route_exists [GET =&gt; '/'], "GET / is handled";

   <b>route_doesnt_exist([$method,</b> <b>$path],</b> <b>$test_name)</b>
       Asserts that the given request does not match any route handler in Dancer's registry.

           route_doesnt_exist [GET =&gt; '/bogus_path'], "GET /bogus_path is not handled";

   <b>response_exists([$method,</b> <b>$path],</b> <b>$test_name)</b>
       Deprecated - Use response_status_isnt and check for status 404.

       Asserts that a response is found for the given request (note that even though a route for that path might
       not exist, a response can be found during request processing, because of filters).

           response_exists [GET =&gt; '/path_that_gets_redirected_to_home'],
               "response found for unknown path";

   <b>response_doesnt_exist([$method,</b> <b>$path],</b> <b>$test_name)</b>
       Deprecated - Use response_status_is and check for status 404.

       Asserts that no response is found when processing the given request.

           response_doesnt_exist [GET =&gt; '/unknown_path'],
               "response not found for unknown path";

   <b>response_status_is([$method,</b> <b>$path],</b> <b>$status,</b> <b>$test_name)</b>
       Asserts that Dancer's response for the given request has a status equal to the one given.

           response_status_is [GET =&gt; '/'], 200, "response for GET / is 200";

   <b>response_status_isnt([$method,</b> <b>$path],</b> <b>$status,</b> <b>$test_name)</b>
       Asserts that the status of Dancer's response is not equal to the one given.

           response_status_isnt [GET =&gt; '/'], 404, "response for GET / is not a 404";

   <b>response_content_is([$method,</b> <b>$path],</b> <b>$expected,</b> <b>$test_name)</b>
       Asserts that the response content is equal to the $expected string.

           response_content_is [GET =&gt; '/'], "Hello, World",
               "got expected response content for GET /";

   <b>response_content_isnt([$method,</b> <b>$path],</b> <b>$not_expected,</b> <b>$test_name)</b>
       Asserts that the response content is not equal to the $not_expected string.

           response_content_isnt [GET =&gt; '/'], "Hello, World",
               "got expected response content for GET /";

   <b>response_content_is_deeply([$method,</b> <b>$path],</b> <b>$expected_struct,</b> <b>$test_name)</b>
       Similar to <b>response_content_is()</b>, except that if response content and $expected_struct are references, it
       does a deep comparison walking each data structure to see if they are equivalent.

       If the two structures are different, it will display the place where they start differing.

           response_content_is_deeply [GET =&gt; '/complex_struct'],
               { foo =&gt; 42, bar =&gt; 24},
               "got expected response structure for GET /complex_struct";

   <b>response_content_like([$method,</b> <b>$path],</b> <b>$regexp,</b> <b>$test_name)</b>
       Asserts that the response content for the given request matches the regexp given.

           response_content_like [GET =&gt; '/'], qr/Hello, World/,
               "response content looks good for GET /";

   <b>response_content_unlike([$method,</b> <b>$path],</b> <b>$regexp,</b> <b>$test_name)</b>
       Asserts that the response content for the given request does not match the regexp given.

           response_content_unlike [GET =&gt; '/'], qr/Page not found/,
               "response content looks good for GET /";

   <b>response_headers_are_deeply([$method,</b> <b>$path],</b> <b>$expected,</b> <b>$test_name)</b>
       Asserts that the response headers data structure equals the one given.

           response_headers_are_deeply [GET =&gt; '/'], [ 'X-Powered-By' =&gt; 'Dancer 1.150' ];

   <b>response_headers_include([$method,</b> <b>$path],</b> <b>$expected,</b> <b>$test_name)</b>
       Asserts that the response headers data structure includes some of the defined ones.

           response_headers_include [GET =&gt; '/'], [ 'Content-Type' =&gt; 'text/plain' ];

   <b>response_redirect_location_is([$method,</b> <b>$path],</b> <b>$expected,</b> <b>$test_name)</b>
       Asserts that the location header sent with a 302 redirect is equal to the $expected location.

           response_redirect_location_is [GET =&gt; '/'], '<a href="http://localhost/index.html">http://localhost/index.html</a>';

   <b>response_redirect_location_like([$method,</b> <b>$path],</b> <b>$regexp,</b> <b>$test_name)</b>
       Asserts that the location header sent with a 302 redirect matches the $regexp provided. Useful if the
       redirect location includes a query string.

           response_redirect_location_like [GET =&gt; '/'], qr/some_pattern/;

   <b>dancer_response($method,</b> <b>$path,</b> <b>{</b> <b>params</b> <b>=&gt;</b> <b>$params,</b> <b>body</b> <b>=&gt;</b> <b>$body,</b> <b>headers</b> <b>=&gt;</b> <b>$headers,</b> <b>files</b> <b>=&gt;</b> <b>[{filename</b>
       <b>=&gt;</b> <b>'/path/to/file',</b> <b>name</b> <b>=&gt;</b> <b>'my_file'}]</b> <b>})</b>
       Returns a Dancer::Response object for the given request.

       Only $method and $path are required.

       $params is a hashref, $body can be a string or a hashref and $headers can be an arrayref or a
       HTTP::Headers object, $files is an arrayref of hashref, containing some files to upload.

       $params always populates the query string, even for POST requests.  $body always populates the request
       body.

       Currently, Dancer::Test cannot cope with both <u>body</u> and <u>files</u> passed in the same call.

       A good reason to use this function is for testing POST requests. Since POST requests may not be
       idempotent, it is necessary to capture the content and status in one shot. Calling the response_status_is
       and response_content_is functions in succession would make two requests, each of which could alter the
       state of the application and cause Schrodinger's cat to die.

           my $response = dancer_response POST =&gt; '/widgets';
           is $response-&gt;{status}, 202, "response for POST /widgets is 202";
           is $response-&gt;{content}, "Widget #1 has been scheduled for creation",
               "response content looks good for first POST /widgets";

           $response = dancer_response POST =&gt; '/widgets';
           is $response-&gt;{status}, 202, "response for POST /widgets is 202";
           is $response-&gt;{content}, "Widget #2 has been scheduled for creation",
               "response content looks good for second POST /widgets";

       It's possible to test file uploads:

           post '/upload' =&gt; sub { return upload('image')-&gt;content };

           $response = dancer_response(POST =&gt; '/upload', {files =&gt; [{name =&gt; 'image', filename =&gt; '/path/to/image.jpg'}]});

       In addition, you can supply the file contents as the "data" key:

           my $data  = 'A test string that will pretend to be file contents.';
           $response = dancer_response(POST =&gt; '/upload', {
               files =&gt; [{name =&gt; 'test', filename =&gt; "filename.ext", data =&gt; $data}]
           });

   <b>read_logs</b>
           my $logs = read_logs;

       Returns an array ref of all log messages issued by the app since the last call to "read_logs".

       For example:

           warning "Danger!  Warning!";
           debug   "I like pie.";

           is_deeply read_logs, [
               { level =&gt; "warning", message =&gt; "Danger!  Warning!" },
               { level =&gt; "debug",   message =&gt; "I like pie.", }
           ];

           error "Put out the light.";

           is_deeply read_logs, [
               { level =&gt; "error", message =&gt; "Put out the light." },
           ];

       See Dancer::Logger::Capture for more details.

</pre><h4><b>LICENSE</b></h4><pre>
       This module is free software and is distributed under the same terms as Perl itself.

</pre><h4><b>AUTHOR</b></h4><pre>
       This module has been written by Alexis Sukrieh &lt;<a href="mailto:sukria@sukria.net">sukria@sukria.net</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Test::More

</pre><h4><b>AUTHOR</b></h4><pre>
       Dancer Core Developers

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2010 by Alexis Sukrieh.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.36.0                                       2023-02-10                                  <u>Dancer::<a href="../man3pm/Test.3pm.html">Test</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>