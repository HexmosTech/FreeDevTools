<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::MockFile - Allows tests to validate code that can interact with files without touching the file</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-mockfile-perl">libtest-mockfile-perl_0.037-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::MockFile - Allows tests to validate code that can interact with files without touching the file
       system.

</pre><h4><b>VERSION</b></h4><pre>
       Version 0.037

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Intercepts file system calls for specific files so unit testing can take place without any files being
       altered on disk.

       This is useful for small tests &lt;https://testing.googleblog.com/2010/12/test-sizes.html&gt; where file
       interaction is discouraged.

       A strict mode is even provided (and turned on by default) which can throw a die when files are accessed
       during your tests!

           # Loaded before Test::MockFile so uses the core perl functions without any hooks.
           use Module::I::Dont::Want::To::Alter;

           # strict mode by default
           use Test::MockFile ();

           # non-strict mode
           use Test::MockFile qw&lt; nostrict &gt;;

           # Load with one or more plugins

           use Test::MockFile plugin =&gt; 'FileTemp';
           use Test::MockFile plugin =&gt; [ 'FileTemp', ... ];

           # Be sure to assign the output of mocks, they disappear when they go out of scope
           my $foobar = Test::MockFile-&gt;file( "/foo/bar", "contents\ngo\nhere" );
           open my $fh, '&lt;', '/foo/bar' or die;    # Does not actually open the file on disk
           say '/foo/bar exists' if -e $fh;
           close $fh;

           say '/foo/bar is a file' if -f '/foo/bar';
           say '/foo/bar is THIS BIG: ' . -s '/foo/bar';

           my $foobaz = Test::MockFile-&gt;file('/foo/baz');    # File starts out missing
           my $opened = open my $baz_fh, '&lt;', '/foo/baz';    # File reports as missing so fails
           say '/foo/baz does not exist yet' if !-e '/foo/baz';

           open $baz_fh, '&gt;', '/foo/baz' or die;             # open for writing
           print {$baz_fh} "first line\n";

           open $baz_fh, '&gt;&gt;', '/foo/baz' or die;            # open for append.
           print {$baz_fh} "second line";
           close $baz_fh;

           say "Contents of /foo/baz:\n&gt;&gt;" . $foobaz-&gt;contents() . '&lt;&lt;';

           # Unmock your file.
           # (same as the variable going out of scope
           undef $foobaz;

           # The file check will now happen on file system now the file is no longer mocked.
           say '/foo/baz is missing again (no longer mocked)' if !-e '/foo/baz';

           my $quux    = Test::MockFile-&gt;file( '/foo/bar/quux.txt', '' );
           my @matches = &lt;/foo/bar/*.txt&gt;;

           # ( '/foo/bar/quux.txt' )
           say "Contents of /foo/bar directory: " . join "\n", @matches;

           @matches = glob('/foo/bar/*.txt');

           # same as above
           say "Contents of /foo/bar directory (using glob()): " . join "\n", @matches;

</pre><h4><b>IMPORT</b></h4><pre>
       When the module is loaded with no parameters, strict mode is turned on.  Any file checks, "open",
       "sysopen", "opendir", "stat", or "lstat" will throw a die.

       For example:

           use Test::MockFile;

           # This will not die.
           my $file    = Test::MockFile-&gt;file("/bar", "...");
           my $symlink = Test::MockFile-&gt;symlink("/foo", "/bar");
           -l '/foo' or print "ok\n";
           open my $fh, '&gt;', '/foo';

           # All of these will die
           open my $fh, '&gt;', '/unmocked/file'; # Dies
           sysopen my $fh, '/other/file', O_RDONLY;
           opendir my $fh, '/dir';
           -e '/file';
           -l '/file';

       If we want to load the module without strict mode:

           use Test::MockFile qw&lt; nostrict &gt;;

       Relative paths are not supported:

           use Test::MockFile;

           # Checking relative vs absolute paths
           $file = Test::MockFile-&gt;file( '/foo/../bar', '...' ); # not ok - relative path
           $file = Test::MockFile-&gt;file( '/bar',        '...' ); # ok     - absolute path
           $file = Test::MockFile-&gt;file( 'bar', '...' );         # ok     - current dir

   <b>authorized_strict_mode_for_package(</b> <b>$pkg</b> <b>)</b>
       Add a package namespace to the list of authorize namespaces.

           authorized_strict_mode_for_package( 'Your::Package' );

   <b>file_arg_position_for_command</b>
       Args: ($command)

       Provides a hint with the position of the argument most likely holding the file name for the current
       $command call.

       This is used internaly to provide better error messages. This can be used when plugging hooks to know
       what's the filename we currently try to access.

   <b>add_strict_rule(</b> <b>$command_rule,</b> <b>$file_rule,</b> <b>$action</b> <b>)</b>
       Args: ($command_rule, $file_rule, $action)

       Add a custom rule to validate strictness mode. This is the fundation to add strict rules. You should use
       it, when none of the other helper to add rules work for you.

       $command_rule a string or regexp or list of any to indicate which command to match
           =item$file_rule  a  string or regexp or undef or list of any to indicate which files your rules apply
           to.

       $action a CODE ref or scalar to handle the exception. Returning '1' skip all other rules and indicate an
       exception.

           # Check open() on /this/file
           add_strict_rule( 'open', '/this/file', sub { ... } );

           # always bypass the strict rule
           add_strict_rule( 'open', '/this/file', 1 );

           # all available options
           add_strict_rule( 'open', '/this/file', sub {
               my ($context) = @_;

               return;   # Skip this rule and continue from the next one
               return 0; # Strict violation, stop testing rules and die
               return 1; # Strict passing, stop testing rules
           } );

           # Disallow open(), close() on everything in <a href="file:/tmp/">/tmp/</a>
           add_strict_rule(
               [ qw&lt; open close &gt; ],
               qr{^<a href="file:/tmp">/tmp</a>}xms,
               0,
           );

           # Disallow open(), close() on everything (ignore filenames)
           # Use add_strict_rule_for_command() instead!
           add_strict_rule(
               [ qw&lt; open close &gt; ],
               undef,
               0,
           );

   <b>clear_strict_rules()</b>
       Args: none

       Clear all previously defined rules. (Mainly used for testing purpose)

   <b>add_strict_rule_for_filename(</b> <b>$file_rule,</b> <b>$action</b> <b>)</b>
       Args: ($file_rule, $action)

       Prefer using that helper when trying to add strict rules targeting files.

       Apply a rule to one or more files.

           add_strict_rule_for_filename( '/that/file' =&gt; sub { ... } );

           add_strict_rule_for_filename( [ qw{list of files} ] =&gt; sub { ... } );

           add_strict_rule_for_filename( qr{*\.t$} =&gt; sub { ... } );

           add_strict_rule_for_filename( [ $dir, qr{^${dir}/} ] =&gt; 1 );

   <b>add_strict_rule_for_command(</b> <b>$command_rule,</b> <b>$action</b> <b>)</b>
       Args: ($command_rule, $action)

       Prefer using that helper when trying to add strict rules targeting specici commands.

       Apply a rule to one or more files.

           add_strict_rule_for_command( 'open' =&gt; sub { ... } );

           add_strict_rule_for_command( [ qw{open readdir} ] =&gt; sub { ... } );

           add_strict_rule_for_command( qr{open.*} =&gt; sub { ... } );

           Test::MockFile::add_strict_rule_for_command(
               [qw{ readdir closedir readlink }],
               sub {
                   my ($ctx) = @_;
                   my $command = $ctx-&gt;{command} // 'unknown';

                   warn( "Ignoring strict mode violation for $command" );
                   return 1;
               }
           );

   <b>add_strict_rule_generic(</b> <b>$action</b> <b>)</b>
       Args: ($action)

       Prefer using that helper when adding a rule which is global and does not apply to a specific  command  or
       file.

       Apply a rule to one or more files.

           add_strict_rule_generic( sub { ... } );

           add_strict_rule_generic( sub  {
               my ($ctx) = @_;

               my $filename = $ctx-&gt;{filename};

               return unless defined $filename;

               return 1 if UNIVERSAL::isa( $filename, 'GLOB' );

               return;
           } );

   <b>is_strict_mode</b>
       Boolean helper to determine if strict mode is currently enabled.

</pre><h4><b>SUBROUTINES/METHODS</b></h4><pre>
   <b>file</b>
       Args: ($file, $contents, $stats)

       This will make cause $file to be mocked in all file checks, opens, etc.

       "undef"  contents  means that the file should act like it's not there.  You can only set the stats if you
       provide content.

       If you give file content, the directory inside it will be mocked as well.

           my $f = Test::MockFile-&gt;file( '/foo/bar' );
           -d '/foo' # not ok

           my $f = Test::MockFile-&gt;file( '/foo/bar', 'some content' );
           -d '/foo' # ok

       See "Mock Stats" for what goes into the stats hashref.

   <b>file_from_disk</b>
       Args: "($file_to_mock, $file_on_disk, $stats)"

       This will make cause $file to be mocked in all file checks, opens, etc.

       If "file_on_disk" isn't present, then this will die.

       See "Mock Stats" for what goes into the stats hashref.

   <b>symlink</b>
       Args: ($readlink, $file )

       This will cause $file to be mocked in all file checks, opens, etc.

       $readlink indicates what "fake" file it points to. If the file $readlink points to is not mocked, it will
       act like a broken link, regardless of what's on disk.

       If $readlink is undef, then the symlink is mocked but not present.(lstat $file is empty.)

       Stats are not able to be specified on instantiation but can in theory be  altered  after  the  object  is
       created. People don't normally mess with the permissions on a symlink.

   <b>dir</b>
       Args: ($dir)

       This will cause $dir to be mocked in all file checks, and "opendir" interactions.

       The directory name is normalized so any trailing slash is removed.

           $dir = Test::MockFile-&gt;dir( 'mydir/', ... ); # ok
           $dir-&gt;path();                                # mydir

       If  there  were previously mocked files (within the same scope), the directory will exist. Otherwise, the
       directory will be nonexistent.

           my $dir = Test::MockFile-&gt;dir('<a href="file:/etc">/etc</a>');
           -d $dir;          # not ok since directory wasn't created yet
           $dir-&gt;contents(); # undef

           # Now we can create an empty directory
           mkdir '<a href="file:/etc">/etc</a>';
           $dir_etc-&gt;contents(); # . ..

           # Alternatively, we can already create files with -&gt;file()
           $dir_log  = Test::MockFile-&gt;dir('<a href="file:/var">/var</a>');
           $file_log = Test::MockFile-&gt;file( '/var/log/access_log', $some_content );
           $dir_log-&gt;contents(); # . .. access_log

           # If you create a nonexistent file but then give it content, it will create
           # the directory for you
           my $file = Test::MockFile-&gt;file('/foo/bar');
           my $dir  = Test::MockFile-&gt;dir('/foo');
           -d '/foo'                 # false
           -e '/foo/bar';            # false
           $dir-&gt;contents();         # undef

           $file-&gt;contents('hello');
           -e '/foo/bar';            # true
           -d '/foo';                # true
           $dir-&gt;contents();         # . .. bar

       NOTE: Because "." and  ".."  will  always  be  the  first  things  "readdir"  returns,  These  files  are
       automatically inserted at the front of the array. The order of files is sorted.

       If  you  want  to  affect  the  stat  information of a directory, you need to use the available core Perl
       keywords. (We might introduce a special helper method for it in the future.)

           $d = Test::MockFile-&gt;dir( '/foo', [], { 'mode' =&gt; 0755 } );    # dies
           $d = Test::MockFile-&gt;dir( '/foo', undef, { 'mode' =&gt; 0755 } ); # dies

           $d = Test::MockFile-&gt;dir('/foo');
           mkdir $d, 0755;                   # ok

   <b>new_dir</b>
           # short form
           $new_dir = Test::MockFile-&gt;new_dir( '/path' );
           $new_dir = Test::MockFile-&gt;new_dir( '/path', { 'mode' =&gt; 0755 } );

           # longer form 1
           $dir = Test::MockFile-&gt;dir('/path');
           mkdir $dir-&gt;path(), 0755;

           # longer form 2
           $dir = Test::MockFile-&gt;dir('/path');
           mkdir $dir-&gt;path();
           chmod $dir-&gt;path();

       This creates a new directory with an optional mode. This is a short-hand that might  be  removed  in  the
       future when a stable, new interface is introduced.

   <b>Mock</b> <b>Stats</b>
       When creating mocked files or directories, we default their stats to:

           my $attrs = Test::MockFile-&gt;file( $file, $contents, {
                   'dev'       =&gt; 0,        # stat[0]
                   'inode'     =&gt; 0,        # stat[1]
                   'mode'      =&gt; $mode,    # stat[2]
                   'nlink'     =&gt; 0,        # stat[3]
                   'uid'       =&gt; int $&gt;,   # stat[4]
                   'gid'       =&gt; int $),   # stat[5]
                   'rdev'      =&gt; 0,        # stat[6]
                   'atime'     =&gt; $now,     # stat[8]
                   'mtime'     =&gt; $now,     # stat[9]
                   'ctime'     =&gt; $now,     # stat[10]
                   'blksize'   =&gt; 4096,     # stat[11]
                   'fileno'    =&gt; undef,    # fileno()
           } );

       You'll  notice that mode, size, and blocks have been left out of this.  Mode is set to 666 (for files) or
       777 (for directories), xored against the current umask. Size and blocks are calculated based on the  size
       of 'contents' a.k.a. the fake file.

       When  you  want  to override one of the defaults, all you need to do is specify that when you declare the
       file or directory. The rest will continue to default.

           my $mfile = Test::MockFile-&gt;file("/root/abc", "...", {inode =&gt; 65, uid =&gt; 123, mtime =&gt; int((2000-1970) * 365.25 * 24 * 60 * 60 }));

           my $mdir = Test::MockFile-&gt;dir("<a href="file:/sbin">/sbin</a>", "...", { mode =&gt; 0700 }));

   <b>new</b>
       This class method is called by file/symlink/dir. There is no good reason to call this directly.

   <b>contents</b>
       Optional Arg: $contents

       Retrieves or updates the current contents of the file.

       Only retrieves the content of the directory (as an  arrayref).   You  can  set  directory  contents  with
       calling the file() method described above.

       Symlinks have no contents.

   <b>filename</b>
       Deprecated. Same as "path".

   <b>path</b>
       The path (filename or dirname) of the file or directory this mock object is controlling.

   <b>unlink</b>
       Makes the virtual file go away. NOTE: This also works for directories.

   <b>touch</b>
       Optional Args: ($epoch_time)

       This function acts like the UNIX utility touch. It sets atime, mtime, ctime to $epoch_time.

       If no arguments are passed, $epoch_time is set to <b>time()</b>. If the file does not exist, contents are set to
       an empty string.

   <b>stat</b>
       Returns the stat of a mocked file (does not follow symlinks.)

   <b>readlink</b>
       Optional Arg: $readlink

       Returns  the  stat of a mocked file (does not follow symlinks.) You can also use this to change what your
       symlink is pointing to.

   <b>is_link</b>
       returns true/false, depending on whether this object is a symlink.

   <b>is_dir</b>
       returns true/false, depending on whether this object is a directory.

   <b>is_file</b>
       returns true/false, depending on whether this object is a regular file.

   <b>size</b>
       returns the size of the file based on its contents.

   <b>exists</b>
       returns true or false based on if the file exists right now.

   <b>blocks</b>
       Calculates the block count of the file based on its size.

   <b>chmod</b>
       Optional Arg: $perms

       Allows you to alter the permissions of a file. This only allows you to change the 07777 bits of the  file
       permissions. The number passed should be the octal 0755 form, not the alphabetic "755" form

   <b>permissions</b>
       Returns the permissions of the file.

   <b>mtime</b>
       Optional Arg: $new_epoch_time

       Returns and optionally sets the mtime of the file if passed as an integer.

   <b>ctime</b>
       Optional Arg: $new_epoch_time

       Returns and optionally sets the ctime of the file if passed as an integer.

   <b>atime</b>
       Optional Arg: $new_epoch_time

       Returns and optionally sets the atime of the file if passed as an integer.

   <b>add_file_access_hook</b>
       Args: ( $code_ref )

       You  can  use <b>add_file_access_hook</b> to add a code ref that gets called every time a real file (not mocked)
       operation happens. We use this for strict mode to die if we detect your program is unexpectedly accessing
       files. You are welcome to use it for whatever you like.

       Whenever the code ref is called, we pass 2 arguments: "$code-&gt;($access_type,  $at_under_ref)".  Be  aware
       that altering the variables in $at_under_ref will affect the variables passed to open / sysopen, etc.

       One use might be:

           Test::MockFile::add_file_access_hook(sub { my $type = shift; print "$type called at: " . Carp::longmess() } );

   <b>clear_file_access_hooks</b>
       Calling this subroutine will clear everything that was passed to <b>add_file_access_hook</b>

   <b>How</b> <b>this</b> <b>mocking</b> <b>is</b> <b>done:</b>
       Test::MockFile uses 2 methods to mock file access:

       <u>-X</u> <u>via</u> <u>Overload::FileCheck</u>

       It is currently not possible in pure perl to override stat &lt;<a href="http://perldoc.perl.org/functions/stat.html">http://perldoc.perl.org/functions/stat.html</a>&gt;,
       lstat          &lt;<a href="http://perldoc.perl.org/functions/lstat.html">http://perldoc.perl.org/functions/lstat.html</a>&gt;          and          -X          operators
       &lt;<a href="http://perldoc.perl.org/functions/-X.html">http://perldoc.perl.org/functions/-X.html</a>&gt;.  In  conjunction   with   this   module,   we've   developed
       Overload::FileCheck.

       This  enables  us to intercept calls to stat, lstat and -X operators (like -e, -f, -d, -s, etc.) and pass
       them to our control. If the file is currently being mocked, we return the stat (or lstat) information  on
       the  file to be used to determine the answer to whatever check was made.  This even works for things like
       "-e _". If we do not control the file in question, we return FALLBACK_TO_REAL_OP()  which  then  makes  a
       normal check.

       <u>CORE::GLOBAL::</u> <u>overrides</u>

       Since 5.10, it has been possible to override function calls by defining them. like:

           *CORE::GLOBAL::open = sub(*;$@) {...}

       Any  code  which  is loaded <b>AFTER</b> this happens will use the alternate open. This means you can place your
       "use Test::MockFile" statement after statements you don't want to be mocked and there is no risk that the
       code will ever be altered by Test::MockFile.

       We oveload the following statements and then return tied handles to enable the rest of the  IO  functions
       to work properly. Only <b>open</b> / <b>sysopen</b> are needed to address file operations. However <b>opendir</b> file handles
       were never setup for tie so we have to override all of <b>opendir</b>'s related functions.

       •   open

       •   sysopen

       •   opendir

       •   readdir

       •   telldir

       •   seekdir

       •   rewinddir

       •   closedir

</pre><h4><b>CAEATS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
   <b>DEBUGGER</b> <b>UNDER</b> <b>STRICT</b> <b>MODE</b>
       If you want to use the Perl debugger (perldebug) on any code that uses Test::MockFile in strict mode, you
       will  need  to  load Term::ReadLine beforehand, because it loads a file. Under the debugger, the debugger
       will load the module after Test::MockFile and get mad.

           # Load it from the command line
           perl -MTerm::ReadLine -d code.pl

           # Or alternatively, add this to the top of your code:
           use Term::ReadLine

   <b>FILENO</b> <b>IS</b> <b>UNSUPPORTED</b>
       Filehandles can provide the  file  descriptor  (in  number)  using  the  "fileno"  keyword  but  this  is
       purposefully unsupported in Test::MockFile.

       The  reaosn  is  that  by mocking a file, we're creating an alternative file system. Returning a "fileno"
       (file descriptor number) would require creating file descriptor numbers that would possibly conflict with
       the file desciptors you receive from the real filesystem.

       In short, this is a recipe for buggy tests or worse - truly destructive behavior. If you have a need  for
       a real file, we suggest File::Temp.

   <b>BAREWORD</b> <b>FILEHANDLE</b> <b>FAILURES</b>
       There is a particular type of bareword filehandle failures that cannot be fixed.

       These  errors  occur  because there's compile-time code that uses bareword filehandles in a function call
       that cannot be expressed by this module's prototypes for core functions.

       The only solution to these is loading `Test::MockFile` after the other code:

       This will fail:

           # This will fail because Test2::V0 will eventually load Term::Table::Util
           # which calls open() with a bareword filehandle that is misparsed by this module's
           # opendir prototypes
           use Test::MockFile ();
           use Test2::V0;

       This will succeed:

           # This will succeed because open() will be parsed by perl
           # and only then we override those functions
           use Test2::V0;
           use Test::MockFile ();

       (Using strict-mode will not fix it, even though you should use it.)

</pre><h4><b>AUTHOR</b></h4><pre>
       Todd Rinaldo, "&lt;toddr at cpan.org&gt;"

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests to &lt;https://github.com/CpanelInc/Test-MockFile&gt;.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc Test::MockFile

       You can also look for information at:

       •   CPAN Ratings

           &lt;https://cpanratings.perl.org/d/Test-MockFile&gt;

       •   Search CPAN

           &lt;https://metacpan.org/release/Test-MockFile&gt;

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to Nicolas R., "&lt;atoomic at cpan.org&gt;" for help with Overload::FileCheck. This  module  could  not
       have been completed without it.

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright 2018 cPanel L.L.C.

       All rights reserved.

       &lt;<a href="http://cpanel.net">http://cpanel.net</a>&gt;

       This  is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See
       perlartistic.

perl v5.40.1                                       2025-05-16                                <u>Test::<a href="../man3pm/MockFile.3pm.html">MockFile</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>