<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::LectroTest::Property - Properties that make testable claims about your software</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-lectrotest-perl">libtest-lectrotest-perl_0.5001-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::LectroTest::Property - Properties that make testable claims about your software

</pre><h4><b>VERSION</b></h4><pre>
       version 0.5001

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use MyModule;  # provides my_function_to_test

        use Test::LectroTest::Generator qw( :common );
        use Test::LectroTest::Property qw( Test );
        use Test::LectroTest::TestRunner;

        my $prop_non_neg = Property {
            ##[ x &lt;- Int, y &lt;- Int ]##
            $tcon-&gt;label("negative") if $x &lt; 0;
            $tcon-&gt;label("odd")      if $x % 2;
            $tcon-&gt;retry             if $y == 0;  # 0 can't be used in test
            my_function_to_test( $x, $y ) &gt;= 0;
        }, name =&gt; "my_function_to_test output is non-negative";

        my $runner = Test::LectroTest::TestRunner-&gt;new();
        $runner-&gt;run_suite(
            $prop_non_neg,
            # ... more properties here ...
        );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>STOP!</b> If you're just looking for an easy way to write and run unit tests, see Test::LectroTest first.
       Once you're comfortable with what is presented there and ready to delve into the full offerings of
       properties, this is the document for you.

       This module allows you to define Properties that can be checked automatically by Test::LectroTest.  A
       Property is a specification of your software's required behavior over a given set of conditions.  The set
       of conditions is given by a generator-binding specification. The required behavior is defined implicitly
       by a block of code that tests your software for a given set of generated conditions; if your software
       matches the expected behavor, the block of code returns true; otherwise, false.

       This documentation serves as reference documentation for LectroTest Properties.  If you don't understand
       the basics of Properties yet, see "OVERVIEW" in Test::LectroTest::Tutorial before continuing.

   <b>Two</b> <b>ways</b> <b>to</b> <b>create</b> <b>Properties</b>
       There are two ways to create a property:

       1.  Use  the  "Property"  function  to  promote  a  block  of code that contains both a generator-binding
           specification and a behavior test into a Test::LectroTest::Property object.  <b>This</b>  <b>is</b>  <b>the</b>  <b>preferred</b>
           <b>method.</b>  Example:

             my $prop1 = Property {
                 ##[ x &lt;- Int ]##
                 thing_to_test($x) &gt;= 0;
             }, name =&gt; "thing_to_test is non-negative";

       2.  Use  the "new" method of Test::LectroTest::Property and provide it with the necessary ingredients via
           named parameters:

             my $prop2 = Test::LectroTest::Property-&gt;new(
                 inputs =&gt; [ x =&gt; Int ],
                 test   =&gt; sub { my ($tcon,$x) = @_;
                                 thing_to_test($x) &gt;= 0 },
                 name   =&gt; "thing_to_test is non-negative"
             );

       Both are equivalent, but the first is concise, easier to read, and lets LectroTest do some of  the  heavy
       lifting for you.  The second is probably better, however, if you are constructing property specifications
       programmatically.

   <b>Generator-binding</b> <b>specification</b>
       The  generator-binding  specification declares that certain variables are to be bound to certain kinds of
       random-value generators during the tests of your software's behavior.  The number and kind of  generators
       define the "condition space" that is examined during property checks.

       If  you  use the "Property" function to create your properties, your generator-binding specification must
       come first in your code block, and you must use the following syntax:

         ##[ var1 &lt;- gen1, var2 &lt;- gen2, ... ]##

       Comments are not allowed within the specification, but you may break it across multiple lines:

         ##[ var1 &lt;- gen1,
             var2 &lt;- gen2, ...
         ]##

       or

         ##[
             var1 &lt;- gen1,
             var2 &lt;- gen2, ...
         ]##

       Further, for better integration with syntax-highlighting IDEs, the terminating  "]##"  delimiter  may  be
       preceded by a hash symbol "#" and optional whitespace to make it appear like a comment:

         ##[
             var1 &lt;- gen1,
             var2 &lt;- gen2, ...
         # ]##

       On  the other hand, if you use "Test::LectroTest::Property-&gt;new()" to create your objects, the generator-
       binding specification takes the form of an array reference containing variable-generator  pairs  that  is
       passed to "new()" via the parameter named "inputs":

         inputs =&gt; [ var1 =&gt; gen1, var2 =&gt; gen2, ... ]

       Normal Perl syntax applies here.

   <b>Specifying</b> <b>multiple</b> <b>sets</b> <b>of</b> <b>generator</b> <b>bindings</b>
       Sometimes  you  may  want  to repeat a property check with multiple sets of generator bindings.  This can
       happen, for instance, when your condition space is vast and you want to ensure that a particular  portion
       of  it  receives  focused  coverage while still sampling the overall space.  For times like this, you can
       list multiple sets of bindings within the "##[" and "]##" delimiters, like so:

         ##[ var1 &lt;- gen1A, ... ],
           [ var1 &lt;- gen1B, ... ],
           ... more sets of bindings ...
           [ var1 &lt;- gen1N, ... ]##

       Note that only the first and last set need the special delimiters.

       The equivalent when using "new()" is as follows:

         inputs =&gt; [ [ var1 =&gt; gen1A, ... ],
                     [ var1 =&gt; gen1B, ... ],
                     ...
                     [ var1 =&gt; gen1N, ... ] ]

       Regardless of how you declare the sets of bindings, each set must provide bindings for the exact same set
       of variables.  (The generators, of course, can be  different.)   For  example,  this  kind  of  thing  is
       illegal:

         ##[ x &lt;- Int ], [ y &lt;- Int ]##

       The  above  is illegal because both sets of bindings must use <u>x</u> or both must use <u>y</u>; they can't each use a
       different variable.

         ##[ x &lt;- Int             ],
           [ x &lt;- Int, y &lt;- Float ]##

       The above is illegal because the second set has an extra variable that isn't present in the first.   Both
       sets  must  use exactly the same variables.  None of the variables may be extra, none may be missing, and
       all must be named identically across the sets of bindings.

   <b>Behavior</b> <b>test</b>
       The behavior test is a subroutine that accepts  a  test-controller  object  and  a  given  set  of  input
       conditions,  tests  your  software's  observed behavior against the required behavior with respect to the
       input conditions, and returns true or false to indicate acceptance or rejection.  If you  are  using  the
       "Property"  function  to  create  your property objects, lexically bound variables are created and loaded
       with values automatically, per your input-generator specification, so you can just go ahead and  use  the
       variables immediately:

         my $prop = Property {
           ##[ i &lt;- Int, delta &lt;- Float(range=&gt;[0,1]) ]##
           my $lo_val = my_thing_to_test($i);
           my $hi_val = my_thing_to_test($i + $delta);
           $lo_val == $hi_val;
         }, name =&gt; "my_thing_to_test ignores fractions" ;

       On  the other hand, if you are using "Test::LectroTest::Property-&gt;new()", you must declare and initialize
       these variables manually from Perl's @_ variable <u>in</u> <u>lexicographically</u> <u>increasing</u>  <u>order</u>  after  receiving
       $tcon,  the  test  controller  object.   (This  inconvenience,  by  the  way, is why the former method is
       preferred.)  The hard way:

         my $prop = Test::LectroTest::Property-&gt;new(
           inputs =&gt; [ i =&gt; Int, delta =&gt; Float(range=&gt;[0,1]) ],
           test =&gt; sub {
               my ($tcon, $delta, $i) = @_;
               my $lo_val = my_thing_to_test($i);
               my $hi_val = my_thing_to_test($i + $delta);
               $lo_val == $hi_val
           },
           name =&gt; "my_thing_to_test ignores fractions"
         ) ;

   <b>Control</b> <b>logic,</b> <b>retries,</b> <b>and</b> <b>labeling</b>
       Inside the behavior test, you have access to a special variable $tcon that allows you  to  interact  with
       the test controller.  Through $tcon you can do the following:

       •   retry the current trial with different inputs (if you don't like the inputs you were given at first)

       •   add labels to the current trial for reporting purposes

       •   attach notes and variable dumps to the current trial for diagnostic purposes, should the trial fail

       (For   the   full   details  of  what  you  can  do  with  $tcon  see  the  "testcontroller"  section  of
       Test::LectroTest::TestRunner.)

       For example, let's say that we have written a function "my_sqrt" that returns  the  square  root  of  its
       input.  In order to check whether our implementation fulfills the mathematical definition of square root,
       we might specify the following property:

         my $epsilon = 0.000_001;

         Property {
             ##[ x &lt;- Float ]##
             return $tcon-&gt;retry if $x &lt; 0;
             $tcon-&gt;label("less than one") if $x &lt; 1;
             my $sx = my_sqrt( $x );
             abs($sx * $sx - $x) &lt; $epsilon;
         }, name =&gt; "my_sqrt satisfies defn of square root";

       Because  we don't want to deal with imaginary numbers, our square-root function is defined only over non-
       negative numbers.  To make sure we don't accidentally check our property "at" a negative number,  we  use
       the following line to re-start the trial with a different input should the input we are given at first be
       negative:

             return $tcon-&gt;retry if $x &lt; 0;

       An  interesting fact is that for all values <u>x</u> between zero and one, the square root of <u>x</u> is larger than <u>x</u>
       itself.  Perhaps our implementation treats such values as a special case.  In order to be confident  that
       we are checking this case, we added the following line:

             $tcon-&gt;label("less than one") if $x &lt; 1;

       In the property-check output, we can see what percentage of the trials checked this case:

         1..1
         ok 1 - 'my_sqrt satisfies defn of square root' (1000 attempts)
         #   1% less than one

   <b>Trivial</b> <b>cases</b>
       Random-input generators may create some inputs that are trivial and don't provide much testing value.  To
       make it easy to label such cases, you can use the following from within your behavior tests:

           $tcon-&gt;trivial if ... ;

       The above is exactly equivalent to the following:

           $tcon-&gt;label("trivial") if ... ;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Test::LectroTest::Generator  describes  the many generators and generator combinators that you can use to
       define the test or condition spaces that you want LectroTest to search for bugs.

       Test::LectroTest::TestRunner describes the objects that check your properties and tells you how  to  turn
       their control knobs.  You'll want to look here if you're interested in customizing the testing procedure.

</pre><h4><b>HERE</b> <b>BE</b> <b>SOURCE</b> <b>FILTERS</b></h4><pre>
       The   special   syntax   used   to   specify   generator  bindings  relies  upon  a  source  filter  (see
       Filter::Util::Call).  If you don't want to use the syntax, you can disable the filter like so:

           use Test::LectroTest::Property qw( NO_FILTER );

</pre><h4><b>AUTHOR</b></h4><pre>
       Tom Moertel (<a href="mailto:tom@moertel.com">tom@moertel.com</a>)

</pre><h4><b>INSPIRATION</b></h4><pre>
       The LectroTest project was inspired by Haskell's QuickCheck module by  Koen  Claessen  and  John  Hughes:
       <a href="http://www.cs.chalmers.se/~rjmh/QuickCheck/">http://www.cs.chalmers.se/~rjmh/QuickCheck/</a>.

</pre><h4><b>COPYRIGHT</b> <b>and</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 2004-13 by Thomas G Moertel.  All rights reserved.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.34.0                                       2022-06-21                    <u>Test::LectroTest::<a href="../man3pm/Property.3pm.html">Property</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>