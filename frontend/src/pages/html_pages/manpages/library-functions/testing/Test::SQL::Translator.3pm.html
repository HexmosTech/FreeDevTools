<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::SQL::Translator - Test::More test functions for the Schema objects.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsql-translator-perl">libsql-translator-perl_1.66-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::SQL::Translator - Test::More test functions for the Schema objects.

</pre><h4><b>SYNOPSIS</b></h4><pre>
        # t/magic.t

        use FindBin '$Bin';
        use Test::More;
        use Test::SQL::Translator;

        # Run parse
        my $sqlt = SQL::Translator-&gt;new(
            parser =&gt; "Magic",
            filename =&gt; "$Bin/data/magic/test.magic",
            ...
        );
        ...
        my $schema = $sqlt-&gt;schema;

        # Test the table it produced.
        table_ok( $schema-&gt;get_table("Customer"), {
            name =&gt; "Customer",
            fields =&gt; [
                {
                    name =&gt; "CustomerID",
                    data_type =&gt; "INT",
                    size =&gt; 12,
                    default_value =&gt; undef,
                    is_nullable =&gt; 0,
                    is_primary_key =&gt; 1,
                },
                {
                    name =&gt; "bar",
                    data_type =&gt; "VARCHAR",
                    size =&gt; 255,
                    is_nullable =&gt; 0,
                },
            ],
            constraints =&gt; [
                {
                    type =&gt; "PRIMARY KEY",
                    fields =&gt; "CustomerID",
                },
            ],
            indices =&gt; [
                {
                    name =&gt; "barindex",
                    fields =&gt; ["bar"],
                },
            ],
        });

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Provides a set of Test::More tests for Schema objects. Testing a parsed schema is then as easy as writing
       a perl data structure describing how you expect the schema to look. Also provides "maybe_plan" for
       conditionally running tests based on their dependencies.

       The data structures given to the test subs don't have to include all the possible values, only the ones
       you expect to have changed. Any left out will be tested to make sure they are still at their default
       value. This is a useful check that you your parser hasn't accidentally set schema values you didn't
       expect it to.

       For an example of the output run the <u>t/16xml-parser.t</u> test.

</pre><h4><b>Tests</b></h4><pre>
       All the tests take a first arg of the schema object to test, followed by a hash ref describing how you
       expect that object to look (you only need give the attributes you expect to have changed from the
       default).  The 3rd arg is an optional test name to prepend to all the generated test names.

   <b>table_ok</b>
   <b>field_ok</b>
   <b>constraint_ok</b>
   <b>index_ok</b>
   <b>view_ok</b>
   <b>trigger_ok</b>
   <b>procedure_ok</b>
</pre><h4><b>CONDITIONAL</b> <b>TESTS</b></h4><pre>
       The "maybe_plan" function handles conditionally running an individual test.  It is here to enable running
       the test suite even when dependencies are missing; not having (for example) GraphViz installed should not
       keep the test suite from passing.

       "maybe_plan" takes the number of tests to (maybe) run, and a list of modules on which test execution
       depends:

           maybe_plan(180, 'SQL::Translator::Parser::MySQL');

       If one of "SQL::Translator::Parser::MySQL"'s dependencies does not exist, then the test will be skipped.

       Instead of a number of tests, you can pass "undef" if you're using done_testing(), or 'no_plan' if you
       don't want a plan at all.

</pre><h4><b>EXPORTS</b></h4><pre>
       table_ok, field_ok, constraint_ok, index_ok, view_ok, trigger_ok, procedure_ok, maybe_plan

</pre><h4><b>TODO</b></h4><pre>
       Test the tests!
       Test Count Constants
           Constants  to  give  the number of tests each *_ok sub uses. e.g. How many tests does "field_ok" run?
           Can then use these to set up the test plan easily.

       Test skipping
           As the test subs wrap up lots of tests in one call you can't skip individual tests  only  whole  sets
           e.g. a whole table or field.  We could add "skip_*" items to the test hashes to allow per test skips.
           e.g.

            skip_is_primary_key =&gt; "Need to fix primary key parsing.",

       yaml test specs
           Maybe  have  the test subs also accept yaml for the test hash ref as it is much nicer for writing big
           data structures. We can then define tests as in input schema file and test yaml file  to  compare  it
           against.

</pre><h4><b>AUTHOR</b></h4><pre>
       Mark D. Addison &lt;<a href="mailto:mark.addison@itn.co.uk">mark.addison@itn.co.uk</a>&gt;, Darren Chamberlain &lt;<a href="mailto:darren@cpan.org">darren@cpan.org</a>&gt;.

       Thanks to Ken Y. Clark for the original table and field test code taken from his mysql test.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), SQL::Translator, SQL::Translator::Schema, Test::More.

perl v5.40.0                                       2024-11-23                         <u>Test::SQL::<a href="../man3pm/Translator.3pm.html">Translator</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>