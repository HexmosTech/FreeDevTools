<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::HTML5::Builder - erect some scaffolding for your documents</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-html5-builder-perl">libhtml-html5-builder-perl_0.004-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::HTML5::Builder - erect some scaffolding for your documents

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use HTML::HTML5::Builder qw[:standard JQUERY];

         open my $fh, '&lt;', 'inline-script.js';

         print html(
           -lang =&gt; 'en',
           head(
             title('Test'),
             Meta(-charset =&gt; 'utf-8'),
           ),
           body(
             h1('Test'),
             p('This is a test.'),
             JQUERY(-version =&gt; '1.6.4'),
             script(-type =&gt; 'text/javascript', $fh),
           ),
         );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module can export function names corresponding to any HTML5 element.

       Each function returns an XML::LibXML::Element with the same name as the function. The arguments to each
       function are processed as a list, and used to set the attributes and contents of that element.

       For each item on the list:

       •   if  it's  an  XML::LibXML::Element,  XML::LibXML::TextNode, XML::LibXML::Comment, or XML::LibXML::PI,
           it's appended as a child of the returned element.

       •   if it's an XML::LibXML::NodeList, each item on the list is  appended  as  a  child  of  the  returned
           element.

       •   if it's an XML::LibXML::Attr, it's set as an attribute on the returned element

       •   if it's an IO::Handle, then it will be slurped and appended to the returned element as a text node.

       •   if  it's  a  scalar  reference, then the returned element is also assigned to it. (This feature is <b>at</b>
           <b>risk</b>.)

       •   if it's a scalar (string) some guesswork is  conducted  to  figure  out  whether  you're  setting  an
           attribute and value, or whether the string should be used as a text node. The presence of a hyphen at
           the start of the string is the main deciding factor.

             p('-class', 'warning', '$LordLucan not found.');

           In  this  example, a paragraph element is returned, with the class attribute set to 'warning' and the
           textual contents '$LordLucan not found.'.

           Sometimes it's necessary to protect values against this guesswork. By passing a hashref, all the keys
           and values are interpreted as setting attributes; by passing an arrayref, all values are  interpreted
           as setting the contents of the element.

             p(['-class'], { warning =&gt; '$LordLucan not found.' });

           In  this  example, a paragraph element is returned, with the warning attribute set to '$LordLucan not
           found.' and the textual contents '-class'.

       •   Anything else is stringified and added as a text node.  This  is  useful  for  things  with  sensible
           stringification defined, such as "DateTime" and "URI" objects, but less so for some other objects, so
           you will sometimes get a warning if warnings are enabled. Warnings can be disabled using:

             no warnings 'HTML::HTML::Builder';

   <b>Exceptional</b> <b>Cases</b>
       The    "html"    function    does    not    return    an    "XML::LibXML::Element",    but    rather    a
       "HTML::HTML5::Builder::Document" object.

       There is special handling for "time" (or "Time"). If the first parameter  passed  to  it  is  a  DateTime
       object,  then  that object is used to set its datetime attribute.  If there are no subsequent parameters,
       then the stringified form of the object is also used to form the content of the &lt;time&gt; element.

       Note that the functions that generate &lt;meta&gt;, &lt;link&gt;, &lt;q&gt;, &lt;time&gt;, &lt;sub&gt;, &lt;s&gt; and &lt;map&gt; HTML elements are
       named Meta(), Link(), Q(), Time(), Sub(), S() and Map() respectively, with an  upper-case  first  letter.
       This is because each of these names corresponds to a built-in perl keyword (except meta, which is used by
       Moose).  The  lower-case  versions of these do exist, and can be exported if you ask for them explicitly.
       The lower-case versions are also available as methods using the object-oriented syntax. (In  fact,  lower
       case and ucfirst versions exist for all HTML elements - they're just not always exportable.)

   <b>General</b> <b>Purpose</b> <b>Functions</b>
       "ELEMENT($tagname, @arguments)"
           If you need to insert an element which doesn't have its own function.

       TEXT($string)
           Produces a text node.

       COMMENT($string)
           Produces an HTML comment.

       CHUNK($string)
           Parses the string as HTML, and produces a list of elements, text nodes and comments.

           This  should  be  a  so-called "balanced chunk". Due to limitations in HTML::HTML5::Parser, this only
           works for body content. Croaks if HTML::HTML5::Parser is not installed.

       XML_CHUNK($string)
           More useful version of "CHUNK", without the restriction on content, but input needs to be a  balanced
           and well-formed XML chunk.

       RAW_CHUNK($string)
           This  allows  you  to include stuff that isn't anything close to valid HTML into the output document,
           such as a PHP block. e.g.

             html(
               head(
                 title('Funny test'),
                 ),
               body(
                 h1('Funny test'),
                 RAW_CHUNK("&lt;p&gt;Here's a fish: &lt;=&gt;&lt;"),
                 ),
               );

           A processing instruction is used to represent this data in the DOM.  HTML::HTML5::Writer  can  detect
           that   processing   instruction   and   use   it  to  output  the  raw  data.  If  you're  not  using
           HTML::HTML5::Writer to serialise the document, then you  may  need  to  post-process  the  serialised
           document.

           With great power comes great responsibility.

   <b>Boiler-Plate</b> <b>Functions</b>
       There are also a number of functions that create lists of multiple HTML elements, for boiler-plate code.

       "JQUERY(-version =&gt; $ver, %options)"
           Link to jQuery at a CDN.

           Other  options  include  <b>-source</b>,  to  indicate where to link to jQuery (currently allowed values are
           "Google", "Microsoft" and "official"); and <b>-min</b>, a  boolean  which  indicates  whether  the  minified
           version should be linked to (true by default).

           Setting  option  <b>-ui</b>  to  true,  also  includes  jQuery  UI.  A version number can be indicated using
           <b>-ui_version</b>. A theme can be included setting <b>-theme</b>. Setting either <b>-ui_version</b> or <b>-theme</b> will  imply
           <b>-ui</b>.

             JQUERY(
               -source     =&gt; 'official',
               -version    =&gt; '1.6.4',
               -ui_version =&gt; '1.8.16',
               -theme      =&gt; 'eggplant',
               );

           If  versions  aren't  provided,  defaults  to the latest versions of the libraries that the author of
           HTML::HTML5::Builder was aware of at the time of publication.  If you choose a version which is known
           to be unavailable at the selected CDN, the function should  automatically  choose  a  slightly  later
           version.

       CREATIVE_COMMONS($licence)
       "CREATIVE_COMMONS(-licence =&gt; $licence, %options)"
           $licence can be one of 'by', 'by-nd', 'by-nc', 'by-sa', 'by-sa-nc', or 'by-sa-nd'.

           Other options supported are:

           •   <b>-url</b> - URL of the thing being licensed (if not the page itself)

           •   <b>-size</b> - 'large' or 'small' for the image

           •   <b>-title</b> - title of the work

           •   <b>-attributionName</b> - name people should use for attribution

           •   <b>-attributionURL</b> - link people should use for attribution

       OPENGRAPH(%data)
           Returns a list of &lt;meta&gt; elements providing Open Graph Protocol data for your page.

             OPENGRAPH(
               -title       =&gt; "Hello World",
               -type        =&gt; "example",
               -description =&gt; "A global greeting.",
               );

   <b>Exporting</b> <b>Functions</b>
       None by default. Pretty much anything can be exported on request.

       Export tags:

       •   ":all" - everything

       •   ":standard"  - elements that are not obsolete in HTML5, plus ELEMENT, TEXT, COMMENT, CHUNK, XML_CHUNK
           and RAW_CHUNK

       •   ":metadata" - head title base Link Meta style

       •   ":sections" - body div section nav article aside h1 h2 h3 h4 h5 h6 header footer address

       •   ":grouping" - p hr br pre dialog blockquote ol ul li dl dt dd

       •   ":text" - a Q cite em strong small mark dfn abbr progress meter code var samp kbd Sub sup  span  i  b
           bdo ruby rt rp Time

       •   ":embedded" - figure img iframe embed object param video audio source canvas area

       •   ":tabular" - table thead tbody tfoot th td colgroup col caption

       •   ":form" - form fieldset label input button select datalist optgroup option textarea output

   <b>Object</b> <b>Oriented</b> <b>Interface</b>
       You can also use these functions as methods of an object blessed into the HTML::HTML5::Builder package.

         my $b = HTML::HTML5::Builder-&gt;new;
         my $document = $b-&gt;html(
           -lang =&gt; 'en',
           $b-&gt;head(
             $b-&gt;title('Test', \(my $foo)),
             $b-&gt;meta(-charset =&gt; 'utf-8'),
           ),
           $b-&gt;body(
             $b-&gt;h1('Test'),
             $b-&gt;p('This is a test.')
           ),
         );

   <b>Using</b> <b>with</b> <b>RDF::RDFa::Generator</b>
       RDF::RDFa::Generator has a "nodes" method which returns a handy list of "XML::LibXML::Node" objects.

         use DateTime;
         use HTML::HTML5::Builder qw[:standard];
         use RDF::RDFa::Generator;
         use RDF::Trine;

         my $url   = '<a href="http://dbpedia.org/data/Charles_Darwin">http://dbpedia.org/data/Charles_Darwin</a>';
         my $model = RDF::Trine::Model-&gt;new;
         RDF::Trine::Parser-&gt;parse_url_into_model($url, $model);

         my $gen = RDF::RDFa::Generator-&gt;new(style=&gt;'HTML::Pretty');

         print html(
           head(
             title("Some Data About Charles Darwin"),
             ),
           body(
             h1("Some Data About Charles Darwin"),
             $gen-&gt;nodes($model),
             hr(),
             address(
               "Source: $url", br(),
               "Generated: ", Time(DateTime-&gt;now),
               ),
             ),
           );

       Nice?

   <b>Using</b> <b>with</b> <b>XML::LibXML::PrettyPrint</b>
       HTML::HTML5::Builder doesn't nicely indent your markup, but XML::LibXML::PrettyPrint can.

         use HTML::HTML5::Builder qw(:standard);
         use XML::LibXML::PrettyPrint qw(print_xml);
         print_xml html(
           head(title("Test")),
           body(h1("Test"), p("This is a test.")),
           );

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs to &lt;<a href="http://rt.cpan.org/Dist/Display.html">http://rt.cpan.org/Dist/Display.html</a>?Queue=HTML-HTML5-Builder&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       XML::LibXML, HTML::HTML5::Writer, HTML::HTML5::Builder::Document.

</pre><h4><b>AUTHOR</b></h4><pre>
       Toby Inkster &lt;<a href="mailto:tobyink@cpan.org">tobyink@cpan.org</a>&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2011 by Toby Inkster.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTIES</b></h4><pre>
       THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  WITHOUT
       LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

perl v5.38.2                                       2024-03-05                          <u>HTML::HTML5::<a href="../man3pm/Builder.3pm.html">Builder</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>