<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POE::Queue - a flexible, generic priority queue API</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpoe-perl">libpoe-perl_1.3700-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       POE::Queue - a flexible, generic priority queue API

</pre><h4><b>SYNOPSIS</b></h4><pre>
       POE::Queue specifies additional methods not illustrated here.

         #!perl

         use warnings;
         use strict;
         use POE::Queue::Array;

         my $pqa = POE::Queue::Array-&gt;new();

         # Enqueue a few items.

         foreach my $priority (505, 404, 303, 202, 101) {
           $pqa-&gt;enqueue($priority, "payload $priority");
         }

         # Dequeue until the queue is drained.

         while (1) {
           my ($priority, $queue_id, $payload) = $pqa-&gt;dequeue_next();
           last unless defined $priority;

           print(
             "dequeued id($queue_id) ",
             "priority($priority) ",
             "payload($payload)\n",
           );
         }

       Sample output:

         dequeued <a href="../man5/id.5.html">id</a>(5) <a href="../man101/priority.101.html">priority</a>(101) payload(payload 101)
         dequeued <a href="../man4/id.4.html">id</a>(4) <a href="../man202/priority.202.html">priority</a>(202) payload(payload 202)
         dequeued <a href="../man3/id.3.html">id</a>(3) <a href="../man303/priority.303.html">priority</a>(303) payload(payload 303)
         dequeued <a href="../man2/id.2.html">id</a>(2) <a href="../man404/priority.404.html">priority</a>(404) payload(payload 404)
         dequeued <a href="../man1/id.1.html">id</a>(1) <a href="../man505/priority.505.html">priority</a>(505) payload(payload 505)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Priority queues may be implemented a number of ways, but they tend to behave similar to lists that are
       kept in order by some kind of "priority".  Enqueued items are stored such that the "next" item to be
       retrieved is the one with the highest priority.  Subsequent fetches return the next lowest priority, and
       so on, until the queue is emptied.

       Priority queues (also known as priority heaps) attempt to do this while consuming the fewest resources.
       Go read about it!  It's fascinating stuff!

   <b>POE::Queue</b> <b>Items</b>
       POE::Queue items consist of three fields: A priority, a unique ID assigned at enqueue time, and a
       payload.  The priority and payload are specified by the caller, and the unique ID is generated by
       POE::Queue when an item is enqueued.

       POE::Queue imposes two limitations on priorities: Priorities must be numeric, and lower numbers indicate
       higher priorities.  Aside from that, POE::Queue doesn't care what the numbers mean.

       Unique IDs are handles into the queue.  POE::Queue generates and returns them as new items are enqueued.
       Some methods manipulate items, and they take IDs to identify the items to alter.

       Item payloads are arbitrary application data.  POE::Queue does not examine or alter payloads itself.  Any
       methods that need to examine payloads will accept a filter function. Filter functions examine payloads so
       POE::Queue need not.

</pre><h4><b>Public</b> <b>Methods</b></h4><pre>
       POE::Queue is an API specification.  Subclasses like POE::Queue::Array provide actual implementations.

   <b>new</b>
       Creates a new priority queue.  Returns a reference to the queue.

         my $queue = POE::Queue::Array-&gt;new();

   <b>enqueue</b> <b>PRIORITY,</b> <b>PAYLOAD</b>
       Enqueues a PAYLOAD, which can be just about anything that will fit into a Perl scalar, at a particular
       PRIORITY level.  <b>enqueue()</b> returns a unique ID which can be used to manipulate the payload or its
       priority directly.

       Following the UNIX tradition, lower priority numbers indicate higher priorities.  The payload with the
       lowest priority number will be dequeued first.  If two payloads have the same PRIORITY, then they will be
       dequeued in the order in which they were enqueued.

       In this example, a queue is used to manage a number of alarms.  The "next" alarm will be the one due
       soonest.

         my $payload_id = $queue-&gt;enqueue($alarm_time, [ "stuff" ]);

   <b>dequeue_next</b>
       Removes the next item from the queue, returning it as three fields: priority, ID and payload.

       The "next" item is the one with the lowest priority number.  If multiple items exist with the same
       priority, <b>dequeue_next()</b> will return the one that was given the priority first.

         ITEM: while (1) {
           my ($priority, $id, $payload) = $queue-&gt;dequeue_next();
           last ITEM unless defined $priority;
           ...;
         }

   <b>get_next_priority</b>
       Returns the priority of the item at the head of the queue.  This is the lowest numeric priority in the
       queue.

       <b>get_next_priority()</b> can be useful for checking the queue to see if it's time to dequeue some items.  In
       this case, the queue manages multiple alarms, and there's nothing to do if the next alarm isn't due yet.

         ALARM: while (1) {
           my $next_alarm_time = $queue-&gt;get_next_priority();
           last ALARM unless defined $next_alarm_time;

           if ($next_alarm_time - time() &gt; 0) {
             sleep($next_alarm_time - time());
           }

           my ($priority, $id, $payload) = $queue-&gt;dequeue_next();
           ...;
         }

   <b>get_item_count</b>
       Returns the number of items in the queue.  It's another way to tell whether the queue has been fully
       drained.  Here's an alternative version of the example for <b>get_next_priority()</b>.

         ALARM: while ($queue-&gt;get_item_count()) {
           my $next_alarm_time = $queue-&gt;get_next_priority();
           if ($next_alarm_time - time() &gt; 0) {
             sleep($next_alarm_time - time());
           }

           my ($priority, $id, $payload) = $queue-&gt;dequeue_next();
           ...;
         }

   <b>remove_item</b> <b>ITEM_ID,</b> <b>FILTER_FUNCTION</b>
       Removes a single item by its ID, but only if a FILTER_FUNCTION approves of the item's payload.

       If a payload is found with the given ITEM_ID, it is passed to FILTER_FUNCTION for examination.  If
       FILTER_FUNCTION returns true, the item is removed from the queue and is returned as three fields.

         my ($priority, $id, $payload) = $queue-&gt;remove_item(
           $target_id, \&amp;monkeys
         );

         sub monkeys {
           my $payload = shift;
           $payload-&gt;{type} eq "monkey";
         }

       The returned $priority will be undef on failure, and $! will be set to the reason why the item couldn't
       be removed.  That will be ESRCH if the ITEM_ID was not found in the queue, or EPERM if the filter
       function returned false.

   <b>remove_items</b> <b>FILTER_FUNCTION</b> <b>[,</b> <b>MAX_ITEM_COUNT</b> <b>]</b>
       Removes and returns items from the queue that match a FILTER_FUNCTION.  <b>remove_items()</b> will return
       immediately if MAX_ITEM_COUNT items is specified and that many items have been removed from the queue.
       MAX_ITEM_COUNT is a bit of optimization if the application knows in advance how many items will match the
       FILTER_FUNCTION.

       Returns a list of items that were removed.  Each item is an array reference containing a priority, item
       ID, and payload.  Returns nothing if FILTER_FUNCTION matched nothing.

         # Remove up to 12 monkeys.
         my @monkeys = $queue-&gt;remove_items(\&amp;monkeys, 12);
         foreach my $monkey (@monkeys) {
           my ($priority, $id, $payload) = @$monkey;
           print(
             "Removed monkey:\n",
             "  priority = $priority\n",
             "  queue id = $id\n",
             "  payload  = $payload\n",
           );
         }

       There is no guarantee which items will be removed if MAX_ITEM_COUNT is specified too low.

   <b>peek_items</b> <b>FILTER_FUNCTION</b> <b>[,</b> <b>MAX_ITEM_COUNT</b> <b>]</b>
       <b>peek_items()</b> returns up to MAX_ITEM_COUNT items that match a given FILTER_FUNCTION without removing them
       from the queue.

         my @entire_queue = $queue-&gt;peek_items(sub { 1 });
         foreach my $item (@entire_queue) {
           my ($priority, $id, $payload) = @$item;
           print(
             "Item:\n",
             "  priority = $priority\n",
             "  queue id = $id\n",
             "  payload  = $payload\n",
           );
         }

   <b>adjust_priority</b> <b>ITEM_ID,</b> <b>FILTER_FUNCTION,</b> <b>DELTA</b>
       Changes the priority of an item by DELTA.  The item is identified by its ITEM_ID, and the change will
       only happen if the item's payload satisfies a FILTER_FUNCTION.  Returns the new priority, which is the
       previous priority + DELTA.  DELTA may be negative.

         my $new_priority = $queue-&gt;adjust_priority(
           $item_id, \&amp;one_of_mine, 100
         );

         sub one_of_mine {
           my $payload = shift;
           return $payload-&gt;{owner} == $me;
         }

       Returns undef if the item's priority could not be adjusted, and sets $! to explain why: ESRCH means that
       the ITEM_ID could not be found, and EPERM means that the FILTER_FUNCTION was not satisfied.

   <b>set_priority</b> <b>ITEM_ID,</b> <b>FILTER_FUNCTION,</b> <b>ABSOLUTE_PRIORITY</b>
       Sets an item's priority to a new ABSOLUTE_PRIORITY.  The item is identified by its ITEM_ID, and the
       change will only be allowed to happen if the item's payload satisfies a FILTER_FUNCTION.  Returns the new
       priority, which should match ABSOLUTE_PRIORITY.

       Returns undef if the item's priority could not be set, and sets $! to explain why: ESRCH means that the
       ITEM_ID could not be found, and EPERM means that the FILTER_FUNCTION was not satisfied.

         my $new_priority = $queue-&gt;set_priority(
           $item_id, \&amp;one_of_mine, time() + 60
         );

         unless (defined $new_priority) {
           die "one of our submarines is missing: $item_id" if $! == ESRCH;
           die "set_priority disallowed for item $item_id" if $! == EPERM;
           die $!;
         }

         sub one_of_mine {
           $_[0]{owner} == $me;
         }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       POE, POE::Queue::Array

</pre><h4><b>BUGS</b></h4><pre>
       None known.

</pre><h4><b>AUTHORS</b> <b>&amp;</b> <b>COPYRIGHTS</b></h4><pre>
       Please see POE for more information about authors, contributors, and POE's licensing.

perl v5.34.0                                       2022-03-25                                    <u>POE::<a href="../man3pm/Queue.3pm.html">Queue</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>