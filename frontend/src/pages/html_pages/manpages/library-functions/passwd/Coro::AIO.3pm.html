<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coro::AIO - truly asynchronous file and directory I/O</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcoro-perl">libcoro-perl_6.570-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Coro::AIO - truly asynchronous file and directory I/O

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use Coro::AIO;

          # can now use any of the aio requests your IO::AIO module supports.

          # read 1MB of <a href="file:/etc/passwd">/etc/passwd</a>, without blocking other coroutines
          my $fh = aio_open "<a href="file:/etc/passwd">/etc/passwd</a>", O_RDONLY, 0
             or die "<a href="file:/etc/passwd">/etc/passwd</a>: $!";
          aio_read $fh, 0, 1_000_000, my $buf, 0
             or die "aio_read: $!";
          aio_close $fh;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is an AnyEvent user, you need to make sure that you use and run a supported event loop.

       This module implements a thin wrapper around IO::AIO. All of the functions that expect a callback are
       being wrapped by this module.

       The API is exactly the same as that of the corresponding IO::AIO routines, except that you have to
       specify <u>all</u> arguments, even the ones optional in IO::AIO, <u>except</u> the callback argument. Instead of
       calling a callback, the routines return the values normally passed to the callback. Everything else,
       including $! and perls stat cache, are set as expected after these functions return.

       You can mix calls to "IO::AIO" functions with calls to this module. You <u>must</u> <u>not</u>, however, call these
       routines from within IO::AIO callbacks, as this causes a deadlock. Start a coro inside the callback
       instead.

       This module also loads AnyEvent::AIO to integrate into the event loop in use, so please refer to its (and
       AnyEvent's) documentation on how it selects an appropriate event module.

       All other functions exported by default by IO::AIO (e.g. "aioreq_pri") will be exported by default by
       Coro::AIO, too.

       Functions that can be optionally imported from IO::AIO can be imported from Coro::AIO or can be called
       directly, e.g. "Coro::AIO::nreqs".

       You cannot specify priorities with "aioreq_pri" if your coroutine has a non-zero priority, as this module
       overwrites the request priority with the current coroutine priority in that case.

       For your convenience, here are the changed function signatures for most of the requests, for
       documentation of these functions please have a look at IO::AIO. Note that requests added by newer
       versions of IO::AIO will be automatically wrapped as well.

       @results = aio_wait $req
           This  is not originally an IO::AIO request: what it does is to wait for $req to finish and return the
           results. This is most useful with "aio_group" requests.

           Is currently implemented by replacing the $req callback (and is  very  much  like  a  wrapper  around
           "$req-&gt;cb ()").

       $fh = aio_open $pathname, $flags, $mode
       $status = aio_close $fh
       $retval = aio_read  $fh,$offset,$length, $data,$dataoffset
       $retval = aio_write $fh,$offset,$length, $data,$dataoffset
       $retval = aio_sendfile $out_fh, $in_fh, $in_offset, $length
       $retval = aio_readahead $fh,$offset,$length
       $status = aio_stat $fh_or_path
       $status = aio_lstat $fh
       $status = aio_unlink $pathname
       $status = aio_rmdir $pathname
       $entries = aio_readdir $pathname
       ($dirs, $nondirs) = aio_scandir $path, $maxreq
       $status = aio_fsync $fh
       $status = aio_fdatasync $fh
       ... = aio_xxx ...
           Any  additional  aio  requests  follow the same scheme: same parameters except you must not specify a
           callback but instead get the callback arguments as return values.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Coro::Socket and Coro::Handle for non-blocking socket operation.

</pre><h4><b>AUTHOR/SUPPORT/CONTACT</b></h4><pre>
          Marc A. Lehmann &lt;<a href="mailto:schmorp@schmorp.de">schmorp@schmorp.de</a>&gt;
          <a href="http://software.schmorp.de/pkg/Coro.html">http://software.schmorp.de/pkg/Coro.html</a>

perl v5.40.1                                       2025-03-21                                           <u><a href="../man3pm/AIO.3pm.html">AIO</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>