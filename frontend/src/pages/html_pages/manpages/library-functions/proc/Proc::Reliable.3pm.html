<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proc::Reliable -- Run external processes reliably with many options.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libproc-reliable-perl">libproc-reliable-perl_1.16-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Proc::Reliable -- Run external processes reliably with many options.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       use Proc::Reliable;

       Create a new process object

          $myproc = Proc::Reliable-&gt;new();

       Run a subprocess and collect its output

          $output = $myproc-&gt;run("<a href="file:/bin/ls">/bin/ls</a> -l");

       Check for problems

          if($myproc-&gt;status()) {
            print("problem!\n");
          }

       Run another subprocess, keeping stdout and stderr separated.  Also, send the subprocess some data on
       stdin.

          $msg = "Hello World\n");
          $p-&gt;<a href="../man0/want_single_list.0.html">want_single_list</a>(0);
          $stdout = $p-&gt;run("/usr/bin/fastmail - <a href="mailto:foo@bar.com">foo@bar.com</a>", $msg);
          if($p-&gt;status()) {
            print("problem: ", $p-&gt;stderr(), "\n");
          }

       Another way to get output

          ($stdout, $stderr, $status, $msg) = $p-&gt;run("<a href="file:/bin/ls">/bin/ls</a> -l");

</pre><h4><b>OPTIONS</b></h4><pre>
       Run Modes

        $p-&gt;run("shell-command-line");  # Launch a shell process
        $p-&gt;run("cmdline", "data");     # Launch a shell process with stdin data
        $p-&gt;run(["cmd", "arg1", ...]);  # Bypass shell processing of arguments
        $p-&gt;run(sub { ... });           # Launch a perl subroutine
        $p-&gt;run(\&amp;subroutine);          # Launch a perl subroutine

       Option settings below represent defaults

        $p-&gt;<a href="../man1/num_tries.1.html">num_tries</a>(1);           # execute the program only once
        $p-&gt;<a href="../man60/time_per_try.60.html">time_per_try</a>(60);       # time per try 60 sec
        $p-&gt;<a href="../man60/maxtime.60.html">maxtime</a>(60);            # set overall timeout
        $p-&gt;<a href="../man5/time_btw_tries.5.html">time_btw_tries</a>(5);      # time between tries 5 sec
        $p-&gt;want_single_list();     # return STDOUT and STDERR together
        $p-&gt;accept_no_error();      # Re-try if any STDERR output
        $p-&gt;pattern_stdout($pat);   # require STDOUT to match regex $pat
        $p-&gt;pattern_stderr($pat);   # require STDERR to match regex $pat
        $p-&gt;<a href="../man1/allow_shell.1.html">allow_shell</a>(1);         # allowed to use shell for operation
        $p-&gt;child_exit_time(1.0);   # timeout for child to exit after it closes stdout
        $p-&gt;sigterm_exit_time(0.5); # timeout for child to exit after sigterm
        $p-&gt;sigkill_exit_time(0.5); # timeout for child to exit after sigkill
        $p-&gt;<a href="../man0/input_chunking.0.html">input_chunking</a>(0);      # feed stdin data line-by-line to subprocess
        $p-&gt;<a href="../man0/stdin_error_ok.0.html">stdin_error_ok</a>(0);      # ok if child exits without reading all stdin
        $p-&gt;stdout_cb(undef);       # callback function for line-by-line stdout
        $p-&gt;stderr_cb(undef);       # callback function for line-by-line stderr

       Getting output

        $out = $p-&gt;stdout();        # stdout produced by last run()
        $err = $p-&gt;stderr();        # stderr produced by last run()
        $stat = $p-&gt;status();       # exit code produced by last run()
        $msg = $p-&gt;msg();           # module messages produced by last run()

       Debug

       Proc::Reliable::debug($level);         # Turn debug on

</pre><h4><b>OVERVIEW</b></h4><pre>
       Proc::Reliable is a class for simple, reliable and configurable subprocess execution in perl.  In
       particular, it is especially useful for managing the execution of 'problem' programs which are likely to
       fail, hang, or otherwise behave in an unruly manner.

       Proc::Reliable includes all the functionality of the backticks operator and <b>system()</b> functions, plus many
       common uses of <b>fork()</b> and <b>exec()</b>, <b>open2()</b> and <b>open3()</b>.  Proc::Reliable incorporates a number of options,
       including sending data to the subprocess on STDIN, collecting STDOUT and STDERR separately or together,
       killing hung processes, timouts and automatic retries.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A new process object is created by

          $myproc = Proc::Reliable-&gt;new();

       The default will run a subprocess only once with a 60-second timeout.  Either shell-like command lines or
       references to perl subroutines can be specified for launching a process in background.  A simple list
       process, for example, can be started via the shell as

          $out = $myproc-&gt;run("ls");

       To separate stdout, stderr, and exit status:

          ($out, $err, $status, $msg) = $myproc-&gt;run("ls");

       The output data is also stored within the $myproc object for later retrieval.  You can also run a perl
       subroutine in a subprocess, with

          $myproc-&gt;run(sub { return &lt;*&gt;; });

       The <u>run</u> Method will try to run the named process.  If the process times out (after <u>time_per_try</u> seconds)
       or has an error defined as unacceptable and you would like to re-run it, you can use the <u>num_tries</u>
       option.  Use the <u>time_btw_tries</u> option to set the number of seconds between runs.  This can repeat until
       <u>maxtime</u> seconds have elapsed.

       When using <u>num_tries</u>, the user can specify what constitutes an unacceptable error of STDOUT or STDERR
       output -- i.e. demanding a retry.  One common shorthand is to have the <u>run</u> method retry if there is any
       return from STDERR.

          $myproc-&gt;accept_no_error();    # Re-try if any STDERR
          $myproc-&gt;pattern_stdout($pat); # require STDOUT to match regex $pat
          $myproc-&gt;pattern_stderr($pat); # require STDERR to match regex $pat

       Subprocess completion is detected when the process closes all filehandles.  The process must then exit
       before child_exit_time expires, or it will be killed.  If the subprocess does not exit, it is sent a TERM
       signal unless sigterm_exit_time is 0.  then if it does not exit before sigterm_exit_time expires, it is
       sent a KILL signal unless sigkill_exit_time is 0.  then if it does not exit before sigkill_exit_time
       expires an error is generated.  waiting is done in 0.01 second increments.

       Proc::Reliable is not MT-Safe due to signals usage.

</pre><h4><b>METHODS</b></h4><pre>
       The following methods are available:

       new (Constructor)
           Create a new instance of this class by writing either

               $proc = new Proc::Reliable;   or   $proc = Proc::Reliable-&gt;new();

           The <u>new</u> method accepts any valid configuration options:

               $proc = Proc::Reliable-&gt;new('maxtime' =&gt; 200, 'num_tries' =&gt; 3);

       run Run a new process and collect the standard output and standard error via separate pipes.

             $out = $proc-&gt;run("program-name");
            ($out, $err, $status, $msg) = $proc-&gt;run("program-name");

           by  default  with  a  single  return  value,  stdout  and  stderr are combined to a single stream and
           returned.  with 4 return values, stdout and stderr are separated, and the program exit status is also
           returned.  $msg contains messages from Proc::Reliable when errors occur.  Set <b><a href="../man1/want_single_list.1.html">want_single_list</a></b>(1)  to
           force stdout and stderr to be combined, and <b><a href="../man0/want_single_list.0.html">want_single_list</a></b>(0) to force them separated.  The results
           from <b>run()</b> are stored as member data also:

             $proc-&gt;<a href="../man0/want_single_list.0.html">want_single_list</a>(0);
             $proc-&gt;run("program");
             if($proc-&gt;status) {
               print($proc-&gt;stderr);
               exit;
             }
             else {
               print($proc-&gt;stdout);
             }

           Program  exit  status is returned in the same format as <b>exec()</b>: bits 0-7 set if program exited from a
           signal, bits 8-15 are the exit status on a normal program exit.

           You can also set up callbacks to run a function of your choice as each line of stdout and  stderr  is
           produced by the child process using the stdout_cb and stderr_cb options.

           There are a number of other options.  You can also feed the forked program data on stdin via a second
           argument to <b>run()</b>:

            $myinput = "hello\ntest\n";
            $output = $proc-&gt;run("program-name", $myinput);

           The first option to <b>run()</b> supports three forms: 1) string containing command string to execute.  this
           incurs  shell  parsing.  2) arrayref containing split command string to execute.  this bypasses shell
           parsing.  3) coderef to perl function.  The first  two  options  are  executed  via  <b>exec()</b>,  so  the
           specifics of incurring shell parsing are the same.

           The  second  option  to  <b>run()</b>  supports  two  forms:  1)  string containing data to feed on stdin 2)
           stringref pointing to data to feed on stdin

           You can start execution of an independent Perl function (like "eval" except  with  timeout,  retries,
           etc.).  Simply provide the function reference like

            $output = $proc-&gt;run(\&amp;perl_function);

           or supply an unnamed subroutine:

            $output = $proc-&gt;run( sub { <a href="../man1/sleep.1.html">sleep</a>(1) } );

           The <u>run</u> Method returns after the the function finishes, one way or another.

       debug
           Switches    debug   messages   on   and   off   --   <b>Proc::Reliable::<a href="../man1/debug.1.html">debug</a></b>(1)   switches   them   on,
           <b>Proc::Reliable::<a href="../man0/debug.0.html">debug</a></b>(0) keeps Proc::Reliable quiet.

       maxtime
           Return or set the maximum time in seconds per <u>run</u> method  call.   Default  is  300  seconds  (i.e.  5
           minutes).

       num_tries
           Return  or  set  the  maximum  number  of tries the <u>run</u> method will attempt an operation if there are
           unallowed errors.  Default is 5.

       time_per_try
           Return or set the maximum time in seconds for each attempt which <u>run</u> makes of an operation.  Multiple
           tries in case of error can go longer than this.  Default is 30 seconds.

       time_btw_tries
           Return or set the time in seconds  between  attempted  operations  in  case  of  unacceptable  error.
           Default is 5 seconds.

       child_exit_time
           When  the subprocess closes stdout, it is assumed to have completed normal operation.  It is expected
           to exit within the amount of time specified.  If it does not exit, it will be killed (with  SIGTERM).
           This option can be disabled by setting to '0'.  Values are in seconds, with a resolution of 0.01.

       sigterm_exit_time
           If  the  <u>time_per_try</u>  or <u>max_time</u> has been exceeded, or if <u>child_exit_time</u> action has not succeeded,
           the subprocess will be killed with SIGTERM.  This option specifies the amount of time  to  allow  the
           process  to exit after closing stdout.  This option can be disabled by setting to '0'.  Values are in
           seconds, with a resolution of 0.01.

       sigkill_exit_time
           Similar to <u>sigterm_exit_time</u>, but a SIGKILL is sent instead of a  SIGTERM.   When  both  options  are
           enabled,  the  SIGTERM  is  sent  first and SIGKILL is then sent after the specified time only if the
           subprocess is still alive.  This option can be disabled by setting to '0'.  Values  are  in  seconds,
           with a resolution of 0.01.

       input_chunking
           If data is being written to the subprocess on stdin, this option will cause the module to <b>split()</b> the
           input  data at linefeeds, and only feed the subprocess a line at a time.  This option typically would
           be used when the subprocess is an application with a command prompt and does not work  properly  when
           all the data is fed on stdin at once.  The module will feed the subprocess one line of data on stdin,
           and  will  then wait until some data is produced by the subprocess on stdout or stderr.  It will then
           feed the next line of data on stdin.

       stdout_cb
           Set up a callback function to get stdout data from the child line-by-line.  The function  you  supply
           will be called whenever the child prints a line onto stdout.  This is the only way to get output from
           the child while it is still running, the normal method will give you all the output at once after the
           child exits.

       stderr_cb
           Similar to stdout_cb for stderr data.

</pre><h4><b>REQUIREMENTS</b></h4><pre>
       I recommend using at least perl 5.003.

</pre><h4><b>AUTHORS</b></h4><pre>
       Proc::Reliable by Dan Goldwater &lt;dgold at zblob dot com&gt;

       Based on Proc::Short, written by John Hanju Kim &lt;<a href="mailto:jhkim@fnal.gov">jhkim@fnal.gov</a>&gt;.

       Contributions by Stephen Cope and Jason Robertson.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright  2001  by  Dan  Goldwater,  all  rights reserved.  Copyright 1999 by John Hanju Kim, all rights
       reserved.

       This program is free software, you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2022-10-22                                      <u><a href="../man3pm/Reliable.3pm.html">Reliable</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>