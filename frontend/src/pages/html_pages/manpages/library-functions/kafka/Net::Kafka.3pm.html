<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::Kafka - High-performant Perl client for Apache Kafka</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-kafka-perl">libnet-kafka-perl_1.06-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::Kafka - High-performant Perl client for Apache Kafka

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Net::Kafka::Producer;
           use Net::Kafka::Consumer;
           use AnyEvent;

           # Produce 1 message into "my_topic"
           my $condvar     = AnyEvent-&gt;condvar;
           my $producer    = Net::Kafka::Producer-&gt;new(
               'bootstrap.servers' =&gt; 'localhost:9092'
           );
           $producer-&gt;produce(
               payload =&gt; "message",
               topic   =&gt; "my_topic"
           )-&gt;then(sub {
               my $delivery_report = shift;
               $condvar-&gt;send;
               print "Message successfully delivered with offset " . $delivery_report-&gt;{offset};
           }, sub {
               my $error = shift;
               $condvar-&gt;send;
               die "Unable to produce a message: " . $error-&gt;{error} . ", code: " . $error-&gt;{code};
           });
           $condvar-&gt;recv;

           # Consume message from "my_topic"
           my $consumer    = Net::Kafka::Consumer-&gt;new(
               'bootstrap.servers'     =&gt; 'localhost:9092',
               'group.id'              =&gt; 'my_consumer_group',
               'enable.auto.commit'    =&gt; 'true',
           );

           $consumer-&gt;subscribe( [ "my_topic" ] );
           while (1) {
               my $msg = $kafka-&gt;<a href="../man1000/consumer_poll.1000.html">consumer_poll</a>(1000);
               if ($msg) {
                   if ( $msg-&gt;err ) {
                       say "Error: ", Net::Kafka::Error::to_string($err);
                   }
                   else {
                       say $msg-&gt;payload;
                   }
               }
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides Perl bindings to librdkafka &lt;https://github.com/edenhill/librdkafka&gt; C client
       library.  It is heavily inspired by Kafka::Librd module originally developed by Pavel Shaydo.

       Please refer to the following modules documentation in order to understand how to use it:

       •   "Net::Kafka::Producer" - asynchronous producer interface

       •   "Net::Kafka::Consumer" - consumer interface that supports both Simple and Distributed modes

</pre><h4><b>REQUIREMENTS</b></h4><pre>
       •   GNU make

       •   librdkafka &gt;= 1.0.0

</pre><h4><b>INSTALLATION</b></h4><pre>
       First install librdkafka (&lt;https://github.com/edenhill/librdkafka#installation&gt;).

   <b>BUILD</b> <b>FROM</b> <b>CPAN</b>
           cpanm install Net::Kafka

   <b>BUILD</b> <b>FROM</b> <b>SOURCE</b>
       Sources are available on Github: &lt;https://github.com/bookingcom/perl-Net-Kafka&gt;.

           perl Makefile.pl
           make
           make test
           make install

</pre><h4><b>Net::Kafka::Producer</b></h4><pre>
       The  Net::Kafka::Producer  module provides interface to librdkafka's producer methods. It utilizes signal
       pipes, AnyEvent watcher and AnyEvent::XSPromises to make its behaviour  asynchronous.  Taking  that  into
       consideration  you need to make sure to properly create condvar and "send"/"recv" in order to collect all
       outstanding  promises.   It  is  highly  suggested  to  familirize  yourself  with  both   AnyEvent   and
       AnyEvent::XSPromises modules. See "SYNOPSIS" for example.

   <b>METHODS</b>
       <b>new()</b>
               my $producer = Net::Kafka::Producer-&gt;new(
                   'bootstrap.servers' =&gt; 'localhost:9092'
               );

           Create  an  instance  of  Net::Kafka::Producer. Accept hash where keys are equal to property names of
           librdkafka (see  &lt;https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md&gt;).   Note  that
           only  "error_cb"  and  "stats_cb"  callbacks are supported for Producer. Message delivery reports are
           served automatically through "Promise" based "produce" method (see below).

       <b>produce()</b>
               my $promise = $producer-&gt;produce(
                   payload     =&gt; "my_message",
                   topic       =&gt; "my_topic",
                   key         =&gt; "my_key",    # optional
                   timestamp   =&gt; 1234567,   # optional, if not specified current local timestamp will be used
                   partition   =&gt; 0          # optional, if not specified internal librdkafka partitioner will be used
                   headers     =&gt; $headers,  # Optional, see Net::Kafka::Headers
               )-&gt;then(sub {
                   my $delivery_report = shift;
                   print "Message is sent with offset " . $delivery_report-&gt;{offset};
               })-&gt;catch(sub {
                   my $error = shift;
                   print $error-&gt;{error} . "\n";
               });

           Sends a message to Kafka. Accepts hash with parameters.

           Returns back an instance of "Promise" that will  be  resolved/rejected  later.  In  case  message  is
           successfully  send  "resolve"  callback  will  receive a delievry report in the form of the hash that
           contains "offset", "partition" and "timestamp". If message delivery has failed "reject" callback will
           receive a  hash  that  contains  "error"  (a  human  readable  error  description)  and  (optionally)
           "error_code"  that  is  equal  to librdkafka's error code. All error codes are mapped and exported by
           "Net::Kafka"  module  as  constants  (e.g.   "Net::Kafka::RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS")   for
           simplicity.

       <b>partitions_for()</b>
               my $partitions = $producer-&gt;partitions_for("my_topic", $timeout_ms);

           Returns  an  "ARRAYREF"  that  contains partition metadata information about the given topic (leader,
           replicas, ISR replicas);

       <b>close()</b>
               $producer-&gt;close();

           Explicitly closees "Net::Kafka::Producer" instance and underlying librdkafka handles.

</pre><h4><b>Net::Kafka::Consumer</b></h4><pre>
       The Net::Kafka::Consumer class provides interface to librdkafka's  consumer  functionality.  It  supports
       both "distributed" (subscription based) and "simple" (manual partition assignment) modes of work.

   <b>METHODS</b>
       <b>new()</b>
               my $consumer = Net::Kafka::Consumer-&gt;new(
                   'bootstrap.servers'  =&gt; 'localhost:9092',
                   'group.id'           =&gt; "my_consumer_group",
                   'enable.auto.commit' =&gt; "true",
               );

           Create  an  instance  of  Net::Kafka::Consumer. Accept hash where keys are equal to property names of
           librdkafka (see  &lt;https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md&gt;).   Note  that
           not  all  callbacks  are  supported  at  the  moment. Supported ones are: "error_cb", "rebalance_cb",
           "commit_cb" and "stats_cb".

       <b>subscribe()</b>
               $consumer-&gt;subscribe([ 'my_topic' ]);

           Subscribe to topic set using  balanced  consumer  groups.  The  main  entry-point  for  "distributed"
           consumer  mode  -  partitions  will  be  assigned  automatically  using  Kafka's  GroupApi semantics.
           Wildcard/regex topics are supported so matching topics will be added to the subscription list.

       <b>unsubscribe()</b>
               $consumer-&gt;unsubscribe();

           Unsubscribe from the current subscription set.

       <b>assign()</b>
               # manually assign partitions 0 and 1 to be consumed
               my $tp_list = Net::Kafka::TopicPartitionList-&gt;new();
               $tp_list-&gt;add("my_topic", 0);
               $tp_list-&gt;add("my_topic", 1);
               $consumer-&gt;assign($tp_list);

           Atomic assignment of partitions to consume.  The  main  entry-point  for  "simple"  consumer  mode  -
           partitions are assigned manually.

       <b>poll()</b>
               my $message = $consumer-&gt;poll($timeout_ms);

           Poll  the  consumer for messages or events. Returns instance of "Net::Kafka::Message". Will block for
           at most "timeout_ms" milliseconds. An  application  should  make  sure  to  call  "poll"  at  regular
           intervals.

       <b>committed()</b>
               my $tp_list = Net::Kafka::TopicPartitionList-&gt;new();
               $tp_list-&gt;add("my_topic", 0);
               $consumer-&gt;committed($tp_list);
               my $offset = $tp_list-&gt;offset("my_topic_, 0);

           Retrieve committed offsets for topics+partitions.

       <b>offsets_for_times()</b>
               my $tp_list = Net::Kafka::TopicPartitionList-&gt;new();
               $tp_list-&gt;add("my_topic", 0);
               $tp_list-&gt;set_offset("my_topic", 0, 958349923); # timestamp if passed through offset field
               $consumer-&gt;offsets_for_times($tp_list);
               my $offset = $tp_list-&gt;offset("my_topic");

           Look up the offsets for the given partitions by timestamp.

       <b>pause()</b>
               my $tp_list = Net::Kafka::TopicPartitionList-&gt;new();
               $tp_list-&gt;add("my_topic", 0);
               $consumer-&gt;pause($tp_list); # pauses consumption of partition 0 of "my_topic"

           Pause consumption for the provided list of partitions.

       <b>resume()</b>
               my $tp_list = Net::Kafka::TopicPartitionList-&gt;new();
               $tp_list-&gt;add("my_topic", 0);
               $consumer-&gt;resume($tp_list); # resumes consumption of partition 0 of "my_topic"

           Resume consumption for the provided list of partitions.

       <b>subscription()</b>
               my $topics = $consumer-&gt;subscription();

           Returns the current topic subscription

       <b>partitions_for()</b>
               my $partitions = $producer-&gt;partitions_for("my_topic");

           Returns  an  "ARRAYREF"  that  contains partition metadata information about the given topic (leader,
           replicas, ISR replicas);

       <b>commit()</b>
               $consumer-&gt;commit(); # commit current partition assignment (blocking call)
               $consumer-&gt;<a href="../man1/commit.1.html">commit</a>(1); # commit current partition assignment (non-blocking call)
               my $tp_list = Net::Kafka::TopicPartitionList-&gt;new();
               $tp_list-&gt;add("my_topic", 0);
               $tp_list-&gt;set_offset("my_topic", 0, 12345);
               $consumer-&gt;commit(0, $tp_list); # commit $tp_list assignment (blocking call);

           Commit offsets on broker for the provided list of  partitions.  If  no  partitions  provided  current
           assignment is committed instead.

       <b>commit_message()</b>;
               my $message = $consumer-&gt;<a href="../man1000/poll.1000.html">poll</a>(1000);
               $consumer-&gt;commit_message(0, $message); # commit message (blocking call);
               $consumer-&gt;commit_message(1, $message); # commit message (non-blocking call);

           Commit message's offset on broker for the message's partition.

       <b>position()</b>
               my $position_list = Net::Kafka::TopicPartitionList-&gt;new();
               $position_list-&gt;add("my_topic", 0);
               $consumer-&gt;position($position_list);
               my $position = $position_list-&gt;offset("my_topic", 0);

           Retrieve  current  positions  (offsets)  for topics+partitions. The \p offset field of each requested
           partition will be set to the offset of the last consumed message + 1, or  RD_KAFKA_OFFSET_INVALID  in
           case there was no previous message.

           Note:  in  this  context  the  last consumed message is the offset consumed by the current librdkafka
           instance and, in case of rebalancing, not necessarily the last message fetched from the partition.

       <b>seek()</b>
               $consumer-&gt;seek("my_topic", 0, 12345); # seek partition 0 of "my_topic" to offset "12345"
               $consumer-&gt;seek("my_topic", 0, RD_KAFKA_OFFSET_BEGINNING); # seek to the beginning of "my_topic" partition 0
               $consumer-&gt;seek("my_topic", 0, RD_KAFKA_OFFSET_END); # seek to the end of "my_topic" partition 0

           Seek consumer for topic+partition to offset which is either an absolute or logical offset.

       <b>query_watermark_offsets()</b>
               my ($low, $high) = $consumer-&gt;query_watermark_offsets("my_topic", 0);

           Queries Kafka Broker for lowest and highest watermark offsets in the given topic-partition.

       <b>close()</b>
               $consumer-&gt;close();

           Close all consumer handles. Make sure to call it before destroying your application to make sure that
           all outstanding requests to be flushed.

</pre><h4><b>Net::Kafka::Message</b></h4><pre>
       This class maps to "rd_kafka_message_t" structure  from  librdkafka  and  represents  message  or  event.
       Objects of this class have the following methods:

       <b>err()</b>
           return error code from the message

       <b>topic()</b>
           return topic name

       <b>partition()</b>
           return partition number

       <b>offset()</b>
           return  offset.  Note,  that  the  value  is  truncated to 32 bit if your perl doesn't support 64 bit
           integers.

       <b>key()</b>
           return message key

       <b>payload()</b>
           return message payload

       <b>headers()</b>
           return a copy of message headers

       <b>detach_headers()</b>
           return message headers and removes them from the message

</pre><h4><b>Net::Kafka::Headers</b></h4><pre>
       This class contains a list of Kafka headers (it allows duplicates).   Objects  of  this  class  have  the
       following methods:

       <b>new()</b>
           create a new instance

       add(name, value)
           append a new name/value pair to the header list

       remove(name)
           remove all headers with the given name, if any

       get_last(name)
           return the last value associated with a given name

       <b>to_hash()</b>
           return an hash-of-arrays containing all headers

</pre><h4><b>Net::Kafka::Err</b></h4><pre>
       This class provides static methods to convert error codes into names and descriptions.

       <b>rd_kafka_get_err_descs()</b>
               rd_kafka_get_err_descs()

           returns a hash mapping error codes to description strings.

       <b>to_string()</b>
               to_string($code)

           return the description string for this error code.

       <b>to_name()</b>
               to_name($code)

           return the name of this error code.

</pre><h4><b>CAVEATS</b></h4><pre>
       Message offset is truncated to 32 bit if perl is compiled without support for 64 bit integers.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   &lt;https://github.com/edenhill/librdkafka&gt;

       •   &lt;https://github.com/trinitum/perl-Kafka-Librd&gt;

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2016, 2017 Pavel Shaydo

       Copyright (C) 2018, 2019 Booking.com

       This  program  is  free software; you can redistribute it and/or modify it under the terms of either: the
       GNU General Public License as published by the Free Software Foundation; or the Artistic License.

       See <a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a> for more information.

perl v5.40.0                                       2024-10-15                                    <u>Net::<a href="../man3pm/Kafka.3pm.html">Kafka</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>