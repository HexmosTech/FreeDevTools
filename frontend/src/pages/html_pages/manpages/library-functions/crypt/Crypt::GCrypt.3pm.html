<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypt::GCrypt - Perl interface to the GNU Cryptographic library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcrypt-gcrypt-perl">libcrypt-gcrypt-perl_1.26-7build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Crypt::GCrypt - Perl interface to the GNU Cryptographic library

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Crypt::GCrypt;

         my $cipher = Crypt::GCrypt-&gt;new(
           type =&gt; 'cipher',
           algorithm =&gt; 'aes',
           mode =&gt; 'cbc'
         );
         $cipher-&gt;start('encrypting');

         $cipher-&gt;setkey('my secret key');
         $cipher-&gt;setiv('my init vector');

         my $ciphertext  = $cipher-&gt;encrypt('plaintext');
         $ciphertext .= $cipher-&gt;finish;

         my $plaintext  = $cipher-&gt;decrypt($ciphertext);
         $plaintext .= $cipher-&gt;finish;

</pre><h4><b>ABSTRACT</b></h4><pre>
       Crypt::GCrypt provides an object interface to the C libgcrypt library. It currently supports symmetric
       encryption/decryption and message digests, while asymmetric cryptography is being worked on.

</pre><h4><b>BINDING</b> <b>INFO</b></h4><pre>
   <b>gcrypt_version()</b>
       Returns a string indicating the running version of gcrypt.

   <b>built_against_version()</b>
       Returns a string indicating the version of gcrypt that this module was built against.  This is likely
       only to be useful in a debugging situation.

</pre><h4><b>SYMMETRIC</b> <b>CRYPTOGRAPHY</b></h4><pre>
   <b>cipher_algo_available()</b>
       Determines whether a given cipher algorithm is available in the local gcrypt installation:

         if (Crypt::GCrypt::cipher_algo_available('aes')) {
           # do stuff with aes
         }

   <b>new()</b>
       In order to encrypt/decrypt your data using a symmetric cipher you first have to build a Crypt::GCrypt
       object:

         my $cipher = Crypt::GCrypt-&gt;new(
           type =&gt; 'cipher',
           algorithm =&gt; 'aes',
           mode =&gt; 'cbc'
         );

       The <u>type</u> argument must be "cipher" and <u>algorithm</u> is required too. See below for a description of
       available algorithms and other initialization parameters:

       algorithm
           This may be one of the following:

           <b>3des</b>    Triple-DES  with  3  Keys as EDE.  The key size of this algorithm is 168 but you have to pass
                   192 bits because the most significant bits of each byte are ignored.

           <b>aes</b>     AES (Rijndael) with a 128 bit key.

           <b>aes192</b>  AES (Rijndael) with a 192 bit key.

           <b>aes256</b>  AES (Rijndael) with a 256 bit key.

           <b>blowfish</b>
                   The blowfish algorithm. The current implementation allows only for a key  size  of  128  bits
                   (and thus is not compatible with Crypt::Blowfish).

           <b>cast5</b>   CAST128-5 block cipher algorithm.  The key size is 128 bits.

           <b>des</b>     Standard  DES  with  a 56 bit key. You need to pass 64 bit but the high bits of each byte are
                   ignored.  Note, that this is a weak algorithm which can be broken in reasonable time using  a
                   brute force approach.

           <b>twofish</b> The Twofish algorithm with a 256 bit key.

           <b>twofish128</b>
                   The Twofish algorithm with a 128 bit key.

           <b>arcfour</b> An  algorithm  which  is  100% compatible with RSA Inc.'s RC4 algorithm.  Note that this is a
                   stream cipher and must be used very carefully to avoid a couple of weaknesses.

       mode
           This is a string specifying one of the following encryption/decryption modes:

           <b>stream</b>  only available for stream ciphers

           <b>ecb</b>     doesn't use an IV, encrypts each block independently

           <b>cbc</b>     the current ciphertext block is encryption  of  current  plaintext  block  xor-ed  with  last
                   ciphertext block

           <b>cfb</b>     the current ciphertext block is the current plaintext block xor-ed with the current keystream
                   block, which is the encryption of the last ciphertext block

           <b>ofb</b>     the current ciphertext block is the current plaintext block xor-ed with the current keystream
                   block, which is the encryption of the last keystream block

           If no mode is specified then <b>cbc</b> is selected for block ciphers, and <b>stream</b> for stream ciphers.

       padding
           When the last block of plaintext is shorter than the block size, it must be padded before encryption.
           Padding  should  permit  a  safe  unpadding  after  decryption.  Crypt::GCrypt currently supports two
           methods:

           <b>standard</b>
                   This is also known as PKCS#5 padding, as it's binary safe. The  string  is  padded  with  the
                   number of bytes that should be truncated. It's compatible with Crypt::CBC.

           <b>null</b>    Only  for text strings. The block will be padded with null bytes (00). If the last block is a
                   full block and blocksize is 8, a block of "0000000000000000" will be appended.

           <b>none</b>    By setting the padding method to "none", Crypt::GCrypt will only accept a multiple of  blklen
                   as input for "<b>encrypt()</b>".

       secure
           If  this  option  is  set to a true value, all data associated with this cipher will be put into non-
           swappable storage, if possible.

       enable_sync
           Enable the CFB sync operation.

       Once you've got your cipher object the following methods are available:

   <b>start()</b>
          $cipher-&gt;start('encrypting');
          $cipher-&gt;start('decrypting');

       This method must be called before any call to <b>setkey()</b> or <b>setiv()</b>. It prepares the cipher for  encryption
       or decryption, resetting the internal state.

   <b>setkey()</b>
          $cipher-&gt;setkey('my secret key');

       Encryption  and  decryption  operations  will  use  this key until a different one is set. If your key is
       shorter than the cipher's keylen (see the "keylen" method) it will be zero-padded, if  it  is  longer  it
       will be truncated.

   <b>setiv()</b>
          $cipher-&gt;setiv('my iv');

       Set  the  initialisation vector for the next encrypt/decrypt operation.  If <u>IV</u> is missing a "standard" IV
       of all zero is used. The same IV is set in newly created cipher objects.

   <b>encrypt()</b>
          $ciphertext = $cipher-&gt;encrypt($plaintext);

       This method encrypts <u>$plaintext</u> with <u>$cipher</u>, returning  the  corresponding  ciphertext.  The  output  is
       buffered;  this  means  that you'll only get multiples of $cipher's block size and that at the end you'll
       have to call "<b>finish()</b>".

   <b>finish()</b>
           $ciphertext .= $cipher-&gt;finish;

           $plaintext .= $cipher-&gt;finish;

       The CBC algorithm must buffer data blocks internally until there are even  multiples  of  the  encryption
       algorithm's  blocksize  (typically  8  or  16  bytes).  After the last call to <b>encrypt()</b> or <b>decrypt()</b> you
       should call <b>finish()</b> to flush the internal buffer and return any leftover data.  This  method  will  also
       take care of padding/unpadding of data (see the "padding" option above).

   <b>decrypt()</b>
          $plaintext = $cipher-&gt;decrypt($ciphertext);

       The  counterpart  to encrypt, decrypt takes a <u>$ciphertext</u> and produces the original plaintext (given that
       the right key was used, of course).  The output is buffered; this means that you'll only get multiples of
       $cipher's block size and that at the end you'll have to call "<b>finish()</b>".

   <b>keylen()</b>
          print "Key length is " . $cipher-&gt;keylen();

       Returns the number of bytes of keying material this cipher needs.

   <b>blklen()</b>
          print "Block size is " . $cipher-&gt;blklen();

       As their name implies, block ciphers operate on blocks of data. This method  returns  the  size  of  this
       blocks  in  bytes for this particular cipher. For stream ciphers 1 is returned, since this implementation
       does not feed less than a byte into the cipher.

   <b>sync()</b>
          $cipher-&gt;sync();

       Apply the CFB sync operation.

</pre><h4><b>MESSAGE</b> <b>DIGESTS</b></h4><pre>
   <b>digest_algo_available()</b>
       Determines whether a given digest algorithm is available in the local gcrypt installation:

          if (Crypt::GCrypt::digest_algo_available('sha256')) {
             # do stuff with sha256
          }

   <b>new()</b>
       In order to create a message digest, you first have to build a Crypt::GCrypt object:

         my $digest = Crypt::GCrypt-&gt;new(
           type =&gt; 'digest',
           algorithm =&gt; 'sha256',
         );

       The <u>type</u> argument must be "digest" and <u>algorithm</u>  is  required  too.  See  below  for  a  description  of
       available algorithms and other initialization parameters:

       algorithm
           Depending  on  your  available  version  of gcrypt, this can be one of the following hash algorithms.
           Note   that   some   gcrypt   installations   do    not    implement    certain    algorithms    (see
           <b>digest_algo_available()</b>).

           <b>md4</b>
           <b>md5</b>
           <b>ripemd160</b>
           <b>sha1</b>
           <b>sha224</b>
           <b>sha256</b>
           <b>sha384</b>
           <b>sha512</b>
           <b>tiger192</b>
           <b>whirlpool</b>
       secure
           If  this  option  is  set to a true value, all data associated with this digest will be put into non-
           swappable storage, if possible.

       hmac
           If the digest is expected to be used as a keyed-Hash Message Authentication Code (HMAC),  supply  the
           key with this argument.  It is good practice to ensure that the key is at least as long as the digest
           used.

       Once you've got your digest object the following methods are available:

   <b>digest_length()</b>
           my $len = $digest-&gt;digest_length();

       Returns the length in bytes of the digest produced by this algorithm.

   <b>write()</b>
           $digest-&gt;write($data);

       Feeds data into the hash context.  Once you have called <b>read()</b>, this method can't be called anymore.

   <b>reset()</b>
       Re-initializes the digest with the same parameters it was initially created with.  This allows <b>write()</b>ing
       again, after a call to <b>read()</b>.

   <b>clone()</b>
       Creates  a  new digest object with the exact same internal state.  This is useful if you want to retrieve
       intermediate digests (i.e.  <b>read()</b> from the copy and continue <b>write()</b>ing to the original).

   <b>read()</b>
           my $md = $digest-&gt;read();

       Completes the digest and return the resultant string.  You can call this  multiple  times,  and  it  will
       return the same information.  Once a digest object has been <b>read()</b>, it may not be written to.

</pre><h4><b>THREAD</b> <b>SAFETY</b></h4><pre>
       libgcrypt is initialized with support for Pthread, so this module should be thread safe.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Crypt::GCrypt::MPI  supports  Multi-precision  integers  (bignum  math)  using  libgcrypt  as the backend
       implementation.

</pre><h4><b>BUGS</b> <b>AND</b> <b>FEEDBACK</b></h4><pre>
       There are no known bugs. You are very welcome to write  mail  to  the  author  (<a href="mailto:aar@cpan.org">aar@cpan.org</a>)  with  your
       contributions, comments, suggestions, bug reports or complaints.

</pre><h4><b>AUTHORS</b> <b>AND</b> <b>CONTRIBUTORS</b></h4><pre>
       Alessandro Ranellucci &lt;<a href="mailto:aar@cpan.org">aar@cpan.org</a>&gt;

       Daniel Kahn Gillmor (message digests) &lt;<a href="mailto:dkg@fifthhorseman.net">dkg@fifthhorseman.net</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright  (c)  Alessandro  Ranellucci.   Crypt::GCrypt  is free software, you may redistribute it and/or
       modify it under the same terms as Perl itself.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       This module was initially inspired by the GCrypt.pm bindings made by Robert Bihlmeyer in 2002. Thanks  to
       users who give feedback and submit patches (see Changelog).

</pre><h4><b>DISCLAIMER</b></h4><pre>
       This  software is provided by the copyright holders and contributors ``as is'' and any express or implied
       warranties, including, but not limited to, the implied warranties of merchantability and  fitness  for  a
       particular  purpose  are  disclaimed.  In  no  event  shall the regents or contributors be liable for any
       direct, indirect, incidental, special, exemplary, or consequential damages (including,  but  not  limited
       to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption)
       however  caused and on any theory of liability, whether in contract, strict liability, or tort (including
       negligence or otherwise) arising in any way out of the use of this  software,  even  if  advised  of  the
       possibility of such damage.

perl v5.40.0                                       2024-10-20                                 <u>Crypt::<a href="../man3pm/GCrypt.3pm.html">GCrypt</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>