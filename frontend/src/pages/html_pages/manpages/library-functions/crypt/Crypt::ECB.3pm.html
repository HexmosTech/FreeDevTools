<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypt::ECB - Use block ciphers using ECB mode</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcrypt-ecb-perl">libcrypt-ecb-perl_2.23-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Crypt::ECB - Use block ciphers using ECB mode

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Use Crypt::ECB OO style

         use Crypt::ECB;

         $ecb = Crypt::ECB-&gt;new;
         $ecb-&gt;cipher('Blowfish');
         $ecb-&gt;key('some_key');

         $enc = $ecb-&gt;encrypt("Some data.");
         print $ecb-&gt;decrypt($enc);

       or use the function style interface

         use Crypt::ECB qw(encrypt decrypt encrypt_hex decrypt_hex);

         $ciphertext = encrypt($key, 'Blowfish', "Some data");
         $plaintext  = decrypt($key, 'Blowfish', $ciphertext);

         $hexcode = encrypt_hex($key, $cipher, $plaintext);
         $plain   = decrypt_hex($key, $cipher, $hexcode);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is a Perl-only implementation of the ECB mode. In combination with a block cipher such as
       Blowfish, DES, IDEA or Rijndael, you can encrypt and decrypt messages of arbitrarily long length. Though
       for security reasons other modes than ECB such as CBC should be preferred. See textbooks on cryptography
       if you want to know why.

       The functionality of the module can be accessed via OO methods or via standard function calls. Remember
       that some block cipher module like for example Crypt::Blowfish has to be installed. The syntax of
       Crypt::ECB follows that of Crypt::CBC.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new()</b>
         $ecb = Crypt::ECB-&gt;new(
               -cipher    =&gt; $cipher,
               -key       =&gt; $key,
               -padding   =&gt; 'oneandzeroes',
               -keysize   =&gt; 8,  # use to override cipher's default
               -blocksize =&gt; 8,  # use to override cipher's default
         );

       or

         $ecb = Crypt::ECB-&gt;new({
               cipher    =&gt; $cipher,
               key       =&gt; $key,
               padding   =&gt; 'oneandzeroes',
               keysize   =&gt; 8,  # use to override cipher's default
               blocksize =&gt; 8,  # use to override cipher's default
         });

       or (only key and cipher can be passed this way)

         $ecb = Crypt::ECB-&gt;new($key, 'Blowfish');
         $ecb = Crypt::ECB-&gt;new($key); # DES is assumed

       The following options are recognized: cipher, key, keysize, blocksize and padding. Options can be passed
       like in Crypt::CBC. All options can be read and also be changed via corresponding methods afterwards.

       If called without parameters you have to call at least <b>key()</b> and <b>cipher()</b> before you can start crypting.

   <b>cipher(),</b> <b>module(),</b> <b>key()</b>
         $ecb = Crypt::ECB-&gt;new;
         $ecb-&gt;cipher('Blowfish');
         $ecb-&gt;key('some_key');

         print $ecb-&gt;cipher;   # Blowfish
         print $ecb-&gt;module;   # Crypt::Blowfish
         print $ecb-&gt;key;      # some_key

       or

         my $ecb  = Crypt::ECB-&gt;new;
         my $xtea = Crypt::XTEA-&gt;new($key, 32, little_endian =&gt; 1);
         $ecb-&gt;cipher($xtea);

       <b>cipher()</b> sets the block cipher to be used. It tries to load the corresponding module. If an error occurs,
       it dies with some errmessage.  Otherwise it returns the cipher name. Free packages available for Perl are
       for example Blowfish, DES, IDEA or Rijndael. If called without parameter it just returns the name of the
       cipher.

       <b>cipher()</b> also accepts a pre-existing object from a suitable block cipher module. This is useful e.g. for
       cipher modules such as Crypt::XTEA which need additional parameters.

       <b>module()</b> returns the perl package containing the block cipher which has been specified using <b>cipher()</b>.

       <b>key()</b> sets the key if given a parameter. It always returns the key. Note that most block ciphers require
       keys of definite length.  For example DES expects an eight byte key.

   <b>keysize(),</b> <b>blocksize()</b>
         $ecb = Crypt::ECB-&gt;new;
         $ecb-&gt;cipher('Blowfish');

         $keysize   = $ecb-&gt;keysize;
         $blocksize = $ecb-&gt;blocksize;

       These methods can be used to retrieve keysize and blocksize as reported from the block cipher chosen.

       They can be used as well to override the values that are reported from the cipher module. Of course that
       doesn't make sense unless the block cipher used supports the new values. E.g. Crypt::Rijndael works with
       16, 24 and 32 byte keys.

   <b>padding()</b>
         $ecb-&gt;padding('oneandzeroes');

         my $custom_padding = sub { ... };
         $ecb-&gt;padding($custom_padding);

       <b>padding()</b> sets the way how data is padded up to a multiple of the cipher's blocksize. Until now the
       following methods are implemented: 'standard', 'zeroes', 'oneandzeroes', 'rijndael_compat', 'space',
       'null' and 'none'. If the padding style is not set explicitly, 'standard' is used.

         'standard' (default) (binary safe)
         The PKCS#5 / PKCS#7 method (RFC 5652): Pads with the number of bytes
         that should be truncated. So, if blocksize is 8, then "0A0B0C" will
         be padded with five "05"s, resulting in "0A0B0C0505050505". If the
         message is already a multiple of the cipher's block size, then another
         whole block is appended.

         'zeroes' (binary safe)
         This is a variant of the standard method. It pads with null bytes, except
         the last byte equals the number of padding bytes. So, if the blocksize is
         8, then "0A0B0C" will be padded to "0A0B0C0000000005". If the message is
         already a multiple of the cipher's block size, then another whole block
         is appended.

         'oneandzeroes' (binary safe)
         Pads with "80" followed by as many "00"s as necessary to fill the block,
         in other words a 1 bit followed by 0s. If the message already is a
         multiple of the cipher's block size, then another whole block is
         appended.

         'rijndael_compat' (binary safe)
         Similar to oneandzeroes, except that no padding is performed if the
         message already is already a multiple of the cipher's block size. This is
         provided for compatibility with Crypt::Rijndael.

         'null'
         Pads with as many null bytes as necessary to fill the block. If the
         message is already a multiple of the cipher's block size, then another
         whole block is appended.
         ATTENTION: Can truncate more characters than it should (if the original
         message ended with one or more null bytes).

         'space'
         Pads with as many space characters as necessary to fill the block.
         If the message is already a multiple of the cipher's block size, unlike
         the other methods NO block is appended.
         ATTENTION: Can truncate more characters than it should (if the original
         message ended with one or more space characters).

         'none'
         No padding added by Crypt::ECB. You then have to take care of correct
         padding and truncating yourself.

       You can also use a custom padding function. To do this, create a function that is called like:

         $padded_block = function($block, $blocksize, $direction);

       and tell Crypt::ECB to use your function:

         $ecb-&gt;padding(\&amp;function);

       $block is the current block of data, $blocksize is the size to pad to, $direction is "e" for encrypting
       and "d" for decrypting, and $padded_block is the result after padding or truncation. When encrypting, the
       function should always return a string of $blocksize length, and when decrypting, it can expect the
       string coming in to be of that length.

   <b>start(),</b> <b>mode(),</b> <b>crypt(),</b> <b>finish()</b>
         $ecb-&gt;start('encrypt');
         $enc .= $ecb-&gt;crypt($_) foreach (@lines);
         $enc .= $ecb-&gt;finish;

         $ecb-&gt;start('decrypt');
         print $ecb-&gt;mode;

       <b>start()</b> sets the crypting mode, checks if all required variables like key and cipher are set, then
       initializes the block cipher specified. Allowed parameters are any words starting either with 'e' or 'd'.
       The method returns the current mode.

       <b>mode()</b> is called without parameters and just returns the current mode.

       <b>crypt()</b> processes the data given as argument. If called without argument $_ is processed. The method
       returns the processed data.  Cipher and key have to be set in order to be able to process data.  If some
       of these are missing or <b>start()</b> was not called before, the method dies.

       After having sent all data to be processed to <b>crypt()</b> you have to call <b>finish()</b> in order to flush data
       that's left in the buffer.

   <b>encrypt(),</b> <b>decrypt(),</b> <b>encrypt_hex(),</b> <b>decrypt_hex()</b>
         $enc = $ecb-&gt;encrypt($data);
         print $ecb-&gt;decrypt($enc);

         $hexenc = $ecb-&gt;encrypt_hex($data);
         print $ecb-&gt;decrypt_hex($hexenc);

       <b>encrypt()</b> and <b>decrypt()</b> are convenience methods which call <b>start()</b>, <b>crypt()</b> and <b>finish()</b> for you.

       <b>encrypt_hex()</b> and <b>decrypt_hex()</b> are convenience functions that operate on ciphertext in a hexadecimal
       representation.  These functions can be useful if, for example, you wish to place the encrypted
       information into an e-mail message, web page or URL.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       For convenience en- or decrypting can also be done by calling ordinary functions. The functions are:
       <b>encrypt()</b>, <b>decrypt()</b>, <b>encrypt_hex()</b>, <b>decrypt_hex()</b>.

   <b>encrypt(),</b> <b>decrypt(),</b> <b>encrypt_hex(),</b> <b>decrypt_hex()</b>
         use Crypt::ECB qw(encrypt decrypt encrypt_hex decrypt_hex);

         $ciphertext = encrypt($key, $cipher, $plaintext, $padstyle);
         $plaintext  = decrypt($key, $cipher, $ciphertext, $padstyle);

         $ciphertext = encrypt_hex($key, $cipher, $plaintext, $padstyle);
         $plaintext  = decrypt_hex($key, $cipher, $ciphertext, $padstyle);

       <b>encrypt()</b> and <b>decrypt()</b> process the provided text and return either the corresponding ciphertext
       (encrypt) or plaintext (decrypt). Data and padstyle are optional. If the padding style is omitted,
       'standard' is assumed. If data is omitted, $_ is used.

       <b>encrypt_hex()</b> and <b>decrypt_hex()</b> operate on ciphertext in a hexadecimal representation, just like the
       methods with the same name, see above. Otherwise usage is the same as for <b>encrypt()</b> and <b>decrypt()</b>.

</pre><h4><b>BUGS</b></h4><pre>
       None that I know of. Please report if you find any.

</pre><h4><b>TODO</b></h4><pre>
       Implement 'random' padding, see <a href="http://www.di-mgt.com.au/cryptopad.html">http://www.di-mgt.com.au/cryptopad.html</a>.

       A taint check on the key like Crypt::CBC does could be added.

</pre><h4><b>LICENSE</b></h4><pre>
       Crypt-ECB is Copyright (C) 2000, 2005, 2008, 2016 by Christoph Appel.

       This module is distributed using the same terms as Perl itself. It is free software; you can redistribute
       it and/or modify it under the terms of either:

       a) the GNU General Public License as published by the Free Software Foundation; either version 1, or (at
       your option) any later version, or

       b) the "Artistic License".

</pre><h4><b>AUTHOR</b></h4><pre>
       Christoph Appel (see ECB.pm for email address)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), <b>Crypt::<a href="../man3/DES.3.html">DES</a></b>(3), <b>Crypt::<a href="../man3/IDEA.3.html">IDEA</a></b>(3), <b>Crypt::<a href="../man3/CBC.3.html">CBC</a></b>(3)

perl v5.38.2                                       2024-01-20                                           <u><a href="../man3pm/ECB.3pm.html">ECB</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>