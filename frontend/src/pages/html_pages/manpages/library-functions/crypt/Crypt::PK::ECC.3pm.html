<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypt::PK::ECC - Public key cryptography based on EC</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcryptx-perl">libcryptx-perl_0.085-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Crypt::PK::ECC - Public key cryptography based on EC

</pre><h4><b>SYNOPSIS</b></h4><pre>
        ### OO interface

        #Encryption: Alice
        my $pub = Crypt::PK::ECC-&gt;new('Bob_pub_ecc1.der');
        my $ct = $pub-&gt;encrypt("secret message");
        #
        #Encryption: Bob (received ciphertext $ct)
        my $priv = Crypt::PK::ECC-&gt;new('Bob_priv_ecc1.der');
        my $pt = $priv-&gt;decrypt($ct);

        #Signature: Alice
        my $priv = Crypt::PK::ECC-&gt;new('Alice_priv_ecc1.der');
        my $sig = $priv-&gt;sign_message($message);
        #
        #Signature: Bob (received $message + $sig)
        my $pub = Crypt::PK::ECC-&gt;new('Alice_pub_ecc1.der');
        $pub-&gt;verify_message($sig, $message) or die "ERROR";

        #Shared secret
        my $priv = Crypt::PK::ECC-&gt;new('Alice_priv_ecc1.der');
        my $pub = Crypt::PK::ECC-&gt;new('Bob_pub_ecc1.der');
        my $shared_secret = $priv-&gt;shared_secret($pub);

        #Key generation
        my $pk = Crypt::PK::ECC-&gt;new();
        $pk-&gt;generate_key('secp160r1');
        my $private_der = $pk-&gt;export_key_der('private');
        my $public_der = $pk-&gt;export_key_der('public');
        my $private_pem = $pk-&gt;export_key_pem('private');
        my $public_pem = $pk-&gt;export_key_pem('public');
        my $public_raw = $pk-&gt;export_key_raw('public');

        ### Functional interface

        #Encryption: Alice
        my $ct = ecc_encrypt('Bob_pub_ecc1.der', "secret message");
        #Encryption: Bob (received ciphertext $ct)
        my $pt = ecc_decrypt('Bob_priv_ecc1.der', $ct);

        #Signature: Alice
        my $sig = ecc_sign_message('Alice_priv_ecc1.der', $message);
        #Signature: Bob (received $message + $sig)
        ecc_verify_message('Alice_pub_ecc1.der', $sig, $message) or die "ERROR";

        #Shared secret
        my $shared_secret = ecc_shared_secret('Alice_priv_ecc1.der', 'Bob_pub_ecc1.der');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The module provides a set of core ECC functions as well as implementation of ECDSA and ECDH.

       Supports elliptic curves "y^2 = x^3 + a*x + b" over prime fields "Fp = Z/pZ" (binary fields not
       supported).

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
        my $pk = Crypt::PK::ECC-&gt;new();
        #or
        my $pk = Crypt::PK::ECC-&gt;new($priv_or_pub_key_filename);
        #or
        my $pk = Crypt::PK::ECC-&gt;new(\$buffer_containing_priv_or_pub_key);

       Support for password protected PEM keys

        my $pk = Crypt::PK::ECC-&gt;new($priv_pem_key_filename, $password);
        #or
        my $pk = Crypt::PK::ECC-&gt;new(\$buffer_containing_priv_pem_key, $password);

   <b>generate_key</b>
       Uses Yarrow-based cryptographically strong random number generator seeded with random data taken from
       "/dev/random" (UNIX) or "CryptGenRandom" (Win32).

        $pk-&gt;generate_key($curve_name);
        #or
        $pk-&gt;generate_key($hashref_with_curve_params);

       The following predefined $curve_name values are supported:

        # curves from <a href="http://www.ecc-brainpool.org/download/Domain-parameters.pdf">http://www.ecc-brainpool.org/download/Domain-parameters.pdf</a>
        'brainpoolp160r1'
        'brainpoolp192r1'
        'brainpoolp224r1'
        'brainpoolp256r1'
        'brainpoolp320r1'
        'brainpoolp384r1'
        'brainpoolp512r1'
        # curves from <a href="http://www.secg.org/collateral/sec2_final.pdf">http://www.secg.org/collateral/sec2_final.pdf</a>
        'secp112r1'
        'secp112r2'
        'secp128r1'
        'secp128r2'
        'secp160k1'
        'secp160r1'
        'secp160r2'
        'secp192k1'
        'secp192r1'   ... same as nistp192, prime192v1
        'secp224k1'
        'secp224r1'   ... same as nistp224
        'secp256k1'   ... used by Bitcoin
        'secp256r1'   ... same as nistp256, prime256v1
        'secp384r1'   ... same as nistp384
        'secp521r1'   ... same as nistp521
        #curves from <a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf</a>
        'nistp192'    ... same as secp192r1, prime192v1
        'nistp224'    ... same as secp224r1
        'nistp256'    ... same as secp256r1, prime256v1
        'nistp384'    ... same as secp384r1
        'nistp521'    ... same as secp521r1
        # curves from ANS X9.62
        'prime192v1'   ... same as nistp192, secp192r1
        'prime192v2'
        'prime192v3'
        'prime239v1'
        'prime239v2'
        'prime239v3'
        'prime256v1'   ... same as nistp256, secp256r1

       Using custom curve parameters:

        $pk-&gt;generate_key({ prime    =&gt; 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF',
                            A        =&gt; 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC',
                            B        =&gt; '22123DC2395A05CAA7423DAECCC94760A7D462256BD56916',
                            Gx       =&gt; '7D29778100C65A1DA1783716588DCE2B8B4AEE8E228F1896',
                            Gy       =&gt; '38A90F22637337334B49DCB66A6DC8F9978ACA7648A943B0',
                            order    =&gt; 'FFFFFFFFFFFFFFFFFFFFFFFF7A62D031C83F4294F640EC13',
                            cofactor =&gt; 1 });

       See &lt;<a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf</a>&gt;,
       &lt;<a href="http://www.secg.org/collateral/sec2_final.pdf">http://www.secg.org/collateral/sec2_final.pdf</a>&gt;,
       &lt;<a href="http://www.ecc-brainpool.org/download/Domain-parameters.pdf">http://www.ecc-brainpool.org/download/Domain-parameters.pdf</a>&gt;

   <b>import_key</b>
       Loads private or public key in DER or PEM format.

        $pk-&gt;import_key($filename);
        #or
        $pk-&gt;import_key(\$buffer_containing_key);

       Support for password protected PEM keys:

        $pk-&gt;import_key($filename, $password);
        #or
        $pk-&gt;import_key(\$buffer_containing_key, $password);

       Loading private or public keys form perl hash:

        $pk-&gt;import_key($hashref);

        # the $hashref is either a key exported via key2hash
        $pk-&gt;import_key({
             curve_A        =&gt; "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC",
             curve_B        =&gt; "1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45",
             curve_bits     =&gt; 160,
             curve_bytes    =&gt; 20,
             curve_cofactor =&gt; 1,
             curve_Gx       =&gt; "4A96B5688EF573284664698968C38BB913CBFC82",
             curve_Gy       =&gt; "23A628553168947D59DCC912042351377AC5FB32",
             curve_order    =&gt; "0100000000000000000001F4C8F927AED3CA752257",
             curve_prime    =&gt; "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF",
             k              =&gt; "B0EE84A749FE95DF997E33B8F333E12101E824C3",
             pub_x          =&gt; "5AE1ACE3ED0AEA9707CE5C0BCE014F6A2F15023A",
             pub_y          =&gt; "895D57E992D0A15F88D6680B27B701F615FCDC0F",
        });

        # or with the curve defined just by name
        $pk-&gt;import_key({
             curve_name =&gt; "secp160r1",
             k          =&gt; "B0EE84A749FE95DF997E33B8F333E12101E824C3",
             pub_x      =&gt; "5AE1ACE3ED0AEA9707CE5C0BCE014F6A2F15023A",
             pub_y      =&gt; "895D57E992D0A15F88D6680B27B701F615FCDC0F",
        });

        # or a hash with items corresponding to JWK (JSON Web Key)
        $pk-&gt;import_key({
              kty =&gt; "EC",
              crv =&gt; "P-256",
              x   =&gt; "MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4",
              y   =&gt; "4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM",
              d   =&gt; "870MB6gfuTJ4HtUnUvYMyJpr5eUZNP4Bk43bVdj3eAE",
        });

       Supported key formats:

        # all formats can be loaded from a file
        my $pk = Crypt::PK::ECC-&gt;new($filename);

        # or from a buffer containing the key
        my $pk = Crypt::PK::ECC-&gt;new(\$buffer_with_key);

       •   EC private keys with with all curve parameters

            -----BEGIN EC PRIVATE KEY-----
            MIIB+gIBAQQwCKEAcA6cIt6CGfyLKm57LyXWv2PgTjydrHSbvhDJTOl+7bzUW8DS
            rgSdtSPONPq1oIIBWzCCAVcCAQEwPAYHKoZIzj0BAQIxAP//////////////////
            ///////////////////////+/////wAAAAAAAAAA/////zB7BDD/////////////
            /////////////////////////////v////8AAAAAAAAAAP////wEMLMxL6fiPufk
            mI4Fa+P4LRkYHZxu/oFBEgMUCI9QE4daxlY5jYou0Z0qhcjt0+wq7wMVAKM1kmqj
            GaJ6HQCJamdzpIJ6zaxzBGEEqofKIr6LBTeOscce8yCtdG4dO2KLp5uYWfdB4IJU
            KjhVAvJdv1UpbDpUXjhydgq3NhfeSpYmLG9dnpi/kpLcKfj0Hb0omhR86doxE7Xw
            uMAKYLHOHX6BnXpDHXyQ6g5fAjEA////////////////////////////////x2NN
            gfQ3Ld9YGg2ySLCneuzsGWrMxSlzAgEBoWQDYgAEeGyHPLmHcszPQ9MIIYnznpzi
            QbvuJtYSjCqtIGxDfzgcLcc3nCc5tBxo+qX6OJEzcWdDAC0bwplY+9Z9jHR3ylNy
            ovlHoK4ItdWkVO8NH89SLSRyVuOF8N5t3CHIo93B

            -----END EC PRIVATE KEY-----
       •   EC private keys with curve defined by OID (short form)

            -----BEGIN EC PRIVATE KEY-----
            MHcCAQEEIBG1c3z52T8XwMsahGVdOZWgKCQJfv+l7djuJjgetdbDoAoGCCqGSM49
            AwEHoUQDQgAEoBUyo8CQAFPeYPvv78ylh5MwFZjTCLQeb042TjiMJxG+9DLFmRSM
            lBQ9T/RsLLc+PmpB1+7yPAR+oR5gZn3kJQ==

            -----END EC PRIVATE KEY-----
       •   EC private keys with curve defined by OID + compressed form (supported since: CryptX-0.059)

            -----BEGIN EC PRIVATE KEY-----
            MFcCAQEEIBG1c3z52T8XwMsahGVdOZWgKCQJfv+l7djuJjgetdbDoAoGCCqGSM49
            AwEHoSQDIgADoBUyo8CQAFPeYPvv78ylh5MwFZjTCLQeb042TjiMJxE=

            -----END EC PRIVATE KEY-----
       •   EC private keys in password protected PEM format

            -----BEGIN EC PRIVATE KEY-----
            Proc-Type: 4,ENCRYPTED
            DEK-Info: AES-128-CBC,98245C830C9282F7937E13D1D5BA11EC

            0Y85oZ2+BKXYwrkBjsZdj6gnhOAfS5yDVmEsxFCDug+R3+Kw3QvyIfO4MVo9iWoA
            D7wtoRfbt2OlBaLVl553+6QrUoa2DyKf8kLHQs1x1/J7tJOMM4SCXjlrOaToQ0dT
            o7fOnjQjHne16pjgBVqGilY/I79Ab85AnE4uw7vgEucBEiU0d3nrhwuS2Opnhzyx
            009q9VLDPwY2+q7tXjTqnk9mCmQgsiaDJqY09wlauSukYPgVuOJFmi1VdkRSDKYZ
            rUUsQvz6Q6Q+QirSlfHna+NhUgQ2eyhGszwcP6NU8iqIxI+NCwfFVuAzw539yYwS
            8SICczoC/YRlaclayXuomQ==

            -----END EC PRIVATE KEY-----
       •   EC public keys with all curve parameters

            -----BEGIN PUBLIC KEY-----
            MIH1MIGuBgcqhkjOPQIBMIGiAgEBMCwGByqGSM49AQECIQD/////////////////
            ///////////////////+///8LzAGBAEABAEHBEEEeb5mfvncu6xVoGKVzocLBwKb
            /NstzijZWfKBWxb4F5hIOtp3JqPEZV2k+/wOEQio/Re0SKaFVBmcR9CP+xDUuAIh
            AP////////////////////66rtzmr0igO7/SXozQNkFBAgEBA0IABITjF/nKK3jg
            pjmBRXKWAv7ekR1Ko/Nb5FFPHXjH0sDrpS7qRxFALwJHv7ylGnekgfKU3vzcewNs
            lvjpBYt0Yg4=

            -----END PUBLIC KEY-----
       •   EC public keys with curve defined by OID (short form)

            -----BEGIN PUBLIC KEY-----
            MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEoBUyo8CQAFPeYPvv78ylh5MwFZjT
            CLQeb042TjiMJxG+9DLFmRSMlBQ9T/RsLLc+PmpB1+7yPAR+oR5gZn3kJQ==

            -----END PUBLIC KEY-----
       •   EC  public  keys  with  curve  defined  by  OID  +  public point in compressed form (supported since:
           CryptX-0.059)

            -----BEGIN PUBLIC KEY-----
            MDkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDIgADoBUyo8CQAFPeYPvv78ylh5MwFZjT
            CLQeb042TjiMJxE=

            -----END PUBLIC KEY-----
       •   PKCS#8 private keys with all curve parameters

            -----BEGIN PRIVATE KEY-----
            MIIBMAIBADCB0wYHKoZIzj0CATCBxwIBATAkBgcqhkjOPQEBAhkA////////////
            /////////v//////////MEsEGP////////////////////7//////////AQYIhI9
            wjlaBcqnQj2uzMlHYKfUYiVr1WkWAxUAxGloRDXes3jEtlypWR4qV2MFmi4EMQR9
            KXeBAMZaHaF4NxZYjc4ri0rujiKPGJY4qQ8iY3M3M0tJ3LZqbcj5l4rKdkipQ7AC
            GQD///////////////96YtAxyD9ClPZA7BMCAQEEVTBTAgEBBBiKolTGIsTgOCtl
            6dpdos0LvuaExCDFyT6hNAMyAAREwaCX0VY1LZxLW3G75tmft4p9uhc0J7/+NGaP
            DN3Tr7SXkT9+co2a+8KPJhQy10k=

            -----END PRIVATE KEY-----
       •   PKCS#8 private keys with curve defined by OID (short form)

            -----BEGIN PRIVATE KEY-----
            MG8CAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQMEVTBTAgEBBBjFP/caeQV4WO3fnWWS
            f917PGzwtypd/t+hNAMyAATSg6pBT7RO6l/p+aKcrFsGuthUdfwJWS5V3NGcVt1b
            lEHQYjWya2YnHaPq/iMFa7A=

            -----END PRIVATE KEY-----
       •   PKCS#8 encrypted private keys - password protected keys (supported since: CryptX-0.059)

            -----BEGIN ENCRYPTED PRIVATE KEY-----
            MIGYMBwGCiqGSIb3DQEMAQMwDgQINApjTa6oFl0CAggABHi+59l4d4e6KtG9yci2
            BSC65LEsQSnrnFAExfKptNU1zMFsDLCRvDeDQDbxc6HlfoxyqFL4SmH1g3RvC/Vv
            NfckdL5O2L8MRnM+ljkFtV2Te4fszWcJFdd7KiNOkPpn+7sWLfzQdvhHChLKUzmz
            4INKZyMv/G7VpZ0=

            -----END ENCRYPTED PRIVATE KEY-----
       •   EC public key from X509 certificate

            -----BEGIN CERTIFICATE-----
            MIIBdDCCARqgAwIBAgIJAL2BBClDEnnOMAoGCCqGSM49BAMEMBcxFTATBgNVBAMM
            DFRlc3QgQ2VydCBFQzAgFw0xNzEyMzAyMDMzNDFaGA8zMDE3MDUwMjIwMzM0MVow
            FzEVMBMGA1UEAwwMVGVzdCBDZXJ0IEVDMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE
            KvkL2r5xZp7RzxLQJK+6tn/7lic+L70e1fmNbHOdxRaRvbK5G0AQWrdsbjJb92Ni
            lCQk2+w/i+VuS2Q3MSR5TaNQME4wHQYDVR0OBBYEFGbJkDyKgaMcIGHS8/WuqIVw
            +R8sMB8GA1UdIwQYMBaAFGbJkDyKgaMcIGHS8/WuqIVw+R8sMAwGA1UdEwQFMAMB
            Af8wCgYIKoZIzj0EAwQDSAAwRQIhAJtOsmrM+gJpImoynAyqTN+7myL71uxd+YeC
            6ze4MnzWAiBQi5/BqEr/SQ1+BC2TPtswvJPRFh2ZvT/6Km3gKoNVXQ==

            -----END CERTIFICATE-----
       •   SSH public EC keys

            ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNT...T3xYfJIs=

       •   SSH public EC keys (RFC-4716 format)

            ---- BEGIN SSH2 PUBLIC KEY ----
            Comment: "521-bit ECDSA, converted from OpenSSH"
            AAAAE2VjZHNhLXNoYTItbmlzdHA1MjEAAAAIbmlzdHA1MjEAAACFBAFk35srteP9twCwYK
            vU9ovMBi77Dd6lEBPrFaMEb0CZdZ5MC3nSqflGHRWkSbUpjdPdO7cYQNpK9YXHbNSO5hbU
            1gFZgyiGFxwJYYz8NAjedBXMgyH4JWplK5FQm5P5cvaglItC9qkKioUXhCc67YMYBtivXl
            Ue0PgIq6kbHTqbX6+5Nw==
            ---- END SSH2 PUBLIC KEY ----

       •   EC private keys in JSON Web Key (JWK) format

           See &lt;<a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-key">http://tools.ietf.org/html/draft-ietf-jose-json-web-key</a>&gt;

            {
             "kty":"EC",
             "crv":"P-256",
             "x":"MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4",
             "y":"4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM",
             "d":"870MB6gfuTJ4HtUnUvYMyJpr5eUZNP4Bk43bVdj3eAE",
            }

           <b>BEWARE:</b> For JWK support you need to have JSON module installed.

       •   EC public keys in JSON Web Key (JWK) format

            {
             "kty":"EC",
             "crv":"P-256",
             "x":"MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4",
             "y":"4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM",
            }

           <b>BEWARE:</b> For JWK support you need to have JSON module installed.

   <b>import_key_raw</b>
       Import raw public/private key - can load data exported by "export_key_raw".

        $pk-&gt;import_key_raw($key, $curve);
        # $key .... data exported by export_key_raw()
        # $curve .. curve name or hashref with curve parameters - same as by generate_key()

   <b>export_key_der</b>
        my $private_der = $pk-&gt;export_key_der('private');
        #or
        my $public_der = $pk-&gt;export_key_der('public');

       Since CryptX-0.36 "export_key_der" can also export keys in a format  that  does  not  explicitly  contain
       curve parameters but only curve OID.

        my $private_der = $pk-&gt;export_key_der('private_short');
        #or
        my $public_der = $pk-&gt;export_key_der('public_short');

       Since  CryptX-0.59 "export_key_der" can also export keys in "compressed" format that defines curve by OID
       + stores public point in compressed form.

        my $private_pem = $pk-&gt;export_key_der('private_compressed');
        #or
        my $public_pem = $pk-&gt;export_key_der('public_compressed');

   <b>export_key_pem</b>
        my $private_pem = $pk-&gt;export_key_pem('private');
        #or
        my $public_pem = $pk-&gt;export_key_pem('public');

       Since CryptX-0.36 "export_key_pem" can also export keys in a format  that  does  not  explicitly  contain
       curve parameters but only curve OID.

        my $private_pem = $pk-&gt;export_key_pem('private_short');
        #or
        my $public_pem = $pk-&gt;export_key_pem('public_short');

       Since  CryptX-0.59 "export_key_pem" can also export keys in "compressed" format that defines curve by OID
       + stores public point in compressed form.

        my $private_pem = $pk-&gt;export_key_pem('private_compressed');
        #or
        my $public_pem = $pk-&gt;export_key_pem('public_compressed');

       Support for password protected PEM keys

        my $private_pem = $pk-&gt;export_key_pem('private', $password);
        #or
        my $private_pem = $pk-&gt;export_key_pem('private', $password, $cipher);

        # supported ciphers: 'DES-CBC'
        #                    'DES-EDE3-CBC'
        #                    'SEED-CBC'
        #                    'CAMELLIA-128-CBC'
        #                    'CAMELLIA-192-CBC'
        #                    'CAMELLIA-256-CBC'
        #                    'AES-128-CBC'
        #                    'AES-192-CBC'
        #                    'AES-256-CBC' (DEFAULT)

   <b>export_key_jwk</b>
       <u>Since:</u> <u>CryptX-0.022</u>

       Exports public/private keys as a JSON Web Key (JWK).

        my $private_json_text = $pk-&gt;export_key_jwk('private');
        #or
        my $public_json_text = $pk-&gt;export_key_jwk('public');

       Also exports public/private keys as a perl HASH with JWK structure.

        my $jwk_hash = $pk-&gt;export_key_jwk('private', 1);
        #or
        my $jwk_hash = $pk-&gt;export_key_jwk('public', 1);

       <b>BEWARE:</b> For JWK support you need to have JSON module installed.

   <b>export_key_jwk_thumbprint</b>
       <u>Since:</u> <u>CryptX-0.031</u>

       Exports the key's JSON Web Key Thumbprint as a string.

       If you don't know what this is, see RFC 7638 &lt;https://tools.ietf.org/html/rfc7638&gt;.

        my $thumbprint = $pk-&gt;export_key_jwk_thumbprint('SHA256');

   <b>export_key_raw</b>
       Export raw public/private key. Public key is exported in ASN X9.62 format (compressed  or  uncompressed),
       private key is exported as raw bytes (padded with leading zeros to have the same size as the ECC curve).

        my $pubkey_octets  = $pk-&gt;export_key_raw('public');
        #or
        my $pubckey_octets = $pk-&gt;export_key_raw('public_compressed');
        #or
        my $privkey_octets = $pk-&gt;export_key_raw('private');

   <b>encrypt</b>
        my $pk = Crypt::PK::ECC-&gt;new($pub_key_filename);
        my $ct = $pk-&gt;encrypt($message);
        #or
        my $ct = $pk-&gt;encrypt($message, $hash_name);

        #NOTE: $hash_name can be 'SHA1' (DEFAULT), 'SHA256' or any other hash supported by Crypt::Digest

   <b>decrypt</b>
        my $pk = Crypt::PK::ECC-&gt;new($priv_key_filename);
        my $pt = $pk-&gt;decrypt($ciphertext);

   <b>sign_message</b>
        my $pk = Crypt::PK::ECC-&gt;new($priv_key_filename);
        my $signature = $priv-&gt;sign_message($message);
        #or
        my $signature = $priv-&gt;sign_message($message, $hash_name);

        #NOTE: $hash_name can be 'SHA1' (DEFAULT), 'SHA256' or any other hash supported by Crypt::Digest

   <b>sign_message_rfc7518</b>
       <u>Since:</u> <u>CryptX-0.024</u>

       Same  as  sign_message  only  the signature format is as defined by &lt;https://tools.ietf.org/html/rfc7518&gt;
       (JWA - JSON Web Algorithms).

       <b>BEWARE:</b> This creates signatures according to the structure that RFC 7518 describes but does not apply the
       RFC logic for the hashing algorithm selection. You'll still need to specify, e.g., SHA256 for a P-256 key
       to get a fully RFC-7518-compliant signature.

   <b>verify_message</b>
        my $pk = Crypt::PK::ECC-&gt;new($pub_key_filename);
        my $valid = $pub-&gt;verify_message($signature, $message)
        #or
        my $valid = $pub-&gt;verify_message($signature, $message, $hash_name);

        #NOTE: $hash_name can be 'SHA1' (DEFAULT), 'SHA256' or any other hash supported by Crypt::Digest

   <b>verify_message_rfc7518</b>
       <u>Since:</u> <u>CryptX-0.024</u>

       Same as verify_message only the signature format is as defined  by  &lt;https://tools.ietf.org/html/rfc7518&gt;
       (JWA - JSON Web Algorithms).

       <b>BEWARE:</b>  This  verifies  signatures according to the structure that RFC 7518 describes but does not apply
       the RFC logic for the hashing algorithm selection. You'll still need to specify, e.g., SHA256 for a P-256
       key to get a fully RFC-7518-compliant signature.

   <b>sign_hash</b>
        my $pk = Crypt::PK::ECC-&gt;new($priv_key_filename);
        my $signature = $priv-&gt;sign_hash($message_hash);

       <u>Since:</u> <u>CyrptX-0.081</u>

   <b>sign_hash_eth</b>
       Same as sign_hash only the signature format is as defined by Ethereum.  32 byte r value, 32 byte s value,
       1 recovery byte (27 or 28)

   <b>sign_hash_rfc7518</b>
       <u>Since:</u> <u>CryptX-0.059</u>

       Same as sign_hash only the signature format is as defined by &lt;https://tools.ietf.org/html/rfc7518&gt; (JWA -
       JSON Web Algorithms).

   <b>verify_hash</b>
        my $pk = Crypt::PK::ECC-&gt;new($pub_key_filename);
        my $valid = $pub-&gt;verify_hash($signature, $message_hash);

   <b>verify_hash_rfc7518</b>
       <u>Since:</u> <u>CyrptX-0.081</u>

   <b>verify_hash_eth</b>
       Same as verify_hash only the signature format is as defined  by  Ethereum.   Compatible  with  signatures
       generated by sign_hash_eth.

   <b>recovery_pub_eth</b>
       Alternative  method  to verify a signature with recovery of the public key.  Mainly used for in Ethereum-
       like blockchain networks.  This method will recover public key from ECDSA signature  in  Ethereum  format
       (see sign_hash_eth).

        my $pk = Crypt::PK::ECC-&gt;new($priv_key_filename);
        my $signature = $pk-&gt;sign_hash_eth($message_hash);
        my $pub_key = $pk-&gt;recovery_pub_eth($sig, $hash)

   <b>recovery_pub</b>
       Same  logic as recovery_pub_eth except, but compatible with sign_hash signature. The main difference that
       <b>$recid</b> is required, because <b>sign_hash</b> signature doesn't contain parity bit, so you  need  to  specify  it
       explicitly.

        my $pk = Crypt::PK::ECC-&gt;new($priv_key_filename);
        my $signature = $pk-&gt;sign_hash($message_hash);
        my $pub_key = $pk-&gt;recovery_pub($signature, $message_hash, $recid)

   <b>recovery_pub_rfc7518</b>
       Same  logic  as  recovery_pub_eth  except,  but  compatible  with  sign_hash_refc7518 signature. The main
       difference that <b>$recid</b> is required, because rfc7518 signature doesn't contain parity bit, so you need  to
       specify it explicitly.

        my $pk = Crypt::PK::ECC-&gt;new($priv_key_filename);
        my $signature = $pk-&gt;sign_hash_rfc7518($message_hash);
        my $pub_key = $pk-&gt;recovery_pub_rfc7518($signature, $message_hash, $recid)

       <u>Since:</u> <u>CryptX-0.059</u>

       Same as verify_hash only the signature format is as defined by &lt;https://tools.ietf.org/html/rfc7518&gt; (JWA
       - JSON Web Algorithms).

   <b>shared_secret</b>
         # Alice having her priv key $pk and Bob's public key $pkb
         my $pk  = Crypt::PK::ECC-&gt;new($priv_key_filename);
         my $pkb = Crypt::PK::ECC-&gt;new($pub_key_filename);
         my $shared_secret = $pk-&gt;shared_secret($pkb);

         # Bob having his priv key $pk and Alice's public key $pka
         my $pk = Crypt::PK::ECC-&gt;new($priv_key_filename);
         my $pka = Crypt::PK::ECC-&gt;new($pub_key_filename);
         my $shared_secret = $pk-&gt;shared_secret($pka);  # same value as computed by Alice

   <b>is_private</b>
        my $rv = $pk-&gt;is_private;
        # 1 .. private key loaded
        # 0 .. public key loaded
        # undef .. no key loaded

   <b>size</b>
        my $size = $pk-&gt;size;
        # returns key size in bytes or undef if no key loaded

   <b>key2hash</b>
        my $hash = $pk-&gt;key2hash;

        # returns hash like this (or undef if no key loaded):
        {
          size           =&gt; 20, # integer: key (curve) size in bytes
          type           =&gt; 1,  # integer: 1 .. private, 0 .. public
          #curve parameters
          curve_A        =&gt; "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC",
          curve_B        =&gt; "1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45",
          curve_bits     =&gt; 160,
          curve_bytes    =&gt; 20,
          curve_cofactor =&gt; 1,
          curve_Gx       =&gt; "4A96B5688EF573284664698968C38BB913CBFC82",
          curve_Gy       =&gt; "23A628553168947D59DCC912042351377AC5FB32",
          curve_name     =&gt; "secp160r1",
          curve_order    =&gt; "0100000000000000000001F4C8F927AED3CA752257",
          curve_prime    =&gt; "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF",
          #private key
          k              =&gt; "B0EE84A749FE95DF997E33B8F333E12101E824C3",
          #public key point coordinates
          pub_x          =&gt; "5AE1ACE3ED0AEA9707CE5C0BCE014F6A2F15023A",
          pub_y          =&gt; "895D57E992D0A15F88D6680B27B701F615FCDC0F",
        }

   <b>curve2hash</b>
       <u>Since:</u> <u>CryptX-0.024</u>

        my $crv = $pk-&gt;curve2hash;

        # returns a hash that can be passed to: $pk-&gt;generate_key($crv)
        {
          A        =&gt; "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC",
          B        =&gt; "1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45",
          cofactor =&gt; 1,
          Gx       =&gt; "4A96B5688EF573284664698968C38BB913CBFC82",
          Gy       =&gt; "23A628553168947D59DCC912042351377AC5FB32",
          order    =&gt; "0100000000000000000001F4C8F927AED3CA752257",
          prime    =&gt; "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF",
        }

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>ecc_encrypt</b>
       Elliptic  Curve  Diffie-Hellman  (ECDH)  encryption  as  implemented by libtomcrypt. See method "encrypt"
       below.

        my $ct = ecc_encrypt($pub_key_filename, $message);
        #or
        my $ct = ecc_encrypt(\$buffer_containing_pub_key, $message);
        #or
        my $ct = ecc_encrypt($pub_key_filename, $message, $hash_name);

        #NOTE: $hash_name can be 'SHA1' (DEFAULT), 'SHA256' or any other hash supported by Crypt::Digest

       ECCDH Encryption is performed by producing a random key, hashing it, and XOR'ing the digest  against  the
       plaintext.

   <b>ecc_decrypt</b>
       Elliptic  Curve  Diffie-Hellman  (ECDH)  decryption  as  implemented by libtomcrypt. See method "decrypt"
       below.

        my $pt = ecc_decrypt($priv_key_filename, $ciphertext);
        #or
        my $pt = ecc_decrypt(\$buffer_containing_priv_key, $ciphertext);

   <b>ecc_sign_message</b>
       Elliptic Curve Digital Signature Algorithm (ECDSA) -  signature  generation.  See  method  "sign_message"
       below.

        my $sig = ecc_sign_message($priv_key_filename, $message);
        #or
        my $sig = ecc_sign_message(\$buffer_containing_priv_key, $message);
        #or
        my $sig = ecc_sign_message($priv_key, $message, $hash_name);

   <b>ecc_verify_message</b>
       Elliptic  Curve Digital Signature Algorithm (ECDSA) - signature verification. See method "verify_message"
       below.

        ecc_verify_message($pub_key_filename, $signature, $message) or die "ERROR";
        #or
        ecc_verify_message(\$buffer_containing_pub_key, $signature, $message) or die "ERROR";
        #or
        ecc_verify_message($pub_key, $signature, $message, $hash_name) or die "ERROR";

   <b>ecc_sign_hash</b>
       Elliptic Curve Digital Signature Algorithm (ECDSA) - signature generation. See method "sign_hash" below.

        my $sig = ecc_sign_hash($priv_key_filename, $message_hash);
        #or
        my $sig = ecc_sign_hash(\$buffer_containing_priv_key, $message_hash);

   <b>ecc_verify_hash</b>
       Elliptic Curve Digital Signature Algorithm (ECDSA) - signature  verification.  See  method  "verify_hash"
       below.

        ecc_verify_hash($pub_key_filename, $signature, $message_hash) or die "ERROR";
        #or
        ecc_verify_hash(\$buffer_containing_pub_key, $signature, $message_hash) or die "ERROR";

   <b>ecc_shared_secret</b>
       Elliptic curve Diffie-Hellman (ECDH) - construct a Diffie-Hellman shared secret with a private and public
       ECC key. See method "shared_secret" below.

        #on Alice side
        my $shared_secret = ecc_shared_secret('Alice_priv_ecc1.der', 'Bob_pub_ecc1.der');

        #on Bob side
        my $shared_secret = ecc_shared_secret('Bob_priv_ecc1.der', 'Alice_pub_ecc1.der');

</pre><h4><b>OpenSSL</b> <b>interoperability</b></h4><pre>
        ### let's have:
        # ECC private key in PEM format - eckey.priv.pem
        # ECC public key in PEM format  - eckey.pub.pem
        # data file to be signed - input.data

   <b>Sign</b> <b>by</b> <b>OpenSSL,</b> <b>verify</b> <b>by</b> <b>Crypt::PK::ECC</b>
       Create signature (from commandline):

        openssl dgst -sha1 -sign eckey.priv.pem -out input.sha1-ec.sig input.data

       Verify signature (Perl code):

        use Crypt::PK::ECC;
        use Crypt::Digest 'digest_file';
        use Crypt::Misc 'read_rawfile';

        my $pkec = Crypt::PK::ECC-&gt;new("eckey.pub.pem");
        my $signature = read_rawfile("input.sha1-ec.sig");
        my $valid = $pkec-&gt;verify_hash($signature, digest_file("SHA1", "input.data"), "SHA1", "v1.5");
        print $valid ? "SUCCESS" : "FAILURE";

   <b>Sign</b> <b>by</b> <b>Crypt::PK::ECC,</b> <b>verify</b> <b>by</b> <b>OpenSSL</b>
       Create signature (Perl code):

        use Crypt::PK::ECC;
        use Crypt::Digest 'digest_file';
        use Crypt::Misc 'write_rawfile';

        my $pkec = Crypt::PK::ECC-&gt;new("eckey.priv.pem");
        my $signature = $pkec-&gt;sign_hash(digest_file("SHA1", "input.data"), "SHA1", "v1.5");
        write_rawfile("input.sha1-ec.sig", $signature);

       Verify signature (from commandline):

        openssl dgst -sha1 -verify eckey.pub.pem -signature input.sha1-ec.sig input.data

   <b>Keys</b> <b>generated</b> <b>by</b> <b>Crypt::PK::ECC</b>
       Generate keys (Perl code):

        use Crypt::PK::ECC;
        use Crypt::Misc 'write_rawfile';

        my $pkec = Crypt::PK::ECC-&gt;new;
        $pkec-&gt;generate_key('secp160k1');
        write_rawfile("eckey.pub.der",  $pkec-&gt;export_key_der('public'));
        write_rawfile("eckey.priv.der", $pkec-&gt;export_key_der('private'));
        write_rawfile("eckey.pub.pem",  $pkec-&gt;export_key_pem('public'));
        write_rawfile("eckey.priv.pem", $pkec-&gt;export_key_pem('private'));
        write_rawfile("eckey-passwd.priv.pem", $pkec-&gt;export_key_pem('private', 'secret'));

       Use keys by OpenSSL:

        openssl ec -in eckey.priv.der -text -inform der
        openssl ec -in eckey.priv.pem -text
        openssl ec -in eckey-passwd.priv.pem -text -inform pem -passin pass:secret
        openssl ec -in eckey.pub.der -pubin -text -inform der
        openssl ec -in eckey.pub.pem -pubin -text

   <b>Keys</b> <b>generated</b> <b>by</b> <b>OpenSSL</b>
       Generate keys:

        openssl ecparam -param_enc explicit -name prime192v3 -genkey -out eckey.priv.pem
        openssl ec -param_enc explicit -in eckey.priv.pem -out eckey.pub.pem -pubout
        openssl ec -param_enc explicit -in eckey.priv.pem -out eckey.priv.der -outform der
        openssl ec -param_enc explicit -in eckey.priv.pem -out eckey.pub.der -outform der -pubout
        openssl ec -param_enc explicit -in eckey.priv.pem -out eckey.privc.der -outform der -conv_form compressed
        openssl ec -param_enc explicit -in eckey.priv.pem -out eckey.pubc.der -outform der -pubout -conv_form compressed
        openssl ec -param_enc explicit -in eckey.priv.pem -passout pass:secret -des3 -out eckey-passwd.priv.pem

       Load keys (Perl code):

        use Crypt::PK::ECC;

        my $pkec = Crypt::PK::ECC-&gt;new;
        $pkec-&gt;import_key("eckey.pub.der");
        $pkec-&gt;import_key("eckey.pubc.der");
        $pkec-&gt;import_key("eckey.priv.der");
        $pkec-&gt;import_key("eckey.privc.der");
        $pkec-&gt;import_key("eckey.pub.pem");
        $pkec-&gt;import_key("eckey.priv.pem");
        $pkec-&gt;import_key("eckey-passwd.priv.pem", "secret");

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   &lt;https://en.wikipedia.org/wiki/Elliptic_curve_cryptography&gt;

       •   &lt;https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman&gt;

       •   &lt;https://en.wikipedia.org/wiki/ECDSA&gt;

perl v5.40.0                                       2025-02-15                                <u>Crypt::PK::<a href="../man3pm/ECC.3pm.html">ECC</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>