<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypt::X509 - Parse a X.509 certificate</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcrypt-x509-perl">libcrypt-x509-perl_0.55-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Crypt::X509 - Parse a X.509 certificate

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Crypt::X509;

        $decoded = Crypt::X509-&gt;new( cert =&gt; $cert );

        $subject_email = $decoded-&gt;subject_email;
        print "do not use after: ".gmtime($decoded-&gt;not_after)." GMT\n";

</pre><h4><b>REQUIRES</b></h4><pre>
       Convert::ASN1

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Crypt::X509</b> parses X.509 certificates. Methods are provided for accessing most certificate elements.

       It is based on the generic ASN.1 module by Graham Barr, on the <u>x509decode</u> example by Norbert Klasen and
       contributions on the perl-ldap-dev-Mailinglist by Chriss Ridd.

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
   <b>new</b> <b>(</b> <b>OPTIONS</b> <b>)</b>
       Creates and returns a parsed X.509 certificate hash, containing the parsed contents. The data is
       organised as specified in RFC 2459.  By default only the first ASN.1 Layer is decoded. Nested decoding is
       done automagically through the data access methods.

       cert =&gt; $certificate
           A   variable   containing   the   DER   formatted   certificate  to  be  parsed  (eg.  as  stored  in
           "usercertificate;binary" attribute in an LDAP-directory).

         use Crypt::X509;
         use Data::Dumper;

         $decoded= Crypt::X509-&gt;new(cert =&gt; $cert);

         print Dumper($decoded);

</pre><h4><b>METHODS</b></h4><pre>
   <b>error</b>
       Returns the last error from parsing, "undef" when no error occured.  This  error  is  updated  on  deeper
       parsing with the data access methods.

         $decoded= Crypt::X509-&gt;new(cert =&gt; $cert);
         if ($decoded-&gt;error) {
           warn "Error on parsing Certificate:".$decoded-&gt;error;
         }

</pre><h4><b>DATA</b> <b>ACCESS</b> <b>METHODS</b></h4><pre>
       You  can  access  all  parsed data directly from the returned hash. For convenience the following methods
       have been implemented to give quick access to the most-used certificate attributes.

   <b>version</b>
       Returns the certificate's version as an integer.  NOTE that version is defined as an Integer  where  0  =
       v1, 1 = v2, and 2 = v3.

   <b>version_string</b>
       Returns the certificate's version as a string value.

   <b>serial</b>
       returns  the  serial  number  (integer  or  Math::BigInt  Object, that gets automagic evaluated in scalar
       context) from the certificate

         $decoded= Crypt::X509-&gt;new(cert =&gt; $cert);
         print "Certificate has serial number:".$decoded-&gt;serial."\n";

   <b>not_before</b>
       returns the GMT-timestamp of the certificate's beginning date of validity.  If the Certificate holds this
       Entry in utcTime, it is guaranteed by the RFC to been correct.

       As utcTime is limited to 32-bit values (like unix-timestamps) newer certificates hold  the  timesamps  as
       "generalTime"-entries.  <b>The</b>  <b>contents</b>  <b>of</b>  <b>"generalTime"-entries</b>  <b>are</b> <b>not</b> <b>well</b> <b>defined</b> <b>in</b> <b>the</b> <b>RFC</b> <b>and</b> <b>are</b>
       <b>returned</b> <b>by</b> <b>this</b> <b>module</b> <b>unmodified</b>, if no utcTime-entry is found.

         $decoded= Crypt::X509-&gt;new(cert =&gt; $cert);
         if ($decoded-&gt;notBefore &lt; time()) {
           warn "Certificate: not yet valid!";
         }

   <b>not_after</b>
       returns the GMT-timestamp of the certificate's ending date of validity.  If the  Certificate  holds  this
       Entry in utcTime, it is guaranteed by the RFC to been correct.

       As  utcTime  is  limited to 32-bit values (like unix-timestamps) newer certificates hold the timesamps as
       "generalTime"-entries. <b>The</b> <b>contents</b> <b>of</b> <b>"generalTime"-entries</b> <b>are</b> <b>not</b> <b>well</b> <b>defined</b>  <b>in</b>  <b>the</b>  <b>RFC</b>  <b>and</b>  <b>are</b>
       <b>returned</b> <b>by</b> <b>this</b> <b>module</b> <b>unmodified</b>, if no utcTime-entry is found.

         $decoded= Crypt::X509-&gt;new(cert =&gt; $cert);
         print "Certificate expires on ".gmtime($decoded-&gt;not_after)." GMT\n";

   <b>signature</b>
       Return's the certificate's signature in binary DER format.

   <b>pubkey</b>
       Returns the certificate's public key in binary DER format.

   <b>pubkey_size</b>
       Returns the certificate's public key size.

   <b>pubkey_algorithm</b>
       Returns the algorithm as OID string which the public key was created with.

   <b>PubKeyAlg</b>
       returns the subject public key encryption algorithm (e.g. 'RSA') as string.

         $decoded= Crypt::X509-&gt;new(cert =&gt; $cert);
         print "Certificate public key is encrypted with:".$decoded-&gt;PubKeyAlg."\n";

         Example Output: Certificate public key is encrypted with: RSA

   <b>pubkey_components</b>
       If this certificate contains an RSA key, this function returns a hashref { modulus =&gt; $m, exponent =&gt; $e)
       from that key; each value in the hash will be an integer scalar or a Math::BigInt object.

       For other pubkey types, it returns undef (implementations welcome!).

   <b>sig_algorithm</b>
       Returns the certificate's signature algorithm as OID string

         $decoded= Crypt::X509-&gt;new(cert =&gt; $cert);
         print "Certificate signature is encrypted with:".$decoded-&gt;sig_algorithm."\n";&gt;

         Example Output: Certificate signature is encrypted with: 1.2.840.113549.1.1.5

   <b>SigEncAlg</b>
       returns the signature encryption algorithm (e.g. 'RSA') as string.

         $decoded= Crypt::X509-&gt;new(cert =&gt; $cert);
         print "Certificate signature is encrypted with:".$decoded-&gt;SigEncAlg."\n";

         Example Output: Certificate signature is encrypted with: RSA

   <b>SigHashAlg</b>
       returns the signature hashing algorithm (e.g. 'SHA1') as string.

         $decoded= Crypt::X509-&gt;new(cert =&gt; $cert);
         print "Certificate signature is hashed with:".$decoded-&gt;SigHashAlg."\n";

         Example Output: Certificate signature is encrypted with: SHA1

   <b>Subject</b>
       returns  a pointer to an array of strings containing subject nameparts of the certificate. Attributenames
       for the most common Attributes are translated from the OID-Numbers, unknown numbers are output verbatim.

         $decoded= Convert::ASN1::X509-&gt;new($cert);
         print "DN for this Certificate is:".join(',',@{$decoded-&gt;Subject})."\n";

   <b>SubjectRaw</b>
       Returns the RDNs as list of hashes, values are stringified but OIDs are not translated.

       If a component contains a SET, the component will become an array of hashes on the second level.

   <b>SubjectSequence</b>
       Returns the subject as returned from the ASN1 parser.

   <b>subject_country</b>
       Returns the string value for subject's country (= the value with the
        OID 2.5.4.6 or in DN Syntax everything after "C=").  Only  the  first  entry  is  returned.  "undef"  if
       subject contains no country attribute.

   <b>subject_locality</b>
       Returns  the  string  value  for  subject's  locality  (=  the value with the OID 2.5.4.7 or in DN Syntax
       everything after "l=").  Only the first entry is  returned.  "undef"  if  subject  contains  no  locality
       attribute.

   <b>subject_state</b>
       Returns  the  string  value  for  subject's  state or province (= the value with the OID 2.5.4.8 or in DN
       Syntax everything after "S=").  Only the first entry is returned. "undef" if subject  contains  no  state
       attribute.

   <b>subject_org</b>
       Returns  the  string  value for subject's organization (= the value with the OID 2.5.4.10 or in DN Syntax
       everything after "O=").  Only the first entry is returned. "undef" if subject  contains  no  organization
       attribute.

   <b>subject_ou</b>
       Returns  the  string  value for subject's organizational unit (= the value with the OID 2.5.4.11 or in DN
       Syntax everything after "OU=").  Only the first  entry  is  returned.  "undef"  if  subject  contains  no
       organization attribute.

   <b>subject_cn</b>
       Returns  the  string  value  for  subject's common name (= the value with the OID 2.5.4.3 or in DN Syntax
       everything after "CN=").  Only the first entry is returned. "undef" if subject contains  no  common  name
       attribute.

   <b>subject_email</b>
       Returns the string value for subject's email address (= the value with the OID 1.2.840.113549.1.9.1 or in
       DN  Syntax  everything  after  "emailAddress=").   Only  the  first entry is returned. "undef" if subject
       contains no email attribute.

   <b>Issuer</b>
       returns a pointer to an array of strings building the DN of the certificate issuer (= the DN of the  CA).
       Attributenames  for  the  most common Attributes are translated from the OID-Numbers, unknown numbers are
       output verbatim.

         $decoded= Crypt::X509-&gt;new($cert);
         print "Certificate was issued by:".join(',',@{$decoded-&gt;Issuer})."\n";

   <b>issuer_cn</b>
       Returns the string value for issuer's common name (= the value with the  OID  2.5.4.3  or  in  DN  Syntax
       everything  after  "CN=").   Only  the first entry is returned. "undef" if issuer contains no common name
       attribute.

   <b>issuer_country</b>
       Returns the string value for issuer's country (= the value with the
        OID 2.5.4.6 or in DN Syntax everything after "C=").  Only the first entry is returned. "undef" if issuer
       contains no country attribute.

   <b>issuer_state</b>
       Returns the string value for issuer's state or province (= the value with the OID 2.5.4.8 or in DN Syntax
       everything after "S=").  Only the first entry is returned. "undef" if issuer contains no state attribute.

   <b>issuer_locality</b>
       Returns the string value for issuer's locality (= the  value  with  the  OID  2.5.4.7  or  in  DN  Syntax
       everything  after  "L=").   Only  the  first  entry  is  returned. "undef" if issuer contains no locality
       attribute.

   <b>issuer_org</b>
       Returns the string value for issuer's organization (= the value with the OID 2.5.4.10  or  in  DN  Syntax
       everything  after  "O=").   Only  the first entry is returned. "undef" if issuer contains no organization
       attribute.

   <b>issuer_email</b>
       Returns the string value for issuer's email address (= the value with the OID 1.2.840.113549.1.9.1 or  in
       DN  Syntax everything after "E=").  Only the first entry is returned. "undef" if issuer contains no email
       attribute.

   <b>KeyUsage</b>
       returns a pointer to an array of strings describing the valid Usages for  this  certificate.  "undef"  is
       returned, when the extension is not set in the certificate.

       If the extension is marked critical, this is also reported.

         $decoded= Crypt::X509-&gt;new(cert =&gt; $cert);
         print "Allowed usages for this Certificate are:\n".join("\n",@{$decoded-&gt;KeyUsage})."\n";

         Example Output:
         Allowed usages for this Certificate are:
         critical
         digitalSignature
         keyEncipherment
         dataEncipherment

   <b>ExtKeyUsage</b>
       returns  a  pointer  to  an  array  of  ExtKeyUsage  strings (or OIDs for unknown OIDs) or "undef" if the
       extension is  not  filled.  OIDs  of  the  following  ExtKeyUsages  are  known:  serverAuth,  clientAuth,
       codeSigning, emailProtection, timeStamping, OCSPSigning

       If the extension is marked critical, this is also reported.

         $decoded= Crypt::X509-&gt;new($cert);
         print "ExtKeyUsage extension of this Certificates is: ", join(", ", @{$decoded-&gt;ExtKeyUsage}), "\n";

         Example Output: ExtKeyUsage extension of this Certificates is: critical, serverAuth

   <b>SubjectAltName</b>
       returns  a pointer to an array of strings containing alternative Subjectnames or "undef" if the extension
       is not filled. Usually this Extension holds the e-Mail address for person-certificates or  DNS-Names  for
       server certificates.

       It also pre-pends the field type (ie rfc822Name) to the returned value.

         $decoded= Crypt::X509-&gt;new($cert);
         print "E-Mail or Hostnames in this Certificates is/are:", join(", ", @{$decoded-&gt;SubjectAltName}), "\n";

         Example Output: E-Mail or Hostnames in this Certificates is/are: rfc822Name=<a href="mailto:user@server.com">user@server.com</a>

   <b>DecodedSubjectAltNames</b>
       Returns a pointer to an array of strings containing all the alternative subject name extensions.

       Each  such  extension  is  represented  as a decoded ASN.1 value, i.e. a pointer to a list of pointers to
       objects, each object having a single key with the type of the alternative name and a  value  specific  to
       that type.

       Example return value:

         [
           [
             {
               'directoryName' =&gt; {
                 'rdnSequence' =&gt; [
                   [
                     {
                       'value' =&gt; { 'utf8String' =&gt; 'example' },
                       'type' =&gt; '2.5.4.3'
                     }
                   ]
                 ]
               }
             },
             {
               'dNSName' =&gt; 'example.com'
             }
           ]
         ]

   <b>authorityCertIssuer</b>
       returns a pointer to an array of strings building the DN of the Authority Cert Issuer. Attributenames for
       the  most  common  Attributes  are  translated from the OID-Numbers, unknown numbers are output verbatim.
       undef if the extension is not set in the certificate.

         $decoded= Crypt::X509-&gt;new($cert);
         print "Certificate was authorised by:".join(',',@{$decoded-&gt;authorityCertIssuer})."\n";

   <b>authority_serial</b>
       Returns the authority's certificate serial number.

   <b>key_identifier</b>
       Returns the authority key identifier or undef if it is a rooted cert

   <b>authority_cn</b>
       Returns the authority's ca.

   <b>authority_country</b>
       Returns the authority's country.

   <b>authority_state</b>
       Returns the authority's state.

   <b>authority_locality</b>
       Returns the authority's locality.

   <b>authority_org</b>
       Returns the authority's organization.

   <b>authority_email</b>
       Returns the authority's email.

   <b>CRLDistributionPoints</b>
       Returns the CRL distribution points as an array of strings (with one value usually)

   <b>CRLDistributionPoints2</b>
       Returns the CRL distribution points as an array of hashes (allowing for some variations)

   <b>CertificatePolicies</b>
       Returns the CertificatePolicies as an array of strings

   <b>EntrustVersionInfo</b>
       Returns the EntrustVersion as a string

           print "Entrust Version: ", $decoded-&gt;EntrustVersion, "\n";

           Example Output: Entrust Version: V7.0

   <b>SubjectDirectoryAttributes</b>
       Returns the SubjectDirectoryAttributes as an array of key = value pairs, to include a data type

           print "Subject Directory Attributes: ", join( ', ' , @{ $decoded-&gt;SubjectDirectoryAttributes } ), "\n";

           Example Output: Subject Directory Attributes: 1.2.840.113533.7.68.29 = 7 (integer)

   <b>BasicConstraints</b>
       Returns the BasicConstraints as an array and the criticallity pre-pended.

   <b>subject_keyidentifier</b>
       Returns the subject key identifier from the extensions.

   <b>SubjectInfoAccess</b>
       Returns the SubjectInfoAccess as an array of hashes with key=value pairs.

               print "Subject Info Access: ";
               if ( defined $decoded-&gt;SubjectInfoAccess ) {
                   my %SIA = $decoded-&gt;SubjectInfoAccess;
                   for my $key ( keys %SIA ) {
                       print "\n\t$key: \n\t";
                       print join( "\n\t" , @{ $SIA{$key} } ), "\n";
                   }
               } else { print "\n" }

           Example Output:
               Subject Info Access:
                   1.3.6.1.5.5.7.48.5:
                   uniformResourceIdentifier = <a href="http://pki.treas.gov/root_sia.p7c">http://pki.treas.gov/root_sia.p7c</a>
                   uniformResourceIdentifier = ldap://ldap.treas.gov/ou=US%20Treasury%20Root%20CA,ou=Certification%20Authorities,ou=Department%20of%20the%20Treasury,o=U.S.%20Government,c=US?cACertificate;binary,crossCertificatePair;binary

   <b>PGPExtension</b>
       Returns    the     creation     timestamp     of     the     corresponding     OpenPGP     key.      (see
       <a href="http://www.imc.org/ietf-openpgp/mail-archive/msg05320.html">http://www.imc.org/ietf-openpgp/mail-archive/msg05320.html</a>)

               print "PGPExtension: ";
               if ( defined $decoded-&gt;PGPExtension ) {
                   my $creationtime = $decoded-&gt;PGPExtension;
                   printf "\n\tcorresponding OpenPGP Creation Time: ", $creationtime, "\n";
                       }

           Example Output:
               PGPExtension:
                           whatever

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See the examples of "Convert::ASN1" and the &lt;<a href="mailto:perl-ldap@perl.org">perl-ldap@perl.org</a>&gt; Mailing List.  An example on how to load
       certificates can be found in <u>t\Crypt-X509.t</u>.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       This  module is based on the x509decode script, which was contributed to Convert::ASN1 in 2002 by Norbert
       Klasen.

</pre><h4><b>AUTHORS</b></h4><pre>
       Mike   Jackson    &lt;<a href="mailto:mj@sci.fi">mj@sci.fi</a>&gt;,    Alexander    Jung    &lt;<a href="mailto:alexander.w.jung@gmail.com">alexander.w.jung@gmail.com</a>&gt;,    Duncan    Segrest
       &lt;<a href="mailto:duncan@gigageek.info">duncan@gigageek.info</a>&gt; Oliver Welter  &lt;<a href="mailto:owelter@whiterabbitsecurity.com">owelter@whiterabbitsecurity.com</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2005 Mike Jackson &lt;<a href="mailto:mj@sci.fi">mj@sci.fi</a>&gt;.  Copyright (c) 2001-2002 Norbert Klasen, DAASI International
       GmbH.

       All  rights  reserved.  This program is free software; you can redistribute it and/or modify it under the
       same terms as Perl itself.

perl v5.36.0                                       2023-01-15                                   <u>Crypt::<a href="../man3pm/X509.3pm.html">X509</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>