<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moose::Manual::Concepts - Moose OO concepts</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmoose-perl">libmoose-perl_2.2207-1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Moose::Manual::Concepts - Moose OO concepts

</pre><h4><b>VERSION</b></h4><pre>
       version 2.2207

</pre><h4><b>MOOSE</b> <b>CONCEPTS</b> <b>(VS</b> <b>"OLD</b> <b>SCHOOL"</b> <b>Perl)</b></h4><pre>
       In the past, you may not have thought too much about the difference between packages and classes,
       attributes and methods, constructors and methods, etc. With Moose, these are all conceptually separate,
       though under the hood they're implemented with plain old Perl.

       Our meta-object protocol (aka MOP) provides well-defined introspection features for each of those
       concepts, and Moose in turn provides distinct sugar for each of them. Moose also introduces additional
       concepts such as roles, method modifiers, and declarative delegation.

       Knowing what these concepts mean in Moose-speak, and how they used to be done in old school Perl 5 OO is
       a good way to start learning to use Moose.

   <b>Class</b>
       When you say "use Moose" in a package, you are making your package a class. At its simplest, a class will
       consist simply of attributes and/or methods. It can also include roles, method modifiers, and more.

       A class <u>has</u> zero or more <b>attributes</b>.

       A class <u>has</u> zero or more <b>methods</b>.

       A class <u>has</u> zero or more superclasses (aka parent classes). A class inherits from its superclass(es).

       A class <u>has</u> zero or more <b>method</b> <b>modifiers</b>. These modifiers can apply to its own methods or methods that
       are inherited from its ancestors.

       A class <u>does</u> (and <u>consumes</u>) zero or more <b>roles</b>.

       A class <u>has</u> a <b>constructor</b> and a <b>destructor</b>. These are provided for you "for free" by Moose.

       The <b>constructor</b> accepts named parameters corresponding to the class's attributes and uses them to
       initialize an <b>object</b> <b>instance</b>.

       A class <u>has</u> a <b>metaclass</b>, which in turn has <b>meta-attributes</b>, <b>meta-methods</b>, and <b>meta-roles</b>. This metaclass
       <u>describes</u> the class.

       A class is usually analogous to a category of nouns, like "People" or "Users".

         package Person;

         use Moose;
         # now it's a Moose class!

   <b>Attribute</b>
       An attribute is a property of the class that defines it. It <u>always</u> has a name, and it <u>may</u> <u>have</u> a number
       of other properties.

       These properties can include a read/write flag, a <b>type</b>, accessor method names, <b>delegations</b>, a default
       value, and more.

       Attributes <u>are</u> <u>not</u> methods, but defining them causes various accessor methods to be created. At a
       minimum, a normal attribute will have a reader accessor method. Many attributes have other methods, such
       as a writer method, a clearer method, or a predicate method ("has it been set?").

       An attribute may also define <b>delegations</b>, which will create additional methods based on the delegation
       mapping.

       By default, Moose stores attributes in the object instance, which is a hashref, <u>but</u> <u>this</u> <u>is</u> <u>invisible</u> <u>to</u>
       <u>the</u> <u>author</u> <u>of</u> <u>a</u> <u>Moose-based</u> <u>class</u>!  It is best to think of Moose attributes as "properties" of the <u>opaque</u>
       <b>object</b> <b>instance</b>. These properties are accessed through well-defined accessor methods.

       An attribute is something that the class's members have. For example, People have first and last names.
       Users have passwords and last login datetimes.

         has 'first_name' =&gt; (
             is  =&gt; 'rw',
             isa =&gt; 'Str',
         );

   <b>Method</b>
       A <b>method</b> is very straightforward. Any subroutine you define in your class is a method.

       <b>Methods</b> correspond to verbs, and are what your objects can do. For example, a User can login.

         sub login { ... }

   <b>Role</b>
       A role is something that a class <u>does</u>. We also say that classes <u>consume</u> roles. For example, a Machine
       class might do the Breakable role, and so could a Bone class. A role is used to define some concept that
       cuts across multiple unrelated classes, like "breakability", or "has a color".

       A role <u>has</u> zero or more <b>attributes</b>.

       A role <u>has</u> zero or more <b>methods</b>.

       A role <u>has</u> zero or more <b>method</b> <b>modifiers</b>.

       A role <u>has</u> zero or more <b>required</b> <b>methods</b>.

       A required method is not implemented by the role. Required methods are a way for the role to declare "to
       use this role you must implement this method".

       A role <u>has</u> zero or more <b>excluded</b> <b>roles</b>.

       An excluded role is a role that the role doing the excluding says it cannot be combined with.

       Roles are <u>composed</u> into classes (or other roles). When a role is composed into a class, its attributes
       and methods are "flattened" into the class. Roles <u>do</u> <u>not</u> show up in the inheritance hierarchy. When a
       role is composed, its attributes and methods appear as if they were defined <u>in</u> <u>the</u> <u>consuming</u> <u>class</u>.

       Role are somewhat like mixins or interfaces in other OO languages.

         package Breakable;

         use Moose::Role;

         requires 'break';

         has 'is_broken' =&gt; (
             is  =&gt; 'rw',
             isa =&gt; 'Bool',
         );

         after 'break' =&gt; sub {
             my $self = shift;

             $self-&gt;<a href="../man1/is_broken.1.html">is_broken</a>(1);
         };

   <b>Method</b> <b>modifiers</b>
       A <b>method</b> <b>modifier</b> is a hook that is called when a named method is called. For example, you could say
       "before calling login(), call this modifier first". Modifiers come in different flavors like "before",
       "after", "around", and "augment", and you can apply more than one modifier to a single method.

       Method modifiers are often used as an alternative to overriding a method in a parent class. They are also
       used in roles as a way of modifying methods in the consuming class.

       Under the hood, a method modifier is just a plain old Perl subroutine that gets called before or after
       (or around, etc.) some named method.

         before 'login' =&gt; sub {
             my $self = shift;
             my $pw   = shift;

             warn "Called login() with $pw\n";
         };

   <b>Type</b>
       Moose also comes with a (miniature) type system. This allows you to define types for attributes. Moose
       has a set of built-in types based on the types Perl provides in its core, such as "Str", "Num", "Bool",
       "HashRef", etc.

       In addition, every class name in your application can also be used as a type name.

       Finally, you can define your own types with their own constraints. For example, you could define a
       "PosInt" type, a subtype of "Int" which only allows positive numbers.

   <b>Delegation</b>
       Moose attributes provide declarative syntax for defining delegations. A delegation is a method which in
       turn calls some method on an attribute to do its real work.

   <b>Constructor</b>
       A constructor creates an <b>object</b> <b>instance</b> for the class. In old school Perl, this was usually done by
       defining a method called new() which in turn called "bless" on a reference.

       With Moose, this new() method is created for you, and it simply does the right thing. You should never
       need to define your own constructor!

       Sometimes you want to do something whenever an object is created. In those cases, you can provide a
       BUILD() method in your class. Moose will call this for you after creating a new object.

   <b>Destructor</b>
       This is a special method called when an object instance goes out of scope. You can specialize what your
       class does in this method if you need to, but you usually don't.

       With old school Perl 5, this is the DESTROY() method, but with Moose it is the DEMOLISH() method.

   <b>Object</b> <b>instance</b>
       An object instance is a specific noun in the class's "category". For example, one specific Person or
       User. An instance is created by the class's <b>constructor</b>.

       An instance has values for its attributes. For example, a specific person has a first and last name.

       In old school Perl 5, this is often a blessed hash reference. With Moose, you should never need to know
       what your object instance actually is. (Okay, it's usually a blessed hashref with Moose, too.)

   <b>Moose</b> <b>vs</b> <b>old</b> <b>school</b> <b>summary</b>
       •   Class

           A package with no introspection other than mucking about in the symbol table.

           With Moose, you get well-defined declaration and introspection.

       •   Attributes

           Hand-written accessor methods, symbol table hackery, or a helper module like "Class::Accessor".

           With Moose, these are declaratively defined, and distinct from methods.

       •   Method

           These are pretty much the same in Moose as in old school Perl.

       •   Roles

           "Class::Trait" or "Class::Role", or maybe "mixin.pm".

           With Moose, they're part of the core feature set, and are introspectable like everything else.

       •   Method Modifiers

           Could  only be done through serious symbol table wizardry, and you probably never saw this before (at
           least in Perl 5).

       •   Type

           Hand-written parameter checking in your new() method and accessors.

           With Moose, you define types declaratively, and then use them by name with your attributes.

       •   Delegation

           "Class::Delegation" or "Class::Delegator", but probably even more hand-written code.

           With Moose, this is also declarative.

       •   Constructor

           A new() method which calls "bless" on a reference.

           Comes for free when you define a class with Moose.

       •   Destructor

           A DESTROY() method.

           With Moose, this is called DEMOLISH().

       •   Object Instance

           A blessed reference, usually a hash reference.

           With Moose, this is an opaque thing which has a bunch of attributes and methods, as  defined  by  its
           class.

       •   Immutabilization

           Moose  comes  with  a feature called "immutabilization". When you make your class immutable, it means
           you're done adding methods, attributes, roles, etc. This lets Moose optimize your class with a  bunch
           of  extremely dirty in-place code generation tricks that speed up things like object construction and
           so on.

</pre><h4><b>META</b> <b>WHAT?</b></h4><pre>
       A metaclass is a class that describes classes. With Moose, every class you define gets a  meta()  method.
       The  meta()  method returns a Moose::Meta::Class object, which has an introspection API that can tell you
       about the class it represents.

         my $meta = User-&gt;meta();

         for my $attribute ( $meta-&gt;get_all_attributes ) {
             print $attribute-&gt;name(), "\n";

             if ( $attribute-&gt;has_type_constraint ) {
                 print "  type: ", $attribute-&gt;type_constraint-&gt;name, "\n";
             }
         }

         for my $method ( $meta-&gt;get_all_methods ) {
             print $method-&gt;name, "\n";
         }

       Almost  every  concept  we  defined  earlier  has  a  meta  class,   so   we   have   Moose::Meta::Class,
       Moose::Meta::Attribute,      Moose::Meta::Method,     Moose::Meta::Role,     Moose::Meta::TypeConstraint,
       Moose::Meta::Instance, and so on.

</pre><h4><b>BUT</b> <b>I</b> <b>NEED</b> <b>TO</b> <b>DO</b> <b>IT</b> <b>MY</b> <b>WAY!</b></h4><pre>
       One of the great things about Moose is that if you dig down and find that it does  something  the  "wrong
       way",  you  can change it by extending a metaclass. For example, you can have arrayref based objects, you
       can make your constructors strict (no unknown parameters allowed!), you can define a  naming  scheme  for
       attribute accessors, you can make a class a Singleton, and much, much more.

       Many of these extensions require surprisingly small amounts of code, and once you've done it once, you'll
       never  have  to  hand-code  "your  way  of  doing  things"  again. Instead you'll just load your favorite
       extensions.

         package MyWay::User;

         use Moose;
         use MooseX::StrictConstructor;
         use MooseX::MyWay;

         has ...;

</pre><h4><b>WHAT</b> <b>NEXT?</b></h4><pre>
       So you're sold on Moose. Time to learn how to really use it.

       If you want to see how Moose would translate  directly  into  old  school  Perl  5  OO  code,  check  out
       Moose::Manual::Unsweetened.  This might be helpful for quickly wrapping your brain around some aspects of
       "the Moose way".

       Or you can skip that and jump straight to Moose::Manual::Classes and the rest of the Moose::Manual.

       After that we recommend that you start with the Moose::Cookbook. If you work your  way  through  all  the
       recipes  under the basics section, you should have a pretty good sense of how Moose works, and all of its
       basic OO features.

       After that, check out the Role recipes. If you're really curious, go on and read the Meta  and  Extending
       recipes, but those are mostly there for people who want to be Moose wizards and extend Moose itself.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Stevan Little &lt;<a href="mailto:stevan@cpan.org">stevan@cpan.org</a>&gt;

       •   Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;

       •   Jesse Luehrs &lt;<a href="mailto:doy@cpan.org">doy@cpan.org</a>&gt;

       •   Shawn M Moore &lt;<a href="mailto:sartak@cpan.org">sartak@cpan.org</a>&gt;

       •   יובל קוג'מן (Yuval Kogman) &lt;<a href="mailto:nothingmuch@woobling.org">nothingmuch@woobling.org</a>&gt;

       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   Florian Ragwitz &lt;<a href="mailto:rafl@debian.org">rafl@debian.org</a>&gt;

       •   Hans Dieter Pearcey &lt;<a href="mailto:hdp@cpan.org">hdp@cpan.org</a>&gt;

       •   Chris Prather &lt;<a href="mailto:chris@prather.org">chris@prather.org</a>&gt;

       •   Matt S Trout &lt;<a href="mailto:mstrout@cpan.org">mstrout@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2006 by Infinity Interactive, Inc.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.0                                       2024-10-20                       <u>Moose::Manual::<a href="../man3pm/Concepts.3pm.html">Concepts</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>