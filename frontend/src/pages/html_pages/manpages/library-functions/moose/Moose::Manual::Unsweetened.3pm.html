<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moose::Manual::Unsweetened - Moose idioms in plain old Perl 5 without the sugar</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmoose-perl">libmoose-perl_2.2207-1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Moose::Manual::Unsweetened - Moose idioms in plain old Perl 5 without the sugar

</pre><h4><b>VERSION</b></h4><pre>
       version 2.2207

</pre><h4><b>DESCRIPTION</b></h4><pre>
       If you're trying to figure out just what the heck Moose does, and how it saves you time, you might find
       it helpful to see what Moose is <u>really</u> doing for you. This document shows you the translation from Moose
       sugar back to plain old Perl 5.

</pre><h4><b>CLASSES</b> <b>AND</b> <b>ATTRIBUTES</b></h4><pre>
       First, we define two very small classes the Moose way.

         package Person;

         use DateTime;
         use DateTime::Format::Natural;
         use Moose;
         use Moose::Util::TypeConstraints;

         has name =&gt; (
             is       =&gt; 'rw',
             isa      =&gt; 'Str',
             required =&gt; 1,
         );

         # Moose doesn't know about non-Moose-based classes.
         class_type 'DateTime';

         my $en_parser = DateTime::Format::Natural-&gt;new(
             lang      =&gt; 'en',
             time_zone =&gt; 'UTC',
         );

         coerce 'DateTime'
             =&gt; from 'Str'
             =&gt; via { $en_parser-&gt;parse_datetime($_) };

         has birth_date =&gt; (
             is      =&gt; 'rw',
             isa     =&gt; 'DateTime',
             coerce  =&gt; 1,
             handles =&gt; { birth_year =&gt; 'year' },
         );

         enum 'ShirtSize' =&gt; [qw( s m l xl xxl )];

         has shirt_size =&gt; (
             is      =&gt; 'rw',
             isa     =&gt; 'ShirtSize',
             default =&gt; 'l',
         );

       This is a fairly simple class with three attributes. We also define an enum type to validate t-shirt
       sizes because we don't want to end up with something like "blue" for the shirt size!

         package User;

         use Email::Valid;
         use Moose;
         use Moose::Util::TypeConstraints;

         extends 'Person';

         subtype 'Email'
             =&gt; as 'Str'
             =&gt; where { Email::Valid-&gt;address($_) }
             =&gt; message { "$_ is not a valid email address" };

         has email_address =&gt; (
             is       =&gt; 'rw',
             isa      =&gt; 'Email',
             required =&gt; 1,
         );

       This class subclasses Person to add a single attribute, email address.

       Now we will show what these classes would look like in plain old Perl 5. For the sake of argument, we
       won't use any base classes or any helpers like "Class::Accessor".

         package Person;

         use strict;
         use warnings;

         use Carp qw( confess );
         use DateTime;
         use DateTime::Format::Natural;

         sub new {
             my $class = shift;
             my %p = ref $_[0] ? %{ $_[0] } : @_;

             exists $p{name}
                 or confess 'name is a required attribute';
             $class-&gt;_validate_name( $p{name} );

             exists $p{birth_date}
                 or confess 'birth_date is a required attribute';

             $p{birth_date} = $class-&gt;_coerce_birth_date( $p{birth_date} );
             $class-&gt;_validate_birth_date( $p{birth_date} );

             $p{shirt_size} = 'l'
                 unless exists $p{shirt_size};

             $class-&gt;_validate_shirt_size( $p{shirt_size} );

             return bless \%p, $class;
         }

         sub _validate_name {
             shift;
             my $name = shift;

             local $Carp::CarpLevel = $Carp::CarpLevel + 1;

             defined $name
                 or confess 'name must be a string';
         }

         {
             my $en_parser = DateTime::Format::Natural-&gt;new(
                 lang      =&gt; 'en',
                 time_zone =&gt; 'UTC',
             );

             sub _coerce_birth_date {
                 shift;
                 my $date = shift;

                 return $date unless defined $date &amp;&amp; ! ref $date;

                 my $dt = $en_parser-&gt;parse_datetime($date);

                 return $dt ? $dt : undef;
             }
         }

         sub _validate_birth_date {
             shift;
             my $birth_date = shift;

             local $Carp::CarpLevel = $Carp::CarpLevel + 1;

             $birth_date-&gt;isa('DateTime')
                 or confess 'birth_date must be a DateTime object';
         }

         sub _validate_shirt_size {
             shift;
             my $shirt_size = shift;

             local $Carp::CarpLevel = $Carp::CarpLevel + 1;

             defined $shirt_size
                 or confess 'shirt_size cannot be undef';

             my %sizes = map { $_ =&gt; 1 } qw( s m l xl xxl );

             $sizes{$shirt_size}
                 or confess "$shirt_size is not a valid shirt size (s, m, l, xl, xxl)";
         }

         sub name {
             my $self = shift;

             if (@_) {
                 $self-&gt;_validate_name( $_[0] );
                 $self-&gt;{name} = $_[0];
             }

             return $self-&gt;{name};
         }

         sub birth_date {
             my $self = shift;

             if (@_) {
                 my $date = $self-&gt;_coerce_birth_date( $_[0] );
                 $self-&gt;_validate_birth_date( $date );

                 $self-&gt;{birth_date} = $date;
             }

             return $self-&gt;{birth_date};
         }

         sub birth_year {
             my $self = shift;

             return $self-&gt;birth_date-&gt;year;
         }

         sub shirt_size {
             my $self = shift;

             if (@_) {
                 $self-&gt;_validate_shirt_size( $_[0] );
                 $self-&gt;{shirt_size} = $_[0];
             }

             return $self-&gt;{shirt_size};
         }

       Wow, that was a mouthful! One thing to note is just how much space the data validation code consumes. As
       a result, it's pretty common for Perl 5 programmers to just not bother. Unfortunately, not validating
       arguments leads to surprises down the line ("why is birth_date an email address?").

       Also, did you spot the (intentional) bug?

       It's in the _validate_birth_date() method. We should check that the value in $birth_date is actually
       defined and an object before we go and call isa() on it! Leaving out those checks means our data
       validation code could actually cause our program to die. Oops.

       Note that if we add a superclass to Person we'll have to change the constructor to account for that.

       (As an aside, getting all the little details of what Moose does for you just right in this example was
       really not easy, which emphasizes the point of the example. Moose saves you a lot of work!)

       Now let's see User:

         package User;

         use strict;
         use warnings;

         use Carp qw( confess );
         use Email::Valid;
         use Scalar::Util qw( blessed );

         use parent 'Person';

         sub new {
             my $class = shift;
             my %p = ref $_[0] ? %{ $_[0] } : @_;

             exists $p{email_address}
                 or confess 'email_address is a required attribute';
             $class-&gt;_validate_email_address( $p{email_address} );

             my $self = $class-&gt;SUPER::new(%p);

             $self-&gt;{email_address} = $p{email_address};

             return $self;
         }

         sub _validate_email_address {
             shift;
             my $email_address = shift;

             local $Carp::CarpLevel = $Carp::CarpLevel + 1;

             defined $email_address
                 or confess 'email_address must be a string';

             Email::Valid-&gt;address($email_address)
                 or confess "$email_address is not a valid email address";
         }

         sub email_address {
             my $self = shift;

             if (@_) {
                 $self-&gt;_validate_email_address( $_[0] );
                 $self-&gt;{email_address} = $_[0];
             }

             return $self-&gt;{email_address};
         }

       That one was shorter, but it only has one attribute.

       Between the two classes, we have a whole lot of code that doesn't do much. We could probably simplify
       this by defining some sort of "attribute and validation" hash, like this:

         package Person;

         my %Attr = (
             name =&gt; {
                 required =&gt; 1,
                 validate =&gt; sub { defined $_ },
             },
             birth_date =&gt; {
                 required =&gt; 1,
                 validate =&gt; sub { blessed $_ &amp;&amp; $_-&gt;isa('DateTime') },
             },
             shirt_size =&gt; {
                 required =&gt; 1,
                 validate =&gt; sub { defined $_ &amp;&amp; $_ =~ /^(?:s|m|l|xl|xxl)$/i },
             }
         );

       Then we could define a base class that would accept such a definition and do the right thing. Keep that
       sort of thing up and we're well on our way to writing a half-assed version of Moose!

       Of course, there are CPAN modules that do some of what Moose does, like "Class::Accessor", "Class::Meta",
       and so on. But none of them put together all of Moose's features along with a layer of declarative sugar,
       nor are these other modules designed for extensibility in the same way as Moose. With Moose, it's easy to
       write a MooseX module to replace or extend a piece of built-in functionality.

       Moose is a complete OO package in and of itself, and is part of a rich ecosystem of extensions. It also
       has an enthusiastic community of users and is being actively maintained and developed.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Stevan Little &lt;<a href="mailto:stevan@cpan.org">stevan@cpan.org</a>&gt;

       •   Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;

       •   Jesse Luehrs &lt;<a href="mailto:doy@cpan.org">doy@cpan.org</a>&gt;

       •   Shawn M Moore &lt;<a href="mailto:sartak@cpan.org">sartak@cpan.org</a>&gt;

       •   יובל קוג'מן (Yuval Kogman) &lt;<a href="mailto:nothingmuch@woobling.org">nothingmuch@woobling.org</a>&gt;

       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   Florian Ragwitz &lt;<a href="mailto:rafl@debian.org">rafl@debian.org</a>&gt;

       •   Hans Dieter Pearcey &lt;<a href="mailto:hdp@cpan.org">hdp@cpan.org</a>&gt;

       •   Chris Prather &lt;<a href="mailto:chris@prather.org">chris@prather.org</a>&gt;

       •   Matt S Trout &lt;<a href="mailto:mstrout@cpan.org">mstrout@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2006 by Infinity Interactive, Inc.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.0                                       2024-10-20                    <u>Moose::Manual::<a href="../man3pm/Unsweetened.3pm.html">Unsweetened</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>