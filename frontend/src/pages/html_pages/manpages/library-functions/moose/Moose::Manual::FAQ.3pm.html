<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moose::Manual::FAQ - Frequently asked questions about Moose</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmoose-perl">libmoose-perl_2.2207-1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Moose::Manual::FAQ - Frequently asked questions about Moose

</pre><h4><b>VERSION</b></h4><pre>
       version 2.2207

</pre><h4><b>FREQUENTLY</b> <b>ASKED</b> <b>QUESTIONS</b></h4><pre>
   <b>Module</b> <b>Stability</b>
       <u>Is</u> <u>Moose</u> <u>"production</u> <u>ready"?</u>

       Yes! Many sites with household names are using Moose to build high-traffic services. Countless others are
       using Moose in production.  See &lt;<a href="http://moose.iinteractive.com/about.html">http://moose.iinteractive.com/about.html</a>#organizations&gt; for a partial
       list.

       As of this writing, Moose is a dependency of several hundred CPAN modules.
       &lt;https://metacpan.org/requires/module/Moose&gt;

       <u>Is</u> <u>Moose's</u> <u>API</u> <u>stable?</u>

       Yes. The sugary API, the one 95% of users will interact with, is <b>very</b> <b>stable</b>. Any changes will be <b>100%</b>
       <b>backwards</b> <b>compatible</b>.

       The meta API is less set in stone. We reserve the right to tweak parts of it to improve efficiency or
       consistency. This will not be done lightly. We do perform deprecation cycles. We <u>really</u> do not like
       making ourselves look bad by breaking your code.  Submitting test cases is the best way to ensure that
       your code is not inadvertently broken by refactoring.

       <u>I</u> <u>heard</u> <u>Moose</u> <u>is</u> <u>slow,</u> <u>is</u> <u>this</u> <u>true?</u>

       Again, this one is tricky, so Yes <u>and</u> No.

       Firstly, <u>nothing</u> in life is free, and some Moose features do cost more than others. It is also the policy
       of Moose to <b>only</b> <b>charge</b> <b>you</b> <b>for</b> <b>the</b> <b>features</b> <b>you</b> <b>use</b>, and to do our absolute best to not place any extra
       burdens on the execution of your code for features you are not using. Of course using Moose itself does
       involve some overhead, but it is mostly compile time. At this point we do have some options available for
       getting the speed you need.

       Currently we provide the option of making your classes immutable as a means of boosting speed. This will
       mean a slightly larger compile time cost, but the runtime speed increase (especially in object
       construction) is pretty significant. This can be done with the following code:

         MyClass-&gt;meta-&gt;make_immutable();

   <b>Constructors</b>
       <u>How</u> <u>do</u> <u>I</u> <u>write</u> <u>custom</u> <u>constructors</u> <u>with</u> <u>Moose?</u>

       Ideally, you should never write your own "new" method, and should use Moose's other features to handle
       your specific object construction needs. Here are a few scenarios, and the Moose way to solve them;

       If you need to call initialization code post instance construction, then use the "BUILD" method. This
       feature is taken directly from Perl 6. Every "BUILD" method in your inheritance chain is called (in the
       correct order) immediately after the instance is constructed.  This allows you to ensure that all your
       superclasses are initialized properly as well. This is the best approach to take (when possible) because
       it makes subclassing your class much easier.

       If you need to affect the constructor's parameters prior to the instance actually being constructed, you
       have a number of options.

       To change the parameter processing as a whole, you can use the "BUILDARGS" method. The default
       implementation accepts key/value pairs or a hash reference. You can override it to take positional args,
       or any other format

       To change the handling of individual parameters, there are <u>coercions</u> (See the
       Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion for a complete example and explanation of coercions).
       With coercions it is possible to morph argument values into the correct expected types. This approach is
       the most flexible and robust, but does have a slightly higher learning curve.

       <u>How</u> <u>do</u> <u>I</u> <u>make</u> <u>non-Moose</u> <u>constructors</u> <u>work</u> <u>with</u> <u>Moose?</u>

       Usually the correct approach to subclassing a non-Moose class is delegation.  Moose makes this easy using
       the "handles" keyword, coercions, and "lazy_build", so subclassing is often not the ideal route.

       That said, if you really need to inherit from a non-Moose class, see
       Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent for an example of how to do it, or take a look
       at "MooseX::NonMoose" in Moose::Manual::MooseX.

   <b>Accessors</b>
       <u>How</u> <u>do</u> <u>I</u> <u>tell</u> <u>Moose</u> <u>to</u> <u>use</u> <u>get/set</u> <u>accessors?</u>

       The easiest way to accomplish this is to use the "reader" and "writer" attribute options:

         has 'bar' =&gt; (
             isa    =&gt; 'Baz',
             reader =&gt; 'get_bar',
             writer =&gt; 'set_bar',
         );

       Moose will still take advantage of type constraints, triggers, etc.  when creating these methods.

       If you do not like this much typing, and wish it to be a default for your classes, please see
       MooseX::FollowPBP. This extension will allow you to write:

         has 'bar' =&gt; (
             isa =&gt; 'Baz',
             is  =&gt; 'rw',
         );

       Moose will create separate "get_bar" and "set_bar" methods instead of a single "bar" method.

       If you like "bar" and "set_bar", see MooseX::SemiAffordanceAccessor.

       NOTE: This <b>cannot</b> be set globally in Moose, as that would break other classes which are built with Moose.
       You can still save on typing by defining a new "MyApp::Moose" that exports Moose's sugar and then turns
       on MooseX::FollowPBP. See Moose::Cookbook::Extending::Mooseish_MooseSugar.

       <u>How</u> <u>can</u> <u>I</u> <u>inflate/deflate</u> <u>values</u> <u>in</u> <u>accessors?</u>

       Well, the first question to ask is if you actually need both inflate and deflate.

       If you only need to inflate, then we suggest using coercions. Here is some basic sample code for
       inflating a DateTime object:

         class_type 'DateTime';

         coerce 'DateTime'
             =&gt; from 'Str'
             =&gt; via { DateTime::Format::MySQL-&gt;parse_datetime($_) };

         has 'timestamp' =&gt; (is =&gt; 'rw', isa =&gt; 'DateTime', coerce =&gt; 1);

       This creates a custom type for DateTime objects, then attaches a coercion to that type. The "timestamp"
       attribute is then told to expect a "DateTime" type, and to try to coerce it. When a "Str" type is given
       to the "timestamp" accessor, it will attempt to coerce the value into a "DateTime" object using the code
       in found in the "via" block.

       For a more comprehensive example of using coercions, see the
       Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion.

       If you need to deflate your attribute's value, the current best practice is to add an "around" modifier
       to your accessor:

         # a timestamp which stores as
         # seconds from the epoch
         has 'timestamp' =&gt; (is =&gt; 'rw', isa =&gt; 'Int');

         around 'timestamp' =&gt; sub {
             my $next = shift;
             my $self = shift;

             return $self-&gt;$next unless @_;

             # assume we get a DateTime object ...
             my $timestamp = shift;
             return $self-&gt;$next( $timestamp-&gt;epoch );
         };

       It is also possible to do deflation using coercion, but this tends to get quite complex and require many
       subtypes. An example of this is outside the scope of this document, ask on #moose or send a mail to the
       list.

       Still another option is to write a custom attribute metaclass, which is also outside the scope of this
       document, but we would be happy to explain it on #moose or the mailing list.

   <b>Method</b> <b>Modifiers</b>
       <u>How</u> <u>can</u> <u>I</u> <u>affect</u> <u>the</u> <u>values</u> <u>in</u> <u>@</u><b>_</b> <u>using</u> <u>"before"?</u>

       You can't, actually: "before" only runs before the main method, and it cannot easily affect the method's
       execution.

       You similarly can't use "after" to affect the return value of a method.

       We limit "before" and "after" because this lets you write more concise code. You do not have to worry
       about passing @_ to the original method, or forwarding its return value (being careful to preserve
       context).

       The "around" method modifier has neither of these limitations, but is a little more verbose.

       Alternatively, the MooseX::Mangle extension provides the "mangle_args" function, which does allow you to
       affect @_.

       <u>Can</u> <u>I</u> <u>use</u> <u>"before"</u> <u>to</u> <u>stop</u> <u>execution</u> <u>of</u> <u>a</u> <u>method?</u>

       Yes, but only if you throw an exception. If this is too drastic a measure then we suggest using "around"
       instead. The "around" method modifier is the only modifier which can gracefully prevent execution of the
       main method. Here is an example:

           around 'baz' =&gt; sub {
               my $next = shift;
               my ($self, %options) = @_;
               unless ($options-&gt;{bar} eq 'foo') {
                   return 'bar';
               }
               $self-&gt;$next(%options);
           };

       By choosing not to call the $next method, you can stop the execution of the main method.

       Alternatively, the MooseX::Mangle extension provides the "guard" function, which will conditionally
       prevent execution of the original method.

       <u>Why</u> <u>can't</u> <u>I</u> <u>see</u> <u>return</u> <u>values</u> <u>in</u> <u>an</u> <u>"after"</u> <u>modifier?</u>

       As with the "before" modifier, the "after" modifier is simply called <u>after</u> the main method. It is passed
       the original contents of @_ and <b>not</b> the return values of the main method.

       Again, the arguments are too lengthy as to why this has to be. And as with "before" I recommend using an
       "around" modifier instead.  Here is some sample code:

         around 'foo' =&gt; sub {
             my $next = shift;
             my ($self, @args) = @_;
             my @rv = $next-&gt;($self, @args);
             # do something silly with the return values
             return reverse @rv;
         };

       Alternatively, the MooseX::Mangle extension provides the "mangle_return" function, which allows modifying
       the return values of the original method.

   <b>Type</b> <b>Constraints</b>
       <u>How</u> <u>can</u> <u>I</u> <u>provide</u> <u>a</u> <u>custom</u> <u>error</u> <u>message</u> <u>for</u> <u>a</u> <u>type</u> <u>constraint?</u>

       Use the "message" option when building the subtype:

         subtype 'NaturalLessThanTen'
             =&gt; as 'Natural'
             =&gt; where { $_ &lt; 10 }
             =&gt; message { "This number ($_) is not less than ten!" };

       This "message" block will be called when a value fails to pass the "NaturalLessThanTen" constraint check.

       <u>Can</u> <u>I</u> <u>turn</u> <u>off</u> <u>type</u> <u>constraint</u> <u>checking?</u>

       There's no support for it in the core of Moose yet. This option may come in a future release.

       Meanwhile there's a MooseX extension that allows you to do this on a per-attribute basis, and if it
       doesn't do what you it's easy to write one that fits your use case.

       <u>My</u> <u>coercions</u> <u>stopped</u> <u>working</u> <u>with</u> <u>recent</u> <u>Moose,</u> <u>why</u> <u>did</u> <u>you</u> <u>break</u> <u>it?</u>

       Moose 0.76 fixed a case where coercions were being applied even if the original constraint passed. This
       has caused some edge cases to fail where people were doing something like

           subtype 'Address', as 'Str';
           coerce 'Address', from 'Str', via { get_address($_) };

       This is not what they intended, because the type constraint "Address" is too loose in this case. It is
       saying that all strings are Addresses, which is obviously not the case. The solution is to provide a
       "where" clause that properly restricts the type constraint:

           subtype 'Address', as 'Str', where { looks_like_address($_) };

       This will allow the coercion to apply only to strings that fail to look like an Address.

   <b>Roles</b>
       <u>Why</u> <u>is</u> <u>BUILD</u> <u>not</u> <u>called</u> <u>for</u> <u>my</u> <u>composed</u> <u>roles?</u>

       "BUILD" is never called in composed roles. The primary reason is that roles are <b>not</b> order sensitive.
       Roles are composed in such a way that the order of composition does not matter (for information on the
       deeper theory of this read the original traits papers here
       &lt;<a href="http://www.iam.unibe.ch/~scg/Research/Traits/">http://www.iam.unibe.ch/~scg/Research/Traits/</a>&gt;).

       Because roles are essentially unordered, it would be impossible to determine the order in which to
       execute the "BUILD" methods.

       As for alternate solutions, there are a couple.

       •   Using  a  combination  of lazy and default in your attributes to defer initialization (see the Binary
           Tree   example    in    the    cookbook    for    a    good    example    of    lazy/default    usage
           Moose::Cookbook::Basics::BinaryTree_AttributeFeatures)

       •   Use attribute triggers, which fire after an attribute is set, to facilitate initialization. These are
           described in the Moose docs, and examples can be found in the test suite.

       In  general,  roles should not <u>require</u> initialization; they should either provide sane defaults or should
       be documented as needing specific initialization. One such way to "document" this is to have  a  separate
       attribute initializer which is required for the role. Here is an example of how to do this:

         package My::Role;
         use Moose::Role;

         has 'height' =&gt; (
             is      =&gt; 'rw',
             isa     =&gt; 'Int',
             lazy    =&gt; 1,
             default =&gt; sub {
                 my $self = shift;
                 $self-&gt;init_height;
             }
         );

         requires 'init_height';

       In this example, the role will not compose successfully unless the class provides a "init_height" method.

       If  none  of  those solutions work, then it is possible that a role is not the best tool for the job, and
       you really should be using classes. Or, at the very least, you should reduce the amount of  functionality
       in your role so that it does not require initialization.

       <u>What</u> <u>are</u> <u>traits,</u> <u>and</u> <u>how</u> <u>are</u> <u>they</u> <u>different</u> <u>from</u> <u>roles?</u>

       In  Moose,  a  trait  is  almost  exactly the same thing as a role, except that traits typically register
       themselves, which allows you to refer to them by a short name ("Big" vs "MyApp::Role::Big").

       In Moose-speak, a <u>Role</u> is usually composed into a <u>class</u> at compile  time,  whereas  a  <u>Trait</u>  is  usually
       composed into an instance of a class at runtime to add or modify the behavior of <b>just</b> <b>that</b> <b>instance</b>.

       Outside  the context of Moose, traits and roles generally mean exactly the same thing. The original paper
       called them traits, but Perl 6 will call them roles.

       <u>Can</u> <u>an</u> <u>attribute-generated</u> <u>method</u> <u>(e.g.</u> <u>an</u> <u>accessor)</u> <u>satisfy</u> <u>requires?</u>

       Yes, just be sure to  consume  the  role  <u>after</u>  declaring  your  attribute.   "Required  Attributes"  in
       Moose::Manual::Roles provides an example:

         package Breakable;
         use Moose::Role;
         requires 'stress';

         package Car;
         use Moose;
         has 'stress' =&gt; ( is  =&gt; 'rw', isa =&gt; 'Int' );
         with 'Breakable';

       If you mistakenly consume the "Breakable" role before declaring your "stress" attribute, you would see an
       error like this:

         'Breakable' requires the method 'stress' to be implemented by 'Car' at...

   <b>Moose</b> <b>and</b> <b>Subroutine</b> <b>Attributes</b>
       <u>Why</u> <u>don't</u> <u>subroutine</u> <u>attributes</u> <u>I</u> <u>inherited</u> <u>from</u> <u>a</u> <u>superclass</u> <u>work?</u>

       Currently  when  subclassing  a  module is done at runtime with the "extends" keyword, but attributes are
       checked at compile time by Perl. To make attributes work, you must place "extends" in a "BEGIN" block  so
       that the attribute handlers will be available at compile time, like this:

         BEGIN { extends qw/Foo/ }

       Note that we're talking about Perl's subroutine attributes here, not Moose attributes:

         sub foo : <a href="../man27/Bar.27.html">Bar</a>(27) { ... }

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Stevan Little &lt;<a href="mailto:stevan@cpan.org">stevan@cpan.org</a>&gt;

       •   Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;

       •   Jesse Luehrs &lt;<a href="mailto:doy@cpan.org">doy@cpan.org</a>&gt;

       •   Shawn M Moore &lt;<a href="mailto:sartak@cpan.org">sartak@cpan.org</a>&gt;

       •   יובל קוג'מן (Yuval Kogman) &lt;<a href="mailto:nothingmuch@woobling.org">nothingmuch@woobling.org</a>&gt;

       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   Florian Ragwitz &lt;<a href="mailto:rafl@debian.org">rafl@debian.org</a>&gt;

       •   Hans Dieter Pearcey &lt;<a href="mailto:hdp@cpan.org">hdp@cpan.org</a>&gt;

       •   Chris Prather &lt;<a href="mailto:chris@prather.org">chris@prather.org</a>&gt;

       •   Matt S Trout &lt;<a href="mailto:mstrout@cpan.org">mstrout@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2006 by Infinity Interactive, Inc.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.0                                       2024-10-20                            <u>Moose::Manual::<a href="../man3pm/FAQ.3pm.html">FAQ</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>