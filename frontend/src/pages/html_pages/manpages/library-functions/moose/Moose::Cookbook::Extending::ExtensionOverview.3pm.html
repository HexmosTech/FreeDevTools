<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moose::Cookbook::Extending::ExtensionOverview - Moose extension overview</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmoose-perl">libmoose-perl_2.2207-1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Moose::Cookbook::Extending::ExtensionOverview - Moose extension overview

</pre><h4><b>VERSION</b></h4><pre>
       version 2.2207

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Moose provides several ways in which extensions can hook into Moose and change its behavior. Moose also
       has a lot of behavior that can be changed. This recipe will provide an overview of each extension method
       and give you some recommendations on what tools to use.

       If you haven't yet read the recipes on metaclasses, go read those first. You can't write Moose extensions
       without understanding the metaclasses, and those recipes also demonstrate some basic extension
       mechanisms, such as metaclass subclasses and traits.

   <b>Playing</b> <b>Nice</b> <b>With</b> <b>Others</b>
       One of the goals of this overview is to help you build extensions that cooperate well with other
       extensions. This is especially important if you plan to release your extension to CPAN.

       Moose comes with several modules that exist to help your write cooperative extensions. These are
       Moose::Exporter and Moose::Util::MetaRole. By using these two modules, you will ensure that your
       extension works with both the Moose core features and any other CPAN extension using those modules.

</pre><h4><b>PARTS</b> <b>OF</b> <b>Moose</b> <b>YOU</b> <b>CAN</b> <b>EXTEND</b></h4><pre>
       The types of things you might want to do in Moose extensions fall into a few broad categories.

   <b>Metaclass</b> <b>Extensions</b>
       One way of extending Moose is by extending one or more Moose metaclasses. For example, in
       Moose::Cookbook::Meta::Table_MetaclassTrait we saw a metaclass role that added a "table" attribute to the
       metaclass. If you were writing an ORM, this would be a logical extension.

       Many of the Moose extensions on CPAN work by providing an attribute metaclass role. For example, the
       MooseX::Aliases module provides an attribute metaclass trait that lets you specify aliases to install for
       methods and attribute accessors.

       A metaclass extension can be packaged as a role/trait or a subclass. If you can, we recommend using
       traits instead of subclasses, since it's much easier to combine disparate traits than it is to combine a
       bunch of subclasses.

       When your extensions are implemented as roles, you can apply them with the Moose::Util::MetaRole module.

   <b>Providing</b> <b>Sugar</b> <b>Functions</b>
       As part of a metaclass extension, you may also want to provide some sugar functions, just like Moose.pm
       does. Moose provides a helper module called Moose::Exporter that makes this much simpler. We will be use
       Moose::Exporter in several of the extension recipes.

   <b>Object</b> <b>Class</b> <b>Extensions</b>
       Another common Moose extension technique is to change the default object class's behavior. As with
       metaclass extensions, this can be done with a role/trait or with a subclass. For example,
       MooseX::StrictConstructor extension applies a trait that makes the constructor reject arguments which
       don't match its attributes.

       Object class extensions often include metaclass extensions as well. In particular, if you want your
       object extension to work when a class is made immutable, you may need to modify the behavior of some or
       all of the Moose::Meta::Instance, Moose::Meta::Method::Constructor, and Moose::Meta::Method::Destructor
       objects.

       The Moose::Util::MetaRole module lets you apply roles to the base object class, as well as the meta
       classes just mentioned.

   <b>Providing</b> <b>a</b> <b>Role</b>
       Some extensions come in the form of a role for you to consume. The MooseX::Object::Pluggable extension is
       a great example of this. In fact, despite the "MooseX" name, it does not actually change anything about
       Moose's behavior. Instead, it is just a role that an object which wants to be pluggable can consume.

       If you are implementing this sort of extension, you don't need to do anything special. You simply create
       a role and document that it should be used via the normal "with" sugar:

          package MyApp::User;

          use Moose;

          with 'My::Role';

       Don't use "MooseX" in the name for such packages.

   <b>New</b> <b>Types</b>
       Another common Moose extension is a new type for the Moose type system. In this case, you simply create a
       type in your module. When people load your module, the type is created, and they can refer to it by name
       after that. The MooseX::Types::URI and MooseX::Types::DateTime distributions are two good examples of how
       this works. These both build on top of the MooseX::Types extension.

</pre><h4><b>ROLES</b> <b>VS</b> <b>TRAITS</b> <b>VS</b> <b>SUBCLASSES</b></h4><pre>
       It is important to understand that <b>roles</b> <b>and</b> <b>traits</b> <b>are</b> <b>the</b> <b>same</b> <b>thing</b>. A trait is simply a role applied
       to a instance. The only thing that may distinguish the two is that a trait can be packaged in a way that
       lets Moose resolve a short name to a class name. In other words, with a trait, the caller can refer to it
       by a short name like "Big", and Moose will resolve it to a class like
       "MooseX::Embiggen::Meta::Attribute::Role::Big".

       See Moose::Cookbook::Meta::Labeled_AttributeTrait and Moose::Cookbook::Meta::Table_MetaclassTrait for
       examples of traits in action. In particular, both of these recipes demonstrate the trait resolution
       mechanism.

       Implementing an extension as a (set of) metaclass or base object role(s) will make your extension more
       cooperative. It is hard for an end-user to effectively combine together multiple metaclass subclasses,
       but it is very easy to combine roles.

</pre><h4><b>USING</b> <b>YOUR</b> <b>EXTENSION</b></h4><pre>
       There are a number of ways in which an extension can be applied. In some cases you can provide multiple
       ways of consuming your extension.

   <b>Extensions</b> <b>as</b> <b>Metaclass</b> <b>Traits</b>
       If your extension is available as a trait, you can ask end users to simply specify it in a list of
       traits. Currently, this only works for (class) metaclass and attribute metaclass traits:

         use Moose -traits =&gt; [ 'Big', 'Blue' ];

         has 'animal' =&gt; (
             traits =&gt; [ 'Big', 'Blue' ],
             ...
         );

       If your extension applies to any other metaclass, or the object base class, you cannot use the trait
       mechanism.

       The benefit of the trait mechanism is that is very easy to see where a trait is applied in the code, and
       consumers have fine-grained control over what the trait applies to. This is especially true for attribute
       traits, where you can apply the trait to just one attribute in a class.

   <b>Extensions</b> <b>as</b> <b>Metaclass</b> <b>(and</b> <b>Base</b> <b>Object)</b> <b>Roles</b>
       Implementing your extensions as metaclass roles makes your extensions easy to apply, and cooperative with
       other role-based extensions for metaclasses.

       Just as with a subclass, you will probably want to package your extensions for consumption with a single
       module that uses Moose::Exporter. However, in this case, you will use Moose::Util::MetaRole to apply all
       of your roles. The advantage of using this module is that <u>it</u> <u>preserves</u> <u>any</u> <u>subclassing</u> <u>or</u> <u>roles</u> <u>already</u>
       <u>applied</u> <u>to</u> <u>the</u> <u>user's</u> <u>metaclasses</u>. This means that your extension is cooperative <u>by</u> <u>default</u>, and
       consumers of your extension can easily use it with other role-based extensions. Most uses of
       Moose::Util::MetaRole can be handled by Moose::Exporter directly; see the Moose::Exporter docs.

         package MooseX::Embiggen;

         use Moose::Exporter;

         use MooseX::Embiggen::Role::Meta::Class;
         use MooseX::Embiggen::Role::Meta::Attribute;
         use MooseX::Embiggen::Role::Meta::Method::Constructor;
         use MooseX::Embiggen::Role::Object;

         Moose::Exporter-&gt;setup_import_methods(
             class_metaroles =&gt; {
                 class     =&gt; ['MooseX::Embiggen::Role::Meta::Class'],
                 attribute =&gt; ['MooseX::Embiggen::Role::Meta::Attribute'],
                 constructor =&gt;
                     ['MooseX::Embiggen::Role::Meta::Method::Constructor'],
             },
             base_class_roles =&gt; ['MooseX::Embiggen::Role::Object'],
         );

       As you can see from this example, you can use Moose::Util::MetaRole to apply roles to any metaclass, as
       well as the base object class. If some other extension has already applied its own roles, they will be
       preserved when your extension applies its roles, and vice versa.

   <b>Providing</b> <b>Sugar</b>
       With Moose::Exporter, you can also export your own sugar functions:

         package MooseX::Embiggen;

         use Moose::Exporter;

         Moose::Exporter-&gt;setup_import_methods(
             with_meta       =&gt; ['embiggen'],
             class_metaroles =&gt; {
                 class =&gt; ['MooseX::Embiggen::Role::Meta::Class'],
             },
         );

         sub embiggen {
             my $meta = shift;
             $meta-&gt;embiggen(@_);
         }

       And then the consumer of your extension can use your "embiggen" sub:

         package Consumer;

         use Moose;
         use MooseX::Embiggen;

         extends 'Thing';

         embiggen ...;

       This can be combined with metaclass and base class roles quite easily.

   <b>More</b> <b>advanced</b> <b>extensions</b>
       Providing your extension simply as a set of traits that gets applied to the appropriate metaobjects is
       easy, but sometimes not sufficient. For instance, sometimes you need to supply not just a base object
       role, but an actual base object class (due to needing to interact with existing systems that only provide
       a base class). To write extensions like this, you will need to provide a custom "init_meta" method in
       your exporter. For instance:

         package MooseX::Embiggen;

         use Moose::Exporter;

         my ($import, $unimport, $init_meta) = Moose::Exporter-&gt;build_import_methods(
             install         =&gt; ['import', 'unimport'],
             with_meta       =&gt; ['embiggen'],
             class_metaroles =&gt; {
                 class =&gt; ['MooseX::Embiggen::Role::Meta::Class'],
             },
         );

         sub embiggen {
             my $meta = shift;
             $meta-&gt;embiggen(@_);
         }

         sub init_meta {
             my $package = shift;
             my %options = @_;
             if (my $meta = Class::MOP::class_of($options{for_class})) {
                 if ($meta-&gt;isa('Class::MOP::Class')) {
                     my @supers = $meta-&gt;superclasses;
                     $meta-&gt;superclasses('MooseX::Embiggen::Base::Class')
                         if @supers == 1 &amp;&amp; $supers[0] eq 'Moose::Object';
                 }
             }
             $package-&gt;$init_meta(%options);
         }

       In the previous examples, "init_meta" was generated for you, but here you must override it in order to
       add additional functionality. Some differences to note:

       "build_import_methods" instead of "setup_import_methods"
           "build_import_methods"  simply returns the "import", "unimport", and "init_meta" methods, rather than
           installing them under the appropriate names.  This way, you can write your own methods which wrap the
           functionality provided by Moose::Exporter.  The "build_import_methods" sub also takes  an  additional
           "install"  parameter,  which tells it to just go ahead and install these methods (since we don't need
           to modify them).

       "sub init_meta"
           Next, we must write our "init_meta" wrapper. The important things to remember are that it  is  called
           as a method, and that %options needs to be passed through to the existing implementation. We call the
           base   implementation   by   using   the   $init_meta  subroutine  reference  that  was  returned  by
           "build_import_methods" earlier.

       Additional implementation
           This extension sets a different default base object class. To do so, it first checks to see  if  it's
           being  applied  to  a class, and then checks to see if Moose::Object is that class's only superclass,
           and if so, replaces that with the superclass that this extension requires.

           Note that two extensions that do this  same  thing  will  not  work  together  properly  (the  second
           extension  to  be  loaded  won't  see  Moose::Object  as  the  base object, since it has already been
           overridden). This is why using a base object role is recommended for the general case.

           This "init_meta" also works defensively, by only applying its functionality if  a  metaclass  already
           exists. This makes sure it doesn't break with legacy extensions which override the metaclass directly
           (and so must be the first extension to initialize the metaclass). This is likely not necessary, since
           almost  no extensions work this way anymore, but just provides an additional level of protection. The
           common case of "use Moose; use MooseX::Embiggen;" is not affected regardless.

       This is just one example of what can be done with a custom "init_meta" method.  It can also be  used  for
       preventing  an extension from being applied to a role, doing other kinds of validation on the class being
       applied to, or pretty much anything that would otherwise be done in an "import" method.

</pre><h4><b>LEGACY</b> <b>EXTENSION</b> <b>MECHANISMS</b></h4><pre>
       Before the existence of Moose::Exporter and Moose::Util::MetaRole, there were a number of other  ways  to
       extend  Moose.  In  general,  these  methods  were  less  cooperative, and only worked well with a single
       extension.

       These methods include metaclass.pm, Moose::Policy (which uses metaclass.pm under the hood),  and  various
       hacks to do what Moose::Exporter does. Please do not use these for your own extensions.

       Note  that  if you write a cooperative extension, it should cooperate with older extensions, though older
       extensions generally do not cooperate with each other.

</pre><h4><b>CONCLUSION</b></h4><pre>
       If you can write your extension as one or more metaclass and base object roles, please consider doing so.
       Make sure to read the docs for Moose::Exporter and Moose::Util::MetaRole as well.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Stevan Little &lt;<a href="mailto:stevan@cpan.org">stevan@cpan.org</a>&gt;

       •   Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;

       •   Jesse Luehrs &lt;<a href="mailto:doy@cpan.org">doy@cpan.org</a>&gt;

       •   Shawn M Moore &lt;<a href="mailto:sartak@cpan.org">sartak@cpan.org</a>&gt;

       •   יובל קוג'מן (Yuval Kogman) &lt;<a href="mailto:nothingmuch@woobling.org">nothingmuch@woobling.org</a>&gt;

       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   Florian Ragwitz &lt;<a href="mailto:rafl@debian.org">rafl@debian.org</a>&gt;

       •   Hans Dieter Pearcey &lt;<a href="mailto:hdp@cpan.org">hdp@cpan.org</a>&gt;

       •   Chris Prather &lt;<a href="mailto:chris@prather.org">chris@prather.org</a>&gt;

       •   Matt S Trout &lt;<a href="mailto:mstrout@cpan.org">mstrout@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2006 by Infinity Interactive, Inc.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.40.0                                       2024-10-20              <u>Moose::<a href="../man3pm/Cookboo...tensionOverview.3pm.html">Cookboo...tensionOverview</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>