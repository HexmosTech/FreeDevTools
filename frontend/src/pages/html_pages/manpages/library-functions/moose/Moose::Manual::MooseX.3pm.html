<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moose::Manual::MooseX - Recommended Moose extensions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmoose-perl">libmoose-perl_2.2207-1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Moose::Manual::MooseX - Recommended Moose extensions

</pre><h4><b>VERSION</b></h4><pre>
       version 2.2207

</pre><h4><b>MooseX?</b></h4><pre>
       It's easy to extend and change Moose, and this is part of what makes Moose so powerful. You can use the
       MOP API to do things your own way, add new features, and generally customize your Moose.

       Writing your own extensions does require a good understanding of the meta-model. You can start learning
       about this with the Moose::Manual::MOP docs. There are also several extension recipes in the
       Moose::Cookbook.

       Explaining how to write extensions is beyond the scope of this manual. Fortunately, lots of people have
       already written extensions and put them on CPAN for you.

       This document covers a few of the ones we like best.

</pre><h4><b>MooseX::AttributeHelpers</b></h4><pre>
       The functionality of this MooseX module has been moved into Moose core.  See
       Moose::Meta::Attribute::Native.

</pre><h4><b>Moose::Autobox</b></h4><pre>
       MooseX::AttributeHelpers, but turned inside out, Moose::Autobox provides methods on both
       arrays/hashes/etc. but also references to them, using Moose roles, allowing you do to things like:

         use Moose::Autobox;

         $somebody_elses_object-&gt;orders-&gt;push($order);

       Lexically scoped and not to everybody's taste, but very handy for sugaring up other people's APIs and
       your own code.

</pre><h4><b>MooseX::StrictConstructor</b></h4><pre>
       By default, Moose lets you pass any old junk into a class's constructor. If you load
       MooseX::StrictConstructor, your class will throw an error if it sees something it doesn't recognize;

         package User;

         use Moose;
         use MooseX::StrictConstructor;

         has 'name';
         has 'email';

         User-&gt;new( name =&gt; 'Bob', emali =&gt; '<a href="mailto:bob@example.com">bob@example.com</a>' );

       With MooseX::StrictConstructor, that typo ("emali") will cause a runtime error. With plain old Moose, the
       "emali" attribute would be silently ignored.

</pre><h4><b>MooseX::Params::Validate</b></h4><pre>
       We have high hopes for the future of MooseX::Method::Signatures and Moops. However, these modules, while
       used regularly in production by some of the more insane members of the community, are still marked alpha
       just in case backwards incompatible changes need to be made.

       If you don't want to risk that, for now we recommend the decidedly more clunky (but also faster and
       simpler) MooseX::Params::Validate. This module lets you apply Moose types and coercions to any method
       arguments.

         package User;

         use Moose;
         use MooseX::Params::Validate;

         sub login {
             my $self = shift;
             my ($password)
                 = validated_list( \@_, password =&gt; { isa =&gt; 'Str', required =&gt; 1 } );

             ...
         }

</pre><h4><b>MooseX::Getopt</b></h4><pre>
       This is a role which adds a "new_with_options" method to your class. This is a constructor that takes the
       command line options and uses them to populate attributes.

       This makes writing a command-line application as a module trivially simple:

         package App::Foo;

         use Moose;
         with 'MooseX::Getopt';

         has 'input' =&gt; (
             is       =&gt; 'ro',
             isa      =&gt; 'Str',
             required =&gt; 1
         );

         has 'output' =&gt; (
             is       =&gt; 'ro',
             isa      =&gt; 'Str',
             required =&gt; 1
         );

         sub run { ... }

       Then in the script that gets run we have:

         use App::Foo;

         App::Foo-&gt;new_with_options-&gt;run;

       From the command line, someone can execute the script:

         foo@example&gt; foo --input /path/to/input --output /path/to/output

</pre><h4><b>MooseX::Singleton</b></h4><pre>
       To be honest, using a singleton is just a way to have a magic global variable in languages that don't
       actually have global variables.

       In perl, you can just as easily use a global. However, if your colleagues are Java-infected, they might
       prefer a singleton. Also, if you have an existing class that <u>isn't</u> a singleton but should be, using
       MooseX::Singleton is the easiest way to convert it.

         package Config;

         use MooseX::Singleton; # instead of Moose

         has 'cache_dir' =&gt; ( ... );

       It's that simple.

</pre><h4><b>EXTENSIONS</b> <b>TO</b> <b>CONSIDER</b></h4><pre>
       There are literally dozens of other extensions on CPAN. This is a list of extensions that you might find
       useful, but we're not quite ready to endorse just yet.

   <b>MooseX::Declare</b>
       MooseX::Declare is based on Devel::Declare, a giant bag of crack originally implemented by mst with the
       goal of upsetting the perl core developers so much by its very existence that they implemented proper
       keyword handling in the core.

       As of perl5 version 14, this goal has been achieved, and modules such as Devel::CallParser,
       Function::Parameters, and Keyword::Simple provide mechanisms to mangle perl syntax that don't require
       hallucinogenic drugs to interpret the error messages they produce.

       If you want to use declarative syntax in new code, please for the love of kittens get yourself a recent
       perl and look at Moops instead.

   <b>MooseX::Types</b>
       This extension helps you build a type library for your application. It also lets you predeclare type
       names and use them as barewords.

         use MooseX::Types -declare =&gt; ['PositiveInt'];
         use MooseX::Types::Moose 'Int';

         subtype PositiveInt,
             as Int,
             where { $_ &gt; 0 },
             message { "Int is not larger than 0" };

       One nice feature is that those bareword names are actually namespaced in Moose's type registry, so
       multiple applications can use the same bareword names, even if the type definitions differ.

   <b>MooseX::Types::Structured</b>
       This extension builds on top of MooseX::Types to let you declare complex data structure types.

         use MooseX::Types -declare =&gt; [ qw( Name Color ) ];
         use MooseX::Types::Moose qw(Str Int);
         use MooseX::Types::Structured qw(Dict Tuple Optional);

         subtype Name
             =&gt; as Dict[ first =&gt; Str, middle =&gt; Optional[Str], last =&gt; Str ];

         subtype Color
             =&gt; as Tuple[ Int, Int, Int, Optional[Int] ];

       Of course, you could always use objects to represent these sorts of things too.

   <b>MooseX::ClassAttribute</b>
       This extension provides class attributes for Moose classes. The declared class attributes are
       introspectable just like regular Moose attributes.

         package User;

         use Moose;
         use MooseX::ClassAttribute;

         has 'name' =&gt; ( ... );

         class_has 'Cache' =&gt; ( ... );

       Note however that this class attribute does <u>not</u> inherit like a Class::Data::Inheritable or similar
       attribute - calling

         $subclass-&gt;Cache($cache);

       will set it for the superclass as well. Additionally, class data is usually The Wrong Thing To Do in a
       strongly OO program since it makes testing a lot harder - consider carefully whether you'd be better off
       with an object that's passed around instead.

   <b>MooseX::Daemonize</b>
       This is a role that provides a number of methods useful for creating a daemon, including methods for
       starting and stopping, managing a PID file, and signal handling.

   <b>MooseX::Role::Parameterized</b>
       If you find yourself wanting a role that customizes itself for each consumer, this is the tool for you.
       With this module, you can create a role that accepts parameters and generates attributes, methods, etc.
       on a customized basis for each consumer.

   <b>MooseX::POE</b>
       This is a small wrapper that ties together a Moose class with "POE::Session", and gives you an "event"
       sugar function to declare event handlers.

   <b>MooseX::FollowPBP</b>
       Automatically names all accessors <u>Perl</u> <u>Best</u> <u>Practices</u>-style, "get_size" and "set_size".

   <b>MooseX::SemiAffordanceAccessor</b>
       Automatically names all accessors with an explicit set and implicit get, "size" and "set_size".

   <b>MooseX::NonMoose</b>
       MooseX::NonMoose allows for easily subclassing non-Moose classes with Moose, taking care of the annoying
       details connected with doing this, such as setting up proper inheritance from Moose::Object and
       installing (and inlining, at make_immutable time) a constructor that makes sure things like BUILD methods
       are called.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Stevan Little &lt;<a href="mailto:stevan@cpan.org">stevan@cpan.org</a>&gt;

       •   Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;

       •   Jesse Luehrs &lt;<a href="mailto:doy@cpan.org">doy@cpan.org</a>&gt;

       •   Shawn M Moore &lt;<a href="mailto:sartak@cpan.org">sartak@cpan.org</a>&gt;

       •   יובל קוג'מן (Yuval Kogman) &lt;<a href="mailto:nothingmuch@woobling.org">nothingmuch@woobling.org</a>&gt;

       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   Florian Ragwitz &lt;<a href="mailto:rafl@debian.org">rafl@debian.org</a>&gt;

       •   Hans Dieter Pearcey &lt;<a href="mailto:hdp@cpan.org">hdp@cpan.org</a>&gt;

       •   Chris Prather &lt;<a href="mailto:chris@prather.org">chris@prather.org</a>&gt;

       •   Matt S Trout &lt;<a href="mailto:mstrout@cpan.org">mstrout@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2006 by Infinity Interactive, Inc.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.0                                       2024-10-20                         <u>Moose::Manual::<a href="../man3pm/MooseX.3pm.html">MooseX</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>