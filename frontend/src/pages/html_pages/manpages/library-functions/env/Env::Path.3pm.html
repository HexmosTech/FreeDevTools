<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Env::Path - Advanced operations on path variables</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libenv-path-perl">libenv-path-perl_0.19-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Env::Path - Advanced operations on path variables

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Env::Path;

         # basic usage
         my $manpath = Env::Path-&gt;MANPATH;
         $manpath-&gt;Append('/opt/samba/man');
         for ($manpath-&gt;List) { print $_, "\n" };

         # similar to above using the "implicit object" shorthand
         Env::Path-&gt;MANPATH;
         MANPATH-&gt;Append('/opt/samba/man');
         for (MANPATH-&gt;List) { print $_, "\n" };

         # one-shot use
         Env::Path-&gt;PATH-&gt;Append('<a href="file:/usr/sbin">/usr/sbin</a>');

         # Windows-ish example
         use Env::Path qw(PATH);
         PATH-&gt;Append('C:\\Program Files\\Debugging Tools for Windows');
         print "$_\n" for (PATH-&gt;List);

         # change instances of <a href="file:/usr/local/bin">/usr/local/bin</a> to an architecture-specific dir
         Env::Path-&gt;PATH-&gt;Replace('<a href="file:/usr/local/bin">/usr/local/bin</a>', "<a href="file:/usr/local/">/usr/local/</a>$ENV{PLATFORM}<a href="file:/bin">/bin</a>");

         # more complex use (different names for same semantics)
         my $libpath;
         if ($^O =~ /aix/) {
             $libpath = Env::Path-&gt;LIBPATH;
         } else {
             $libpath = Env::Path-&gt;LD_LIBRARY_PATH;
         }
         $libpath-&gt;Assign(qw(<a href="file:/usr/lib">/usr/lib</a> /usr/openwin/lib));
         $libpath-&gt;Prepend('/usr/ucblib') unless $libpath-&gt;Contains('/usr/ucblib');
         $libpath-&gt;InsertAfter('/usr/ucblib', '/xx/yy/zz');
         $libpath-&gt;Uniqify;
         $libpath-&gt;DeleteNonexistent;
         $libpath-&gt;Remove('<a href="file:/usr/local/lib">/usr/local/lib</a>');
         print $libpath-&gt;Name, ":";
         for ($libpath-&gt;List) { print " $_" };
         print "\n";

         # simplest usage: bless all existing EV's as Env::Path objects
         use Env::Path ':all';
         my @cats = PATH-&gt;Whence('cat*');
         print "@cats\n";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Env::Path presents an object-oriented interface to <u>path</u> <u>variables</u>, defined as that subclass of
       <u>environment</u> <u>variables</u> which name an ordered list of filesystem elements separated by a platform-standard
       <u>separator</u> (typically ':' on UNIX and ';' on Windows).

       Of course, core Perl constructs such

         $ENV{PATH} .= ":<a href="file:/usr/local/bin">/usr/local/bin</a>";

       will suffice for most uses. Env::Path is for the others; cases where you need to insert or remove
       interior path entries, strip redundancies, operate on a pathvar without having to know whether the
       current platform uses ":" or ";", operate on a pathvar which may have a different name on different
       platforms, etc.

       The OO interface is slightly unusual in that the environment variable is itself the object and the
       constructor is Env::Path-&gt;<b>AUTOLOAD()</b>; thus

           Env::Path-&gt;MANPATH;

       will bless $ENV{MANPATH} into its package while leaving it otherwise unmodified (with the exception of
       possible autovivification).  Unlike most objects, this is a scalar and thus can have only one attribute;
       its value.

       In other words, Env::Path simply defines a set of methods a path variable may call on itself without
       changing the variable's value or other semantics.

       Also, while the object reference may be assigned and used in the normal style

           my $path = Env::Path-&gt;CLASSPATH;
           $path-&gt;Append('/opt/foo/classes.jar');

       a shorthand is also available:

           Env::Path-&gt;CLASSPATH;
           CLASSPATH-&gt;Append('/opt/foo/classes.jar');

       I.e. the name of the path variable may be used as a proxy for its object reference. This may be done at
       'use' time too:

           use Env::Path qw(PATH CLASSPATH);   # or qw(:all) to bless all EV's
           CLASSPATH-&gt;Append('/opt/foo/classes.jar');

       The design is intended to make use of this module as lightweight as possible.  Rather than creating a new
       object to manage an environment variable, the environment variable is provided a set of methods for self-
       modification but is otherwise left undisturbed and can be used in all normal ways.

   <b>CLASS</b> <b>METHODS</b>
       •   &lt;CONSTRUCTOR&gt;

           The constructor may have any name; it's assumed to name a <u>path</u> <u>variable</u> as defined above. Returns the
           object reference.

       •   PathSeparator

           Returns  or sets the platform-specific path separator character, by default <u>:</u> on open platforms and <u>;</u>
           on monopolistic ones.

   <b>INSTANCE</b> <b>METHODS</b>
       Unless otherwise indicated these methods return the object reference, allowing method calls to be  strung
       together. All methods which take lists join them together using the value of "Env::Path-&gt;PathSeparator".

       •   Name

           Returns the name of the pathvar.

       •   Contains

           Returns true iff the specified entry is present in the pathvar.

       •   Assign

           Takes a list and sets the pathvar to that value, separated by the current PathSeparator.

       •   List

           Returns the current path in list format.

       •   Prepend

           For  each  entry  in  the supplied list, removes it from the pathvar if present and prepends it, thus
           ensuring that it's present exactly once and at the front.

       •   Append

           Analogous to Prepend.

       •   InsertBefore

           Takes a &lt;dirname&gt; and a list, inserts the list just before the first instance of  the  &lt;dirname&gt;.  If
           <u>dirname</u>  is  not  found, works just like <u>Prepend</u>. As with <u>Prepend</u>, duplicates of the supplied entries
           are removed.

       •   InsertAfter

           Analogous to <u>InsertBefore</u>

       •   Remove

           Removes the specified entries from the path.

       •   Replace

           Takes a /pattern/ and a list. Traverses the path and replaces all entries  which  match  the  pattern
           with the concatenated list entries.

       •   ListNonexistent

           Returns a list of all entries which do not exist as filesystem entities.

       •   DeleteNonexistent

           Removes from the path all entries which do not exist as filesystem entities.

       •   Uniqify

           Removes redundant entries (the 2nd through nth instances of each entry).

       •   Whence

           Takes  a pattern and returns an ordered list of all filenames found along the path which match it and
           are executable.

       •   Shell

           Returns a string suitable for passing to a shell which would  set  and  export  the  pathvar  to  its
           current value within the shell context.

</pre><h4><b>NOTES</b></h4><pre>
       •   No  provision  is made for path variables which are not also environment variables, a situation which
           is technically possible but quite rare.

       •   Except where necessary no assumption is  made  that  path  entries  should  be  directories,  because
           pathvars  like  CLASSPATH  may  contain  "virtual  dirs"  such  as  zip/jar  files.  For instance the
           <u>DeleteNonexistent</u> method does not remove entries which are files.  In Perl terms the test applied  is
           "-e", not "-d".

       •   The  shorthand notation for pathvar <u>FOO</u> is implemented by hacking <u>@FOO::ISA</u>, so there's a slight risk
           of namespace collision if your code also creates packages with all-upper-case names. No packages  are
           created unless the shorthand notation is employed.

       •   There's  some cute code in the Env module by Gregor N. Purdy for splitting pathvars into arrays using
           ties. I'd love to be able to take advantage of that, and it pains me to do the same thing (and not as
           well) here rather than using Env. Unfortunately it's a newish feature (5.6.0? 5.005? 5.6.1?)  in  Env
           and I don't want Env::Path to be "tied" to the very latest Perls.

</pre><h4><b>WORKS</b> <b>ON</b></h4><pre>
       UNIX and Windows.

</pre><h4><b>AUTHOR</b></h4><pre>
       David Boyce &lt;dsbperl AT boyski.com&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright  (c)  2000-2001  David Boyce. All rights reserved.  This Perl program is free software; you may
       redistribute and/or modify it under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), <b><a href="../man1/perlobj.1.html">perlobj</a></b>(1), <b>Env::<a href="../man3/Array.3.html">Array</a></b>(3), <b><a href="../man3/Env.3.html">Env</a></b>(3)

perl v5.36.0                                       2022-10-13                                          <u><a href="../man3pm/Path.3pm.html">Path</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>