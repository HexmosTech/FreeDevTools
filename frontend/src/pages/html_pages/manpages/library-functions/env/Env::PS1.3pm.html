<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Env::PS1 - prompt string formatter</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libenv-ps1-perl">libenv-ps1-perl_0.06-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Env::PS1 - prompt string formatter

</pre><h4><b>SYNOPSIS</b></h4><pre>
               # use the import function
               use Env::PS1 qw/$PS1/;
               $ENV{PS1} = '\u@\h \$ ';
               print $PS1;
               $readline = &lt;STDIN&gt;;

               # or tie it yourself
               tie $prompt, 'Env::PS1', 'PS1';

               # you can also tie a scalar ref
               $format = '\u@\h\$ ';
               tie $prompt, 'Env::PS1', \$format;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This package supplies variables that are "tied" to environment variables like 'PS1' and 'PS2', if read it
       takes the contents of the variable as a format string like the ones <b><a href="../man1/bash.1.html">bash</a>(1)</b> uses to format the prompt.

       It is intended to be used in combination with the various ReadLine packages.

</pre><h4><b>EXPORT</b></h4><pre>
       You can request for arbitrary variables to be exported, they will be tied to the environment variables of
       the same name.

</pre><h4><b>TIE</b></h4><pre>
       When you "tie" a variable you can supply one argument which can either be the name of an environment
       variable or a SCALAR reference. This argument defaults to 'PS1'.

</pre><h4><b>METHODS</b></h4><pre>
       "sprintf($format)"
           Returns the formatted string.

           Using this method all the time is a lot <b>less</b> efficient then using the tied variable, because the tied
           variable caches parts of the format that remain the same anyway.

</pre><h4><b>FORMAT</b></h4><pre>
       The  format  is  copied  mostly from <b><a href="../man1/bash.1.html">bash</a></b>(1) because that's what it is supposed to be compatible with. We
       made some private extensions which obviously are not portable.

       Note that this is not the prompt format as specified by the posix specification, that would only know "!"
       for the history number and "!!" for a literal "!".

       Apart from the escape sequences you can also use environment variables in the format string; use $VAR  or
       "${VAR}".

       The following escape sequences are recognized:

       \a  The bell character, identical to "\007"

       \d  The date in "Weekday Month Date" format

       \D{format}
           The date in <b><a href="../man3/strftime.3.html">strftime</a></b>(3) format, uses POSIX

       \e  The escape character, identical to "\033"

       \n  Newline

       \r  Carriage return

       \s  The basename of $0

       \t  The current time in 24-hour format, identical to "\D{%H:%M:%S}"

       \T  The current time in 12-hour format, identical to "\D{%I:%M:%S}"

       \@  The current time in 12-hour am/pm format, identical to "\D{%I:%M %p}"

       \A  The current time in short 24-hour format, identical to "\D{%H:%M}"

       \u  The username of the current user

       \w  The current working directory

       \W  The basename of the current working directory

       \$  "#" for effective uid is 0 (root), else "$"

       \0dd
           The character corresponding to the octal number 0dd

       \\  Literal backslash

       \H  Hostname, uses Sys::Hostname

       \h  First part of the hostname

       \l  The basename of the (output) terminal device name, uses POSIX, but won't be really portable.

       \[ \]
           These  are  used to encapsulate a sequence of non-printing chars.  Since we don't need that, they are
           removed.

   <b>Extensions</b>
       The following escapes are extensions not supported by bash, and are not portable:

       \L  The (output) terminal device name, uses POSIX, but won't be really portable.

       \C{colour}
           Insert the ANSI sequence for named colour.  Known colours  are:  black,  red,  green,  yellow,  blue,
           magenta,  cyan  and white; background colours prefixed with "on_".  Also known are reset, bold, dark,
           underline, blink and reverse, although the effect depends on the terminla you use.

           Unless you want the whole commandline coloured you should end your prompt with "\C{reset}".

           Of course you can still use the "raw" ansi escape codes for these colours.

           Note that "bold" is sometimes also known as "bright", so  "\C{bold,black}"  will  on  some  terminals
           render dark grey.

           If the environment variable "CLICOLOR" is defined but false colours are switched off automatically.

       \P{format}
           Proc information.

           <u>All</u> <u>of</u> <u>these</u> <u>are</u> <u>unix</u> <u>specific</u>

           %a  Acpi AC status '+' or '-' for connected or not, linux specific

           %b  Acpi battery status in mWh, linux specific

           %L  Load average

           %l  First number of the load average

           %t  Acpi temperature, linux specific

           %u  Uptime

           %w  Number of users logged in

   <b>Not</b> <b>implemented</b> <b>escapes</b>
       The following escapes are not implemented, because they are application specific.

       \j  The number of jobs currently managed by the application.

       \v  The version of the application.

       \V  The release number of the application, version + patchelvel

       \!  The history number of the next command.

           This  escape  gets  replaced by literal '!' while a literal '!' gets replaces by '!!'; this makes the
           string a posix compatible prompt, thus it will work if your readline module expects a posix prompt.

       \#  The command number of the next command (like history number,  but  minus  the  lines  read  from  the
           history file).

   <b>Customizing</b>
       If you want to overload escapes or want to supply values for the application specific escapes you can put
       them in %Env::PS1::map, the key is the escape letter, the value either a string or a CODE ref. If you map
       a  CODE ref it normally is called every time the prompt string is read. When the escape is followed by an
       argument in the format string (like "\D{argument}") the CODE ref is called only once when the  string  is
       cached, but in that case it may in turn return a CODE ref.

</pre><h4><b>BUGS</b></h4><pre>
       Please mail the author if you encounter any bugs.

</pre><h4><b>AUTHOR</b></h4><pre>
       Jaap Karssenberg || Pardus [Larus] &lt;<a href="mailto:pardus@cpan.org">pardus@cpan.org</a>&gt;

       This module is currently maintained by Ryan Niebur &lt;<a href="mailto:rsn@cpan.org">rsn@cpan.org</a>&gt;

       Copyright  (c)  2004  Jaap  G  Karssenberg.  All  rights reserved.  Copyright (c) 2009 Ryan Niebur.  This
       program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Env, Term::ReadLine::Zoid

perl v5.36.0                                       2022-10-13                                      <u>Env::<a href="../man3pm/PS1.3pm.html">PS1</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>