<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>grammar::peg - Create and manipulate parsing expression grammars</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       grammar::peg - Create and manipulate parsing expression grammars

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>snit</b>

       package require <b>grammar::peg</b> <b>?0.3?</b>

       <b>::grammar::peg</b> <u>pegName</u> ?<b>=</b>|<b>:=</b>|<b>&lt;--</b>|<b>as</b>|<b>deserialize</b> <u>src</u>?

       <u>pegName</u> <b>destroy</b>

       <u>pegName</u> <b>clear</b>

       <u>pegName</u> <b>=</b> <u>srcPEG</u>

       <u>pegName</u> <b>--&gt;</b> <u>dstPEG</u>

       <u>pegName</u> <b>serialize</b>

       <u>pegName</u> <b>deserialize</b> <u>serialization</u>

       <u>pegName</u> <b>is</b> <b>valid</b>

       <u>pegName</u> <b>start</b> ?<u>pe</u>?

       <u>pegName</u> <b>nonterminals</b>

       <u>pegName</u> <b>nonterminal</b> <b>add</b> <u>nt</u> <u>pe</u>

       <u>pegName</u> <b>nonterminal</b> <b>delete</b> <u>nt1</u> ?<u>nt2</u> ...?

       <u>pegName</u> <b>nonterminal</b> <b>exists</b> <u>nt</u>

       <u>pegName</u> <b>nonterminal</b> <b>rename</b> <u>nt</u> <u>ntnew</u>

       <u>pegName</u> <b>nonterminal</b> <b>mode</b> <u>nt</u> ?<u>mode</u>?

       <u>pegName</u> <b>nonterminal</b> <b>rule</b> <u>nt</u>

       <u>pegName</u> <b>unknown</b> <b>nonterminals</b>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  package  provides  a  container  class for <u>parsing</u> <u>expression</u> <u>grammars</u> (Short: PEG).  It allows the
       incremental definition of the grammar, its manipulation and querying  of  the  definition.   The  package
       neither  provides  complex  operations  on  the  grammar,  nor  has  it  the ability to execute a grammar
       definition for a stream  of  symbols.   Two  packages  related  to  this  one  are  <b>grammar::mengine</b>  and
       <b>grammar::peg::interpreter</b>.  The  first  of  them  defines a general virtual machine for the matching of a
       character stream, and the second implements an interpreter for parsing expression grammars on top of that
       virtual machine.

   <b>TERMS</b> <b>&amp;</b> <b>CONCEPTS</b>
       PEGs are similar to context-free grammars, but not equivalent; in  some  cases  PEGs  are  strictly  more
       powerful  than  context-free grammars (there exist PEGs for some non-context-free languages).  The formal
       mathematical definition of parsing expressions and parsing expression grammars can be  found  in  section
       <b>PARSING</b> <b>EXPRESSION</b> <b>GRAMMARS</b>.

       In  short,  we  have  <u>terminal</u>  <u>symbols</u>,  which  are  the  most  basic building blocks for <u>sentences</u>, and
       <u>nonterminal</u> <u>symbols</u> with associated <u>parsing</u>  <u>expressions</u>,  defining  the  grammatical  structure  of  the
       sentences.  The  two sets of symbols are distinctive, and do not overlap. When speaking about symbols the
       word "symbol" is often left out. The union of the sets of terminal and nonterminal symbols is called  the
       set of <u>symbols</u>.

       Here  the  set  of  <u>terminal</u>  <u>symbols</u> is not explicitly managed, but implicitly defined as the set of all
       characters. Note that this means that we inherit from Tcl the ability to handle all of Unicode.

       A pair of <u>nonterminal</u> and <u>parsing</u> <u>expression</u> is also called a <u>grammatical</u> <u>rule</u>, or <u>rule</u> for short. In the
       context of a rule the nonterminal is often called the left-hand-side (LHS), and  the  parsing  expression
       the right-hand-side (RHS).

       The  <u>start</u>  <u>expression</u> of a grammar is a parsing expression from which all the sentences contained in the
       language specified by the grammar are <u>derived</u>.  To make the understanding of  this  term  easier  let  us
       assume for a moment that the RHS of each rule, and the start expression, is either a sequence of symbols,
       or a series of alternate parsing expressions.  In the latter case the rule can be seen as a set of rules,
       each  providing  one  alternative  for the nonterminal.  A parsing expression A' is now a derivation of a
       parsing expression A if we pick one of the nonterminals N in the expression, and one of  the  alternative
       rules R for N, and then replace the nonterminal in A with the RHS of the chosen rule. Here we can see why
       the  terminal symbols are called such. They cannot be expanded any further, thus terminate the process of
       deriving new expressions.  An example

                  Rules
                    (1)  A &lt;- a B c
                    (2a) B &lt;- d B
                    (2b) B &lt;- e

                  Some derivations, using starting expression A.

                    A -/1/-&gt; a B c -/2a/-&gt; a d B c -/2b/-&gt; a d e c

       A derived expression containing only terminal symbols is a <u>sentence</u>. The set of all sentences  which  can
       be derived from the start expression is the <u>language</u> of the grammar.

       Some definitions for nonterminals and expressions:

       [1]    A  nonterminal  A  is  called  <u>reachable</u> if it is possible to derive a parsing expression from the
              start expression which contains A.

       [2]    A nonterminal A is called <u>useful</u> if it is possible to derive a sentence from it.

       [3]    A nonterminal A is called <u>recursive</u> if it is possible to derive a parsing expression from it which
              contains A, again.

       [4]    The <u>FIRST</u> <u>set</u> of a nonterminal A contains all the symbols which  can  occur  of  as  the  leftmost
              symbol  in  a  parsing  expression  derived  from  A. If the FIRST set contains A itself then that
              nonterminal is called <u>left-recursive</u>.

       [5]    The <u>LAST</u> <u>set</u> of a nonterminal A contains all the symbols which  can  occur  of  as  the  rightmost
              symbol  in  a  parsing  expression  derived  from  A.  If the LAST set contains A itself then that
              nonterminal is called <u>right-recursive</u>.

       [6]    The <u>FOLLOW</u> <u>set</u> of a nonterminal A contains all the symbols which can occur after A  in  a  parsing
              expression derived from the start expression.

       [7]    A nonterminal (or parsing expression) is called <u>nullable</u> if the empty sentence can be derived from
              it.

       And based on the above definitions for grammars:

       [1]    A  grammar G is <u>recursive</u> if and only if it contains a nonterminal A which is recursive. The terms
              <u>left-</u> and <u>right-recursive</u>, and <u>useful</u> are analogously defined.

       [2]    A grammar is <u>minimal</u> if it contains only <u>reachable</u> and <u>useful</u> nonterminals.

       [3]    A grammar is <u>wellformed</u> if it is not left-recursive. Such grammars are also <u>complete</u>, which  means
              that  they  always  succeed or fail on all input sentences. For an incomplete grammar on the other
              hand input sentences exist for which an attempt  to  match  them  against  the  grammar  will  not
              terminate.

       [4]    As  we  wish  to  allow  ourselves  to build a grammar incrementally in a container object we will
              encounter stages where the RHS of one or more rules reference symbols which are not yet  known  to
              the  container. Such a grammar we call <u>invalid</u>.  We cannot use the term <u>incomplete</u> as this term is
              already taken, see the last item.

   <b>CONTAINER</b> <b>CLASS</b> <b>API</b>
       The package exports the API described here.

       <b>::grammar::peg</b> <u>pegName</u> ?<b>=</b>|<b>:=</b>|<b>&lt;--</b>|<b>as</b>|<b>deserialize</b> <u>src</u>?
              The command creates a new container object for a parsing expression grammar and returns the  fully
              qualified  name  of the object command as its result. The API the returned command is following is
              described in the section <b>CONTAINER</b> <b>OBJECT</b> <b>API</b>. It may be used to invoke various operations on  the
              container and the grammar within.

              The  new container, i.e. grammar will be empty if no <u>src</u> is specified. Otherwise it will contain a
              copy of the grammar contained in the <u>src</u>.  The <u>src</u> has to be a container object reference for  all
              operators  except <b>deserialize</b>.  The <b>deserialize</b> operator requires <u>src</u> to be the serialization of a
              parsing expression grammar instead.

              An empty grammar has no nonterminal symbols, and the start expression  is  the  empty  expression,
              i.e. epsilon. It is <u>valid</u>, but not <u>useful</u>.

   <b>CONTAINER</b> <b>OBJECT</b> <b>API</b>
       All grammar container objects provide the following methods for the manipulation of their contents:

       <u>pegName</u> <b>destroy</b>
              Destroys the grammar, including its storage space and associated command.

       <u>pegName</u> <b>clear</b>
              Clears out the definition of the grammar contained in <u>pegName</u>, but does <u>not</u> destroy the object.

       <u>pegName</u> <b>=</b> <u>srcPEG</u>
              Assigns  the  contents  of  the  grammar  contained in <u>srcPEG</u> to <u>pegName</u>, overwriting any existing
              definition.  This is the assignment operator for grammars. It copies the grammar contained in  the
              grammar  object  <u>srcPEG</u>  over  the  grammar definition in <u>pegName</u>. The old contents of <u>pegName</u> are
              deleted by this operation.

              This operation is in effect equivalent to

                  <u>pegName</u> <b>deserialize</b> [<u>srcPEG</u> <b>serialize</b>]

       <u>pegName</u> <b>--&gt;</b> <u>dstPEG</u>
              This is the reverse assignment operator for grammars. It copies the automation  contained  in  the
              object  <u>pegName</u>  over the grammar definition in the object <u>dstPEG</u>.  The old contents of <u>dstPEG</u> are
              deleted by this operation.

              This operation is in effect equivalent to

                  <u>dstPEG</u> <b>deserialize</b> [<u>pegName</u> <b>serialize</b>]

       <u>pegName</u> <b>serialize</b>
              This method serializes the grammar stored in <u>pegName</u>. In  other  words  it  returns  a  tcl  <u>value</u>
              completely  describing  that  grammar.   This  allows,  for example, the transfer of grammars over
              arbitrary channels, persistence, etc.  This method is also the basis for both the copy constructor
              and the assignment operator.

              The result of this method has to  be  semantically  identical  over  all  implementations  of  the
              <b>grammar::peg</b>  interface.  This  is  what  will  enable  us  to  copy  grammars  between  different
              implementations of the same interface.

              The result is a list of four elements with the following structure:

              [1]    The constant string <b>grammar::peg</b>.

              [2]    A dictionary. Its keys are the names of all known nonterminal symbols, and their associated
                     values are the parsing expressions describing their sentennial structure.

              [3]    A dictionary. Its keys are the names of all known nonterminal symbols, and their associated
                     values hints to a matcher regarding the semantic values produced by the symbol.

              [4]    The last item is a parsing expression, the <u>start</u> <u>expression</u> of the grammar.

       Assuming the following PEG for simple mathematical expressions

                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'
                  Sign       &lt;- '+' / '-'
                  Number     &lt;- Sign? Digit+
                  Expression &lt;- '(' Expression ')' / (Factor (MulOp Factor)*)
                  MulOp      &lt;- '*' / '/'
                  Factor     &lt;- Term (AddOp Term)*
                  AddOp      &lt;- '+'/'-'
                  Term       &lt;- Number

       a possible serialization is

                  grammar::peg \
                  {Expression {/ {x ( Expression )} {x Factor {* {x MulOp Factor}}}} \
                   Factor     {x Term {* {x AddOp Term}}} \
                   Term       Number \
                   MulOp      {/ * /} \
                   AddOp      {/ + -} \
                   Number     {x {? Sign} {+ Digit}} \
                   Sign       {/ + -} \
                   Digit      {/ 0 1 2 3 4 5 6 7 8 9} \
                  } \
                  {Expression value     Factor     value \
                   Term       value     MulOp      value \
                   AddOp      value     Number     value \
                   Sign       value     Digit      value \
                  }
                  Expression

       A possible one, because the order of the nonterminals in the dictionary is not relevant.

       <u>pegName</u> <b>deserialize</b> <u>serialization</u>
              This is the complement to <b>serialize</b>. It replaces  the  grammar  definition  in  <u>pegName</u>  with  the
              grammar  described  by  the  <u>serialization</u>  value. The old contents of <u>pegName</u> are deleted by this
              operation.

       <u>pegName</u> <b>is</b> <b>valid</b>
              A predicate. It tests whether the PEG in <u>pegName</u> is <u>valid</u>.  See section <b>TERMS</b> <b>&amp;</b> <b>CONCEPTS</b>  for  the
              definition of this grammar property.  The result is a boolean value. It will be set to <b>true</b> if the
              PEG has the tested property, and <b>false</b> otherwise.

       <u>pegName</u> <b>start</b> ?<u>pe</u>?
              This  method defines the <u>start</u> <u>expression</u> of the grammar. It replaces the previously defined start
              expression with the parsing expression <u>pe</u>.  The method fails and throws an error if  <u>pe</u>  does  not
              contain  a  valid parsing expression as specified in the section <b>PARSING</b> <b>EXPRESSIONS</b>. In that case
              the existing start expression is not changed.  The method returns the empty string as its result.

              If the method is called without an argument it will return the currently defined start expression.

       <u>pegName</u> <b>nonterminals</b>
              Returns the set of all nonterminal symbols known to the grammar.

       <u>pegName</u> <b>nonterminal</b> <b>add</b> <u>nt</u> <u>pe</u>
              This method adds the nonterminal <u>nt</u> and its  associated  parsing  expression  <u>pe</u>  to  the  set  of
              nonterminal  symbols  and  rules of the PEG contained in the object <u>pegName</u>.  The method fails and
              throws an error if either the string <u>nt</u> is already known as a symbol of the grammar, or if <u>pe</u> does
              not contain a valid parsing expression as specified in the section <b>PARSING</b>  <b>EXPRESSIONS</b>.  In  that
              case  the  current  set  of  nonterminal symbols and rules is not changed.  The method returns the
              empty string as its result.

       <u>pegName</u> <b>nonterminal</b> <b>delete</b> <u>nt1</u> ?<u>nt2</u> ...?
              This method removes the named symbols <u>nt1</u>, <u>nt2</u> from the set of  nonterminal  symbols  of  the  PEG
              contained  in  the  object <u>pegName</u>.  The method fails and throws an error if any of the strings is
              not known as a nonterminal symbol. In that case the current set  of  nonterminal  symbols  is  not
              changed.  The method returns the empty string as its result.

              The stored grammar becomes invalid if the deleted nonterminals are referenced by the RHS of still-
              known rules.

       <u>pegName</u> <b>nonterminal</b> <b>exists</b> <u>nt</u>
              A  predicate.  It  tests  whether  the  nonterminal symbol <u>nt</u> is known to the PEG in <u>pegName</u>.  The
              result is a boolean value. It will be set to <b>true</b> if the symbol <u>nt</u> is known, and <b>false</b> otherwise.

       <u>pegName</u> <b>nonterminal</b> <b>rename</b> <u>nt</u> <u>ntnew</u>
              This method renames the nonterminal symbol <u>nt</u> to <u>ntnew</u>.  The method fails and throws an  error  if
              either  <u>nt</u>  is  not known as a nonterminal, or if <u>ntnew</u> is a known symbol.  The method returns the
              empty string as its result.

       <u>pegName</u> <b>nonterminal</b> <b>mode</b> <u>nt</u> ?<u>mode</u>?
              This mode returns or sets the semantic mode associated with the nonterminal symbol <u>nt</u>. If no  <u>mode</u>
              is specified the current mode of the nonterminal is returned. Otherwise the current mode is set to
              <u>mode</u>.   The  method  fails  and  throws an error if <u>nt</u> is not known as a nonterminal.  The grammar
              interpreter implemented by the package <b>grammar::peg::interpreter</b> recognizes the following modes:

              value  The semantic value of the nonterminal is the abstract syntax tree created from the AST's of
                     the RHS and a node for the nonterminal itself.

              match  The semantic value of the nonterminal is an the abstract syntax tree consisting of single a
                     node for the string matched by the RHS. The ASTs generated by the RHS are discarded.

              leaf   The semantic value of the nonterminal is an the abstract syntax tree consisting of single a
                     node for the nonterminal itself. The ASTs generated by the RHS are discarded.

              discard
                     The nonterminal has no semantic value. The ASTs generated by  the  RHS  are  discarded  (as
                     well).

       <u>pegName</u> <b>nonterminal</b> <b>rule</b> <u>nt</u>
              This  method  returns the parsing expression associated with the nonterminal <u>nt</u>.  The method fails
              and throws an error if <u>nt</u> is not known as a nonterminal.

       <u>pegName</u> <b>unknown</b> <b>nonterminals</b>
              This method returns a list containing the names of all nonterminal symbols which are referenced on
              the RHS of a grammatical rule, but have no rule definining their structure. In other words, a list
              of the nonterminal symbols which make the grammar invalid. The grammar is valid if  this  list  is
              empty.

   <b>PARSING</b> <b>EXPRESSIONS</b>
       Various  methods  of  PEG container objects expect a parsing expression as their argument, or will return
       such. This section specifies the format such parsing expressions are in.

       [1]    The string <b>epsilon</b> is an atomic parsing expression. It matches the empty string.

       [2]    The string <b>alnum</b> is an atomic parsing expression. It matches any alphanumeric character.

       [3]    The string <b>alpha</b> is an atomic parsing expression. It matches any alphabetical character.

       [4]    The string <b>dot</b> is an atomic parsing expression. It matches any character.

       [5]    The expression [list t <b>x</b>] is an atomic parsing expression. It matches the terminal string <b>x</b>.

       [6]    The expression [list n <b>A</b>] is an atomic parsing expression. It matches the nonterminal <b>A</b>.

       [7]    For parsing expressions <b>e1</b>, <b>e2</b>, ... the result of [list / <b>e1</b> <b>e2</b> ... ] is a parsing  expression  as
              well.  This is the <u>ordered</u> <u>choice</u>, aka <u>prioritized</u> <u>choice</u>.

       [8]    For  parsing  expressions <b>e1</b>, <b>e2</b>, ... the result of [list x <b>e1</b> <b>e2</b> ... ] is a parsing expression as
              well.  This is the <u>sequence</u>.

       [9]    For a parsing expression <b>e</b> the result of [list * <b>e</b>] is a parsing expression as well.  This is  the
              <u>kleene</u> <u>closure</u>, describing zero or more repetitions.

       [10]   For  a parsing expression <b>e</b> the result of [list + <b>e</b>] is a parsing expression as well.  This is the
              <u>positive</u> <u>kleene</u> <u>closure</u>, describing one or more repetitions.

       [11]   For a parsing expression <b>e</b> the result of [list &amp; <b>e</b>] is a parsing expression as well.  This is  the
              <u>and</u> <u>lookahead</u> <u>predicate</u>.

       [12]   For  a parsing expression <b>e</b> the result of [list ! <b>e</b>] is a parsing expression as well.  This is the
              <u>not</u> <u>lookahead</u> <u>predicate</u>.

       [13]   For a parsing expression <b>e</b> the result of [list ? <b>e</b>] is a parsing expression as well.  This is  the
              <u>optional</u> <u>input</u>.

       Examples of parsing expressions where already shown, in the description of the method <b>serialize</b>.

</pre><h4><b>PARSING</b> <b>EXPRESSION</b> <b>GRAMMARS</b></h4><pre>
       For the mathematically inclined, a PEG is a 4-tuple (VN,VT,R,eS) where

       •      VN is a set of <u>nonterminal</u> <u>symbols</u>,

       •      VT is a set of <u>terminal</u> <u>symbols</u>,

       •      R is a finite set of rules, where each rule is a pair (A,e), A in VN, and <u>e</u> a <u>parsing</u> <u>expression</u>.

       •      eS is a parsing expression, the <u>start</u> <u>expression</u>.

       Further constraints are

       •      The intersection of VN and VT is empty.

       •      For  all  A  in  VT  exists  exactly  one  pair  (A,e)  in R. In other words, R is a function from
              nonterminal symbols to parsing expressions.

       Parsing expression are inductively defined via

       •      The empty string (epsilon) is a parsing expression.

       •      A terminal symbol <u>a</u> is a parsing expression.

       •      A nonterminal symbol <u>A</u> is a parsing expression.

       •      <u>e1e2</u> is a parsing expression for parsing expressions <u>e1</u> and <u>2</u>. This is called <u>sequence</u>.

       •      <u>e1</u>/<u>e2</u> is a parsing expression for parsing expressions <u>e1</u> and <u>2</u>. This is called <u>ordered</u> <u>choice</u>.

       •      <u>e</u>* is a parsing expression for parsing expression <u>e</u>. This is called <u>zero-or-more</u> <u>repetitions</u>, also
              known as <u>kleene</u> <u>closure</u>.

       •      <u>e</u>+ is a parsing expression for parsing expression <u>e</u>. This is called <u>one-or-more</u> <u>repetitions</u>,  also
              known as <u>positive</u> <u>kleene</u> <u>closure</u>.

       •      !<u>e</u> is a parsing expression for parsing expression <u>e1</u>. This is called a <u>not</u> <u>lookahead</u> <u>predicate</u>.

       •      &amp;<u>e</u> is a parsing expression for parsing expression <u>e1</u>. This is called an <u>and</u> <u>lookahead</u> <u>predicate</u>.

       PEGs  are  used  to  define  a  grammatical  structure  for streams of symbols over VT. They are a modern
       phrasing of older formalisms  invented  by  Alexander  Birham.  These  formalisms  were  called  TS  (TMG
       recognition  scheme),  and  gTS  (generalized  TS).  Later  they  were  renamed to TPDL (Top-Down Parsing
       Languages) and gTPDL (generalized TPDL).

       They can be easily implemented by recursive descent parsers with backtracking. This makes them  relatives
       of LL(k) Context-Free Grammars.

</pre><h4><b>REFERENCES</b></h4><pre>
       [1]    <u>The</u>       <u>Packrat</u>       <u>Parsing</u>       <u>and</u>       <u>Parsing</u>       <u>Expression</u>       <u>Grammars</u>       <u>Page</u>
              [<a href="http://www.pdos.lcs.mit.edu/~baford/packrat/">http://www.pdos.lcs.mit.edu/~baford/packrat/</a>],  by  Bryan  Ford,   Massachusetts   Institute   of
              Technology. This is the main entry page to PEGs, and their realization through Packrat Parsers.

       [2]    <u>Parsing</u>  <u>Techniques</u>  <u>-</u>  <u>A</u>  <u>Practical</u> <u>Guide</u>  [<a href="http://www.cs.vu.nl/~dick/PTAPG.html">http://www.cs.vu.nl/~dick/PTAPG.html</a>], an online book
              offering a clear, accessible, and thorough discussion of many different  parsing  techniques  with
              their interrelations and applicabilities, including error recovery techniques.

       [3]    <u>Compilers</u>  <u>and</u>  <u>Compiler</u>  <u>Generators</u>  [<a href="http://scifac.ru.ac.za/compilers/">http://scifac.ru.ac.za/compilers/</a>],  an  online  book using
              CoCo/R, a generator for recursive descent parsers.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the category <u>grammar_peg</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       LL(k), TDPL, context-free languages, expression, grammar, parsing, parsing expression, parsing expression
       grammar, push down automaton, recursive descent, state, top-down parsing languages, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Grammars and finite automata

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2005 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 0.3                                    <u>grammar::<a href="../man3tcl/peg.3tcl.html">peg</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>