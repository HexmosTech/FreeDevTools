<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>grammar::fa::op - Operations on finite automatons</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       grammar::fa::op - Operations on finite automatons

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>snit</b>

       package require <b>struct::list</b>

       package require <b>struct::set</b>

       package require <b>grammar::fa::op</b> <b>?0.4.2?</b>

       <b>::grammar::fa::op::constructor</b> <u>cmd</u>

       <b>::grammar::fa::op::reverse</b> <u>fa</u>

       <b>::grammar::fa::op::complete</b> <u>fa</u> ?<u>sink</u>?

       <b>::grammar::fa::op::remove_eps</b> <u>fa</u>

       <b>::grammar::fa::op::trim</b> <u>fa</u> ?<u>what</u>?

       <b>::grammar::fa::op::determinize</b> <u>fa</u> ?<u>mapvar</u>?

       <b>::grammar::fa::op::minimize</b> <u>fa</u> ?<u>mapvar</u>?

       <b>::grammar::fa::op::complement</b> <u>fa</u>

       <b>::grammar::fa::op::kleene</b> <u>fa</u>

       <b>::grammar::fa::op::optional</b> <u>fa</u>

       <b>::grammar::fa::op::union</b> <u>fa</u> <u>fb</u> ?<u>mapvar</u>?

       <b>::grammar::fa::op::intersect</b> <u>fa</u> <u>fb</u> ?<u>mapvar</u>?

       <b>::grammar::fa::op::difference</b> <u>fa</u> <u>fb</u> ?<u>mapvar</u>?

       <b>::grammar::fa::op::concatenate</b> <u>fa</u> <u>fb</u> ?<u>mapvar</u>?

       <b>::grammar::fa::op::fromRegex</b> <u>fa</u> <u>regex</u> ?<u>over</u>?

       <b>::grammar::fa::op::toRegexp</b> <u>fa</u>

       <b>::grammar::fa::op::toRegexp2</b> <u>fa</u>

       <b>::grammar::fa::op::toTclRegexp</b> <u>regexp</u> <u>symdict</u>

       <b>::grammar::fa::op::simplifyRegexp</b> <u>regexp</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This package provides a number of complex operations on finite automatons (Short: FA), as provided by the
       package  <b>grammar::fa</b>.  The package does not provide the ability to create and/or manipulate such FAs, nor
       the  ability  to  execute  a  FA  for  a  stream  of  symbols.   Use   the   packages   <b>grammar::fa</b>   and
       <b>grammar::fa::interpreter</b>  for that.  Another package related to this is <b>grammar::fa::compiler</b> which turns
       a FA into an executor class which has the definition of the FA hardwired into it.

       For more information about  what  a  finite  automaton  is  see  section  <u>FINITE</u>  <u>AUTOMATONS</u>  in  package
       <b>grammar::fa</b>.

</pre><h4><b>API</b></h4><pre>
       The  package  exports the API described here.  All commands modify their first argument. I.e. whatever FA
       they compute is stored back into it. Some of the operations will construct an automaton whose states  are
       all  new,  but  related to the states in the source automaton(s). These operations take variable names as
       optional arguments where they will store mappings which describe the relationship(s).  The operations can
       be loosely partitioned into structural and language operations. The latter are defined in  terms  of  the
       language the automaton(s) accept, whereas the former are defined in terms of the structural properties of
       the involved automaton(s). Some operations are both.  <u>Structure</u> <u>operations</u>

       <b>::grammar::fa::op::constructor</b> <u>cmd</u>
              This command has to be called by the user of the package before any other operations is performed,
              to  establish  a command which can be used to construct a FA container object. If this is not done
              several operations will fail as they are unable to construct internal and transient containers  to
              hold state and/or partial results.

              Any  container class using this package for complex operations should set its own class command as
              the constructor. See package <b>grammar::fa</b> for an example.

       <b>::grammar::fa::op::reverse</b> <u>fa</u>
              Reverses the <u>fa</u>. This is done by reversing the direction of all transitions and swapping the  sets
              of <u>start</u> and <u>final</u> states. The language of <u>fa</u> changes unpredictably.

       <b>::grammar::fa::op::complete</b> <u>fa</u> ?<u>sink</u>?
              Completes  the  <u>fa</u>  <u>complete</u>, but nothing is done if the <u>fa</u> is already <u>complete</u>. This implies that
              only the first in a series  of  multiple  consecutive  complete  operations  on  <u>fa</u>  will  perform
              anything. The remainder will be null operations.

              The language of <u>fa</u> is unchanged by this operation.

              This is done by adding a single new state, the <u>sink</u>, and transitions from all other states to that
              sink for all symbols they have no transitions for. The sink itself is made complete by adding loop
              transitions for all symbols.

              Note:  When  a FA has epsilon-transitions transitions over a symbol for a state S can be indirect,
              i.e. not attached directly to S, but to a state in the epsilon-closure of S. The symbols for  such
              indirect  transitions  count  when  computing  completeness  of  a  state.  In  other words, these
              indirectly reached symbols are <u>not</u> missing.

              The argument <u>sink</u> provides the name for the new state and  most  not  be  present  in  the  <u>fa</u>  if
              specified. If the name is not specified the command will name the state "sink<b>n</b>", where <b>n</b> is set so
              that there are no collisions with existing states.

              Note  that  the  sink  state  is  <u>not</u>  <u>useful</u> by definition.  In other words, while the FA becomes
              complete, it is also <u>not</u> <u>useful</u> in the strict sense as it has a state from which  no  final  state
              can be reached.

       <b>::grammar::fa::op::remove_eps</b> <u>fa</u>
              Removes  all epsilon-transitions from the <u>fa</u> in such a manner the the language of <u>fa</u> is unchanged.
              However nothing is done if the <u>fa</u> is already <u>epsilon-free</u>.  This implies that only the first in  a
              series of multiple consecutive complete operations on <u>fa</u> will perform anything. The remainder will
              be null operations.

              <u>Note:</u>  This  operation  may cause states to become unreachable or not useful. These states are not
              removed by this operation.  Use <b>::grammar::fa::op::trim</b> for that instead.

       <b>::grammar::fa::op::trim</b> <u>fa</u> ?<u>what</u>?
              Removes unwanted baggage from <u>fa</u>.  The legal  values  for  <u>what</u>  are  listed  below.  The  command
              defaults to <b>!reachable|!useful</b> if no specific argument was given.

              <b>!reachable</b>
                     Removes all states which are not reachable from a start state.

              <b>!useful</b>
                     Removes all states which are unable to reach a final state.

              <b>!reachable&amp;!useful</b>

              <b>!(reachable|useful)</b>
                     Removes  all  states  which  are not reachable from a start state and are unable to reach a
                     final state.

              <b>!reachable|!useful</b>

              <b>!(reachable&amp;useful)</b>
                     Removes all states which are not reachable from a start state or  are  unable  to  reach  a
                     final state.

       <b>::grammar::fa::op::determinize</b> <u>fa</u> ?<u>mapvar</u>?
              Makes  the  <u>fa</u>  deterministic without changing the language accepted by the <u>fa</u>. However nothing is
              done if the <u>fa</u> is already <u>deterministic</u>. This implies that only the first in a series of  multiple
              consecutive  complete  operations  on  <u>fa</u>  will  perform  anything.  The  remainder  will  be null
              operations.

              The command will store a dictionary describing the relationship between  the  new  states  of  the
              resulting  dfa  and  the  states of the input nfa in <u>mapvar</u>, if it has been specified. Keys of the
              dictionary are the handles for the states of the resulting dfa, values are sets of states from the
              input nfa.

              <u>Note</u>: An empty dictionary signals that the command was able to make the <u>fa</u>  deterministic  without
              performing  a  full  subset construction, just by removing states and shuffling transitions around
              (As part of making the FA epsilon-free).

              <u>Note</u>: The algorithm fails to make the FA deterministic in the technical sense if  the  FA  has  no
              start  state(s),  because  determinism  requires the FA to have exactly one start states.  In that
              situation we make a best effort; and the missing start state will be the only condition preventing
              the generated result from being <u>deterministic</u>.  It should also be noted  that  in  this  case  the
              possibilities  for  trimming  states  from  the  FA are also severely reduced as we cannot declare
              states unreachable.

       <b>::grammar::fa::op::minimize</b> <u>fa</u> ?<u>mapvar</u>?
              Creates a FA which accepts the same language as <u>fa</u>, but has  a  minimal  number  of  states.  Uses
              Brzozowski's method to accomplish this.

              The  command  will  store  a  dictionary describing the relationship between the new states of the
              resulting minimal fa and the states of the input fa in <u>mapvar</u>, if it has been specified.  Keys  of
              the  dictionary  are  the  handles  for the states of the resulting minimal fa, values are sets of
              states from the input fa.

              <u>Note</u>: An empty dictionary signals that the command was able to minimize the <u>fa</u> without  having  to
              compute new states. This should happen if and only if the input FA was already minimal.

              <u>Note</u>:  If  the  algorithm  has  no  start  or  final  states to work with then the result might be
              technically minimal, but have a very unexpected structure.  It should also be noted that  in  this
              case  the  possibilities  for  trimming  states from the FA are also severely reduced as we cannot
              declare states unreachable.

       <u>Language</u> <u>operations</u> All operations in this section require that all input FAs have at least one start and
       at least one final state. Otherwise the language of the FAs will not be  defined,  making  the  operation
       senseless (as it operates on the languages of the FAs in a defined manner).

       <b>::grammar::fa::op::complement</b> <u>fa</u>
              Complements <u>fa</u>. This is possible if and only if <u>fa</u> is <u>complete</u> and <u>deterministic</u>. The resulting FA
              accepts the complementary language of <u>fa</u>. In other words, all inputs not accepted by the input are
              accepted by the result, and vice versa.

              The result will have all states and transitions of the input, and different final states.

       <b>::grammar::fa::op::kleene</b> <u>fa</u>
              Applies  Kleene's  closure  to <u>fa</u>.  The resulting FA accepts all strings <b>S</b> for which we can find a
              natural number <b>n</b> (0 inclusive) and strings <b>A1</b> ... <b>An</b> in the language of <u>fa</u>  such  that  <b>S</b>  is  the
              concatenation of <b>A1</b> ... <b>An</b>.  In other words, the language of the result is the infinite union over
              finite length concatenations over the language of <u>fa</u>.

              The result will have all states and transitions of the input, and new start and final states.

       <b>::grammar::fa::op::optional</b> <u>fa</u>
              Makes  the <u>fa</u> optional. In other words it computes the FA which accepts the language of <u>fa</u> and the
              empty the word (epsilon) as well.

              The result will have all states and transitions of the input, and new start and final states.

       <b>::grammar::fa::op::union</b> <u>fa</u> <u>fb</u> ?<u>mapvar</u>?
              Combines the FAs <u>fa</u> and <u>fb</u> such that the resulting FA accepts the union of the  languages  of  the
              two FAs.

              The  result  will  have  all  states and transitions of the two input FAs, and new start and final
              states. All states of <u>fb</u> which exist in <u>fa</u> as well will be renamed, and the <u>mapvar</u> will contain  a
              mapping from the old states of <u>fb</u> to the new ones, if present.

              It  should  be  noted  that  the  result  will  be  non-deterministic,  even  if  the  inputs  are
              deterministic.

       <b>::grammar::fa::op::intersect</b> <u>fa</u> <u>fb</u> ?<u>mapvar</u>?
              Combines the FAs <u>fa</u> and <u>fb</u> such that the resulting FA accepts the intersection of the languages of
              the two FAs. In other words, the result will accept a word if and only if the word is accepted  by
              both <u>fa</u> and <u>fb</u>. The result will be useful, but not necessarily deterministic or minimal.

              The  command  will  store  a  dictionary describing the relationship between the new states of the
              resulting fa and the pairs of states of the input FAs in <u>mapvar</u>, if it has been specified. Keys of
              the dictionary are the handles for the states of the resulting fa, values are pairs of states from
              the input FAs. Pairs are represented by lists. The first element in each pair will be a  state  in
              <u>fa</u>, the second element will be drawn from <u>fb</u>.

       <b>::grammar::fa::op::difference</b> <u>fa</u> <u>fb</u> ?<u>mapvar</u>?
              Combines  the  FAs <u>fa</u> and <u>fb</u> such that the resulting FA accepts the difference of the languages of
              the two FAs. In other words, the result will accept a word if and only if the word is accepted  by
              <u>fa</u>, but not by <u>fb</u>. This can also be expressed as the intersection of <u>fa</u> with the complement of <u>fb</u>.
              The result will be useful, but not necessarily deterministic or minimal.

              The  command  will  store  a  dictionary describing the relationship between the new states of the
              resulting fa and the pairs of states of the input FAs in <u>mapvar</u>, if it has been specified. Keys of
              the dictionary are the handles for the states of the resulting fa, values are pairs of states from
              the input FAs. Pairs are represented by lists. The first element in each pair will be a  state  in
              <u>fa</u>, the second element will be drawn from <u>fb</u>.

       <b>::grammar::fa::op::concatenate</b> <u>fa</u> <u>fb</u> ?<u>mapvar</u>?
              Combines  the  FAs <u>fa</u> and <u>fb</u> such that the resulting FA accepts the cross-product of the languages
              of the two FAs. I.e. a word W will be accepted by the result if  there  are  two  words  A  and  B
              accepted by <u>fa</u>, and <u>fb</u> resp. and W is the concatenation of A and B.

              The result FA will be non-deterministic.

       <b>::grammar::fa::op::fromRegex</b> <u>fa</u> <u>regex</u> ?<u>over</u>?
              Generates  a non-deterministic FA which accepts the same language as the regular expression <u>regex</u>.
              If the <u>over</u> is specified it is treated as the set  of  symbols  the  regular  expression  and  the
              automaton  are  defined  over. The command will compute the set from the "S" constructors in <u>regex</u>
              when <u>over</u> was not specified. This set is important if and only if the complement operator  "!"  is
              used  in  <u>regex</u>  as  the  complementary language of an FA is quite different for different sets of
              symbols.

              The regular expression is represented by a nested list, which forms a syntax tree.  The  following
              structures are legal:

              {S x}  Atomic  regular  expression.  Everything else is constructed from these. Accepts the <b>S</b>ymbol
                     "x".

              {. A1 A2 ...}
                     Concatenation operator. Accepts the concatenation of the regular expressions <b>A1</b>, <b>A2</b>, etc.

                     <u>Note</u> that this operator accepts zero or more arguments. With zero arguments the represented
                     language is <u>epsilon</u>, the empty word.

              {| A1 A2 ...}
                     Choice operator, also called "Alternative". Accepts all input accepted by at least  one  of
                     the regular expressions <b>A1</b>, <b>A2</b>, etc. In other words, the union of <b>A1</b>, <b>A2</b>.

                     <u>Note</u> that this operator accepts zero or more arguments. With zero arguments the represented
                     language is the <u>empty</u> language, the language without words.

              {&amp; A1 A2 ...}
                     Intersection  operator, logical and. Accepts all input accepted which is accepted by all of
                     the regular expressions <b>A1</b>, <b>A2</b>, etc. In other words, the intersection of <b>A1</b>, <b>A2</b>.

              {? A}  Optionality operator. Accepts the empty word and anything from the regular expression <b>A</b>.

              {* A}  Kleene closure. Accepts the empty word and any finite concatenation of  words  accepted  by
                     the regular expression <b>A</b>.

              {+ A}  Positive  Kleene closure. Accepts any finite concatenation of words accepted by the regular
                     expression <b>A</b>, but not the empty word.

              {! A}  Complement operator. Accepts any word not accepted by the regular expression <b>A</b>.  Note  that
                     the  complement depends on the set of symbol the result should run over. See the discussion
                     of the argument <u>over</u> before.

       <b>::grammar::fa::op::toRegexp</b> <u>fa</u>
              This command generates and returns a regular expression which accepts the  same  language  as  the
              finite   automaton  <u>fa</u>.  The  regular  expression  is  in  the  format  as  described  above,  for
              <b>::grammar::fa::op::fromRegex</b>.

       <b>::grammar::fa::op::toRegexp2</b> <u>fa</u>
              This command has the same functionality  as  <b>::grammar::fa::op::toRegexp</b>,  but  uses  a  different
              algorithm to simplify the generated regular expressions.

       <b>::grammar::fa::op::toTclRegexp</b> <u>regexp</u> <u>symdict</u>
              This  command  generates and returns a regular expression in Tcl syntax for the regular expression
              <u>regexp</u>,   if   that   is   possible.   <u>regexp</u>   is   in   the   same   format   as   expected   by
              <b>::grammar::fa::op::fromRegex</b>.

              The  command  will  fail  and  throw  an error if <u>regexp</u> contains complementation and intersection
              operations.

              The argument <u>symdict</u> is a dictionary mapping symbol names to pairs  of  <u>syntactic</u>  <u>type</u>  and  Tcl-
              regexp. If a symbol occurring in the <u>regexp</u> is not listed in this dictionary then single-character
              symbols  are  considered to designate themselves whereas multiple-character symbols are considered
              to be a character class name.

       <b>::grammar::fa::op::simplifyRegexp</b> <u>regexp</u>
              This command simplifies a regular expression by applying the following algorithm first to the main
              expression and then recursively to all sub-expressions:

              [1]    Convert the expression into a finite automaton.

              [2]    Minimize the automaton.

              [3]    Convert the automaton back to a regular expression.

              [4]    Choose the shorter of original expression and expression from the previous step.

</pre><h4><b>EXAMPLES</b></h4><pre>
</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category <u>grammar_fa</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       automaton, finite automaton, grammar, parsing, regular expression, regular  grammar,  regular  languages,
       state, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Grammars and finite automata

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2004-2008 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 0.4                                 <u>grammar::fa::<a href="../man3tcl/op.3tcl.html">op</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>