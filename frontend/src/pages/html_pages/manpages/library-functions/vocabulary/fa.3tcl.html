<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>grammar::fa - Create and manipulate finite automatons</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       grammar::fa - Create and manipulate finite automatons

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>snit</b> <b>1.3</b>

       package require <b>struct::list</b>

       package require <b>struct::set</b>

       package require <b>grammar::fa::op</b> <b>?0.3?</b>

       package require <b>grammar::fa</b> <b>?0.6?</b>

       <b>::grammar::fa</b> <u>faName</u> ?<b>=</b>|<b>:=</b>|<b>&lt;--</b>|<b>as</b>|<b>deserialize</b> <u>src</u>|<b>fromRegex</b> <u>re</u> ?<u>over</u>??

       <b>faName</b> <u>option</u> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <u>faName</u> <b>destroy</b>

       <u>faName</u> <b>clear</b>

       <u>faName</u> <b>=</b> <u>srcFA</u>

       <u>faName</u> <b>--&gt;</b> <u>dstFA</u>

       <u>faName</u> <b>serialize</b>

       <u>faName</u> <b>deserialize</b> <u>serialization</u>

       <u>faName</u> <b>states</b>

       <u>faName</u> <b>state</b> <b>add</b> <u>s1</u> ?<u>s2</u> ...?

       <u>faName</u> <b>state</b> <b>delete</b> <u>s1</u> ?<u>s2</u> ...?

       <u>faName</u> <b>state</b> <b>exists</b> <u>s</u>

       <u>faName</u> <b>state</b> <b>rename</b> <u>s</u> <u>snew</u>

       <u>faName</u> <b>startstates</b>

       <u>faName</u> <b>start</b> <b>add</b> <u>s1</u> ?<u>s2</u> ...?

       <u>faName</u> <b>start</b> <b>remove</b> <u>s1</u> ?<u>s2</u> ...?

       <u>faName</u> <b>start?</b> <u>s</u>

       <u>faName</u> <b>start?set</b> <u>stateset</u>

       <u>faName</u> <b>finalstates</b>

       <u>faName</u> <b>final</b> <b>add</b> <u>s1</u> ?<u>s2</u> ...?

       <u>faName</u> <b>final</b> <b>remove</b> <u>s1</u> ?<u>s2</u> ...?

       <u>faName</u> <b>final?</b> <u>s</u>

       <u>faName</u> <b>final?set</b> <u>stateset</u>

       <u>faName</u> <b>symbols</b>

       <u>faName</u> <b>symbols@</b> <u>s</u> ?<u>d</u>?

       <u>faName</u> <b>symbols@set</b> <u>stateset</u>

       <u>faName</u> <b>symbol</b> <b>add</b> <u>sym1</u> ?<u>sym2</u> ...?

       <u>faName</u> <b>symbol</b> <b>delete</b> <u>sym1</u> ?<u>sym2</u> ...?

       <u>faName</u> <b>symbol</b> <b>rename</b> <u>sym</u> <u>newsym</u>

       <u>faName</u> <b>symbol</b> <b>exists</b> <u>sym</u>

       <u>faName</u> <b>next</b> <u>s</u> <u>sym</u> ?<b>--&gt;</b> <u>next</u>?

       <u>faName</u> <b>!next</b> <u>s</u> <u>sym</u> ?<b>--&gt;</b> <u>next</u>?

       <u>faName</u> <b>nextset</b> <u>stateset</u> <u>sym</u>

       <u>faName</u> <b>is</b> <b>deterministic</b>

       <u>faName</u> <b>is</b> <b>complete</b>

       <u>faName</u> <b>is</b> <b>useful</b>

       <u>faName</u> <b>is</b> <b>epsilon-free</b>

       <u>faName</u> <b>reachable_states</b>

       <u>faName</u> <b>unreachable_states</b>

       <u>faName</u> <b>reachable</b> <u>s</u>

       <u>faName</u> <b>useful_states</b>

       <u>faName</u> <b>unuseful_states</b>

       <u>faName</u> <b>useful</b> <u>s</u>

       <u>faName</u> <b>epsilon_closure</b> <u>s</u>

       <u>faName</u> <b>reverse</b>

       <u>faName</u> <b>complete</b>

       <u>faName</u> <b>remove_eps</b>

       <u>faName</u> <b>trim</b> ?<u>what</u>?

       <u>faName</u> <b>determinize</b> ?<u>mapvar</u>?

       <u>faName</u> <b>minimize</b> ?<u>mapvar</u>?

       <u>faName</u> <b>complement</b>

       <u>faName</u> <b>kleene</b>

       <u>faName</u> <b>optional</b>

       <u>faName</u> <b>union</b> <u>fa</u> ?<u>mapvar</u>?

       <u>faName</u> <b>intersect</b> <u>fa</u> ?<u>mapvar</u>?

       <u>faName</u> <b>difference</b> <u>fa</u> ?<u>mapvar</u>?

       <u>faName</u> <b>concatenate</b> <u>fa</u> ?<u>mapvar</u>?

       <u>faName</u> <b>fromRegex</b> <u>regex</u> ?<u>over</u>?

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  package  provides  a  container class for <u>finite</u> <u>automatons</u> (Short: FA).  It allows the incremental
       definition of the automaton, its manipulation and querying of the definition.  While the package provides
       complex operations on the automaton (via package <b>grammar::fa::op</b>),  it  does  not  have  the  ability  to
       execute   a   definition   for  a  stream  of  symbols.   Use  the  packages  <b>grammar::fa::dacceptor</b>  and
       <b>grammar::fa::dexec</b> for that.  Another package related to this is <b>grammar::fa::compiler</b>.  It  turns  a  FA
       into  an  executor class which has the definition of the FA hardwired into it. The output of this package
       is configurable to suit a large number of different implementation languages and paradigms.

       For more information about what a finite automaton is see section <b>FINITE</b> <b>AUTOMATONS</b>.

</pre><h4><b>API</b></h4><pre>
       The package exports the API described here.

       <b>::grammar::fa</b> <u>faName</u> ?<b>=</b>|<b>:=</b>|<b>&lt;--</b>|<b>as</b>|<b>deserialize</b> <u>src</u>|<b>fromRegex</b> <u>re</u> ?<u>over</u>??
              Creates a new finite automaton with an associated global Tcl command whose name  is  <u>faName</u>.  This
              command  may  be  used to invoke various operations on the automaton. It has the following general
              form:

              <b>faName</b> <u>option</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
                     <u>Option</u> and the <u>arg</u>s determine the exact behavior of the command. See section <b>FA</b> <b>METHODS</b> for
                     more explanations. The new automaton will be empty if no <u>src</u>  is  specified.  Otherwise  it
                     will  contain a copy of the definition contained in the <u>src</u>.  The <u>src</u> has to be a FA object
                     reference for all operators except <b>deserialize</b>  and  <b>fromRegex</b>.  The  <b>deserialize</b>  operator
                     requires  <u>src</u>  to  be  the  serialization  of  a  FA instead, and <b>fromRegex</b> takes a regular
                     expression in the form a of a syntax tree. See <b>::grammar::fa::op::fromRegex</b> for more detail
                     on that.

</pre><h4><b>FA</b> <b>METHODS</b></h4><pre>
       All automatons provide the following methods for their manipulation:

       <u>faName</u> <b>destroy</b>
              Destroys the automaton, including its storage space and associated command.

       <u>faName</u> <b>clear</b>
              Clears out the definition of the automaton contained in <u>faName</u>, but does <u>not</u> destroy the object.

       <u>faName</u> <b>=</b> <u>srcFA</u>
              Assigns the contents of the automaton contained in  <u>srcFA</u>  to  <u>faName</u>,  overwriting  any  existing
              definition.   This is the assignment operator for automatons. It copies the automaton contained in
              the FA object <u>srcFA</u> over the automaton definition in  <u>faName</u>.  The  old  contents  of  <u>faName</u>  are
              deleted by this operation.

              This operation is in effect equivalent to

                  <u>faName</u> <b>deserialize</b> [<u>srcFA</u> <b>serialize</b>]

       <u>faName</u> <b>--&gt;</b> <u>dstFA</u>
              This  is the reverse assignment operator for automatons. It copies the automation contained in the
              object <u>faName</u> over the automaton definition in the object <u>dstFA</u>.  The old contents  of  <u>dstFA</u>  are
              deleted by this operation.

              This operation is in effect equivalent to

                  <u>dstFA</u> <b>deserialize</b> [<u>faName</u> <b>serialize</b>]

       <u>faName</u> <b>serialize</b>
              This  method  serializes  the  automaton  stored  in <u>faName</u>. In other words it returns a tcl <u>value</u>
              completely describing that automaton.  This allows, for example, the transfer of  automatons  over
              arbitrary channels, persistence, etc.  This method is also the basis for both the copy constructor
              and the assignment operator.

              The  result  of  this  method  has  to  be  semantically identical over all implementations of the
              <b>grammar::fa</b> interface.  This  is  what  will  enable  us  to  copy  automatons  between  different
              implementations of the same interface.

              The result is a list of three elements with the following structure:

              [1]    The constant string <b>grammar::fa</b>.

              [2]    A  list containing the names of all known input symbols. The order of elements in this list
                     is not relevant.

              [3]    The last item in the list is a dictionary, however the order of the keys  is  important  as
                     well.  The  keys are the states of the serialized FA, and their order is the order in which
                     to  create  the  states  when  deserializing.  This  is  relevant  to  preserve  the  order
                     relationship between states.

                     The value of each dictionary entry is a list of three elements describing the state in more
                     detail.

                     [1]    A  boolean  flag. If its value is <b>true</b> then the state is a start state, otherwise it
                            is not.

                     [2]    A boolean flag. If its value is <b>true</b> then the state is a final state,  otherwise  it
                            is not.

                     [3]    The  last element is a dictionary describing the transitions for the state. The keys
                            are symbols (or the empty string), and the values are sets of successor states.

       Assuming the following FA (which describes the life of a truck driver in a very simple way :)

                  Drive -- yellow --&gt; Brake -- red --&gt; (Stop) -- red/yellow --&gt; Attention -- green --&gt; Drive
                  (...) is the start state.

       a possible serialization is

                  grammar::fa \
                  {yellow red green red/yellow} \
                  {Drive     {0 0 {yellow     Brake}} \
                   Brake     {0 0 {red        Stop}} \
                   Stop      {1 0 {red/yellow Attention}} \
                   Attention {0 0 {green      Drive}}}

       A possible one, because I did not care about creation order here

       <u>faName</u> <b>deserialize</b> <u>serialization</u>
              This is the complement to <b>serialize</b>. It replaces the  automaton  definition  in  <u>faName</u>  with  the
              automaton  described  by  the  <u>serialization</u> value. The old contents of <u>faName</u> are deleted by this
              operation.

       <u>faName</u> <b>states</b>
              Returns the set of all states known to <u>faName</u>.

       <u>faName</u> <b>state</b> <b>add</b> <u>s1</u> ?<u>s2</u> ...?
              Adds the states <u>s1</u>, <u>s2</u>, et cetera to the FA definition in <u>faName</u>. The operation will fail  any  of
              the new states is already declared.

       <u>faName</u> <b>state</b> <b>delete</b> <u>s1</u> ?<u>s2</u> ...?
              Deletes  the  state  <u>s1</u>,  <u>s2</u>,  et cetera, and all associated information from the FA definition in
              <u>faName</u>. The latter means that the information about in- or  outbound  transitions  is  deleted  as
              well.  If  the  deleted  state  was a start or final state then this information is invalidated as
              well. The operation will fail if the state <u>s</u> is not known to the FA.

       <u>faName</u> <b>state</b> <b>exists</b> <u>s</u>
              A predicate. It tests whether the state <u>s</u> is known to the FA in <u>faName</u>.  The result is  a  boolean
              value. It will be set to <b>true</b> if the state <u>s</u> is known, and <b>false</b> otherwise.

       <u>faName</u> <b>state</b> <b>rename</b> <u>s</u> <u>snew</u>
              Renames  the state <u>s</u> to <u>snew</u>. Fails if <u>s</u> is not a known state. Also fails if <u>snew</u> is already known
              as a state.

       <u>faName</u> <b>startstates</b>
              Returns the set of states which are marked as <u>start</u> states, also known  as  <u>initial</u>  states.   See
              <b>FINITE</b> <b>AUTOMATONS</b> for explanations what this means.

       <u>faName</u> <b>start</b> <b>add</b> <u>s1</u> ?<u>s2</u> ...?
              Mark the states <u>s1</u>, <u>s2</u>, et cetera in the FA <u>faName</u> as <u>start</u> (aka <u>initial</u>).

       <u>faName</u> <b>start</b> <b>remove</b> <u>s1</u> ?<u>s2</u> ...?
              Mark the states <u>s1</u>, <u>s2</u>, et cetera in the FA <u>faName</u> as <u>not</u> <u>start</u> (aka <u>not</u> <u>accepting</u>).

       <u>faName</u> <b>start?</b> <u>s</u>
              A  predicate.  It  tests if the state <u>s</u> in the FA <u>faName</u> is <u>start</u> or not.  The result is a boolean
              value. It will be set to <b>true</b> if the state <u>s</u> is <u>start</u>, and <b>false</b> otherwise.

       <u>faName</u> <b>start?set</b> <u>stateset</u>
              A predicate. It tests if the set of states <u>stateset</u>  contains  at  least  one  start  state.  They
              operation  will  fail  if the set contains an element which is not a known state.  The result is a
              boolean value. It will be set to <b>true</b>  if  a  start  state  is  present  in  <u>stateset</u>,  and  <b>false</b>
              otherwise.

       <u>faName</u> <b>finalstates</b>
              Returns  the  set of states which are marked as <u>final</u> states, also known as <u>accepting</u> states.  See
              <b>FINITE</b> <b>AUTOMATONS</b> for explanations what this means.

       <u>faName</u> <b>final</b> <b>add</b> <u>s1</u> ?<u>s2</u> ...?
              Mark the states <u>s1</u>, <u>s2</u>, et cetera in the FA <u>faName</u> as <u>final</u> (aka <u>accepting</u>).

       <u>faName</u> <b>final</b> <b>remove</b> <u>s1</u> ?<u>s2</u> ...?
              Mark the states <u>s1</u>, <u>s2</u>, et cetera in the FA <u>faName</u> as <u>not</u> <u>final</u> (aka <u>not</u> <u>accepting</u>).

       <u>faName</u> <b>final?</b> <u>s</u>
              A predicate. It tests if the state <u>s</u> in the FA <u>faName</u> is <u>final</u> or not.  The result  is  a  boolean
              value. It will be set to <b>true</b> if the state <u>s</u> is <u>final</u>, and <b>false</b> otherwise.

       <u>faName</u> <b>final?set</b> <u>stateset</u>
              A  predicate.  It  tests  if  the  set  of states <u>stateset</u> contains at least one final state. They
              operation will fail if the set contains an element which is not a known state.  The  result  is  a
              boolean  value.  It  will  be  set  to  <b>true</b>  if  a  final state is present in <u>stateset</u>, and <b>false</b>
              otherwise.

       <u>faName</u> <b>symbols</b>
              Returns the set of all symbols known to the FA <u>faName</u>.

       <u>faName</u> <b>symbols@</b> <u>s</u> ?<u>d</u>?
              Returns the set of all symbols for which the state <u>s</u> has transitions.   If  the  empty  symbol  is
              present  then  <u>s</u>  has  epsilon  transitions.  If two states are specified the result is the set of
              symbols which have transitions from <u>s</u> to <u>t</u>. This set may be empty  if  there  are  no  transitions
              between the two specified states.

       <u>faName</u> <b>symbols@set</b> <u>stateset</u>
              Returns  the  set  of  all  symbols for which at least one state in the set of states <u>stateset</u> has
              transitions.  In other words, the union of [<u>faName</u> <b>symbols@</b> <b>s</b>] for all states <b>s</b> in  <u>stateset</u>.   If
              the empty symbol is present then at least one state contained in <u>stateset</u> has epsilon transitions.

       <u>faName</u> <b>symbol</b> <b>add</b> <u>sym1</u> ?<u>sym2</u> ...?
              Adds the symbols <u>sym1</u>, <u>sym2</u>, et cetera to the FA definition in <u>faName</u>. The operation will fail any
              of the symbols is already declared. The empty string is not allowed as a value for the symbols.

       <u>faName</u> <b>symbol</b> <b>delete</b> <u>sym1</u> ?<u>sym2</u> ...?
              Deletes the symbols <u>sym1</u>, <u>sym2</u> et cetera, and all associated information from the FA definition in
              <u>faName</u>. The latter means that all transitions using the symbols are deleted as well. The operation
              will fail if any of the symbols is not known to the FA.

       <u>faName</u> <b>symbol</b> <b>rename</b> <u>sym</u> <u>newsym</u>
              Renames  the  symbol  <u>sym</u>  to  <u>newsym</u>. Fails if <u>sym</u> is not a known symbol. Also fails if <u>newsym</u> is
              already known as a symbol.

       <u>faName</u> <b>symbol</b> <b>exists</b> <u>sym</u>
              A predicate. It tests whether the symbol <u>sym</u> is known to the  FA  in  <u>faName</u>.   The  result  is  a
              boolean value. It will be set to <b>true</b> if the symbol <u>sym</u> is known, and <b>false</b> otherwise.

       <u>faName</u> <b>next</b> <u>s</u> <u>sym</u> ?<b>--&gt;</b> <u>next</u>?
              Define or query transition information.

              If  <u>next</u>  is  specified,  then  the method will add a transition from the state <u>s</u> to the <u>successor</u>
              state <u>next</u> labeled with the symbol <u>sym</u> to the FA contained in <u>faName</u>. The operation will  fail  if
              <u>s</u>,  or  <u>next</u>  are not known states, or if <u>sym</u> is not a known symbol. An exception to the latter is
              that <u>sym</u> is allowed to be the empty string.  In  that  case  the  new  transition  is  an  <u>epsilon</u>
              <u>transition</u>  which  will  not  consume  input  when  traversed. The operation will also fail if the
              combination of (<u>s</u>, <u>sym</u>, and <u>next</u>) is already present in the FA.

              If <u>next</u> was not specified, then the method will return the set of states which can be reached from
              <u>s</u> through a single transition labeled with symbol <u>sym</u>.

       <u>faName</u> <b>!next</b> <u>s</u> <u>sym</u> ?<b>--&gt;</b> <u>next</u>?
              Remove one or more transitions from the Fa in <u>faName</u>.

              If <u>next</u> was specified then the single transition from the state <u>s</u> to the state <u>next</u>  labeled  with
              the  symbol  <u>sym</u>  is  removed  from  the  FA. Otherwise <u>all</u> transitions originating in state <u>s</u> and
              labeled with the symbol <u>sym</u> will be removed.

              The operation will fail if <u>s</u> and/or <u>next</u> are not known as states. It will also fail if a non-empty
              <u>sym</u> is not known as symbol. The empty string is acceptable, and  allows  the  removal  of  epsilon
              transitions.

       <u>faName</u> <b>nextset</b> <u>stateset</u> <u>sym</u>
              Returns  the  set  of states which can be reached by a single transition originating in a state in
              the set <u>stateset</u> and labeled with the symbol <u>sym</u>.

              In other words, this is the union of [<u>faName</u> next <b>s</b> <u>symbol</u>] for all states <b>s</b> in <u>stateset</u>.

       <u>faName</u> <b>is</b> <b>deterministic</b>
              A predicate. It tests whether the FA in <u>faName</u> is a deterministic FA or  not.   The  result  is  a
              boolean value. It will be set to <b>true</b> if the FA is deterministic, and <b>false</b> otherwise.

       <u>faName</u> <b>is</b> <b>complete</b>
              A predicate. It tests whether the FA in <u>faName</u> is a complete FA or not. A FA is complete if it has
              at least one transition per state and symbol. This also means that a FA without symbols, or states
              is  also  complete.   The  result  is  a  boolean  value.  It  will  be  set  to <b>true</b> if the FA is
              deterministic, and <b>false</b> otherwise.

              Note: When a FA has epsilon-transitions transitions over a symbol for a state S can  be  indirect,
              i.e.  not attached directly to S, but to a state in the epsilon-closure of S. The symbols for such
              indirect transitions count when computing completeness.

       <u>faName</u> <b>is</b> <b>useful</b>
              A predicate. It tests whether the FA in <u>faName</u> is an useful FA or not.  A  FA  is  useful  if  all
              states  are <u>reachable</u> and <u>useful</u>.  The result is a boolean value. It will be set to <b>true</b> if the FA
              is deterministic, and <b>false</b> otherwise.

       <u>faName</u> <b>is</b> <b>epsilon-free</b>
              A predicate. It tests whether the FA in <u>faName</u> is an epsilon-free FA or not. A FA is  epsilon-free
              if  it  has  no epsilon transitions. This definition means that all deterministic FAs are epsilon-
              free as well, and epsilon-freeness is  a  necessary  pre-condition  for  deterministic'ness.   The
              result is a boolean value. It will be set to <b>true</b> if the FA is deterministic, and <b>false</b> otherwise.

       <u>faName</u> <b>reachable_states</b>
              Returns the set of states which are reachable from a start state by one or more transitions.

       <u>faName</u> <b>unreachable_states</b>
              Returns  the  set  of  states  which  are  not  reachable  from  any  start state by any number of
              transitions. This is

                 [faName states] - [faName reachable_states]

       <u>faName</u> <b>reachable</b> <u>s</u>
              A predicate. It tests whether the state <u>s</u> in the FA <u>faName</u> can be reached from a  start  state  by
              one  or  more transitions.  The result is a boolean value. It will be set to <b>true</b> if the state can
              be reached, and <b>false</b> otherwise.

       <u>faName</u> <b>useful_states</b>
              Returns the set of states which are able to reach a final state by one or more transitions.

       <u>faName</u> <b>unuseful_states</b>
              Returns the set of states which are not able to reach a final state by any number of  transitions.
              This is

                 [faName states] - [faName useful_states]

       <u>faName</u> <b>useful</b> <u>s</u>
              A  predicate.  It tests whether the state <u>s</u> in the FA <u>faName</u> is able to reach a final state by one
              or more transitions.  The result is a boolean value. It will be  set  to  <b>true</b>  if  the  state  is
              useful, and <b>false</b> otherwise.

       <u>faName</u> <b>epsilon_closure</b> <u>s</u>
              Returns  the  set  of  states which are reachable from the state <u>s</u> in the FA <u>faName</u> by one or more
              epsilon transitions, i.e transitions over the empty  symbol,  transitions  which  do  not  consume
              input. This is called the <u>epsilon</u> <u>closure</u> of <u>s</u>.

       <u>faName</u> <b>reverse</b>

       <u>faName</u> <b>complete</b>

       <u>faName</u> <b>remove_eps</b>

       <u>faName</u> <b>trim</b> ?<u>what</u>?

       <u>faName</u> <b>determinize</b> ?<u>mapvar</u>?

       <u>faName</u> <b>minimize</b> ?<u>mapvar</u>?

       <u>faName</u> <b>complement</b>

       <u>faName</u> <b>kleene</b>

       <u>faName</u> <b>optional</b>

       <u>faName</u> <b>union</b> <u>fa</u> ?<u>mapvar</u>?

       <u>faName</u> <b>intersect</b> <u>fa</u> ?<u>mapvar</u>?

       <u>faName</u> <b>difference</b> <u>fa</u> ?<u>mapvar</u>?

       <u>faName</u> <b>concatenate</b> <u>fa</u> ?<u>mapvar</u>?

       <u>faName</u> <b>fromRegex</b> <u>regex</u> ?<u>over</u>?
              These  methods  provide  more complex operations on the FA.  Please see the same-named commands in
              the package <b>grammar::fa::op</b> for descriptions of what they do.

</pre><h4><b>EXAMPLES</b></h4><pre>
</pre><h4><b>FINITE</b> <b>AUTOMATONS</b></h4><pre>
       For the mathematically inclined, a FA is a 5-tuple (S,Sy,St,Fi,T) where

       •      S is a set of <u>states</u>,

       •      Sy a set of <u>input</u> <u>symbols</u>,

       •      St is a subset of S, the set of <u>start</u> states, also known as <u>initial</u> states.

       •      Fi is a subset of S, the set of <u>final</u> states, also known as <u>accepting</u>.

       •      T is a function from S x (Sy + epsilon) to {S}, the <u>transition</u> <u>function</u>.  Here <b>epsilon</b> denotes the
              empty input symbol and is distinct from all symbols in Sy; and {S} is the set of subsets of S.  In
              other  words,  T  maps a combination of State and Input (which can be empty) to a set of <u>successor</u>
              <u>states</u>.

       In computer theory a FA is most often shown as a graph where the nodes  represent  the  states,  and  the
       edges  between  the  nodes  encode  the transition function: For all n in S' = T (s, sy) we have one edge
       between the nodes representing s and n resp., labeled with sy. The start and accepting states are encoded
       through distinct visual markers, i.e. they are attributes of the nodes.

       FA's are used to process streams of symbols over Sy.

       A specific FA is said to <u>accept</u> a finite stream sy_1 sy_2 ... sy_n if there is a path in the graph of the
       FA beginning at a state in St and ending at a state in Fi whose edges have the labels sy_1, sy_2, etc. to
       sy_n.  The set of all strings accepted by the FA is the <u>language</u> of the FA. One important equivalence  is
       that the set of languages which can be accepted by an FA is the set of <u>regular</u> <u>languages</u>.

       Another  important  concept  is  that  of deterministic FAs. A FA is said to be <u>deterministic</u> if for each
       string of input symbols there is exactly one path in the graph of the FA beginning at the start state and
       whose edges are labeled with the symbols in the string.  While it might seem that  non-deterministic  FAs
       to  have  more  power  of  recognition,  this is not so. For each non-deterministic FA we can construct a
       deterministic FA which accepts the same language (--&gt; Thompson's subset construction).

       While one of the premier applications of FAs is in <u>parsing</u>, especially in the <u>lexer</u> stage (where  symbols
       == characters), this is not the only possibility by far.

       Quite  a  lot  of processes can be modeled as a FA, albeit with a possibly large set of states. For these
       the notion of accepting states is often less or not relevant at  all.  What  is  needed  instead  is  the
       ability  to  act to state changes in the FA, i.e. to generate some output in response to the input.  This
       transforms a FA into a <u>finite</u> <u>transducer</u>, which has an additional set OSy of <u>output</u> <u>symbols</u> and  also  an
       additional <u>output</u> <u>function</u> O which maps from "S x (Sy + epsilon)" to "(Osy + epsilon)", i.e a combination
       of state and input, possibly empty to an output symbol, or nothing.

       For the graph representation this means that edges are additional labeled with the output symbol to write
       when this edge is traversed while matching input. Note that for an application "writing an output symbol"
       can also be "executing some code".

       Transducers are not handled by this package. They will get their own package in the future.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category <u>grammar_fa</u> of  the  <u>Tcllib</u>  <u>Trackers</u>  [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       automaton,  finite  automaton,  grammar, parsing, regular expression, regular grammar, regular languages,
       state, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Grammars and finite automata

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2004-2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 0.6                                     <u>grammar::<a href="../man3tcl/fa.3tcl.html">fa</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>