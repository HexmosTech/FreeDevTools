<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>grammar::me::tcl - Virtual machine implementation I for parsing token streams</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       grammar::me::tcl - Virtual machine implementation I for parsing token streams

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>grammar::me::tcl</b> <b>?0.2?</b>

       <b>::grammar::me::tcl</b> <b>cmd</b> <u>...</u>

       <b>::grammar::me::tcl</b> <b>init</b> <u>nextcmd</u> ?<u>tokmap</u>?

       <b>::grammar::me::tcl</b> <b>lc</b> <u>location</u>

       <b>::grammar::me::tcl</b> <b>tok</b> <u>from</u> ?<u>to</u>?

       <b>::grammar::me::tcl</b> <b>tokens</b>

       <b>::grammar::me::tcl</b> <b>sv</b>

       <b>::grammar::me::tcl</b> <b>ast</b>

       <b>::grammar::me::tcl</b> <b>astall</b>

       <b>::grammar::me::tcl</b> <b>ctok</b>

       <b>::grammar::me::tcl</b> <b>nc</b>

       <b>::grammar::me::tcl</b> <b>next</b>

       <b>::grammar::me::tcl</b> <b>ord</b>

       <b>::grammar::me::tcl::ict_advance</b> <u>message</u>

       <b>::grammar::me::tcl::ict_match_token</b> <u>tok</u> <u>message</u>

       <b>::grammar::me::tcl::ict_match_tokrange</b> <u>tokbegin</u> <u>tokend</u> <u>message</u>

       <b>::grammar::me::tcl::ict_match_tokclass</b> <u>code</u> <u>message</u>

       <b>::grammar::me::tcl::inc_restore</b> <u>nt</u>

       <b>::grammar::me::tcl::inc_save</b> <u>nt</u> <u>startlocation</u>

       <b>::grammar::me::tcl::iok_ok</b>

       <b>::grammar::me::tcl::iok_fail</b>

       <b>::grammar::me::tcl::iok_negate</b>

       <b>::grammar::me::tcl::icl_get</b>

       <b>::grammar::me::tcl::icl_rewind</b> <u>oldlocation</u>

       <b>::grammar::me::tcl::ier_get</b>

       <b>::grammar::me::tcl::ier_clear</b>

       <b>::grammar::me::tcl::ier_nonterminal</b> <u>message</u> <u>location</u>

       <b>::grammar::me::tcl::ier_merge</b> <u>olderror</u>

       <b>::grammar::me::tcl::isv_clear</b>

       <b>::grammar::me::tcl::isv_terminal</b>

       <b>::grammar::me::tcl::isv_nonterminal_leaf</b> <u>nt</u> <u>startlocation</u>

       <b>::grammar::me::tcl::isv_nonterminal_range</b> <u>nt</u> <u>startlocation</u>

       <b>::grammar::me::tcl::isv_nonterminal_reduce</b> <u>nt</u> <u>startlocation</u> ?<u>marker</u>?

       <b>::grammar::me::tcl::ias_push</b>

       <b>::grammar::me::tcl::ias_mark</b>

       <b>::grammar::me::tcl::ias_pop2mark</b> <u>marker</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  package  provides  an  implementation  of  the ME virtual machine.  Please go and read the document
       <b>grammar::me_intro</b> first if you do not know what a ME virtual machine is.

       This implementation is tied very strongly to Tcl. All the stacks in the machine state are handled through
       the Tcl stack, all control flow is handled by Tcl commands, and the remaining  machine  instructions  are
       directly  mapped  to  Tcl  commands.  Especially  the  matching  of nonterminal symbols is handled by Tcl
       procedures as well, essentially extending the machine implementation with custom instructions.

       Further on the implementation handles only a single machine which is uninteruptible during execution  and
       hardwired  for  pull  operation.  I.e.  it explicitly requests each new token through a callback, pulling
       them into its state.

       A related package is <b>grammar::peg::interp</b> which provides a  generic  interpreter  /  parser  for  parsing
       expression grammars (PEGs), implemented on top of this implementation of the ME virtual machine.

</pre><h4><b>API</b></h4><pre>
       The  commands  documented  in  this  section  do  not implement any of the instructions of the ME virtual
       machine. They provide the facilities for the initialization of the machine and the retrieval of important
       information.

       <b>::grammar::me::tcl</b> <b>cmd</b> <u>...</u>
              This is an ensemble command providing access to the commands  listed  in  this  section.  See  the
              methods themselves for detailed specifications.

       <b>::grammar::me::tcl</b> <b>init</b> <u>nextcmd</u> ?<u>tokmap</u>?
              This  command  (re)initializes  the  machine.  It returns the empty string. This command has to be
              invoked before any other command of this package.

              The command prefix <u>nextcmd</u> represents the input stream of characters and is invoked by the machine
              whenever the a new character from the stream is required. The instruction  for  handling  this  is
              <u>ict_advance</u>.  The callback has to return either the empty list, or a list of 4 elements containing
              the  token, its lexeme attribute, and its location as line number and column index, in this order.
              The empty list is the signal that the end of  the  input  stream  has  been  reached.  The  lexeme
              attribute is stored in the terminal cache, but otherwise not used by the machine.

              The  optional dictionary <u>tokmap</u> maps from tokens to integer numbers. If present the numbers impose
              an order on the tokens, which is subsequently used by <u>ict_match_tokrange</u> to determine if  a  token
              is in the specified range or not. If no token map is specified the lexicographic order of th token
              names will be used instead. This choice is especially asensible when using characters as tokens.

       <b>::grammar::me::tcl</b> <b>lc</b> <u>location</u>
              This  command  converts  the  location  of  a  token  given as offset in the input stream into the
              associated line number and column index. The result of the command is a 2-element list  containing
              the  two  values,  in  the order mentioned in the previous sentence.  This allows higher levels to
              convert the location information found in the error status and the generated AST into  more  human
              readable data.

              <u>Note</u>  that the command is not able to convert locations which have not been reached by the machine
              yet. In other words, if the machine has read 7 tokens the command is able to convert the offsets <b>0</b>
              to <b>6</b>, but nothing beyond that. This also shows that it is not possible to  convert  offsets  which
              refer to locations before the beginning of the stream.

              After  a  call  of  <b>init</b>  the state used for the conversion is cleared, making further conversions
              impossible until the machine has read tokens again.

       <b>::grammar::me::tcl</b> <b>tok</b> <u>from</u> ?<u>to</u>?
              This command returns a Tcl list containing the part of the input stream between the locations <u>from</u>
              and <u>to</u> (both inclusive). If <u>to</u> is not specified it will default to the value of <u>from</u>.

              Each element of the returned list is a list of four elements, the token,  its  associated  lexeme,
              line number, and column index, in this order.  In other words, each element has the same structure
              as the result of the <u>nextcmd</u> callback given to <b>::grammar::me::tcl::init</b>

              This command places the same restrictions on its location arguments as <b>::grammar::me::tcl::lc</b>.

       <b>::grammar::me::tcl</b> <b>tokens</b>
              This command returns the number of tokens currently known to the ME virtual machine.

       <b>::grammar::me::tcl</b> <b>sv</b>
              This  command  returns  the  current  semantic value <u>SV</u> stored in the machine. This is an abstract
              syntax tree as specified in the document <b>grammar::me_ast</b>, section <b>AST</b> <b>VALUES</b>.

       <b>::grammar::me::tcl</b> <b>ast</b>
              This method returns the abstract syntax tree currently at the top of  the  AST  stack  of  the  ME
              virtual  machine.  This  is  an abstract syntax tree as specified in the document <b>grammar::me_ast</b>,
              section <b>AST</b> <b>VALUES</b>.

       <b>::grammar::me::tcl</b> <b>astall</b>
              This method returns the whole stack of abstract syntax trees currently known  to  the  ME  virtual
              machine. Each element of the returned list is an abstract syntax tree as specified in the document
              <b>grammar::me_ast</b>, section <b>AST</b> <b>VALUES</b>.  The top of the stack resides at the end of the list.

       <b>::grammar::me::tcl</b> <b>ctok</b>
              This method returns the current token considered by the ME virtual machine.

       <b>::grammar::me::tcl</b> <b>nc</b>
              This  method  returns  the  contents  of  the  nonterminal  cache  as  a  dictionary  mapping from
              "<b>symbol</b>,<b>location</b>" to match information.

       <b>::grammar::me::tcl</b> <b>next</b>
              This method returns the next token callback as specified during initialization of the  ME  virtual
              machine.

       <b>::grammar::me::tcl</b> <b>ord</b>
              This  method  returns a dictionary containing the <u>tokmap</u> specified during initialization of the ME
              virtual machine.  <b>::grammar::me::tcl::ok</b> This variable contains the current match status <u>OK</u>. It is
              provided as variable instead of a command because that makes access to  this  information  faster,
              and  the  speed of access is considered very important here as this information is used constantly
              to determine the control flow.

</pre><h4><b>MACHINE</b> <b>STATE</b></h4><pre>
       Please go and read the document <b>grammar::me_vm</b> first for a specification of the basic ME virtual  machine
       and its state.

       This  implementation  manages  the  state described in that document, except for the stacks minus the AST
       stack. In other words, location stack, error stack, return stack, and ast  marker  stack  are  implicitly
       managed through standard Tcl scoping, i.e. Tcl variables in procedures, outside of this implementation.

</pre><h4><b>MACHINE</b> <b>INSTRUCTIONS</b></h4><pre>
       Please  go and read the document <b>grammar::me_vm</b> first for a specification of the basic ME virtual machine
       and its instruction set.

       This implementation maps all instructions to Tcl commands in the namespace  "::grammar::me::tcl",  except
       for  the  stack related commands, nonterminal symbols and control flow.  Here we simply list the commands
       and explain the differences to the specified instructions, if there are any. For their semantics see  the
       aforementioned  specification.  The  machine  commands  are  <u>not</u>  reachable  through the ensemble command
       <b>::grammar::me::tcl</b>.

       <b>::grammar::me::tcl::ict_advance</b> <u>message</u>
              No changes.

       <b>::grammar::me::tcl::ict_match_token</b> <u>tok</u> <u>message</u>
              No changes.

       <b>::grammar::me::tcl::ict_match_tokrange</b> <u>tokbegin</u> <u>tokend</u> <u>message</u>
              If, and only if a token map was specified during initialization then the arguments are the numeric
              representations of the smallest and largest tokens in the range. Otherwise they are  the  relevant
              tokens themselves and lexicographic comparison is used.

       <b>::grammar::me::tcl::ict_match_tokclass</b> <u>code</u> <u>message</u>
              No changes.

       <b>::grammar::me::tcl::inc_restore</b> <u>nt</u>
              Instead  of  taking a branchlabel the command returns a boolean value.  The result will be <b>true</b> if
              and only if cached information was found. The caller has to perform the appropriate branching.

       <b>::grammar::me::tcl::inc_save</b> <u>nt</u> <u>startlocation</u>
              The command takes the start location as additional argument, as it is managed on  the  Tcl  stack,
              and not in the machine state.

       <b>icf_ntcall</b> <u>branchlabel</u>

       <b>icf_ntreturn</b>
              These  two instructions are not mapped to commands. They are control flow instructions and handled
              in Tcl.

       <b>::grammar::me::tcl::iok_ok</b>
              No changes.

       <b>::grammar::me::tcl::iok_fail</b>
              No changes.

       <b>::grammar::me::tcl::iok_negate</b>
              No changes.

       <b>icf_jalways</b> <u>branchlabel</u>

       <b>icf_jok</b> <u>branchlabel</u>

       <b>icf_jfail</b> <u>branchlabel</u>

       <b>icf_halt</b>
              These four instructions are not mapped to commands. They are control flow instructions and handled
              in Tcl.

       <b>::grammar::me::tcl::icl_get</b>
              This command returns the current location <u>CL</u> in the input.  It replaces <u>icl_push</u>.

       <b>::grammar::me::tcl::icl_rewind</b> <u>oldlocation</u>
              The command takes the location as argument as it comes from the Tcl stack, not the machine state.

       <b>icl_pop</b>
              Not mapped, the stacks are not managed by the package.

       <b>::grammar::me::tcl::ier_get</b>
              This command returns the current error state <u>ER</u>.  It replaces <u>ier_push</u>.

       <b>::grammar::me::tcl::ier_clear</b>
              No changes.

       <b>::grammar::me::tcl::ier_nonterminal</b> <u>message</u> <u>location</u>
              The command takes the location as argument as it comes from the Tcl stack, not the machine state.

       <b>::grammar::me::tcl::ier_merge</b> <u>olderror</u>
              The command takes the second error state to merge as argument as it comes from the Tcl stack,  not
              the machine state.

       <b>::grammar::me::tcl::isv_clear</b>
              No changes.

       <b>::grammar::me::tcl::isv_terminal</b>
              No changes.

       <b>::grammar::me::tcl::isv_nonterminal_leaf</b> <u>nt</u> <u>startlocation</u>
              The  command  takes the start location as argument as it comes from the Tcl stack, not the machine
              state.

       <b>::grammar::me::tcl::isv_nonterminal_range</b> <u>nt</u> <u>startlocation</u>
              The command takes the start location as argument as it comes from the Tcl stack, not  the  machine
              state.

       <b>::grammar::me::tcl::isv_nonterminal_reduce</b> <u>nt</u> <u>startlocation</u> ?<u>marker</u>?
              The  command  takes  start location and marker as argument as it comes from the Tcl stack, not the
              machine state.

       <b>::grammar::me::tcl::ias_push</b>
              No changes.

       <b>::grammar::me::tcl::ias_mark</b>
              This command returns a marker for the current state of the AST stack <u>AS</u>. The marker stack  is  not
              managed by the machine.

       <b>::grammar::me::tcl::ias_pop2mark</b> <u>marker</u>
              The command takes the marker as argument as it comes from the Tcl stack, not the machine state. It
              replaces <u>ias_mpop</u>.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category <u>grammar_me</u> of  the  <u>Tcllib</u>  <u>Trackers</u>  [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       grammar, parsing, virtual machine

</pre><h4><b>CATEGORY</b></h4><pre>
       Grammars and finite automata

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2005 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 0.2                                <u>grammar::me::<a href="../man3tcl/tcl.3tcl.html">tcl</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>