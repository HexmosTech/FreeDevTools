<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pt::peg_language - PEG Language Tutorial</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pt::peg_language - PEG Language Tutorial

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Are  you lost ?  Do you have trouble understanding this document ?  In that case please read the overview
       provided by the <u>Introduction</u> <u>to</u> <u>Parser</u> <u>Tools</u>. This document is the entrypoint to  the  whole  system  the
       current package is a part of.

       Welcome  to  the tutorial / introduction for the <b>PEG</b> <b>Specification</b> <b>Language</b>.  If you are already familiar
       with the language we are about to discuss, and only wish to refresh your memory you can, of course,  skip
       ahead to the aforementioned section and just read the full formal specification.

</pre><h4><b>WHAT</b> <b>IS</b> <b>IT?</b></h4><pre>
       <b>peg</b>,  a  language for the specification of parsing expression grammars is meant to be human readable, and
       writable as well, yet strict enough to allow its processing by machine. Like any  computer  language.  It
       was defined to make writing the specification of a grammar easy, something the other formats found in the
       Parser Tools do not lend themselves too.

</pre><h4><b>THE</b> <b>ELEMENTS</b> <b>OF</b> <b>THE</b> <b>LANGUAGE</b></h4><pre>
   <b>BASIC</b> <b>STRUCTURE</b>
       The general outline of a textual PEG is

              PEG &lt;&lt;name&gt;&gt; (&lt;&lt;start-expression&gt;&gt;)
                 &lt;&lt;rules&gt;&gt;
              END;

       <u>Note</u>: We are using text in double angle-brackets as place-holders for things not yet explained.

   <b>NAMES</b>
       Names  are  mostly used to identify the nonterminal symbols of the grammar, i.e. that which occurs on the
       left-hand side of a &lt;rule&gt;.  The exception to that is the name given after the keyword <b>PEG</b> (see  previous
       section), which is the name of the whole grammar itself.

       The structure of a name is simple:

       [1]    It begins with a letter, underscore, or colon, followed by

       [2]    zero or more letters, digits, underscores, or colons.

       Or, in formal textual notation:

                  ([_:] / &lt;alpha&gt;) ([_:] / &lt;alnum&gt;)*

       Examples of names:

                  Hello
                  ::world
                  _:submarine55_

       Examples of text which are <u>not</u> names:

                  12
                  .bogus
                  0wrong
                  @location

   <b>RULES</b>
       The  main  body  of  the  text of a grammar specification is taken up by the rules. Each rule defines the
       sentence structure of one nonterminal symbol. Their basic structure is

                   &lt;&lt;name&gt;&gt;  &lt;-  &lt;&lt;expression&gt;&gt; ;

       The &lt;name&gt; specifies the nonterminal symbol to be defined, the &lt;expression&gt; after  the  arrow  (&lt;-)  then
       declares its structure.

       Note  that each rule ends in a single semicolon, even the last.  I.e. the semicolon is a rule <u>terminator</u>,
       not a separator.

       We can have as many rules as we like, as long as we define each nonterminal symbol at most once, and have
       at least one rule for each nonterminal symbol which occured in an expression, i.e. in  either  the  start
       expression of the grammar, or the right-hande side of a rule.

   <b>EXPRESSIONS</b>
       The  <u>parsing</u>  expressions  are  the  meat  of  any specification. They declare the structure of the whole
       document (&lt;&lt;start-expression&gt;&gt;), and of all nonterminal symbols.

       All expressions are made up out of <u>atomic</u> <u>expressions</u> and <u>operators</u> combining them. We have operators for
       choosing between alternatives, repetition of parts, and for look-ahead constraints. There is no  explicit
       operator  for  the sequencing (also known as <u>concatenation</u>) of parts however. This is specified by simply
       placing the parts adjacent to each other.

       Here are the operators, from highest to lowest priority (i.e. strength of binding):

                  # Binary operators.

                  &lt;&lt;expression-1&gt;&gt;     &lt;&lt;expression-2&gt;&gt;  # sequence. parse 1, then 2.
                  &lt;&lt;expression-1&gt;&gt;  /  &lt;&lt;expression-2&gt;&gt;  # alternative. try to parse 1, and parse 2 if 1 failed to parse.

                  # Prefix operators. Lookahead constraints. Same priority.

                  &amp; &lt;&lt;expression&gt;&gt;  # Parse expression, ok on successful parse.
                  ! &lt;&lt;expression&gt;&gt;  # Ditto, except ok on failure to parse.

                  # Suffix operators. Repetition. Same priority.

                  &lt;&lt;expression&gt;&gt; ?  # Parse expression none, or once (repeat 0 or 1).
                  &lt;&lt;expression&gt;&gt; *  # Parse expression zero or more times.
                  &lt;&lt;expression&gt;&gt; +  # Parse expression one or more times.

                  # Expression nesting

                  ( &lt;&lt;expression&gt;&gt; ) # Put an expression in parens to change its priority.

       With this we can now deconstruct the formal expression for names given in section <b>Names</b>:

                  ([_:] / &lt;alpha&gt;) ([_:] / &lt;alnum&gt;)*

       It is a sequence of two parts,

                  [_:] / &lt;alpha&gt;
       and

                  ([_:] / &lt;alnum&gt;)*
       The parentheses around the parts kept their inner alternatives bound together against the normally higher
       priority of the sequence. Each of the two parts is an alternative,  with  the  second  part  additionally
       repeated zero or more times, leaving us with the three atomic expressions

                  [_:]
                  &lt;alpha&gt;
                  &lt;alnum&gt;

       And <u>atomic</u> <u>expressions</u> are our next topic. They fall into three classes:

       [1]    names, i.e. nonterminal symbols,

       [2]    string literals, and

       [3]    character classes.

       Names we know about already, or see section <b>Names</b> for a refresher.

       String  literals  are  simple. They are delimited by (i.e. start and end with) either a single or double-
       apostroph, and in between the delimiters we can have any character but the delimiter itself. They can  be
       empty as well. Examples of strings are

                  ''
                  ""
                  'hello'
                  "umbra"
                  "'"
                  '"'

       The last two examples show how to place any of the delimiters into a string.

       For  the last, but not least of our atomic expressions, character classes, we have a number of predefined
       classes, shown below, and the ability to construct or own. The predefined classes are:

                  &lt;alnum&gt;    # Any unicode alphabet or digit character (string is alnum).
                  &lt;alpha&gt;    # Any unicode alphabet character (string is alpha).
                  &lt;ascii&gt;    # Any unicode character below codepoint 0x80 (string is ascii).
                  &lt;control&gt;  # Any unicode control character (string is control).
                  &lt;ddigit&gt;   # The digit characters [0-9].
                  &lt;digit&gt;    # Any unicode digit character (string is digit).
                  &lt;graph&gt;    # Any unicode printing character, except space (string is graph).
                  &lt;lower&gt;    # Any unicode lower-case alphabet character (string is lower).
                  &lt;print&gt;    # Any unicode printing character, incl. space (string is print).
                  &lt;punct&gt;    # Any unicode punctuation character (string is punct).
                  &lt;space&gt;    # Any unicode space character (string is space).
                  &lt;upper&gt;    # Any unicode upper-case alphabet character (string is upper).
                  &lt;wordchar&gt; # Any unicode word character (string is wordchar).
                  &lt;xdigit&gt;   # The hexadecimal digit characters [0-9a-fA-F].
                  .          # Any character, except end of input.

       And the syntax of custom-defined character classes is

                  [ &lt;&lt;range&gt;&gt;* ]

       where each range is either a single character, or of the form

                 &lt;&lt;character&gt;&gt; - &lt;character&gt;&gt;

       Examples for character classes we have seen already in the course of this introduction are

                  [_:]
                  [0-9]
                  [0-9a-fA-F]

       We are nearly done with expressions. The only piece left is to  tell  how  the  characters  in  character
       classes and string literals are specified.

       Basically  characters  in  the  input  stand  for themselves, and in addition to that we several types of
       escape syntax to to repesent control characters, or characters outside of the encoding the text is in.

       All the escaped forms are started with a backslash character ('\', unicode codepoint 0x5C). This is  then
       followed  by a series of octal digits, or 'u' and hexedecimal digits, or a regular character from a fixed
       set for various control characters. Some examples:

                  \n \r \t \' \" \[ \] \\ #
                  \000 up to \277         # octal escape, all ascii character, leading 0's can be removed.
                  \u2CA7                  # hexadecimal escape, all unicode characters.
                  #                       # Here 2ca7 &lt;=&gt; Koptic Small Letter Tau

   <b>WHITESPACE</b> <b>AND</b> <b>COMMENTS</b>
       One issue not touched upon so far is whitespace and comments.

       Whitespace is any unicode space character, i.e. anything in the character class  &lt;space&gt;,  and  comments.
       The  latter  are sequences of characters starting with a '#' (hash, unicode codepoint 0x23) and ending at
       the next end-of-line.

       Whitespace can be freely used between all syntactical elements of a grammar specification. It  cannot  be
       used inside of syntactical elements, like names, string literals, predefined character classes, etc.

   <b>NONTERMINAL</b> <b>ATTRIBUTES</b>
       Lastly, a more advanced topic. In the section <b>Rules</b> we gave the structure of a rule as

                   &lt;&lt;name&gt;&gt;  &lt;-  &lt;&lt;expression&gt;&gt; ;

       This  is not quite true. It is possible to associate a semantic mode with the nonterminal in the rule, by
       writing it before the name, separated from it by a colon, i.e. writing

                  &lt;&lt;mode&gt;&gt; : &lt;&lt;name&gt;&gt;  &lt;-  &lt;&lt;expression&gt;&gt; ;

       is also allowed. This mode is optional. The known modes and their meanings are:

       <b>value</b>  The semantic value of the nonterminal symbol is an abstract syntax tree  consisting  of  a  single
              node  node  for  the nonterminal itself, which has the ASTs of the symbol's right hand side as its
              children.

       <b>leaf</b>   The semantic value of the nonterminal symbol is an abstract syntax tree  consisting  of  a  single
              node node for the nonterminal, without any children. Any ASTs generated by the symbol's right hand
              side are discarded.

       <b>void</b>   The  nonterminal  has  no  semantic  value. Any ASTs generated by the symbol's right hand side are
              discarded (as well).

       Of these three modes only <b>leaf</b> and <b>void</b> can be specified directly. <b>value</b> is implicitly specified  by  the
       absence of a mode before the nonterminal.

       Now,  with all the above under our belt it should be possible to not only read, but understand the formal
       specification of the text representation shown in the next section, written in itself.

</pre><h4><b>PEG</b> <b>SPECIFICATION</b> <b>LANGUAGE</b></h4><pre>
       <b>peg</b>, a language for the specification of parsing expression grammars is meant to be human  readable,  and
       writable  as  well,  yet strict enough to allow its processing by machine. Like any computer language. It
       was defined to make writing the specification of a grammar easy, something the other formats found in the
       Parser Tools do not lend themselves too.

       It is formally specified by the grammar shown below, written in itself. For a tutorial / introduction  to
       the language please go and read the <u>PEG</u> <u>Language</u> <u>Tutorial</u>.

              PEG pe_grammar_for_peg (Grammar)

                # --------------------------------------------------------------------
                      # Syntactical constructs

                      Grammar         &lt;- WHITESPACE Header Definition* Final EOF ;

                      Header          &lt;- PEG Identifier StartExpr ;
                      Definition      &lt;- Attribute? Identifier IS Expression SEMICOLON ;
                      Attribute       &lt;- (VOID / LEAF) COLON ;
                      Expression      &lt;- Sequence (SLASH Sequence)* ;
                      Sequence        &lt;- Prefix+ ;
                      Prefix          &lt;- (AND / NOT)? Suffix ;
                      Suffix          &lt;- Primary (QUESTION / STAR / PLUS)? ;
                      Primary         &lt;- ALNUM / ALPHA / ASCII / CONTROL / DDIGIT / DIGIT
                                      /  GRAPH / LOWER / PRINTABLE / PUNCT / SPACE / UPPER
                                      /  WORDCHAR / XDIGIT
                                      / Identifier
                                      /  OPEN Expression CLOSE
                                      /  Literal
                                      /  Class
                                      /  DOT
                                      ;
                      Literal         &lt;- APOSTROPH  (!APOSTROPH  Char)* APOSTROPH  WHITESPACE
                                      /  DAPOSTROPH (!DAPOSTROPH Char)* DAPOSTROPH WHITESPACE ;
                      Class           &lt;- OPENB (!CLOSEB Range)* CLOSEB WHITESPACE ;
                      Range           &lt;- Char TO Char / Char ;

                      StartExpr       &lt;- OPEN Expression CLOSE ;
              void:   Final           &lt;- "END" WHITESPACE SEMICOLON WHITESPACE ;

                      # --------------------------------------------------------------------
                      # Lexing constructs

                      Identifier      &lt;- Ident WHITESPACE ;
              leaf:   Ident           &lt;- ([_:] / &lt;alpha&gt;) ([_:] / &lt;alnum&gt;)* ;
                      Char            &lt;- CharSpecial / CharOctalFull / CharOctalPart
                                      /  CharUnicode / CharUnescaped
                                      ;

              leaf:   CharSpecial     &lt;- "\\" [nrt'"\[\]\\] ;
              leaf:   CharOctalFull   &lt;- "\\" [0-3][0-7][0-7] ;
              leaf:   CharOctalPart   &lt;- "\\" [0-7][0-7]? ;
              leaf:   CharUnicode     &lt;- "\\" 'u' HexDigit (HexDigit (HexDigit HexDigit?)?)? ;
              leaf:   CharUnescaped   &lt;- !"\\" . ;

              void:   HexDigit        &lt;- [0-9a-fA-F] ;

              void:   TO              &lt;- '-'           ;
              void:   OPENB           &lt;- "["           ;
              void:   CLOSEB          &lt;- "]"           ;
              void:   APOSTROPH       &lt;- "'"           ;
              void:   DAPOSTROPH      &lt;- '"'           ;
              void:   PEG             &lt;- "PEG" !([_:] / &lt;alnum&gt;) WHITESPACE ;
              void:   IS              &lt;- "&lt;-"    WHITESPACE ;
              leaf:   VOID            &lt;- "void"  WHITESPACE ; # Implies that definition has no semantic value.
              leaf:   LEAF            &lt;- "leaf"  WHITESPACE ; # Implies that definition has no terminals.
              void:   SEMICOLON       &lt;- ";"     WHITESPACE ;
              void:   COLON           &lt;- ":"     WHITESPACE ;
              void:   SLASH           &lt;- "/"     WHITESPACE ;
              leaf:   AND             &lt;- "&amp;"     WHITESPACE ;
              leaf:   NOT             &lt;- "!"     WHITESPACE ;
              leaf:   QUESTION        &lt;- "?"     WHITESPACE ;
              leaf:   STAR            &lt;- "*"     WHITESPACE ;
              leaf:   PLUS            &lt;- "+"     WHITESPACE ;
              void:   OPEN            &lt;- "("     WHITESPACE ;
              void:   CLOSE           &lt;- ")"     WHITESPACE ;
              leaf:   DOT             &lt;- "."     WHITESPACE ;

              leaf:   ALNUM           &lt;- "&lt;alnum&gt;"    WHITESPACE ;
              leaf:   ALPHA           &lt;- "&lt;alpha&gt;"    WHITESPACE ;
              leaf:   ASCII           &lt;- "&lt;ascii&gt;"    WHITESPACE ;
              leaf:   CONTROL         &lt;- "&lt;control&gt;"  WHITESPACE ;
              leaf:   DDIGIT          &lt;- "&lt;ddigit&gt;"   WHITESPACE ;
              leaf:   DIGIT           &lt;- "&lt;digit&gt;"    WHITESPACE ;
              leaf:   GRAPH           &lt;- "&lt;graph&gt;"    WHITESPACE ;
              leaf:   LOWER           &lt;- "&lt;lower&gt;"    WHITESPACE ;
              leaf:   PRINTABLE       &lt;- "&lt;print&gt;"    WHITESPACE ;
              leaf:   PUNCT           &lt;- "&lt;punct&gt;"    WHITESPACE ;
              leaf:   SPACE           &lt;- "&lt;space&gt;"    WHITESPACE ;
              leaf:   UPPER           &lt;- "&lt;upper&gt;"    WHITESPACE ;
              leaf:   WORDCHAR        &lt;- "&lt;wordchar&gt;" WHITESPACE ;
              leaf:   XDIGIT          &lt;- "&lt;xdigit&gt;"   WHITESPACE ;

              void:   WHITESPACE      &lt;- (" " / "\t" / EOL / COMMENT)* ;
              void:   COMMENT         &lt;- '#' (!EOL .)* EOL ;
              void:   EOL             &lt;- "\n\r" / "\n" / "\r" ;
              void:   EOF             &lt;- !. ;

                      # --------------------------------------------------------------------
              END;

   <b>EXAMPLE</b>
       Our example specifies the grammar for a basic 4-operation calculator.

              PEG calculator (Expression)
                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'       ;
                  Sign       &lt;- '-' / '+'                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- '*' / '/'                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- '+'/'-'                                       ;
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

       Using  higher-level  features  of  the notation, i.e. the character classes (predefined and custom), this
       example can be rewritten as

              PEG calculator (Expression)
                  Sign       &lt;- [-+]                                          ;
                  Number     &lt;- Sign? &lt;ddigit&gt;+                               ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- [*/];
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- [-+];
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category <u>pt</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       EBNF,  LL(k),  PEG,  TDPL,  context-free  languages,  expression,  grammar,  matching,  parser,   parsing
       expression,  parsing  expression grammar, push down automaton, recursive descent, state, top-down parsing
       languages, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Parsing and Grammars

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 1.1                                <u>pt::<a href="../man3tcl/peg_language.3tcl.html">peg_language</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>