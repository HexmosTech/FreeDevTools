<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business::EDI - Top level class for generating U.N. EDI interchange objects and subobjects.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbusiness-edi-perl">libbusiness-edi-perl_0.05-3build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Business::EDI - Top level class for generating U.N. EDI interchange objects and subobjects.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Business::EDI;

         my $edi = Business::EDI-new('d09b');      # set the EDI spec version
         my $rtc = $edi-&gt;codelist('ResponseTypeCode', $json) or die "Unrecognized code!";
         printf "EDI response type: %s - %s (%s)\n", $rtc-&gt;code, $rtc-&gt;label, $rtc-&gt;value;

         my $msg = Business::EDI::Message-&gt;new($ordrsp) or die "Failed Message constructor";
         foreach ($msg-&gt;xpath('line_detail/all_LIN') {
             ($_-&gt;<a href="../man7143/part.7143.html">part</a>(7143) || '') eq 'EN' or next;
             print $_-&gt;<a href="../man7140/part.7140.html">part</a>(7140)-&gt;value, "\n";    # print all the 13-digit (EN) ISBNs
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The focus of functionality is to provide object based access to EDI messages and subelements.  At
       present, the EDI input processed by Business::EDI objects is JSON from the <b>edi4r</b> ruby library, and there
       is no EDI output beyond the perl objects themselves.

</pre><h4><b>NAMESPACE</b></h4><pre>
       When you "use Business::EDI;" the following package namespaces are also loaded:
           Business::EDI::Segment_group
           Business::EDI::Message

       That's why the example message constructor in SYNOPSIS would succeed without having done "use
       Business::EDI::Message;"

</pre><h4><b>EDI</b> <b>Structure</b></h4><pre>
       Everything depends on the spec.  That means you have to have declared a spec version before you can
       create or parse a given chunk of data.  The exception is a whole EDI message, because each message
       declares its spec version internally.

       EDI has a hierachical specification defining data.  From top to bottom, it includes:

       <b>Communication</b> - containing one or more messages (not yet modeled here)
       <b>Message</b>       - containing segment groups and segments
       <b>Segment</b> <b>Group</b> - containing segments
       <b>Segment</b>       - containing composites, codelists and data elements
       <b>Composite</b>     - containing multiple codelists and/or data elements
       <b>Codelist</b>      - enumerated value from a spec-defined set
       <b>Data</b> <b>Element</b>  - unenumerated value

       This module handles messages and everything below, but not (yet) communications.

</pre><h4><b>CLASS</b> <b>FUNCTIONS</b></h4><pre>
       Much more documentation needed here...

   <b>new()</b>
       Constructor

</pre><h4><b>OBJECT</b> <b>METHODS</b> <b>(General)</b></h4><pre>
   <b>value()</b>
       Get/set accessor for the value of the field.

   <b>code()</b>
       The  string  code  designating  this node's type.  The code is what is what the spec uses to refer to the
       object's definition.  For example, a composite "C504", segment "RFF", data element "7140", etc.

       Don't be confused when dealing with CodeList objects.  Calling <b>code()</b> gets you the  4-character  code  of
       the CodeList field, NOT what that CodeList is currently set to.  For that use <b>value()</b>.

   <b>desc()</b>
       English description of the element.

</pre><h4><b>METHODS</b> <b>(for</b> <b>Traversal)</b></h4><pre>
   <b>part_keys()</b>
       This method returns strings that can be fed to <b>part()</b> like:
           foreach ($x-&gt;part_keys) { something($x-&gt;part($_)) }

       This is similar to doing:
           foreach (keys %x) { something($x{$_}) }

       In this way an object can be exhaustively, recursively parsed without further knowledge of it.

   <b>part($key)</b>
       Returns  subelement(s)  of  the object.  The key can reference any subobject allowed by the spec.  If the
       subobject is repeatable, then prepending "all_" to the key will return an array of all  such  subobjects.
       This  is  the  safest  and most comprehensive approach.  Using part($key) without "all_" to retrieve when
       there is only one $key subobject will succeed.  Using part($key) without "all_" to  retrieve  when  there
       are  multiple  $key  subobjects  will  FAIL.  Since that difference is only dependent on data, you should
       always use "all_" when dealing with a repeatable field (or xpath, see below).

       Examples:

           my $qty  = $detail-&gt;part('QTY');      # FAILURE PRONE!
           my @qtys = $detail-&gt;part('all_QTY');  # OK!

   <b>xpath($path)</b>
       $path can traverse multiple depths in representation via one call.  For example:

           $message-&gt;xpath('all_SG26/all_QTY/6063')

       is like this function <b>foo()</b>:

           sub foo {
               my @x;
               for my $sg ($message-&gt;part-&gt;('all_SG26') {
                   for ($sg-&gt;part('all_QTY') {
                       push @x, $-&gt;part('6063');
                   }
               }
               return @x;
           }

       The xpath version is much nicer!  However this is nowhere near as fully featured as W3C  xpath  for  XML.
       This is more like a multple-depth <b>part()</b>.

       Examples:
           my @obj_1154 = $message-&gt;xpath('line_detail/SG31/RFF/C506/1154');

   <b>xpath_value($path)</b>
       Returns value(s) instead of object(s).

       Examples:
           'ORDRSP' eq $ordrsp-&gt;xpath_value('UNH/S009/0065') or die "Wrong Message Type!";

</pre><h4><b>WARNINGS</b></h4><pre>
       This code is experimental.  EDI is a big spec with many revisions.

       At  the  lower  levels,  all  data elements, codelists, composites and segments from the most recent spec
       (D09B) are present.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        Business::EDI::Spec
        edi4r - <a href="http://edi4r.rubyforge.org">http://edi4r.rubyforge.org</a>

</pre><h4><b>AUTHOR</b></h4><pre>
       Joe Atzberger

perl v5.40.1                                       2025-02-18                                 <u>Business::<a href="../man3pm/EDI.3pm.html">EDI</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>