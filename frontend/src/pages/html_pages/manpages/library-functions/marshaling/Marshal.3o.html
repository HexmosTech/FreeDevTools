<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marshal - Marshaling of data structures.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Marshal - Marshaling of data structures.

</pre><h4><b>Module</b></h4><pre>
       Module   Marshal

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Marshal</b>
        : <b>sig</b> <b>end</b>

       Marshaling of data structures.

       This  module provides functions to encode arbitrary data structures as sequences of bytes, which can then
       be written on a file or sent over a pipe or network connection.  The bytes can then be read  back  later,
       possibly in another process, and decoded back into a data structure. The format for the byte sequences is
       compatible across all machines for a given version of OCaml.

       Warning:  marshaling  is currently not type-safe. The type of marshaled data is not transmitted along the
       value of the data, making it impossible to check that the data read back possesses the type  expected  by
       the  context. In particular, the result type of the <b>Marshal.from_*</b> functions is given as <b>'a</b> , but this is
       misleading: the returned OCaml value does not possess type <b>'a</b> for all <b>'a</b> ; it has one, unique type  which
       cannot  be  determined  at  compile-time.  The programmer should explicitly give the expected type of the
       returned value, using the following syntax:

       - <b>(Marshal.from_channel</b> <b>chan</b> <b>:</b> <b>type)</b> .  Anything can happen at run-time if the object in  the  file  does
       not belong to the given type.

       Values  of  extensible  variant  types, for example exceptions (of extensible type <b>exn</b> ), returned by the
       unmarshaller should not be pattern-matched over through  <b>match</b>  <b>...</b>  <b>with</b>  or  <b>try</b>  <b>...</b>  <b>with</b>  ,  because
       unmarshalling  does  not  preserve  the  information required for matching their constructors. Structural
       equalities with other extensible  variant  values  does  not  work  either.   Most  other  uses  such  as
       Printexc.to_string, will still work as expected.

       The  representation  of  marshaled  values  is  not human-readable, and uses bytes that are not printable
       characters. Therefore, input  and  output  channels  used  in  conjunction  with  <b>Marshal.to_channel</b>  and
       <b>Marshal.from_channel</b>  must  be  opened in binary mode, using e.g.  <b>open_out_bin</b> or <b>open_in_bin</b> ; channels
       opened in text mode will cause unmarshaling errors on platforms where text  channels  behave  differently
       than binary channels, e.g. Windows.

       <u>type</u> <u>extern_flags</u> =
        | No_sharing  (* Don't preserve sharing
        *)
        | Closures  (* Send function closures
        *)
        | Compat_32  (* Ensure 32-bit compatibility
        *)

       The flags to the <b>Marshal.to_*</b> functions below.

       <u>val</u> <u>to_channel</u> : <b>out_channel</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>extern_flags</b> <b>list</b> <b>-&gt;</b> <b>unit</b>

       <b>Marshal.to_channel</b>  <b>chan</b> <b>v</b> <b>flags</b> writes the representation of <b>v</b> on channel <b>chan</b> . The <b>flags</b> argument is a
       possibly empty list of flags that governs the marshaling behavior with  respect  to  sharing,  functional
       values, and compatibility between 32- and 64-bit platforms.

       If  <b>flags</b> does not contain <b>Marshal.No_sharing</b> , circularities and sharing inside the value <b>v</b> are detected
       and preserved in the sequence of bytes produced. In particular, this guarantees  that  marshaling  always
       terminates.  Sharing  between  values  marshaled  by  successive  calls  to <b>Marshal.to_channel</b> is neither
       detected nor preserved, though.  If <b>flags</b> contains <b>Marshal.No_sharing</b> , sharing is ignored.  This results
       in faster marshaling if <b>v</b> contains no shared substructures, but may cause slower  marshaling  and  larger
       byte representations if <b>v</b> actually contains sharing, or even non-termination if <b>v</b> contains cycles.

       If  <b>flags</b>  does  not  contain  <b>Marshal.Closures</b>  , marshaling fails when it encounters a functional value
       inside <b>v</b> : only 'pure'  data  structures,  containing  neither  functions  nor  objects,  can  safely  be
       transmitted  between  different  programs. If <b>flags</b> contains <b>Marshal.Closures</b> , functional values will be
       marshaled as a the position in the code of the program together with the values corresponding to the free
       variables captured in the closure.  In this case, the output of marshaling  can  only  be  read  back  in
       processes  that  run  exactly  the same program, with exactly the same compiled code. (This is checked at
       un-marshaling time, using an MD5 digest of the code transmitted along with the code position.)

       The exact definition of which free variables are captured in a closure is  not  specified  and  can  vary
       between  bytecode and native code (and according to optimization flags).  In particular, a function value
       accessing a global reference may or  may  not  include  the  reference  in  its  closure.   If  it  does,
       unmarshaling the corresponding closure will create a new reference, different from the global one.

       If  <b>flags</b>  contains  <b>Marshal.Compat_32</b> , marshaling fails when it encounters an integer value outside the
       range <b>-2</b> ^ <b>30</b> , <b>2</b> ^ <b>30</b> <b>-1</b> of integers that are representable on a 32-bit  platform.   This  ensures  that
       marshaled  data  generated  on  a 64-bit platform can be safely read back on a 32-bit platform.  If <b>flags</b>
       does not contain <b>Marshal.Compat_32</b> , integer values outside the range <b>-2</b> ^ <b>30</b> , <b>2</b> ^ <b>30</b> <b>-1</b> are  marshaled,
       and  can  be read back on a 64-bit platform, but will cause an error at un-marshaling time when read back
       on a 32-bit platform.  The <b>Mashal.Compat_32</b> flag only matters when marshaling is performed  on  a  64-bit
       platform; it has no effect if marshaling is performed on a 32-bit platform.

       <b>Raises</b> <b>Failure</b> if <b>chan</b> is not in binary mode.

       <u>val</u> <u>to_bytes</u> : <b>'a</b> <b>-&gt;</b> <b>extern_flags</b> <b>list</b> <b>-&gt;</b> <b>bytes</b>

       <b>Marshal.to_bytes</b> <b>v</b> <b>flags</b> returns a byte sequence containing the representation of <b>v</b> .  The <b>flags</b> argument
       has the same meaning as for <b>Marshal.to_channel</b> .

       <b>Since</b> 4.02

       <u>val</u> <u>to_string</u> : <b>'a</b> <b>-&gt;</b> <b>extern_flags</b> <b>list</b> <b>-&gt;</b> <b>string</b>

       Same as <b>to_bytes</b> but return the result as a string instead of a byte sequence.

       <u>val</u> <u>to_buffer</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>extern_flags</b> <b>list</b> <b>-&gt;</b> <b>int</b>

       <b>Marshal.to_buffer</b>  <b>buff</b>  <b>ofs</b>  <b>len</b>  <b>v</b>  <b>flags</b> marshals the value <b>v</b> , storing its byte representation in the
       sequence <b>buff</b> , starting at index <b>ofs</b> , and writing at most <b>len</b> bytes.  It returns the  number  of  bytes
       actually  written  to  the  sequence. If the byte representation of <b>v</b> does not fit in <b>len</b> characters, the
       exception <b>Failure</b> is raised.

       <u>val</u> <u>from_channel</u> : <b>in_channel</b> <b>-&gt;</b> <b>'a</b>

       <b>Marshal.from_channel</b> <b>chan</b> reads from channel <b>chan</b> the byte  representation  of  a  structured  value,  as
       produced by one of the <b>Marshal.to_*</b> functions, and reconstructs and returns the corresponding value.

       <b>Raises</b> <b>End_of_file</b> if <b>chan</b> is already at the end of the file.

       <b>Raises</b>  <b>Failure</b> if the end of the file is reached during unmarshalling itself or if <b>chan</b> is not in binary
       mode.

       <u>val</u> <u>from_bytes</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b>

       <b>Marshal.from_bytes</b> <b>buff</b> <b>ofs</b> unmarshals a structured value like <b>Marshal.from_channel</b> does, except that the
       byte representation is not read from a channel, but taken from the  byte  sequence  <b>buff</b>  ,  starting  at
       position <b>ofs</b> .  The byte sequence is not mutated.

       <b>Since</b> 4.02

       <u>val</u> <u>from_string</u> : <b>string</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b>

       Same as <b>from_bytes</b> but take a string as argument instead of a byte sequence.

       <u>val</u> <u>header_size</u> : <b>int</b>

       The  bytes  representing  a marshaled value are composed of a fixed-size header and a variable-sized data
       part, whose size can be determined from the header.  <b>Marshal.header_size</b> is the size, in  bytes,  of  the
       header.   <b>Marshal.data_size</b>  <b>buff</b> <b>ofs</b> is the size, in bytes, of the data part, assuming a valid header is
       stored in <b>buff</b> starting at position <b>ofs</b> .  Finally, <b>Marshal.total_size</b> <b>buff</b> <b>ofs</b> is  the  total  size,  in
       bytes, of the marshaled value.  Both <b>Marshal.data_size</b> and <b>Marshal.total_size</b> raise <b>Failure</b> if <b>buff</b> , <b>ofs</b>
       does not contain a valid header.

       To  read  the  byte  representation  of a marshaled value into a byte sequence, the program needs to read
       first <b>Marshal.header_size</b> bytes into the sequence, then determine the length  of  the  remainder  of  the
       representation  using  <b>Marshal.data_size</b>  ,  make sure the sequence is large enough to hold the remaining
       data, then read it, and finally call <b>Marshal.from_bytes</b> to unmarshal the value.

       <u>val</u> <u>data_size</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b>

       See <b>Marshal.header_size</b> .

       <u>val</u> <u>total_size</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b>

       See <b>Marshal.header_size</b> .

   <b>Marshal</b> <b>and</b> <b>domain</b> <b>safety</b>
       Care must be taken when marshaling a mutable value that may be modified by a different domain. Mutating a
       value that is being marshaled (i.e., turned into a sequence of bytes) is a programming  error  and  might
       result  in  surprising values (when unmarshaling) due to tearing, since marshaling involves byte-per-byte
       copy.

OCamldoc                                           2025-06-12                                        <u><a href="../man3o/Marshal.3o.html">Marshal</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>