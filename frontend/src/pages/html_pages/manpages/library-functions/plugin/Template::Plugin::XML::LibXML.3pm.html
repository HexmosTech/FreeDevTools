<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Template::Plugin::XML::LibXML - XML::LibXML Template Toolkit Plugin</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtemplate-plugin-xml-perl">libtemplate-plugin-xml-perl_2.17-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Template::Plugin::XML::LibXML - XML::LibXML Template Toolkit Plugin

</pre><h4><b>SYNOPSIS</b></h4><pre>
          [% USE docroot = XML.LibXML("helloworld.xml") %]

          The message is: [% docroot.find("/greeting/text") %]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides a plugin for the XML::LibXML module.  It can be utilised the same as any other
       Template Toolkit plugin, by using a USE statement from within a Template.  The use statment will return a
       reference to root node of the parsed document

   <b>Specifying</b> <b>a</b> <b>Data</b> <b>Source</b>
       The plugin is capable of using either a string, a filename or a filehandle as a source for either XML
       data, or HTML data which will be converted to XHTML internally.

       The USE statement can take one or more arguments to specify what XML should be processed.  If only one
       argument is passed then the plugin will attempt to guess how what it has been passed should be
       interpreted.

       When it is forced to guess what type of data it is used the routine will first look for an open
       filehandle, which if it finds it will assume it's a filehandle to a file containing XML.  Failing this
       (in decreasing order) it will look for the chars "&lt;?xml" at the start of what it was passed (and assume
       it's an XML string,) look for a "&lt;html&gt;" tag (and assume it's HTML string,) look for a "&lt;" (and assume
       it's XML string without a header,) or assume what it's been passed is the filename to a file containing
       XML.

       In the interests of being explicit, you may specify the type of data you are loading using the same names
       as in the <b>XML::LibXML</b> documentation:

          # value contains the xml string
          [% USE docroot = XML.LibXML(string =&gt; value) %]

          # value contains the filename of the xml
          [% USE docroot = XML.LibXML(file =&gt; value) %]

          # value contains an open filehandle to some xml
          [% USE docroot = XML.LibXML(fh =&gt; value) %]

          # value contains the html string
          [% USE docroot = XML.LibXML(html_string =&gt; value) %]

          # value contains the filename of the html
          [% USE docroot = XML.LibXML(html_file =&gt; value) %]

          # value contains an open filehandle to some html
          [% USE docroot = XML.LibXML(html_fh =&gt; value) %]

       Or, if you want you can use similar names to that the XML.XPath plugin uses:

          # value contains the xml string
          [% USE docroot = XML.LibXML(xml =&gt; value) %] or
          [% USE docroot = XML.LibXML(text =&gt; value) %]

          # value contains the filename of the xml
          [% USE docroot = XML.LibXML(filename =&gt; value) %]

          # value contains the html string
          [% USE docroot = XML.LibXML(html =&gt; value) %] or
          [% USE docroot = XML.LibXML(html_text =&gt; value) %]

          # value contains the filename of the html
          [% USE docroot = XML.LibXML(html_file =&gt; value) %]
          [% USE docroot = XML.LibXML(html_filename =&gt; value) %]

       You can provide extra arguments which will be used to set parser options.  See XML::LibXML for details on
       these.  I will repeat the following warning however: "LibXML options are global (unfortunately this is a
       limitation of the underlying implementation, not this interface)...Note that even two forked processes
       will share some of the same options, so be careful out there!"

          # turn off expanding entities
          [% USE docroot = XML.LibXML("file.xml",
                                      expand_entities =&gt; 0);

   <b>Obtaining</b> <b>Parts</b> <b>of</b> <b>an</b> <b>XML</b> <b>Document</b>
       XML::LibXML provides two simple mechanisms for obtaining sections of the XML document, both of which can
       be used from within the Template Toolkit

       The first of these is to use a XPath statement.  Simple values can be found with the "findvalue" routine:

         # get the title attribute of the first page node
         # (note xpath starts counting from one not zero)
         [% docroot.findvalue("/website/section/page[1]/@title"); %]

         # get the text contained within a node
         [% htmldoc.findvalue("/html/body/h1[1]/text()") %]

       Nodes of the xml document can be found with the "findnodes"

         # get all the pages ('pages' is a list of nodes)
         [% pages = docroot.findnodes("/website/section/page") %]

         # get the first page (as TT folds single elements arrays
         # to scalars, 'page1' is the one node that matched)
         [% page1 = docroot.findnodes("/website/section/page[1]") %]

       Then further xpath commands can then be applied to those nodes in turn:

         # get the title attribute of the first page
         [% page1.findvalue("@title") %]

       An alternative approach is to use individual method calls to move around the tree.  So the above could be
       written:

         # get the text of the h1 node
          [% htmlroot.documentElement
                     .getElementsByLocalName("body").first
                     .getElementsByLocalName("h1").first
                     .textContent %]

         # get the title of the first page
         [% docroot.documentElement
                   .getElementsByLocalName("section").first
                   .getElementsByLocalName("page").first
                   .getAttribute("title") %]

       You should use the technique that makes the most since in the particular situation.  These approaches can
       even be mixed:

         # get the first page title
         [% page1 = htmlroot.findnodes("/website/section/page[1]");
            page1.getAttribute("title") %]

       Much more information can be found in XML::LibXML::Node.

   <b>Rendering</b> <b>XML</b>
       The simplest way to use this plugin is simply to extract each value you want to print by hand

          The title of the first page is '[%
           docroot.findvalue("/website/section/page[1]/@title") %]'

       or

          The title of the first page is '[%
            docroot.documentElement
                   .getElementsByLocalName("section").first
                   .getElementsByLocalName("page").first
                   .getAttribute("title") %]'

       You might want to discard whitespace from text areas.  XPath can remove all leading and following
       whitespace, and condense all multiple spaces in the text to single spaces.

          &lt;p&gt;[% htmlroot.findvalue("normalize-space(
                                     /html/body/p[1]/text()
                                  )" | html %]&lt;/p&gt;

       Note that, as above, when we're inserting the values extracted into a XML or HTML document we have to be
       careful to re-encode the attributes we need to escape with something like the html filter.  A slightly
       more advanced technique is to extract a whole node and use the toString method call on it to convert it
       to a string of XML.  This is most useful when you are extracting an existing chunk of XML en mass, as
       things like &lt;b&gt; and &lt;i&gt; tags will be passed thought correctly and entities will be encoded suitably (for
       example '"' will be turned into '&amp;quot;')

         # get the second paragraph and insert it here as XML
         [% htmlroot.findnodes("/html/body/p[2]").toString %]

       The most powerful technique is to use a view (as defined by the VIEW keyword) to recursively render out
       the XML.  By loading this plugin "present" methods will be created in the <b>XML::LibXML::Node</b> classes and
       subclasses.  Calling "present" on a node with a VIEW will cause it to be rendered by the view block
       matching the local name of that node (with any non alphanumeric charecters turned to underscores.  So a
       &lt;author&gt; tag will be rendered by the 'author' block.  Text nodes will call the 'text' block with the text
       of the node.

       As the blocks can refer back to both the node it was called with and the view they can choose to
       recursively render out it's children using the view again.  To better facilitate this technique the extra
       methods "starttag" (recreate a string of the starting tag, including attributes,) "endtag" (recreate a
       string of the ending tag) and "content" (when called with a view, will render by calling all the children
       of that node in turn with that view) have been added.

       This is probably best shown with a well commented example:

         # create the view
         [% VIEW myview notfound =&gt; 'passthru' %]

           # default tag that will recreate the tag 'as is' meaning
           # that unknown tags will 'passed though' by the view
           [% BLOCK passthru; item.starttag;
                              item.content(view);
                              item.endtag;
           END %]

           # convert all sections to headed paragraphs
           [% BLOCK section %]
           &lt;h2&gt;[% item.getAttribute("title") %]&lt;/h2&gt;
           &lt;p&gt;[% item.content(view) %]&lt;/p&gt;
           [% END %]

           # urls link to themselves
           [% BLOCK url %]
           &lt;a href="[% item.content(view) %]"&gt;[% item.content(view) %]&lt;/a&gt;
           [% END %]

           # email link to themselves with mailtos
           [% BLOCK email %]
           &lt;a href="mailto:[% item.content(view) %]"&gt;[% item.content(view) %]&lt;/a&gt;
           [% END %]

           # make pod links bold
           [% BLOCK pod %]
           &lt;b&gt;[% item.content(view) %]&lt;/b&gt;
           [% END %]

           # render text, re-encoding the attributes as we go
           [% BLOCK text; item | html; END %]

           # render arrays out
           [% BLOCK list; FOREACH i = item; view.print(i); END ; END %]

         [% END %]

         # use it to render the paragraphs
         [% USE doc = XML.LibXML("mydoc.xml") %]
         &lt;html&gt;
          &lt;head&gt;
           &lt;title&gt;[% doc.findvalue("/doc/page[1]/@title") %]&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
           [% sections = doc.findnodes("/doc/page[1]/section");
              FOREACH section = sections %]
           &lt;!-- next section --&gt;
           [% <a href="../manmyview/section.present.myview.html">section.present</a>(myview);
              END %]
          &lt;/body&gt;
         &lt;/html&gt;

</pre><h4><b>BUGS</b></h4><pre>
       In order to detect if a scalar is an open filehandle (which is used if the USE isn't explicit about it's
       data source) this plugin uses the "openhandle" routine from <b>Scalar::Util</b>.  If you do not have
       <b>Scalar::Util</b> installed, or the version of <b>Scalar::Util</b> is sufficiently old that it does not support the
       "openhandle" routine then a much cruder "defined(fileno $scalar)" check will be employed.

       Bugs may be reported either via the CPAN RT at
       <a href="http://rt.cpan.org/NoAuth/Bugs.html">http://rt.cpan.org/NoAuth/Bugs.html</a>?Dist=Template-Plugin-XML-LibXML or via the Template Toolkit mailing
       list: <a href="http://www.template-toolkit.org/mailman/listinfo/templates">http://www.template-toolkit.org/mailman/listinfo/templates</a> or direct to the author

</pre><h4><b>AUTHOR</b></h4><pre>
       Written by Mark Fowler &lt;<a href="mailto:mark@twoshortplanks.com">mark@twoshortplanks.com</a>&gt;

       Copyright Mark Fowler 2002-3, all rights reserved.

       This program is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

       This module wouldn't have been possible without the wonderful work that has been put into the libxml
       library by the gnome team or the equally wonderful work put in by Matt Sergeant and Christian Glahn in
       creating XML::LibXML.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Template, Template::Plugin, XML::LibXML, XML::LibXML::Node.

       On a similar note, you may want to see Template::Plugin::XML::XPath.

       The t/test directory in the Template-Plugin-XML-LibXML distribution contains all the example XML files
       discussed in this documentation.

perl v5.34.0                                       2022-07-04                 <u>Template::Plugin::XML::<a href="../man3pm/LibXML.3pm.html">LibXML</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>