<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       timer_create — create a per-process timer

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;
       #include &lt;<a href="file:/usr/include/time.h">time.h</a>&gt;

       int timer_create(clockid_t <u>clockid</u>, struct sigevent *restrict <u>evp</u>,
           timer_t *restrict <u>timerid</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>timer_create</u>() function shall create a per-process timer using the specified clock, <u>clock_id</u>, as the
       timing base. The <u>timer_create</u>() function shall return, in the location referenced by <u>timerid</u>, a timer  ID
       of  type  <b>timer_t</b>  used to identify the timer in timer requests. This timer ID shall be unique within the
       calling process until the timer is deleted. The particular clock, <u>clock_id</u>, is defined in <u>&lt;time.h&gt;</u>.   The
       timer whose ID is returned shall be in a disarmed state upon return from <u>timer_create</u>().

       The  <u>evp</u>  argument,  if  non-NULL,  points  to  a  <b>sigevent</b>  structure.  This structure, allocated by the
       application, defines the asynchronous notification  to  occur  as  specified  in  <u>Section</u>  <u>2.4.1</u>,  <u>Signal</u>
       <u>Generation</u>  <u>and</u> <u>Delivery</u> when the timer expires. If the <u>evp</u> argument is NULL, the effect is as if the <u>evp</u>
       argument pointed to a <b>sigevent</b> structure with the <u>sigev_notify</u> member having the value SIGEV_SIGNAL,  the
       <u>sigev_signo</u> having a default signal number, and the <u>sigev_value</u> member having the value of the timer ID.

       Each implementation shall define a set of clocks that can be used as timing bases for per-process timers.
       All  implementations  shall  support  a  <u>clock_id</u>  of  CLOCK_REALTIME.   If the Monotonic Clock option is
       supported, implementations shall support a <u>clock_id</u> of CLOCK_MONOTONIC.

       Per-process timers shall not be inherited by a child process across a <u>fork</u>() and shall  be  disarmed  and
       deleted by an <u>exec</u>.

       If  _POSIX_CPUTIME  is  defined,  implementations shall support <u>clock_id</u> values representing the CPU-time
       clock of the calling process.

       If _POSIX_THREAD_CPUTIME is defined, implementations shall support <u>clock_id</u> values representing the  CPU-
       time clock of the calling thread.

       It  is  implementation-defined  whether  a  <u>timer_create</u>()  function will succeed if the value defined by
       <u>clock_id</u> corresponds to the CPU-time clock of a process or thread different from the  process  or  thread
       invoking the function.

       If <u>evp</u>-&gt;<u>sigev_sigev_notify</u> is SIGEV_THREAD and <u>sev</u>-&gt;<u>sigev_notify_attributes</u> is not NULL, if the attribute
       pointed  to  by  <u>sev</u>-&gt;<u>sigev_notify_attributes</u>  has  a  thread  stack  address  specified  by  a  call  to
       <u>pthread_attr_setstack</u>(), the results are unspecified if the signal is generated more than once.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       If the call succeeds, <u>timer_create</u>() shall return zero and update the location referenced by <u>timerid</u> to a
       <b>timer_t</b>, which can be passed to the per-process timer calls. If  an  error  occurs,  the  function  shall
       return  a  value of -1 and set <u>errno</u> to indicate the error. The value of <u>timerid</u> is undefined if an error
       occurs.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>timer_create</u>() function shall fail if:

       <b>EAGAIN</b> The system lacks sufficient signal queuing resources to honor the request.

       <b>EAGAIN</b> The calling process has already created all of the timers it is allowed by this implementation.

       <b>EINVAL</b> The specified clock ID is not defined.

       <b>ENOTSUP</b>
              The implementation does not support the creation of a timer attached to the CPU-time clock that is
              specified by <u>clock_id</u> and associated with a process or thread different from the process or thread
              invoking <u>timer_create</u>().

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       None.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       If a timer is created which has <u>evp</u>-&gt;<u>sigev_sigev_notify</u> set to SIGEV_THREAD and the attribute pointed  to
       by    <u>evp</u>-&gt;<u>sigev_notify_attributes</u>    has   a   thread   stack   address   specified   by   a   call   to
       <u>pthread_attr_setstack</u>(), the memory dedicated as a thread stack cannot be recovered. The reason for  this
       is  that the threads created in response to a timer expiration are created detached, or in an unspecified
       way if the thread attribute's <u>detachstate</u> is PTHREAD_CREATE_JOINABLE. In neither case is it valid to call
       <u>pthread_join</u>(), which makes it impossible to determine the lifetime of  the  created  thread  which  thus
       means the stack memory cannot be reused.

</pre><h4><b>RATIONALE</b></h4><pre>
   <b>Periodic</b> <b>Timer</b> <b>Overrun</b> <b>and</b> <b>Resource</b> <b>Allocation</b>
       The  specified timer facilities may deliver realtime signals (that is, queued signals) on implementations
       that support this option. Since realtime applications cannot afford to lose notifications of asynchronous
       events, like timer expirations or asynchronous I/O completions,  it  must  be  possible  to  ensure  that
       sufficient  resources  exist  to  deliver  the  signal  when  the event occurs. In general, this is not a
       difficulty because there is a one-to-one  correspondence  between  a  request  and  a  subsequent  signal
       generation.  If  the  request cannot allocate the signal delivery resources, it can fail the call with an
       <b>[EAGAIN]</b> error.

       Periodic timers are a special case. A single request can generate an unspecified number of signals.  This
       is  not  a  problem if the requesting process can service the signals as fast as they are generated, thus
       making the signal delivery resources available for  delivery  of  subsequent  periodic  timer  expiration
       signals.  But,  in  general, this cannot be assured—processing of periodic timer signals may ``overrun'';
       that is, subsequent periodic timer expirations may occur before the currently  pending  signal  has  been
       delivered.

       Also,  for signals, according to the POSIX.1‐1990 standard, if subsequent occurrences of a pending signal
       are generated, it is implementation-defined whether a signal is delivered for each  occurrence.  This  is
       not  adequate  for some realtime applications. So a mechanism is required to allow applications to detect
       how many timer expirations were delayed without requiring an indefinite amount  of  system  resources  to
       store the delayed expirations.

       The  specified  facilities  provide  for  an overrun count. The overrun count is defined as the number of
       extra timer expirations that occurred between the time a timer expiration signal  is  generated  and  the
       time  the  signal  is  delivered.  The  signal-catching  function,  if it is concerned with overruns, can
       retrieve this count on entry. With this  method,  a  periodic  timer  only  needs  one  ``signal  queuing
       resource'' that can be allocated at the time of the <u>timer_create</u>() function call.

       A  function  is  defined  to  retrieve  the overrun count so that an application need not allocate static
       storage to contain the count, and an implementation need not update this storage asynchronously on  timer
       expirations.  But,  for  some  high-frequency periodic applications, the overhead of an additional system
       call on each timer expiration may be prohibitive. The functions, as defined, permit an implementation  to
       maintain  the  overrun count in user space, associated with the <u>timerid</u>.  The <u>timer_getoverrun</u>() function
       can then be implemented as a macro that uses the <u>timerid</u> argument (which may just be a pointer to a  user
       space  structure  containing the counter) to locate the overrun count with no system call overhead. Other
       implementations, less concerned with this class of applications, can avoid  the  asynchronous  update  of
       user  space by maintaining the count in a system structure at the cost of the extra system call to obtain
       it.

   <b>Timer</b> <b>Expiration</b> <b>Signal</b> <b>Parameters</b>
       The Realtime Signals Extension option supports an application-specific datum that  is  delivered  to  the
       extended  signal  handler.  This  value is explicitly specified by the application, along with the signal
       number to be delivered, in a <b>sigevent</b> structure. The type of the application-defined value can be  either
       an  integer constant or a pointer. This explicit specification of the value, as opposed to always sending
       the timer ID, was selected based on existing practice.

       It is common practice for realtime applications (on non-POSIX systems or realtime extended POSIX systems)
       to use the parameters of event handlers as the case label of a switch statement or as  a  pointer  to  an
       application-defined  data  structure.  Since  <u>timer_id</u>s  are  dynamically allocated by the <u>timer_create</u>()
       function, they can be used for neither of these functions without additional application overhead in  the
       signal handler; for example, to search an array of saved timer IDs to associate the ID with a constant or
       application data structure.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>clock_getres</u>(), <u>timer_delete</u>(), <u>timer_getoverrun</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;signal.h&gt;</b>, <b>&lt;time.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                  <u><a href="../man3POSIX/TIMER_CREATE.3POSIX.html">TIMER_CREATE</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>