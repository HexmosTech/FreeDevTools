<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>"IO::Async::Timer::Countdown" - event callback after a fixed delay</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libio-async-perl">libio-async-perl_0.804-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       "IO::Async::Timer::Countdown" - event callback after a fixed delay

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use IO::Async::Timer::Countdown;

          use IO::Async::Loop;
          my $loop = IO::Async::Loop-&gt;new;

          my $timer = IO::Async::Timer::Countdown-&gt;new(
             delay =&gt; 10,

             on_expire =&gt; sub {
                print "Sorry, your time's up\n";
                $loop-&gt;stop;
             },
          );

          $timer-&gt;start;

          $loop-&gt;add( $timer );

          $loop-&gt;run;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This subclass of IO::Async::Timer implements one-shot fixed delays.  The object implements a countdown
       timer, which invokes its callback after the given period from when it was started. After it has expired
       the Timer may be started again, when it will wait the same period then invoke the callback again. A timer
       that is currently running may be stopped or reset.

       For a "Timer" object that repeatedly runs a callback at regular intervals, see instead
       IO::Async::Timer::Periodic. For a "Timer" that invokes its callback at a fixed time in the future, see
       IO::Async::Timer::Absolute.

</pre><h4><b>EVENTS</b></h4><pre>
       The following events are invoked, either using subclass methods or CODE references in parameters:

   <b>on_expire</b>
       Invoked when the timer expires.

</pre><h4><b>PARAMETERS</b></h4><pre>
       The following named parameters may be passed to "new" or "configure":

   <b>on_expire</b> <b>=&gt;</b> <b>CODE</b>
       CODE reference for the "on_expire" event.

   <b>delay</b> <b>=&gt;</b> <b>NUM</b>
       The delay in seconds after starting the timer until it expires. Cannot be changed if the timer is
       running. A timer with a zero delay expires "immediately".

   <b>remove_on_expire</b> <b>=&gt;</b> <b>BOOL</b>
       Optional. If true, remove this timer object from its parent notifier or containing loop when it expires.
       Defaults to false.

       Once constructed, the timer object will need to be added to the "Loop" before it will work. It will also
       need to be started by the "start" method.

</pre><h4><b>METHODS</b></h4><pre>
   <b>is_expired</b>
          $expired = $timer-&gt;is_expired;

       Returns true if the Timer has already expired.

   <b>reset</b>
          $timer-&gt;reset;

       If the timer is running, restart the countdown period from now. If the timer is not running, this method
       has no effect.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Watchdog</b> <b>Timer</b>
       Because the "reset" method restarts a running countdown timer back to its full period, it can be used to
       implement a watchdog timer. This is a timer which will not expire provided the method is called at least
       as often as it is configured. If the method fails to be called, the timer will eventually expire and run
       its callback.

       For example, to expire an accepted connection after 30 seconds of inactivity:

          ...

          on_accept =&gt; sub {
             my ( $newclient ) = @_;

             my $watchdog = IO::Async::Timer::Countdown-&gt;new(
                delay =&gt; 30,

                on_expire =&gt; sub {
                   my $self = shift;

                   my $stream = $self-&gt;parent;
                   $stream-&gt;close;
                },
             );

             my $stream = IO::Async::Stream-&gt;new(
                handle =&gt; $newclient,

                on_read =&gt; sub {
                   my ( $self, $buffref, $eof ) = @_;
                   $watchdog-&gt;reset;

                   ...
                },

                on_closed =&gt; sub {
                   $watchdog-&gt;stop;
                },
             ) );

             $stream-&gt;add_child( $watchdog );
             $watchdog-&gt;start;

             $loop-&gt;add( $watchdog );
          }

       Rather than setting up a lexical variable to store the Stream so that the Timer's "on_expire" closure can
       call "close" on it, the parent/child relationship between the two Notifier objects is used. At the time
       the Timer "on_expire" closure is invoked, it will have been added as a child notifier of the Stream; this
       means the Timer's "parent" method will return the Stream Notifier. This enables it to call "close"
       without needing to capture a lexical variable, which would create a cyclic reference.

   <b>Fixed-Delay</b> <b>Repeating</b> <b>Timer</b>
       The "on_expire" event fires a fixed delay after the "start" method has begun the countdown. The "start"
       method can be invoked again at some point during the "on_expire" handling code, to create a timer that
       invokes its code regularly a fixed delay after the previous invocation has finished. This creates an
       arrangement similar to an IO::Async::Timer::Periodic, except that it will wait until the previous
       invocation has indicated it is finished, before starting the countdown for the next call.

          my $timer = IO::Async::Timer::Countdown-&gt;new(
             delay =&gt; 60,

             on_expire =&gt; sub {
                my $self = shift;

                start_some_operation(
                   on_complete =&gt; sub { $self-&gt;start },
                );
             },
          );

          $timer-&gt;start;
          $loop-&gt;add( $timer );

       This example invokes the "start_some_operation" function 60 seconds after the previous iteration has
       indicated it has finished.

</pre><h4><b>AUTHOR</b></h4><pre>
       Paul Evans &lt;<a href="mailto:leonerd@leonerd.org.uk">leonerd@leonerd.org.uk</a>&gt;

perl v5.40.1                                       2025-05-17                   <u>IO::Async::Timer::<a href="../man3pm/Countdown.3pm.html">Countdown</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>