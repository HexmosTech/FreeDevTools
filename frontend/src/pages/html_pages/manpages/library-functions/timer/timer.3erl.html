<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>timer - Timer functions.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       timer - Timer functions.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  provides useful functions related to time. Unless otherwise stated, time is always measured
       in <u>milliseconds</u>. All timer functions return immediately, regardless of work done by another process.

       Successful evaluations of the timer functions give return values containing a  timer  reference,  denoted
       <u>TRef</u>.  By using <u>cancel/1</u>, the returned reference can be used to cancel any requested action. A <u>TRef</u> is an
       Erlang term, which contents must not be changed.

       The time-outs are not exact, but are <u>at</u> <u>least</u> as long as requested.

       Creating timers using erlang:send_after/3 and erlang:start_timer/3 is much more efficient than using  the
       timers provided by this module. See the Timer Module section in the Efficiency Guide.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>time()</b> = integer() &gt;= 0

              Time in milliseconds.

       <b>tref()</b>

              A timer reference.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>apply_after(Time,</b> <b>Module,</b> <b>Function,</b> <b>Arguments)</b> <b>-&gt;</b>
                      {ok, TRef} | {error, Reason}

              Types:

                 Time = time()
                 Module = module()
                 Function = atom()
                 Arguments = [term()]
                 TRef = tref()
                 Reason = term()

              Evaluates <u>apply(Module,</u> <u>Function,</u> <u>Arguments)</u> after <u>Time</u> milliseconds.

              Returns <u>{ok,</u> <u>TRef}</u> or <u>{error,</u> <u>Reason}</u>.

       <b>apply_interval(Time,</b> <b>Module,</b> <b>Function,</b> <b>Arguments)</b> <b>-&gt;</b>
                         {ok, TRef} | {error, Reason}

              Types:

                 Time = time()
                 Module = module()
                 Function = atom()
                 Arguments = [term()]
                 TRef = tref()
                 Reason = term()

              Evaluates <u>apply(Module,</u> <u>Function,</u> <u>Arguments)</u> repeatedly at intervals of <u>Time</u>.

              Returns <u>{ok,</u> <u>TRef}</u> or <u>{error,</u> <u>Reason}</u>.

       <b>cancel(TRef)</b> <b>-&gt;</b> <b>{ok,</b> <b>cancel}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 TRef = tref()
                 Reason = term()

              Cancels  a previously requested time-out. <u>TRef</u> is a unique timer reference returned by the related
              timer function.

              Returns <u>{ok,</u> <u>cancel}</u>, or <u>{error,</u> <u>Reason}</u> when <u>TRef</u> is not a timer reference.

       <b>exit_after(Time,</b> <b>Reason1)</b> <b>-&gt;</b> <b>{ok,</b> <b>TRef}</b> <b>|</b> <b>{error,</b> <b>Reason2}</b>

       <b>exit_after(Time,</b> <b>Pid,</b> <b>Reason1)</b> <b>-&gt;</b> <b>{ok,</b> <b>TRef}</b> <b>|</b> <b>{error,</b> <b>Reason2}</b>

              Types:

                 Time = time()
                 Pid = pid() | (RegName :: atom())
                 TRef = tref()
                 Reason1 = Reason2 = term()

              <u>exit_after/2</u> is the same as <u>exit_after(Time,</u> <u>self(),</u> <u>Reason1)</u>.

              <u>exit_after/3</u> sends an exit signal with reason <u>Reason1</u> to pid <u>Pid</u>. Returns <u>{ok,</u>  <u>TRef}</u>  or  <u>{error,</u>
              <u>Reason2}</u>.

       <b>hms(Hours,</b> <b>Minutes,</b> <b>Seconds)</b> <b>-&gt;</b> <b>MilliSeconds</b>

              Types:

                 Hours = Minutes = Seconds = MilliSeconds = integer() &gt;= 0

              Returns the number of milliseconds in <u>Hours</u> <u>+</u> <u>Minutes</u> <u>+</u> <u>Seconds</u>.

       <b>hours(Hours)</b> <b>-&gt;</b> <b>MilliSeconds</b>

              Types:

                 Hours = MilliSeconds = integer() &gt;= 0

              Returns the number of milliseconds in <u>Hours</u>.

       <b>kill_after(Time)</b> <b>-&gt;</b> <b>{ok,</b> <b>TRef}</b> <b>|</b> <b>{error,</b> <b>Reason2}</b>

       <b>kill_after(Time,</b> <b>Pid)</b> <b>-&gt;</b> <b>{ok,</b> <b>TRef}</b> <b>|</b> <b>{error,</b> <b>Reason2}</b>

              Types:

                 Time = time()
                 Pid = pid() | (RegName :: atom())
                 TRef = tref()
                 Reason2 = term()

              <u>kill_after/1</u> is the same as <u>exit_after(Time,</u> <u>self(),</u> <u>kill)</u>.

              <u>kill_after/2</u> is the same as <u>exit_after(Time,</u> <u>Pid,</u> <u>kill)</u>.

       <b>minutes(Minutes)</b> <b>-&gt;</b> <b>MilliSeconds</b>

              Types:

                 Minutes = MilliSeconds = integer() &gt;= 0

              Returns the number of milliseconds in <u>Minutes</u>.

       <b>now_diff(T2,</b> <b>T1)</b> <b>-&gt;</b> <b>Tdiff</b>

              Types:

                 T1 = T2 = erlang:timestamp()
                 Tdiff = integer()
                   In microseconds

              Calculates  the  time  difference  <u>Tdiff</u> <u>=</u> <u>T2</u> <u>-</u> <u>T1</u> in <u>microseconds</u>, where <u>T1</u> and <u>T2</u> are time-stamp
              tuples on the same format as returned from <u>erlang:timestamp/0</u> or <u>os:timestamp/0</u>.

       <b>seconds(Seconds)</b> <b>-&gt;</b> <b>MilliSeconds</b>

              Types:

                 Seconds = MilliSeconds = integer() &gt;= 0

              Returns the number of milliseconds in <u>Seconds</u>.

       <b>send_after(Time,</b> <b>Message)</b> <b>-&gt;</b> <b>{ok,</b> <b>TRef}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>send_after(Time,</b> <b>Pid,</b> <b>Message)</b> <b>-&gt;</b> <b>{ok,</b> <b>TRef}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Time = time()
                 Pid = pid() | (RegName :: atom())
                 Message = term()
                 TRef = tref()
                 Reason = term()

                <u>send_after/3</u>:
                  Evaluates <u>Pid</u> <u>!</u> <u>Message</u> after <u>Time</u> milliseconds. (<u>Pid</u> can also be  an  atom  of  a  registered
                  name.)

                  Returns <u>{ok,</u> <u>TRef}</u> or <u>{error,</u> <u>Reason}</u>.

                  See also  the Timer Module section in the Efficiency Guide.

                <u>send_after/2</u>:
                  Same as <u>send_after(Time,</u> <u>self(),</u> <u>Message)</u>.

       <b>send_interval(Time,</b> <b>Message)</b> <b>-&gt;</b> <b>{ok,</b> <b>TRef}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>send_interval(Time,</b> <b>Pid,</b> <b>Message)</b> <b>-&gt;</b> <b>{ok,</b> <b>TRef}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Time = time()
                 Pid = pid() | (RegName :: atom())
                 Message = term()
                 TRef = tref()
                 Reason = term()

                <u>send_interval/3</u>:
                  Evaluates  <u>Pid</u>  <u>!</u>  <u>Message</u>  repeatedly  after <u>Time</u> milliseconds. (<u>Pid</u> can also be an atom of a
                  registered name.)

                  Returns <u>{ok,</u> <u>TRef}</u> or <u>{error,</u> <u>Reason}</u>.

                <u>send_interval/2</u>:
                  Same as <u>send_interval(Time,</u> <u>self(),</u> <u>Message)</u>.

       <b>sleep(Time)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Time = timeout()

              Suspends the process calling this function for <u>Time</u> milliseconds and then returns <u>ok</u>, or  suspends
              the  process  forever  if  <u>Time</u>  is  the  atom  <u>infinity</u>. Naturally, this function does <u>not</u> return
              immediately.

       <b>start()</b> <b>-&gt;</b> <b>ok</b>

              Starts the timer server. Normally, the server does not  need  to  be  started  explicitly.  It  is
              started dynamically if it is needed. This is useful during development, but in a target system the
              server is to be started explicitly. Use configuration parameters for Kernel for this.

       <b>tc(Fun)</b> <b>-&gt;</b> <b>{Time,</b> <b>Value}</b>

       <b>tc(Fun,</b> <b>Arguments)</b> <b>-&gt;</b> <b>{Time,</b> <b>Value}</b>

       <b>tc(Module,</b> <b>Function,</b> <b>Arguments)</b> <b>-&gt;</b> <b>{Time,</b> <b>Value}</b>

              Types:

                 Module = module()
                 Function = atom()
                 Arguments = [term()]
                 Time = integer()
                   In microseconds
                 Value = term()

                <u>tc/3</u>:
                  Evaluates <u>apply(Module,</u> <u>Function,</u> <u>Arguments)</u> and measures the elapsed real time as reported by
                  <u>erlang:monotonic_time/0</u>.

                  Returns  <u>{Time,</u> <u>Value}</u>, where <u>Time</u> is the elapsed real time in <u>microseconds</u>, and <u>Value</u> is what
                  is returned from the apply.

                <u>tc/2</u>:
                  Evaluates <u>apply(Fun,</u> <u>Arguments)</u>. Otherwise the same as <u>tc/3</u>.

                <u>tc/1</u>:
                  Evaluates <u>Fun()</u>. Otherwise the same as <u>tc/2</u>.

</pre><h4><b>EXAMPLES</b></h4><pre>
       <u>Example</u> <u>1</u>

       The following example shows how to print "Hello World!" in 5 seconds:

       1&gt; timer:apply_after(5000, io, format, ["~nHello World!~n", []]).
       {ok,TRef}
       Hello World!

       <u>Example</u> <u>2</u>

       The following example shows a process performing a certain action, and if this action  is  not  completed
       within a certain limit, the process is killed:

       Pid = spawn(mod, fun, [foo, bar]),
       %% If pid is not finished in 10 seconds, kill him
       {ok, R} = timer:kill_after(timer:<a href="../man10/seconds.10.html">seconds</a>(10), Pid),
       ...
       %% We change our mind...
       timer:cancel(R),
       ...

</pre><h4><b>NOTES</b></h4><pre>
       A timer can always be removed by calling <u>cancel/1</u>.

       An  interval  timer,  that  is,  a  timer  created  by  evaluating any of the functions <u>apply_interval/4</u>,
       <u>send_interval/3</u>, and <u>send_interval/2</u> is linked to the process to which the timer performs its task.

       A one-shot  timer,  that  is,  a  timer  created  by  evaluating  any  of  the  functions  <u>apply_after/4</u>,
       <u>send_after/3</u>,  <u>send_after/2</u>,  <u>exit_after/3</u>, <u>exit_after/2</u>, <u>kill_after/2</u>, and <u>kill_after/1</u> is not linked to
       any process. Hence, such a timer is removed only when it reaches its time-out, or  if  it  is  explicitly
       removed by a call to <u>cancel/1</u>.

Ericsson AB                                        stdlib 3.17                                       <u><a href="../man3erl/timer.3erl.html">timer</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>