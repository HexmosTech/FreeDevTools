<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>uplevel - Execute a script in a different stack frame</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       uplevel - Execute a script in a different stack frame

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>uplevel</b> ?<u>level</u>? <u>arg</u> ?<u>arg</u> <u>...</u>?
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       All  of  the  <u>arg</u>  arguments  are  concatenated  as if they had been passed to <b>concat</b>; the result is then
       evaluated in the variable context indicated by <u>level</u>.  <b>Uplevel</b> returns the result of that evaluation.

       If <u>level</u> is an integer then it gives a distance (up the procedure calling stack) to move before executing
       the command.  If <u>level</u> consists of <b>#</b> followed by a integer then the level gives an  absolute  level.   If
       <u>level</u>  is  omitted  then it defaults to <b>1</b>.  <u>Level</u> cannot be defaulted if the first <u>command</u> argument is an
       integer or starts with <b>#</b>.

       For example, suppose that procedure <b>a</b> was invoked from top-level, and that it called <b>b</b>, and that <b>b</b> called
       <b>c</b>.  Suppose that <b>c</b> invokes the <b>uplevel</b> command.  If <u>level</u> is <b>1</b> or <b>#2</b>  or omitted, then the  command  will
       be  executed  in the variable context of <b>b</b>.  If <u>level</u> is <b>2</b> or <b>#1</b> then the command will be executed in the
       variable context of <b>a</b>.  If <u>level</u> is <b>3</b> or <b>#0</b> then the command will be executed at top-level  (only  global
       variables will be visible).

       The <b>uplevel</b> command causes the invoking procedure to disappear from the procedure calling stack while the
       command is being executed.  In the above example, suppose <b>c</b> invokes the command

              <b>uplevel</b> 1 {set x 43; d}

       where  <b>d</b> is another Tcl procedure.  The <b>set</b> command will modify the variable <b>x</b> in <b>b</b>'s context, and <b>d</b> will
       execute at level 3, as if called from <b>b</b>.  If it in turn executes the command

              <b>uplevel</b> {set x 42}

       then the <b>set</b> command will modify the same variable <b>x</b> in <b>b</b>'s context:  the procedure <b>c</b> does not appear  to
       be  on the call stack when <b>d</b> is executing.  The <b>info</b> <b>level</b> command may be used to obtain the level of the
       current procedure.

       <b>Uplevel</b> makes it possible to implement new control constructs as Tcl  procedures  (for  example,  <b>uplevel</b>
       could be used to implement the <b>while</b> construct as a Tcl procedure).

       The  <b>namespace</b>  <b>eval</b>  and  <b>apply</b>  commands offer other ways (besides procedure calls) that the Tcl naming
       context can change.  They add a call frame to the stack to represent the namespace context.   This  means
       each  <b>namespace</b>  <b>eval</b>  command counts as another call level for <b>uplevel</b> and <b>upvar</b> commands.  For example,
       <b>info</b> <b>level</b> <b>1</b> will return a list describing a command that is either the outermost procedure call  or  the
       outermost  <b>namespace</b>  <b>eval</b>  command.   Also,  <b>uplevel</b> <b>#0</b> evaluates a script at top-level in the outermost
       namespace (the global namespace).

</pre><h4><b>EXAMPLE</b></h4><pre>
       As stated above, the <b>uplevel</b> command is useful for creating new control constructs.  This  example  shows
       how  (without  error  handling)  it  can  be used to create a <b>do</b> command that is the counterpart of <b>while</b>
       except for always performing the test after running the loop body:

              proc do {body while condition} {
                  if {$while ne "while"} {
                      error "required word missing"
                  }
                  set conditionCmd [list expr $condition]
                  while {1} {
                      <b>uplevel</b> 1 $body
                      if {![<b>uplevel</b> 1 $conditionCmd]} {
                          break
                      }
                  }
              }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/apply.3tcl.html">apply</a>(3tcl), <a href="../man3tcl/namespace.3tcl.html">namespace</a>(3tcl), <a href="../man3tcl/upvar.3tcl.html">upvar</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       context, level, namespace, stack frame, variable

Tcl                                                                                                <u><a href="../man3tcl/uplevel.3tcl.html">uplevel</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>