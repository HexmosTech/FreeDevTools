<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pvm_reg_tasker - Register task as PVM task starter.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/pvm-dev">pvm-dev_3.4.6-3.2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pvm_reg_tasker - Register task as PVM task starter.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>C</b>    <b>#include</b> <b>&lt;pvmsdpro.h&gt;</b>

            <b>int</b> <b>cc</b> <b>=</b> <b>pvm_reg_tasker()</b>

       <b>Fortran</b>   <b>Not</b> <b>Available</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Registers  the calling task as a PVM task starter.  When a tasker is registered with a pvmd, and the pvmd
       receives a DM_EXEC message, instead of fork()ing and exec()ing the task itself, it passes  a  message  to
       the tasker, which does the dirty work and sends a message back to the pvmd.

       Note:   If  this  doesn't  make  sense, don't worry about it.  This function is for folks who are writing
       stuff like debugger servers and so on.  For a more complete explanation of  what's  going  on  here,  you
       should refer to the PVM source code and/or user guide section on implementation; this is only a man page.
       That said...

       When  the  pvmd  receives  a  <u>DM_EXEC</u>  message  (request  to  exec new tasks), it searches <u>epath</u> (the PVM
       executable search path) for the file name.  If it finds the file, it then either attempts  to  start  the
       processes (using <u>fork()</u> and <u>exec()</u>) or, if a tasker has registered, sends it a <u>SM_STTASK</u> message.

       The format of the SM_STTASK message is:
           int tid               // of task
           int flags             // as passed to spawn()
           string path           // absolute path of the executable
           int argc              // number of args to process
           string argv[argc]     // args
           int nenv              // number of envars to pass to task
           string env[nenv]      // environment strings

       The  tasker  must  attempt  to  start the process when it gets one of these messages.  The tasker doesn't
       reply to the pvmd if the task is successfully started; the task will reconnect to the pvmd  on  its  own,
       using the cookie in envar <u>PVMEPID</u> to identify itself to the pvmd.

       The tasker must send a <u>SM_TASKX</u> message to the pvmd when any task that it owns (has started) exits, or if
       it can't start a particular task.  The format of the SM_TASKX message is:

           int tid               // of task
           int status            // the Unix exit status (from <u>wait()</u>)
           int u_sec             // user time used by the task, seconds
           int u_usec            // microseconds
           int s_sec             // system time used by the task, seconds
           int s_usec            // microseconds

       The  tasker task must use pvm_setopt(PvmResvTids, 1) to allow sending reserved messages.  Messages should
       be packed using encoding <u>PvmDataDefault</u> to ensure they can be unpacked anywhere in the system.

       pvm_reg_tasker() returns PvmOk when successful.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3PVM/pvm_spawn.3PVM.html">pvm_spawn</a>(3PVM), <a href="../man3PVM/pvm_tasks.3PVM.html">pvm_tasks</a>(3PVM),

                                                 16 March, 1994                                 <u><a href="../man3PVM/REG_TASKER.3PVM.html">REG_TASKER</a></u>(3PVM)
</pre>
 </div>
</div></section>
</div>
</body>
</html>