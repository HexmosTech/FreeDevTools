<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>history - GNU History Library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/readline-common">readline-common_8.3-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       history - GNU History Library

</pre><h4><b>COPYRIGHT</b></h4><pre>
       The GNU History Library is Copyright (C) 1989-2025 by the Free Software Foundation, Inc.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Many  programs  read input from the user a line at a time.  The GNU History library is able to keep track
       of those lines, associate arbitrary data with each line, and utilize information from previous lines when
       composing new ones.

       The History library provides functions that allow applications to their <u>history</u>, the set  of  previously-
       typed  lines, which it keeps in a list.  Applications can choose which lines to save into a history list,
       how many commands to save, save a history list to a file, read a history list from a  file,  and  display
       lines from the history in various formats.

</pre><h4><b>HISTORY</b> <b>EXPANSION</b></h4><pre>
       The  history  library  supports a history expansion feature that is identical to the history expansion in
       <b>bash</b>.  This section describes what syntax features are available.

       History expansions introduce words from the history list into the input stream, making it easy to  repeat
       commands,  insert  the  arguments  to  a  previous  command into the current input line, or fix errors in
       previous commands quickly.

       History expansion is usually performed immediately after a complete line is read.  It takes place in  two
       parts.   The first is to determine which history list entry to use during substitution.  The second is to
       select portions of that entry to include into the current one.

       The entry selected from the history is the <u>event</u>, and the portions of that entry that are acted upon  are
       <u>words</u>.   Various <u>modifiers</u> are available to manipulate the selected words.  The entry is split into words
       in the same fashion as <b>bash</b> does when reading input, so  that  several  words  that  would  otherwise  be
       separated  are  considered  one word when surrounded by quotes (see the description of <b>history_tokenize()</b>
       below).  The <u>event</u> <u>designator</u> selects the event, the optional <u>word</u>  <u>designator</u>  selects  words  from  the
       event, and various optional <u>modifiers</u> are available to manipulate the selected words.

       History  expansions  are  introduced  by the appearance of the history expansion character, which is <b>!</b> by
       default.  History expansions may appear anywhere in the input, but do not nest.

       Only backslash (<b>\</b>) and single quotes can quote the history expansion character.

       There is a special abbreviation for substitution, active when the <u>quick</u> <u>substitution</u>  character  (default
       <b>^</b>)  is  the  first  character  on  the  line.  It selects the previous history list entry, using an event
       designator equivalent to <b>!!</b>, and substitutes one string for another in that entry.  It is described below
       under <b>Event</b> <b>Designators</b>.  This is the only history  expansion  that  does  not  begin  with  the  history
       expansion character.

   <b>Event</b> <b>Designators</b>
       An event designator is a reference to an entry in the history list.  The event designator consists of the
       portion of the word beginning with the history expansion character and ending with the word designator if
       present,  or  the  end of the word.  Unless the reference is absolute, events are relative to the current
       position in the history list.

       <b>!</b>      Start a history substitution, except when followed by a <b>blank</b>, newline, carriage return, =, or (.
       <b>!</b><u>n</u>     Refer to history list entry <u>n</u>.
       <b>!-</b><u>n</u>    Refer to the current entry minus <u>n</u>.
       <b>!!</b>     Refer to the previous entry.  This is a synonym for “!-1”.
       <b>!</b><u>string</u>
              Refer to the most recent command preceding the current position in the history list starting  with
              <u>string</u>.
       <b>!?</b><u>string</u><b>[?]</b>
              Refer  to  the  most  recent command preceding the current position in the history list containing
              <u>string</u>.  The trailing <b>?</b> may be omitted if <u>string</u> is followed immediately by a newline.  If  <u>string</u>
              is  missing,  this  uses  the  string  from  the most recent search; it is an error if there is no
              previous search string.
       <b>^</b><u>string1</u><b>^</b><u>string2</u><b>^</b>
              Quick substitution.  Repeat the previous command, replacing <u>string1</u> with <u>string2</u>.   Equivalent  to
              “!!:s^<u>string1</u>^<u>string2</u>^” (see <b>Modifiers</b> below).
       <b>!#</b>     The entire command line typed so far.

   <b>Word</b> <b>Designators</b>
       Word  designators  are  used  to  select  desired  words  from the event.  They are optional; if the word
       designator isn't supplied, the history expansion  uses  the  entire  event.   A  <b>:</b>  separates  the  event
       specification  from the word designator.  It may be omitted if the word designator begins with a <b>^</b>, <b>$</b>, <b>*</b>,
       <b>-</b>, or <b>%</b>.  Words are numbered from the beginning of the line, with the  first  word  being  denoted  by  0
       (zero).  Words are inserted into the current line separated by single spaces.

       <b>0</b> <b>(zero)</b>
              The zeroth word.  For the shell, and many other applications, this is the command word.
       <u>n</u>      The <u>n</u>th word.
       <b>^</b>      The first argument: word 1.
       <b>$</b>      The last word.  This is usually the last argument, but expands to the zeroth word if there is only
              one word in the line.
       <b>%</b>      The  first  word matched by the most recent “?<u>string</u>?”  search, if the search string begins with a
              character that is part of a word.  By default, searches begin at the end of each line and  proceed
              to the beginning, so the first word matched is the one closest to the end of the line.
       <u>x</u><b>-</b><u>y</u>    A range of words; “-<u>y</u>” abbreviates “0-<u>y</u>”.
       <b>*</b>      All  of  the  words  but the zeroth.  This is a synonym for “<u>1-$</u>”.  It is not an error to use <b>*</b> if
              there is just one word in the event; it expands to the empty string in that case.
       <b>x*</b>     Abbreviates <u>x-$</u>.
       <b>x-</b>     Abbreviates <u>x-$</u> like <b>x*</b>, but omits the last word.  If <b>x</b> is missing, it defaults to 0.

       If a word designator is supplied without an event specification, the previous  command  is  used  as  the
       event, equivalent to <b>!!</b>.

   <b>Modifiers</b>
       After  the optional word designator, the expansion may include a sequence of one or more of the following
       modifiers, each preceded by a “:”.  These modify, or edit, the word or words selected  from  the  history
       event.

       <b>h</b>      Remove a trailing filename component, leaving only the head.
       <b>t</b>      Remove all leading filename components, leaving the tail.
       <b>r</b>      Remove a trailing suffix of the form <u>.xxx</u>, leaving the basename.
       <b>e</b>      Remove all but the trailing suffix.
       <b>p</b>      Print the new command but do not execute it.
       <b>q</b>      Quote the substituted words, escaping further substitutions.
       <b>x</b>      Quote  the  substituted words as with <b>q</b>, but break into words at <b>blanks</b> and newlines.  The <b>q</b> and <b>x</b>
              modifiers are mutually exclusive; expansion uses the last one supplied.
       <b>s/</b><u>old</u><b>/</b><u>new</u><b>/</b>
              Substitute <u>new</u> for the first occurrence of <u>old</u> in the event line.  Any character may  be  used  as
              the  delimiter  in place of <a href="file:/.">/.</a>  The final delimiter is optional if it is the last character of the
              event line.  A single backslash quotes the delimiter in <u>old</u> and <u>new</u>.  If &amp; appears in <u>new</u>,  it  is
              replaced  with  <u>old</u>.   A single backslash quotes the &amp;.  If <u>old</u> is null, it is set to the last <u>old</u>
              substituted, or, if no previous history substitutions took place, the last <u>string</u> in a <b>!?</b><u>string</u><b>[?]</b>
              search.  If <u>new</u> is null, each matching <u>old</u> is deleted.
       <b>&amp;</b>      Repeat the previous substitution.
       <b>g</b>      Cause changes to be applied over the entire event line.  This is used  in  conjunction  with  “<b>:s</b>”
              (e.g.,  “<b>:gs/</b><u>old</u><b>/</b><u>new</u><b>/</b>”)  or “<b>:&amp;</b>”.  If used with “<b>:s</b>”, any delimiter can be used in place of /, and
              the final delimiter is optional if it is the last character of the event line.  An <b>a</b> may  be  used
              as a synonym for <b>g</b>.
       <b>G</b>      Apply the following “<b>s</b>” or “<b>&amp;</b>” modifier once to each word in the event line.

</pre><h4><b>PROGRAMMING</b> <b>WITH</b> <b>HISTORY</b> <b>FUNCTIONS</b></h4><pre>
       This section describes how to use the History library in other programs.

   <b>Introduction</b> <b>to</b> <b>History</b>
       A  programmer  using the History library has available functions for remembering lines on a history list,
       associating arbitrary data with a line, removing lines from the list, searching through the  list  for  a
       line  containing an arbitrary text string, and referencing any line in the list directly.  In addition, a
       history <u>expansion</u> function is available which provides for a consistent user interface  across  different
       programs.

       The  user  using programs written with the History library has the benefit of a consistent user interface
       with a set of well-known commands for manipulating the text of previous lines and using that text in  new
       commands.   The basic history manipulation commands are identical to the history substitution provided by
       <b>bash</b>.

       The programmer can also use the readline library, which includes some history  manipulation  by  default,
       and has the added advantage of command line editing.

       Before  declaring  any  functions  using any functionality the History library provides in other code, an
       application writer should include the file  <u>&lt;readline/history.h&gt;</u>  in  any  file  that  uses  the  History
       library's  features.   It  supplies  extern  declarations  for  all of the library's public functions and
       variables, and declares all of the public data structures.

   <b>History</b> <b>Storage</b>
       The history list is an array of history entries.  A history entry is declared as follows:

       <u>typedef</u> <u>void</u> <u>*</u> <b>histdata_t;</b>

       typedef struct _hist_entry {
         char *line;
         char *timestamp;
         histdata_t data;
       } HIST_ENTRY;

       The history list itself might therefore be declared as

       <u>HIST_ENTRY</u> <u>**</u> <b>the_history_list;</b>

       The state of the History library is encapsulated into a single structure:

       /*
        * A structure used to pass around the current state of the history.
        */
       typedef struct _hist_state {
         HIST_ENTRY **entries; /* Pointer to entry records. */
         int offset;           /* The current record. */
         int length;           /* Number of records in list. */
         int size;             /* Number of records allocated. */
         int flags;
       } HISTORY_STATE;

       If the flags member includes <b>HS_STIFLED</b>, the history has been stifled.

</pre><h4><b>History</b> <b>Functions</b></h4><pre>
       This section describes the calling sequence for  the  various  functions  exported  by  the  GNU  History
       library.

   <b>Initializing</b> <b>History</b> <b>and</b> <b>State</b> <b>Management</b>
       This  section describes functions used to initialize and manage the state of the History library when you
       want to use the history functions in your program.

       <u>void</u> <b>using_history</b> (<u>void</u>)
       Begin a session in which  the  history  functions  might  be  used.   This  initializes  the  interactive
       variables.

       <u>HISTORY_STATE</u> <u>*</u> <b>history_get_history_state</b> (<u>void</u>)
       Return a structure describing the current state of the input history.

       <u>void</u> <b>history_set_history_state</b> (<u>HISTORY_STATE</u> <u>*state</u>)
       Set the state of the history list according to <u>state</u>.

   <b>History</b> <b>List</b> <b>Management</b>
       These  functions  manage  individual  entries  on  the  history list, or set parameters managing the list
       itself.

       <u>void</u> <b>add_history</b> (<u>const</u> <u>char</u> <u>*string</u>)
       Place <u>string</u> at the end of the history list.  The associated data field (if any) is set to <b>NULL</b>.  If  the
       maximum  number  of  history  entries  has been set using <b>stifle_history()</b>, and the new number of history
       entries would exceed that maximum, the oldest history entry is removed.

       <u>void</u> <b>add_history_time</b> (<u>const</u> <u>char</u> <u>*string</u>)
       Change the time stamp associated with the most recent history entry to <u>string</u>.

       <u>HIST_ENTRY</u> <u>*</u> <b>remove_history</b> (<u>int</u> <u>which</u>)
       Remove history entry at offset <u>which</u> from the history.  The removed element is returned so you  can  free
       the line, data, and containing structure.

       <u>histdata_t</u> <b>free_history_entry</b> (<u>HIST_ENTRY</u> <u>*histent</u>)
       Free  the  history  entry  <u>histent</u>  and any history library private data associated with it.  Returns the
       application-specific data so the caller can dispose of it.

       <u>HIST_ENTRY</u> <u>*</u> <b>replace_history_entry</b> (<u>int</u> <u>which,</u> <u>const</u> <u>char</u> <u>*line,</u> <u>histdata_t</u> <u>data</u>)
       Make the history entry at offset <u>which</u> have <u>line</u> and <u>data</u>.  This returns the old entry so the caller  can
       dispose of any application-specific data.  In the case of an invalid <u>which</u>, a <b>NULL</b> pointer is returned.

       <u>void</u> <b>clear_history</b> (<u>void</u>)
       Clear the history list by deleting all the entries.

       <u>void</u> <b>stifle_history</b> (<u>int</u> <u>max</u>)
       Stifle  the  history list, remembering only the last <u>max</u> entries.  The history list will contain only <u>max</u>
       entries at a time.

       <u>int</u> <b>unstifle_history</b> (<u>void</u>)
       Stop stifling the history.  This returns the previously-set maximum number of history entries (as set  by
       <b>stifle_history()</b>).   history  was stifled.  The value is positive if the history was stifled, negative if
       it wasn't.

       <u>int</u> <b>history_is_stifled</b> (<u>void</u>)
       Returns non-zero if the history is stifled, zero if it is not.

   <b>Information</b> <b>About</b> <b>the</b> <b>History</b> <b>List</b>
       These functions return information about the entire history list or individual list entries.

       <u>HIST_ENTRY</u> <u>**</u> <b>history_list</b> (<u>void</u>)
       Return a <b>NULL</b> terminated array of <u>HIST_ENTRY</u> <u>*</u> which is the current input history.   Element  0  of  this
       list is the beginning of time.  If there is no history, return <b>NULL</b>.

       <u>int</u> <b>where_history</b> (<u>void</u>)
       Returns the offset of the current history element.

       <u>HIST_ENTRY</u> <u>*</u> <b>current_history</b> (<u>void</u>)
       Return the history entry at the current position, as determined by <b>where_history()</b>.  If there is no entry
       there, return a <b>NULL</b> pointer.

       <u>HIST_ENTRY</u> <u>*</u> <b>history_get</b> (<u>int</u> <u>offset</u>)
       Return  the history entry at position <u>offset</u>.  The range of valid values of <u>offset</u> starts at <b>history_base</b>
       and ends at <b>history_length</b> - 1.  If there is no entry there, or if <u>offset</u> is  outside  the  valid  range,
       return a <b>NULL</b> pointer.

       <u>time_t</u> <b>history_get_time</b> (<u>HIST_ENTRY</u> <u>*</u>)
       Return the time stamp associated with the history entry passed as the argument.

       <u>int</u> <b>history_total_bytes</b> (<u>void</u>)
       Return  the number of bytes that the primary history entries are using.  This function returns the sum of
       the lengths of all the lines in the history.

   <b>Moving</b> <b>Around</b> <b>the</b> <b>History</b> <b>List</b>
       These functions allow the current index into the history list to be set or changed.

       <u>int</u> <b>history_set_pos</b> (<u>int</u> <u>pos</u>)
       Set the current history offset to <u>pos</u>, an absolute index into the list.  Returns 1 on success, 0  if  <u>pos</u>
       is less than zero or greater than the number of history entries.

       <u>HIST_ENTRY</u> <u>*</u> <b>previous_history</b> (<u>void</u>)
       Back up the current history offset to the previous history entry, and return a pointer to that entry.  If
       there is no previous entry, return a <b>NULL</b> pointer.

       <u>HIST_ENTRY</u> <u>*</u> <b>next_history</b> (<u>void</u>)
       If  the current history offset refers to a valid history entry, increment the current history offset.  If
       the possibly-incremented history offset refers to a valid history entry, return a pointer to that  entry;
       otherwise, return a <b>NULL</b> pointer.

   <b>Searching</b> <b>the</b> <b>History</b> <b>List</b>
       These  functions allow searching of the history list for entries containing a specific string.  Searching
       may be performed both forward and backward  from  the  current  history  position.   The  search  may  be
       <u>anchored</u>, meaning that the string must match at the beginning of the history entry.

       <u>int</u> <b>history_search</b> (<u>const</u> <u>char</u> <u>*string,</u> <u>int</u> <u>direction</u>)
       Search the history for <u>string</u>, starting at the current history offset.  If <u>direction</u> is less than 0, then
       the  search  is through previous entries, otherwise through subsequent entries.  If <u>string</u> is found, then
       the current history index is set to that history entry, and the value returned is the offset in the  line
       of the entry where <u>string</u> was found.  Otherwise, nothing is changed, and the function returns -1.

       <u>int</u> <b>history_search_prefix</b> (<u>const</u> <u>char</u> <u>*string,</u> <u>int</u> <u>direction</u>)
       Search  the history for <u>string</u>, starting at the current history offset.  The search is anchored: matching
       lines must begin with <u>string</u>.  If <u>direction</u> is less than 0, then the search is through previous  entries,
       otherwise  through subsequent entries.  If <u>string</u> is found, then the current history index is set to that
       entry, and the return value is 0.  Otherwise, nothing is changed, and the function returns -1.

       <u>int</u> <b>history_search_pos</b> (<u>const</u> <u>char</u> <u>*string,</u> <u>int</u> <u>direction,</u> <u>int</u> <u>pos</u>)
       Search for <u>string</u> in the history list, starting at <u>pos</u>, an absolute index into the list.  If <u>direction</u> is
       negative, the search proceeds backward from <u>pos</u>, otherwise forward.  Returns the absolute  index  of  the
       history element where <u>string</u> was found, or -1 otherwise.

   <b>Managing</b> <b>the</b> <b>History</b> <b>File</b>
       The  History  library  can  read  the  history  from  and write it to a file.  This section documents the
       functions for managing a history file.

       <u>int</u> <b>read_history</b> (<u>const</u> <u>char</u> <u>*filename</u>)
       Add the contents of <u>filename</u> to the history list, a line at a time.  If <u>filename</u> is <b>NULL</b>, then read  from
       <u><a href="file:~/.history">~/.history</a></u>.  Returns 0 if successful, or <b>errno</b> if not.

       <u>int</u> <b>read_history_range</b> (<u>const</u> <u>char</u> <u>*filename,</u> <u>int</u> <u>from,</u> <u>int</u> <u>to</u>)
       Read a range of lines from <u>filename</u>, adding them to the history list.  Start reading at line <u>from</u> and end
       at <u>to</u>.  If <u>from</u> is zero, start at the beginning.  If <u>to</u> is less than <u>from</u>, then read until the end of the
       file.  If <u>filename</u> is <b>NULL</b>, then read from <u><a href="file:~/.history">~/.history</a></u>.  Returns 0 if successful, or <b>errno</b> if not.

       <u>int</u> <b>write_history</b> (<u>const</u> <u>char</u> <u>*filename</u>)
       Write  the  current  history  to  <u>filename</u>, overwriting <u>filename</u> if necessary.  If <u>filename</u> is <b>NULL</b>, then
       write the history list to <u><a href="file:~/.history">~/.history</a></u>.  Returns 0 on success, or <b>errno</b> on a read or write error.

       <u>int</u> <b>append_history</b> (<u>int</u> <u>nelements,</u> <u>const</u> <u>char</u> <u>*filename</u>)
       Append the last <u>nelements</u> of the history  list  to  <u>filename</u>.   If  <u>filename</u>  is  <b>NULL</b>,  then  append  to
       <u><a href="file:~/.history">~/.history</a></u>.  Returns 0 on success, or <b>errno</b> on a read or write error.

       <u>int</u> <b>history_truncate_file</b> (<u>const</u> <u>char</u> <u>*filename,</u> <u>int</u> <u>nlines</u>)
       Truncate  the  history  file  <u>filename</u>,  leaving  only  the last <u>nlines</u> lines.  If <u>filename</u> is <b>NULL</b>, then
       <u><a href="file:~/.history">~/.history</a></u> is truncated.  Returns 0 on success, or <b>errno</b> on failure.

   <b>History</b> <b>Expansion</b>
       These functions implement history expansion.

       <u>int</u> <b>history_expand</b> (<u>const</u> <u>char</u> <u>*string,</u> <u>char</u> <u>**output</u>)
       Expand <u>string</u>, placing the result into <u>output</u>, a pointer to a string.  Returns:
              0      If no expansions took place (or, if the only change in the text was the removal  of  escape
                     characters preceding the history expansion character);
              1      if expansions did take place;
              -1     if there was an error in expansion;
              2      if the returned line should be displayed, but not executed, as with the <b>:p</b> modifier.
       If an error occurred in expansion, then <u>output</u> contains a descriptive error message.

       <u>char</u> <u>*</u> <b>get_history_event</b> (<u>const</u> <u>char</u> <u>*string,</u> <u>int</u> <u>*cindex,</u> <u>int</u> <u>qchar</u>)
       Returns  the  text  of  the history event beginning at <u>string</u> + <u>*cindex</u>.  <u>*cindex</u> is modified to point to
       after the event specifier.  At function entry, <u>cindex</u> points to the index into <u>string</u> where  the  history
       event  specification  begins.   <u>qchar</u>  is  a  character that is allowed to end the event specification in
       addition to the “normal” terminating characters.

       <u>char</u> <u>**</u> <b>history_tokenize</b> (<u>const</u> <u>char</u> <u>*string</u>)
       Return an array of tokens parsed out of <u>string</u>, much as the shell might.  The tokens  are  split  on  the
       characters in the <b>history_word_delimiters</b> variable, and shell quoting conventions are obeyed.

       <u>char</u> <u>*</u> <b>history_arg_extract</b> (<u>int</u> <u>first,</u> <u>int</u> <u>last,</u> <u>const</u> <u>char</u> <u>*string</u>)
       Extract a string segment consisting of the <u>first</u> through <u>last</u> arguments present in <u>string</u>.  Arguments are
       split using <b>history_tokenize()</b>.

   <b>History</b> <b>Variables</b>
       This section describes the externally-visible variables exported by the GNU History Library.

       <u>int</u> <b>history_base</b>
       The logical offset of the first entry in the history list.

       <u>int</u> <b>history_length</b>
       The number of entries currently stored in the history list.

       <u>int</u> <b>history_max_entries</b>
       The maximum number of history entries.  This must be changed using <b>stifle_history()</b>.

       <u>int</u> <b>history_write_timestamps</b>
       If  non-zero, timestamps are written to the history file, so they can be preserved between sessions.  The
       default value is 0, meaning that timestamps are not saved.  The current timestamp format uses  the  value
       of <u>history_comment_char</u> to delimit timestamp entries in the history file.  If that variable does not have
       a value (the default), the history library will not write timestamps.

       <u>char</u> <b>history_expansion_char</b>
       The  character  that  introduces  a history event.  The default is <b>!</b>.  Setting this to 0 inhibits history
       expansion.

       <u>char</u> <b>history_subst_char</b>
       The character that invokes word substitution if found at the start of a line.  The default is <b>^</b>.

       <u>char</u> <b>history_comment_char</b>
       During tokenization, if this character is seen as the  first  character  of  a  word,  then  it  and  all
       subsequent characters up to a newline are ignored, suppressing history expansion for the remainder of the
       line.  This is disabled by default.

       <u>char</u> <u>*</u> <b>history_word_delimiters</b>
       The characters that separate tokens for <b>history_tokenize()</b>.  The default value is <b>"</b> <b>\t\n()&lt;&gt;;&amp;|"</b>.

       <u>char</u> <u>*</u> <b>history_no_expand_chars</b>
       The   list   of   characters   which   inhibit   history   expansion   if   found  immediately  following
       <b>history_expansion_char</b>.  The default is space, tab, newline, <b>\r</b>, and <b>=</b>.

       <u>char</u> <u>*</u> <b>history_search_delimiter_chars</b>
       The list of additional characters which can delimit a history search string, in addition to space, tab, <u>:</u>
       and <u>?</u> in the case of a substring search.  The default is empty.

       <u>int</u> <b>history_quotes_inhibit_expansion</b>
       If non-zero, the history expansion code  implements  shell-like  quoting:  single-quoted  words  are  not
       scanned for the history expansion character or the history comment character, and double-quoted words may
       have  history expansion performed, since single quotes are not special within double quotes.  The default
       value is 0.

       <u>int</u> <b>history_quoting_state</b>
       An application may set this variable to indicate that the current  line  being  expanded  is  subject  to
       existing  quoting.   If  set  to  <u>'</u>, history expansion assumes that the line is single-quoted and inhibit
       expansion until it reads an unquoted closing single quote; if set to <u>"</u>,  history  expansion  assumes  the
       line  is  double  quoted  until  it reads an unquoted closing double quote.  If set to zero, the default,
       history expansion assumes the line is not quoted and treats quote characters within the line as described
       above.  This is only effective if <b>history_quotes_inhibit_expansion</b> is set.

       <u>rl_linebuf_func_t</u> <u>*</u> <b>history_inhibit_expansion_function</b>
       This should be set to the address of a function that takes two arguments: a <b>char</b> <b>*</b> (<u>string</u>)  and  an  <b>int</b>
       index  into  that  string  (<u>i</u>).   It  should return a non-zero value if the history expansion starting at
       <u>string[i]</u> should not be performed; zero if the expansion should be done.   It  is  intended  for  use  by
       applications  like  <b>bash</b>  that  use the history expansion character for additional purposes.  By default,
       this variable is set to <b>NULL</b>.

</pre><h4><b>FILES</b></h4><pre>
       <u><a href="file:~/.history">~/.history</a></u>
              Default filename for reading and writing saved history

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>The</u> <u>Gnu</u> <u>Readline</u> <u>Library</u>, Brian Fox and Chet Ramey
       <u>The</u> <u>Gnu</u> <u>History</u> <u>Library</u>, Brian Fox and Chet Ramey
       <u><a href="../man1/bash.1.html">bash</a></u>(1)
       <u><a href="../man3/readline.3.html">readline</a></u>(3)

</pre><h4><b>AUTHORS</b></h4><pre>
       Brian Fox, Free Software Foundation
       <a href="mailto:bfox@gnu.org">bfox@gnu.org</a>

       Chet Ramey, Case Western Reserve University
       <a href="mailto:chet.ramey@case.edu">chet.ramey@case.edu</a>

</pre><h4><b>BUG</b> <b>REPORTS</b></h4><pre>
       If you find a bug in the <b>history</b> library, you should report it.  But first, you should make sure that  it
       really is a bug, and that it appears in the latest version of the <b>history</b> library that you have.

       Once  you  have determined that a bug actually exists, mail a bug report to <u>bug-readline</u>@<u>gnu.org</u>.  If you
       have a fix, you are welcome to mail that as well!  Suggestions and “philosophical”  bug  reports  may  be
       mailed to <u>bug-readline</u>@<u>gnu.org</u> or posted to the Usenet newsgroup <b>gnu.bash.bug</b>.

       Comments and bug reports concerning this manual page should be directed to <u><a href="mailto:chet.ramey@case.edu">chet.ramey@case.edu</a></u>.

GNU History 8.3                                 2024 December 31                                      <u><a href="../man3/HISTORY.3.html">HISTORY</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>