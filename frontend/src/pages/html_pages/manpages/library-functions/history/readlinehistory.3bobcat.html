<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::ReadLineHistory - std::streambuf offering line-editing and history</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::ReadLineHistory - std::streambuf offering line-editing and history

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/readlinebuf&gt;</b>
       Linking option: -lbobcat -lreadline

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>FBB::ReadLineHistory</b>  object  offers  access  to  the  history  maintained  by  <b>FBB::ReadLineBuf</b> and
       <b>ReadLineStream</b> objects.

       The latter two classes use Gnu’s readline library to  allow  editing  of  input  lines.  The  accumulated
       history of these objects can be accessed from the <b>ReadLineHistory</b> object.

       Since  Gnu’s  readline  library  maintains global data there can only be one history. The <b>ReadLineHistory</b>
       class is therefore, like <b>ReadLineBuf</b> a singleton.  (Gnu’s readline library does, however, offer functions
       allowing programs to use  multiple  histories.  So  it  would  in  principle  be  possible  to  design  a
       non-singleton  <u>ReadLineHistory</u> class. Since programs normally only interact with a single terminal, there
       is probably little use for non-singleton <b>ReadLineHistory</b> class).

       The <b>ReadLineHistory</b> class encapsulates history access. It offers limited facilities:  either  forward  or
       backward  iterations  over  the  history  are  offered as well as reading and writing the history from/to
       streams. When reading the history from a stream it  replaces  the  currently  available  lines  in  Gnu’s
       readline  history. The content of the history lines and --if defined-- the timestamps of the lines in the
       history can be obtained using iterators defined by <b>ReadLineHistory</b>.

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All constructors, members, operators and manipulators, mentioned in this man-page,  are  defined  in  the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       -

</pre><h4><b>NESTED</b> <b>TYPES</b></h4><pre>
       The class <b>ReadLineHistory</b> defines the following nested types:

       <b>HistoryElement</b>

       The  iterators  made  available  by the <b>ReadLineHistory</b> object provide access to a <b>HistoryElement</b> object.
       These objects can be copied and assigned to each other, but  user  programs  cannot  otherwise  construct
       <b>HistoryElement</b> objects.

       The class <b>HistoryElement</b> has but two members:

       o      <u>char</u>  <u>const</u>  <u>*line()</u>  <u>const</u>  returns  the  content  of the history line to which a <b>ReadLineHistory</b>
              iterator refers;

       o      <u>char</u> <u>const</u> <u>*timestamp()</u> <u>const</u> returns the timestamp (if defined) of the history line  to  which  a
              <b>ReadLineHistory</b> iterator refers;

       <b>const_iterator</b> and <b>const_reverse_iterator</b>

       The  iterators  returned  by  members  of  the  class  <b>ReadLineHistory</b>  are  input iterators, pointing to
       <b>HistoryElement</b> objects. As they are input iterators modification of the history elements  to  which  they
       refer is not allowed.

       The  class  <b>const_iterator</b>  allows  iterations  from  the  first  to  the last history element, the class
       <b>const_reverse_iterator</b> allows iterations from the last back to the first history element.

       The iterators can be incremented, compared for (in)equality and offer <u>operator*</u> and  <u>operator-&gt;</u>  members,
       offering access to, respectively, <b>HistoryElement</b> objects and their addresses.

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
       As  the class <b>ReadLineHistory</b> is a singleton class, there are no publicly available constructors, nor are
       assignment operators available.

</pre><h4><b>STATIC</b> <b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       o      <b>ReadLineHistory</b> <b>&amp;instance()</b>:
              A reference to the <b>ReadLineHistory</b> object is returned. If any history has been accumulated it  can
              immediately  be  retrieved.  Using  this static member will not affect the way the <b>ReadLineHistory</b>
              object handles timestamps when saving or retrieving history lines. When initially constructed  the
              <u>ReadLineHistory</u> object assumes that timestamps are not used.

       o      <b>ReadLineHistory</b> <b>&amp;instance(bool</b> <b>useTimestamps)</b>:
              A  reference to the <b>ReadLineHistory</b> object is returned. If any history has been accumulated it can
              immediately be retrieved. The <u>useTimestamps</u> parameter defines the way history lines are read  from
              or  written  to  a  stream.  When  specifying <u>true</u> the history inserted into a stream will include
              timestamps (which may be empty if no timestamps were  recorded).  Likewise,  when  extracting  the
              history  timestamps  are  extracted  too  (which  may  also  be  empty).  When specifying <u>false</u> no
              timestamps are read or written. A mismatch between the actual content of the stream from which the
              history is extracted and the <u>useTimestamps</u> parameter will results in unexpected behavior.

</pre><h4><b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       o      <b>ReadLineHistory::const_iterator</b> <b>begin()</b> <b>const</b>:
              An input iterator pointing to the first history line is returned.

       o      <b>ReadLineHistory::const_iterator</b> <b>end()</b> <b>const</b>:
              An input iterator pointing beyond the last history line is returned.

       o      <b>size_t</b> <b>maxSize()</b> <b>const</b>:
              The maximum number of lines that can be stored in the history  is  returned.  After  collecting  a
              history  of <u>maxSize</u> lines, the next line entered will cause the initial history line to be removed
              from the history, making room for the next line to be added at the end of the history.

       o      <b>ReadLineHistory::const_reverse_iterator</b> <b>rbegin()</b> <b>const</b>:
              An input iterator pointing to the last history line is returned. Incrementing this  iterator  will
              access the previous line in the history.

       o      <b>ReadLineHistory::const_reverse_iterator</b> <b>rend()</b> <b>const</b>:
              An input iterator pointing before the first history line is returned.

       o      <b>ReadLineHistory</b> <b>&amp;setTimestamps(bool</b> <b>useTimestamps)</b>:
              xThe  current  status of the timestamps usage is set according to the value of its parameter. When
              <u>true</u> inserting and extracting history will include the timestamps. No timestamps are  inserted  or
              extracted  when  <u>false</u>.  It  returns  a  reference to the updated <b>ReadLineHistory</b> object, allowing
              constructions like (assuming the availability of <u>ReadLineHistory</u> <u>&amp;history</u>):

                  cout &lt;&lt; history.setTimestamps(true);

       o      <b>size_t</b> <b>size()</b> <b>const</b>:
              The number of lines currently stored in the history is returned.

       o      <b>bool</b> <b>timestamps()</b> <b>const</b>:
              The current status of the  timestamps  usage  is  returned.  When  returning  <u>true</u>  inserting  and
              extracting  history will include the timestamps. No timestamps are inserted or extracted when this
              member returns <u>false</u>

</pre><h4><b>OVERLOADED</b> <b>OPERATORS</b></h4><pre>
       o      <b>std::istream</b> <b>&amp;operator&gt;&gt;(std::istream</b> <b>&amp;in,</b> <b>ReadLineHistory</b> <b>&amp;his)</b>:
              The history available at the <u>in</u> stream is extracted to become the current history,  replacing  the
              existing  (Gnu  readline)  history by the history read from <u>in</u>. The <u>useTimestamp</u> status determines
              whether timestams are extracted (if <u>true</u>) or not (if <u>false</u>). If extracting  the  history  from  <u>in</u>
              fails an exception is thrown.

       o      <b>std::ostream</b> <b>&amp;operator&lt;&lt;(std::ostream</b> <b>&amp;out,</b> <b>ReadLineHistory</b> <b>&amp;his)</b>:
              The  current  history  is  written  to  the <u>out</u> stream. The <u>useTimestamp</u> status determines whether
              timestams are inserted (if <u>true</u>) or not (if <u>false</u>).

</pre><h4><b>EXAMPLE</b></h4><pre>
       #include &lt;iostream&gt;
       #include &lt;algorithm&gt;
       #include &lt;fstream&gt;

       #include &lt;bobcat/datetime&gt;
       #include &lt;bobcat/readlinestream&gt;
       #include &lt;bobcat/readlinehistory&gt;

       using namespace std;
       using namespace FBB;

       void showHis(ReadLineHistory::HistoryElement const &amp;element)
       {
           cout &lt;&lt; element.timestamp() &lt;&lt; " " &lt;&lt; element.line() &lt;&lt; ’\n’;
       }

       string timestamp()
       {
           return DateTime().rfc2822();
       };

       int main(int argc, char **argv)
       {
           ReadLineStream in("? ", ReadLineBuf::EXPAND_HISTORY);
           in.useTimestamps(&amp;timestamp);

           cout &lt;&lt; "Enter some lines, end the input using ctrl-d\n";
           string line;
           while (getline(in, line))
               ;
                                                   // argument means: write/read
                                                   // history timestamps
           ReadLineHistory &amp;history = ReadLineHistory::instance(argc &gt; 1);

           cout &lt;&lt; "All lines, from the first to the last:\n";
           for_each(history.begin(), history.end(), showHis);

           cout &lt;&lt; "\n"
                   "Again: all lines, from the first to the last:\n";
           for_each(history.begin(), history.end(), showHis);

           cout &lt;&lt; "\n"
                   "All lines, from the last to the first:\n";
           for_each(history.rbegin(), history.rend(), showHis);

           cout &lt;&lt; "\n"
                   "History out and in:\n"
                   "\n";

           ofstream hisout("history.out");

           hisout &lt;&lt; history;

           hisout.close();

           ifstream hisin("history.out");
           hisin &gt;&gt; history;

           cout &lt;&lt; "All lines, from the first to the last:\n";
           for_each(history.begin(), history.end(), showHis);

           cout &lt;&lt; "\n"
                   "All lines, from the last to the first:\n";
           for_each(history.rbegin(), history.rend(), showHis);

       }

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/readlinehistory</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7), <b><a href="../man3/readline.3.html">readline</a></b>(3), <b><a href="../man3bobcat/readlinebuf.3bobcat.html">readlinebuf</a></b>(3bobcat), <b><a href="../man3bobcat/readlinestream.3bobcat.html">readlinestream</a></b>(3bobcat)

</pre><h4><b>BUGS</b></h4><pre>
       None Reported.

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>: debian package containing the static library, headers, manual pages, and  developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                      <u>FBB::<a href="../man3bobcat/ReadLineHistory.3bobcat.html">ReadLineHistory</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>