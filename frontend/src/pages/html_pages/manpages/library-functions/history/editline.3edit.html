<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>editline, el_init, el_init_fd, el_end, el_reset, el_gets, el_wgets, el_getc, el_wgetc, el_push, el_wpush,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libedit-dev">libedit-dev_3.1-20250104-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       editline, el_init, el_init_fd, el_end, el_reset, el_gets, el_wgets, el_getc, el_wgetc, el_push, el_wpush,
       el_parse,  el_wparse,  el_set,  el_wset,  el_get,  el_wget,  el_source,  el_resize,  el_cursor,  el_line,
       el_wline,  el_insertstr,  el_winsertstr,  el_deletestr,   el_wdeletestr,   history_init,   history_winit,
       history_end,  history_wend,  history,  history_w,  tok_init,  tok_winit,  tok_end,  tok_wend,  tok_reset,
       tok_wreset, tok_line, tok_wline, tok_str, tok_wstr — line editor, history and tokenization functions

</pre><h4><b>LIBRARY</b></h4><pre>
       Command Line Editor Library (libedit, -ledit)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;histedit.h&gt;</b>

       <u>EditLine</u> <u>*</u>
       <b>el_init</b>(<u>const</u> <u>char</u> <u>*prog</u>, <u>FILE</u> <u>*fin</u>, <u>FILE</u> <u>*fout</u>, <u>FILE</u> <u>*ferr</u>);

       <u>EditLine</u> <u>*</u>
       <b>el_init_fd</b>(<u>const</u> <u>char</u> <u>*prog</u>, <u>FILE</u> <u>*fin</u>, <u>FILE</u> <u>*fout</u>, <u>FILE</u> <u>*ferr</u>, <u>int</u> <u>fdin</u>, <u>int</u> <u>fdout</u>, <u>int</u> <u>fderr</u>);

       <u>void</u>
       <b>el_end</b>(<u>EditLine</u> <u>*e</u>);

       <u>void</u>
       <b>el_reset</b>(<u>EditLine</u> <u>*e</u>);

       <u>const</u> <u>char</u> <u>*</u>
       <b>el_gets</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>*count</u>);

       <u>const</u> <u>wchar_t</u> <u>*</u>
       <b>el_wgets</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>*count</u>);

       <u>int</u>
       <b>el_getc</b>(<u>EditLine</u> <u>*e</u>, <u>char</u> <u>*ch</u>);

       <u>int</u>
       <b>el_wgetc</b>(<u>EditLine</u> <u>*e</u>, <u>wchar_t</u> <u>*wc</u>);

       <u>void</u>
       <b>el_push</b>(<u>EditLine</u> <u>*e</u>, <u>const</u> <u>char</u> <u>*mbs</u>);

       <u>void</u>
       <b>el_wpush</b>(<u>EditLine</u> <u>*e</u>, <u>const</u> <u>wchar_t</u> <u>*wcs</u>);

       <u>int</u>
       <b>el_parse</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>argc</u>, <u>const</u> <u>char</u> <u>*argv[]</u>);

       <u>int</u>
       <b>el_wparse</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>argc</u>, <u>const</u> <u>wchar_t</u> <u>*argv[]</u>);

       <u>int</u>
       <b>el_set</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>op</u>, <u>...</u>);

       <u>int</u>
       <b>el_wset</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>op</u>, <u>...</u>);

       <u>int</u>
       <b>el_get</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>op</u>, <u>...</u>);

       <u>int</u>
       <b>el_wget</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>op</u>, <u>...</u>);

       <u>int</u>
       <b>el_source</b>(<u>EditLine</u> <u>*e</u>, <u>const</u> <u>char</u> <u>*file</u>);

       <u>void</u>
       <b>el_resize</b>(<u>EditLine</u> <u>*e</u>);

       <u>int</u>
       <b>el_cursor</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>count</u>);

       <u>const</u> <u>LineInfo</u> <u>*</u>
       <b>el_line</b>(<u>EditLine</u> <u>*e</u>);

       <u>const</u> <u>LineInfoW</u> <u>*</u>
       <b>el_wline</b>(<u>EditLine</u> <u>*e</u>);

       <u>int</u>
       <b>el_insertstr</b>(<u>EditLine</u> <u>*e</u>, <u>const</u> <u>char</u> <u>*str</u>);

       <u>int</u>
       <b>el_winsertstr</b>(<u>EditLine</u> <u>*e</u>, <u>const</u> <u>wchar_t</u> <u>*str</u>);

       <u>void</u>
       <b>el_deletestr</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>count</u>);

       <u>void</u>
       <b>el_wdeletestr</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>count</u>);

       <u>History</u> <u>*</u>
       <b>history_init</b>(<u>void</u>);

       <u>HistoryW</u> <u>*</u>
       <b>history_winit</b>(<u>void</u>);

       <u>void</u>
       <b>history_end</b>(<u>History</u> <u>*h</u>);

       <u>void</u>
       <b>history_wend</b>(<u>HistoryW</u> <u>*h</u>);

       <u>int</u>
       <b>history</b>(<u>History</u> <u>*h</u>, <u>HistEvent</u> <u>*ev</u>, <u>int</u> <u>op</u>, <u>...</u>);

       <u>int</u>
       <b>history_w</b>(<u>HistoryW</u> <u>*h</u>, <u>HistEventW</u> <u>*ev</u>, <u>int</u> <u>op</u>, <u>...</u>);

       <u>Tokenizer</u> <u>*</u>
       <b>tok_init</b>(<u>const</u> <u>char</u> <u>*IFS</u>);

       <u>TokenizerW</u> <u>*</u>
       <b>tok_winit</b>(<u>const</u> <u>wchar_t</u> <u>*IFS</u>);

       <u>void</u>
       <b>tok_end</b>(<u>Tokenizer</u> <u>*t</u>);

       <u>void</u>
       <b>tok_wend</b>(<u>TokenizerW</u> <u>*t</u>);

       <u>void</u>
       <b>tok_reset</b>(<u>Tokenizer</u> <u>*t</u>);

       <u>void</u>
       <b>tok_wreset</b>(<u>TokenizerW</u> <u>*t</u>);

       <u>int</u>
       <b>tok_line</b>(<u>Tokenizer</u> <u>*t</u>, <u>const</u> <u>LineInfo</u> <u>*li</u>, <u>int</u> <u>*argc</u>, <u>const</u> <u>char</u> <u>**argv[]</u>, <u>int</u> <u>*cursorc</u>, <u>int</u> <u>*cursoro</u>);

       <u>int</u>
       <b>tok_wline</b>(<u>TokenizerW</u>  <u>*t</u>,  <u>const</u>  <u>LineInfoW</u>  <u>*li</u>,  <u>int</u>  <u>*argc</u>,  <u>const</u>  <u>wchar_t</u>  <u>**argv[]</u>,  <u>int</u>  <u>*cursorc</u>,
           <u>int</u> <u>*cursoro</u>);

       <u>int</u>
       <b>tok_str</b>(<u>Tokenizer</u> <u>*t</u>, <u>const</u> <u>char</u> <u>*str</u>, <u>int</u> <u>*argc</u>, <u>const</u> <u>char</u> <u>**argv[]</u>);

       <u>int</u>
       <b>tok_wstr</b>(<u>TokenizerW</u> <u>*t</u>, <u>const</u> <u>wchar_t</u> <u>*str</u>, <u>int</u> <u>*argc</u>, <u>const</u> <u>wchar_t</u> <u>**argv[]</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>editline</b> library provides generic line editing, history and tokenization functions, similar to those
       found in <u><a href="../man1/sh.1.html">sh</a></u>(1).

       These functions are available in the <b>libedit</b> library (which  needs  the  <b>libtermcap</b>  library).   Programs
       should be linked with <b>-ledit</b> <b>-ltermcap</b>.

       The  <b>editline</b>  library  respects  the  LC_CTYPE  locale  set  by  the  application program and never uses
       <u><a href="../man3/setlocale.3.html">setlocale</a></u>(3) to change the locale.

</pre><h4><b>LINE</b> <b>EDITING</b> <b>FUNCTIONS</b></h4><pre>
       The line editing functions use a common data structure,  <u>EditLine</u>,  which  is  created  by  <b>el_init</b>()  or
       <b>el_init_fd</b>() and freed by <b>el_end</b>().

       The wide-character functions behave the same way as their narrow counterparts.

       The following functions are available:

       <b>el_init</b>()
             Initialize  the  line  editor,  and  return  a  data structure to be used by all other line editing
             functions, or NULL on failure.  <u>prog</u> is the name of the invoking program,  used  when  reading  the
             <u><a href="../man5/editrc.5.html">editrc</a></u>(5)  file  to determine which settings to use.  <u>fin</u>, <u>fout</u> and <u>ferr</u> are the input, output, and
             error streams (respectively) to use.  In this documentation, references to “the tty”  are  actually
             to this input/output stream combination.

       <b>el_init_fd</b>()
             Like  <b>el_init</b>()  but  allows specifying file descriptors for the <u><a href="../man3/stdio.3.html">stdio</a></u>(3) corresponding streams, in
             case those were created with <u><a href="../man3/funopen.3.html">funopen</a></u>(3).

       <b>el_end</b>()
             Clean up and finish with <u>e</u>, assumed to have been created with <b>el_init</b>() or <b>el_init_fd</b>().

       <b>el_reset</b>()
             Reset the tty and the parser.  This should be called after an error which may have upset the  tty's
             state.

       <b>el_gets</b>()
             Read a line from the tty.  <u>count</u> is modified to contain the number of characters read.  Returns the
             line  read  if successful, or NULL if no characters were read or if an error occurred.  If an error
             occurred, <u>count</u> is set to -1 and errno contains the error code that caused it.   The  return  value
             may not remain valid across calls to <b>el_gets</b>() and must be copied if the data is to be retained.

       <b>el_wgetc</b>()
             Read  a  wide  character  from  the  tty,  respecting  the  current locale, or from the input queue
             described in <u><a href="../man7/editline.7.html">editline</a></u>(7) if that is not empty, and store it in <u>wc</u>.  If  an  invalid  or  incomplete
             character  is  found,  it  is discarded, <u>errno</u> is set to EILSEQ, and the next character is read and
             stored in <u>wc</u>.  Returns 1 if a valid character was read, 0 on end of file, or -1 on <u><a href="../man2/read.2.html">read</a></u>(2) failure.
             In the latter case, <u>errno</u> is set to indicate the error.

       <b>el_getc</b>()
             Read a wide character as described for <b>el_wgetc</b>() and return 0 on end of file or -1 on failure.  If
             the wide character can be represented as a single-byte character, convert it with  <u><a href="../man3/wctob.3.html">wctob</a></u>(3),  store
             the  result  in  <u>ch</u>, and return 1; otherwise, set <u>errno</u> to ERANGE and return -1.  In the C or POSIX
             locale, this simply reads a byte, but for any other locale, including UTF-8, this is rarely useful.

       <b>el_wpush</b>()
             Push the wide character string <u>wcs</u> back onto the input queue  described  in  <u><a href="../man7/editline.7.html">editline</a></u>(7).   If  the
             queue  overflows,  for example due to a recursive macro, or if an error occurs, for example because
             <u>wcs</u> is NULL or memory allocation fails, the function beeps at the user, but  does  not  report  the
             problem to the caller.

       <b>el_push</b>()
             Use the current locale to convert the multibyte string <u>mbs</u> to a wide character string, and pass the
             result to <b>el_wpush</b>().

       <b>el_parse</b>()
             Parses  the  <u>argv</u>  array (which is <u>argc</u> elements in size) to execute builtin <b>editline</b> commands.  If
             the command is prefixed with “prog”: then <b>el_parse</b>()  will  only  execute  the  command  if  “prog”
             matches the <u>prog</u> argument supplied to <b>el_init</b>().  The return value is -1 if the command is unknown,
             0  if  there  was no error or “prog” didn't match, or 1 if the command returned an error.  Refer to
             <u><a href="../man5/editrc.5.html">editrc</a></u>(5) for more information.

       <b>el_set</b>()
             Set <b>editline</b> parameters.  <u>op</u> determines which parameter to set, and  each  operation  has  its  own
             parameter list.  Returns 0 on success, -1 on failure.

             The following values for <u>op</u> are supported, along with the required argument list:

             EL_PROMPT, <u>char</u> <u>*(*f)(EditLine</u> <u>*)</u>
                   Define prompt printing function as <u>f</u>, which is to return a string that contains the prompt.

             EL_PROMPT_ESC, <u>char</u> <u>*(*f)(EditLine</u> <u>*)</u>, <u>char</u> <u>c</u>
                   Same as EL_PROMPT, but the <u>c</u> argument indicates the start/stop literal prompt character.

                   If  a  start/stop  literal  character  is  found  in  the prompt, the character itself is not
                   printed, but characters after it are printed directly to the terminal without  affecting  the
                   state  of  the  current  line.   A  subsequent  second start/stop literal character ends this
                   behavior.  This is  typically  used  to  embed  literal  escape  sequences  that  change  the
                   color/style  of the terminal in the prompt.  Note that the literal escape character cannot be
                   the last character in the prompt, as the escape sequence is attached to the next character in
                   the prompt.  0 unsets it.

             EL_REFRESH
                   Re-display the current line on the next terminal line.

             EL_RPROMPT, <u>char</u> <u>*(*f)(EditLine</u> <u>*)</u>
                   Define right side prompt printing function as <u>f</u>, which is to return a  string  that  contains
                   the prompt.

             EL_RPROMPT_ESC, <u>char</u> <u>*(*f)(EditLine</u> <u>*)</u>, <u>char</u> <u>c</u>
                   Define the right prompt printing function but with a literal escape character.

             EL_TERMINAL, <u>const</u> <u>char</u> <u>*type</u>
                   Define terminal type of the tty to be <u>type</u>, or to TERM if <u>type</u> is NULL.

             EL_EDITOR, <u>const</u> <u>char</u> <u>*mode</u>
                   Set editing mode to <u>mode</u>, which must be one of “emacs” or “vi”.

             EL_SIGNAL, <u>int</u> <u>flag</u>
                   If  <u>flag</u>  is non-zero, <b>editline</b> will install its own signal handler for the following signals
                   when reading command input: SIGCONT, SIGHUP, SIGINT, SIGQUIT, SIGSTOP, SIGTERM, SIGTSTP,  and
                   SIGWINCH.  Otherwise, the current signal handlers will be used.

             EL_BIND, <u>const</u> <u>char</u> <u>*</u>, <u>...</u>, NULL
                   Perform the <b>bind</b> builtin command.  Refer to <u><a href="../man5/editrc.5.html">editrc</a></u>(5) for more information.

             EL_ECHOTC, <u>const</u> <u>char</u> <u>*</u>, <u>...</u>, NULL
                   Perform the <b>echotc</b> builtin command.  Refer to <u><a href="../man5/editrc.5.html">editrc</a></u>(5) for more information.

             EL_SETTC, <u>const</u> <u>char</u> <u>*</u>, <u>...</u>, NULL
                   Perform the <b>settc</b> builtin command.  Refer to <u><a href="../man5/editrc.5.html">editrc</a></u>(5) for more information.

             EL_SETTY, <u>const</u> <u>char</u> <u>*</u>, <u>...</u>, NULL
                   Perform the <b>setty</b> builtin command.  Refer to <u><a href="../man5/editrc.5.html">editrc</a></u>(5) for more information.

             EL_TELLTC, <u>const</u> <u>char</u> <u>*</u>, <u>...</u>, NULL
                   Perform the <b>telltc</b> builtin command.  Refer to <u><a href="../man5/editrc.5.html">editrc</a></u>(5) for more information.

             EL_ADDFN, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>char</u> <u>*help</u>, <u>unsigned</u> <u>char</u> <u>(*func)(EditLine</u> <u>*e,</u> <u>int</u> <u>ch)</u>
                   Add a user defined function, <b>func</b>(), referred to as <u>name</u> which is invoked when a key which is
                   bound  to <u>name</u> is entered.  <u>help</u> is a description of <u>name</u>.  At invocation time, <u>ch</u> is the key
                   which caused the invocation.  The return value of <b>func</b>() should be one of:

                   CC_NORM       Add a normal character.

                   CC_NEWLINE    End of line was entered.

                   CC_EOF        EOF was entered.

                   CC_ARGHACK    Expecting further command input as arguments, do nothing visually.

                   CC_REFRESH    Refresh display.

                   CC_REFRESH_BEEP
                                 Refresh display, and beep.

                   CC_CURSOR     Cursor moved, so update and perform CC_REFRESH.

                   CC_REDISPLAY  Redisplay entire input line.  This is useful if a  key  binding  outputs  extra
                                 information.

                   CC_ERROR      An error occurred.  Beep, and flush tty.

                   CC_FATAL      Fatal error, reset tty to known state.

             EL_HIST, <u>History</u> <u>*(*func)(History</u> <u>*,</u> <u>int</u> <u>op,</u> <u>...)</u>, <u>const</u> <u>char</u> <u>*ptr</u>
                   Defines  which  history function to use, which is usually <b>history</b>().  <u>ptr</u> should be the value
                   returned by <b>history_init</b>().

             EL_EDITMODE, <u>int</u> <u>flag</u>
                   If <u>flag</u> is non-zero, editing is enabled (the default).  Note that this is only an indication,
                   and does  not  affect  the  operation  of  <b>editline</b>.   At  this  time,  it  is  the  caller's
                   responsibility  to  check  this (using <b>el_get</b>()) to determine if editing should be enabled or
                   not.

             EL_UNBUFFERED, <u>int</u> <u>flag</u>
                   If <u>flag</u> is zero, unbuffered mode is disabled (the default).  In  unbuffered  mode,  <b>el_gets</b>()
                   will return immediately after processing a single character.

             EL_SAFEREAD, <u>int</u> <u>flag</u>
                   If  the  <u>flag</u>  argument  is  non-zero,  then  <b>editline</b>  attempts to recover from read errors,
                   ignoring the first interrupted error, and trying to reset the input file descriptor to  reset
                   non-blocking  I/O.   This is disabled by default, and desirable only when <b>editline</b> is used in
                   shell-like applications.

             EL_GETCFN, <u>el_rfunc_t</u> <u>f</u>
                   Whenever reading a character, use the function
                         <u>int</u> <b>f</b>(<u>EditLine</u> <u>*e</u>, <u>wchar_t</u> <u>*wc</u>)
                   which stores the character in <u>wc</u> and returns 1 on success, 0 on end of file, or -1 on I/O  or
                   encoding  errors.   Functions  internally using it include <b>el_wgets</b>(), <b>el_wgetc</b>(), <b>el_gets</b>(),
                   and <b>el_getc</b>().  Initially, a builtin function is installed, and replacing it  is  discouraged
                   because writing such a function is very error prone.  The builtin function can be restored at
                   any time by passing the special value EL_BUILTIN_GETCFN instead of a function pointer.

             EL_CLIENTDATA, <u>void</u> <u>*data</u>
                   Register  <u>data</u>  to  be associated with this EditLine structure.  It can be retrieved with the
                   corresponding <b>el_get</b>() call.

             EL_SETFP, <u>int</u> <u>fd</u>, <u>FILE</u> <u>*fp</u>
                   Set the current <b>editline</b> file pointer for “input” <u>fd</u> = 0, “output” <u>fd</u> = 1, or “error” <u>fd</u> =  2
                   from <u>fp</u>.

       <b>el_get</b>()
             Get  <b>editline</b>  parameters.   <u>op</u>  determines  which parameter to retrieve into <u>result</u>.  Returns 0 if
             successful, -1 otherwise.

             The following values for <u>op</u> are supported, along with actual type of <u>result</u>:

             EL_PROMPT, <u>char</u> <u>*(*f)(EditLine</u> <u>*)</u>, <u>char</u> <u>*c</u>
                   Set <u>f</u> to a pointer to the function that displays the prompt.  If <u>c</u> is not NULL, set it to the
                   start/stop literal prompt character.

             EL_RPROMPT, <u>char</u> <u>*(*f)(EditLine</u> <u>*)</u>, <u>char</u> <u>*c</u>
                   Set <u>f</u> to a pointer to the function that displays the prompt.  If <u>c</u> is not NULL, set it to the
                   start/stop literal prompt character.

             EL_EDITOR, <u>const</u> <u>char</u> <u>**n</u>
                   Set the name of the editor in <u>n</u>, which will be one of “emacs” or “vi”.

             EL_GETTC, <u>const</u> <u>char</u> <u>*name</u>, <u>void</u> <u>*value</u>
                   If <u>name</u> is a valid <u><a href="../man5/termcap.5.html">termcap</a></u>(5) capability set <u>value</u> to the current value of that capability.

             EL_SIGNAL, <u>int</u> <u>*s</u>
                   Set <u>s</u> to non-zero if <b>editline</b> has installed private signal handlers (see <b>el_get</b>() above).

             EL_EDITMODE, <u>int</u> <u>*c</u>
                   Set <u>c</u> to non-zero if editing is enabled.

             EL_GETCFN, <u>el_rfunc_t</u> <u>*f</u>
                   Set <u>f</u> to a pointer to the function that reads characters,  or  to  EL_BUILTIN_GETCFN  if  the
                   builtin function is in use.

             EL_CLIENTDATA, <u>void</u> <u>**data</u>
                   Set <u>data</u> to the previously registered client data set by an <b>el_set</b>() call.

             EL_UNBUFFERED, <u>int</u> <u>*c</u>
                   Set <u>c</u> to non-zero if unbuffered mode is enabled.

             EL_SAFEREAD, <u>int</u> <u>*c</u>
                   Set <u>c</u> to non-zero if safe read is set.

             EL_GETFP, <u>int</u> <u>fd</u>, <u>FILE</u> <u>**fp</u>
                   Set  <u>fp</u>  to the current <b>editline</b> file pointer for “input” <u>fd</u> = 0, “output” <u>fd</u> = 1, or “error”
                   <u>fd</u> = 2.

       <b>el_source</b>()
             Initialize <b>editline</b> by reading the contents of <u>file</u>.  <b>el_parse</b>() is called for each line  in  <u>file</u>.
             If  <u>file</u> is NULL, try <u>$EDITRC</u> and if that is not set <u>$HOME/.editrc</u>.  Refer to <u><a href="../man5/editrc.5.html">editrc</a></u>(5) for details
             on the format of <u>file</u>.  <b>el_source</b>() returns 0 on success and -1 on error.

       <b>el_resize</b>()
             Must be called if the terminal size changes.  If EL_SIGNAL has been set with <b>el_set</b>(), then this is
             done automatically.  Otherwise, it's the responsibility of the application to call  <b>el_resize</b>()  on
             the appropriate occasions.

       <b>el_cursor</b>()
             Move  the cursor to the right (if positive) or to the left (if negative) <u>count</u> characters.  Returns
             the resulting offset of the cursor from the beginning of the line.

       <b>el_line</b>()
             Return the editing information for the current line in a <u>LineInfo</u> structure, which  is  defined  as
             follows:

             typedef struct lineinfo {
                 const char *buffer;    /* address of buffer */
                 const char *cursor;    /* address of cursor */
                 const char *lastchar;  /* address of last character */
             } LineInfo;

             <u>buffer</u>  is  not NUL terminated.  This function may be called after <b>el_gets</b>() to obtain the <u>LineInfo</u>
             structure pertaining to line returned by that function, and  from  within  user  defined  functions
             added with EL_ADDFN.

       <b>el_insertstr</b>()
             Insert <u>str</u> into the line at the cursor.  Returns -1 if <u>str</u> is empty or won't fit, and 0 otherwise.

       <b>el_deletestr</b>()
             Delete <u>count</u> characters before the cursor.

</pre><h4><b>HISTORY</b> <b>LIST</b> <b>FUNCTIONS</b></h4><pre>
       The  history functions use a common data structure, <u>History</u>, which is created by <b>history_init</b>() and freed
       by <b>history_end</b>().

       The following functions are available:

       <b>history_init</b>()
             Initialize the history list, and return a data structure to be  used  by  all  other  history  list
             functions, or NULL on failure.

       <b>history_end</b>()
             Clean up and finish with <u>h</u>, assumed to have been created with <b>history_init</b>().

       <b>history</b>()
             Perform  operation  <u>op</u> on the history list, with optional arguments as needed by the operation.  <u>ev</u>
             is changed accordingly to operation.  The following values for <u>op</u> are  supported,  along  with  the
             required argument list:

             H_SETSIZE, <u>int</u> <u>size</u>
                   Set size of history to <u>size</u> elements.

             H_GETSIZE
                   Get number of events currently in history.

             H_END
                   Cleans up and finishes with <u>h</u>, assumed to be created with <b>history_init</b>().

             H_CLEAR
                   Clear the history.

             H_FUNC,  <u>void</u>  <u>*ptr</u>, <u>history_gfun_t</u> <u>first</u>, <u>history_gfun_t</u> <u>next</u>, <u>history_gfun_t</u> <u>last</u>, <u>history_gfun_t</u>
                   <u>prev</u>, <u>history_gfun_t</u> <u>curr</u>, <u>history_sfun_t</u> <u>set</u>, <u>history_vfun_t</u>  <u>clear</u>,  <u>history_efun_t</u>  <u>enter</u>,
                   <u>history_efun_t</u> <u>add</u>
                   Define  functions  to  perform  various  history  operations.  <u>ptr</u> is the argument given to a
                   function when it's invoked.

             H_FIRST
                   Return the first element in the history.

             H_LAST
                   Return the last element in the history.

             H_PREV
                   Return the previous element in the history.  It is newer than the current one.

             H_NEXT
                   Return the next element in the history.  It is older than the current one.

             H_CURR
                   Return the current element in the history.

             H_SET, <u>int</u> <u>position</u>
                   Set the cursor to point to the requested element.

             H_ADD, <u>const</u> <u>char</u> <u>*str</u>
                   Append <u>str</u> to the current element of the history,  or  perform  the  H_ENTER  operation  with
                   argument <u>str</u> if there is no current element.

             H_APPEND, <u>const</u> <u>char</u> <u>*str</u>
                   Append <u>str</u> to the last new element of the history.

             H_ENTER, <u>const</u> <u>char</u> <u>*str</u>
                   Add  <u>str</u> as a new element to the history and, if necessary, removing the oldest entry to keep
                   the list to the created size.  If H_SETUNIQUE has been called with a non-zero  argument,  the
                   element  will  not  be entered into the history if its contents match the ones of the current
                   history element.  If the element is entered <b>history</b>() returns  1;  if  it  is  ignored  as  a
                   duplicate returns 0.  Finally <b>history</b>() returns -1 if an error occurred.

             H_PREV_STR, <u>const</u> <u>char</u> <u>*str</u>
                   Return the closest previous event that starts with <u>str</u>.

             H_NEXT_STR, <u>const</u> <u>char</u> <u>*str</u>
                   Return the closest next event that starts with <u>str</u>.

             H_PREV_EVENT, <u>int</u> <u>e</u>
                   Return the previous event numbered <u>e</u>.

             H_NEXT_EVENT, <u>int</u> <u>e</u>
                   Return the next event numbered <u>e</u>.

             H_LOAD, <u>const</u> <u>char</u> <u>*file</u>
                   Load the history list stored in <u>file</u>.

             H_SAVE, <u>const</u> <u>char</u> <u>*file</u>
                   Save the history list to <u>file</u>.

             H_SAVE_FP, <u>FILE</u> <u>*fp</u>
                   Save the history list to the opened <u>FILE</u> pointer <u>fp</u>.

             H_NSAVE_FP, <u>size_t</u> <u>n</u>, <u>FILE</u> <u>*fp</u>
                   Save the last <u>n</u> history entries to the opened <u>FILE</u> pointer <u>fp</u>.

             H_SETUNIQUE, <u>int</u> <u>unique</u>
                   Set flag that adjacent identical event strings should not be entered into the history.

             H_GETUNIQUE
                   Retrieve  the  current  setting  if  adjacent  identical  elements should be entered into the
                   history.

             H_DEL, <u>int</u> <u>e</u>
                   Delete the event numbered <u>e</u>.  This function is only provided for <b>readline</b> compatibility.  The
                   caller is responsible for free'ing the string in the returned <u>HistEvent</u>.

             <b>history</b>() returns &gt;= 0 if the operation <u>op</u> succeeds.  Otherwise, -1 is returned and <u>ev</u>  is  updated
             to contain more details about the error.

</pre><h4><b>TOKENIZATION</b> <b>FUNCTIONS</b></h4><pre>
       The  tokenization  functions  use  a common data structure, <u>Tokenizer</u>, which is created by <b>tok_init</b>() and
       freed by <b>tok_end</b>().

       The following functions are available:

       <b>tok_init</b>()
             Initialize the tokenizer, and return a data structure to be used by all other tokenizer  functions.
             <u>IFS</u> contains the Input Field Separators, which defaults to ⟨space⟩, ⟨tab⟩, and ⟨newline⟩ if NULL.

       <b>tok_end</b>()
             Clean up and finish with <u>t</u>, assumed to have been created with <b>tok_init</b>().

       <b>tok_reset</b>()
             Reset  the  tokenizer  state.   Use  after  a line has been successfully tokenized by <b>tok_line</b>() or
             <b>tok_str</b>() and before a new line is to be tokenized.

       <b>tok_line</b>()
             Tokenize <u>li</u>, If successful, modify: <u>argv</u> to contain the words, <u>argc</u> to contain the number of words,
             <u>cursorc</u> (if not NULL) to contain the index of the word containing the cursor, and <u>cursoro</u>  (if  not
             NULL) to contain the offset within <u>argv[cursorc]</u> of the cursor.

             Returns  0  if  successful,  -1  for  an  internal error, 1 for an unmatched single quote, 2 for an
             unmatched double quote, and 3 for a backslash quoted ⟨newline⟩.  A  positive  exit  code  indicates
             that another line should be read and tokenization attempted again.

       <b>tok_str</b>()
             A simpler form of <b>tok_line</b>(); <u>str</u> is a NUL terminated string to tokenize.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/sh.1.html">sh</a></u>(1), <u><a href="../man3/signal.3.html">signal</a></u>(3), <u><a href="../man3/termcap.3.html">termcap</a></u>(3), <u><a href="../man5edit/editrc.5edit.html">editrc</a></u>(5edit), <u><a href="../man5/termcap.5.html">termcap</a></u>(5), <u><a href="../man7edit/editline.7edit.html">editline</a></u>(7edit)

</pre><h4><b>HISTORY</b></h4><pre>
       The  <b>editline</b>  library  first appeared in 4.4BSD.  CC_REDISPLAY appeared in NetBSD 1.3.  CC_REFRESH_BEEP,
       EL_EDITMODE and the readline emulation appeared in NetBSD 1.4.  EL_RPROMPT appeared in NetBSD 1.5.

</pre><h4><b>AUTHORS</b></h4><pre>
       The <b>editline</b> library was written by Christos Zoulas.  Luke Mewburn  wrote  this  manual  and  implemented
       CC_REDISPLAY,  CC_REFRESH_BEEP,  EL_EDITMODE,  and  EL_RPROMPT.  Jaromir Dolecek implemented the readline
       emulation.  Johny Mattsson implemented wide-character support.

</pre><h4><b>BUGS</b></h4><pre>
       At this time, it is the responsibility of the caller to check the result of the EL_EDITMODE operation  of
       <b>el_get</b>()  (after an <b>el_source</b>() or <b>el_parse</b>()) to determine if <b>editline</b> should be used for further input.
       I.e., EL_EDITMODE is purely an indication of the result of the most recent <u><a href="../man5/editrc.5.html">editrc</a></u>(5) <b>edit</b> command.

Debian                                           August 15, 2021                                 <u><a href="../man3edit/EDITLINE.3edit.html">EDITLINE</a></u>(3edit)
</pre>
 </div>
</div></section>
</div>
</body>
</html>