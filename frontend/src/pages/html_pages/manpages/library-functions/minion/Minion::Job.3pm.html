<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minion::Job - Minion job</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libminion-perl">libminion-perl_10.31+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Minion::Job - Minion job

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package MyApp::Task::Foo;
         use Mojo::Base 'Minion::Job', -signatures;

         sub run ($self, @args) {

           # Magic here! :)
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Minion::Job is a container for Minion jobs.

</pre><h4><b>EVENTS</b></h4><pre>
       Minion::Job inherits all events from Mojo::EventEmitter and can emit the following new ones.

   <b>cleanup</b>
         $job-&gt;on(cleanup =&gt; sub ($job) {
           ...
         });

       Emitted in the process performing this job right before the process will exit.

         $job-&gt;on(cleanup =&gt; sub ($job) {
           $job-&gt;app-&gt;log-&gt;debug("Process $$ is about to exit");
         });

   <b>failed</b>
         $job-&gt;on(failed =&gt; sub ($job, $err) {
           ...
         });

       Emitted in the worker process managing this job or the process performing it, after it has transitioned
       to the "failed" state.

         $job-&gt;on(failed =&gt; sub ($job, $err) {
           say "Something went wrong: $err";
         });

   <b>finish</b>
         $job-&gt;on(finish =&gt; sub ($job) {
           ...
         });

       Emitted in the process performing this job if the task was successful.

         $job-&gt;on(finish =&gt; sub ($job) {
           my $id   = $job-&gt;id;
           my $task = $job-&gt;task;
           $job-&gt;app-&gt;log-&gt;debug(qq{Job "$id" was performed with task "$task"});
         });

   <b>finished</b>
         $job-&gt;on(finished =&gt; sub ($job, $result) {
           ...
         });

       Emitted in the worker process managing this job or the process performing it, after it has transitioned
       to the "finished" state.

         $job-&gt;on(finished =&gt; sub ($job, $result) {
           my $id = $job-&gt;id;
           say "Job $id is finished.";
         });

   <b>reap</b>
         $job-&gt;on(reap =&gt; sub ($job, $pid) {
           ...
         });

       Emitted in the worker process managing this job, after the process performing it has exited.

         $job-&gt;on(reap =&gt; sub ($job, $pid) {
           my $id = $job-&gt;id;
           say "Job $id ran in process $pid";
         });

   <b>spawn</b>
         $job-&gt;on(spawn =&gt; sub ($job, $pid) {
           ...
         });

       Emitted in the worker process managing this job, after a new process has been spawned for processing.

         $job-&gt;on(spawn =&gt; sub ($job, $pid) {
           my $id = $job-&gt;id;
           say "Job $id running in process $pid";
         });

   <b>start</b>
         $job-&gt;on(start =&gt; sub ($job) {
           ...
         });

       Emitted in the process performing this job, after it has been spawned.

         $job-&gt;on(start =&gt; sub ($job) {
           $0 = $job-&gt;id;
         });

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       Minion::Job implements the following attributes.

   <b>args</b>
         my $args = $job-&gt;args;
         $job     = $job-&gt;args([]);

       Arguments passed to task.

   <b>id</b>
         my $id = $job-&gt;id;
         $job   = $job-&gt;id($id);

       Job id.

   <b>minion</b>
         my $minion = $job-&gt;minion;
         $job       = $job-&gt;minion(Minion-&gt;new);

       Minion object this job belongs to.

   <b>retries</b>
         my $retries = $job-&gt;retries;
         $job        = $job-&gt;<a href="../man5/retries.5.html">retries</a>(5);

       Number of times job has been retried.

   <b>task</b>
         my $task = $job-&gt;task;
         $job     = $job-&gt;task('foo');

       Task name.

</pre><h4><b>METHODS</b></h4><pre>
       Minion::Job inherits all methods from Mojo::EventEmitter and implements the following new ones.

   <b>app</b>
         my $app = $job-&gt;app;

       Get application from "app" in Minion.

         # Longer version
         my $app = $job-&gt;minion-&gt;app;

   <b>execute</b>
         my $err = $job-&gt;execute;

       Perform job in this process and return "undef" if the task was successful or an exception otherwise.
       Note that this method should only be used to implement custom workers.

         # Perform job in foreground
         if (my $err = $job-&gt;execute) { $job-&gt;fail($err) }
         else                         { $job-&gt;finish }

   <b>fail</b>
         my $bool = $job-&gt;fail;
         my $bool = $job-&gt;fail('Something went wrong!');
         my $bool = $job-&gt;fail({whatever =&gt; 'Something went wrong!'});

       Transition from "active" to "failed" state with or without a result, and if there are attempts remaining,
       transition back to "inactive" with a delay based on "backoff" in Minion.

   <b>finish</b>
         my $bool = $job-&gt;finish;
         my $bool = $job-&gt;finish('All went well!');
         my $bool = $job-&gt;finish({whatever =&gt; 'All went well!'});

       Transition from "active" to "finished" state with or without a result.

   <b>info</b>
         my $info = $job-&gt;info;

       Get job information.

         # Check job state
         my $state = $job-&gt;info-&gt;{state};

         # Get job metadata
         my $progress = $job-&gt;info-&gt;{notes}{progress};

         # Get job result
         my $result = $job-&gt;info-&gt;{result};

       These fields are currently available:

       args
           args =&gt; ['foo', 'bar']

         Job arguments.

       attempts
           attempts =&gt; 25

         Number of times performing this job will be attempted.

       children
           children =&gt; ['10026', '10027', '10028']

         Jobs depending on this job.

       created
           created =&gt; 784111777

         Epoch time job was created.

       delayed
           delayed =&gt; 784111777

         Epoch time job was delayed to.

       expires
           expires =&gt; 784111777

         Epoch time job is valid until before it expires.

       finished
           finished =&gt; 784111777

         Epoch time job was finished.

       lax
           lax =&gt; 0

         Existing jobs this job depends on may also have failed to allow for it to be processed.

       notes
           notes =&gt; {foo =&gt; 'bar', baz =&gt; [1, 2, 3]}

         Hash reference with arbitrary metadata for this job.

       parents
           parents =&gt; ['10023', '10024', '10025']

         Jobs this job depends on.

       priority
           priority =&gt; 3

         Job priority.

       queue
           queue =&gt; 'important'

         Queue name.

       result
           result =&gt; 'All went well!'

         Job result.

       retried
           retried =&gt; 784111777

         Epoch time job has been retried.

       retries
           retries =&gt; 3

         Number of times job has been retried.

       started
           started =&gt; 784111777

         Epoch time job was started.

       state
           state =&gt; 'inactive'

         Current job state, usually "active", "failed", "finished" or "inactive".

       task
           task =&gt; 'foo'

         Task name.

       time
           time =&gt; 784111777

         Server time.

       worker
           worker =&gt; '154'

         Id of worker that is processing the job.

   <b>is_finished</b>
         my $bool = $job-&gt;is_finished;

       Check  if  job performed with "start" is finished. Note that this method should only be used to implement
       custom workers.

   <b>kill</b>
         $job-&gt;kill('INT');

       Send a signal to job performed with "start". Note that this method  should  only  be  used  to  implement
       custom workers.

   <b>note</b>
         my $bool = $job-&gt;note(mojo =&gt; 'rocks', minion =&gt; 'too');

       Change  one  or  more metadata fields for this job. Setting a value to "undef" will remove the field. The
       new values will get serialized by "backend" in Minion (often with  Mojo::JSON),  so  you  shouldn't  send
       objects  and  be careful with binary data, nested data structures with hash and array references are fine
       though.

         # Share progress information
         $job-&gt;note(progress =&gt; 95);

         # Share stats
         $job-&gt;note(stats =&gt; {utime =&gt; '0.012628', stime =&gt; '0.002429'});

   <b>parents</b>
         my $parents = $job-&gt;parents;

       Return a Mojo::Collection object containing all jobs this job depends on as Minion::Job objects.

         # Check parent state
         for my $parent ($job-&gt;parents-&gt;each) {
           my $info = $parent-&gt;info;
           say "$info-&gt;{id}: $info-&gt;{state}";
         }

   <b>perform</b>
         $job-&gt;perform;

       Perform job in new process and wait for it to finish. Note that  this  method  should  only  be  used  to
       implement custom workers.

   <b>pid</b>
         my $pid = $job-&gt;pid;

       Process  id  of the process spawned by "start" if available. Note that this method should only be used to
       implement custom workers.

   <b>remove</b>
         my $bool = $job-&gt;remove;

       Remove "failed", "finished" or "inactive" job from queue.

   <b>retry</b>
         my $bool = $job-&gt;retry;
         my $bool = $job-&gt;retry({delay =&gt; 10});

       Transition job back to "inactive" state, already "inactive" jobs may also be retried to change options.

       These options are currently available:

       attempts
           attempts =&gt; 25

         Number of times performing this job will be attempted.

       delay
           delay =&gt; 10

         Delay job for this many seconds (from now), defaults to 0.

       expire
           expire =&gt; 300

         Job is valid for this many seconds (from now) before it expires.

       lax
           lax =&gt; 1

         Existing jobs this job depends on may also have transitioned to the "failed" state to allow for  it  to
         be  processed,  defaults  to  "false".  Note  that this option is <b>EXPERIMENTAL</b> and might change without
         warning!

       parents
           parents =&gt; [$id1, $id2, $id3]

         Jobs this job depends on.

       priority
           priority =&gt; 5

         Job priority.

       queue
           queue =&gt; 'important'

         Queue to put job in.

   <b>run</b>
         $job-&gt;run(@args);

       Task to perform by this job. Meant to be overloaded in a subclass to create a  custom  task  class.  Note
       that this method is <b>EXPERIMENTAL</b> and might change without warning!

   <b>start</b>
         $job = $job-&gt;start;

       Perform  job  in new process, but do not wait for it to finish. Note that this method should only be used
       to implement custom workers.

         # Perform two jobs concurrently
         $job1-&gt;start;
         $job2-&gt;start;
         my ($first, $second);
         sleep 1
           until $first ||= $job1-&gt;is_finished and $second ||= $job2-&gt;is_finished;

   <b>stop</b>
         $job-&gt;stop;

       Stop job performed with "start" immediately. Note that this method  should  only  be  used  to  implement
       custom workers.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Minion, Minion::Guide, &lt;https://minion.pm&gt;, Mojolicious::Guides, &lt;https://mojolicious.org&gt;.

perl v5.40.0                                       2024-12-20                                   <u>Minion::<a href="../man3pm/Job.3pm.html">Job</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>