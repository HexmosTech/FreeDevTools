<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minion::Worker - Minion worker</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libminion-perl">libminion-perl_10.31+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Minion::Worker - Minion worker

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Minion::Worker;

         my $worker = Minion::Worker-&gt;new(minion =&gt; $minion);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Minion::Worker performs jobs for Minion.

</pre><h4><b>WORKER</b> <b>SIGNALS</b></h4><pre>
       The Minion::Worker process can be controlled at runtime with the following signals.

   <b>INT,</b> <b>TERM</b>
       Stop gracefully after finishing the current jobs.

   <b>QUIT</b>
       Stop immediately without finishing the current jobs.

</pre><h4><b>JOB</b> <b>SIGNALS</b></h4><pre>
       The job processes spawned by the Minion::Worker process can be controlled at runtime with the following
       signals.

   <b>INT,</b> <b>TERM</b>
       This signal starts out with the operating system default and allows for jobs to install a custom signal
       handler to stop gracefully.

   <b>USR1,</b> <b>USR2</b>
       These signals start out being ignored and allow for jobs to install custom signal handlers.

</pre><h4><b>EVENTS</b></h4><pre>
       Minion::Worker inherits all events from Mojo::EventEmitter and can emit the following new ones.

   <b>busy</b>
         $worker-&gt;on(busy =&gt; sub ($worker) {
           ...
         });

       Emitted in the worker process when it is performing the maximum number of jobs in parallel.

         $worker-&gt;on(busy =&gt; sub ($worker) {
           my $max = $worker-&gt;status-&gt;{jobs};
           say "Performing $max jobs.";
         });

   <b>dequeue</b>
         $worker-&gt;on(dequeue =&gt; sub ($worker, $job) {
           ...
         });

       Emitted in the worker process after a job has been dequeued.

         $worker-&gt;on(dequeue =&gt; sub ($worker, $job) {
           my $id = $job-&gt;id;
           say "Job $id has been dequeued.";
         });

   <b>wait</b>
         $worker-&gt;on(wait =&gt; sub ($worker) {
           ...
         });

       Emitted in the worker process before it tries to dequeue a job.

         $worker-&gt;on(wait =&gt; sub ($worker) {
           my $max = $worker-&gt;status-&gt;{dequeue_timeout};
           say "Waiting up to $max seconds for a new job.";
         });

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       Minion::Worker implements the following attributes.

   <b>commands</b>
         my $commands = $worker-&gt;commands;
         $worker      = $worker-&gt;commands({jobs =&gt; sub {...}});

       Registered worker remote control commands.

   <b>id</b>
         my $id  = $worker-&gt;id;
         $worker = $worker-&gt;id($id);

       Worker id.

   <b>minion</b>
         my $minion = $worker-&gt;minion;
         $worker    = $worker-&gt;minion(Minion-&gt;new);

       Minion object this worker belongs to.

   <b>status</b>
         my $status = $worker-&gt;status;
         $worker    = $worker-&gt;status({queues =&gt; ['default', 'important']);

       Status information to configure workers started with "run" and to share every time "register" is called.

</pre><h4><b>METHODS</b></h4><pre>
       Minion::Worker inherits all methods from Mojo::EventEmitter and implements the following new ones.

   <b>add_command</b>
         $worker = $worker-&gt;add_command(jobs =&gt; sub {...});

       Register a worker remote control command.

         $worker-&gt;add_command(foo =&gt; sub ($worker, @args) {
           ...
         });

   <b>dequeue</b>
         my $job = $worker-&gt;dequeue(0.5);
         my $job = $worker-&gt;dequeue(0.5 =&gt; {queues =&gt; ['important']});

       Wait a given amount of time in seconds for a job, dequeue Minion::Job object and transition from
       "inactive" to "active" state, or return "undef" if queues were empty.

       These options are currently available:

       id
           id =&gt; '10023'

         Dequeue a specific job.

       min_priority
           min_priority =&gt; 3

         Do not dequeue jobs with a lower priority.

       queues
           queues =&gt; ['important']

         One or more queues to dequeue jobs from, defaults to "default".

   <b>info</b>
         my $info = $worker-&gt;info;

       Get worker information.

         # Check worker host
         my $host = $worker-&gt;info-&gt;{host};

       These fields are currently available:

       host
           host =&gt; 'localhost'

         Worker host.

       jobs
           jobs =&gt; ['10023', '10024', '10025', '10029']

         Ids of jobs the worker is currently processing.

       notified
           notified =&gt; 784111777

         Epoch time worker sent the last heartbeat.

       pid
           pid =&gt; 12345

         Process id of worker.

       started
           started =&gt; 784111777

         Epoch time worker was started.

       status
           status =&gt; {queues =&gt; ['default', 'important']}

         Hash reference with whatever status information the worker would like to share.

   <b>new</b>
         my $worker = Minion::Worker-&gt;new;
         my $worker = Minion::Worker-&gt;new(status =&gt; {foo =&gt; 'bar'});
         my $worker = Minion::Worker-&gt;new({status =&gt; {foo =&gt; 'bar'}});

       Construct  a new Minion::Worker object and subscribe to "busy" event with default handler that sleeps for
       one second.

   <b>process_commands</b>
         $worker = $worker-&gt;process_commands;

       Process worker remote control commands.

   <b>register</b>
         $worker = $worker-&gt;register;

       Register worker or send heartbeat to show that this worker is still alive.

   <b>run</b>
         $worker-&gt;run;

       Run worker and wait for "WORKER SIGNALS".

         # Start a worker for a special named queue
         my $worker = $minion-&gt;worker;
         $worker-&gt;status-&gt;{queues} = ['important'];
         $worker-&gt;run;

       These "status" options are currently available:

       command_interval
           command_interval =&gt; 20

         Worker remote control command interval, defaults to 10.

       dequeue_timeout
           dequeue_timeout =&gt; 5

         Maximum amount time in seconds to wait for a job, defaults to 5.

       heartbeat_interval
           heartbeat_interval =&gt; 60

         Heartbeat interval, defaults to 300.

       jobs
           jobs =&gt; 12

         Maximum number of jobs to perform parallel in forked worker processes (not including spare  processes),
         defaults to 4.

       queues
           queues =&gt; ['test']

         One or more queues to get jobs from, defaults to "default".

       repair_interval
           repair_interval =&gt; 3600

         Repair  interval,  up  to  half  of  this value can be subtracted randomly to make sure not all workers
         repair at the same time, defaults to 21600 (6 hours).

       spare
           spare =&gt; 2

         Number of spare worker processes to reserve for high priority jobs, defaults to 1.

       spare_min_priority
           spare_min_priority =&gt; 7

         Minimum priority of jobs to use spare worker processes for, defaults to 1.

       These remote control "commands" are currently available:

       jobs
           $minion-&gt;broadcast('jobs', [10]);
           $minion-&gt;broadcast('jobs', [10], [$worker_id]);

         Instruct one or more workers to change the number of jobs to perform concurrently. Setting  this  value
         to  0  will effectively pause the worker. That means all current jobs will be finished, but no new ones
         accepted, until the number is increased again.

       kill
           $minion-&gt;broadcast('kill', ['INT', 10025]);
           $minion-&gt;broadcast('kill', ['INT', 10025], [$worker_id]);

         Instruct one or more workers to send a signal to a job that is currently being performed. This  command
         will  be  ignored by workers that do not have a job matching the id. That means it is safe to broadcast
         this command to all workers.

       stop
           $minion-&gt;broadcast('stop', [10025]);
           $minion-&gt;broadcast('stop', [10025], [$worker_id]);

         Instruct one or more workers to stop a job that is currently being performed immediately. This  command
         will  be  ignored by workers that do not have a job matching the id. That means it is safe to broadcast
         this command to all workers.

   <b>unregister</b>
         $worker = $worker-&gt;unregister;

       Unregister worker.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Minion, Minion::Guide, &lt;https://minion.pm&gt;, Mojolicious::Guides, &lt;https://mojolicious.org&gt;.

perl v5.40.0                                       2024-12-20                                <u>Minion::<a href="../man3pm/Worker.3pm.html">Worker</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>