<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       getcwd — get the pathname of the current working directory

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       char *getcwd(char *<u>buf</u>, size_t <u>size</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>getcwd</u>()  function  shall  place  an absolute pathname of the current working directory in the array
       pointed to by <u>buf</u>, and return <u>buf</u>.  The pathname shall contain no components that are dot or dot-dot,  or
       are symbolic links.

       If  there  are multiple pathnames that <u>getcwd</u>() could place in the array pointed to by <u>buf</u>, one beginning
       with a single &lt;slash&gt; character and one or more beginning with  two  &lt;slash&gt;  characters,  then  <u>getcwd</u>()
       shall  place  the pathname beginning with a single &lt;slash&gt; character in the array. The pathname shall not
       contain any unnecessary &lt;slash&gt; characters after the leading one or two &lt;slash&gt; characters.

       The <u>size</u> argument is the size in bytes of the character array pointed to by the <u>buf</u> argument. If <u>buf</u> is a
       null pointer, the behavior of <u>getcwd</u>() is unspecified.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon successful completion, <u>getcwd</u>() shall return the <u>buf</u> argument. Otherwise, <u>getcwd</u>()  shall  return  a
       null  pointer  and  set <u>errno</u> to indicate the error. The contents of the array pointed to by <u>buf</u> are then
       undefined.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>getcwd</u>() function shall fail if:

       <b>EINVAL</b> The <u>size</u> argument is 0.

       <b>ERANGE</b> The <u>size</u> argument is greater than 0, but is smaller than the length of the string +1.

       The <u>getcwd</u>() function may fail if:

       <b>EACCES</b> Search permission was denied for the current directory, or read or search  permission  was  denied
              for a directory above the current directory in the file hierarchy.

       <b>ENOMEM</b> Insufficient storage space is available.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following  example  uses  {PATH_MAX}  as the initial buffer size (unless it is indeterminate or very
       large), and calls <u>getcwd</u>() with progressively larger buffers until it does not give an <b>[ERANGE]</b> error.

           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

           ...

           long path_max;
           size_t size;
           char *buf;
           char *ptr;

           path_max = pathconf(".", _PC_PATH_MAX);
           if (path_max == -1)
               size = 1024;
           else if (path_max &gt; 10240)
               size = 10240;
           else
               size = path_max;

           for (buf = ptr = NULL; ptr == NULL; size *= 2)
           {
               if ((buf = realloc(buf, size)) == NULL)
               {
                   ... handle error ...
               }

               ptr = getcwd(buf, size);
               if (ptr == NULL &amp;&amp; errno != ERANGE)
               {
                   ... handle error ...
               }
           }
           ...
           free (buf);

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       If  the  pathname  obtained  from  <u>getcwd</u>()  is  longer  than  {PATH_MAX}  bytes,  it  could  produce  an
       <b>[ENAMETOOLONG]</b>  error  if  passed  to <u>chdir</u>().  Therefore, in order to return to that directory it may be
       necessary to break the pathname into sections shorter than {PATH_MAX} bytes  and  call  <u>chdir</u>()  on  each
       section  in  turn  (the  first  section being an absolute pathname and subsequent sections being relative
       pathnames). A simpler way to handle saving and restoring the working directory when it may be deeper than
       {PATH_MAX} bytes in the file hierarchy is to use a file descriptor and <u>fchdir</u>(), rather than <u>getcwd</u>() and
       <u>chdir</u>().  However, the two methods do have some differences. The <u>fchdir</u>() approach causes the program  to
       restore  a  working  directory  even if it has been renamed in the meantime, whereas the <u>chdir</u>() approach
       restores to a directory with the same name as the original, even if the directories were renamed  in  the
       meantime.  Since  the  <u>fchdir</u>() approach does not access parent directories, it can succeed when <u>getcwd</u>()
       would fail due to permissions problems. In applications conforming to earlier versions of this  standard,
       it  was  not  possible  to  use  the  <u>fchdir</u>()  approach when the working directory is searchable but not
       readable, as the only way to open a directory was  with  O_RDONLY,  whereas  the  <u>getcwd</u>()  approach  can
       succeed in this case.

</pre><h4><b>RATIONALE</b></h4><pre>
       Having <u>getcwd</u>() take no arguments and instead use the <u>malloc</u>() function to produce space for the returned
       argument  was considered.  The advantage is that <u>getcwd</u>() knows how big the working directory pathname is
       and can allocate an appropriate amount of space. But the programmer would have to use the <u>free</u>() function
       to free the resulting object, or each use of <u>getcwd</u>() would further reduce the available memory. Finally,
       <u>getcwd</u>() is taken from the SVID where it has the two arguments used in this volume of POSIX.1‐2017.

       The older function <u>getwd</u>() was rejected for use in this context because it had only a buffer argument and
       no <u>size</u> argument, and thus had no way to  prevent  overwriting  the  buffer,  except  to  depend  on  the
       programmer to provide a large enough buffer.

       On  some  implementations,  if  <u>buf</u>  is  a  null  pointer, <u>getcwd</u>() may obtain <u>size</u> bytes of memory using
       <u>malloc</u>().  In this case, the pointer returned by <u>getcwd</u>() may be used as the  argument  in  a  subsequent
       call  to  <u>free</u>().   Invoking  <u>getcwd</u>()  with  <u>buf</u>  as  a  null  pointer  is not recommended in conforming
       applications.

       Earlier implementations of <u>getcwd</u>() sometimes generated pathnames like <b>"../../../subdirname"</b>  internally,
       using  them  to  explore  the  path  of  ancestor  directories back to the root. If one of these internal
       pathnames exceeded {PATH_MAX} in length, the implementation could fail with <u>errno</u> set to  <b>[ENAMETOOLONG]</b>.
       This is no longer allowed.

       If  a  program  is  operating  in a directory where some (grand)parent directory does not permit reading,
       <u>getcwd</u>() may fail, as in most implementations it must read the directory to determine  the  name  of  the
       file.  This  can occur if search, but not read, permission is granted in an intermediate directory, or if
       the program is placed in that directory by some more privileged process (for example,  login).  Including
       the  <b>[EACCES]</b>  error  condition  makes  the  reporting  of the error consistent and warns the application
       developer that <u>getcwd</u>() can fail for reasons beyond the control of the  application  developer  or  user.
       Some  implementations  can  avoid this occurrence (for example, by implementing <u>getcwd</u>() using <u>pwd</u>, where
       <u>pwd</u> is a set-user-root process), thus the error was made optional.  Since  this  volume  of  POSIX.1‐2017
       permits the addition of other errors, this would be a common addition and yet one that applications could
       not be expected to deal with without this addition.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>malloc</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;unistd.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                        <u><a href="../man3POSIX/GETCWD.3POSIX.html">GETCWD</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>