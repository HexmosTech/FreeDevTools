<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>filelib - File utilities, such as wildcard matching of filenames.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       filelib - File utilities, such as wildcard matching of filenames.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module contains utilities on a higher level than the <u>file</u> module.

       This  module does not support "raw" filenames (that is, files whose names do not comply with the expected
       encoding). Such files are ignored by the functions in this module.

       For more information about raw filenames, see the <u>file</u> module.

   <b>Note:</b>
       Functionality in this module generally assumes valid input and does not necessarily fail  on  input  that
       does not use a valid encoding, but may instead very likely produce invalid output.

       File operations used to accept filenames containing null characters (integer value zero). This caused the
       name  to  be  truncated  and  in  some  cases arguments to primitive operations to be mixed up. Filenames
       containing null characters inside the filename are now <u>rejected</u> and will cause primitive file  operations
       to fail.

   <b>Warning:</b>
       Currently  null characters at the end of the filename will be accepted by primitive file operations. Such
       filenames are however still documented as invalid. The implementation will also change in the future  and
       reject such filenames.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>filename()</b> = file:name()

       <b>dirname()</b> = filename()

       <b>dirname_all()</b> = filename_all()

       <b>filename_all()</b> = file:name_all()

       <b>find_file_rule()</b> =
           {ObjDirSuffix :: string(), SrcDirSuffix :: string()}

       <b>find_source_rule()</b> =
           {ObjExtension :: string(),
            SrcExtension :: string(),
            [find_file_rule()]}

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>ensure_dir(Name)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = filename_all() | dirname_all()
                 Reason = file:posix()

              Ensures that all parent directories for the specified file or directory name <u>Name</u> exist, trying to
              create them if necessary.

              Returns  <u>ok</u>  if all parent directories already exist or can be created. Returns <u>{error,</u> <u>Reason}</u> if
              some parent directory does not exist and cannot be created.

       <b>file_size(Filename)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Filename = filename_all()

              Returns the size of the specified file.

       <b>fold_files(Dir,</b> <b>RegExp,</b> <b>Recursive,</b> <b>Fun,</b> <b>AccIn)</b> <b>-&gt;</b> <b>AccOut</b>

              Types:

                 Dir = dirname()
                 RegExp = string()
                 Recursive = boolean()
                 Fun = fun((F :: file:filename(), AccIn) -&gt; AccOut)
                 AccIn = AccOut = term()

              Folds function <u>Fun</u> over all (regular) files <u>F</u> in directory <u>Dir</u> that match the  regular  expression
              <u>RegExp</u>  (for a description of the allowed regular expressions, see the <u>re</u> module). If <u>Recursive</u> is
              <u>true</u>, all subdirectories to <u>Dir</u> are processed. The regular expression matching is only done on the
              filename without the directory part.

              If Unicode filename translation is in effect and the file system is  transparent,  filenames  that
              cannot  be  interpreted as Unicode can be encountered, in which case the <u>fun()</u> must be prepared to
              handle raw filenames (that is, binaries). If the regular expression contains codepoints &gt; 255,  it
              does  not match filenames that do not conform to the expected character encoding (that is, are not
              encoded in valid UTF-8).

              For more information about raw filenames, see the <u>file</u> module.

       <b>is_dir(Name)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Name = filename_all() | dirname_all()

              Returns <u>true</u> if <u>Name</u> refers to a directory, otherwise <u>false</u>.

       <b>is_file(Name)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Name = filename_all() | dirname_all()

              Returns <u>true</u> if <u>Name</u> refers to a file or a directory, otherwise <u>false</u>.

       <b>is_regular(Name)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Name = filename_all()

              Returns <u>true</u> if <u>Name</u> refers to a (regular) file, otherwise <u>false</u>.

       <b>last_modified(Name)</b> <b>-&gt;</b> <b>file:date_time()</b> <b>|</b> <b>0</b>

              Types:

                 Name = filename_all() | dirname_all()

              Returns the date and time the specified file or directory was last modified, or <u>0</u> if the file does
              not exist.

       <b>wildcard(Wildcard)</b> <b>-&gt;</b> <b>[file:filename()]</b>

              Types:

                 Wildcard = filename() | dirname()

              Returns a list of all files that match Unix-style wildcard string <u>Wildcard</u>.

              The wildcard string  looks  like  an  ordinary  filename,  except  that  the  following  "wildcard
              characters" are interpreted in a special way:

                <b>?:</b>
                  Matches one character.

                <b>*:</b>
                  Matches  any  number  of  characters  up to the end of the filename, the next dot, or the next
                  slash.

                <b>**:</b>
                  Two adjacent <u>*</u> used as a single pattern match all files  and  zero  or  more  directories  and
                  subdirectories.

                <b>[Character1,Character2,...]:</b>
                  Matches  any  of  the characters listed. Two characters separated by a hyphen match a range of
                  characters. Example: <u>[A-Z]</u> matches any uppercase letter.

                <b>{Item,...}:</b>
                  Alternation. Matches one of the alternatives.

              Other characters represent themselves. Only filenames that have exactly the same character in  the
              same position match. Matching is case-sensitive, for example, "a" does not match "A".

              Directory separators must always be written as <u>/</u>, even on Windows.

              A character preceded by <u>\</u> loses its special meaning. Note that <u>\</u> must be written as <u>\\</u> in a string
              literal. For example, "\\?*" will match any filename starting with <u>?</u>.

              Notice  that multiple "*" characters are allowed (as in Unix wildcards, but opposed to Windows/DOS
              wildcards).

              <u>Examples:</u>

              The following examples assume that the current directory is the top of an Erlang/OTP installation.

              To find all <u>.beam</u> files in all applications, use the following line:

              filelib:wildcard("lib/*/ebin/*.beam").

              To find <u>.erl</u> or <u>.hrl</u> in all applications <u>src</u> directories, use either of the following lines:

              filelib:wildcard("lib/*/src/*.?rl")

              filelib:wildcard("lib/*/src/*.{erl,hrl}")

              To find all <u>.hrl</u> files in <u>src</u> or <u>include</u> directories:

              filelib:wildcard("lib/*/{src,include}/*.hrl").

              To find all <u>.erl</u> or <u>.hrl</u> files in either <u>src</u> or <u>include</u> directories:

              filelib:wildcard("lib/*/{src,include}/*.{erl,hrl}")

              To find all <u>.erl</u> or <u>.hrl</u> files in any subdirectory:

              filelib:wildcard("lib/**/*.{erl,hrl}")

       <b>wildcard(Wildcard,</b> <b>Cwd)</b> <b>-&gt;</b> <b>[file:filename()]</b>

              Types:

                 Wildcard = filename() | dirname()
                 Cwd = dirname()

              Same as <u>wildcard/1</u>, except that <u>Cwd</u> is used instead of the working directory.

       <b>find_file(Filename</b> <b>::</b> <b>filename(),</b> <b>Dir</b> <b>::</b> <b>filename())</b> <b>-&gt;</b>
                    {ok, filename()} | {error, not_found}

       <b>find_file(Filename</b> <b>::</b> <b>filename(),</b>
                 Dir :: filename(),
                 Rules :: [find_file_rule()]) -&gt;
                    {ok, filename()} | {error, not_found}

              Looks for a file of the given name by applying suffix rules  to  the  given  directory  path.  For
              example,  a  rule  <u>{"ebin",</u>  <u>"src"}</u>  means  that  if  the  directory  path  ends  with <u>"ebin"</u>, the
              corresponding path ending in <u>"src"</u> should be searched.

              If <u>Rules</u> is left out or is an empty list, the default system rules are used. See also  the  Kernel
              application parameter <u>source_search_rules</u>.

       <b>find_source(FilePath</b> <b>::</b> <b>filename())</b> <b>-&gt;</b>
                      {ok, filename()} | {error, not_found}

              Equivalent  to  <u>find_source(Base,</u>  <u>Dir)</u>,  where  <u>Dir</u>  is  <u>filename:dirname(FilePath)</u>  and  <u>Base</u> is
              <u>filename:basename(FilePath)</u>.

       <b>find_source(Filename</b> <b>::</b> <b>filename(),</b> <b>Dir</b> <b>::</b> <b>filename())</b> <b>-&gt;</b>
                      {ok, filename()} | {error, not_found}

       <b>find_source(Filename</b> <b>::</b> <b>filename(),</b>
                   Dir :: filename(),
                   Rules :: [find_source_rule()]) -&gt;
                      {ok, filename()} | {error, not_found}

              Applies file extension specific rules to find the source file for a given object file relative  to
              the  object  directory.  For  example, for a file with the extension <u>.beam</u>, the default rule is to
              look for a file with a corresponding extension <u>.erl</u> by replacing the suffix <u>"ebin"</u> of  the  object
              directory  path  with <u>"src"</u> or <u>"src/*"</u>. The file search is done through <u>find_file/3</u>. The directory
              of the object file is always tried before any other directory specified by the rules.

              If <u>Rules</u> is left out or is an empty list, the default system rules are used. See also  the  Kernel
              application parameter <u>source_search_rules</u>.

       <b>safe_relative_path(Filename,</b> <b>Cwd)</b> <b>-&gt;</b> <b>unsafe</b> <b>|</b> <b>SafeFilename</b>

              Types:

                 Filename = Cwd = SafeFilename = filename_all()

              Sanitizes  the  relative  path by eliminating ".." and "." components to protect against directory
              traversal attacks. Either returns the sanitized path name, or the  atom  <u>unsafe</u>  if  the  path  is
              unsafe. The path is considered unsafe in the following circumstances:

                * The path is not relative.

                * A ".." component would climb up above the root of the relative path.

                * A symbolic link in the path points above the root of the relative path.

              <u>Examples:</u>

              1&gt; {ok, Cwd} = file:get_cwd().
              ...
              2&gt; filelib:safe_relative_path("dir/sub_dir/..", Cwd).
              "dir"
              3&gt; filelib:safe_relative_path("dir/..", Cwd).
              []
              4&gt; filelib:safe_relative_path("dir/..<a href="file:/..">/..</a>", Cwd).
              unsafe
              5&gt; filelib:safe_relative_path("/abs/path", Cwd).
              unsafe

Ericsson AB                                        stdlib 3.17                                     <u><a href="../man3erl/filelib.3erl.html">filelib</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>