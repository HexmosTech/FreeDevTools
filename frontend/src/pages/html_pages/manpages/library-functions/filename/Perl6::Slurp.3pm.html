<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perl6::Slurp - Implements the Perl 6 'slurp' built-in</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libperl6-slurp-perl">libperl6-slurp-perl_0.051005-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Perl6::Slurp - Implements the Perl 6 'slurp' built-in

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Perl6::Slurp;

           # Slurp a file by name...

           $file_contents = slurp 'filename';
           $file_contents = slurp '&lt;filename';
           $file_contents = slurp '&lt;', 'filename';
           $file_contents = slurp '+&lt;', 'filename';

           # Slurp a file via an (already open!) handle...

           $file_contents = slurp \*STDIN;
           $file_contents = slurp $filehandle;
           $file_contents = slurp IO::File-&gt;new('filename');

           # Slurp a string...

           $str_contents = slurp \$string;
           $str_contents = slurp '&lt;', \$string;

           # Slurp a pipe (not on Windows, alas)...

           $str_contents = slurp 'tail -20 $filename |';
           $str_contents = slurp '-|', 'tail', -20, $filename;

           # Slurp with no source slurps from whatever $_ indicates...

           for (@files) {
               $contents .= slurp;
           }

           # ...or from the entire ARGV list, if $_ is undefined...

           $_ = undef;
           $ARGV_contents = slurp;

           # Specify I/O layers as part of mode...

           $file_contents = slurp '&lt;:raw', $file;
           $file_contents = slurp '&lt;:utf8', $file;
           $file_contents = slurp '&lt;:raw :utf8', $file;

           # Specify I/O layers as separate options...

           $file_contents = slurp $file, {raw=&gt;1};
           $file_contents = slurp $file, {utf8=&gt;1};
           $file_contents = slurp $file, {raw=&gt;1}, {utf8=&gt;1};
           $file_contents = slurp $file, [raw=&gt;1, utf8=&gt;1];

           # Specify input record separator...

           $file_contents = slurp $file, {irs=&gt;"\n\n"};
           $file_contents = slurp '&lt;', $file, {irs=&gt;"\n\n"};
           $file_contents = slurp {irs=&gt;"\n\n"}, $file;

           # Input record separator can be regex...

           $file_contents = slurp $file, {irs=&gt;qr/\n+/};
           $file_contents = slurp '&lt;', $file, {irs=&gt;qr/\n+|\t{2,}};

           # Specify autochomping...

           $file_contents = slurp $file, {chomp=&gt;1};
           $file_contents = slurp {chomp=&gt;1}, $file;
           $file_contents = slurp $file, {chomp=&gt;1, irs=&gt;"\n\n"};
           $file_contents = slurp $file, {chomp=&gt;1, irs=&gt;qr/\n+/};

           # Specify autochomping that replaces irs
           # with another string...

           $file_contents = slurp $file, {irs=&gt;"\n\n", chomp=&gt;"\n"};
           $file_contents = slurp $file, {chomp=&gt;"\n\n"}, {irs=&gt;qr/\n+/};

           # Specify autochomping that replaces
           # irs with a dynamically computed string...

           my $n = 1;
           $file_contents = slurp $file, {chomp=&gt;sub{ "\n#line ".$n++."\n"};

           # Slurp in a list context...

           @lines = slurp 'filename';
           @lines = slurp $filehandle;
           @lines = slurp \$string;
           @lines = slurp '&lt;:utf8', 'filename', {irs=&gt;"\x{2020}", chomp=&gt;"\n"};

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "slurp" takes:

       •   a filename,

       •   a filehandle,

       •   a typeglob reference,

       •   an IO::File object, or

       •   a scalar reference,

       converts  it to an input stream (using "open()" if necessary), and reads in the entire stream. If "slurp"
       fails to set up or read the stream, it throws an exception.

       If no data source is specified "slurp" uses the value of $_ as the source. If $_  is  undefined,  "slurp"
       uses the @ARGV list, and magically slurps the contents of <u>all</u> the sources listed in @ARGV.  Note that the
       same magic is also applied if you explicitly slurp &lt;*ARGV&gt;, so the following three input operations:

           $contents = join "", &lt;ARGV&gt;;

           $contents = slurp \*ARGV;

           $/ = undef;
           $contents = slurp;

       are identical in effect.

       In  a scalar context "slurp" returns the stream contents as a single string.  If the stream is at EOF, it
       returns an empty string.  In a list context, it splits the contents after the  appropriate  input  record
       separator and returns the resulting list of strings.

       You  can  set  the  input  record  separator  ("{  irs  =&gt; $your_irs_here}") for the input operation. The
       separator can be specified as a string or a regex. Note that an explicit input record  separator  has  no
       input-terminating  effect  in a scalar context; "slurp" always reads in the entire input stream, whatever
       the 'irs' value.

       In a list context, changing the separator can change how the input is broken up within the list  that  is
       returned.

       If  an  input  record separator is not explicitly specified, "slurp" defaults to "\n" (<u>not</u> to the current
       value of $/ – since Perl 6 doesn't <u>have</u> a $/);

       You can also tell "slurp"  to  automagically  "chomp"  the  input  as  it  is  read  in,  by  specifying:
       ("{ chomp =&gt; 1 }")

       Better  still,  you  can  tell "slurp" to automagically "chomp" the input and <u>replace</u> what it chomps with
       another string, by specifying: ("{ chomp =&gt; "another string" }")

       You can also tell "slurp" to compute the replacement string on-the-fly by specifying a subroutine as  the
       "chomp"  value: ("{ chomp =&gt; sub{...} }"). This subroutine is passed the string being chomped off, so for
       example you could squeeze single newlines to a single space and multiple consecutive newlines  to  a  two
       newlines with:

           sub squeeze {
               my ($removed) = @_;
               if ($removed =~ tr/\n/\n/ == 1) { return " " }
               else                            { return "\n\n"; }
           }

           print slurp(\*DATA, {irs=&gt;qr/[ \t]*\n+/, chomp=&gt;\&amp;squeeze}), "\n";

       Which would transform:

           This is the
           first paragraph

           This is the
           second
           paragraph

           This, the
           third

           This one is
           the
           very
           last

       to:

           This is the first paragraph

           This is the second paragraph

           This, the third

           This one is the very last

       Autochomping  works  in  both  scalar  and  list contexts. In scalar contexts every instance of the input
       record separator will be removed (or replaced) within the returned string. In  list  context,  each  list
       item returned with its terminating separator removed (or replaced).

       You can specify I/O layers, either using the Perl 5 notation:

           slurp "&lt;:layer1 :layer2 :etc", $filename;

       or as an array of options:

           slurp $filename, [layer1=&gt;1, layer2=&gt;1, etc=&gt;1];
           slurp [layer1=&gt;1, layer2=&gt;1, etc=&gt;1], $filename;

       or as individual options (each of which must be in a separate hash):

           slurp $filename, {layer1=&gt;1}, {layer2=&gt;1}, {etc=&gt;1};
           slurp {layer1=&gt;1}, {layer2=&gt;1}, {etc=&gt;1}, $filename;

       (...which, of course, would look much cooler in Perl 6:

           # Perl 6 only :-(

           slurp $filename, :layer1 :layer2 :etc;
           slurp :layer1 :layer2 :etc, $filename;

       )

       A common mistake is to put all the options together in one hash:

           slurp $filename, {layer1=&gt;1, layer2=&gt;1, etc=&gt;1};

       This is almost always a disaster, since the order of I/O layers is usually critical, and placing them all
       in one hash effectively randomizes that order.  Use an array instead:

           slurp $filename, [layer1=&gt;1, layer2=&gt;1, etc=&gt;1];

</pre><h4><b>WARNINGS</b></h4><pre>
       The  syntax  and  semantics of Perl 6 is still being finalized and consequently is at any time subject to
       change. That means the same caveat applies to this module.

       When called with a filename or piped shell command, "slurp()" uses Perl's built- in  "open()"  to  access
       the  file.  This  means  that  it  is subject to the same platform-specific limitations as "open()".  For
       example, slurping from piped shell commands may not work under Windows.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       Requires: Perl 5.8.0

</pre><h4><b>AUTHOR</b></h4><pre>
       Damian Conway (<a href="mailto:damian@conway.org">damian@conway.org</a>)

</pre><h4><b>COPYRIGHT</b></h4><pre>
        Copyright (c) 2003-2012, Damian Conway. All Rights Reserved.
        This module is free software. It may be used, redistributed
           and/or modified under the same terms as Perl itself.

perl v5.36.0                                       2022-11-19                                  <u>Perl6::<a href="../man3pm/Slurp.3pm.html">Slurp</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>