<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File::Temp - return name and handle of a temporary file safely</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       File::Temp - return name and handle of a temporary file safely

</pre><h4><b>VERSION</b></h4><pre>
       version 0.2311

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use File::Temp qw/ tempfile tempdir /;

         $fh = tempfile();
         ($fh, $filename) = tempfile();

         ($fh, $filename) = tempfile( $template, DIR =&gt; $dir);
         ($fh, $filename) = tempfile( $template, SUFFIX =&gt; '.dat');
         ($fh, $filename) = tempfile( $template, TMPDIR =&gt; 1 );

         binmode( $fh, ":utf8" );

         $dir = tempdir( CLEANUP =&gt; 1 );
         ($fh, $filename) = tempfile( DIR =&gt; $dir );

       Object interface:

         require File::Temp;
         use File::Temp ();
         use File::Temp qw/ :seekable /;

         $fh = File::Temp-&gt;new();
         $fname = $fh-&gt;filename;

         $fh = File::Temp-&gt;new(TEMPLATE =&gt; $template);
         $fname = $fh-&gt;filename;

         $tmp = File::Temp-&gt;new( UNLINK =&gt; 0, SUFFIX =&gt; '.dat' );
         print $tmp "Some data\n";
         print "Filename is $tmp\n";
         $tmp-&gt;seek( 0, SEEK_END );

         $dir = File::Temp-&gt;newdir(); # CLEANUP =&gt; 1 by default

       The following interfaces are provided for compatibility with existing APIs. They should not be used in
       new code.

       MkTemp family:

         use File::Temp qw/ :mktemp  /;

         ($fh, $file) = mkstemp( "tmpfileXXXXX" );
         ($fh, $file) = mkstemps( "tmpfileXXXXXX", $suffix);

         $tmpdir = mkdtemp( $template );

         $unopened_file = mktemp( $template );

       POSIX functions:

         use File::Temp qw/ :POSIX /;

         $file = tmpnam();
         $fh = tmpfile();

         ($fh, $file) = tmpnam();

       Compatibility functions:

         $unopened_file = File::Temp::tempnam( $dir, $pfx );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "File::Temp" can be used to create and open temporary files in a safe way.  There is both a function
       interface and an object-oriented interface.  The File::Temp constructor or the <b>tempfile()</b> function can be
       used to return the name and the open filehandle of a temporary file.  The <b>tempdir()</b> function can be used
       to create a temporary directory.

       The security aspect of temporary file creation is emphasized such that a filehandle and filename are
       returned together.  This helps guarantee that a race condition can not occur where the temporary file is
       created by another process between checking for the existence of the file and its opening.  Additional
       security levels are provided to check, for example, that the sticky bit is set on world writable
       directories.  See "safe_level" for more information.

       For compatibility with popular C library functions, Perl implementations of the <b>mkstemp()</b> family of
       functions are provided. These are, <b>mkstemp()</b>, <b>mkstemps()</b>, <b>mkdtemp()</b> and <b>mktemp()</b>.

       Additionally, implementations of the standard POSIX <b>tmpnam()</b> and <b>tmpfile()</b> functions are provided if
       required.

       Implementations of <b>mktemp()</b>, <b>tmpnam()</b>, and <b>tempnam()</b> are provided, but should be used with caution since
       they return only a filename that was valid when function was called, so cannot guarantee that the file
       will not exist by the time the caller opens the filename.

       Filehandles returned by these functions support the seekable methods.

</pre><h4><b>OBJECT-ORIENTED</b> <b>INTERFACE</b></h4><pre>
       This is the primary interface for interacting with "File::Temp". Using the OO interface a temporary file
       can be created when the object is constructed and the file can be removed when the object is no longer
       required.

       Note that there is no method to obtain the filehandle from the "File::Temp" object. The object itself
       acts as a filehandle.  The object isa "IO::Handle" and isa "IO::Seekable" so all those methods are
       available.

       Also, the object is configured such that it stringifies to the name of the temporary file and so can be
       compared to a filename directly.  It numifies to the "refaddr" the same as other handles and so can be
       compared to other handles with "==".

           $fh eq $filename       # as a string
           $fh != \*STDOUT        # as a number

       Available since 0.14.

       <b>new</b> Create a temporary file object.

             my $tmp = File::Temp-&gt;new();

           by  default  the  object  is  constructed  as  if "tempfile" was called without options, but with the
           additional behaviour that the temporary file is removed by the object destructor if UNLINK is set  to
           true (the default).

           Supported  arguments  are the same as for "tempfile": UNLINK (defaulting to true), DIR, EXLOCK, PERMS
           and SUFFIX.  Additionally, the filename template is specified using the  TEMPLATE  option.  The  OPEN
           option is not supported (the file is always opened).

            $tmp = File::Temp-&gt;new( TEMPLATE =&gt; 'tempXXXXX',
                                   DIR =&gt; 'mydir',
                                   SUFFIX =&gt; '.dat');

           Arguments are case insensitive.

           Can call <b>croak()</b> if an error occurs.

           Available since 0.14.

           TEMPLATE available since 0.23

       <b>newdir</b>
           Create a temporary directory using an object oriented interface.

             $dir = File::Temp-&gt;newdir();

           By default the directory is deleted when the object goes out of scope.

           Supports  the  same options as the "tempdir" function. Note that directories created with this method
           default to CLEANUP =&gt; 1.

             $dir = File::Temp-&gt;newdir( $template, %options );

           A template may be specified either with a leading template or with a TEMPLATE argument.

           Available since 0.19.

           TEMPLATE available since 0.23.

       <b>filename</b>
           Return the name of the temporary file associated with this object (if the object  was  created  using
           the "new" constructor).

             $filename = $tmp-&gt;filename;

           This method is called automatically when the object is used as a string.

           Current API available since 0.14

       <b>dirname</b>
           Return  the  name  of  the temporary directory associated with this object (if the object was created
           using the "newdir" constructor).

             $dirname = $tmpdir-&gt;dirname;

           This method is called automatically when the object is used in string context.

       <b>unlink_on_destroy</b>
           Control whether the file is unlinked when the object goes out of scope.  The file is removed if  this
           value is true and $KEEP_ALL is not.

            $fh-&gt;unlink_on_destroy( 1 );

           Default is for the file to be removed.

           Current API available since 0.15

       <b>DESTROY</b>
           When  the  object goes out of scope, the destructor is called. This destructor will attempt to unlink
           the file (using unlink1) if the constructor was called with UNLINK set to 1  (the  default  state  if
           UNLINK is not specified).

           No error is given if the unlink fails.

           If  the  object  has  been passed to a child process during a fork, the file will be deleted when the
           object goes out of scope in the parent.

           For a temporary directory object the directory will be removed unless the CLEANUP argument  was  used
           in  the constructor (and set to false) or "unlink_on_destroy" was modified after creation.  Note that
           if a temp directory is your current directory, it cannot be removed - a warning will be given in this
           case.  chdir() out of the directory before letting the object go out of scope.

           If the global variable $KEEP_ALL is true, the file or directory will not be removed.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       This section describes the recommended interface for generating temporary files and directories.

       <b>tempfile</b>
           This is the basic function to generate temporary files.  The behaviour of the  file  can  be  changed
           using various options:

             $fh = tempfile();
             ($fh, $filename) = tempfile();

           Create a temporary file in  the directory specified for temporary files, as specified by the <b>tmpdir()</b>
           function in File::Spec.

             ($fh, $filename) = tempfile($template);

           Create  a  temporary  file  in  the  current  directory  using  the  supplied template.  Trailing `X'
           characters are replaced with random letters to generate the filename.  At least four  `X'  characters
           must be present at the end of the template.

             ($fh, $filename) = tempfile($template, SUFFIX =&gt; $suffix)

           Same  as previously, except that a suffix is added to the template after the `X' translation.  Useful
           for ensuring that a temporary filename has a particular extension when needed by other  applications.
           But see the WARNING at the end.

             ($fh, $filename) = tempfile($template, DIR =&gt; $dir);

           Translates the template as before except that a directory name is specified.

             ($fh, $filename) = tempfile($template, TMPDIR =&gt; 1);

           Equivalent  to  specifying  a  DIR  of "File::Spec-&gt;tmpdir", writing the file into the same temporary
           directory as would be used if no template was specified at all.

             ($fh, $filename) = tempfile($template, UNLINK =&gt; 1);

           Return the filename and filehandle as before except that the file is automatically removed  when  the
           program  exits  (dependent  on  $KEEP_ALL). Default is for the file to be removed if a file handle is
           requested and to be kept if the filename is requested. In a scalar  context  (where  no  filename  is
           returned) the file is always deleted either (depending on the operating system) on exit or when it is
           closed (unless $KEEP_ALL is true when the temp file is created).

           Use the object-oriented interface if fine-grained control of when a file is removed is required.

           If  the  template is not specified, a template is always automatically generated. This temporary file
           is placed in <b>tmpdir()</b> (File::Spec) unless a directory is specified explicitly with the DIR option.

             $fh = tempfile( DIR =&gt; $dir );

           If called in scalar context, only the filehandle is returned  and  the  file  will  automatically  be
           deleted  when  closed  on  operating  systems  that  support  this  (see the description of <b>tmpfile()</b>
           elsewhere in this document).  This is the preferred  mode  of  operation,  as  if  you  only  have  a
           filehandle,  you can never create a race condition by fumbling with the filename. On systems that can
           not unlink an open file or can not mark a file as temporary when it is opened (for  example,  Windows
           NT  uses the "O_TEMPORARY" flag) the file is marked for deletion when the program ends (equivalent to
           setting UNLINK to 1). The "UNLINK" flag is ignored if present.

             (undef, $filename) = tempfile($template, OPEN =&gt; 0);

           This will return the filename based on the template but will not open this file.  Cannot be  used  in
           conjunction with UNLINK set to true. Default is to always open the file to protect from possible race
           conditions.  A  warning is issued if warnings are turned on. Consider using the <b>tmpnam()</b> and <b>mktemp()</b>
           functions described elsewhere in this document if opening the file is not required.

           To open the temporary filehandle with O_EXLOCK (open with exclusive file lock) use "EXLOCK=&gt;1".  This
           is  supported  only  by  some operating systems (most notably BSD derived systems). By default EXLOCK
           will be false. Former "File::Temp" versions set EXLOCK to true, so to be  sure  to  get  an  unlocked
           filehandle also with older versions, explicitly set "EXLOCK=&gt;0".

             ($fh, $filename) = tempfile($template, EXLOCK =&gt; 1);

           By default, the temp file is created with 0600 file permissions.  Use "PERMS" to change this:

             ($fh, $filename) = tempfile($template, PERMS =&gt; 0666);

           Options can be combined as required.

           Will <b>croak()</b> if there is an error.

           Available since 0.05.

           UNLINK flag available since 0.10.

           TMPDIR flag available since 0.19.

           EXLOCK flag available since 0.19.

           PERMS flag available since 0.2310.

       <b>tempdir</b>
           This  is  the  recommended interface for creation of temporary directories.  By default the directory
           will not be removed on exit (that is, it won't be  temporary;  this  behaviour  can  not  be  changed
           because  of  issues  with  backwards  compatibility). To enable removal either use the CLEANUP option
           which will trigger removal on program exit, or consider using  the  "newdir"  method  in  the  object
           interface which will allow the directory to be cleaned up when the object goes out of scope.

           The behaviour of the function depends on the arguments:

             $tempdir = tempdir();

           Create a directory in <b>tmpdir()</b> (see File::Spec).

             $tempdir = tempdir( $template );

           Create  a  directory  from  the  supplied  template.  This  template is similar to that described for
           <b>tempfile()</b>. `X' characters at the end of the template are replaced with random letters  to  construct
           the directory name. At least four `X' characters must be in the template.

             $tempdir = tempdir ( DIR =&gt; $dir );

           Specifies  the directory to use for the temporary directory.  The temporary directory name is derived
           from an internal template.

             $tempdir = tempdir ( $template, DIR =&gt; $dir );

           Prepend the supplied directory name to the template. The template should not include parent directory
           specifications itself. Any parent directory specifications  are  removed  from  the  template  before
           prepending the supplied directory.

             $tempdir = tempdir ( $template, TMPDIR =&gt; 1 );

           Using  the  supplied  template,  create  the temporary directory in a standard location for temporary
           files. Equivalent to doing

             $tempdir = tempdir ( $template, DIR =&gt; File::Spec-&gt;tmpdir);

           but shorter. Parent directory specifications are stripped from  the  template  itself.  The  "TMPDIR"
           option  is  ignored  if  "DIR"  is  set  explicitly.   Additionally, "TMPDIR" is implied if neither a
           template nor a directory are supplied.

             $tempdir = tempdir( $template, CLEANUP =&gt; 1);

           Create a temporary directory using the supplied template, but attempt to remove  it  (and  all  files
           inside  it)  when  the  program exits. Note that an attempt will be made to remove all files from the
           directory even if they were not created by this module (otherwise why  ask  to  clean  it  up?).  The
           directory  removal  is made with the <b>rmtree()</b> function from the File::Path module.  Of course, if the
           template is not specified, the temporary directory will be created  in  <b>tmpdir()</b>  and  will  also  be
           removed at program exit.

           Will <b>croak()</b> if there is an error.

           Current API available since 0.05.

</pre><h4><b>MKTEMP</b> <b>FUNCTIONS</b></h4><pre>
       The  following  functions  are Perl implementations of the <b>mktemp()</b> family of temp file generation system
       calls.

       <b>mkstemp</b>
           Given a template, returns a filehandle to the temporary file and the name of the file.

             ($fh, $name) = mkstemp( $template );

           In scalar context, just the filehandle is returned.

           The template may be any filename with some number of X's appended to it, for example  <u>/tmp/temp.XXXX</u>.
           The trailing X's are replaced with unique alphanumeric combinations.

           Will <b>croak()</b> if there is an error.

           Current API available since 0.05.

       <b>mkstemps</b>
           Similar  to  <b>mkstemp()</b>, except that an extra argument can be supplied with a suffix to be appended to
           the template.

             ($fh, $name) = mkstemps( $template, $suffix );

           For example a template of "testXXXXXX" and  suffix  of  ".dat"  would  generate  a  file  similar  to
           <u>testhGji_w.dat</u>.

           Returns just the filehandle alone when called in scalar context.

           Will <b>croak()</b> if there is an error.

           Current API available since 0.05.

       <b>mkdtemp</b>
           Create a directory from a template. The template must end in X's that are replaced by the routine.

             $tmpdir_name = mkdtemp($template);

           Returns the name of the temporary directory created.

           Directory must be removed by the caller.

           Will <b>croak()</b> if there is an error.

           Current API available since 0.05.

       <b>mktemp</b>
           Returns a valid temporary filename but does not guarantee that the file will not be opened by someone
           else.

             $unopened_file = mktemp($template);

           Template is the same as that required by <b>mkstemp()</b>.

           Will <b>croak()</b> if there is an error.

           Current API available since 0.05.

</pre><h4><b>POSIX</b> <b>FUNCTIONS</b></h4><pre>
       This  section  describes the re-implementation of the <b>tmpnam()</b> and <b>tmpfile()</b> functions described in POSIX
       using the <b>mkstemp()</b> from this module.

       Unlike the POSIX implementations, the directory used for the temporary file is not specified in a  system
       include  file  ("P_tmpdir")  but simply depends on the choice of <b>tmpdir()</b> returned by File::Spec. On some
       implementations this location can be set using the  "TMPDIR"  environment  variable,  which  may  not  be
       secure.  If this is a problem, simply use <b>mkstemp()</b> and specify a template.

       <b>tmpnam</b>
           When  called  in  scalar  context,  returns  the full name (including path) of a temporary file (uses
           <b>mktemp()</b>). The only check is that the file does not already exist, but there  is  no  guarantee  that
           that condition will continue to apply.

             $file = tmpnam();

           When  called  in  list  context,  a  filehandle to the open file and a filename are returned. This is
           achieved by calling <b>mkstemp()</b> after constructing a suitable template.

             ($fh, $file) = tmpnam();

           If possible, this form should be used to prevent possible race conditions.

           See "tmpdir" in File::Spec for information on the choice of  temporary  directory  for  a  particular
           operating system.

           Will <b>croak()</b> if there is an error.

           Current API available since 0.05.

       <b>tmpfile</b>
           Returns the filehandle of a temporary file.

             $fh = tmpfile();

           The  file  is  removed  when  the  filehandle  is  closed or when the program exits. No access to the
           filename is provided.

           If the temporary file can not be created undef is returned.  Currently this command will probably not
           work when the temporary directory is on an NFS file system.

           Will <b>croak()</b> if there is an error.

           Available since 0.05.

           Returning undef if unable to create file added in 0.12.

</pre><h4><b>ADDITIONAL</b> <b>FUNCTIONS</b></h4><pre>
       These functions are provided for backwards  compatibility  with  common  tempfile  generation  C  library
       functions.

       They are not exported and must be addressed using the full package name.

       <b>tempnam</b>
           Return the name of a temporary file in the specified directory using a prefix. The file is guaranteed
           not  to  exist  at  the time the function was called, but such guarantees are good for one clock tick
           only.  Always use the proper form of "sysopen" with "O_CREAT |  O_EXCL"  if  you  must  open  such  a
           filename.

             $filename = File::Temp::tempnam( $dir, $prefix );

           Equivalent to running <b>mktemp()</b> with $dir/$prefixXXXXXXXX (using unix file convention as an example)

           Because this function uses <b>mktemp()</b>, it can suffer from race conditions.

           Will <b>croak()</b> if there is an error.

           Current API available since 0.05.

</pre><h4><b>UTILITY</b> <b>FUNCTIONS</b></h4><pre>
       Useful functions for dealing with the filehandle and filename.

       <b>unlink0</b>
           Given  an  open filehandle and the associated filename, make a safe unlink. This is achieved by first
           checking that the filename and filehandle initially point to the same file and  that  the  number  of
           links  to  the file is 1 (all fields returned by <b>stat()</b> are compared).  Then the filename is unlinked
           and the filehandle checked once again to verify that the number of links on that file is now 0.  This
           is the closest you can come to making sure that the filename unlinked was the same as the file  whose
           descriptor you hold.

             unlink0($fh, $path)
                or die "Error unlinking file $path safely";

           Returns  false  on  error  but  <b>croaks()</b> if there is a security anomaly. The filehandle is not closed
           since on some occasions this is not required.

           On some platforms, for example Windows NT, it is not possible to unlink an open file (the  file  must
           be  closed  first).  On  those platforms, the actual unlinking is deferred until the program ends and
           good status is returned. A check is still performed to make sure that the filehandle and filename are
           pointing to the same thing (but not at the time the end block is executed since the deferred  removal
           may not have access to the filehandle).

           Additionally,  on  Windows NT not all the fields returned by <b>stat()</b> can be compared. For example, the
           "dev" and "rdev" fields seem to be different.  Also, it seems that the size of the file  returned  by
           <b>stat()</b>  does  not  always  agree,  with  stat(FH) being more accurate than stat(filename), presumably
           because of caching issues even when using autoflush (this is usually  overcome  by  waiting  a  while
           after writing to the tempfile before attempting to "unlink0" it).

           Finally, on NFS file systems the link count of the file handle does not always go to zero immediately
           after unlinking. Currently, this command is expected to fail on NFS disks.

           This  function  is  disabled  if  the global variable $KEEP_ALL is true and an unlink on open file is
           supported. If the unlink is to be deferred to the  END  block,  the  file  is  still  registered  for
           removal.

           This  function  should not be called if you are using the object oriented interface since the it will
           interfere with the object destructor deleting the file.

           Available Since 0.05.

           If can not unlink open file, defer removal until later available since 0.06.

       <b>cmpstat</b>
           Compare "stat" of filehandle with "stat" of provided filename.  This can be used to  check  that  the
           filename  and filehandle initially point to the same file and that the number of links to the file is
           1 (all fields returned by <b>stat()</b> are compared).

             cmpstat($fh, $path)
                or die "Error comparing handle with file";

           Returns false if the stat information differs or if the link count is greater than 1. Calls croak  if
           there is a security anomaly.

           On certain platforms, for example Windows, not all the fields returned by <b>stat()</b> can be compared. For
           example,  the  "dev" and "rdev" fields seem to be different in Windows.  Also, it seems that the size
           of the file returned by <b>stat()</b> does  not  always  agree,  with  stat(FH)  being  more  accurate  than
           stat(filename),  presumably  because  of  caching  issues  even when using autoflush (this is usually
           overcome by waiting a while after writing to the tempfile before attempting to "unlink0" it).

           Not exported by default.

           Current API available since 0.14.

       <b>unlink1</b>
           Similar to "unlink0" except after file comparison using cmpstat, the filehandle is  closed  prior  to
           attempting  to  unlink  the  file. This allows the file to be removed without using an END block, but
           does mean that the post-unlink comparison of the  filehandle  state  provided  by  "unlink0"  is  not
           available.

             unlink1($fh, $path)
                or die "Error closing and unlinking file";

           Usually called from the object destructor when using the OO interface.

           Not exported by default.

           This function is disabled if the global variable $KEEP_ALL is true.

           Can call <b>croak()</b> if there is a security anomaly during the <b>stat()</b> comparison.

           Current API available since 0.14.

       <b>cleanup</b>
           Calling  this  function will cause any temp files or temp directories that are registered for removal
           to be removed. This happens automatically when the process exits but can be triggered manually if the
           caller is sure that none of the temp files are required. This method can be registered as  an  Apache
           callback.

           Note  that  if  a temp directory is your current directory, it cannot be removed.  chdir() out of the
           directory first before calling cleanup(). (For the cleanup at program exit when the CLEANUP  flag  is
           set, this happens automatically.)

           On  OSes  where  temp  files  are  automatically  removed  when the temp file is closed, calling this
           function will have no effect other than to remove temporary directories (which may include  temporary
           files).

             File::Temp::cleanup();

           Not exported by default.

           Current API available since 0.15.

</pre><h4><b>PACKAGE</b> <b>VARIABLES</b></h4><pre>
       These functions control the global state of the package.

       <b>safe_level</b>
           Controls  the  lengths  to  which  the  module  will  go to check the safety of the temporary file or
           directory before proceeding.  Options are:

           STANDARD
                   Do the basic security measures to ensure the directory exists and is writable, that temporary
                   files are opened only if they do not already exist, and that  possible  race  conditions  are
                   avoided.  Finally the unlink0 function is used to remove files safely.

           MEDIUM  In addition to the STANDARD security, the output directory is checked to make sure that it is
                   owned  either  by root or the user running the program. If the directory is writable by group
                   or by other, it is then checked to make sure that the sticky bit is set.

                   Will not work on platforms that do not support the "-k" test for sticky bit.

           HIGH    In addition to the MEDIUM security checks,  also  check  for  the  possibility  of  ``<b>chown()</b>
                   giveaway''  using  the  POSIX <b>sysconf()</b> function. If this is a possibility, each directory in
                   the path is checked in turn for safeness, recursively walking back to the root directory.

                   For platforms that do not support  the  POSIX  "_PC_CHOWN_RESTRICTED"  symbol  (for  example,
                   Windows  NT)  it  is  assumed that ``<b>chown()</b> giveaway'' is possible and the recursive test is
                   performed.

           The level can be changed as follows:

             File::Temp-&gt;safe_level( File::Temp::HIGH );

           The level constants are not exported by the module.

           Currently, you must be running at least perl v5.6.0 in order to run with  MEDIUM  or  HIGH  security.
           This  is  simply  because  the  safety tests use functions from Fcntl that are not available in older
           versions of perl. The problem is that the version number for Fcntl is the same in perl 5.6.0  and  in
           5.005_03 even though they are different versions.

           On  systems  that  do  not  support the HIGH or MEDIUM safety levels (for example Win NT or OS/2) any
           attempt to change the level will be ignored. The decision to ignore rather than  raise  an  exception
           allows  portable  programs  to be written with high security in mind for the systems that can support
           this without those programs failing on systems where the extra tests are irrelevant.

           If you really need to see whether the change has been accepted simply examine  the  return  value  of
           "safe_level".

             $newlevel = File::Temp-&gt;safe_level( File::Temp::HIGH );
             die "Could not change to high security"
                 if $newlevel != File::Temp::HIGH;

           Available since 0.05.

       TopSystemUID
           This  is  the  highest UID on the current system that refers to a root UID. This is used to make sure
           that the temporary directory is owned by a system UID ("root", "bin", "sys" etc) rather  than  simply
           by root.

           This is required since on many unix systems "<a href="file:/tmp">/tmp</a>" is not owned by root.

           Default is to assume that any UID less than or equal to 10 is a root UID.

             File::Temp-&gt;<a href="../man10/top_system_uid.10.html">top_system_uid</a>(10);
             my $topid = File::Temp-&gt;top_system_uid;

           This  value can be adjusted to reduce security checking if required.  The value is only relevant when
           "safe_level" is set to MEDIUM or higher.

           Available since 0.05.

       <b>$KEEP_ALL</b>
           Controls whether temporary files and directories should be retained regardless of any instructions in
           the program to remove them automatically.  This is useful for debugging but should  not  be  used  in
           production code.

             $File::Temp::KEEP_ALL = 1;

           Default is for files to be removed as requested by the caller.

           In  some  cases,  files will only be retained if this variable is true when the file is created. This
           means that you can not create a temporary file, set this variable and expect the temp file  to  still
           be around when the program exits.

       <b>$DEBUG</b>
           Controls whether debugging messages should be enabled.

             $File::Temp::DEBUG = 1;

           Default is for debugging mode to be disabled.

           Available since 0.15.

</pre><h4><b>WARNING</b></h4><pre>
       For maximum security, endeavour always to avoid ever looking at, touching, or even imputing the existence
       of  the  filename.   You  do  not know that that filename is connected to the same file as the handle you
       have, and attempts to check this can only trigger more race conditions.  It's far more secure to use  the
       filehandle alone and dispense with the filename altogether.

       If  you  need  to  pass the handle to something that expects a filename then on a unix system you can use
       ""<a href="file:/dev/fd/">/dev/fd/</a>" . fileno($fh)" for arbitrary programs. Perl code that uses the 2-argument version  of  "open"
       can  be  passed  ""+&lt;=&amp;"  .  fileno($fh)". Otherwise you will need to pass the filename. You will have to
       clear the close-on-exec bit on that file descriptor before passing it to another process.

           use Fcntl qw/F_SETFD F_GETFD/;
           fcntl($tmpfh, F_SETFD, 0)
               or die "Can't clear close-on-exec flag on temp fh: $!\n";

   <b>Temporary</b> <b>files</b> <b>and</b> <b>NFS</b>
       Some problems are associated with using temporary files that  reside  on  NFS  file  systems  and  it  is
       recommended  that  a  local  filesystem  is  used whenever possible. Some of the security tests will most
       probably fail when the temp file is not local.  Additionally,  be  aware  that  the  performance  of  I/O
       operations over NFS will not be as good as for a local disk.

   <b>Forking</b>
       In  some  cases  files  created  by File::Temp are removed from within an END block. Since END blocks are
       triggered when a child process exits (unless POSIX::_exit() is used by the child) File::Temp  takes  care
       to  only  remove  those  temp  files created by a particular process ID. This means that a child will not
       attempt to remove temp files created by the parent process.

       If you are forking many processes in parallel that are all creating temporary  files,  you  may  need  to
       reset  the  random number seed using srand(EXPR) in each child else all the children will attempt to walk
       through the same set of random file names and may well cause themselves to give up  if  they  exceed  the
       number of retry attempts.

   <b>Directory</b> <b>removal</b>
       Note  that if you have chdir'ed into the temporary directory and it is subsequently cleaned up (either in
       the END block or as part of object destruction), then you will get a warning from <b>File::Path::rmtree()</b>.

   <b>Taint</b> <b>mode</b>
       If you need to run code under taint mode, updating to the latest File::Spec is  highly  recommended.   On
       Windows, if the directory given by File::Spec::tmpdir isn't writable, File::Temp will attempt to fallback
       to the user's local application data directory or croak with an error.

   <b>BINMODE</b>
       The file returned by File::Temp will have been opened in binary mode if such a mode is available. If that
       is not correct, use the binmode() function to change the mode of the filehandle.

       Note that you can modify the encoding of a file opened by File::Temp also by using binmode().

</pre><h4><b>HISTORY</b></h4><pre>
       Originally began life in May 1999 as an XS interface to the system <b>mkstemp()</b> function. In March 2000, the
       OpenBSD  <b>mkstemp()</b>  code  was  translated  to  Perl for total control of the code's security checking, to
       ensure the presence of the function regardless of operating system and  to  help  with  portability.  The
       module was shipped as a standard part of perl from v5.6.1.

       Thanks to Tom Christiansen for suggesting that this module should be written and providing ideas for code
       improvements and security enhancements.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       "tmpnam" in POSIX, "tmpfile" in POSIX, File::Spec, File::Path

       See IO::File and File::MkTemp, Apache::TempFile for different implementations of temporary file handling.

       See File::Tempdir for an alternative object-oriented wrapper for the "tempdir" function.

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs may be submitted through the RT bug tracker &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=File-
       Temp&gt; (or <a href="mailto:bug-File-Temp@rt.cpan.org">bug-File-Temp@rt.cpan.org</a> &lt;<a href="mailto:bug-File-Temp@rt.cpan.org">mailto:bug-File-Temp@rt.cpan.org</a>&gt;).

       There    is    also    a    mailing    list    available    for    users   of   this   distribution,   at
       &lt;<a href="http://lists.perl.org/list/cpan-workers.html">http://lists.perl.org/list/cpan-workers.html</a>&gt;.

       There is also an irc channel available for users of this distribution, at "#toolchain" on  "irc.perl.org"
       &lt;irc://irc.perl.org/#toolchain&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       Tim Jenness &lt;<a href="mailto:tjenness@cpan.org">tjenness@cpan.org</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Tim Jenness &lt;<a href="mailto:t.jenness@jach.hawaii.edu">t.jenness@jach.hawaii.edu</a>&gt;

       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   David Golden &lt;<a href="mailto:dagolden@cpan.org">dagolden@cpan.org</a>&gt;

       •   Slaven Rezic &lt;<a href="mailto:srezic@cpan.org">srezic@cpan.org</a>&gt;

       •   mohawk2 &lt;<a href="mailto:mohawk2@users.noreply.github.com">mohawk2@users.noreply.github.com</a>&gt;

       •   Roy Ivy III &lt;<a href="mailto:rivy.dev@gmail.com">rivy.dev@gmail.com</a>&gt;

       •   Peter Rabbitson &lt;<a href="mailto:ribasushi@cpan.org">ribasushi@cpan.org</a>&gt;

       •   Olivier Mengué &lt;<a href="mailto:dolmen@cpan.org">dolmen@cpan.org</a>&gt;

       •   Peter John Acklam &lt;<a href="mailto:pjacklam@online.no">pjacklam@online.no</a>&gt;

       •   Tim Gim Yee &lt;<a href="mailto:tim.gim.yee@gmail.com">tim.gim.yee@gmail.com</a>&gt;

       •   Nicolas R &lt;<a href="mailto:atoomic@cpan.org">atoomic@cpan.org</a>&gt;

       •   Brian Mowrey &lt;<a href="mailto:brian@drlabs.org">brian@drlabs.org</a>&gt;

       •   Dagfinn Ilmari Mannsåker &lt;<a href="mailto:ilmari@ilmari.org">ilmari@ilmari.org</a>&gt;

       •   David Steinbrunner &lt;<a href="mailto:dsteinbrunner@pobox.com">dsteinbrunner@pobox.com</a>&gt;

       •   Ed Avis &lt;<a href="mailto:eda@linux01.wcl.local">eda@linux01.wcl.local</a>&gt;

       •   Guillem Jover &lt;<a href="mailto:guillem@hadrons.org">guillem@hadrons.org</a>&gt;

       •   James E. Keenan &lt;<a href="mailto:jkeen@verizon.net">jkeen@verizon.net</a>&gt;

       •   Kevin Ryde &lt;<a href="mailto:user42@zip.com.au">user42@zip.com.au</a>&gt;

       •   Ben Tilly &lt;<a href="mailto:btilly@gmail.com">btilly@gmail.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This  software  is  copyright  (c) 2020 by Tim Jenness and the UK Particle Physics and Astronomy Research
       Council.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.40.1                                       2025-07-03                                  <u>File::<a href="../man3perl/Temp.3perl.html">Temp</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>