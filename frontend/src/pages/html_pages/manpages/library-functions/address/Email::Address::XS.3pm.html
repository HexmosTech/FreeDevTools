<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email::Address::XS - Parse and format RFC 5322 email addresses and groups</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libemail-address-xs-perl">libemail-address-xs-perl_1.05-1build5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Email::Address::XS - Parse and format RFC 5322 email addresses and groups

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Email::Address::XS;

         my $winstons_address = Email::Address::XS-&gt;new(phrase =&gt; 'Winston Smith', user =&gt; 'winston.smith', host =&gt; 'recdep.minitrue', comment =&gt; 'Records Department');
         print $winstons_address-&gt;address();
         # <a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>

         my $julias_address = Email::Address::XS-&gt;new('Julia', '<a href="mailto:julia@ficdep.minitrue">julia@ficdep.minitrue</a>');
         print $julias_address-&gt;format();
         # Julia &lt;<a href="mailto:julia@ficdep.minitrue">julia@ficdep.minitrue</a>&gt;

         my $users_address = Email::Address::XS-&gt;parse('user &lt;user@oceania&gt;');
         print $users_address-&gt;host();
         # oceania

         my $goldsteins_address = Email::Address::XS-&gt;parse_bare_address('<a href="mailto:goldstein@brotherhood.oceania">goldstein@brotherhood.oceania</a>');
         print $goldsteins_address-&gt;user();
         # goldstein

         my @addresses = Email::Address::XS-&gt;parse('"Winston Smith" &lt;<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>&gt; (Records Department), Julia &lt;<a href="mailto:julia@ficdep.minitrue">julia@ficdep.minitrue</a>&gt;');
         # ($winstons_address, $julias_address)

         use Email::Address::XS qw(format_email_addresses format_email_groups parse_email_addresses parse_email_groups);

         my $addresses_string = format_email_addresses($winstons_address, $julias_address, $users_address);
         # "Winston Smith" &lt;<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>&gt; (Records Department), Julia &lt;<a href="mailto:julia@ficdep.minitrue">julia@ficdep.minitrue</a>&gt;, user &lt;user@oceania&gt;

         my @addresses = map { $_-&gt;address() } parse_email_addresses($addresses_string);
         # ('<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>', '<a href="mailto:julia@ficdep.minitrue">julia@ficdep.minitrue</a>', 'user@oceania')

         my $groups_string = format_email_groups('Brotherhood' =&gt; [ $winstons_address, $julias_address ], undef() =&gt; [ $users_address ]);
         # Brotherhood: "Winston Smith" &lt;<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>&gt; (Records Department), Julia &lt;<a href="mailto:julia@ficdep.minitrue">julia@ficdep.minitrue</a>&gt;;, user &lt;user@oceania&gt;

         my @groups = parse_email_groups($groups_string);
         # ('Brotherhood' =&gt; [ $winstons_address, $julias_address ], undef() =&gt; [ $users_address ])

         use Email::Address::XS qw(compose_address split_address);

         my ($user, $host) = split_address('julia(outer party)@ficdep.minitrue');
         # ('julia', 'ficdep.minitrue')

         my $string = compose_address('charrington"@"shop', 'thought.police.oceania');
         # "charrington\"@\"shop"@thought.police.oceania

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module implements RFC 5322 &lt;https://tools.ietf.org/html/rfc5322&gt; parser and formatter of email
       addresses and groups. It parses an input string from email headers which contain a list of email
       addresses or a groups of email addresses (like From, To, Cc, Bcc, Reply-To, Sender, ...). Also it can
       generate a string value for those headers from a list of email addresses objects. Module is backward
       compatible with RFC 2822 &lt;https://tools.ietf.org/html/rfc2822&gt; and RFC 822
       &lt;https://tools.ietf.org/html/rfc822&gt;.

       Parser and formatter functionality is implemented in XS and uses shared code from Dovecot IMAP server.

       It is a drop-in replacement for the Email::Address module which has several security issues. E.g. issue
       CVE-2015-7686 (Algorithmic complexity vulnerability) &lt;https://cve.mitre.org/cgi-
       bin/cvename.cgi?name=CVE-2015-7686&gt;, which allows remote attackers to cause denial of service, is still
       present in Email::Address version 1.908.

       Email::Address::XS module was created to finally fix CVE-2015-7686.

       Existing applications that use Email::Address module could be easily switched to Email::Address::XS
       module. In most cases only changing "use Email::Address" to "use Email::Address::XS" and replacing every
       "Email::Address" occurrence with "Email::Address::XS" is sufficient.

       So unlike Email::Address, this module does not use regular expressions for parsing but instead native XS
       implementation parses input string sequentially according to RFC 5322 grammar.

       Additionally it has support also for named groups and so can be use instead of the Email::Address::List
       module.

       If you are looking for the module which provides object representation for the list of email addresses
       suitable for the MIME email headers, see Email::MIME::Header::AddressList.

   <b>EXPORT</b>
       None by default. Exportable functions are: "parse_email_addresses", "parse_email_groups",
       "format_email_addresses", "format_email_groups", "compose_address", "split_address".

   <b>Exportable</b> <b>Functions</b>
       format_email_addresses
             use Email::Address::XS qw(format_email_addresses);

             my $winstons_address = Email::Address::XS-&gt;new(phrase =&gt; 'Winston Smith', address =&gt; '<a href="mailto:winston@recdep.minitrue">winston@recdep.minitrue</a>');
             my $julias_address = Email::Address::XS-&gt;new(phrase =&gt; 'Julia', address =&gt; '<a href="mailto:julia@ficdep.minitrue">julia@ficdep.minitrue</a>');
             my @addresses = ($winstons_address, $julias_address);
             my $string = format_email_addresses(@addresses);
             print $string;
             # "Winston Smith" &lt;<a href="mailto:winston@recdep.minitrue">winston@recdep.minitrue</a>&gt;, Julia &lt;<a href="mailto:julia@ficdep.minitrue">julia@ficdep.minitrue</a>&gt;

           Takes a list of email address objects and returns one formatted string of those email addresses.

       format_email_groups
             use Email::Address::XS qw(format_email_groups);

             my $winstons_address = Email::Address::XS-&gt;new(phrase =&gt; 'Winston Smith', user =&gt; 'winston.smith', host =&gt; 'recdep.minitrue');
             my $julias_address = Email::Address::XS-&gt;new('Julia', '<a href="mailto:julia@ficdep.minitrue">julia@ficdep.minitrue</a>');
             my $users_address = Email::Address::XS-&gt;new(address =&gt; 'user@oceania');

             my $groups_string = format_email_groups('Brotherhood' =&gt; [ $winstons_address, $julias_address ], undef() =&gt; [ $users_address ]);
             print $groups_string;
             # Brotherhood: "Winston Smith" &lt;<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>&gt;, Julia &lt;<a href="mailto:julia@ficdep.minitrue">julia@ficdep.minitrue</a>&gt;;, user@oceania

             my $undisclosed_string = format_email_groups('undisclosed-recipients' =&gt; []);
             print $undisclosed_string;
             # undisclosed-recipients:;

           Like "format_email_addresses" but this method takes pairs which consist of a group display name and a
           reference to address list. If a group is not undef then address list is formatted inside named group.

       parse_email_addresses
             use Email::Address::XS qw(parse_email_addresses);

             my $string = '"Winston Smith" &lt;<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>&gt;, Julia &lt;<a href="mailto:julia@ficdep.minitrue">julia@ficdep.minitrue</a>&gt;, user@oceania';
             my @addresses = parse_email_addresses($string);
             # @addresses now contains three Email::Address::XS objects, one for each address

           Parses  an  input  string  and  returns  a list of Email::Address::XS objects. Optional second string
           argument specifies class name for blessing new objects.

       parse_email_groups
             use Email::Address::XS qw(parse_email_groups);

             my $string = 'Brotherhood: "Winston Smith" &lt;<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>&gt;, Julia &lt;<a href="mailto:julia@ficdep.minitrue">julia@ficdep.minitrue</a>&gt;;, user@oceania, undisclosed-recipients:;';
             my @groups = parse_email_groups($string);
             # @groups now contains list ('Brotherhood' =&gt; [ $winstons_object, $julias_object ], undef() =&gt; [ $users_object ], 'undisclosed-recipients' =&gt; [])

           Like "parse_email_addresses" but this function returns a list of pairs: a group display  name  and  a
           reference to a list of addresses which belongs to that named group.  An undef value for a group means
           that  a following list of addresses is not inside any named group. An output is in a same format as a
           input for the function "format_email_groups".  This function preserves order of groups and  does  not
           do any de-duplication or merging.

       compose_address
             use Email::Address::XS qw(compose_address);
             my $string_address = compose_address($user, $host);

           Takes an unescaped user part and unescaped host part of an address and returns escaped address.

           Available since version 1.01.

       split_address
             use Email::Address::XS qw(split_address);
             my ($user, $host) = split_address($string_address);

           Takes  an  escaped  address  and split it into pair of unescaped user part and unescaped host part of
           address. If splitting input address into these two parts is not possible then this  function  returns
           pair of undefs.

           Available since version 1.01.

   <b>Class</b> <b>Methods</b>
       new
             my $empty_address = Email::Address::XS-&gt;new();
             my $winstons_address = Email::Address::XS-&gt;new(phrase =&gt; 'Winston Smith', user =&gt; 'winston.smith', host =&gt; 'recdep.minitrue', comment =&gt; 'Records Department');
             my $julias_address = Email::Address::XS-&gt;new('Julia', '<a href="mailto:julia@ficdep.minitrue">julia@ficdep.minitrue</a>');
             my $users_address = Email::Address::XS-&gt;new(address =&gt; 'user@oceania');
             my $only_name = Email::Address::XS-&gt;new(phrase =&gt; 'Name');
             my $copy_of_winstons_address = Email::Address::XS-&gt;new(copy =&gt; $winstons_address);

           Constructs  and  returns  a  new  "Email::Address::XS" object. Takes named list of arguments: phrase,
           address, user, host, comment and copy.  An argument address takes precedence over user and host.

           When an argument copy is specified then it is expected an Email::Address::XS object and a cloned copy
           of that object is returned. All other parameters are ignored.

           Old syntax from the Email::Address module is supported too. Takes one to four  positional  arguments:
           phrase, address comment, and original string. Passing an argument original is deprecated, ignored and
           throws a warning.

       parse
             my $winstons_address = Email::Address::XS-&gt;parse('"Winston Smith" &lt;<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>&gt; (Records Department)');
             my @users_addresses = Email::Address::XS-&gt;parse('user1@oceania, user2@oceania');

           Parses  an  input  string  and  returns a list of an Email::Address::XS objects. Same as the function
           "parse_email_addresses" but this one is class method.

           In scalar context this function returns just first parsed object.  If more then one object was parsed
           then "is_valid" method on returned  object  returns  false.  If  no  object  was  parsed  then  empty
           Email::Address::XS object is returned.

           Prior to version 1.01 return value in scalar context is undef when no object was parsed.

       parse_bare_address
             my $winstons_address = Email::Address::XS-&gt;parse_bare_address('<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>');

           Parses  an  input  string  as  one bare email address (addr spec) which does not allow phrase part or
           angle brackets around email address and returns an Email::Address::XS object. It is  just  a  wrapper
           around "address" method. Method "is_valid" can be used to check if parsing was successful.

           Available since version 1.01.

   <b>Object</b> <b>Methods</b>
       format
             my $string = $address-&gt;format();

           Returns  formatted Email::Address::XS object as a string. This method throws a warning when "user" or
           "host" part of the email address is invalid or empty string.

       is_valid
             my $is_valid = $address-&gt;is_valid();

           Returns true if the parse function or method which created this  Email::Address::XS  object  had  not
           received  any  syntax error on input string and also that "user" and "host" part of the email address
           are not empty strings.

           Thus this function can be used for checking if Email::Address::XS  object  is  valid  before  calling
           "format" method on it.

           Available since version 1.01.

       phrase
             my $phrase = $address-&gt;phrase();
             $address-&gt;phrase('Winston Smith');

           Accessor and mutator for the phrase (display name).

       user
             my $user = $address-&gt;user();
             $address-&gt;user('winston.smith');

           Accessor and mutator for the unescaped user (local/mailbox) part of an address.

       host
             my $host = $address-&gt;host();
             $address-&gt;host('recdep.minitrue');

           Accessor and mutator for the unescaped host (domain) part of an address.

           Since  version 1.03 this method checks if setting a new value is syntactically valid. If not undef is
           set and returned.

       address
             my $string_address = $address-&gt;address();
             $address-&gt;address('<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>');

           Accessor and mutator for the escaped address (addr spec).

           Internally  this  module  stores  a  user  and  a  host  part  of  an  address  separately.  Function
           "compose_address"  is used for composing full address and function "split_address" for splitting into
           a user and a host parts. If splitting new address into these two parts  is  not  possible  then  this
           method returns undef and sets both parts to undef.

       comment
             my $comment = $address-&gt;comment();
             $address-&gt;comment('Records Department');

           Accessor  and  mutator  for  the  comment  which is formatted after an address. A comment can contain
           another nested comments in round brackets. When setting new comment this method check if brackets are
           balanced. If not undef is set and returned.

       name
             my $name = $address-&gt;name();

           This method tries to return a name which belongs to  the  address.  It  returns  either  "phrase"  or
           "comment"  or  "user" part of the address or empty string (first defined value in this order). But it
           never returns undef.

       as_string
             my $address = Email::Address::XS-&gt;new(phrase =&gt; 'Winston Smith', address =&gt; '<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>');
             my $stringified = $address-&gt;as_string();

           This method is used for object stringification.  It  returns  string  representation  of  object.  By
           default object is stringified to "format".

           Available since version 1.01.

       original
             my $address = Email::Address::XS-&gt;parse('(Winston) "Smith"   &lt;<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>&gt; (Minitrue)');
             my $original = $address-&gt;original();
             # (Winston) "Smith"   &lt;<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>&gt; (Minitrue)
             my $format = $address-&gt;format();
             # Smith &lt;<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>&gt; (Minitrue)

           This method returns original part of the string which was used for parsing current Email::Address::XS
           object. If object was not created by parsing input string, then this method returns undef.

           Note that "format" method does not have to return same original string.

           Available since version 1.01.

   <b>Overloaded</b> <b>Operators</b>
       stringify
             my $address = Email::Address::XS-&gt;new(phrase =&gt; 'Winston Smith', address =&gt; '<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>');
             print "Winston's address is $address.";
             # Winston's address is "Winston Smith" &lt;<a href="mailto:winston.smith@recdep.minitrue">winston.smith@recdep.minitrue</a>&gt;.

           Stringification is done by method "as_string".

   <b>Deprecated</b> <b>Functions</b> <b>and</b> <b>Variables</b>
       For  compatibility  with  the  Email::Address  module  there  are  defined  some deprecated functions and
       variables.  Do not use them in new code. Their usage throws warnings.

       Altering deprecated variable $Email::Address::XS::STRINGIFY changes method which is  called  for  objects
       stringification.

       Deprecated cache functions "purge_cache", "disable_cache" and "enable_cache" are noop and do nothing.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       RFC  822  &lt;https://tools.ietf.org/html/rfc822&gt;,  RFC 2822 &lt;https://tools.ietf.org/html/rfc2822&gt;, RFC 5322
       &lt;https://tools.ietf.org/html/rfc5322&gt;,         Email::MIME::Header::AddressList,          Email::Address,
       Email::Address::List, Email::AddressParser

</pre><h4><b>AUTHOR</b></h4><pre>
       Pali &lt;<a href="mailto:pali@cpan.org">pali@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2015-2018 by Pali &lt;<a href="mailto:pali@cpan.org">pali@cpan.org</a>&gt;

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself, either Perl version 5.6.0 or, at your option, any later version of Perl 5 you may have available.

       Dovecot parser is licensed under The MIT License and copyrighted by Dovecot authors.

perl v5.40.0                                       2024-10-20                            <u>Email::Address::<a href="../man3pm/XS.3pm.html">XS</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>