<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::Cidr - Compares IP4 addresses to CIDR specifications</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::Cidr - Compares IP4 addresses to CIDR specifications

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/cidr&gt;</b>
       Linking option: <u>-lbobcat</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Objects of the class <u>Cidr</u> can be used for testing whether IP4 Internet addresses belong to address ranges
       defined  by Classless Inter-Domain Routing (CIDR) address block specifications. CIDR blocks are specified
       as <u>a.b.c.d/m</u> where <u>a.b.c.d</u> are the four octets of a  dotted  decimal  IP4  address  specification  (e.g.,
       129.125.14.80)  and  <u>m</u> is a mask-size (ranging from 0 to 32) defining the number of most significant bits
       to remain as-is. The CIDR specification 129.125.14.80/16  defines  a  class  B  network,  with  addresses
       ranging from 129.125.0.0 to 129.125.255.255.

       The  mask  size  does not have to be a multiple of 8. E.g., when specifying 129.125.14.80/5 only the most
       significant 5 bits of the first octed are fixed, resulting in an address range ranging from 128.0.0.0  to
       135.255.255.255.

       CIDR  specifications passed to a <u>Cidr</u> object must be of the form <u>a.b.c.d</u> or <u>a.b.c.d/m</u>. If the mask is not
       specified a mask-size of 32 is used, effectively defining an address range  of  only  one  address.  Mask
       values of 0 are ignored.  Mask values of 0 are ignored by <u>Cidr</u> objects.

       When  specifying  CIDRs  on a stream, empty lines and comment lines (having a hash-character (#) as their
       first non-blank character) are ignored.  Non-empty lines must start with a CIDR  specification,  and  the
       <u>Cidr</u> object will ignore all information on a line trailing a CIDR specification.

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All  constructors,  members,  operators  and manipulators, mentioned in this man-page, are defined in the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       -

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
       o      <b>Cidr(std::string</b> <b>const</b> <b>&amp;cidrPattern)</b>:
              The <u>Cidr</u> object is initialized with a single CIDR specification.

       o      <b>Cidr(std::istream</b> <b>&amp;cidrStream)</b>:
              The <u>Cidr</u> object is initialized with CIDR specifications read from the <u>std::istream</u> <u>cidrStream</u>.

       Default, copy and move constructors and the copy and move assignment operators are available.

</pre><h4><b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       The return valuess of the accessors (i.e., the <u>const</u> members) are only  defined  following  a  successful
       match (see below, the <u>match</u> members).

       o      <b>std::string</b> <b>const</b> <b>&amp;address()</b> <b>const</b>:
              returns the address matching a CIDR.

       o      <b>std::string</b> <b>cidr()</b> <b>const</b>:
              returns the CIDR containing a specified address.

       o      <b>std::string</b> <b>first()</b> <b>const</b>:
              returns the first address of the range of addresses defined by the CIDR specification.

       o      <b>std::string</b> <b>last()</b> <b>const</b>:
              returns  the  last  address of the range of addresses defined by the CIDR specification. Note that
              <u>first,</u> <u>last</u> do not define an iterator range. The address returned by <u>last</u>  still  belongs  to  the
              CIDR-range.

       o      <b>bool</b> <b>match(std::istream</b> <b>&amp;in)</b>:
              The  value  <u>true</u>  is returned when an IP4 address found in the lines of <u>in</u> belongs to a CIDR range
              inspected by the <u>Cidr</u> object. The <u>match</u> function returns  <u>true</u>  at  the  first  matching  address.
              E.g., if a line contains the text

                  This is address 1.2.3.4 and this is 5.6.7.8

              and the CIDR specifications

                      5.1.1.1/8
                      1.2.1.1/16

              were provided to the <u>Cidr</u> object, then the object will report a match for <u>5.6.7.8</u>.

              As  soon as a match is found <u>match</u> returns <u>true</u>. If none of the addresses found in the lines of <u>in</u>
              matches any of the object’s CIDR specifications, <u>false</u> is returned.

       o      <b>std::string</b> <b>mask()</b> <b>const</b>:
              returns the mask used by the <u>CIDR</u> specification.

       o      <b>bool</b> <b>match(std::string</b> <b>const</b> <b>&amp;line)</b>:
              The value <u>true</u> is returned when an IP4 address found in <u>line</u> belongs to a CIDR range inspected  by
              the <u>Cidr</u> object. The <u>match</u> function returns <u>true</u> at the first matching address.

              If  none  of the addresses found in <u>line</u> matches any of the object’s CIDR specifications, <u>false</u> is
              returned.

       o      <b>void</b> <b>setCidr(std::istream</b> <b>&amp;cidrStream)</b>:
              A new set of CIDR specification is loaded into the <u>Cidr</u> object, reading  the  specifications  from
              <u>cidrStream</u>.

       o      <b>void</b> <b>setCidr(std::string</b> <b>const</b> <b>&amp;cidrPattern)</b>:
              A  new  CIDR  specification  is  loaded  into  the  <u>Cidr</u>  object, using the specification found in
              <u>cidrPattern</u>.  The <u>Cidr</u> object is initialized with a single CIDR specification which must be of the
              form <u>a.b.c.d</u> or <u>a.b.c.d/m</u>. If the mask is not specified a mask-size of  32  is  used,  effectively
              defining an address range of only one address. Mask values of 0 are ignored.

       o      <b>void</b> <b>swap(Cidr</b> <b>&amp;other)</b>:
              The current and <u>other</u> object are swapped.

</pre><h4><b>STATIC</b> <b>MEMBERS</b></h4><pre>
       o      <b>size_t</b> <b>dotted2binary(std::string</b> <b>const</b> <b>&amp;dotted)</b>:
              Converts "a.b.c.d" to a 32-bits value

       o      <b>std::string</b> <b>binary2dotted(size_t</b> <b>binary)</b>:
              Converts a 32-bits value to a dotted decimal IP4 address

</pre><h4><b>EXAMPLE</b></h4><pre>
       #include &lt;fstream&gt;
       #include &lt;iostream&gt;

       #include &lt;bobcat/exception&gt;
       #ifdef BOBCAT
           #include &lt;bobcat/cidr&gt;
       #else
           #include "cidr"
       #endif

       using namespace std;
       using namespace FBB;

       int main(int argc, char **argv)
       {
           enum Spec
           {
               NONE,
               FILE,
               CIN
           };

           Spec spec = CIN;
           ifstream in;

           if (argc &gt; 1)
           {
               Exception::open(in, argv[1]);       // file containing cidr-specs
               spec = FILE;
           }

           while (true)
           {
               string cidrSpec;
               if (spec == CIN)
               {
                   cout &lt;&lt; "Specify cidr (empty to quit): ";
                   if (!getline(cin, cidrSpec) || cidrSpec.empty())
                       break;
               }
               try
               {
                   Cidr cidr;

                   switch (spec)
                   {
                       case NONE:
                       return 0;

                       case FILE:
                           cidr.setCidr(in);
                           spec = NONE;
                       break;

                       case CIN:
                           cidr.setCidr(cidrSpec);
                   }

                   while (true)
                   {
                       cout &lt;&lt; "Specify address to test (empty to " &lt;&lt;
                           (spec == CIN ? "respec. CIDR" : "quit") &lt;&lt; "): ";
                       string address;
                       if (!getline(cin, address) || address.empty())
                           break;

                       if (!cidr.match(address))
                       {
                           cout &lt;&lt; "Address " &lt;&lt; address &lt;&lt; " not in ";
                           if (spec == CIN)
                               cout &lt;&lt; cidrSpec &lt;&lt; ’\n’;
                           else
                               cout &lt;&lt; "specifications in " &lt;&lt; argv[1] &lt;&lt; ’\n’;
                       }
                       else
                           cout &lt;&lt; "Address " &lt;&lt; address &lt;&lt; " in " &lt;&lt; cidr.cidr() &lt;&lt;
                                                                               "\n"
                               "Lowest address: " &lt;&lt; cidr.first() &lt;&lt; "\n"
                               "Highest address: " &lt;&lt; cidr.last() &lt;&lt; "\n"
                               "CIDR mask: " &lt;&lt; cidr.mask() &lt;&lt; "\n"
                               "Address: " &lt;&lt; cidr.address() &lt;&lt; ’\n’;
                   }
               }
               catch (exception const &amp;err)
               {
                   cout &lt;&lt; "Oops... " &lt;&lt; err.what() &lt;&lt; "\n"
                           "Try again...\n";
               }
           }
       }

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/cidr</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7)

</pre><h4><b>BUGS</b></h4><pre>
       Members of <u>Cidr</u> use static data. The current implementation of <u>Cidr</u> is therefore not thread-safe.

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>:  debian package containing the static library, headers, manual pages, and developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                                 <u>FBB::<a href="../man3bobcat/Cidr.3bobcat.html">Cidr</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>