<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Config::INI::Writer - a subclassable .ini-file emitter</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libconfig-ini-perl">libconfig-ini-perl_0.029-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Config::INI::Writer - a subclassable .ini-file emitter

</pre><h4><b>VERSION</b></h4><pre>
       version 0.029

</pre><h4><b>SYNOPSIS</b></h4><pre>
       If $hash contains:

         {
           '_'  =&gt; { admin =&gt; 'rjbs' },
           rjbs =&gt; {
             awesome =&gt; 'yes',
             height  =&gt; q{5' 10"},
           },
           mj   =&gt; {
             awesome =&gt; 'totally',
             height  =&gt; '23"',
           },
         }

       Then when your program contains:

         Config::INI::Writer-&gt;write_file($hash, 'family.ini');

       <u>family.ini</u> will contains:

         admin = rjbs

         [rjbs]
         awesome = yes
         height = 5' 10"

         [mj]
         awesome = totally
         height = 23"

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Config::INI::Writer is <u>yet</u> <u>another</u> config module implementing <u>yet</u> <u>another</u> slightly different take on the
       undeniably easy to read ".ini" file format.  Its default behavior is quite similar to that of
       Config::Tiny, on which it is based.

       The chief difference is that Config::INI::Writer is designed to be subclassed to allow for side-effects
       and self-reconfiguration to occur during the course of reading its input.

</pre><h4><b>PERL</b> <b>VERSION</b></h4><pre>
       This library should run on perls released even a long time ago.  It should work on any version of perl
       released in the last five years.

       Although it may work on older versions of perl, no guarantee is made that the minimum required version
       will not be increased.  The version may be increased for any reason, and there is no promise that patches
       will be accepted to lower the minimum required perl.

</pre><h4><b>METHODS</b> <b>FOR</b> <b>WRITING</b> <b>CONFIG</b></h4><pre>
       There are three writer methods, "write_string", "write_file", and "write_handle".  The first two are
       implemented in terms of the third.  It iterates over a collection of data, emitting lines to the
       filehandle as it goes.  The lines are generated by events produced by iterating over the data.  Those
       events are detailed below in the "METHODS FOR SUBCLASSING" section.

       The given data should be a hashref of hashrefs:

         {
           section_name_1 =&gt; { prop1 =&gt; 'value1', prop2 =&gt; 'value2' },
           section_name_2 =&gt; ...
         }

       ...or an arrayref of section name and arrayref pairs:

         [
           section_name_1 =&gt; [ prop1 =&gt; 'value1', prop2 =&gt; 'value2' ],
           section_name_2 =&gt; ...
         ]

       ...or a combination of those:

         [
           section_name_1 =&gt; { prop1 =&gt; 'value1', prop2 =&gt; 'value2' },
           section_name_2 =&gt; [ prop3 =&gt; 'value3', prop4 =&gt; 'value4' ],
           section_name_3 =&gt; ...
         ]

       All the reader methods throw an exception when they encounter an error.

   <b>write_file</b>
         Config::INI::Writer-&gt;write_file($input, $filename);

       This method writes out the configuration represented by $data to the file named by $filename.  If a file
       by that name exists, it is overwritten.

       This method will either succeed or raise an exception.  (Its return value is not defined.)

   <b>write_string</b>
         my $string = Config::INI::Writer-&gt;write_string($input);

       This method returns a string containing the INI content describing the given data.

   <b>write_handle</b>
         Config::INI::Writer-&gt;write_handle($input, $handle);

       This method writes the data in $data to the IO::Handle-like object in $handle.  This method should either
       succeed or throw an exception.

</pre><h4><b>METHODS</b> <b>FOR</b> <b>SUBCLASSING</b></h4><pre>
       These are the methods you need to understand and possibly change when subclassing Config::INI::Reader to
       handle a different format of input.

   <b>preprocess_input</b>
         my $processed_input = $writer-&gt;preprocess_input($input_data);

       This method is called to ensure that the data given to the "write_*" methods are in a canonical form for
       processing and emitting.  The default implementation converts hashrefs to arrayrefs and, if the input is
       a hashref, moves the "starting_section" to the beginning of the produced arrayref.

       In other words, given:

         {
           section_1 =&gt; { a =&gt; 1, b =&gt; 2 },
           section_2 =&gt; { c =&gt; 3, c =&gt; 4 },
           _         =&gt; { d =&gt; 5, e =&gt; 6 },
         }

       This method will return:

         [
           _         =&gt; [ d =&gt; 5, e =&gt; 6 ],
           section_2 =&gt; [ c =&gt; 3, c =&gt; 4 ],
           section_1 =&gt; [ a =&gt; 1, b =&gt; 2 ],
         ]

       The only guaranteed ordering when hashes are provided as input is that the starting section will appear
       first.

   <b>validate_section_name</b>
         Carp::croak "section name contains illegal character"
           if not $writer-&gt;is_valid_section_name($name);

   <b>is_valid_property_name</b>
         Carp::croak "property name contains illegal character"
           if not $writer-&gt;is_valid_property_name($name);

   <b>is_valid_value</b>
         Carp::croak "value contains illegal character"
           if not $writer-&gt;is_valid_value($name);

   <b>validate_input</b>
         $writer-&gt;validate_input($input);

       This method is called on the input data once they've been preprocessed by "preprocess_input".

       It ensures that the processed input is structurally sound before beginning to output it.  For example, it
       ensures that no property is ever assigned more than once in a given section.

       This method either raises an exception or it doesn't.

   <b>change_section</b>
         $writer-&gt;change_section($section_name);

       This method is called each time a new section is going to be written out.  If the same section appears
       twice in a row in the input, this method will still be called between instances of that section.

       In other words, given this input:

         [
           section_1 =&gt; [ a =&gt; 1 ],
           section_1 =&gt; [ b =&gt; 2 ],
         ]

       "change_section" will be called twice: once before the first "section_1" and once before the second
       "section_1".

   <b>current_section</b>
         $writer-&gt;current_section

       This method returns the section currently being written out.

   <b>finish_section</b>
         $writer-&gt;finish_section

       This method is called after all of the current section's properties have been written.

   <b>done_sections</b>
         my @names = $writer-&gt;done_sections;

       This method returns a list of all sections that have been written out and finished.  The fact that a
       section name is returned by "done_sections" does not mean that there will be no more data for that
       section, but that at least one entire set of data has been written out for it.

   <b>stringify_section</b>
         my $string = $writer-&gt;stringify_section($props);

       This method returns a string assigning all the properties set in the given data.  This still will include
       the section header, if needed.  (The only case in which it is not needed is when the
       "explicit_starting_header" method returns false, no other sections have been done, and the section about
       to be stringified is the "starting_section".

       This method is implemented in terms of "stringify_section_header" and "stringify_section_data".

   <b>stringify_section_data</b>
         my $string = $writer-&gt;stringify_section_data($props)

       This method returns a string containing a series of lines, each containing a value assignment for the
       given properties.

   <b>stringify_value_assignment</b>
         my $string = $writer-&gt;stringify_value_assignment($name =&gt; $value);

       This method returns a string that assigns a value to a named property.  If the value is undefined, an
       empty string is returned.

   <b>stringify_value</b>
         my $string = $writer-&gt;stringify_value($value);

       This method returns the string that will represent the given value in a property assignment.

   <b>stringify_section_header</b>
         my $string = $writer-&gt;stringify_section_header($section_name);

       This method returns the string (a line) that represents the given section name.  Basically, this returns:

         [section_name]

   <b>starting_section</b>
       This method returns the name of the starting section.  If this section appears first (as it will, when
       given a hashref as input) and if "explicit_starting_header" returns false, its section header can be
       omitted.

   <b>explicit_starting_header</b>
       If this method returns true (which it does <u>not</u>, by default), then the section header for the starting
       section will be emitted, even if it appears first.

   <b>new</b>
         my $reader = Config::INI::Writer-&gt;new;

       This method returns a new writer.  This generally does not need to be called by anything but the various
       "write_*" methods, which create a writer object only ephemerally.

</pre><h4><b>AUTHOR</b></h4><pre>
       Ricardo Signes &lt;<a href="mailto:cpan@semiotic.systems">cpan@semiotic.systems</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2007 by Ricardo Signes.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.36.0                                       2023-01-21                           <u>Config::INI::<a href="../man3pm/Writer.3pm.html">Writer</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>