<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Config::INI::Reader - a subclassable .ini-file parser</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libconfig-ini-perl">libconfig-ini-perl_0.029-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Config::INI::Reader - a subclassable .ini-file parser

</pre><h4><b>VERSION</b></h4><pre>
       version 0.029

</pre><h4><b>SYNOPSIS</b></h4><pre>
       If <u>family.ini</u> contains:

         admin = rjbs

         [rjbs]
         awesome = yes
         height = 5' 10"

         [mj]
         awesome = totally
         height = 23"

       Then when your program contains:

         my $hash = Config::INI::Reader-&gt;read_file('family.ini');

       $hash will contain:

         {
           '_'  =&gt; { admin =&gt; 'rjbs' },
           rjbs =&gt; {
             awesome =&gt; 'yes',
             height  =&gt; q{5' 10"},
           },
           mj   =&gt; {
             awesome =&gt; 'totally',
             height  =&gt; '23"',
           },
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Config::INI::Reader is <u>yet</u> <u>another</u> config module implementing <u>yet</u> <u>another</u> slightly different take on the
       undeniably easy to read ".ini" file format.  Its default behavior is quite similar to that of
       Config::Tiny, on which it is based.

       The chief difference is that Config::INI::Reader is designed to be subclassed to allow for side-effects
       and self-reconfiguration to occur during the course of reading its input.

</pre><h4><b>PERL</b> <b>VERSION</b></h4><pre>
       This library should run on perls released even a long time ago.  It should work on any version of perl
       released in the last five years.

       Although it may work on older versions of perl, no guarantee is made that the minimum required version
       will not be increased.  The version may be increased for any reason, and there is no promise that patches
       will be accepted to lower the minimum required perl.

</pre><h4><b>METHODS</b> <b>FOR</b> <b>READING</b> <b>CONFIG</b></h4><pre>
       These methods are all that most users will need: they read configuration from a source of input, then
       they return the data extracted from that input.  There are three reader methods, "read_string",
       "read_file", and "read_handle".  The first two are implemented in terms of the third.  It iterates over
       lines in a file, calling methods on the reader when events occur.  Those events are detailed below in the
       "METHODS FOR SUBCLASSING" section.

       All of the reader methods return an unblessed reference to a hash.

       All throw an exception when they encounter an error.

   <b>read_file</b>
         my $hash_ref = Config::INI::Reader-&gt;read_file($filename);

       Given a filename, this method returns a hashref of the contents of that file.

   <b>read_string</b>
         my $hash_ref = Config::INI::Reader-&gt;read_string($string);

       Given a string, this method returns a hashref of the contents of that string.

   <b>read_handle</b>
         my $hash_ref = Config::INI::Reader-&gt;read_handle($io_handle);

       Given an IO::Handle, this method returns a hashref of the contents of that handle.

</pre><h4><b>METHODS</b> <b>FOR</b> <b>SUBCLASSING</b></h4><pre>
       These are the methods you need to understand and possibly change when subclassing Config::INI::Reader to
       handle a different format of input.

   <b>current_section</b>
         my $section_name = $reader-&gt;current_section;

       This method returns the name of the current section.  If no section has yet been set, it returns the
       result of calling the "starting_section" method.

   <b>parse_section_header</b>
         my $name = $reader-&gt;parse_section_header($line, $handle);

       Given a line of input, this method decides whether the line is a section-change declaration.  If it is,
       it returns the name of the section to which to change.  If the line is not a section-change, the method
       returns false.

   <b>change_section</b>
         $reader-&gt;change_section($section_name);

       This method is called whenever a section change occurs in the file.

       The default implementation is to change the current section into which data is being read and to
       initialize that section to an empty hashref.

   <b>parse_value_assignment</b>
         my ($name, $value) = $reader-&gt;parse_value_assignment($line, $handle);

       Given a line of input, this method decides whether the line is a property value assignment.  If it is, it
       returns the name of the property and the value being assigned to it.  If the line is not a property
       assignment, the method returns false.

   <b>set_value</b>
         $reader-&gt;set_value($name, $value);

       This method is called whenever an assignment occurs in the file.  The default behavior is to change the
       value of the named property to the given value.

   <b>starting_section</b>
         my $section = Config::INI::Reader-&gt;starting_section;

       This method returns the name of the starting section.  The default is: "_"

   <b>can_ignore</b>
         do_nothing if $reader-&gt;can_ignore($line, $handle)

       This method returns true if the given line of input is safe to ignore.  The default implementation
       ignores lines that contain only whitespace or comments.

       This is run <u>after</u> preprocess_line.

   <b>preprocess_line</b>
         $reader-&gt;preprocess_line(\$line);

       This method is called to preprocess each line after it's read but before it's parsed.  The default
       implementation just strips inline comments.  Alterations to the line are made in place.

   <b>handle_unparsed_line</b>
         $reader-&gt;handle_unparsed_line( $line, $handle );

       This method is called when the reader encounters a line that doesn't look like anything it recognizes.
       By default, it throws an exception.

   <b>finalize</b>
         $reader-&gt;finalize;

       This method is called when the reader has finished reading in every line of the file.

   <b>new</b>
         my $reader = Config::INI::Reader-&gt;new;

       This method returns a new reader.  This generally does not need to be called by anything but the various
       "read_*" methods, which create a reader object only ephemerally.

</pre><h4><b>ORIGIN</b></h4><pre>
       Originaly derived from Config::Tiny, by Adam Kennedy.

</pre><h4><b>AUTHOR</b></h4><pre>
       Ricardo Signes &lt;<a href="mailto:cpan@semiotic.systems">cpan@semiotic.systems</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2007 by Ricardo Signes.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.36.0                                       2023-01-21                           <u>Config::INI::<a href="../man3pm/Reader.3pm.html">Reader</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>