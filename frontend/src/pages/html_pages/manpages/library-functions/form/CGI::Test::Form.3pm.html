<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGI::Test::Form - Querying interface to CGI form widgets</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcgi-test-perl">libcgi-test-perl_1.111-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CGI::Test::Form - Querying interface to CGI form widgets

</pre><h4><b>SYNOPSIS</b></h4><pre>
        my $form = $page-&gt;forms-&gt;[0];       # first form in CGI::Test::Page

        #
        # Querying interface, to access form widgets
        #

        my @buttons = $form-&gt;button_list;   # -&gt;buttons would give list ref
        my $radio_listref = $form-&gt;radios;  # -&gt;radios_list would give list

        my $passwd_widget = $form-&gt;input_by_name("password");
        my ($login, $passwd) = $form-&gt;input_by_name(qw(login password));

        my @menus = $form-&gt;widgets_matching(sub { $_[0]-&gt;is_menu });
        my @menus = $form-&gt;menu_list;       # same as line above

        my $rg = $form-&gt;radio_groups;       # a CGI::Test::Form::Group or undef

        #
        # &lt;FORM&gt; attributes, as defined by HTML 4.0
        #

        my $encoding = $form-&gt;enctype;
        my $action = $form-&gt;action;
        my $method = $form-&gt;method;
        my $name = $form-&gt;name;
        my $accept = $form-&gt;accept;
        my $accept_charset = $form-&gt;accept_charset;

        #
        # Miscellaneous
        #

        # Low-level, direct calls normally not needed
        $form-&gt;reset;
        my $new_page = $form-&gt;submit;

        # Very low-level access
        my $html_tree = $form-&gt;tree;        # HTML::Element form tree
        my $page = $form-&gt;page;             # Page containing this form

        #
        # Garbage collection -- needed to break circular references
        #

        $form-&gt;delete;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The "CGI::Test::Form" class provides an interface to the content of the CGI forms.  Instances are
       automatically created by "CGI::Test" when it analyzes an HTML output from a GET/POST request and
       encounters such beasts.

       This class is really the basis of the "CGI::Test" testing abilities: it provides the necessary routines
       to query the CGI widgets present in the form: buttons, input areas, menus, etc...  Queries can be made by
       type, and by name.  There is also an interface to specifically access groupped widgets like checkboxes
       and radio buttons.

       All widgets returned by the queries are polymorphic objects, heirs of "CGI::Test::Form::Widget".  If the
       querying interface can be compared to the human eye, enabling you to locate a particular graphical item
       on the browser screen, the widget interface can be compared to the mouse and keyboard, allowing you to
       interact with the located graphical components.  Please refer to CGI::Test::Form::Widget for interaction
       details.

       Apart from the widget querying interface, this class also offers a few services to other "CGI::Test"
       components, like handling of <u>reset</u> and <u>submit</u> actions, which need not be used directly in practice.

       Finally, it provides inspection of the &lt;FORM&gt; tag attributes (encoding type, action, etc...) and, if you
       really need it, to the HTML tree of the all &lt;FORM&gt; content.  This interface is based on the
       "HTML::Element" class, which represents a tree node.  The tree is shared with other "CGI::Test"
       components, it is not a private copy.  See HTML::Element if you are not already familiar with it.

       If memory is a problem, you must be aware that circular references are used almost everywhere within
       "CGI::Test".  Because Perl's garbage collector cannot reclaim objects that are part of such a reference
       loop, you must explicitely call the <u>delete</u> method on "CGI::Test::Form".  Simply forgetting about the
       reference to that object is not enough.  Don't bother with it if your regression test scripts die
       quickly.

</pre><h4><b>INTERFACE</b></h4><pre>
       The interface is mostly a querying interface.  Most of the routines return widget objects, via lists or
       list references.  See CGI::Test::Form::Widget for details about the interface provided by widget objects,
       and the classification.

       The order of the widgets returned lists is the same as the order the widgets appear in the HTML
       representation.

   <b>Type</b> <b>Querying</b> <b>Interface</b>
       There are two groups or routines: one group returns expanded lists, the other returns list references.
       They are listed in the table below.

       The <u>Item</u> <u>Polymorphic</u> <u>Type</u> column refers to the polymorphic dynamic type of items held within the list:
       each item is guaranteed to at least be of that type, but can be a descendant.  Types are listed in the
       abridged form, and you have to prepend the string "CGI::Test::Form::" in front of them to get the real
       type.

        Expanded List  List Reference  Item Polymorphic Type
        -------------  --------------  ----------------------
        button_list    buttons         Widget::Button
        checkbox_list  checkboxes      Widget::Box::Check
        hidden_list    hidden          Widget::Hidden
        input_list     inputs          Widget::Input
        menu_list      menus           Widget::Menu
        radio_list     radios          Widget::Box::Radio
        submit_list    submits         Widget::Button::Submit
        widget_list    widgets         Widget

       For instance:

           my @widgets = @{$form-&gt;widgets};     # heavy style
           my @widgets = $form-&gt;widget_list;    # light style

       A given widget may appear in several lists, i.e.the above do not form a partition over the widget set.
       For instance, a submit button would appear in the "widget_list" (which lists <u>all</u> widgets), in the
       "button_list" and in the "submit_list".

   <b>Name</b> <b>Querying</b> <b>Interface</b>
       Those routine take a name or a list of names, and return the widgets whose parameter name is <b>exactly</b> the
       given name (string comparison).  You may query all widgets, or a particular class, like all buttons, or
       all input fields.

       There are two groups of routines:

       •   One  group allows for multiple name queries, and returns a list of widgets, one entry for each listed
           name.  Some widgets like radio buttons may have multiple instances bearing the same name, and in that
           case only one is returned.  When querying for one name, you are allowed to use scalar context:

               my  @hidden   = $form-&gt;hidden_by_name("foo", "bar");
               my ($context) = $form-&gt;hidden_by_name("context");
               my  $context  = $form-&gt;hidden_by_name("context");

           When no widget (of that particular type) bearing the requested name is found, "undef" is returned for
           that particular slot, so don't blindly make method calls on each returned value.

           We shall call that group of query routines the <b>by-name</b> group.

       •   The other group allows for a single name query, but returns a  list  of  all  the  widgets  (of  some
           particular type when not querying the whole widget list) bearing that name.

               my @hidden = $form-&gt;hidden_named("foo");

           Don't assume that only radios and checkboxes can have multiple instances bearing the same name.

           We shall call that group of query routines the <b>all-named</b> group.

       The  available  routines  are listed in the table below.  Note that <u>by-name</u> queries are singular, because
       there is at most one returned widget  per  name  asked,  whereas  <u>all-named</u>  queries  are  plural,  where
       possible.

       The  <u>Item</u>  <u>Polymorphic</u>  <u>Type</u> column refers to the polymorphic dynamic type of items held within the list:
       each defined item is guaranteed to at least be of that type, but can be a descendant.  Types  are  listed
       in  the abridged form, and you have to prepend the string "CGI::Test::Form::" in front of them to get the
       real type.

        By-Name Queries   All-Named Queries  Item Polymorphic Type
        ----------------  -----------------  ----------------------
        button_by_name    buttons_named      Widget::Button
        checkbox_by_name  checkboxes_named   Widget::Box::Check
        hidden_by_name    hidden_named       Widget::Hidden
        input_by_name     inputs_named       Widget::Input
        menu_by_name      menus_named        Widget::Menu
        radio_by_name     radios_named       Widget::Box::Radio
        submit_by_name    submits_named      Widget::Button::Submit
        widget_by_name    widgets_named      Widget

   <b>Match</b> <b>Querying</b> <b>Interface</b>
       This is a general interface, which invokes a matching callback on each widget of a  particular  category.
       The signature of the matching routines is:

           my @matching = $form-&gt;widgets_matching(sub {code}, $arg);

       and the callback is invoked as:

           callback($widget, $arg);

       A  widget  is kept if, and only if, the callback returns true.  Be sure to write your callback so that is
       only uses calls that apply to the particular widget.  When you know you're matching on menu widgets,  you
       can  call  menu-specific  features,  but  should  you use that same callback for buttons, you would get a
       runtime error.

       Each matching routine returns a list of matching widgets.  Using the  $arg  parameter  is  optional,  and
       should be avoided unless you have no other choice, so as to be as stateless as possible.

       The  following  table lists the available matching routines, along with the polymorphic widget type to be
       expected in the callback.  As usual, you must prepend the string  "CGI::Test::Form::"  to  get  the  real
       type.

        Matching Routine     Item Polymorphic Type
        -------------------  ---------------------
        buttons_matching     Widget::Button
        checkboxes_matching  Widget::Box::Check
        hidden_matching      Widget::Hidden
        inputs_matching      Widget::Input
        menus_matching       Widget::Menu
        radios_matching      Widget::Box::Radio
        submits_matching     Widget::Button::Submit
        widgets_matching     Widget

       For instance:

           my @menus = $form-&gt;widgets_matching(sub { $_[0]-&gt;is_menu });
           my @color = $form-&gt;widgets_matching(
               sub { $_[0]-&gt;is_menu &amp;&amp; $_[0]-&gt;name eq "color" }
           );

       is an inefficient way of saying:

           my @menus = $form-&gt;menu_list;
           my @color = $form-&gt;menus_matching(sub { $_[0]-&gt;name eq "color" });

       and the latter can further be rewritten as:

           my @color = $form-&gt;menus_named("color");

   <b>Form</b> <b>Interface</b>
       This provides an interface to get at the attributes of the &lt;FORM&gt; tag.  For instance:

           my $enctype = $form-&gt;enctype;

       to get at the encoding type of that particular form.  The following attributes are available:

           accept
           accept_charset
           action
           enctype
           method
           name

       as defined by HTML 4.0.

   <b>Group</b> <b>Querying</b> <b>Interface</b>
       There  are two kinds of widgets that are architecturally groupped, meaning more that one instance of that
       widget can bear the same name: radio buttons and checkboxes (although you may have  a  single  standalone
       checkbox).

       All  radio buttons and checkboxes defined in a form are automatically inserted into a group of their own,
       which is an instance of the "CGI::Test::Form::Group" class.  This class contains all the  defined  groups
       for a particular kind.  The routines:

           checkbox_groups
           radio_groups

       give  you  access to the "CGI::Test::Form::Group" container.  Both routines may return "undef" when there
       is no checkbox or radio button in the form.  See CGI::Test::Form::Group for its querying interface.

   <b>Memory</b> <b>Cleanup</b>
       You <b>must</b> call the <u>delete</u> method to break the circular references if you wish to dispose of the object.

   <b>Internal</b> <b>Interface</b>
       The following routines are available internally:

       reset
           Reset the form state, restoring all the controls to the value they had upon entry.

       submit
           Submit the form, returning a "CGI::Test::Page" reply.

</pre><h4><b>AUTHORS</b></h4><pre>
       The original author is Raphael Manfredi.

       Steven Hilton was long time maintainer of this module.

       Current maintainer is Alexander Tokarev <u>&lt;<a href="mailto:tokarev@cpan.org">tokarev@cpan.org</a>&gt;</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>CGI::<a href="../man3/Test.3.html">Test</a></b>(3),      <b>CGI::Test::Form::<a href="../man3/Widget.3.html">Widget</a></b>(3),       <b>CGI::Test::Form::<a href="../man3/Group.3.html">Group</a></b>(3),       <b>CGI::Test::<a href="../man3/Page.3.html">Page</a></b>(3),
       <b>HTML::<a href="../man3/Element.3.html">Element</a></b>(3).

perl v5.34.0                                       2022-06-10                               <u>CGI::Test::<a href="../man3pm/Form.3pm.html">Form</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>