<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WWW::Form::UrlEncoded - parser and builder for application/x-www-form-urlencoded</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libwww-form-urlencoded-perl">libwww-form-urlencoded-perl_0.26-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       WWW::Form::UrlEncoded - parser and builder for application/x-www-form-urlencoded

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use WWW::Form::UrlEncoded qw/parse_urlencoded build_urlencoded/;

           my $query_string = "foo=bar&amp;baz=param";
           my @params = parse_urlencoded($query_string);
           # ('foo','bar','baz','param')

           my $query_string = build_urlencoded('foo','bar','baz','param');
           # "foo=bar&amp;baz=param";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       WWW::Form::UrlEncoded provides application/x-www-form-urlencoded parser and builder.  This module aims to
       have compatibility with other CPAN modules like HTTP::Body's urlencoded parser.

       This module try to use WWW::Form::UrlEncoded::XS by default and fail to it, use WWW::Form::UrlEncoded::PP
       instead

   <b>Parser</b> <b>rules</b>
       WWW::Form::UrlEncoded parsed string in this rule.

       1. Split application/x-www-form-urlencoded payload by "&amp;" (U+0026) or ";" (U+003B)
       2. Ready empty array to store "name" and "value"
       3. For each divided string, apply next steps.
           1. If first character of string is ' ' (U+0020 SPACE), remove it.
           2. If string has "=", let <b>name</b> be substring from start to first "=", but excluding first "=", and
           remains to be <b>value</b>. If there is no strings after first "=", <b>value</b> to be empty string "". If first
           "=" is first character of the string, let <b>key</b> be empty string "". If string does not have any "=",
           all of the string to be <b>key</b> and <b>value</b> to be empty string "".
           3. replace all "+" (U+002B) with ' ' (U+0020 SPACE).
           4. unescape <b>name</b> and <b>value</b>. push them to the array.
       4. return the array.

   <b>Test</b> <b>data</b>
         'a=b&amp;c=d'     =&gt; ["a","b","c","d"]
         'a=b;c=d'     =&gt; ["a","b","c","d"]
         'a=1&amp;b=2;c=3' =&gt; ["a","1","b","2","c","3"]
         'a==b&amp;c==d'   =&gt; ["a","=b","c","=d"]
         'a=b&amp; c=d'    =&gt; ["a","b","c","d"]
         'a=b; c=d'    =&gt; ["a","b","c","d"]
         'a=b; c =d'   =&gt; ["a","b","c ","d"]
         'a=b;c= d '   =&gt; ["a","b","c"," d "]
         'a=b&amp;+c=d'    =&gt; ["a","b"," c","d"]
         'a=b&amp;+c+=d'   =&gt; ["a","b"," c ","d"]
         'a=b&amp;c=+d+'   =&gt; ["a","b","c"," d "]
         'a=b&amp;%20c=d'  =&gt; ["a","b"," c","d"]
         'a=b&amp;%20c%20=d' =&gt; ["a","b"," c ","d"]
         'a=b&amp;c=%20d%20' =&gt; ["a","b","c"," d "]
         'a&amp;c=d'       =&gt; ["a","","c","d"]
         'a=b&amp;=d'      =&gt; ["a","b","","d"]
         'a=b&amp;='       =&gt; ["a","b","",""]
         '&amp;'           =&gt; ["","","",""]
         '='           =&gt; ["",""]
         ''            =&gt; []

</pre><h4><b>FUNCTION</b></h4><pre>
       @param = parse_urlencoded($str:String)
           parse $str and return Array that contains key-value pairs.

       $param:ArrayRef = parse_urlencoded_arrayref($str:String)
           parse $str and return ArrayRef that contains key-value pairs.

       $string = build_urlencoded(@param)
       $string = build_urlencoded(@param, $delim)
       $string = build_urlencoded(\@param)
       $string = build_urlencoded(\@param, $delim)
       $string = build_urlencoded(\%param)
       $string = build_urlencoded(\%param, $delim)
           build urlencoded string from <b>param</b>. build_urlencoded accepts arrayref and hashref values.

             build_urlencoded( foo =&gt; 1, foo =&gt; 2);
             build_urlencoded( foo =&gt; [1,2] );
             build_urlencoded( [ foo =&gt; 1, foo =&gt; 2 ] );
             build_urlencoded( [foo =&gt; [1,2]] );
             build_urlencoded( {foo =&gt; [1,2]} );

           If $delim parameter is passed, this function use it instead of using "&amp;".

       $string = build_urlencoded_utf8(...)
           This function is almost same as "build_urlencoded". build_urlencoded_utf8 call "utf8::encode" for all
           parameters.

</pre><h4><b>ENVIRONMENT</b> <b>VALUE</b></h4><pre>
       â€¢   WWW_FORM_URLENCODED_PP

           If true, WWW::Form::UrlEncoded force to load WWW::Form::UrlEncoded::PP.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       CPAN already has some application/x-www-form-urlencoded parser modules like these.

       URL::Encode
       URL::Encode::XS
       Text::QueryString

       They  does  not  fully  compatible with WWW::Form::UrlEncoded. Handling of empty key-value and supporting
       separator characters are different.

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright (C) Masahiro Nagano.

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

</pre><h4><b>AUTHOR</b></h4><pre>
       Masahiro Nagano &lt;<a href="mailto:kazeburo@gmail.com">kazeburo@gmail.com</a>&gt;

perl v5.36.0                                       2022-12-04                         <u>WWW::Form::<a href="../man3pm/UrlEncoded.3pm.html">UrlEncoded</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>