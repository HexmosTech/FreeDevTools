<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::CCS::Nd - N-dimensional sparse pseudo-PDLs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpdl-ccs-perl">libpdl-ccs-perl_1.24.1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::CCS::Nd - N-dimensional sparse pseudo-PDLs

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use PDL;
        use PDL::CCS::Nd;

        ##---------------------------------------------------------------------
        ## Example data

        $missing = 0;                                   ##-- missing values
        $dense   = random(@dims);                       ##-- densely encoded pdl
        $dense-&gt;where(random(@dims)&lt;=0.95) .= $missing; ##   ... made sparse

        $whichND = $dense-&gt;whichND;                     ##-- which values are present?
        $nzvals  = $dense-&gt;indexND($whichND);           ##-- ... and what are they?

        ##---------------------------------------------------------------------
        ## Constructors etc.

        $ccs = PDL::CCS:Nd-&gt;newFromDense($dense,%args);           ##-- construct from dense matrix
        $ccs = PDL::CCS:Nd-&gt;newFromWhich($whichND,$nzvals,%args); ##-- construct from index+value pairs

        $ccs = $dense-&gt;toccs();                ##-- ensure PDL::CCS::Nd-hood
        $ccs = $ccs-&gt;toccs();                  ##-- ... analogous to PDL::topdl()
        $ccs = $dense-&gt;toccs($missing,$flags); ##-- ... with optional arguments

        $ccs2 = $ccs-&gt;copy();                  ##-- copy constructor
        $ccs2 = $ccs-&gt;copyShallow();           ##-- shallow copy, mainly for internal use
        $ccs2 = $ccs-&gt;shadow(%args);           ##-- flexible copy method, for internal use

        ##---------------------------------------------------------------------
        ## Maintenance &amp; Decoding

        $ccs = $ccs-&gt;recode();                 ##-- remove missing values from stored VALS
        $ccs = $ccs-&gt;sortwhich();              ##-- internal use only

        $dense2 = $ccs-&gt;decode();              ##-- extract to a (new) dense matrix

        $dense2 = $ccs-&gt;todense();             ##-- ensure dense storage
        $dense2 = $dense2-&gt;todense();          ##-- ... analogous to PDL::topdl()

        ##---------------------------------------------------------------------
        ## PDL API: Basic Properties

        ##---------------------------------------
        ## Type conversion &amp; Checking
        $ccs2 = $ccs-&gt;convert($type);
        $ccs2 = $ccs-&gt;byte;
        $ccs2 = $ccs-&gt;short;
        $ccs2 = $ccs-&gt;ushort;
        $ccs2 = $ccs-&gt;long;
        $ccs2 = $ccs-&gt;longlong;
        $ccs2 = $ccs-&gt;float;
        $ccs2 = $ccs-&gt;double;

        ##---------------------------------------
        ## Dimensions
        @dims  = $ccs-&gt;dims();
        $ndims = $ccs-&gt;ndims();
        $dim   = $ccs-&gt;dim($dimi);
        $nelem = $ccs-&gt;nelem;
        $bool  = $ccs-&gt;isnull;
        $bool  = $ccs-&gt;isempty;

        ##---------------------------------------
        ## Inplace &amp; Dataflow
        $ccs  = $ccs-&gt;inplace();
        $bool = $ccs-&gt;is_inplace;
        $bool = $ccs-&gt;set_inplace($bool);
        $ccs  = $ccs-&gt;sever;

        ##---------------------------------------
        ## Bad Value Handling

        $bool = $ccs-&gt;bad_is_missing();          ##-- treat BAD values as missing?
        $bool = $ccs-&gt;bad_is_missing($bool);
        $ccs  = $ccs-&gt;badmissing();              ##-- ... a la inplace()

        $bool = $ccs-&gt;nan_is_missing();          ##-- treat NaN values as missing?
        $bool = $ccs-&gt;nan_is_missing($bool);
        $ccs  = $ccs-&gt;nanmissing();              ##-- ... a la inplace()

        $ccs2 = $ccs-&gt;setnantobad();
        $ccs2 = $ccs-&gt;setbadtonan();
        $ccs2 = $ccs-&gt;setbadtoval($val);
        $ccs2 = $ccs-&gt;setvaltobad($val);

        ##---------------------------------------------------------------------
        ## PDL API: Dimension Shuffling

        $ccs2 = $ccs-&gt;dummy($vdimi,$size);
        $ccs2 = $ccs-&gt;reorder(@vdims);
        $ccs2 = $ccs-&gt;xchg($vdim1,$vdim2);
        $ccs2 = $ccs-&gt;mv($vdimFrom,$vdimTo);
        $ccs2 = $ccs-&gt;transpose();

        ##---------------------------------------------------------------------
        ## PDL API: Indexing

        $nzi   = $ccs-&gt;indexNDi($ndi);              ##-- guts for indexing methods
        $ndi   = $ccs-&gt;n2oned($ndi);                ##-- returns 1d pseudo-index for $ccs

        $ivals = $ccs-&gt;indexND($ndi);
        $ivals = $ccs-&gt;index2d($xi,$yi);
        $ivals = $ccs-&gt;index($flati);               ##-- buggy: no pseudo-threading!
        $ccs2  = $ccs-&gt;dice_axis($vaxis,$vaxis_ix);

        $nzi   = $ccs-&gt;xindex1d($xi);               ##-- nz-indices along 0th dimension
        $nzi   = $ccs-&gt;pxindex1d($dimi,$xi);        ##-- ... or any dimension, using ptr()
        $nzi   = $ccs-&gt;xindex2d($xi,$yi);           ##-- ... or for Cartesian product on 2d matrix

        $ccs2  = $ccs-&gt;xsubset1d($xi);              ##-- subset along 0th dimension
        $ccs2  = $ccs-&gt;pxsubset1d($dimi,$xi);       ##-- ... or any dimension, using ptr()
        $ccs2  = $ccs-&gt;xsubset2d($xi,$yi);          ##-- ... or for Cartesian product on 2d matrix

        $whichND = $ccs-&gt;whichND();
        $vals    = $ccs-&gt;whichVals();               ##-- like $ccs-&gt;indexND($ccs-&gt;whichND), but faster
        $which   = $ccs-&gt;which()

        $value = $ccs-&gt;at(@index);
        $ccs   = $ccs-&gt;set(@index,$value);

        ##---------------------------------------------------------------------
        ## PDL API: Ufuncs

        $ccs2 = $ccs-&gt;prodover;
        $ccs2 = $ccs-&gt;dprodover;
        $ccs2 = $ccs-&gt;sumover;
        $ccs2 = $ccs-&gt;dsumover;
        $ccs2 = $ccs-&gt;andover;
        $ccs2 = $ccs-&gt;orover;
        $ccs2 = $ccs-&gt;bandover;
        $ccs2 = $ccs-&gt;borover;
        $ccs2 = $ccs-&gt;maximum;
        $ccs2 = $ccs-&gt;minimum;
        $ccs2 = $ccs-&gt;maximum_ind; ##-- -1 indicates "missing" value is maximal
        $ccs2 = $ccs-&gt;minimum_ind; ##-- -1 indicates "missing" value is minimal
        $ccs2 = $ccs-&gt;nbadover;
        $ccs2 = $ccs-&gt;ngoodover;
        $ccs2 = $ccs-&gt;nnz;

        $sclr = $ccs-&gt;prod;
        $sclr = $ccs-&gt;dprod;
        $sclr = $ccs-&gt;sum;
        $sclr = $ccs-&gt;dsum;
        $sclr = $ccs-&gt;nbad;
        $sclr = $ccs-&gt;ngood;
        $sclr = $ccs-&gt;min;
        $sclr = $ccs-&gt;max;
        $bool = $ccs-&gt;any;
        $bool = $ccs-&gt;all;

        ##---------------------------------------------------------------------
        ## PDL API: Unary Operations         (Overloaded)

        $ccs2 = $ccs-&gt;bitnot;                $ccs2 = ~$ccs;
        $ccs2 = $ccs-&gt;not;                   $ccs2 = !$ccs;
        $ccs2 = $ccs-&gt;sqrt;
        $ccs2 = $ccs-&gt;abs;
        $ccs2 = $ccs-&gt;sin;
        $ccs2 = $ccs-&gt;cos;
        $ccs2 = $ccs-&gt;exp;
        $ccs2 = $ccs-&gt;log;
        $ccs2 = $ccs-&gt;log10;

        ##---------------------------------------------------------------------
        ## PDL API: Binary Operations (missing is annihilator)
        ##  + $b may be a perl scalar, a dense PDL, or a PDL::CCS::Nd object
        ##  + $c is always returned as a PDL::CCS::Nd ojbect

        ##---------------------------------------
        ## Arithmetic
        $c = $ccs-&gt;plus($b);         $c = $ccs1 +  $b;
        $c = $ccs-&gt;minus($b);        $c = $ccs1 -  $b;
        $c = $ccs-&gt;mult($b);         $c = $ccs1 *  $b;
        $c = $ccs-&gt;divide($b);       $c = $ccs1 /  $b;
        $c = $ccs-&gt;modulo($b);       $c = $ccs1 %  $b;
        $c = $ccs-&gt;power($b);        $c = $ccs1 ** $b;

        ##---------------------------------------
        ## Comparisons
        $c = $ccs-&gt;gt($b);           $c = ($ccs  &gt;  $b);
        $c = $ccs-&gt;ge($b);           $c = ($ccs  &gt;= $b);
        $c = $ccs-&gt;lt($b);           $c = ($ccs  &lt;  $b);
        $c = $ccs-&gt;le($b);           $c = ($ccs  &lt;= $b);
        $c = $ccs-&gt;eq($b);           $c = ($ccs  == $b);
        $c = $ccs-&gt;ne($b);           $c = ($ccs  != $b);
        $c = $ccs-&gt;spaceship($b);    $c = ($ccs &lt;=&gt; $b);

        ##---------------------------------------
        ## Bitwise Operations
        $c = $ccs-&gt;and2($b);          $c = ($ccs &amp;  $b);
        $c = $ccs-&gt;or2($b);           $c = ($ccs |  $b);
        $c = $ccs-&gt;xor($b);           $c = ($ccs ^  $b);
        $c = $ccs-&gt;shiftleft($b);     $c = ($ccs &lt;&lt; $b);
        $c = $ccs-&gt;shiftright($b);    $c = ($ccs &gt;&gt; $b);

        ##---------------------------------------
        ## Matrix Operations
        $c = $ccs-&gt;inner($b);
        $c = $ccs-&gt;matmult($b);       $c = $ccs x $b;
        $c_dense = $ccs-&gt;matmult2d_sdd($b_dense, $zc);
        $c_dense = $ccs-&gt;matmult2d_zdd($b_dense);

        $vnorm = $ccs-&gt;vnorm($pdimi);
        $vcos  = $ccs-&gt;vcos_zdd($b_dense);
        $vcos  = $ccs-&gt;vcos_pzd($b_ccs);

        ##---------------------------------------
        ## Other Operations
        $ccs-&gt;rassgn($b);             $ccs .= $b;
        $str = $ccs-&gt;string();        $str  = "$ccs";

        ##---------------------------------------------------------------------
        ## Indexing Utilities

        ##---------------------------------------------------------------------
        ## Low-Level Object Access

        $num_v_per_p = $ccs-&gt;_ccs_nvperp;                                  ##-- num virtual / num physical
        $pdims    = $ccs-&gt;pdims;            $vdims    = $ccs-&gt;vdims;       ##-- physical|virtual dim pdl
        $nelem    = $ccs-&gt;nelem_p;          $nelem    = $ccs-&gt;nelem_v;     ##-- physical|virtual nelem
        $nstored  = $ccs-&gt;nstored_p;        $nstored  = $ccs-&gt;nstored_v;   ##-- physical|virtual Nnz+1
        $nmissing = $ccs-&gt;nmissing_p;       $nmissing = $ccs-&gt;nmissing_v;  ##-- physical|virtual nelem-Nnz

        $ccs = $ccs-&gt;make_physically_indexed();        ##-- ensure all dimensions are physically indexed

        $bool = $ccs-&gt;allmissing();                    ##-- are all values missing?

        $missing_val = $ccs-&gt;missing;                  ##-- get missing value
        $missing_val = $ccs-&gt;missing($missing_val);    ##-- set missing value
        $ccs         = $ccs-&gt;_missing($missing_val);   ##-- ... returning the object

        $whichND_phys = $ccs-&gt;_whichND();              ##-- get/set physical indices
        $whichND_phys = $ccs-&gt;_whichND($whichND_phys);

        $nzvals_phys  = $ccs-&gt;_nzvals();               ##-- get/set physically indexed values
        $nzvals_phys  = $ccs-&gt;_nzvals($vals_phys);

        $vals_phys    = $ccs-&gt;_vals();                 ##-- get/set physically indexed values
        $vals_phys    = $ccs-&gt;_vals($vals_phys);

        $bool         = $ccs-&gt;hasptr($pdimi);          ##-- check for cached Harwell-Boeing pointer
        ($ptr,$ptrix) = $ccs-&gt;ptr($pdimi);             ##-- ... get one, caching for later use
        ($ptr,$ptrix) = $ccs-&gt;getptr($pdimi);          ##-- ... compute one, regardless of cache
        ($ptr,$ptrix) = $ccs-&gt;setptr($pdimi,$p,$pix);  ##-- ... set a cached pointer
        $ccs-&gt;clearptr($pdimi);                        ##-- ... clear a cached pointer
        $ccs-&gt;clearptrs();                             ##-- ... clear all cached pointers

        $flags = $ccs-&gt;flags();                        ##-- get/set object-local flags
        $flags = $ccs-&gt;flags($flags);

        $density = $ccs-&gt;density;                      ##-- get object density
        $crate   = $ccs-&gt;compressionRate;              ##-- get compression rate

</pre><h4><b>DESCRIPTION</b></h4><pre>
       PDL::CCS::Nd provides an object-oriented implementation of sparse N-dimensional vectors &amp; matrices using
       a set of low-level PDLs to encode non-missing values.  Currently, only a portion of the PDL API is
       implemented.

</pre><h4><b>GLOBALS</b></h4><pre>
       The following package-global variables are defined:

   <b>Block</b> <b>Size</b> <b>Constants</b>
        $BINOP_BLOCKSIZE_MIN = 1;
        $BINOP_BLOCKSIZE_MAX = 0;

       Minimum (maximum) block size for block-wise incremental computation of binary operations.  Zero or undef
       indicates no minimum (maximum).

   <b>Object</b> <b>Structure</b>
       PDL::CCS::Nd object are implemented as perl ARRAY-references.  For more intuitive access to object
       components, the following package-global variables can be used as array indices to access internal object
       structure:

       $PDIMS
           Indexes a pdl(long,$NPdims) of physically indexed dimension sizes:

            $ccs-&gt;[$PDIMS]-&gt;at($pdim_i) == $dimSize_i

       $VDIMS
           Indexes a pdl(long,$NVdims) of "virtual" dimension sizes:

            $ccs-&gt;[$VDIMS]-&gt;at($vdim_i) == / -$vdimSize_i    if $vdim_i is a dummy dimension
                                           \  $pdim_i        otherwise

           The  $VDIMS  piddle  is used for dimension-shuffling transformations such as <b>xchg()</b> and <b>reorder()</b>, as
           well as for <b>dummy()</b>.

       $WHICH
           Indexes a pdl(long,$NPdims,$Nnz) of the "physical indices" of all non-missing values in the non-dummy
           dimensions of the corresponding dense matrix.  Vectors in $WHICH  are  guaranteed  to  be  sorted  in
           lexicographic  order.   If  your  $missing  value  is zero, and if your <b>qsortvec()</b> function works, it
           should be the case that:

            all( $ccs-&gt;[$WHICH] == $dense-&gt;whichND-&gt;qsortvec )

           A "physically indexed dimension" is just a dimension corresponding tp a single column of  the  $WHICH
           pdl, whereas a dummy dimension does not correspond to any physically indexed dimension.

       $VALS
           Indexes  a  vector pdl($valType, $Nnz+1) of all values in the sparse matrix, where $Nnz is the number
           of non-missing values in the sparse matrix.  Non-final elements of the $VALS piddle  are  interpreted
           as the values of the corresponding indices in the $WHICH piddle:

            all( $ccs-&gt;[$VALS]-&gt;slice("0:-2") == $dense-&gt;indexND($ccs-&gt;[$WHICH]) )

           The  final  element of the $VALS piddle is referred to as "$missing", and represents the value of all
           elements of the dense physical matrix whose indices are not explicitly listed in the $WHICH piddle:

            all( $ccs-&gt;[$VALS]-&gt;slice("-1") == $dense-&gt;flat-&gt;index(which(!$dense)) )

       $PTRS
           Indexes an array of arrays containing Harwell-Boeing "pointer" piddle  pairs  for  the  corresponding
           physically  indexed  dimension.   For a physically indexed dimension $d of size $N, $ccs-&gt;[$PTRS][$d]
           (if      it      exists)      is      a      pair      [$ptr,$ptrix]       as       returned       by
           PDL::CCS::Utils::ccs_encode_pointers($WHICH,$N), which are such that:

           $ptr
               $ptr  is a pdl(long,$N+1) containing the offsets in $ptrix corresponding to the first non-missing
               value in the dimension $d.  For all $i, 0 &lt;= $i &lt; $N, $ptr($i) contains the index  of  the  first
               non-missing  value  (if  any)  from column $i of $dense(...,N,...)  encoded in the $WHICH piddle.
               $ptr($N+1) contains the number of physically indexed cells in the $WHICH piddle.

           $ptrix
               Is an index piddle into <b><a href="../man1/dim.1.html">dim</a></b>(1) of $WHICH rsp. <b><a href="../man0/dim.0.html">dim</a></b>(0) of $VALS whose key positions  correspond  to
               the offsets listed in $ptr.  The point here is that:

                $WHICH-&gt;dice_axis(1,$ptrix)

               is  guaranteed to be primarily sorted along the pointer dimension $d, and stably sorted along all
               other dimensions, e.g. should be identical to:

                $WHICH-&gt;mv($d,0)-&gt;qsortvec-&gt;mv(0,$d)

       $FLAGS
           Indexes a perl scalar containing some object-local flags.  See "Object Flags" for details.

       $USER
           Indexes the first unused position in the object array.  If you derive a class from PDL::CCS::Nd,  you
           should use this position to place any new object-local data.

   <b>Object</b> <b>Flags</b>
       The following object-local constants are defined as bitmask flags:

       $CCSND_BAD_IS_MISSING
           Bitmask of the "bad-is-missing" flag.  See the <b>bad_is_missing()</b> method.

       $CCSND_NAN_IS_MISSING
           Bitmask of the "NaN-is-missing" flag.  See the <b>nan_is_missing()</b> method.

       $CCSND_INPLACE
           Bitmask of the "inplace" flag.  See PDL::Core for details.

       $CCSND_FLAGS_DEFAULT
           Default flags for new objects.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Constructors,</b> <b>etc.</b>
       $class_or_obj-&gt;newFromDense($dense,$missing,$flags)
             Signature ($class_or_obj; dense(N1,...,NNdims); missing(); int flags)

           Class  method. Create and return a new PDL::CCS::Nd object from a dense N-dimensional PDL $dense.  If
           specified, $missing is used as the value for "missing" elements, and $flags are  used  to  initialize
           the object-local flags.

           $missing defaults to BAD if the bad flag of $dense is set, otherwise $missing defaults to zero.

       $ccs-&gt;fromDense($dense,$missing,$flags)
             Signature ($ccs; dense(N1,...,NNdims); missing(); int flags)

           Object method.  Populate a sparse matrix object from a dense piddle $dense.  See <b>newFromDense()</b>.

       $class_or_obj-&gt;newFromWhich($whichND,$nzvals,%options)
             Signature ($class_or_obj; int whichND(Ndims,Nnz); nzvals(Nnz+1); %options)

           Class  method.  Create  and  return  a new PDL::CCS::Nd object from a set of indices $whichND of non-
           missing elements in a (hypothetical) dense piddle and a vector $nzvals of the  corresponding  values.
           Known %options:

             sorted  =&gt; $bool,    ##-- if true, $whichND is assumed to be pre-sorted
             steal   =&gt; $bool,    ##-- if true, $whichND and $nzvals are used literally (formerly implied 'sorted')
                                  ##    + in this case, $nzvals should really be: $nzvals-&gt;append($missing)
             pdims   =&gt; $pdims,   ##-- physical dimension list; default guessed from $whichND (alias: 'dims')
             vdims   =&gt; $vdims,   ##-- virtual dims (default: sequence($nPhysDims)); alias: 'xdims'
             missing =&gt; $missing, ##-- default: BAD if $nzvals-&gt;badflag, 0 otherwise
             flags   =&gt; $flags    ##-- flags

       $ccs-&gt;fromWhich($whichND,$nzvals,%options)
           Object method.  Guts for <b>newFromWhich()</b>.

       $a-&gt;toccs($missing,$flags)
           Wrapper for <b>newFromDense()</b>.  Return a PDL::CCS::Nd object for any piddle or perl scalar $a.  If $a is
           already a PDL::CCS::Nd object, just returns $a.  This method gets exported into the PDL namespace for
           ease of use.

       $ccs = $ccs-&gt;<b>copy()</b>
           Full copy constructor.

       $ccs2 = $ccs-&gt;<b>copyShallow()</b>
           Shallow copy constructor, used e.g. by dimension-shuffling transformations.  Copied components:

            $PDIMS, @$PTRS, @{$PTRS-&gt;[*]}, $FLAGS

           Referenced components:

            $VDIMS, $WHICH, $VALS,  $PTRS-&gt;[*][*]

       $ccs2 = $ccs1-&gt;shadow(%args)
           Flexible constructor for computed PDL::CCS::Nd objects.  Known %args:

             to    =&gt; $ccs2,    ##-- default: new
             pdims =&gt; $pdims2,  ##-- default: $pdims1-&gt;pdl  (alias: 'dims')
             vdims =&gt; $vdims2,  ##-- default: $vdims1-&gt;pdl  (alias: 'xdims')
             ptrs  =&gt; \@ptrs2,  ##-- default: []
             which =&gt; $which2,  ##-- default: undef
             vals  =&gt; $vals2,   ##-- default: undef
             flags =&gt; $flags,   ##-- default: $flags1

   <b>Maintenance</b> <b>&amp;</b> <b>Decoding</b>
       $ccs = $ccs-&gt;<b>recode()</b>
           Recodes the PDL::CCS::Nd object, removing any missing values from its $VALS piddle.

       $ccs = $ccs-&gt;<b>sortwhich()</b>
           Lexicographically sorts $ccs-&gt;[$WHICH], altering $VALS accordingly.  Clears $PTRS.

       $dense = $ccs-&gt;<b>decode()</b>
       $dense = $ccs-&gt;decode($dense)
           Decode  a PDL::CCS::Nd object to a dense piddle.  Dummy dimensions in $ccs should be created as dummy
           dimensions in $dense.

       $dense = $a-&gt;<b>todense()</b>
           Ensures that $a is not a PDL::CCS::Nd by wrapping <b>decode()</b>.  For PDLs or perl scalars,  just  returns
           $a.

   <b>PDL</b> <b>API:</b> <b>Basic</b> <b>Properties</b>
       The following basic PDL API methods are implemented and/or wrapped for PDL::CCS::Nd objects:

       Type Checking &amp; Conversion
           type, convert, byte, short, ushort, long, double

           Type-checking and conversion routines are passed on to the $VALS sub-piddle.

       Dimension Access
           dims, dim, getdim, ndims, getndims, nelem, isnull, isempty

           Note  that  <b>nelem()</b>  returns the number of hypothetically addressable cells -- the number of cells in
           the corresponding dense matrix, rather than the number of non-missing elements actually stored.

       Inplace Operations
           set_inplace($bool), <b>is_inplace()</b>, <b>inplace()</b>

       Dataflow
           sever

       Bad Value Handling
           setnantobad, setbadtonan, setbadtoval, setvaltobad

           See also the <b>bad_is_missing()</b> and <b>nan_is_missing()</b> methods, below.

   <b>PDL</b> <b>API:</b> <b>Dimension</b> <b>Shuffling</b>
       The following  dimension-shuffling  methods  are  supported,  and  should  be  compatible  to  their  PDL
       counterparts:

       dummy($vdimi)
       dummy($vdimi, $size)
           Insert a "virtual" dummy dimension of size $size at dimension index $vdimi.

       reorder(@vdim_list)
           Reorder dimensions according to @vdim_list.

       xchg($vdim1,$vdim2)
           Exchange two dimensions.

       mv($vdimFrom, $vdimTo)
           Move a dimension to another position, shoving remaining dimensions out of the way to make room.

       <b>transpose()</b>
           Always copies, unlike <b>xchg()</b>.  Also unlike <b>xchg()</b>, works for 1d row-vectors.

   <b>PDL</b> <b>API:</b> <b>Indexing</b>
       indexNDi($ndi)
             Signature: ($ccs; int ndi(NVdims,Nind); int [o]nzi(Nind))

           Guts  for  indexing methods.  Given an N-dimensional index piddle $ndi, return a 1d index vector into
           $VALS for the corresponding values.  Missing values are returned in $nzi as $Nnz == $ccs-&gt;_nnz_p;

           Uses <b>PDL::VectorValues::vsearchvec()</b> internally, so expect O(Ndims * log(Nnz)) complexity.   Although
           the theoretical complexity is tough to beat, this method could be made much faster in the usual (read
           "sparse") case by an intelligent use of $PTRS if and when available.

       indexND($ndi)
       index2d($xi,$yi)
           Should  be  mostly  compatible  to  the  PDL  functions  of  the same names, but without any boundary
           handling.

       index($flati)
           Implicitly flattens the source pdl.  This ought to be fixed.

       dice_axis($axis_v, $axisi)
           Should be compatible with the PDL function of the same name.  Returns a new PDL::CCS::Nd object which
           should participate in dataflow.

       xindex1d($xi)
           Get non-missing indices for any element of $xi along 0th dimension; $xi must be sorted  in  ascending
           order.

       pxindex1d($dimi,$xi)
           Get  non-missing indices for any element of $xi along physically indexed dimension $dimi, using "ptr"
           in ptr($dimi).  $xi must be sorted in ascending order.

       xindex2d($xi,$yi)
           Get non-missing indices for any element in Cartesian product ($xi x $yi) for 2d sparse  matrix.   $xi
           and $yi must be sorted in ascending order.

       xsubset1d($xi)
           Returns  a  subset  object  similar  to dice_axis(0,$x), but without renumbering of indices along the
           diced dimension; $xi must be sorted in ascending order.

       pxsubset1d($dimi,$xi)
           Returns a subset object similar to dice_axis($dimi,$x), but without renumbering of indices along  the
           diced dimension; $xi must be sorted in ascending order.

       xsubset2d($xi,$yi)
           Returns  a  subset object similar to indexND( $xi-&gt;slice("*1,")-&gt;cat($yi)-&gt;<b><a href="../man2/clump.2.html">clump</a></b>(2)-&gt;xchg(0,1) ), but
           without renumbering of indices; $xi and $yi must be sorted in ascending order.

       n2oned($ndi)
           Returns a 1d pseudo-index, used for implementation of <b>which()</b>, etc.

       <b>whichND()</b>
           Should behave mostly like the PDL function of the same name.

           Just returns the literal $WHICH piddle if possible: beware of dataflow!  Indices are  NOT  guaranteed
           to  be returned in any surface-logical order, although physically indexed dimensions should be sorted
           in physical-lexicographic order.

       <b>whichVals()</b>
           Returns $VALS indexed to correspond to the indices returned by <b>whichND()</b>.  The  only  reason  to  use
           <b>whichND()</b>  and  <b>whichVals()</b> rather than $WHICH and $VALS would be a need for physical representations
           of dummy dimension indices: try to avoid it if you can.

       <b>which()</b>
           As for the builtin PDL function.

       at(@index)
           Return a perl scalar corresponding to the Nd index @index.

       set(@index, $value)
           Set a non-missing value at index @index to $value.  <b>barf()</b>s if @index points to a missing value.

   <b>Ufuncs</b>
       The following functions from PDL::Ufunc are implemented, and ought to  handle  missing  values  correctly
       (i.e. as their dense counterparts would):

        prodover
        prod
        dprodover
        dprod
        sumover
        sum
        dsumover
        dsum
        andover
        orover
        bandover
        borover
        maximum
        maximum_ind ##-- goofy if "missing" value is maximal
        max
        minimum
        minimum_ind ##-- goofy if "missing" value is minimal
        min
        nbadover
        nbad
        ngoodover
        ngood
        nnz
        any
        all

       Some Ufuncs are still unimplemented. see PDL::CCS::Ufunc for details.

   <b>Unary</b> <b>Operations</b>
       The following unary operations are supported:

        FUNCTION   OVERLOADS
        bitnot      ~
        not         !
        sqrt
        abs
        sin
        cos
        exp
        log
        log10

       Note that any pointwise unary operation can be performed directly on the $VALS piddle.  You can wrap such
       an operation MY_UNARY_OP on piddles into a PDL::CCS::Nd method using the idiom:

        package PDL::CCS::Nd;
        *MY_UNARY_OP = _unary_op('MY_UNARY_OP', PDL-&gt;can('MY_UNARY_OP'));

       Note  also  that unary operations may change the "missing" value associated with the sparse matrix.  This
       is easily seen to be the Right Way To Do It if you consider unary "not"  over  a  very  sparse  (say  99%
       missing)  binary-valued  matrix:  is is much easier and more efficient to alter only the 1% of physically
       stored (non-missing) values as well as the missing value than to generate a  new  matrix  with  99%  non-
       missing values, assuming $missing==0.

   <b>Binary</b> <b>Operations</b>
       A  number of basic binary operations on PDL::CCS::Nd operations are supported, which will produce correct
       results only under the assumption that "missing" values $missing are annihilators for  the  operation  in
       question.  For example, if we want to compute:

        $c = OP($a,$b)

       for  a binary operation OP on PDL::CCS::Nd objects $a and $b, the current implementation will produce the
       correct result for $c only if for all values $av in $a and $bv in $b:

        OP($av,$b-&gt;missing) == OP($a-&gt;missing,$b-&gt;missing) , and
        OP($a-&gt;missing,$bv) == OP($a-&gt;missing,$b-&gt;missing)

       This is true in general for OP==\&amp;mult and $missing==0, but not e.g. for OP==\&amp;plus and $missing==0.   It
       should  always  hold  for  $missing==BAD  (except  in  the  case  of assignment, which is a funny kind of
       operation anyways).

       Currently, the only way to ensure that all values are computed correctly in the general case  is  for  $a
       and $b to contain exactly the same physically indexed values, which rather defeats the purposes of sparse
       storage,  particularly  if  implicit  pseudo-threading  is involved (because then we would likely wind up
       instantiating -- or at least inspecting -- the entire dense matrix).  Future  implementations  may  relax
       these restrictions somewhat.

       The following binary operations are implemented:

       Arithmetic Operations
            FUNCTION     OVERLOADS
            plus          +
            minus         -
            mult          *
            divide        /
            modulo        %
            power         **

       Comparisons
            FUNCTION     OVERLOADS
            gt            &gt;
            ge            &gt;=
            lt            &lt;
            le            &lt;=
            eq            ==
            ne            !=
            spaceship     &lt;=&gt;

       Bitwise Operations
            FUNCTION     OVERLOADS
            and2          &amp;
            or2           |
            xor           ^
            shiftleft     &lt;&lt;
            shiftright    &gt;&gt;

       Matrix Operations
            FUNCTION     OVERLOADS
            inner        (none)
            matmult       x

       Other Operations
            FUNCTION     OVERLOADS
            rassgn        .=
            string        ""

       All  supported  binary operation functions obey the PDL input calling conventions (i.e. they all accept a
       third argument $swap), and  delegate  computation  to  the  underlying  PDL  functions.   Note  that  the
       PDL::CCS::Nd  methods currently do <b>NOT</b> support a third "output" argument.  To wrap a new binary operation
       MY_BINOP into a PDL::CCS::Nd method, you can use the following idiom:

        package PDL::CCS::Nd;
        *MY_BINOP = _ccsnd_binary_op_mia('MY_BINOP', PDL-&gt;can('MY_BINOP'));

       The low-level alignment of physically indexed values for binary operations is performed by  the  function
       <b>PDL::CCS::ccs_binop_align_block_mia()</b>.   Computation  is  performed block-wise at the perl level to avoid
       over- rsp. underflow of the space requirements for the output PDL.

   <b>Low-Level</b> <b>Object</b> <b>Access</b>
       The following methods provide low-level access to PDL::CCS::Nd object structure:

       insertWhich
             Signature: ($ccs; int whichND(Ndims,Nnz1); vals(Nnz1))

           Set or insert values in $ccs for the indices in $whichND to $vals.   $whichND  need  not  be  sorted.
           Implicitly makes $ccs physically indexed.  Returns the (destructively altered) $ccs.

       appendWhich
             Signature: ($ccs; int whichND(Ndims,Nnz1); vals(Nnz1))

           Like <b>insertWhich()</b>, but assumes that no values for any of the $whichND indices are already present in
           $ccs.  This is faster (because indexNDi need not be called), but less safe.

       <b>is_physically_indexed()</b>
           Returns true iff only physical dimensions are present.

       <b>to_physically_indexed()</b>
           Just  returns  the  calling  object  if  all  non-missing  elements  are  already physically indexed.
           Otherwise, returns a new PDL::CCS::Nd object identical to the  caller  except  that  all  non-missing
           elements are physically indexed.  This may gobble a large amount of memory if the calling element has
           large dummy dimensions.  Also ensures that physical dimension order is identical to logical dimension
           order.

       make_physically_indexed
           Wrapper  for  <b>to_physically_indexed()</b>  which eliminates dummy dimensions destructively in the calling
           object.

           Alias: <b>make_physical()</b>.

       <b>pdims()</b>
           Returns the $PDIMS piddle.  See "Object Structure", above.

       <b>vdims()</b>
           Returns the $VDIMS piddle.  See "Object Structure", above.

       setdims_p(@dims)
           Sets $PDIMS piddle.   See "Object Structure", above.  Returns the calling object.  Alias: <b>setdims()</b>.

       <b>nelem_p()</b>
           Returns the number of physically addressable elements.

       <b>nelem_v()</b>
           Returns the number of virtually addressable elements.  Alias for <b>nelem()</b>.

       <b>_ccs_nvperp()</b>
           Returns number of virtually addressable elements per physically addressable element, which should  be
           a positive integer.

       <b>nstored_p()</b>
           Returns actual number of physically addressed stored elements (aka $Nnz aka $WHICH-&gt;<b><a href="../man1/dim.1.html">dim</a></b>(1)).

       <b>nstored_v()</b>
           Returns actual number of physically+virtually addressed stored elements.

       <b>nmissing_p()</b>
           Returns number of physically addressable elements minus the number of physically stored elements.

       <b>nmissing_v()</b>
           Returns  number of physically+virtually addressable elements minus the number of physically+virtually
           stored elements.

       <b>allmissing()</b>
           Returns true iff no non-missing values are stored.

       <b>missing()</b>
       missing($missing)
           Get/set the value to use for missing elements.  Returns the (new) value for $missing.

       <b>_whichND()</b>
       _whichND($whichND)
           Get/set the underlying $WHICH piddle.

       <b>_nzvals()</b>
       _nzvals($storedvals)
           Get/set the slice of the underlying $VALS piddle corresponding for non-missing values  only.   Alias:
           <b>whichVals()</b>.

       <b>_vals()</b>
       _vals($storedvals)
           Get/set the underlying $VALS piddle.

       hasptr($pdimi)
           Returns true iff a pointer for physical dim $pdimi is cached.

       ptr($pdimi)
           Get  a  pointer  pair  for  a  physically  indexed dimension $pdimi.  Uses cached piddles in $PTRS if
           present, computes &amp; caches otherwise.

           $pdimi defaults to zero.  If $pdimi is zero, then it should hold that:

            all( $pi2nzi==sequence($ccs-&gt;nstored_p) )

       getptr($pdimi)
           Guts for <b>ptr()</b>.  Does not check $PTRS and does not cache anything.

       clearptr($pdimi)
           Clears any cached Harwell-Boeing pointers for physically indexed dimension $pdimi.

       <b>clearptrs()</b>
           Clears any cached Harwell-Boeing pointers.

       <b>flags()</b>
       flags($flags)
           Get/set object-local $FLAGS.

       <b>bad_is_missing()</b>
       bad_is_missing($bool)
           Get/set the value of the object-local "bad-is-missing" flag.  If this flag  is  set,  BAD  values  in
           $VALS are considered "missing", regardless of the current value of $missing.

       <b>badmissing()</b>
           Sets the "bad-is-missing" flag and returns the calling object.

       <b>nan_is_missing()</b>
       nan_is_missing($bool)
           Get/set  the  value  of  the object-local "NaN-is-missing" flag.  If this flag is set, NaN (and +inf,
           -inf) values in $VALS are considered "missing", regardless of the current value of $missing.

       <b>nanmissing()</b>
           Sets the "nan-is-missing" flag and returns the calling object.

   <b>General</b> <b>Information</b>
       <b>density()</b>
           Returns the number of non-missing values divided by the number of  indexable  values  in  the  sparse
           object as a perl scalar.

       <b>compressionRate()</b>
           Returns  the compression rate of the PDL::CCS::Nd object compared to a dense piddle of the physically
           indexable dimensions.  Higher values indicate better  compression  (e.g.  lower  density).   Negative
           values  indicate that dense storage would be more memory-efficient.  Pointers are not included in the
           computation of the compression rate.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Perl by Larry Wall.

       PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

</pre><h4><b>KNOWN</b> <b>BUGS</b></h4><pre>
       Many.

</pre><h4><b>AUTHOR</b></h4><pre>
       Bryan Jurish &lt;<a href="mailto:moocow@cpan.org">moocow@cpan.org</a>&gt;

   <b>Copyright</b> <b>Policy</b>
       Copyright (C) 2007-2024, Bryan Jurish. All rights reserved.

       This package is free software, and entirely without warranty.  You may redistribute it and/or  modify  it
       under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), <b><a href="../man3perl/PDL.3perl.html">PDL</a></b>(3perl), <b>PDL::<a href="../man3perl/SVDLIBC.3perl.html">SVDLIBC</a></b>(3perl), <b>PDL::CCS::<a href="../man3perl/Nd.3perl.html">Nd</a></b>(3perl),

       SVDLIBC: <a href="http://tedlab.mit.edu/~dr/SVDLIBC/">http://tedlab.mit.edu/~dr/SVDLIBC/</a>

       SVDPACKC: <a href="http://www.netlib.org/svdpack/">http://www.netlib.org/svdpack/</a>

perl v5.40.0                                       2025-01-04                                            <u><a href="../man3pm/Nd.3pm.html">Nd</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>