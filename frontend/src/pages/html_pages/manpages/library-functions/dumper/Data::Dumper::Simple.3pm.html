<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Dumper::Simple - Easily dump variables with names</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-dumper-simple-perl">libdata-dumper-simple-perl_0.11-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Dumper::Simple - Easily dump variables with names

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Data::Dumper::Simple;
         warn Dumper($scalar,  @array,  %hash);
         warn Dumper($scalar, \@array, \%hash);
         warn Dumper $scalar, @array, %hash;

</pre><h4><b>ABSTRACT</b></h4><pre>
         This module allow the user to dump variables in a Data::Dumper format.
         Unlike the default behavior of Data::Dumper, the variables are named
         (instead of $VAR1, $VAR2, etc.)  Data::Dumper provides an extended
         interface that allows the programmer to name the variables, but this
         interface requires a lot of typing and is prone to tyops (sic).  This
         module fixes that.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Data::Dumper::Simple" is actually a source filter that replaces all instances of "Dumper($some, @args)"
       in your code with a call to "Data::Dumper-&gt;Dump()".  You can use the one function provided to make
       dumping variables for debugging a trivial task.

       Note that this is primarily a debugging tool.  "Data::Dumper" offers a bit more than that, so don't
       expect this module to be more than it is.

       Note that if you strongly object to source filters, I've also released Data::Dumper::Names.  It does what
       this module does by it uses PadWalker instead of a source filter.  Unfortunately, it has a few
       limitations and is not as powerful as this module.  Think of Data::Dumper::Names as a "proof of concept".

   <b>The</b> <b>Problem</b>
       Frequently, we use "Data::Dumper" to dump out some variables while debugging.  When this happens, we
       often do this:

        use Data::Dumper;
        warn Dumper($foo, $bar, $baz);

       And we get simple output like:

        $VAR1 = 3;
        $VAR2 = 2;
        $VAR3 = 1;

       While this is usually what we want, this can be confusing if we forget which variable corresponds to
       which variable printed.  To get around this, there is an extended interface to "Data::Dumper":

         warn Data::Dumper-&gt;Dump(
           [$foo, $bar, $baz],
           [qw/*foo *bar *baz/]
         );

       This provides much more useful output.

         $foo = 3;
         $bar = 2;
         $baz = 1;

       (There's more control over the output than what I've shown.)

       You can even use this to output more complex data structures:

         warn Data::Dumper-&gt;Dump(
           [$foo, \@array],
           [qw/*foo *array/]
         );

       And get something like this:

         $foo = 3;
         @array = (
                    8,
                    'Ovid'
                  );

       Unfortunately, this can involve a lot of annoying typing.

         warn Data::Dumper-&gt;Dump(
           [$foo, \%this, \@array, \%that],
           [qw/*foo *that *array *this/]
         );

       You'll also notice a typo in the second array ref which can cause great confusion while debugging.

   <b>The</b> <b>Solution</b>
       With "Data::Dumper::Simple" you can do this instead:

         use Data::Dumper::Simple.
         warn Dumper($scalar, @array, %hash);

       Note that there's no need to even take a reference to the variables.  The output of the above resembles
       this (sample data, of course):

         $scalar = 'Ovid';
         @array = (
                    'Data',
                    'Dumper',
                    'Simple',
                    'Rocks!'
                  );
         %hash = (
                   'it' =&gt; 'does',
                   'I' =&gt; 'hope',
                   'at' =&gt; 'least'
                 );

       Taking a reference to an array or hash works as expected, but taking a reference to a scalar is
       effectively a no-op (because it can turn into a confusing reference to a reference);

        my $foo   = { hash =&gt; 'ref' };
        my @foo   = qw/foo bar baz/;
        warn Dumper ($foo, \@foo);

       Produces:

        $foo = {
          'hash' =&gt; 'ref'
        };
        $foo = [
          'foo',
          'bar',
          'baz'
        ];

       Note that this means similarly named variables can get quite confusing, as in the example above.

       If you already have a &amp;Dumper function, you can specify a different function name with the "as" key in
       the import list:

         use Data::Dumper::Simple as =&gt; 'display';
         warn display( $scalar, @array, %hash );

       Also, if you really, really can't stand typing "warn" or "print", you can turn on "autowarn":

         use Data::Dumper::Simple as =&gt; 'display', autowarn =&gt; 1;
         display($scalar, @array, $some-&gt;{ data });

       Or you can send the output (as a list) to a different function:

         use Data::Dumper::Simple as =&gt; 'debug', autowarn =&gt; 'to_log';

         sub to_log {
             my @data = @_;
             # some logging function
         }

         debug(
           $customer =&gt; @order_nums
         ); # yeah, we support the fat comma "=&gt;" and newlines

</pre><h4><b>EXPORT</b></h4><pre>
       The only thing exported is the <b>Dumper()</b> function.

       Well, actually that's not really true.  Nothing is exported.  However, a source filter is used to
       automatically rewrite any apparent calls to "Dumper()" so that it just Does The Right Thing.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   Data::Dumper - Stringified perl data structures

       •   Filter::Simple - Simplified source filtering

</pre><h4><b>BUGS</b></h4><pre>
       This  module  uses a source filter.  If you don't like that, don't use this.  There are no known bugs but
       there probably are some as this is <b>Alpha</b> <b>Code</b>.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       •   Calling with a sub

           Do not try to call "Dumper()" with a subroutine in the argument list:

             Dumper($foo, some_sub()); # Bad!

           The filter gets confused by the parentheses.  Your author  was  going  to  fix  this  but  it  became
           apparent  that  there  was no way that "Dumper()" could figure out how to name the return values from
           the subroutines, thus ensuring further breakage.  So don't do that.

       •   Multiple enreferencing

           Getting really crazy by using multiple enreferencing will confuse things (e.g., "\\\\\\$foo"),  don't
           do that, either.  I might use "Text::Balanced" at some point to fix this if it's an issue.

       •   Slices

           List and hash slices are not supported at this time.

       •   String interpolation

           "Dumper($foo)" can potentially interpolate if it's in a string.  This is because of a weird edge case
           with "FILTER_ONLY code" which caused a failure on some items being dumped.  I've fixed that, but made
           the  module  a  wee  bit  less  robust.   This  will  hopefully  be  fixed  in  the  next  release of
           Text::Balanced.

       •   Line numbers may be wrong

           Because this module uses a source filter, line numbers reported from syntax or other  errors  may  be
           thrown off a little.

           This is probably a bug in the source filter implementation, which should use "#line" directives. As a
           workaround  until  this  is  fixed,  put a directive (such as "#line 10000") a few lines ahead of the
           suspected bug. If the error is reported as happening in line 10007, you  know  to  look  about  eight
           lines below your directive for the bug. Be sure to remove the bogus directive once you find the bug!

       •   The parentheses are optional, but the syntax isn't bulletproof

           If you try, it's not hard to confuse the parser. Patches welcome.

       Note  that  this  is not a drop-in replacement for "Data::Dumper".  If you need the power of that module,
       use it.

</pre><h4><b>AUTHOR</b></h4><pre>
       Curtis "Ovid" Poe, &lt;<a href="mailto:eop_divo_sitruc@yahoo.com">eop_divo_sitruc@yahoo.com</a>&gt;

       Reverse the name to email me.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2004 by Curtis "Ovid" Poe

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2022-10-22                          <u>Data::Dumper::<a href="../man3pm/Simple.3pm.html">Simple</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>