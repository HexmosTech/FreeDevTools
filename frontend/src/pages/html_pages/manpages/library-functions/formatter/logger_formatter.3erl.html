<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>logger_formatter - Default formatter for Logger.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       logger_formatter - Default formatter for Logger.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Each  Logger  handler  has  a  configured  formatter  specified as a module and a configuration term. The
       purpose of the formatter is to translate the log events to a final printable string  (<u>unicode:chardata()</u>)
       which  can  be  written  to the output device of the handler. See sections Handlers and Formatters in the
       Kernel User's Guide for more information.

       <u>logger_formatter</u> is the default formatter used by Logger.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>config()</b> =
           #{chars_limit =&gt; integer() &gt;= 1 | unlimited,
             depth =&gt; integer() &gt;= 1 | unlimited,
             legacy_header =&gt; boolean(),
             max_size =&gt; integer() &gt;= 1 | unlimited,
             report_cb =&gt; logger:report_cb(),
             single_line =&gt; boolean(),
             template =&gt; template(),
             time_designator =&gt; byte(),
             time_offset =&gt; integer() | [byte()]}

              The configuration term for <u>logger_formatter</u> is a map,  and  the  following  keys  can  be  set  as
              configuration parameters:

                <u>chars_limit</u> <u>=</u> <u>integer()</u> <u>&gt;</u> <u>0</u> <u>|</u> <u>unlimited</u>:
                  A  positive  integer  representing  the value of the option with the same name to be used when
                  calling <u>io_lib:format/3</u>. This value limits the total number of characters printed for each log
                  event. Notice that this is a soft limit. For a hard truncation limit, see option <u>max_size</u>.

                  Defaults to <u>unlimited</u>.

                <u>depth</u> <u>=</u> <u>integer()</u> <u>&gt;</u> <u>0</u> <u>|</u> <u>unlimited</u>:
                  A positive integer representing the maximum depth to which terms  shall  be  printed  by  this
                  formatter.  Format  strings passed to this formatter are rewritten. The format controls ~p and
                  ~w are replaced with ~P and ~W, respectively, and the value is used as  the  depth  parameter.
                  For details, see <u>io:format/2,3</u> in STDLIB.

                  Defaults to <u>unlimited</u>.

                <u>legacy_header</u> <u>=</u> <u>boolean()</u>:
                  If  set  to  <u>true</u> a header field is added to logger_formatter's part of <u>Metadata</u>. The value of
                  this field is a string similar to the header created by the old <u>error_logger</u>  event  handlers.
                  It  can  be  included  in  the  log  event by adding the list <u>[logger_formatter,header]</u> to the
                  template. See the description of the <u>template()</u> type for more information.

                  Defaults to <u>false</u>.

                <u>max_size</u> <u>=</u> <u>integer()</u> <u>&gt;</u> <u>0</u> <u>|</u> <u>unlimited</u>:
                  A positive integer representing  the  absolute  maximum  size  a  string  returned  from  this
                  formatter  can  have.  If  the  formatted  string  is  longer, after possibly being limited by
                  <u>chars_limit</u> or <u>depth</u>, it is truncated.

                  Defaults to <u>unlimited</u>.

                <u>report_cb</u> <u>=</u> <u>logger:report_cb()</u>:
                  A report callback is used by the formatter to transform log  messages  on  report  form  to  a
                  format  string and arguments. The report callback can be specified in the metadata for the log
                  event.   If   no   report   callback   exists   in   metadata,   <u>logger_formatter</u>   will   use
                  <u>logger:format_report/1</u> as default callback.

                  If  this configuration parameter is set, it replaces both the default report callback, and any
                  report callback found in metadata. That is, all  reports  are  converted  by  this  configured
                  function.

                <u>single_line</u> <u>=</u> <u>boolean()</u>:
                  If  set to <u>true</u>, each log event is printed as a single line. To achieve this, <u>logger_formatter</u>
                  sets the field width to <u>0</u> for all <u>~p</u> and <u>~P</u> control sequences in  the  format  a  string  (see
                  <u>io:format/2</u>),  and  replaces  all  newlines  in  the message with <u>",</u> <u>"</u>. White spaces following
                  directly after newlines are removed. Notice that newlines added by the <u>template</u> parameter  are
                  not replaced.

                  Defaults to <u>true</u>.

                <u>template</u> <u>=</u> <u>template()</u>:
                  The template describes how the formatted string is composed by combining different data values
                  from  the  log  event.  See  the description of the <u>template()</u> type for more information about
                  this.

                <u>time_designator</u> <u>=</u> <u>byte()</u>:
                  Timestamps are formatted according to RFC3339, and the time designator is the  character  used
                  as date and time separator.

                  Defaults to <u>$T</u>.

                  The    value    of    this    parameter   is   used   as   the   <u>time_designator</u>   option   to
                  <u>calendar:system_time_to_rcf3339/2</u>.

                <u>time_offset</u> <u>=</u> <u>integer()</u> <u>|</u> <u>[byte()]</u>:
                  The time offset, either a string or an integer, to be used when formatting the timestamp.

                  An empty string is interpreted as local time. The values <u>"Z"</u>, <u>"z"</u>  or  <u>0</u>  are  interpreted  as
                  Universal Coordinated Time (UTC).

                  Strings,  other  than <u>"Z"</u>, <u>"z"</u>, or <u>""</u>, must be on the form <u>Â±[hh]:[mm]</u>, for example <u>"-02:00"</u> or
                  <u>"+00:00"</u>.

                  Integers must be in  microseconds,  meaning  that  the  offset  <u>7200000000</u>  is  equivalent  to
                  <u>"+02:00"</u>.

                  Defaults to an empty string, meaning that timestamps are displayed in local time. However, for
                  backwards  compatibility,  if  the  SASL  configuration parameter <u>utc_log=true</u>, the default is
                  changed to <u>"Z"</u>, meaning that timestamps are displayed in UTC.

                  The value of this parameter is used as the <u>offset</u> option to <u>calendar:system_time_to_rcf3339/2</u>.

       <b>metakey()</b> = atom() | [atom()]

       <b>template()</b> =
           [metakey() |
            {metakey(), template(), template()} |
            unicode:chardata()]

              The template is a list of atoms, atom lists, tuples and strings.  The  atoms  <u>level</u>  or  <u>msg</u>,  are
              treated  as  placeholders for the severity level and the log message, respectively. Other atoms or
              atom lists are interpreted as placeholders for metadata, where atoms are  expected  to  match  top
              level  keys,  and  atom  lists  represent paths to sub keys when the metadata is a nested map. For
              example the list <u>[key1,key2]</u> is replaced by the value of the <u>key2</u> field in the nested  map  below.
              The  atom  <u>key1</u>  on  its  own  is replaced by the complete value of the <u>key1</u> field. The values are
              converted to strings.

              #{key1 =&gt; #{key2 =&gt; my_value,
                          ...}
                ...}

              Tuples in the template express if-exist tests for metadata keys. For example, the following  tuple
              says  that  if  <u>key1</u> exists in the metadata map, print <u>"key1=Value"</u>, where <u>Value</u> is the value that
              <u>key1</u> is associated with in the metadata map. If <u>key1</u> does not exist, print nothing.

              {key1, ["key1=",key1], []}

              Strings in the template are printed literally.

              The default value for the <u>template</u> configuration parameter depends on the value of the <u>single_line</u>
              and <u>legacy_header</u> configuration parameters as follows.

              The log event used in the examples is:

              ?LOG_ERROR("name: ~p~nexit_reason: ~p", [my_name, "It crashed"])

                <u>legacy_header</u> <u>=</u> <u>true,</u> <u>single_line</u> <u>=</u> <u>false</u>:
                  Default template: <u>[[logger_formatter,header],"\n",msg,"\n"]</u>

                  Example log entry:

                =ERROR REPORT==== 17-May-2018::18:30:19.453447 ===
                name: my_name
                exit_reason: "It crashed"

                  Notice that all eight levels can occur in the heading, not only  <u>ERROR</u>,  <u>WARNING</u>  or  <u>INFO</u>  as
                  <u>error_logger</u> produces. And microseconds are added at the end of the timestamp.

                <u>legacy_header</u> <u>=</u> <u>true,</u> <u>single_line</u> <u>=</u> <u>true</u>:
                  Default template: <u>[[logger_formatter,header],"\n",msg,"\n"]</u>

                  Notice  that  the  template  is  here the same as for <u>single_line=false</u>, but the resulting log
                  entry differs in that there is only one line after the heading:

                =ERROR REPORT==== 17-May-2018::18:31:06.952665 ===
                name: my_name, exit_reason: "It crashed"

                <u>legacy_header</u> <u>=</u> <u>false,</u> <u>single_line</u> <u>=</u> <u>true</u>:
                  Default template: <u>[time,"</u> <u>",level,":</u> <u>",msg,"\n"]</u>

                  Example log entry:

                2018-05-17T18:31:31.152864+02:00 error: name: my_name, exit_reason: "It crashed"

                <u>legacy_header</u> <u>=</u> <u>false,</u> <u>single_line</u> <u>=</u> <u>false</u>:
                  Default template: <u>[time,"</u> <u>",level,":\n",msg,"\n"]</u>

                  Example log entry:

                2018-05-17T18:32:20.105422+02:00 error:
                name: my_name
                exit_reason: "It crashed"

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>check_config(Config)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Config = config()

              The function is called by Logger when  the  formatter  configuration  for  a  handler  is  set  or
              modified. It returns <u>ok</u> if the configuration is valid, and <u>{error,term()}</u> if it is faulty.

              The following Logger API functions can trigger this callback:

                * <u>logger:add_handler/3</u>

                * <u>logger:set_handler_config/2,3</u>

                * <u>logger:update_handler_config/2</u>

                * <u>logger:update_formatter_config/2</u>

       <b>format(LogEvent,</b> <b>Config)</b> <b>-&gt;</b> <b>unicode:chardata()</b>

              Types:

                 LogEvent = logger:log_event()
                 Config = config()

              This  the  formatter  callback  function to be called from handlers. The log event is processed as
              follows:

                * If the message is on report form, it is converted  to  <u>{Format,Args}</u>  by  calling  the  report
                  callback. See section Log Message in the Kernel User's Guide for more information about report
                  callbacks and valid forms of log messages.

                * The  message  size  is limited according to the values of configuration parameters <u>chars_limit</u>
                  and <u>depth</u>.

                * The full log entry is composed according to the <u>template</u>.

                * If the final string is too long, it is truncated  according  to  the  value  of  configuration
                  parameter <u>max_size</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/calendar.3erl.html">calendar</a>(3erl)</u>,   <u><a href="../man3erl/error_logger.3erl.html">error_logger</a>(3erl)</u>,   <u><a href="../man3erl/io.3erl.html">io</a>(3erl)</u>,   <u><a href="../man3erl/io_lib.3erl.html">io_lib</a>(3erl)</u>,   <u><a href="../man3erl/logger.3erl.html">logger</a>(3erl)</u>,   <u><a href="../man3erl/maps.3erl.html">maps</a>(3erl)</u>,  <u><a href="../man7/sasl.7.html">sasl</a>(7)</u>,
       <u><a href="../man3erl/unicode.3erl.html">unicode</a>(3erl)</u>

Ericsson AB                                        kernel 8.2                             <u><a href="../man3erl/logger_formatter.3erl.html">logger_formatter</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>