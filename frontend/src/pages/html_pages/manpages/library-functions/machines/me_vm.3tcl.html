<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>grammar::me_vm - Virtual machine for parsing token streams</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       grammar::me_vm - Virtual machine for parsing token streams

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Please  go  and  read  the  document <b>grammar::me_intro</b> first for an overview of the various documents and
       their relations.

       This document specifies a virtual machine for the controlled  matching  and  parsing  of  token  streams,
       creating  an  <u>abstract</u>  <u>syntax</u>  <u>tree</u>  (short  <u>AST</u>) reflecting the structure of the input. Special machine
       features are the caching and reuse of partial results, caching of the encountered input, and the  ability
       to backtrack in both input and AST creation.

       These  features  make the specified virtual machine especially useful to packrat parsers based on parsing
       expression grammars. It is however not restricted to this type of parser. Normal LL and LR parsers can be
       implemented with it as well.

       The following sections will discuss first the abstract state kept by ME virtual machines, and then  their
       instruction set.

</pre><h4><b>MACHINE</b> <b>STATE</b></h4><pre>
       A ME virtual machine manages the following state:

       <u>Current</u> <u>token</u> CT
              The token from the input under consideration by the machine.

              This  information  is  used  and  modified  by  the  instructions  defined in the section <b>TERMINAL</b>
              <b>MATCHING</b>.

       <u>Current</u> <u>location</u> CL
              The location of the <u>current</u> <u>token</u> in the input stream, as offset relative to the beginning of  the
              stream. The first token is considered to be at offset <b>0</b>.

              This  information  is  implicitly  used  and  modified by the instructions defined in the sections
              <b>TERMINAL</b> <b>MATCHING</b> and <b>NONTERMINAL</b> <b>MATCHING</b>, and can  be  directly  queried  and  modified  by  the
              instructions defined in section <b>INPUT</b> <b>LOCATION</b> <b>HANDLING</b>.

       <u>Location</u> <u>stack</u> LS
              In  addition to the above a stack of locations, for backtracking.  Locations can put on the stack,
              removed from it, and removed with setting the current location.

              This information is implicitly used and modified by  the  instructions  defined  in  the  sections
              <b>TERMINAL</b>  <b>MATCHING</b>  and  <b>NONTERMINAL</b>  <b>MATCHING</b>,  and  can  be directly queried and modified by the
              instructions defined in section <b>INPUT</b> <b>LOCATION</b> <b>HANDLING</b>.

       <u>Match</u> <u>status</u> OK
              A boolean value, the result of the last attempt at matching input.  It is  set  to  <b>true</b>  if  that
              attempt was successful, and <b>false</b> otherwise.

              This  information  is  influenced  by  the instructions defined in the sections <b>TERMINAL</b> <b>MATCHING</b>,
              <b>NONTERMINAL</b> <b>MATCHING</b>, and <b>UNCONDITIONAL</b> <b>MATCHING</b>.  It is queried by the  instructions  defined  in
              the section <b>CONTROL</b> <b>FLOW</b>.

       <u>Semantic</u> <u>value</u> SV
              The  semantic  value  associated  with (generated by) the last attempt at matching input. Contains
              either the empty string or a node for the abstract syntax tree constructed from the input.

              This information is influenced by the instructions defined in the sections  <b>SEMANTIC</b>  <b>VALUES</b>,  and
              <b>AST</b> <b>STACK</b> <b>HANDLING</b>.

       <u>AST</u> <u>stack</u> AS
              A stack of partial abstract syntax trees constructed by the machine during matching.

              This  information  is  influenced by the instructions defined in the sections <b>SEMANTIC</b> <b>VALUES</b>, and
              <b>AST</b> <b>STACK</b> <b>HANDLING</b>.

       <u>AST</u> <u>Marker</u> <u>stack</u> MS
              In addition to the above a stack of stacks, for backtracking. This is actually a stack of  markers
              into the AST stack, thus implicitly snapshooting the state of the AST stack at some point in time.
              Markers  can  be  put  on  the  stack,  dropped from it, and used to roll back the AST stack to an
              earlier state.

              This information is influenced by the instructions defined in the sections  <b>SEMANTIC</b>  <b>VALUES</b>,  and
              <b>AST</b> <b>STACK</b> <b>HANDLING</b>.

       <u>Error</u> <u>status</u> ER
              Error  information  associated  with the last attempt at matching input. Contains either the empty
              string or a list of 2 elements, a location in the input and a list of  error  messages  associated
              with it, in this order.

              <u>Note</u>  that error information can be set even if the last attempt at matching input was successful.
              For example the *-operator (matching a sub-expression zero or more times) in a parsing  expression
              grammar  is  always  successful,  even  if it encounters a problem further in the input and has to
              backtrack. Such problems must not be forgotten when continuing to match.

              This information is queried and influenced by the instructions defined in  the  sections  <b>TERMINAL</b>
              <b>MATCHING</b>, <b>NONTERMINAL</b> <b>MATCHING</b>, and <b>ERROR</b> <b>HANDLING</b>.

       <u>Error</u> <u>stack</u> ES
              In  addition  to the above a stack of error information, to allow the merging of current and older
              error information when performing backtracking in choices after an unsucessful match.

              This information is queried and influenced by the instructions defined in  the  sections  <b>TERMINAL</b>
              <b>MATCHING</b>, <b>NONTERMINAL</b> <b>MATCHING</b>, and <b>ERROR</b> <b>HANDLING</b>.

       <u>Return</u> <u>stack</u> RS
              A stack of program counter values, i.e. locations in the code controlling the virtual machine, for
              the management of subroutine calls, i.e. the matching of nonterminal symbols.

              This  information is queried and influenced by the instructions defined in the section <b>NONTERMINAL</b>
              <b>MATCHING</b>.

       <u>Nonterminal</u> <u>cache</u> NC
              A cache of machine states (A 4-tuple containing a location in the input, match status <u>OK</u>, semantic
              value <u>SV</u>, and error status <u>ER</u>) keyed by name of nonterminal  symbol  and  location  in  the  input
              stream.

              The  key  location is where machine started the attempt to match the named nonterminal symbol, and
              the location in the value is where machine ended up after the attempt  completed,  independent  of
              the success of the attempt.

              This  status  is  queried  and  influenced  by the instructions defined in the section <b>NONTERMINAL</b>
              <b>MATCHING</b>.

</pre><h4><b>MACHINE</b> <b>INSTRUCTIONS</b></h4><pre>
       With the machine state specified it is now  possible  to  explain  the  instruction  set  of  ME  virtual
       machines. They are grouped roughly by the machine state they influence and/or query.

   <b>TERMINAL</b> <b>MATCHING</b>
       First the instructions to match tokens from the input stream, and by extension all terminal symbols.

       These  instructions are the only ones which may retrieve a new token from the input stream. This is a <u>may</u>
       and not a <u>will</u> because the instructions will a retrieve new token if, and only if the current location <u>CL</u>
       is at the head of the stream.  If the machine has backtracked  (see  <b>icl_rewind</b>)  the  instructions  will
       retrieve the token to compare against from the internal cache.

       <b>ict_advance</b> <u>message</u>
              This  instruction  tries  to advance to the next token in the input stream, i.e. the one after the
              current location <u>CL</u>. The instruction will fail if, and only if the end  of  the  input  stream  is
              reached, i.e. if there is no next token.

              The sucess/failure of the instruction is remembered in the match status <u>OK</u>. In the case of failure
              the  error  status  <u>ER</u>  is  set  to  the current location and the message <u>message</u>.  In the case of
              success the error status <u>ER</u> is cleared, the new token is made the current token <u>CT</u>,  and  the  new
              location is made the current location <u>CL</u>.

              The  argument  <u>message</u>  is  a  reference to the string to put into the error status <u>ER</u>, if such is
              needed.

       <b>ict_match_token</b> <u>tok</u> <u>message</u>
              This instruction tests the current token <u>CT</u> for equality with the argument  <u>tok</u>  and  records  the
              result in the match status <u>OK</u>. The instruction fails if the current token is not equal to <u>tok</u>.

              In  case of failure the error status <u>ER</u> is set to the current location <u>CL</u> and the message <u>message</u>,
              and the current location <u>CL</u> is moved one token backwards.  Otherwise, i.e. upon success, the error
              status <u>ER</u> is cleared and the current location <u>CL</u> is not touched.

       <b>ict_match_tokrange</b> <u>tokbegin</u> <u>tokend</u> <u>message</u>
              This instruction tests the current token <u>CT</u> for being in the range  of  tokens  from  <u>tokbegin</u>  to
              <u>tokend</u>  (inclusive)  and  records  the result in the match status <u>OK</u>. The instruction fails if the
              current token is not inside the range.

              In case of failure the error status <u>ER</u> is set to the current location <u>CL</u> and the message  <u>message</u>,
              and the current location <u>CL</u> is moved one token backwards.  Otherwise, i.e. upon success, the error
              status <u>ER</u> is cleared and the current location <u>CL</u> is not touched.

       <b>ict_match_tokclass</b> <u>code</u> <u>message</u>
              This instruction tests the current token <u>CT</u> for being a member of the token class <u>code</u> and records
              the  result  in the match status <u>OK</u>. The instruction fails if the current token is not a member of
              the specified class.

              In case of failure the error status <u>ER</u> is set to the current location <u>CL</u> and the message  <u>message</u>,
              and the current location <u>CL</u> is moved one token backwards.  Otherwise, i.e. upon success, the error
              status <u>ER</u> is cleared and the current location <u>CL</u> is not touched.

              Currently the following classes are legal:

              alnum  A token is accepted if it is a unicode alphabetical character, or a digit.

              alpha  A token is accepted if it is a unicode alphabetical character.

              digit  A token is accepted if it is a unicode digit character.

              xdigit A token is accepted if it is a hexadecimal digit character.

              punct  A token is accepted if it is a unicode punctuation character.

              space  A token is accepted if it is a unicode space character.

   <b>NONTERMINAL</b> <b>MATCHING</b>
       The  instructions  in this section handle the matching of nonterminal symbols. They query the nonterminal
       cache <u>NC</u> for saved information, and put such information into the cache.

       The usage of the cache is a performance aid for backtracking parsers, allowing them to avoid an expensive
       rematch of complex nonterminal symbols if they have been encountered before.

       <b>inc_restore</b> <u>branchlabel</u> <u>nt</u>
              This instruction checks if the nonterminal cache <u>NC</u> contains  information  about  the  nonterminal
              symbol <u>nt</u>, at the current location <u>CL</u>. If that is the case the instruction will update the machine
              state  (current  location  <u>CL</u>,  match  status <u>OK</u>, semantic value <u>SV</u>, and error status <u>ER</u>) with the
              found information and continue execution at the instruction refered to by the <u>branchlabel</u>. The new
              current location <u>CL</u> will be the last token matched by the nonterminal symbol,  i.e.  belonging  to
              it.

              If no information was found the instruction will continue execution at the next instruction.

              Together with <b>icf_ntcall</b> it is possible to generate code for memoized and non-memoized matching of
              nonterminal symbols, either as subroutine calls, or inlined in the caller.

       <b>inc_save</b> <u>nt</u>
              This  instruction  saves  the  current state of the machine (current location <u>CL</u>, match status <u>OK</u>,
              semantic value <u>SV</u>, and error status <u>ER</u>), to the nonterminal cache <u>NC</u>. It will also  pop  an  entry
              from the location stack <u>LS</u> and save it as the start location of the match.

              It  is  expected to be called at the end of matching a nonterminal symbol, with <u>nt</u> the name of the
              nonterminal symbol the code was working on. This allows the instruction <b>inc_restore</b> to  check  for
              and retrieve the data, should we have to match this nonterminal symbol at the same location again,
              during backtracking.

       <b>icf_ntcall</b> <u>branchlabel</u>
              This  instruction invokes the code for matching the nonterminal symbol <u>nt</u> as a subroutine. To this
              end it stores the current program counter <u>PC</u> on the return stack <u>RS</u>, the current  location  <u>CL</u>  on
              the location stack <u>LS</u>, and then continues execution at the address <u>branchlabel</u>.

              The  next  matching  <b>icf_ntreturn</b>  will  cause the execution to continue at the instruction coming
              after the call.

       <b>icf_ntreturn</b>
              This instruction will pop an entry from the return stack <u>RS</u>, assign it to the program counter  <u>PC</u>,
              and then continue execution at the new address.

   <b>UNCONDITIONAL</b> <b>MATCHING</b>
       The  instructions  in  this  section  are  the remaining match operators. They change the match status <u>OK</u>
       directly and unconditionally.

       <b>iok_ok</b> This instruction sets the match status <u>OK</u> to <b>true</b>, indicating a successful match.

       <b>iok_fail</b>
              This instruction sets the match status <u>OK</u> to <b>false</b>, indicating a failed match.

       <b>iok_negate</b>
              This instruction negates the match status <u>OK</u>, turning a failure into a success and vice versa.

   <b>CONTROL</b> <b>FLOW</b>
       The instructions in  this  section  implement  both  conditional  and  unconditional  control  flow.  The
       conditional jumps query the match status <u>OK</u>.

       <b>icf_jalways</b> <u>branchlabel</u>
              This  instruction  sets  the  program  counter <u>PC</u> to the address specified by <u>branchlabel</u> and then
              continues execution from there. This is an unconditional jump.

       <b>icf_jok</b> <u>branchlabel</u>
              This instruction sets the program counter <u>PC</u> to the address specified by <u>branchlabel</u>. This happens
              if, and only if the match status <u>OK</u> indicates a success. Otherwise it simply  continues  execution
              at the next instruction. This is a conditional jump.

       <b>icf_jfail</b> <u>branchlabel</u>
              This instruction sets the program counter <u>PC</u> to the address specified by <u>branchlabel</u>. This happens
              if,  and  only if the match status <u>OK</u> indicates a failure. Otherwise it simply continues execution
              at the next instruction. This is a conditional jump.

       <b>icf_halt</b>
              This instruction halts the machine and blocks any further execution.

   <b>INPUT</b> <b>LOCATION</b> <b>HANDLING</b>
       The instructions in this section are for backtracking, they manipulate the current  location  <u>CL</u>  of  the
       machine  state.  They allow a user of the machine to query and save locations in the input, and to rewind
       the current location <u>CL</u> to saved locations, making them one of the components enabling the implementation
       of backtracking parsers.

       <b>icl_push</b>
              This instruction pushes a copy of the current location <u>CL</u> on the location stack <u>LS</u>.

       <b>icl_rewind</b>
              This instruction pops an entry from the location stack <u>LS</u> and then moves the current  location  <u>CL</u>
              back to this point in the input.

       <b>icl_pop</b>
              This instruction pops an entry from the location stack <u>LS</u> and discards it.

   <b>ERROR</b> <b>HANDLING</b>
       The instructions in this section provide read and write access to the error status <u>ER</u> of the machine.

       <b>ier_push</b>
              This instruction pushes a copy of the current error status <u>ER</u> on the error stack <u>ES</u>.

       <b>ier_clear</b>
              This instruction clears the error status <u>ER</u>.

       <b>ier_nonterminal</b> <u>message</u>
              This  instruction  checks if the error status <u>ER</u> contains an error whose location is just past the
              location found in the top entry of the location stack <u>LS</u>.  Nothing happens if  no  such  error  is
              found.   Otherwise  the  found  error  is replaced by an error at the location found on the stack,
              having the message <u>message</u>.

       <b>ier_merge</b>
              This instruction pops an entry from the error stack <u>ES</u>, merges it with the current error status <u>ER</u>
              and stores the result of the merge as the new error status <u>ER</u>.

              The merge is performed as described below:

              If one of the two error states is empty the other is chosen. If neither error state is empty,  and
              refering  to  different  locations, then the error state with the location further in the input is
              chosen. If both error states refer to the same location their messages are merged  (with  removing
              duplicates).

   <b>SEMANTIC</b> <b>VALUES</b>
       The instructions in this section manipulate the semantic value <u>SV</u>.

       <b>isv_clear</b>
              This instruction clears the semantic value <u>SV</u>.

       <b>isv_terminal</b>
              This instruction creates a terminal AST node for the current token <u>CT</u>, makes it the semantic value
              <u>SV</u>, and also pushes the node on the AST stack <u>AS</u>.

       <b>isv_nonterminal_leaf</b> <u>nt</u>
              This  instruction  creates a nonterminal AST node without any children for the nonterminal <u>nt</u>, and
              makes it the semantic value <u>SV</u>.

              This instruction should be executed if, and only if the match status <u>OK</u> indicates a  success.   In
              the case of a failure <b>isv_clear</b> should be called.

       <b>isv_nonterminal_range</b> <u>nt</u>
              This  instruction  creates  a  nonterminal AST node for the nonterminal <u>nt</u>, with a single terminal
              node as its child, and makes this AST the semantic value <u>SV</u>. The terminal node refers to the input
              string from the location found on top of the location stack <u>LS</u> to the current  location  <u>CL</u>  (both
              inclusive).

              This  instruction  should be executed if, and only if the match status <u>OK</u> indicates a success.  In
              the case of a failure <b>isv_clear</b> should be called.

       <b>isv_nonterminal_reduce</b> <u>nt</u>
              This instruction creates a nonterminal AST node for the nonterminal <u>nt</u> and makes it  the  semantic
              value <u>SV</u>.

              All entries on the AST stack <u>AS</u> above the marker found in the top entry of the AST Marker stack <u>MS</u>
              become  children of the new node, with the entry at the stack top becoming the rightmost child. If
              the AST Marker stack <u>MS</u> is empty the whole stack  is  used.  The  AST  marker  stack  <u>MS</u>  is  left
              unchanged.

              This  instruction  should be executed if, and only if the match status <u>OK</u> indicates a success.  In
              the case of a failure <b>isv_clear</b> should be called.

   <b>AST</b> <b>STACK</b> <b>HANDLING</b>
       The instructions in this section manipulate the AST stack <u>AS</u>, and the AST Marker stack <u>MS</u>.

       <b>ias_push</b>
              This instruction pushes the semantic value <u>SV</u> on the AST stack <u>AS</u>.

       <b>ias_mark</b>
              This instruction pushes a marker for the current state of the AST stack <u>AS</u> on the AST Marker stack
              <u>MS</u>.

       <b>ias_mrewind</b>
              This instruction pops an entry from the AST Marker stack <u>MS</u> and then proceeds to pop entries  from
              the AST stack <u>AS</u> until the state represented by the popped marker has been reached again.  Nothing
              is done if the AST stack <u>AS</u> is already smaller than indicated by the popped marker.

       <b>ias_mpop</b>
              This instruction pops an entry from the AST Marker stack <u>MS</u> and discards it.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category <u>grammar_me</u> of  the  <u>Tcllib</u>  <u>Trackers</u>  [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       grammar, parsing, virtual machine

</pre><h4><b>CATEGORY</b></h4><pre>
       Grammars and finite automata

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2005 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 0.2                                  <u>grammar::<a href="../man3tcl/me_vm.3tcl.html">me_vm</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>