<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web::Machine::Util - General Utility module</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libweb-machine-perl">libweb-machine-perl_0.17-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Web::Machine::Util - General Utility module

</pre><h4><b>VERSION</b></h4><pre>
       version 0.17

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Web::Machine::Util;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is just a basic utility module used internally by Web::Machine. There are no real user serviceable
       parts in here.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       "first"
           This is imported from List::Util and passed on here for export.

       "pair_key"
       "pair_value"
           These  two  functions  are  used  for  fetching  the  key and value out of a pair in the Web::Machine
           internals.  We represent a pair simply as a HASH ref with one key.

       inflate_headers( $request )
           This will call "inflate" on an instance of HTTP::Headers::ActionPack.

       create_header( @args )
           This will call "create" on an instance of HTTP::Headers::ActionPack.

       "create_date( $date_string | $time_peice )"
           Given  either  a  $date_string  or  an  instance  of  Time::Piece,  this  will  inflate  it  into   a
           HTTP::Headers::ActionPack::DateHeader object, suitable for use in the FSM.

       "bind_path( $path_spec, $path )"
           Given  a  $path_spec  (described  below)  and a $path, this will either bind the path to the spec and
           return and array of bound values, or it will return nothing.  Returning  nothing  indicates  that  no
           match  was  found.  Additionally, if this function is called in scalar context, and there is only one
           match, it will return that item. Otherwise it will return the array as normal. This all makes it easy
           to use the following idiom:

             if ( my $id = bind_path( '/:id', $request-&gt;path_info ) ) {
                 # handle the case with an ID here
             }
             else {
                 # handle other cases here
             }

           The $path_spec follows a pretty standard convention. Literal  path  parts  must  match  corresponding
           literal.  Variable  path  parts  are  prefixed  by a colon and are captured for returning later, if a
           question mark (?) prefixes the colon, that element  will  be  considered  optional.  And  lastly  the
           "splat"  operator  ("*")  is  supported  and causes all the rest of the path segments to be returned.
           Below are a few examples of this:

             spec                  path             result
             ------------------------------------------------------------
             /test/:foo/:bar       /test/1/2        ( 1, 2 )
             /test/:foo/:bar       /test/1/         undef #failure-case
             /test/*               /test/1/2/3      ( 1, 2, 3 )
             /user/:id/:action     /user/1/edit     ( 1, 'edit' )
             /?:id                 /201             ( 201 )
             /?:id                 /                ( )

           This function is kept deliberately simple and it is expected that the user will use "my" in the array
           form to assign multiple variables, like this:

             my ( $foo, $bar ) = bind_path( '/test/:foo/:bar', $path );

           In the future we might add a "bind_path_hash" function which captures the variable names as well, but
           to be honest, if you feel you need that, you likely want one of the many excellent  path  dispatching
           modules available on CPAN.

           <b>NOTE:</b>  Some  care  should be taken when using path specs in which the only things are either optional
           parameters (prefixed with "?:") or the "splat" operator ("*") as they can return empty arrays,  which
           in  certain  contexts  can  look  like match failure. In these cases you can test the match in scalar
           context to verify, a match failure will be "undef" whereas a match  success  (in  which  nothing  was
           matched) will return 0 (indicating an array with zero size).

</pre><h4><b>SUPPORT</b></h4><pre>
       bugs may be submitted through &lt;https://github.com/houseabsolute/webmachine-perl/issues&gt;.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Stevan Little &lt;<a href="mailto:stevan@cpan.org">stevan@cpan.org</a>&gt;

       •   Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2016 by Infinity Interactive, Inc.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.1                                       2025-08-04                            <u>Web::Machine::<a href="../man3pm/Util.3pm.html">Util</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>