<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sd_notify, sd_notifyf, sd_pid_notify, sd_pid_notifyf, sd_pid_notify_with_fds, sd_pid_notifyf_with_fds,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsystemd-dev">libsystemd-dev_257.7-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sd_notify, sd_notifyf, sd_pid_notify, sd_pid_notifyf, sd_pid_notify_with_fds, sd_pid_notifyf_with_fds,
       sd_notify_barrier, sd_pid_notify_barrier - Notify service manager about start-up completion and other
       service status changes

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;systemd/sd-daemon.h&gt;</b>

       <b>int</b> <b>sd_notify(int</b> <u>unset_environment</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>state</u><b>);</b>

       <b>int</b> <b>sd_notifyf(int</b> <u>unset_environment</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>format</u><b>,</b> <b>...);</b>

       <b>int</b> <b>sd_pid_notify(pid_t</b> <u>pid</u><b>,</b> <b>int</b> <u>unset_environment</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>state</u><b>);</b>

       <b>int</b> <b>sd_pid_notifyf(pid_t</b> <u>pid</u><b>,</b> <b>int</b> <u>unset_environment</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>format</u><b>,</b> <b>...);</b>

       <b>int</b> <b>sd_pid_notify_with_fds(pid_t</b> <u>pid</u><b>,</b> <b>int</b> <u>unset_environment</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>state</u><b>,</b> <b>const</b> <b>int</b> <b>*</b><u>fds</u><b>,</b>
                                  <b>unsigned</b> <u>n_fds</u><b>);</b>

       <b>int</b> <b>sd_pid_notifyf_with_fds(pid_t</b> <u>pid</u><b>,</b> <b>int</b> <u>unset_environment</u><b>,</b> <b>const</b> <b>int</b> <b>*</b><u>fds</u><b>,</b> <b>size_t</b> <u>n_fds</u><b>,</b>
                                   <b>const</b> <b>char</b> <b>*</b><u>format</u><b>,</b> <b>...);</b>

       <b>int</b> <b>sd_notify_barrier(int</b> <u>unset_environment</u><b>,</b> <b>uint64_t</b> <u>timeout</u><b>);</b>

       <b>int</b> <b>sd_pid_notify_barrier(pid_t</b> <u>pid</u><b>,</b> <b>int</b> <u>unset_environment</u><b>,</b> <b>uint64_t</b> <u>timeout</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>sd_notify()</b> may be called by a service to notify the service manager about state changes. It can be used
       to send arbitrary information, encoded in an environment-block-like string. Most importantly, it can be
       used for start-up or reload completion notifications.

       If the <u>unset_environment</u> parameter is non-zero, <b>sd_notify()</b> will unset the <u>$NOTIFY_SOCKET</u> environment
       variable before returning (regardless of whether the function call itself succeeded or not). Further
       calls to <b>sd_notify()</b> will then silently do nothing, and the variable is no longer inherited by child
       processes.

       The <u>state</u> parameter should contain a newline-separated list of variable assignments, similar in style to
       an environment block. A trailing newline is implied if none is specified. The string may contain any kind
       of variable assignments, but see the next section for a list of assignments understood by the service
       manager.

       Note that systemd will accept status data sent from a service only if the <u>NotifyAccess=</u> option is
       correctly set in the service definition file. See <b><a href="../man5/systemd.service.5.html">systemd.service</a></b>(5) for details.

       Note that <b>sd_notify()</b> notifications may be attributed to units correctly only if either the sending
       process is still around at the time PID 1 processes the message, or if the sending process is explicitly
       runtime-tracked by the service manager. The latter is the case if the service manager originally forked
       off the process, i.e. on all processes that match <u>NotifyAccess=</u><b>main</b> or <u>NotifyAccess=</u><b>exec</b>. Conversely, if
       an auxiliary process of the unit sends an <b>sd_notify()</b> message and immediately exits, the service manager
       might not be able to properly attribute the message to the unit, and thus will ignore it, even if
       <u>NotifyAccess=</u><b>all</b> is set for it.

       Hence, to eliminate all race conditions involving lookup of the client's unit and attribution of
       notifications to units correctly, <b>sd_notify_barrier()</b> may be used. This call acts as a synchronization
       point and ensures all notifications sent before this call have been picked up by the service manager when
       it returns successfully. Use of <b>sd_notify_barrier()</b> is needed for clients which are not invoked by the
       service manager, otherwise this synchronization mechanism is unnecessary for attribution of notifications
       to the unit.

       <b>sd_notifyf()</b> is similar to <b>sd_notify()</b> but takes a <b>printf()</b>-like format string plus arguments.

       <b>sd_pid_notify()</b> and <b>sd_pid_notifyf()</b> are similar to <b>sd_notify()</b> and <b>sd_notifyf()</b> but take a process ID
       (PID) to use as originating PID for the message as first argument. This is useful to send notification
       messages on behalf of other processes, provided the appropriate privileges are available. Effectively,
       this means that a privileged invocation of <b>sd_pid_notify()</b> may circumvent <u>NotifyAccess=main</u> or
       <u>NotifyAccess=exec</u> restrictions enforced for a service. If the PID argument is specified as 0, the process
       ID of the calling process is used, in which case the calls are fully equivalent to <b>sd_notify()</b> and
       <b>sd_notifyf()</b>.

       <b>sd_pid_notify_with_fds()</b> is similar to <b>sd_pid_notify()</b> but takes an additional array of file descriptors.
       These file descriptors are sent along the notification message to the service manager. This is
       particularly useful for sending "FDSTORE=1" messages, as described above. The additional arguments are a
       pointer to the file descriptor array plus the number of file descriptors in the array. If the number of
       file descriptors is passed as 0, the call is fully equivalent to <b>sd_pid_notify()</b>, i.e. no file
       descriptors are passed. Note that file descriptors sent to the service manager on a message without
       "FDSTORE=1" are immediately closed on reception.

       <b>sd_pid_notifyf_with_fds()</b> is a combination of <b>sd_pid_notify_with_fds()</b> and <b>sd_notifyf()</b>, i.e. it accepts
       both a PID and a set of file descriptors as input, and processes a format string to generate the state
       string.

       <b>sd_notify_barrier()</b> allows the caller to synchronize against reception of previously sent notification
       messages and uses the <u>BARRIER=1</u> command. It takes a relative <u>timeout</u> value in microseconds which is
       passed to <b><a href="../man2/ppoll.2.html">ppoll</a></b>(2). A value of UINT64_MAX is interpreted as infinite timeout.

       <b>sd_pid_notify_barrier()</b> is just like <b>sd_notify_barrier()</b>, but allows specifying the originating PID for
       the notification message.

</pre><h4><b>WELL-KNOWN</b> <b>ASSIGNMENTS</b></h4><pre>
       The following assignments have a defined meaning:

       READY=1
           Tells the service manager that service startup is finished, or the service finished re-loading its
           configuration. This is only used by systemd if the service definition file has <u>Type=notify</u> or
           <u>Type=notify-reload</u> set. Since there is little value in signaling non-readiness, the only value
           services should send is "READY=1" (i.e.  "READY=0" is not defined).

       RELOADING=1
           Tells the service manager that the service is beginning to reload its configuration. This is useful
           to allow the service manager to track the service's internal state, and present it to the user. Note
           that a service that sends this notification must also send a "READY=1" notification when it completed
           reloading its configuration. Reloads the service manager is notified about with this mechanisms are
           propagated in the same way as they are when originally initiated through the service manager. This
           message is particularly relevant for <u>Type=notify-reload</u> services, to inform the service manager that
           the request to reload the service has been received and is now being processed.

           Added in version 217.

       STOPPING=1
           Tells the service manager that the service is beginning its shutdown. This is useful to allow the
           service manager to track the service's internal state, and present it to the user.

           Added in version 217.

       MONOTONIC_USEC=...
           A field carrying the monotonic timestamp (as per <b>CLOCK_MONOTONIC</b>) formatted in decimal in Î¼s, when
           the notification message was generated by the client. This is typically used in combination with
           "RELOADING=1", to allow the service manager to properly synchronize reload cycles. See
           <b><a href="../man5/systemd.service.5.html">systemd.service</a></b>(5) for details, specifically "Type=notify-reload".

           Added in version 253.

       STATUS=...
           Passes a single-line UTF-8 status string back to the service manager that describes the service
           state. This is free-form and can be used for various purposes: general state feedback, fsck-like
           programs could pass completion percentages and failing programs could pass a human-readable error
           message. Example: "STATUS=Completed 66% of file system check..."

           Added in version 233.

       NOTIFYACCESS=...
           Reset the access to the service status notification socket during runtime, overriding <u>NotifyAccess=</u>
           setting in the service unit file. See <b><a href="../man5/systemd.service.5.html">systemd.service</a></b>(5) for details, specifically "NotifyAccess="
           for a list of accepted values.

           Added in version 254.

       ERRNO=...
           If a service fails, the errno-style error code, formatted as string. Example: "ERRNO=2" for ENOENT.

           Added in version 233.

       BUSERROR=...
           If a service fails, the D-Bus error-style error code. Example:
           "BUSERROR=org.freedesktop.DBus.Error.TimedOut".

           Added in version 233.

       VARLINKERROR=...
           If a service fails, the Varlink error-style error code. Example:
           "VARLINKERROR=org.varlink.service.InvalidParameter".

           Added in version 257.

       EXIT_STATUS=...
           The exit status of a service or the manager itself. Note that <b>systemd</b> currently does not consume this
           value when sent by services, so this assignment is only informational. The manager will send this
           notification to <u>its</u> notification socket, which may be used to collect an exit status from the system
           (a container or VM) as it shuts down. For example, <b><a href="../man1/mkosi.1.html">mkosi</a></b>(1) makes use of this. The value to return
           may be set via the <b><a href="../man1/systemctl.1.html">systemctl</a></b>(1) <b>exit</b> verb.

           Added in version 254.

       MAINPID=...
           Change the main process ID (PID) of the service. This is especially useful in the case where the real
           main process is not directly forked off by the service manager. Example: "MAINPID=4711".

           Added in version 233.

       MAINPIDFDID=...
           The pidfd inode number of the new main process (specified through <u>MAINPID=</u>). This information can be
           acquired through <b><a href="../man2/fstat.2.html">fstat</a></b>(2) on the pidfd and is used to identify the process in a race-free fashion.
           Alternatively, a pidfd can be sent directly to the service manager (see <u>MAINPIDFD=1</u> below).

           Added in version 257.

       MAINPIDFD=1
           Similar to <u>MAINPID=</u> with <u>MAINPIDFDID=</u>, but the process is referenced directly by the pidfd passed to
           the service manager. This is useful if pidfd id is not supported on the system. Exactly one fd is
           expected for this notification.

           Added in version 257.

       WATCHDOG=1
           Tells the service manager to update the watchdog timestamp. This is the keep-alive ping that services
           need to issue in regular intervals if <u>WatchdogSec=</u> is enabled for it. See <b><a href="../man5/systemd.service.5.html">systemd.service</a></b>(5) for
           information how to enable this functionality and <b><a href="../man3/sd_watchdog_enabled.3.html">sd_watchdog_enabled</a></b>(3) for the details of how the
           service can check whether the watchdog is enabled.

       WATCHDOG=trigger
           Tells the service manager that the service detected an internal error that should be handled by the
           configured watchdog options. This will trigger the same behaviour as if <u>WatchdogSec=</u> is enabled and
           the service did not send "WATCHDOG=1" in time. Note that <u>WatchdogSec=</u> does not need to be enabled for
           "WATCHDOG=trigger" to trigger the watchdog action. See <b><a href="../man5/systemd.service.5.html">systemd.service</a></b>(5) for information about the
           watchdog behavior.

           Added in version 243.

       WATCHDOG_USEC=...
           Reset <u>watchdog_usec</u> value during runtime. Notice that this is not available when using
           <b>sd_event_set_watchdog()</b> or <b>sd_watchdog_enabled()</b>. Example : "WATCHDOG_USEC=20000000"

           Added in version 233.

       EXTEND_TIMEOUT_USEC=...
           Tells the service manager to extend the startup, runtime or shutdown service timeout corresponding
           the current state. The value specified is a time in microseconds during which the service must send a
           new message. A service timeout will occur if the message is not received, but only if the runtime of
           the current state is beyond the original maximum times of <u>TimeoutStartSec=</u>, <u>RuntimeMaxSec=</u>, and
           <u>TimeoutStopSec=</u>. See <b><a href="../man5/systemd.service.5.html">systemd.service</a></b>(5) for effects on the service timeouts.

           Added in version 236.

       FDSTORE=1
           Store file descriptors in the service manager. File descriptors sent this way will be held for the
           service by the service manager and will later be handed back using the usual file descriptor passing
           logic at the next start or restart of the service, see <b><a href="../man3/sd_listen_fds.3.html">sd_listen_fds</a></b>(3). Any open sockets and other
           file descriptors which should not be closed during a restart may be stored this way. When a service
           is stopped, its file descriptor store is discarded and all file descriptors in it are closed, except
           when overridden with <u>FileDescriptorStorePreserve=</u>, see <b><a href="../man5/systemd.service.5.html">systemd.service</a></b>(5).

           The service manager will accept messages for a service only if its <u>FileDescriptorStoreMax=</u> setting is
           non-zero (defaults to zero, see <b><a href="../man5/systemd.service.5.html">systemd.service</a></b>(5)). The service manager will set the <u>$FDSTORE</u>
           environment variable for services that have the file descriptor store enabled, see <b><a href="../man5/systemd.exec.5.html">systemd.exec</a></b>(5).

           If <u>FDPOLL=0</u> is not set and the file descriptors are pollable (see <b><a href="../man2/epoll_ctl.2.html">epoll_ctl</a></b>(2)), then any <b>EPOLLHUP</b> or
           <b>EPOLLERR</b> event seen on them will result in their automatic removal from the store.

           Multiple sets of file descriptors may be sent in separate messages, in which case the sets are
           combined. The service manager removes duplicate file descriptors (those pointing to the same object)
           before passing them to the service.

           This functionality should be used to implement services that can restart after an explicit request or
           a crash without losing state. Application state can either be serialized to a file in <a href="file:/run/">/run/</a>, or
           better, stored in a <b><a href="../man2/memfd_create.2.html">memfd_create</a></b>(2) memory file descriptor. Use <b>sd_pid_notify_with_fds()</b> to send
           messages with "FDSTORE=1". It is recommended to combine <u>FDSTORE=</u> with <u>FDNAME=</u> to make it easier to
           manage the stored file descriptors.

           For further information on the file descriptor store see the <b>File</b> <b>Descriptor</b> <b>Store</b>[1] overview.

           Added in version 219.

       FDSTOREREMOVE=1
           Removes file descriptors from the file descriptor store. This field needs to be combined with <u>FDNAME=</u>
           to specify the name of the file descriptors to remove.

           Added in version 236.

       FDNAME=...
           When used in combination with <u>FDSTORE=1</u>, specifies a name for the submitted file descriptors. When
           used with <u>FDSTOREREMOVE=1</u>, specifies the name for the file descriptors to remove. This name is passed
           to the service during activation, and may be queried using <b><a href="../man3/sd_listen_fds_with_names.3.html">sd_listen_fds_with_names</a></b>(3). File
           descriptors submitted without this field will be called "stored".

           The name may consist of arbitrary ASCII characters except control characters or ":". It may not be
           longer than 255 characters. If a submitted name does not follow these restrictions, it is ignored.

           Note that if multiple file descriptors are submitted in a single message, the specified name will be
           used for all of them. In order to assign different names to submitted file descriptors, submit them
           in separate messages.

           Added in version 233.

       FDPOLL=0
           When used in combination with <u>FDSTORE=1</u>, disables polling of the submitted file descriptors
           regardless of whether or not they are pollable. As this option disables automatic cleanup of the
           submitted file descriptors on EPOLLERR and EPOLLHUP, care must be taken to ensure proper manual
           cleanup. Use of this option is not generally recommended except for when automatic cleanup has
           unwanted behavior such as prematurely discarding file descriptors from the store.

           Added in version 246.

       BARRIER=1
           Tells the service manager that the client is explicitly requesting synchronization by means of
           closing the file descriptor sent with this command. The service manager guarantees that the
           processing of a <u>BARRIER=1</u> command will only happen after all previous notification messages sent
           before this command have been processed. Hence, this command accompanied with a single file
           descriptor can be used to synchronize against reception of all previous status messages. Note that
           this command cannot be mixed with other notifications, and has to be sent in a separate message to
           the service manager, otherwise all assignments will be ignored. Note that sending 0 or more than 1
           file descriptor with this command is a violation of the protocol.

           Added in version 246.

       The notification messages sent by services are interpreted by the service manager. Unknown assignments
       are ignored. Thus, it is safe (but often without effect) to send assignments which are not in this list.
       The protocol is extensible, but care should be taken to ensure private extensions are recognizable as
       such. Specifically, it is recommend to prefix them with "X_" followed by some namespace identifier. The
       service manager also sends some messages to <u>its</u> notification socket, which may then consumed by a
       supervising machine or container manager further up the stack. The service manager sends a number of
       extension fields, for example <u>X_SYSTEMD_UNIT_ACTIVE=</u>, for details see <b><a href="../man1/systemd.1.html">systemd</a></b>(1).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On failure, these calls return a negative errno-style error code. If <u>$NOTIFY_SOCKET</u> was not set and hence
       no status message could be sent, 0 is returned. If the status was sent, these functions return a positive
       value. In order to support both service managers that implement this scheme and those which do not, it is
       generally recommended to ignore the return value of this call. Note that the return value simply
       indicates whether the notification message was enqueued properly, it does not reflect whether the message
       could be processed successfully. Specifically, no error is returned when a file descriptor is attempted
       to be stored using <u>FDSTORE=1</u> but the service is not actually configured to permit storing of file
       descriptors (see above).

   <b>Errors</b>
       Returned errors may indicate the following problems:

       <b>-E2BIG</b>
           More file descriptors passed at once than the system allows. On Linux the number of file descriptors
           that may be passed across <b>AF_UNIX</b> sockets at once is 253, see <b><a href="../man7/unix.7.html">unix</a></b>(7) for details.

           Added in version 257.

</pre><h4><b>NOTES</b></h4><pre>
       Functions described here are available as a shared library, which can be compiled against and linked to
       with the <b>libsystemd</b> <b><a href="../man1/pkg-config.1.html">pkg-config</a></b>(1) file.

       The code described here uses <b><a href="../man3/getenv.3.html">getenv</a></b>(3), which is declared to be not multi-thread-safe. This means that
       the code calling the functions described here must not call <b><a href="../man3/setenv.3.html">setenv</a></b>(3) from a parallel thread. It is
       recommended to only do calls to <b>setenv()</b> from an early phase of the program when no other threads have
       been started.

       These functions send a single datagram with the state string as payload to the socket referenced in the
       <u>$NOTIFY_SOCKET</u> environment variable. If the first character of <u>$NOTIFY_SOCKET</u> is "/" or "@", the string
       is understood as an <b>AF_UNIX</b> or Linux abstract namespace socket (respectively), and in both cases the
       datagram is accompanied by the process credentials of the sending service, using SCM_CREDENTIALS. If the
       string starts with "vsock:" then the string is understood as an <b>AF_VSOCK</b> address, which is useful for
       hypervisors/VMMs or other processes on the host to receive a notification when a virtual machine has
       finished booting. Note that in case the hypervisor does not support <b>SOCK_DGRAM</b> over <b>AF_VSOCK</b>,
       <b>SOCK_SEQPACKET</b> will be used instead.  "vsock-stream", "vsock-dgram" and "vsock-seqpacket" can be used
       instead of "vsock" to force usage of the corresponding socket type. The address should be in the form:
       "vsock:CID:PORT". Note that unlike other uses of vsock, the CID is mandatory and cannot be
       "VMADDR_CID_ANY". Note that PID1 will send the VSOCK packets from a privileged port (i.e.: lower than
       1024), as an attempt to address concerns that unprivileged processes in the guest might try to send
       malicious notifications to the host, driving it to make destructive decisions based on them.

   <b>Standalone</b> <b>Implementations</b>
       Note that, while using this library should be preferred in order to avoid code duplication, it is also
       possible to reimplement the simple readiness notification protocol without external dependencies, as
       demonstrated in the following self-contained examples from several languages:

       <b>C</b>

               /* SPDX-License-Identifier: MIT-0 */

               /* Implement the systemd notify protocol without external dependencies.
                * Supports both readiness notification on startup and on reloading,
                * according to the protocol defined at:
                * https://www.freedesktop.org/software/systemd/man/latest/sd_notify.html
                * This protocol is guaranteed to be stable as per:
                * https://systemd.io/PORTABILITY_AND_STABILITY/ */

               #define _GNU_SOURCE 1
               #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
               #include &lt;<a href="file:/usr/include/inttypes.h">inttypes.h</a>&gt;
               #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;
               #include &lt;stdbool.h&gt;
               #include &lt;stddef.h&gt;
               #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
               #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
               #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
               #include &lt;sys/socket.h&gt;
               #include &lt;sys/un.h&gt;
               #include &lt;<a href="file:/usr/include/time.h">time.h</a>&gt;
               #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

               #define _cleanup_(f) __attribute__((cleanup(f)))

               static void closep(int *fd) {
                 if (!fd || *fd &lt; 0)
                   return;

                 close(*fd);
                 *fd = -1;
               }

               static int notify(const char *message) {
                 union sockaddr_union {
                   struct sockaddr sa;
                   struct sockaddr_un sun;
                 } socket_addr = {
                   .sun.sun_family = AF_UNIX,
                 };
                 size_t path_length, message_length;
                 _cleanup_(closep) int fd = -1;
                 const char *socket_path;

                 /* Verify the argument first */
                 if (!message)
                   return -EINVAL;

                 message_length = <a href="../manmessage/strlen.message.html">strlen</a>(message);
                 if (message_length == 0)
                   return -EINVAL;

                 /* If the variable is not set, the protocol is a noop */
                 socket_path = getenv("NOTIFY_SOCKET");
                 if (!socket_path)
                   return 0; /* Not set? Nothing to do */

                 /* Only AF_UNIX is supported, with path or abstract sockets */
                 if (socket_path[0] != '/' &amp;&amp; socket_path[0] != '@')
                   return -EAFNOSUPPORT;

                 path_length = strlen(socket_path);
                 /* Ensure there is room for NUL byte */
                 if (path_length &gt;= sizeof(socket_addr.sun.sun_path))
                   return -E2BIG;

                 memcpy(socket_addr.sun.sun_path, socket_path, path_length);

                 /* Support for abstract socket */
                 if (socket_addr.sun.sun_path[0] == '@')
                   socket_addr.sun.sun_path[0] = 0;

                 fd = socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC, 0);
                 if (fd &lt; 0)
                   return -errno;

                 if (connect(fd, &amp;socket_addr.sa, offsetof(struct sockaddr_un, sun_path) + path_length) != 0)
                   return -errno;

                 ssize_t written = write(fd, message, message_length);
                 if (written != (ssize_t) message_length)
                   return written &lt; 0 ? -errno : -EPROTO;

                 return 1; /* Notified! */
               }

               static int notify_ready(void) {
                 return notify("READY=1");
               }

               static int notify_reloading(void) {
                 /* A buffer with length sufficient to format the maximum UINT64 value. */
                 char reload_message[sizeof("RELOADING=1\nMONOTONIC_USEC=18446744073709551615")];
                 struct timespec ts;
                 uint64_t now;

                 /* Notify systemd that we are reloading, including a CLOCK_MONOTONIC timestamp in usec
                  * so that the program is compatible with a Type=notify-reload service. */

                 if (clock_gettime(CLOCK_MONOTONIC, &amp;ts) &lt; 0)
                   return -errno;

                 if (ts.tv_sec &lt; 0 || ts.tv_nsec &lt; 0 ||
                     (uint64_t) ts.tv_sec &gt; (UINT64_MAX - (ts.tv_nsec / 1000ULL)) / 1000000ULL)
                   return -EINVAL;

                 now = (uint64_t) ts.tv_sec * 1000000ULL + (uint64_t) ts.tv_nsec / 1000ULL;

                 if (snprintf(reload_message, sizeof(reload_message), "RELOADING=1\nMONOTONIC_USEC=%" PRIu64, now) &lt; 0)
                   return -EINVAL;

                 return notify(reload_message);
               }

               static int notify_stopping(void) {
                 return notify("STOPPING=1");
               }

               static volatile sig_atomic_t reloading = 0;
               static volatile sig_atomic_t terminating = 0;

               static void signal_handler(int sig) {
                 if (sig == SIGHUP)
                   reloading = 1;
                 else if (sig == SIGINT || sig == SIGTERM)
                   terminating = 1;
               }

               int main(int argc, char **argv) {
                 struct sigaction sa = {
                   .sa_handler = signal_handler,
                   .sa_flags = SA_RESTART,
                 };
                 int r;

                 /* Setup signal handlers */
                 sigemptyset(&amp;sa.sa_mask);
                 sigaction(SIGHUP, &amp;sa, NULL);
                 sigaction(SIGINT, &amp;sa, NULL);
                 sigaction(SIGTERM, &amp;sa, NULL);

                 /* Do more service initialization work here ... */

                 /* Now that all the preparations steps are done, signal readiness */

                 r = notify_ready();
                 if (r &lt; 0) {
                   fprintf(stderr, "Failed to notify readiness to $NOTIFY_SOCKET: %s\n", strerror(-r));
                   return EXIT_FAILURE;
                 }

                 while (!terminating) {
                   if (reloading) {
                     reloading = false;

                     /* As a separate but related feature, we can also notify the manager
                      * when reloading configuration. This allows accurate state-tracking,
                      * and also automated hook-in of 'systemctl reload' without having to
                      * specify manually an ExecReload= line in the unit file. */

                     r = notify_reloading();
                     if (r &lt; 0) {
                       fprintf(stderr, "Failed to notify reloading to $NOTIFY_SOCKET: %s\n", strerror(-r));
                       return EXIT_FAILURE;
                     }

                     /* Do some reconfiguration work here ... */

                     r = notify_ready();
                     if (r &lt; 0) {
                       fprintf(stderr, "Failed to notify readiness to $NOTIFY_SOCKET: %s\n", strerror(-r));
                       return EXIT_FAILURE;
                     }
                   }

                   /* Do some daemon work here ... */
                   <a href="../man5/sleep.5.html">sleep</a>(5);
                 }

                 r = notify_stopping();
                 if (r &lt; 0) {
                   fprintf(stderr, "Failed to report termination to $NOTIFY_SOCKET: %s\n", strerror(-r));
                   return EXIT_FAILURE;
                 }

                 /* Do some shutdown work here ... */

                 return EXIT_SUCCESS;
               }

       <b>Python</b>

               #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?env">/usr/bin/env</a> python3
               # SPDX-License-Identifier: MIT-0
               #
               # Implement the systemd notify protocol without external dependencies.
               # Supports both readiness notification on startup and on reloading,
               # according to the protocol defined at:
               # https://www.freedesktop.org/software/systemd/man/latest/sd_notify.html
               # This protocol is guaranteed to be stable as per:
               # https://systemd.io/PORTABILITY_AND_STABILITY/

               import errno
               import os
               import signal
               import socket
               import sys
               import time

               reloading = False
               terminating = False

               def <a href="../manmessage/notify.message.html">notify</a>(message):
                   if not message:
                       raise ValueError("notify() requires a message")

                   socket_path = os.environ.get("NOTIFY_SOCKET")
                   if not socket_path:
                       return

                   if socket_path[0] not in ("/", "@"):
                       raise OSError(errno.EAFNOSUPPORT, "Unsupported socket type")

                   # Handle abstract socket.
                   if socket_path[0] == "@":
                       socket_path = "\0" + socket_path[1:]

                   with socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM | socket.SOCK_CLOEXEC) as sock:
                       sock.connect(socket_path)
                       <a href="../manmessage/sock.sendall.message.html">sock.sendall</a>(message)

               def notify_ready():
                   notify(b"READY=1")

               def notify_reloading():
                   microsecs = time.clock_gettime_ns(time.CLOCK_MONOTONIC) // 1000
                   notify(f"RELOADING=1\nMONOTONIC_USEC={microsecs}".encode())

               def notify_stopping():
                   notify(b"STOPPING=1")

               def reload(signum, frame):
                   global reloading
                   reloading = True

               def terminate(signum, frame):
                   global terminating
                   terminating = True

               def main():
                   print("Doing initial setup")
                   global reloading, terminating

                   # Set up signal handlers.
                   print("Setting up signal handlers")
                   signal.signal(signal.SIGHUP, reload)
                   signal.signal(signal.SIGINT, terminate)
                   signal.signal(signal.SIGTERM, terminate)

                   # Do any other setup work here.

                   # Once all setup is done, signal readiness.
                   print("Done setting up")
                   notify_ready()

                   print("Starting loop")
                   while not terminating:
                       if reloading:
                           print("Reloading")
                           reloading = False

                           # Support notifying the manager when reloading configuration.
                           # This allows accurate state tracking as well as automatically
                           # enabling 'systemctl reload' without needing to manually
                           # specify an ExecReload= line in the unit file.

                           notify_reloading()

                           # Do some reconfiguration work here.

                           print("Done reloading")
                           notify_ready()

                       # Do the real work here ...

                       print("Sleeping for five seconds")
                       <a href="../man5/time.sleep.5.html">time.sleep</a>(5)

                   print("Terminating")
                   notify_stopping()

               if __name__ == "__main__":
                   sys.stdout.reconfigure(line_buffering=True)
                   print("Starting app")
                   main()
                   print("Stopped app")

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       <u>$NOTIFY_SOCKET</u>
           Set by the service manager for supervised processes for status and start-up completion notification.
           This environment variable specifies the socket <b>sd_notify()</b> talks to. See above for details.

</pre><h4><b>EXAMPLES</b></h4><pre>
       <b>Example</b> <b>1.</b> <b>Start-up</b> <b>Notification</b>

       When a service finished starting up, it might issue the following call to notify the service manager:

           sd_notify(0, "READY=1");

       <b>Example</b> <b>2.</b> <b>Extended</b> <b>Start-up</b> <b>Notification</b>

       A service could send the following after completing initialization:

           sd_notifyf(0, "READY=1\n"
                         "STATUS=Processing requests...\n"
                         "MAINPID=%lu",
                      (unsigned long) getpid());

       <b>Example</b> <b>3.</b> <b>Error</b> <b>Cause</b> <b>Notification</b>

       A service could send the following shortly before exiting, on failure:

           sd_notifyf(0, "STATUS=Failed to start up: %s\n"
                         "ERRNO=%i",
                      strerror_r(errnum, (char[1024]){}, 1024),
                      errnum);

       <b>Example</b> <b>4.</b> <b>Store</b> <b>a</b> <b>File</b> <b>Descriptor</b> <b>in</b> <b>the</b> <b>Service</b> <b>Manager</b>

       To store an open file descriptor in the service manager, in order to continue operation after a service
       restart without losing state, use "FDSTORE=1":

           sd_pid_notify_with_fds(0, 0, "FDSTORE=1\nFDNAME=foobar", &amp;fd, 1);

       <b>Example</b> <b>5.</b> <b>Eliminating</b> <b>race</b> <b>conditions</b>

       When the client sending the notifications is not spawned by the service manager, it may exit too quickly
       and the service manager may fail to attribute them correctly to the unit. To prevent such races, use
       <b>sd_notify_barrier()</b> to synchronize against reception of all notifications sent before this call is made.

           sd_notify(0, "READY=1");
           /* set timeout to 5 seconds */
           sd_notify_barrier(0, 5 * 1000000);

</pre><h4><b>HISTORY</b></h4><pre>
       <b>sd_pid_notify()</b>, <b>sd_pid_notifyf()</b>, and <b>sd_pid_notify_with_fds()</b> were added in version 219.

       <b>sd_notify_barrier()</b> was added in version 246.

       <b>sd_pid_notifyf_with_fds()</b> and <b>sd_pid_notify_barrier()</b> were added in version 254.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/systemd.1.html">systemd</a></b>(1), <b><a href="../man3/sd-daemon.3.html">sd-daemon</a></b>(3), <b><a href="../man3/sd_listen_fds.3.html">sd_listen_fds</a></b>(3), <b><a href="../man3/sd_listen_fds_with_names.3.html">sd_listen_fds_with_names</a></b>(3), <b><a href="../man3/sd_watchdog_enabled.3.html">sd_watchdog_enabled</a></b>(3),
       <b><a href="../man7/daemon.7.html">daemon</a></b>(7), <b><a href="../man5/systemd.service.5.html">systemd.service</a></b>(5)

</pre><h4><b>NOTES</b></h4><pre>
        1. File Descriptor Store
           https://systemd.io/FILE_DESCRIPTOR_STORE

systemd 257.7                                                                                       <u><a href="../man3/SD_NOTIFY.3.html">SD_NOTIFY</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>