<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>aliased - Use shorter versions of class names.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libaliased-perl">libaliased-perl_0.34-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       aliased - Use shorter versions of class names.

</pre><h4><b>VERSION</b></h4><pre>
       version 0.34

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # Class name interface
         use aliased 'My::Company::Namespace::Customer';
         my $cust = Customer-&gt;new;

         use aliased 'My::Company::Namespace::Preferred::Customer' =&gt; 'Preferred';
         my $pref = Preferred-&gt;new;

         # Variable interface
         use aliased;
         my $Customer  = alias "My::Other::Namespace::Customer";
         my $cust      = $Customer-&gt;new;

         my $Preferred = alias "My::Other::Namespace::Preferred::Customer";
         my $pref      = $Preferred-&gt;new;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "aliased" is simple in concept but is a rather handy module.  It loads the class you specify and exports
       into your namespace a subroutine that returns the class name.  You can explicitly alias the class to
       another name or, if you prefer, you can do so implicitly.  In the latter case, the name of the subroutine
       is the last part of the class name.  Thus, it does something similar to the following:

         #use aliased 'Some::Annoyingly::Long::Module::Name::Customer';

         use Some::Annoyingly::Long::Module::Name::Customer;
         sub Customer {
           return 'Some::Annoyingly::Long::Module::Name::Customer';
         }
         my $cust = Customer-&gt;new;

       This module is useful if you prefer a shorter name for a class.  It's also handy if a class has been
       renamed.

       (Some may object to the term "aliasing" because we're not aliasing one namespace to another, but it's a
       handy term.  Just keep in mind that this is done with a subroutine and not with typeglobs and weird
       namespace munging.)

       Note that this is <b>only</b> for "use"ing OO modules.  You cannot use this to load procedural modules.  See the
       "Why OO Only?" section.  Also, don't let the version number fool you.  This code is ridiculously simple
       and is just fine for most use.

   <b>Implicit</b> <b>Aliasing</b>
       The most common use of this module is:

         use aliased 'Some::Module::name';

       "aliased" will  allow you to reference the class by the last part of the class name.  Thus,
       "Really::Long::Name" becomes "Name".  It does this by exporting a subroutine into your namespace with the
       same name as the aliased name.  This subroutine returns the original class name.

       For example:

         use aliased "Acme::Company::Customer";
         my $cust = Customer-&gt;find($id);

       Note that any class method can be called on the shorter version of the class name, not just the
       constructor.

   <b>Explicit</b> <b>Aliasing</b>
       Sometimes two class names can cause a conflict (they both end with "Customer" for example), or you
       already have a subroutine with the same name as the aliased name.  In that case, you can make an explicit
       alias by stating the name you wish to alias to:

         use aliased 'Original::Module::Name' =&gt; 'NewName';

       Here's how we use "aliased" to avoid conflicts:

         use aliased "Really::Long::Name";
         use aliased "Another::Really::Long::Name" =&gt; "Aname";
         my $name  = Name-&gt;new;
         my $aname = Aname-&gt;new;

       You can even alias to a different package:

         use aliased "Another::Really::Long::Name" =&gt; "Another::Name";
         my $aname = Another::Name-&gt;new;

       Messing around with different namespaces is a really bad idea and you probably don't want to do this.
       However, it might prove handy if the module you are using has been renamed.  If the interface has not
       changed, this allows you to use the new module by only changing one line of code.

         use aliased "New::Module::Name" =&gt; "Old::Module::Name";
         my $thing = Old::Module::Name-&gt;new;

   <b>Import</b> <b>Lists</b>
       Sometimes, even with an OO module, you need to specify extra arguments when using the module.  When this
       happens, simply use "Explicit Aliasing" followed by the import list:

       Snippet 1:

         use Some::Module::Name qw/foo bar/;
         my $o = Some::Module::Name-&gt;some_class_method;

       Snippet 2 (equivalent to snippet 1):

         use aliased 'Some::Module::Name' =&gt; 'Name', qw/foo bar/;
         my $o = Name-&gt;some_class_method;

       <b>Note</b>:  remember, you cannot use import lists with "Implicit Aliasing".  As a result, you may simply
       prefer to only use "Explicit Aliasing" as a matter of style.

   <b>alias()</b>
       This function is only exported if you specify "use aliased" with no import list.

           use aliased;
           my $alias = alias($class);
           my $alias = alias($class, @imports);

       "alias()" is an alternative to "use aliased ..." which uses less magic and avoids some of the
       ambiguities.

       Like "use aliased" it "use"s the $class (pass in @imports, if given) but instead of providing an "Alias"
       constant it simply returns a scalar set to the $class name.

           my $thing = alias("Some::Thing::With::A::Long::Name");

           # Just like Some::Thing::With::A::Long::Name-&gt;method
           $thing-&gt;method;

       The use of a scalar instead of a constant avoids any possible ambiguity when aliasing two similar names:

           # No ambiguity despite the fact that they both end with "Name"
           my $thing = alias("Some::Thing::With::A::Long::Name");
           my $other = alias("Some::Other::Thing::With::A::Long::Name");

       and there is no magic constant exported into your namespace.

       The only caveat is loading of the $class happens at run time.  If $class exports anything you might want
       to ensure it is loaded at compile time with:

           my $thing;
           BEGIN { $thing = alias("Some::Thing"); }

       However, since OO classes rarely export this should not be necessary.

   <b>prefix()</b> <b>(experimental)</b>
       This function is only exported if you specify "use aliased" with no import list.

           use aliased;

       Sometimes you find you have a ton of packages in the same top-level namespace and you want to alias them,
       but only use them on demand.  For example:

           # instead of:
           MailVerwaltung::Client::Exception::REST::Response-&gt;throw()

           my $error = prefix('MailVerwaltung::Client::Exception');
           $error-&gt;('REST::Response')-&gt;throw();   # same as above
           $error-&gt;()-&gt;throw; # same as MailVerwaltung::Client::Exception-&gt;throw

   <b>Why</b> <b>OO</b> <b>Only?</b>
       Some people have asked why this code only support object-oriented modules (OO).  If I were to support
       normal subroutines, I would have to allow the following syntax:

         use aliased 'Some::Really::Long::Module::Name';
         my $data = Name::data();

       That causes a serious problem.  The only (reasonable) way it can be done is to handle the aliasing via
       typeglobs.  Thus, instead of a subroutine that provides the class name, we alias one package to another
       (as the namespace module does.)  However, we really don't want to simply alias one package to another and
       wipe out namespaces willy-nilly.  By merely exporting a single subroutine to a namespace, we minimize the
       issue.

       Fortunately, this doesn't seem to be that much of a problem.  Non-OO modules generally support exporting
       of the functions you need and this eliminates the need for a module such as this.

</pre><h4><b>EXPORT</b></h4><pre>
       This modules exports a subroutine with the same name as the "aliased" name.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The namespace module.

</pre><h4><b>THANKS</b></h4><pre>
       Many thanks to Rentrak, Inc. (<a href="http://www.rentrak.com/">http://www.rentrak.com/</a>) for graciously allowing me to replicate the
       functionality of some of their internal code.

</pre><h4><b>AUTHOR</b></h4><pre>
       Curtis "Ovid" Poe &lt;<a href="mailto:ovid@cpan.org">ovid@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2005 by Curtis "Ovid" Poe.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   Curtis Poe &lt;<a href="mailto:ovid@cpan.org">ovid@cpan.org</a>&gt;

       •   Ovid &lt;<a href="mailto:curtis_ovid_poe@yahoo.com">curtis_ovid_poe@yahoo.com</a>&gt;

       •   Florian Ragwitz &lt;<a href="mailto:rafl@debian.org">rafl@debian.org</a>&gt;

       •   Grzegorz RoXniecki &lt;<a href="mailto:xaerxess@gmail.com">xaerxess@gmail.com</a>&gt;

       •   Father Chrysostomos &lt;<a href="mailto:sprout@cpan.org">sprout@cpan.org</a>&gt;

       •   Belden Lyman &lt;<a href="mailto:belden@shutterstock.com">belden@shutterstock.com</a>&gt;

       •   Olivier Mengue &lt;<a href="mailto:dolmen@cpan.org">dolmen@cpan.org</a>&gt;

perl v5.36.0                                       2022-10-21                                       <u><a href="../man3pm/aliased.3pm.html">aliased</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>