<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bread::Board - A solderless way to wire up your application components</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbread-board-perl">libbread-board-perl_0.37-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bread::Board - A solderless way to wire up your application components

</pre><h4><b>VERSION</b></h4><pre>
       version 0.37

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Bread::Board;

         my $c = container 'MyApp' =&gt; as {

             service 'log_file_name' =&gt; "logfile.log";

             service 'logger' =&gt; (
                 class        =&gt; 'FileLogger',
                 lifecycle    =&gt; 'Singleton',
                 dependencies =&gt; [ 'log_file_name' ],
             );

             container 'Database' =&gt; as {
                 service 'dsn'      =&gt; "dbi:SQLite:dbname=my-app.db";
                 service 'username' =&gt; "user234";
                 service 'password' =&gt; "****";

                 service 'dbh' =&gt; (
                     block =&gt; sub {
                         my $s = shift;
                         require DBI;
                         DBI-&gt;connect(
                             $s-&gt;param('dsn'),
                             $s-&gt;param('username'),
                             $s-&gt;param('password'),
                         ) || die "Could not connect";
                     },
                     dependencies =&gt; [ 'dsn', 'username', 'password' ]
                 );
             };

             service 'application' =&gt; (
                 class        =&gt; 'MyApplication',
                 dependencies =&gt; {
                     logger =&gt; 'logger',
                     dbh    =&gt; 'Database/dbh',
                 }
             );

         };

         no Bread::Board; # removes keywords

         # get an instance of MyApplication
         # from the container
         my $app = $c-&gt;resolve( service =&gt; 'application' );

         # now user your MyApplication
         # as you normally would ...
         $app-&gt;run;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Bread::Board is an inversion of control framework with a focus on dependency injection and lifecycle
       management. It's goal is to help you write more decoupled objects and components by removing the need for
       you to manually wire those objects/components together.

       Want to know more? See the Bread::Board::Manual.

         +-----------------------------------------+
         |          A B C D E   F G H I J          |
         |-----------------------------------------|
         | o o |  1 o-o-o-o-o v o-o-o-o-o 1  | o o |
         | o o |  2 o-o-o-o-o   o-o-o-o-o 2  | o o |
         | o o |  3 o-o-o-o-o   o-o-o-o-o 3  | o o |
         | o o |  4 o-o-o-o-o   o-o-o-o-o 4  | o o |
         | o o |  5 o-o-o-o-o   o-o-o-o-o 5  | o o |
         |     |  6 o-o-o-o-o   o-o-o-o-o 6  |     |
         | o o |  7 o-o-o-o-o   o-o-o-o-o 7  | o o |
         | o o |  8 o-o-o-o-o   o-o-o-o-o 8  | o o |
         | o o |  9 o-o-o-o-o   o-o-o-o-o 9  | o o |
         | o o | 10 o-o-o-o-o   o-o-o-o-o 10 | o o |
         | o o | 11 o-o-o-o-o   o-o-o-o-o 11 | o o |
         |     | 12 o-o-o-o-o   o-o-o-o-o 12 |     |
         | o o | 13 o-o-o-o-o   o-o-o-o-o 13 | o o |
         | o o | 14 o-o-o-o-o   o-o-o-o-o 14 | o o |
         | o o | 15 o-o-o-o-o   o-o-o-o-o 15 | o o |
         | o o | 16 o-o-o-o-o   o-o-o-o-o 16 | o o |
         | o o | 17 o-o-o-o-o   o-o-o-o-o 17 | o o |
         |     | 18 o-o-o-o-o   o-o-o-o-o 18 |     |
         | o o | 19 o-o-o-o-o   o-o-o-o-o 19 | o o |
         | o o | 20 o-o-o-o-o   o-o-o-o-o 20 | o o |
         | o o | 21 o-o-o-o-o   o-o-o-o-o 21 | o o |
         | o o | 22 o-o-o-o-o   o-o-o-o-o 22 | o o |
         | o o | 22 o-o-o-o-o   o-o-o-o-o 22 | o o |
         |     | 23 o-o-o-o-o   o-o-o-o-o 23 |     |
         | o o | 24 o-o-o-o-o   o-o-o-o-o 24 | o o |
         | o o | 25 o-o-o-o-o   o-o-o-o-o 25 | o o |
         | o o | 26 o-o-o-o-o   o-o-o-o-o 26 | o o |
         | o o | 27 o-o-o-o-o   o-o-o-o-o 27 | o o |
         | o o | 28 o-o-o-o-o ^ o-o-o-o-o 28 | o o |
         +-----------------------------------------+

       Loading this package will automatically load the rest of the packages needed by your Bread::Board
       configuration.

</pre><h4><b>EXPORTED</b> <b>FUNCTIONS</b></h4><pre>
       The functions of this package provide syntactic sugar to help you build your Bread::Board configuration.
       You can build such a configuration by constructing the objects manually instead, but your code may be
       more difficult to understand.

   <b>"container"</b>
       <u>simple</u> <u>case</u>

         container $name, \&amp;body;

       This function constructs and returns an instance of Bread::Board::Container.  The (optional) &amp;body block
       may be used to add services or sub-containers within the newly constructed container. Usually, the block
       is not passed directly, but passed using the "as" function.

       For example,

         container 'MyWebApp' =&gt; as {
             service my_dispatcher =&gt; (
                 class =&gt; 'MyWebApp::Dispatcher',
             );
         };

       If $name starts with '+', and the container is being declared inside another container, then this
       declaration will instead extend an existing container with the name $name (without the '+').

       <u>from</u> <u>an</u> <u>instance</u>

         container $container_instance, \&amp;body

       In many cases, subclassing Bread::Board::Container is the easiest route to getting access to this
       framework. You can do this and still get all the benefits of the syntactic sugar for configuring that
       class by passing an instance of your container subclass to "container".

       You could, for example, configure your container inside the "BUILD" method of your class:

         package MyWebApp;
         use Moose;

         extends 'Bread::Board::Container';

         sub BUILD {
             my $self = shift;

             container $self =&gt; as {
                 service dbh =&gt; ( ... );
             };
         }

       <u>with</u> <u>parameters</u>

         container $name, \@parameters, \&amp;body

       A third way of using the "container" function is to build a parameterized container. These are useful as
       a way of providing a placeholder for parts of the configuration that may be provided later. You may not
       use an instance object in place of the $name in this case.

       For more detail on how you might use parameterized containers, see "Parameterized Containers" in
       Bread::Board::Manual::Concepts::Advanced.

   <b>"as"</b>
         as { some_code() };

       This is just a replacement for the "sub" keyword that is easier to read when defining containers.

   <b>"service"</b>
         service $name, $literal;
         service $name, %service_description;

       Within the "as" blocks for your containers, you may construct services using the "service" function. This
       can construct several different kinds of services based upon how it is called.

       <u>literal</u> <u>services</u>

       To build a literal service (a Bread::Board::Literal object), just specify a scalar value or reference you
       want to use as the literal value:

         # In case you need to adjust the gravitational constant of the Universe
         service gravitational_constant =&gt; 6.673E-11;

       <u>using</u> <u>injections</u>

       To build a service using one of the injection services, just fill in all the details required to use that
       sort of injection:

         service search_service =&gt; (
             class =&gt; 'MyApp::Search',
             block =&gt; sub {
                 my $s = shift;
                 MyApp::Search-&gt;new($s-&gt;param('url'), $s-&gt;param('type'));
             },
             dependencies =&gt; {
                 url =&gt; 'search_url',
             },
             parameters =&gt; {
                 type =&gt; { isa =&gt; 'Str', default =&gt; 'text' },
             },
         );

       The type of injection performed depends on the parameters used. You may use the "service_class" parameter
       to pick a specific injector class. For instance, this is useful if you need to use
       Bread::Board::SetterInjection or have defined a custom injection service.  If you specify a "block",
       block injection will be performed using Bread::Board::BlockInjection. If neither of these is present,
       constructor injection will be used with Bread::Board::ConstructorInjection (and you must provide the
       "class" option).

       <u>service</u> <u>dependencies</u>

       The "dependencies" parameter takes a hashref of dependency names mapped to Bread::Board::Dependency
       objects, but there are several coercions and sugar functions available to make specifying dependencies as
       easy as possible. The simplest case is when the names of the services you're depending on are the same as
       the names that the service you're defining will be accessing them with.  In this case, you can just
       specify an arrayref of service names:

         service foo =&gt; (
             dependencies =&gt; [ 'bar', 'baz' ],
             # ...
         );

       If you need to use a different name, you can specify the dependencies as a hashref instead:

         service foo =&gt; (
             dependencies =&gt; {
                 dbh =&gt; 'foo_dbh',
             },
             # ...
         );

       You can also specify parameters when depending on a parameterized service:

         service foo =&gt; (
             dependencies =&gt; [
                 { bar =&gt; { bar_param =&gt; 1 } },
                 'baz',
             ],
             # ...
         );

       Finally, services themselves can also be specified as dependencies, in which case they will just be
       resolved directly:

         service foo =&gt; (
             dependencies =&gt; {
                 dsn =&gt; Bread::Board::Literal-&gt;new(
                     name  =&gt; 'dsn',
                     value =&gt; 'dbi:mysql:mydb',
                 ),
             },
             # ...
         );

       As a special case, an arrayref of dependencies will be interpreted as a service which returns an arrayref
       containing the resolved values of those dependencies:

         service foo =&gt; (
             dependencies =&gt; {
                 # items will resolve to [ $bar_service-&gt;get, $baz_service-&gt;get ]
                 items =&gt; [
                     'bar',
                     Bread::Board::Literal-&gt;new(name =&gt; 'baz', value =&gt; 'BAZ'),
                 ],
             },
             # ...
         );

       <u>inheriting</u> <u>and</u> <u>extending</u> <u>services</u>

       If the $name starts with a '+', the service definition will instead extend an existing service with the
       given $name (without the '+'). This works similarly to the "has '+foo'" syntax in Moose. It is most
       useful when defining a container class where the container is built up in "BUILD" methods, as each class
       in the inheritance hierarchy can modify services defined in superclasses. The "dependencies" and
       "parameters" options will be merged with the existing values, rather than overridden. Note that literal
       services can't be extended, because there's nothing to extend. You can still override them entirely by
       declaring the service name without a leading '+'.

   <b>"literal"</b>
         literal($value);

       Creates an anonymous Bread::Board::Literal object with the given value.

                 service 'dbh' =&gt; (
                     block =&gt; sub {
                         my $s = shift;
                         require DBI;
                         DBI-&gt;connect(
                             $s-&gt;param('dsn'),
                             $s-&gt;param('username'),
                             $s-&gt;param('password'),
                         ) || die "Could not connect";
                     },
                     dependencies =&gt; {
                       dsn      =&gt; literal 'dbi:SQLite:somedb',
                       username =&gt; literal 'foo',
                       password =&gt; literal 'password',

                     },
                 );

   <b>"depends_on"</b>
         depends_on($service_path);

       The "depends_on" function creates a Bread::Board::Dependency object for the named $service_path and
       returns it.

   <b>"wire_names"</b>
         wire_names(@service_names);

       This function is just a shortcut for passing a hash reference of dependencies into the service. It is not
       typically needed, since Bread::Board can usually understand what you mean - these declarations are all
       equivalent:

         service foo =&gt; (
             class =&gt; 'Pity::TheFoo',
             dependencies =&gt; {
                 foo =&gt; depends_on('foo'),
                 bar =&gt; depends_on('bar'),
                 baz =&gt; depends_on('baz'),
             },
         );

         service foo =&gt; (
             class =&gt; 'Pity::TheFoo',
             dependencies =&gt; wire_names(qw( foo bar baz )),
         );

         service foo =&gt; (
             class =&gt; 'Pity::TheFoo',
             dependencies =&gt; {
                 foo =&gt; 'foo',
                 bar =&gt; 'bar',
                 baz =&gt; 'baz',
             },
         );

         service foo =&gt; (
             class =&gt; 'Pity::TheFoo',
             dependencies =&gt; [ qw(foo bar baz ) ],
         );

   <b>"typemap"</b>
         typemap $type, $service;
         typemap $type, $service_path;

       This creates a type mapping for the named type. Typically, it is paired with the "infer" call like so:

         typemap 'MyApp::Model::UserAccount' =&gt; infer;

       For more details on what type mapping is and how it works, see Bread::Board::Manual::Concepts::Typemap.

   <b>"infer"</b>
         infer;
         infer(%hints);

       This is used with "typemap" to help create the typemap inference. It can be used with no arguments to do
       everything automatically. However, in some cases, you may want to pass a service instance as the argument
       or a hash of service arguments to change how the type map works. For example, if your type needs to be
       constructed using a setter injection, you can use an inference similar to this:

         typemap 'MyApp::Model::UserPassword' =&gt; infer(
             service_class =&gt; 'Bread::Board::SetterInjection',
         );

       For more details on what type mapping is and how it works, see Bread::Board::Manual::Concepts::Typemap.

   <b>"include"</b>
         include $file;

       This is a shortcut for loading a Bread::Board configuration from another file.

         include "filename.pl";

       The above is pretty much identical to running:

         do "filename.pl";

       However, you might find it more readable to use "include".

   <b>"alias"</b>
         alias $service_name, $service_path, %service_description;

       This helper allows for the creation of service aliases, which allows you to define a service in one place
       and then reuse that service with a different name somewhere else. This is sort of like a symbolic link
       for services. Aliases will be resolved recursively, so an alias can alias an alias.

       For example,

         service file_logger =&gt; (
             class =&gt; 'MyApp::Logger::File',
         );

         alias my_logger =&gt; 'file_logger';

</pre><h4><b>OTHER</b> <b>FUNCTIONS</b></h4><pre>
       These are not exported, but might be helpful to you.

   <b>"set_root_container"</b>
         set_root_container $container;

       You may use this to set a top-level root container for all container definitions.

       For example,

         my $app = container MyApp =&gt; as { ... };

         Bread::Board::set_root_container($app);

         my $config = container Config =&gt; as { ... };

       Here the $config container would be created as a sub-container of $app.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to Daisuke Maki for his contributions and for really pushing the development of this module along.

       Chuck "sprongie" Adams, for testing/using early (pre-release) versions of this module, and some good
       suggestions for naming it.

       Matt "mst" Trout, for finally coming up with the best name for this module.

       Gianni "dakkar" Ceccarelli for writing lots of documentation, and Net-a-Porter.com for paying his salary
       while he was doing it.

</pre><h4><b>ARTICLES</b></h4><pre>
       Bread::Board is the right tool for this job
       &lt;<a href="http://domm.plix.at/perl/2013_04_bread_board_is_the_right_rool_for_this_job.html">http://domm.plix.at/perl/2013_04_bread_board_is_the_right_rool_for_this_job.html</a>&gt; Thomas Klausner
       showing a use-case for Bread::Board.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Bread::Board::Declare
           This provides more powerful syntax for writing Bread::Board container classes.

       IOC Bread::Board is basically my re-write of IOC.

       &lt;<a href="http://en.wikipedia.org/wiki/Breadboard">http://en.wikipedia.org/wiki/Breadboard</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Stevan Little &lt;<a href="mailto:stevan@iinteractive.com">stevan@iinteractive.com</a>&gt;

</pre><h4><b>BUGS</b></h4><pre>
       Please     report     any     bugs     or     feature     requests     on    the    bugtracker    website
       https://github.com/stevan/BreadBoard/issues

       When submitting a bug or request, please include a test-file or a patch to  an  existing  test-file  that
       illustrates the bug or desired feature.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2019, 2017, 2016, 2015, 2014, 2013, 2011, 2009 by Infinity Interactive.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.36.0                                       2022-12-12                                  <u>Bread::<a href="../man3pm/Board.3pm.html">Board</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>