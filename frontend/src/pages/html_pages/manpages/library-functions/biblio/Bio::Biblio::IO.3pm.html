<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::Biblio::IO - Handling the bibliographic references</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-biblio-perl">libbio-biblio-perl_1.70-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::Biblio::IO - Handling the bibliographic references

</pre><h4><b>VERSION</b></h4><pre>
       version 1.70

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Bio::Biblio::IO;

           # getting citations from a file
           $in = Bio::Biblio::IO-&gt;new ('-file' =&gt; 'myfile.xml' ,
                                       '-format' =&gt; 'medlinexml');
         # --- OR ---

           # getting citations from a string
           $in = Bio::Biblio::IO-&gt;new ('-data' =&gt; '&lt;MedlineCitation&gt;...&lt;/MedlineCitation&gt;' ,
                                       '-format' =&gt; 'medlinexml');
         #--- OR ---

           # getting citations from a string if IO::String is installed
           use IO::String;
           $in = Bio::Biblio::IO-&gt;new ('-fh' =&gt; IO::String-&gt;new ($citation),
                                       '-format' =&gt; 'medlinexml');

           $in = Bio::Biblio::IO-&gt;new(-fh =&gt; $io_handle , '-format' =&gt; 'medlinexml');

         #--- OR ---

           # getting citations from any IO handler
           $in = Bio::Biblio::IO-&gt;new('-fh' =&gt; $io_handle ,
                                      '-format' =&gt; 'medlinexml');

           # now, having $in, we can read all citations
           while ( my $citation = $in-&gt;next_bibref() ) {
               &amp;do_something_with_citation ($citation);
           }

         #--- OR ---

           # again reading all citation but now a callback defined in your
           # code is used (note that the reading starts already when new()
           # is called)
           $io = Bio::Biblio::IO-&gt;new('-format'   =&gt; 'medlinexml',
                                      '-file'     =&gt; $testfile,
                                      '-callback' =&gt; \&amp;callback);
           sub callback {
               my $citation = shift;
               print $citation-&gt;{'_identifier'} . "\n";
           }

         #Now, to actually get a citation in an XML format,
         #use I&lt;Bio::Biblio&gt; module which returns an XML string:

           use Bio::Biblio;
           use Bio::Biblio::IO;
           my $xml = Bio::Biblio-&gt;new-&gt;get_by_id ('12368254');
           my $reader = Bio::Biblio::IO-&gt;new ('-data' =&gt; $xml,
                                              '-format' =&gt; 'medlinexml');

           while (my $citation = $reader-&gt;next_bibref()) {
              #... do something here with $citation
              }

         #And, finally, the resulting citation can be received in different
         #output formats:

           $io = Bio::Biblio::IO-&gt;new('-format' =&gt; 'medlinexml',
                                      '-result' =&gt; 'raw');
         #--- OR ---

           $io = Bio::Biblio::IO-&gt;new('-format' =&gt; 'medlinexml',
                                      '-result' =&gt; 'medline2ref');

         #--- OR ---

           $io = Bio::Biblio::IO-&gt;new('-format' =&gt; 'pubmedxml',
                                      '-result' =&gt; 'pubmed2ref');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Bio::Biblio::IO is a handler module for accessing bibliographic citations. The citations can be in
       different formats - assuming that there is a corresponding module knowing that format in Bio::Biblio::IO
       directory (e.g. Bio::Biblio::IO::medlinexml). The format (and the module name) is given by the argument
       <u>-format</u>.

       Once an instance of "Bio::Biblio::IO" class is available, the citations can be read by calling repeatedly
       method <u>next_bibref</u>:

           while (my $citation = $reader-&gt;next_bibref()) {
              ... do something here with $citation
              }

       However, this may imply that all citations were already read into the memory. If you expect a huge amount
       of citations to be read, you may choose a <u>callback</u> option. Your subroutine is specified in the "new()"
       method and is called everytime a new citation is available (see an example above in SYNOPSIS).

       The citations returned by <u>next_bibref</u> or given to your callback routine can be of different formats
       depending on the argument <u>-result</u>. One result type is <u>raw</u> and it is represented by a simple, not blessed
       hash table:

           $io = Bio::Biblio::IO-&gt;new('-result' =&gt; 'raw');

       What other result formats are available depends on the module who reads the citations in the first place.
       At the moment, the following ones are available:

           $io = Bio::Biblio::IO-&gt;new('-result' =&gt; 'medline2ref');

       This is a default result format for reading citations by the <u>medlinexml</u> module. The "medlinexml" module
       is again the default one. Which means that you can almost omit arguments (you still need to say where the
       citations come from):

           $io = Bio::Biblio::IO-&gt;new('-file' =&gt; 'data/medline_data.xml');

       Another result format available is for PUBMED citations (which is a super-set of the MEDLINE citations
       having few more tags):

           $io = Bio::Biblio::IO-&gt;new('-format' =&gt; 'pubmedxml',
                                      '-result' =&gt; 'pubmed2ref',
                                      '-data'   =&gt; $citation);

       Or, because "pubmed2ref" is a default one for PUBMED citations, you can say just:

           $io = Bio::Biblio::IO-&gt;new('-format' =&gt; 'pubmedxml',
                                      '-data'   =&gt; $citation);

       Both "medline2ref" and "pubmed2ref" results are objects defined in the directory "Bio::Biblio".

</pre><h4><b>ATTRIBUTES</b></h4><pre>
   <b>fh</b>
</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
   <b>newFh</b>
   <b>next_bibref</b>
        Usage   : $citation = stream-&gt;next_bibref
        Function: Reads the next citation object from the stream and returns it.
        Returns : a Bio::Biblio::Ref citation object, or something else
                  (depending on the '-result' argument given in the 'new()'
                  method).
        Args    : none

   <b>DESTROY</b>
   <b>TIEHANDLE</b>
   <b>READLINE</b>
</pre><h4><b>INTERNAL</b> <b>METHODS</b></h4><pre>
   <b>_initialize</b>
   <b>_load_format_module</b>
        Usage   : $class-&gt;_load_format_module ($format)
        Returns : 1 on success, undef on failure
        Args    : 'format' should contain the last part of the
                  name of a module who does the real implementation

       It does (in run-time) a similar thing as

          require Bio::Biblio::IO::$format

       It throws an exception if it fails to find and load the module (for example, because of the compilation
       errors in the module).

   <b>_guess_format</b>
        Usage   : $class-&gt;_guess_format ($filename)
        Returns : string with a guessed format of the input data (e.g. 'medlinexml')
        Args    : a file name whose extension can help to guess its format

       It makes an expert guess what kind of data are in the given file (but be prepare that $filename may be
       empty).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   An example script <u>eg/biblio-soap.pl</u>

           It  has  many  options and its own help.  The relevant options to this IO module are "-f" (specifying
           what file to read) and "-O" (specifying what result format to achieve).

       •   OpenBQS home page

           <a href="http://www.ebi.ac.uk/~senger/openbqs/">http://www.ebi.ac.uk/~senger/openbqs/</a>

       •   Comments to the Perl client

           <a href="http://www.ebi.ac.uk/~senger/openbqs/Client_perl.html">http://www.ebi.ac.uk/~senger/openbqs/Client_perl.html</a>

</pre><h4><b>FEEDBACK</b></h4><pre>
   <b>Mailing</b> <b>lists</b>
       User feedback is an integral part of the evolution of this and other Bioperl modules. Send your  comments
       and suggestions preferably to the Bioperl mailing list.  Your participation is much appreciated.

         <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>                  - General discussion
         <a href="http://bioperl.org/wiki/Mailing_lists">http://bioperl.org/wiki/Mailing_lists</a>  - About the mailing lists

   <b>Support</b>
       Please direct usage questions or support issues to the mailing list: <u><a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a></u>

       rather  than  to the module maintainer directly. Many experienced and reponsive experts will be able look
       at the problem and quickly address it. Please include a thorough description of the problem with code and
       data examples if at all possible.

   <b>Reporting</b> <b>bugs</b>
       Report bugs to the Bioperl bug tracking system to help us keep track of the bugs  and  their  resolution.
       Bug reports can be submitted via the web:

         https://redmine.open-bio.org/projects/bioperl/

</pre><h4><b>LEGAL</b></h4><pre>
   <b>Authors</b>
       Martin Senger &lt;<a href="mailto:senger@ebi.ac.uk">senger@ebi.ac.uk</a>&gt;

   <b>Copyright</b> <b>and</b> <b>License</b>
       This  software  is Copyright (c) by 2002 European Bioinformatics Institute and released under the license
       of the same terms as the perl 5 programming language system itself

perl v5.36.0                                       2023-02-14                               <u>Bio::Biblio::<a href="../man3pm/IO.3pm.html">IO</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>