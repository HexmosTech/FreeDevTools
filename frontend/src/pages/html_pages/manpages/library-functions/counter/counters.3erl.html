<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>counters - Counter Functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       counters - Counter Functions

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  provides  a set of functions to do operations towards shared mutable counter variables. The
       implementation does not utilize any software level locking, which makes it very efficient for  concurrent
       access. The counters are organized into arrays with the following semantics:

         * Counters are 64 bit signed integers.

         * Counters wrap around at overflow and underflow operations.

         * Counters are initialized to zero.

         * Write  operations  guarantee  atomicity.  No  intermediate  results  can  be seen from a single write
           operation.

         * Two types of counter arrays can be created with options <u>atomics</u>  or  <u>write_concurrency</u>.  The  <u>atomics</u>
           counters  have  good  allround  performance  with  nice  consistent semantics while <u>write_concurrency</u>
           counters offers even better concurrent write performance  at  the  expense  of  some  potential  read
           inconsistencies. See <u>new/2</u>.

         * Indexes  into  counter arrays are one-based. A counter array of size N contains N counters with index
           from 1 to N.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>counters_ref()</b>

              Identifies a counter array returned from <u>new/2</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>new(Size,</b> <b>Opts)</b> <b>-&gt;</b> <b>counters_ref()</b>

              Types:

                 Size = integer() &gt;= 1
                 Opts = [Opt]
                 Opt = atomics | write_concurrency

              Create a new counter array of <u>Size</u> counters. All counters in the array are initially set to zero.

              Argument <u>Opts</u> is a list of the following possible options:

                <u>atomics</u> (Default):
                  Counters will be sequentially consistent. If write operation A  is  done  sequentially  before
                  write  operation  B,  then  a concurrent reader may see the result of none of them, only A, or
                  both A and B. It cannot see the result of only B.

                <u>write_concurrency</u>:
                  This is an optimization to achieve very efficient concurrent <u>add</u> and  <u>sub</u>  operations  at  the
                  expense of potential read inconsistency and memory consumption per counter.

                  Read  operations  may  see  sequentially  inconsistent results with regard to concurrent write
                  operations. Even if write operation A  is  done  sequentially  before  write  operation  B,  a
                  concurrent  reader  may  see any combination of A and B, including only B. A read operation is
                  only guaranteed to see all writes done sequentially before the read. No writes are ever  lost,
                  but will eventually all be seen.

                  The  typical use case for <u>write_concurrency</u> is when concurrent calls to <u>add</u> and <u>sub</u> toward the
                  same counters are very frequent, while calls to <u>get</u> and <u>put</u> are much less frequent.  The  lack
                  of absolute read consistency must also be acceptable.

              Counters are not tied to the current process and are automatically garbage collected when they are
              no longer referenced.

       <b>get(Ref,</b> <b>Ix)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 Ref = counters_ref()
                 Ix = integer()

              Read counter value.

       <b>add(Ref,</b> <b>Ix,</b> <b>Incr)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Ref = counters_ref()
                 Ix = Incr = integer()

              Add <u>Incr</u> to counter at index <u>Ix</u>.

       <b>sub(Ref,</b> <b>Ix,</b> <b>Decr)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Ref = counters_ref()
                 Ix = Decr = integer()

              Subtract <u>Decr</u> from counter at index <u>Ix</u>.

       <b>put(Ref,</b> <b>Ix,</b> <b>Value)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Ref = counters_ref()
                 Ix = Value = integer()

              Write <u>Value</u> to counter at index <u>Ix</u>.

          <b>Note:</b>
              Despite  its  name,  the  <u>write_concurrency</u>  optimization does not improve <u>put</u>. A call to <u>put</u> is a
              relatively heavy operation compared to the very lightweight and scalable <u>add</u> and <u>sub</u>. The cost for
              a <u>put</u> with <u>write_concurrency</u> is like a <u>get</u> plus a <u>put</u> without <u>write_concurrency</u>.

       <b>info(Ref)</b> <b>-&gt;</b> <b>Info</b>

              Types:

                 Ref = counters_ref()
                 Info = #{size := Size, memory := Memory}
                 Size = Memory = integer() &gt;= 0

              Return information about a counter array in a map. The map has the following keys (at least):

                <u>size</u>:
                  The number of counters in the array.

                <u>memory</u>:
                  Approximate memory consumption for the array in bytes.

Ericsson AB                                        erts 12.2.1                                    <u><a href="../man3erl/counters.3erl.html">counters</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>