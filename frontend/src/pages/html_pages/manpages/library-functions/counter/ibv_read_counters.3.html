<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ibv_read_counters - Read counter values</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libibverbs-dev">libibverbs-dev_56.1-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>ibv_read_counters</b> - Read counter values

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;infiniband/verbs.h&gt;

              int ibv_read_counters(struct ibv_counters *counters,
                                    uint64_t *counters_value,
                                    uint32_t ncounters,
                                    uint32_t flags);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>ibv_read_counters</b>()  returns  the  values  of  the chosen counters into <u>counters_value</u> array of which can
       accumulate <u>ncounters</u>.  The values are filled according to the configuration defined by the  user  in  the
       <b>ibv_attach_counters_point_xxx</b> functions.

</pre><h4><b>ARGUMENTS</b></h4><pre>
       <u>counters</u>
              Counters object to read.

       <u>counters_value</u>
              Input buffer to hold read result.

       <u>ncounters</u>
              Number of counters to fill.

       <u>flags</u>  Use enum ibv_read_counters_flags.

   <u><b>flags</b></u> Argument
       IBV_READ_COUNTERS_ATTR_PREFER_CACHED
              Will  prefer  reading the values from driver cache, else it will do volatile hardware access which
              is the default.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>ibv_read_counters</b>() returns 0 on success, or the value of errno on failure (which indicates  the  failure
       reason)

</pre><h4><b>EXAMPLE</b></h4><pre>
       Example: Statically attach counters to a new flow

       This  example  demonstrates  the use of counters which are attached statically with the creation of a new
       flow.  The counters are read from hardware periodically, and finally all resources are released.

              /* create counters object and define its counters points        */
              /* create simple L2 flow with hardcoded MAC, and a count action */
              /* read counters periodically, every 1sec, until loop ends      */
              /* assumes user prepared a RAW_PACKET QP as input               */
              /* only limited error checking in run time for code simplicity  */

              #include &lt;<a href="file:/usr/include/inttypes.h">inttypes.h</a>&gt;
              #include &lt;infiniband/verbs.h&gt;

              /* the below MAC should be replaced by user */
              #define FLOW_SPEC_ETH_MAC_VAL {
                  .dst_mac = { 0x00, 0x01, 0x02, 0x03, 0x04,0x05},
                  .src_mac = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
                  .ether_type = 0, .vlan_tag = 0, }
              #define FLOW_SPEC_ETH_MAC_MASK {
                  .dst_mac = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                  .src_mac = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                  .ether_type = 0, .vlan_tag = 0, }

              void example_create_flow_with_counters_on_raw_qp(struct ibv_qp *qp) {
                  int idx = 0;
                  int loop = 10;
                  struct ibv_flow *flow = NULL;
                  struct ibv_counters *counters = NULL;
                  struct ibv_counters_init_attr init_attr = {0};
                  struct ibv_counter_attach_attr attach_attr = {0};

                  /* create single counters handle */
                  counters = ibv_create_counters(qp-&gt;context, &amp;init_attr);

                  /* define counters points */
                  attach_attr.counter_desc = IBV_COUNTER_PACKETS;
                  attach_attr.index = idx++;
                  ret = ibv_attach_counters_point_flow(counters, &amp;attach_attr, NULL);
                  if (ret == ENOTSUP) {
                      fprintf(stderr, "Attaching IBV_COUNTER_PACKETS to flow is not \
              supported");
                      <a href="../man1/exit.1.html">exit</a>(1);
                  }
                  attach_attr.counter_desc = IBV_COUNTER_BYTES;
                  attach_attr.index = idx++;
                  ibv_attach_counters_point_flow(counters, &amp;attach_attr, NULL);
                  if (ret == ENOTSUP) {
                      fprintf(stderr, "Attaching IBV_COUNTER_BYTES to flow is not \
              supported");
                      <a href="../man1/exit.1.html">exit</a>(1);
                  }

                  /* define a new flow attr that includes the counters handle */
                  struct raw_eth_flow_attr {
                      struct ibv_flow_attr              attr;
                      struct ibv_flow_spec_eth          spec_eth;
                      struct ibv_flow_spec_counter_action spec_count;
                  } flow_attr = {
                      .attr = {
                              .comp_mask  = 0,
                              .type       = IBV_FLOW_ATTR_NORMAL,
                              .size       = sizeof(flow_attr),
                              .priority   = 0,
                              .num_of_specs = 2, /* ETH + COUNT */
                              .port       = 1,
                              .flags      = 0,
                          },
                      .spec_eth = {
                              .type = IBV_EXP_FLOW_SPEC_ETH,
                              .size = sizeof(struct ibv_flow_spec_eth),
                              .val  = FLOW_SPEC_ETH_MAC_VAL,
                              .mask = FLOW_SPEC_ETH_MAC_MASK,
                          },
                      .spec_count = {
                              .type   = IBV_FLOW_SPEC_ACTION_COUNT,
                              .size   = sizeof(struct ibv_flow_spec_counter_action),
                              .counters = counters, /* attached this counters handle
              to the newly created ibv_flow */ } };

                  /* create the flow */
                  flow = ibv_create_flow(qp, &amp;flow_attr.attr);

                  /* allocate array for counters value reading */
                  uint64_t *counters_value = malloc(sizeof(uint64_t) * idx);

                  /* periodical read and print of flow counters */
                  while (--loop) {
                      <a href="../man1/sleep.1.html">sleep</a>(1);

                      /* read hardware counters values */
                      ibv_read_counters(counters, counters_value, idx,
                                IBV_READ_COUNTERS_ATTR_PREFER_CACHED);

                      printf("PACKETS = %"PRIu64", BYTES = %"PRIu64 \n",
                          counters_value[0], counters_value[1] );
                  }

                  /* all done, release all */
                  free(counters_value);

                  /* destroy flow and detach counters */
                  ibv_destroy_flow(flow);

                  /* destroy counters handle */
                  ibv_destroy_counters(counters);

                  return;
              }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>ibv_create_counters</b>, <b>ibv_destroy_counters</b>, <b>ibv_attach_counters_point_flow</b>, <b>ibv_create_flow</b>

</pre><h4><b>AUTHORS</b></h4><pre>
       Raed Salem <a href="mailto:raeds@mellanox.com">raeds@mellanox.com</a>

       Alex Rosenbaum <a href="mailto:alexr@mellanox.com">alexr@mellanox.com</a>

libibverbs                                         2018-04-02                               <u><a href="../man3/ibv_read_counters.3.html">ibv_read_counters</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>