<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>"Commandable::Finder::Packages" - find commands stored per package</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcommandable-perl">libcommandable-perl_0.14-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       "Commandable::Finder::Packages" - find commands stored per package

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use Commandable::Finder::Packages;

          my $finder = Commandable::Finder::Packages-&gt;new(
             base =&gt; "MyApp::Command",
          );

          my $help_command = $finder-&gt;find_command( "help" );

          foreach my $command ( $finder-&gt;find_commands ) {
             ...
          }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This implementation of Commandable::Finder looks for implementations of commands, where each command is
       implemented by a different package somewhere in the symbol table.

       This class uses Module::Pluggable to load packages from the filesystem.  As commands are located per
       package (and not per file), the application can provide special-purpose internal commands by implementing
       more packages in the given namespace, regardless of which files they come from.

</pre><h4><b>CONSTANTS</b></h4><pre>
          package My::App::Commands::example;

          use constant COMMAND_NAME =&gt; "example";
          use constant COMMAND_DESC =&gt; "an example of a command";

          ...

       Properties about each command are stored as methods (usually constant methods) within each package. Often
       the constant pragma module is used to create them.

       The following constant names are used by default:

   <b>COMMAND_NAME</b>
          use constant COMMAND_NAME =&gt; "name";

       Gives a string name for the command.

   <b>COMMAND_DESC</b>
          use constant COMMAND_DESC =&gt; "description";

       Gives a string description for the command.

   <b>COMMAND_ARGS</b>
          use constant COMMAND_ARGS =&gt; (
             { name =&gt; "argname", description =&gt; "description" },
          );

       Gives a list of command argument specifications. Each specification is a HASH reference corresponding to
       one positional argument, and should contain keys named "name", "description", and optionally "optional".

   <b>COMMAND_OPTS</b>
          use constant COMMAND_OPTS =&gt; (
             { name =&gt; "optname", description =&gt; "description" },
          );

       Gives a list of command option specifications. Each specification is a HASH reference giving one named
       option, in no particular order, and should contain keys named "name", "description" and optionally
       "mode", "multi" and "default".

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
   <b>new</b>
          $finder = Commandable::Finder::Packages-&gt;new( %args )

       Constructs a new instance of "Commandable::Finder::Packages".

       Takes the following named arguments:

       base =&gt; STR
           The base of the package namespace to look inside for packages that implement commands.

       name_method =&gt; STR
           Optional.  Gives the name of the method inside each command package to invoke to generate the name of
           the command. Default "COMMAND_NAME".

       description_method =&gt; STR
           Optional. Gives the name of the method  inside  each  command  package  to  invoke  to  generate  the
           description text of the command. Default "COMMAND_DESC".

       arguments_method =&gt; STR
           Optional.  Gives  the  name of the method inside each command package to invoke to generate a list of
           argument specifications. Default "COMMAND_ARGS".

       options_method =&gt; STR
           Optional. Gives the name of the method inside each command package to invoke to generate  a  list  of
           option specifications. Default "COMMAND_OPTS".

       code_method =&gt; STR
           Optional.  Gives  the  name  of  the  method  inside each command package which implements the actual
           command behaviour. Default "run".

       named_by_package =&gt; BOOL
           Optional. If true, the name of each command will be taken from its package  name.  with  the  leading
           "base" string removed. If absent or false, the "name_method" will be used instead.

       If either name or description method are missing from a package, that package is silently ignored.

       Any additional arguments are passed to the "configure" method to be used as configuration options.

</pre><h4><b>AUTHOR</b></h4><pre>
       Paul Evans &lt;<a href="mailto:leonerd@leonerd.org.uk">leonerd@leonerd.org.uk</a>&gt;

perl v5.40.0                                       2024-09-08                 <u>Commandable::Finder::<a href="../man3pm/Packages.3pm.html">Packages</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>