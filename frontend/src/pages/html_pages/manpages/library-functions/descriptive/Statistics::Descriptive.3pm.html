<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Statistics::Descriptive - Module of basic descriptive statistical functions.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstatistics-descriptive-perl">libstatistics-descriptive-perl_3.0801-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Statistics::Descriptive - Module of basic descriptive statistical functions.

</pre><h4><b>VERSION</b></h4><pre>
       version 3.0801

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Statistics::Descriptive;
           my $stat = Statistics::Descriptive::Full-&gt;new();
           $stat-&gt;add_data(1,2,3,4);
           my $mean = $stat-&gt;mean();
           my $var = $stat-&gt;variance();
           my $tm = $stat-&gt;trimmed_mean(.25);
           $Statistics::Descriptive::Tolerance = 1e-10;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides basic functions used in descriptive statistics.  It has an object oriented design
       and supports two different types of data storage and calculation objects: sparse and full. With the
       sparse method, none of the data is stored and only a few statistical measures are available. Using the
       full method, the entire data set is retained and additional functions are available.

       Whenever a division by zero may occur, the denominator is checked to be greater than the value
       $Statistics::Descriptive::Tolerance, which defaults to 0.0. You may want to change this value to some
       small positive value such as 1e-24 in order to obtain error messages in case of very small denominators.

       Many of the methods (both Sparse and Full) cache values so that subsequent calls with the same arguments
       are faster.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Sparse</b> <b>Methods</b>
       $stat = Statistics::Descriptive::Sparse-&gt;<b>new()</b>;
            Create a new sparse statistics object.

       $stat-&gt;<b>clear()</b>;
            Effectively the same as

              my $class = ref($stat);
              undef $stat;
              $stat = new $class;

            except more efficient.

       $stat-&gt;add_data(1,2,3);
            Adds data to the statistics variable. The cached statistical values are updated automatically.

       $stat-&gt;<b>count()</b>;
            Returns the number of data items.

       $stat-&gt;<b>mean()</b>;
            Returns the mean of the data.

       $stat-&gt;<b>sum()</b>;
            Returns the sum of the data.

       $stat-&gt;<b>variance()</b>;
            Returns the variance of the data.  Division by n-1 is used.

       $stat-&gt;<b>standard_deviation()</b>;
            Returns the standard deviation of the data. Division by n-1 is used.

       $stat-&gt;<b>min()</b>;
            Returns the minimum value of the data set.

       $stat-&gt;<b>mindex()</b>;
            Returns the index of the minimum value of the data set.

       $stat-&gt;<b>max()</b>;
            Returns the maximum value of the data set.

       $stat-&gt;<b>maxdex()</b>;
            Returns the index of the maximum value of the data set.

       $stat-&gt;<b>sample_range()</b>;
            Returns the sample range (max - min) of the data set.

   <b>Full</b> <b>Methods</b>
       Similar  to the Sparse Methods above, any Full Method that is called caches the current result so that it
       doesn't have to be recalculated.  In some cases, several values can be cached at the same time.

       $stat = Statistics::Descriptive::Full-&gt;<b>new()</b>;
            Create a new statistics  object  that  inherits  from  Statistics::Descriptive::Sparse  so  that  it
            contains all the methods described above.

       $stat-&gt;add_data(1,2,4,5);
            Adds  data to the statistics variable.  All of the sparse statistical values are updated and cached.
            Cached values from Full methods are deleted since they are no longer valid.

            <u>Note:</u>  <u>Calling</u> <u>add_data</u> <u>with</u> <u>an</u> <u>empty</u> <u>array</u> <u>will</u> <u>delete</u> <u>all</u>  <u>of</u>  <u>your</u>  <u>Full</u>  <u>method</u>  <u>cached</u>  <u>values!</u>
            <u>Cached</u> <u>values</u> <u>for</u> <u>the</u> <u>sparse</u> <u>methods</u> <u>are</u> <u>not</u> <u>changed</u>

       $stat-&gt;add_data_with_samples([{1 =&gt; 10}, {2 =&gt; 20}, {3 =&gt; 30},]);
            Add  data  to  the statistics variable and set the number of samples each value has been built with.
            The data is the key of each element of the input array  ref,  while  the  value  is  the  number  of
            samples: [{data1 =&gt; smaples1}, {data2 =&gt; samples2}, ...].

            <b>NOTE:</b>  The  number of samples is only used by the smoothing function and is ignored otherwise. It is
            not equivalent to repeat count. In order  to  repeat  a  certain  datum  more  than  one  time  call
            <b>add_data()</b> like this:

                my $value = 5;
                my $repeat_count = 10;
                $stat-&gt;add_data(
                    [ ($value) x $repeat_count ]
                );

       $stat-&gt;<b>get_data()</b>;
            Returns a copy of the data array.

       $stat-&gt;<b>get_data_without_outliers()</b>;
            Returns  a  copy  of  the  data  array  without outliers. The number minimum of samples to apply the
            outlier filtering is $Statistics::Descriptive::Min_samples_number, 4 by default.

            A function to detect outliers need to be defined (see "set_outlier_filter"), otherwise the  function
            will return an undef value.

            The  filtering will act only on the most extreme value of the data set (i.e.: value with the highest
            absolute standard deviation from the mean).

            If there is the need to remove more than one outlier, the filtering need to be re-run for  the  next
            most extreme value with the initial outlier removed.

            This is not always needed since the test (for example Grubb's test) usually can only detect the most
            exreme  value.  If there is more than one extreme case in a set, then the standard deviation will be
            high enough to make neither case an outlier.

       $stat-&gt;set_outlier_filter($code_ref);
            Set the function to filter out the outlier.

            $code_ref is the reference to the subroutine implementing the filtering function.

            Returns "undef" for invalid values of $code_ref (i.e.: not defined  or  not  a  code  reference),  1
            otherwise.

            •   Example #1: Undefined code reference

                    my $stat = Statistics::Descriptive::Full-&gt;new();
                    $stat-&gt;add_data(1, 2, 3, 4, 5);

                    print $stat-&gt;set_outlier_filter(); # =&gt; undef

            •   Example #2: Valid code reference

                    sub outlier_filter { return $_[1] &gt; 1; }

                    my $stat = Statistics::Descriptive::Full-&gt;new();
                    $stat-&gt;add_data( 1, 1, 1, 100, 1, );

                    print $stat-&gt;set_outlier_filter( \&amp;outlier_filter ); # =&gt; 1
                    my @filtered_data = $stat-&gt;get_data_without_outliers();
                    # @filtered_data is (1, 1, 1, 1)

                In  this  example the series is really simple and the outlier filter function as well.  For more
                complex series the outlier  filter  function  might  be  more  complex  (see  Grubbs'  test  for
                outliers).

                The  outlier  filter  function will receive as first parameter the Statistics::Descriptive::Full
                object, as second the value of the candidate outlier. Having the object in the function might be
                useful for complex filters where statistics property are needed  (again  see  Grubbs'  test  for
                outlier).

       $stat-&gt;set_smoother({ method =&gt; 'exponential', coeff =&gt; 0, });
            Set    the    method   used   to   smooth   the   data   and   the   smoothing   coefficient.    See
            "Statistics::Descriptive::Smoother" for more details.

       $stat-&gt;<b>get_smoothed_data()</b>;
            Returns a copy of the smoothed data array.

            The smoothing method and coefficient need to be defined (see "set_smoother"), otherwise the function
            will return an undef value.

       $stat-&gt;<b>sort_data()</b>;
            Sort the stored data and update the mindex and maxdex methods.  This  method  uses  perl's  internal
            sort.

       $stat-&gt;<b><a href="../man1/presorted.1.html">presorted</a></b>(1);
       $stat-&gt;<b>presorted()</b>;
            If called with a non-zero argument, this method sets a flag that says the data is already sorted and
            need  not  be sorted again.  Since some of the methods in this class require sorted data, this saves
            some time.  If you supply sorted data to the object, call this method to prevent the data from being
            sorted again. The flag is cleared whenever add_data  is  called.   Calling  the  method  without  an
            argument returns the value of the flag.

       $stat-&gt;<b>skewness()</b>;
            Returns  the  skewness  of  the  data.   A value of zero is no skew, negative is a left skewed tail,
            positive is a right skewed tail.  This is consistent with Excel.

       $stat-&gt;<b>kurtosis()</b>;
            Returns the kurtosis of the data.  Positive is peaked, negative is flattened.

       $x = $stat-&gt;<a href="../man25/percentile.25.html">percentile</a>(25);
       ($x, $index) = $stat-&gt;<a href="../man25/percentile.25.html">percentile</a>(25);
            Sorts the data and returns the value that corresponds to the percentile as defined in RFC2330:

            •   For example, given the 6 measurements:

                -2, 7, 7, 4, 18, -5

                Then F(-8) = 0, F(-5) = 1/6, F(-5.0001) = 0, F(-4.999) = 1/6, <a href="../man7/F.7.html">F</a>(7) = 5/6, <a href="../man18/F.18.html">F</a>(18) = 1, <a href="../man239/F.239.html">F</a>(239) = 1.

                Note that we can recover the different measured values and how many  times  each  occurred  from
                F(x)  --  no  information regarding the range in values is lost.  Summarizing measurements using
                histograms, on the other hand, in general loses information about the different values observed,
                so the EDF is preferred.

                Using either the EDF or a histogram, however, we do lose  information  regarding  the  order  in
                which the values were observed.  Whether this loss is potentially significant will depend on the
                metric being measured.

                We  will use the term "percentile" to refer to the smallest value of x for which F(x) &gt;= a given
                percentage.  So the 50th percentile of the example above is 4, since <a href="../man4/F.4.html">F</a>(4) = 3/6 = 50%; the  25th
                percentile  is  -2, since F(-5) = 1/6 &lt; 25%, and F(-2) = 2/6 &gt;= 25%; the 100th percentile is 18;
                and the 0th percentile is -infinity, as is the 15th percentile, which for ease of  handling  and
                backward compatibility is returned as <b>undef()</b> by the function.

                Care  must  be  taken  when  using  percentiles  to summarize a sample, because they can lend an
                unwarranted appearance of more precision than  is  really  available.   Any  such  summary  must
                include  the  sample  size  N,  because  any  percentile  difference finer than 1/N is below the
                resolution of the sample.

            (Taken from: <u>RFC2330</u> <u>-</u> <u>Framework</u> <u>for</u> <u>IP</u> <u>Performance</u> <u>Metrics</u>,  Section  11.3.   Defining  Statistical
            Distributions.  RFC2330 is available from: &lt;<a href="http://www.ietf.org/rfc/rfc2330.txt">http://www.ietf.org/rfc/rfc2330.txt</a>&gt; .)

            If  the  percentile  method  is  called  in a list context then it will also return the index of the
            percentile.

       $x = $stat-&gt;quantile($Type);
            Sorts the data and returns estimates of underlying distribution quantiles based on one or two  order
            statistics from the supplied elements.

            This method use the same algorithm as Excel and R language (quantile <b>type</b> <b>7</b>).

            The generic function quantile produces sample quantiles corresponding to the given probabilities.

            <b>$Type</b> is an integer value between 0 to 4 :

              0 =&gt; zero quartile (Q0) : minimal value
              1 =&gt; first quartile (Q1) : lower quartile = lowest cut off (25%) of data = 25th percentile
              2 =&gt; second quartile (Q2) : median = it cuts data set in half = 50th percentile
              3 =&gt; third quartile (Q3) : upper quartile = highest cut off (25%) of data, or lowest 75% = 75th percentile
              4 =&gt; fourth quartile (Q4) : maximal value

            Example :

              my @data = (1..10);
              my $stat = Statistics::Descriptive::Full-&gt;new();
              $stat-&gt;add_data(@data);
              print $stat-&gt;<a href="../man0/quantile.0.html">quantile</a>(0); # =&gt; 1
              print $stat-&gt;<a href="../man1/quantile.1.html">quantile</a>(1); # =&gt; 3.25
              print $stat-&gt;<a href="../man2/quantile.2.html">quantile</a>(2); # =&gt; 5.5
              print $stat-&gt;<a href="../man3/quantile.3.html">quantile</a>(3); # =&gt; 7.75
              print $stat-&gt;<a href="../man4/quantile.4.html">quantile</a>(4); # =&gt; 10

       $stat-&gt;<b>median()</b>;
            Sorts the data and returns the median value of the data.

       $stat-&gt;<b>harmonic_mean()</b>;
            Returns  the  harmonic mean of the data.  Since the mean is undefined if any of the data are zero or
            if the sum of the reciprocals is zero, it will return undef for both of those cases.

       $stat-&gt;<b>geometric_mean()</b>;
            Returns the geometric mean of the data.

       my $mode = $stat-&gt;<b>mode()</b>;
            Returns  the  mode  of  the  data.  The  mode  is  the   most   commonly   occurring   datum.    See
            &lt;<a href="http://en.wikipedia.org/wiki/Mode_">http://en.wikipedia.org/wiki/Mode_</a>%28statistics%29&gt;  .  If  all values occur only once, then <b>mode()</b>
            will return undef.

       $stat-&gt;trimmed_mean(ltrim[,utrim]);
            "trimmed_mean(ltrim)" returns the mean with a fraction "ltrim"  of  entries  at  each  end  dropped.
            "trimmed_mean(ltrim,utrim)"  returns  the  mean  after  a fraction "ltrim" has been removed from the
            lower end of the data and a fraction "utrim" has been removed from the upper end of the data.   This
            method sorts the data before beginning to analyze it.

            All calls to <b>trimmed_mean()</b> are cached so that they don't have to be calculated a second time.

       $stat-&gt;frequency_distribution_ref($num_partitions);
       $stat-&gt;frequency_distribution_ref(\@bins);
       $stat-&gt;<b>frequency_distribution_ref()</b>;
            "frequency_distribution_ref($num_partitions)"  slices  the  data  into  $num_partitions  sets (where
            $num_partitions is greater than 1) and counts the number of items that fall into each partition.  It
            returns  a  reference  to a hash where the keys are the numerical values of the partitions used. The
            minimum value of the data set is not a key and the maximum value of the data set is  always  a  key.
            The  number of entries for a particular partition key are the number of items which are greater than
            the previous partition key and less then or equal to the current partition key. As an example,

               $stat-&gt;add_data(1,1.5,2,2.5,3,3.5,4);
               $f = $stat-&gt;<a href="../man2/frequency_distribution_ref.2.html">frequency_distribution_ref</a>(2);
               for (sort {$a &lt;=&gt; $b} keys %$f) {
                  print "key = $_, count = $f-&gt;{$_}\n";
               }

            prints

               key = 2.5, count = 4
               key = 4, count = 3

            since there are four items less than or equal to 2.5, and 3 items greater than 2.5 and less than 4.

            "frequency_distribution_refs(\@bins)" provides the bins that are to be used  for  the  distribution.
            This  allows  for  non-uniform distributions as well as trimmed or sample distributions to be found.
            @bins must be monotonic and must contain at least one element.  Note that unless  the  set  of  bins
            contains the full range of the data, the total counts returned will be less than the sample size.

            Calling  "frequency_distribution_ref()"  with no arguments returns the last distribution calculated,
            if such exists.

       my %hash = $stat-&gt;frequency_distribution($partitions);
       my %hash = $stat-&gt;frequency_distribution(\@bins);
       my %hash = $stat-&gt;<b>frequency_distribution()</b>;
            Same as "frequency_distribution_ref()" except that it returns the hash  clobbered  into  the  return
            list.  Kept for compatibility reasons with previous versions of Statistics::Descriptive and using it
            is discouraged.

       $stat-&gt;<b>least_squares_fit()</b>;
       $stat-&gt;least_squares_fit(@x);
            "least_squares_fit()" performs a least squares fit on the data, assuming a domain of @x or a default
            of 1..$stat-&gt;<b>count()</b>.  It returns an array of four elements "($q, $m, $r, $rms)" where

            "$q and $m"
                satisfy the equation C($y = $m*$x + $q).

            $r  is the Pearson linear correlation cofficient.

            $rms
                is the root-mean-square error.

            If case of error or division by zero, the empty list is returned.

            The array that is returned can be "coerced" into a hash structure by doing the following:

              my %hash = ();
              @hash{'q', 'm', 'r', 'err'} = $stat-&gt;least_squares_fit();

            Because calling "least_squares_fit()" with no arguments defaults to using the current  range,  there
            is no caching of the results.

</pre><h4><b>REPORTING</b> <b>ERRORS</b></h4><pre>
       I  read my email frequently, but since adopting this module I've added 2 children and 1 dog to my family,
       so please be patient about my response times.  When reporting errors, please  include  the  following  to
       help me out:

       •   Your version of perl.  This can be obtained by typing perl "-v" at the command line.

       •   Which  version  of  Statistics::Descriptive  you're using.  As you can see below, I do make mistakes.
           Unfortunately for me, right now there are thousands of CD's with the version of this module with  the
           bugs in it.  Fortunately for you, I'm a very patient module maintainer.

       •   Details about what the error is.  Try to narrow down the scope of the problem and send me code that I
           can run to verify and track it down.

</pre><h4><b>AUTHOR</b></h4><pre>
       Current maintainer:

       Shlomi Fish, &lt;<a href="http://www.shlomifish.org/">http://www.shlomifish.org/</a>&gt; , "<a href="mailto:shlomif@cpan.org">shlomif@cpan.org</a>"

       Previously:

       Colin Kuskie

       My    email    address    can    be    found    at   <a href="http://www.perl.com">http://www.perl.com</a>   under   Who's   Who   or   at:
       https://metacpan.org/author/COLINK .

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       Fabio Ponciroli &amp; Adzuna Ltd. team (outliers handling)

</pre><h4><b>REFERENCES</b></h4><pre>
       RFC2330, Framework for IP Performance Metrics

       The Art of Computer Programming, Volume 2, Donald Knuth.

       Handbook of Mathematica Functions, Milton Abramowitz and Irene Stegun.

       Probability and Statistics for Engineering and the Sciences, Jay Devore.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 1997,1998 Colin Kuskie. All rights reserved.   This  program  is  free  software;  you  can
       redistribute it and/or modify it under the same terms as Perl itself.

       Copyright  (c)  1998  Andrea  Spinelli.  All  rights  reserved.   This  program is free software; you can
       redistribute it and/or modify it under the same terms as Perl itself.

       Copyright (c) 1994,1995 Jason Kastner. All rights reserved.  This  program  is  free  software;  you  can
       redistribute it and/or modify it under the same terms as Perl itself.

</pre><h4><b>LICENSE</b></h4><pre>
       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>SUPPORT</b></h4><pre>
   <b>Websites</b>
       The following websites have more information about this module, and may be of help to you. As always,  in
       addition to those websites please use your favorite search engine to discover more resources.

       •   MetaCPAN

           A modern, open-source CPAN search engine, useful to view POD in HTML format.

           &lt;https://metacpan.org/release/Statistics-Descriptive&gt;

       •   RT: CPAN's Bug Tracker

           The RT ( Request Tracker ) website is the default bug/issue tracking system for CPAN.

           &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Statistics-Descriptive&gt;

       •   CPANTS

           The CPANTS is a website that analyzes the Kwalitee ( code metrics ) of a distribution.

           &lt;<a href="http://cpants.cpanauthors.org/dist/Statistics-Descriptive">http://cpants.cpanauthors.org/dist/Statistics-Descriptive</a>&gt;

       •   CPAN Testers

           The  CPAN  Testers  is  a  network  of  smoke  testers  who  run  automated  tests  on  uploaded CPAN
           distributions.

           &lt;<a href="http://www.cpantesters.org/distro/S/Statistics-Descriptive">http://www.cpantesters.org/distro/S/Statistics-Descriptive</a>&gt;

       •   CPAN Testers Matrix

           The CPAN Testers Matrix is a website that provides a visual  overview  of  the  test  results  for  a
           distribution on various Perls/platforms.

           &lt;<a href="http://matrix.cpantesters.org/">http://matrix.cpantesters.org/</a>?dist=Statistics-Descriptive&gt;

       •   CPAN Testers Dependencies

           The CPAN Testers Dependencies is a website that shows a chart of the test results of all dependencies
           for a distribution.

           &lt;<a href="http://deps.cpantesters.org/">http://deps.cpantesters.org/</a>?module=Statistics::Descriptive&gt;

   <b>Bugs</b> <b>/</b> <b>Feature</b> <b>Requests</b>
       Please  report  any  bugs or feature requests by email to "bug-statistics-descriptive at rt.cpan.org", or
       through the web interface  at  &lt;https://rt.cpan.org/Public/Bug/Report.html?Queue=Statistics-Descriptive&gt;.
       You will be automatically notified of any progress on the request by the system.

   <b>Source</b> <b>Code</b>
       The  code  is open to the world, and available for you to hack on. Please feel free to browse it and play
       with it, or whatever. If you want to contribute patches, please send me a diff or prod me  to  pull  from
       your repository :)

       &lt;https://github.com/shlomif/perl-Statistics-Descriptive&gt;

         git clone git://github.com/shlomif/perl-Statistics-Descriptive.git

</pre><h4><b>AUTHOR</b></h4><pre>
       Shlomi Fish &lt;<a href="mailto:shlomif@cpan.org">shlomif@cpan.org</a>&gt;

</pre><h4><b>BUGS</b></h4><pre>
       Please     report     any     bugs     or     feature     requests     on    the    bugtracker    website
       &lt;https://github.com/shlomif/perl-Statistics-Descriptive/issues&gt;

       When submitting a bug or request, please include a test-file or a patch to  an  existing  test-file  that
       illustrates the bug or desired feature.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 1997 by Jason Kastner, Andrea Spinelli, Colin Kuskie, and others.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.36.0                                       2023-08-11                       <u>Statistics::<a href="../man3pm/Descriptive.3pm.html">Descriptive</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>