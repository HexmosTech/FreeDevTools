<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIO_s_bio, BIO_make_bio_pair, BIO_destroy_bio_pair, BIO_shutdown_wr, BIO_set_write_buf_size,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       BIO_s_bio, BIO_make_bio_pair, BIO_destroy_bio_pair, BIO_shutdown_wr, BIO_set_write_buf_size,
       BIO_get_write_buf_size, BIO_new_bio_pair, BIO_get_write_guarantee, BIO_ctrl_get_write_guarantee,
       BIO_get_read_request, BIO_ctrl_get_read_request, BIO_ctrl_reset_read_request - BIO pair BIO

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/bio.h&gt;

        const BIO_METHOD *BIO_s_bio(void);

        int BIO_make_bio_pair(BIO *b1, BIO *b2);
        int BIO_destroy_bio_pair(BIO *b);
        int BIO_shutdown_wr(BIO *b);

        int BIO_set_write_buf_size(BIO *b, long size);
        size_t BIO_get_write_buf_size(BIO *b, long size);

        int BIO_new_bio_pair(BIO **bio1, size_t writebuf1, BIO **bio2, size_t writebuf2);

        int BIO_get_write_guarantee(BIO *b);
        size_t BIO_ctrl_get_write_guarantee(BIO *b);
        int BIO_get_read_request(BIO *b);
        size_t BIO_ctrl_get_read_request(BIO *b);
        int BIO_ctrl_reset_read_request(BIO *b);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>BIO_s_bio()</b> returns the method for a BIO pair. A BIO pair is a pair of source/sink BIOs where data
       written to either half of the pair is buffered and can be read from the other half. Both halves must
       usually by handled by the same application thread since no locking is done on the internal data
       structures.

       Since BIO chains typically end in a source/sink BIO it is possible to make this one half of a BIO pair
       and have all the data processed by the chain under application control.

       One typical use of BIO pairs is to place TLS/SSL I/O under application control, this can be used when the
       application wishes to use a non standard transport for TLS/SSL or the normal socket routines are
       inappropriate.

       Calls to <b>BIO_read_ex()</b> will read data from the buffer or request a retry if no data is available.

       Calls to <b>BIO_write_ex()</b> will place data in the buffer or request a retry if the buffer is full.

       The standard calls <b>BIO_ctrl_pending()</b> and <b>BIO_ctrl_wpending()</b> can be used to determine the amount of
       pending data in the read or write buffer.

       <b>BIO_reset()</b> clears any data in the write buffer.

       <b>BIO_make_bio_pair()</b> joins two separate BIOs into a connected pair.

       <b>BIO_destroy_pair()</b> destroys the association between two connected BIOs. Freeing up any half of the pair
       will automatically destroy the association.

       <b>BIO_shutdown_wr()</b> is used to close down a BIO <b>b</b>. After this call no further writes on BIO <b>b</b> are allowed
       (they will return an error). Reads on the other half of the pair will return any pending data or EOF when
       all pending data has been read.

       <b>BIO_set_write_buf_size()</b> sets the write buffer size of BIO <b>b</b> to <b>size</b>.  If the size is not initialized a
       default value is used. This is currently 17K, sufficient for a maximum size TLS record.

       <b>BIO_get_write_buf_size()</b> returns the size of the write buffer.

       <b>BIO_new_bio_pair()</b> combines the calls to <b>BIO_new()</b>, <b>BIO_make_bio_pair()</b> and <b>BIO_set_write_buf_size()</b> to
       create a connected pair of BIOs <b>bio1</b>, <b>bio2</b> with write buffer sizes <b>writebuf1</b> and <b>writebuf2</b>. If either
       size is zero then the default size is used.  <b>BIO_new_bio_pair()</b> does not check whether <b>bio1</b> or <b>bio2</b> do
       point to some other BIO, the values are overwritten, <b>BIO_free()</b> is not called.

       <b>BIO_get_write_guarantee()</b> and <b>BIO_ctrl_get_write_guarantee()</b> return the maximum length of data that can
       be currently written to the BIO. Writes larger than this value will return a value from <b>BIO_write_ex()</b>
       less than the amount requested or if the buffer is full request a retry. <b>BIO_ctrl_get_write_guarantee()</b>
       is a function whereas <b>BIO_get_write_guarantee()</b> is a macro.

       <b>BIO_get_read_request()</b> and <b>BIO_ctrl_get_read_request()</b> return the amount of data requested, or the buffer
       size if it is less, if the last read attempt at the other half of the BIO pair failed due to an empty
       buffer.  This can be used to determine how much data should be written to the BIO so the next read will
       succeed: this is most useful in TLS/SSL applications where the amount of data read is usually meaningful
       rather than just a buffer size. After a successful read this call will return zero.  It also will return
       zero once new data has been written satisfying the read request or part of it.  Note that
       <b>BIO_get_read_request()</b> never returns an amount larger than that returned by <b>BIO_get_write_guarantee()</b>.

       <b>BIO_ctrl_reset_read_request()</b> can also be used to reset the value returned by <b>BIO_get_read_request()</b> to
       zero.

</pre><h4><b>NOTES</b></h4><pre>
       Both halves of a BIO pair should be freed. That is even if one half is implicit freed due to a
       <b>BIO_free_all()</b> or <b>SSL_free()</b> call the other half needs to be freed.

       When used in bidirectional applications (such as TLS/SSL) care should be taken to flush any data in the
       write buffer. This can be done by calling <b>BIO_pending()</b> on the other half of the pair and, if any data is
       pending, reading it and sending it to the underlying transport. This must be done before any normal
       processing (such as calling <b>select()</b> ) due to a request and <b>BIO_should_read()</b> being true.

       To see why this is important consider a case where a request is sent using <b>BIO_write_ex()</b> and a response
       read with <b>BIO_read_ex()</b>, this can occur during an TLS/SSL handshake for example. <b>BIO_write_ex()</b> will
       succeed and place data in the write buffer. <b>BIO_read_ex()</b> will initially fail and <b>BIO_should_read()</b> will
       be true. If the application then waits for data to be available on the underlying transport before
       flushing the write buffer it will never succeed because the request was never sent!

       <b>BIO_eof()</b> is true if no data is in the peer BIO and the peer BIO has been shutdown.

       <b>BIO_make_bio_pair()</b>, <b>BIO_destroy_bio_pair()</b>, <b>BIO_shutdown_wr()</b>, <b>BIO_set_write_buf_size()</b>,
       <b>BIO_get_write_buf_size()</b>, <b>BIO_get_write_guarantee()</b>, and <b>BIO_get_read_request()</b> are implemented as
       macros.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>BIO_new_bio_pair()</b> returns 1 on success, with the new BIOs available in <b>bio1</b> and <b>bio2</b>, or 0 on failure,
       with NULL pointers stored into the locations for <b>bio1</b> and <b>bio2</b>. Check the error stack for more
       information.

       [XXXXX: More return values need to be added here]

</pre><h4><b>EXAMPLES</b></h4><pre>
       The BIO pair can be used to have full control over the network access of an application. The application
       can call <b>select()</b> on the socket as required without having to go through the SSL-interface.

        BIO *internal_bio, *network_bio;

        ...
        BIO_new_bio_pair(&amp;internal_bio, 0, &amp;network_bio, 0);
        SSL_set_bio(ssl, internal_bio, internal_bio);
        SSL_operations(); /* e.g. SSL_read and SSL_write */
        ...

        application |   TLS-engine
           |        |
           +----------&gt; SSL_operations()
                    |     /\    ||
                    |     ||    \/
                    |   BIO-pair (internal_bio)
                    |   BIO-pair (network_bio)
                    |     ||     /\
                    |     \/     ||
           +-----------&lt; BIO_operations()
           |        |
           |        |
          socket

         ...
         SSL_free(ssl);                /* implicitly frees internal_bio */
         BIO_free(network_bio);
         ...

       As the BIO pair will only buffer the data and never directly access the connection, it behaves
       nonblocking and will return as soon as the write buffer is full or the read buffer is drained. Then the
       application has to flush the write buffer and/or fill the read buffer.

       Use the <b>BIO_ctrl_pending()</b>, to find out whether data is buffered in the BIO and must be transferred to
       the network. Use <b>BIO_ctrl_get_read_request()</b> to find out, how many bytes must be written into the buffer
       before the <b>SSL_operation()</b> can successfully be continued.

</pre><h4><b>WARNINGS</b></h4><pre>
       As the data is buffered, <b>SSL_operation()</b> may return with an ERROR_SSL_WANT_READ condition, but there is
       still data in the write buffer. An application must not rely on the error value of <b>SSL_operation()</b> but
       must assure that the write buffer is always flushed first. Otherwise a deadlock may occur as the peer
       might be waiting for the data before being able to continue.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/SSL_set_bio.3.html">SSL_set_bio</a></b>(3), <b><a href="../man7/ssl.7.html">ssl</a></b>(7), <b><a href="../man7/bio.7.html">bio</a></b>(7), <b><a href="../man3/BIO_should_retry.3.html">BIO_should_retry</a></b>(3), <b><a href="../man3/BIO_read_ex.3.html">BIO_read_ex</a></b>(3)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2000-2020 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                    <u><a href="../man3SSL/BIO_S_BIO.3SSL.html">BIO_S_BIO</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>