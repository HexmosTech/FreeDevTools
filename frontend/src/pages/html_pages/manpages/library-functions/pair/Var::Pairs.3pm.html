<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Var::Pairs - OO iterators and pair constructors for variables</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libvar-pairs-perl">libvar-pairs-perl_0.004002-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Var::Pairs - OO iterators and pair constructors for variables

</pre><h4><b>VERSION</b></h4><pre>
       This document describes Var::Pairs version 0.004002

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Var::Pairs;

           # pairs() lists all OO pairs from arrays and hashes...

           for my $next (pairs @array) {
               say $next-&gt;index, ' has the value ', $next-&gt;value;
           }

           # each_pair() iterates OO pairs from arrays and hashes...

           while (my $next = each_pair %hash) {
               say $next-&gt;key, ' had the value ', $next-&gt;value;
               $next-&gt;value++;
           }

           # to_kv() converts vars into var_name =&gt; var_value pairs...

           Sub::Install::install_sub({to_kv $code, $from, $into});

           # invert() reverses a one-to-many mapping correctly...

           my %reverse_mapping = invert %mapping;

           my %reverse_lookup  = invert @data;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module exports a small number of subroutines that add some Perl 6 conveniences to Perl 5.
       Specifically, the module exports several subroutines that simplify interactions with key/value pairs in
       hashes and arrays.

</pre><h4><b>INTERFACE</b></h4><pre>
   <b>Array</b> <b>and</b> <b>hash</b> <b>iterators</b>
       "pairs %hash"
       "pairs @array"
       "pairs $hash_or_array_ref"
           In list context, "pairs()" returns a list of "pair" objects, each of which contains one key/index and
           value from the argument.  In scalar and void contexts, "pairs()" throws an exception.

           The typical list usage is:

               for my $pair (pairs %container) {
                   # ...do something with $pair
               }

           The  intent  is  to  provide  a  safe  and  reliable  replacement for the built-in "each()" function;
           specifically, a replacement that can be used in "for" loops.

       "kvs %hash"
       "kvs @array"
       "kvs $hash_or_array_ref"
           In list context, "kvs()" returns a list of alternating keys and values.  That is "kvs %hash" flattens
           the hash to "(<u>key</u>, <u>value</u>, <u>key</u>, <u>value</u>...)"  and "kvs @array" flattens the  array  to  "(<u>index</u>,  <u>value</u>,
           <u>index</u>, <u>value</u>...)".

           In scalar and void contexts, "kvs()" throws an exception.

           The most typical use is to populate a hash from an array:

               my %hash = kvs @array;

               # does the same as:

               my %hash; @hash{0..$#array} = @array;

       "each_pair %hash"
       "each_pair @array"
       "each_pair $hash_or_array_ref"
       "each_pair $subroutine_ref"
           In  all contexts, "each_pair()" returns a single "pair" object, containing the key/index and value of
           the next element in the argument.

           A separate internal iterator is created  for  each  call  to  "each_pair()",  so  multiple  calls  to
           "each_pair()"  on the same container variable can be nested without interacting with each other (i.e.
           unlike multiple calls to "each()").

           When the iterator is exhausted, the next call to "each_pair()"  returns  "undef"  or  an  empty  list
           (depending  on  context),  and resets the iterator.  The iterator is also reset when execution leaves
           the block in which "each_pair()" is called. This means, for  example,  that  "last"-ing  out  of  the
           middle of an iterated loop does the right thing (by resetting the iterator).

           The typical usage is:

               while (my $pair = each_pair %container) {
                   # ...do something with $pair-&gt;key and $pair-&gt;value
               }

           Note, however, that using "pairs()" in a "for" loop is the preferred idiom:

               for my $pair (pairs %container) {
                   # ...do something with $pair-&gt;key and $pair-&gt;value
               }

           The  "each_pair()"  subroutine  can  also  be  passed a reference to a subroutine, in which case that
           subroutine is used directly as the iterator.

           When iterated, this iterator subroutine is called in list context and is expected to return a  single
           value  on  each call (i.e. the next value to be iterated), or else an empty list when the iterator is
           exhausted.

           For example:

               # Calling this sub returns a reference to an anonymous iterator sub...
               sub count_down {
                   my ($from, $to) = @_;

                   return sub {
                       return () if $from &lt; $to;  # End of iterator
                       return $from--;            # Next iterated value
                   }
               }

               # Build a 10--&gt;1 countdown and iterate it...
               while (my $next = each_pair count_down(10, 1)) {
                   say $next-&gt;value;
               }

       "each_kv %hash"
       "each_kv @array"
       "each_kv $hash_or_array_ref"
       "each_kv $subroutine_ref"
           This subroutine is very similar to "each_pair()", except that in list contexts, &lt;<b>each_kv()</b>&gt; returns a
           list of two elements: the key/index and the value of the next element in  the  argument.   In  scalar
           contexts, just the next key is returned.

           As  with  "each_pair()",  a  separate  internal  iterator is created for each call to "each_kv()", so
           multiple calls to "each_kv()" on the same container variable can be nested without  interacting  with
           each other (i.e. unlike multiple calls to "each()").

           When  the iterator is exhausted, the next call to "each_kv()" returns "undef" in scalar context or an
           empty list in list context, and resets the iterator. The iterator is also reset when execution leaves
           the block in which "each_kv()" is called.

           The typical list usage is:

               while (my ($key1, $val1) = each_kv %container) {
                   while (my ($key2, $val2) = each_kv %container) {
                       # ...do something with the two keys and two values
                   }
               }

           The typical scalar usage is:

               while (my $key1 = each_kv %container) {
                   while (my $key2 = each_kv %container) {
                       # ...do something with the two keys
                   }
               }

           In other words, "each_kv()"  is  a  drop-in  replacement  for  Perl's  built-in  "each()",  with  two
           exceptions:  one an advantage, the other a limitation. The advantage is that you can nest "each_kv()"
           iterations over the same variable without shooting yourself in the  foot.  The  limitation  is  that,
           unlike  "each()",  "each_kv()"  does  not  reset when you call the "keys" function on the hash you're
           iterating.

       "each_value %hash"
       "each_value @array"
       "each_value $hash_or_array_ref"
       "each_value $subroutine_ref"
           The "each_value()" subroutine works exactly like "each_kv()", except that in  all  contexts  it  just
           returns the value being iterated, not the key or key/value combination.

           For example:

               # Build a 10--&gt;1 countdown and iterate it...
               while (my ($next) = each_value count_down(10, -10)) {
                   say $next;
               }

               while (my $value1 = each_value %container) {
                   while (my $value2 = each_value %container) {
                       # ...do something with the two values
                   }
               }

           Note  that,  if your iterator can return a false value, such as 0 from the "count_down()" iterator in
           the previous example, then you should call "each_value()" in list context (as in  the  "count_down()"
           example) so that the false value does not prematurely terminate the "while" loop.

       "%hash-&gt;pairs"
       "@array-&gt;pairs"
       "$hash_or_array_ref-&gt;pairs"
       "%hash-&gt;kvs"
       "@array-&gt;kvs"
       "$hash_or_array_ref-&gt;kvs"
       "%hash-&gt;each_pair"
       "@array-&gt;each_pair"
       "$hash_or_array_ref-&gt;each_pair"
       "%hash-&gt;each_kv"
       "@array-&gt;each_kv"
       "$hash_or_array_ref-&gt;each_kv"
       "%hash-&gt;each_value"
       "@array-&gt;each_value"
       "$hash_or_array_ref-&gt;each_value"
           If you have the "autobox" module installed, you can use this OO syntax as well. Apart from their call
           syntax, these OO forms are exactly the same as the subroutine-based interface described above.

   <b>Pairs</b>
       "$pair-&gt;key"
           Returns  a  copy  of the key of the pair, if the pair was derived from a hash.  Returns a copy of the
           index of the pair, if the pair was derived from an array.

       "$pair-&gt;index"
           Nothing but a synonym for "$pair-&gt;key". Use whichever suits  your  purpose,  your  program,  or  your
           predilections.

       "$pair-&gt;value"
           Returns the value of the pair, as an lvalue.  That is:

               for my $item (pairs %items) {
                   say $item-&gt;value
                       if $item-&gt;key =~ /\d/;
               }

           will print the value of every entry in the %items hash whose key includes a digit.

           And:

               for my $item (pairs %items) {
                   $item-&gt;value++;
                       if $item-&gt;key =~ /^Q/;
               }

           will increment each value in the %items hash whose key starts with 'Q'.

       "$pair-&gt;kv"
           Returns a two-element list containing copies of the key and the value of the pair. That is:

               for my $item (pairs %items) {
                   my ($k, $v) = $item-&gt;kv;
                   say $v
                       if $k =~ /\d/;
               }

           will print the value of every entry in the %items hash whose key includes a digit.

       "$pair"
           When  used  as a string, a pair is converted to a suitable representation for a pair, namely: "<u>key</u> =&gt;
           <u>value</u>"

       "0 + $pair"
           Pairs cannot be used as numbers: an exception is thrown.

       "if ($pair) {...}"
           When a pair is used as a boolean, it is always true.

   <b>Named</b> <b>pair</b> <b>constructors</b>
       "to_pair $scalar, @array, %hash, $etc"
           The "to_pair" subroutine takes one or more variables and converts each  of  them  to  a  single  Pair
           object.  The  Pair's  key is the name of the variable (minus its leading sigil), and the value is the
           value of the variable (if it's a scalar) or a reference to the variable (if it's an array or hash).

           That is:

               to_pair $scalar, @array, %hash, $etc

           is equivalent to:

               Pair-&gt;new( scalar =&gt;  $scalar ),
               Pair-&gt;new( array  =&gt; \@array  ),
               Pair-&gt;new( hash   =&gt; \%hash   ),
               Pair-&gt;new( etc    =&gt;  $etc    )

           This is especially useful for generating modern sets of named arguments for  other  subroutines.  For
           example:

               Sub::Install::install_sub(to_pair $code, $from, $into);

           instead of:

               Sub::Install::install_sub(
                   Pair-&gt;new(code =&gt; $code),
                   Pair-&gt;new(from =&gt; $from),
                   Pair-&gt;new(into =&gt; $into)
               );

       "to_kv $scalar, @array, %hash, $etc"
           The  "to_kv()"  subroutine  takes one or more variables and converts each of them to a <u>key</u> "=&gt;" <u>value</u>
           sequence (i.e. a two-element list, rather than a Pair object).

           As with "to_pair()", the key is the name of the variable (minus its leading sigil), and the value  is
           the  value  of  the  variable  (if it's a scalar) or a reference to the variable (if it's an array or
           hash).

           That is:

               to_kv $scalar, @array, %hash, $etc

           is equivalent to:

               scalar =&gt; $scalar, array =&gt; \@array, hash =&gt; \%hash, etc =&gt; $etc

           This is especially useful for generating traditional sets of named arguments for  other  subroutines.
           For example:

               Sub::Install::install_sub({to_kv $code, $from, $into});

           instead of:

               Sub::Install::install_sub({code =&gt; $code, from =&gt; $from, into =&gt; $into});

   <b>Array</b> <b>and</b> <b>hash</b> <b>inverters</b>
       "invert %hash"
       "invert @array"
       "invert $hash_or_array_ref"
           The "invert" subroutine takes a single hash or array (or a reference to either) and returns a list of
           alternating  keys  and  value,  where  each  key  is  a  value  from  the  original variable and each
           corresponding value is a reference to an array containing the original key(s). This list is typically
           used to initialize a second hash, which can then be used as a reverse mapping.  In other words:

               my %hash = ( a =&gt; 1, b =&gt; 2, c =&gt; 1, d =&gt; 1, e =&gt; 2, f =&gt; 3 );

               my %inversion = invert %hash;

           is equivalent to:

               my %inversion = (
                   1 =&gt; ['a', 'c', 'd'],
                   2 =&gt; ['b', 'e'],
                   3 =&gt; ['f'],
               );

           "invert" correctly handles the many-to-many case where some of the values in the original  are  array
           references. For example:

               my %hash = ( a =&gt; [1,2], b =&gt; 2, c =&gt; [1,3], d =&gt; 1, e =&gt; [3,2], f =&gt; 3 );

               my %inversion = invert %hash;

           is equivalent to:

               my %inversion = (
                   1 =&gt; ['a', 'c', 'd'],
                   2 =&gt; ['a', 'b', 'e'],
                   3 =&gt; ['c', 'e', 'f'],
               );

       "invert_pairs %hash"
       "invert_pairs @array"
       "invert_pairs $hash_or_array_ref"
           "invert_pairs()"  acts  exactly  like "invert()", except that it returns a list of Pair objects (like
           "pairs()" does).

           This is not useful for initializing other hashes, but is handy for debugging a reverse mapping:

               say for invert_pairs %hash;

       "%hash-&gt;invert" or "%hash-&gt;invert_pairs"
       "@array-&gt;invert" or "@array-&gt;invert_pairs"
       "$hash_or_array_ref-&gt;invert" or "$hash_or_array_ref-&gt;invert_pairs"
           If you have the "autobox" module installed, you can use this OO syntax as well. Apart from their call
           syntax, these OO forms are exactly the same as the subroutine-based interfaces described above.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       "Argument to %s must be hash or array (not %s)"
           Except for "to_pair()" and "to_kv()", all of the subroutines exported by this module only operate  on
           hashes, arrays, or references to hashes or arrays. Asking for the "pairs" insidde a scalar, typeglob,
           or other entity is meaningless; they're simply not structured as collections of keyed values.

       "Useless use of pairs() in void context"
       "Useless use of kvs() in void context"
       "Useless use of invert() in void context"
           None of these subroutines has any side-effects, so calling them in void context is a waste of time.

       "Invalid call to pairs() in scalar context"
       "Invalid call to kvs() in scalar context"
       "Invalid call to invert() in scalar context"
           All  these  subroutines  return  a  list,  so in scalar context you just get a count (which there are
           cheaper and easier ways to obtain).

           The most common case where this error is reported is when "pairs()" or "kvs()" is used in  a  "while"
           loop,  instead  of  a  "for"  loop.  Either  change  the  type  of loop, or else use "each_pair()" or
           "each_kv()" instead.

       "Can't convert Pair(%s =&gt; %s) to a number"
           You attempted to use one of the pair objects returned by "pairs()" as a number, but the module has no
           idea how to do that.

           You probably need to use "$pair-&gt;index" or "$pair-&gt;value" instead.

</pre><h4><b>CONFIGURATION</b> <b>AND</b> <b>ENVIRONMENT</b></h4><pre>
       Var::Pairs requires no configuration files or environment variables.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       The module requires Perl 5.014 and the following modules:

       Perl 5.14 or later
       Devel::Callsite
       Data::Alias (under Perl 5.20 and earlier)
       PadWalker

       To use the optional "$container-&gt;pairs" syntax, you also need the "autobox" module.

</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
       None reported.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       No bugs have been reported.

       Please report any bugs or feature requests to "<a href="mailto:bug-var-pairs@rt.cpan.org">bug-var-pairs@rt.cpan.org</a>", or through the  web  interface
       at &lt;<a href="http://rt.cpan.org">http://rt.cpan.org</a>&gt;.

       "each_kv()"  acts  like  a true one-time only iterator (in the OO sense), so there is no way to reset its
       iteration (i.e. the way that calling "keys()" on a hash or array, resets any "each()" that  is  iterating
       it).  If you need to reset partially iterated hashes or arrays, you will need to use some other mechanism
       to do so.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Based on a suggestion by Karl Brodowsky and inspired by several features of Perl 6.

</pre><h4><b>AUTHOR</b></h4><pre>
       Damian Conway  "&lt;<a href="mailto:DCONWAY@CPAN.org">DCONWAY@CPAN.org</a>&gt;"

</pre><h4><b>LICENCE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2012, Damian Conway "&lt;<a href="mailto:DCONWAY@CPAN.org">DCONWAY@CPAN.org</a>&gt;". All rights reserved.

       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself. See perlartistic.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       BECAUSE  THIS  SOFTWARE  IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE, TO THE EXTENT
       PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS  AND/OR  OTHER
       PARTIES  PROVIDE  THE  SOFTWARE  "AS  IS"  WITHOUT  WARRANTY  OF  ANY  KIND, EITHER EXPRESSED OR IMPLIED,
       INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS  FOR  A  PARTICULAR
       PURPOSE.  THE  ENTIRE  RISK  AS  TO  THE  QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE
       SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

       IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER,  OR  ANY
       OTHER  PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
       TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING  OUT  OF
       THE  USE  OR  INABILITY  TO  USE  THE  SOFTWARE  (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
       RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE  TO  OPERATE
       WITH  ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
       DAMAGES.

perl v5.36.0                                       2023-07-21                                    <u>Var::<a href="../man3pm/Pairs.3pm.html">Pairs</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>