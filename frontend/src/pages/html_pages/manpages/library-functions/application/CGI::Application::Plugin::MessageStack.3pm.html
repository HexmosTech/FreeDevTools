<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGI::Application::Plugin::MessageStack - A message stack for your CGI::Application</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcgi-application-plugin-messagestack-perl">libcgi-application-plugin-messagestack-perl_0.34-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CGI::Application::Plugin::MessageStack - A message stack for your CGI::Application

</pre><h4><b>VERSION</b></h4><pre>
       Version 0.34

</pre><h4><b>SYNOPSIS</b></h4><pre>
       This plugin gives you a few support methods that you can call within your cgiapp to pass along messages
       between requests for a given user.

        use CGI::Application::Plugin::Session;
        use CGI::Application::Plugin::MessageStack;

        sub mainpage {
          my $self = shift;
          my $template = $self-&gt;load_tmpl( 'mainpage.TMPL', 'die_on_bad_params' =&gt; 0 );
          # ...
          $template-&gt;output;
        }

        sub process {
          my $self = shift;
          $self-&gt;push_message(
              -scope          =&gt; 'mainpage',
              -message        =&gt; 'Your listing has been updated',
              -classification =&gt; 'INFO',
            );
          $self-&gt;forward( 'mainpage' );
        }

        sub cgiapp_init {
          # setup your session object as usual...
        }

       Meanwhile, in your (HTML::Template) template code:

        ...
        &lt;style type="text/css"&gt;
          .INFO {
            font-weight: bold;
          }
          .ERROR {
            color: red;
          }
        &lt;/style&gt;
        ...
        &lt;h1&gt;Howdy!&lt;/h1&gt;
        &lt;!-- TMPL_LOOP NAME="CAP_Messages" --&gt;
          &lt;div class="&lt;!-- TMPL_VAR NAME="classification" --&gt;"&gt;
            &lt;!-- TMPL_VAR NAME="message" --&gt;
          &lt;/div&gt;
        &lt;!-- /TMPL_LOOP --&gt;
        ...

       It's a good idea to turn off 'die_on_bad_params' in HTML::Template - in case this plugin tries to put in
       the parameters and they're not available in your template.

       Here's a quick TT example:

        &lt;style type="text/css"&gt;
          .INFO {
            font-weight: bold;
          }
          .ERROR {
            color: red;
          }
        &lt;/style&gt;
        ...
        &lt;h1&gt;Howdy!&lt;/h1&gt;
        [% FOREACH CAP_Messages %]
           &lt;div class="[% classification %]"&gt;[% message %]&lt;/div&gt;
        [% END %]
        ...

       If you use TT, I recommend using CAP-TT and a more recent version (0.09), which supports cgiapp's
       load_tmpl hook and then this plugin will automatically supply TT with the relevant messages.  Your
       runmode could be this simple:

        sub start {
            my $self = shift;
            my $session = $self-&gt;session;
            return $self-&gt;tt_process( 'output.tt' );
        }

       I don't have the experience to weigh in on how you'd do this with other templates (HTDot, Petal), but
       basically, this plugin will put in a loop parameter called 'CAP_Messages'.  Within each element of that
       loop, you'll have two tags, 'classification' and 'message'.

       NOTE: I have broken backwards compatibility with this release (0.30) and the loop parameter's default
       name is now 'CAP_Messages'.  If you used the old __CAP_Messages or want to use another name, feel free to
       use the capms_config to override the "-loop_param_name".

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This plugin by default needs a session object to tuck away the message(s).  It's recommended that you use
       this in conjunction with CGI::Application::Plugin::Session.  You can opt to not have the messages persist
       and thereby, not use CAP-Session by using the "-dont_use_session" option in the "capms_config" method.

       This plugin hooks into cgiapp's load_tmpl method and if you've pushed any messages in the stack, will
       automatically add the message parameters.

       In the functions, there are scope &amp; classification keys and when they're used for either display or your
       API purposes (clearing, pop'ing, etc), the classification is an exclusive specification.  Meaning, if you
       ask for messages with the 'ERROR' classification, it will only deal with messages that you've pushed in
       with the 'ERROR' classification.  Any messages that have no classification aren't included.

       The scope key is not exclusive, meaning that if you ask for messages with a 'mainpage' scope, it will
       deal with messages that you've pushed with that scope <b>as</b> <b>well</b> <b>as</b> any messages that you've pushed in
       without a scope.

       If you use both scope &amp; classification, it blends both of those rules, first getting all matching
       messages with the same classification and then filtering out messages that are scoped and don't match the
       scope you're looking for.

       This logic may change as I get feedback from more saavy developers.  What we may end up doing is have a
       plugin configuration where you can dictate the logic that's used.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>push_message</b>
        $self-&gt;push_message(
            -scope          =&gt; 'mainpage',
            -message        =&gt; 'Your listing has been updated',
            -classification =&gt; 'INFO',
          );

       You provide a hash to the <b>push_message()</b> method with three possible keys:

       •   message  -  a text message.  You can put HTML in there - just make sure you don't use the ESCAPE=HTML
           in your HTML::Template code

       •   scope - which runmode(s) can this message appear?  If you want to specify  just  one,  use  a  scalar
           assignment.  Otherwise, use an array reference with the list of runmodes.

       •   classification  - a simple scalar name representing the classification of your message (i.e. 'ERROR',
           'WARNING' ... ).  This is very useful for CSS styles (see template example above).

       The scope &amp; classification keys are optional.  If you don't provide a scope,  it  will  assume  a  global
       presence.

   <b>messages</b>
        my @messages = $self-&gt;messages();
        my @messages = $self-&gt;messages( -scope =&gt; 'mainpage' );
        my @messages = $self-&gt;messages( -scope =&gt; 'mainpage', -classification =&gt; 'ERROR' );
        my @messages = $self-&gt;messages( -classification =&gt; 'ERROR' );

       If you want to take a gander at the message stack data structure, you can use this method.

       Optionally,  you  can  use  a  hash  parameters  to  get  a slice of the messages, using the same keys as
       specified in the <b>push_message()</b> method.

       It will return an array reference of the matching messages or 'undef', if there's either no  messages  in
       the stack or no messages that match your specification(s).

   <b>pop_message</b>
        my $message = $self-&gt;pop_message();
        my $message = $self-&gt;pop_message( -scope =&gt; 'mainpage' );
        my $message = $self-&gt;pop_message( -scope =&gt; 'mainpage', -classification =&gt; 'WARNING' );
        my $message = $self-&gt;pop_message( -classification =&gt; 'ERROR' );

       Pops off the last message from the stack and returns it.  Note that this just returns the -message part.

       You  can  pop  off  an  exact  message,  given a hash parameters, using the same keys as specified in the
       <b>push_message()</b> method.

       Otherwise, it will pop off the message, given the current runmode and the last message added.

   <b>clear_messages</b>
        $self-&gt;clear_messages();
        $self-&gt;clear_messages( -scope =&gt; 'mainpage' );
        $self-&gt;clear_messages( -scope =&gt; 'mainpage', -classification =&gt; 'ERROR' );
        $self-&gt;clear_messages( -classification =&gt; 'ERROR' );

       Clears the message stack.

       Optionally, you can clear particular slices of the message stack, given a hash parameters, using the same
       keys as specified in the <b>push_message()</b> method.

       If you specify a scope, it will clear any messages that are either global or match that scope

       If you specify a classification, it will clear any messages that have that classification  (but  not  any
       messages that don't have any classification).

       If you specify both, it will combine both that logic in an AND fashion.

   <b>capms_config</b>
        $self-&gt;capms_config(
            -automatic_clearing            =&gt; 1,
            -dont_use_session              =&gt; 1,
            -loop_param_name               =&gt; 'MyOwnLoopName',
            -message_param_name            =&gt; 'MyOwnMessageName',
            -classification_param_name     =&gt; 'MyOwnClassificationName',
          );

       There is a configuration option that you, as the developer can specify:

       •   -automatic_clearing:  By  default, this is turned off.  If you override it with a true value, it will
           call <b>clear_messages()</b> automatically after the messages are automatically put into template.

       •   -dont_use_session: This will override this Plugin's dependence  on  CGI::Application::Plugin::Session
           and  instead,  temporarily  store the message data such that it will be available to templates within
           the same web request, but no further.  If  you're  running  your  cgiapp  under  a  persistent  state
           (mod_perl), we'll also make sure your messages are gone by the end of the request.

       •   -loop_param_name:  This  will override the default __CAP_Messages (or CAP_Messages for TT users) name
           for the loop  of  messages,  which  is  only  used  for  the  "load_tmpl"  callback.   Meaning,  this
           configuration  will  only  impact  your template code.  So if you use the 'MyOwnLoopName' above, then
           your template code (for HTML::Template users) should look like:

            &lt;!-- TMPL_LOOP NAME="MyOwnLoopName" --&gt;
            ...
            &lt;!-- /TMPL_LOOP --&gt;

       •   -message_param_name: This will override the default '-message' in both the template code <b>as</b>  <b>well</b>  <b>as</b>
           the  keys  in  each hashref of the arrayref that's returned by the <b>messages()</b> function.  So a call to
           <b>messages()</b> may return:

            [ { 'MyOwnMessageName' =&gt; 'this is just a test' }, ... ]

           instead of:

            [ { '-message' =&gt; 'this is just a test' }, ... ]

           Likewise, your templates will need to use your parameter name:

            &lt;!-- TMPL_LOOP NAME="MyOwnLoopName" --&gt;
              Here's the message: &lt;!-- TMPL_VAR NAME="MyOwnMessageName" --&gt;
            &lt;!-- /TMPL_LOOP --&gt;

       •   -classification_param_name: Just like the "-message_param_name" parameter - this  will  override  the
           default  '-classification'  key  in both the template code <b>as</b> <b>well</b> <b>as</b> the keys in each hashref of the
           arrayref that's returned by the <b>messages()</b> function.  So a call to <b>messages()</b> may return:

            [ { 'MyOwnClassificationName' =&gt; 'ERROR', 'MyOwnMessageName' =&gt; 'this is just a test' }, ... ]

           instead of:

            [ { '-classification' =&gt; 'ERROR', '-message' =&gt; 'this is just a test' }, ... ]

           Likewise, your templates will need to use your parameter name:

            &lt;!-- TMPL_LOOP NAME="MyOwnLoopName" --&gt;
               &lt;div class="&lt;!-- TMPL_VAR NAME="MyOwnClassificationName" --&gt;"&gt;
                  Here's the message: &lt;!-- TMPL_VAR NAME="MyOwnMessageName" --&gt;
               &lt;/div&gt;
            &lt;!-- /TMPL_LOOP --&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Jason Purdy, "&lt;<a href="mailto:Jason@Purdy.INFO">Jason@Purdy.INFO</a>&gt;"

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       CGI::Application and CGI::Application::Plugin::Session

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests to  "<a href="mailto:bug-cgi-application-plugin-messagestack@rt.cpan.org">bug-cgi-application-plugin-messagestack@rt.cpan.org</a>",  or
       through                     the                    web                    interface                    at
       &lt;<a href="http://rt.cpan.org/NoAuth/ReportBug.html">http://rt.cpan.org/NoAuth/ReportBug.html</a>?Queue=CGI-Application-Plugin-MessageStack&gt;.     I    will    be
       notified, and then you'll automatically be notified of progress on your bug as I make changes.

       I suspect that this code could use some expert guidance.  I hacked it together and I'd hate to think that
       it  would  be  responsible  for  slowing  templates  down.   Please  feel free to submit patches, guiding
       comments, etc.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to the guys on the #cgiapp channel

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2005 Jason Purdy, all rights reserved.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.38.2                                       2022-12-12             <u>CGI::Applicatio...n::<a href="../man3pm/MessageStack.3pm.html">MessageStack</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>