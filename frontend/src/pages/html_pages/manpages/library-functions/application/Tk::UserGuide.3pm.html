<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tk::UserGuide - Writing Tk applications in Perl 5</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-tk">perl-tk_804.036+dfsg1-5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tk::UserGuide - Writing Tk applications in Perl 5

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This document is for beginners.  It assumes you know some <b>Perl</b>, and have it and Tk running.  If you are
       <u>not</u> currently reading this document courtesy of the <b>widget</b> demonstration program, please be sure to run
       <b>widget</b>, as it will show you the various widget types supported by Tk and how to use them. <b>widget</b> should
       be installed in your default path, so type <u>widget</u> at a command prompt.

       Here are links to other novice tutorials:

       &lt;<a href="http://www.lehigh.edu/~sol0/ptk/tpj1.html">http://www.lehigh.edu/~sol0/ptk/tpj1.html</a>&gt; &lt;<a href="http://www.lehigh.edu/~sol0/ptk/perlmonth01/pm1.html">http://www.lehigh.edu/~sol0/ptk/perlmonth01/pm1.html</a>&gt;

       <u>Mastering</u> <u>Perl/Tk</u> is the definitive book on Perl/Tk:

       &lt;<a href="http://www.oreilly.com/catalog/mastperltk">http://www.oreilly.com/catalog/mastperltk</a>&gt;

</pre><h4><b>Some</b> <b>Background</b></h4><pre>
       Tk GUI programming is event-driven.  (This may already be familiar to you.)  In event-driven programs,
       the main GUI loop is outside of the user program and inside the GUI library.  This loop - initiated by
       calling <b>MainLoop</b> - watches all events of interest and activates the correct handler procedures to handle
       these events.  Some of these handler procedures may be user-supplied; others will be part of the library.

       For a programmer, this means that you're not watching what is happening; instead, you are requested by
       the toolkit to perform actions whenever necessary.  So, you're not watching for 'raise window / close
       window / redraw window' requests, but you tell the toolkit which routine will handle such cases, and the
       toolkit will call the procedures when required. These procedures are known as <u>callbacks</u>, and some of them
       you write yourself.

</pre><h4><b>First</b> <b>Requirements</b></h4><pre>
       <b>Perl</b> programs that use Tk need to include "use Tk".  A program should also use "use strict" and the <b>-w</b>
       switch to ensure the program is working without common errors.

       Any Perl/Tk application starts by creating the Tk <b>MainWindow</b>.  You then create items inside the
       <b>MainWindow</b>, and/or create new windows called <b>Toplevel</b>s that also contain child items, before starting the
       <b>MainLoop</b>, which is the last logical statment in your program. You can also create more items and windows
       while you're running, using callbacks.  Items are only shown on the display after they have been arranged
       by a <u>geometry</u> <u>manager</u> like <b>pack</b>; more information on this later.  <b>MainLoop</b> starts the GUI and handle all
       events.  That's all there is to it!  A trivial one-window example is shown below:

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
           use Tk;
           use strict;

           my $mw = MainWindow-&gt;new;
           $mw-&gt;Label(-text =&gt; 'Hello, world!')-&gt;pack;
           $mw-&gt;Button(
               -text    =&gt; 'Quit',
               -command =&gt; sub { exit },
           )-&gt;pack;
           MainLoop;

       Please run this example.  It shows you two widget types, a <b>Label</b> and a <b>Button</b>, and how they are packed.
       When clicked, the <b>Button</b> widget invokes the callback specified by the "-command" option.  Finally, note
       the typical Tk style using "-option" =&gt; "value" pairs.

</pre><h4><b>Widget</b> <b>creation</b></h4><pre>
       Tk windows and widgets are hierarchical, i.e. one window includes one or more other windows.  You create
       the first Tk window using "MainWindow-&gt;new".  This returns a window handle, assigned to $mw in the
       example above.  Keep track of the main handle, commonly called a <u>widget</u> <u>reference</u>.

       You can use any Tk handle to create child widgets within the window (or widget).  This is done by calling
       the Tk constructor method on the variable.  In the example above, the "Label" method called from $mw
       creates a <b>Label</b> widget inside the <b>MainWindow</b>.  In the constructor call, you can specify various options;
       you can later add or change options for any widget using the <b>configure</b> method, which takes the same
       parameters as the constructor.  The one exception to the hierarchical structure is the <b>Toplevel</b>
       constructor, which creates a new outermost window.

       After you create any widget (other than the <b>MainWindow</b> or <b>Toplevel</b>s, you must render it by calling <b>pack</b>.
       (This is not entirely true; more later)).  If you do not need to refer to the widget after construction
       and packing, call <b>pack</b> off the constructor results, as shown for the <b>Label</b> and <b>Button</b> in the example
       above.  Note that the result of the compound call is the result of <b>pack</b>, which is a valid Tk handle.

       Windows and widgets are deleted by calling <b>destroy</b> on them; this will delete and un-draw the widget and
       all its children.

</pre><h4><b>Standard</b> <b>Tk</b> <b>widgets</b></h4><pre>
       Here is an itemize of the standard Tk widget set.

       Button
       Canvas
       Checkbutton
       Entry
       Frame
       Label
       Labelframe
       Listbox
       Menu
       Menubutton
       Message
       Panedwindow
       Radiobutton
       Scale
       Scrollbar
       Spinbox
       Text
       Toplevel

       Perl/Tk provides an equal number of new widgets, above and beyond this core set.

       Adjuster
       Balloon
       BrowseEntry
       ColorEditor
       Dialog
       DialogBox
       DirTree
       ErrorDialog
       FBox
       FileSelect
       HList
       LabEntry
       LabFrame
       NoteBook
       Optionmenu
       Pane
       ProgressBar
       ROText
       Table
       TextUndo
       Tiler
       TList
       Tree

</pre><h4><b>Variables</b> <b>and</b> <b>callback</b> <b>routines</b></h4><pre>
       Most  graphical  interfaces  are  used  to  set  up  a set of values and conditions, and then perform the
       appropriate action.  The Tk toolkit is different from your average text-based prompting  or  menu  driven
       system  in  that  you  do  not collect settings yourself, and decide on an action based on an input code;
       instead, you leave these values to your toolkit and only get them when the action is performed.

       So, where a traditional text-based system would look like this:

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
           use strict;

           print "Please type a font name\n";
           my $font = &lt;&gt;; chomp $font;
           # Validate font

           print "Please type a file name\n";
           my $filename = &lt;&gt;; chomp $filename;
           # Validate filename

           print "Type &lt;1&gt; to fax, &lt;2&gt; to print\n";
           my $option = &lt;&gt;; chomp $option;
           if ($option eq 1) {
               print "Faxing $filename in font $font\n";
           } elsif ($option eq 2) {
               print "Now sending $filename to printer in font $font\n";
           }

       The slightly larger example below shows how to do this in Tk.  Note the use of  callbacks.   Note,  also,
       that  Tk  handles  the  values,  and  the subroutine uses the method <b>get</b> to get at the values.  If a user
       changes his mind and wants to change the font again, the application never notices; it's all  handled  by
       Tk.

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
           use Tk;
           use strict;

           my $mw = MainWindow-&gt;new;

           $mw-&gt;Label(-text =&gt; 'File Name')-&gt;pack;
           my $filename = $mw-&gt;Entry(-width =&gt; 20);
           $filename-&gt;pack;

           $mw-&gt;Label(-text =&gt; 'Font Name')-&gt;pack;
           my $font = $mw-&gt;Entry(-width =&gt; 10);
           $font-&gt;pack;

           $mw-&gt;Button(
               -text =&gt; 'Fax',
               -command =&gt; sub{do_fax($filename, $font)}
           )-&gt;pack;

           $mw-&gt;Button(
               -text =&gt; 'Print',
               -command =&gt; sub{do_print($filename, $font)}
           )-&gt;pack;

           MainLoop;

           sub do_fax {
               my ($file, $font) = @_;
               my $file_val = $file-&gt;get;
               my $font_val = $font-&gt;get;
               print "Now faxing $file_val in font $font_val\n";
           }

           sub do_print {
               my ($file, $font) = @_;
               my $file_val = $file-&gt;get;
               my $font_val = $font-&gt;get;
               print "Sending file $file_val to printer in font $font_val\n";
           }

</pre><h4><b>The</b> <b>packer</b> <b>-</b> <b>grouping</b> <b>with</b> <b>Frame</b> <b>widgets</b></h4><pre>
       In  the  examples above, you must have noticed the <b>pack</b> calls.  This is one of the more complicated parts
       of Tk.  The basic idea is that any window or widget should be subject  to  a  Tk  geometry  manager;  the
       <u>packer</u> is one of the placement managers, and <b>grid</b> is another.

       The  actions  of the packer are rather simple: when applied to a widget, the packer positions that widget
       on the indicated position within the remaining space in its parent.  By default, the position is on  top;
       this  means the next items will be put below.  You can also specify the left, right, or bottom positions.
       Specify position using <b>-side</b> <b>=&gt;</b> <b>'right'</b>.

       Additional packing parameters specify the behavior of the widget when there is some  space  left  in  the
       <b>Frame</b>  or  when  the window size is increased.  If widgets should maintain a fixed size, specify nothing;
       this is the default.  For widgets that you want to fill up the current horizontal and/or vertical  space,
       specify  <b>-fill</b>  <b>=&gt;</b>  <b>'x'</b>,  <b>'y'</b>,  or  <b>'both'</b>;  for  widgets  that should grow, specify <b>-expand</b> <b>=&gt;</b> <b>1</b>.  These
       parameters are not shown in the example below; see the <b>widget</b> demonstration.

       If you want to group some items within a window that have a different packing order than others, you  can
       include  them  in a Frame.  This is a do-nothing window type that is meant for packing or filling (and to
       play games with borders and colors).

       The example below shows the use of pack and Frames:

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
           use Tk;
           use strict;

           # Take top and the bottom - now implicit top is in the middle
           my $mw = MainWindow-&gt;new;
           $mw-&gt;title( 'The MainWindow' );
           $mw-&gt;Label(-text =&gt; 'At the top (default)')-&gt;pack;
           $mw-&gt;Label(-text =&gt; 'At the bottom')-&gt;pack(-side =&gt; 'bottom');
           $mw-&gt;Label(-text =&gt; 'The middle remains')-&gt;pack;

           # Since left and right are taken, bottom will not work...
           my $top1 = $mw-&gt;Toplevel;
           $top1-&gt;title( 'Toplevel 1' );
           $top1-&gt;Label(-text =&gt; 'Left')-&gt;pack(-side =&gt; 'left');
           $top1-&gt;Label(-text =&gt; 'Right')-&gt;pack(-side =&gt; 'right');
           $top1-&gt;Label(-text =&gt; '?Bottom?')-&gt;pack(-side =&gt; 'bottom');

           # But when you use Frames, things work quite alright
           my $top2 = $mw-&gt;Toplevel;
           $top2-&gt;title( 'Toplevel 2' );
           my $frame = $top2-&gt;Frame;
           $frame-&gt;pack;
           $frame-&gt;Label(-text =&gt; 'Left2')-&gt;pack(-side =&gt; 'left');
           $frame-&gt;Label(-text =&gt; 'Right2')-&gt;pack(-side =&gt; 'right');
           $top2-&gt;Label(-text =&gt; 'Bottom2')-&gt;pack(-side =&gt; 'bottom');

           MainLoop;

</pre><h4><b>More</b> <b>than</b> <b>one</b> <b>window</b></h4><pre>
       Most real applications require more than one window.  As you just saw,  you  can  create  more  outermost
       windows  by  using  a <b>Toplevel</b> widget.  Each window is independent; destroying a <b>Toplevel</b> window does not
       affect the others as long as they are  not  a  child  of  the  closed  <b>Toplevel</b>.   However,  exiting  the
       <b>MainWindow</b>  will destroy all remaining <b>Toplevel</b> widgets and end the application.  The example below shows
       a trivial three-window application:

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
           use Tk;
           use strict;

           my $mw = MainWindow-&gt;new;
           fill_window($mw, 'Main');
           my $top1 = $mw-&gt;Toplevel;
           fill_window($top1, 'First top-level');
           my $top2 = $mw-&gt;Toplevel;
           fill_window($top2, 'Second top-level');
           MainLoop;

           sub fill_window {
               my ($window, $header) = @_;
               $window-&gt;Label(-text =&gt; $header)-&gt;pack;
               $window-&gt;Button(
                   -text    =&gt; 'close',
                   -command =&gt; [$window =&gt; 'destroy']
               )-&gt;pack(-side =&gt; 'left');
               $window-&gt;Button(
                   -text    =&gt; 'exit',
                   -command =&gt; [$mw =&gt; 'destroy']
               )-&gt;pack(-side =&gt; 'right');
           }

</pre><h4><b>More</b> <b>callbacks</b></h4><pre>
       So far, all callback routines shown called a user procedure.  You can also have a callback  routine  call
       another  Tk routine.  This is the way that scroll bars are implemented: scroll-bars can call a Tk item or
       a user procedure, whenever their position has changed.  The Tk item that has a scrollbar  attached  calls
       the scrollbar when its size or offset has changed.  In this way, the items are linked.  You can still ask
       a scrollbar's position, or set it by hand - but the defaults will be taken care of.

       The example below shows a <b>Listbox</b> with a scroll bar.  Moving the scrollbar moves the <b>Listbox</b>.  Scanning a
       <b>Listbox</b> (dragging an item with the left mouse button) moves the scrollbar.

            #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
            use Tk;
            use strict;

            my $mw = MainWindow-&gt;new;
            my $box = $mw-&gt;Listbox(
                -relief =&gt; 'sunken',
                -height  =&gt; 5,
                -setgrid =&gt; 1,
           );
           my @items = qw(One Two Three Four Five Six Seven
                          Eight Nine Ten Eleven Twelve);
           foreach (@items) {
              $box-&gt;insert('end', $_);
           }
           my $scroll = $mw-&gt;Scrollbar(-command =&gt; ['yview', $box]);
           $box-&gt;configure(-yscrollcommand =&gt; ['set', $scroll]);
           $box-&gt;pack(-side =&gt; 'left', -fill =&gt; 'both', -expand =&gt; 1);
           $scroll-&gt;pack(-side =&gt; 'right', -fill =&gt; 'y');

           MainLoop;

       Note  that  there's  a  convenience  method  <b>Scrolled</b> which helps constructing widgets with automatically
       managed scrollbars.

</pre><h4><b>Canvases</b> <b>and</b> <b>tags</b></h4><pre>
       One of the most powerful widgets in Tk is the <b>Canvas</b> window.  In a <b>Canvas</b> window,  you  can  draw  simple
       graphics  and include other widgets.  The <b>Canvas</b> area may be larger than the visible window, and may then
       be scrolled.  Any item you draw on the canvas has its own id, and may optionally have one or  more  <u>tags</u>.
       You  may  refer to any item by its id, and may refer to any group of items by a common tag; you can move,
       delete, or change groups of items using these tags, and you can <u>bind</u> actions to  tags.   For  a  properly
       designed (often structured) <b>Canvas</b>, you can specify powerful actions quite simply.

       In  the  example  below,  actions  are  bound  to  circles  (single click) and blue items (double-click);
       obviously, this can be extended to any tag or group of tags.

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
           use Tk;
           use strict;

           # Create B&lt;MainWindow&gt; and canvas
           my $mw = MainWindow-&gt;new;
           my $canvas = $mw-&gt;Canvas;
           $canvas-&gt;pack(-expand =&gt; 1, -fill =&gt; 'both');

           # Create various items
           create_item($canvas, 1, 1, 'circle', 'blue', 'Jane');
           create_item($canvas, 4, 4, 'circle', 'red', 'Peter');
           create_item($canvas, 4, 1, 'square', 'blue', 'James');
           create_item($canvas, 1, 4, 'square', 'red', 'Patricia');

           # Single-clicking with left on a 'circle' item invokes a procedure
           $canvas-&gt;bind('circle', '&lt;1&gt;' =&gt; sub {handle_circle($canvas)});
           # Double-clicking with left on a 'blue' item invokes a procedure
           $canvas-&gt;bind('blue', '&lt;Double-1&gt;' =&gt; sub {handle_blue($canvas)});
           MainLoop;

           # Create an item; use parameters as tags (this is not a default!)
           sub create_item {
               my ($can, $x, $y, $form, $color, $name) = @_;

               my $x2 = $x + 1;
               my $y2 = $y + 1;
               my $kind;
               $kind = 'oval' if ($form eq 'circle');
               $kind = 'rectangle' if ($form eq 'square');
               $can-&gt;create(
                   ($kind, "$x" . 'c', "$y" . 'c',
                   "$x2" . 'c', "$y2" . 'c'),
                   -tags =&gt; [$form, $color, $name],
                   -fill =&gt; $color);
           }

           # This gets the real name (not current, blue/red, square/circle)
           # Note: you'll want to return a list in realistic situations...
           sub get_name {
               my ($can) = @_;
               my $item = $can-&gt;find('withtag', 'current');
               my @taglist = $can-&gt;gettags($item);
               my $name;
               foreach (@taglist) {
                   next if ($_ eq 'current');
                   next if ($_ eq 'red' or $_ eq 'blue');
                   next if ($_ eq 'square' or $_ eq 'circle');
                   $name = $_;
                   last;
               }
               return $name;
           }

           sub handle_circle {
               my ($can) = @_;
               my $name = get_name($can);
               print "Action on circle $name...\n";
           }

           sub handle_blue {
               my ($can) = @_;
               my $name = get_name($can);
               print "Action on blue item $name...\n";
           }

</pre><h4><b>Perl/Tk</b> <b>and</b> <b>Unicode</b></h4><pre>
       Perl/Tk follows Perl's model of handling Unicode. That  is,  if  a  string  is  correctly  flagged  as  a
       "character"  string  in  the  sense  like  described  in  "TERMINOLOGY" in Encode, then Perl/Tk will very
       probably display and handle this string correctly.

       Note that every variable which is passed somehow into a Perl/Tk method will be implicitely  changed  into
       an internally utf8-flagged variable.  Semantically nothing changes, as the series of codepoints stays the
       same,  but  things  will  change when variables with high-bit iso-8859-1 characters will be passed to the
       "outer" world. In this case you have to explicitly mark the encoding of your output stream if  using  IO,
       or encode the variables using Encode for other style of communication.

       This is the theory, now some examples.

       If you use non-iso-8859-1 characters in the source code, then use either the "use utf8;" or "use encoding
       '<u>encodingname</u>'" pragma:

            use utf8;
            use Tk;
            my $x = "some characters using utf8 encoding";
            tkinit-&gt;Label(-text =&gt; $x)-&gt;pack;
            MainLoop;

       For  data  that  comes  from  a  file  you  have  to specify the encoding unless it's encoded as ascii or
       iso-8559-1:

            use Tk;
            open my $FH, "&lt;:encoding(utf-8)", "filename" or die $!;
            # or for utf-16 data: open my $FH, "&lt;:encoding(utf-16)", "filename" or die $!;
            my $data = &lt;$FH&gt;;
            tkinit-&gt;Label(-text =&gt; $data)-&gt;pack;
            MainLoop;

       Likewise, the encoding must be specified for all data which is read from Tk widgets  and  that  shall  be
       output into a file. For the output, the encoding should be always specified, even if it is iso-8859-1:

            use Tk;
            $mw = tkinit;
            $mw-&gt;Entry(-textvariable =&gt; \$input)-&gt;pack;
            $mw-&gt;Button(
                -text =&gt; "Write to file",
                -command =&gt; sub {
                    open my $FH, "&gt;:encoding(iso-8859-1)", "filename" or die $!;
                    print $FH $input;
                },
            )-&gt;pack;
            MainLoop;

       Note  that  Tk  is  Unicode-capable.  So  you need to be prepared that the user has the appropriate input
       methods activated to enter non-ascii characters. If an output encoding is used which does not  cover  the
       whole of Unicode codepoints then a warning will be issued when writing the file, like this:

           "\x{20ac}" does not map to iso-8859-1 at /usr/local/lib/perl5/site_perl/5.8.8/mach/Tk.pm line 250.

       Also, the same hexadecimal notation will be used as replacements for the unhandled characters.

       Handling encoding in I/O is pretty simple using the "encoding" PerlIO layer, as described above. In other
       cases, such as when dealing with databases, encoding the data usually has to be done manually, unless the
       database driver has some means for automatically do this for you.  So when working with a MySQL database,
       one could use:

            use Tk;
            use DBI;
            use Encode qw(encode);
            $mw = tkinit;
            $mw-&gt;Entry(-textvariable =&gt; \$input)-&gt;pack;
            $mw-&gt;Button(
                -text =&gt; "Write to database",
                -command =&gt; sub {
                    my $dbh = DBI-&gt;connect("dbi:mysql:test", "root", "") or die;
                    my $encoded_input = encode("iso-8859-1", $input);
                    $dbh-&gt;do("INSERT INTO testtable VALUES (?)", undef, $encoded_input) or die;
                },
            )-&gt;pack;
            MainLoop;

       Unfortunately,  there  are  still  places in Perl ignorant of Unicode. One of these places are filenames.
       Consequently, the file selectors in Perl/Tk do not handle encoding of filenames properly. Currently  they
       suppose  that  filenames  are  in  iso-8859-1  encoding,  at least on Unix systems. As soon as Perl has a
       concept of filename encodings, then Perl/Tk will also implement such schemes.

perl v5.40.1                                       2025-04-13                                     <u><a href="../man3pm/UserGuide.3pm.html">UserGuide</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>