<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>application - Generic OTP application functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       application - Generic OTP application functions

</pre><h4><b>DESCRIPTION</b></h4><pre>
       In OTP, <u>application</u> denotes a component implementing some specific functionality, that can be started and
       stopped  as  a  unit,  and  that  can  be reused in other systems. This module interacts with <u>application</u>
       <u>controller</u>, a process started at  every  Erlang  runtime  system.  This  module  contains  functions  for
       controlling  applications  (for  example,  starting  and  stopping applications), and functions to access
       information about applications (for example, configuration parameters).

       An application is defined by an <u>application</u> <u>specification</u>. The specification is normally  located  in  an
       <u>application</u>  <u>resource</u>  <u>file</u> named <u>Application.app</u>, where <u>Application</u> is the application name. For details
       about the application specification, see <u><a href="../man5/app.5.html">app</a>(5)</u>.

       This module can also be viewed as a behaviour for an application implemented according to the OTP  design
       principles as a supervision tree. The definition of how to start and stop the tree is to be located in an
       <u>application</u> <u>callback</u> <u>module</u>, exporting a predefined set of functions.

       For details about applications and behaviours, see OTP Design Principles.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>start_type()</b> =
           normal |
           {takeover, Node :: node()} |
           {failover, Node :: node()}

       <b>restart_type()</b> = permanent | transient | temporary

       <b>tuple_of(T)</b>

              A tuple where the elements are of type <u>T</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>ensure_all_started(Application)</b> <b>-&gt;</b> <b>{ok,</b> <b>Started}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>ensure_all_started(Application,</b> <b>Type)</b> <b>-&gt;</b>
                             {ok, Started} | {error, Reason}

              Types:

                 Application = atom()
                 Type = restart_type()
                 Started = [atom()]
                 Reason = term()

              Equivalent  to  calling  <u>start/1,2</u>  repeatedly on all dependencies that are not yet started for an
              application. Optional dependencies will also be loaded and started if they are available.

              Returns <u>{ok,</u> <u>AppNames}</u> for a successful start or for an already  started  application  (which  is,
              however, omitted from the <u>AppNames</u> list).

              The  function  reports  <u>{error,</u>  <u>{AppName,Reason}}</u> for errors, where <u>Reason</u> is any possible reason
              returned by <u>start/1,2</u> when starting a specific dependency.

              If an error occurs, the applications started by the function are  stopped  to  bring  the  set  of
              running applications back to its initial state.

       <b>ensure_started(Application)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>ensure_started(Application,</b> <b>Type)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Application = atom()
                 Type = restart_type()
                 Reason = term()

              Equivalent to <u>start/1,2</u> except it returns <u>ok</u> for already started applications.

       <b>get_all_env()</b> <b>-&gt;</b> <b>Env</b>

       <b>get_all_env(Application)</b> <b>-&gt;</b> <b>Env</b>

              Types:

                 Application = atom()
                 Env = [{Par :: atom(), Val :: term()}]

              Returns the configuration parameters and their values for <u>Application</u>. If the argument is omitted,
              it defaults to the application of the calling process.

              If  the  specified application is not loaded, or if the process executing the call does not belong
              to any application, the function returns <u>[]</u>.

       <b>get_all_key()</b> <b>-&gt;</b> <b>[]</b> <b>|</b> <b>{ok,</b> <b>Keys}</b>

       <b>get_all_key(Application)</b> <b>-&gt;</b> <b>undefined</b> <b>|</b> <b>Keys</b>

              Types:

                 Application = atom()
                 Keys = {ok, [{Key :: atom(), Val :: term()}, ...]}

              Returns the application specification keys and their values for <u>Application</u>. If  the  argument  is
              omitted, it defaults to the application of the calling process.

              If  the  specified  application  is  not  loaded,  the  function returns <u>undefined</u>. If the process
              executing the call does not belong to any application, the function returns <u>[]</u>.

       <b>get_application()</b> <b>-&gt;</b> <b>undefined</b> <b>|</b> <b>{ok,</b> <b>Application}</b>

       <b>get_application(PidOrModule)</b> <b>-&gt;</b> <b>undefined</b> <b>|</b> <b>{ok,</b> <b>Application}</b>

              Types:

                 PidOrModule = (Pid :: pid()) | (Module :: module())
                 Application = atom()

              Returns the name of the application to which  the  process  <u>Pid</u>  or  the  module  <u>Module</u>  belongs.
              Providing no argument is the same as calling <u>get_application(self())</u>.

              If the specified process does not belong to any application, or if the specified process or module
              does not exist, the function returns <u>undefined</u>.

       <b>get_env(Par)</b> <b>-&gt;</b> <b>undefined</b> <b>|</b> <b>{ok,</b> <b>Val}</b>

       <b>get_env(Application,</b> <b>Par)</b> <b>-&gt;</b> <b>undefined</b> <b>|</b> <b>{ok,</b> <b>Val}</b>

              Types:

                 Application = Par = atom()
                 Val = term()

              Returns  the  value of configuration parameter <u>Par</u> for <u>Application</u>. If the application argument is
              omitted, it defaults to the application of the calling process.

              Returns <u>undefined</u> if any of the following applies:

                * The specified application is not loaded.

                * The configuration parameter does not exist.

                * The process executing the call does not belong to any application.

       <b>get_env(Application,</b> <b>Par,</b> <b>Def)</b> <b>-&gt;</b> <b>Val</b>

              Types:

                 Application = Par = atom()
                 Def = Val = term()

              Works like <u>get_env/2</u> but returns value <u>Def</u> when configuration parameter <u>Par</u> does not exist.

       <b>get_key(Key)</b> <b>-&gt;</b> <b>undefined</b> <b>|</b> <b>{ok,</b> <b>Val}</b>

       <b>get_key(Application,</b> <b>Key)</b> <b>-&gt;</b> <b>undefined</b> <b>|</b> <b>{ok,</b> <b>Val}</b>

              Types:

                 Application = Key = atom()
                 Val = term()

              Returns the value of the application specification key <u>Key</u> for  <u>Application</u>.  If  the  application
              argument is omitted, it defaults to the application of the calling process.

              Returns <u>undefined</u> if any of the following applies:

                * The specified application is not loaded.

                * The specification key does not exist.

                * The process executing the call does not belong to any application.

       <b>load(AppDescr)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>load(AppDescr,</b> <b>Distributed)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 AppDescr = Application | (AppSpec :: application_spec())
                 Application = atom()
                 Distributed =
                     {Application, Nodes} | {Application, Time, Nodes} | default
                 Nodes = [node() | tuple_of(node())]
                 Time = integer() &gt;= 1
                 Reason = term()
                 <b>application_spec()</b> =
                     {application,
                      Application :: atom(),
                      AppSpecKeys :: [application_opt()]}
                 <b>application_opt()</b> =
                     {description, Description :: string()} |
                     {vsn, Vsn :: string()} |
                     {id, Id :: string()} |
                     {modules, [Module :: module()]} |
                     {registered, Names :: [Name :: atom()]} |
                     {applications, [Application :: atom()]} |
                     {included_applications, [Application :: atom()]} |
                     {env, [{Par :: atom(), Val :: term()}]} |
                     {start_phases,
                      [{Phase :: atom(), PhaseArgs :: term()}] | undefined} |
                     {maxT, MaxT :: timeout()} |
                     {maxP, MaxP :: integer() &gt;= 1 | infinity} |
                     {mod, Start :: {Module :: module(), StartArgs :: term()}}

              Loads  the  application  specification for an application into the application controller. It also
              loads the application specifications for any included applications. Notice that the function  does
              not load the Erlang object code.

              The application can be specified by its name <u>Application</u>. In this case, the application controller
              searches  the  code  path  for  the  application  resource  file  <u>Application.app</u>  and  loads  the
              specification it contains.

              The application specification can also be specified directly as a tuple <u>AppSpec</u>, having the format
              and contents as described in <u><a href="../man5/app.5.html">app</a>(5)</u>.

              If <u>Distributed</u> <u>==</u> <u>{Application,[Time,]Nodes}</u>, the application becomes  distributed.  The  argument
              overrides  the  value  for  the  application  in  the  Kernel configuration parameter <u>distributed</u>.
              <u>Application</u> must be the application name (same as in the first argument). If a  node  crashes  and
              <u>Time</u>  is  specified,  the  application controller waits for <u>Time</u> milliseconds before attempting to
              restart the application on another node. If <u>Time</u> is not  specified,  it  defaults  to  <u>0</u>  and  the
              application is restarted immediately.

              <u>Nodes</u>  is a list of node names where the application can run, in priority from left to right. Node
              names can be grouped using tuples to indicate that they have the same priority.

              <u>Example:</u>

              Nodes = [cp1@cave, {cp2@cave, cp3@cave}]

              This means that the application is preferably to be started at <u>cp1@cave</u>. If <u>cp1@cave</u> is down,  the
              application is to be started at <u>cp2@cave</u> or <u>cp3@cave</u>.

              If  <u>Distributed</u>  <u>==</u>  <u>default</u>,  the value for the application in the Kernel configuration parameter
              <u>distributed</u> is used.

       <b>loaded_applications()</b> <b>-&gt;</b> <b>[{Application,</b> <b>Description,</b> <b>Vsn}]</b>

              Types:

                 Application = atom()
                 Description = Vsn = string()

              Returns a list with information about the  applications,  and  included  applications,  which  are
              loaded  using <u>load/1,2</u>. <u>Application</u> is the application name. <u>Description</u> and <u>Vsn</u> are the values of
              their <u>description</u> and <u>vsn</u> application specification keys, respectively.

       <b>set_env(Config)</b> <b>-&gt;</b> <b>ok</b>

       <b>set_env(Config,</b> <b>Opts)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Config = [{Application, Env}]
                 Application = atom()
                 Env = [{Par :: atom(), Val :: term()}]
                 Opts = [{timeout, timeout()} | {persistent, boolean()}]

              Sets the configuration <u>Config</u> for multiple applications. It is equivalent to calling <u>set_env/4</u>  on
              each  application  individually, except it is more efficient. The given <u>Config</u> is validated before
              the configuration is set.

              <u>set_env/2</u> uses the standard <u>gen_server</u> time-out value (5000 ms). Option <u>timeout</u> can  be  specified
              if  another  time-out value is useful, for example, in situations where the application controller
              is heavily loaded.

              Option <u>persistent</u> can be set to <u>true</u> to guarantee that  parameters  set  with  <u>set_env/2</u>  are  not
              overridden  by  those defined in the application resource file on load. This means that persistent
              values will stick after the application is loaded and also on application reload.

              If an application is given more than once or if an application has the same key  given  more  than
              once,  the  behaviour  is  undefined  and a warning message will be logged. In future releases, an
              error will be raised.

              <u>set_env/1</u> is equivalent to <u>set_env(Config,</u> <u>[])</u>.

          <b>Warning:</b>
              Use this function only if you know what you are doing, that is, on your own  applications.  It  is
              very  application-dependent  and configuration parameter-dependent when and how often the value is
              read by the application. Careless use of this  function  can  put  the  application  in  a  weird,
              inconsistent, and malfunctioning state.

       <b>permit(Application,</b> <b>Permission)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Application = atom()
                 Permission = boolean()
                 Reason = term()

              Changes  the permission for <u>Application</u> to run at the current node. The application must be loaded
              using <u>load/1,2</u> for the function to have effect.

              If the permission of a loaded, but not started, application is set to <u>false</u>, <u>start</u> returns <u>ok</u>  but
              the application is not started until the permission is set to <u>true</u>.

              If  the  permission  of  a running application is set to <u>false</u>, the application is stopped. If the
              permission later is set to <u>true</u>, it is restarted.

              If the application is distributed, setting the permission to <u>false</u> means that the application will
              be started at, or moved to, another node according to how  its  distribution  is  configured  (see
              <u>load/2</u>).

              The  function  does not return until the application is started, stopped, or successfully moved to
              another node. However, in some cases where permission is set to <u>true</u>, the function returns <u>ok</u> even
              though the application is not started. This is true when an application cannot  start  because  of
              dependencies to other applications that are not yet started. When they are started, <u>Application</u> is
              started as well.

              By  default,  all applications are loaded with permission <u>true</u> on all nodes. The permission can be
              configured using the Kernel configuration parameter <u>permissions</u>.

       <b>set_env(Application,</b> <b>Par,</b> <b>Val)</b> <b>-&gt;</b> <b>ok</b>

       <b>set_env(Application,</b> <b>Par,</b> <b>Val,</b> <b>Opts)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Application = Par = atom()
                 Val = term()
                 Opts = [{timeout, timeout()} | {persistent, boolean()}]

              Sets the value of configuration parameter <u>Par</u> for <u>Application</u>.

              <u>set_env/4</u> uses the standard <u>gen_server</u> time-out value (5000 ms). Option <u>timeout</u> can  be  specified
              if  another  time-out value is useful, for example, in situations where the application controller
              is heavily loaded.

              If <u>set_env/4</u> is called before the  application  is  loaded,  the  application  environment  values
              specified  in  file  <u>Application.app</u>  override  the  ones  previously  set.  This is also true for
              application reloads.

              Option <u>persistent</u> can be set to <u>true</u> to guarantee that  parameters  set  with  <u>set_env/4</u>  are  not
              overridden  by  those defined in the application resource file on load. This means that persistent
              values will stick after the application is loaded and also on application reload.

          <b>Warning:</b>
              Use this function only if you know what you are doing, that is, on your own  applications.  It  is
              very  application-dependent  and configuration parameter-dependent when and how often the value is
              read by the application. Careless use of this  function  can  put  the  application  in  a  weird,
              inconsistent, and malfunctioning state.

       <b>start(Application)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>start(Application,</b> <b>Type)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Application = atom()
                 Type = restart_type()
                 Reason = term()

              Starts  <u>Application</u>.  If it is not loaded, the application controller first loads it using <u>load/1</u>.
              It ensures that any included applications are loaded, but does not start them. That is assumed  to
              be taken care of in the code for <u>Application</u>.

              The  application controller checks the value of the application specification key <u>applications</u>, to
              ensure that all applications needed to be started before  this  application  are  running.  If  an
              application is missing and the application is not marked as optional, <u>{error,{not_started,App}}</u> is
              returned, where <u>App</u> is the name of the missing application. Note this function makes no attempt to
              start   any   of   the   applications   listed  in  <u>applications</u>,  not  even  optional  ones.  See
              <u>ensure_all_started/1,2</u> for recursively starting the current application and its dependencies.

              Once validated, the application controller then creates an <u>application</u> <u>master</u> for the application.
              The application master becomes the group leader of all the processes in the  application.  I/O  is
              forwarded  to  the  previous  group  leader, though, this is just a way to identify processes that
              belong to the application. Used for example to find itself from any process, or, reciprocally,  to
              kill them all when it terminates.

              The  application  master  starts  the  application  by  calling  the application callback function
              <u>Module:start/2</u> as defined by the application specification key <u>mod</u>.

              Argument <u>Type</u> specifies the type of the application. If omitted, it defaults to <u>temporary</u>.

                * If a permanent application terminates, all other applications and the entire Erlang  node  are
                  also terminated.

                * If a transient application terminates:

                  * with <u>Reason</u> <u>==</u> <u>normal</u>, this is reported but no other applications are terminated.

                  * abnormally, all other applications and the entire Erlang node are also terminated.

                * If  a  temporary  application  terminates,  this  is  reported  but  no other applications are
                  terminated.

              Notice that an application can always be stopped explicitly by calling <u>stop/1</u>. Regardless  of  the
              type of the application, no other applications are affected.

              Notice  also  that  the transient type is of little practical use, because when a supervision tree
              terminates, the reason is set to <u>shutdown</u>, not <u>normal</u>.

       <b>start_type()</b> <b>-&gt;</b> <b>StartType</b> <b>|</b> <b>undefined</b> <b>|</b> <b>local</b>

              Types:

                 StartType = start_type()

              This function is intended to be called  by  a  process  belonging  to  an  application,  when  the
              application is started, to determine the start type, which is <u>StartType</u> or <u>local</u>.

              For a description of <u>StartType</u>, see <u>Module:start/2</u>.

              <u>local</u>  is  returned  if  only  parts of the application are restarted (by a supervisor), or if the
              function is called outside a startup.

              If the process executing the call does  not  belong  to  any  application,  the  function  returns
              <u>undefined</u>.

       <b>stop(Application)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Application = atom()
                 Reason = term()

              Stops <u>Application</u>. The application master calls <u>Module:prep_stop/1</u>, if such a function is defined,
              and  then  tells  the  top supervisor of the application to shut down (see <u><a href="../man3erl/supervisor.3erl.html">supervisor</a>(3erl)</u>). This
              means that the entire supervision tree, including included applications, is terminated in reversed
              start order. After the shutdown,  the  application  master  calls  <u>Module:stop/1</u>.  <u>Module</u>  is  the
              callback module as defined by the application specification key <u>mod</u>.

              Last,  the application master terminates. Notice that all processes with the application master as
              group leader, that is, processes spawned from a process belonging to  the  application,  are  also
              terminated.

              When stopped, the application is still loaded.

              To  stop  a distributed application, <u>stop/1</u> must be called on all nodes where it can execute (that
              is, on all nodes where it has been started). The call to <u>stop/1</u> on the node where the  application
              currently  executes  stops its execution. The application is not moved between nodes, as <u>stop/1</u> is
              called on the node where the application currently executes before <u>stop/1</u> is called on  the  other
              nodes.

       <b>takeover(Application,</b> <b>Type)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Application = atom()
                 Type = restart_type()
                 Reason = term()

              Takes  over  the  distributed application <u>Application</u>, which executes at another node <u>Node</u>. At the
              current node, the application is  restarted  by  calling  <u>Module:start({takeover,Node},StartArgs)</u>.
              <u>Module</u>  and  <u>StartArgs</u> are retrieved from the loaded application specification. The application at
              the other node is not stopped until the startup is completed, that is, when <u>Module:start/2</u> and any
              calls to <u>Module:start_phase/3</u> have returned.

              Thus, two instances of the application run simultaneously during the takeover, so that data can be
              transferred from the old to the new instance. If this is not an acceptable behavior, parts of  the
              old instance can be shut down when the new instance is started. However, the application cannot be
              stopped entirely, at least the top supervisor must remain alive.

              For a description of <u>Type</u>, see <u>start/1,2</u>.

       <b>unload(Application)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Application = atom()
                 Reason = term()

              Unloads  the  application  specification  for <u>Application</u> from the application controller. It also
              unloads the application specifications for any included applications.  Notice  that  the  function
              does not purge the Erlang object code.

       <b>unset_env(Application,</b> <b>Par)</b> <b>-&gt;</b> <b>ok</b>

       <b>unset_env(Application,</b> <b>Par,</b> <b>Opts)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Application = Par = atom()
                 Opts = [{timeout, timeout()} | {persistent, boolean()}]

              Removes the configuration parameter <u>Par</u> and its value for <u>Application</u>.

              <u>unset_env/2</u> uses the standard <u>gen_server</u> time-out value (5000 ms). Option <u>timeout</u> can be specified
              if  another  time-out value is useful, for example, in situations where the application controller
              is heavily loaded.

              <u>unset_env/3</u> also allows the persistent option to be passed (see <u>set_env/4</u>).

          <b>Warning:</b>
              Use this function only if you know what you are doing, that is, on your own  applications.  It  is
              very  application-dependent  and configuration parameter-dependent when and how often the value is
              read by the application. Careless use of this  function  can  put  the  application  in  a  weird,
              inconsistent, and malfunctioning state.

       <b>which_applications()</b> <b>-&gt;</b> <b>[{Application,</b> <b>Description,</b> <b>Vsn}]</b>

       <b>which_applications(Timeout)</b> <b>-&gt;</b> <b>[{Application,</b> <b>Description,</b> <b>Vsn}]</b>

              Types:

                 Timeout = timeout()
                 Application = atom()
                 Description = Vsn = string()

              Returns  a list with information about the applications that are currently running. <u>Application</u> is
              the application name. <u>Description</u> and <u>Vsn</u> are the values of their <u>description</u> and <u>vsn</u>  application
              specification keys, respectively.

              <u>which_applications/0</u> uses the standard <u>gen_server</u> time-out value (5000 ms). A <u>Timeout</u> argument can
              be specified if another time-out value is useful, for example, in situations where the application
              controller is heavily loaded.

</pre><h4><b>CALLBACK</b> <b>MODULE</b></h4><pre>
       The following functions are to be exported from an <u>application</u> callback module.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>Module:start(StartType,</b> <b>StartArgs)</b> <b>-&gt;</b> <b>{ok,</b> <b>Pid}</b> <b>|</b> <b>{ok,</b> <b>Pid,</b> <b>State}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 StartType = <u>start_type()</u>
                 StartArgs = term()
                 Pid = pid()
                 State = term()

              This  function  is  called whenever an application is started using <u>start/1,2</u>, and is to start the
              processes of the application. If the  application  is  structured  according  to  the  OTP  design
              principles as a supervision tree, this means starting the top supervisor of the tree.

              <u>StartType</u> defines the type of start:

                * <u>normal</u> if it is a normal startup.

                * <u>normal</u>  also  if  the  application is distributed and started at the current node because of a
                  failover from another node, and the application specification key <u>start_phases</u> <u>==</u> <u>undefined</u>.

                * <u>{takeover,Node}</u> if the application is distributed and started at the current node because of a
                  takeover from <u>Node</u>, either because <u>takeover/2</u> has been called or because the current node  has
                  higher priority than <u>Node</u>.

                * <u>{failover,Node}</u> if the application is distributed and started at the current node because of a
                  failover from <u>Node</u>, and the application specification key <u>start_phases</u> <u>/=</u> <u>undefined</u>.

              <u>StartArgs</u> is the <u>StartArgs</u> argument defined by the application specification key <u>mod</u>.

              The  function  is to return <u>{ok,Pid}</u> or <u>{ok,Pid,State}</u>, where <u>Pid</u> is the pid of the top supervisor
              and <u>State</u> is any term. If omitted, <u>State</u> defaults to <u>[]</u>. If  the  application  is  stopped  later,
              <u>State</u> is passed to <u>Module:prep_stop/1</u>.

       <b>Module:start_phase(Phase,</b> <b>StartType,</b> <b>PhaseArgs)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Phase = atom()
                 StartType = <u>start_type()</u>
                 PhaseArgs = term()
                 Pid = pid()
                 State = state()

              Starts an application with included applications, when synchronization is needed between processes
              in the different applications during startup.

              The   start   phases   are   defined   by   the  application  specification  key  <u>start_phases</u>  <u>==</u>
              <u>[{Phase,PhaseArgs}]</u>. For included applications, the set of phases must be a subset of the  set  of
              phases defined for the including application.

              The  function  is  called  for  each  start phase (as defined for the primary application) for the
              primary application and all included applications, for which the start phase is defined.

              For a description of <u>StartType</u>, see <u>Module:start/2</u>.

       <b>Module:prep_stop(State)</b> <b>-&gt;</b> <b>NewState</b>

              Types:

                 State = NewState = term()

              This function is called when an application is about to  be  stopped,  before  shutting  down  the
              processes of the application.

              <u>State</u>  is  the state returned from <u>Module:start/2</u>, or <u>[]</u> if no state was returned. <u>NewState</u> is any
              term and is passed to <u>Module:stop/1</u>.

              The function  is  optional.  If  it  is  not  defined,  the  processes  are  terminated  and  then
              <u>Module:stop(State)</u> is called.

       <b>Module:stop(State)</b>

              Types:

                 State = term()

              This  function is called whenever an application has stopped. It is intended to be the opposite of
              <u>Module:start/2</u> and is to do any necessary cleaning up. The return value is ignored.

              <u>State</u> is the return value of <u>Module:prep_stop/1</u>, if such a function  exists.  Otherwise  <u>State</u>  is
              taken from the return value of <u>Module:start/2</u>.

       <b>Module:config_change(Changed,</b> <b>New,</b> <b>Removed)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Changed = [{Par,Val}]
                 New = [{Par,Val}]
                 Removed = [Par]
                  Par = atom()
                  Val = term()

              This  function  is  called  by  an  application  after  a  code  replacement, if the configuration
              parameters have changed.

              <u>Changed</u> is a list of parameter-value tuples including all configuration  parameters  with  changed
              values.

              <u>New</u> is a list of parameter-value tuples including all added configuration parameters.

              <u>Removed</u> is a list of all removed parameters.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       OTP Design Principles, <a href="../man7/kernel.7.html">kernel</a>(7), <a href="../man5/app.5.html">app</a>(5)

Ericsson AB                                        kernel 8.2                                  <u><a href="../man3erl/application.3erl.html">application</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>