<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CLI::Framework::Tutorial - "HOWTO" develop CLIF applications using best practices</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcli-framework-perl">libcli-framework-perl_0.05-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CLI::Framework::Tutorial - "HOWTO" develop CLIF applications using best practices

</pre><h4><b>CLIF</b> <b>DOCUMENTATION</b></h4><pre>
       This is a guide to developing CLIF applications.  It is a supplement to the documentation in
       CLI::Framework, CLI::Framework::Application and CLI::Framework::Command, which have more thorough
       coverage of some finer points.

       It is suggested that new users start by reading this document, then use the other documentation for
       reference as necessary.

</pre><h4><b>INTRODUCTION</b></h4><pre>
       Developers have been reluctantly writing ad-hoc, disposable scripts for too long or struggling to decide
       how not to do so.  There is a better alternative.

       The CLI::Framework documentation enumerates many advantages to using CLIF instead of writing yet-another-
       getopt-based-script.  CLIF comes with a lot of documentation, but don't take that to mean that using CLIF
       is complicated.  CLIF apps with simple needs are very easy to build.  Apps with complex needs are a bit
       more work, but much easier to build (and far easier to test and maintain) than doing that work from
       scratch.

       This document will first demonstrate a very simple CLIF application.  Next, a complete application will
       be shown to demonstrate more advanced CLIF features.

       Think of a typical command-line script.  It needs to parse command-line options and arguments, check that
       any required external resources (files, databases, etc.) are available, fail nicely if something is
       missing or inconsistent, then do something application-specific that depends on the options, arguments,
       and external resources.

       What happens when new scripts are created to do something similar?  All too often, they end up with
       different option names for conceptually the same purpose.  It is common for functionality needed by
       several scripts to be duplicated in each similar script.  This rapidly gets out of hand, becoming a
       maintenance frustration.  Your team members are not "on the same page" and new people learning your tools
       must have lengthy, verbal, one-on-one code tours.

       Instead, a set of related scripts could be combined into a CLIF application.  Consistent naming
       conventions and sharing of common code is naturally encouraged.  The commands are easy to test.  New
       commands can be added with ease.

</pre><h4><b>FROM</b> <b>P.O.S.</b> <b>TO</b> <b>CLIF</b> <b>IN</b> <b>A</b> <b>FEW</b> <b>EASY</b> <b>STEPS</b></h4><pre>
       A "P.O.S." is a "Plain Old Script."  This section shows you how to reform an old P.O.S., creating a shiny
       new CLIF application!

       Please see working code for this example included with the "CLI::Framework" distribution
       (<u>examples/demo-simple.pl</u>).

       This example demonstrates the following features:

       •   inline application definition

       •   basics (app, commands, command options and args)

       •   the relationship between plain scripts and CLIF applications (including how to convert between them)

       To  understand  CLIF commands, imagine converting a legacy script to a CLIF application.  First, create a
       Perl class that inherits from CLI::Framework::Command.  Place the main body of the script  in  a  "run()"
       method.  Add the functions that the script defines, if any.

           # Your Command subclass...
           package Converted::Script::Command::LegacyScript;
           use base qw( CLI::Framework::Command );

           # main body of former script goes inside run():
           sub run { ... }

       Next,  create  a  Perl  class  (creating  a separate package file for the class is totally optional) that
       inherits from CLI::Framework::Application (or you can use "CLI::Framework" as a shorthand) and  define  a
       method, "command_map()", that links command names with classes that implement the commands:

           # Your Application class...
           package Converted::Script;
           use base qw( CLI::Framework );

           sub command_map {
               'legacy-script' =&gt; 'Converted::Script::Command::LegacyScript',
           }

       The  code  that  provides a friendly usage message (if the legacy script provided one) can be replaced by
       defining the "usage_text" method:

           sub usage_text {
               qq{
               $0 [--verbose|v] [--help|h]: how to use this application...
               }
           }

       Back in your Command subclass, the option/argument  processing  code  will  be  replaced  with  a  method
       defining  what  options will be recognized (the data structure to be returned is exactly as documented in
       Getopt::Long::Descriptive):

           sub option_spec {
               [ 'help|h'      =&gt; 'show help' ],
               [ 'verbose|v'   =&gt; 'be verbose' ],
           }

       ...and that's all it takes to convert a simple script to a CLIF app.  This contrived example demonstrates
       the mechanics, but let me point out a few advantages (see DESIGN GOALS AND FEATURES for the long list):

       Clear division of responsibilities
           Using packages, subroutines, and separate files (if desired), CLIF apps follow established convention
           and provide a new pattern for creating tools.

       Easy to test
           Now that functional units of code are subroutines in packages,  you  can  unit  test  each  component
           independently.

       Easy to maintain
           Instead  of  puzzling  over  a  several-thousand-line  script, maintaining a CLIF application is like
           maintaining any other well-engineered application code.

       Easy to extend
           Related tools frequently occur in groups.  Instead of  awkwardly  forcing  loosely-related  behaviors
           into the same script, CLIF makes it easy to add additional commands in a modular way.

</pre><h4><b>WHEN</b> <b>NOT</b> <b>TO</b> <b>USE</b> <b>CLIF</b></h4><pre>
       CLIF could be used for the simplest of needs, but it may be overkill in very simple situations.

       You  may  want  to  avoid  CLIF  for  very  basic  scripts that have a single behavior and are completely
       independent from other such tools.  However, if there's a chance that the scripts might  grow  to  become
       more complex or if you would simply like a pattern to follow, it may still be worth considering.

</pre><h4><b>CONCEPTS</b> <b>AND</b> <b>DEFINITIONS</b></h4><pre>
       See CONCEPTS AND DEFINITIONS.

</pre><h4><b>UNDERSTANDING</b> <b>THE</b> <b>APPLICATION</b> <b>RUN</b> <b>SEQUENCE</b></h4><pre>
       See APPLICATION RUN SEQUENCE.

       <b>Understanding</b> <b>this</b> <b>is</b> <b>important</b> <b>to</b> <b>building</b> <b>more</b> <b>complex</b> <b>apps</b>.  You need, at the least, to understand how
       CLIF  differentiates  between  options  and arguments that are meant for the application itself and those
       options and arguments that are meant for individual commands.

       The following examples demonstrate the alternative command request forms.  Note that in  all  cases,  any
       number  of  (sub)command  options  and  arguments can be passed (these examples show only one of each for
       brevity).

       FORM #1 (without subcommands) -- command requests that involve NO subcommands take the following form:

           &lt;app&gt; [--app-opt] &lt;cmd&gt; [--cmd-opt] [cmd-arg] ...

       (notice how the position of options and arguments determines whether they are meant for  the  application
       as a whole or for the specific command).

       FORM #2 (with subcommands) -- Command requests that involve A SINGLE subcommand take this form:

           &lt;app&gt; [--app-opt] &lt;cmd&gt; [--cmd-opt] &lt;subcmd&gt; [--subcmd-opt] [subcmd-arg] ...

       Command requests that involve MULTIPLE subcommands follow the same form:

           &lt;app&gt; [--app-opt] &lt;cmd&gt; [--cmd-opt] &lt;subcmd1&gt; [--subcmd1-opt] &lt;subcmd2&gt; [--subcmd2-opt] [subcmd2-arg] ...

       (notice  that  the  final  arguments  apply  to  the final subcommand.  The only command that can receive
       arguments is the final subcommand).

</pre><h4><b>A</b> <b>MORE</b> <b>INVOLVED</b> <b>EXAMPLE</b></h4><pre>
       Please  see  working  code  for  this   example   included   with   the   "CLI::Framework"   distribution
       (<u>examples/queue</u>).

       The next example demonstrates the following features:

       •   inline application definition

       •   basics (app, commands, command options and args)

       •   subcommands

       •   validation of application and command arguments

       •   interactive mode and non-interactive mode

       Suppose  we  need to write a command-line application that provides an interface to a queue.  Strings can
       be added to or removed from the queue, queue contents can be displayed, and queue "properties" can be set
       to restrict the contents added to the queue.  The interface should work interactively.

       The following usage demonstrates the desired behavior:

           [somebody@somewhere]$ examples/queue --qin=/tmp/qfile --qout=/tmp/qfile console

           # ---- interactive mode ----
           1) dequeue
           2) cmd-list
           3) enqueue
           4) print
           5) alias
           6) property

           &gt; help enqueue

           enqueue [--tag=&lt;tag1&gt; [--tag=&lt;tag2&gt; [...] ] ] &lt;item1&gt; [&lt;item2&gt; ...  &lt;itemN&gt;]: add item(s) to queue

           &gt; enqueue --tag=x "something"

           &gt; property set --evens

           &gt; e 1 21 514 937 18

       The working example in <u>examples/queue</u> accomplishes this goal in a single  inline  application  containing
       the Application class and multiple Command Classes.

       This  application  is created in fundamentally the same way as the simple one presented earlier.  It uses
       more commands, more Application class/Command Class hooks, and subcommands.  The code is much longer  but
       almost all of it is for business logic -- very little additional CLIF-specific code is needed.

       The  example  code  shows  how  various  commands can be managed by an Application subclass.  The code is
       commented thoroughly to explain the various hooks that are available for Application  class  and  Command
       Classes.

       Of course, CLIF applications can always be used in non-interactive mode:

           # ---- non-interactive mode ----
           $ examples/queue --qout=/tmp/qfile enqueue 'first'
           $ examples/queue --qin=/tmp/qfile --qout=/tmp/qfile enqueue --tag=x --tag=y 'second'
           $ examples/queue --qin=/tmp/qfile --qout=/tmp/qfile property list
           $ examples/queue --qin=/tmp/qfile --qout=/tmp/qfile property set --evens
           $ examples/queue --qin=/tmp/qfile --qout=/tmp/qfile property list
           $ examples/queue --qin=/tmp/qfile --qout=/tmp/qfile enqueue 17
           $ examples/queue --qin=/tmp/qfile --qout=/tmp/qfile enqueue 4
           $ examples/queue --qin=/tmp/qfile --qout=/tmp/qfile enqueue 2
           $ examples/queue --qin=/tmp/qfile --qout=/tmp/qfile dequeue
           $ examples/queue --qin=/tmp/qfile --qout=/tmp/qfile dequeue
           $ examples/queue --qin=/tmp/qfile --qout=/tmp/qfile dequeue
           $ examples/queue --qin=/tmp/qfile --qout=/tmp/qfile enqueue 3
           $ examples/queue --qin=/tmp/qfile print

</pre><h4><b>PLANNING</b> <b>A</b> <b>COMPLEX</b> <b>CLIF</b> <b>APPLICATION</b></h4><pre>
       Little  additional thought (beyond that needed for business logic) is required to create a basic CLIF app
       -- the strategy explained in "FROM P.O.S. TO CLIF IN A FEW EASY STEPS" demonstrates how CLIF differs from
       a "Plain Old Script".

       A more sophisticated command line application will benefit from a wider  variety  of  the  features  CLIF
       provides.  The extra features are easy to use, but the additional complexity warrants careful planning.

       After  the  initial  learning curve, applying interface design principles and implementing business rules
       will become the only challenging aspects to developing your CLIF applications.  This is as it  should  be
       --  the framework handles application-independent aspects, leaving you to focus on the unique features of
       your application.

       Here are some considerations:

       Basic interface
           What commands and subcommands should be available?
           What options and arguments will they support?
           What kind of validation should be done on the provided command requests?
           Which built-in commands will be used?
           Will an interactive mode be provided?
           If so, will a custom menu be created?
           Do any commands need to directly access or modify the application itself or the other commands (these
           will be metacommands)?
       High-level code layout
           Which components of the application will be defined in  their  own  package  files?   Which  will  be
           defined inline?

       Separation of concerns using MVC strategy
           How will the model be separated from the rest of the application?  What about the view?

       Data sharing between application and commands
           What  data  will  data  be shared between the application and the commands?  Will this be arranged by
           using the cache, using a Command superclass (a generic  command  class  that  all  of  your  commands
           inherit from), or by some other means?

       Read on for possible answers to some of these questions.

</pre><h4><b>HOW</b> <b>CAN</b> <b>I</b> <b>...?</b></h4><pre>
       This  section  briefly  highlights  how CLIF could be used to support various common goals.  Even if your
       particular situation does not appear here, reading this short section will give you an  understanding  of
       how CLIF could be set up to support novel cases.

   <b>How</b> <b>can</b> <b>I</b> <b>quickly</b> <b>create</b> <b>a</b> <b>very</b> <b>simple</b> <b>application?</b>
       For  a  demonstration  of  how  to  create a very simple CLIF app, see "FROM P.O.S. TO CLIF IN A FEW EASY
       STEPS".  CLIF applications require, at the minimum:

       •   An Application class that  inherits  from  CLI::Framework::Application  (or  "CLI::Framework").   For
           anything useful to happen, it should override the "command_map()" hook and include a new command.

       •   A  Command Class that inherits from CLI::Framework::Command.  It should override the "run()" hook (or
           have a subcommand that overrides "run()").

       •   An Application Script that calls the "run()" method in your application.

       These can all be defined in one file or each class can be placed in a separate file.  Do  whatever  works
       best for your particular needs.

   <b>How</b> <b>can</b> <b>I</b> <b>add</b> <b>an</b> <b>interactive</b> <b>mode</b> <b>to</b> <b>my</b> <b>application?</b>
       The  built-in  console  command can be used to enable your application to run interactively.  To do this,
       simply add the built-in command CLI::Framework::Command::Console to the command_map in  your  Application
       class.

   <b>How</b> <b>can</b> <b>I</b> <b>include</b> <b>logging</b> <b>in</b> <b>my</b> <b>application?</b>
       In  your  Application  class,  define  "init()"  to initialize your logging object and save the resulting
       object in the cache, where the object will be available to your application and command objects.

   <b>How</b> <b>can</b> <b>I</b> <b>include</b> <b>database</b> <b>connectivity</b> <b>in</b> <b>my</b> <b>application?</b>
       In your Application class, define "init()" to connect to your database and save the resulting  object  or
       database  handle  in the cache, where the object/handle will be available to your application and command
       objects.

       Of course, for proper Separation of Concerns, you should not simply store a connected database handle  in
       the  cache  and  use  it directly in your Command classes.  You should instead store an object of another
       class that encapsulates your data model layer code.  An example of this is the model class for  the  demo
       journal application included with CLIF tests: <u>t/lib/My/Journal/Model.pm</u>.

   <b>How</b> <b>can</b> <b>I</b> <b>support</b> <b>an</b> <b>application</b> <b>configuration</b> <b>file?</b>
       In  your  Application  class,  define  "init()"  to  load  your configuration file and save the resulting
       configuration object in the cache using the cache, where the object will be available to your application
       and command objects.

   <b>How</b> <b>can</b> <b>I</b> <b>use</b> <b>templates</b> <b>for</b> <b>more</b> <b>flexible</b> <b>output?</b>
       In your Application class, override the "render()" method.

       For instance, you could write an application where all commands return a data structure  to  be  used  in
       processing a template.  Your "render()" method could determine which template file to process (e.g. based
       on which command is being run) and then process it using the received data structure.

   <b>How</b> <b>can</b> <b>I</b> <b>create</b> <b>an</b> <b>application-aware</b> <b>command?</b>
       In  exceptional  cases,  you  may  need  to create a command that "knows about" the application and needs
       access to some of its data (which may include the data of other commands in the application).

       To create an application-aware command, inherit from  CLI::Framework::Command::Meta.   The  command  will
       then have an accessor that will provide access to the application object.

       You  should  generally  not  need  to  do  this  --  your  commands should usually be decoupled from your
       application.  This will occur by default when you inherit from CLI::Framework::Command.

   <b>How</b> <b>can</b> <b>I</b> <b>use</b> <b>alternative</b> <b>CLI</b> <b>prompting</b> <b>techniques</b> <b>and</b> <b>terminal</b> <b>I/O</b> <b>convenience</b> <b>functions?</b>
       You may, for example, want to present a menu of options from a variety of choices based on content from a
       database.  Or perhaps you want to prompt the user for a list of numbers and you want to support a  comma-
       separated list with ranges, etc.

       Create  a  CLI::Framework::Command  subclass  (say,  "Your::Command")  that  implements  your convenience
       functions or uses a CPAN module such as Term::Prompt.   Then  all  of  your  commands  can  inherit  from
       "Your::Command" and will all have access to the functions.

       You may also want to override read_cmd.

   <b>How</b> <b>can</b> <b>I</b> <b>create</b> <b>an</b> <b>app</b> <b>without</b> <b>a</b> <b>"help"</b> <b>command?</b>
       The  'help'  command  is  fundamental  to  most applications.  If you really want to build an application
       without a 'help' command, simply create a custom Help command with an empty "run" method.

   <b>How</b> <b>can</b> <b>I</b> <b>dynamically</b> <b>determine</b> <b>whether</b> <b>or</b> <b>not</b> <b>to</b> <b>run</b> <b>interactively</b> <b>based</b> <b>on</b> <b>command-line</b> <b>options?</b>
       You may wish to provide an application option ("--interactive") to start interactive mode.  One way to do
       this is to use your application's "init" method to determine  whether  or  not  to  invoke  the  built-in
       console command.  For example:

           sub init {
               my ($app, $opts) = @_;
               # imagine fancy logic to determine whether or not to run interactively...
               if( $opts-&gt;{interactive} ) {
                   $app-&gt;set_current_command('console');
               }
               return 1;
           }

       This  will  cause  the interactive console to be launched during initialization.  This technique could be
       used to launch the built-in console command or a custom interactive command.

       This was considered in greater detail on the discussion forum: &lt;<a href="http://cpanforum.com/posts/12426">http://cpanforum.com/posts/12426</a>&gt;.

</pre><h4><b>TROUBLESHOOTING</b></h4><pre>
       The following solutions may be helpful when working with CLIF.

       •   Don't  forget  to  inherit  from  CLI::Framework::Application   in   your   Application   class   and
           CLI::Framework::Command in your command class

       •   Don't forget to override <b>command_map()</b> in your Application class

       •   Don't forget to override <b>run()</b> in your Command class

       •   If in doubt, run "perl -wc &lt;your command class file&gt;"

           If  a user-defined command class does not compile, your CLIF application will fail silently.  Running
           "perl -wc Class.pm" will report compilation problems for <u>Class.pm</u>.

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Karl Erisman (<a href="mailto:kerisman@cpan.org">kerisman@cpan.org</a>). All rights reserved.

       This is free software; you can redistribute it and/or modify it under the same terms as Perl itself.  See
       perlartistic.

</pre><h4><b>AUTHOR</b></h4><pre>
       Karl Erisman (<a href="mailto:kerisman@cpan.org">kerisman@cpan.org</a>)

perl v5.34.0                                       2022-06-11                      <u>CLI::Framework::<a href="../man3pm/Tutorial.3pm.html">Tutorial</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>