<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CLI::Framework::Application - CLIF Application superclass</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcli-framework-perl">libcli-framework-perl_0.05-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CLI::Framework::Application - CLIF Application superclass

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # The code below shows a few of the methods your application class is likely
           # to override...

           package My::Journal;
           use base qw( CLI::Framework );

           sub usage_text { q{
               $0 [--verbose|v]

               OPTIONS
                   --db [path]  : path to SQLite database file
                   -v --verbose : be verbose
                   -h --help    : show help

               COMMANDS
                   help        - show application or command-specific help
                   menu        - print command menu
                   entry       - work with journal entries
                   publish     - publish a journal
                   console     - start a command console for the application
           } }

           sub option_spec {
               [ 'help|h'      =&gt; 'show help' ],
               [ 'verbose|v'   =&gt; 'be verbose' ],
               [ 'db=s'        =&gt; 'path to SQLite database file' ],
           }

           sub command_map {
               help    =&gt; 'CLI::Framework::Command::Help',
               menu    =&gt; 'My::Journal::Command::Menu',
               entry   =&gt; 'My::Journal::Command::Entry',
               publish =&gt; 'My::Journal::Command::Publish',
               console =&gt; 'CLI::Framework::Command::Console',
           }

           sub command_alias {
               h   =&gt; 'help',
               m   =&gt; 'menu',
               e   =&gt; 'entry',
               p   =&gt; 'publish',
               sh  =&gt; 'console',
               c   =&gt; 'console',
           }

           sub init {
               my ($self, $opts) = @_;
               my $db = DBI-&gt;connect( ... );
               $self-&gt;cache-&gt;set( db =&gt; $db );
               return 1;
           }
           1;

</pre><h4><b>OBJECT</b> <b>CONSTRUCTION</b></h4><pre>
   <b>new(</b> <b>[interactive</b> <b>=&gt;</b> <b>1]</b> <b>)</b>
           $app = My::Application-&gt;new( interactive =&gt; 1 );

       "interactive": Optional parameter.  Set this to a true value if the application is to be run
       interactively (or call "set_interactivity_mode" later)

       Constructs and returns a new CLIF Application object.  As part of this process, some validation is
       performed on SUBCLASS HOOKS defined in the application class.  If validation fails, an exception is
       thrown.

</pre><h4><b>COMMAND</b> <b>INTROSPECTION</b> <b>&amp;</b> <b>REGISTRATION</b></h4><pre>
       The methods in this section are responsible for providing access to the commands in an application.

   <b>command_map_hashref()</b>
           $h = $app-&gt;command_map_hashref();

       Returns a HASH ref built from the command_map for an Application (by direct conversion from the command
       map array).

       If the list returned by the definition of command_map in the application is not hash-worthy, an exception
       is thrown.

   <b>is_valid_command_pkg(</b> <b>$package_name</b> <b>)</b>
           $app-&gt;is_valid_command_pkg( 'My::Command::Swim' );

       Returns a true value if the specified command class (package name) is valid within the application.
       Returns a false value otherwise.

       A command class is "valid" if it is included in command_map or if it is a built-in command that was
       included automatically in the application.

   <b>is_valid_command_name(</b> <b>$command_name</b> <b>)</b>
           $app-&gt;is_valid_command_name( 'swim' );

       Returns a true value if the specified command name is valid within the application.  Returns a false
       value otherwise.

       A command name is "valid" if it is included in command_map or if it is a built-in command that was
       included automatically in the application.

   <b>registered_command_names()</b>
           @registered_commands = $app-&gt;registered_command_names();

       Returns a list of the names of all registered commands.  These are the names that each command was given
       in command_map (plus any auto-registered built-ins).

   <b>registered_command_object(</b> <b>$command_name</b> <b>)</b>
           $command_object = $app-&gt;registered_command_object( 'fly' );

       Given the name of a registered command, returns the CLI::Framework::Command object that is registered in
       the application under that name.  If the command is not registered, returns "undef".

   <b>register_command(</b> <b>$cmd</b> <b>)</b>
           # Register by name...
           $command_object = $app-&gt;register_command( $command_name );

           # ...or register by object reference...
           $command_object = CLI::Framework::Command-&gt;new( ... );
           $app-&gt;register_command( $command_object );

       Register a command to be recognized by the application.  This method accepts either the name of a command
       or a reference to a CLI::Framework::Command object.

       If $cmd is a CLI::Framework::Command object and it is one of the command types specified in command_map
       to be valid, the command object is registered and returned.

       If $cmd is the name of a valid command specified in command_map, an object of the corresponding command
       class is registered and returned.

       If $cmd is not recognized, an exception is thrown.

   <b>get_default_command()</b> <b>/</b> <b>set_default_command(</b> <b>$default_cmd</b> <b>)</b>
       "get_defualt_command()" retrieves the name of the command that is currently set as the default command
       for the application.

           my $default_command = $app-&gt;get_default_command();

       Given a command name, "set_default_command" makes it the default command for the application.

           $app-&gt;set_default_command( 'jump' );

   <b>get_current_command()</b> <b>/</b> <b>set_current_command(</b> <b>$current</b> <b>)</b>
       "get_current_command" returns the name of the current command (or the one that was most recently run).

           $status = $app-&gt;run();
           print 'The command named: ', $app-&gt;get_current_command(), ' was just run';

       Given a command name, "set_current_command" forwards execution to that command.  This might be useful
       (for instance) to "redirect" to another command.

           $app-&gt;set_current_command( 'fly' );

   <b>get_default_usage()</b> <b>/</b> <b>set_default_usage(</b> <b>$default_usage</b> <b>)</b>
       The "default usage" message is used as a last resort when usage information is unavailable by other
       means.  See usage.

       "get_default_usage" gets the default usage message for the application.

           $usage_msg = $app-&gt;get_default_usage();

       "set_default_usage" sets the default usage message for the application.

           $app-&gt;set_default_usage( $usage_message );

</pre><h4><b>PARSING</b> <b>&amp;</b> <b>RUNNING</b> <b>COMMANDS</b></h4><pre>
   <b>usage(</b> <b>$command_name,</b> <b>@subcommand_chain</b> <b>)</b>
           # Application usage...
           print $app-&gt;usage();

           # Command-specific usage...
           $command_name = 'task';
           @subcommand_chain = qw( list completed );
           print $app-&gt;usage( $command_name, @subcommand_chain );

       Returns a usage message for the application or a specific (sub)command.

       If a command name is given (optionally with subcommands), returns a usage message string for that
       (sub)command.  If no command name is given or if no usage message is defined for the specified
       (sub)command, returns a general usage message for the application.

       Here is how the usage message is produced:

       •   If  a  valid  command name (or alias) is given, attempt to get a usage message from the command (this
           step takes into account @subcommand_chain so that  a  subcommand  usage  message  will  be  shown  if
           applicable);  if  no  usage  message  is  defined  for the command, use the application usage message
           instead.

       •   If the application object has defined usage_text, use its return value as the usage message.

       •   Finally, fall back to using the default usage message returned by get_default_usage.

           <b>Note</b>: It is  advisable  to  define  usage_text  because  the  default  usage  message,  produced  via
           Getopt::Long::Descriptive, is terse and is not context-specific to the command request.

   <b>cache()</b>
       CLIF  Applications  may  have the need to share data between individual CLIF Commands and the Application
       object itself.  "cache()" provides a way for this data  to  be  stored,  retrieved,  and  shared  between
       components.

           $cache_object = $app-&gt;cache();

       "cache()" returns a cache object.  The following methods demonstrate usage of the resulting object:

           $cache_object-&gt;get( 'key' );
           $cache_object-&gt;set( 'key' =&gt; $value );

       <b>Note</b>:  The underlying cache class is currently limited to these rudimentary features.  In the future, the
       object returned by "cache()" may be changed to an instance of a real caching class, such  as  CHI  (which
       would  maintain  backwards  compatibility but offer expiration, serialization, multiple caching backends,
       etc.).

   <b>run()</b>
           # as class method:
           My::App-&gt;run();

           # as object method (when having an object reference to call other methods
           # is desirable):
           my $app = My::App-&gt;new();
           $app-&gt;run();

           ...

           # Explicitly specify whether or not initialization should be done:
           $app-&gt;run( initialize =&gt; 0 );

       This method controls the request processing and dispatching of a single command.  It takes its input from
       @ARGV (which may be populated by a script running non-interactively on the command line)  and  dispatches
       the  indicated  command,  capturing  its  return value.  The command's return value represents the output
       produced by the command.  This value is passed to render for final display.

       If errors occur, they result in exceptions that are handled by handle_exception.

       The following parameters are accepted:

       "initialize": This controls whether or not application initialization (via init) should be performed.  If
       not specified, initialization is performed upon the first call to  "run".   Should  there  be  subsequent
       calls, initialization is not repeated.  Passing "initialize" explicitly can modify this behavior.

</pre><h4><b>INTERACTIVITY</b></h4><pre>
   <b>get_interactivity_mode()</b> <b>/</b> <b>set_interactivity_mode(</b> <b>$is_interactive</b> <b>)</b>
       "get_interactivity_mode"  returns  a true value if the application is in an interactive state and a false
       value otherwise.

           print "running interactively" if $app-&gt;get_interactivity_mode();

       "set_interactivity_mode" sets the interactivity state of the application.  One parameter is recognized: a
       true or false value to indicate whether the application state should be interactive  or  non-interactive,
       respectively.

           $app-&gt;<a href="../man1/set_interactivity_mode.1.html">set_interactivity_mode</a>(1);

   <b>is_interactive_command(</b> <b>$command_name</b> <b>)</b>
           $help_command_is_interactive = $app-&gt;is_interactive_command( 'help' );

       Returns  a  true value if there is a valid command with the specified name that is an interactive command
       (i.e. a command that is enabled for this  application  in  interactive  mode).   Returns  a  false  value
       otherwise.

   <b>get_interactive_commands()</b>
           my @interactive_commands = $app-&gt;get_interactive_commands();

       Return a list of all commands that are to be available in interactive mode ("interactive commands").

   <b>run_interactive(</b> <b>[%param]</b> <b>)</b>
           MyApp-&gt;run_interactive();

           # ...or as an object method:
           $app-&gt;run_interactive();

       Start an event processing loop to prompt for and run commands in sequence.  The "menu" command is used to
       display available command selections (the built-in "menu" command, CLI::Framework::Command::Menu, will be
       used unless the application defines its own "menu" command).

       Within  this loop, valid input is the same as in non-interactive mode except that application options are
       not accepted (any application options should be handled upon application initialization  and  before  the
       interactive <b>command</b> loop is entered -- see the description of the "initialize" parameter below).

       The following parameters are recognized:

       "initialize":  causes  any  application  options  that  are present in @ARGV to be procesed/validated and
       causes init to be invoked prior to entering  the  interactive  event  loop  to  recognize  commands.   If
       "run_interactive()"  is called after application options have already been handled, this parameter can be
       omitted.

       "invalid_request_threshold": the number of unrecognized command requests the user can  enter  before  the
       menu is re-displayed.

   <b>read_cmd()</b>
           $app-&gt;read_cmd();

       This method is responsible for retrieving a command request and placing the user input into @ARGV.  It is
       called in void context.

       The  default implementation uses Term::ReadLine to prompt the user and read a command request, supporting
       command history.

       Subclasses are free to override this method if a different means of  accepting  user  input  is  desired.
       This  makes  it  possible  to read command selections without assuming that the console is being used for
       I/O.

   <b>is_quit_signal()</b>
           until( $app-&gt;is_quit_signal(read_string_from_user()) ) { ... }

       Given a string, return a true value if it is a quit signal (indicating that the application should  exit)
       and  a  false  value  otherwise.   quit_signals is an application subclass hook that defines what strings
       signify that the interactive session should exit.

</pre><h4><b>SUBCLASS</b> <b>HOOKS</b></h4><pre>
       There are several hooks that allow CLIF applications to influence the command  execution  process.   This
       makes customizing the critical aspects of an application as easy as overriding methods.

       Except  where  noted,  all  hooks  are  optional  -- subclasses may choose not to override them (in fact,
       runnable CLIF applications can be created with very minimal subclasses).

   <b>init(</b> <b>$options_hash</b> <b>)</b>
       This hook is called in void context with one parameter:

       $options_hash is a hash of pre-validated application options received and parsed from the  command  line.
       The  options  hash has already been checked against the options defined to be accepted by the application
       in option_spec.

       This method allows CLIF applications to perform  any  common  initialization  tasks  that  are  necessary
       regardless  of  which  command  is to be run.  Some examples of this include connecting to a database and
       storing a connection handle in the shared cache slot for use by individual commands, setting up a logging
       facility that can be used by each command by storing a logging  object  in  the  cache,  or  initializing
       settings from a configuration file.

   <b>pre_dispatch(</b> <b>$command_object</b> <b>)</b>
       This hook is called in void context.  It allows applications to perform actions after each command object
       has  been  prepared for dispatch but before the command dispatch actually takes place.  Its purpose is to
       allow applications to do whatever may be necessary to prepare for running the command.   For  example,  a
       log entry could be inserted in a database to store a record of every command that is run.

   <b>option_spec()</b>
       An example definition of this hook is as follows:

           sub option_spec {
               [ 'verbose|v'   =&gt; 'be verbose'         ],
               [ 'logfile=s'   =&gt; 'path to log file'   ],
           }

       This  method  should return an option specification as expected by Getopt::Long::Descriptive.  The option
       specification defines what options are allowed and recognized by the application.

   <b>validate_options(</b> <b>$options_hash</b> <b>)</b>
       This hook is called in void context.  It is provided so  that  applications  can  perform  validation  of
       received options.

       $options_hash is an options hash parsed from the command-line.

       This method should throw an exception if the options are invalid (throwing the exception using "die()" is
       sufficient).

       <b>Note</b>  that  Getopt::Long::Descriptive,  which is used internally for part of the options processing, will
       perform some validation of its own based on the option_spec.  However, the "validate_options" hook allows
       for additional flexibility in validating application options.

   <b>command_map()</b>
       Return  a  mapping  between  command   names   and   Command   classes   (classes   that   inherit   from
       CLI::Framework::Command).   The  mapping is a list of key-value pairs.  The list should be "hash-worthy",
       meaning that it can be directly converted to a hash.

       Note that the order of the commands in this list determines the order that the commands are displayed  in
       the built-in interactive menu.

       The  keys  are  names that should be used to install the commands in the application.  The values are the
       names of the packages that implement the corresponding commands, as in this example:

           sub command_map {
               # custom commands:
               fly     =&gt; 'My::Command::Fly',
               run     =&gt; 'My::Command::Run',

               # overridden built-in commands:
               menu    =&gt; 'My::Command::Menu',

               # built-in commands:
               help    =&gt; 'CLI::Framework::Command::Help',
               list    =&gt; 'CLI::Framework::Command::List',
               tree    =&gt; 'CLI::Framework::Command::Tree',
               'dump'  =&gt; 'CLI::Framework::Command::Dump',
               console =&gt; 'CLI::Framework::Command::Console',
               alias   =&gt; 'CLI::Framework::Command::Alias',
           }

   <b>command_alias()</b>
       This hook allows aliases for commands to be specified.  The aliases will be recognized in  place  of  the
       actual command names.  This is useful for setting up shortcuts to longer command names.

       "command_alias"  should return a "hash-worthy" list where the keys are aliases and the values are command
       names.

       An example of its definition:

           sub command_alias {
               h   =&gt; 'help',
               l   =&gt; 'list',
               ls  =&gt; 'list',
               sh  =&gt; 'console',
               c   =&gt; 'console',
           }

   <b>noninteractive_commands()</b>
           sub noninteractive_commands { qw( console menu ) }

       Certain commands do not make sense to run interactively (e.g. the "console" command,  which  itself  puts
       the application into interactive mode).  This method should return a list of their names.  These commands
       will  be  disabled during interactive mode.  By default, all commands are interactive commands except for
       "console" and "menu".

   <b>quit_signals()</b>
           sub quit_signals { qw( q quit exit ) }

       An application can specify exactly what input represents a request to end  an  interactive  session.   By
       default, the example definition above is used.

   <b>handle_exception(</b> <b>$e</b> <b>)</b>
           sub handle_exception {
               my ($app, $e) = @_;

               # Handle the exception represented by object $e...
               $app-&gt;my_error_logger( error =&gt; $e-&gt;error, pid =&gt; $e-&gt;pid, gid =&gt; $e-&gt;gid, ... );

               warn "caught error ", $e-&gt;error, ", continuing...";
               return;
           }

       Error  conditions  are  caught by CLIF and forwarded to this exception handler.  It receives an exception
       object (see Exception::Class::Base for methods that can be called on the object).

       If not overridden, the default implementation extracts the error message from the  exception  object  and
       processes it through the render method.

   <b>render(</b> <b>$output</b> <b>)</b>
           $app-&gt;render( $output );

       This  method  is  responsible  for presentation of the result from a command.  The default implementation
       simply attempts to print the $output scalar, assuming that it is a string.

       Subclasses are free to override this method to provide more sophisticated behavior such as processing the
       $output scalar through a templating system.

   <b>usage_text()</b>
           sub usage_text {
               q{
               OPTIONS
                   -v --verbose : be verbose
                   -h --help    : show help

               COMMANDS
                   tree        - print a tree of only those commands that are currently-registered in your application
                   menu        - print command menu
                   help        - show application or command-specific help
                   console     - start a command console for the application
                   list        - list all commands available to the application
               }
           }

       To provide application usage information, this method may be overridden.  It accepts  no  parameters  and
       should return a string containing a useful help message for the overall application.

       Overriding  this  method  is encouraged in order to provide a better usage message than the default.  See
       usage.

</pre><h4><b>ERROR</b> <b>HANDLING</b> <b>IN</b> <b>CLIF</b></h4><pre>
       Internally, CLIF handles errors by throwing exceptions.

       The handle_exception method provides an opportunity for customizing the way errors are treated in a  CLIF
       application.

       Application  and  Command  class  hooks  such  as  validate_options and validate are expected to indicate
       success or failure by throwing exceptions (via "die()" or something more  elaborate,  such  as  exception
       objects).

</pre><h4><b>CONFIGURATION</b> <b>&amp;</b> <b>ENVIRONMENT</b></h4><pre>
       For  interactive  usage,  Term::ReadLine  is  used by default.  Depending on which readline libraries are
       available on your system, your interactive experience will vary (for example, systems with  GNU  readline
       can benefit from a command history buffer).

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       Exception::Class::TryCatch

       Getopt::Long::Descriptive

       Text::ParseWords (only for interactive use)

       Term::ReadLine (only for interactive use)

       CLI::Framework::Exceptions

       CLI::Framework::Command

</pre><h4><b>DEFECTS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       No known bugs.

</pre><h4><b>PLANS</b> <b>FOR</b> <b>FUTURE</b> <b>VERSIONS</b></h4><pre>
       •   Command-line completion of commands in interactive mode

       •   Features to make it simpler to use templates for output

       •   Features to instantly web-enable your CLIF Applications, making them accessible via a "web console"

       •   Better automatic usage message generation

       •   An optional inline automatic class generation interface similar to that of Exception::Class that will
           make the simple "inline" form of usage even more compact

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       CLI::Framework

       CLI::Framework::Command

       CLI::Framework::Tutorial

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Karl Erisman (<a href="mailto:kerisman@cpan.org">kerisman@cpan.org</a>). All rights reserved.

       This  is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See
       perlartistic.

</pre><h4><b>AUTHOR</b></h4><pre>
       Karl Erisman (<a href="mailto:kerisman@cpan.org">kerisman@cpan.org</a>)

perl v5.34.0                                       2022-06-11                   <u>CLI::Framework::<a href="../man3pm/Application.3pm.html">Application</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>