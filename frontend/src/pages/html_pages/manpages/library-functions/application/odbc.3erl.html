<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>odbc - Erlang ODBC application</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       odbc - Erlang ODBC application

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  application  provides an Erlang interface to communicate with relational SQL-databases. It is built
       on top of Microsofts ODBC interface and therefore requires that you have an ODBC driver to  the  database
       that you want to connect to.

   <b>Note:</b>
       The  functions  <u>first/[1,2]</u>, <u>last/[1,2]</u>, <u>next/[1,2]</u>, <u>prev[1,2]</u> and <u>select/[3,4]</u> assumes there is a result
       set associated with the connection to work on. Calling the function <u>select_count/[2,3]</u> associates such  a
       result set with the connection. Calling select_count again will remove the current result set association
       and  create  a  new  one. Calling a function which dose not operate on an associated result sets, such as
       <u>sql_query/[2,3]</u>, will remove the current result set association.

       Alas some drivers only support sequential traversal of the result set, e.i. they do not support  what  in
       the  ODBC  world  is  known  as  scrollable  cursors.  This  will  have the effect that functions such as
       <u>first/[1,2]</u>, <u>last/[1,2]</u>, <u>prev[1,2]</u>, etc will return <u>{error,</u> <u>driver_does_not_support_function}</u>

</pre><h4><b>COMMON</b> <b>DATA</b> <b>TYPES</b></h4><pre>
       Here follows type definitions that are used by more than one function in the ODBC API.

   <b>Note:</b>
       The type <u>TimeOut</u> has the default value <u>infinity</u>, so for instance:
       commit(Ref, CommitMode) is the same as commit(Ref, CommitMode, infinity).  If  the  timeout  expires  the
       client will exit with the reason timeout.

        connection_reference() - as returned by connect/2

        time_out() = milliseconds() | infinity

        milliseconds() = integer() &gt;= 0

        common_reason() = connection_closed | extended_error() | term() - some kind of
        explanation of what went wrong

        extended_error() = {string(), integer(), Reason} - extended error type with ODBC
        and native database error codes, as well as the base reason that would have been
        returned had extended_errors not been enabled.

        string() = list of ASCII characters

        col_name() = string() - Name of column in the result set

        col_names() - [col_name()] - e.g. a list of the names of the
                  selected columns in the result set.

        row() = {value()} - Tuple of column values e.g. one row of the
                  result set.

        value() = null | term() - A column value.

        rows() = [row()] - A list of rows from the result set.

        result_tuple() =
             {updated, n_rows()} | {selected, col_names(), rows()}

        n_rows() = integer() - The number of affected rows for UPDATE,
                  INSERT, or DELETE queries. For other query types the value
                  is driver defined, and hence should be ignored.

        odbc_data_type() = sql_integer | sql_smallint | sql_tinyint |
             {sql_decimal, precision(), scale()} |
             {sql_numeric, precision(), scale()} |
             {sql_char, size()} |
             {sql_wchar, size()} |
             {sql_varchar, size()} |
             {sql_wvarchar, size()}|
             {sql_float, precision()} |
             {sql_wlongvarchar, size()} |
             {sql_float, precision()} |
             sql_real | sql_double | sql_bit | atom()

        precision() = integer()

        scale() = integer()

        size() = integer()

</pre><h4><b>ERROR</b> <b>HANDLING</b></h4><pre>
       The error handling strategy and possible errors sources are described in the Erlang ODBC User's Guide.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>commit(Ref,</b> <b>CommitMode)</b> <b>-&gt;</b>
       <b>commit(Ref,</b> <b>CommitMode,</b> <b>TimeOut)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Ref = connection_reference()
                 CommitMode = commit | rollback
                 TimeOut = time_out()
                 Reason    =    not_an_explicit_commit_connection   |   process_not_owner_of_odbc_connection   |
                 common_reason()

              Commits or rollbacks a transaction. Needed on connections where automatic commit is turned off.

       <b>connect(ConnectStr,</b> <b>Options)</b> <b>-&gt;</b> <b>{ok,</b> <b>Ref}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 ConnectStr = string()
                   An example of a connection string: <u>"DSN=sql-server;UID=aladdin;PWD=sesame"</u> where DSN is  your
                   ODBC Data Source Name, UID is a database user id and PWD is the password for that user. These
                   are  usually  the  attributes  required in the connection string, but some drivers have other
                   driver  specific  attributes,  for  example  <u>"DSN=Oracle8;DBQ=gandalf;UID=aladdin;PWD=sesame"</u>
                   where DBQ is your TNSNAMES.ORA entry name e.g. some Oracle specific configuration attribute.
                 Options = [] | [option()]
                   All options has default values.
                 option()  =  {auto_commit, on | off} | {timeout, milliseconds()} | {binary_strings, on | off} |
                 {tuple_row, on |  off}  |  {scrollable_cursors,  on  |  off}  |  {trace_driver,  on  |  off}  |
                 {extended_errors, on | off}
                 Ref = connection_reference() - should be used to access the connection.
                 Reason = port_program_executable_not_found | common_reason()

              Opens  a connection to the database. The connection is associated with the process that created it
              and can only be accessed through  it.  This  function  may  spawn  new  processes  to  handle  the
              connection.  These  processes will terminate if the process that created the connection dies or if
              you call disconnect/1.

              If automatic commit mode is turned on, each query will be considered as an individual  transaction
              and will be automatically committed after it has been executed. If you want more than one query to
              be part of the same transaction the automatic commit mode should be turned off. Then you will have
              to call commit/3 explicitly to end a transaction.

              The default timeout is infinity

              &gt;If  the  option  binary_strings is turned on all strings will be returned as binaries and strings
              inputed to param_query will be expected to be binaries. The user needs to ensure that  the  binary
              is in an encoding that the database expects. By default this option is turned off.

              As  default  result  sets  are returned as a lists of tuples. The <u>TupleMode</u> option still exists to
              keep some degree of backwards compatibility. If the option is set to  off,  result  sets  will  be
              returned as a lists of lists instead of a lists of tuples.

              Scrollable  cursors  are  nice  but causes some overhead. For some connections speed might be more
              important than flexible data access and then you can disable scrollable cursor for  a  connection,
              limiting the API but gaining speed.

          <b>Note:</b>
              Turning  the  scrollable_cursors option off is noted to make old odbc-drivers able to connect that
              will otherwhise fail.

              If trace mode is turned on this tells the ODBC driver to write a trace log  to  the  file  SQL.LOG
              that  is placed in the current directory of the erlang emulator. This information may be useful if
              you suspect there might be a bug in the erlang ODBC application, and it might be relevant for  you
              to send this file to our support. Otherwise you will probably not have much use of this.

          <b>Note:</b>
              For more information about the <u>ConnectStr</u> see description of the function SQLDriverConnect in [1].

              The <u>extended_errors</u> option enables extended ODBC error information when an operation fails. Rather
              than  returning  <u>{error,</u>  <u>Reason}</u>,  the  failing  function  will  reutrn  <u>{error,</u>  <u>{ODBCErrorCode,</u>
              <u>NativeErrorCode,</u> <u>Reason}}</u>. Note that this information is  probably  of  little  use  when  writing
              database-independent code, but can be of assistance in providing more sophisticated error handling
              when dealing with a known underlying database.

                * <u>ODBCErrorCode</u> is the ODBC error string returned by the ODBC driver.

                * <u>NativeErrorCode</u>  is  the numberic error code returned by the underlying database. The possible
                  values and their meanings are dependent on the database being used.

                * <u>Reason</u> is as per the <u>Reason</u> field when extended errors are not enabled.

          <b>Note:</b>
              The current implementation spawns a port program written  in  C  that  utilizes  the  actual  ODBC
              driver.  There  is  a default timeout of 5000 msec for this port programm to connect to the Erlang
              ODBC application. This timeout can be changed  by  setting  an  application  specific  environment
              variable  'port_timeout'  with  the number of milliseconds for the ODBC application. E.g.: [{odbc,
              [{port_timeout, 60000}]}] to set it to 60 seconds.

       <b>disconnect(Ref)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Ref = connection_reference()
                 Reason = process_not_owner_of_odbc_connection | extended_error()

              Closes a connection to a database. This will also terminate  all  processes  that  may  have  been
              spawned when the connection was opened. This call will always succeed. If the connection cannot be
              disconnected  gracefully  it  will be brutally killed. However you may receive an error message as
              result if you try to disconnect a connection started by another process.

       <b>describe_table(Ref,</b> <b>Table)</b> <b>-&gt;</b>
       <b>describe_table(Ref,</b> <b>Table,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{ok,</b> <b>Description}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Ref = connection_reference()
                 Table = string() - Name of databas table.
                 TimeOut = time_out()
                 Description = [{col_name(), odbc_data_type()}]
                 Reason = common_reason()

              Queries the database to find out the ODBC data types of the columns of the table <u>Table</u>.

       <b>first(Ref)</b> <b>-&gt;</b>
       <b>first(Ref,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{selected,</b> <b>ColNames,</b> <b>Rows}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Ref = connection_reference()
                 TimeOut = time_out()
                 ColNames = col_names()
                 Rows = rows()
                 Reason     =      result_set_does_not_exist      |      driver_does_not_support_function      |
                 scrollable_cursors_disabled | process_not_owner_of_odbc_connection | common_reason()

              Returns the first row of the result set and positions a cursor at this row.

       <b>last(Ref)</b> <b>-&gt;</b>
       <b>last(Ref,</b> <b>TimeOut)</b> <b>-&gt;</b> <b>{selected,</b> <b>ColNames,</b> <b>Rows}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Ref = connection_reference()
                 TimeOut = time_out()
                 ColNames = col_names()
                 Rows = rows()
                 Reason      =      result_set_does_not_exist      |      driver_does_not_support_function     |
                 scrollable_cursors_disabled | process_not_owner_of_odbc_connection | common_reason()

              Returns the last row of the result set and positions a cursor at this row.

       <b>next(Ref)</b> <b>-&gt;</b>
       <b>next(Ref,</b> <b>TimeOut)</b> <b>-&gt;</b> <b>{selected,</b> <b>ColNames,</b> <b>Rows}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Ref = connection_reference()
                 TimeOut = time_out()
                 ColNames = col_names()
                 Rows = rows()
                 Reason = result_set_does_not_exist | process_not_owner_of_odbc_connection | common_reason()

              Returns the next row of the result set relative the current  cursor  position  and  positions  the
              cursor  at  this  row.  If  the  cursor  is positioned at the last row of the result set when this
              function is called the returned value will be <u>{selected,</u> <u>ColNames,[]}</u> e.i. the list of row  values
              is empty indicating that there is no more data to fetch.

       <b>param_query(Ref,</b> <b>SQLQuery,</b> <b>Params)</b> <b>-&gt;</b>
       <b>param_query(Ref,</b> <b>SQLQuery,</b> <b>Params,</b> <b>TimeOut)</b> <b>-&gt;</b> <b>ResultTuple</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Ref = connection_reference()
                 SQLQuery  =  string()  -  a  SQL query with parameter markers/place holders in form of question
                 marks.
                 Params = [{odbc_data_type(), [value()]}] |[{odbc_data_type(), in_or_out(), [value()]}]
                 in_or_out = in | out | inout
                   Defines IN, OUT, and IN OUT Parameter Modes for stored procedures.
                 TimeOut = time_out()
                 Values = term() - Must be consistent with the Erlang data type that  corresponds  to  the  ODBC
                 data type ODBCDataType

              Executes  a  parameterized  SQL query. For an example see the "Using the Erlang API" in the Erlang
              ODBC User's Guide.

          <b>Note:</b>
              Use the function describe_table/[2,3] to find out which ODBC data type that is expected  for  each
              column  of that table. If a column has a data type that is described with capital letters, alas it
              is not currently  supported  by  the  param_query  function.  Too  know  which  Erlang  data  type
              corresponds to an ODBC data type see the Erlang to ODBC data type mapping in the User's Guide.

       <b>prev(Ref)</b> <b>-&gt;</b>
       <b>prev(ConnectionReference,</b> <b>TimeOut)</b> <b>-&gt;</b> <b>{selected,</b> <b>ColNames,</b> <b>Rows}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Ref = connection_reference()
                 TimeOut = time_out()
                 ColNames = col_names()
                 Rows = rows()
                 Reason      =      result_set_does_not_exist      |      driver_does_not_support_function     |
                 scrollable_cursors_disabled | process_not_owner_of_odbc_connection | common_reason()

              Returns the previous row of the result set relative the current cursor position and positions  the
              cursor at this row.

       <b>start()</b> <b>-&gt;</b>
       <b>start(Type)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Type = permanent | transient | temporary

              Starts the odbc application. Default type is temporary. See <a href="../man3erl/application.3erl.html">application</a>(3erl)

       <b>stop()</b> <b>-&gt;</b> <b>ok</b>

              Stops the odbc application. See <a href="../man3erl/application.3erl.html">application</a>(3erl)

       <b>sql_query(Ref,</b> <b>SQLQuery)</b> <b>-&gt;</b>
       <b>sql_query(Ref,</b> <b>SQLQuery,</b> <b>TimeOut)</b> <b>-&gt;</b> <b>ResultTuple</b> <b>|</b> <b>[ResultTuple]</b> <b>|{error,</b> <b>Reason}</b>

              Types:

                 Ref = connection_reference()
                 SQLQuery  =  string()  -  The string may be composed by several SQL-queries separated by a ";",
                 this is called a batch.
                 TimeOut = time_out()
                 ResultTuple = result_tuple()
                 Reason = process_not_owner_of_odbc_connection | common_reason()

              Executes a SQL query or a batch of SQL queries. If  it  is  a  SELECT  query  the  result  set  is
              returned,  on  the  format  <u>{selected,</u>  <u>ColNames,</u> <u>Rows}</u>. For other query types the tuple <u>{updated,</u>
              <u>NRows}</u> is returned, and for batched queries, if the driver supports them, this function  can  also
              return a list of result tuples.

          <b>Note:</b>
              Some  drivers  may  not have the information of the number of affected rows available and then the
              return value may be <u>{updated,</u> <u>undefined}</u> .

              The list of column names is ordered in the same way as the list of values of a row, e.g. the first
              <u>ColName</u> is associated with the first <u>Value</u> in a <u>Row</u>.

       <b>select_count(Ref,</b> <b>SelectQuery)</b> <b>-&gt;</b>
       <b>select_count(Ref,</b> <b>SelectQuery,</b> <b>TimeOut)</b> <b>-&gt;</b> <b>{ok,</b> <b>NrRows}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Ref = connection_reference()
                 SelectQuery = string()
                   SQL SELECT query.
                 TimeOut = time_out()
                 NrRows = n_rows()
                 Reason = process_not_owner_of_odbc_connection | common_reason()

              Executes a SQL SELECT query and associates the  result  set  with  the  connection.  A  cursor  is
              positioned before the first row in the result set and the tuple <u>{ok,</u> <u>NrRows}</u> is returned.

          <b>Note:</b>
              Some  drivers  may  not  have the information of the number of rows in the result set, then <u>NrRows</u>
              will have the value <u>undefined</u>.

       <b>select(Ref,</b> <b>Position,</b> <b>N)</b> <b>-&gt;</b>
       <b>select(Ref,</b> <b>Position,</b> <b>N,</b> <b>TimeOut)</b> <b>-&gt;</b> <b>{selected,</b> <b>ColNames,</b> <b>Rows}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Ref = connection_reference()
                 Position = next | {relative, Pos} | {absolute, Pos}
                   Selection strategy, determines at which row in the result set to start the selection.
                 Pos = integer()
                   Should indicate a row number in the result set. When used together with the option <u>relative</u>it
                   will be used as an offset from the current cursor  position,  when  used  together  with  the
                   option <u>absolute</u>it will be interpreted as a row number.
                 N = integer()
                 TimeOut = time_out()
                 Reason      =      result_set_does_not_exist      |      driver_does_not_support_function     |
                 scrollable_cursors_disabled | process_not_owner_of_odbc_connection | common_reason()

              Selects <u>N</u> consecutive rows of the result set. If <u>Position</u> is <u>next</u> it is semantically equivalent of
              calling <u>next/[1,2]</u> <u>N</u> times. If <u>Position</u> is <u>{relative,</u> <u>Pos}</u>, <u>Pos</u> will be used as an offset from the
              current cursor position to determine the first selected row. If <u>Position</u> is <u>{absolute,</u>  <u>Pos}</u>,  <u>Pos</u>
              will  be  the  number  of  the  first row selected. After this function has returned the cursor is
              positioned at the last selected row. If there is less then <u>N</u> rows  left  of  the  result  set  the
              length  of  <u>Rows</u> will be less than <u>N</u>. If the first row to select happens to be beyond the last row
              of the result set, the returned value will be <u>{selected,</u> <u>ColNames,[]}</u> e.i. the list of row  values
              is empty indicating that there is no more data to fetch.

</pre><h4><b>REFERENCES</b></h4><pre>
       [1]: Microsoft ODBC 3.0, Programmer's Reference and SDK Guide
       See also <a href="http://msdn.microsoft.com/">http://msdn.microsoft.com/</a>

Ericsson AB                                        odbc 2.13.5                                        <u><a href="../man3erl/odbc.3erl.html">odbc</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>