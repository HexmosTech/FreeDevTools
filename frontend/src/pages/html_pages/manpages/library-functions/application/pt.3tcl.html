<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pt - Parser Tools Application</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pt - Parser Tools Application

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       <b>pt</b> <b>generate</b> <u>resultformat</u> ?<u>options...</u>? <u>resultfile</u> <u>inputformat</u> <u>inputfile</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Are  you lost ?  Do you have trouble understanding this document ?  In that case please read the overview
       provided by the <u>Introduction</u> <u>to</u> <u>Parser</u> <u>Tools</u>. This document is the entrypoint to  the  whole  system  the
       current package is a part of.

       This document describes <b>pt</b>, the main application of the module, a <u>parser</u> <u>generator</u>. Its intended audience
       are  people  who  wish  to  create  a  parser  for some language of theirs. Should you wish to modify the
       application instead, please see the section about the application's <b>Internals</b> for the basic references.

       It resides in the User Application Layer of Parser Tools.

       IMAGE: arch_user_app

</pre><h4><b>COMMAND</b> <b>LINE</b></h4><pre>
       <b>pt</b> <b>generate</b> <u>resultformat</u> ?<u>options...</u>? <u>resultfile</u> <u>inputformat</u> <u>inputfile</u>
              This sub-command of the application reads the parsing expression grammar stored in  the  <u>inputfile</u>
              in  the  format  <u>inputformat</u>,  converts it to the <u>resultformat</u> under the direction of the (format-
              specific) set of options specified by the user and stores the result in the <u>resultfile</u>.

              The <u>inputfile</u> has to exist, while the <u>resultfile</u> may  be  created,  overwriting  any  pre-existing
              content of the file. Any missing directory in the path to the <u>resultfile</u> will be created as well.

              The  exact  form  of the result for, and the set of options supported by the known result-formats,
              are explained in the upcoming sections of this document, with the list below  providing  an  index
              mapping between format name and its associated section. In alphabetical order:

              <b>c</b>      A <u>resultformat</u>. See section <b>C</b> <b>Parser</b>.

              <b>container</b>
                     A <u>resultformat</u>. See section <b>Grammar</b> <b>Container</b>.

              <b>critcl</b> A <u>resultformat</u>. See section <b>C</b> <b>Parser</b> <b>Embedded</b> <b>In</b> <b>Tcl</b>.

              <b>json</b>   A <u>input</u>- and <u>resultformat</u>. See section <b>JSON</b> <b>Grammar</b> <b>Exchange</b>.

              <b>oo</b>     A <u>resultformat</u>. See section <b>TclOO</b> <b>Parser</b>.

              <b>peg</b>    A <u>input</u>- and <u>resultformat</u>. See section <b>PEG</b> <b>Specification</b> <b>Language</b>.

              <b>snit</b>   A <u>resultformat</u>. See section <b>Snit</b> <b>Parser</b>.

       Of  the  seven  possible  results  four  are  parsers outright (<b>c</b>, <b>critcl</b>, <b>oo</b>, and <b>snit</b>), one (<b>container</b>)
       provides code which can be  used  in  conjunction  with  a  generic  parser  (also  known  as  a  grammar
       interpreter),  and  the  last  two  (<b>json</b>  and  <b>peg</b>) are doing double-duty as input formats, allowing the
       transformation of grammars for exchange, reformatting, and the like.

       The created parsers fall into three categories:

       .nf + --- C ---&gt; critcl, c | + --- specialized -+ |                  | ---+                  + --- Tcl -&gt;
       snit, oo | + --- interpreted (Tcl) ------&gt; container .fi

       <b>Specialized</b> <b>parsers</b> <b>implemented</b> <b>in</b> <b>C</b>
              The fastest parsers are created when using the result formats <b>c</b> and <b>critcl</b>. The first returns  the
              raw C code for the parser, while the latter wraps it into a Tcl package using <u>CriTcl</u>.

              This  makes  the  latter  much easier to use than the former. On the other hand, the former can be
              adapted to the users' requirements through a multitude of options, allowing for things like  usage
              of  the  parser outside of a Tcl environment, something the <b>critcl</b> format doesn't support. As such
              the <b>c</b> format is meant for more advanced users, or users with special needs.

              A disadvantage of all the parsers in this section is the need to run them through a C compiler  to
              make  them  actually  executable.  This is not something everyone has the necessary tools for. The
              parsers in the next section are for people under such restrictions.

       <b>Specialized</b> <b>parsers</b> <b>implemented</b> <b>in</b> <b>Tcl</b>
              As the parsers in this section are implemented in Tcl they are quite a bit  slower  than  anything
              from the previous section. On the other hand this allows them to be used in pure-Tcl environments,
              or  in  environments which allow only a limited set of binary packages. In the latter case it will
              be advantageous to lobby for the inclusion of the C-based runtime support (notes below)  into  the
              environment to reduce the impact of Tcl's on the speed of these parsers.

              The  relevant  formats  are  <b>snit</b>  and <b>oo</b>. Both place their result into a Tcl package containing a
              <b>snit::type</b>, or TclOO <b>class</b> respectively.

              Of the supporting runtime, which is the package <b>pt::rde</b>, the user has to know nothing but that  it
              does  exist and that the parsers are dependent on it. Knowledge of the API exported by the runtime
              for the parsers' consumption is <u>not</u> required by the parsers' users.

       <b>Interpreted</b> <b>parsing</b> <b>implemented</b> <b>in</b> <b>Tcl</b>
              The last category, grammar interpretation. This means that an interpreter for  parsing  expression
              grammars  takes  the  description of the grammar to parse input for, and uses it guide the parsing
              process.  This is the slowest of the available options, as the interpreter has to continually  run
              through  the configured grammar, whereas the specialized parsers of the previous sections have the
              relevant knowledge about the grammar baked into them.

              The only places where using interpretation make sense is where the grammar for some input  may  be
              changed  interactively  by  the user, as the interpretation allows for quick turnaround after each
              change, whereas the previous methods require the generation of a whole new parser, which is not as
              fast.  On the other hand, wherever the grammar to use is fixed, the previous methods are much more
              advantageous as the time to generate the parser is minuscule compared to the time the parser  code
              is in use.

              The  relevant result format is <b>container</b>.  It (quickly) generates grammar descriptions (instead of
              a full parser) which match the API expected by ParserTools' grammar interpreter.   The  latter  is
              provided by the package <b>pt::peg::interp</b>.

       All  the  parsers  generated  by <b>critcl</b>, <b>snit</b>, and <b>oo</b>, and the grammar interpreter share a common API for
       access to the actual parsing functionality, making them all plug-compatible.   It  is  described  in  the
       <u>Parser</u> <u>API</u> specification document.

</pre><h4><b>PEG</b> <b>SPECIFICATION</b> <b>LANGUAGE</b></h4><pre>
       <b>peg</b>,  a  language for the specification of parsing expression grammars is meant to be human readable, and
       writable as well, yet strict enough to allow its processing by machine. Like any  computer  language.  It
       was defined to make writing the specification of a grammar easy, something the other formats found in the
       Parser Tools do not lend themselves too.

       For  either  an  introduction  to or the formal specification of the language, please go and read the <u>PEG</u>
       <u>Language</u> <u>Tutorial</u>.

       When used as a result-format this format supports the following options:

       <b>-file</b> string
              The value of this option is the name of the file or other entity from which the grammar came,  for
              which the command is run. The default value is <b>unknown</b>.

       <b>-name</b> string
              The  value  of  this  option  is  the name of the grammar we are processing.  The default value is
              <b>a_pe_grammar</b>.

       <b>-user</b> string
              The value of this option is the name of the user for which the command is run. The  default  value
              is <b>unknown</b>.

       <b>-template</b> string
              The  value  of  this option is a string into which to put the generated text and the values of the
              other options. The various  locations  for  user-data  are  expected  to  be  specified  with  the
              placeholders listed below. The default value is "<b>@code@</b>".

              <b>@user@</b> To be replaced with the value of the option <b>-user</b>.

              <b>@format@</b>
                     To be replaced with the the constant <b>PEG</b>.

              <b>@file@</b> To be replaced with the value of the option <b>-file</b>.

              <b>@name@</b> To be replaced with the value of the option <b>-name</b>.

              <b>@code@</b> To be replaced with the generated text.

</pre><h4><b>JSON</b> <b>GRAMMAR</b> <b>EXCHANGE</b></h4><pre>
       The  <b>json</b>  format for parsing expression grammars was written as a data exchange format not bound to Tcl.
       It was defined to allow the exchange of grammars with  PackRat/PEG  based  parser  generators  for  other
       languages.

       For  the  formal  specification  of the JSON grammar exchange format, please go and read <u>The</u> <u>JSON</u> <u>Grammar</u>
       <u>Exchange</u> <u>Format</u>.

       When used as a result-format this format supports the following options:

       <b>-file</b> string
              The value of this option is the name of the file or other entity from which the grammar came,  for
              which the command is run. The default value is <b>unknown</b>.

       <b>-name</b> string
              The  value  of  this  option  is  the name of the grammar we are processing.  The default value is
              <b>a_pe_grammar</b>.

       <b>-user</b> string
              The value of this option is the name of the user for which the command is run. The  default  value
              is <b>unknown</b>.

       <b>-indented</b> boolean
              If  this  option  is  set  the  system  will  break  the generated JSON across lines and indent it
              according to its inner structure, with each key of a dictionary on a separate line.

              If the option is not set (the default), the whole JSON object will be written on  a  single  line,
              with minimum spacing between all elements.

       <b>-aligned</b> boolean
              If  this  option  is  set  the system will ensure that the values for the keys in a dictionary are
              vertically aligned with each other, for a nice table effect.  To make this work this also  implies
              that <b>-indented</b> is set.

              If  the  option  is  not  set (the default), the output is formatted as per the value of <b>indented</b>,
              without trying to align the values for dictionary keys.

</pre><h4><b>C</b> <b>PARSER</b> <b>EMBEDDED</b> <b>IN</b> <b>TCL</b></h4><pre>
       The <b>critcl</b> format is executable code, a parser for the grammar. It is  a  Tcl  package  with  the  actual
       parser implementation written in C and embedded in Tcl via the <b>critcl</b> package.

       This result-format supports the following options:

       <b>-file</b> string
              The  value of this option is the name of the file or other entity from which the grammar came, for
              which the command is run. The default value is <b>unknown</b>.

       <b>-name</b> string
              The value of this option is the name of the grammar we  are  processing.   The  default  value  is
              <b>a_pe_grammar</b>.

       <b>-user</b> string
              The  value  of this option is the name of the user for which the command is run. The default value
              is <b>unknown</b>.

       <b>-class</b> string
              The value of this option is the name of the  class  to  generate,  without  leading  colons.   The
              default value is <b>CLASS</b>.

              For  a  simple  value <b>X</b> without colons, like CLASS, the parser command will be <b>X</b>::<b>X</b>. Whereas for a
              namespaced value <b>X::Y</b> the parser command will be <b>X::Y</b>.

       <b>-package</b> string
              The value of this option is the name of the package to generate.  The default value is <b>PACKAGE</b>.

       <b>-version</b> string
              The value of this option is the version of the package to generate.  The default value is <b>1</b>.

</pre><h4><b>C</b> <b>PARSER</b></h4><pre>
       The <b>c</b> format is executable code, a parser for the grammar. The parser implementation is written in C  and
       can be tweaked to the users' needs through a multitude of options.

       The  <b>critcl</b>  format, for example, is implemented as a canned configuration of these options on top of the
       generator for <b>c</b>.

       This result-format supports the following options:

       <b>-file</b> string
              The value of this option is the name of the file or other entity from which the grammar came,  for
              which the command is run. The default value is <b>unknown</b>.

       <b>-name</b> string
              The  value  of  this  option  is  the name of the grammar we are processing.  The default value is
              <b>a_pe_grammar</b>.

       <b>-user</b> string
              The value of this option is the name of the user for which the command is run. The  default  value
              is <b>unknown</b>.

       <b>-template</b> string
              The  value  of  this  option  is  a  string  into  which  to  put the generated text and the other
              configuration settings. The various locations for user-data are expected to be specified with  the
              placeholders listed below. The default value is "<b>@code@</b>".

              <b>@user@</b> To be replaced with the value of the option <b>-user</b>.

              <b>@format@</b>
                     To be replaced with the the constant <b>C/PARAM</b>.

              <b>@file@</b> To be replaced with the value of the option <b>-file</b>.

              <b>@name@</b> To be replaced with the value of the option <b>-name</b>.

              <b>@code@</b> To be replaced with the generated Tcl code.

              The  following  options  are  special,  in that they will occur within the generated code, and are
              replaced there as well.

              <b>@statedecl@</b>
                     To be replaced with the value of the option <b>state-decl</b>.

              <b>@stateref@</b>
                     To be replaced with the value of the option <b>state-ref</b>.

              <b>@strings@</b>
                     To be replaced with the value of the option <b>string-varname</b>.

              <b>@self@</b> To be replaced with the value of the option <b>self-command</b>.

              <b>@def@</b>  To be replaced with the value of the option <b>fun-qualifier</b>.

              <b>@ns@</b>   To be replaced with the value of the option <b>namespace</b>.

              <b>@main@</b> To be replaced with the value of the option <b>main</b>.

              <b>@prelude@</b>
                     To be replaced with the value of the option <b>prelude</b>.

       <b>-state-decl</b> string
              A C string representing the argument declaration to use in  the  generated  parsing  functions  to
              refer  to  the  parsing state. In essence type and argument name.  The default value is the string
              <b>RDE_PARAM</b> <b>p</b>.

       <b>-state-ref</b> string
              A C string representing the argument named used in the generated parsing functions to refer to the
              parsing state.  The default value is the string <b>p</b>.

       <b>-self-command</b> string
              A C string representing the reference needed to call the generated parser function  (methods  ...)
              from another parser fonction, per the chosen framework (template).  The default value is the empty
              string.

       <b>-fun-qualifier</b> string
              A  C  string  containing  the attributes to give to the generated functions (methods ...), per the
              chosen framework (template).  The default value is <b>static</b>.

       <b>-namespace</b> string
              The name of the C namespace the parser functions (methods, ...) shall  reside  in,  or  a  general
              prefix to add to the function names.  The default value is the empty string.

       <b>-main</b> string
              The  name  of  the  main function (method, ...) to be called by the chosen framework (template) to
              start parsing input.  The default value is <b>__main</b>.

       <b>-string-varname</b> string
              The name of the variable used for the table of strings used by the generated  parser,  i.e.  error
              messages, symbol names, etc.  The default value is <b>p_string</b>.

       <b>-prelude</b> string
              A  snippet  of  code  to  be inserted at the head of each generated parsing function.  The default
              value is the empty string.

       <b>-indent</b> integer
              The number of characters to indent each line of the generated code by.  The default value is <b>0</b>.

       <b>-comments</b> boolean
              A flag controlling the generation of code comments containing the original  parsing  expression  a
              parsing function is for.  The default value is <b>on</b>.

</pre><h4><b>SNIT</b> <b>PARSER</b></h4><pre>
       The  <b>snit</b>  format is executable code, a parser for the grammar. It is a Tcl package holding a <b>snit::type</b>,
       i.e. a class, whose instances are parsers for the input grammar.

       This result-format supports the following options:

       <b>-file</b> string
              The value of this option is the name of the file or other entity from which the grammar came,  for
              which the command is run. The default value is <b>unknown</b>.

       <b>-name</b> string
              The  value  of  this  option  is  the name of the grammar we are processing.  The default value is
              <b>a_pe_grammar</b>.

       <b>-user</b> string
              The value of this option is the name of the user for which the command is run. The  default  value
              is <b>unknown</b>.

       <b>-class</b> string
              The  value  of  this option is the name of the class to generate, without leading colons. Note, it
              serves double-duty as the name of  the  package  to  generate  too,  if  option  <b>-package</b>  is  not
              specified,  see below.  The default value is <b>CLASS</b>, applying if neither option <b>-class</b> nor <b>-package</b>
              were specified.

       <b>-package</b> string
              The value of this option is the name of the package to generate, without leading colons. Note,  it
              serves  double-duty  as  the name of the class to generate too, if option <b>-class</b> is not specified,
              see above.  The default value is <b>PACKAGE</b>, applying if neither  option  <b>-package</b>  nor  <b>-class</b>  were
              specified.

       <b>-version</b> string
              The value of this option is the version of the package to generate.  The default value is <b>1</b>.

</pre><h4><b>TCLOO</b> <b>PARSER</b></h4><pre>
       The  <b>oo</b>  format  is executable code, a parser for the grammar. It is a Tcl package holding a <b>TclOO</b> class,
       whose instances are parsers for the input grammar.

       This result-format supports the following options:

       <b>-file</b> string
              The value of this option is the name of the file or other entity from which the grammar came,  for
              which the command is run. The default value is <b>unknown</b>.

       <b>-name</b> string
              The  value  of  this  option  is  the name of the grammar we are processing.  The default value is
              <b>a_pe_grammar</b>.

       <b>-user</b> string
              The value of this option is the name of the user for which the command is run. The  default  value
              is <b>unknown</b>.

       <b>-class</b> string
              The  value  of  this option is the name of the class to generate, without leading colons. Note, it
              serves double-duty as the name of  the  package  to  generate  too,  if  option  <b>-package</b>  is  not
              specified,  see below.  The default value is <b>CLASS</b>, applying if neither option <b>-class</b> nor <b>-package</b>
              were specified.

       <b>-package</b> string
              The value of this option is the name of the package to generate, without leading colons. Note,  it
              serves  double-duty  as  the name of the class to generate too, if option <b>-class</b> is not specified,
              see above.  The default value is <b>PACKAGE</b>, applying if neither  option  <b>-package</b>  nor  <b>-class</b>  were
              specified.

       <b>-version</b> string
              The value of this option is the version of the package to generate.  The default value is <b>1</b>.

</pre><h4><b>GRAMMAR</b> <b>CONTAINER</b></h4><pre>
       The <b>container</b> format is another form of describing parsing expression grammars. While data in this format
       is  executable  it  does not constitute a parser for the grammar. It always has to be used in conjunction
       with the package <b>pt::peg::interp</b>, a grammar interpreter.

       The format represents grammars by a <b>snit::type</b>, i.e. class, whose instances  are  API-compatible  to  the
       instances of the <b>pt::peg::container</b> package, and which are preloaded with the grammar in question.

       This result-format supports the following options:

       <b>-file</b> string
              The  value of this option is the name of the file or other entity from which the grammar came, for
              which the command is run. The default value is <b>unknown</b>.

       <b>-name</b> string
              The value of this option is the name of the grammar we  are  processing.   The  default  value  is
              <b>a_pe_grammar</b>.

       <b>-user</b> string
              The  value  of this option is the name of the user for which the command is run. The default value
              is <b>unknown</b>.

       <b>-mode</b> <b>bulk</b>|<b>incremental</b>
              The value of this option controls which  methods  of  <b>pt::peg::container</b>  instances  are  used  to
              specify  the  grammar,  i.e.  preload it into the container. There are two legal values, as listed
              below. The default is <b>bulk</b>.

              <b>bulk</b>   In this mode the methods <b>start</b>, <b>add</b>, <b>modes</b>, and <b>rules</b> are used to specify the grammar in  a
                     bulk  manner,  i.e.  as a set of nonterminal symbols, and two dictionaries mapping from the
                     symbols to their semantic modes and parsing expressions.

                     This mode is the default.

              <b>incremental</b>
                     In this mode the methods <b>start</b>, <b>add</b>, <b>mode</b>,  and  <b>rule</b>  are  used  to  specify  the  grammar
                     piecemal, with each nonterminal having its own block of defining commands.

       <b>-template</b> string
              The  value  of  this  option  is  a  string  into  which  to  put the generated code and the other
              configuration settings. The various locations for user-data are expected to be specified with  the
              placeholders listed below. The default value is "<b>@code@</b>".

              <b>@user@</b> To be replaced with the value of the option <b>-user</b>.

              <b>@format@</b>
                     To be replaced with the the constant <b>CONTAINER</b>.

              <b>@file@</b> To be replaced with the value of the option <b>-file</b>.

              <b>@name@</b> To be replaced with the value of the option <b>-name</b>.

              <b>@mode@</b> To be replaced with the value of the option <b>-mode</b>.

              <b>@code@</b> To be replaced with the generated code.

</pre><h4><b>EXAMPLE</b></h4><pre>
       In  this  section  we are working a complete example, starting with a PEG grammar and ending with running
       the parser generated from it over some input, following the outline shown in the figure below:

       IMAGE: flow

       Our grammar, assumed to the stored in the file "<u>calculator.peg</u>" is

              PEG calculator (Expression)
                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'       ;
                  Sign       &lt;- '-' / '+'                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- '*' / '/'                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- '+'/'-'                                       ;
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

       From this we create a snit-based parser via

              pt generate snit calculator.tcl -class calculator -name calculator peg calculator.peg

       which leaves us with the parser package and class written to the file  "<u>calculator.tcl</u>".   Assuming  that
       this  package is then properly installed in a place where Tcl can find it we can now use this class via a
       script like

                  package require calculator

                  lassign $argv input
                  set channel [open $input r]

                  set parser [calculator]
                  set ast [$parser parse $channel]
                  $parser destroy
                  close $channel

                  ... now process the returned abstract syntax tree ...

       where the abstract syntax tree stored in the variable will look like

              set ast {Expression 0 4
                  {Factor 0 4
                      {Term 0 2
                          {Number 0 2
                              {Digit 0 0}
                              {Digit 1 1}
                              {Digit 2 2}
                          }
                      }
                      {AddOp 3 3}
                      {Term 4 4
                          {Number 4 4
                              {Digit 4 4}
                          }
                      }
                  }
              }

       assuming that the input file and channel contained the text

               120+5
       A more graphical representation of the tree would be

       .nf  +-  Digit  0  0  |  1  |             |  +-  Term  0  2  ---  Number  0  2  -+-  Digit  1  1  |  2  |
       |             |  |                            +- Digit 2 2 | 0 |                                        |
       Expression   0   4   ---   Factor   0   4   -+-----------------------------   AddOp   3   3   |    +    |
       | +- Term 4 4 --- Number 4 4 --- Digit 4 4 | 5 .fi

       Regardless,  at  this  point it is the user's responsibility to work with the tree to reach whatever goal
       she desires. I.e. analyze it, transform it, etc. The package <b>pt::ast</b> should be of  help  here,  providing
       commands to walk such ASTs structures in various ways.

       One  important  thing  to  note  is  that  the parsers used here return a data structure representing the
       structure of the input per the grammar underlying the parser. There are <u>no</u> callbacks during  the  parsing
       process, i.e. no <u>parsing</u> <u>actions</u>, as most other parsers will have.

       Going  back  to the last snippet of code, the execution of the parser for some input, note how the parser
       instance follows the specified <u>Parser</u> <u>API</u>.

</pre><h4><b>INTERNALS</b></h4><pre>
       This section is intended for users of the application which wish to  modify  or  extend  it.  Users  only
       interested in the generation of parsers can ignore it.

       The  main  functionality  of  the application is encapsulated in the package <b>pt::pgen</b>. Please read it for
       more information.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category <u>pt</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       EBNF,  LL(k),  PEG,  TDPL,  context-free  languages,  expression,  grammar,  matching,  parser,   parsing
       expression,  parsing  expression grammar, push down automaton, recursive descent, state, top-down parsing
       languages, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Parsing and Grammars

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                  1                                               <u><a href="../man3tcl/pt.3tcl.html">pt</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>