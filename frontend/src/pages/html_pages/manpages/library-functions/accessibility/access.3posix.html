<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       access, faccessat — determine accessibility of a file descriptor

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       int access(const char *<u>path</u>, int <u>amode</u>);

       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;

       int faccessat(int <u>fd</u>, const char *<u>path</u>, int <u>amode</u>, int <u>flag</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>access</u>()  function  shall  check  the file named by the pathname pointed to by the <u>path</u> argument for
       accessibility according to the bit pattern contained in <u>amode</u>.  The checks for  accessibility  (including
       directory  permissions  checked  during pathname resolution) shall be performed using the real user ID in
       place of the effective user ID and the real group ID in place of the effective group ID.

       The value of <u>amode</u> is either the bitwise-inclusive OR of the access  permissions  to  be  checked  (R_OK,
       W_OK, X_OK) or the existence test (F_OK).

       If  any  access  permissions  are  checked,  each shall be checked individually, as described in the Base
       Definitions volume of POSIX.1‐2017,  <u>Section</u>  <u>4.5</u>,  <u>File</u>  <u>Access</u>  <u>Permissions</u>,  except  that  where  that
       description refers to execute permission for a process with appropriate privileges, an implementation may
       indicate success for X_OK even if execute permission is not granted to any user.

       The  <u>faccessat</u>()  function,  when  called  with a <u>flag</u> value of zero, shall be equivalent to the <u>access</u>()
       function, except in the case where  <u>path</u>  specifies  a  relative  path.  In  this  case  the  file  whose
       accessibility  is  to  be  determined shall be located relative to the directory associated with the file
       descriptor <u>fd</u> instead of the current working directory.  If the access mode of the open file  description
       associated  with the file descriptor is not O_SEARCH, the function shall check whether directory searches
       are permitted using the current permissions of the directory underlying  the  file  descriptor.   If  the
       access mode is O_SEARCH, the function shall not perform the check.

       If  <u>faccessat</u>()  is  passed the special value AT_FDCWD in the <u>fd</u> parameter, the current working directory
       shall be used and, if flag is zero, the behavior shall be identical to a call to <u>access</u>().

       Values for <u>flag</u> are constructed by a bitwise-inclusive OR of flags from the following  list,  defined  in
       <u>&lt;fcntl.h&gt;</u>:

       AT_EACCESS  The  checks  for  accessibility  (including  directory  permissions  checked  during pathname
                   resolution) shall be performed using the effective user ID and group ID instead of  the  real
                   user ID and group ID as required in a call to <u>access</u>().

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon  successful  completion,  these functions shall return 0. Otherwise, these functions shall return -1
       and set <u>errno</u> to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       These functions shall fail if:

       <b>EACCES</b> Permission bits of the file mode do not permit the  requested  access,  or  search  permission  is
              denied on a component of the path prefix.

       <b>ELOOP</b>  A loop exists in symbolic links encountered during resolution of the <u>path</u> argument.

       <b>ENAMETOOLONG</b>
              The length of a component of a pathname is longer than {NAME_MAX}.

       <b>ENOENT</b> A component of <u>path</u> does not name an existing file or <u>path</u> is an empty string.

       <b>ENOTDIR</b>
              A  component  of the path prefix names an existing file that is neither a directory nor a symbolic
              link to a directory, or the <u>path</u> argument contains at least one  non-&lt;slash&gt;  character  and  ends
              with  one  or  more  trailing &lt;slash&gt; characters and the last pathname component names an existing
              file that is neither a directory nor a symbolic link to a directory.

       <b>EROFS</b>  Write access is requested for a file on a read-only file system.

       The <u>faccessat</u>() function shall fail if:

       <b>EACCES</b> The access mode of the  open  file  description  associated  with  <u>fd</u>  is  not  O_SEARCH  and  the
              permissions of the directory underlying <u>fd</u> do not permit directory searches.

       <b>EBADF</b>  The  <u>path</u> argument does not specify an absolute path and the <u>fd</u> argument is neither AT_FDCWD nor a
              valid file descriptor open for reading or searching.

       <b>ENOTDIR</b>
              The <u>path</u> argument is not an absolute path and <u>fd</u> is a  file  descriptor  associated  with  a  non-
              directory file.

       These functions may fail if:

       <b>EINVAL</b> The value of the <u>amode</u> argument is invalid.

       <b>ELOOP</b>  More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the <u>path</u> argument.

       <b>ENAMETOOLONG</b>
              The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an
              intermediate result with a length that exceeds {PATH_MAX}.

       <b>ETXTBSY</b>
              Write access is requested for a pure procedure (shared text) file that is being executed.

       The <u>faccessat</u>() function may fail if:

       <b>EINVAL</b> The value of the <u>flag</u> argument is not valid.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Testing</b> <b>for</b> <b>the</b> <b>Existence</b> <b>of</b> <b>a</b> <b>File</b>
       The following example tests whether a file named <b>myfile</b> exists in the <b><a href="file:/tmp">/tmp</a></b> directory.

           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           ...
           int result;
           const char *pathname = "/tmp/myfile";

           result = access (pathname, F_OK);

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       Use  of  these  functions  is discouraged since by the time the returned information is acted upon, it is
       out-of-date. (That is, acting upon the information always leads to  a  time-of-check-to-time-of-use  race
       condition.)  An  application  should instead attempt the action itself and handle the <b>[EACCES]</b> error that
       occurs if the file is not accessible (with a change of effective  user  and  group  IDs  beforehand,  and
       perhaps  a change back afterwards, in the case where <u>access</u>() or <u>faccessat</u>() without AT_EACCES would have
       been used.)

       Historically, one of the uses of <u>access</u>() was in set-user-ID root programs  to  check  whether  the  user
       running  the  program  had  access to a file. This relied on ``super-user'' privileges which were granted
       based on the effective user ID being zero, so  that  when  <u>access</u>()  used  the  real  user  ID  to  check
       accessibility  those  privileges  were  not  taken into account. On newer systems where privileges can be
       assigned which have no association with user or group IDs,  if  a  program  with  such  privileges  calls
       <u>access</u>(),  the change of IDs has no effect on the privileges and therefore they are taken into account in
       the accessibility checks. Thus, <u>access</u>() (and <u>faccessat</u>()  with  flag  zero)  cannot  be  used  for  this
       historical  purpose  in  such  programs.  Likewise, if a system provides any additional or alternate file
       access control mechanisms that are not user ID-based, they will still be taken into account.

       If a relative pathname is used, no account is taken of whether the current directory  (or  the  directory
       associated  with  the  file  descriptor  <u>fd</u>)  is accessible via any absolute pathname. Applications using
       <u>access</u>(), or <u>faccessat</u>() without AT_EACCES, may consequently act as if the file would be accessible to  a
       user  with the real user ID and group ID of the process when such a user would not in practice be able to
       access the file because access would be denied  at  some  point  above  the  current  directory  (or  the
       directory associated with the file descriptor <u>fd</u>) in the file hierarchy.

       If  <u>access</u>()  or  <u>faccessat</u>()  is  used  with W_OK to check for write access to a directory which has the
       S_ISVTX bit set, a return value indicating the  directory  is  writable  can  be  misleading  since  some
       operations  on  files  in the directory would not be permitted based on the ownership of those files (see
       the Base Definitions volume of POSIX.1‐2017, <u>Section</u> <u>4.3</u>, <u>Directory</u> <u>Protection</u>).

       Additional values of <u>amode</u> other than the set defined in the description may be valid; for example, if  a
       system has extended access controls.

       The use of the AT_EACCESS value for <u>flag</u> enables functionality not available in <u>access</u>().

</pre><h4><b>RATIONALE</b></h4><pre>
       In  early  proposals,  some  inadequacies  in  the  <u>access</u>() function led to the creation of an <u>eaccess</u>()
       function because:

        1. Historical implementations of <u>access</u>() do not test file access correctly when the process' real  user
           ID  is  superuser.  In  particular,  they always return zero when testing execute permissions without
           regard to whether the file is executable.

        2. The superuser has complete access to all files on a system. As a consequence, programs started by the
           superuser and switched to the effective user ID with lesser privileges cannot use  <u>access</u>()  to  test
           their file access permissions.

       However,  the  historical model of <u>eaccess</u>() does not resolve problem (1), so this volume of POSIX.1‐2017
       now allows <u>access</u>() to behave in the desired way  because  several  implementations  have  corrected  the
       problem.  It  was  also argued that problem (2) is more easily solved by using <u>open</u>(), <u>chdir</u>(), or one of
       the <u>exec</u> functions as appropriate and responding to the error, rather than creating a new  function  that
       would not be as reliable. Therefore, <u>eaccess</u>() is not included in this volume of POSIX.1‐2017.

       The sentence concerning appropriate privileges and execute permission bits reflects the two possibilities
       implemented by historical implementations when checking superuser access for X_OK.

       New  implementations  are discouraged from returning X_OK unless at least one execution permission bit is
       set.

       The purpose of the <u>faccessat</u>() function is to enable the  checking  of  the  accessibility  of  files  in
       directories other than the current working directory without exposure to race conditions. Any part of the
       path  of a file could be changed in parallel to a call to <u>access</u>(), resulting in unspecified behavior. By
       opening a file descriptor for the  target  directory  and  using  the  <u>faccessat</u>()  function  it  can  be
       guaranteed that the file tested for accessibility is located relative to the desired directory.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       These  functions may be formally deprecated (for example, by shading them OB) in a future version of this
       standard.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>chmod</u>(), <u>fstatat</u>()

       The Base Definitions volume of POSIX.1‐2017, <u>Section</u> <u>4.5</u>, <u>File</u> <u>Access</u> <u>Permissions</u>, <b>&lt;fcntl.h&gt;</b>, <b>&lt;unistd.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                        <u><a href="../man3POSIX/ACCESS.3POSIX.html">ACCESS</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>