<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wiki::Toolkit::Formatter::UseMod - UseModWiki-style formatting for Wiki::Toolkit</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libwiki-toolkit-formatter-usemod-perl">libwiki-toolkit-formatter-usemod-perl_0.25-1.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Wiki::Toolkit::Formatter::UseMod - UseModWiki-style formatting for Wiki::Toolkit

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A formatter backend for Wiki::Toolkit that supports UseMod-style formatting.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Wiki::Toolkit::Formatter::UseMod;

         # Instantiate - see below for parameter details.
         my $formatter = Wiki::Toolkit::Formatter::UseMod-&gt;new( %config );

         # Format some text.
         my $cooked = $formatter-&gt;format($raw);

         # Find out which other nodes that text would link to.
         my @links_to = $formatter-&gt;find_internal_links($raw);

</pre><h4><b>METHODS</b></h4><pre>
       <b>new</b>
             my $formatter = Wiki::Toolkit::Formatter::UseMod-&gt;new(
                            extended_links      =&gt; 0, # $FreeLinks
                            implicit_links      =&gt; 1, # $WikiLinks
                            force_ucfirst_nodes =&gt; 1, # $FreeUpper
                            use_headings        =&gt; 1, # $UseHeadings
                            allowed_tags        =&gt; [qw(b i)], # defaults to none
                            macros              =&gt; {},
                            pass_wiki_to_macros =&gt; 0,
                            node_prefix         =&gt; 'wiki.pl?',
                            node_suffix         =&gt; '',
                            edit_prefix         =&gt; 'wiki.pl?action=edit;id=',
                            edit_suffix         =&gt; '',
                            munge_urls          =&gt; 0,
                            external_link_class =&gt; 'external',
                            escape_url_commas   =&gt; 1,
             );

           Parameters  will  default  to  the  values  shown above (apart from "allowed_tags", which defaults to
           allowing no tags, and "external_link_class", which defaults to false).

           <b>Internal</b> <b>links</b>
               "node_prefix", "node_suffix", "edit_prefix" and "edit_suffix"  allow  you  to  control  the  URLs
               generated for links to other wiki pages.  So for example with the defaults given above, a link to
               the Home node will have the URL "wiki.pl?Home" and a link to the edit form for the Home node will
               have the URL "wiki.pl?action=edit;id=Home"

               (Note  that  of  course  the  URLs  that  you wish to have generated will depend on how your wiki
               application processes its CGI parameters - you can't just put random stuff in there and  hope  it
               works!)

               By  default,  any commas in these URLs will be escaped to %2C, in line with the default behaviour
               of URI::Escape.  If you don't want this to happen, pass a false value to "escape_url_commas".

           <b>Internal</b> <b>links</b> <b>-</b> <b>advanced</b> <b>options</b>
               If you wish to have greater control over the links, you may use the "munge_node_name"  parameter.
               The  value  of  this  should be a subroutine reference.  This sub will be called on each internal
               link after all other formatting and munging <u>except</u> URL escaping has been  applied.   It  will  be
               passed  the  node name as its first parameter and should return a node name.  Note that this will
               affect the URLs of internal links, but not the link text.

               Example:

                 # The formatter munges links so node names are ucfirst.
                 # Ensure 'state51' always appears in lower case in node names.
                 munge_node_name =&gt; sub {
                                        my $node_name = shift;
                                        $node_name =~ s/State51/state51/g;
                                        return $node_name;
                                    }

               <b>Note:</b> This is <u>advanced</u> usage and you should only do it if you  <u>really</u>  know  what  you're  doing.
               Consider  in  particular  whether  and  how  your  munged  nodes  are  going  to  be  treated  by
               "retrieve_node".

           <b>External</b> <b>links</b>
               By default, we emulate the UseModWiki behaviour  of  formatting  external  links  with  hardcoded
               square  brackets  around  them.  If you would instead prefer to control this with CSS, supply the
               "external_link_class" parameter to "-&gt;new" - the value of this parameter  will  be  used  as  the
               class  applied  to the link (so it should be a valid CSS class name).  Controlling the appearance
               with CSS is our recommended method, but the default is  as  described  for  reasons  of  backward
               compatibility.

           <b>URL</b> <b>munging</b>
               If you set "munge_urls" to true, then your URLs will be more user-friendly, for example

                 <a href="http://example.com/wiki.cgi">http://example.com/wiki.cgi</a>?Mailing_List_Managers

               rather than

                 <a href="http://example.com/wiki.cgi">http://example.com/wiki.cgi</a>?Mailing%20List%20Managers

               The former behaviour is the actual UseMod behaviour, but requires a little fiddling about in your
               code (see "node_name_to_node_param"), so the default is to <b>not</b> munge URLs.

           <b>Macros</b>
               Be  aware  that  macros  are  processed  <u>after</u>  filtering  out  disallowed  HTML  tags and <u>before</u>
               transforming from wiki markup into HTML.  They are also not called in any particular order.

               The keys of macros should be either regexes or strings. The values can be  strings,  or,  if  the
               corresponding  key  is  a regex, can be coderefs.  The coderef will be called with the first nine
               substrings captured by the regex as arguments.  I  would  like  to  call  it  with  all  captured
               substrings but apparently this is complicated.

               You  may wish to have access to the overall wiki object in the subs defined in your macro.  To do
               this:

               •   Pass the wiki object to the "-&gt;formatter" call as described below.

               •   Pass a true value in the "pass_wiki_to_macros" parameter when calling "-&gt;new".

               If you do this, then <u>all</u> coderefs will be called with the wiki object  as  the  first  parameter,
               followed  by  the first nine captured substrings as described above.  Note therefore that setting
               "pass_wiki_to_macros" may cause backwards compatibility issues.

           Macro examples:

             # Simple example - substitute a little search box for '@SEARCHBOX'

             macros =&gt; {

                 '@SEARCHBOX' =&gt;
                           qq(&lt;form action="wiki.pl" method="get"&gt;
                              &lt;input type="hidden" name="action" value="search"&gt;
                              &lt;input type="text" size="20" name="terms"&gt;
                              &lt;input type="submit"&gt;&lt;/form&gt;),
             }

             # More complex example - substitute a list of all nodes in a
             # category for '@INDEX_LINK [[Category Foo]]'

             pass_wiki_to_macros =&gt; 1,
             macros              =&gt; {
                 qr/\@INDEX_LINK\s+\[\[Category\s+([^\]]+)]]/ =&gt;
                     sub {
                           my ($wiki, $category) = @_;
                           my @nodes = $wiki-&gt;list_nodes_by_metadata(
                                   metadata_type  =&gt; "category",
                                   metadata_value =&gt; $category,
                                   ignore_case    =&gt; 1,
                           );
                           my $return = "\n";
                           foreach my $node ( @nodes ) {
                               $return .= "* "
                                       . $wiki-&gt;formatter-&gt;format_link(
                                                                  wiki =&gt; $wiki,
                                                                  link =&gt; $node,
                                                                      )
                                       . "\n";
                            }
                            return $return;
                          },
             }

       <b>format</b>
             my $html = $formatter-&gt;format($submitted_content, $wiki);

           Escapes any tags which weren't specified as allowed on creation, then interpolates any  macros,  then
           translates the raw Wiki language supplied into HTML.

           A  Wiki::Toolkit object can be supplied as an optional second parameter.  This object will be used to
           determine whether a linked-to node exists or not, and alter the presentation of the link accordingly.
           This is only really in here for use when this method is being called from within Wiki::Toolkit.

       <b>format_link</b>
             my $string = $formatter-&gt;format_link(
                                                   link =&gt; "Home Node",
                                                   wiki =&gt; $wiki,
                                                 );

           An internal method exposed to make it easy to go from eg

             * Foo
             * Bar

           to

             * &lt;a href="index.cgi?Foo"&gt;Foo&lt;/a&gt;
             * &lt;a href="index.cgi?Bar"&gt;Bar&lt;/a&gt;

           See Macro Examples above for why you might find this useful.

           "link" should be something that would go inside your extended link delimiters.   "wiki"  is  optional
           but  should be a Wiki::Toolkit object.  If you do supply "wiki" then the method will be able to check
           whether  the  node  exists  yet  or  not   and   so   will   call   "-&gt;make_edit_link"   instead   of
           "-&gt;make_internal_link"  where  appropriate.   If  you don't supply "wiki" then "-&gt;make_internal_link"
           will be called always.

           This method used to be private so may do unexpected things if you use it in  a  way  that  I  haven't
           tested yet.

       <b>find_internal_links</b>
             my @links_to = $formatter-&gt;find_internal_links( $content );

           Returns a list of all nodes that the supplied content links to.

       <b>node_name_to_node_param</b>
             use URI::Escape;
             $param = $formatter-&gt;node_name_to_node_param( "Recent Changes" );
             my $url = "wiki.pl?" . uri_escape($param);

           In  usemod,  the  node  name is encoded prior to being used as part of the URL. This method does this
           encoding (essentially, whitespace is munged into underscores). In addition, if  "force_ucfirst_nodes"
           is in action then the node names will be forced ucfirst if they weren't already.

           Note that unless "munge_urls" was set to true when "new" was called, this method will do nothing.

       <b>node_param_to_node_name</b>
             my $node = $q-&gt;param('node') || "";
             $node = $formatter-&gt;node_param_to_node_name( $node );

           In  usemod,  the  node  name  is encoded prior to being used as part of the URL, so we must decode it
           before we can get back the original node name.

           Note that unless "munge_urls" was set to true when "new" was called, this method will do nothing.

</pre><h4><b>SUBCLASSING</b></h4><pre>
       The following methods can be overridden to provide custom behaviour.

       <b>make_edit_link</b>
               my $link = $self-&gt;make_edit_link(
                   title =&gt; "Home Page",
                   url   =&gt; "<a href="http://example.com/">http://example.com/</a>?id=Home",
                                              );

           This method will be passed a title and a url and should return an HTML snippet.  For example, you can
           add a "title" attribute to the link like so:

             sub make_edit_link {
                 my ($self, %args) = @_;
                 my $title = $args{title};
                 my $url = $args{url};
                 return qq|[$title]&lt;a href="$url" title="create"&gt;?&lt;/a&gt;|;
             }

       <b>make_internal_link</b>
               my $link = $self-&gt;make_internal_link(
                   title =&gt; "Home Page",
                   url   =&gt; "<a href="http://example.com/">http://example.com/</a>?id=Home",
                                                   );

           This method will be passed a title and a url and should return an HTML snippet.  For example, you can
           add a "class" attribute to the link like so:

             sub make_internal_link {
                 my ($self, %args) = @_;
                 my $title = $args{title};
                 my $url = $args{url};
                 return qq|&lt;a href="$url" class="internal"&gt;$title&lt;/a&gt;|;
             }

       <b>make_external_link</b>
               my $link = $self-&gt;make_external_link(
                   title =&gt; "London Perlmongers",
                   url   =&gt; "<a href="http://london.pm.org">http://london.pm.org</a>",
                                                   );

           This method will be passed a title and a url and should return an HTML snippet.  For example, you can
           add a little icon after each external link like so:

             sub make_external_link {
                 my ($self, %args) = @_;
                 my $title = $args{title};
                 my $url = $args{url};
                 return qq|&lt;a href="$url"&gt;$title&lt;/a&gt; &lt;img src="external.gif"&gt;|;
             }

</pre><h4><b>AUTHOR</b></h4><pre>
       Kake Pugh (<a href="mailto:kake@earth.li">kake@earth.li</a>) and the Wiki::Toolkit team.

</pre><h4><b>COPYRIGHT</b></h4><pre>
            Copyright (C) 2003-2004 Kake Pugh.  All Rights Reserved.
            Copyright (C) 2006-2012 the Wiki::Toolkit team. All Rights Reserved.

       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself.

</pre><h4><b>CREDITS</b></h4><pre>
       The OpenGuides London team (&lt;<a href="http://openguides.org/london/">http://openguides.org/london/</a>&gt;) sent some very helpful bug reports. A lot of
       the work of this module is done within chromatic's module, Text::WikiFormat.

</pre><h4><b>CAVEATS</b></h4><pre>
       This  doesn't  yet  support  all  of UseMod's formatting features and options, by any means.  This really
       truly <u>is</u> a 0.* release. Please send bug reports, omissions, patches, and stuff, to me at "<a href="mailto:kake@earth.li">kake@earth.li</a>".

</pre><h4><b>NOTE</b> <b>ON</b> <b>USEMOD</b> <b>COMPATIBILITY</b></h4><pre>
       UseModWiki "encodes" node names before making them part of a URL, so for  example  a  node  about  Wombat
       Defenestration will have a URL like

         <a href="http://example.com/wiki.cgi">http://example.com/wiki.cgi</a>?Wombat_Defenestration

       So  if  we  want  to  emulate a UseModWiki exactly, we need to munge back and forth between node names as
       titles, and node names as CGI params.

         my $formatter = Wiki::Toolkit::Formatter::UseMod-&gt;new( munge_urls =&gt; 1 );
         my $node_param = $q-&gt;param('id') || $q-&gt;param('keywords') || "";
         my $node_name = $formatter-&gt;node_param_to_node_name( $node_param );

         use URI::Escape;
         my $url = "<a href="http://example.com/wiki.cgi">http://example.com/wiki.cgi</a>?"
           . uri_escape(
              $formatter-&gt;node_name_to_node_param( "Wombat Defenestration" )
                        );

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   Wiki::Toolkit

       •   Text::WikiFormat

       •   UseModWiki (&lt;<a href="http://www.usemod.com/cgi-bin/wiki.pl">http://www.usemod.com/cgi-bin/wiki.pl</a>&gt;)

perl v5.34.0                                       2022-06-14              <u>Wiki::Toolkit::Formatter::<a href="../man3pm/UseMod.3pm.html">UseMod</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>