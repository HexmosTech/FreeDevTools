<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PPI::Structure - The base class for Perl braced structures</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libppi-perl">libppi-perl_1.281-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PPI::Structure - The base class for Perl braced structures

</pre><h4><b>INHERITANCE</b></h4><pre>
         PPI::Structure
         isa PPI::Node
             isa PPI::Element

</pre><h4><b>DESCRIPTION</b></h4><pre>
       PPI::Structure is the root class for all Perl bracing structures. This covers all forms of " [ ... ] ", "
       { ... } ", and " ( ... ) " brace types, and includes cases where only one half of the pair exist.

       The class PPI::Structure itself is full abstract and no objects of that type should actually exist in the
       tree.

   <b>Elements</b> <b>vs</b> <b>Children</b>
       A <b>PPI::Structure</b> has an unusual existence. Unlike a PPI::Document or PPI::Statement, which both simply
       contain other elements, a structure <b>both</b> contains and consists of content.

       That is, the brace tokens are <b>not</b> considered to be "children" of the structure, but are part of it.

       In practice, this will mean that while the -&gt;elements and -&gt;tokens methods (and related) <b>will</b> return a
       list with the brace tokens at either end, the -&gt;children method explicitly will <b>not</b> return the brace.

</pre><h4><b>STRUCTURE</b> <b>CLASSES</b></h4><pre>
       Excluding the transient PPI::Structure::Unknown that exists briefly inside the parser, there are eight
       types of structure.

   <b>PPI::Structure::List</b>
       This covers all round braces used for function arguments, in "foreach" loops, literal lists, and braces
       used for precedence-ordering purposes.

   <b>PPI::Structure::For</b>
       Although <b>not</b> used for the "foreach" loop list, this <b>is</b> used for the special case of the round-brace
       three-part semicolon-separated "for" loop expression (the traditional C style for loop).

   <b>PPI::Structure::Given</b>
       This is for the expression being matched in switch statements.

   <b>PPI::Structure::When</b>
       This is for the matching expression in "when" statements.

   <b>PPI::Structure::Condition</b>
       This round-brace structure covers boolean conditional braces, such as for "if" and "while" blocks.

   <b>PPI::Structure::Block</b>
       This curly-brace and common structure is used for all form of code blocks. This includes those for "if",
       "do" and similar, as well as "grep", "map", "sort", "sub" and (labelled or anonymous) scoping blocks.

   <b>PPI::Structure::Constructor</b>
       This class covers brace structures used for the construction of anonymous "ARRAY" and "HASH" references.

   <b>PPI::Structure::Subscript</b>
       This class covers square-braces and curly-braces used after a -&gt; pointer to access the subscript of an
       "ARRAY" or "HASH".

</pre><h4><b>METHODS</b></h4><pre>
       "PPI::Structure" itself has very few methods. Most of the time, you will be working with the more generic
       PPI::Element or PPI::Node methods, or one of the methods that are subclass-specific.

   <b>start</b>
       For lack of better terminology (like "open" and "close") that has not already in use for some other more
       important purpose, the two individual braces for the structure are known within PPI as the "start" and
       "finish" braces (at least for method purposes).

       The "start" method returns the start brace for the structure (i.e. the opening brace).

       Returns the brace as a PPI::Token::Structure or "undef" if the structure does not have a starting brace.

       Under normal parsing circumstances this should never occur, but may happen due to manipulation of the
       PDOM tree.

   <b>finish</b>
       The "finish" method returns the finish brace for the structure (i.e. the closing brace).

       Returns the brace as a PPI::Token::Structure or "undef" if the structure does not have a finishing brace.
       This can be quite common if the document is not complete (for example, from an editor where the user may
       be halfway through typeing a subroutine).

   <b>braces</b>
       The "braces" method is a utility method which returns the brace type, regardless of whether both or just
       one of the braces is defined.

       Returns one of the three strings '[]', '{}', or '()', or "undef" on error (primarily not having a start
       brace, as mentioned above).

</pre><h4><b>complete</b></h4><pre>
       The "complete" method is a convenience method that returns true if the both braces are defined for the
       structure, or false if only one brace is defined.

       Unlike the top level "complete" method which checks for completeness in depth, the structure complete
       method ONLY confirms completeness for the braces, and does not recurse downwards.

</pre><h4><b>SUPPORT</b></h4><pre>
       See the support section in the main module.

</pre><h4><b>AUTHOR</b></h4><pre>
       Adam Kennedy &lt;<a href="mailto:adamk@cpan.org">adamk@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2001 - 2011 Adam Kennedy.

       This program is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

       The full text of the license can be found in the LICENSE file included with this module.

perl v5.40.0                                       2025-01-12                                <u>PPI::<a href="../man3pm/Structure.3pm.html">Structure</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>