<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::deque< _Tp, _Alloc > - A standard container using fixed-size memory allocation and constant-time</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::deque&lt; _Tp, _Alloc &gt; - A standard container using fixed-size memory allocation and constant-time
       manipulation of elements at either end.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;deque&gt;

       Inherits <b>std::_Deque_base&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b>.

   <b>Public</b> <b>Types</b>
       <b>typedef</b> _Alloc <b>allocator_type</b>
       <b>typedef</b> <b>_Base::const_iterator</b> <b>const_iterator</b>
       <b>typedef</b> _Alloc_traits::const_pointer <b>const_pointer</b>
       <b>typedef</b> _Alloc_traits::const_reference <b>const_reference</b>
       <b>typedef</b> <b>std::reverse_iterator</b>&lt; <b>const_iterator</b> &gt; <b>const_reverse_iterator</b>
       <b>typedef</b> ptrdiff_t <b>difference_type</b>
       <b>typedef</b> <b>_Base::iterator</b> <b>iterator</b>
       <b>typedef</b> _Alloc_traits::pointer <b>pointer</b>
       <b>typedef</b> _Alloc_traits::reference <b>reference</b>
       <b>typedef</b> <b>std::reverse_iterator</b>&lt; <b>iterator</b> &gt; <b>reverse_iterator</b>
       <b>typedef</b> size_t <b>size_type</b>
       <b>typedef</b> _Tp <b>value_type</b>

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>deque</b> ()=<b>default</b>
           Creates a deque with no elements.
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b>  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; <b>deque</b>
           (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last, const allocator_type &amp;__a=allocator_type())
           Builds a deque from a range.
       <b>deque</b> (const allocator_type &amp;__a)
           Creates a deque with no elements.
       <b>deque</b> (const <b>deque</b> &amp;__x)
           Deque copy constructor.
       <b>deque</b> (const <b>deque</b> &amp;__x, const <b>__type_identity_t</b>&lt; allocator_type &gt; &amp;__a)
           Copy constructor with alternative allocator.
       <b>deque</b> (<b>deque</b> &amp;&amp;)=<b>default</b>
           Deque move constructor.
       <b>deque</b> (<b>deque</b> &amp;&amp;__x, const <b>__type_identity_t</b>&lt; allocator_type &gt; &amp;__a)
           Move constructor with alternative allocator.
       <b>deque</b> (<b>initializer_list</b>&lt; value_type &gt; <b>__l</b>, const allocator_type &amp;__a=allocator_type())
           Builds a deque from an initializer list.
       <b>deque</b> (size_type __n, const allocator_type &amp;__a=allocator_type())
           Creates a deque with default constructed elements.
       <b>deque</b> (size_type __n, const value_type &amp;__value, const allocator_type &amp;__a=allocator_type())
           Creates a deque with copies of an exemplar element.
       <b>~deque</b> ()
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b>  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; <b>void</b> <b>assign</b>
           (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last)
           Assigns a range to a deque.
       <b>void</b> <b>assign</b> (<b>initializer_list</b>&lt; value_type &gt; <b>__l</b>)
           Assigns an initializer list to a deque.
       <b>void</b> <b>assign</b> (size_type __n, const value_type &amp;__val)
           Assigns a given value to a deque.
       reference <b>at</b> (size_type __n)
           Provides access to the data contained in the deque.
       const_reference <b>at</b> (size_type __n) const
           Provides access to the data contained in the deque.
       const_reference <b>back</b> () const noexcept
       reference <b>back</b> () noexcept
       <b>const_iterator</b> <b>begin</b> () const noexcept
       <b>iterator</b> <b>begin</b> () noexcept
       <b>const_iterator</b> <b>cbegin</b> () const noexcept
       <b>const_iterator</b> <b>cend</b> () const noexcept
       <b>void</b> <b>clear</b> () noexcept
       <b>const_reverse_iterator</b> <b>crbegin</b> () const noexcept
       <b>const_reverse_iterator</b> <b>crend</b> () const noexcept
       template&lt;typename... _Args&gt; <b>iterator</b> <b>emplace</b> (<b>const_iterator</b> <b>__position</b>, <b>_Args</b> &amp;&amp;... <b>__args</b>)
           Inserts an object in deque before specified iterator.
       template&lt;typename... _Args&gt; reference <b>emplace_back</b> (<b>_Args</b> &amp;&amp;... <b>__args</b>)
       template&lt;typename... _Args&gt; reference <b>emplace_front</b> (<b>_Args</b> &amp;&amp;... <b>__args</b>)
       bool <b>empty</b> () const noexcept
       <b>const_iterator</b> <b>end</b> () const noexcept
       <b>iterator</b> <b>end</b> () noexcept
       <b>iterator</b> <b>erase</b> (<b>const_iterator</b> __first, <b>const_iterator</b> __last)
           Remove a range of elements.
       <b>iterator</b> <b>erase</b> (<b>const_iterator</b> <b>__position</b>)
           Remove element at given position.
       const_reference <b>front</b> () const noexcept
       reference <b>front</b> () noexcept
       allocator_type <b>get_allocator</b> () const noexcept
           Get a copy of the memory allocation object.
       <b>iterator</b> <b>insert</b> (<b>const_iterator</b> __p, <b>initializer_list</b>&lt; value_type &gt; <b>__l</b>)
           Inserts an initializer list into the deque.
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b>  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; <b>iterator</b> <b>insert</b>
           (<b>const_iterator</b> <b>__position</b>, <b>_InputIterator</b> __first, <b>_InputIterator</b> __last)
           Inserts a range into the deque.
       <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__position</b>, const value_type &amp;__x)
           Inserts given value into deque before specified iterator.
       <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__position</b>, size_type __n, const value_type &amp;__x)
           Inserts a number of copies of given data into the deque.
       <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__position</b>, value_type &amp;&amp;__x)
           Inserts given rvalue into deque before specified iterator.
       size_type <b>max_size</b> () const noexcept
       <b>deque</b> &amp; <b>operator=</b> (const <b>deque</b> &amp;__x)
           Deque assignment operator.
       <b>deque</b> &amp; <b>operator=</b> (<b>deque</b> &amp;&amp;__x) noexcept(_Alloc_traits::_S_always_equal())
           Deque move assignment operator.
       <b>deque</b> &amp; <b>operator=</b> (<b>initializer_list</b>&lt; value_type &gt; <b>__l</b>)
           Assigns an initializer list to a deque.
       const_reference <b>operator[]</b> (size_type __n) const noexcept
           Subscript access to the data contained in the deque.
       reference <b>operator[]</b> (size_type __n) noexcept
           Subscript access to the data contained in the deque.
       <b>void</b> <b>pop_back</b> () noexcept
           Removes last element.
       <b>void</b> <b>pop_front</b> () noexcept
           Removes first element.
       <b>void</b> <b>push_back</b> (const value_type &amp;__x)
           Add data to the end of the deque.
       <b>void</b> <b>push_back</b> (value_type &amp;&amp;__x)
       <b>void</b> <b>push_front</b> (const value_type &amp;__x)
           Add data to the front of the deque.
       <b>void</b> <b>push_front</b> (value_type &amp;&amp;__x)
       <b>const_reverse_iterator</b> <b>rbegin</b> () const noexcept
       <b>reverse_iterator</b> <b>rbegin</b> () noexcept
       <b>const_reverse_iterator</b> <b>rend</b> () const noexcept
       <b>reverse_iterator</b> <b>rend</b> () noexcept
       <b>void</b> <b>resize</b> (size_type <b>__new_size</b>)
           Resizes the deque to the specified number of elements.
       <b>void</b> <b>resize</b> (size_type <b>__new_size</b>, const value_type &amp;__x)
           Resizes the deque to the specified number of elements.
       <b>void</b> <b>shrink_to_fit</b> () noexcept
       size_type <b>size</b> () const noexcept
       <b>void</b> <b>swap</b> (<b>deque</b> &amp;__x) noexcept
           Swaps data with another deque.

   <b>Protected</b> <b>Types</b>
       enum { <b>_S_initial_map_size</b> }
       <b>typedef</b> <b>__gnu_cxx::__alloc_traits</b>&lt; _Map_alloc_type &gt; <b>_Map_alloc_traits</b>
       <b>typedef</b> _Alloc_traits::template rebind&lt; <b>_Ptr</b> &gt;::other <b>_Map_alloc_type</b>
       <b>typedef</b> _Alloc_traits::pointer <b>_Ptr</b>
       <b>typedef</b> _Alloc_traits::const_pointer <b>_Ptr_const</b>

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       template&lt;<b>typename</b> <b>_ForwardIterator</b> &gt; <b>void</b> <b>_M_assign_aux</b> (<b>_ForwardIterator</b> __first, <b>_ForwardIterator</b>
           __last, <b>std::forward_iterator_tag</b>)
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>void</b> <b>_M_assign_aux</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last,
           <b>std::input_iterator_tag</b>)
       <b>void</b> <b>_M_deallocate_map</b> (_Map_pointer __p, size_t __n) noexcept
       <b>void</b> <b>_M_default_append</b> (size_type __n)
       <b>void</b> <b>_M_default_initialize</b> ()
       template&lt;<b>typename</b> _Alloc1 &gt; <b>void</b> <b>_M_destroy_data</b> (<b>iterator</b> __first, <b>iterator</b> __last, const _Alloc1 &amp;)
       <b>void</b> <b>_M_destroy_data</b> (<b>iterator</b> __first, <b>iterator</b> __last, const <b>std::allocator</b>&lt; _Tp &gt; &amp;)
       <b>void</b> <b>_M_destroy_data_aux</b> (<b>iterator</b> __first, <b>iterator</b> __last)
       template&lt;typename... _Args&gt; <b>iterator</b> <b>_M_emplace_aux</b> (<b>iterator</b> <b>__pos</b>, <b>_Args</b> &amp;&amp;... <b>__args</b>)
       <b>iterator</b> <b>_M_erase</b> (<b>iterator</b> __first, <b>iterator</b> __last)
       <b>iterator</b> <b>_M_erase</b> (<b>iterator</b> <b>__pos</b>)
       <b>void</b> <b>_M_erase_at_begin</b> (<b>iterator</b> <b>__pos</b>)
       <b>void</b> <b>_M_erase_at_end</b> (<b>iterator</b> <b>__pos</b>)
       <b>void</b> <b>_M_fill_assign</b> (size_type __n, const value_type &amp;__val)
       <b>void</b> <b>_M_fill_initialize</b> (const value_type &amp;__value)
           Fills the deque with copies of value.
       <b>void</b> <b>_M_fill_insert</b> (<b>iterator</b> <b>__pos</b>, size_type __n, const value_type &amp;__x)
       _Map_alloc_type <b>_M_get_map_allocator</b> () const noexcept
       template&lt;<b>typename</b> <b>_ForwardIterator</b> &gt; <b>void</b> <b>_M_insert_aux</b> (<b>iterator</b> <b>__pos</b>, <b>_ForwardIterator</b> __first,
           <b>_ForwardIterator</b> __last, size_type __n)
       <b>iterator</b> <b>_M_insert_aux</b> (<b>iterator</b> <b>__pos</b>, const value_type &amp;__x)
       <b>void</b> <b>_M_insert_aux</b> (<b>iterator</b> <b>__pos</b>, size_type __n, const value_type &amp;__x)
       <b>void</b> <b>_M_move_assign1</b> (<b>deque</b> &amp;&amp;__x, <b>false_type</b>)
       <b>void</b> <b>_M_move_assign1</b> (<b>deque</b> &amp;&amp;__x, <b>true_type</b>) noexcept
       <b>void</b> <b>_M_move_assign2</b> (<b>deque</b> &amp;&amp;__x, <b>false_type</b>)
       <b>void</b> <b>_M_move_assign2</b> (<b>deque</b> &amp;&amp;__x, <b>true_type</b>)
       <b>void</b> <b>_M_range_check</b> (size_type __n) const
           Safety check used only from at().
       template&lt;<b>typename</b> <b>_ForwardIterator</b> &gt; <b>void</b> <b>_M_range_insert_aux</b> (<b>iterator</b> <b>__pos</b>, <b>_ForwardIterator</b> __first,
           <b>_ForwardIterator</b> __last, <b>std::forward_iterator_tag</b>)
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>void</b> <b>_M_range_insert_aux</b> (<b>iterator</b> <b>__pos</b>, <b>_InputIterator</b> __first,
           <b>_InputIterator</b> __last, <b>std::input_iterator_tag</b>)
       template&lt;typename... _Args&gt; <b>void</b> <b>_M_replace_map</b> (<b>_Args</b> &amp;&amp;... <b>__args</b>)
       bool <b>_M_shrink_to_fit</b> ()

           template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>void</b> <b>_M_range_initialize</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b>
               __last, <b>std::input_iterator_tag</b>)
               Fills the deque with whatever is in [first,last).
           template&lt;<b>typename</b> <b>_ForwardIterator</b> &gt; <b>void</b> <b>_M_range_initialize</b> (<b>_ForwardIterator</b> __first,
               <b>_ForwardIterator</b> __last, <b>std::forward_iterator_tag</b>)
               Fills the deque with whatever is in [first,last).

           template&lt;typename... _Args&gt; <b>void</b> <b>_M_push_back_aux</b> (<b>_Args</b> &amp;&amp;... <b>__args</b>)
               Helper functions for push_* and pop_*.
           template&lt;typename... _Args&gt; <b>void</b> <b>_M_push_front_aux</b> (<b>_Args</b> &amp;&amp;... <b>__args</b>)
               Helper functions for push_* and pop_*.
           <b>void</b> <b>_M_pop_back_aux</b> ()
               Helper functions for push_* and pop_*.
           <b>void</b> <b>_M_pop_front_aux</b> ()
               Helper functions for push_* and pop_*.

           <b>iterator</b> <b>_M_reserve_elements_at_front</b> (size_type __n)
               Memory-handling helpers for the previous internal insert functions.
           <b>iterator</b> <b>_M_reserve_elements_at_back</b> (size_type __n)
               Memory-handling helpers for the previous internal insert functions.
           <b>void</b> <b>_M_new_elements_at_front</b> (size_type <b>__new_elements</b>)
               Memory-handling helpers for the previous internal insert functions.
           <b>void</b> <b>_M_new_elements_at_back</b> (size_type <b>__new_elements</b>)
               Memory-handling helpers for the previous internal insert functions.

           <b>void</b> <b>_M_reserve_map_at_back</b> (size_type <b>__nodes_to_add</b>=1)
               Memory-handling helpers for the major map.
           <b>void</b> <b>_M_reserve_map_at_front</b> (size_type <b>__nodes_to_add</b>=1)
               Memory-handling helpers for the major map.
           <b>void</b> <b>_M_reallocate_map</b> (size_type <b>__nodes_to_add</b>, bool <b>__add_at_front</b>)
               Memory-handling helpers for the major map.

   <b>Static</b> <b>Protected</b> <b>Member</b> <b>Functions</b>
       <b>static</b> size_t <b>_S_check_init_len</b> (size_t __n, const allocator_type &amp;__a)
       <b>static</b> size_type <b>_S_max_size</b> (const _Tp_alloc_type &amp;__a) noexcept

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp,</b> <b>typename</b> <b>_Alloc</b> <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b>
       class std::deque&lt; _Tp, _Alloc &gt;"A standard container using fixed-size memory allocation and constant-time
       manipulation of elements at either end.

       <b>Template</b> <b>Parameters</b>
           <b>_</b><u>Tp</u> Type of element.
           <b>_</b><u>Alloc</u> Allocator type, defaults to allocator&lt;_Tp&gt;.

       Meets the requirements of a container, a reversible container, and a sequence, including the optional
       sequence requirements.

       In previous HP/SGI versions of deque, there was an extra template parameter so users could control the
       node size. This extension turned out to violate the C++ standard (it can be detected using template
       template parameters), and it was removed.

       Here's how a deque&lt;Tp&gt; manages memory. Each deque has 4 members:

       • Tp** _M_map

       • size_t _M_map_size

       • iterator _M_start, _M_finish

       map_size  is  at  least 8. map is an array of map_size pointers-to-<u>nodes</u>. (The name map has nothing to do
       with the std::map class, and <b>nodes</b> should not be confused with std::list's usage of <u>node</u>.)

       A <u>node</u> has no specific type name as such, but it is referred to as <u>node</u> in this  file.  It  is  a  simple
       array-of-Tp. If Tp is very large, there will be one Tp element per node (i.e., an <u>array</u> of one). For non-
       huge  Tp's,  node  size  is inversely related to Tp size: the larger the Tp, the fewer Tp's will fit in a
       node. The goal here is to keep the total size of a node relatively  small  and  constant  over  different
       Tp's, to improve allocator efficiency.

       Not  every  pointer in the map array will point to a node. If the initial number of elements in the deque
       is small, the /middle/ map pointers will be valid, and the ones at the edges will be  unused.  This  same
       situation  will arise as the map grows: available map pointers, if any, will be on the ends. As new nodes
       are created, only a subset of the map's pointers need to be copied <u>outward</u>.

       Class invariants:

       • For any nonsingular iterator i:

         • i.node points to a member of the map array. (Yes, you read that correctly: i.node does  not  actually
           point to a node.) The member of the map array is what actually points to the node.

         • i.first == *(i.node) (This points to the node (first Tp element).)

         • i.last == i.first + node_size

         • i.cur  is  a  pointer  in the range [i.first, i.last). NOTE: the implication of this is that i.cur is
           always a dereferenceable pointer, even if i is a past-the-end iterator.

       • Start and Finish are always nonsingular iterators. NOTE: this means that an empty deque must  have  one
         node,  a  deque  with  &lt;N elements (where N is the node buffer size) must have one node, a deque with N
         through (2N-1) elements must have two nodes, etc.

       • For every node other than start.node and finish.node, every element  in  the  node  is  an  initialized
         object.  If  start.node  ==  finish.node, then [start.cur, finish.cur) are initialized objects, and the
         elements  outside  that  range  are  uninitialized  storage.  Otherwise,  [start.cur,  start.last)  and
         [finish.first,  finish.cur)  are  initialized  objects,  and  [start.first, start.cur) and [finish.cur,
         finish.last) are uninitialized storage.

       • [map, map + map_size) is a valid, non-empty range.

       • [start.node, finish.node] is a valid range contained within [map, map + map_size).

       • A pointer in the range [map, map + map_size) points to an allocated node if and only if the pointer  is
         in the range [start.node, finish.node].

       Here's the magic: nothing in deque is <b>aware</b> of the discontiguous storage!

       The  memory  setup and layout occurs in the parent, _Base, and the iterator class is entirely responsible
       for <u>leaping</u> from one node to the next. All the implementation routines for deque itself work only through
       the start and finish iterators. This keeps the routines simple and sane, and we can  use  other  standard
       algorithms as well.

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::deque</b> <b>()</b> <b>[default]</b>

       Creates a deque with no elements.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::deque</b> <b>(const</b>
       <b>allocator_type</b> <b>&amp;</b> <b>__a)</b> <b>[inline],</b>  <b>[explicit]</b>
       Creates a deque with no elements.

       <b>Parameters</b>
           <b>__</b><u>a</u> An allocator object.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b>  <b>&gt;::deque</b>  <b>(size_type</b>
       <b>__n,</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b> <b>[inline],</b>  <b>[explicit]</b>
       Creates a deque with default constructed elements.

       <b>Parameters</b>
           <b>__</b><u>n</u> The number of elements to initially create.
           <b>__</b><u>a</u> An allocator.

       This constructor fills the deque with <u>n</u> default constructed elements.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::deque</b> <b>(size_type</b>
       <b>__n,</b> <b>const</b> <b>value_type</b> <b>&amp;</b> <b>__value,</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b> <b>[inline]</b>
       Creates a deque with copies of an exemplar element.

       <b>Parameters</b>
           <b>__</b><u>n</u> The number of elements to initially create.
           <b>__</b><u>value</u> An element to copy.
           <b>__</b><u>a</u> An allocator.

       This constructor fills the deque with <b>__</b><u>n</u> copies of <b>__</b><u>value</u>.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_fill_initialize()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>  <b>&gt;::deque</b>  <b>(const</b>
       <b>deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Deque copy constructor.

       <b>Parameters</b>
           <b>__</b><u>x</u> A deque of identical element and allocator types.

       The  newly-created  deque  uses  a  copy of the allocator object used by <b>__</b><u>x</u> (unless the allocator traits
       dictate a different object).

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>, and <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::deque</b> <b>(deque&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;)</b> <b>[default]</b>
       Deque move constructor. The newly-created deque contains the exact contents of the  moved  instance.  The
       contents of the moved instance are a valid, but unspecified deque.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::deque</b> <b>(const</b>
       <b>deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__x,</b> <b>const</b> <b>__type_identity_t&lt;</b> <b>allocator_type</b> <b>&gt;</b> <b>&amp;</b> <b>__a)</b> <b>[inline]</b>
       Copy constructor with alternative allocator.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>, and <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::deque</b> <b>(deque&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__x,</b> <b>const</b> <b>__type_identity_t&lt;</b> <b>allocator_type</b> <b>&gt;</b> <b>&amp;</b> <b>__a)</b> <b>[inline]</b>
       Move constructor with alternative allocator.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>std::deque&lt;</b>   <b>_Tp,</b>   <b>_Alloc</b>   <b>&gt;::deque</b>
       <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l,</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b> <b>[inline]</b>
       Builds a deque from an initializer list.

       <b>Parameters</b>
           <b>__</b><u>l</u> An initializer_list.
           <b>__</b><u>a</u> An allocator object.

       Create a deque consisting of copies of the elements in the initializer_list <b>__</b><u>l</u>.

       This  will  call  the  element  type's  copy constructor N times (where N is __l.size()) and do no memory
       reallocation.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_range_initialize()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b>  <b>,</b>  <b>typename</b>
       <b>=</b>  <b>std::_RequireInputIter&lt;_InputIterator&gt;&gt;</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>  <b>&gt;::deque</b>  <b>(_InputIterator</b> <b>__first,</b>
       <b>_InputIterator</b> <b>__last,</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b> <b>[inline]</b>
       Builds a deque from a range.

       <b>Parameters</b>
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>last</u> An input iterator.
           <b>__</b><u>a</u> An allocator object.

       Create a deque consisting of copies of the elements from [__first, __last).

       If the iterators are forward, bidirectional, or random-access, then this will  call  the  elements'  copy
       constructor  N  times  (where  N  is distance(__first,__last)) and do no memory reallocation. But if only
       input iterators are used, then this will do at most 2N calls to the copy  constructor,  and  logN  memory
       reallocations.

       References <b>std::__iterator_category()</b>, and <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_range_initialize()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::~deque</b> <b>()</b> <b>[inline]</b>

       The  dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-to
       memory is not touched in any way. Managing the pointer is the user's responsibility.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>, and <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b>  <b>_Alloc</b>  <b>&gt;</b>  <b>void</b>  <b>deque::_M_fill_initialize</b>  <b>(const</b>  <b>value_type</b>  <b>&amp;</b>  <b>__value)</b>
       <b>[protected]</b>
       Fills the deque with copies of value.

       <b>Parameters</b>
           <b>__</b><u>value</u> Initial value.

       <b>Returns</b>
           Nothing.

       <b>Precondition</b>
           _M_start  and _M_finish have already been initialized, but none of the deque's elements have yet been
           constructed.

       This function is called only when the user provides  an  explicit  size  (with  or  without  an  explicit
       exemplar value).

       References <b>std::_Destroy()</b>.

       Referenced by <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::deque()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>  <b>&gt;</b> <b>void</b> <b>deque::_M_new_elements_at_back</b> <b>(size_type</b> <b>__new_elements)</b>
       <b>[protected]</b>
       Memory-handling helpers for the previous internal insert functions.

       References <b>std::size()</b>.

       Referenced by <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_reserve_elements_at_back()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>&gt;</b>  <b>void</b>  <b>deque::_M_new_elements_at_front</b>  <b>(size_type</b>  <b>__new_elements)</b>
       <b>[protected]</b>
       Memory-handling helpers for the previous internal insert functions.

       References <b>std::size()</b>.

       Referenced by <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_reserve_elements_at_front()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>&gt;</b> <b>void</b> <b>deque::_M_pop_back_aux</b> <b>()</b> <b>[protected]</b>
       Helper functions for push_* and pop_*.

       Referenced by <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::pop_back()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>&gt;</b> <b>void</b> <b>deque::_M_pop_front_aux</b> <b>()</b> <b>[protected]</b>
       Helper functions for push_* and pop_*.

       Referenced by <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::pop_front()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b> <b>&gt;</b> <b>template&lt;typename...</b> <b>_Args&gt;</b> <b>void</b> <b>deque::_M_push_back_aux</b> <b>(_Args</b>
       <b>&amp;&amp;...</b> <b>__args)</b> <b>[protected]</b>
       Helper functions for push_* and pop_*.

       References <b>std::size()</b>.

       Referenced by <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::push_back()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>&gt;</b> <b>template&lt;typename...</b> <b>_Args&gt;</b>  <b>void</b>  <b>deque::_M_push_front_aux</b>  <b>(_Args</b>
       <b>&amp;&amp;...</b> <b>__args)</b> <b>[protected]</b>
       Helper functions for push_* and pop_*.

       References <b>std::size()</b>.

       Referenced by <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::push_front()</b>.

   <b>template&lt;typename</b>   <b>_Tp</b>   <b>,</b>   <b>typename</b>   <b>_Alloc</b>    <b>=</b>   <b>std::allocator&lt;_Tp&gt;&gt;</b>   <b>void</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>
       <b>&gt;::_M_range_check</b> <b>(size_type</b> <b>__n)</b> <b>const</b> <b>[inline],</b>  <b>[protected]</b>
       Safety check used only from at().

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::size()</b>.

       Referenced by <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::at()</b>, and <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::at()</b>.

   <b>template&lt;typename</b>   <b>_Tp</b>    <b>,</b>    <b>typename</b>    <b>_Alloc</b>    <b>&gt;</b>    <b>template&lt;typename</b>    <b>_ForwardIterator</b>    <b>&gt;</b>    <b>void</b>
       <b>deque::_M_range_initialize</b> <b>(_ForwardIterator</b> <b>__first,</b> <b>_ForwardIterator</b> <b>__last,</b> <b>std::forward_iterator_tag)</b>
       <b>[protected]</b>
       Fills the deque with whatever is in [first,last).

       <b>Parameters</b>
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>last</u> An input iterator.

       <b>Returns</b>
           Nothing.

       If  the  iterators  are actually forward iterators (or better), then the memory layout can be done all at
       once. Else we move forward using push_back on each value from the iterator.

       References <b>std::_Destroy()</b>, <b>std::advance()</b>, and <b>std::distance()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b> <b>&gt;</b> <b>void</b>  <b>deque::_M_range_initialize</b>
       <b>(_InputIterator</b> <b>__first,</b> <b>_InputIterator</b> <b>__last,</b> <b>std::input_iterator_tag)</b> <b>[protected]</b>
       Fills the deque with whatever is in [first,last).

       <b>Parameters</b>
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>last</u> An input iterator.

       <b>Returns</b>
           Nothing.

       If  the  iterators  are actually forward iterators (or better), then the memory layout can be done all at
       once. Else we move forward using push_back on each value from the iterator.

       Referenced by <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::deque()</b>, and <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::deque()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>&gt;</b>  <b>void</b>  <b>deque::_M_reallocate_map</b>  <b>(size_type</b>  <b>__nodes_to_add,</b>  <b>bool</b>
       <b>__add_at_front)</b> <b>[protected]</b>
       Memory-handling  helpers  for  the  major  map.  Makes  sure the _M_map has space for new nodes. Does not
       actually add the nodes. Can invalidate _M_map pointers. (And consequently, deque iterators.)

       References <b>std::max()</b>.

       Referenced  by  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>  <b>&gt;::_M_reserve_map_at_back()</b>,  and  <b>std::deque&lt;</b>   <b>_Tp,</b>   <b>_Alloc</b>
       <b>&gt;::_M_reserve_map_at_front()</b>.

   <b>template&lt;typename</b>   <b>_Tp</b>   <b>,</b>   <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>iterator</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>
       <b>&gt;::_M_reserve_elements_at_back</b> <b>(size_type</b> <b>__n)</b> <b>[inline],</b>  <b>[protected]</b>
       Memory-handling helpers for the previous internal insert functions.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_new_elements_at_back()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>iterator</b>   <b>std::deque&lt;</b>   <b>_Tp,</b>   <b>_Alloc</b>
       <b>&gt;::_M_reserve_elements_at_front</b> <b>(size_type</b> <b>__n)</b> <b>[inline],</b>  <b>[protected]</b>
       Memory-handling helpers for the previous internal insert functions.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_new_elements_at_front()</b>.

   <b>template&lt;typename</b>   <b>_Tp</b>   <b>,</b>   <b>typename</b>   <b>_Alloc</b>    <b>=</b>   <b>std::allocator&lt;_Tp&gt;&gt;</b>   <b>void</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>
       <b>&gt;::_M_reserve_map_at_back</b> <b>(size_type</b> <b>__nodes_to_add</b> <b>=</b> <b>1)</b> <b>[inline],</b>  <b>[protected]</b>
       Memory-handling helpers for the major map. Makes sure the _M_map  has  space  for  new  nodes.  Does  not
       actually add the nodes. Can invalidate _M_map pointers. (And consequently, deque iterators.)

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_reallocate_map()</b>.

   <b>template&lt;typename</b>   <b>_Tp</b>   <b>,</b>   <b>typename</b>   <b>_Alloc</b>    <b>=</b>   <b>std::allocator&lt;_Tp&gt;&gt;</b>   <b>void</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>
       <b>&gt;::_M_reserve_map_at_front</b> <b>(size_type</b> <b>__nodes_to_add</b> <b>=</b> <b>1)</b> <b>[inline],</b>  <b>[protected]</b>
       Memory-handling helpers for the major map. Makes sure the _M_map  has  space  for  new  nodes.  Does  not
       actually add the nodes. Can invalidate _M_map pointers. (And consequently, deque iterators.)

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_reallocate_map()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b> <b>,</b> <b>typename</b>
       <b>=</b> <b>std::_RequireInputIter&lt;_InputIterator&gt;&gt;</b> <b>void</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::assign</b> <b>(_InputIterator</b> <b>__first,</b>
       <b>_InputIterator</b> <b>__last)</b> <b>[inline]</b>
       Assigns a range to a deque.

       <b>Parameters</b>
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>last</u> An input iterator.

       This function fills a deque with copies of the elements in the range [__first,__last).

       Note that the assignment completely changes the deque and that the resulting deque's size is the same  as
       the number of elements assigned.

       References <b>std::__iterator_category()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>void</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::assign</b>
       <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l)</b> <b>[inline]</b>
       Assigns an initializer list to a deque.

       <b>Parameters</b>
           <b>__</b><u>l</u> An initializer_list.

       This function fills a deque with copies of the elements in the initializer_list <b>__</b><u>l</u>.

       Note that the assignment completely changes the deque and that the resulting deque's size is the same  as
       the number of elements assigned.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>void</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::assign</b>
       <b>(size_type</b> <b>__n,</b> <b>const</b> <b>value_type</b> <b>&amp;</b> <b>__val)</b> <b>[inline]</b>
       Assigns a given value to a deque.

       <b>Parameters</b>
           <b>__</b><u>n</u> Number of elements to be assigned.
           <b>__</b><u>val</u> Value to be assigned.

       This function fills a deque with <u>n</u> copies of the given value. Note that the assignment completely changes
       the deque and that the resulting deque's size is the same as the number of elements assigned.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>reference</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>  <b>&gt;::at</b>
       <b>(size_type</b> <b>__n)</b> <b>[inline]</b>
       Provides access to the data contained in the deque.

       <b>Parameters</b>
           <b>__</b><u>n</u> The index of the element for which data should be accessed.

       <b>Returns</b>
           Read/write reference to data.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If <b>__</b><u>n</u> is an invalid index.

       This  function  provides for safer data access. The parameter is first checked that it is in the range of
       the deque. The function throws out_of_range if the check fails.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_range_check()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>const_reference</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::at</b>
       <b>(size_type</b> <b>__n)</b> <b>const</b> <b>[inline]</b>
       Provides access to the data contained in the deque.

       <b>Parameters</b>
           <b>__</b><u>n</u> The index of the element for which data should be accessed.

       <b>Returns</b>
           Read-only (constant) reference to data.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If <b>__</b><u>n</u> is an invalid index.

       This function provides for safer data access. The parameter is first checked that it is in the  range  of
       the deque. The function throws out_of_range if the check fails.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_range_check()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>const_reference</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::back</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reference to the data at the last element of the deque.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>reference</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::back</b>  <b>()</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read/write reference to the data at the last element of the deque.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>const_iterator</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::begin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points to the first element in the deque. Iteration is  done
       in ordinary element order.

   <b>template&lt;typename</b>  <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>iterator</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin</b> <b>()</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read/write iterator that points to the first  element  in  the  deque.  Iteration  is  done  in
       ordinary element order.

       Referenced  by  <b>std::deque&lt;</b>  <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::deque()</b>, <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::deque()</b>, <b>std::deque&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::~deque()</b>, <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::clear()</b>, <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b>  <b>&gt;::front()</b>,  <b>std::deque&lt;</b>
       <b>_Tp,</b>  <b>_Alloc</b>  <b>&gt;::front()</b>,  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>  <b>&gt;::insert()</b>,  <b>std::deque&lt;</b>  <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::insert()</b>,
       <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::insert()</b>, and <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::operator=()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>const_iterator</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>
       <b>&gt;::cbegin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns  a read-only (constant) iterator that points to the first element in the deque. Iteration is done
       in ordinary element order.

       Referenced by <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::insert()</b>, <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::insert()</b>,  and  <b>std::deque&lt;</b>
       <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::insert()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>const_iterator</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::cend</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points one past the last element in the deque. Iteration  is
       done in ordinary element order.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>void</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::clear</b> <b>()</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Erases all the elements. Note that this function only erases the  elements,  and  that  if  the  elements
       themselves  are  pointers,  the  pointed-to memory is not touched in any way. Managing the pointer is the
       user's responsibility.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>const_reverse_iterator</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::crbegin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns  a  read-only (constant) reverse iterator that points to the last element in the deque. Iteration
       is done in reverse element order.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>const_reverse_iterator</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::crend</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reverse iterator that points to one before the first element in the deque.
       Iteration is done in reverse element order.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>  <b>&gt;</b>  <b>template&lt;typename...</b>  <b>_Args&gt;</b>  <b>deque&lt;</b>  <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::iterator</b>
       <b>deque::emplace</b> <b>(const_iterator</b> <b>__position,</b> <b>_Args</b> <b>&amp;&amp;...</b> <b>__args)</b>
       Inserts an object in deque before specified iterator.

       <b>Parameters</b>
           <b>__</b><u>position</u> A const_iterator into the deque.
           <b>__</b><u>args</u> Arguments.

       <b>Returns</b>
           An iterator that points to the inserted data.

       This function will insert an object of type T constructed with T(std::forward&lt;Args&gt;(args)...) before  the
       specified location.

       Referenced by <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::insert()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>bool</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::empty</b> <b>()</b>
       <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns true if the deque is empty. (Thus begin() would equal end().)

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>const_iterator</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end</b>
       <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points one past the last element in the deque. Iteration  is
       done in ordinary element order.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>iterator</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end</b> <b>()</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read/write iterator that points one past the last element in the deque. Iteration  is  done  in
       ordinary element order.

       Referenced  by  <b>std::deque&lt;</b>  <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::deque()</b>, <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::deque()</b>, <b>std::deque&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::~deque()</b>, <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::back()</b>, <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::back()</b>, and <b>std::deque&lt;</b>
       <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::operator=()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>iterator</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>  <b>&gt;::erase</b>
       <b>(const_iterator</b> <b>__first,</b> <b>const_iterator</b> <b>__last)</b> <b>[inline]</b>
       Remove a range of elements.

       <b>Parameters</b>
           <b>__</b><u>first</u> Iterator pointing to the first element to be erased.
           <b>__</b><u>last</u> Iterator pointing to one past the last element to be erased.

       <b>Returns</b>
           An iterator pointing to the element pointed to by <u>last</u> prior to erasing (or end()).

       This function will erase the elements in the range [__first,__last) and shorten the deque accordingly.

       The  user  is  cautioned that this function only erases the elements, and that if the elements themselves
       are pointers, the pointed-to memory is not touched in  any  way.  Managing  the  pointer  is  the  user's
       responsibility.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>iterator</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::erase</b>
       <b>(const_iterator</b> <b>__position)</b> <b>[inline]</b>
       Remove element at given position.

       <b>Parameters</b>
           <b>__</b><u>position</u> Iterator pointing to element to be erased.

       <b>Returns</b>
           An iterator pointing to the next element (or end()).

       This function will erase the element at the given position and thus shorten the deque by one.

       The user is cautioned that this function only erases the element, and that if the  element  is  itself  a
       pointer,  the  pointed-to  memory  is  not  touched  in  any  way.  Managing  the  pointer  is the user's
       responsibility.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>const_reference</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>
       <b>&gt;::front</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reference to the data at the first element of the deque.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>reference</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::front</b> <b>()</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read/write reference to the data at the first element of the deque.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>allocator_type</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::get_allocator</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Get a copy of the memory allocation object.

       Referenced by <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::operator=()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>iterator</b> <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>  <b>&gt;::insert</b>
       <b>(const_iterator</b> <b>__p,</b> <b>initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l)</b> <b>[inline]</b>
       Inserts an initializer list into the deque.

       <b>Parameters</b>
           <b>__</b><u>p</u> An iterator into the deque.
           <b>__</b><u>l</u> An initializer_list.

       <b>Returns</b>
           An iterator that points to the inserted data.

       This  function  will  insert  copies  of  the  data in the initializer_list <b>__</b><u>l</u> into the deque before the
       location specified by <b>__</b><u>p</u>. This is known as <u>list</u> <u>insert</u>.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>, and <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::cbegin()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b>  <b>,</b>  <b>typename</b>
       <b>=</b>  <b>std::_RequireInputIter&lt;_InputIterator&gt;&gt;</b>  <b>iterator</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b> <b>&gt;::insert</b> <b>(const_iterator</b>
       <b>__position,</b> <b>_InputIterator</b> <b>__first,</b> <b>_InputIterator</b> <b>__last)</b> <b>[inline]</b>
       Inserts a range into the deque.

       <b>Parameters</b>
           <b>__</b><u>position</u> A const_iterator into the deque.
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>last</u> An input iterator.

       <b>Returns</b>
           An iterator that points to the inserted data.

       This function will insert copies of the data in the range [__first,__last)  into  the  deque  before  the
       location specified by <b>__</b><u>position</u>. This is known as <u>range</u> <u>insert</u>.

       References  <b>std::__iterator_category()</b>,  <b>std::deque&lt;</b>  <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>, and <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::cbegin()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>&gt;</b>  <b>deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>  <b>&gt;::iterator</b>  <b>deque::insert</b>  <b>(const_iterator</b>
       <b>__position,</b> <b>const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b>
       Inserts given value into deque before specified iterator.

       <b>Parameters</b>
           <b>__</b><u>position</u> A const_iterator into the deque.
           <b>__</b><u>x</u> Data to be inserted.

       <b>Returns</b>
           An iterator that points to the inserted data.

       This function will insert a copy of the given value before the specified location.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>iterator</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::insert</b>
       <b>(const_iterator</b> <b>__position,</b> <b>size_type</b> <b>__n,</b> <b>const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Inserts a number of copies of given data into the deque.

       <b>Parameters</b>
           <b>__</b><u>position</u> A const_iterator into the deque.
           <b>__</b><u>n</u> Number of elements to be inserted.
           <b>__</b><u>x</u> Data to be inserted.

       <b>Returns</b>
           An iterator that points to the inserted data.

       This function will insert a specified number of copies of the given data before the location specified by
       <b>__</b><u>position</u>.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>, and <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::cbegin()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>iterator</b> <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>  <b>&gt;::insert</b>
       <b>(const_iterator</b> <b>__position,</b> <b>value_type</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline]</b>
       Inserts given rvalue into deque before specified iterator.

       <b>Parameters</b>
           <b>__</b><u>position</u> A const_iterator into the deque.
           <b>__</b><u>x</u> Data to be inserted.

       <b>Returns</b>
           An iterator that points to the inserted data.

       This function will insert a copy of the given rvalue before the specified location.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::emplace()</b>, and <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>size_type</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::max_size</b>
       <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the size() of the largest possible deque.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>&gt;</b> <b>deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>deque::operator=</b> <b>(const</b> <b>deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b>
       <b>&amp;</b> <b>__x)</b>
       Deque assignment operator.

       <b>Parameters</b>
           <b>__</b><u>x</u> A deque of identical element and allocator types.

       All the elements of <u>x</u> are copied.

       The  newly-created  deque  uses  a  copy of the allocator object used by <b>__</b><u>x</u> (unless the allocator traits
       dictate a different object).

       References <b>std::__addressof()</b>, <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b>  <b>&gt;::begin()</b>,  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>  <b>&gt;::end()</b>,
       <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::get_allocator()</b>, <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::size()</b>, and <b>std::size()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>deque</b> <b>&amp;</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::operator=</b>
       <b>(deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Deque move assignment operator.

       <b>Parameters</b>
           <b>__</b><u>x</u> A deque of identical element and allocator types.

       The contents of <b>__</b><u>x</u> are moved into this deque (without copying, if the allocators permit it).  <b>__</b><u>x</u>  is  a
       valid, but unspecified deque.

       References <b>std::move()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>deque</b> <b>&amp;</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::operator=</b>
       <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l)</b> <b>[inline]</b>
       Assigns an initializer list to a deque.

       <b>Parameters</b>
           <b>__</b><u>l</u> An initializer_list.

       This function fills a deque with copies of the elements in the initializer_list <b>__</b><u>l</u>.

       Note that the assignment completely changes the deque and that the resulting deque's size is the same  as
       the number of elements assigned.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>const_reference</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::operator[]</b> <b>(size_type</b> <b>__n)</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Subscript access to the data contained in the deque.

       <b>Parameters</b>
           <b>__</b><u>n</u> The index of the element for which data should be accessed.

       <b>Returns</b>
           Read-only (constant) reference to data.

       This operator allows for easy, array-style, data access. Note that data  access  with  this  operator  is
       unchecked and out_of_range lookups are not defined. (For checked lookups see at().)

   <b>template&lt;typename</b>   <b>_Tp</b>   <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>reference</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>
       <b>&gt;::operator[]</b> <b>(size_type</b> <b>__n)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Subscript access to the data contained in the deque.

       <b>Parameters</b>
           <b>__</b><u>n</u> The index of the element for which data should be accessed.

       <b>Returns</b>
           Read/write reference to data.

       This operator allows for easy, array-style, data access. Note that data  access  with  this  operator  is
       unchecked and out_of_range lookups are not defined. (For checked lookups see at().)

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>void</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::pop_back</b> <b>()</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Removes last element. This is a typical stack operation. It shrinks the deque by one.

       Note that no data is returned, and if the last element's data is needed, it should  be  retrieved  before
       pop_back() is called.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_pop_back_aux()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>void</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::pop_front</b> <b>()</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Removes first element. This is a typical stack operation. It shrinks the deque by one.

       Note that no data is returned, and if the first element's data is needed, it should be  retrieved  before
       pop_front() is called.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_pop_front_aux()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>void</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::push_back</b>
       <b>(const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Add data to the end of the deque.

       <b>Parameters</b>
           <b>__</b><u>x</u> Data to be added.

       This is a typical stack operation. The function creates an element at the end of the  deque  and  assigns
       the given data to it. Due to the nature of a deque this operation can be done in constant time.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_push_back_aux()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>void</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::push_front</b>
       <b>(const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Add data to the front of the deque.

       <b>Parameters</b>
           <b>__</b><u>x</u> Data to be added.

       This is a typical stack operation. The function creates an element at the front of the deque and  assigns
       the given data to it. Due to the nature of a deque this operation can be done in constant time.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_push_front_aux()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>const_reverse_iterator</b> <b>std::deque&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::rbegin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reverse iterator that points to the last element in the  deque.  Iteration
       is done in reverse element order.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>reverse_iterator</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::rbegin</b> <b>()</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read/write reverse iterator that points to the last element in the deque. Iteration is done  in
       reverse element order.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>const_reverse_iterator</b> <b>std::deque&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::rend</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reverse iterator that points to one before the first element in the deque.
       Iteration is done in reverse element order.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>reverse_iterator</b>  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>
       <b>&gt;::rend</b> <b>()</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read/write reverse iterator that points to one before the first element in the deque. Iteration
       is done in reverse element order.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>void</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::resize</b>
       <b>(size_type</b> <b>__new_size)</b> <b>[inline]</b>
       Resizes the deque to the specified number of elements.

       <b>Parameters</b>
           <b>__</b><u>new_size</u> Number of elements the deque should contain.

       This function will resize the deque to the specified number of elements. If the number  is  smaller  than
       the deque's current size the deque is truncated, otherwise default constructed elements are appended.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::size()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Alloc</b>   <b>=</b>  <b>std::allocator&lt;_Tp&gt;&gt;</b>  <b>void</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::resize</b>
       <b>(size_type</b> <b>__new_size,</b> <b>const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Resizes the deque to the specified number of elements.

       <b>Parameters</b>
           <b>__</b><u>new_size</u> Number of elements the deque should contain.
           <b>__</b><u>x</u> Data with which new elements should be populated.

       This function will resize the deque to the specified number of elements. If the number  is  smaller  than
       the  deque's  current  size  the deque is truncated, otherwise the deque is extended and new elements are
       populated with given data.

       References <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::size()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>void</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::shrink_to_fit</b>
       <b>()</b> <b>[inline],</b>  <b>[noexcept]</b>
       A non-binding request to reduce memory use.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>size_type</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::size</b>  <b>()</b>
       <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the number of elements in the deque.

       Referenced  by  <b>std::deque&lt;</b>  <b>_Tp,</b>  <b>_Alloc</b>  <b>&gt;::_M_range_check()</b>,  <b>std::deque&lt;</b>  <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::operator=()</b>,
       <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::resize()</b>, and <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::resize()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>void</b> <b>std::deque&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::swap</b>  <b>(deque&lt;</b>
       <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Swaps data with another deque.

       <b>Parameters</b>
           <b>__</b><u>x</u> A deque of the same element and allocator types.

       This  exchanges  the  elements between two deques in constant time. (Four pointers, so it should be quite
       fast.) Note that the global std::swap() function is specialized such that std::swap(d1,d2) will  feed  to
       this function.

       Whether the allocators are swapped depends on the allocator traits.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++                    <u>std::deque&lt;</u> <b>_</b><u>Tp,</u> <b>_</b><u>Alloc</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>