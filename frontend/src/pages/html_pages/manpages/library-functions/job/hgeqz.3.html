<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hgeqz - hgeqz: generalized Hessenberg eig</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       hgeqz - hgeqz: generalized Hessenberg eig

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>chgeqz</b> (job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz, work,
           lwork, rwork, info)
           <b>CHGEQZ</b>
       subroutine <b>dhgeqz</b> (job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz,
           work, lwork, info)
           <b>DHGEQZ</b>
       subroutine <b>shgeqz</b> (job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz,
           work, lwork, info)
           <b>SHGEQZ</b>
       subroutine <b>zhgeqz</b> (job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz, work,
           lwork, rwork, info)
           <b>ZHGEQZ</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>chgeqz</b> <b>(character</b> <b>job,</b> <b>character</b> <b>compq,</b> <b>character</b> <b>compz,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>ilo,</b> <b>integer</b> <b>ihi,</b>
       <b>complex,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>h,</b> <b>integer</b> <b>ldh,</b> <b>complex,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>t,</b> <b>integer</b> <b>ldt,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>alpha,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>beta,</b> <b>complex,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>q,</b> <b>integer</b> <b>ldq,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>z,</b> <b>integer</b> <b>ldz,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>rwork,</b> <b>integer</b> <b>info)</b>
       <b>CHGEQZ</b>

       <b>Purpose:</b>

            CHGEQZ computes the eigenvalues of a complex matrix pair (H,T),
            where H is an upper Hessenberg matrix and T is upper triangular,
            using the single-shift QZ method.
            Matrix pairs of this type are produced by the reduction to
            generalized upper Hessenberg form of a complex matrix pair (A,B):

               A = Q1*H*Z1**H,  B = Q1*T*Z1**H,

            as computed by CGGHRD.

            If JOB='S', then the Hessenberg-triangular pair (H,T) is
            also reduced to generalized Schur form,

               H = Q*S*Z**H,  T = Q*P*Z**H,

            where Q and Z are unitary matrices and S and P are upper triangular.

            Optionally, the unitary matrix Q from the generalized Schur
            factorization may be postmultiplied into an input matrix Q1, and the
            unitary matrix Z may be postmultiplied into an input matrix Z1.
            If Q1 and Z1 are the unitary matrices from CGGHRD that reduced
            the matrix pair (A,B) to generalized Hessenberg form, then the output
            matrices Q1*Q and Z1*Z are the unitary factors from the generalized
            Schur factorization of (A,B):

               A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.

            To avoid overflow, eigenvalues of the matrix pair (H,T)
            (equivalently, of (A,B)) are computed as a pair of complex values
            (alpha,beta).  If beta is nonzero, lambda = alpha / beta is an
            eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
               A*x = lambda*B*x
            and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
            alternate form of the GNEP
               mu*A*y = B*y.
            The values of alpha and beta for the i-th eigenvalue can be read
            directly from the generalized Schur form:  alpha = S(i,i),
            beta = P(i,i).

            Ref: C.B. Moler &amp; G.W. Stewart, 'An Algorithm for Generalized Matrix
                 Eigenvalue Problems', SIAM J. Numer. Anal., <a href="../man1973/10.1973.html">10</a>(1973),
                 pp. 241--256.

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is CHARACTER*1
                     = 'E': Compute eigenvalues only;
                     = 'S': Computer eigenvalues and the Schur form.

           <u>COMPQ</u>

                     COMPQ is CHARACTER*1
                     = 'N': Left Schur vectors (Q) are not computed;
                     = 'I': Q is initialized to the unit matrix and the matrix Q
                            of left Schur vectors of (H,T) is returned;
                     = 'V': Q must contain a unitary matrix Q1 on entry and
                            the product Q1*Q is returned.

           <u>COMPZ</u>

                     COMPZ is CHARACTER*1
                     = 'N': Right Schur vectors (Z) are not computed;
                     = 'I': Q is initialized to the unit matrix and the matrix Z
                            of right Schur vectors of (H,T) is returned;
                     = 'V': Z must contain a unitary matrix Z1 on entry and
                            the product Z1*Z is returned.

           <u>N</u>

                     N is INTEGER
                     The order of the matrices H, T, Q, and Z.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER
                     ILO and IHI mark the rows and columns of H which are in
                     Hessenberg form.  It is assumed that A is already upper
                     triangular in rows and columns 1:ILO-1 and IHI+1:N.
                     If N &gt; 0, 1 &lt;= ILO &lt;= IHI &lt;= N; if N = 0, ILO=1 and IHI=0.

           <u>H</u>

                     H is COMPLEX array, dimension (LDH, N)
                     On entry, the N-by-N upper Hessenberg matrix H.
                     On exit, if JOB = 'S', H contains the upper triangular
                     matrix S from the generalized Schur factorization.
                     If JOB = 'E', the diagonal of H matches that of S, but
                     the rest of H is unspecified.

           <u>LDH</u>

                     LDH is INTEGER
                     The leading dimension of the array H.  LDH &gt;= max( 1, N ).

           <u>T</u>

                     T is COMPLEX array, dimension (LDT, N)
                     On entry, the N-by-N upper triangular matrix T.
                     On exit, if JOB = 'S', T contains the upper triangular
                     matrix P from the generalized Schur factorization.
                     If JOB = 'E', the diagonal of T matches that of P, but
                     the rest of T is unspecified.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= max( 1, N ).

           <u>ALPHA</u>

                     ALPHA is COMPLEX array, dimension (N)
                     The complex scalars alpha that define the eigenvalues of
                     GNEP.  ALPHA(i) = S(i,i) in the generalized Schur
                     factorization.

           <u>BETA</u>

                     BETA is COMPLEX array, dimension (N)
                     The real non-negative scalars beta that define the
                     eigenvalues of GNEP.  BETA(i) = P(i,i) in the generalized
                     Schur factorization.

                     Together, the quantities alpha = ALPHA(j) and beta = BETA(j)
                     represent the j-th eigenvalue of the matrix pair (A,B), in
                     one of the forms lambda = alpha/beta or mu = beta/alpha.
                     Since either lambda or mu may overflow, they should not,
                     in general, be computed.

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ, N)
                     On entry, if COMPQ = 'V', the unitary matrix Q1 used in the
                     reduction of (A,B) to generalized Hessenberg form.
                     On exit, if COMPQ = 'I', the unitary matrix of left Schur
                     vectors of (H,T), and if COMPQ = 'V', the unitary matrix of
                     left Schur vectors of (A,B).
                     Not referenced if COMPQ = 'N'.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.  LDQ &gt;= 1.
                     If COMPQ='V' or 'I', then LDQ &gt;= N.

           <u>Z</u>

                     Z is COMPLEX array, dimension (LDZ, N)
                     On entry, if COMPZ = 'V', the unitary matrix Z1 used in the
                     reduction of (A,B) to generalized Hessenberg form.
                     On exit, if COMPZ = 'I', the unitary matrix of right Schur
                     vectors of (H,T), and if COMPZ = 'V', the unitary matrix of
                     right Schur vectors of (A,B).
                     Not referenced if COMPZ = 'N'.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1.
                     If COMPZ='V' or 'I', then LDZ &gt;= N.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO &gt;= 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.  LWORK &gt;= max(1,N).

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     = 1,...,N: the QZ iteration did not converge.  (H,T) is not
                                in Schur form, but ALPHA(i) and BETA(i),
                                i=INFO+1,...,N should be correct.
                     = N+1,...,2*N: the shift calculation failed.  (H,T) is not
                                in Schur form, but ALPHA(i) and BETA(i),
                                i=INFO-N+1,...,N should be correct.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             We assume that complex ABS works as long as its value is less than
             overflow.

   <b>subroutine</b> <b>dhgeqz</b> <b>(character</b> <b>job,</b> <b>character</b> <b>compq,</b> <b>character</b> <b>compz,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>ilo,</b> <b>integer</b> <b>ihi,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>h,</b> <b>integer</b> <b>ldh,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>t,</b> <b>integer</b>
       <b>ldt,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>alphar,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>alphai,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>beta,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>q,</b> <b>integer</b> <b>ldq,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>ldz,</b> <b>*</b> <b>)</b> <b>z,</b> <b>integer</b> <b>ldz,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>DHGEQZ</b>

       <b>Purpose:</b>

            DHGEQZ computes the eigenvalues of a real matrix pair (H,T),
            where H is an upper Hessenberg matrix and T is upper triangular,
            using the double-shift QZ method.
            Matrix pairs of this type are produced by the reduction to
            generalized upper Hessenberg form of a real matrix pair (A,B):

               A = Q1*H*Z1**T,  B = Q1*T*Z1**T,

            as computed by DGGHRD.

            If JOB='S', then the Hessenberg-triangular pair (H,T) is
            also reduced to generalized Schur form,

               H = Q*S*Z**T,  T = Q*P*Z**T,

            where Q and Z are orthogonal matrices, P is an upper triangular
            matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
            diagonal blocks.

            The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
            (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
            eigenvalues.

            Additionally, the 2-by-2 upper triangular diagonal blocks of P
            corresponding to 2-by-2 blocks of S are reduced to positive diagonal
            form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
            P(j,j) &gt; 0, and P(j+1,j+1) &gt; 0.

            Optionally, the orthogonal matrix Q from the generalized Schur
            factorization may be postmultiplied into an input matrix Q1, and the
            orthogonal matrix Z may be postmultiplied into an input matrix Z1.
            If Q1 and Z1 are the orthogonal matrices from DGGHRD that reduced
            the matrix pair (A,B) to generalized upper Hessenberg form, then the
            output matrices Q1*Q and Z1*Z are the orthogonal factors from the
            generalized Schur factorization of (A,B):

               A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.

            To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
            of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
            complex and beta real.
            If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
            generalized nonsymmetric eigenvalue problem (GNEP)
               A*x = lambda*B*x
            and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
            alternate form of the GNEP
               mu*A*y = B*y.
            Real eigenvalues can be read directly from the generalized Schur
            form:
              alpha = S(i,i), beta = P(i,i).

            Ref: C.B. Moler &amp; G.W. Stewart, 'An Algorithm for Generalized Matrix
                 Eigenvalue Problems', SIAM J. Numer. Anal., <a href="../man1973/10.1973.html">10</a>(1973),
                 pp. 241--256.

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is CHARACTER*1
                     = 'E': Compute eigenvalues only;
                     = 'S': Compute eigenvalues and the Schur form.

           <u>COMPQ</u>

                     COMPQ is CHARACTER*1
                     = 'N': Left Schur vectors (Q) are not computed;
                     = 'I': Q is initialized to the unit matrix and the matrix Q
                            of left Schur vectors of (H,T) is returned;
                     = 'V': Q must contain an orthogonal matrix Q1 on entry and
                            the product Q1*Q is returned.

           <u>COMPZ</u>

                     COMPZ is CHARACTER*1
                     = 'N': Right Schur vectors (Z) are not computed;
                     = 'I': Z is initialized to the unit matrix and the matrix Z
                            of right Schur vectors of (H,T) is returned;
                     = 'V': Z must contain an orthogonal matrix Z1 on entry and
                            the product Z1*Z is returned.

           <u>N</u>

                     N is INTEGER
                     The order of the matrices H, T, Q, and Z.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER
                     ILO and IHI mark the rows and columns of H which are in
                     Hessenberg form.  It is assumed that A is already upper
                     triangular in rows and columns 1:ILO-1 and IHI+1:N.
                     If N &gt; 0, 1 &lt;= ILO &lt;= IHI &lt;= N; if N = 0, ILO=1 and IHI=0.

           <u>H</u>

                     H is DOUBLE PRECISION array, dimension (LDH, N)
                     On entry, the N-by-N upper Hessenberg matrix H.
                     On exit, if JOB = 'S', H contains the upper quasi-triangular
                     matrix S from the generalized Schur factorization.
                     If JOB = 'E', the diagonal blocks of H match those of S, but
                     the rest of H is unspecified.

           <u>LDH</u>

                     LDH is INTEGER
                     The leading dimension of the array H.  LDH &gt;= max( 1, N ).

           <u>T</u>

                     T is DOUBLE PRECISION array, dimension (LDT, N)
                     On entry, the N-by-N upper triangular matrix T.
                     On exit, if JOB = 'S', T contains the upper triangular
                     matrix P from the generalized Schur factorization;
                     2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks of S
                     are reduced to positive diagonal form, i.e., if H(j+1,j) is
                     non-zero, then T(j+1,j) = T(j,j+1) = 0, T(j,j) &gt; 0, and
                     T(j+1,j+1) &gt; 0.
                     If JOB = 'E', the diagonal blocks of T match those of P, but
                     the rest of T is unspecified.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= max( 1, N ).

           <u>ALPHAR</u>

                     ALPHAR is DOUBLE PRECISION array, dimension (N)
                     The real parts of each scalar alpha defining an eigenvalue
                     of GNEP.

           <u>ALPHAI</u>

                     ALPHAI is DOUBLE PRECISION array, dimension (N)
                     The imaginary parts of each scalar alpha defining an
                     eigenvalue of GNEP.
                     If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
                     positive, then the j-th and (j+1)-st eigenvalues are a
                     complex conjugate pair, with ALPHAI(j+1) = -ALPHAI(j).

           <u>BETA</u>

                     BETA is DOUBLE PRECISION array, dimension (N)
                     The scalars beta that define the eigenvalues of GNEP.
                     Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and
                     beta = BETA(j) represent the j-th eigenvalue of the matrix
                     pair (A,B), in one of the forms lambda = alpha/beta or
                     mu = beta/alpha.  Since either lambda or mu may overflow,
                     they should not, in general, be computed.

           <u>Q</u>

                     Q is DOUBLE PRECISION array, dimension (LDQ, N)
                     On entry, if COMPQ = 'V', the orthogonal matrix Q1 used in
                     the reduction of (A,B) to generalized Hessenberg form.
                     On exit, if COMPQ = 'I', the orthogonal matrix of left Schur
                     vectors of (H,T), and if COMPQ = 'V', the orthogonal matrix
                     of left Schur vectors of (A,B).
                     Not referenced if COMPQ = 'N'.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.  LDQ &gt;= 1.
                     If COMPQ='V' or 'I', then LDQ &gt;= N.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (LDZ, N)
                     On entry, if COMPZ = 'V', the orthogonal matrix Z1 used in
                     the reduction of (A,B) to generalized Hessenberg form.
                     On exit, if COMPZ = 'I', the orthogonal matrix of
                     right Schur vectors of (H,T), and if COMPZ = 'V', the
                     orthogonal matrix of right Schur vectors of (A,B).
                     Not referenced if COMPZ = 'N'.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1.
                     If COMPZ='V' or 'I', then LDZ &gt;= N.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
                     On exit, if INFO &gt;= 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.  LWORK &gt;= max(1,N).

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     = 1,...,N: the QZ iteration did not converge.  (H,T) is not
                                in Schur form, but ALPHAR(i), ALPHAI(i), and
                                BETA(i), i=INFO+1,...,N should be correct.
                     = N+1,...,2*N: the shift calculation failed.  (H,T) is not
                                in Schur form, but ALPHAR(i), ALPHAI(i), and
                                BETA(i), i=INFO-N+1,...,N should be correct.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Iteration counters:

             JITER  -- counts iterations.
             IITER  -- counts iterations run since ILAST was last
                       changed.  This is therefore reset only when a 1-by-1 or
                       2-by-2 block deflates off the bottom.

   <b>subroutine</b> <b>shgeqz</b> <b>(character</b> <b>job,</b> <b>character</b> <b>compq,</b> <b>character</b> <b>compz,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>ilo,</b> <b>integer</b> <b>ihi,</b>
       <b>real,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>h,</b> <b>integer</b> <b>ldh,</b> <b>real,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>t,</b> <b>integer</b> <b>ldt,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>alphar,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>alphai,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>beta,</b> <b>real,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>q,</b> <b>integer</b> <b>ldq,</b>
       <b>real,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>z,</b> <b>integer</b> <b>ldz,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>SHGEQZ</b>

       <b>Purpose:</b>

            SHGEQZ computes the eigenvalues of a real matrix pair (H,T),
            where H is an upper Hessenberg matrix and T is upper triangular,
            using the double-shift QZ method.
            Matrix pairs of this type are produced by the reduction to
            generalized upper Hessenberg form of a real matrix pair (A,B):

               A = Q1*H*Z1**T,  B = Q1*T*Z1**T,

            as computed by SGGHRD.

            If JOB='S', then the Hessenberg-triangular pair (H,T) is
            also reduced to generalized Schur form,

               H = Q*S*Z**T,  T = Q*P*Z**T,

            where Q and Z are orthogonal matrices, P is an upper triangular
            matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
            diagonal blocks.

            The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
            (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
            eigenvalues.

            Additionally, the 2-by-2 upper triangular diagonal blocks of P
            corresponding to 2-by-2 blocks of S are reduced to positive diagonal
            form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
            P(j,j) &gt; 0, and P(j+1,j+1) &gt; 0.

            Optionally, the orthogonal matrix Q from the generalized Schur
            factorization may be postmultiplied into an input matrix Q1, and the
            orthogonal matrix Z may be postmultiplied into an input matrix Z1.
            If Q1 and Z1 are the orthogonal matrices from SGGHRD that reduced
            the matrix pair (A,B) to generalized upper Hessenberg form, then the
            output matrices Q1*Q and Z1*Z are the orthogonal factors from the
            generalized Schur factorization of (A,B):

               A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.

            To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
            of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
            complex and beta real.
            If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
            generalized nonsymmetric eigenvalue problem (GNEP)
               A*x = lambda*B*x
            and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
            alternate form of the GNEP
               mu*A*y = B*y.
            Real eigenvalues can be read directly from the generalized Schur
            form:
              alpha = S(i,i), beta = P(i,i).

            Ref: C.B. Moler &amp; G.W. Stewart, 'An Algorithm for Generalized Matrix
                 Eigenvalue Problems', SIAM J. Numer. Anal., <a href="../man1973/10.1973.html">10</a>(1973),
                 pp. 241--256.

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is CHARACTER*1
                     = 'E': Compute eigenvalues only;
                     = 'S': Compute eigenvalues and the Schur form.

           <u>COMPQ</u>

                     COMPQ is CHARACTER*1
                     = 'N': Left Schur vectors (Q) are not computed;
                     = 'I': Q is initialized to the unit matrix and the matrix Q
                            of left Schur vectors of (H,T) is returned;
                     = 'V': Q must contain an orthogonal matrix Q1 on entry and
                            the product Q1*Q is returned.

           <u>COMPZ</u>

                     COMPZ is CHARACTER*1
                     = 'N': Right Schur vectors (Z) are not computed;
                     = 'I': Z is initialized to the unit matrix and the matrix Z
                            of right Schur vectors of (H,T) is returned;
                     = 'V': Z must contain an orthogonal matrix Z1 on entry and
                            the product Z1*Z is returned.

           <u>N</u>

                     N is INTEGER
                     The order of the matrices H, T, Q, and Z.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER
                     ILO and IHI mark the rows and columns of H which are in
                     Hessenberg form.  It is assumed that A is already upper
                     triangular in rows and columns 1:ILO-1 and IHI+1:N.
                     If N &gt; 0, 1 &lt;= ILO &lt;= IHI &lt;= N; if N = 0, ILO=1 and IHI=0.

           <u>H</u>

                     H is REAL array, dimension (LDH, N)
                     On entry, the N-by-N upper Hessenberg matrix H.
                     On exit, if JOB = 'S', H contains the upper quasi-triangular
                     matrix S from the generalized Schur factorization.
                     If JOB = 'E', the diagonal blocks of H match those of S, but
                     the rest of H is unspecified.

           <u>LDH</u>

                     LDH is INTEGER
                     The leading dimension of the array H.  LDH &gt;= max( 1, N ).

           <u>T</u>

                     T is REAL array, dimension (LDT, N)
                     On entry, the N-by-N upper triangular matrix T.
                     On exit, if JOB = 'S', T contains the upper triangular
                     matrix P from the generalized Schur factorization;
                     2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks of S
                     are reduced to positive diagonal form, i.e., if H(j+1,j) is
                     non-zero, then T(j+1,j) = T(j,j+1) = 0, T(j,j) &gt; 0, and
                     T(j+1,j+1) &gt; 0.
                     If JOB = 'E', the diagonal blocks of T match those of P, but
                     the rest of T is unspecified.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= max( 1, N ).

           <u>ALPHAR</u>

                     ALPHAR is REAL array, dimension (N)
                     The real parts of each scalar alpha defining an eigenvalue
                     of GNEP.

           <u>ALPHAI</u>

                     ALPHAI is REAL array, dimension (N)
                     The imaginary parts of each scalar alpha defining an
                     eigenvalue of GNEP.
                     If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
                     positive, then the j-th and (j+1)-st eigenvalues are a
                     complex conjugate pair, with ALPHAI(j+1) = -ALPHAI(j).

           <u>BETA</u>

                     BETA is REAL array, dimension (N)
                     The scalars beta that define the eigenvalues of GNEP.
                     Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and
                     beta = BETA(j) represent the j-th eigenvalue of the matrix
                     pair (A,B), in one of the forms lambda = alpha/beta or
                     mu = beta/alpha.  Since either lambda or mu may overflow,
                     they should not, in general, be computed.

           <u>Q</u>

                     Q is REAL array, dimension (LDQ, N)
                     On entry, if COMPQ = 'V', the orthogonal matrix Q1 used in
                     the reduction of (A,B) to generalized Hessenberg form.
                     On exit, if COMPQ = 'I', the orthogonal matrix of left Schur
                     vectors of (H,T), and if COMPQ = 'V', the orthogonal matrix
                     of left Schur vectors of (A,B).
                     Not referenced if COMPQ = 'N'.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.  LDQ &gt;= 1.
                     If COMPQ='V' or 'I', then LDQ &gt;= N.

           <u>Z</u>

                     Z is REAL array, dimension (LDZ, N)
                     On entry, if COMPZ = 'V', the orthogonal matrix Z1 used in
                     the reduction of (A,B) to generalized Hessenberg form.
                     On exit, if COMPZ = 'I', the orthogonal matrix of
                     right Schur vectors of (H,T), and if COMPZ = 'V', the
                     orthogonal matrix of right Schur vectors of (A,B).
                     Not referenced if COMPZ = 'N'.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1.
                     If COMPZ='V' or 'I', then LDZ &gt;= N.

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK))
                     On exit, if INFO &gt;= 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.  LWORK &gt;= max(1,N).

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     = 1,...,N: the QZ iteration did not converge.  (H,T) is not
                                in Schur form, but ALPHAR(i), ALPHAI(i), and
                                BETA(i), i=INFO+1,...,N should be correct.
                     = N+1,...,2*N: the shift calculation failed.  (H,T) is not
                                in Schur form, but ALPHAR(i), ALPHAI(i), and
                                BETA(i), i=INFO-N+1,...,N should be correct.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Iteration counters:

             JITER  -- counts iterations.
             IITER  -- counts iterations run since ILAST was last
                       changed.  This is therefore reset only when a 1-by-1 or
                       2-by-2 block deflates off the bottom.

   <b>subroutine</b> <b>zhgeqz</b> <b>(character</b> <b>job,</b> <b>character</b> <b>compq,</b> <b>character</b> <b>compz,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>ilo,</b> <b>integer</b> <b>ihi,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>h,</b> <b>integer</b> <b>ldh,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>t,</b> <b>integer</b> <b>ldt,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>alpha,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>beta,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>q,</b>
       <b>integer</b> <b>ldq,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>z,</b> <b>integer</b> <b>ldz,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b>
       <b>lwork,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>rwork,</b> <b>integer</b> <b>info)</b>
       <b>ZHGEQZ</b>

       <b>Purpose:</b>

            ZHGEQZ computes the eigenvalues of a complex matrix pair (H,T),
            where H is an upper Hessenberg matrix and T is upper triangular,
            using the single-shift QZ method.
            Matrix pairs of this type are produced by the reduction to
            generalized upper Hessenberg form of a complex matrix pair (A,B):

               A = Q1*H*Z1**H,  B = Q1*T*Z1**H,

            as computed by ZGGHRD.

            If JOB='S', then the Hessenberg-triangular pair (H,T) is
            also reduced to generalized Schur form,

               H = Q*S*Z**H,  T = Q*P*Z**H,

            where Q and Z are unitary matrices and S and P are upper triangular.

            Optionally, the unitary matrix Q from the generalized Schur
            factorization may be postmultiplied into an input matrix Q1, and the
            unitary matrix Z may be postmultiplied into an input matrix Z1.
            If Q1 and Z1 are the unitary matrices from ZGGHRD that reduced
            the matrix pair (A,B) to generalized Hessenberg form, then the output
            matrices Q1*Q and Z1*Z are the unitary factors from the generalized
            Schur factorization of (A,B):

               A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.

            To avoid overflow, eigenvalues of the matrix pair (H,T)
            (equivalently, of (A,B)) are computed as a pair of complex values
            (alpha,beta).  If beta is nonzero, lambda = alpha / beta is an
            eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
               A*x = lambda*B*x
            and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
            alternate form of the GNEP
               mu*A*y = B*y.
            The values of alpha and beta for the i-th eigenvalue can be read
            directly from the generalized Schur form:  alpha = S(i,i),
            beta = P(i,i).

            Ref: C.B. Moler &amp; G.W. Stewart, 'An Algorithm for Generalized Matrix
                 Eigenvalue Problems', SIAM J. Numer. Anal., <a href="../man1973/10.1973.html">10</a>(1973),
                 pp. 241--256.

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is CHARACTER*1
                     = 'E': Compute eigenvalues only;
                     = 'S': Computer eigenvalues and the Schur form.

           <u>COMPQ</u>

                     COMPQ is CHARACTER*1
                     = 'N': Left Schur vectors (Q) are not computed;
                     = 'I': Q is initialized to the unit matrix and the matrix Q
                            of left Schur vectors of (H,T) is returned;
                     = 'V': Q must contain a unitary matrix Q1 on entry and
                            the product Q1*Q is returned.

           <u>COMPZ</u>

                     COMPZ is CHARACTER*1
                     = 'N': Right Schur vectors (Z) are not computed;
                     = 'I': Q is initialized to the unit matrix and the matrix Z
                            of right Schur vectors of (H,T) is returned;
                     = 'V': Z must contain a unitary matrix Z1 on entry and
                            the product Z1*Z is returned.

           <u>N</u>

                     N is INTEGER
                     The order of the matrices H, T, Q, and Z.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER
                     ILO and IHI mark the rows and columns of H which are in
                     Hessenberg form.  It is assumed that A is already upper
                     triangular in rows and columns 1:ILO-1 and IHI+1:N.
                     If N &gt; 0, 1 &lt;= ILO &lt;= IHI &lt;= N; if N = 0, ILO=1 and IHI=0.

           <u>H</u>

                     H is COMPLEX*16 array, dimension (LDH, N)
                     On entry, the N-by-N upper Hessenberg matrix H.
                     On exit, if JOB = 'S', H contains the upper triangular
                     matrix S from the generalized Schur factorization.
                     If JOB = 'E', the diagonal of H matches that of S, but
                     the rest of H is unspecified.

           <u>LDH</u>

                     LDH is INTEGER
                     The leading dimension of the array H.  LDH &gt;= max( 1, N ).

           <u>T</u>

                     T is COMPLEX*16 array, dimension (LDT, N)
                     On entry, the N-by-N upper triangular matrix T.
                     On exit, if JOB = 'S', T contains the upper triangular
                     matrix P from the generalized Schur factorization.
                     If JOB = 'E', the diagonal of T matches that of P, but
                     the rest of T is unspecified.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= max( 1, N ).

           <u>ALPHA</u>

                     ALPHA is COMPLEX*16 array, dimension (N)
                     The complex scalars alpha that define the eigenvalues of
                     GNEP.  ALPHA(i) = S(i,i) in the generalized Schur
                     factorization.

           <u>BETA</u>

                     BETA is COMPLEX*16 array, dimension (N)
                     The real non-negative scalars beta that define the
                     eigenvalues of GNEP.  BETA(i) = P(i,i) in the generalized
                     Schur factorization.

                     Together, the quantities alpha = ALPHA(j) and beta = BETA(j)
                     represent the j-th eigenvalue of the matrix pair (A,B), in
                     one of the forms lambda = alpha/beta or mu = beta/alpha.
                     Since either lambda or mu may overflow, they should not,
                     in general, be computed.

           <u>Q</u>

                     Q is COMPLEX*16 array, dimension (LDQ, N)
                     On entry, if COMPQ = 'V', the unitary matrix Q1 used in the
                     reduction of (A,B) to generalized Hessenberg form.
                     On exit, if COMPQ = 'I', the unitary matrix of left Schur
                     vectors of (H,T), and if COMPQ = 'V', the unitary matrix of
                     left Schur vectors of (A,B).
                     Not referenced if COMPQ = 'N'.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.  LDQ &gt;= 1.
                     If COMPQ='V' or 'I', then LDQ &gt;= N.

           <u>Z</u>

                     Z is COMPLEX*16 array, dimension (LDZ, N)
                     On entry, if COMPZ = 'V', the unitary matrix Z1 used in the
                     reduction of (A,B) to generalized Hessenberg form.
                     On exit, if COMPZ = 'I', the unitary matrix of right Schur
                     vectors of (H,T), and if COMPZ = 'V', the unitary matrix of
                     right Schur vectors of (A,B).
                     Not referenced if COMPZ = 'N'.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1.
                     If COMPZ='V' or 'I', then LDZ &gt;= N.

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
                     On exit, if INFO &gt;= 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.  LWORK &gt;= max(1,N).

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>RWORK</u>

                     RWORK is DOUBLE PRECISION array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     = 1,...,N: the QZ iteration did not converge.  (H,T) is not
                                in Schur form, but ALPHA(i) and BETA(i),
                                i=INFO+1,...,N should be correct.
                     = N+1,...,2*N: the shift calculation failed.  (H,T) is not
                                in Schur form, but ALPHA(i) and BETA(i),
                                i=INFO-N+1,...,N should be correct.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             We assume that complex ABS works as long as its value is less than
             overflow.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                              Sun Jul 20 2025 01:40:05                                    <u><a href="../man3/hgeqz.3.html">hgeqz</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>