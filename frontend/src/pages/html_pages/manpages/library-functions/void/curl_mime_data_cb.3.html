<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>curl_mime_data_cb - set a callback-based data source for a mime part's body</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       curl_mime_data_cb - set a callback-based data source for a mime part's body

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       size_t readfunc(char *buffer, size_t size, size_t nitems, void *arg);

       int seekfunc(void *arg, curl_off_t offset, int origin);

       void freefunc(void *arg);

       CURLcode curl_mime_data_cb(curl_mimepart *part, curl_off_t datasize,
                                  curl_read_callback readfunc,
                                  curl_seek_callback seekfunc,
                                  curl_free_callback freefunc, void *arg);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u><a href="../man3/curl_mime_data_cb.3.html">curl_mime_data_cb</a>(3)</u>  sets  the  data  source  of  a  mime  part's body content from a data read callback
       function.

       <u>part</u> is the part's to assign contents to.

       <u>readfunc</u> is a pointer to a data read callback function, with a signature as shown by the above prototype.
       It may not be set to NULL.

       <u>seekfunc</u> is a pointer to a seek callback function, with a signature as shown by the above prototype. This
       function is used when resending data (i.e.: after a redirect); this pointer may be set to NULL, in  which
       case a resend might not be not possible.

       <u>freefunc</u>  is  a  pointer  to  a user resource freeing callback function, with a signature as shown by the
       above prototype. If no resource is to be freed, it may safely be set to NULL.  This  function  is  called
       upon mime structure freeing.

       <u>arg</u> is a user defined argument to callback functions.

       The read callback function gets called by libcurl as soon as it needs to read data in order to send it to
       the  peer  -  like  if  you  ask it to upload or post data to the server. The data area pointed at by the
       pointer <u>buffer</u> should be filled up with at most <u>size</u> multiplied with  <u>nitems</u>  number  of  bytes  by  your
       function.

       Your  read  function  must  then  return  the  actual number of bytes that it stored in that memory area.
       Returning 0 signals end-of-file to the library and cause it to stop the current transfer.

       If you stop the current transfer by returning 0 "pre-maturely" (i.e. before the server expected it,  like
       when you have said you intend to upload N bytes and yet you upload less than N bytes), you may experience
       that the server "hangs" waiting for the rest of the data that does not come.

       The  read callback may return <u>CURL_READFUNC_ABORT</u> to stop the current operation immediately, resulting in
       a <u>CURLE_ABORTED_BY_CALLBACK</u> error code from the transfer.

       The callback can return  <u>CURL_READFUNC_PAUSE</u>  to  cause  reading  from  this  connection  to  pause.  See
       <u><a href="../man3/curl_easy_pause.3.html">curl_easy_pause</a>(3)</u> for further details.

       The  seek  function  gets called by libcurl to rewind input stream data or to seek to a certain position.
       The function shall work like <a href="../man3/fseek.3.html">fseek</a>(3) or <a href="../man3/lseek.3.html">lseek</a>(3) and it gets SEEK_SET, SEEK_CUR or SEEK_END as  argument
       for <u>origin</u>, although libcurl currently only passes SEEK_SET.

       The  callback  function  must  return <u>CURL_SEEKFUNC_OK</u> on success, <u>CURL_SEEKFUNC_FAIL</u> to cause the upload
       operation to fail or <u>CURL_SEEKFUNC_CANTSEEK</u> to indicate that while the seek failed, libcurl  is  free  to
       work  around  the problem if possible. The latter can sometimes be done by instead reading from the input
       or similar.

       Care must be taken if the part is bound to a curl easy handle that is later duplicated: the  <u>arg</u>  pointer
       argument  is  also  duplicated,  resulting  in the pointed item to be shared between the original and the
       copied handle. In particular, special attention should be given to the <u>freefunc</u> procedure code  since  it
       then gets called twice with the same argument.

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects http, imap and smtp

</pre><h4><b>EXAMPLE</b></h4><pre>
       Sending  a huge data string causes the same amount of memory to be allocated: to avoid overhead resources
       consumption, one might want to use a callback source to avoid data duplication. In  this  case,  original
       data must be retained until after the transfer terminates.
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt; /* for memcpy */
       char hugedata[512000];

       struct ctl {
         char *buffer;
         curl_off_t size;
         curl_off_t position;
       };

       size_t read_callback(char *buffer, size_t size, size_t nitems, void *arg)
       {
         struct ctl *p = (struct ctl *) arg;
         curl_off_t sz = p-&gt;size - p-&gt;position;

         nitems *= size;
         if(sz &gt; nitems)
           sz = nitems;
         if(sz)
           memcpy(buffer, p-&gt;buffer + p-&gt;position, sz);
         p-&gt;position += sz;
         return sz;
       }

       int seek_callback(void *arg, curl_off_t offset, int origin)
       {
         struct ctl *p = (struct ctl *) arg;

         switch(origin) {
         case SEEK_END:
           offset += p-&gt;size;
           break;
         case SEEK_CUR:
           offset += p-&gt;position;
           break;
         }

         if(offset &lt; 0)
           return CURL_SEEKFUNC_FAIL;
         p-&gt;position = offset;
         return CURL_SEEKFUNC_OK;
       }

       int main(void)
       {
         CURL *curl = curl_easy_init();
         if(curl) {
           curl_mime *mime = curl_mime_init(curl);
           curl_mimepart *part = <a href="../manmime/curl_mime_addpart.mime.html">curl_mime_addpart</a>(mime);
           struct ctl hugectl;

           hugectl.buffer = hugedata;
           hugectl.size = sizeof(hugedata);
           hugectl.position = 0;
           curl_mime_data_cb(part, hugectl.size, read_callback, seek_callback, NULL,
                             &amp;hugectl);
         }
       }

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.56.0

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       This function returns a CURLcode indicating success or error.

       CURLE_OK  (0)  means  everything  was  OK,  non-zero  means  an error occurred, see <u><a href="../man3/libcurl-errors.3.html">libcurl-errors</a>(3)</u>. If
       <u><a href="../man3/CURLOPT_ERRORBUFFER.3.html">CURLOPT_ERRORBUFFER</a>(3)</u> was set with <u><a href="../man3/curl_easy_setopt.3.html">curl_easy_setopt</a>(3)</u> there can be an error message stored in the error
       buffer when non-zero is returned.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/curl_easy_duphandle.3.html">curl_easy_duphandle</a></b>(3), <b><a href="../man3/curl_mime_addpart.3.html">curl_mime_addpart</a></b>(3), <b><a href="../man3/curl_mime_data.3.html">curl_mime_data</a></b>(3), <b><a href="../man3/curl_mime_name.3.html">curl_mime_name</a></b>(3)

libcurl                                            2025-06-16                               <u><a href="../man3/curl_mime_data_cb.3.html">curl_mime_data_cb</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>