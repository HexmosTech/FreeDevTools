<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>__pmAFsetup,  __pmAFregister,  __pmAFunregister,  __pmAFblock, __pmAFunblock, __pmAFisempty - event queue</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpcp3-dev">libpcp3-dev_6.3.8-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>__pmAFsetup</b>,  <b>__pmAFregister</b>,  <b>__pmAFunregister</b>,  <b>__pmAFblock</b>, <b>__pmAFunblock</b>, <b>__pmAFisempty</b> - event queue
       services for periodic asynchronous callbacks

</pre><h4><b>C</b> <b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>"pmapi.h"</b>
       <b>#include</b> <b>"libpcp.h"</b>

       <b>int</b> <b>__pmAFsetup(const</b> <b>struct</b> <b>timeval</b> <b>*</b><u>start</u><b>,</b> <b>const</b> <b>struct</b> <b>timeval</b> <b>*</b><u>delta</u><b>,</b> <b>void</b> <b>*</b><u>data</u><b>,</b>
               <b>void</b> <b>(*</b><u>func</u><b>)(int,</b> <b>void</b> <b>*));</b>
       <b>int</b> <b>__pmAFregister(const</b> <b>struct</b> <b>timeval</b> <b>*</b><u>delta</u><b>,</b> <b>void</b> <b>*</b><u>data</u><b>,</b> <b>void</b> <b>(*</b><u>func</u><b>)(int,</b> <b>void</b> <b>*));</b>
       <b>int</b> <b>__pmAFunregister(int</b> <u>afid</u><b>);</b>
       <b>void</b> <b>__pmAFblock(void);</b>
       <b>void</b> <b>__pmAFunblock(void);</b>
       <b>int</b> <b>__pmAFisempty(void);</b>

       <b>cc</b> <b>...</b> <b>-lpcp</b>

</pre><h4><b>CAVEAT</b></h4><pre>
       This documentation is intended for internal Performance Co-Pilot (PCP) developer use.

       These interfaces are not part of the PCP APIs that are guaranteed to remain fixed  across  releases,  and
       they may not work, or may provide different semantics at some point in the future.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  routines  implement an event queue and callback framework that supports periodic evaluation of a se‐
       ries of events with varying frequencies for Performance Co-Pilot (PCP) applications.

       The <b><a href="../man1/pmlogger.1.html">pmlogger</a></b>(1) application, the <b><a href="../man1/pmdatrace.1.html">pmdatrace</a></b>(1) PMDA and the <b><a href="../man1/pmdahotproc.1.html">pmdahotproc</a></b>(1) PMDA are the principal users of
       these services.

       An event is created by calling <b>__pmAFsetup</b> or <b>__pmAFregister</b> and on success the return value is an  event
       number  greater  than  zero.   The event has associated event data identified by the opaque pointer <u>data</u>.
       The event will occur with frequency <u>delta</u> and each time the event occurs the function <u>func</u> will be called
       with the event number and the event data as arguments.

       If <b>__pmAFsetup</b> is used then the first event is scheduled  for  the  current  time  plus  <u>start</u>,  else  if
       <b>__pmAFregister</b> is used then the first event is scheduled for the current time plus <u>delta</u>.

       <u>func</u>  is  called  in  a SIGALRM signal handler context and so the routines that may be safely called from
       <u>func</u> are restricted to the so-called <u>async-signal-safe</u> set.  In particular there must be no Standard  I/O
       calls  nor  calls to any of the <b><a href="../man3/malloc.3.html">malloc</a></b>(3) routines to modify the state of the heap.  Refer to the <u>Pointer</u>
       <u>to</u>   <u>a</u>   <u>Function</u>   Section   of   the    POSIX.1-2013    document    at    <a href="http://pubs.opengroup.org/on">http://pubs.opengroup.org/on</a>‐
       linepubs/9699919799/functions/V2_chap02.html for a fuller description.

       The  safest  and  simplest  class  of <u>func</u> routines are those that do minimal processing, set some global
       state and return.  The real work associated with the event is done subsequently  from  the  application's
       main loop when the global state change is detected.

       Once  the  event  occurs and the callback has been executed, the event will be rescheduled for <u>delta</u> into
       the future, except if all the fields of <u>delta</u> are zero, in which case the event will not  be  rescheduled
       (a ``one trip'' event).

       Internally,  events  are  processed serially so there is no possibility of nested callbacks or re-entrant
       callbacks from the event management routines.

       Given an event number <u>afid</u>, <b>__pmAFunregister</b> will permanently remove the  corresponding  entry  from  the
       event queue.

       To  control the event queue processing, <b>__pmAFblock</b> and <b>__pmAFunblock</b> may be used to explicitly block and
       unblock the dispatch of events.  This is most useful when the caller wishes to set up a number of  events
       via <b>__pmAFsetup</b> or <b>__pmAFregister</b> and complete the registration phase before the first event callback oc‐
       curs.

       A call to <b>__pmAFisempty</b> returns 1 or 0 depending on whether the event queue is empty or not.

</pre><h4><b>CAVEATS</b></h4><pre>
       These  routines rely on <b><a href="../man2/setitimer.2.html">setitimer</a></b>(2) and manipulate the handling of <b>SIGALRM</b> signals, and hence are proba‐
       bly ill-suited for applications that require direct and concurrent  access  to  these  services  and  re‐
       sources.

       If  the  callback functions are slow, or delayed, it is possible that the event scheduling could fall be‐
       hind and never catchup.  When this begins to happen, events are silently skipped and rescheduled  at  the
       earliest  possible  time in the future according to the fixed schedule defined by the time of the call to
       <b>__pmAFsetup</b> and the value of the <u>start</u> and <u>delta</u> arguments (or  defined  by  the  time  of  the  call  to
       <b>__pmAFregister</b> and the value of the <u>delta</u> argument).

       In addition, the semantics of the interval timer(s) and the global state needed to support these services
       demand that applications calling these routines must do so from a single thread.  This restriction is en‐
       forced  at  the  <b><a href="../man3/PMAPI.3.html">PMAPI</a></b>(3),  where routines may return the error code <b>PM_ERR_THREAD</b> if the library detects
       calls from more than one thread.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       <b>__pmAFsetup</b>, <b>__pmAFregister</b> and <b>__pmAFunregister</b> return values less than zero in the case  of  an  error.
       These values are PCP error codes, and may be used to produce error messages via <b><a href="../man3/pmErrStr.3.html">pmErrStr</a></b>(3).

       The  routines  support  the  standard PCP debug tracing, and the <b>af</b> option (or <b>-D</b> <b>af</b> on the command line)
       will produce diagnostics on standard error that trace the enqueuing and execution of events.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/PMAPI.3.html">PMAPI</a></b>(3)

Performance Co-Pilot                                   PCP                                               <u><a href="../man3/PMAF.3.html">PMAF</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>