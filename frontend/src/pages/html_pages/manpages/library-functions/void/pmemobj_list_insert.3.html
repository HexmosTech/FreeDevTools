<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pmemobj_list_insert(), pmemobj_list_insert_new(), pmemobj_list_move(), pmemobj_list_remove() - non-trans‐</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpmemobj-dev">libpmemobj-dev_1.13.1-1.1ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>pmemobj_list_insert</b>(), <b>pmemobj_list_insert_new</b>(), <b>pmemobj_list_move</b>(), <b>pmemobj_list_remove</b>() - non-trans‐
       actional persistent atomic lists functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;libpmemobj.h&gt;

              int pmemobj_list_insert(PMEMobjpool *pop, size_t pe_offset, void *head,
                  PMEMoid dest, int before, PMEMoid oid);

              PMEMoid pmemobj_list_insert_new(PMEMobjpool *pop, size_t pe_offset,
                  void *head, PMEMoid dest, int before, size_t size,
                  uint64_t type_num, pmemobj_constr constructor, void arg);

              int pmemobj_list_move(PMEMobjpool *pop,
                  size_t pe_old_offset, void *head_old,
                  size_t pe_new_offset, void *head_new,
                  PMEMoid dest, int before, PMEMoid oid);

              int pmemobj_list_remove(PMEMobjpool *pop, size_t pe_offset,
                  void *head, PMEMoid oid, int free);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       In  addition  to  the  container operations on internal object collections described in <b><a href="../man3/pmemobj_first.3.html">pmemobj_first</a></b>(3),
       <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) provides a mechanism for organizing persistent objects in user-defined, persistent, atomic,
       circular, doubly-linked lists.  All the routines and macros operating on  the  persistent  lists  provide
       atomicity  with  respect  to any power-fail interruptions.  If any of those operations is torn by program
       failure or system crash, on recovery they are guaranteed to be entirely completed or  discarded,  leaving
       the lists, persistent memory heap and internal object containers in a consistent state.

       The persistent atomic circular doubly linked lists support the following functionality:

       • Insertion of an object at the head of the list, or at the end of the list.

       • Insertion of an object before or after any element in the list.

       • Atomic allocation and insertion of a new object at the head of the list, or at the end of the list.

       • Atomic allocation and insertion of a new object before or after any element in the list.

       • Atomic moving of an element from one list to the specific location on another list.

       • Removal of any object in the list.

       • Atomic removal and freeing of any object in the list.

       • Forward or backward traversal through the list.

       A  list is headed by a <u>list_head</u> structure containing the object handle of the first element on the list.
       The elements are doubly linked so that an arbitrary element can be removed without the need  to  traverse
       the  list.  New elements can be added to the list before or after an existing element, at the head of the
       list, or at the tail of the list.  A list may be traversed in either direction.

       The user-defined structure of each element must contain a field of type <u>list_entry</u> that holds the  object
       handles  to  the previous and next element on the list.  Both the <u>list_head</u> and the <u>list_entry</u> structures
       are declared in <b>&lt;libpmemobj.h&gt;</b>.

       The functions below are intended to be used outside transactions - transactional variants  are  described
       in  manpages to functions mentioned at <b>TRANSACTIONAL</b> <b>OBJECT</b> <b>MANIPULATION</b> in <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7).  Note that op‐
       erations performed using this non-transactional API are independent  from  their  transactional  counter‐
       parts.   If any non-transactional allocations or list manipulations are performed within an open transac‐
       tion, the changes will not be rolled back if such a transaction is aborted or interrupted.

       The list insertion and move functions use a common set of arguments to define where an object will be in‐
       serted into the list.  <u>dest</u> identifies the element before or after which the object will be inserted, or,
       if <u>dest</u> is <b>OID_NULL</b>, indicates that the object should be inserted at the head or tail of the  list.   <u>be‐</u>
       <u>fore</u> determines where the object will be inserted:

       • <b>POBJ_LIST_DEST_BEFORE</b> - insert the element before the existing element <u>dest</u>

       • <b>POBJ_LIST_DEST_AFTER</b> - insert the element after the existing element <u>dest</u>

       • <b>POBJ_LIST_DEST_HEAD</b> - when <u>dest</u> is <b>OID_NULL</b>, insert the element at the head of the list

       • <b>POBJ_LIST_DEST_TAIL</b> - when <u>dest</u> is <b>OID_NULL</b>, insert the element at the tail of the list

         NOTE:  Earlier  versions of <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) do not define <b>POBJ_LIST_DEST_BEFORE</b> and <b>POBJ_LIST_DEST_AFTER</b>.
         Use 1 for before, and 0 for after.

       The <b>pmemobj_list_insert</b>() function inserts the element represented by object handle  <u>oid</u>  into  the  list
       referenced by <u>head</u>, at the location specified by <u>dest</u> and <u>before</u> as described above.  <u>pe_offset</u> specifies
       the  offset  of the structure that connects the elements in the list.  All the handles <u>head</u>, <u>dest</u> and <u>oid</u>
       must point to objects allocated from memory pool <u>pop</u>.  <u>head</u> and <u>oid</u> cannot be <b>OID_NULL</b>.

       The <b>pmemobj_list_insert_new</b>() function atomically allocates a new object of given <u>size</u> and type  <u>type_num</u>
       and inserts it into the list referenced by <u>head</u> at the location specified by <u>dest</u> and <u>before</u> as described
       above.  <u>pe_offset</u> specifies the offset of the structure that connects the elements in the list.  The han‐
       dles  <u>head</u>  and  <u>dest</u>  must  point  to  objects allocated from memory pool <u>pop</u>.  Before returning, <b>pmemo‐</b>
       <b>bj_list_insert_new</b>() calls the <u>constructor</u> function, passing the pool handle <u>pop</u>, the pointer to the new‐
       ly allocated object <u>ptr</u>, and the <u>arg</u> argument.  It is guaranteed that  the  allocated  object  is  either
       properly  initialized  or,  if the allocation is interrupted before the constructor completes, the memory
       space reserved for the object is reclaimed.  <u>head</u> cannot be <b>OID_NULL</b>.  The allocated object is also added
       to the internal container associated with <u>type_num</u>, as described in <b><a href="../man3/POBJ_FOREACH.3.html">POBJ_FOREACH</a></b>(3).

       The <b>pmemobj_list_move</b>() function moves the object represented by object handle <u>oid</u> from the  list  refer‐
       enced  by <u>head_old</u> to the list referenced by <u>head_new</u>, inserting it at the location specified by <u>dest</u> and
       <u>before</u> as described above.  <u>pe_old_offset</u> and <u>pe_new_offset</u> specify the offsets of  the  structures  that
       connect  the  elements  in the old and new lists, respectively.  All the handles <u>head_old</u>, <u>head_new</u>, <u>dest</u>
       and <u>oid</u> must point to objects allocated from memory pool <u>pop</u>.   <u>head_old</u>,  <u>head_new</u>  and  <u>oid</u>  cannot  be
       <b>OID_NULL</b>.

       The <b>pmemobj_list_remove</b>() function removes the object represented by object handle <u>oid</u> from the list ref‐
       erenced by <u>head</u>.  If <u>free</u> is set, it also removes the object from the internal object container and frees
       the  associated memory space.  <u>pe_offset</u> specifies the offset of the structure that connects the elements
       in the list.  Both <u>head</u> and <u>oid</u> must point to objects allocated  from  memory  pool  <u>pop</u>  and  cannot  be
       <b>OID_NULL</b>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success,  <b>pmemobj_list_insert</b>(),  <b>pmemobj_list_remove</b>()  and <b>pmemobj_list_move</b>() return 0.  On error,
       they return -1 and set <u>errno</u> appropriately.

       On success, <b>pmemobj_list_insert_new</b>() returns a handle to the newly allocated object.  If the constructor
       returns a non-zero value, the allocation is canceled, -1 is returned, and <u>errno</u> is set to <b>ECANCELED</b>.   On
       other errors, <b>OID_NULL</b> is returned and <u>errno</u> is set appropriately.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/pmemobj_first.3.html">pmemobj_first</a></b>(3), <b><a href="../man3/POBJ_FOREACH.3.html">POBJ_FOREACH</a></b>(3), <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) and <b>&lt;https://pmem.io&gt;</b>
</pre>
 </div>
</div></section>
</div>
</body>
</html>