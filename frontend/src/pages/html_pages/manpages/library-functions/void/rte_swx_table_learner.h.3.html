<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rte_swx_table_learner.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dpdk-doc">dpdk-doc_24.11.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rte_swx_table_learner.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;rte_compat.h&gt;
       #include 'rte_swx_hash_func.h'

   <b>Data</b> <b>Structures</b>
       struct <b>rte_swx_table_learner_params</b>

   <b>Macros</b>
       #define <b>RTE_SWX_TABLE_LEARNER_N_KEY_TIMEOUTS_MAX</b>   16

   <b>Functions</b>
       __rte_experimental uint64_t <b>rte_swx_table_learner_footprint_get</b> (struct <b>rte_swx_table_learner_params</b>
           *params)
       __rte_experimental uint64_t <b>rte_swx_table_learner_mailbox_size_get</b> (void)
       __rte_experimental void * <b>rte_swx_table_learner_create</b> (struct <b>rte_swx_table_learner_params</b> *params, int
           numa_node)
       __rte_experimental int <b>rte_swx_table_learner_timeout_update</b> (void *table, uint32_t key_timeout_id,
           uint32_t key_timeout)
       __rte_experimental int <b>rte_swx_table_learner_lookup</b> (void *table, void *mailbox, uint64_t time, uint8_t
           **key, uint64_t *action_id, uint8_t **action_data, size_t *entry_id, int *hit)
       __rte_experimental uint32_t <b>rte_swx_table_learner_add</b> (void *table, void *mailbox, uint64_t time,
           uint64_t action_id, uint8_t *action_data, uint32_t key_timeout_id)
       __rte_experimental void <b>rte_swx_table_learner_rearm</b> (void *table, void *mailbox, uint64_t time)
       __rte_experimental void <b>rte_swx_table_learner_rearm_new</b> (void *table, void *mailbox, uint64_t time,
           uint32_t key_timeout_id)
       __rte_experimental void <b>rte_swx_table_learner_delete</b> (void *table, void *mailbox)
       __rte_experimental void <b>rte_swx_table_learner_free</b> (void *table)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       RTE SWX Learner Table

       The learner table API.

       This table type is typically used for learning or connection tracking, where it allows for the
       implementation of the 'add on miss' scenario: whenever the lookup key is not found in the table (lookup
       miss), the data plane can decide to add this key to the table with a given action with no control plane
       intervention. Likewise, the table keys expire based on a configurable timeout and are thus automatically
       removed from the table with no control plane intervention.

       The keys are not automatically rearmed on lookup hit. To delay the key expiration, the key timer has to
       be explicitly reinitialized on lookup hit. The key will be kept in the table as long as it is frequently
       hit and explicitly rearmed on every hit.

       Operation overview: 1) Lookup miss: a) add: Add the current input key (the key that missed the lookup) to
       the table with given action, action parameters and expiration timeout. This is the way to populate the
       table (which is empty initially). Data plane operation. b) Do nothing: Keep the current input key out of
       the table. 2) Lookup hit: a) add: Update the action, action parameters and/or the expiration timeout for
       the current input key, which is already in the table. The expiration timer of the key is automatically
       rearmed. Data plane operation. b) rearm: Rearm the expiration timer for the current input key, which is
       already in the table. The timeout value used for the expiration timer is either the same as the one
       currently associated with the key or a new one can be provided as input. Data plane operation. c) delete:
       Delete the current input key from the table. The purpose of this operation is to force the deletion of
       the key from the table before the key expires on timeout due to inactivity. Data plane operation. d) Do
       nothing: Keep the expiration timer of the current input key running down. This key will thus expire
       naturally, unless it is hit again as part of a subsequent lookup operation, when the key timer can be
       rearmed or re-added to prolong its life.

       Definition in file <b>rte_swx_table_learner.h</b>.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>RTE_SWX_TABLE_LEARNER_N_KEY_TIMEOUTS_MAX</b>   <b>16</b>
       Maximum number of key timeout values per learner table.

       Definition at line <b>58</b> of file <b>rte_swx_table_learner.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>__rte_experimental</b> <b>uint64_t</b> <b>rte_swx_table_learner_footprint_get</b> <b>(struct</b> <b>rte_swx_table_learner_params</b> <b>*</b>
       <b>params)</b>
       Learner table memory footprint get

       <b>Parameters</b>
           <u>params</u> Table create parameters.

       <b>Returns</b>
           Table memory footprint in bytes.

   <b>__rte_experimental</b> <b>uint64_t</b> <b>rte_swx_table_learner_mailbox_size_get</b> <b>(void)</b>
       Learner table mailbox size get

       The mailbox is used to store the context of a lookup operation that is in progress and it is passed as a
       parameter to the lookup operation. This allows for multiple concurrent lookup operations into the same
       table.

       <b>Returns</b>
           Table mailbox footprint in bytes.

   <b>__rte_experimental</b> <b>void</b> <b>*</b> <b>rte_swx_table_learner_create</b> <b>(struct</b> <b>rte_swx_table_learner_params</b> <b>*</b> <b>params,</b> <b>int</b>
       <b>numa_node)</b>
       Learner table create

       <b>Parameters</b>
           <u>params</u> Table creation parameters.
           <u>numa_node</u> Non-Uniform Memory Access (NUMA) node.

       <b>Returns</b>
           Table handle, on success, or NULL, on error.

   <b>__rte_experimental</b> <b>int</b> <b>rte_swx_table_learner_timeout_update</b> <b>(void</b> <b>*</b> <b>table,</b> <b>uint32_t</b> <b>key_timeout_id,</b> <b>uint32_t</b>
       <b>key_timeout)</b>
       Learner table key timeout update

       <b>Parameters</b>
           <u>table</u> Table handle.
           <u>key_timeout_id</u> Key timeout ID. Must be less than the configured <u>n_key_timeouts</u> value.
           <u>key_timeout</u> Key timeout value measured in seconds.

       <b>Returns</b>
           0 on success or the following error codes otherwise: -EINVAL: Invalid argument(s).

   <b>__rte_experimental</b> <b>int</b> <b>rte_swx_table_learner_lookup</b> <b>(void</b> <b>*</b> <b>table,</b> <b>void</b> <b>*</b> <b>mailbox,</b> <b>uint64_t</b> <b>time,</b> <b>uint8_t</b> <b>**</b>
       <b>key,</b> <b>uint64_t</b> <b>*</b> <b>action_id,</b> <b>uint8_t</b> <b>**</b> <b>action_data,</b> <b>size_t</b> <b>*</b> <b>entry_id,</b> <b>int</b> <b>*</b> <b>hit)</b>
       Learner table key lookup

       The table lookup operation searches a given key in the table and upon its completion it returns an
       indication of whether the key is found in the table (lookup hit) or not (lookup miss). In case of lookup
       hit, the action_id and the action_data associated with the key are also returned.

       Multiple invocations of this function may be required in order to complete a single table lookup
       operation for a given table and a given lookup key. The completion of the table lookup operation is
       flagged by a return value of 1; in case of a return value of 0, the function must be invoked again with
       exactly the same arguments.

       The mailbox argument is used to store the context of an on-going table key lookup operation, and possibly
       an associated key add operation. The mailbox mechanism allows for multiple concurrent table key lookup
       and add operations into the same table.

       The table entry consists of the action ID and the action data. Each table entry is unique, even though
       different table entries can have identical content, i.e. same values for the action ID and the action
       data. The table entry ID is also returned by the table lookup operation. It can be used to index into an
       external array of resources such as counters, registers or meters to identify the resource directly
       associated with the current table entry with no need to store the corresponding index into the table
       entry. The index of the external resource is thus auto-generated instead of being stored in the table
       entry.

       <b>Parameters</b>
           <u>table</u> Table handle.
           <u>mailbox</u> Mailbox for the current table lookup operation.
           <u>time</u> Current time measured in CPU clock cycles.
           <u>key</u> Lookup key. Its size must be equal to the table <u>key_size</u>.
           <u>action_id</u> ID of the action associated with the <u>key</u>. Must point to a valid 64-bit variable. Only valid
           when the function returns 1 and <u>hit</u> is set to true.
           <u>action_data</u> Action data for the <u>action_id</u> action. Must point to a valid array of table
           <u>action_data_size</u> bytes. Only valid when the function returns 1 and <u>hit</u> is set to true.
           <u>entry_id</u> Table entry unique ID. Must point to a valid 32-bit variable. Only valid when the function
           returns 1 and <u>hit</u> is set to true.
           <u>hit</u> Only valid when the function returns 1. Set to non-zero (true) on table lookup hit and to zero
           (false) on table lookup miss.

       <b>Returns</b>
           0 when the table lookup operation is not yet completed, and 1 when the table lookup operation is
           completed. No other return values are allowed.

   <b>__rte_experimental</b> <b>uint32_t</b> <b>rte_swx_table_learner_add</b> <b>(void</b> <b>*</b> <b>table,</b> <b>void</b> <b>*</b> <b>mailbox,</b> <b>uint64_t</b> <b>time,</b> <b>uint64_t</b>
       <b>action_id,</b> <b>uint8_t</b> <b>*</b> <b>action_data,</b> <b>uint32_t</b> <b>key_timeout_id)</b>
       Learner table key add

       This operation takes the latest key that was looked up in the table and adds it to the table with the
       given action ID and action data. Typically, this operation is only invoked when the latest lookup
       operation in the current table resulted in lookup miss.

       <b>Parameters</b>
           <u>table</u> Table handle.
           <u>mailbox</u> Mailbox for the current operation.
           <u>time</u> Current time measured in CPU clock cycles.
           <u>action_id</u> ID of the action associated with the key.
           <u>action_data</u> Action data for the <u>action_id</u> action.
           <u>key_timeout_id</u> Key timeout ID.

       <b>Returns</b>
           0 on success, 1 or error (table full).

   <b>__rte_experimental</b> <b>void</b> <b>rte_swx_table_learner_rearm</b> <b>(void</b> <b>*</b> <b>table,</b> <b>void</b> <b>*</b> <b>mailbox,</b> <b>uint64_t</b> <b>time)</b>
       Learner table key rearm with same timeout value

       This operation takes the latest key that was looked up in the table and, in case of lookup hit, it rearms
       its expiration timer using the same timeout value currently associated with the key.

       <b>Parameters</b>
           <u>table</u> Table handle.
           <u>mailbox</u> Mailbox for the current operation.
           <u>time</u> Current time measured in CPU clock cycles.

   <b>__rte_experimental</b> <b>void</b> <b>rte_swx_table_learner_rearm_new</b> <b>(void</b> <b>*</b> <b>table,</b> <b>void</b> <b>*</b> <b>mailbox,</b> <b>uint64_t</b> <b>time,</b>
       <b>uint32_t</b> <b>key_timeout_id)</b>
       Learner table key rearm with given timeout value

       This operation takes the latest key that was looked up in the table and, in case of lookup hit, it rearms
       its expiration timer using the given timeout value.

       <b>Parameters</b>
           <u>table</u> Table handle.
           <u>mailbox</u> Mailbox for the current operation.
           <u>time</u> Current time measured in CPU clock cycles.
           <u>key_timeout_id</u> Key timeout ID.

   <b>__rte_experimental</b> <b>void</b> <b>rte_swx_table_learner_delete</b> <b>(void</b> <b>*</b> <b>table,</b> <b>void</b> <b>*</b> <b>mailbox)</b>
       Learner table key delete

       This operation takes the latest key that was looked up in the table and deletes it from the table.
       Typically, this operation is only invoked to force the deletion of the key before the key expires on
       timeout due to inactivity.

       <b>Parameters</b>
           <u>table</u> Table handle.
           <u>mailbox</u> Mailbox for the current operation.

   <b>__rte_experimental</b> <b>void</b> <b>rte_swx_table_learner_free</b> <b>(void</b> <b>*</b> <b>table)</b>
       Learner table free

       <b>Parameters</b>
           <u>table</u> Table handle.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for DPDK from the source code.

DPDK                                             Version 24.11.2                      <u><a href="../man3/rte_swx_table_learner.h.3.html">rte_swx_table_learner.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>