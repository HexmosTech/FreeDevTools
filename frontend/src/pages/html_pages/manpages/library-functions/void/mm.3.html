<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSSP mm - Shared Memory Allocation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmm-dev">libmm-dev_1.4.2-7_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>OSSP</b> <b>mm</b> - <b>Shared</b> <b>Memory</b> <b>Allocation</b>

</pre><h4><b>VERSION</b></h4><pre>
       OSSP mm 1.4.2 (15-Aug-2006)

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include "mm.h"

        <b>Global</b> <b>Malloc-Replacement</b> <b>API</b>

        int     <b>MM_create</b>(size_t size, const char *file);
        int     <b>MM_permission</b>(mode_t mode, uid_t owner, gid_t group);
        void    <b>MM_reset</b>(void);
        void    <b>MM_destroy</b>(void);
        int     <b>MM_lock</b>(mm_lock_mode mode);
        int     <b>MM_unlock</b>(void);
        void   *<b>MM_malloc</b>(size_t size);
        void   *<b>MM_realloc</b>(void *ptr, size_t size);
        void    <b>MM_free</b>(void *ptr);
        void   *<b>MM_calloc</b>(size_t number, size_t size);
        char   *<b>MM_strdup</b>(const char *str);
        size_t  <b>MM_sizeof</b>(void *ptr);
        size_t  <b>MM_maxsize</b>(void);
        size_t  <b>MM_available</b>(void);
        char   *<b>MM_error</b>(void);

        <b>Standard</b> <b>Malloc-Style</b> <b>API</b>

        MM     *<b>mm_create</b>(size_t size, char *file);
        int     <b>mm_permission</b>(MM *mm, mode_t mode, uid_t owner, gid_t group);
        void    <b>mm_reset</b>(MM *mm);
        void    <b>mm_destroy</b>(MM *mm);
        int     <b>mm_lock</b>(MM *mm, mm_lock_mode mode);
        int     <b>mm_unlock</b>(MM *mm);
        void   *<b>mm_malloc</b>(MM *mm, size_t size);
        void   *<b>mm_realloc</b>(MM *mm, void *ptr, size_t size);
        void    <b>mm_free</b>(MM *mm, void *ptr);
        void   *<b>mm_calloc</b>(MM *mm, size_t number, size_t size);
        char   *<b>mm_strdup</b>(MM *mm, const char *str);
        size_t  <b>mm_sizeof</b>(MM *mm, void *ptr);
        size_t  <b>mm_maxsize</b>(void);
        size_t  <b>mm_available</b>(MM *mm);
        char   *<b>mm_error</b>(void);
        void    <b>mm_display_info</b>(MM *mm);

        <b>Low-level</b> <b>Shared</b> <b>Memory</b> <b>API</b>

        void   *<b>mm_core_create</b>(size_t size, char *file);
        int     <b>mm_core_permission</b>(void *core, mode_t mode, uid_t owner, gid_t group);
        void    <b>mm_core_delete</b>(void *core);
        int     <b>mm_core_lock</b>(void *core, mm_lock_mode mode);
        int     <b>mm_core_unlock</b>(void *core);
        size_t  <b>mm_core_size</b>(void *core);
        size_t  <b>mm_core_maxsegsize</b>(void);
        size_t  <b>mm_core_align2page</b>(size_t size);
        size_t  <b>mm_core_align2click</b>(size_t size);

        <b>Internal</b> <b>Library</b> <b>API</b>

        void    <b>mm_lib_error_set</b>(unsigned int, const char *str);
        char   *<b>mm_lib_error_get</b>(void);
        int     <b>mm_lib_version</b>(void);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>OSSP</b> <b>mm</b> library is a 2-layer abstraction library which simplifies the usage of shared memory between
       forked (and this way strongly related) processes under Unix platforms. On  the  first  (lower)  layer  it
       hides  all  platform  dependent  implementation details (allocation and locking) when dealing with shared
       memory segments and on the second (higher) layer it provides  a  high-level  <u><a href="../man3/malloc.3.html">malloc</a></u>(3)-style  API  for  a
       convenient and well known way to work with data-structures inside those shared memory segments.

       The  abbreviation  <b>OSSP</b> <b>mm</b> is historically and originally comes from the phrase ``<u>memory</u> <u>mapped</u>'' as used
       by the POSIX.1 <u><a href="../man2/mmap.2.html">mmap</a></u>(2) function. Because this facility  is  internally  used  by  this  library  on  most
       platforms to establish the shared memory segments.

       <b>LIBRARY</b> <b>STRUCTURE</b>

       This library is structured into three main APIs which are internally based on each other:

       <b>Global</b> <b>Malloc-Replacement</b> <b>API</b>
           This  is the most high-level API which directly can be used as replacement API for the POSIX.1 memory
           allocation API (<u><a href="../man2/malloc.2.html">malloc</a></u>(2) and friends). This is useful when converting <u>heap</u> based data structures  to
           <u>shared</u>  <u>memory</u>  based data structures without the need to change the code dramatically.  All which is
           needed is to prefix the POSIX.1 memory allocation functions with  `"MM_"',  i.e.  `"malloc"'  becomes
           `"MM_malloc"', `"strdup"' becomes `"MM_strdup"', etc. This API internally uses just a global `"MM *"'
           pool for calling the corresponding functions (those with prefix `"mm_"') of the <u>Standard</u> <u>Malloc-Style</u>
           <u>API</u>.

       <b>Standard</b> <b>Malloc-Style</b> <b>API</b>
           This is the standard high-level memory allocation API. Its interface is similar to the <u>Global</u> <u>Malloc-</u>
           <u>Replacement</u>  <u>API</u>  but  it uses an explicit `"MM *"' pool to operate on. That is why every function of
           this API has an argument of type `"MM *"' as its first argument. This API provides a comfortable  way
           to  work  with  small  dynamically  allocated  shared memory chunks inside large statically allocated
           shared memory segments. It is internally based on the <u>Low-Level</u> <u>Shared</u> <u>Memory</u> <u>API</u>  for  creating  the
           underlying shared memory segment.

       <b>Low-Level</b> <b>Shared</b> <b>Memory</b> <b>API</b>
           This  is  the basis of the whole <b>OSSP</b> <b>mm</b> library. It provides low-level functions for creating shared
           memory segments with mutual exclusion (in short <u>mutex</u>) capabilities in a portable way. Internally the
           shared memory and mutex facility is  implemented  in  various  platform-dependent  ways.  A  list  of
           implementation variants follows under the next topic.

       <b>SHARED</b> <b>MEMORY</b> <b>IMPLEMENTATION</b>

       Internally the shared memory facility is implemented in various platform-dependent ways. Each way has its
       own  advantages  and disadvantages (in addition to the fact that some variants aren't available at all on
       some platforms). The <b>OSSP</b> <b>mm</b> library's configuration procedure tries hard to make a  good  decision.  The
       implemented  variants  are  now  given  for  overview  and  background  reasons with their advantages and
       disadvantages and in an ascending order, i.e. the  <b>OSSP</b>  <b>mm</b>  configuration  mechanism  chooses  the  last
       available one in the list as the preferred variant.

       Classical <u><a href="../man2/mmap.2.html">mmap</a></u>(2) on temporary file (MMFILE)
           <u>Advantage:</u> maximum portable.  <u>Disadvantage:</u> needs a temporary file on the filesystem.

       <u><a href="../man2/mmap.2.html">mmap</a></u>(2) via POSIX.1 <u><a href="../man3/shm_open.3.html">shm_open</a></u>(3) on temporary file (MMPOSX)
           <u>Advantage:</u>  standardized by POSIX.1 and theoretically portable.  <u>Disadvantage:</u> needs a temporary file
           on the filesystem and is is usually not available on existing Unix platform.

       SVR4-style <u><a href="../man2/mmap.2.html">mmap</a></u>(2) on "/dev/zero" device (MMZERO)
           <u>Advantage:</u> widely  available  and  mostly  portable  on  SVR4  platforms.   <u>Disadvantage:</u>  needs  the
           "/dev/zero" device and a <u><a href="../man2/mmap.2.html">mmap</a></u>(2) which supports memory mapping through this device.

       SysV IPC <u><a href="../man2/shmget.2.html">shmget</a></u>(2) (IPCSHM)
           <u>Advantage:</u>  does  not  need a temporary file or external device.  <u>Disadvantage:</u> although available on
           mostly all modern Unix platforms, it has strong restrictions like the maximum size of a single shared
           memory segment (can be as small as 100KB, but depends on the platform).

       4.4BSD-style <u><a href="../man2/mmap.2.html">mmap</a></u>(2) via "MAP_ANON" facility (MMANON)
           <u>Advantage:</u> does not need a temporary file or external device.  <u>Disadvantage:</u> usually  only  available
           on BSD platforms and derivatives.

       <b>LOCKING</b> <b>IMPLEMENTATION</b>

       As  for  the  shared memory facility, internally the locking facility is implemented in various platform-
       dependent ways. They are again listed in ascending  order,  i.e.  the  <b>OSSP</b>  <b>mm</b>  configuration  mechanism
       chooses the last available one in the list as the preferred variant. The list of implemented variants is:

       4.2BSD-style <u><a href="../man2/flock.2.html">flock</a></u>(2) on temporary file (FLOCK)
           <u>Advantage:</u>  exists on a lot of platforms, especially on older Unix derivatives. <u>Disadvantage:</u> needs a
           temporary file on the filesystem and has to re-open file-descriptors  to  it  in  each(!)  <u><a href="../man2/fork.2.html">fork</a></u>(2)'ed
           child process.

       SysV IPC <u><a href="../man2/semget.2.html">semget</a></u>(2) (IPCSEM)
           <u>Advantage:</u> exists on a lot of platforms and does not need a temporary file.  <u>Disadvantage:</u> an unmeant
           termination  of  the  application  leads  to  a  semaphore leak because the facility does not allow a
           ``remove in advance'' trick (as the IPC shared memory facility does) for safe cleanups.

       SVR4-style <u><a href="../man2/fcntl.2.html">fcntl</a></u>(2) on temporary file (FCNTL)
           <u>Advantage:</u> exists on a lot of platforms and is also the most powerful variant  (although  not  always
           the fastest one). <u>Disadvantage:</u> needs a temporary file.

       <b>MEMORY</b> <b>ALLOCATION</b> <b>STRATEGY</b>

       The memory allocation strategy the <u>Standard</u> <u>Malloc-Style</u> <u>API</u> functions use internally is the following:

       <b>Allocation</b>
           If a chunk of memory has to be allocated, the internal list of free chunks is searched for a minimal-
           size chunk which is larger or equal than the size of the to be allocated chunk (a <u>best</u> <u>fit</u> strategy).

           If  a  chunk  is  found  which  matches  this  best-fit  criteria, but is still a lot larger than the
           requested size, it is split into two chunks: One with  exactly  the  requested  size  (which  is  the
           resulting  chunk  given  back) and one with the remaining size (which is immediately re-inserted into
           the list of free chunks).

           If no fitting chunk is found at all in the list of free chunks, a new one is created from  the  spare
           area  of  the  shared  memory segment until the segment is full (in which case an <u>out</u> <u>of</u> <u>memory</u> error
           occurs).

       <b>Deallocation</b>
           If a chunk of memory has to be deallocated, it is inserted in sorted manner into the internal list of
           free chunks. The insertion operation automatically merges the chunk with a  previous  and/or  a  next
           free  chunk  if  possible,  i.e.   if the free chunks stay physically seamless (one after another) in
           memory, to automatically form larger free chunks out of smaller ones.

           This way the shared memory segment is automatically defragmented when memory is deallocated.

       This strategy reduces memory waste and  fragmentation  caused  by  small  and  frequent  allocations  and
       deallocations to a minimum.

       The  internal implementation of the list of free chunks is not specially optimized (for instance by using
       binary search trees or even <u>splay</u> trees, etc), because it is assumed that the total amount of entries  in
       the  list of free chunks is always small (caused both by the fact that shared memory segments are usually
       a lot smaller than heaps and the fact that we always defragment by merging the free chunks if possible).

</pre><h4><b>API</b> <b>FUNCTIONS</b></h4><pre>
       In the following, all API functions are described in detail. The order directly follows the  one  in  the
       <b>SYNOPSIS</b> section above.

       <b>Global</b> <b>Malloc-Replacement</b> <b>API</b>

       int <b>MM_create</b>(size_t <u>size</u>, const char *<u>file</u>);
           This  initializes  the  global  shared memory pool with <u>size</u> and <u>file</u> and has to be called <u>before</u> any
           <u><a href="../man2/fork.2.html">fork</a></u>(2) operations are performed by the application.

       int <b>MM_permission</b>(mode_t <u>mode</u>, uid_t <u>owner</u>, gid_t <u>group</u>);
           This sets the filesystem <u>mode</u>, <u>owner</u> and <u>group</u> for the global shared memory pool (has effects only if
           the underlying shared memory segment implementation is actually based on external  auxiliary  files).
           The arguments are directly passed through to <u><a href="../man2/chmod.2.html">chmod</a></u>(2) and <u><a href="../man2/chown.2.html">chown</a></u>(2).

       void <b>MM_reset</b>(void);
           This resets the global shared memory pool: all chunks that have been allocated in the pool are marked
           as free and are eligible for reuse. The global memory pool itself is not destroyed.

       void <b>MM_destroy</b>(void);
           This  destroys  the  global  shared  memory  pool and should be called <u>after</u> all child processes were
           killed.

       int <b>MM_lock</b>(mm_lock_mode <u>mode</u>);
           This locks the global shared memory  pool  for  the  current  process  in  order  to  perform  either
           shared/read-only  (<u>mode</u>  is  "MM_LOCK_RD")  or  exclusive/read-write  (<u>mode</u> is "MM_LOCK_RW") critical
           operations inside the global shared memory pool.

       int <b>MM_unlock</b>(void);
           This unlocks the global shared memory pool for the current process after the critical operations were
           performed inside the global shared memory pool.

       void *<b>MM_malloc</b>(size_t <u>size</u>);
           Identical to the POSIX.1 <u><a href="../man3/malloc.3.html">malloc</a></u>(3) function but  instead  of  allocating  memory  from  the  <u>heap</u>  it
           allocates it from the global shared memory pool.

       void <b>MM_free</b>(void *<u>ptr</u>);
           Identical  to  the  POSIX.1  <u><a href="../man3/free.3.html">free</a></u>(3)  function  but  instead  of  deallocating  memory in the <u>heap</u> it
           deallocates it in the global shared memory pool.

       void *<b>MM_realloc</b>(void *<u>ptr</u>, size_t <u>size</u>);
           Identical to the POSIX.1 <u><a href="../man3/realloc.3.html">realloc</a></u>(3) function but instead  of  reallocating  memory  in  the  <u>heap</u>  it
           reallocates it inside the global shared memory pool.

       void *<b>MM_calloc</b>(size_t <u>number</u>, size_t <u>size</u>);
           Identical  to  the  POSIX.1 <u><a href="../man3/calloc.3.html">calloc</a></u>(3) function but instead of allocating and initializing memory from
           the <u>heap</u> it allocates and initializes it from the global shared memory pool.

       char *<b>MM_strdup</b>(const char *<u>str</u>);
           Identical to the POSIX.1 <u><a href="../man3/strdup.3.html">strdup</a></u>(3) function but instead of creating the string copy in  the  <u>heap</u>  it
           creates it in the global shared memory pool.

       size_t <b>MM_sizeof</b>(const void *<u>ptr</u>);
           This  function  returns  the  size  in  bytes  of  the  chunk starting at <u>ptr</u> when <u>ptr</u> was previously
           allocated with <u><a href="../man3/MM_malloc.3.html">MM_malloc</a></u>(3). The result is  undefined  if  <u>ptr</u>  was  not  previously  allocated  with
           <u><a href="../man3/MM_malloc.3.html">MM_malloc</a></u>(3).

       size_t <b>MM_maxsize</b>(void);
           This  function  returns  the  maximum size which is allowed as the first argument to the <u><a href="../man3/MM_create.3.html">MM_create</a></u>(3)
           function.

       size_t <b>MM_available</b>(void);
           Returns the amount in bytes of still available (free) memory in the global shared memory pool.

       char *<b>MM_error</b>(void);
           Returns the last error message which occurred inside the <b>OSSP</b> <b>mm</b> library.

       <b>Standard</b> <b>Malloc-Style</b> <b>API</b>

       MM *<b>mm_create</b>(size_t <u>size</u>, const char *<u>file</u>);
           This creates a shared memory pool which has space for approximately a total of <u>size</u>  bytes  with  the
           help  of <u>file</u>. Here <u>file</u> is a filesystem path to a file which need not to exist (and perhaps is never
           created because this depends on the platform and chosen shared memory and mutex implementation).  The
           return value is a pointer to a "MM" structure which should be treated as opaque by  the  application.
           It describes the internals of the created shared memory pool. In case of an error "NULL" is returned.
           A  <u>size</u>  of 0 means to allocate the maximum allowed size which is platform dependent and is between a
           few KB and the soft limit of 64MB.

       int <b>mm_permission</b>(MM *<u>mm</u>, mode_t <u>mode</u>, uid_t <u>owner</u>, gid_t <u>group</u>);
           This sets the filesystem <u>mode</u>, <u>owner</u> and <u>group</u> for the shared memory pool <u>mm</u> (has effects  only  when
           the  underlying  shared memory segment implementation is actually based on external auxiliary files).
           The arguments are directly passed through to <u><a href="../man2/chmod.2.html">chmod</a></u>(2) and <u><a href="../man2/chown.2.html">chown</a></u>(2).

       void <b>mm_reset</b>(MM *<u>mm</u>);
           This resets the shared memory pool <u>mm</u>: all chunks that have been allocated in the pool are marked  as
           free and are eligible for reuse. The memory pool itself is not destroyed.

       void <b>mm_destroy</b>(MM *<u>mm</u>);
           This  destroys the complete shared memory pool <u>mm</u> and with it all chunks which were allocated in this
           pool. Additionally any created files on the filesystem corresponding to the shared  memory  pool  are
           unlinked.

       int <b>mm_lock</b>(MM *<u>mm</u>, mm_lock_mode <u>mode</u>);
           This  locks  the  shared  memory  pool  <u>mm</u>  for  the  current  process  in  order  to  perform either
           shared/read-only (<u>mode</u> is "MM_LOCK_RD")  or  exclusive/read-write  (<u>mode</u>  is  "MM_LOCK_RW")  critical
           operations inside the global shared memory pool.

       int <b>mm_unlock</b>(MM *<u>mm</u>);
           This  unlocks  the  shared  memory  pool  <u>mm</u>  for  the current process after critical operations were
           performed inside the global shared memory pool.

       void *<b>mm_malloc</b>(MM *<u>mm</u>, size_t <u>size</u>);
           This function allocates <u>size</u> bytes from the shared memory pool  <u>mm</u>  and  returns  either  a  (virtual
           memory word aligned) pointer to it or "NULL" in case of an error (out of memory). It behaves like the
           POSIX.1  <u><a href="../man3/malloc.3.html">malloc</a></u>(3)  function  but instead of allocating memory from the <u>heap</u> it allocates it from the
           shared memory segment underlying <u>mm</u>.

       void <b>mm_free</b>(MM *<u>mm</u>, void *<u>ptr</u>);
           This deallocates the chunk starting at <u>ptr</u> in the shared memory pool <u>mm</u>.  It behaves like the POSIX.1
           <u><a href="../man3/free.3.html">free</a></u>(3) function but instead of deallocating memory from the <u>heap</u> it deallocates it from  the  shared
           memory segment underlying <u>mm</u>.

       void *<b>mm_realloc</b>(MM *<u>mm</u>, void *<u>ptr</u>, size_t <u>size</u>);
           This  function  reallocates  the  chunk starting at <u>ptr</u> inside the shared memory pool <u>mm</u> with the new
           size of <u>size</u> bytes.  It behaves like the POSIX.1 <u><a href="../man3/realloc.3.html">realloc</a></u>(3)  function  but  instead  of  reallocating
           memory in the <u>heap</u> it reallocates it in the shared memory segment underlying <u>mm</u>.

       void *<b>mm_calloc</b>(MM *<u>mm</u>, size_t <u>number</u>, size_t <u>size</u>);
           This  is  similar  to  <u><a href="../man3/mm_malloc.3.html">mm_malloc</a></u>(3),  but  additionally clears the chunk. It behaves like the POSIX.1
           <u><a href="../man3/calloc.3.html">calloc</a></u>(3) function.  It allocates space for <u>number</u> objects, each <u>size</u> bytes in length from the shared
           memory pool <u>mm</u>.  The result is identical to calling <u><a href="../man3/mm_malloc.3.html">mm_malloc</a></u>(3)  with  an  argument  of  ``<u>number</u>  *
           <u>size</u>'', with the exception that the allocated memory is initialized to nul bytes.

       char *<b>mm_strdup</b>(MM *<u>mm</u>, const char *<u>str</u>);
           This function behaves like the POSIX.1 <u><a href="../man3/strdup.3.html">strdup</a></u>(3) function.  It allocates sufficient memory inside the
           shared  memory pool <u>mm</u> for a copy of the string <u>str</u>, does the copy, and returns a pointer to it.  The
           pointer may subsequently be used as an argument to the function <u><a href="../man3/mm_free.3.html">mm_free</a></u>(3).  If  insufficient  shared
           memory is available, "NULL" is returned.

       size_t <b>mm_sizeof</b>(MM *<u>mm</u>, const void *<u>ptr</u>);
           This  function  returns  the  size  in  bytes  of  the  chunk starting at <u>ptr</u> when <u>ptr</u> was previously
           allocated with <u><a href="../man3/mm_malloc.3.html">mm_malloc</a></u>(3) inside the shared memory pool <u>mm</u>. The result is undefined  when  <u>ptr</u>  was
           not previously allocated with <u><a href="../man3/mm_malloc.3.html">mm_malloc</a></u>(3).

       size_t <b>mm_maxsize</b>(void);
           This  function  returns  the  maximum size which is allowed as the first argument to the <u><a href="../man3/mm_create.3.html">mm_create</a></u>(3)
           function.

       size_t <b>mm_available</b>(MM *<u>mm</u>);
           Returns the amount in bytes of still available (free) memory in the shared memory pool <u>mm</u>.

       char *<b>mm_error</b>(void);
           Returns the last error message which occurred inside the <b>OSSP</b> <b>mm</b> library.

       void <b>mm_display_info</b>(MM *<u>mm</u>);
           This is debugging function which displays a summary page for the shared  memory  pool  <u>mm</u>  describing
           various internal sizes and counters.

       <b>Low-Level</b> <b>Shared</b> <b>Memory</b> <b>API</b>

       void *<b>mm_core_create</b>(size_t <u>size</u>, const char *<u>file</u>);
           This  creates  a  shared  memory area which is at least <u>size</u> bytes in size with the help of <u>file</u>. The
           value <u>size</u> has to be greater than 0 and less or equal the value  returned  by  <u><a href="../man3/mm_core_maxsegsize.3.html">mm_core_maxsegsize</a></u>(3).
           Here  <u>file</u>  is  a  filesystem  path  to  a file which need not to exist (and perhaps is never created
           because this depends on the platform and chosen shared memory and mutex implementation).  The  return
           value  is  either  a  (virtual memory word aligned) pointer to the shared memory segment or "NULL" in
           case of an error.  The application is guaranteed to be able to access the shared memory segment  from
           byte 0 to byte <u>size</u>-1 starting at the returned address.

       int <b>mm_core_permission</b>(void *<u>core</u>, mode_t <u>mode</u>, uid_t <u>owner</u>, gid_t <u>group</u>);
           This  sets  the filesystem <u>mode</u>, <u>owner</u> and <u>group</u> for the shared memory segment <u>code</u> (has effects only
           when the underlying shared memory segment implementation is  actually  based  on  external  auxiliary
           files).  The arguments are directly passed through to <u><a href="../man2/chmod.2.html">chmod</a></u>(2) and <u><a href="../man2/chown.2.html">chown</a></u>(2).

       void <b>mm_core_delete</b>(void *<u>core</u>);
           This deletes a shared memory segment <u>core</u> (as previously returned by a <u><a href="../man3/mm_core_create.3.html">mm_core_create</a></u>(3) call). After
           this  operation, accessing the segment starting at <u>core</u> is no longer allowed and will usually lead to
           a segmentation fault.

       int <b>mm_core_lock</b>(const void *<u>core</u>, mm_lock_mode <u>mode</u>);
           This function acquires an advisory lock for the current process on the shared memory segment <u>core</u> for
           either shared/read-only  (<u>mode</u>  is  "MM_LOCK_RD")  or  exclusive/read-write  (<u>mode</u>  is  "MM_LOCK_RW")
           critical operations between <u><a href="../man2/fork.2.html">fork</a></u>(2)'ed child processes.

       int <b>mm_core_unlock</b>(const void *<u>core</u>);
           This  function  releases  a  previously  acquired advisory lock for the current process on the shared
           memory segment <u>core</u>.

       size_t <b>mm_core_size</b>(const void *<u>core</u>);
           This returns the size in bytes of <u>core</u>. This size is exactly the size which was used for creating the
           shared memory area via <u><a href="../man3/mm_core_create.3.html">mm_core_create</a></u>(3). The function is provided just for  convenience  reasons  to
           not require the application to remember the memory size behind <u>core</u> itself.

       size_t <b>mm_core_maxsegsize</b>(void);
           This returns the number of bytes of a maximum-size shared memory segment which is allowed to allocate
           via the MM library. It is between a few KB and the soft limit of 64MB.

       size_t <b>mm_core_align2page</b>(size_t <u>size</u>);
           This is just a utility function which can be used to align the number <u>size</u> to the next virtual memory
           <u>page</u>  boundary  used  by  the  underlying platform.  The memory page boundary under Unix platforms is
           usually somewhere between 2048 and 16384 bytes. You do not have to align the <u>size</u> arguments of  other
           <b>OSSP</b>  <b>mm</b>  library  functions  yourself,  because  this  is already done internally.  This function is
           exported by the <b>OSSP</b> <b>mm</b> library just for convenience reasons in case an application wants to  perform
           similar calculations for other purposes.

       size_t <b>mm_core_align2word</b>(size_t <u>size</u>);
           This  is  another  utility  function  which  can be used to align the number <u>size</u> to the next virtual
           memory <u>word</u> boundary used by the underlying platform.  The memory word boundary under Unix  platforms
           is  usually  somewhere  between 4 and 16 bytes.  You do not have to align the <u>size</u> arguments of other
           <b>OSSP</b> <b>mm</b> library functions yourself, because this  is  already  done  internally.   This  function  is
           exported  by the <b>OSSP</b> <b>mm</b> library just for convenience reasons in case an application wants to perform
           similar calculations for other purposes.

       <b>Low-Level</b> <b>Shared</b> <b>Memory</b> <b>API</b>

       void <b>mm_lib_error_set</b>(unsigned int, const char *str);
           This is a function which is used internally by the various MM function to set an error  string.  It's
           usually not called directly from applications.

       char *<b>mm_lib_error_get</b>(void);
           This  is  a  function  which  is  used internally by <u><a href="../man3/MM_error.3.html">MM_error</a></u>(3) and <u><a href="../man3/mm_error.3.html">mm_error</a></u>(3) functions to get the
           current error string. It is usually not called directly from applications.

       int <b>mm_lib_version</b>(void);
           This function returns a hex-value ``0x<u>VRRTLL</u>'' which describes the current <b>OSSP</b> <b>mm</b> library version. <u>V</u>
           is the version, <u>RR</u> the  revisions,  <u>LL</u>  the  level  and  <u>T</u>  the  type  of  the  level  (alphalevel=0,
           betalevel=1,  patchlevel=2,  etc).  For  instance  <b>OSSP</b> <b>mm</b> version 1.0.4 is encoded as 0x100204.  The
           reason for this unusual mapping is that this way the version number is steadily <u>increasing</u>.

</pre><h4><b>RESTRICTIONS</b></h4><pre>
       The maximum size of a continuous shared memory  segment  one  can  allocate  depends  on  the  underlying
       platform.  This cannot be changed, of course.  But currently the high-level <u><a href="../man3/malloc.3.html">malloc</a></u>(3)-style API just uses
       a single shared memory segment as the underlying data structure for an "MM" object which means  that  the
       maximum amount of memory an "MM" object represents also depends on the platform.

       This  could  be  changed  in  later  versions  by allowing at least the high-level <u><a href="../man3/malloc.3.html">malloc</a></u>(3)-style API to
       internally use multiple shared memory segments to form the "MM" object. This way "MM" objects could  have
       arbitrary  sizes,  although  the  maximum size of an allocatable continuous chunk still is bounded by the
       maximum size of a shared memory segment.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/mm-config.1.html">mm-config</a></u>(1).

       <u><a href="../man3/malloc.3.html">malloc</a></u>(3), <u><a href="../man3/calloc.3.html">calloc</a></u>(3), <u><a href="../man3/realloc.3.html">realloc</a></u>(3), <u><a href="../man3/strdup.3.html">strdup</a></u>(3), <u><a href="../man3/free.3.html">free</a></u>(3), <u><a href="../man2/mmap.2.html">mmap</a></u>(2), <u><a href="../man2/shmget.2.html">shmget</a></u>(2), <u><a href="../man2/shmctl.2.html">shmctl</a></u>(2), <u><a href="../man2/flock.2.html">flock</a></u>(2),  <u><a href="../man2/fcntl.2.html">fcntl</a></u>(2),
       <u><a href="../man2/semget.2.html">semget</a></u>(2), <u><a href="../man2/semctl.2.html">semctl</a></u>(2), <u><a href="../man2/semop.2.html">semop</a></u>(2).

</pre><h4><b>HOME</b></h4><pre>
       <a href="http://www.ossp.org/pkg/lib/mm/">http://www.ossp.org/pkg/lib/mm/</a>

</pre><h4><b>HISTORY</b></h4><pre>
       This library was originally written in January 1999 by <u>Ralf</u> <u>S.</u>  <u>Engelschall</u> &lt;<a href="mailto:rse@engelschall.com">rse@engelschall.com</a>&gt; for use
       in  the  <b>Extended</b>  <b>API</b>  (EAPI)  of the <b>Apache</b> HTTP server project (see <a href="http://www.apache.org/">http://www.apache.org/</a>), which was
       originally invented for <b>mod_ssl</b> (see <a href="http://www.modssl.org/">http://www.modssl.org/</a>).

       Its base idea (a malloc-style API for handling shared  memory)  was  originally  derived  from  the  non-
       publically    available    <u>mm_malloc</u>    library    written   in   October   1997   by   <u>Charles</u>   <u>Randall</u>
       &lt;<a href="mailto:crandall@matchlogic.com">crandall@matchlogic.com</a>&gt; for MatchLogic, Inc.

       In 2000 this library joined the <b>OSSP</b> project where all other software development  projects  of  <u>Ralf</u>  <u>S.</u>
       <u>Engelschall</u> are located.

</pre><h4><b>AUTHOR</b></h4><pre>
        Ralf S. Engelschall
        <a href="mailto:rse@engelschall.com">rse@engelschall.com</a>
        www.engelschall.com

15-Aug-2006                                         MM 1.4.2                                               <u><a href="../man3/mm.3.html">mm</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>