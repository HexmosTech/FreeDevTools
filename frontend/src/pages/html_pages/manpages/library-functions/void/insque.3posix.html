<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       insque, remque — insert or remove an element in a queue

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/search.h">search.h</a>&gt;

       void insque(void *<u>element</u>, void *<u>pred</u>);
       void remque(void *<u>element</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>insque</u>()  and  <u>remque</u>() functions shall manipulate queues built from doubly-linked lists.  The queue
       can be either circular or linear. An application using <u>insque</u>() or <u>remque</u>() shall  ensure  it  defines  a
       structure in which the first two members of the structure are pointers to the same type of structure, and
       any  further  members are application-specific. The first member of the structure is a forward pointer to
       the next entry in the queue. The second member is a backward pointer to the previous entry in the  queue.
       If the queue is linear, the queue is terminated with null pointers. The names of the structure and of the
       pointer members are not subject to any special restriction.

       The  <u>insque</u>()  function shall insert the element pointed to by <u>element</u> into a queue immediately after the
       element pointed to by <u>pred</u>.

       The <u>remque</u>() function shall remove the element pointed to by <u>element</u> from a queue.

       If the queue is to be used as a linear list,  invoking  <u>insque</u>(&amp;<u>element</u>,  NULL),  where  <u>element</u>  is  the
       initial  element  of  the  queue,  shall  initialize the forward and backward pointers of <u>element</u> to null
       pointers.

       If the queue is to be used as a circular list, the application shall ensure it  initializes  the  forward
       pointer and the backward pointer of the initial element of the queue to the element's own address.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The <u>insque</u>() and <u>remque</u>() functions do not return a value.

</pre><h4><b>ERRORS</b></h4><pre>
       No errors are defined.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Creating</b> <b>a</b> <b>Linear</b> <b>Linked</b> <b>List</b>
       The following example creates a linear linked list.

           #include &lt;<a href="file:/usr/include/search.h">search.h</a>&gt;
           ...
           struct myque element1;
           struct myque element2;

           char *data1 = "DATA1";
           char *data2 = "DATA2";
           ...
           element1.data = data1;
           element2.data = data2;

           insque (&amp;element1, NULL);
           insque (&amp;element2, &amp;element1);

   <b>Creating</b> <b>a</b> <b>Circular</b> <b>Linked</b> <b>List</b>
       The following example creates a circular linked list.

           #include &lt;<a href="file:/usr/include/search.h">search.h</a>&gt;
           ...
           struct myque element1;
           struct myque element2;

           char *data1 = "DATA1";
           char *data2 = "DATA2";
           ...
           element1.data = data1;
           element2.data = data2;

           element1.fwd = &amp;element1;
           element1.bck = &amp;element1;

           insque (&amp;element2, &amp;element1);

   <b>Removing</b> <b>an</b> <b>Element</b>
       The following example removes the element pointed to by <u>element1</u>.

           #include &lt;<a href="file:/usr/include/search.h">search.h</a>&gt;
           ...
           struct myque element1;
           ...
           remque (&amp;element1);

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       The historical implementations of these functions described the arguments as being of type <b>struct</b> <b>qelem</b> <b>*</b>
       rather  than as being of type <b>void</b> <b>*</b> as defined here. In those implementations, <b>struct</b> <b>qelem</b> was commonly
       defined in <u>&lt;search.h&gt;</u> as:

           struct qelem {
               struct qelem  *q_forw;
               struct qelem  *q_back;
           };

       Applications using these functions, however, were never able to use  this  structure  directly  since  it
       provided no room for the actual data contained in the elements. Most applications defined structures that
       contained  the  two  pointers  as  the  initial elements and also provided space for, or pointers to, the
       object's data. Applications that used these functions to update more than one type of table also had  the
       problem  of specifying two or more different structures with the same name, if they literally used <b>struct</b>
       <b>qelem</b> as specified.

       As described here, the implementations were actually expecting a  structure  type  where  the  first  two
       members  were  forward and backward pointers to structures. With C compilers that didn't provide function
       prototypes, applications used structures as specified in the DESCRIPTION above and the compiler did  what
       the application expected.

       If  this  method  had  been  carried  forward with an ISO C standard compiler and the historical function
       prototype, most applications would have to be modified to cast pointers to the structures  actually  used
       to  be pointers to <b>struct</b> <b>qelem</b> to avoid compilation warnings. By specifying <b>void</b> <b>*</b> as the argument type,
       applications do not need to change (unless they specifically referenced <b>struct</b> <b>qelem</b> and depended  on  it
       being defined in <u>&lt;search.h&gt;</u>).

</pre><h4><b>RATIONALE</b></h4><pre>
       None.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The Base Definitions volume of POSIX.1‐2017, <b>&lt;search.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                        <u><a href="../man3POSIX/INSQUE.3POSIX.html">INSQUE</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>