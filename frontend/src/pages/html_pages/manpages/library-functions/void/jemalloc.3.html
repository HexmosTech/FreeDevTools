<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jemalloc - general purpose memory allocation functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libjemalloc-dev">libjemalloc-dev_5.3.0-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       jemalloc - general purpose memory allocation functions

</pre><h4><b>LIBRARY</b></h4><pre>
       This manual describes jemalloc 5.3.0-0-g54eaed1d8b56b1aa528be3bdd1877e59c56fa90c. More information can be
       found at the <b>jemalloc</b> <b>website</b>[1].

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;jemalloc/jemalloc.h&gt;</b>

   <b>Standard</b> <b>API</b>

       <b>void</b> <b>*malloc(size_t</b> <u>size</u><b>);</b>

       <b>void</b> <b>*calloc(size_t</b> <u>number</u><b>,</b> <b>size_t</b> <u>size</u><b>);</b>

       <b>int</b> <b>posix_memalign(void</b> <b>**</b><u>ptr</u><b>,</b> <b>size_t</b> <u>alignment</u><b>,</b> <b>size_t</b> <u>size</u><b>);</b>

       <b>void</b> <b>*aligned_alloc(size_t</b> <u>alignment</u><b>,</b> <b>size_t</b> <u>size</u><b>);</b>

       <b>void</b> <b>*realloc(void</b> <b>*</b><u>ptr</u><b>,</b> <b>size_t</b> <u>size</u><b>);</b>

       <b>void</b> <b>free(void</b> <b>*</b><u>ptr</u><b>);</b>

   <b>Non-standard</b> <b>API</b>

       <b>void</b> <b>*mallocx(size_t</b> <u>size</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>

       <b>void</b> <b>*rallocx(void</b> <b>*</b><u>ptr</u><b>,</b> <b>size_t</b> <u>size</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>

       <b>size_t</b> <b>xallocx(void</b> <b>*</b><u>ptr</u><b>,</b> <b>size_t</b> <u>size</u><b>,</b> <b>size_t</b> <u>extra</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>

       <b>size_t</b> <b>sallocx(void</b> <b>*</b><u>ptr</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>

       <b>void</b> <b>dallocx(void</b> <b>*</b><u>ptr</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>

       <b>void</b> <b>sdallocx(void</b> <b>*</b><u>ptr</u><b>,</b> <b>size_t</b> <u>size</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>

       <b>size_t</b> <b>nallocx(size_t</b> <u>size</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>

       <b>int</b> <b>mallctl(const</b> <b>char</b> <b>*</b><u>name</u><b>,</b> <b>void</b> <b>*</b><u>oldp</u><b>,</b> <b>size_t</b> <b>*</b><u>oldlenp</u><b>,</b> <b>void</b> <b>*</b><u>newp</u><b>,</b> <b>size_t</b> <u>newlen</u><b>);</b>

       <b>int</b> <b>mallctlnametomib(const</b> <b>char</b> <b>*</b><u>name</u><b>,</b> <b>size_t</b> <b>*</b><u>mibp</u><b>,</b> <b>size_t</b> <b>*</b><u>miblenp</u><b>);</b>

       <b>int</b> <b>mallctlbymib(const</b> <b>size_t</b> <b>*</b><u>mib</u><b>,</b> <b>size_t</b> <u>miblen</u><b>,</b> <b>void</b> <b>*</b><u>oldp</u><b>,</b> <b>size_t</b> <b>*</b><u>oldlenp</u><b>,</b> <b>void</b> <b>*</b><u>newp</u><b>,</b>
                        <b>size_t</b> <u>newlen</u><b>);</b>

       <b>void</b> <b>malloc_stats_print(void</b> <u>(*write_cb)</u> <b>(void</b> <b>*,</b> <b>const</b> <b>char</b> <b>*),</b> <b>void</b> <b>*</b><u>cbopaque</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>opts</u><b>);</b>

       <b>size_t</b> <b>malloc_usable_size(const</b> <b>void</b> <b>*</b><u>ptr</u><b>);</b>

       <b>void</b> <b>(*malloc_message)(void</b> <b>*</b><u>cbopaque</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>s</u><b>);</b>

       const char *<u>malloc_conf</u>;

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>Standard</b> <b>API</b>
       The malloc() function allocates <u>size</u> bytes of uninitialized memory. The allocated space is suitably
       aligned (after possible pointer coercion) for storage of any type of object.

       The calloc() function allocates space for <u>number</u> objects, each <u>size</u> bytes in length. The result is
       identical to calling malloc() with an argument of <u>number</u> * <u>size</u>, with the exception that the allocated
       memory is explicitly initialized to zero bytes.

       The posix_memalign() function allocates <u>size</u> bytes of memory such that the allocation's base address is a
       multiple of <u>alignment</u>, and returns the allocation in the value pointed to by <u>ptr</u>. The requested <u>alignment</u>
       must be a power of 2 at least as large as sizeof(<b>void</b> <b>*</b>).

       The aligned_alloc() function allocates <u>size</u> bytes of memory such that the allocation's base address is a
       multiple of <u>alignment</u>. The requested <u>alignment</u> must be a power of 2. Behavior is undefined if <u>size</u> is not
       an integral multiple of <u>alignment</u>.

       The realloc() function changes the size of the previously allocated memory referenced by <u>ptr</u> to <u>size</u>
       bytes. The contents of the memory are unchanged up to the lesser of the new and old sizes. If the new
       size is larger, the contents of the newly allocated portion of the memory are undefined. Upon success,
       the memory referenced by <u>ptr</u> is freed and a pointer to the newly allocated memory is returned. Note that
       realloc() may move the memory allocation, resulting in a different return value than <u>ptr</u>. If <u>ptr</u> is <b>NULL</b>,
       the realloc() function behaves identically to malloc() for the specified size.

       The free() function causes the allocated memory referenced by <u>ptr</u> to be made available for future
       allocations. If <u>ptr</u> is <b>NULL</b>, no action occurs.

   <b>Non-standard</b> <b>API</b>
       The mallocx(), rallocx(), xallocx(), sallocx(), dallocx(), sdallocx(), and nallocx() functions all have a
       <u>flags</u> argument that can be used to specify options. The functions only check the options that are
       contextually relevant. Use bitwise or (|) operations to specify one or more of the following:

       <b>MALLOCX_LG_ALIGN(</b><u>la</u><b>)</b>
           Align the memory allocation to start at an address that is a multiple of (1 &lt;&lt; <u>la</u>). This macro does
           not validate that <u>la</u> is within the valid range.

       <b>MALLOCX_ALIGN(</b><u>a</u><b>)</b>
           Align the memory allocation to start at an address that is a multiple of <u>a</u>, where <u>a</u> is a power of
           two. This macro does not validate that <u>a</u> is a power of 2.

       <b>MALLOCX_ZERO</b>
           Initialize newly allocated memory to contain zero bytes. In the growing reallocation case, the real
           size prior to reallocation defines the boundary between untouched bytes and those that are
           initialized to contain zero bytes. If this macro is absent, newly allocated memory is uninitialized.

       <b>MALLOCX_TCACHE(</b><u>tc</u><b>)</b>
           Use the thread-specific cache (tcache) specified by the identifier <u>tc</u>, which must have been acquired
           via the tcache.create mallctl. This macro does not validate that <u>tc</u> specifies a valid identifier.

       <b>MALLOCX_TCACHE_NONE</b>
           Do not use a thread-specific cache (tcache). Unless <b>MALLOCX_TCACHE(</b><u>tc</u><b>)</b> or <b>MALLOCX_TCACHE_NONE</b> is
           specified, an automatically managed tcache will be used under many circumstances. This macro cannot
           be used in the same <u>flags</u> argument as <b>MALLOCX_TCACHE(</b><u>tc</u><b>)</b>.

       <b>MALLOCX_ARENA(</b><u>a</u><b>)</b>
           Use the arena specified by the index <u>a</u>. This macro has no effect for regions that were allocated via
           an arena other than the one specified. This macro does not validate that <u>a</u> specifies an arena index
           in the valid range.

       The mallocx() function allocates at least <u>size</u> bytes of memory, and returns a pointer to the base address
       of the allocation. Behavior is undefined if <u>size</u> is <b>0</b>.

       The rallocx() function resizes the allocation at <u>ptr</u> to be at least <u>size</u> bytes, and returns a pointer to
       the base address of the resulting allocation, which may or may not have moved from its original location.
       Behavior is undefined if <u>size</u> is <b>0</b>.

       The xallocx() function resizes the allocation at <u>ptr</u> in place to be at least <u>size</u> bytes, and returns the
       real size of the allocation. If <u>extra</u> is non-zero, an attempt is made to resize the allocation to be at
       least (<u>size</u> + <u>extra</u>) bytes, though inability to allocate the extra byte(s) will not by itself result in
       failure to resize. Behavior is undefined if <u>size</u> is <b>0</b>, or if (<u>size</u> + <u>extra</u> &gt; <b>SIZE_T_MAX</b>).

       The sallocx() function returns the real size of the allocation at <u>ptr</u>.

       The dallocx() function causes the memory referenced by <u>ptr</u> to be made available for future allocations.

       The sdallocx() function is an extension of dallocx() with a <u>size</u> parameter to allow the caller to pass in
       the allocation size as an optimization. The minimum valid input size is the original requested size of
       the allocation, and the maximum valid input size is the corresponding value returned by nallocx() or
       sallocx().

       The nallocx() function allocates no memory, but it performs the same size computation as the mallocx()
       function, and returns the real size of the allocation that would result from the equivalent mallocx()
       function call, or <b>0</b> if the inputs exceed the maximum supported size class and/or alignment. Behavior is
       undefined if <u>size</u> is <b>0</b>.

       The mallctl() function provides a general interface for introspecting the memory allocator, as well as
       setting modifiable parameters and triggering actions. The period-separated <u>name</u> argument specifies a
       location in a tree-structured namespace; see the MALLCTL NAMESPACE section for documentation on the tree
       contents. To read a value, pass a pointer via <u>oldp</u> to adequate space to contain the value, and a pointer
       to its length via <u>oldlenp</u>; otherwise pass <b>NULL</b> and <b>NULL</b>. Similarly, to write a value, pass a pointer to
       the value via <u>newp</u>, and its length via <u>newlen</u>; otherwise pass <b>NULL</b> and <b>0</b>.

       The mallctlnametomib() function provides a way to avoid repeated name lookups for applications that
       repeatedly query the same portion of the namespace, by translating a name to a “Management Information
       Base” (MIB) that can be passed repeatedly to mallctlbymib(). Upon successful return from
       mallctlnametomib(), <u>mibp</u> contains an array of <u>*miblenp</u> integers, where <u>*miblenp</u> is the lesser of the
       number of components in <u>name</u> and the input value of <u>*miblenp</u>. Thus it is possible to pass a <u>*miblenp</u> that
       is smaller than the number of period-separated name components, which results in a partial MIB that can
       be used as the basis for constructing a complete MIB. For name components that are integers (e.g. the 2
       in arenas.bin.2.size), the corresponding MIB component will always be that integer. Therefore, it is
       legitimate to construct code like the following:

           unsigned nbins, i;
           size_t mib[4];
           size_t len, miblen;

           len = sizeof(nbins);
           mallctl("arenas.nbins", &amp;nbins, &amp;len, NULL, 0);

           miblen = 4;
           mallctlnametomib("arenas.bin.0.size", mib, &amp;miblen);
           for (i = 0; i &lt; nbins; i++) {
                size_t bin_size;

                mib[2] = i;
                len = sizeof(bin_size);
                mallctlbymib(mib, miblen, (void *)&amp;bin_size, &amp;len, NULL, 0);
                /* Do something with bin_size... */
           }

       The malloc_stats_print() function writes summary statistics via the <u>write_cb</u> callback function pointer
       and <u>cbopaque</u> data passed to <u>write_cb</u>, or malloc_message() if <u>write_cb</u> is <b>NULL</b>. The statistics are
       presented in human-readable form unless “J” is specified as a character within the <u>opts</u> string, in which
       case the statistics are presented in <b>JSON</b> <b>format</b>[2]. This function can be called repeatedly. General
       information that never changes during execution can be omitted by specifying “g” as a character within
       the <u>opts</u> string. Note that malloc_stats_print() uses the mallctl*() functions internally, so inconsistent
       statistics can be reported if multiple threads use these functions simultaneously. If <b>--enable-stats</b> is
       specified during configuration, “m”, “d”, and “a” can be specified to omit merged arena, destroyed merged
       arena, and per arena statistics, respectively; “b” and “l” can be specified to omit per size class
       statistics for bins and large objects, respectively; “x” can be specified to omit all mutex statistics;
       “e” can be used to omit extent statistics. Unrecognized characters are silently ignored. Note that thread
       caching may prevent some statistics from being completely up to date, since extra locking would be
       required to merge counters that track thread cache operations.

       The malloc_usable_size() function returns the usable size of the allocation pointed to by <u>ptr</u>. The return
       value may be larger than the size that was requested during allocation. The malloc_usable_size() function
       is not a mechanism for in-place realloc(); rather it is provided solely as a tool for introspection
       purposes. Any discrepancy between the requested allocation size and the size reported by
       malloc_usable_size() should not be depended on, since such behavior is entirely implementation-dependent.

</pre><h4><b>TUNING</b></h4><pre>
       Once, when the first call is made to one of the memory allocation routines, the allocator initializes its
       internals based in part on various options that can be specified at compile- or run-time.

       The string specified via <b>--with-malloc-conf</b>, the string pointed to by the global variable <u>malloc_conf</u>,
       the “name” of the file referenced by the symbolic link named /etc/malloc.conf, and the value of the
       environment variable <b>MALLOC_CONF</b>, will be interpreted, in that order, from left to right as options. Note
       that <u>malloc_conf</u> may be read before main() is entered, so the declaration of <u>malloc_conf</u> should specify
       an initializer that contains the final value to be read by jemalloc.  <b>--with-malloc-conf</b> and <u>malloc_conf</u>
       are compile-time mechanisms, whereas /etc/malloc.conf and <b>MALLOC_CONF</b> can be safely set any time prior to
       program invocation.

       An options string is a comma-separated list of option:value pairs. There is one key corresponding to each
       opt.*  mallctl (see the MALLCTL NAMESPACE section for options documentation). For example,
       abort:true,narenas:1 sets the opt.abort and opt.narenas options. Some options have boolean values
       (true/false), others have integer values (base 8, 10, or 16, depending on prefix), and yet others have
       raw string values.

</pre><h4><b>IMPLEMENTATION</b> <b>NOTES</b></h4><pre>
       Traditionally, allocators have used <b><a href="../man2/sbrk.2.html">sbrk</a></b>(2) to obtain memory, which is suboptimal for several reasons,
       including race conditions, increased fragmentation, and artificial limitations on maximum usable memory.
       If <b><a href="../man2/sbrk.2.html">sbrk</a></b>(2) is supported by the operating system, this allocator uses both <b><a href="../man2/mmap.2.html">mmap</a></b>(2) and <b><a href="../man2/sbrk.2.html">sbrk</a></b>(2), in that
       order of preference; otherwise only <b><a href="../man2/mmap.2.html">mmap</a></b>(2) is used.

       This allocator uses multiple arenas in order to reduce lock contention for threaded programs on
       multi-processor systems. This works well with regard to threading scalability, but incurs some costs.
       There is a small fixed per-arena overhead, and additionally, arenas manage memory completely
       independently of each other, which means a small fixed increase in overall memory fragmentation. These
       overheads are not generally an issue, given the number of arenas normally used. Note that using
       substantially more arenas than the default is not likely to improve performance, mainly due to reduced
       cache performance. However, it may make sense to reduce the number of arenas if an application does not
       make much use of the allocation functions.

       In addition to multiple arenas, this allocator supports thread-specific caching, in order to make it
       possible to completely avoid synchronization for most allocation requests. Such caching allows very fast
       allocation in the common case, but it increases memory usage and fragmentation, since a bounded number of
       objects can remain allocated in each thread cache.

       Memory is conceptually broken into extents. Extents are always aligned to multiples of the page size.
       This alignment makes it possible to find metadata for user objects quickly. User objects are broken into
       two categories according to size: small and large. Contiguous small objects comprise a slab, which
       resides within a single extent, whereas large objects each have their own extents backing them.

       Small objects are managed in groups by slabs. Each slab maintains a bitmap to track which regions are in
       use. Allocation requests that are no more than half the quantum (8 or 16, depending on architecture) are
       rounded up to the nearest power of two that is at least sizeof(<b>double</b>). All other object size classes are
       multiples of the quantum, spaced such that there are four size classes for each doubling in size, which
       limits internal fragmentation to approximately 20% for all but the smallest size classes. Small size
       classes are smaller than four times the page size, and large size classes extend from four times the page
       size up to the largest size class that does not exceed <b>PTRDIFF_MAX</b>.

       Allocations are packed tightly together, which can be an issue for multi-threaded applications. If you
       need to assure that allocations do not suffer from cacheline sharing, round your allocation requests up
       to the nearest multiple of the cacheline size, or specify cacheline alignment when allocating.

       The realloc(), rallocx(), and xallocx() functions may resize allocations without moving them under
       limited circumstances. Unlike the *allocx() API, the standard API does not officially round up the usable
       size of an allocation to the nearest size class, so technically it is necessary to call realloc() to grow
       e.g. a 9-byte allocation to 16 bytes, or shrink a 16-byte allocation to 9 bytes. Growth and shrinkage
       trivially succeeds in place as long as the pre-size and post-size both round up to the same size class.
       No other API guarantees are made regarding in-place resizing, but the current implementation also tries
       to resize large allocations in place, as long as the pre-size and post-size are both large. For shrinkage
       to succeed, the extent allocator must support splitting (see arena.&lt;i&gt;.extent_hooks). Growth only
       succeeds if the trailing memory is currently available, and the extent allocator supports merging.

       Assuming 4 KiB pages and a 16-byte quantum on a 64-bit system, the size classes in each category are as
       shown in Table 1.

       <b>Table</b> <b>1.</b> <b>Size</b> <b>classes</b>
       ┌──────────┬─────────┬──────────────────────────────┐
       │ <b>Category</b> │ <b>Spacing</b> │ <b>Size</b>                         │
       ├──────────┼─────────┼──────────────────────────────┤
       │          │      lg │ [8]                          │
       │          ├─────────┼──────────────────────────────┤
       │          │      16 │ [16, 32, 48, 64, 80, 96,     │
       │          │         │ 112, 128]                    │
       │          ├─────────┼──────────────────────────────┤
       │          │      32 │ [160, 192, 224, 256]         │
       │          ├─────────┼──────────────────────────────┤
       │          │      64 │ [320, 384, 448, 512]         │
       │ Small    ├─────────┼──────────────────────────────┤
       │          │     128 │ [640, 768, 896, 1024]        │
       │          ├─────────┼──────────────────────────────┤
       │          │     256 │ [1280, 1536, 1792, 2048]     │
       │          ├─────────┼──────────────────────────────┤
       │          │     512 │ [2560, 3072, 3584, 4096]     │
       │          ├─────────┼──────────────────────────────┤
       │          │   1 KiB │ [5 KiB, 6 KiB, 7 KiB, 8 KiB] │
       │          ├─────────┼──────────────────────────────┤
       │          │   2 KiB │ [10 KiB, 12 KiB, 14 KiB]     │
       ├──────────┼─────────┼──────────────────────────────┤
       │          │   2 KiB │ [16 KiB]                     │
       │          ├─────────┼──────────────────────────────┤
       │          │   4 KiB │ [20 KiB, 24 KiB, 28 KiB, 32  │
       │          │         │ KiB]                         │
       │          ├─────────┼──────────────────────────────┤
       │          │   8 KiB │ [40 KiB, 48 KiB, 56 KiB, 64  │
       │          │         │ KiB]                         │
       │          ├─────────┼──────────────────────────────┤
       │          │  16 KiB │ [80 KiB, 96 KiB, 112 KiB,    │
       │          │         │ 128 KiB]                     │
       │          ├─────────┼──────────────────────────────┤
       │          │  32 KiB │ [160 KiB, 192 KiB, 224 KiB,  │
       │          │         │ 256 KiB]                     │
       │          ├─────────┼──────────────────────────────┤
       │          │  64 KiB │ [320 KiB, 384 KiB, 448 KiB,  │
       │          │         │ 512 KiB]                     │
       │          ├─────────┼──────────────────────────────┤
       │          │ 128 KiB │ [640 KiB, 768 KiB, 896 KiB,  │
       │          │         │ 1 MiB]                       │
       │          ├─────────┼──────────────────────────────┤
       │          │ 256 KiB │ [1280 KiB, 1536 KiB, 1792    │
       │ Large    │         │ KiB, 2 MiB]                  │
       │          ├─────────┼──────────────────────────────┤
       │          │ 512 KiB │ [2560 KiB, 3 MiB, 3584 KiB,  │
       │          │         │ 4 MiB]                       │
       │          ├─────────┼──────────────────────────────┤
       │          │   1 MiB │ [5 MiB, 6 MiB, 7 MiB, 8 MiB] │
       │          ├─────────┼──────────────────────────────┤
       │          │   2 MiB │ [10 MiB, 12 MiB, 14 MiB, 16  │
       │          │         │ MiB]                         │
       │          ├─────────┼──────────────────────────────┤
       │          │   4 MiB │ [20 MiB, 24 MiB, 28 MiB, 32  │
       │          │         │ MiB]                         │
       │          ├─────────┼──────────────────────────────┤
       │          │   8 MiB │ [40 MiB, 48 MiB, 56 MiB, 64  │
       │          │         │ MiB]                         │
       │          ├─────────┼──────────────────────────────┤
       │          │     ... │ ...                          │
       │          ├─────────┼──────────────────────────────┤
       │          │ 512 PiB │ [2560 PiB, 3 EiB, 3584 PiB,  │
       │          │         │ 4 EiB]                       │
       │          ├─────────┼──────────────────────────────┤
       │          │   1 EiB │ [5 EiB, 6 EiB, 7 EiB]        │
       └──────────┴─────────┴──────────────────────────────┘

</pre><h4><b>MALLCTL</b> <b>NAMESPACE</b></h4><pre>
       The following names are defined in the namespace accessible via the mallctl*() functions. Value types are
       specified in parentheses, their readable/writable statuses are encoded as rw, r-, -w, or --, and required
       build configuration flags follow, if any. A name element encoded as &lt;i&gt; or &lt;j&gt; indicates an integer
       component, where the integer varies from 0 to some upper value that must be determined via introspection.
       In the case of stats.arenas.&lt;i&gt;.*  and arena.&lt;i&gt;.{initialized,purge,decay,dss}, &lt;i&gt; equal to
       <b>MALLCTL_ARENAS_ALL</b> can be used to operate on all arenas or access the summation of statistics from all
       arenas; similarly &lt;i&gt; equal to <b>MALLCTL_ARENAS_DESTROYED</b> can be used to access the summation of statistics
       from all destroyed arenas. These constants can be utilized either via mallctlnametomib() followed by
       mallctlbymib(), or via code such as the following:

           #define STRINGIFY_HELPER(x) #x
           #define STRINGIFY(x) STRINGIFY_HELPER(x)

           mallctl("arena." STRINGIFY(MALLCTL_ARENAS_ALL) ".decay",
               NULL, NULL, NULL, 0);

       Take special note of the epoch mallctl, which controls refreshing of cached dynamic statistics.

       version (<b>const</b> <b>char</b> <b>*</b>) r-
           Return the jemalloc version string.

       epoch (<b>uint64_t</b>) rw
           If a value is passed in, refresh the data from which the mallctl*() functions report values, and
           increment the epoch. Return the current epoch. This is useful for detecting whether another thread
           caused a refresh.

       background_thread (<b>bool</b>) rw
           Enable/disable internal background worker threads. When set to true, background threads are created
           on demand (the number of background threads will be no more than the number of CPUs or active
           arenas). Threads run periodically, and handle purging asynchronously. When switching off, background
           threads are terminated synchronously. Note that after <b><a href="../man2/fork.2.html">fork</a></b>(2) function, the state in the child
           process will be disabled regardless the state in parent process. See stats.background_thread for
           related stats.  opt.background_thread can be used to set the default option. This option is only
           available on selected pthread-based platforms.

       max_background_threads (<b>size_t</b>) rw
           Maximum number of background worker threads that will be created. This value is capped at
           opt.max_background_threads at startup.

       config.cache_oblivious (<b>bool</b>) r-
           <b>--enable-cache-oblivious</b> was specified during build configuration.

       config.debug (<b>bool</b>) r-
           <b>--enable-debug</b> was specified during build configuration.

       config.fill (<b>bool</b>) r-
           <b>--enable-fill</b> was specified during build configuration.

       config.lazy_lock (<b>bool</b>) r-
           <b>--enable-lazy-lock</b> was specified during build configuration.

       config.malloc_conf (<b>const</b> <b>char</b> <b>*</b>) r-
           Embedded configure-time-specified run-time options string, empty unless <b>--with-malloc-conf</b> was
           specified during build configuration.

       config.prof (<b>bool</b>) r-
           <b>--enable-prof</b> was specified during build configuration.

       config.prof_libgcc (<b>bool</b>) r-
           <b>--disable-prof-libgcc</b> was not specified during build configuration.

       config.prof_libunwind (<b>bool</b>) r-
           <b>--enable-prof-libunwind</b> was specified during build configuration.

       config.stats (<b>bool</b>) r-
           <b>--enable-stats</b> was specified during build configuration.

       config.utrace (<b>bool</b>) r-
           <b>--enable-utrace</b> was specified during build configuration.

       config.xmalloc (<b>bool</b>) r-
           <b>--enable-xmalloc</b> was specified during build configuration.

       opt.abort (<b>bool</b>) r-
           Abort-on-warning enabled/disabled. If true, most warnings are fatal. Note that runtime option
           warnings are not included (see opt.abort_conf for that). The process will call <b><a href="../man3/abort.3.html">abort</a></b>(3) in these
           cases. This option is disabled by default unless <b>--enable-debug</b> is specified during configuration, in
           which case it is enabled by default.

       opt.confirm_conf (<b>bool</b>) r-
           Confirm-runtime-options-when-program-starts enabled/disabled. If true, the string specified via
           <b>--with-malloc-conf</b>, the string pointed to by the global variable <u>malloc_conf</u>, the “name” of the file
           referenced by the symbolic link named /etc/malloc.conf, and the value of the environment variable
           <b>MALLOC_CONF</b>, will be printed in order. Then, each option being set will be individually printed. This
           option is disabled by default.

       opt.abort_conf (<b>bool</b>) r-
           Abort-on-invalid-configuration enabled/disabled. If true, invalid runtime options are fatal. The
           process will call <b><a href="../man3/abort.3.html">abort</a></b>(3) in these cases. This option is disabled by default unless <b>--enable-debug</b>
           is specified during configuration, in which case it is enabled by default.

       opt.cache_oblivious (<b>bool</b>) r-
           Enable / Disable cache-oblivious large allocation alignment, for large requests with no alignment
           constraints. If this feature is disabled, all large allocations are page-aligned as an implementation
           artifact, which can severely harm CPU cache utilization. However, the cache-oblivious layout comes at
           the cost of one extra page per large allocation, which in the most extreme case increases physical
           memory usage for the 16 KiB size class to 20 KiB. This option is enabled by default.

       opt.metadata_thp (<b>const</b> <b>char</b> <b>*</b>) r-
           Controls whether to allow jemalloc to use transparent huge page (THP) for internal metadata (see
           stats.metadata).  “always” allows such usage.  “auto” uses no THP initially, but may begin to do so
           when metadata usage reaches certain level. The default is “disabled”.

       opt.trust_madvise (<b>bool</b>) r-
           If true, do not perform runtime check for MADV_DONTNEED, to check that it actually zeros pages. The
           default is disabled on Linux and enabled elsewhere.

       opt.retain (<b>bool</b>) r-
           If true, retain unused virtual memory for later reuse rather than discarding it by calling <b><a href="../man2/munmap.2.html">munmap</a></b>(2)
           or equivalent (see stats.retained for related details). It also makes jemalloc use <b><a href="../man2/mmap.2.html">mmap</a></b>(2) or
           equivalent in a more greedy way, mapping larger chunks in one go. This option is disabled by default
           unless discarding virtual memory is known to trigger platform-specific performance problems, namely
           1) for [64-bit] Linux, which has a quirk in its virtual memory allocation algorithm that causes
           semi-permanent VM map holes under normal jemalloc operation; and 2) for [64-bit] Windows, which
           disallows split / merged regions with <b>MEM_RELEASE</b>. Although the same issues may present on 32-bit
           platforms as well, retaining virtual memory for 32-bit Linux and Windows is disabled by default due
           to the practical possibility of address space exhaustion.

       opt.dss (<b>const</b> <b>char</b> <b>*</b>) r-
           dss (<b><a href="../man2/sbrk.2.html">sbrk</a></b>(2)) allocation precedence as related to <b><a href="../man2/mmap.2.html">mmap</a></b>(2) allocation. The following settings are
           supported if <b><a href="../man2/sbrk.2.html">sbrk</a></b>(2) is supported by the operating system: “disabled”, “primary”, and “secondary”;
           otherwise only “disabled” is supported. The default is “secondary” if <b><a href="../man2/sbrk.2.html">sbrk</a></b>(2) is supported by the
           operating system; “disabled” otherwise.

       opt.narenas (<b>unsigned</b>) r-
           Maximum number of arenas to use for automatic multiplexing of threads and arenas. The default is four
           times the number of CPUs, or one if there is a single CPU.

       opt.oversize_threshold (<b>size_t</b>) r-
           The threshold in bytes of which requests are considered oversize. Allocation requests with greater
           sizes are fulfilled from a dedicated arena (automatically managed, however not within narenas), in
           order to reduce fragmentation by not mixing huge allocations with small ones. In addition, the decay
           API guarantees on the extents greater than the specified threshold may be overridden. Note that
           requests with arena index specified via <b>MALLOCX_ARENA</b>, or threads associated with explicit arenas
           will not be considered. The default threshold is 8MiB. Values not within large size classes disables
           this feature.

       opt.percpu_arena (<b>const</b> <b>char</b> <b>*</b>) r-
           Per CPU arena mode. Use the “percpu” setting to enable this feature, which uses number of CPUs to
           determine number of arenas, and bind threads to arenas dynamically based on the CPU the thread runs
           on currently.  “phycpu” setting uses one arena per physical CPU, which means the two hyper threads on
           the same CPU share one arena. Note that no runtime checking regarding the availability of hyper
           threading is done at the moment. When set to “disabled”, narenas and thread to arena association will
           not be impacted by this option. The default is “disabled”.

       opt.background_thread (<b>bool</b>) r-
           Internal background worker threads enabled/disabled. Because of potential circular dependencies,
           enabling background thread using this option may cause crash or deadlock during initialization. For a
           reliable way to use this feature, see background_thread for dynamic control options and details. This
           option is disabled by default.

       opt.max_background_threads (<b>size_t</b>) r-
           Maximum number of background threads that will be created if background_thread is set. Defaults to
           number of cpus.

       opt.dirty_decay_ms (<b>ssize_t</b>) r-
           Approximate time in milliseconds from the creation of a set of unused dirty pages until an equivalent
           set of unused dirty pages is purged (i.e. converted to muzzy via e.g.  madvise(<u>...</u><b>MADV_FREE</b>) if
           supported by the operating system, or converted to clean otherwise) and/or reused. Dirty pages are
           defined as previously having been potentially written to by the application, and therefore consuming
           physical memory, yet having no current use. The pages are incrementally purged according to a
           sigmoidal decay curve that starts and ends with zero purge rate. A decay time of 0 causes all unused
           dirty pages to be purged immediately upon creation. A decay time of -1 disables purging. The default
           decay time is 10 seconds. See arenas.dirty_decay_ms and arena.&lt;i&gt;.dirty_decay_ms for related dynamic
           control options. See opt.muzzy_decay_ms for a description of muzzy pages.for a description of muzzy
           pages. Note that when the oversize_threshold feature is enabled, the arenas reserved for oversize
           requests may have its own default decay settings.

       opt.muzzy_decay_ms (<b>ssize_t</b>) r-
           Approximate time in milliseconds from the creation of a set of unused muzzy pages until an equivalent
           set of unused muzzy pages is purged (i.e. converted to clean) and/or reused. Muzzy pages are defined
           as previously having been unused dirty pages that were subsequently purged in a manner that left them
           subject to the reclamation whims of the operating system (e.g.  madvise(<u>...</u><b>MADV_FREE</b>)), and therefore
           in an indeterminate state. The pages are incrementally purged according to a sigmoidal decay curve
           that starts and ends with zero purge rate. A decay time of 0 causes all unused muzzy pages to be
           purged immediately upon creation. A decay time of -1 disables purging. The default decay time is 10
           seconds. See arenas.muzzy_decay_ms and arena.&lt;i&gt;.muzzy_decay_ms for related dynamic control options.

       opt.lg_extent_max_active_fit (<b>size_t</b>) r-
           When reusing dirty extents, this determines the (log base 2 of the) maximum ratio between the size of
           the active extent selected (to split off from) and the size of the requested allocation. This
           prevents the splitting of large active extents for smaller allocations, which can reduce
           fragmentation over the long run (especially for non-active extents). Lower value may reduce
           fragmentation, at the cost of extra active extents. The default value is 6, which gives a maximum
           ratio of 64 (2^6).

       opt.stats_print (<b>bool</b>) r-
           Enable/disable statistics printing at exit. If enabled, the malloc_stats_print() function is called
           at program exit via an <b><a href="../man3/atexit.3.html">atexit</a></b>(3) function.  opt.stats_print_opts can be combined to specify output
           options. If <b>--enable-stats</b> is specified during configuration, this has the potential to cause
           deadlock for a multi-threaded process that exits while one or more threads are executing in the
           memory allocation functions. Furthermore, atexit() may allocate memory during application
           initialization and then deadlock internally when jemalloc in turn calls atexit(), so this option is
           not universally usable (though the application can register its own atexit() function with equivalent
           functionality). Therefore, this option should only be used with care; it is primarily intended as a
           performance tuning aid during application development. This option is disabled by default.

       opt.stats_print_opts (<b>const</b> <b>char</b> <b>*</b>) r-
           Options (the <u>opts</u> string) to pass to the malloc_stats_print() at exit (enabled through
           opt.stats_print). See available options in malloc_stats_print(). Has no effect unless opt.stats_print
           is enabled. The default is “”.

       opt.stats_interval (<b>int64_t</b>) r-
           Average interval between statistics outputs, as measured in bytes of allocation activity. The actual
           interval may be sporadic because decentralized event counters are used to avoid synchronization
           bottlenecks. The output may be triggered on any thread, which then calls malloc_stats_print().
           opt.stats_interval_opts can be combined to specify output options. By default, interval-triggered
           stats output is disabled (encoded as -1).

       opt.stats_interval_opts (<b>const</b> <b>char</b> <b>*</b>) r-
           Options (the <u>opts</u> string) to pass to the malloc_stats_print() for interval based statistics printing
           (enabled through opt.stats_interval). See available options in malloc_stats_print(). Has no effect
           unless opt.stats_interval is enabled. The default is “”.

       opt.junk (<b>const</b> <b>char</b> <b>*</b>) r- [<b>--enable-fill</b>]
           Junk filling. If set to “alloc”, each byte of uninitialized allocated memory will be initialized to
           0xa5. If set to “free”, all deallocated memory will be initialized to 0x5a. If set to “true”, both
           allocated and deallocated memory will be initialized, and if set to “false”, junk filling be disabled
           entirely. This is intended for debugging and will impact performance negatively. This option is
           “false” by default unless <b>--enable-debug</b> is specified during configuration, in which case it is
           “true” by default.

       opt.zero (<b>bool</b>) r- [<b>--enable-fill</b>]
           Zero filling enabled/disabled. If enabled, each byte of uninitialized allocated memory will be
           initialized to 0. Note that this initialization only happens once for each byte, so realloc() and
           rallocx() calls do not zero memory that was previously allocated. This is intended for debugging and
           will impact performance negatively. This option is disabled by default.

       opt.utrace (<b>bool</b>) r- [<b>--enable-utrace</b>]
           Allocation tracing based on <b><a href="../man2/utrace.2.html">utrace</a></b>(2) enabled/disabled. This option is disabled by default.

       opt.xmalloc (<b>bool</b>) r- [<b>--enable-xmalloc</b>]
           Abort-on-out-of-memory enabled/disabled. If enabled, rather than returning failure for any allocation
           function, display a diagnostic message on <b>STDERR_FILENO</b> and cause the program to drop core (using
           <b><a href="../man3/abort.3.html">abort</a></b>(3)). If an application is designed to depend on this behavior, set the option at compile time
           by including the following in the source code:

               malloc_conf = "xmalloc:true";

           This option is disabled by default.

       opt.tcache (<b>bool</b>) r-
           Thread-specific caching (tcache) enabled/disabled. When there are multiple threads, each thread uses
           a tcache for objects up to a certain size. Thread-specific caching allows many allocations to be
           satisfied without performing any thread synchronization, at the cost of increased memory use. See the
           opt.tcache_max option for related tuning information. This option is enabled by default.

       opt.tcache_max (<b>size_t</b>) r-
           Maximum size class to cache in the thread-specific cache (tcache). At a minimum, the first size class
           is cached; and at a maximum, size classes up to 8 MiB can be cached. The default maximum is 32 KiB
           (2^15). As a convenience, this may also be set by specifying lg_tcache_max, which will be taken to be
           the base-2 logarithm of the setting of tcache_max.

       opt.thp (<b>const</b> <b>char</b> <b>*</b>) r-
           Transparent hugepage (THP) mode. Settings "always", "never" and "default" are available if THP is
           supported by the operating system. The "always" setting enables transparent hugepage for all user
           memory mappings with <b>MADV_HUGEPAGE</b>; "never" ensures no transparent hugepage with <b>MADV_NOHUGEPAGE</b>; the
           default setting "default" makes no changes. Note that: this option does not affect THP for jemalloc
           internal metadata (see opt.metadata_thp); in addition, for arenas with customized extent_hooks, this
           option is bypassed as it is implemented as part of the default extent hooks.

       opt.prof (<b>bool</b>) r- [<b>--enable-prof</b>]
           Memory profiling enabled/disabled. If enabled, profile memory allocation activity. See the
           opt.prof_active option for on-the-fly activation/deactivation. See the opt.lg_prof_sample option for
           probabilistic sampling control. See the opt.prof_accum option for control of cumulative sample
           reporting. See the opt.lg_prof_interval option for information on interval-triggered profile dumping,
           the opt.prof_gdump option for information on high-water-triggered profile dumping, and the
           opt.prof_final option for final profile dumping. Profile output is compatible with the <b>jeprof</b>
           command, which is based on the <b>pprof</b> that is developed as part of the <b>gperftools</b> <b>package</b>[3]. See HEAP
           PROFILE FORMAT for heap profile format documentation.

       opt.prof_prefix (<b>const</b> <b>char</b> <b>*</b>) r- [<b>--enable-prof</b>]
           Filename prefix for profile dumps. If the prefix is set to the empty string, no automatic dumps will
           occur; this is primarily useful for disabling the automatic final heap dump (which also disables leak
           reporting, if enabled). The default prefix is jeprof. This prefix value can be overridden by
           prof.prefix.

       opt.prof_active (<b>bool</b>) r- [<b>--enable-prof</b>]
           Profiling activated/deactivated. This is a secondary control mechanism that makes it possible to
           start the application with profiling enabled (see the opt.prof option) but inactive, then toggle
           profiling at any time during program execution with the prof.active mallctl. This option is enabled
           by default.

       opt.prof_thread_active_init (<b>bool</b>) r- [<b>--enable-prof</b>]
           Initial setting for thread.prof.active in newly created threads. The initial setting for newly
           created threads can also be changed during execution via the prof.thread_active_init mallctl. This
           option is enabled by default.

       opt.lg_prof_sample (<b>size_t</b>) r- [<b>--enable-prof</b>]
           Average interval (log base 2) between allocation samples, as measured in bytes of allocation
           activity. Increasing the sampling interval decreases profile fidelity, but also decreases the
           computational overhead. The default sample interval is 512 KiB (2^19 B).

       opt.prof_accum (<b>bool</b>) r- [<b>--enable-prof</b>]
           Reporting of cumulative object/byte counts in profile dumps enabled/disabled. If this option is
           enabled, every unique backtrace must be stored for the duration of execution. Depending on the
           application, this can impose a large memory overhead, and the cumulative counts are not always of
           interest. This option is disabled by default.

       opt.lg_prof_interval (<b>ssize_t</b>) r- [<b>--enable-prof</b>]
           Average interval (log base 2) between memory profile dumps, as measured in bytes of allocation
           activity. The actual interval between dumps may be sporadic because decentralized allocation counters
           are used to avoid synchronization bottlenecks. Profiles are dumped to files named according to the
           pattern &lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.i&lt;iseq&gt;.heap, where &lt;prefix&gt; is controlled by the opt.prof_prefix and
           prof.prefix options. By default, interval-triggered profile dumping is disabled (encoded as -1).

       opt.prof_gdump (<b>bool</b>) r- [<b>--enable-prof</b>]
           Set the initial state of prof.gdump, which when enabled triggers a memory profile dump every time the
           total virtual memory exceeds the previous maximum. This option is disabled by default.

       opt.prof_final (<b>bool</b>) r- [<b>--enable-prof</b>]
           Use an <b><a href="../man3/atexit.3.html">atexit</a></b>(3) function to dump final memory usage to a file named according to the pattern
           &lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.f.heap, where &lt;prefix&gt; is controlled by the opt.prof_prefix and prof.prefix
           options. Note that atexit() may allocate memory during application initialization and then deadlock
           internally when jemalloc in turn calls atexit(), so this option is not universally usable (though the
           application can register its own atexit() function with equivalent functionality). This option is
           disabled by default.

       opt.prof_leak (<b>bool</b>) r- [<b>--enable-prof</b>]
           Leak reporting enabled/disabled. If enabled, use an <b><a href="../man3/atexit.3.html">atexit</a></b>(3) function to report memory leaks
           detected by allocation sampling. See the opt.prof option for information on analyzing heap profile
           output. Works only when combined with opt.prof_final, otherwise does nothing. This option is disabled
           by default.

       opt.prof_leak_error (<b>bool</b>) r- [<b>--enable-prof</b>]
           Similar to opt.prof_leak, but makes the process exit with error code 1 if a memory leak is detected.
           This option supersedes opt.prof_leak, meaning that if both are specified, this option takes
           precedence. When enabled, also enables opt.prof_leak. Works only when combined with opt.prof_final,
           otherwise does nothing. This option is disabled by default.

       opt.zero_realloc (<b>const</b> <b>char</b> <b>*</b>) r-
           Determines the behavior of realloc() when passed a value of zero for the new size.  “alloc” treats
           this as an allocation of size zero (and returns a non-null result except in case of resource
           exhaustion).  “free” treats this as a deallocation of the pointer, and returns <b>NULL</b> without setting
           <u>errno</u>.  “abort” aborts the process if zero is passed. The default is “free” on Linux and Windows, and
           “alloc” elsewhere.

           There is considerable divergence of behaviors across implementations in handling this case. Many have
           the behavior of “free”. This can introduce security vulnerabilities, since a <b>NULL</b> return value
           indicates failure, and the continued validity of the passed-in pointer (per POSIX and C11).  “alloc”
           is safe, but can cause leaks in programs that expect the common behavior. Programs intended to be
           portable and leak-free cannot assume either behavior, and must therefore never call realloc with a
           size of 0. The “abort” option enables these testing this behavior.

       thread.arena (<b>unsigned</b>) rw
           Get or set the arena associated with the calling thread. If the specified arena was not initialized
           beforehand (see the arena.i.initialized mallctl), it will be automatically initialized as a side
           effect of calling this interface.

       thread.allocated (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Get the total number of bytes ever allocated by the calling thread. This counter has the potential to
           wrap around; it is up to the application to appropriately interpret the counter in such cases.

       thread.allocatedp (<b>uint64_t</b> <b>*</b>) r- [<b>--enable-stats</b>]
           Get a pointer to the the value that is returned by the thread.allocated mallctl. This is useful for
           avoiding the overhead of repeated mallctl*() calls. Note that the underlying counter should not be
           modified by the application.

       thread.deallocated (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Get the total number of bytes ever deallocated by the calling thread. This counter has the potential
           to wrap around; it is up to the application to appropriately interpret the counter in such cases.

       thread.deallocatedp (<b>uint64_t</b> <b>*</b>) r- [<b>--enable-stats</b>]
           Get a pointer to the the value that is returned by the thread.deallocated mallctl. This is useful for
           avoiding the overhead of repeated mallctl*() calls. Note that the underlying counter should not be
           modified by the application.

       thread.peak.read (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Get an approximation of the maximum value of the difference between the number of bytes allocated and
           the number of bytes deallocated by the calling thread since the last call to thread.peak.reset, or
           since the thread's creation if it has not called thread.peak.reset. No guarantees are made about the
           quality of the approximation, but jemalloc currently endeavors to maintain accuracy to within one
           hundred kilobytes.

       thread.peak.reset (<b>void</b>) -- [<b>--enable-stats</b>]
           Resets the counter for net bytes allocated in the calling thread to zero. This affects subsequent
           calls to thread.peak.read, but not the values returned by thread.allocated or thread.deallocated.

       thread.tcache.enabled (<b>bool</b>) rw
           Enable/disable calling thread's tcache. The tcache is implicitly flushed as a side effect of becoming
           disabled (see thread.tcache.flush).

       thread.tcache.flush (<b>void</b>) --
           Flush calling thread's thread-specific cache (tcache). This interface releases all cached objects and
           internal data structures associated with the calling thread's tcache. Ordinarily, this interface need
           not be called, since automatic periodic incremental garbage collection occurs, and the thread cache
           is automatically discarded when a thread exits. However, garbage collection is triggered by
           allocation activity, so it is possible for a thread that stops allocating/deallocating to retain its
           cache indefinitely, in which case the developer may find manual flushing useful.

       thread.prof.name (<b>const</b> <b>char</b> <b>*</b>) r- or -w [<b>--enable-prof</b>]
           Get/set the descriptive name associated with the calling thread in memory profile dumps. An internal
           copy of the name string is created, so the input string need not be maintained after this interface
           completes execution. The output string of this interface should be copied for non-ephemeral uses,
           because multiple implementation details can cause asynchronous string deallocation. Furthermore, each
           invocation of this interface can only read or write; simultaneous read/write is not supported due to
           string lifetime limitations. The name string must be nil-terminated and comprised only of characters
           in the sets recognized by <b><a href="../man3/isgraph.3.html">isgraph</a></b>(3) and <b><a href="../man3/isblank.3.html">isblank</a></b>(3).

       thread.prof.active (<b>bool</b>) rw [<b>--enable-prof</b>]
           Control whether sampling is currently active for the calling thread. This is an activation mechanism
           in addition to prof.active; both must be active for the calling thread to sample. This flag is
           enabled by default.

       thread.idle (<b>void</b>) --
           Hints to jemalloc that the calling thread will be idle for some nontrivial period of time (say, on
           the order of seconds), and that doing some cleanup operations may be beneficial. There are no
           guarantees as to what specific operations will be performed; currently this flushes the caller's
           tcache and may (according to some heuristic) purge its associated arena.

           This is not intended to be a general-purpose background activity mechanism, and threads should not
           wake up multiple times solely to call it. Rather, a thread waiting for a task should do a timed wait
           first, call thread.idle if no task appears in the timeout interval, and then do an untimed wait. For
           such a background activity mechanism, see background_thread.

       tcache.create (<b>unsigned</b>) r-
           Create an explicit thread-specific cache (tcache) and return an identifier that can be passed to the
           <b>MALLOCX_TCACHE(</b><u>tc</u><b>)</b> macro to explicitly use the specified cache rather than the automatically managed
           one that is used by default. Each explicit cache can be used by only one thread at a time; the
           application must assure that this constraint holds.

           If the amount of space supplied for storing the thread-specific cache identifier does not equal
           sizeof(<b>unsigned</b>), no thread-specific cache will be created, no data will be written to the space
           pointed by <u>oldp</u>, and <u>*oldlenp</u> will be set to 0.

       tcache.flush (<b>unsigned</b>) -w
           Flush the specified thread-specific cache (tcache). The same considerations apply to this interface
           as to thread.tcache.flush, except that the tcache will never be automatically discarded.

       tcache.destroy (<b>unsigned</b>) -w
           Flush the specified thread-specific cache (tcache) and make the identifier available for use during a
           future tcache creation.

       arena.&lt;i&gt;.initialized (<b>bool</b>) r-
           Get whether the specified arena's statistics are initialized (i.e. the arena was initialized prior to
           the current epoch). This interface can also be nominally used to query whether the merged statistics
           corresponding to <b>MALLCTL_ARENAS_ALL</b> are initialized (always true).

       arena.&lt;i&gt;.decay (<b>void</b>) --
           Trigger decay-based purging of unused dirty/muzzy pages for arena &lt;i&gt;, or for all arenas if &lt;i&gt;
           equals <b>MALLCTL_ARENAS_ALL</b>. The proportion of unused dirty/muzzy pages to be purged depends on the
           current time; see opt.dirty_decay_ms and opt.muzy_decay_ms for details.

       arena.&lt;i&gt;.purge (<b>void</b>) --
           Purge all unused dirty pages for arena &lt;i&gt;, or for all arenas if &lt;i&gt; equals <b>MALLCTL_ARENAS_ALL</b>.

       arena.&lt;i&gt;.reset (<b>void</b>) --
           Discard all of the arena's extant allocations. This interface can only be used with arenas explicitly
           created via arenas.create. None of the arena's discarded/cached allocations may accessed afterward.
           As part of this requirement, all thread caches which were used to allocate/deallocate in conjunction
           with the arena must be flushed beforehand.

       arena.&lt;i&gt;.destroy (<b>void</b>) --
           Destroy the arena. Discard all of the arena's extant allocations using the same mechanism as for
           arena.&lt;i&gt;.reset (with all the same constraints and side effects), merge the arena stats into those
           accessible at arena index <b>MALLCTL_ARENAS_DESTROYED</b>, and then completely discard all metadata
           associated with the arena. Future calls to arenas.create may recycle the arena index. Destruction
           will fail if any threads are currently associated with the arena as a result of calls to
           thread.arena.

       arena.&lt;i&gt;.dss (<b>const</b> <b>char</b> <b>*</b>) rw
           Set the precedence of dss allocation as related to mmap allocation for arena &lt;i&gt;, or for all arenas
           if &lt;i&gt; equals <b>MALLCTL_ARENAS_ALL</b>. See opt.dss for supported settings.

       arena.&lt;i&gt;.dirty_decay_ms (<b>ssize_t</b>) rw
           Current per-arena approximate time in milliseconds from the creation of a set of unused dirty pages
           until an equivalent set of unused dirty pages is purged and/or reused. Each time this interface is
           set, all currently unused dirty pages are considered to have fully decayed, which causes immediate
           purging of all unused dirty pages unless the decay time is set to -1 (i.e. purging disabled). See
           opt.dirty_decay_ms for additional information.

       arena.&lt;i&gt;.muzzy_decay_ms (<b>ssize_t</b>) rw
           Current per-arena approximate time in milliseconds from the creation of a set of unused muzzy pages
           until an equivalent set of unused muzzy pages is purged and/or reused. Each time this interface is
           set, all currently unused muzzy pages are considered to have fully decayed, which causes immediate
           purging of all unused muzzy pages unless the decay time is set to -1 (i.e. purging disabled). See
           opt.muzzy_decay_ms for additional information.

       arena.&lt;i&gt;.retain_grow_limit (<b>size_t</b>) rw
           Maximum size to grow retained region (only relevant when opt.retain is enabled). This controls the
           maximum increment to expand virtual memory, or allocation through arena.&lt;i&gt;extent_hooks. In
           particular, if customized extent hooks reserve physical memory (e.g. 1G huge pages), this is useful
           to control the allocation hook's input size. The default is no limit.

       arena.&lt;i&gt;.extent_hooks (<b>extent_hooks_t</b> <b>*</b>) rw
           Get or set the extent management hook functions for arena &lt;i&gt;. The functions must be capable of
           operating on all extant extents associated with arena &lt;i&gt;, usually by passing unknown extents to the
           replaced functions. In practice, it is feasible to control allocation for arenas explicitly created
           via arenas.create such that all extents originate from an application-supplied extent allocator (by
           specifying the custom extent hook functions during arena creation). However, the API guarantees for
           the automatically created arenas may be relaxed -- hooks set there may be called in a "best effort"
           fashion; in addition there may be extents created prior to the application having an opportunity to
           take over extent allocation.

               typedef extent_hooks_s extent_hooks_t;
               struct extent_hooks_s {
                    extent_alloc_t      *alloc;
                    extent_dalloc_t          *dalloc;
                    extent_destroy_t    *destroy;
                    extent_commit_t          *commit;
                    extent_decommit_t   *decommit;
                    extent_purge_t      *purge_lazy;
                    extent_purge_t      *purge_forced;
                    extent_split_t      *split;
                    extent_merge_t      *merge;
               };

           The <b>extent_hooks_t</b> structure comprises function pointers which are described individually below.
           jemalloc uses these functions to manage extent lifetime, which starts off with allocation of mapped
           committed memory, in the simplest case followed by deallocation. However, there are performance and
           platform reasons to retain extents for later reuse. Cleanup attempts cascade from deallocation to
           decommit to forced purging to lazy purging, which gives the extent management functions opportunities
           to reject the most permanent cleanup operations in favor of less permanent (and often less costly)
           operations. All operations except allocation can be universally opted out of by setting the hook
           pointers to <b>NULL</b>, or selectively opted out of by returning failure. Note that once the extent hook is
           set, the structure is accessed directly by the associated arenas, so it must remain valid for the
           entire lifetime of the arenas.

           <b>typedef</b> <b>void</b> <b>*(extent_alloc_t)(extent_hooks_t</b> <b>*</b><u>extent_hooks</u><b>,</b> <b>void</b> <b>*</b><u>new_addr</u><b>,</b> <b>size_t</b> <u>size</u><b>,</b>
                                          <b>size_t</b> <u>alignment</u><b>,</b> <b>bool</b> <b>*</b><u>zero</u><b>,</b> <b>bool</b> <b>*</b><u>commit</u><b>,</b> <b>unsigned</b> <u>arena_ind</u><b>);</b>

           An extent allocation function conforms to the <b>extent_alloc_t</b> type and upon success returns a pointer
           to <u>size</u> bytes of mapped memory on behalf of arena <u>arena_ind</u> such that the extent's base address is a
           multiple of <u>alignment</u>, as well as setting <u>*zero</u> to indicate whether the extent is zeroed and <u>*commit</u>
           to indicate whether the extent is committed. Upon error the function returns <b>NULL</b> and leaves <u>*zero</u>
           and <u>*commit</u> unmodified. The <u>size</u> parameter is always a multiple of the page size. The <u>alignment</u>
           parameter is always a power of two at least as large as the page size. Zeroing is mandatory if <u>*zero</u>
           is true upon function entry. Committing is mandatory if <u>*commit</u> is true upon function entry. If
           <u>new_addr</u> is not <b>NULL</b>, the returned pointer must be <u>new_addr</u> on success or <b>NULL</b> on error. Committed
           memory may be committed in absolute terms as on a system that does not overcommit, or in implicit
           terms as on a system that overcommits and satisfies physical memory needs on demand via soft page
           faults. Note that replacing the default extent allocation function makes the arena's arena.&lt;i&gt;.dss
           setting irrelevant.

           <b>typedef</b> <b>bool</b> <b>(extent_dalloc_t)(extent_hooks_t</b> <b>*</b><u>extent_hooks</u><b>,</b> <b>void</b> <b>*</b><u>addr</u><b>,</b> <b>size_t</b> <u>size</u><b>,</b> <b>bool</b> <u>committed</u><b>,</b>
                                          <b>unsigned</b> <u>arena_ind</u><b>);</b>

           An extent deallocation function conforms to the <b>extent_dalloc_t</b> type and deallocates an extent at
           given <u>addr</u> and <u>size</u> with <u>committed</u>/decommited memory as indicated, on behalf of arena <u>arena_ind</u>,
           returning false upon success. If the function returns true, this indicates opt-out from deallocation;
           the virtual memory mapping associated with the extent remains mapped, in the same commit state, and
           available for future use, in which case it will be automatically retained for later reuse.

           <b>typedef</b> <b>void</b> <b>(extent_destroy_t)(extent_hooks_t</b> <b>*</b><u>extent_hooks</u><b>,</b> <b>void</b> <b>*</b><u>addr</u><b>,</b> <b>size_t</b> <u>size</u><b>,</b>
                                           <b>bool</b> <u>committed</u><b>,</b> <b>unsigned</b> <u>arena_ind</u><b>);</b>

           An extent destruction function conforms to the <b>extent_destroy_t</b> type and unconditionally destroys an
           extent at given <u>addr</u> and <u>size</u> with <u>committed</u>/decommited memory as indicated, on behalf of arena
           <u>arena_ind</u>. This function may be called to destroy retained extents during arena destruction (see
           arena.&lt;i&gt;.destroy).

           <b>typedef</b> <b>bool</b> <b>(extent_commit_t)(extent_hooks_t</b> <b>*</b><u>extent_hooks</u><b>,</b> <b>void</b> <b>*</b><u>addr</u><b>,</b> <b>size_t</b> <u>size</u><b>,</b> <b>size_t</b> <u>offset</u><b>,</b>
                                          <b>size_t</b> <u>length</u><b>,</b> <b>unsigned</b> <u>arena_ind</u><b>);</b>

           An extent commit function conforms to the <b>extent_commit_t</b> type and commits zeroed physical memory to
           back pages within an extent at given <u>addr</u> and <u>size</u> at <u>offset</u> bytes, extending for <u>length</u> on behalf of
           arena <u>arena_ind</u>, returning false upon success. Committed memory may be committed in absolute terms as
           on a system that does not overcommit, or in implicit terms as on a system that overcommits and
           satisfies physical memory needs on demand via soft page faults. If the function returns true, this
           indicates insufficient physical memory to satisfy the request.

           <b>typedef</b> <b>bool</b> <b>(extent_decommit_t)(extent_hooks_t</b> <b>*</b><u>extent_hooks</u><b>,</b> <b>void</b> <b>*</b><u>addr</u><b>,</b> <b>size_t</b> <u>size</u><b>,</b>
                                            <b>size_t</b> <u>offset</u><b>,</b> <b>size_t</b> <u>length</u><b>,</b> <b>unsigned</b> <u>arena_ind</u><b>);</b>

           An extent decommit function conforms to the <b>extent_decommit_t</b> type and decommits any physical memory
           that is backing pages within an extent at given <u>addr</u> and <u>size</u> at <u>offset</u> bytes, extending for <u>length</u>
           on behalf of arena <u>arena_ind</u>, returning false upon success, in which case the pages will be committed
           via the extent commit function before being reused. If the function returns true, this indicates
           opt-out from decommit; the memory remains committed and available for future use, in which case it
           will be automatically retained for later reuse.

           <b>typedef</b> <b>bool</b> <b>(extent_purge_t)(extent_hooks_t</b> <b>*</b><u>extent_hooks</u><b>,</b> <b>void</b> <b>*</b><u>addr</u><b>,</b> <b>size_t</b> <u>size</u><b>,</b> <b>size_t</b> <u>offset</u><b>,</b>
                                         <b>size_t</b> <u>length</u><b>,</b> <b>unsigned</b> <u>arena_ind</u><b>);</b>

           An extent purge function conforms to the <b>extent_purge_t</b> type and discards physical pages within the
           virtual memory mapping associated with an extent at given <u>addr</u> and <u>size</u> at <u>offset</u> bytes, extending
           for <u>length</u> on behalf of arena <u>arena_ind</u>. A lazy extent purge function (e.g. implemented via
           madvise(<u>...</u><b>MADV_FREE</b>)) can delay purging indefinitely and leave the pages within the purged virtual
           memory range in an indeterminite state, whereas a forced extent purge function immediately purges,
           and the pages within the virtual memory range will be zero-filled the next time they are accessed. If
           the function returns true, this indicates failure to purge.

           <b>typedef</b> <b>bool</b> <b>(extent_split_t)(extent_hooks_t</b> <b>*</b><u>extent_hooks</u><b>,</b> <b>void</b> <b>*</b><u>addr</u><b>,</b> <b>size_t</b> <u>size</u><b>,</b> <b>size_t</b> <u>size_a</u><b>,</b>
                                         <b>size_t</b> <u>size_b</u><b>,</b> <b>bool</b> <u>committed</u><b>,</b> <b>unsigned</b> <u>arena_ind</u><b>);</b>

           An extent split function conforms to the <b>extent_split_t</b> type and optionally splits an extent at given
           <u>addr</u> and <u>size</u> into two adjacent extents, the first of <u>size_a</u> bytes, and the second of <u>size_b</u> bytes,
           operating on <u>committed</u>/decommitted memory as indicated, on behalf of arena <u>arena_ind</u>, returning false
           upon success. If the function returns true, this indicates that the extent remains unsplit and
           therefore should continue to be operated on as a whole.

           <b>typedef</b> <b>bool</b> <b>(extent_merge_t)(extent_hooks_t</b> <b>*</b><u>extent_hooks</u><b>,</b> <b>void</b> <b>*</b><u>addr_a</u><b>,</b> <b>size_t</b> <u>size_a</u><b>,</b>
                                         <b>void</b> <b>*</b><u>addr_b</u><b>,</b> <b>size_t</b> <u>size_b</u><b>,</b> <b>bool</b> <u>committed</u><b>,</b> <b>unsigned</b> <u>arena_ind</u><b>);</b>

           An extent merge function conforms to the <b>extent_merge_t</b> type and optionally merges adjacent extents,
           at given <u>addr_a</u> and <u>size_a</u> with given <u>addr_b</u> and <u>size_b</u> into one contiguous extent, operating on
           <u>committed</u>/decommitted memory as indicated, on behalf of arena <u>arena_ind</u>, returning false upon
           success. If the function returns true, this indicates that the extents remain distinct mappings and
           therefore should continue to be operated on independently.

       arenas.narenas (<b>unsigned</b>) r-
           Current limit on number of arenas.

       arenas.dirty_decay_ms (<b>ssize_t</b>) rw
           Current default per-arena approximate time in milliseconds from the creation of a set of unused dirty
           pages until an equivalent set of unused dirty pages is purged and/or reused, used to initialize
           arena.&lt;i&gt;.dirty_decay_ms during arena creation. See opt.dirty_decay_ms for additional information.

       arenas.muzzy_decay_ms (<b>ssize_t</b>) rw
           Current default per-arena approximate time in milliseconds from the creation of a set of unused muzzy
           pages until an equivalent set of unused muzzy pages is purged and/or reused, used to initialize
           arena.&lt;i&gt;.muzzy_decay_ms during arena creation. See opt.muzzy_decay_ms for additional information.

       arenas.quantum (<b>size_t</b>) r-
           Quantum size.

       arenas.page (<b>size_t</b>) r-
           Page size.

       arenas.tcache_max (<b>size_t</b>) r-
           Maximum thread-cached size class.

       arenas.nbins (<b>unsigned</b>) r-
           Number of bin size classes.

       arenas.nhbins (<b>unsigned</b>) r-
           Total number of thread cache bin size classes.

       arenas.bin.&lt;i&gt;.size (<b>size_t</b>) r-
           Maximum size supported by size class.

       arenas.bin.&lt;i&gt;.nregs (<b>uint32_t</b>) r-
           Number of regions per slab.

       arenas.bin.&lt;i&gt;.slab_size (<b>size_t</b>) r-
           Number of bytes per slab.

       arenas.nlextents (<b>unsigned</b>) r-
           Total number of large size classes.

       arenas.lextent.&lt;i&gt;.size (<b>size_t</b>) r-
           Maximum size supported by this large size class.

       arenas.create (<b>unsigned</b>, <b>extent_hooks_t</b> <b>*</b>) rw
           Explicitly create a new arena outside the range of automatically managed arenas, with optionally
           specified extent hooks, and return the new arena index.

           If the amount of space supplied for storing the arena index does not equal sizeof(<b>unsigned</b>), no arena
           will be created, no data will be written to the space pointed by <u>oldp</u>, and <u>*oldlenp</u> will be set to 0.

       arenas.lookup (<b>unsigned</b>, <b>void*</b>) rw
           Index of the arena to which an allocation belongs to.

       prof.thread_active_init (<b>bool</b>) rw [<b>--enable-prof</b>]
           Control the initial setting for thread.prof.active in newly created threads. See the
           opt.prof_thread_active_init option for additional information.

       prof.active (<b>bool</b>) rw [<b>--enable-prof</b>]
           Control whether sampling is currently active. See the opt.prof_active option for additional
           information, as well as the interrelated thread.prof.active mallctl.

       prof.dump (<b>const</b> <b>char</b> <b>*</b>) -w [<b>--enable-prof</b>]
           Dump a memory profile to the specified file, or if NULL is specified, to a file according to the
           pattern &lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.m&lt;mseq&gt;.heap, where &lt;prefix&gt; is controlled by the opt.prof_prefix and
           prof.prefix options.

       prof.prefix (<b>const</b> <b>char</b> <b>*</b>) -w [<b>--enable-prof</b>]
           Set the filename prefix for profile dumps. See opt.prof_prefix for the default setting. This can be
           useful to differentiate profile dumps such as from forked processes.

       prof.gdump (<b>bool</b>) rw [<b>--enable-prof</b>]
           When enabled, trigger a memory profile dump every time the total virtual memory exceeds the previous
           maximum. Profiles are dumped to files named according to the pattern
           &lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.u&lt;useq&gt;.heap, where &lt;prefix&gt; is controlled by the opt.prof_prefix and
           prof.prefix options.

       prof.reset (<b>size_t</b>) -w [<b>--enable-prof</b>]
           Reset all memory profile statistics, and optionally update the sample rate (see opt.lg_prof_sample
           and prof.lg_sample).

       prof.lg_sample (<b>size_t</b>) r- [<b>--enable-prof</b>]
           Get the current sample rate (see opt.lg_prof_sample).

       prof.interval (<b>uint64_t</b>) r- [<b>--enable-prof</b>]
           Average number of bytes allocated between interval-based profile dumps. See the opt.lg_prof_interval
           option for additional information.

       stats.allocated (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Total number of bytes allocated by the application.

       stats.active (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Total number of bytes in active pages allocated by the application. This is a multiple of the page
           size, and greater than or equal to stats.allocated. This does not include stats.arenas.&lt;i&gt;.pdirty,
           stats.arenas.&lt;i&gt;.pmuzzy, nor pages entirely devoted to allocator metadata.

       stats.metadata (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Total number of bytes dedicated to metadata, which comprise base allocations used for
           bootstrap-sensitive allocator metadata structures (see stats.arenas.&lt;i&gt;.base) and internal
           allocations (see stats.arenas.&lt;i&gt;.internal). Transparent huge page (enabled with opt.metadata_thp)
           usage is not considered.

       stats.metadata_thp (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Number of transparent huge pages (THP) used for metadata. See stats.metadata and opt.metadata_thp)
           for details.

       stats.resident (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Maximum number of bytes in physically resident data pages mapped by the allocator, comprising all
           pages dedicated to allocator metadata, pages backing active allocations, and unused dirty pages. This
           is a maximum rather than precise because pages may not actually be physically resident if they
           correspond to demand-zeroed virtual memory that has not yet been touched. This is a multiple of the
           page size, and is larger than stats.active.

       stats.mapped (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Total number of bytes in active extents mapped by the allocator. This is larger than stats.active.
           This does not include inactive extents, even those that contain unused dirty pages, which means that
           there is no strict ordering between this and stats.resident.

       stats.retained (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Total number of bytes in virtual memory mappings that were retained rather than being returned to the
           operating system via e.g.  <b><a href="../man2/munmap.2.html">munmap</a></b>(2) or similar. Retained virtual memory is typically untouched,
           decommitted, or purged, so it has no strongly associated physical memory (see extent hooks for
           details). Retained memory is excluded from mapped memory statistics, e.g.  stats.mapped.

       stats.zero_reallocs (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Number of times that the realloc() was called with a non-<b>NULL</b> pointer argument and a <b>0</b> size argument.
           This is a fundamentally unsafe pattern in portable programs; see opt.zero_realloc for details.

       stats.background_thread.num_threads (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Number of background threads running currently.

       stats.background_thread.num_runs (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Total number of runs from all background threads.

       stats.background_thread.run_interval (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Average run interval in nanoseconds of background threads.

       stats.mutexes.ctl.{counter}; (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>ctl</u> mutex (global scope; mallctl related).  {counter} is one of the counters below:

               <u>num_ops</u> (<b>uint64_t</b>): Total number of lock acquisition operations on this mutex.

               <u>num_spin_acq</u> (<b>uint64_t</b>): Number of times the mutex was spin-acquired. When the mutex is currently
               locked and cannot be acquired immediately, a short period of spin-retry within jemalloc will be
               performed. Acquired through spin generally means the contention was lightweight and not causing
               context switches.

               <u>num_wait</u> (<b>uint64_t</b>): Number of times the mutex was wait-acquired, which means the mutex
               contention was not solved by spin-retry, and blocking operation was likely involved in order to
               acquire the mutex. This event generally implies higher cost / longer delay, and should be
               investigated if it happens often.

               <u>max_wait_time</u> (<b>uint64_t</b>): Maximum length of time in nanoseconds spent on a single wait-acquired
               lock operation. Note that to avoid profiling overhead on the common path, this does not consider
               spin-acquired cases.

               <u>total_wait_time</u> (<b>uint64_t</b>): Cumulative time in nanoseconds spent on wait-acquired lock
               operations. Similarly, spin-acquired cases are not considered.

               <u>max_num_thds</u> (<b>uint32_t</b>): Maximum number of threads waiting on this mutex simultaneously.
               Similarly, spin-acquired cases are not considered.

               <u>num_owner_switch</u> (<b>uint64_t</b>): Number of times the current mutex owner is different from the
               previous one. This event does not generally imply an issue; rather it is an indicator of how
               often the protected data are accessed by different threads.

       stats.mutexes.background_thread.{counter} (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>background_thread</u> mutex (global scope; background_thread related).  {counter} is one of
           the counters in mutex profiling counters.

       stats.mutexes.prof.{counter} (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>prof</u> mutex (global scope; profiling related).  {counter} is one of the counters in
           mutex profiling counters.

       stats.mutexes.prof_thds_data.{counter} (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>prof</u> threads data mutex (global scope; profiling related).  {counter} is one of the
           counters in mutex profiling counters.

       stats.mutexes.prof_dump.{counter} (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>prof</u> dumping mutex (global scope; profiling related).  {counter} is one of the counters
           in mutex profiling counters.

       stats.mutexes.reset (<b>void</b>) -- [<b>--enable-stats</b>]
           Reset all mutex profile statistics, including global mutexes, arena mutexes and bin mutexes.

       stats.arenas.&lt;i&gt;.dss (<b>const</b> <b>char</b> <b>*</b>) r-
           dss (<b><a href="../man2/sbrk.2.html">sbrk</a></b>(2)) allocation precedence as related to <b><a href="../man2/mmap.2.html">mmap</a></b>(2) allocation. See opt.dss for details.

       stats.arenas.&lt;i&gt;.dirty_decay_ms (<b>ssize_t</b>) r-
           Approximate time in milliseconds from the creation of a set of unused dirty pages until an equivalent
           set of unused dirty pages is purged and/or reused. See opt.dirty_decay_ms for details.

       stats.arenas.&lt;i&gt;.muzzy_decay_ms (<b>ssize_t</b>) r-
           Approximate time in milliseconds from the creation of a set of unused muzzy pages until an equivalent
           set of unused muzzy pages is purged and/or reused. See opt.muzzy_decay_ms for details.

       stats.arenas.&lt;i&gt;.nthreads (<b>unsigned</b>) r-
           Number of threads currently assigned to arena.

       stats.arenas.&lt;i&gt;.uptime (<b>uint64_t</b>) r-
           Time elapsed (in nanoseconds) since the arena was created. If &lt;i&gt; equals <b>0</b> or <b>MALLCTL_ARENAS_ALL</b>,
           this is the uptime since malloc initialization.

       stats.arenas.&lt;i&gt;.pactive (<b>size_t</b>) r-
           Number of pages in active extents.

       stats.arenas.&lt;i&gt;.pdirty (<b>size_t</b>) r-
           Number of pages within unused extents that are potentially dirty, and for which madvise() or similar
           has not been called. See opt.dirty_decay_ms for a description of dirty pages.

       stats.arenas.&lt;i&gt;.pmuzzy (<b>size_t</b>) r-
           Number of pages within unused extents that are muzzy. See opt.muzzy_decay_ms for a description of
           muzzy pages.

       stats.arenas.&lt;i&gt;.mapped (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Number of mapped bytes.

       stats.arenas.&lt;i&gt;.retained (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Number of retained bytes. See stats.retained for details.

       stats.arenas.&lt;i&gt;.extent_avail (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Number of allocated (but unused) extent structs in this arena.

       stats.arenas.&lt;i&gt;.base (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Number of bytes dedicated to bootstrap-sensitive allocator metadata structures.

       stats.arenas.&lt;i&gt;.internal (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Number of bytes dedicated to internal allocations. Internal allocations differ from
           application-originated allocations in that they are for internal use, and that they are omitted from
           heap profiles.

       stats.arenas.&lt;i&gt;.metadata_thp (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Number of transparent huge pages (THP) used for metadata. See opt.metadata_thp for details.

       stats.arenas.&lt;i&gt;.resident (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Maximum number of bytes in physically resident data pages mapped by the arena, comprising all pages
           dedicated to allocator metadata, pages backing active allocations, and unused dirty pages. This is a
           maximum rather than precise because pages may not actually be physically resident if they correspond
           to demand-zeroed virtual memory that has not yet been touched. This is a multiple of the page size.

       stats.arenas.&lt;i&gt;.dirty_npurge (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Number of dirty page purge sweeps performed.

       stats.arenas.&lt;i&gt;.dirty_nmadvise (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Number of madvise() or similar calls made to purge dirty pages.

       stats.arenas.&lt;i&gt;.dirty_purged (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Number of dirty pages purged.

       stats.arenas.&lt;i&gt;.muzzy_npurge (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Number of muzzy page purge sweeps performed.

       stats.arenas.&lt;i&gt;.muzzy_nmadvise (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Number of madvise() or similar calls made to purge muzzy pages.

       stats.arenas.&lt;i&gt;.muzzy_purged (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Number of muzzy pages purged.

       stats.arenas.&lt;i&gt;.small.allocated (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Number of bytes currently allocated by small objects.

       stats.arenas.&lt;i&gt;.small.nmalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of times a small allocation was requested from the arena's bins, whether to fill
           the relevant tcache if opt.tcache is enabled, or to directly satisfy an allocation request otherwise.

       stats.arenas.&lt;i&gt;.small.ndalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of times a small allocation was returned to the arena's bins, whether to flush the
           relevant tcache if opt.tcache is enabled, or to directly deallocate an allocation otherwise.

       stats.arenas.&lt;i&gt;.small.nrequests (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of allocation requests satisfied by all bin size classes.

       stats.arenas.&lt;i&gt;.small.nfills (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of tcache fills by all small size classes.

       stats.arenas.&lt;i&gt;.small.nflushes (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of tcache flushes by all small size classes.

       stats.arenas.&lt;i&gt;.large.allocated (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Number of bytes currently allocated by large objects.

       stats.arenas.&lt;i&gt;.large.nmalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of times a large extent was allocated from the arena, whether to fill the relevant
           tcache if opt.tcache is enabled and the size class is within the range being cached, or to directly
           satisfy an allocation request otherwise.

       stats.arenas.&lt;i&gt;.large.ndalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of times a large extent was returned to the arena, whether to flush the relevant
           tcache if opt.tcache is enabled and the size class is within the range being cached, or to directly
           deallocate an allocation otherwise.

       stats.arenas.&lt;i&gt;.large.nrequests (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of allocation requests satisfied by all large size classes.

       stats.arenas.&lt;i&gt;.large.nfills (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of tcache fills by all large size classes.

       stats.arenas.&lt;i&gt;.large.nflushes (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of tcache flushes by all large size classes.

       stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nmalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of times a bin region of the corresponding size class was allocated from the arena,
           whether to fill the relevant tcache if opt.tcache is enabled, or to directly satisfy an allocation
           request otherwise.

       stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.ndalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of times a bin region of the corresponding size class was returned to the arena,
           whether to flush the relevant tcache if opt.tcache is enabled, or to directly deallocate an
           allocation otherwise.

       stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nrequests (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of allocation requests satisfied by bin regions of the corresponding size class.

       stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.curregs (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Current number of regions for this size class.

       stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nfills (<b>uint64_t</b>) r-
           Cumulative number of tcache fills.

       stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nflushes (<b>uint64_t</b>) r-
           Cumulative number of tcache flushes.

       stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nslabs (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of slabs created.

       stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nreslabs (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of times the current slab from which to allocate changed.

       stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.curslabs (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Current number of slabs.

       stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nonfull_slabs (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Current number of nonfull slabs.

       stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.mutex.{counter} (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>arena.&lt;i&gt;.bins.&lt;j&gt;</u> mutex (arena bin scope; bin operation related).  {counter} is one of
           the counters in mutex profiling counters.

       stats.arenas.&lt;i&gt;.extents.&lt;j&gt;.n{extent_type} (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Number of extents of the given type in this arena in the bucket corresponding to page size index &lt;j&gt;.
           The extent type is one of dirty, muzzy, or retained.

       stats.arenas.&lt;i&gt;.extents.&lt;j&gt;.{extent_type}_bytes (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Sum of the bytes managed by extents of the given type in this arena in the bucket corresponding to
           page size index &lt;j&gt;. The extent type is one of dirty, muzzy, or retained.

       stats.arenas.&lt;i&gt;.lextents.&lt;j&gt;.nmalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of times a large extent of the corresponding size class was allocated from the
           arena, whether to fill the relevant tcache if opt.tcache is enabled and the size class is within the
           range being cached, or to directly satisfy an allocation request otherwise.

       stats.arenas.&lt;i&gt;.lextents.&lt;j&gt;.ndalloc (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of times a large extent of the corresponding size class was returned to the arena,
           whether to flush the relevant tcache if opt.tcache is enabled and the size class is within the range
           being cached, or to directly deallocate an allocation otherwise.

       stats.arenas.&lt;i&gt;.lextents.&lt;j&gt;.nrequests (<b>uint64_t</b>) r- [<b>--enable-stats</b>]
           Cumulative number of allocation requests satisfied by large extents of the corresponding size class.

       stats.arenas.&lt;i&gt;.lextents.&lt;j&gt;.curlextents (<b>size_t</b>) r- [<b>--enable-stats</b>]
           Current number of large allocations for this size class.

       stats.arenas.&lt;i&gt;.mutexes.large.{counter} (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>arena.&lt;i&gt;.large</u> mutex (arena scope; large allocation related).  {counter} is one of the
           counters in mutex profiling counters.

       stats.arenas.&lt;i&gt;.mutexes.extent_avail.{counter} (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>arena.&lt;i&gt;.extent_avail</u> mutex (arena scope; extent avail related).  {counter} is one of
           the counters in mutex profiling counters.

       stats.arenas.&lt;i&gt;.mutexes.extents_dirty.{counter} (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>arena.&lt;i&gt;.extents_dirty</u> mutex (arena scope; dirty extents related).  {counter} is one
           of the counters in mutex profiling counters.

       stats.arenas.&lt;i&gt;.mutexes.extents_muzzy.{counter} (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>arena.&lt;i&gt;.extents_muzzy</u> mutex (arena scope; muzzy extents related).  {counter} is one
           of the counters in mutex profiling counters.

       stats.arenas.&lt;i&gt;.mutexes.extents_retained.{counter} (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>arena.&lt;i&gt;.extents_retained</u> mutex (arena scope; retained extents related).  {counter} is
           one of the counters in mutex profiling counters.

       stats.arenas.&lt;i&gt;.mutexes.decay_dirty.{counter} (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>arena.&lt;i&gt;.decay_dirty</u> mutex (arena scope; decay for dirty pages related).  {counter} is
           one of the counters in mutex profiling counters.

       stats.arenas.&lt;i&gt;.mutexes.decay_muzzy.{counter} (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>arena.&lt;i&gt;.decay_muzzy</u> mutex (arena scope; decay for muzzy pages related).  {counter} is
           one of the counters in mutex profiling counters.

       stats.arenas.&lt;i&gt;.mutexes.base.{counter} (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>arena.&lt;i&gt;.base</u> mutex (arena scope; base allocator related).  {counter} is one of the
           counters in mutex profiling counters.

       stats.arenas.&lt;i&gt;.mutexes.tcache_list.{counter} (<b>counter</b> <b>specific</b> <b>type</b>) r- [<b>--enable-stats</b>]
           Statistics on <u>arena.&lt;i&gt;.tcache_list</u> mutex (arena scope; tcache to arena association related). This
           mutex is expected to be accessed less often.  {counter} is one of the counters in mutex profiling
           counters.

</pre><h4><b>HEAP</b> <b>PROFILE</b> <b>FORMAT</b></h4><pre>
       Although the heap profiling functionality was originally designed to be compatible with the <b>pprof</b> command
       that is developed as part of the <b>gperftools</b> <b>package</b>[3], the addition of per thread heap profiling
       functionality required a different heap profile format. The <b>jeprof</b> command is derived from <b>pprof</b>, with
       enhancements to support the heap profile format described here.

       In the following hypothetical heap profile, <b>[...]</b>  indicates elision for the sake of compactness.

           heap_v2/524288
             t*: 28106: 56637512 [0: 0]
             [...]
             t3: 352: 16777344 [0: 0]
             [...]
             t99: 17754: 29341640 [0: 0]
             [...]
           @ 0x5f86da8 0x5f5a1dc [...] 0x29e4d4e 0xa200316 0xabb2988 [...]
             t*: 13: 6688 [0: 0]
             t3: 12: 6496 [0: 0]
             t99: 1: 192 [0: 0]
           [...]

           MAPPED_LIBRARIES:
           [...]

       The following matches the above heap profile, but most tokens are replaced with <b>&lt;description&gt;</b> to indicate
       descriptions of the corresponding fields.

           &lt;heap_profile_format_version&gt;/&lt;mean_sample_interval&gt;
             &lt;aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
             [...]
             &lt;thread_3_aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
             [...]
             &lt;thread_99_aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
             [...]
           @ &lt;top_frame&gt; &lt;frame&gt; [...] &lt;frame&gt; &lt;frame&gt; &lt;frame&gt; [...]
             &lt;backtrace_aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
             &lt;backtrace_thread_3&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
             &lt;backtrace_thread_99&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
           [...]

           MAPPED_LIBRARIES:
           &lt;<a href="file:/proc/">/proc/</a>&lt;pid&gt;/maps&gt;

</pre><h4><b>DEBUGGING</b> <b>MALLOC</b> <b>PROBLEMS</b></h4><pre>
       When debugging, it is a good idea to configure/build jemalloc with the <b>--enable-debug</b> and <b>--enable-fill</b>
       options, and recompile the program with suitable options and symbols for debugger support. When so
       configured, jemalloc incorporates a wide variety of run-time assertions that catch application errors
       such as double-free, write-after-free, etc.

       Programs often accidentally depend on “uninitialized” memory actually being filled with zero bytes. Junk
       filling (see the opt.junk option) tends to expose such bugs in the form of obviously incorrect results
       and/or coredumps. Conversely, zero filling (see the opt.zero option) eliminates the symptoms of such
       bugs. Between these two options, it is usually possible to quickly detect, diagnose, and eliminate such
       bugs.

       This implementation does not provide much detail about the problems it detects, because the performance
       impact for storing such information would be prohibitive.

</pre><h4><b>DIAGNOSTIC</b> <b>MESSAGES</b></h4><pre>
       If any of the memory allocation/deallocation functions detect an error or warning condition, a message
       will be printed to file descriptor <b>STDERR_FILENO</b>. Errors will result in the process dumping core. If the
       opt.abort option is set, most warnings are treated as errors.

       The <u>malloc_message</u> variable allows the programmer to override the function which emits the text strings
       forming the errors and warnings if for some reason the <b>STDERR_FILENO</b> file descriptor is not suitable for
       this.  malloc_message() takes the <u>cbopaque</u> pointer argument that is <b>NULL</b> unless overridden by the
       arguments in a call to malloc_stats_print(), followed by a string pointer. Please note that doing
       anything which tries to allocate memory in this function is likely to result in a crash or deadlock.

       All messages are prefixed by “&lt;jemalloc&gt;: ”.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
   <b>Standard</b> <b>API</b>
       The malloc() and calloc() functions return a pointer to the allocated memory if successful; otherwise a
       <b>NULL</b> pointer is returned and <u>errno</u> is set to ENOMEM.

       The posix_memalign() function returns the value 0 if successful; otherwise it returns an error value. The
       posix_memalign() function will fail if:

       EINVAL
           The <u>alignment</u> parameter is not a power of 2 at least as large as sizeof(<b>void</b> <b>*</b>).

       ENOMEM
           Memory allocation error.

       The aligned_alloc() function returns a pointer to the allocated memory if successful; otherwise a <b>NULL</b>
       pointer is returned and <u>errno</u> is set. The aligned_alloc() function will fail if:

       EINVAL
           The <u>alignment</u> parameter is not a power of 2.

       ENOMEM
           Memory allocation error.

       The realloc() function returns a pointer, possibly identical to <u>ptr</u>, to the allocated memory if
       successful; otherwise a <b>NULL</b> pointer is returned, and <u>errno</u> is set to ENOMEM if the error was the result
       of an allocation failure. The realloc() function always leaves the original buffer intact when an error
       occurs.

       The free() function returns no value.

   <b>Non-standard</b> <b>API</b>
       The mallocx() and rallocx() functions return a pointer to the allocated memory if successful; otherwise a
       <b>NULL</b> pointer is returned to indicate insufficient contiguous memory was available to service the
       allocation request.

       The xallocx() function returns the real size of the resulting resized allocation pointed to by <u>ptr</u>, which
       is a value less than <u>size</u> if the allocation could not be adequately grown in place.

       The sallocx() function returns the real size of the allocation pointed to by <u>ptr</u>.

       The nallocx() returns the real size that would result from a successful equivalent mallocx() function
       call, or zero if insufficient memory is available to perform the size computation.

       The mallctl(), mallctlnametomib(), and mallctlbymib() functions return 0 on success; otherwise they
       return an error value. The functions will fail if:

       EINVAL
           <u>newp</u> is not <b>NULL</b>, and <u>newlen</u> is too large or too small. Alternatively, <u>*oldlenp</u> is too large or too
           small; when it happens, except for a very few cases explicitly documented otherwise, as much data as
           possible are read despite the error, with the amount of data read being recorded in <u>*oldlenp</u>.

       ENOENT
           <u>name</u> or <u>mib</u> specifies an unknown/invalid value.

       EPERM
           Attempt to read or write void value, or attempt to write read-only value.

       EAGAIN
           A memory allocation failure occurred.

       EFAULT
           An interface with side effects failed in some way not directly related to mallctl*() read/write
           processing.

       The malloc_usable_size() function returns the usable size of the allocation pointed to by <u>ptr</u>.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       The following environment variable affects the execution of the allocation functions:

       <b>MALLOC_CONF</b>
           If the environment variable <b>MALLOC_CONF</b> is set, the characters it contains will be interpreted as
           options.

</pre><h4><b>EXAMPLES</b></h4><pre>
       To dump core whenever a problem occurs:

           ln -s 'abort:true' /etc/malloc.conf

       To specify in the source that only one arena should be automatically created:

           malloc_conf = "narenas:1";

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/madvise.2.html">madvise</a></b>(2), <b><a href="../man2/mmap.2.html">mmap</a></b>(2), <b><a href="../man2/sbrk.2.html">sbrk</a></b>(2), <b><a href="../man2/utrace.2.html">utrace</a></b>(2), <b><a href="../man3/alloca.3.html">alloca</a></b>(3), <b><a href="../man3/atexit.3.html">atexit</a></b>(3), <b><a href="../man3/getpagesize.3.html">getpagesize</a></b>(3)

</pre><h4><b>STANDARDS</b></h4><pre>
       The malloc(), calloc(), realloc(), and free() functions conform to ISO/IEC 9899:1990 (“ISO C90”).

       The posix_memalign() function conforms to IEEE Std 1003.1-2001 (“POSIX.1”).

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>Jason</b> <b>Evans</b>

</pre><h4><b>NOTES</b></h4><pre>
        1. jemalloc website
           <a href="http://jemalloc.net/">http://jemalloc.net/</a>

        2. JSON format
           <a href="http://www.json.org/">http://www.json.org/</a>

        3. gperftools package
           <a href="http://code.google.com/p/gperftools/">http://code.google.com/p/gperftools/</a>

jemalloc 5.3.0-0-g54eaed1d8b56                     03/03/2025                                        <u><a href="../man3/JEMALLOC.3.html">JEMALLOC</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>