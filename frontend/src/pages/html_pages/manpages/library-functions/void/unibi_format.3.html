<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unibi_format, unibi_run - interpret a terminfo format string</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libunibilium-dev">libunibilium-dev_2.1.1-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unibi_format, unibi_run - interpret a terminfo format string

</pre><h4><b>SYNOPSIS</b></h4><pre>
         #include &lt;unibilium.h&gt;

         void unibi_format(
             unibi_var_t var_dyn[26],
             unibi_var_t var_static[26],
             const char *fmt,
             unibi_var_t param[9],
             void (*out)(void *, const char *, size_t),
             void *ctx1,
             void (*pad)(void *, size_t, int, int),
             void *ctx2
         );

         size_t unibi_run(const char *fmt, unibi_var_t param[9], char *p, size_t n);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "unibi_format" takes a format string <u>fmt</u> and executes it. All output is done by (possibly repeated) calls
       to <u>out</u>. In the calls to <u>out</u> the first argument is always <u>ctx1</u>, the second argument is a pointer to a
       chunk of data, and the third argument is a count specifying the size of the chunk in bytes.

       <u>pad</u> is used when the format string contains "$&lt;...&gt;" padding instructions. In the calls to <u>pad</u> the first
       argument is always <u>ctx2</u>, the second argument is the delay in tenths of milliseconds, the third argument
       is a boolean flag indicating whether "*" (proportional delay) was specified in the format string, and the
       fourth argument is a boolean flag indicating whether "/" (forced padding) was specified in the format
       string. Thus a format string of "$&lt;5/&gt;" would translate into "pad(ctx2, 50, 0, 1)". You may pass a null
       pointer for <u>pad</u>; in that case padding instructions are silently skipped.

       The values of <u>param</u> are used for the format codes %p1 .. %p9; the values of <u>var_dyn</u> and <u>var_static</u> are
       used for the so-called dynamic/static variables %Pa .. %Pz and %PA .. %PZ, respectively.

       "unibi_run" is a wrapper around "unibi_format". It passes two arrays (each initialized to 26 zeroes) as
       <u>var_dyn</u> and <u>var_static</u>. <u>fmt</u> and <u>param</u> are passed on unchanged. It ignores padding and places all normal
       output in the buffer pointed to by <u>p</u>. <u>n</u> is the size of the buffer; at most <u>n</u> bytes will be written to <u>p</u>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       "unibi_run" returns the number of bytes that would have been written if the buffer was big enough. Thus
       the number of valid bytes in <u>p</u> after a call to "unibi_run" is the minimum of <u>n</u> and the return value of
       "unibi_run".

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/unibi_var_from_num.3.html">unibi_var_from_num</a></b>(3), <b><a href="../man3/unibi_var_from_str.3.html">unibi_var_from_str</a></b>(3), <b><a href="../man3/unibilium.h.3.html">unibilium.h</a></b>(3)

unibilium-2.1.1                                    2024-03-20                               <u>doc::<a href="../man3/unibi_format.3.html">unibi_format</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>