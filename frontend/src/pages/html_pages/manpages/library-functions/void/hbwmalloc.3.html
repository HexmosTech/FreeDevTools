<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hbwmalloc - The high bandwidth memory interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/libmemkind-dev">libmemkind-dev_1.14.0-3.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       hbwmalloc - The high bandwidth memory interface
       <b>Note:</b> <u>hbwmalloc.h</u> functionality is considered as stable API (STANDARD API).

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;hbwmalloc.h&gt;</b>

       <b>Link</b> <b>with</b> <b>-lmemkind</b>

       <b>int</b> <b>hbw_check_available(void);</b>
       <b>void*</b> <b>hbw_malloc(size_t</b> <u>size</u><b>);</b>
       <b>void*</b> <b>hbw_calloc(size_t</b> <u>nmemb</u><b>,</b> <b>size_t</b> <u>size</u><b>);</b>
       <b>void*</b> <b>hbw_realloc</b> <b>(void</b> <u>*ptr</u><b>,</b> <b>size_t</b> <u>size</u><b>);</b>
       <b>void</b> <b>hbw_free(void</b> <u>*ptr</u><b>);</b>
       <b>size_t</b> <b>hbw_malloc_usable_size(void</b> <u>*ptr</u><b>);</b>
       <b>int</b> <b>hbw_posix_memalign(void</b> <u>**memptr</u><b>,</b> <b>size_t</b> <u>alignment</u><b>,</b> <b>size_t</b> <u>size</u><b>);</b>
       <b>int</b> <b>hbw_posix_memalign_psize(void</b> <u>**memptr</u><b>,</b> <b>size_t</b> <u>alignment</u><b>,</b> <b>size_t</b> <u>size</u><b>,</b> <b>hbw_pagesize_t</b> <u>pagesize</u><b>);</b>
       <b>hbw_policy_t</b> <b>hbw_get_policy(void);</b>
       <b>int</b> <b>hbw_set_policy(hbw_policy_t</b> <u>mode</u><b>);</b>
       <b>int</b> <b>hbw_verify_memory_region(void</b> <u>*addr</u><b>,</b> <b>size_t</b> <u>size</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>hbw_check_available</b>()  returns  zero  if high bandwidth memory is available or an error code described in
       the <b>ERRORS</b> section if not.

       <b>hbw_malloc</b>() allocates <u>size</u> bytes of uninitialized high bandwidth memory. The allocated space is suitably
       aligned (after possible pointer coercion) for storage of any  type  of  object.  If  <u>size</u>  is  zero  then
       <b>hbw_malloc</b>() returns <u>NULL</u>.

       <b>hbw_calloc</b>()  allocates  space for <u>nmemb</u> objects in high bandwidth memory, each <u>size</u> bytes in length. The
       result is identical to calling <b>hbw_malloc</b>() with an argument of <u>nmemb</u> * <u>size</u>, with the exception that the
       allocated memory is explicitly initialized to zero bytes.  If <u>nmemb</u>  or  <u>size</u>  is  0,  then  <b>hbw_calloc</b>()
       returns <u>NULL</u>.

       <b>hbw_realloc</b>()  changes  the  size  of the previously allocated high bandwidth memory referenced by <u>ptr</u> to
       <u>size</u> bytes. The contents of the memory remain unchanged up to the lesser of the new and old sizes. If the
       new size is larger, the contents of the newly  allocated  portion  of  the  memory  are  undefined.  Upon
       success, the memory referenced by <u>ptr</u> is freed and a pointer to the newly allocated high bandwidth memory
       is returned.

       <b>Note:</b> <b>hbw_realloc</b>() may move the memory allocation, resulting in a different return value than <u>ptr</u>.

       If  <u>ptr</u>  is  <u>NULL</u>, the <b>hbw_realloc</b>() function behaves identically to <b>hbw_malloc</b>() for the specified size.
       If <u>size</u> is equal to zero, and <u>ptr</u> is not <u>NULL</u>, then the call is equivalent to <u>hbw_free(ptr)</u> and  <u>NULL</u>  is
       returned.  The  address  <u>ptr</u>, if not <u>NULL</u>, was returned by a previous call to <b>hbw_malloc</b>(), <b>hbw_calloc</b>(),
       <b>hbw_realloc</b>() or <b>hbw_posix_memalign</b>().  Otherwise, or  if  <u>hbw_free(ptr)</u>  was  called  before,  undefined
       behavior occurs.

       <b>Note:</b> <b>hbw_realloc</b>() cannot be used with a pointer returned by <b>hbw_posix_memalign_psize</b>().

       <b>hbw_free</b>()  causes the allocated memory referenced by <u>ptr</u> to be made available for future allocations. If
       <u>ptr</u> is <u>NULL</u>, no action occurs.  The address <u>ptr</u>, if not <u>NULL</u>, must have been returned by a previous  call
       to   <b>hbw_malloc</b>(),   <b>hbw_calloc</b>(),  <b>hbw_realloc</b>(),  <b>hbw_posix_memalign</b>()  or  <b>hbw_posix_memalign_psize</b>().
       Otherwise, if <u>hbw_free(ptr)</u> was called before, undefined behavior occurs.

       <b>hbw_malloc_usable_size</b>() returns the number of usable bytes in the block pointed to by <u>ptr</u>, a pointer  to
       a  block  of  memory  allocated  by  <b>hbw_malloc</b>(),  <b>hbw_calloc</b>(), <b>hbw_realloc</b>(), <b>hbw_posix_memalign</b>(), or
       <b>hbw_posix_memalign_psize</b>().

       <b>hbw_posix_memalign</b>() allocates <u>size</u> bytes of high  bandwidth  memory  such  that  the  allocation's  base
       address  is  an even multiple of <u>alignment</u>, and returns the allocation in the value pointed to by <u>memptr</u>.
       The requested <u>alignment</u> must be a power of 2 at least as large as <u>sizeof(void*)</u>.   If  <u>size</u>  is  0,  then
       <b>hbw_posix_memalign</b>() returns 0, with a <u>NULL</u> returned in <u>memptr</u>.

       <b>hbw_posix_memalign_psize</b>()  allocates <u>size</u> bytes of high bandwidth memory such that the allocation's base
       address is an even multiple of <u>alignment</u>, and returns the allocation in the value pointed to  by  <u>memptr</u>.
       The  requested  <u>alignment</u>  must  be  a power of 2 at least as large as <u>sizeof(void*)</u>.  The memory will be
       allocated using pages determined by the <u>pagesize</u> variable which may be one of  the  following  enumerated
       values:

       <b>HBW_PAGESIZE_4KB</b>
              The  four  kilobyte  page  size  option.  Note  that  with  transparent  huge  pages enabled these
              allocations may be promoted by the operating system to two megabyte pages.

       <b>HBW_PAGESIZE_2MB</b>
              The two megabyte page size option.   <b>Note:</b>  This  page  size  requires  huge  pages  configuration
              described in <b>SYSTEM</b> <b>CONFIGURATION</b> section.

       <b>HBW_PAGESIZE_1GB</b> <b>(DEPRECATED)</b>
              This  option  allows  the user to specify arbitrary sizes backed by 1GB chunks of huge pages. Huge
              pages are allocated even if the size is not a modulo of 1GB.  <b>Note:</b> This page size  requires  huge
              pages configuration described in <b>SYSTEM</b> <b>CONFIGURATION</b> section.

       <b>HBW_PAGESIZE_1GB_STRICT</b> <b>(DEPRECATED)</b>
              The  total  size  of  the  allocation  must  be  a multiple of 1GB with this option, otherwise the
              allocation will fail.  <b>Note:</b> This page size requires huge pages configuration described in  <b>SYSTEM</b>
              <b>CONFIGURATION</b> section.

       <b>Note:</b>  <b>HBW_PAGESIZE_2MB</b>,  <b>HBW_PAGESIZE_1GB</b>  and  <b>HBW_PAGESIZE_1GB_STRICT</b>  options  are not supported with
       <b>HBW_POLICY_INTERLEAVE</b> policy.

       <b>hbw_get_policy</b>() returns  the  current  fallback  policy  when  insufficient  high  bandwidth  memory  is
       available.

       <b>hbw_set_policy</b>()  sets  the current fallback policy. The policy can be modified only once in the lifetime
       of an application and before calling <b>hbw_malloc</b>(), <b>hbw_calloc</b>(), <b>hbw_realloc</b>(), <b>hbw_posix_memalign</b>(),  or
       <b>hbw_posix_memalign_psize</b>() function.
       <b>Note:</b> If the policy is not set, than <b>HBW_POLICY_PREFERRED</b> will be used by default.

       <b>HBW_POLICY_BIND</b>
              If  insufficient  high  bandwidth  memory  from  the  nearest  NUMA node is available to satisfy a
              request, the allocated pointer is set to <u>NULL</u> and <u>errno</u> is set to <b>ENOMEM</b>.   If  insufficient  high
              bandwidth  memory  pages  are available at fault time the Out Of Memory (OOM) Killer is triggered.
              Note that pages are faulted exclusively from the high bandwidth  NUMA  node  nearest  at  time  of
              allocation, not at time of fault.

       <b>HBW_POLICY_BIND_ALL</b>
              If  insufficient high bandwidth memory is available to satisfy a request, the allocated pointer is
              set to <u>NULL</u> and <u>errno</u> is set to <b>ENOMEM</b>.  If insufficient high bandwidth memory pages are available
              at fault time the Out Of Memory (OOM) Killer is triggered.  Note that pages are faulted  from  the
              high bandwidth NUMA nodes.  Nearest NUMA node is selected at time of page fault.

       <b>HBW_POLICY_PREFERRED</b>
              If  insufficient memory is available from the high bandwidth NUMA node closest at allocation time,
              fall back to standard memory (default) with the smallest NUMA distance.

       <b>HBW_POLICY_INTERLEAVE</b>
              Interleave faulted pages from across all high bandwidth NUMA nodes using standard size pages  (the
              Transparent Huge Page feature is disabled).

       <b>hbw_verify_memory_region</b>() verifies if memory region fully falls into high bandwidth memory. Returns 0 if
       memory  address  range from <u>addr</u> to <u>addr</u> + <u>size</u> is allocated in high bandwidth memory, -1 if any fragment
       of memory was not backed by high bandwidth memory (e.g. when memory is not initialized) or one  of  error
       codes described in <b>ERRORS</b> section.

       Using this function in production code may result in serious performance penalty.

       The <u>Flags</u> argument may include optional flags that modify function behavior:

       <b>HBW_TOUCH_PAGES</b>
              Before  checking pages, function will touch first byte of all pages in address range starting from
              <u>addr</u> to <u>addr</u> + <u>size</u> by read and write (so the content will be overwritten by the same data  as  it
              was read).  Using this option may trigger Out Of Memory Killer.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>hbw_get_policy</b>()     returns     <b>HBW_POLICY_BIND,</b>     <b>HBW_POLICY_BIND_ALL,</b>     <b>HBW_POLICY_PREFERRED</b>    or
       <b>HBW_POLICY_INTERLEAVE</b> which represents the current high bandwidth policy.  <b>hbw_free</b>() do not have  return
       value.   <b>hbw_malloc</b>()  <b>hbw_calloc</b>() and <b>hbw_realloc</b>() return the pointer to the allocated memory, or <u>NULL</u>
       if the request fails.  <b>hbw_posix_memalign</b>(), <b>hbw_posix_memalign_psize</b>() and <b>hbw_set_policy</b>() return  zero
       on success and return an error code as described in the <b>ERRORS</b> section below on failure.

</pre><h4><b>ERRORS</b></h4><pre>
       Error codes described here are the POSIX standard error codes as defined in
              <u>&lt;errno.h&gt;</u>

       <b>hbw_check_available</b>()
              returns <b>ENODEV</b> if high-bandwidth memory is unavailable.

       <b>hbw_posix_memalign</b>() and <b>hbw_posix_memalign_psize</b>()
              If  the  <u>alignment</u>  parameter  is not a power of two, or was not a multiple of <u>sizeof(void*)</u>, then
              <b>EINVAL</b> is returned.  If the  policy  and  <u>pagesize</u>  combination  is  unsupported  then  <b>EINVAL</b>  is
              returned.  If there was insufficient memory to satisfy the request then <b>ENOMEM</b> is returned.

       <b>hbw_set_policy</b>()
              returns  <b>EPERM</b>  if  <b>hbw_set_policy</b>()  was  called  more  than once, or <b>EINVAL</b> if <u>mode</u> argument was
              neither <b>HBW_POLICY_PREFERRED</b>, <b>HBW_POLICY_BIND</b>, <b>HBW_POLICY_BIND_ALL</b> nor <b>HBW_POLICY_INTERLEAVE</b>.

       <b>hbw_verify_memory_region</b>()
              returns <b>EINVAL</b> if <u>addr</u> is <u>NULL</u>, <u>size</u> equals 0 or <u>flags</u> contained unsupported bit  set.  If  memory
              pointed by <u>addr</u> could not be verified then <b>EFAULT</b> is returned.

</pre><h4><b>NOTES</b></h4><pre>
       The  <u>&lt;hbwmalloc.h&gt;</u>  file defines the external functions and enumerations for the hbwmalloc library. These
       interfaces define a heap manager that targets high bandwidth memory numa nodes.

</pre><h4><b>FILES</b></h4><pre>
       <u>/usr/bin/memkind-hbw-nodes</u>
              Prints a comma-separated list of high bandwidth nodes.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       <b>MEMKIND_HBW_NODES</b>
              This environment variable is a comma-separated list  of  NUMA  nodes  that  are  treated  as  high
              bandwidth.  Uses  the <u>libnuma</u> routine <b>numa_parse_nodestring</b>() for parsing, so the syntax described
              in the <b><a href="../man3/numa.3.html">numa</a></b>(3) man page for this routine applies for example: 1-3,5 is a valid setting.

       <b>MEMKIND_ARENA_NUM_PER_KIND</b>
              This environment variable allows leveraging internal mechanism of the library for  setting  number
              of  arenas  per  kind.  Value  should  be  a positive integer (not greater than <b>INT_MAX</b> defined in
              <u>&lt;limits.h&gt;</u>).  The user should set the value based on the characteristics of  application  that  is
              using  the  library.  Higher  value  can  provide  better  performance  in extremely multithreaded
              applications at the cost of memory overhead. See section <b>IMPLEMENTATION</b> <b>NOTES</b> of  <b><a href="../man3/jemalloc.3.html">jemalloc</a></b>(3)  for
              more details about arenas.

       <b>MEMKIND_HEAP_MANAGER</b>
              Controls  heap  management  behavior  in memkind library by switching to one of the available heap
              managers.
              Values:
                  JEMALLOC - sets the jemalloc heap manager
                  TBB - sets the Intel Threading Building Blocks heap manager. This option requires installed
                  Intel Threading Building Blocks library.

       <b>Note:</b> If the <b>MEMKIND_HEAP_MANAGER</b> is not set then the jemalloc heap manager will be used by default.

</pre><h4><b>SYSTEM</b> <b>CONFIGURATION</b></h4><pre>
       Interfaces for obtaining 2MB (HUGETLB) memory need allocated huge pages in the kernel's huge page pool.

       <b>HUGETLB</b> <b>(huge</b> <b>pages)</b>
              Current number of "persistent"  huge  pages  can  be  read  from  <u><a href="file:/proc/sys/vm/nr_hugepages">/proc/sys/vm/nr_hugepages</a></u>  file.
              Proposed  way  of  setting  hugepages is: <b>sudo</b> <b>sysctl</b> <b>vm.nr_hugepages=&lt;number_of_hugepages&gt;</b>.  More
              information can be found here: https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt

</pre><h4><b>KNOWN</b> <b>ISSUES</b></h4><pre>
       <b>HUGETLB</b> <b>(huge</b> <b>pages)</b>
              There might be some overhead in huge  pages  consumption  caused  by  heap  management.   If  your
              allocation fails because of OOM, please try to allocate extra huge pages (e.g. 8 huge pages).

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2014 - 2020 Intel Corporation. All rights reserved.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/malloc.3.html">malloc</a></b>(3), <b><a href="../man3/numa.3.html">numa</a></b>(3), <b><a href="../man8/numactl.8.html">numactl</a></b>(8), <b><a href="../man2/mbind.2.html">mbind</a></b>(2), <b><a href="../man2/mmap.2.html">mmap</a></b>(2), <b><a href="../man2/move_pages.2.html">move_pages</a></b>(2), <b><a href="../man3/jemalloc.3.html">jemalloc</a></b>(3), <b><a href="../man3/memkind.3.html">memkind</a></b>(3)

Intel Corporation                                  2015-03-31                                       <u><a href="../man3/HBWMALLOC.3.html">HBWMALLOC</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>