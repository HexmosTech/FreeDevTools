<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mem_open,  mem_check,  mem_alloc,  mem_realloc,  mem_free,  mem_close  -  memory  allocation routines for</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mem_open,  mem_check,  mem_alloc,  mem_realloc,  mem_free,  mem_close  -  memory  allocation routines for
       debugging

</pre><h4><b>LIBRARIES</b></h4><pre>
       Debug Library (-ldebug)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;debug/memory.h&gt;</b>

       <b>void</b> <b>mem_open(void</b> <b>(*</b><u>fail</u><b>)(const</b> <b>char</b> <b>*</b><u>fmt</u><b>,</b> <b>...));</b>
       <b>void</b> <b>mem_check(void);</b>
       <b>void</b> <b>*mem_alloc(size_t</b> <u>size</u><b>);</b>
       <b>void</b> <b>*mem_realloc(void</b> <b>*</b><u>ptr</u><b>,</b> <b>size_t</b> <u>size</u><b>);</b>
       <b>void</b> <b>mem_free(void</b> <b>*</b><u>ptr</u><b>);</b>
       <b>void</b> <b>mem_close(void);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>mem_open()</b> initializes the memory debugging system. It should be called before any of the other routines.
       You can specify a callback function which should be called whenever something bad  happens,  or  NULL  in
       which  case  the  default error handler will be used. The default error handler logs error messages using
       the debug logging routines and exit.

       <b>mem_check()</b> check all the allocated memory areas. This is called every time memory is allocated or freed.
       You can also call it anytime you think memory might be corrupted.

       <b>mem_alloc()</b> allocates <u>size</u> bytes and returns a pointer  to  the  allocated  memory.  The  memory  is  not
       cleared.

       <b>mem_realloc()</b>  changes the size of the memory block pointed to by <u>ptr</u> to <u>size</u> bytes. The contents will be
       unchanged to the minimum of the old and new sizes; newly allocated memory will be uninitialized.  If  <u>ptr</u>
       is  <b>NULL</b>,  the call is equivalent to <b>mem_alloc(size)</b>; if size is equal to zero, the call is equivalent to
       <b>mem_free(ptr)</b>. Unless <u>ptr</u> is <b>NULL</b>, it must have been returned  by  an  earlier  call  to  <b>mem_alloc()</b>  or
       <b>mem_realloc()</b>.

       <b>mem_free()</b>  frees the memory space pointed to by <u>ptr</u>, which must have been returned by a previous call to
       <b>mem_alloc()</b> or <b>mem_realloc()</b>. If <u>ptr</u> is <b>NULL</b>, no operation is performed.

       <b>mem_close()</b> checks for leaks and possible memory corruptions.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       For <b>mem_alloc()</b>, the value returned is a pointer to the allocated memory, which is suitably  aligned  for
       any kind of variable, or <b>NULL</b> if the request fails.

       <b>mem_realloc()</b>  returns a pointer to the newly allocated memory, which is suitably aligned for any kind of
       variable and may be different from <u>ptr</u>, or <b>NULL</b> if the request fails or  if  size  was  equal  to  0.  If
       <b>mem_realloc()</b> fails the original block is left untouched - it is not freed or moved.

       All other functions returns no value.

</pre><h4><b>NOTES</b></h4><pre>
       If  the default fail callback is used or if this routines are combined with the log routines, care should
       be taken to call open and close functions in the right order. The correct order is as follows:

              mem_open (NULL);
              log_open (NULL,LOG_NORMAL,LOG_HAVE_COLORS | LOG_PRINT_FUNCTION);
              atexit (mem_close);
              atexit (log_close);

       Of course, <b><a href="../man3/atexit.3.html">atexit</a></b>(3) should only be used if the program will not forked.

       None of the libdebug routines are  thread-safe.  I'm  not  planning  to  change  this  either!  For  more
       information, please see <a href="http://threading.2038bug.com/">http://threading.2038bug.com/</a>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/log_open.3.html">log_open</a>(3), <a href="../man3/atexit.3.html">atexit</a>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
       Written by Abraham vd Merwe &lt;<a href="mailto:abz@blio.com">abz@blio.com</a>&gt;

Unix                                               August 2004                                  <u><a href="../man3debug/MEM_OPEN.3debug.html">MEM_OPEN</a></u>(3debug)
</pre>
 </div>
</div></section>
</div>
</body>
</html>