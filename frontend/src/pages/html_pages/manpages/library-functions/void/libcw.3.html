<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libcw - general purpose Morse code functions library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcw-dev">libcw-dev_3.6.1-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libcw - general purpose Morse code functions library

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;libcw.h&gt;</b>

       <b>int</b> <b>cw_generator_new(int</b> <b>audio_system,</b> <b>const</b> <b>char</b> <b>*device)</b>
       <b>void</b> <b>cw_generator_delete(void)</b>
       <b>int</b> <b>cw_generator_start(void)</b>
       <b>void</b> <b>cw_generator_stop(void)</b>
       <b>int</b> <b>cw_set_send_speed(int</b> <b>new_value)</b>
       <b>int</b> <b>cw_set_frequency(int</b> <b>new_value)</b>
       <b>int</b> <b>cw_set_volume(int</b> <b>new_value)</b>
       <b>int</b> <b>cw_set_gap(int</b> <b>new_value)</b>
       <b>int</b> <b>cw_set_weighting(int</b> <b>new_value)</b>
       <b>int</b> <b>cw_get_send_speed(void)</b>
       <b>int</b> <b>cw_get_frequency(void)</b>
       <b>int</b> <b>cw_get_volume(void)</b>
       <b>int</b> <b>cw_get_gap(void)</b>
       <b>int</b> <b>cw_get_weighting(void)</b>
       <b>void</b> <b>cw_get_send_parameters(int</b> <b>*dot_usecs,</b> <b>int</b> <b>*dash_usecs,</b>
                                   <b>int</b> <b>*end_of_element_usecs,</b>
                                   <b>int</b> <b>*end_of_character_usecs,</b> <b>int</b> <b>*end_of_word_usecs,</b>
                                   <b>int</b> <b>*additional_usecs,</b> <b>int</b> <b>*adjustment_usecs)</b>
       <b>int</b> <b>cw_send_dot(void)</b>
       <b>int</b> <b>cw_send_dash(void)</b>
       <b>int</b> <b>cw_send_character_space(void)</b>
       <b>int</b> <b>cw_send_word_space(void)</b>
       <b>int</b> <b>cw_send_representation(const</b> <b>char</b> <b>*representation)</b>
       <b>int</b> <b>cw_send_representation_partial(const</b> <b>char</b> <b>*representation)</b>
       <b>int</b> <b>cw_send_character(char</b> <b>c)</b>
       <b>int</b> <b>cw_send_character_partial(char</b> <b>c)</b>
       <b>int</b> <b>cw_send_string(const</b> <b>char</b> <b>*string)</b>
       <b>void</b> <b>cw_reset_send_receive_parameters(void)</b>
       <b>const</b> <b>char</b> <b>*cw_get_console_device(void)</b>
       <b>const</b> <b>char</b> <b>*cw_get_soundcard_device(void)</b>
       <b>const</b> <b>char</b> <b>*cw_generator_get_audio_system_label(void)</b>
       <b>int</b> <b>cw_generator_remove_last_character(void)</b>
       <b>int</b> <b>cw_register_tone_queue_low_callback(void</b> <b>(*callback_func)(void*),</b> <b>void</b> <b>*callback_arg,</b> <b>int</b> <b>level)</b>
       <b>bool</b> <b>cw_is_tone_busy(void)</b>
       <b>int</b> <b>cw_wait_for_tone(void)</b>
       <b>int</b> <b>cw_wait_for_tone_queue(void)</b>
       <b>int</b> <b>cw_wait_for_tone_queue_critical(int</b> <b>level)</b>
       <b>bool</b> <b>cw_is_tone_queue_full(void)</b>
       <b>int</b> <b>cw_get_tone_queue_capacity(void)</b>
       <b>int</b> <b>cw_get_tone_queue_length(void)</b>
       <b>void</b> <b>cw_flush_tone_queue(void)</b>
       <b>void</b> <b>cw_reset_tone_queue(void)</b>
       <b>int</b> <b>cw_queue_tone(int</b> <b>usecs,</b> <b>int</b> <b>frequency)</b>
       <b>int</b> <b>cw_set_receive_speed(int</b> <b>new_value)</b>
       <b>int</b> <b>cw_get_receive_speed(void)</b>
       <b>int</b> <b>cw_set_tolerance(int</b> <b>new_value)</b>
       <b>int</b> <b>cw_get_tolerance(void)</b>
       <b>void</b> <b>cw_get_receive_parameters(int</b> <b>*dot_usecs,</b> <b>int</b> <b>*dash_usecs,</b>
                                      <b>int</b> <b>*dot_min_usecs,</b> <b>int</b> <b>*dot_max_usecs,</b>
                                      <b>int</b> <b>*dash_min_usecs,</b> <b>int</b> <b>*dash_max_usecs,</b>
                                      <b>int</b> <b>*end_of_element_min_usecs,</b>
                                      <b>int</b> <b>*end_of_element_max_usecs,</b>
                                      <b>int</b> <b>*end_of_element_ideal_usecs,</b>
                                      <b>int</b> <b>*end_of_character_min_usecs,</b>
                                      <b>int</b> <b>*end_of_character_max_usecs,</b>
                                      <b>int</b> <b>*end_of_character_ideal_usecs,</b>
                                      <b>int</b> <b>*adaptive_threshold)</b>
       <b>int</b> <b>cw_set_noise_spike_threshold(int</b> <b>new_value)</b>
       <b>int</b> <b>cw_get_noise_spike_threshold(void)</b>
       <b>void</b> <b>cw_get_receive_statistics(double</b> <b>*dot_sd,</b> <b>double</b> <b>*dash_sd,</b>
                                      <b>double</b> <b>*element_end_sd,</b> <b>double</b> <b>*character_end_sd)</b>
       <b>void</b> <b>cw_reset_receive_statistics(void)</b>
       <b>void</b> <b>cw_enable_adaptive_receive(void)</b>
       <b>void</b> <b>cw_disable_adaptive_receive(void)</b>
       <b>bool</b> <b>cw_get_adaptive_receive_state(void)</b>
       <b>int</b> <b>cw_start_receive_tone(const</b> <b>struct</b> <b>timeval</b> <b>*timestamp)</b>
       <b>int</b> <b>cw_end_receive_tone(const</b> <b>struct</b> <b>timeval</b> <b>*timestamp)</b>
       <b>int</b> <b>cw_receive_buffer_dot(const</b> <b>struct</b> <b>timeval</b> <b>*timestamp)</b>
       <b>int</b> <b>cw_receive_buffer_dash(const</b> <b>struct</b> <b>timeval</b> <b>*timestamp)</b>
       <b>int</b> <b>cw_receive_representation(const</b> <b>struct</b> <b>timeval</b> <b>*timestamp,</b>
                                     <b>/*</b> <b>out</b> <b>*/</b> <b>char</b> <b>*representation,</b>
                                     <b>/*</b> <b>out</b> <b>*/</b> <b>bool</b> <b>*is_end_of_word,</b>
                                     <b>/*</b> <b>out</b> <b>*/</b> <b>bool</b> <b>*is_error)</b>
       <b>int</b> <b>cw_receive_character(const</b> <b>struct</b> <b>timeval</b> <b>*timestamp,</b>
                                <b>/*</b> <b>out</b> <b>*/</b> <b>char</b> <b>*c,</b>
                                <b>/*</b> <b>out</b> <b>*/</b> <b>bool</b> <b>*is_end_of_word,</b>
                                <b>/*</b> <b>out</b> <b>*/</b> <b>bool</b> <b>*is_error)</b>
       <b>void</b> <b>cw_clear_receive_buffer(void)</b>
       <b>int</b> <b>cw_get_receive_buffer_capacity(void)</b>
       <b>int</b> <b>cw_get_receive_buffer_length(void)</b>
       <b>void</b> <b>cw_reset_receive(void)</b>
       <b>void</b> <b>cw_register_keying_callback(void</b> <b>(*callback_func)(void*,</b> <b>int),</b> <b>void</b> <b>*callback_arg)</b>
       <b>void</b> <b>cw_enable_iambic_curtis_mode_b(void)</b>
       <b>void</b> <b>cw_disable_iambic_curtis_mode_b(void)</b>
       <b>int</b> <b>cw_get_iambic_curtis_mode_b_state(void)</b>
       <b>int</b> <b>cw_notify_keyer_paddle_event(int</b> <b>dot_paddle_state,</b> <b>int</b> <b>dash_paddle_state)</b>
       <b>int</b> <b>cw_notify_keyer_dot_paddle_event(int</b> <b>dot_paddle_state)</b>
       <b>int</b> <b>cw_notify_keyer_dash_paddle_event(int</b> <b>dash_paddle_state)</b>
       <b>void</b> <b>cw_get_keyer_paddles(int</b> <b>*dot_paddle_state,</b> <b>int</b> <b>*dash_paddle_state)</b>
       <b>void</b> <b>cw_get_keyer_paddle_latches(int</b> <b>*dot_paddle_latch_state,</b> <b>int</b> <b>*dash_paddle_latch_state)</b>
       <b>bool</b> <b>cw_is_keyer_busy(void)</b>
       <b>int</b> <b>cw_wait_for_keyer_element(void)</b>
       <b>int</b> <b>cw_wait_for_keyer(void)</b>
       <b>void</b> <b>cw_reset_keyer(void)</b>
       <b>int</b> <b>cw_notify_straight_key_event(int</b> <b>key_state)</b>
       <b>int</b> <b>cw_get_straight_key_state(void)</b>
       <b>bool</b> <b>cw_is_straight_key_busy(void)</b>
       <b>void</b> <b>cw_reset_straight_key(void)</b>
       <b>bool</b> <b>cw_is_alsa_possible(const</b> <b>char</b> <b>*</b> <b>device_name)</b>
       <b>bool</b> <b>cw_is_console_possible(const</b> <b>char</b> <b>*</b> <b>device_name)</b>
       <b>int</b> <b>cw_get_character_count(void)</b>
       <b>void</b> <b>cw_list_characters(char</b> <b>*</b> <b>list)</b>
       <b>int</b> <b>cw_get_maximum_representation_length(void)</b>
       <b>int</b> <b>cw_lookup_character(char</b> <b>character,</b> <b>char</b> <b>*</b> <b>representation)</b>
       <b>char</b> <b>*</b> <b>cw_character_to_representation(int</b> <b>character)</b>
       <b>int</b> <b>cw_check_representation(const</b> <b>char</b> <b>*</b> <b>representation)</b>
       <b>bool</b> <b>cw_representation_is_valid(const</b> <b>char</b> <b>*</b> <b>representation)</b>
       <b>int</b> <b>cw_lookup_representation(const</b> <b>char</b> <b>*</b> <b>representation,</b> <b>char</b> <b>*</b> <b>character)</b>
       <b>int</b> <b>cw_representation_to_character(const</b> <b>char</b> <b>*</b> <b>representation)</b>
       <b>int</b> <b>cw_get_procedural_character_count(void)</b>
       <b>void</b> <b>cw_list_procedural_characters(char</b> <b>*</b> <b>list)</b>
       <b>int</b> <b>cw_get_maximum_procedural_expansion_length(void)</b>
       <b>int</b> <b>cw_lookup_procedural_character(char</b> <b>character,</b> <b>char</b> <b>*expansion,</b> <b>int</b> <b>*</b> <b>is_usually_expanded)</b>
       <b>int</b> <b>cw_get_maximum_phonetic_length(void)</b>
       <b>int</b> <b>cw_lookup_phonetic(char</b> <b>character,</b> <b>char</b> <b>*</b> <b>phonetic)</b>
       <b>bool</b> <b>cw_character_is_valid(char</b> <b>character)</b>
       <b>int</b> <b>cw_check_character(char</b> <b>character)</b>
       <b>bool</b> <b>cw_string_is_valid(const</b> <b>char</b> <b>*</b> <b>string)</b>
       <b>int</b> <b>cw_check_string(const</b> <b>char</b> <b>*</b> <b>string)</b>
       <b>void</b> <b>cw_set_debug_flags(uint32_t</b> <b>flags)</b>
       <b>void</b> <b>cw_debug_set_flags(cw_debug_t</b> <b>*</b> <b>debug_object,</b> <b>uint32_t</b> <b>flags)</b>
       <b>uint32_t</b> <b>cw_get_debug_flags(void)</b>
       <b>uint32_t</b> <b>cw_debug_get_flags(const</b> <b>cw_debug_t</b> <b>*</b> <b>debug_object)</b>
       <b>bool</b> <b>cw_debug_has_flag(const</b> <b>cw_debug_t</b> <b>*</b> <b>debug_object,</b> <b>uint32_t</b> <b>flag)</b>
       <b>int</b> <b>cw_generator_set_tone_slope(cw_gen_t</b> <b>*</b> <b>gen,</b> <b>int</b> <b>slope_shape,</b> <b>int</b> <b>slope_duration)</b>
       <b>bool</b> <b>cw_is_null_possible(__attribute__((unused))</b> <b>const</b> <b>char</b> <b>*</b> <b>device_name)</b>
       <b>bool</b> <b>cw_is_oss_possible(const</b> <b>char</b> <b>*</b> <b>device_name)</b>
       <b>bool</b> <b>cw_is_pa_possible(const</b> <b>char</b> <b>*</b> <b>device_name)</b>
       <b>void</b> <b>cw_block_callback(int</b> <b>block)</b>
       <b>int</b> <b>cw_register_signal_handler(int</b> <b>signal_number,</b> <b>void</b> <b>(*callback_func)(int))</b>
       <b>int</b> <b>cw_unregister_signal_handler(int</b> <b>signal_number)</b>
       <b>int</b> <b>cw_version(void)</b>
       <b>void</b> <b>cw_license(void)</b>
       <b>const</b> <b>char</b> <b>*</b> <b>cw_get_audio_system_label(int</b> <b>sound_system)</b>
       <b>void</b> <b>cw_get_speed_limits(int</b> <b>*</b> <b>min_speed,</b> <b>int</b> <b>*</b> <b>max_speed)</b>
       <b>void</b> <b>cw_get_frequency_limits(int</b> <b>*</b> <b>min_frequency,</b> <b>int</b> <b>*</b> <b>max_frequency)</b>
       <b>void</b> <b>cw_get_volume_limits(int</b> <b>*</b> <b>min_volume,</b> <b>int</b> <b>*</b> <b>max_volume)</b>
       <b>void</b> <b>cw_get_gap_limits(int</b> <b>*</b> <b>min_gap,</b> <b>int</b> <b>*</b> <b>max_gap)</b>
       <b>void</b> <b>cw_get_tolerance_limits(int</b> <b>*</b> <b>min_tolerance,</b> <b>int</b> <b>*</b> <b>max_tolerance)</b>
       <b>void</b> <b>cw_get_weighting_limits(int</b> <b>*</b> <b>min_weighting,</b> <b>int</b> <b>*</b> <b>max_weighting)</b>
       <b>void</b> <b>cw_complete_reset(void)</b>

   <b>DESCRIPTION</b>
       <b>libcw</b>  is  a  general  purpose  CW  (Morse  code) functions library.  It contains routines for converting
       characters into Morse code representations and back again, for sending Morse  code  characters,  and  for
       receiving characters.  It also contains routines to emulate an Iambic Morse keyer, and a straight key.

       The library can be included in any program that wishes to make use of these features.  It forms the heart
       of three Morse code tutor applications that accompany the package in which it is distributed.

       See  the  <b><a href="../man7/cw.7.html">cw</a></b>(7)  man page for information on Morse code timings, and the dot and dash representations for
       the various Morse characters.

   <b>TONE</b> <b>QUEUE</b>
       <b>libcw</b> contains an inbuilt tone queue.  The queue is emptied by background processing, using SIGALRM calls
       and itimers, so a caller program can continue with other tasks while the library sends tones and keys any
       external device.

       As well as being used by the library functions that sound Morse  code  characters  and  provide  a  keyer
       sidetone, the primitive tone queue functions are publicly available to caller programs.

   <b>CONTROLLING</b> <b>AN</b> <b>EXTERNAL</b> <b>DEVICE</b>
       <b>libcw</b>  may  be  passed  the address of a function that controls external keying.  This function is called
       each time the library changes the keying state, either as a  result  of  sending  a  Morse  character  or
       representation, or as a result of an iambic keyer or straight key state change.  The argument passed is a
       single integer, TRUE for key-down, and FALSE for key-up.

       <b>libcw</b>  calls the external keying function only when the keying state changes.  A call is likely each time
       a tone is taken off the tone queue.

   <b>SENDING</b> <b>CW</b> <b>CHARACTERS</b> <b>AND</b> <b>STRINGS</b>
       <b>libcw</b> offers several functions that send individual characters and character strings as Morse  code.   It
       also  offers  functions  that  allow  specialized 'representations' to be sent.  A 'representation' is an
       ASCII string that consists of only the characters '.' and '-'.

       Characters and strings are converted into representations, and then the correct tones for  the  dots  and
       dashes in these representations are queued on the tone queue, for action by the background queue emptying
       process.

   <b>RECEIVING</b> <b>CW</b> <b>CHARACTERS</b> <b>AND</b> <b>REPRESENTATIONS</b>
       <b>libcw</b>  contains functions to allow it to receive Morse code.  To receive, the library must be told when a
       tone start is detected, and when a tone end is detected.  It then determines whether the tone was  a  dot
       or a dash depending on the timing difference between the two.  After the required silence gap has passed,
       the library may be queried to see what the received representation or character was.

       Errors in receiving may be detected by means of the flags passed back on receive character functions.

   <b>IAMBIC</b> <b>KEYER</b>
       <b>libcw</b>  offers  functions to simulate an Iambic Morse keyer.  The caller program needs to tell the library
       of paddle state changes.  Iambic keyer functions are mutually exclusive with character send and  straight
       key functions.

   <b>STRAIGHT</b> <b>KEY</b>
       <b>libcw</b>  offers  simple  functions to allow effective pass-through of straight key information.  The caller
       program needs to tell the library of key state changes.  Straight key functions  are  mutually  exclusive
       with character send and iambic keyer functions.

   <b>RETURN</b> <b>CODES</b>
       Some  of  the  library's  function  return a return code of type int.  The return code has two values, as
       defined in libcw.h: <b>CW_SUCCESS</b> or <b>CW_FAILURE</b>. The two symbolic constants are guaranteed to  be  identical
       to boolean <b>true</b> and <b>false</b>.

   <b>FUNCTIONS</b>
       The following list describes the functions available to a <b>libcw</b> caller:

       <b>int</b> <b>cw_generator_new(int</b> <b>audio_system,</b> <b>const</b> <b>char</b> <b>*device)</b>
       Brief: Create new generator

       Allocate  memory  for  new  generator  data  structure,  set up default values of some of the generator's
       properties.  The function does not start the generator (generator does not produce a sound), you have  to
       use cw_generator_start() for this.

       Notice  that the function doesn't return a generator variable. There is at most one generator variable at
       any given time. You can't have two generators. In some future version of the library  the  function  will
       return pointer to newly allocated generator, and then you could have as many of them as you want, but not
       yet.

       <b>audio_system</b>  can  be  one  of  following:  NULL,  console,  OSS,  ALSA, PulseAudio, soundcard. See "enum
       cw_audio_systems" in libcw.h for exact names of symbolic constants.

       Parameter: audio_system - audio system to be used by the generator
       Parameter: device - name of audio device to be used; if NULL then library will use default device.

       <b>void</b> <b>cw_generator_delete(void)</b>
       Brief: Deallocate generator

       Deallocate/destroy generator data structure created with call to cw_generator_new(). You can't start  nor
       use the generator after the call to this function.

       <b>int</b> <b>cw_generator_start(void)</b>
       Brief: Start a generator

       Start  producing  tones  using  generator  created with cw_generator_new(). The source of tones is a tone
       queue associated with the generator. If the tone queue is empty, the generator will wait for new tones to
       be queued.

       Returns: CW_FAILURE on errors
       Returns: CW_SUCCESS on success

       <b>void</b> <b>cw_generator_stop(void)</b>
       Brief: Shut down a generator

       Silence tone generated by generator (level of generated sine wave is set to zero,  with  falling  slope),
       and shut the generator down.

       The shutdown does not erase generator's configuration.

       If you want to have this generator running again, you have to call cw_generator_start().

       <b>int</b> <b>cw_set_send_speed(int</b> <b>new_value)</b>
       Brief: Set sending speed of generator

       See libcw.h/CW_SPEED_{INITIAL|MIN|MAX} for initial/minimal/maximal value of send speed.

       errno is set to EINVAL if <b>new_value</b> is out of range.

       Parameter: new_value - new value of send speed to be assigned to generator

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_set_frequency(int</b> <b>new_value)</b>
       Brief: Set frequency of generator

       Set  frequency  of  sound  wave  generated  by  generator.  The frequency must be within limits marked by
       CW_FREQUENCY_MIN and CW_FREQUENCY_MAX.

       See libcw.h/CW_FREQUENCY_{INITIAL|MIN|MAX} for initial/minimal/maximal value of frequency.

       errno is set to EINVAL if <b>new_value</b> is out of range.

       Parameter: new_value - new value of frequency to be assigned to generator

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_set_volume(int</b> <b>new_value)</b>
       Brief: Set volume of generator

       Set volume of  sound  wave  generated  by  generator.   The  volume  must  be  within  limits  marked  by
       CW_VOLUME_MIN and CW_VOLUME_MAX.

       Note  that volume settings are not fully possible for the console speaker.  In this case, volume settings
       greater than zero indicate console speaker sound is on, and setting volume to zero will turn off  console
       speaker sound.

       See  libcw.h/CW_VOLUME_{INITIAL|MIN|MAX}  for  initial/minimal/maximal  value of volume.  errno is set to
       EINVAL if <b>new_value</b> is out of range.

       Parameter: new_value - new value of volume to be assigned to generator

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_set_gap(int</b> <b>new_value)</b>
       Brief: Set sending gap of generator

       See libcw.h/CW_GAP_{INITIAL|MIN|MAX} for initial/minimal/maximal value of gap.  errno is set to EINVAL if
       <b>new_value</b> is out of range.

       Notice that this function also sets the same gap value for library's receiver.

       Parameter: new_value - new value of gap to be assigned to generator

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_set_weighting(int</b> <b>new_value)</b>
       Brief: Set sending weighting for generator

       See libcw.h/CW_WEIGHTING_{INITIAL|MIN|MAX} for initial/minimal/maximal value of weighting.  errno is  set
       to EINVAL if <b>new_value</b> is out of range.

       Parameter: new_value - new value of weighting to be assigned for generator

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_get_send_speed(void)</b>
       Brief: Get sending speed from generator

       Returns: current value of the generator's send speed

       <b>int</b> <b>cw_get_frequency(void)</b>
       Brief: Get frequency from generator

       Function  returns  "frequency"  parameter  of  generator,  even if the generator is stopped, or volume of
       generated sound is zero.

       Returns: current value of generator's frequency

       <b>int</b> <b>cw_get_volume(void)</b>
       Brief: Get sound volume from generator

       Function returns "volume" parameter of generator, even if the generator is stopped.

       Returns: current value of generator's sound volume

       <b>int</b> <b>cw_get_gap(void)</b>
       Brief: Get sending gap from generator

       Returns: current value of generator's sending gap

       <b>int</b> <b>cw_get_weighting(void)</b>
       Brief: Get sending weighting from generator

       Returns: current value of generator's sending weighting

       <b>void</b> <b>cw_get_send_parameters(int</b> <b>*dot_usecs,</b> <b>int</b> <b>*dash_usecs,</b>
                                <b>int</b> <b>*end_of_element_usecs,</b>
                                <b>int</b> <b>*end_of_character_usecs,</b> <b>int</b> <b>*end_of_word_usecs,</b>
                                <b>int</b> <b>*additional_usecs,</b> <b>int</b> <b>*adjustment_usecs)</b>
       Brief: Get timing parameters for sending

       Return the low-level timing parameters calculated from the speed,  gap,  tolerance,  and  weighting  set.
       Parameter values are returned in microseconds.

       Use NULL for the pointer argument to any parameter value not required.

       Parameter: dot_usecs
       Parameter: dash_usecs
       Parameter: end_of_element_usecs
       Parameter: end_of_character_usecs
       Parameter: end_of_word_usecs
       Parameter: additional_usecs
       Parameter: adjustment_usecs

       <b>int</b> <b>cw_send_dot(void)</b>
       Brief: Low-level primitive for sending a Dot Mark

       Low-level  primitive  function  able to play/send single Dot Mark. The function appends to a tone queue a
       normal inter-mark-space after the Dot Mark.

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_send_dash(void)</b>
       Brief: Low-level primitive for sending a Dash Mark

       Low-level primitive function able to play/send single Dash Mark.  The function appends to a tone queue  a
       normal inter-mark-space after the Dash Mark.

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_send_character_space(void)</b>
       The  function enqueues space of specific length: together with previously implicitly enqueued inter-mark-
       space of size 1 Unit, enqueueing this space will form a full inter-character-space of size 3 Units.

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_send_word_space(void)</b>
       The function enqueues space of specific length: together with previously implicitly enqueued  inter-mark-
       space  of  size 1 Unit and implicitly or explicitly enqueued inter-character-space, enqueueing this space
       will form a full inter-word-space of size 7 Units.

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_send_representation(const</b> <b>char</b> <b>*representation)</b>
       Brief: Check, then send the given string as dots and dashes.

       The representation passed in is assumed to be a complete Morse character;  that  is,  all  post-character
       delays will be added when the character is sent.

       On  success, the routine returns CW_SUCCESS.  On failure, it returns CW_FAILURE, with errno set to EINVAL
       if any character of the representation is invalid, EBUSY if the sound card, console  speaker,  or  keying
       system is busy, or EAGAIN if the tone queue is full, or if there is insufficient space to queue the tones
       or the representation.

       Parameter: representation - representation to send

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_send_representation_partial(const</b> <b>char</b> <b>*representation)</b>
       Brief: Check, then send the given string as dots and dashes

       The  <b>representation</b>  passed  in  is assumed to be only part of a larger Morse representation; that is, no
       post-character delays will be added when the character is sent.

       On success, the routine returns CW_SUCCESS.  On failure, it returns CW_FAILURE, with errno set to  EINVAL
       if  any  character  of the representation is invalid, EBUSY if the sound card, console speaker, or keying
       system is busy, or EAGAIN if the tone queue is full, or if there is insufficient space to queue the tones
       for the representation.

       <b>int</b> <b>cw_send_character(char</b> <b>c)</b>
       Brief: Look up and send a given ASCII character as Morse

       The end of character delay is appended to the Morse sent.

       On success the routine returns CW_SUCCESS.  On failure the function returns CW_FAILURE and sets errno.

       errno is set to ENOENT if the given character <b>c</b> is not a valid Morse character.  errno is set to EBUSY if
       current audio sink or keying system is busy.  errno is set to EAGAIN if the  generator's  tone  queue  is
       full, or if there is insufficient space to queue the tones for the character.

       This  routine  returns as soon as the character has been successfully queued for sending; that is, almost
       immediately.   The  actual  sending  happens  in  background  processing.   See  cw_wait_for_tone()   and
       cw_wait_for_tone_queue() for ways to check the progress of sending.

       Parameter: c - character to send

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_send_character_partial(char</b> <b>c)</b>
       Brief: Look up and send a given ASCII character as Morse code

       "partial" means that the inter-character-space is not appended to the Morse code sent by the function, to
       support the formation of combination characters.

       On success the function returns CW_SUCCESS.  On failure the function returns CW_FAILURE and sets errno.

       errno is set to ENOENT if the given character <b>c</b> is not a valid Morse character.  errno is set to EBUSY if
       the  audio  sink or keying system is busy.  errno is set to EAGAIN if the tone queue is full, or if there
       is insufficient space to queue the tones for the character.

       This  routine  queues  its   arguments   for   background   processing.    See   cw_wait_for_tone()   and
       cw_wait_for_tone_queue() for ways to check the progress of sending.

       Parameter: c - character to send

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_send_string(const</b> <b>char</b> <b>*string)</b>
       Brief: Send a given ASCII string in Morse code

       errno is set to ENOENT if any character in the string is not a valid Morse character.

       errno is set to EBUSY if audio sink or keying system is busy.

       errno  is set to EAGAIN if the tone queue is full or if the tone queue runs out of space part way through
       queueing the string.  However, an indeterminate number of  the  characters  from  the  string  will  have
       already been queued.

       For   safety,   clients   can  ensure  the  tone  queue  is  empty  before  queueing  a  string,  or  use
       cw_send_character() if they need finer control.

       This routine queues its arguments for background processing, the actual  sending  happens  in  background
       processing.  See  cw_wait_for_tone()  and  cw_wait_for_tone_queue()  for  ways  to  check the progress of
       sending.

       Parameter: string - string to send

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>void</b> <b>cw_reset_send_receive_parameters(void)</b>
       Brief: Reset send/receive parameters

       Reset the library speed, frequency, volume, gap, tolerance, weighting, adaptive receive, and noise  spike
       threshold  to their initial default values: send/receive speed 12 WPM, volume 70 %, frequency 800 Hz, gap
       0 dots, tolerance 50 %, and weighting 50 %.

       <b>const</b> <b>char</b> <b>*cw_get_console_device(void)</b>
       Brief: Return char string with console device path

       Returned pointer is owned by library.

       Returns: char string with current console device path

       <b>const</b> <b>char</b> <b>*cw_get_soundcard_device(void)</b>
       Brief: Return char string with soundcard device name/path

       Returned pointer is owned by library.

       Returns: char string with current soundcard device name or device path

       <b>const</b> <b>char</b> <b>*cw_generator_get_audio_system_label(void)</b>
       Brief: Get a readable label of current audio system

       The function returns one of following strings: None, Null, Console, OSS, ALSA, PulseAudio, Soundcard

       Returns: audio system's label

       <b>int</b> <b>cw_generator_remove_last_character(void)</b>
       Brief: Remove last character from queue of already enqueued characters

       If the character is not actually played by sound sink yet, library may be able to remove  the  character.
       The character's Dots and Dashes won't be played.

       This function may be useful if user presses backspace in UI to remove/undo a character.

       If  your  application  doesn't  enqueue  whole characters or strings of characters but is using low-level
       cw_send_dot()/cw_send_dash() functions to  enqueue  individual  Marks,  don't  use  this  function.  This
       function won't be able to recognize whole characters and is likely to remove more tones than expected.

       Returns: CW_SUCCESS if function managed to remove a last character before it has been played
       Returns: CW_FAILURE otherwise

       <b>int</b> <b>cw_register_tone_queue_low_callback(void</b> <b>(*callback_func)(void*),</b> <b>void</b> <b>*callback_arg,</b> <b>int</b> <b>level)</b>
       Brief: Register callback for low queue state

       Register a function to be called automatically by the dequeue routine whenever the count of tones in tone
       queue  falls to a given <b>level</b>. To be more precise: the callback is called by queue's dequeue function if,
       after dequeueing a tone, the function notices that tone queue length has become equal or less than <b>level</b>.

       <b>level</b> can't be negative.

       <b>level</b> can't be equal to or larger than tone queue capacity.

       If <b>level</b> is zero, the behaviour of the mechanism is not guaranteed to work correctly.

       If <b>callback_func</b> is NULL then the mechanism becomes disabled.

       <b>callback_arg</b> will be passed to <b>callback_arg</b>.

       errno is set to EINVAL when <b>level</b> is invalid.

       Parameter: callback_func - callback function to be registered
       Parameter: callback_arg - argument for callback_func to pass return value
       Parameter: level - low level of queue triggering callback call

       Returns: CW_SUCCESS on successful registration
       Returns: CW_FAILURE on failure

       <b>bool</b> <b>cw_is_tone_busy(void)</b>
       Brief: Check if tone sender is busy

       Indicate if the tone sender is busy.

       Returns: true if there are still entries in the tone queue
       Returns: false if the queue is empty

       <b>int</b> <b>cw_wait_for_tone(void)</b>
       Brief: Wait for the current tone to complete

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_wait_for_tone_queue(void)</b>
       Brief: Wait for the tone queue to drain

       Notice that generator must be running (started with cw_generator_start()) when this function  is  called,
       otherwise it will be waiting forever for a change of tone queue's level that will never happen.

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_wait_for_tone_queue_critical(int</b> <b>level)</b>
       Brief: Wait for the tone queue to drain until only as many tones as given in level remain queued

       This  routine  is  for use by programs that want to optimize themselves to avoid the cleanup that happens
       when the tone queue drains completely; such programs have a short time in which to add more tones to  the
       queue.

       Notice  that  generator must be running (started with cw_generator_start()) when this function is called,
       otherwise it will be waiting forever for a change of tone queue's level that will never happen.

       If <b>level</b> is negative, function sets errno to EINVAL and returns CW_FAILURE.

       Parameter: level - low level in queue, at which to return

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>bool</b> <b>cw_is_tone_queue_full(void)</b>
       Brief: Indicate if the tone queue is full

       Returns: true if tone queue is full
       Returns: false if tone queue is not full

       <b>int</b> <b>cw_get_tone_queue_capacity(void)</b>
       Brief: Return the number of entries the tone queue can accommodate

       <b>int</b> <b>cw_get_tone_queue_length(void)</b>
       Brief: Return the number of entries currently pending in the tone queue

       <b>void</b> <b>cw_flush_tone_queue(void)</b>
       Brief: Cancel all pending queued tones, and return to silence.

       If there is a tone in progress, the function will wait until this last one has  completed,  then  silence
       the tones.

       <b>void</b> <b>cw_reset_tone_queue(void)</b>
       Cancel  all  pending  queued tones, reset any queue low callback registered, and return to silence.  This
       function is suitable for calling from an application exit handler.

       <b>int</b> <b>cw_queue_tone(int</b> <b>usecs,</b> <b>int</b> <b>frequency)</b>
       Brief: Primitive access to simple tone generation

       This routine queues a tone of given duration and frequency.  The routine returns CW_SUCCESS  on  success.
       If  usec  or  frequency  are invalid, it returns CW_FAILURE with errno set to EINVAL.  If the sound card,
       console speaker, or keying function are busy, it returns CW_FAILURE  with errno set  to  EBUSY.   If  the
       tone queue is full, it returns false with errno set to EAGAIN.

       Parameter: usecs - duration of queued tone, in microseconds
       Parameter: frequency - frequency of queued tone

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_set_receive_speed(int</b> <b>new_value)</b>
       Brief: Set receiving speed of receiver

       See documentation of cw_set_send_speed() for more information.

       See  libcw.h/CW_SPEED_{INITIAL|MIN|MAX} for initial/minimal/maximal value of receive speed.  errno is set
       to EINVAL if <b>new_value</b> is out of range.  errno is set to EPERM if  adaptive  receive  speed  tracking  is
       enabled.

       Parameter: new_value - new value of receive speed to be assigned to receiver

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_get_receive_speed(void)</b>
       Brief: Get receiving speed from receiver

       Returns: current value of the receiver's receive speed

       <b>int</b> <b>cw_set_tolerance(int</b> <b>new_value)</b>
       Brief: Set tolerance for receiver

       See  libcw.h/CW_TOLERANCE_{INITIAL|MIN|MAX} for initial/minimal/maximal value of tolerance.  errno is set
       to EINVAL if <b>new_value</b> is out of range.

       Parameter: new_value - new value of tolerance to be assigned to receiver

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_get_tolerance(void)</b>
       Brief: Get tolerance from receiver

       Returns: current value of receiver's tolerance

       <b>void</b> <b>cw_get_receive_parameters(int</b> <b>*dot_usecs,</b> <b>int</b> <b>*dash_usecs,</b>
                                   <b>int</b> <b>*dot_min_usecs,</b> <b>int</b> <b>*dot_max_usecs,</b>
                                   <b>int</b> <b>*dash_min_usecs,</b> <b>int</b> <b>*dash_max_usecs,</b>
                                   <b>int</b> <b>*end_of_element_min_usecs,</b>
                                   <b>int</b> <b>*end_of_element_max_usecs,</b>
                                   <b>int</b> <b>*end_of_element_ideal_usecs,</b>
                                   <b>int</b> <b>*end_of_character_min_usecs,</b>
                                   <b>int</b> <b>*end_of_character_max_usecs,</b>
                                   <b>int</b> <b>*end_of_character_ideal_usecs,</b>
                                   <b>int</b> <b>*adaptive_threshold)</b>
       Brief: Get timing parameters for receiving, and adaptive threshold

       Return the low-level timing parameters calculated from the speed,  gap,  tolerance,  and  weighting  set.
       Parameter values are returned in microseconds.

       Use NULL for the pointer argument to any parameter value not required.

       Parameter: dot_usecs
       Parameter: dash_usecs
       Parameter: dot_min_usecs
       Parameter: dot_max_usecs
       Parameter: dash_min_usecs
       Parameter: dash_max_usecs
       Parameter: end_of_element_min_usecs
       Parameter: end_of_element_max_usecs
       Parameter: end_of_element_ideal_usecs
       Parameter: end_of_character_min_usecs
       Parameter: end_of_character_max_usecs
       Parameter: end_of_character_ideal_usecs
       Parameter: adaptive_threshold

       <b>int</b> <b>cw_set_noise_spike_threshold(int</b> <b>new_value)</b>
       Brief: Set noise spike threshold for receiver

       Set  the  period  shorter  than  which, on receive, received marks are ignored.  This allows the "receive
       mark" functions to apply noise canceling for very short apparent marks.  For  useful  results  the  value
       should  never  exceed  the  dot  length  of a dot at maximum speed: 20000 microseconds (the dot length at
       60WPM).  Setting a noise threshold of zero turns off receive mark noise canceling.

       The default noise spike threshold is 10000 microseconds.

       errno is set to EINVAL if <b>new_value</b> is out of range.

       Parameter: new_value - new value of noise spike threshold to be assigned to receiver

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_get_noise_spike_threshold(void)</b>
       Brief: Get noise spike threshold from receiver

       See documentation of cw_set_noise_spike_threshold() for more information

       Returns: current value of receiver's threshold

       <b>void</b> <b>cw_get_receive_statistics(double</b> <b>*dot_sd,</b> <b>double</b> <b>*dash_sd,</b>
                                   <b>double</b> <b>*element_end_sd,</b> <b>double</b> <b>*character_end_sd)</b>
       Brief: Calculate and return receiver's timing statistics

       These statistics may be used to obtain a measure of the accuracy of received CW.  The values  <b>dot_sd</b>  and
       <b>dot_sd</b>  contain  the standard deviation of dot and dash lengths from the ideal values, and <b>element_end_sd</b>
       and <b>element_end_sd</b> the deviations for inter element and inter character spacing.  Statistics are held for
       all timings in a 256 element circular buffer.  If any statistic cannot be calculated, because no  records
       for  it  exist,  the  returned  value  is  0.0.   Use  NULL for the pointer argument to any statistic not
       required.

       Parameter: dot_sd
       Parameter: dash_sd
       Parameter: element_end_sd
       Parameter: character_end_sd

       <b>void</b> <b>cw_reset_receive_statistics(void)</b>
       Brief: Clear the receive statistics buffer

       Clear the receive statistics buffer by removing all records from it  and  returning  it  to  its  initial
       default state.

       <b>void</b> <b>cw_enable_adaptive_receive(void)</b>
       Brief: Enable adaptive receive speed tracking

       If  adaptive  speed  tracking  is enabled, the receive functions will attempt to automatically adjust the
       receive speed setting to match the speed of the incoming Morse code.  If  it  is  disabled,  the  receive
       functions will use fixed speed settings, and reject incoming Morse which is not at the expected speed.

       Adaptive  speed  tracking  uses  a moving average length of the past N marks as its baseline for tracking
       speeds.  The default state is adaptive speed tracking disabled.

       <b>void</b> <b>cw_disable_adaptive_receive(void)</b>
       Brief: Disable adaptive receive speed tracking

       See documentation of cw_enable_adaptive_receive() for more information

       <b>bool</b> <b>cw_get_adaptive_receive_state(void)</b>
       Brief: Get adaptive receive speed tracking flag

       The  function   returns   state   of   "adaptive   receive   enabled"   flag.    See   documentation   of
       cw_enable_adaptive_receive() for more information

       Returns: true if adaptive speed tracking is enabled
       Returns: false otherwise

       <b>int</b> <b>cw_start_receive_tone(const</b> <b>struct</b> <b>timeval</b> <b>*timestamp)</b>
       Brief: Signal beginning of receive mark

       Called  on  the  start  of  a  receive  mark.  If the <b>timestamp</b> is NULL, the current timestamp is used as
       beginning of mark.

       The function should be called by client application when pressing a key down (closing a circuit) has been
       detected by client application.

       On error the function returns CW_FAILURE, with errno set to ERANGE if the call is directly after  another
       cw_start_receive_tone()  call  or if an existing received character has not been cleared from the buffer,
       or EINVAL if the timestamp passed in is invalid.

       Parameter: timestamp - time stamp of "key down" event

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE otherwise (with errno set)

       <b>int</b> <b>cw_end_receive_tone(const</b> <b>struct</b> <b>timeval</b> <b>*timestamp)</b>
       Brief: Signal end of mark

       The function should be called by client application when releasing a key (opening  a  circuit)  has  been
       detected by client application.

       If the <b>timestamp</b> is NULL, the current time is used as timestamp of end of mark.

       On  success,  the  routine  adds  a  dot  or  dash  to  the receiver's representation buffer, and returns
       CW_SUCCESS.

       On failure, it returns CW_FAIURE, with  errno  set  to:  ERANGE  if  the  call  was  not  preceded  by  a
       cw_start_receive_tone()  call,  EINVAL  if the timestamp passed in is not valid, ENOENT if function can't
       tell from duration of the Mark if it's Dot or Dash, ENOMEM if the  receiver's  representation  buffer  is
       full, EAGAIN if the mark was shorter than the threshold for noise and was therefore ignored.

       Parameter: timestamp - time stamp of "key up" event

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_receive_buffer_dot(const</b> <b>struct</b> <b>timeval</b> <b>*timestamp)</b>
       Brief: Add a dot to the receiver's representation buffer

       Documentation for both cw_receive_buffer_dot() and cw_receive_buffer_dash():

       Since  we  can't  add  a  mark  to  the buffer without any accompanying timing information, the functions
       accepts <b>timestamp</b> of the "end of mark" event.  If the <b>timestamp</b> is NULL, the current timestamp is used.

       These routines are for client code that has already determined whether a dot or dash was  received  by  a
       method other than calling the routines cw_start_receive_tone() and cw_end_receive_tone().

       On success, the relevant mark is added to the receiver's representation buffer.

       On failure, the routines return CW_FAILURE and set errno: ERANGE if preceded by a cw_start_receive_tone()
       call  with  no  matching  cw_end_receive_tone()  or  if  an  error  condition currently exists within the
       receiver's  buffer,  EINVAL  if  the  timestamp  passed  in  is  not  valid,  ENOMEM  if  the  receiver's
       representation buffer is full.

       Parameter: timestamp - timestamp of "end of dot" event

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_receive_buffer_dash(const</b> <b>struct</b> <b>timeval</b> <b>*timestamp)</b>
       Brief: Add a dash to the receiver's representation buffer

       See documentation of cw_receive_buffer_dot() for more information.

       Parameter: timestamp - timestamp of "end of dash" event

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_receive_representation(const</b> <b>struct</b> <b>timeval</b> <b>*timestamp,</b>
                                  <b>/*</b> <b>out</b> <b>*/</b> <b>char</b> <b>*representation,</b>
                                  <b>/*</b> <b>out</b> <b>*/</b> <b>bool</b> <b>*is_end_of_word,</b>
                                  <b>/*</b> <b>out</b> <b>*/</b> <b>bool</b> <b>*is_error)</b>
       Brief: Get the current buffered representation from the receiver's representation buffer

       On  success  the  function fills in <b>representation</b> with the contents of the current representation buffer
       and returns CW_SUCCESS.

       On failure, it returns CW_FAILURE and sets errno to: ERANGE if not preceded  by  a  cw_end_receive_tone()
       call,   a   prior   successful  cw_receive_representation  call,  or  a  prior  cw_receive_buffer_dot  or
       cw_receive_buffer_dash, EINVAL if the timestamp passed in is invalid, EAGAIN if  the  call  is  made  too
       early  to  determine  whether  a complete representation has yet been placed in the buffer (that is, less
       than   the   inter-character-space   duration   elapsed   since   the   last   cw_end_receive_tone()   or
       cw_receive_buffer_dot/dash  call). This is not a *hard* error, just an information that the caller should
       try to get the representation later.

       <b>is_end_of_word</b> indicates that the space after the last mark received is longer that the  inter-character-
       space, so it must be qualified as inter-word-space.

       <b>is_error</b> indicates that the representation was terminated by an error condition.

       The  function  is  called periodically (poll()-like function) by client code in hope that at some attempt
       receiver will be ready to pass <b>representation</b>. The attempt succeeds only if data  stream  is  in  "space"
       state.  To  mark  end  of  the space, client code has to provide a timestamp (or pass NULL timestamp, the
       function will get time stamp at function call). The receiver needs to know the "end  of  space"  event  -
       thus the <b>timestamp</b> parameter.

       Parameter: timestamp - timestamp of event that ends inter-character-space or inter-word-space
       Parameter: representation - buffer for representation (output parameter)
       Parameter: is_end_of_word - buffer for "is end of word" state (output parameter)
       Parameter: is_error - buffer for "error" state (output parameter)

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_receive_character(const</b> <b>struct</b> <b>timeval</b> <b>*timestamp,</b>
                             <b>/*</b> <b>out</b> <b>*/</b> <b>char</b> <b>*c,</b>
                             <b>/*</b> <b>out</b> <b>*/</b> <b>bool</b> <b>*is_end_of_word,</b>
                             <b>/*</b> <b>out</b> <b>*/</b> <b>bool</b> <b>*is_error)</b>
       Brief: Get a current character

       Function returns the character currently stored in receiver's representation buffer.

       On  success  the function returns CW_SUCCESS, and fills <b>c</b> with the contents of the current representation
       buffer, translated into a character.

       On failure the function returns CW_FAILURE, with errno set to:

       ERANGE if not preceded by a cw_end_receive_tone() call, a prior successful  cw_receive_character()  call,
       or  a  cw_receive_buffer_dot()  or  cw_receive_buffer_dash()  call,  EINVAL if the timestamp passed in is
       invalid, or EAGAIN if the call is made too early to determine whether a complete character has  yet  been
       placed  in  the  buffer  (that  is,  less  than the inter-character-space duration elapsed since the last
       cw_end_receive_tone() or cw_receive_buffer_dot/dash call).  ENOENT if character stored in receiver cannot
       be recognized as valid

       <b>is_end_of_word</b> indicates that the space after the last mark received is longer that the  inter-character-
       space, so it must be qualified as inter-word-space.

       <b>is_error</b> indicates that the character was terminated by an error condition.

       Parameter: timestamp - timestamp of event that ends inter-character-space or inter-word-space
       Parameter: c - buffer for character (output parameter)
       Parameter: is_end_of_word - buffer for "is end of word" state (output parameter)
       Parameter: is_error - buffer for "error" state (output parameter)

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>void</b> <b>cw_clear_receive_buffer(void)</b>
       Brief: Clear receiver's representation buffer

       Clears the receiver's representation buffer, resets receiver's internal state. This prepares the receiver
       to receive marks and spaces again.

       This   routine   must   be  called  after  successful,  or  terminating,  cw_receive_representation()  or
       cw_receive_character() calls, to clear the states and prepare  the  buffer  to  receive  more  marks  and
       spaces.

       When migrating to libcw2.h, use cw_rec_reset_state() instead of this function.

       <b>int</b> <b>cw_get_receive_buffer_capacity(void)</b>
       Brief: Get the number of elements (dots/dashes) the receiver's buffer can accommodate

       The  maximum number of elements written out by cw_receive_representation() is the capacity + 1, the extra
       character being used for the terminating NUL.

       Returns: number of elements that can be stored in receiver's representation buffer

       <b>int</b> <b>cw_get_receive_buffer_length(void)</b>
       Brief: Get the number of elements (dots/dashes) currently pending  in  the  cw_receiver's  representation
       buffer

       Returns: number of elements in receiver's representation buffer

       <b>void</b> <b>cw_reset_receive(void)</b>
       Brief: Clear receive data

       Clear the receiver's representation buffer, statistics, and any retained receiver's state.  This function
       is suitable for calling from an application exit handler.

       When  migrating  to  libcw2.h,  use  cw_rec_reset_state()  and  cw_rec_reset_statistics() instead of this
       function.

       <b>void</b> <b>cw_register_keying_callback(void</b> <b>(*callback_func)(void*,</b> <b>int),</b> <b>void</b> <b>*callback_arg)</b>
       Brief: Register external callback function for keying

       Register a <b>callback_func</b> function that should be called when a state of a key changes from "key open"  to
       "key closed", or vice-versa.

       The  first argument passed to the registered callback function is the supplied <b>callback_arg</b>, if any.  The
       second argument passed to registered callback function is the key state:  CW_KEY_STATE_CLOSED  (one/true)
       for "key closed", and CW_KEY_STATE_OPEN (zero/false) for "key open".

       Calling  this routine with a NULL function address disables keying callbacks.  Any callback supplied will
       be called in signal handler context (??).

       Parameter: callback_func - callback function to be called on key state changes
       Parameter: callback_arg - first argument to callback_func

       <b>void</b> <b>cw_enable_iambic_curtis_mode_b(void)</b>
       Brief: Enable iambic Curtis mode B

       Normally, the iambic keying functions will emulate Curtis 8044 Keyer mode A.  In  this  mode,  when  both
       paddles  are  pressed together, the last dot or dash being sent on release is completed, and nothing else
       is sent. In mode B, when both paddles are pressed together, the last dot or dash being sent on release is
       completed, then an opposite element is also sent. Some operators  prefer  mode  B,  but  timing  is  more
       critical in this mode. The default mode is Curtis mode A.

       <b>void</b> <b>cw_disable_iambic_curtis_mode_b(void)</b>
       See documentation of cw_enable_iambic_curtis_mode_b() for more information

       <b>int</b> <b>cw_get_iambic_curtis_mode_b_state(void)</b>
       See documentation of cw_enable_iambic_curtis_mode_b() for more information

       <b>int</b> <b>cw_notify_keyer_paddle_event(int</b> <b>dot_paddle_state,</b> <b>int</b> <b>dash_paddle_state)</b>
       Brief: Inform about changed state of iambic keyer's paddles

       Function informs the library that the iambic keyer paddles have changed state.  The new paddle states are
       recorded,  and  if  either  transition from false to true, paddle latches, for iambic functions, are also
       set.

       On success, the routine returns CW_SUCCESS.  On failure, it returns CW_FAILURE, with errno set  to  EBUSY
       if the tone queue or straight key are using the sound card, console speaker, or keying system.

       If  appropriate,  this routine starts the keyer functions sending the relevant element.  Element send and
       timing occurs in the background, so this routine returns almost immediately.

       Parameter: dot_paddle_state
       Parameter: dash_paddle_state

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_notify_keyer_dot_paddle_event(int</b> <b>dot_paddle_state)</b>
       Brief: Change state of dot paddle

       Alter the state of just one of the two iambic keyer paddles.  The other paddle state of the  paddle  pair
       remains unchanged.

       See  cw_notify_keyer_paddle_event()  for  details of iambic keyer background processing, and how to check
       its status.

       Parameter: dot_paddle_state

       <b>int</b> <b>cw_notify_keyer_dash_paddle_event(int</b> <b>dash_paddle_state)</b>
       See documentation of cw_notify_keyer_dot_paddle_event() for more information

       <b>void</b> <b>cw_get_keyer_paddles(int</b> <b>*dot_paddle_state,</b> <b>int</b> <b>*dash_paddle_state)</b>
       Brief: Get the current saved states of the two paddles

       Parameter: dot_paddle_state
       Parameter: dash_paddle_state

       <b>void</b> <b>cw_get_keyer_paddle_latches(int</b> <b>*dot_paddle_latch_state,</b> <b>int</b> <b>*dash_paddle_latch_state)</b>
       Brief: Get the current states of paddle latches

       Function returns the current saved states of the two paddle latches.  A paddle latches  is  set  to  true
       when the paddle state becomes true, and is cleared if the paddle state is false when the element finishes
       sending.

       Parameter: dot_paddle_latch_state
       Parameter: dash_paddle_latch_state

       <b>bool</b> <b>cw_is_keyer_busy(void)</b>
       Brief: Check if a keyer is busy

       Returns: true if keyer is busy
       Returns: false if keyer is not busy

       <b>int</b> <b>cw_wait_for_keyer_element(void)</b>
       Brief: Wait for end of element from the keyer

       Waits until the end of the current element, dot or dash, from the keyer.

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_wait_for_keyer(void)</b>
       Brief: Wait for the current keyer cycle to complete

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>void</b> <b>cw_reset_keyer(void)</b>
       Brief: Reset iambic keyer data

       Clear  all  latches  and paddle states of iambic keyer, return to Curtis 8044 Keyer mode A, and return to
       silence.  This function is suitable for calling from an application exit handler.

       <b>int</b> <b>cw_notify_straight_key_event(int</b> <b>key_state)</b>
       Brief: Inform the library that the straight key has changed state

       This routine returns CW_SUCCESS on success.  On error, it returns CW_FAILURE, with errno set to EBUSY  if
       the  tone  queue or iambic keyer are using the sound card, console speaker, or keying control system.  If
       <b>key_state</b> indicates no change of state, the call is ignored.

       <b>key_state</b> may be either CW_KEY_STATE_OPEN (false) or CW_KEY_STATE_CLOSED (true).

       Parameter: key_state - state of straight key

       <b>int</b> <b>cw_get_straight_key_state(void)</b>
       Brief: Get saved state of straight key

       Returns the current saved state of the straight key.

       Returns: CW_KEY_STATE_CLOSED (true) if the key is down
       Returns: CW_KEY_STATE_OPEN (false) if the key up

       <b>bool</b> <b>cw_is_straight_key_busy(void)</b>
       Brief: Check if the straight key is busy

       This routine is just a pseudonym for cw_get_straight_key_state(), and exists to fill a hole  in  the  API
       naming conventions.

       Returns: true if the straight key is busy
       Returns: false if the straight key is not busy

       <b>void</b> <b>cw_reset_straight_key(void)</b>
       Brief: Clear the straight key state, and return to silence

       This function is suitable for calling from an application exit handler.

       <b>bool</b> <b>cw_is_alsa_possible(const</b> <b>char</b> <b>*</b> <b>device_name)</b>
       Brief: Check if it is possible to open ALSA output with given device name

       The  check  consists  of two parts: -# whether it's possible to load ALSA shared library, -# whether it's
       possible to open ALSA device specified by <b>device_name</b>

       If it's possible to use ALSA with given device name, the function  leaves  library  handle  (returned  by
       dlopen()) open and some library function symbols loaded, but does not leave any ALSA PCM handle open.

       Parameter(in):  device_name  name  of ALSA device to be used; if NULL or empty then the function will use
       library-default device name.

       Returns: true if opening ALSA output succeeded
       Returns: false if opening ALSA output failed

       <b>bool</b> <b>cw_is_console_possible(const</b> <b>char</b> <b>*</b> <b>device_name)</b>
       Brief: Check if it is possible to open console buzzer output

       Function does a test opening and test writing to console buzzer device  <b>device_name</b>,  but  it  closes  it
       before returning.

       The  function  tests  that  the given console buzzer device exists, and that it will accept the KIOCSOUND
       ioctl.  It unconditionally returns false on platforms that do no support the KIOCSOUND ioctl.

       Call to ioctl will fail if calling code doesn't have root privileges.

       This is the only place where we ask if KIOCSOUND is defined, so  client  code  must  call  this  function
       whenever  it  wants  to  use console output, as every other function called to perform console operations
       will happily assume that it is allowed to perform such operations.

       Parameter(in): device_name name of console buzzer device to be used; if NULL or empty then  the  function
       will use library-default device name.

       Returns: true if opening console output succeeded
       Returns: false if opening console output failed

       <b>int</b> <b>cw_get_character_count(void)</b>
       Brief: Return the number of characters present in main character lookup table

       Return  the  number  of characters that are known to libcw.  The number includes: @li ASCII 7bit letters,
       @li numerals, @li punctuation, @li ISO 8859-1 accented characters, @li ISO  8859-2  accented  characters,
       @li non-standard procedural signal extensions to standard CW characters.

       Returns: number of characters known to libcw

       <b>void</b> <b>cw_list_characters(char</b> <b>*</b> <b>list)</b>
       Brief: Get list of characters present in character lookup table

       Function provides a string containing all of the characters represented in library's lookup table.

       The  list  includes:  @li  ASCII  7bit  letters,  @li  numerals, @li punctuation, @li ISO 8859-1 accented
       characters, @li ISO 8859-2 accented characters, @li non-standard procedural signal extensions to standard
       CW characters.

       <b>list</b> should be allocated and managed by caller.  The length of <b>list</b> must be at least one greater than the
       number of characters represented in the character lookup table, returned by cw_get_character_count(). The
       string placed in <b>list</b> will be NUL-terminated.

       Parameter(out): list buffer for string with all characters

       <b>int</b> <b>cw_get_maximum_representation_length(void)</b>
       Brief: Get length of the longest representation of characters

       Function returns the string length of the longest representation in the main character lookup  table.  It
       is the count of dots and dashes in the longest representation of characters known to libcw (not including
       terminating NUL).

       Returns: length of the longest representation

       <b>int</b> <b>cw_lookup_character(char</b> <b>character,</b> <b>char</b> <b>*</b> <b>representation)</b>
       Brief: Get representation of a given character

       The function is depreciated, use cw_character_to_representation() instead.

       Return the string representation of a given character <b>character</b>.

       The  routine  returns  CW_SUCCESS on success, and fills in the string pointer (<b>representation</b>) passed in.
       On failure, it returns CW_FAILURE and sets errno to ENOENT, indicating that the character <b>character</b> could
       not be found.

       The length  of  <b>representation</b>  buffer  must  be  at  least  one  greater  than  the  length  of  longest
       representation  held  in  the  character  lookup  table.  The  largest  value  of  length  is returned by
       cw_get_maximum_representation_length().

       Parameter(in): character character to  look  up  Parameter(out):  representation  pointer  to  space  for
       representation of character

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>char</b> <b>*</b> <b>cw_character_to_representation(int</b> <b>character)</b>
       Brief: Get representation of a given character

       On  success  return  representation  of  a  given  character.  Returned pointer is owned by caller of the
       function.

       On failure function returns NULL and sets errno.

       ERRNO ENOENT the character could not be found.  ERRNO ENOMEM  character  has  been  found,  but  function
       failed to strdup() representation.

       Parameter(in): character character to look up

       Returns: pointer to freshly allocated representation on success
       Returns: NULL on failure

       <b>int</b> <b>cw_check_representation(const</b> <b>char</b> <b>*</b> <b>representation)</b>
       Brief: Check if representation of a character is valid

       This function is depreciated, use cw_representation_is_valid() instead.

       Check  that the given string is a valid Morse representation.  A valid string is one composed of only "."
       and "-" characters.  This means that the function checks only if representation is  error-free,  and  not
       whether the representation represents existing/defined character.

       If representation is invalid, function returns CW_FAILURE and sets errno to EINVAL.

       Parameter(in): representation representation of a character to check

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>bool</b> <b>cw_representation_is_valid(const</b> <b>char</b> <b>*</b> <b>representation)</b>
       Brief: Check if representation of a character is valid

       Check  that the given string is a valid Morse representation.  A valid string is one composed of only "."
       and "-" characters.  This means that the function checks only if representation is  error-free,  and  not
       whether the representation represents existing/defined character.

       ERRNO EINVAL representation is invalid

       Parameter(in): representation representation of a character to check

       Returns: true if representation is valid
       Returns: false if representation is invalid

       <b>int</b> <b>cw_lookup_representation(const</b> <b>char</b> <b>*</b> <b>representation,</b> <b>char</b> <b>*</b> <b>character)</b>
       Brief: Get the character represented by a given Morse representation

       This function is depreciated, use cw_representation_to_character() instead.

       Function  checks  <b>representation</b>,  and  if it is valid and represents a known character, function returns
       CW_SUCCESS. Additionally, if <b>character</b> is non-NULL, function puts the looked up character in <b>character</b>.

       <b>character</b> should be allocated by caller. Function assumes that <b>character</b> being NULL pointer  is  a  valid
       situation, and can return CW_SUCCESS in such situation.

       On  error,  function returns CW_FAILURE. errno is set to EINVAL if any character of the representation is
       invalid, or ENOENT to indicate that the character represented by <b>representation</b> could not be found.

       Parameter(in): representation representation of a character to look up Parameter(out): character location
       where to put looked up character

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>int</b> <b>cw_representation_to_character(const</b> <b>char</b> <b>*</b> <b>representation)</b>
       Brief: Return the character represented by a given Morse representation

       Function checks <b>representation</b>, and if it is valid and represents a known character, function returns the
       character (a non-zero value).

       On error, function returns zero (character represented by <b>representation</b> was not found).

       ERRNO EINVAL <b>representation</b> contains invalid symbol (other than Dots and Dashes) ERRNO ENOENT a character
       represented by <b>representation</b> could not be found

       Parameter(in): representation representation of a character to look up

       Returns: non-zero character on success
       Returns: zero on failure

       <b>int</b> <b>cw_get_procedural_character_count(void)</b>
       Brief: Get number of procedural signals

       Returns: the number of characters stored in the procedural signal expansion lookup table

       <b>void</b> <b>cw_list_procedural_characters(char</b> <b>*</b> <b>list)</b>
       Brief: Get list of characters for which procedural expansion is available

       Function copies into preallocated buffer <b>list</b> a string containing all of the Morse characters  for  which
       procedural expansion is available.  The length of <b>list</b> must be at least by one greater than the number of
       characters    represented    in   the   procedural   signal   expansion   lookup   table,   returned   by
       cw_get_procedural_character_count().

       <b>list</b> buffer is allocated and managed by caller.

       Parameter(out): list buffer for returned string

       <b>int</b> <b>cw_get_maximum_procedural_expansion_length(void)</b>
       Brief: Get length of the longest procedural expansion

       Function returns the string length of the longest expansion in the procedural signal expansion table.

       Returns: the string length of the longest expansion of procedural signals

       <b>int</b> <b>cw_lookup_procedural_character(char</b> <b>character,</b> <b>char</b> <b>*expansion,</b> <b>int</b> <b>*</b> <b>is_usually_expanded)</b>
       Brief: Get the string expansion of a given Morse code procedural signal character

       On success the function @li fills <b>expansion</b> with the string expansion of a given  Morse  code  procedural
       signal  character  <b>character</b>; @li sets <b>is_usually_expanded</b> to appropriate value as a display hint for the
       caller; @li returns CW_SUCCESS.

       Both <b>expansion</b> and <b>expansion</b> must be allocated and managed by caller. They can be NULL, then the function
       won't attempt to use them.

       The length of <b>expansion</b> must be at least by one greater than the longest expansion held in the procedural
       signal character lookup table, as returned by cw_get_maximum_procedural_expansion_length().

       ERRNO ENOENT procedural signal character <b>character</b> cannot be found

       Parameter(in): character character to look up Parameter(out): expansion buffer to fill with expansion  of
       the character Parameter(out): is_usually_expanded visual hint

       Returns: CW_FAILURE on failure (character cannot be found)
       Returns: CW_SUCCESS on success

       <b>int</b> <b>cw_get_maximum_phonetic_length(void)</b>
       Brief: Get length of a longest phonetic

       Returns: the string length of the longest phonetic in the phonetics lookup table

       <b>int</b> <b>cw_lookup_phonetic(char</b> <b>character,</b> <b>char</b> <b>*</b> <b>phonetic)</b>
       Brief: Look up the phonetic of a given character

       On  success  the  routine copies a phonetic corresponding to <b>character</b> into <b>phonetic</b>. <b>phonetic</b> is managed
       and owned by caller.

       It is NOT considered an error if <b>phonetic</b> is NULL.  In  such  case  the  function  will  just  verify  if
       <b>character</b> can be represented by a phonetic, i.e. if <b>character</b> is a letter.

       If  non-NULL,  the  size  of <b>phonetic</b> must be greater by at least 1 than the longest phonetic held in the
       phonetic lookup table, as returned by cw_get_maximum_phonetic_length().

       ERRNO ENOENT phonetic for given character cannot be found

       Parameter(in): character character to look up Parameter(out): phonetic buffer for phonetic of a character
       (may be NULL)

       Returns: CW_SUCCESS on success (phonetic has been found and - if <b>phonetic</b> is non-NULL) has been copied to
       the buffer
       Returns: CW_FAILURE on failure (phonetic for given character cannot be found)

       <b>bool</b> <b>cw_character_is_valid(char</b> <b>character)</b>
       Brief: Check if given character is valid

       Check that a given character is valid, i.e. it is present in library's character-to-representation lookup
       table and can be represented with Dots and Dashes.

       Space character (' ') is also considered to be a valid character.

       ERRNO ENOENT on failure (character is invalid).

       Notice the difference in errno set by cw_character_is_valid() (ENOENT) and cw_string_is_valid() (EINVAL).
       This different behaviour goes way back to unixcw-2.3 and is  preserved  in  new  versions  for  backwards
       compatibility reasons.

       Parameter(in): character character to check

       Returns: true if character is valid
       Returns: false otherwise

       <b>int</b> <b>cw_check_character(char</b> <b>character)</b>

       <b>bool</b> <b>cw_string_is_valid(const</b> <b>char</b> <b>*</b> <b>string)</b>
       Brief: Check if all characters in given string are valid

       Check  that  each  character  in  the  given  string is valid and can be converted by libcw to Morse code
       symbols sent as a Morse character.

       Space character (' ') is also considered to be a valid character.

       ERRNO EINVAL on failure (when an invalid character has been found in <b>string</b>).

       Notice the difference in errno set by cw_character_is_valid() (ENOENT) and cw_string_is_valid() (EINVAL).
       This different behaviour goes way back to unixcw-2.3 and is  preserved  in  new  versions  for  backwards
       compatibility reasons.

       Parameter(in): string string to check

       Returns: true if all characters in string are valid
       Returns: false otherwise

       <b>int</b> <b>cw_check_string(const</b> <b>char</b> <b>*</b> <b>string)</b>

       <b>void</b> <b>cw_set_debug_flags(uint32_t</b> <b>flags)</b>
       Brief: Set a value of internal debug flags variable

       Assign  specified  value  to  library's  internal  debug flags variable.  Note that this function doesn't
       *append*  given  flag  to  the  variable,  it  erases  existing  value   and   assigns   new   one.   Use
       cw_get_debug_flags() if you want to OR new flag with existing ones.

       Parameter: flags new value of flags to be assigned to the debug object

       <b>void</b> <b>cw_debug_set_flags(cw_debug_t</b> <b>*</b> <b>debug_object,</b> <b>uint32_t</b> <b>flags)</b>
       Brief: Set a value of debug flags in given debug variable

       Assign specified value to given debug variable.

       Note that this function doesn't *append* given flag to the variable, it erases existing value and assigns
       new one. Use cw_debug_get_flags() if you want to OR new flag with existing ones.

       Parameter(in):  debug_object  debug  object  for  which to set flags Parameter(in): flags new value to be
       assigned to the object, a sum of one or more of CW_DEBUG_* flags from libcw.h

       <b>uint32_t</b> <b>cw_get_debug_flags(void)</b>
       Brief: Get library's current debug flags

       Function returns value of library's internal debug variable, a sum of one or  more  of  CW_DEBUG_*  flags
       from libcw.h.

       Returns: value of library's debug flags variable

       <b>uint32_t</b> <b>cw_debug_get_flags(const</b> <b>cw_debug_t</b> <b>*</b> <b>debug_object)</b>
       Brief: Get current debug flags from given debug object

       Function  returns  value  of  debug  object's  debug flags, a sum of one or more of CW_DEBUG_* flags from
       libcw.h.

       Returns: value of debug object's debug flags

       <b>bool</b> <b>cw_debug_has_flag(const</b> <b>cw_debug_t</b> <b>*</b> <b>debug_object,</b> <b>uint32_t</b> <b>flag)</b>
       Brief: Check if given debug flag is set

       Function checks if a specified debug flag is set in given debug object.

       Parameter(in): debug_object debug object to be checked Parameter(in): flag flag to  be  checked,  one  of
       CW_DEBUG_* flags from libcw.h

       Returns: true if given flag is set
       Returns: false otherwise

       <b>int</b> <b>cw_generator_set_tone_slope(cw_gen_t</b> <b>*</b> <b>gen,</b> <b>int</b> <b>slope_shape,</b> <b>int</b> <b>slope_duration)</b>
       Brief: Set parameters describing slopes of tones generated by generator

       Most  of  variables  related  to  slope  of tones is in <b>tone</b>, but there are still some variables that are
       generator-specific, as they are common for all tones.  This function sets two of these generator-specific
       variables.

       A: If you pass to function conflicting values of <b>slope_shape</b> and <b>slope_duration</b>, the function will return
       CW_FAILURE. These conflicting values are rectangular slope shape and larger than zero slope  length.  You
       just can't have rectangular slopes that have non-zero length.

       B:  If  you  pass  to  function  '-1' as value of both <b>slope_shape</b> and <b>slope_duration</b>, the function won't
       change any of the related two generator's parameters.

       C1: If you pass to function '-1' as value of either <b>slope_shape</b>  or  <b>slope_duration</b>,  the  function  will
       attempt to set only this generator's parameter that is different than '-1'.

       C2:  However, if selected slope shape is rectangular, function will set generator's slope length to zero,
       even                              if                               value                               of
       slope_duration is '-1'.

       D: Notice that the function allows non-rectangular slope shape with zero length of the slopes. The slopes
       will be non-rectangular, but just unusually short.

       The function should be called every time one of following parameters change:

       @li shape of slope, @li duration of slope, @li generator's sample rate, @li generator's volume.

       There  are  four  supported  shapes  of slopes: @li linear (the only one supported by libcw until version
       4.1.1), @li raised cosine (supposedly the most desired shape), @li sine, @li rectangular.

       Use CW_TONE_SLOPE_SHAPE_* symbolic names as values of <b>slope_shape</b>.

       FIXME: first argument of this public function is gen,  but  no  function  provides  access  to  generator
       variable.

       Parameter(in):  gen  generator for which to set tone slope parameters Parameter(in): slope_shape shape of
       slope:  linear,  raised  cosine,  sine,  rectangular  Parameter(in):  slope_duration  duration  of  slope
       [microseconds]

       Returns: CW_SUCCESS on success
       Returns: CW_FAILURE on failure

       <b>bool</b> <b>cw_is_null_possible(__attribute__((unused))</b> <b>const</b> <b>char</b> <b>*</b> <b>device_name)</b>
       Brief: Check if it is possible to open Null sound output

       Parameter(in): device_name name of Null device to be used. Value is ignored for Null sound system.

       Returns: true it's always possible to write to Null device

       <b>bool</b> <b>cw_is_oss_possible(const</b> <b>char</b> <b>*</b> <b>device_name)</b>
       Brief: Check if it is possible to open OSS output with given device name

       Function does a test opening and test configuration of OSS output, but it closes it before returning.

       Parameter(in):  device_name  name  of  OSS device to be used; if NULL or empty then the function will use
       library-default device name.

       Returns: true if opening OSS output succeeded
       Returns: false if opening OSS output failed

       <b>bool</b> <b>cw_is_pa_possible(const</b> <b>char</b> <b>*</b> <b>device_name)</b>
       Brief: Check if it is possible to open PulseAudio output with given device name

       Function first tries to load PulseAudio library, and then does a test opening of PulseAudio  output,  but
       it closes it before returning.

       Parameter(in):  device_name  name  of  PulseAudio  device  to be used; if NULL then the function will use
       library-default device name.

       Returns: true if opening PulseAudio output succeeded
       Returns: false if opening PulseAudio output failed

       <b>void</b> <b>cw_block_callback(int</b> <b>block)</b>
       Brief: Block the callback from being called

       Function blocks the callback from being called for a critical section of caller code if  <b>block</b>  is  true,
       and unblocks the callback if <b>block</b> is false.

       Function  works  by  blocking SIGALRM; a block should always be matched by an unblock, otherwise the tone
       queue will suspend forever.

       Parameter: block - pass 1 to block SIGALRM, and 0 to unblock it

       <b>int</b> <b>cw_register_signal_handler(int</b> <b>signal_number,</b> <b>void</b> <b>(*callback_func)(int))</b>
       Brief: Register a signal handler and optional callback function for given signal number

       On receipt of that signal, all library features will be reset to their  default  states.   Following  the
       reset,  if  <b>callback_func</b>  is  a  function pointer, the function is called; if it is SIG_DFL, the library
       calls exit(); and if it is SIG_IGN, the library returns from the signal handler.

       This is a convenience function for clients that need to clean up library on signals,  with  either  exit,
       continue, or an additional function call; in effect, a wrapper round a restricted form of sigaction.

       The <b>signal_number</b> argument indicates which signal to catch.

       On  problems  errno is set to EINVAL if <b>signal_number</b> is invalid or if a handler is already installed for
       that signal, or to the sigaction error code.

       Parameter: signal_number
       Parameter: callback_func

       Returns: CW_SUCCESS - if the signal handler installs correctly
       Returns: CW_FAILURE - on errors or problems

       <b>int</b> <b>cw_unregister_signal_handler(int</b> <b>signal_number)</b>
       Brief: Unregister a signal handler interception

       Function removes a signal handler interception previously registered with cw_register_signal_handler().

       Parameter: signal_number

       Returns: true if the signal handler uninstalls correctly
       Returns: false otherwise (with errno set to EINVAL or to the sigaction error code)

       <b>int</b> <b>cw_version(void)</b>
       Brief: Return version number of libcw library

       Return the version number of the library.  Version numbers (major and minor)  are  returned  as  an  int,
       composed of major_version &lt;&lt; 16 | minor_version.

       Returns: library's major and minor version number encoded as single int

       <b>void</b> <b>cw_license(void)</b>
       Brief: Print libcw's license text to stdout

       Function  prints  to  stdout  information  about libcw version, followed by short text presenting libcw's
       copyright and license notice.

       <b>const</b> <b>char</b> <b>*</b> <b>cw_get_audio_system_label(int</b> <b>sound_system)</b>
       Brief: Get a readable label of given sound system

       The function returns one of following strings: None, Null, Console, OSS, ALSA, PulseAudio, Soundcard

       Returned pointer is owned and managed by the library.

       *const cw_get_audio_system_label(...)"?

       Parameter(in): sound_system ID of sound system

       Returns: sound system's label

       <b>void</b> <b>cw_get_speed_limits(int</b> <b>*</b> <b>min_speed,</b> <b>int</b> <b>*</b> <b>max_speed)</b>
       Brief: Get speed limits

       Get (through function's arguments) limits on speed of Morse code that are supported by libcw.

       See CW_SPEED_MIN and CW_SPEED_MAX in libcw.h for values.

       Any of functions two arguments can be NULL - function won't update value of that argument.

       Parameter(out): min_speed minimal allowed speed Parameter(out): max_speed maximal allowed speed

       <b>void</b> <b>cw_get_frequency_limits(int</b> <b>*</b> <b>min_frequency,</b> <b>int</b> <b>*</b> <b>max_frequency)</b>
       Brief: Get frequency limits

       Get (through function's arguments) limits on frequency that are supported by libcw.

       See CW_FREQUENCY_MIN and CW_FREQUENCY_MAX in libcw.h for values.

       Any of functions two arguments can be NULL - function won't update value of that argument.

       Parameter(out): min_frequency minimal allowed frequency  Parameter(out):  max_frequency  maximal  allowed
       frequency

       <b>void</b> <b>cw_get_volume_limits(int</b> <b>*</b> <b>min_volume,</b> <b>int</b> <b>*</b> <b>max_volume)</b>
       Brief: Get volume limits

       Get  (through  function's  arguments)  limits  on  volume  of  sound  supported by libcw and generated by
       generator.

       See CW_VOLUME_MIN and CW_VOLUME_MAX in libcw.h for values.

       Any of functions two arguments can be NULL - function won't update value of that argument.

       Parameter(out): min_volume minimal allowed volume Parameter(out): max_volume maximal allowed volume

       <b>void</b> <b>cw_get_gap_limits(int</b> <b>*</b> <b>min_gap,</b> <b>int</b> <b>*</b> <b>max_gap)</b>
       Brief: Get gap limits

       Get (through function's arguments) limits on gap in cw signal supported by libcw.

       See CW_GAP_MIN and CW_GAP_MAX in libcw.h for values.

       Any of functions two arguments can be NULL - function won't update value of that argument.

       Parameter(out): min_gap minimal allowed gap Parameter(out): max_gap maximal allowed gap

       <b>void</b> <b>cw_get_tolerance_limits(int</b> <b>*</b> <b>min_tolerance,</b> <b>int</b> <b>*</b> <b>max_tolerance)</b>
       Brief: Get tolerance limits

       Get (through function's arguments) limits on "tolerance" parameter supported by libcw.

       See CW_TOLERANCE_MIN and CW_TOLERANCE_MAX in libcw.h for values.

       Any of functions two arguments can be NULL - function won't update value of that argument.

       Parameter(out): min_tolerance minimal allowed tolerance  Parameter(out):  max_tolerance  maximal  allowed
       tolerance

       <b>void</b> <b>cw_get_weighting_limits(int</b> <b>*</b> <b>min_weighting,</b> <b>int</b> <b>*</b> <b>max_weighting)</b>
       Brief: Get weighting limits

       Get (through function's arguments) limits on "weighting" parameter supported by libcw.

       See CW_WEIGHTING_MIN and CW_WEIGHTING_MAX in libcw.h for values.

       Any of functions two arguments can be NULL - function won't update value of that argument.

       Parameter(out):  min_weighting  minimal  allowed  weighting Parameter(out): max_weighting maximal allowed
       weighting

       <b>void</b> <b>cw_complete_reset(void)</b>
       Brief: Reset all library features to their default states

       Clears the tone queue, receive buffers and retained state information, any current  keyer  activity,  and
       any  straight  key activity, returns to silence, and closes soundcard and console devices.  This function
       is suitable for calling from an application exit handler.

</pre><h4><b>NOTES</b></h4><pre>
       Despite the fact that this manual page constantly and consistently refers to Morse code elements as  dots
       and  dashes, DO NOT think in these terms when trying to learn Morse code.  Always think of them as 'dit's
       and 'dah's.

       <b>libcw</b> uses system itimers for its internal timing.  On most UNIX flavours, itimers are not guaranteed  to
       signal a program exactly at the specified time, and they generally offer a resolution only as good as the
       normal system 'clock tick' resolution.  An itimer SIGALRM usually falls on a system clock tick, making it
       accurate to no better than 10mS on a typical 100Hz kernel.

       The  effect  of  this is that an itimer period is generally either exactly as specified, or, more likely,
       slightly longer.  At higher WPM settings, the cumulative effect of this affects timing accuracy,  because
       at  higher  speeds,  there  are  fewer 10mS clock ticks in a dot period.  For example, at 12 WPM, the dot
       length is 100mS, enough to contain five kernel clock ticks; at 60 WPM, the dot length is  20mS,  or  just
       two kernel clock ticks.  So at higher speeds, the effect of itimer resolutions becomes more pronounced.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Man pages for <b>cw</b>(7,LOCAL), <b>cw</b>(1,LOCAL), <b>cwgen</b>(1,LOCAL), <b>cwcp</b>(1,LOCAL), and <b>xcwcp</b>(1,LOCAL).

libcw ver. 8.0.0                                CW Tutor Package                                        <u><a href="../man3/LIBCW.3.html">LIBCW</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>