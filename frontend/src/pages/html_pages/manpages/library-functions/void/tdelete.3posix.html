<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       tdelete, tfind, tsearch, twalk — manage a binary search tree

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/search.h">search.h</a>&gt;

       void *tdelete(const void *restrict <u>key</u>, void **restrict <u>rootp</u>,
           int(*<u>compar</u>)(const void *, const void *));
       void *tfind(const void *<u>key</u>, void *const *<u>rootp</u>,
           int(*<u>compar</u>)(const void *, const void *));
       void *tsearch(const void *<u>key</u>, void **<u>rootp</u>,
           int (*<u>compar</u>)(const void *, const void *));
       void twalk(const void *<u>root</u>,
           void (*<u>action</u>)(const void *, VISIT, int));

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>tdelete</u>(), <u>tfind</u>(), <u>tsearch</u>(), and <u>twalk</u>() functions manipulate binary search trees. Comparisons are
       made with a user-supplied routine, the address of which is passed as the <u>compar</u> argument. This routine is
       called with two arguments, which are the pointers to the elements being compared. The  application  shall
       ensure  that  the  user-supplied  routine  returns  an  integer  less  than, equal to, or greater than 0,
       according to whether the first argument is to be considered less than, equal  to,  or  greater  than  the
       second argument.  The comparison function need not compare every byte, so arbitrary data may be contained
       in the elements in addition to the values being compared.

       The <u>tsearch</u>() function shall build and access the tree. The <u>key</u> argument is a pointer to an element to be
       accessed or stored. If there is a node in the tree whose element is equal to the value pointed to by <u>key</u>,
       a  pointer to this found node shall be returned. Otherwise, the value pointed to by <u>key</u> shall be inserted
       (that is, a new node is created and the value of <u>key</u> is copied to this node), and a pointer to this  node
       returned.  Only  pointers are copied, so the application shall ensure that the calling routine stores the
       data. The <u>rootp</u> argument points to a variable that points to the root node of the tree.  A  null  pointer
       value for the variable pointed to by <u>rootp</u> denotes an empty tree; in this case, the variable shall be set
       to point to the node which shall be at the root of the new tree.

       Like  <u>tsearch</u>(),  <u>tfind</u>()  shall  search  for  a  node  in  the tree, returning a pointer to it if found.
       However, if it is not found, <u>tfind</u>() shall return a null pointer. The arguments for <u>tfind</u>() are the  same
       as for <u>tsearch</u>().

       The  <u>tdelete</u>()  function shall delete a node from a binary search tree. The arguments are the same as for
       <u>tsearch</u>().  The variable pointed to by <u>rootp</u> shall be changed if the deleted node was  the  root  of  the
       tree.  If the deleted node was the root of the tree and had no children, the variable pointed to by <u>rootp</u>
       shall  be  set  to  a  null  pointer.  The <u>tdelete</u>() function shall return a pointer to the parent of the
       deleted node, or an unspecified non-null pointer if the deleted node was the root node, or a null pointer
       if the node is not found.

       If <u>tsearch</u>() adds an element to a tree, or <u>tdelete</u>() successfully deletes an element  from  a  tree,  the
       concurrent  use of that tree in another thread, or use of pointers produced by a previous call to <u>tfind</u>()
       or <u>tsearch</u>(), produces undefined results.

       The <u>twalk</u>() function shall traverse a binary search tree. The <u>root</u> argument is a pointer to the root node
       of the tree to be traversed.  (Any node in a tree may be used as the root for a walk  below  that  node.)
       The argument <u>action</u> is the name of a routine to be invoked at each node. This routine is, in turn, called
       with  three  arguments.  The first argument shall be the address of the node being visited. The structure
       pointed to by this argument is unspecified and shall not be modified by the application, but it shall  be
       possible  to  cast a pointer-to-node into a pointer-to-pointer-to-element to access the element stored in
       the node.  The second argument shall be a value from an enumeration data type:

           typedef enum { preorder, postorder, endorder, leaf } VISIT;

       (defined in <u>&lt;search.h&gt;</u>), depending on whether this is the first, second, or third time that the  node  is
       visited  (during  a depth-first, left-to-right traversal of the tree), or whether the node is a leaf. The
       third argument shall be the level of the node in the tree, with the root being level 0.

       If the calling function alters the pointer to the root, the result is undefined.

       If the functions pointed to by <u>action</u> or <u>compar</u> (for any of these binary  search  functions)  change  the
       tree, the results are undefined.

       These functions are thread-safe only as long as multiple threads do not access the same tree.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       If  the  node  is  found,  both <u>tsearch</u>() and <u>tfind</u>() shall return a pointer to it. If not, <u>tfind</u>() shall
       return a null pointer, and <u>tsearch</u>() shall return a pointer to the inserted item.

       A null pointer shall be returned by <u>tsearch</u>() if there is not enough space  available  to  create  a  new
       node.

       A  null  pointer  shall  be  returned  by <u>tdelete</u>(), <u>tfind</u>(), and <u>tsearch</u>() if <u>rootp</u> is a null pointer on
       entry.

       The <u>tdelete</u>() function shall return a pointer to the parent of the deleted node, or an  unspecified  non-
       null pointer if the deleted node was the root node, or a null pointer if the node is not found.

       The <u>twalk</u>() function shall not return a value.

</pre><h4><b>ERRORS</b></h4><pre>
       No errors are defined.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following code reads in strings and stores structures containing a pointer to each string and a count
       of  its length. It then walks the tree, printing out the stored strings and their lengths in alphabetical
       order.

           #include &lt;<a href="file:/usr/include/limits.h">limits.h</a>&gt;
           #include &lt;<a href="file:/usr/include/search.h">search.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

           struct element {      /* Pointers to these are stored in the tree. */
               int     count;
               char    string[];
           };

           void  *root = NULL;          /* This points to the root. */

           int main(void)
           {
               char   str[_POSIX2_LINE_MAX+1];
               int    length = 0;
               struct element *elementptr;
               void   *node;
               void   print_node(const void *, VISIT, int);
               int    node_compare(const void *, const void *),
                      delete_root(const void *, const void *);

               while (fgets(str, sizeof(str), stdin))  {
                   /* Set element. */
                   length = strlen(str);
                   if (str[length-1] == '\n')
                       str[--length] = '\0';
                   elementptr = malloc(sizeof(struct element) + length + 1);
                   strcpy(elementptr-&gt;string, str);
                   elementptr-&gt;count = 1;
                   /* Put element into the tree. */
                   node = tsearch((void *)elementptr, &amp;root, node_compare);
                   if (node == NULL) {
                       fprintf(stderr,
                               "tsearch: Not enough space available\n");
                       exit(EXIT_FAILURE);
                   }
                   else if (*(struct element **)node != elementptr) {
                       /* A node containing the element already exists */
                       (*(struct element **)node)-&gt;count++;
                       free(elementptr);
                   }
               }
               twalk(root, print_node);

               /* Delete all nodes in the tree */
               while (root != NULL) {
                   elementptr = *(struct element **)root;
                   printf("deleting node: string = %s,  count = %d\n",
                          elementptr-&gt;string,
                          elementptr-&gt;count);
                   tdelete((void *)elementptr, &amp;root, delete_root);
                   free(elementptr);
               }

               return 0;
           }

           /*
            *  This routine compares two nodes, based on an
            *  alphabetical ordering of the string field.
            */
           int
           node_compare(const void *node1, const void *node2)
           {
               return strcmp(((const struct element *) node1)-&gt;string,
                   ((const struct element *) node2)-&gt;string);
           }

           /*
            *  This comparison routine can be used with tdelete()
            *  when explicitly deleting a root node, as no comparison
            *  is necessary.
            */
           int
           delete_root(const void *node1, const void *node2)
           {
               return 0;
           }

           /*
            *  This routine prints out a node, the second time
            *  twalk encounters it or if it is a leaf.
            */
           void
           print_node(const void *ptr, VISIT order, int level)
           {
               const struct element *p = *(const struct element **) ptr;

               if (order == postorder || order == leaf)  {
                   (void) printf("string = %s,  count = %d\n",
                       p-&gt;string, p-&gt;count);
               }
           }

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       The <u>root</u> argument to <u>twalk</u>() is one level of indirection less than the <u>rootp</u> arguments to  <u>tdelete</u>()  and
       <u>tsearch</u>().

       There  are  two  nomenclatures  used  to  refer to the order in which tree nodes are visited. The <u>twalk</u>()
       function uses <b>preorder</b>, <b>postorder</b>, and <b>endorder</b> to refer respectively to visiting a node  before  any  of
       its  children,  after  its  left child and before its right, and after both its children. The alternative
       nomenclature uses <b>preorder</b>, <b>inorder</b>, and <b>postorder</b> to refer to the same visits,  which  could  result  in
       some confusion over the meaning of <b>postorder</b>.

       Since  the  return value of <u>tdelete</u>() is an unspecified non-null pointer in the case that the root of the
       tree has been deleted, applications should only use the  return  value  of  <u>tdelete</u>()  as  indication  of
       success  or  failure and should not assume it can be dereferenced. Some implementations in this case will
       return a pointer to the new root of the tree (or to an empty tree if the deleted root node was  the  only
       node in the tree); other implementations return arbitrary non-null pointers.

</pre><h4><b>RATIONALE</b></h4><pre>
       None.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>hcreate</u>(), <u>lsearch</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;search.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                       <u><a href="../man3POSIX/TDELETE.3POSIX.html">TDELETE</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>