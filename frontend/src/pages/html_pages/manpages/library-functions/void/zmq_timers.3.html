<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zmq_timers - helper functions for cross-platform timers callbacks</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libzmq3-dev">libzmq3-dev_4.3.5-1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       zmq_timers - helper functions for cross-platform timers callbacks

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>typedef</b> <b>void(zmq_timer_fn)</b> <b>(int</b> <u>timer_id</u><b>,</b> <b>void</b> <b>*</b><u>arg</u><b>);</b>

       <b>void</b> <b>*zmq_timers_new</b> <b>(void);</b>

       <b>int</b> <b>zmq_timers_destroy</b> <b>(void</b> <b>*</b><u>timers_p</u>);*

       <b>int</b> <b>zmq_timers_add</b> <b>(void</b> <b>*</b><u>timers</u><b>,</b> <b>size_t</b> <u>interval</u><b>,</b> <b>zmq_timer_fn</b> <u>handler</u><b>,</b> <b>void</b> <b>*</b><u>arg</u><b>);</b>

       <b>int</b> <b>zmq_timers_cancel</b> <b>(void</b> <b>*</b><u>timers</u><b>,</b> <b>int</b> <u>timer_id</u><b>);</b>

       <b>int</b> <b>zmq_timers_set_interval</b> <b>(void</b> <b>*</b><u>timers</u><b>,</b> <b>int</b> <u>timer_id</u><b>,</b> <b>size_t</b> <u>interval</u><b>);</b>

       <b>int</b> <b>zmq_timers_reset</b> <b>(void</b> <b>*</b><u>timers</u><b>,</b> <b>int</b> <u>timer_id</u><b>);</b>

       <b>long</b> <b>zmq_timers_timeout</b> <b>(void</b> <b>*</b><u>timers</u><b>);</b>

       <b>int</b> <b>zmq_timers_execute</b> <b>(void</b> <b>*</b><u>timers</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>zmq_timers</u>*_ functions provide cross-platform access to timers callbacks. Once a timer has been
       registered, it will repeat at the specified interval until it gets manually cancelled. To run the
       callbacks, <u>zmq_timers_execute</u> must be ran.

       <u>zmq_timers_new</u> and <u>zmq_timers_destroy</u> manage the lifetime of a timer instance. <u>zmq_timers_new</u> creates and
       returns a new timer instance, while <u>zmq_timers_destroy</u> destroys it. A pointer to a valid timer must be
       passed as the <u>timers_p</u> argument of <u>zmq_timers_destroy</u>. In particular, <u>zmq_timers_destroy</u> may not be
       called multiple times for the same timer instance. <u>zmq_timers_destroy</u> sets the passed pointer to NULL in
       case of a successful execution.

       <u>zmq_timers_add</u> and <u>zmq_timers_cancel</u> manage the timers registered.

       <u>zmq_timers_add</u> registers a new <u>timer</u> with a given instance. <u>timers</u> must point to a valid <u>timers</u> object.
       The <u>interval</u> parameter specifies the expiration of the timer in milliseconds. <u>handler</u> and <u>arg</u> specify the
       callback that will be invoked on expiration and the optional parameter that will be passed through. The
       callback must be a valid function implementing the <u>zmq_timer_fn</u> prototype. An ID will be returned that
       can be used to modify or cancel the timer.

       <u>zmq_timers_cancel</u> will cancel the timer associated with <u>timer_id</u> from the instance <u>timers</u>.

       <u>zmq_timers_set_interval</u> will set the expiration of the timer associated with <u>timer_id</u> from the instance
       <u>timers</u> to <u>interval</u> milliseconds into the future.

       <u>zmq_timers_reset</u> will restart the timer associated with <u>timer_id</u> from the instance <u>timers</u>.

       <u>zmq_timers_timeout</u> will return the time left in milliseconds until the next timer registered with <u>timers</u>
       expires.

       <u>zmq_timers_execute</u> will run callbacks of all expired timers from the instance <u>timers</u>.

</pre><h4><b>THREAD</b> <b>SAFETY</b></h4><pre>
       Like most other 0MQ objects, timers are not thread-safe. All operations must be called from the same
       thread. Otherwise, behaviour is undefined.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <u>zmq_timers_new</u> always returns a valid pointer to a poller.

       All functions that return an int, return -1 in case of a failure. In that case, zmq_errno() can be used
       to query the type of the error as described below.

       <u>zmq_timers_timeout</u> returns the time left in milliseconds until the next timer registered with <u>timers</u>
       expires, or -1 if there are no timers left.

       All other functions return 0 in case of a successful execution.

</pre><h4><b>ERRORS</b></h4><pre>
       On <u>zmq_timers_destroy</u>, <u>zmq_poller_cancel</u>, <u>zmq_timers_set_interval</u>, <u>zmq_timers_reset</u>, zmq_timers_timeout_,
       and <u>zmq_timers_execute</u>: <b>EFAULT</b>:: <u>timers</u> did not point to a valid timer. Note that passing an invalid
       pointer (e.g. pointer to deallocated memory) may cause undefined behaviour (e.g. an access violation).

       On <u>zmq_timers_add</u>: <b>EFAULT</b>:: <u>timers</u> did not point to a valid timer or <u>handler</u> did not point to a valid
       function.

       On <u>zmq_poller_cancel</u>, <u>zmq_timers_set_interval</u> and zmq_timers_timeout_: <b>EINVAL</b>:: <u>timer_id</u> did not exist or
       was already cancelled.

</pre><h4><b>EXAMPLE</b></h4><pre>
       <b>Add</b> <b>one</b> <b>timer</b> <b>with</b> <b>a</b> <b>simple</b> <b>callback</b> <b>that</b> <b>changes</b> <b>a</b> <b>boolean.</b>.

               void handler (int timer_id_, void *arg_)
               {
                   (void) timer_id_; //  Stop 'unused' compiler warnings
                   *((bool *) arg_) = true;
               }

               ...

               void *timers = zmq_timers_new ();
               assert (timers);

               bool timer_invoked = false;

               const unsigned long full_timeout = 100;

               int timer_id =
                 zmq_timers_add (timers, full_timeout, handler, &amp;timer_invoked);
               assert (timer_id);

               //  Timer should not have been invoked yet
               int rc = zmq_timers_execute (timers);
               assert (rc == 0);

               //  Wait half the time and check again
               long timeout = zmq_timers_timeout (timers);
               assert (rc != -1);
               msleep (timeout / 2);
               rc = zmq_timers_execute (timers);
               assert (rc == 0);

               // Wait until the end
               rc = msleep (zmq_timers_timeout (timers));
               assert (rc == 0);
               assert (timer_invoked);

               rc = zmq_timers_destroy (&amp;timers);
               assert (rc == 0);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/zmq.7.html">zmq</a></b>(7)

</pre><h4><b>AUTHORS</b></h4><pre>
       This page was written by the 0MQ community. To make a change please read the 0MQ Contribution Policy at
       <b><a href="http://www.zeromq.org/docs">http://www.zeromq.org/docs</a>:contributing</b>.

0MQ 4.3.5                                          03/31/2024                                      <u><a href="../man3/ZMQ_TIMERS.3.html">ZMQ_TIMERS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>