<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>csv - CSV parser and writer library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcsv-dev">libcsv-dev_3.0.3+dfsg-6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       csv - CSV parser and writer library

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;csv.h&gt;</b>

       <b>int</b> <b>csv_init(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>,</b> <b>unsigned</b> <b>char</b> <u>options</u><b>);</b>
       <b>size_t</b> <b>csv_parse(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>,</b>
               <b>const</b> <b>void</b> <b>*</b><u>s</u><b>,</b>
               <b>size_t</b> <u>len</u><b>,</b>
               <b>void</b> <b>(*</b><u>cb1</u><b>)(void</b> <b>*,</b> <b>size_t,</b> <b>void</b> <b>*),</b>
               <b>void</b> <b>(*</b><u>cb2</u><b>)(int,</b> <b>void</b> <b>*),</b>
               <b>void</b> <b>*</b><u>data</u><b>);</b>
       <b>int</b> <b>csv_fini(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>,</b>
               <b>void</b> <b>(*</b><u>cb1</u><b>)(void</b> <b>*,</b> <b>size_t,</b> <b>void</b> <b>*),</b>
               <b>void</b> <b>(*</b><u>cb2</u><b>)(int,</b> <b>void</b> <b>*),</b>
               <b>void</b> <b>*</b><u>data</u><b>);</b>
       <b>void</b> <b>csv_free(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>);</b>

       <b>unsigned</b> <b>char</b> <b>csv_get_delim(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>);</b>
       <b>unsigned</b> <b>char</b> <b>csv_get_quote(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>);</b>
       <b>void</b> <b>csv_set_space_func(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>,</b> <b>int</b> <b>(*</b><u>f</u><b>)(unsigned</b> <b>char));</b>
       <b>void</b> <b>csv_set_term_func(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>,</b> <b>int</b> <b>(*</b><u>f</u><b>)(unsigned</b> <b>char));</b>

       <b>int</b> <b>csv_get_opts(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>);</b>
       <b>int</b> <b>csv_set_opts(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>,</b> <b>unsigned</b> <b>char</b> <u>options</u><b>);</b>
       <b>int</b> <b>csv_error(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>);</b>
       <b>char</b> <b>*</b> <b>csv_strerror(int</b> <u>error</u><b>);</b>

       <b>size_t</b> <b>csv_write(void</b> <b>*</b><u>dest</u><b>,</b> <b>size_t</b> <u>dest_size</u><b>,</b> <b>const</b> <b>void</b> <b>*</b><u>src</u><b>,</b>
               <b>size_t</b> <u>src_size</u><b>);</b>
       <b>int</b> <b>csv_fwrite(FILE</b> <b>*</b><u>fp</u><b>,</b> <b>const</b> <b>void</b> <b>*</b><u>src</u><b>,</b> <b>size_t</b> <u>src_size</u><b>);</b>

       <b>size_t</b> <b>csv_write2(void</b> <b>*</b><u>dest</u><b>,</b> <b>size_t</b> <u>dest_size</u><b>,</b> <b>const</b> <b>void</b> <b>*</b><u>src</u><b>,</b>
               <b>size_t</b> <u>src_size</u><b>,</b> <b>unsigned</b> <b>char</b> <u>quote</u><b>);</b>
       <b>int</b> <b>csv_fwrite2(FILE</b> <b>*</b><u>fp</u><b>,</b> <b>const</b> <b>void</b> <b>*</b><u>src</u><b>,</b> <b>size_t</b> <u>src_size</u><b>,</b> <b>unsigned</b> <b>char</b> <u>quote</u><b>);</b>

       <b>void</b> <b>csv_set_realloc_func(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>,</b> <b>void</b> <b>*(*</b><u>func</u><b>)(void</b> <b>*,</b> <b>size_t));</b>
       <b>void</b> <b>csv_set_free_func(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>,</b> <b>void</b> <b>(*</b><u>func</u><b>)(void</b> <b>*));</b>
       <b>void</b> <b>csv_set_blk_size(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>,</b> <b>size_t</b> <u>size</u><b>);</b>
       <b>size_t</b> <b>csv_get_blk_size(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>);</b>
       <b>size_t</b> <b>csv_get_buffer_size(struct</b> <b>csv_parser</b> <b>*</b><u>p</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The CSV library provides a flexible, intuitive interface for parsing and writing csv data.

</pre><h4><b>OVERVIEW</b></h4><pre>
       The  idea  behind parsing with <b>libcsv</b> is straight-forward: you initialize a parser object with <b>csv_init()</b>
       and feed data to the parser over one or more calls  to  <b>csv_parse()</b>  providing  callback  functions  that
       handle end-of-field and end-of-row events.  <b>csv_parse()</b> parses the data provided calling the user-defined
       callback functions as it reads fields and rows.  When complete, <b>csv_fini()</b> is called to finish processing
       the  current  field  and  make  a  final call to the callback functions if necessary.  <b>csv_free()</b> is then
       called to free the parser object.   <b>csv_error()</b>  and  <b>csv_strerror()</b>  provide  information  about  errors
       encountered by the functions.  <b>csv_write()</b> and <b>csv_fwrite()</b> provide a simple interface for converting raw
       data into CSV data and storing the result into a buffer or file respectively.

       CSV is a binary format allowing the storage of arbitrary binary data, files opened for reading or writing
       CSV data should be opened in binary mode.

       <b>libcsv</b>  provides  a  default  mode  in  which  the  parser  will  happily process any data as CSV without
       complaint, this is useful for parsing files which don't adhere to all the  traditional  rules.  A  strict
       mode is also supported which will cause any violation of the imposed rules to cause a parsing failure.

</pre><h4><b>ROUTINES</b></h4><pre>
   PARSING DATA
       <b>csv_init()</b>  initializes  a  pointer  to  a  <b>csv_parser</b>  structure.   This structure contains housekeeping
       information such as the current state of the parser, the buffer, current size  and  position,  etc.   The
       <b>csv_init()</b>  function returns 0 on success and a non-zero value upon failure.  <b>csv_init()</b> will fail if the
       pointer passed to it is a null pointer.  The <u>options</u> argument specifies the parser options, these may  be
       changed later with the <b>csv_set_opts()</b> function.

       <u>OPTIONS</u>

              <b>CSV_STRICT</b>
                     Enables strict mode.

              <b>CSV_REPALL_NL</b>
                     Causes each instance of a carriage return or linefeed outside of a record to be reported.

              <b>CSV_STRICT_FINI</b>
                     Causes  unterminated  quoted fields encountered in <b>csv_fini()</b> to cause a parsing error (see
                     below).

              <b>CSV_APPEND_NULL</b>
                     Will cause all fields to be nul-terminated when provided to <u>cb1</u>, introduced in 3.0.0.

              <b>CSV_EMPTY_IS_NULL</b>
                     Will cause NULL to be passed as the first argument to  <u>cb1</u>  for  empty,  unquoted,  fields.
                     Empty means consisting only of either spaces and tabs or the values defined by the a custom
                     function registered via <b>csv_set_space_func()</b>.  Added in 3.0.3.

       Multiple options can be specified by OR-ing them together.

       <b>csv_parse()</b> is the function that does the actual parsing, it takes 6 arguments:

              <u>p</u> is a pointer to an initialized <b>struct</b> <b>csv_parser</b>.

              <u>s</u> is a pointer to the data to read in, such as a dynamically allocated region of memory containing
              data read in from a call to <b>fread()</b>.

              <u>len</u> is the number of bytes of data to process.

              <u>cb1</u> is a pointer to the callback function that will be called from <b>csv_parse()</b> after an entire
              field has been read. <u>cb1</u> will be called with a pointer to the parsed data (which is NOT nul-
              terminated unless the CSV_APPEND_NULL option is set), the number of bytes in the data, and the
              pointer that was passed to <b>csv_parse()</b>.

              <u>cb2</u> is a pointer to the callback function that will be called when the end of a record is
              encountered, it will be called with the character that caused the record to end, cast to an
              unsigned char, or -1 if called from csv_fini, and the pointer that was passed to <b>csv_init()</b>.

              <u>data</u> is a pointer to user-defined data that will be passed to the callback functions when invoked.

              <u>cb1</u> and/or <u>cb2</u> may be <b>NULL</b> in which case no function will be called for the associated actions.
              <u>data</u> may also be <b>NULL</b> but the callback functions must be prepared to handle receiving a null
              pointer.

       By  default <u>cb2</u> is not called when rows that do not contain any fields are encountered.  This behavior is
       meant to accommodate files using only either a linefeed or a carriage return as a record separator to  be
       parsed  properly  while  at  the  same  time  being  able to parse files with rows terminated by multiple
       characters from resulting in blank rows after each actual row of data (for example, processing a text CSV
       file created that was created on a Windows machine on a Unix machine).   The  <b>CSV_REPALL_NL</b>  option  will
       cause <b>cb2</b> to be called once for every carriage return or linefeed encountered outside of a field.  <u>cb2</u> is
       called  with  the  character  that  prompted the call to the function, , cast to an unsigned char, either
       <b>CSV_CR</b> for carriage return, <b>CSV_LF</b> for linefeed, or <b>-1</b> for record termination from a call  to  <b>csv_fini()</b>
       (see  below).   A  carriage return or linefeed within a non-quoted field always marks both the end of the
       field and the row.  Other characters can be used as row terminators and thus be provided as  an  argument
       to <u>cb2</u> using <b>csv_set_space_func()</b>.

       <b>Note:</b>  The  first  parameter  of  the <u>cb1</u> function is <b>void</b> <b>*</b>, not <b>const</b> <b>void</b> <b>*</b>; the pointer passed to the
       callback function is actually a pointer to the entry buffer inside the <b>csv_parser</b> <b>struct</b>, this  data  may
       safely  be modified from the callback function (or any function that the callback function calls) but you
       must not attempt to access more than <u>len</u> bytes and you should not access  the  data  after  the  callback
       function returns as the buffer is dynamically allocated and its location and size may change during calls
       to <b>csv_parse()</b>.

       <b>Note:</b>  Different  callback  functions may safely be specified during each call to <b>csv_parse()</b> but keep in
       mind that the callback functions may be called many times during a single call to  <b>csv_parse()</b>  depending
       on the amount of data being processed in a given call.

       <b>csv_parse()</b>  returns  the number of bytes processed, on a successful call this will be <u>len</u>, if it is less
       than len an error has occurred.  An error can occur, for example, if  there  is  insufficient  memory  to
       store  the  contents of the current field in the entry buffer.  An error can also occur if malformed data
       is encountered while running in strict mode.

       The <b>csv_error()</b> function can be used to determine what the error is and the <b>csv_strerror()</b>  function  can
       be  used to provide a textual description of the error. <b>csv_error()</b> takes a single argument, a pointer to
       a <b>struct</b> <b>csv_parser</b>, and returns one of the following values defined in <b>csv.h</b>:

              <b>CSV_EPARSE</b>   A parse error has occurred while in strict mode

              <b>CSV_ENOMEM</b>   There was not enough memory while attempting to increase the entry buffer for the
              current field

              <b>CSV_ETOOBIG</b>  Continuing to process the current field would require a buffer of more than SIZE_MAX
              bytes

       The value passed to <b>csv_strerror()</b> should  be  one  returned  from  <b>csv_error()</b>.   The  return  value  of
       <b>csv_strerror()</b>  is  a  pointer to a static string. The pointer may be used for the entire lifetime of the
       program and the contents will not change during execution but you must not attempt to modify  the  string
       it points to.

       When  you  have  finished submitting data to <b>csv_parse()</b>, you need to call the <b>csv_fini()</b> function.  This
       function will call the <u>cb1</u> function with any remaining data in the entry buffer (if  there  is  any)  and
       call  the  <u>cb2</u>  function unless we are already at the end of a row (the last byte processed was a newline
       character for example).  It is necessary to call this function because the file being processed might not
       end with a carriage return or newline but the data that has been read in to this point still needs to  be
       submitted  to  the callback routines.  If <u>cb2</u> is called from within <b>csv_fini()</b> it will be because the row
       was not terminated with a newline sequence, in this case <u>cb2</u> will be called with an argument of -1.

       <b>Note:</b> A call to <b>csv_fini</b> implicitly ends the field current field and row.  If the last field processed is
       a quoted field that ends before a closing quote is encountered, no error will  be  reported  by  default,
       even  if  CSV_STRICT  is  specified.   To  cause  <b>csv_fini()</b>  to  report an error in such a case, set the
       CSV_STRICT_FINI option (new in version 1.0.1) in addition to the CSV_STRICT option.

       <b>csv_fini()</b> also reinitializes the parser state so that it is ready to be used on the next file or set  of
       data.   <b>csv_fini()</b>  does not alter the current buffer size. If the last set of data that was being parsed
       contained a very large field that increased the size of the buffer, and you  need  to  free  that  memory
       before  continuing,  you must call <b>csv_free()</b>, you do not need to call <b>csv_init()</b> again after <b>csv_free()</b>.
       Like csv_parse, the callback functions provided to <b>csv_fini()</b> may  be  NULL.   <b>csv_fini()</b>  returns  0  on
       success and a non-zero value if you pass it a null pointer.

       After   calling  <b>csv_fini()</b>  you  may  continue  to  use  the  same  struct  csv_parser  pointer  without
       reinitializing it (in fact you must not call <b>csv_init()</b> with an  initialized  csv_parser  object  or  the
       memory allocated for the original structure will be lost).

       When  you  are  finished  using  the  csv_parser  object  you  can  free any dynamically allocated memory
       associated with it by calling <b>csv_free()</b>.  You may call <b>csv_free()</b> at any time, it need not  be  preceded
       by  a call to <b>csv_fini()</b>.  You must only call <b>csv_free()</b> on a csv_parser object that has been initialized
       with a successful call to <b>csv_init()</b>.

   WRITING DATA
       <b>libcsv</b> provides two functions to transform raw data into CSV formatted  data:  the  <b>csv_write()</b>  function
       which  writes the result to a provided buffer, and the <b>csv_fwrite()</b> function which writes the result to a
       file.  The functionality of both functions is straight-forward, they write out a single  field  including
       the opening and closing quotes and escape each encountered quote with another quote.

       The  <b>csv_write()</b>  function  takes  a  pointer  to  a  source  buffer (<u>src</u>) and processes at most <u>src_size</u>
       characters from <u>src</u>.  <b>csv_write()</b> will write at most <u>dest_size</u> characters to <u>dest</u> and returns the  number
       of  characters  that  would have been written if <u>dest</u> was large enough.  This can be used to determine if
       all the characters were written and, if not, how large <u>dest</u> needs to be to write out  all  of  the  data.
       <b>csv_write()</b>  may be called with a null pointer for the <u>dest</u> argument in which case no data is written but
       the size required to write out the data will be returned.  The space needed to write out the data is  the
       size  of  the  data  + number of quotes appearing in data (each one will be escaped) + 2 (the leading and
       terminating quotes).  <u>csv_write()</u> and <u>csv_fwrite()</u> always surround  the  output  data  with  quotes.   If
       <u>src_size</u>  is  very  large  (SIZE_MAX/2  or  greater)  it  is  possible that the number of bytes needed to
       represent the data, after inserting escaping quotes, will be greater than  SIZE_MAX.   In  such  a  case,
       csv_write will return SIZE_MAX which should be interpreted as meaning the data is too large to write to a
       single field.  The <b>csv_fwrite()</b> function is not similarly limited.

       <b>csv_fwrite()</b>  takes a FILE pointer (which should have been opened in binary mode) and converts and writes
       the data pointed to by <u>src</u> of size <u>src_size</u>.  It returns <b>0</b> on success and  <b>EOF</b>  if  there  was  an  error
       writing  to  the  file.   <b>csv_fwrite()</b> doesn't provide the number of characters processed or written.  If
       this functionality is required, use the <b>csv_write()</b> function combined with <b>fwrite()</b>.

       <b>csv_write2()</b> and <b>csv_fwrite2()</b> work similarly but take an additional argument, the quote character to use
       when composing the field.

   CUSTOMIZING THE PARSER
       The <b>csv_set_delim()</b> and <b>csv_set_quote()</b> functions provide a means  to  change  the  characters  that  the
       parser   will   consider  the  delimiter  and  quote  characters  respetively,  cast  to  unsigned  char.
       <b>csv_get_delim()</b>  and <b>csv_get_delim()</b> return the current  delimiter  and  quote  characters  respectively.
       When  <b>csv_init()</b>  is  called the delimiter is set to <b>CSV_COMMA</b> and the quote to <b>CSV_QUOTE</b>.  Note that the
       rest of the CSV conventions still apply when these functions are used  to  change  the  delimiter  and/or
       quote  characters,  fields  containing  the  new  quote  character  or delimiter must be quoted and quote
       characters must be escaped with an immediately preceding instance of the same  character.   Additionally,
       the  <b>csv_set_space_func()</b> and <b>csv_set_term_func()</b> allow a user-defined function to be provided which will
       be used determine what constitutes a space character and what constitutes a record terminator  character.
       The  space  characters  determine  which  characters are removed from the beginning and end of non-quoted
       fields and the terminator characters govern when a record ends.  When <b>csv_init()</b> is called, the effect is
       as if these functions were each called with a NULL argument in which  case  no  function  is  called  and
       CSV_SPACE  and  CSV_TAB  are  used  for  space  characters, and CSV_CR and CSV_LF are used for terminator
       characters.

       <b>csv_set_realloc_func()</b> can be used to set the function that is called when the internal buffer  needs  to
       be  resized,  only  realloc,  not  malloc, is used internally; the default is to use the standard realloc
       function.  Likewise, <b>csv_set_free_func()</b> is used to set the function called to free the internal  buffer,
       the default is the standard free function.

       <b>csv_get_blk_size()</b>  and  <b>csv_set_blk_size()</b>  can  be  used  to  get  and set the block size of the parser
       respectively.  The block size if the amount of extra memory allocated  every  time  the  internal  buffer
       needs to be increased, the default is 128.  <b>csv_get_buffer_size()</b> will return the current number of bytes
       allocated for the internal buffer.

</pre><h4><b>THE</b> <b>CSV</b> <b>FORMAT</b></h4><pre>
       Although  quite  prevelant  there  is  no  standard  for  the  CSV  format.   There are however, a set of
       traditional conventions  used  by  many  applications.   <b>libcsv</b>  follows  the  conventions  described  at
       <a href="http://www.creativyst.com/Doc/Articles/CSV/CSV01.htm">http://www.creativyst.com/Doc/Articles/CSV/CSV01.htm</a>  which  seem to reflect the most common usage of the
       format, namely:

              Fields are separated with commas.

              Rows are delimited by newline sequences (see below).

              Fields may be surrounded with quotes.

              Fields that contain comma, quote, or newline characters MUST be quoted.

              Each instance of a quote character must be escaped with an immediately preceding quote character.

              Leading and trailing spaces and tabs are removed from non-quoted fields.

              The final line need not contain a newline sequence.

       In strict mode, any detectable violation of these rules results in an error.

       RFC 4180 is an informational memo which attempts to document the CSV format, especially with  regards  to
       its  use  as  a  MIME  type.   There are a several parts of the description documented in this memo which
       either do not accurately reflect widely used conventions or artificially  limit  the  usefulness  of  the
       format.  The differences between the RFC and <b>libcsv</b> are:

              "Each line should contain the same number of fields throughout the file"
                     <b>libcsv</b>  doesn't  care  if  every  record  contains  a  different  number  of fields, such a
                     restriction could easily be enforced by the application itself if desired.

              "Spaces are considered part of a field and should not be ignored"
                     Leading and trailing spaces that are part of non-quoted fields are ignored as  this  is  by
                     far the most common behavior and expected by many applications.

                     <b>abc</b> <b>,</b>  <b>def</b>

                     is considered equivalent to:

                     <b>"abc",</b> <b>"def"</b>

              "The last field in the record must not be followed by a comma"
                     The  meaning  of  this  statement  is  not clear but if the last character of a record is a
                     comma, <b>libcsv</b> will interpret that as a final empty field, i.e.:

                     <b>"abc",</b> <b>"def",</b>

                     will be interpreted as 3 fields, equivalent to:

                     <b>"abc",</b> <b>"def",</b> <b>""</b>

              RFC 4180 limits the allowable characters in a CSV field, <b>libcsv</b> allows any character to be present
              in a field provided it adheres to the conventions mentioned above.   This  makes  it  possible  to
              store binary data in CSV format, an attribute that many application rely on.

              RFC  4180  states  that  a  Carriage  Return plus Linefeed combination is used to delimit records,
              <b>libcsv</b> allows any combination of Carriage Returns and Linefeeds to signify the end  of  a  record.
              This  is to increase portability among systems that use different combinations to denote a newline
              sequence.

</pre><h4><b>PARSING</b> <b>MALFORMED</b> <b>DATA</b></h4><pre>
       <b>libcsv</b> should correctly parse any CSV data that conforms to  the  rules  discussed  above.   By  default,
       however, <b>libcsv</b> will also attempt to parse malformed CSV data such as data containing unescaped quotes or
       quotes within non-quoted fields.  For example:

       <b>a"c,</b> <b>"d"f"</b>

       would be parsed equivalently to the correct form:

       <b>"a""c",</b> <b>"d""f"</b>

       This  is  often  desirable  as  there  are  some  applications  that  do not adhere to the specifications
       previously discussed.  However, there are instances where malformed CSV data is ambiguous, namely when  a
       comma or newline is the next non-space character following a quote such as:

       <b>"Sally</b> <b>said</b> <b>"Hello",</b> <b>Wally</b> <b>said</b> <b>"Goodbye""</b>

       This could either be parsed as a single field containing the data:

       <b>Sally</b> <b>said</b> <b>"Hello",</b> <b>Wally</b> <b>said</b> <b>"Goodbye"</b>

       or as 2 separate fields:

       <b>Sally</b> <b>said</b> <b>"Hello</b> and <b>Wally</b> <b>said</b> <b>"Goodbye""</b>

       Since  the  data  is  malformed,  there  is no way to know if the quote before the comma is meant to be a
       literal quote or if it signifies the end of the field.  This is of  course  not  an  issue  for  properly
       formed data as all quotes must be escaped.  <b>libcsv</b> will parse this example as 2 separate fields.

       <b>libcsv</b>  provides a strict mode that will return with a parse error if a quote is seen inside a non-quoted
       field or if a non-escaped quote is seen whose next non-space character isn't a comma or newline sequence.

</pre><h4><b>PARSER</b> <b>DETAILS</b></h4><pre>
       A field is considered quoted if the first non-space character for a new field is a quote.

       If a quote is encountered in a quoted field and the next non-space character is a comma, the  field  ends
       at the closed quote and the field data is submitted when the comma is encountered.  If the next non-space
       character after a quote is a newline character, the row has ended and the field data is submitted and the
       end of row is signalled (via the appropriate callback function).  If two quotes are immediately adjacent,
       the first one is interpreted as escaping the second one and one quote is written to the field buffer.  If
       the  next  non-space  character  following  a  quote is anything else, the quote is interpreted as a non-
       escaped literal quote and it and what follows are written to the field buffer, this would cause  a  parse
       error in strict mode.

       Example 1
       <b>"abc"""</b>
       Parses as: <b>abc"</b>
       The  first  quote  marks  the  field as quoted, the second quote escapes the following quote and the last
       quote ends the field.  This is valid in both strict and non-strict modes.

       Example 2
       <b>"ab"c</b>
       Parses as: <b>ab"c</b>
       The first qute marks the field as quoted, the second quote is taken as a literal  quote  since  the  next
       non-space  character  is  not  a comma, or newline and the quote is not escaped.  The last quote ends the
       field (assuming there is a newline character following).  A parse error  would  result  upon  seeing  the
       character c in strict mode.

       Example 3
       <b>"abc"</b> <b>"</b>
       Parses as: <b>abc"</b>
       In  this  case,  since  the next non-space character following the second quote is not a comma or newline
       character, a literal quote is written, the space character after is part of the field, and the last quote
       terminated the field.  This demonstrates the fact that a quote must immediately precede another quote  to
       escape it.  This would be a strict-mode violation as all quotes are required to be escaped.

       If  the field is not quoted, any quote character is taken as part of the field data, any comma terminated
       the field, and any newline character terminated the field and the record.

       Example 4
       <b>ab""c</b>
       Parses as: <b>ab""c</b>
       Quotes are not considered special in non-quoted fields.  This would be  a  strict  mode  violation  since
       quotes may not exist in non-quoted fields in strict mode.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following  example  prints the number of fields and rows in a file.  This is a simplified version of
       the csvinfo program provided in the examples directory.  Error checking not related to  <b>libcsv</b>  has  been
       removed  for  clarity,  the  csvinfo program also provides an option for enabling strict mode and handles
       multiple files.

              #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
              #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
              #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
              #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
              #include &lt;csv.h&gt;

              struct counts {
                long unsigned fields;
                long unsigned rows;
              };

              void cb1 (void *s, size_t len, void *data) {
                ((struct counts *)data)-&gt;fields++; }
              void cb2 (int c, void *data) {
                ((struct counts *)data)-&gt;rows++; }

              int main (int argc, char *argv[]) {
                FILE *fp;
                struct csv_parser p;
                char buf[1024];
                size_t bytes_read;
                struct counts c = {0, 0};

                if (csv_init(&amp;p, 0) != 0) exit(EXIT_FAILURE);
                fp = fopen(argv[1], "rb");
                if (!fp) exit(EXIT_FAILURE);

                while ((bytes_read=fread(buf, 1, 1024, fp)) &gt; 0)
                  if (csv_parse(&amp;p, buf, bytes_read, cb1, cb2, &amp;c) != bytes_read) {
                    fprintf(stderr, "Error while parsing file: %s\n",
                    csv_strerror(csv_error(&amp;p)) );
                    exit(EXIT_FAILURE);
                  }

                csv_fini(&amp;p, cb1, cb2, &amp;c);

                fclose(fp);
                printf("%lu fields, %lu rows\n", c.fields, c.rows);

                csv_free(&amp;p);
                exit(EXIT_SUCCESS);
              }

       See the examples directory for several complete example programs.

</pre><h4><b>AUTHOR</b></h4><pre>
       Written by Robert Gamble.

</pre><h4><b>BUGS</b></h4><pre>
       Please send questions, comments, bugs, etc. to:

               <a href="mailto:rgamble@users.sourceforge.net">rgamble@users.sourceforge.net</a>

                                                 9 January 2013                                           <u><a href="../man3/CSV.3.html">CSV</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>