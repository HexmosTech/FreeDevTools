<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pmem2_get_memmove_fn(), pmem2_get_memset_fn(), pmem2_get_memcpy_fn() - get a function that provides opti‐</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpmem2-dev">libpmem2-dev_1.13.1-1.1ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>pmem2_get_memmove_fn</b>(), <b>pmem2_get_memset_fn</b>(), <b>pmem2_get_memcpy_fn</b>() - get a function that provides opti‐
       mized copying to persistent memory

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;libpmem2.h&gt;

              typedef void *(*pmem2_memmove_fn)(void *pmemdest, const void *src, size_t len,
                      unsigned flags);
              typedef void *(*pmem2_memcpy_fn)(void *pmemdest, const void *src, size_t len,
                      unsigned flags);
              typedef void *(*pmem2_memset_fn)(void *pmemdest, int c, size_t len,
                      unsigned flags);

              struct pmem2_map;

              pmem2_memmove_fn pmem2_get_memmove_fn(struct pmem2_map *map);
              pmem2_memset_fn pmem2_get_memset_fn(struct pmem2_map *map);
              pmem2_memcpy_fn pmem2_get_memcpy_fn(struct pmem2_map *map);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>pmem2_get_memmove_fn</b>(), <b>pmem2_get_memset_fn</b>(), <b>pmem2_get_memcpy_fn</b>() functions return a pointer to a
       function responsible for efficient storing and flushing of data for mapping <u>map</u>.

       <b>pmem2_memmove_fn</b>(), <b>pmem2_memset_fn</b>() and <b>pmem2_memcpy_fn</b>() functions provide  the  same  memory  copying
       functionalities  as  their  namesakes <b><a href="../man3/memmove.3.html">memmove</a></b>(3), <b><a href="../man3/memcpy.3.html">memcpy</a></b>(3) and <b><a href="../man3/memset.3.html">memset</a></b>(3), and ensure that the result has
       been flushed to persistence before returning (unless <b>PMEM2_F_MEM_NOFLUSH</b> flag was used).

       For example, the following code:

                      memmove(dest, src, len);
                      pmem2_persist_fn persist_fn = <a href="../manmap/pmem2_get_persist_fn.map.html">pmem2_get_persist_fn</a>(map);
                      persist_fn(dest, len);

       is functionally equivalent to:

                      pmem2_memmove_fn memmove_fn = <a href="../manmap/pmem2_get_memmove_fn.map.html">pmem2_get_memmove_fn</a>(map);
                      memmove_fn(dest, src, len, 0);

       Unlike libc implementation, <b>libpmem2</b> functions guarantee that if destination buffer  address  and  length
       are  8  byte  aligned  then  all stores will be performed using at least 8 byte store instructions.  This
       means that a series of 8 byte stores followed by <u>persist_fn</u> can be safely replaced by a single <u>memmove_fn</u>
       call.

       The <u>flags</u> argument of all of the above functions has the same meaning.  It can be 0 or a  bitwise  OR  of
       one or more of the following flags:

       • <b>PMEM2_F_MEM_NODRAIN</b>  - modifies the behavior to skip the final <u>pmem2_drain_fn</u> step.  This allows appli‐
         cations to optimize cases where several ranges are being copied to persistent  memory,  followed  by  a
         single  call to <u>pmem2_drain_fn</u>.  The following example illustrates how this flag might be used to avoid
         multiple calls to <u>pmem2_drain_fn</u> when copying several ranges of memory to pmem:

         pmem2_memcpy_fn memcpy_fn = <a href="../manmap/pmem2_get_memcpy_fn.map.html">pmem2_get_memcpy_fn</a>(map);
         pmem2_drain_fn drain_fn = <a href="../manmap/pmem2_get_drain_fn.map.html">pmem2_get_drain_fn</a>(map);

         /* ... write several ranges to pmem ... */
         memcpy_fn(pmemdest1, src1, len1, PMEM2_F_MEM_NODRAIN);
         memcpy_fn(pmemdest2, src2, len2, PMEM2_F_MEM_NODRAIN);

         /* ... */

         /* wait for any pmem stores to drain from HW buffers */
         drain_fn();

       • <b>PMEM2_F_MEM_NOFLUSH</b> - Don’t flush anything.  This implies <b>PMEM2_F_MEM_NODRAIN</b>.  Using  this  flag  only
         makes sense when it’s followed by any function that flushes data.

       The remaining flags say <u>how</u> the operation should be done, and are merely hints.

       • <b>PMEM2_F_MEM_NONTEMPORAL</b>  -  Use  non-temporal  instructions.   This  flag  is  mutually  exclusive with
         <b>PMEM2_F_MEM_TEMPORAL</b>.  On x86_64 this flag is mutually exclusive with <b>PMEM2_F_MEM_NOFLUSH</b>.

       • <b>PMEM2_F_MEM_TEMPORAL</b>  -  Use  temporal  instructions.    This   flag   is   mutually   exclusive   with
         <b>PMEM2_F_MEM_NONTEMPORAL</b>.

       • <b>PMEM2_F_MEM_WC</b>  -  Use  write combining mode.  This flag is mutually exclusive with <b>PMEM2_F_MEM_WB</b>.  On
         x86_64 this flag is mutually exclusive with <b>PMEM2_F_MEM_NOFLUSH</b>.

       • <b>PMEM2_F_MEM_WB</b> - Use write back mode.  This flag is mutually exclusive with <b>PMEM2_F_MEM_WC</b>.  On  x86_64
         this is an alias for <b>PMEM2_F_MEM_TEMPORAL</b>.

       Using an invalid combination of flags has undefined behavior.

       Without  any of the above flags <b>libpmem2</b> will try to guess the best strategy based on the data size.  See
       <b>PMEM_MOVNT_THRESHOLD</b> description in <b><a href="../man7/libpmem2.7.html">libpmem2</a></b>(7) for details.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The <b>pmem2_get_memmove_fn</b>(), <b>pmem2_get_memset_fn</b>(), <b>pmem2_get_memcpy_fn</b>() functions never return NULL.

       They return the same function for the same mapping.

       This means that it’s safe to cache their return values.  However, these functions are very cheap (because
       their return values are precomputed), so caching may not be necessary.

       If two (or more) mappings share the same <u>pmem2_memmove_fn</u>, <u>pmem2_memset_fn</u>, <u>pmem2_memcpy_fn</u> and they  are
       adjacent to each other, it is safe to call these functions for a range spanning those mappings.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/memcpy.3.html">memcpy</a></b>(3),  <b><a href="../man3/memmove.3.html">memmove</a></b>(3), <b><a href="../man3/memset.3.html">memset</a></b>(3), <b><a href="../man3/pmem2_get_drain_fn.3.html">pmem2_get_drain_fn</a></b>(3), <b><a href="../man3/pmem2_get_memcpy_fn.3.html">pmem2_get_memcpy_fn</a></b>(3), <b><a href="../man3/pmem2_get_memset_fn.3.html">pmem2_get_memset_fn</a></b>(3),
       <b><a href="../man3/pmem2_map_new.3.html">pmem2_map_new</a></b>(3), <b><a href="../man3/pmem2_get_persist_fn.3.html">pmem2_get_persist_fn</a></b>(3), <b><a href="../man7/libpmem2.7.html">libpmem2</a></b>(7) and <b>&lt;https://pmem.io&gt;</b>
</pre>
 </div>
</div></section>
</div>
</body>
</html>