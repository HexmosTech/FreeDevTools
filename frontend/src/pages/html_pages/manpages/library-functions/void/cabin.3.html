<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cabin - the utility API of QDBM</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libqdbm-dev">libqdbm-dev_1.8.78-13build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Cabin - the utility API of QDBM

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;cabin.h&gt;</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;</b>

       <b>extern</b> <b>void</b> <b>(*cbfatalfunc)(const</b> <b>char</b> <b>*message);</b>

       <b>void</b> <b>*cbmalloc(size_t</b> <b>size);</b>

       <b>void</b> <b>*cbrealloc(void</b> <b>*ptr,</b> <b>size_t</b> <b>size);</b>

       <b>char</b> <b>*cbmemdup(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>void</b> <b>cbfree(void</b> <b>*ptr);</b>

       <b>void</b> <b>cbglobalgc(void</b> <b>*ptr,</b> <b>void</b> <b>(*func)(void</b> <b>*));</b>

       <b>void</b> <b>cbggcsweep(void);</b>

       <b>int</b> <b>cbvmemavail(size_t</b> <b>size);</b>

       <b>void</b> <b>cbisort(void</b> <b>*base,</b> <b>int</b> <b>nmemb,</b> <b>int</b> <b>size,</b> <b>int(*compar)(const</b> <b>void</b> <b>*,</b> <b>const</b> <b>void</b> <b>*));</b>

       <b>void</b> <b>cbssort(void</b> <b>*base,</b> <b>int</b> <b>nmemb,</b> <b>int</b> <b>size,</b> <b>int(*compar)(const</b> <b>void</b> <b>*,</b> <b>const</b> <b>void</b> <b>*));</b>

       <b>void</b> <b>cbhsort(void</b> <b>*base,</b> <b>int</b> <b>nmemb,</b> <b>int</b> <b>size,</b> <b>int(*compar)(const</b> <b>void</b> <b>*,</b> <b>const</b> <b>void</b> <b>*));</b>

       <b>void</b> <b>cbqsort(void</b> <b>*base,</b> <b>int</b> <b>nmemb,</b> <b>int</b> <b>size,</b> <b>int(*compar)(const</b> <b>void</b> <b>*,</b> <b>const</b> <b>void</b> <b>*));</b>

       <b>int</b> <b>cbstricmp(const</b> <b>char</b> <b>*astr,</b> <b>const</b> <b>char</b> <b>*bstr);</b>

       <b>int</b> <b>cbstrfwmatch(const</b> <b>char</b> <b>*str,</b> <b>const</b> <b>char</b> <b>*key);</b>

       <b>int</b> <b>cbstrfwimatch(const</b> <b>char</b> <b>*str,</b> <b>const</b> <b>char</b> <b>*key);</b>

       <b>int</b> <b>cbstrbwmatch(const</b> <b>char</b> <b>*str,</b> <b>const</b> <b>char</b> <b>*key);</b>

       <b>int</b> <b>cbstrbwimatch(const</b> <b>char</b> <b>*str,</b> <b>const</b> <b>char</b> <b>*key);</b>

       <b>char</b> <b>*cbstrstrkmp(const</b> <b>char</b> <b>*haystack,</b> <b>const</b> <b>char</b> <b>*needle);</b>

       <b>char</b> <b>*cbstrstrbm(const</b> <b>char</b> <b>*haystack,</b> <b>const</b> <b>char</b> <b>*needle);</b>

       <b>char</b> <b>*cbstrtoupper(char</b> <b>*str);</b>

       <b>char</b> <b>*cbstrtolower(char</b> <b>*str);</b>

       <b>char</b> <b>*cbstrtrim(char</b> <b>*str);</b>

       <b>char</b> <b>*cbstrsqzspc(char</b> <b>*str);</b>

       <b>int</b> <b>cbstrcountutf(const</b> <b>char</b> <b>*str);</b>

       <b>char</b> <b>*cbstrcututf(char</b> <b>*str,</b> <b>int</b> <b>num);</b>

       <b>CBDATUM</b> <b>*cbdatumopen(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>CBDATUM</b> <b>*cbdatumdup(const</b> <b>CBDATUM</b> <b>*datum);</b>

       <b>void</b> <b>cbdatumclose(CBDATUM</b> <b>*datum);</b>

       <b>void</b> <b>cbdatumcat(CBDATUM</b> <b>*datum,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>const</b> <b>char</b> <b>*cbdatumptr(const</b> <b>CBDATUM</b> <b>*datum);</b>

       <b>int</b> <b>cbdatumsize(const</b> <b>CBDATUM</b> <b>*datum);</b>

       <b>void</b> <b>cbdatumsetsize(CBDATUM</b> <b>*datum,</b> <b>int</b> <b>size);</b>

       <b>void</b> <b>cbdatumprintf(CBDATUM</b> <b>*datum,</b> <b>const</b> <b>char</b> <b>*format,</b> <b>...);</b>

       <b>char</b> <b>*cbdatumtomalloc(CBDATUM</b> <b>*datum,</b> <b>int</b> <b>*sp);</b>

       <b>CBLIST</b> <b>*cblistopen(void);</b>

       <b>CBLIST</b> <b>*cblistdup(const</b> <b>CBLIST</b> <b>*list);</b>

       <b>void</b> <b>cblistclose(CBLIST</b> <b>*list);</b>

       <b>int</b> <b>cblistnum(const</b> <b>CBLIST</b> <b>*list);</b>

       <b>const</b> <b>char</b> <b>*cblistval(const</b> <b>CBLIST</b> <b>*list,</b> <b>int</b> <b>index,</b> <b>int</b> <b>*sp);</b>

       <b>void</b> <b>cblistpush(CBLIST</b> <b>*list,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>char</b> <b>*cblistpop(CBLIST</b> <b>*list,</b> <b>int</b> <b>*sp);</b>

       <b>void</b> <b>cblistunshift(CBLIST</b> <b>*list,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>char</b> <b>*cblistshift(CBLIST</b> <b>*list,</b> <b>int</b> <b>*sp);</b>

       <b>void</b> <b>cblistinsert(CBLIST</b> <b>*list,</b> <b>int</b> <b>index,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>char</b> <b>*cblistremove(CBLIST</b> <b>*list,</b> <b>int</b> <b>index,</b> <b>int</b> <b>*sp);</b>

       <b>void</b> <b>cblistover(CBLIST</b> <b>*list,</b> <b>int</b> <b>index,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>void</b> <b>cblistsort(CBLIST</b> <b>*list);</b>

       <b>int</b> <b>cblistlsearch(const</b> <b>CBLIST</b> <b>*list,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>int</b> <b>cblistbsearch(const</b> <b>CBLIST</b> <b>*list,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>char</b> <b>*cblistdump(const</b> <b>CBLIST</b> <b>*list,</b> <b>int</b> <b>*sp);</b>

       <b>CBLIST</b> <b>*cblistload(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>CBMAP</b> <b>*cbmapopen(void);</b>

       <b>CBMAP</b> <b>*cbmapdup(CBMAP</b> <b>*map);</b>

       <b>void</b> <b>cbmapclose(CBMAP</b> <b>*map);</b>

       <b>int</b> <b>cbmapput(CBMAP</b> <b>*map,</b> <b>const</b> <b>char</b> <b>*kbuf,</b> <b>int</b> <b>ksiz,</b> <b>const</b> <b>char</b> <b>*vbuf,</b> <b>int</b> <b>vsiz,</b> <b>int</b> <b>over);</b>

       <b>void</b> <b>cbmapputcat(CBMAP</b> <b>*map,</b> <b>const</b> <b>char</b> <b>*kbuf,</b> <b>int</b> <b>ksiz,</b> <b>const</b> <b>char</b> <b>*vbuf,</b> <b>int</b> <b>vsiz);</b>

       <b>int</b> <b>cbmapout(CBMAP</b> <b>*map,</b> <b>const</b> <b>char</b> <b>*kbuf,</b> <b>int</b> <b>ksiz);</b>

       <b>const</b> <b>char</b> <b>*cbmapget(const</b> <b>CBMAP</b> <b>*map,</b> <b>const</b> <b>char</b> <b>*kbuf,</b> <b>int</b> <b>ksiz,</b> <b>int</b> <b>*sp);</b>

       <b>int</b> <b>cbmapmove(CBMAP</b> <b>*map,</b> <b>const</b> <b>char</b> <b>*kbuf,</b> <b>int</b> <b>ksiz,</b> <b>int</b> <b>head);</b>

       <b>void</b> <b>cbmapiterinit(CBMAP</b> <b>*map);</b>

       <b>const</b> <b>char</b> <b>*cbmapiternext(CBMAP</b> <b>*map,</b> <b>int</b> <b>*sp);</b>

       <b>const</b> <b>char</b> <b>*cbmapiterval(const</b> <b>char</b> <b>*kbuf,</b> <b>int</b> <b>*sp);</b>

       <b>int</b> <b>cbmaprnum(const</b> <b>CBMAP</b> <b>*map);</b>

       <b>CBLIST</b> <b>*cbmapkeys(CBMAP</b> <b>*map);</b>

       <b>CBLIST</b> <b>*cbmapvals(CBMAP</b> <b>*map);</b>

       <b>char</b> <b>*cbmapdump(const</b> <b>CBMAP</b> <b>*map,</b> <b>int</b> <b>*sp);</b>

       <b>CBMAP</b> <b>*cbmapload(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>char</b> <b>*cbmaploadone(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>const</b> <b>char</b> <b>*kbuf,</b> <b>int</b> <b>ksiz,</b> <b>int</b> <b>*sp);</b>

       <b>CBHEAP</b> <b>*cbheapopen(int</b> <b>size,</b> <b>int</b> <b>max,</b> <b>int(*compar)(const</b> <b>void</b> <b>*,</b> <b>const</b> <b>void</b> <b>*));</b>

       <b>CBHEAP</b> <b>*cbheapdup(CBHEAP</b> <b>*heap);</b>

       <b>void</b> <b>cbheapclose(CBHEAP</b> <b>*heap);</b>

       <b>int</b> <b>cbheapnum(CBHEAP</b> <b>*heap);</b>

       <b>int</b> <b>cbheapinsert(CBHEAP</b> <b>*heap,</b> <b>const</b> <b>void</b> <b>*ptr);</b>

       <b>void</b> <b>*cbheapval(CBHEAP</b> <b>*heap,</b> <b>int</b> <b>index);</b>

       <b>void</b> <b>*cbheaptomalloc(CBHEAP</b> <b>*heap,</b> <b>int</b> <b>*np);</b>

       <b>char</b> <b>*cbsprintf(const</b> <b>char</b> <b>*format,</b> <b>...);</b>

       <b>char</b> <b>*cbreplace(const</b> <b>char</b> <b>*str,</b> <b>CBMAP</b> <b>*pairs);</b>

       <b>CBLIST</b> <b>*cbsplit(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>const</b> <b>char</b> <b>*delim);</b>

       <b>char</b> <b>*cbreadfile(const</b> <b>char</b> <b>*name,</b> <b>int</b> <b>*sp);</b>

       <b>int</b> <b>cbwritefile(const</b> <b>char</b> <b>*name,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>CBLIST</b> <b>*cbreadlines(const</b> <b>char</b> <b>*name);</b>

       <b>CBLIST</b> <b>*cbdirlist(const</b> <b>char</b> <b>*name);</b>

       <b>int</b> <b>cbfilestat(const</b> <b>char</b> <b>*name,</b> <b>int</b> <b>*isdirp,</b> <b>int</b> <b>*sizep,</b> <b>time_t</b> <b>*mtimep);</b>

       <b>int</b> <b>cbremove(const</b> <b>char</b> <b>*name);</b>

       <b>CBMAP</b> <b>*cburlbreak(const</b> <b>char</b> <b>*str);</b>

       <b>char</b> <b>*cburlresolve(const</b> <b>char</b> <b>*base,</b> <b>const</b> <b>char</b> <b>*target);</b>

       <b>char</b> <b>*cburlencode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>char</b> <b>*cburldecode(const</b> <b>char</b> <b>*str,</b> <b>int</b> <b>*sp);</b>

       <b>char</b> <b>*cbbaseencode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>char</b> <b>*cbbasedecode(const</b> <b>char</b> <b>*str,</b> <b>int</b> <b>*sp);</b>

       <b>char</b> <b>*cbquoteencode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>char</b> <b>*cbquotedecode(const</b> <b>char</b> <b>*str,</b> <b>int</b> <b>*sp);</b>

       <b>char</b> <b>*cbmimebreak(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>CBMAP</b> <b>*attrs,</b> <b>int</b> <b>*sp);</b>

       <b>CBLIST</b> <b>*cbmimeparts(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>const</b> <b>char</b> <b>*boundary);</b>

       <b>char</b> <b>*cbmimeencode(const</b> <b>char</b> <b>*str,</b> <b>const</b> <b>char</b> <b>*encname,</b> <b>int</b> <b>base);</b>

       <b>char</b> <b>*cbmimedecode(const</b> <b>char</b> <b>*str,</b> <b>char</b> <b>*enp);</b>

       <b>CBLIST</b> <b>*cbcsvrows(const</b> <b>char</b> <b>*str);</b>

       <b>CBLIST</b> <b>*cbcsvcells(const</b> <b>char</b> <b>*str);</b>

       <b>char</b> <b>*cbcsvescape(const</b> <b>char</b> <b>*str);</b>

       <b>char</b> <b>*cbcsvunescape(const</b> <b>char</b> <b>*str);</b>

       <b>CBLIST</b> <b>*cbxmlbreak(const</b> <b>char</b> <b>*str,</b> <b>int</b> <b>cr);</b>

       <b>CBMAP</b> <b>*cbxmlattrs(const</b> <b>char</b> <b>*str);</b>

       <b>char</b> <b>*cbxmlescape(const</b> <b>char</b> <b>*str);</b>

       <b>char</b> <b>*cbxmlunescape(const</b> <b>char</b> <b>*str);</b>

       <b>char</b> <b>*cbdeflate(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>

       <b>char</b> <b>*cbinflate(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>

       <b>char</b> <b>*cbgzencode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>

       <b>char</b> <b>*cbgzdecode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>

       <b>unsigned</b> <b>int</b> <b>cbgetcrc(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>char</b> <b>*cblzoencode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>

       <b>char</b> <b>*cblzodecode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>

       <b>char</b> <b>*cbbzencode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>

       <b>char</b> <b>*cbbzdecode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>

       <b>char</b> <b>*cbiconv(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>const</b> <b>char</b> <b>*icode,</b> <b>const</b> <b>char</b> <b>*ocode,</b> <b>int</b> <b>*sp,</b> <b>int</b> <b>*mp);</b>

       <b>const</b> <b>char</b> <b>*cbencname(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>

       <b>int</b> <b>cbjetlag(void);</b>

       <b>void</b> <b>cbcalendar(time_t</b> <b>t,</b> <b>int</b> <b>jl,</b> <b>int</b> <b>*yearp,</b> <b>int</b> <b>*monp,</b> <b>int</b> <b>*dayp,</b> <b>int</b> <b>*hourp,</b> <b>int</b> <b>*minp,</b> <b>int</b> <b>*secp);</b>

       <b>int</b> <b>cbdayofweek(int</b> <b>year,</b> <b>int</b> <b>mon,</b> <b>int</b> <b>day);</b>

       <b>char</b> <b>*cbdatestrwww(time_t</b> <b>t,</b> <b>int</b> <b>jl);</b>

       <b>char</b> <b>*cbdatestrhttp(time_t</b> <b>t,</b> <b>int</b> <b>jl);</b>

       <b>time_t</b> <b>cbstrmktime(const</b> <b>char</b> <b>*str);</b>

       <b>void</b> <b>cbproctime(double</b> <b>*usrp,</b> <b>double</b> <b>*sysp);</b>

       <b>void</b> <b>cbstdiobin(void);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Cabin is the utility API which provides memory allocating functions, sorting functions, extensible datum,
       array  list,  hash  map,  heap array, and so on for handling records easily on memory.  This API features
       also parsing MIME, CSV, and XML, and features various types of encoding and decoding.

       In order to use Cabin, you should include `cabin.h' and `stdlib.h' in the  source  files.   Usually,  the
       following description will be near the beginning of a source file.

              <b>#include</b> <b>&lt;cabin.h&gt;</b>
              <b>#include</b> <b>&lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;</b>

       A  pointer  to  `CBDATUM'  is used as a handle of an extensible datum.  A datum handle is opened with the
       function `cbdatumopen' and closed with `cbdatumclose'.  A pointer to `CBLIST' is used as a handle  of  an
       array  list.   A  list  handle is opened with the function `cblistopen' and closed with `cblistclose'.  A
       pointer to `CBMAP' is used as a handle of a  hash  map.   A  map  handle  is  opened  with  the  function
       `cbmapopen'  and closed with `cbmapclose'.  A pointer to `CBHEAP' is used as a handle of a heap array.  A
       heap handle is opened with the function `cbheapopen' and closed with `cbheapclose'.  You should not refer
       directly to any member of each handles.

       The external variable `cbfatalfunc' is the pointer to call back function for handling a fatal error.

       <b>extern</b> <b>void</b> <b>(*cbfatalfunc)(const</b> <b>char</b> <b>*message);</b>
              The argument specifies the error message.  The initial value of this variable is `NULL'.   If  the
              value  is  `NULL', the default function is called when a fatal error occurs.  A fatal error occurs
              when memory allocation is failed.

       The function `cbmalloc' is used in order to allocate a region on memory.

       <b>void</b> <b>*cbmalloc(size_t</b> <b>size);</b>
              `size' specifies the size of the region.  The return value is the pointer to the allocated region.
              Because the region of the return value is allocated with the `malloc' call, it should be  released
              with the `free' call if it is no longer in use.

       The function `cbrealloc' is used in order to re-allocate a region on memory.

       <b>void</b> <b>*cbrealloc(void</b> <b>*ptr,</b> <b>size_t</b> <b>size);</b>
              `ptr'  specifies  the  pointer  to a region.  `size' specifies the size of the region.  The return
              value is the pointer to the re-allocated region.  Because  the  region  of  the  return  value  is
              allocated with the `malloc' call, it should be released with the `free' call if it is no longer in
              use.

       The function `cbmemdup' is used in order to duplicate a region on memory.

       <b>char</b> <b>*cbmemdup(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `ptr'  specifies  the  pointer  to  a  region.  `size' specifies the size of the region.  If it is
              negative, the size is assigned with `strlen(ptr)'.   The  return  value  is  the  pointer  to  the
              allocated  region of the duplicate.  Because an additional zero code is appended at the end of the
              region of the return value, the return value can be treated as a character  string.   Because  the
              region  of  the  return  value is allocated with the `malloc' call, it should be released with the
              `free' call if it is no longer in use.

       The function `cbfree' is used in order to free a region on memory.

       <b>void</b> <b>cbfree(void</b> <b>*ptr);</b>
              `ptr' specifies the pointer to a region.  If it is `NULL', this function has no effect.   Although
              this  function  is  just  a  wrapper  of `free' call, this is useful in applications using another
              package of the `malloc' series.

       The function `cbglobalgc' is used in order to register the pointer or handle of an object to  the  global
       garbage collector.

       <b>void</b> <b>cbglobalgc(void</b> <b>*ptr,</b> <b>void</b> <b>(*func)(void</b> <b>*));</b>
              `ptr' specifies the pointer or handle of an object.  `func' specifies the pointer to a function to
              release  resources of the object.  Its argument is the pointer or handle of the object to release.
              This function assures that resources of an object are released when the process exits normally  by
              returning from the `main' function or calling the `exit' function.

       The function `cbggcsweep' is used in order to exercise the global garbage collector explicitly.

       <b>void</b> <b>cbggcsweep(void);</b>
              Note  that  you should not use objects registered to the global garbage collector any longer after
              calling this function.  Because the global garbage collector is initialized and you  can  register
              new objects into it.

       The function `cbvmemavail' is used in order to check availability of allocation of the virtual memory.

       <b>int</b> <b>cbvmemavail(size_t</b> <b>size);</b>
              `size' specifies the size of region to be allocated newly.  The return value is true if allocation
              should be success, or false if not.

       The function `cbisort' is used in order to sort an array using insert sort.

       <b>void</b> <b>cbisort(void</b> <b>*base,</b> <b>int</b> <b>nmemb,</b> <b>int</b> <b>size,</b> <b>int(*compar)(const</b> <b>void</b> <b>*,</b> <b>const</b> <b>void</b> <b>*));</b>
              `base'  specifies the pointer to an array.  `nmemb' specifies the number of elements of the array.
              `size' specifies the size of each element.  `compar' specifies the pointer to comparing  function.
              The  two  arguments  specify  the  pointers  of  elements.   The comparing function should returns
              positive if the former is big, negative if the latter is big, 0 if both are equal.  Insert sort is
              useful only if most elements have been sorted already.

       The function `cbssort' is used in order to sort an array using shell sort.

       <b>void</b> <b>cbssort(void</b> <b>*base,</b> <b>int</b> <b>nmemb,</b> <b>int</b> <b>size,</b> <b>int(*compar)(const</b> <b>void</b> <b>*,</b> <b>const</b> <b>void</b> <b>*));</b>
              `base' specifies the pointer to an array.  `nmemb' specifies the number of elements of the  array.
              `size'  specifies the size of each element.  `compar' specifies the pointer to comparing function.
              The two arguments specify the  pointers  of  elements.   The  comparing  function  should  returns
              positive  if  the  former  is  big,  negative  if the latter is big, 0 if both are equal.  If most
              elements have been sorted, shell sort may be faster than heap sort or quick sort.

       The function `cbhsort' is used in order to sort an array using heap sort.

       <b>void</b> <b>cbhsort(void</b> <b>*base,</b> <b>int</b> <b>nmemb,</b> <b>int</b> <b>size,</b> <b>int(*compar)(const</b> <b>void</b> <b>*,</b> <b>const</b> <b>void</b> <b>*));</b>
              `base' specifies the pointer to an array.  `nmemb' specifies the number of elements of the  array.
              `size'  specifies  the size of each element. `compar' specifies the pointer to comparing function.
              The two arguments specify the  pointers  of  elements.   The  comparing  function  should  returns
              positive  if the former is big, negative if the latter is big, 0 if both are equal.  Although heap
              sort is robust against bias of input, quick sort is faster in most cases.

       The function `cbqsort' is used in order to sort an array using quick sort.

       <b>void</b> <b>cbqsort(void</b> <b>*base,</b> <b>int</b> <b>nmemb,</b> <b>int</b> <b>size,</b> <b>int(*compar)(const</b> <b>void</b> <b>*,</b> <b>const</b> <b>void</b> <b>*));</b>
              `base' specifies the pointer to an array.  `nmemb' specifies the number of elements of the  array.
              `size'  specifies  the size of each element. `compar' specifies the pointer to comparing function.
              The two arguments specify the  pointers  of  elements.   The  comparing  function  should  returns
              positive  if  the  former  is  big,  negative  if  the  latter is big, 0 if both are equal.  Being
              sensitive to bias of input, quick sort is the fastest sorting algorithm.

       The function `cbstricmp' is used in order to compare two strings with case insensitive evaluation.

       <b>int</b> <b>cbstricmp(const</b> <b>char</b> <b>*astr,</b> <b>const</b> <b>char</b> <b>*bstr);</b>
              `astr' specifies the pointer of one string.  `astr' specifies the pointer  of  the  other  string.
              The  return  value  is positive if the former is big, negative if the latter is big, 0 if both are
              equivalent.  Upper cases and lower cases of alphabets in ASCII code are not distinguished.

       The function `cbstrfwmatch' is used in order to check whether a string begins with a key.

       <b>int</b> <b>cbstrfwmatch(const</b> <b>char</b> <b>*str,</b> <b>const</b> <b>char</b> <b>*key);</b>
              `str' specifies the pointer of a target string.  `key' specifies the pointer of a forward matching
              key string.  The return value is true if the target string begins with the key, else, it is false.

       The function `cbstrfwimatch' is used in order to check whether a string begins  with  a  key,  with  case
       insensitive evaluation.

       <b>int</b> <b>cbstrfwimatch(const</b> <b>char</b> <b>*str,</b> <b>const</b> <b>char</b> <b>*key);</b>
              `str' specifies the pointer of a target string.  `key' specifies the pointer of a forward matching
              key string.  The return value is true if the target string begins with the key, else, it is false.
              Upper cases and lower cases of alphabets in ASCII code are not distinguished.

       The function `cbstrbwmatch' is used in order to check whether a string ends with a key.

       <b>int</b> <b>cbstrbwmatch(const</b> <b>char</b> <b>*str,</b> <b>const</b> <b>char</b> <b>*key);</b>
              `str'  specifies  the  pointer  of  a  target  string.   `key' specifies the pointer of a backward
              matching key string.  The return value is true if the target string ends with the key, else, it is
              false.

       The function `cbstrbwimatch' is used in order to check whether a  string  ends  with  a  key,  with  case
       insensitive evaluation.

       <b>int</b> <b>cbstrbwimatch(const</b> <b>char</b> <b>*str,</b> <b>const</b> <b>char</b> <b>*key);</b>
              `str'  specifies  the  pointer  of  a  target  string.   `key' specifies the pointer of a backward
              matching key string.  The return value is true if the target string ends with the key, else, it is
              false.  Upper cases and lower cases of alphabets in ASCII code are not distinguished.

       The function `cbstrstrkmp' is used in order to locate a substring in a string using KMP method.

       <b>char</b> <b>*cbstrstrkmp(const</b> <b>char</b> <b>*haystack,</b> <b>const</b> <b>char</b> <b>*needle);</b>
              `haystack' specifies the pointer of  a  target  string.   `needle'  specifies  the  pointer  of  a
              substring  to  be  found.   The  return  value is the pointer to the beginning of the substring or
              `NULL' if the substring is not found.  In most cases, `strstr'  as  a  built-in  function  of  the
              compiler is faster than this function.

       The function `cbstrstrkmp' is used in order to locate a substring in a string using BM method.

       <b>char</b> <b>*cbstrstrbm(const</b> <b>char</b> <b>*haystack,</b> <b>const</b> <b>char</b> <b>*needle);</b>
              `haystack'  specifies  the  pointer  of  a  target  string.   `needle'  specifies the pointer of a
              substring to be found.  The return value is the pointer to  the  beginning  of  the  substring  or
              `NULL'  if  the  substring  is  not  found.  In most cases, `strstr' as a built-in function of the
              compiler is faster than this function.

       The function `cbstrtoupper' is used in order to convert the letters of a string to upper case.

       <b>char</b> <b>*cbstrtoupper(char</b> <b>*str);</b>
              `str' specifies the pointer of a string to convert.  The  return  value  is  the  pointer  to  the
              string.

       The function `cbstrtolower' is used in order to convert the letters of a string to lower case.

       <b>char</b> <b>*cbstrtolower(char</b> <b>*str);</b>
              `str'  specifies  the  pointer  of  a  string  to convert.  The return value is the pointer to the
              string.

       The function `cbstrtrim' is used in order to cut space characters at head or tail of a string.

       <b>char</b> <b>*cbstrtrim(char</b> <b>*str);</b>
              `str' specifies the pointer of a string to convert.  The  return  value  is  the  pointer  to  the
              string.

       The function `cbstrsqzspc' is used in order to squeeze space characters in a string and trim it.

       <b>char</b> <b>*cbstrsqzspc(char</b> <b>*str);</b>
              `str'  specifies  the  pointer  of  a  string  to convert.  The return value is the pointer to the
              string.

       The function `cbstrcountutf' is used in order to count the number of characters in a string of UTF-8.

       <b>int</b> <b>cbstrcountutf(const</b> <b>char</b> <b>*str);</b>
              `str' specifies the pointer of a string of UTF-8.  The return value is the number of characters in
              the string.

       The function `cbstrcututf' is used in order to  cut  a  string  of  UTF-8  at  the  specified  number  of
       characters.

       <b>char</b> <b>*cbstrcututf(char</b> <b>*str,</b> <b>int</b> <b>num);</b>
              `str'  specifies the pointer of a string of UTF-8.  `num' specifies the number of characters to be
              kept.  The return value is the pointer to the string.

       The function `cbdatumopen' is used in order to get a datum handle.

       <b>CBDATUM</b> <b>*cbdatumopen(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `ptr' specifies the pointer to the region of the initial content.  If it is `NULL', an empty datum
              is created.  `size' specifies the size of the region.  If it is negative,  the  size  is  assigned
              with `strlen(ptr)'.  The return value is a datum handle.

       The function `cbdatumdup' is used in order to copy a datum.

       <b>CBDATUM</b> <b>*cbdatumdup(const</b> <b>CBDATUM</b> <b>*datum);</b>
              `datum' specifies a datum handle.  The return value is a new datum handle.

       The function `cbdatumclose' is used in order to free a datum handle.

       <b>void</b> <b>cbdatumclose(CBDATUM</b> <b>*datum);</b>
              `datum'  specifies  a datum handle.  Because the region of a closed handle is released, it becomes
              impossible to use the handle.

       The function `cbdatumcat' is used in order to concatenate a datum and a region.

       <b>void</b> <b>cbdatumcat(CBDATUM</b> <b>*datum,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `datum' specifies a datum handle.  `ptr' specifies the pointer  to  the  region  to  be  appended.
              `size'  specifies  the  size  of  the  region.   If  it  is  negative,  the  size is assigned with
              `strlen(ptr)'.

       The function `cbdatumptr' is used in order to get the pointer of the region of a datum.

       <b>const</b> <b>char</b> <b>*cbdatumptr(const</b> <b>CBDATUM</b> <b>*datum);</b>
              `datum' specifies a datum handle.  The return value is the pointer  of  the  region  of  a  datum.
              Because  an  additional  zero  code  is appended at the end of the region of the return value, the
              return value can be treated as a character string.

       The function `cbdatumsize' is used in order to get the size of the region of a datum.

       <b>int</b> <b>cbdatumsize(const</b> <b>CBDATUM</b> <b>*datum);</b>
              `datum' specifies a datum handle.  The return value is the size of the region of a datum.

       The function `cbdatumsetsize' is used in order to change the size of the region of a datum.

       <b>void</b> <b>cbdatumsetsize(CBDATUM</b> <b>*datum,</b> <b>int</b> <b>size);</b>
              `datum' specifies a datum handle.  `size' specifies the new size of the region.  If the  new  size
              is bigger than the one of old, the surplus region is filled with zero codes.

       The function `cbdatumprintf' is used in order to perform formatted output into a datum.

       <b>void</b> <b>cbdatumprintf(CBDATUM</b> <b>*datum,</b> <b>const</b> <b>char</b> <b>*format,</b> <b>...);</b>
              `format'  specifies  a  printf-like  format string.  The conversion character `%' can be used with
              such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', `@', `?', `:',
              `%'.  `@' works as with `s' but escapes meta characters of XML.  `?' works as with `s' but escapes
              meta characters of URL.  `:' works as with `s' but performs MIME encoding  as  UTF-8.   The  other
              conversion character work as with each original.

       The function `cbdatumtomalloc' is used in order to convert a datum to an allocated region.

       <b>char</b> <b>*cbdatumtomalloc(CBDATUM</b> <b>*datum,</b> <b>int</b> <b>*sp);</b>
              `datum'  specifies  a datum handle.  `sp' specifies the pointer to a variable to which the size of
              the region of the return value is assigned.  If it is `NULL', it is not used.  The return value is
              the pointer to the region of the datum.  Because an additional zero code is appended at the end of
              the region of the return value, the return value can be treated as a  character  string.   Because
              the region of the return value is allocated with the `malloc' call, it should be released with the
              `free'  call  if it is no longer in use.  Because the region of the original datum is released, it
              should not be released again.

       The function `cblistopen' is used in order to get a list handle.

       <b>CBLIST</b> <b>*cblistopen(void);</b>
              The return value is a list handle.

       The function `cblistdup' is used in order to copy a list.

       <b>CBLIST</b> <b>*cblistdup(const</b> <b>CBLIST</b> <b>*list);</b>
              `list' specifies a list handle.  The return value is a new list handle.

       The function `cblistclose' is used in order to close a list handle.

       <b>void</b> <b>cblistclose(CBLIST</b> <b>*list);</b>
              `list' specifies a list handle.  Because the region of a closed handle  is  released,  it  becomes
              impossible to use the handle.

       The function `cblistnum' is used in order to get the number of elements of a list.

       <b>int</b> <b>cblistnum(const</b> <b>CBLIST</b> <b>*list);</b>
              `list' specifies a list handle.  The return value is the number of elements of the list.

       The function `cblistval' is used in order to get the pointer to the region of an element of a list.

       <b>const</b> <b>char</b> <b>*cblistval(const</b> <b>CBLIST</b> <b>*list,</b> <b>int</b> <b>index,</b> <b>int</b> <b>*sp);</b>
              `list'  specifies  a  list handle.  `index' specifies the index of an element.  `sp' specifies the
              pointer to a variable to which the size of the region of the return value is assigned.  If  it  is
              `NULL', it is not used.  The return value is the pointer to the region of the element.  Because an
              additional  zero  code  is appended at the end of the region of the return value, the return value
              can be treated as a character string.  If `index' is equal to or more than the number of elements,
              the return value is `NULL'.

       The function `cblistpush' is used in order to add an element at the end of a list.

       <b>void</b> <b>cblistpush(CBLIST</b> <b>*list,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `list' specifies a list handle.  `ptr' specifies the pointer to the region of an element.   `size'
              specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.

       The function `cblistpop' is used in order to remove an element of the end of a list.

       <b>char</b> <b>*cblistpop(CBLIST</b> <b>*list,</b> <b>int</b> <b>*sp);</b>
              `list' specifies a list handle.  `sp' specifies the pointer to a variable to which the size of the
              region of the return value is assigned.  If it is `NULL', it is not used.  The return value is the
              pointer to the region of the value.  Because an additional zero code is appended at the end of the
              region  of  the  return value, the return value can be treated as a character string.  Because the
              region of the return value is allocated with the `malloc' call, it should  be  released  with  the
              `free' call if it is no longer in use.  If the list is empty, the return value is `NULL'.

       The function `cblistunshift' is used in order to add an element at the top of a list.

       <b>void</b> <b>cblistunshift(CBLIST</b> <b>*list,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `list'  specifies a list handle.  `ptr' specifies the pointer to the region of an element.  `size'
              specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.

       The function `cblistshift' is used in order to remove an element of the top of a list.

       <b>char</b> <b>*cblistshift(CBLIST</b> <b>*list,</b> <b>int</b> <b>*sp);</b>
              `list' specifies a list handle.  `sp' specifies the pointer to a variable to which the size of the
              region of the return value is assigned.  If it is `NULL', it is not used.  The return value is the
              pointer to the region of the value.  Because an additional zero code is appended at the end of the
              region of the return value, the return value can be treated as a character  string.   Because  the
              region  of  the  return  value is allocated with the `malloc' call, it should be released with the
              `free' call if it is no longer in use.  If the list is empty, the return value is `NULL'.

       The function `cblistinsert' is used in order to add an element at the specified location of a list.

       <b>void</b> <b>cblistinsert(CBLIST</b> <b>*list,</b> <b>int</b> <b>index,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `list' specifies a list handle.  `index' specifies the index of an element.  `ptr'  specifies  the
              pointer  to  the  region  of  the  element.   `size'  specifies  the size of the region.  If it is
              negative, the size is assigned with `strlen(ptr)'.

       The function `cblistremove' is used in order to remove an element at the specified location of a list.

       <b>char</b> <b>*cblistremove(CBLIST</b> <b>*list,</b> <b>int</b> <b>index,</b> <b>int</b> <b>*sp);</b>
              `list' specifies a list handle.  `index' specifies the index of an element.   `sp'  specifies  the
              pointer  to  a variable to which the size of the region of the return value is assigned.  If it is
              `NULL', it is not used.  The return value is the pointer to the region of the value.   Because  an
              additional  zero  code  is appended at the end of the region of the return value, the return value
              can be treated as a character string.  Because the region of the return value  is  allocated  with
              the  `malloc'  call,  it  should  be  released with the `free' call if it is no longer in use.  If
              `index' is equal to or more than the number of elements, no element  is  removed  and  the  return
              value is `NULL'.

       The function `cblistover' is used in order to overwrite an element at the specified location of a list.

       <b>void</b> <b>cblistover(CBLIST</b> <b>*list,</b> <b>int</b> <b>index,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `list'  specifies  a list handle.  `index' specifies the index of an element.  `ptr' specifies the
              pointer to the region of the new content.  `size' specifies the size of the new content.  If it is
              negative, the size is assigned with `strlen(ptr)'.  If `index' is equal to or more than the number
              of elements, this function has no effect.

       The function `cblistsort' is used in order to sort elements of a list in lexical order.

       <b>void</b> <b>cblistsort(CBLIST</b> <b>*list);</b>
              `list' specifies a list handle.  Quick sort is used for sorting.

       The function `cblistlsearch' is used in order to search a list for an element using liner search.

       <b>int</b> <b>cblistlsearch(const</b> <b>CBLIST</b> <b>*list,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `list' specifies a list handle.  `ptr' specifies the pointer to  the  region  of  a  key.   `size'
              specifies  the  size  of  the region.  If it is negative, the size is assigned with `strlen(ptr)'.
              The return value is the index of a corresponding element  or  -1  if  there  is  no  corresponding
              element.  If two or more elements corresponds, the former returns.

       The function `cblistbsearch' is used in order to search a list for an element using binary search.

       <b>int</b> <b>cblistbsearch(const</b> <b>CBLIST</b> <b>*list,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `list'  specifies  a  list  handle.   It  should  be sorted in lexical order.  `ptr' specifies the
              pointer to the region of a key.  `size' specifies the size of the region.  If it is negative,  the
              size  is assigned with `strlen(ptr)'.  The return value is the index of a corresponding element or
              -1 if there is no corresponding element.  If two or more elements corresponds,  which  returns  is
              not defined.

       The function `cblistdump' is used in order to serialize a list into a byte array.

       <b>char</b> <b>*cblistdump(const</b> <b>CBLIST</b> <b>*list,</b> <b>int</b> <b>*sp);</b>
              `list' specifies a list handle.  `sp' specifies the pointer to a variable to which the size of the
              region  of  the  return  value  is assigned.  The return value is the pointer to the region of the
              result serial region.  Because the region of the return value is allocated with the `malloc' call,
              it should be released with the `free' call if it is no longer in use.

       The function `cblistload' is used in order to redintegrate a serialized list.

       <b>CBLIST</b> <b>*cblistload(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `ptr' specifies the pointer to a byte array.  `size' specifies the size of the region.  The return
              value is a new list handle.

       The function `cbmapopen' is used in order to get a map handle.

       <b>CBMAP</b> <b>*cbmapopen(void);</b>
              The return value is a map handle.

       The function `cbmapdup' is used in order to copy a map.

       <b>CBMAP</b> <b>*cbmapdup(CBMAP</b> <b>*map);</b>
              `map' specifies a map handle.  The return value is a new map handle.  The iterator of  the  source
              map is initialized.

       The function `cbmapclose' is used in order to close a map handle.

       <b>void</b> <b>cbmapclose(CBMAP</b> <b>*map);</b>
              `map'  specifies  a  map  handle.   Because  the region of a closed handle is released, it becomes
              impossible to use the handle.

       The function `cbmapput' is used in order to store a record into a map.

       <b>int</b> <b>cbmapput(CBMAP</b> <b>*map,</b> <b>const</b> <b>char</b> <b>*kbuf,</b> <b>int</b> <b>ksiz,</b> <b>const</b> <b>char</b> <b>*vbuf,</b> <b>int</b> <b>vsiz,</b> <b>int</b> <b>over);</b>
              `map' specifies a map handle.  `kbuf' specifies the pointer  to  the  region  of  a  key.   `ksiz'
              specifies  the  size  of  the  region  of  the  key.  If it is negative, the size is assigned with
              `strlen(kbuf)'.  `vbuf' specifies the pointer to the region of a value.  `vsiz' specifies the size
              of the region of the value.  If it is negative, the size is assigned with `strlen(vbuf)'.   `over'
              specifies  whether  the  value of the duplicated record is overwritten or not.  If `over' is false
              and the key is duplicated, the return value is false, else, it is true.

       The function `cbmapputcat' is used in order to concatenate a value  at  the  end  of  the  value  of  the
       existing record.

       <b>void</b> <b>cbmapputcat(CBMAP</b> <b>*map,</b> <b>const</b> <b>char</b> <b>*kbuf,</b> <b>int</b> <b>ksiz,</b> <b>const</b> <b>char</b> <b>*vbuf,</b> <b>int</b> <b>vsiz);</b>
              `map'  specifies  a  map  handle.   `kbuf'  specifies  the pointer to the region of a key.  `ksiz'
              specifies the size of the region of the key.  If  it  is  negative,  the  size  is  assigned  with
              `strlen(kbuf)'.  `vbuf' specifies the pointer to the region of a value.  `vsiz' specifies the size
              of  the  region  of  the  value.  If it is negative, the size is assigned with `strlen(vbuf)'.  If
              there is no corresponding record, a new record is created.

       The function `cbmapout' is used in order to delete a record in a map.

       <b>int</b> <b>cbmapout(CBMAP</b> <b>*map,</b> <b>const</b> <b>char</b> <b>*kbuf,</b> <b>int</b> <b>ksiz);</b>
              `map' specifies a map handle.  `kbuf' specifies the pointer  to  the  region  of  a  key.   `ksiz'
              specifies  the  size  of  the  region  of  the  key.  If it is negative, the size is assigned with
              `strlen(kbuf)'.  If successful, the return value is  true.   False  is  returned  when  no  record
              corresponds to the specified key.

       The function `cbmapget' is used in order to retrieve a record in a map.

       <b>const</b> <b>char</b> <b>*cbmapget(const</b> <b>CBMAP</b> <b>*map,</b> <b>const</b> <b>char</b> <b>*kbuf,</b> <b>int</b> <b>ksiz,</b> <b>int</b> <b>*sp);</b>
              `map'  specifies  a  map  handle.   `kbuf'  specifies  the pointer to the region of a key.  `ksiz'
              specifies the size of the region of the key.  If  it  is  negative,  the  size  is  assigned  with
              `strlen(kbuf)'.   `sp'  specifies the pointer to a variable to which the size of the region of the
              return value is assigned.  If it is `NULL', it is not used.  If successful, the  return  value  is
              the  pointer  to  the region of the value of the corresponding record.  `NULL' is returned when no
              record corresponds.  Because an additional zero code is appended at the end of the region  of  the
              return value, the return value can be treated as a character string.

       The function `cbmapmove' is used in order to move a record to the edge of a map.

       <b>int</b> <b>cbmapmove(CBMAP</b> <b>*map,</b> <b>const</b> <b>char</b> <b>*kbuf,</b> <b>int</b> <b>ksiz,</b> <b>int</b> <b>head);</b>
              `map'  specifies  a  map  handle.   `kbuf'  specifies  the pointer to the region of a key.  `ksiz'
              specifies the size of the region of the key.  If  it  is  negative,  the  size  is  assigned  with
              `strlen(kbuf)'.  `head' specifies the destination which is head if it is true or tail if else.  If
              successful,  the  return  value  is  true.   False  is  returned when no record corresponds to the
              specified key.

       The function `cbmapiterinit' is used in order to initialize the iterator of a map.

       <b>void</b> <b>cbmapiterinit(CBMAP</b> <b>*map);</b>
              `map' specifies a map handle.  The iterator is used in order to access the  key  of  every  record
              stored in a map.

       The function `cbmapiternext' is used in order to get the next key of the iterator of a map.

       <b>const</b> <b>char</b> <b>*cbmapiternext(CBMAP</b> <b>*map,</b> <b>int</b> <b>*sp);</b>
              `map'  specifies  a map handle.  `sp' specifies the pointer to a variable to which the size of the
              region of the return value is assigned.  If it is `NULL', it is  not  used.   If  successful,  the
              return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned
              when  no  record is to be get out of the iterator.  Because an additional zero code is appended at
              the end of the region of the return value, the return value can be treated as a character  string.
              The order of iteration is assured to be the same of the one of storing.

       The function `cbmapiterval' is used in order to get the value binded to the key fetched from the iterator
       of a map.

       <b>const</b> <b>char</b> <b>*cbmapiterval(const</b> <b>char</b> <b>*kbuf,</b> <b>int</b> <b>*sp);</b>
              `kbuf'  specifies  the  pointer to the region of a iteration key.  `sp' specifies the pointer to a
              variable to which the size of the region of the return value is assigned.  If it is `NULL', it  is
              not used.  The return value is the pointer to the region of the value of the corresponding record.
              Because  an  additional  zero  code  is appended at the end of the region of the return value, the
              return value can be treated as a character string.

       The function `cbmaprnum' is used in order to get the number of the records stored in a map.

       <b>int</b> <b>cbmaprnum(const</b> <b>CBMAP</b> <b>*map);</b>
              `map' specifies a map handle.  The return value is the number of the records stored in the map.

       The function `cbmapkeys' is used in order to get the list handle contains all keys in a map.

       <b>CBLIST</b> <b>*cbmapkeys(CBMAP</b> <b>*map);</b>
              `map' specifies a map handle.  The return value is the list handle contains all keys in  the  map.
              Because  the  handle  of  the  return value is opened with the function `cblistopen', it should be
              closed with the function `cblistclose' if it is no longer in use.

       The function `cbmapvals' is used in order to get the list handle contains all values in a map.

       <b>CBLIST</b> <b>*cbmapvals(CBMAP</b> <b>*map);</b>
              `map' specifies a map handle.  The return value is the list handle contains all values in the map.
              Because the handle of the return value is opened with the  function  `cblistopen',  it  should  be
              closed with the function `cblistclose' if it is no longer in use.

       The function `cbmapdump' is used in order to serialize a map into a byte array.

       <b>char</b> <b>*cbmapdump(const</b> <b>CBMAP</b> <b>*map,</b> <b>int</b> <b>*sp);</b>
              `map'  specifies  a map handle.  `sp' specifies the pointer to a variable to which the size of the
              region of the return value is assigned.  The return value is the pointer  to  the  region  of  the
              result serial region.  Because the region of the return value is allocated with the `malloc' call,
              it should be released with the `free' call if it is no longer in use.

       The function `cbmapload' is used in order to redintegrate a serialized map.

       <b>CBMAP</b> <b>*cbmapload(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `ptr' specifies the pointer to a byte array.  `size' specifies the size of the region.  The return
              value is a new map handle.

       The function `cbmaploadone' is used in order to extract a record from a serialized map.

       <b>char</b> <b>*cbmaploadone(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>const</b> <b>char</b> <b>*kbuf,</b> <b>int</b> <b>ksiz,</b> <b>int</b> <b>*sp);</b>
              `ptr'  specifies  the  pointer  to a byte array.  `size' specifies the size of the region.  `kbuf'
              specifies the pointer to the region of a key.  `ksiz' specifies the size of the region of the key.
              If it is negative, the size is assigned with `strlen(kbuf)'.  `sp'  specifies  the  pointer  to  a
              variable  to which the size of the region of the return value is assigned.  If it is `NULL', it is
              not used.  If successful, the return value is the pointer to  the  region  of  the  value  of  the
              corresponding  record.  `NULL' is returned when no record corresponds.  Because an additional zero
              code is appended at the end of the region of the return value, the return value can be treated  as
              a character string.

       The function `cbheapopen' is used in order to get a heap handle.

       <b>CBHEAP</b> <b>*cbheapopen(int</b> <b>size,</b> <b>int</b> <b>max,</b> <b>int(*compar)(const</b> <b>void</b> <b>*,</b> <b>const</b> <b>void</b> <b>*));</b>
              `size'  specifies  the  size of each record.  `max' specifies the maximum number of records in the
              heap.  `compar' specifies the pointer to  comparing  function.   The  two  arguments  specify  the
              pointers  of  records.   The  comparing  function  should  returns  positive if the former is big,
              negative if the latter is big, 0 if both are equal.  The return value is a heap handle.

       The function `cbheapdup' is used in order to copy a heap.

       <b>CBHEAP</b> <b>*cbheapdup(CBHEAP</b> <b>*heap);</b>
              `heap' specifies a heap handle.  The return value is a new heap handle.

       The function `cbheapclose' is used in order to close a heap handle.

       <b>void</b> <b>cbheapclose(CBHEAP</b> <b>*heap);</b>
              `heap' specifies a heap handle.  Because the region of a closed handle  is  released,  it  becomes
              impossible to use the handle.

       The function `cbheapnum' is used in order to get the number of the records stored in a heap.

       <b>int</b> <b>cbheapnum(CBHEAP</b> <b>*heap);</b>
              `heap' specifies a heap handle.  The return value is the number of the records stored in the heap.

       The function `cbheapinsert' is used in order to insert a record into a heap.

       <b>int</b> <b>cbheapinsert(CBHEAP</b> <b>*heap,</b> <b>const</b> <b>void</b> <b>*ptr);</b>
              `heap'  specifies  a  heap  handle.   `ptr'  specifies the pointer to the region of a record.  The
              return value is true if the record is added, else false.  If the new record  is  bigger  than  the
              biggest  existing  regord, the new record is not added.  If the new record is added and the number
              of records exceeds the maximum number, the biggest existing record is removed.

       The function `cbheapval' is used in order to get the pointer to the region of a record in a heap.

       <b>void</b> <b>*cbheapval(CBHEAP</b> <b>*heap,</b> <b>int</b> <b>index);</b>
              `heap' specifies a heap handle.  `index' specifies the index of a record.  The return value is the
              pointer to the region of the record.  If `index' is equal to or more than the number  of  records,
              the  return  value is `NULL'.  Note that records are organized by the nagative order the comparing
              function.

       The function `cbheaptomalloc' is used in order to convert a heap to an allocated region.

       <b>void</b> <b>*cbheaptomalloc(CBHEAP</b> <b>*heap,</b> <b>int</b> <b>*np);</b>
              `heap' specifies a heap handle.  `np' specifies the pointer to a variable to which the  number  of
              records  of  the  return value is assigned.  If it is `NULL', it is not used.  The return value is
              the pointer to the region of the heap.  Records are sorted.  Because  the  region  of  the  return
              value  is allocated with the `malloc' call, it should be released with the `free' call if it is no
              longer in use.  Because the region of the original heap is released, it  should  not  be  released
              again.

       The function `cbsprintf' is used in order to allocate a formatted string on memory.

       <b>char</b> <b>*cbsprintf(const</b> <b>char</b> <b>*format,</b> <b>...);</b>
              `format'  specifies  a  printf-like  format string.  The conversion character `%' can be used with
              such flag characters as `d', `o', `u', `x', `X', `e', `E', `f',  `g',  `G',  `c',  `s',  and  `%'.
              Specifiers  of the field length and the precision can be put between the conversion characters and
              the flag characters.  The specifiers consist of decimal characters, `.', `+', `-', and  the  space
              character.   The other arguments are used according to the format string.  The return value is the
              pointer to the allocated region of the result string.  Because the region of the return  value  is
              allocated with the `malloc' call, it should be released with the `free' call if it is no longer in
              use.

       The function `cbreplace' is used in order to replace some patterns in a string.

       <b>char</b> <b>*cbreplace(const</b> <b>char</b> <b>*str,</b> <b>CBMAP</b> <b>*pairs);</b>
              `str' specifies the pointer to a source string.  `pairs' specifies the handle of a map composed of
              pairs  of  replacement.  The key of each pair specifies a pattern before replacement and its value
              specifies the pattern after replacement.  The return value is the pointer to the allocated  region
              of the result string.  Because the region of the return value is allocated with the `malloc' call,
              it should be released with the `free' call if it is no longer in use.

       The function `cbsplit' is used in order to make a list by splitting a serial datum.

       <b>CBLIST</b> <b>*cbsplit(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>const</b> <b>char</b> <b>*delim);</b>
              `ptr' specifies the pointer to the region of the source content.  `size' specifies the size of the
              region.   If  it is negative, the size is assigned with `strlen(ptr)'.  `delim' specifies a string
              containing delimiting characters.  If it is `NULL', zero code is used as a delimiter.  The  return
              value  is a list handle.  If two delimiters are successive, it is assumed that an empty element is
              between the two.  Because the handle of the return value is opened with the function `cblistopen',
              it should be closed with the function `cblistclose'.

       The function `cbreadfile' is used in order to read whole data of a file.

       <b>char</b> <b>*cbreadfile(const</b> <b>char</b> <b>*name,</b> <b>int</b> <b>*sp);</b>
              `name' specifies the name of a file.  If it is `NULL', the  standard  input  is  specified.   `sp'
              specifies  the  pointer  to  a  variable  to  which  the size of the region of the return value is
              assigned.  If it is `NULL', it is not used.  The return value is  the  pointer  to  the  allocated
              region  of the read data.  Because an additional zero code is appended at the end of the region of
              the return value, the return value can be treated as a character string.  Because  the  region  of
              the  return  value is allocated with the `malloc' call, it should be released with the `free' call
              if it is no longer in use.

       The function `cbwritefile' is used in order to write a serial datum into a file.

       <b>int</b> <b>cbwritefile(const</b> <b>char</b> <b>*name,</b> <b>const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `name specifies the name of a file.  If it is `NULL', the standard  output  is  specified.   `ptr'
              specifies  the  pointer  to  the  region  of the source content.  `size' specifies the size of the
              region.  If it is negative, the size is assigned with `strlen(ptr)'.  If  successful,  the  return
              value  is  true,  else,  it is false.  If the file exists, it is overwritten.  Else, a new file is
              created.

       The function `cbreadlines' is used in order to read every line of a file.

       <b>CBLIST</b> <b>*cbreadlines(const</b> <b>char</b> <b>*name);</b>
              `name' specifies the name of a file.  If it is `NULL',  the  standard  input  is  specified.   The
              return  value  is  a list handle of the lines if successful, else it is NULL.  Line separators are
              cut out.  Because the handle of the return value is opened  with  the  function  `cblistopen',  it
              should be closed with the function `cblistclose' if it is no longer in use.

       The function `cbdirlist' is used in order to read names of files in a directory.

       <b>CBLIST</b> <b>*cbdirlist(const</b> <b>char</b> <b>*name);</b>
              `name'  specifies  the  name  of  a  directory.   The  return  value  is a list handle of names if
              successful, else it is NULL.  Because the handle of the return value is opened with  the  function
              `cblistopen', it should be closed with the function `cblistclose' if it is no longer in use.

       The function `cbfilestat' is used in order to get the status of a file or a directory.

       <b>int</b> <b>cbfilestat(const</b> <b>char</b> <b>*name,</b> <b>int</b> <b>*isdirp,</b> <b>int</b> <b>*sizep,</b> <b>time_t</b> <b>*mtimep);</b>
              `name' specifies the name of a file or a directory.  `dirp' specifies the pointer to a variable to
              which  whether  the  file  is  a directory is assigned.  If it is `NULL', it is not used.  `sizep'
              specifies the pointer to a variable to which the size of the file is assigned.  If it  is  `NULL',
              it  is  not used.  `mtimep' specifies the pointer to a variable to which the last modified time of
              the file is assigned.  If it is `NULL', it is not used.  If successful, the return value is  true,
              else, false.  False is returned when the file does not exist or the permission is denied.

       The function `cbremove' is used in order to remove a file or a directory and its sub ones recursively.

       <b>int</b> <b>cbremove(const</b> <b>char</b> <b>*name);</b>
              `name'  specifies  the  name  of  a file or a directory.  If successful, the return value is true,
              else, false.  False is returned when the file does not exist or the permission is denied.

       The function `cburlbreak' is used in order to break up a URL into elements.

       <b>CBMAP</b> <b>*cburlbreak(const</b> <b>char</b> <b>*str);</b>
              `str' specifies the pointer to a string of URL.  The return value is a map handle.   Each  key  of
              the  map  is  the  name of an element.  The key "self" specifies the URL itself.  The key "scheme"
              specifies the scheme.  The key "host" specifies the host of the server.  The key "port"  specifies
              the  port number of the server.  The key "authority" specifies the authority information.  The key
              "path" specifies the path of the resource.  The key "file" specifies the  file  name  without  the
              directory  section.  The key "query" specifies the query string.  The key "fragment" specifies the
              fragment string.  Supported schema are HTTP, HTTPS, FTP, and FILE.  Absolute URL and relative  URL
              are supported.  Because the handle of the return value is opened with the function `cbmapopen', it
              should be closed with the function `cbmapclose' if it is no longer in use.

       The runction `cburlresolve' is used in order to resolve a relative URL with another absolute URL.

       <b>char</b> <b>*cburlresolve(const</b> <b>char</b> <b>*base,</b> <b>const</b> <b>char</b> <b>*target);</b>
              `base'  specifies  an  absolute  URL of a base location.  `target' specifies a URL to be resolved.
              The return value is a resolved URL.  If the target URL is relative, a new URL of relative location
              from the base location is returned.  Else, a copy of the target  URL  is  returned.   Because  the
              region  of  the  return  value is allocated with the `malloc' call, it should be released with the
              `free' call if it is no longer in use.

       The function `cburlencode' is used in order to encode a serial object with URL encoding.

       <b>char</b> <b>*cburlencode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `ptr' specifies the pointer to a region.  `size' specifies the size  of  the  region.   If  it  is
              negative,  the size is assigned with `strlen(ptr)'.  The return value is the pointer to the result
              string.  Because the region of the return value is allocated with the `malloc' call, it should  be
              released with the `free' call if it is no longer in use.

       The function `cburldecode' is used in order to decode a string encoded with URL encoding.

       <b>char</b> <b>*cburldecode(const</b> <b>char</b> <b>*str,</b> <b>int</b> <b>*sp);</b>
              `str' specifies the pointer to a source string.  `sp' specifies the pointer to a variable to which
              the  size  of  the  region of the return value is assigned.  If it is `NULL', it is not used.  The
              return value is the pointer to the region of the result.   Because  an  additional  zero  code  is
              appended  at  the  end  of  the  region  of the return value, the return value can be treated as a
              character string.  Because the region of the return value is allocated with the `malloc' call,  it
              should be released with the `free' call if it is no longer in use.

       The function `cbbaseencode' is used in order to encode a serial object with Base64 encoding.

       <b>char</b> <b>*cbbaseencode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `ptr'  specifies  the  pointer  to  a  region.  `size' specifies the size of the region.  If it is
              negative, the size is assigned with `strlen(ptr)'.  The return value is the pointer to the  result
              string.   Because the region of the return value is allocated with the `malloc' call, it should be
              released with the `free' call if it is no longer in use.

       The function `cbbasedecode' is used in order to decode a string encoded with Base64 encoding.

       <b>char</b> <b>*cbbasedecode(const</b> <b>char</b> <b>*str,</b> <b>int</b> <b>*sp);</b>
              `str' specifies the pointer to a source string.  `sp' specifies the pointer to a variable to which
              the size of the region of the return value is assigned.  If it is `NULL', it  is  not  used.   The
              return  value  is  the  pointer  to  the region of the result.  Because an additional zero code is
              appended at the end of the region of the return value, the  return  value  can  be  treated  as  a
              character  string.  Because the region of the return value is allocated with the `malloc' call, it
              should be released with the `free' call if it is no longer in use.

       The function `cbquoteencode' is used in order to encode a serial object with quoted-printable encoding.

       <b>char</b> <b>*cbquoteencode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `ptr' specifies the pointer to a region.  `size' specifies the size  of  the  region.   If  it  is
              negative,  the size is assigned with `strlen(ptr)'.  The return value is the pointer to the result
              string.  Because the region of the return value is allocated with the `malloc' call, it should  be
              released with the `free' call if it is no longer in use.

       The function `cbquotedecode' is used in order to decode a string encoded with quoted-printable encoding.

       <b>char</b> <b>*cbquotedecode(const</b> <b>char</b> <b>*str,</b> <b>int</b> <b>*sp);</b>
              `str' specifies the pointer to a source string.  `sp' specifies the pointer to a variable to which
              the  size  of  the  region of the return value is assigned.  If it is `NULL', it is not used.  The
              return value is the pointer to the region of the result.   Because  an  additional  zero  code  is
              appended  at  the  end  of  the  region  of the return value, the return value can be treated as a
              character string.  Because the region of the return value is allocated with the `malloc' call,  it
              should be released with the `free' call if it is no longer in use.

       The function `cbmimebreak' is used in order to split a string of MIME into headers and the body.

       <b>char</b> <b>*cbmimebreak(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>CBMAP</b> <b>*attrs,</b> <b>int</b> <b>*sp);</b>
              `ptr'  specifies the pointer to the region of MIME data.  `size' specifies the size of the region.
              If it is negative, the size is assigned with `strlen(ptr)'.  `attrs' specifies  a  map  handle  to
              store  attributes.   If  it  is  `NULL', it is not used.  Each key of the map is an attribute name
              uncapitalized.  `sp' specifies the pointer to a variable to which the size of the  region  of  the
              return  value  is  assigned.  If it is `NULL', it is not used.  The return value is the pointer of
              the body data.  If the content type is defined, the attribute map has the  key  "TYPE"  specifying
              the  type.   If  the character encoding is defined, the key "CHARSET" specifies the encoding name.
              If the boundary string of multipart is defined, the key "BOUNDARY" specifies the string.   If  the
              content  disposition  is defined, the key "DISPOSITION" specifies the direction.  If the file name
              is defined, the key "FILENAME" specifies the name.  If the attribute  name  is  defined,  the  key
              "NAME"  specifies the name.  Because the region of the return value is allocated with the `malloc'
              call, it should be released with the `free' call if it is no longer in use.

       The function `cbmimeparts' is used in order to split multipart data of MIME into its parts.

       <b>CBLIST</b> <b>*cbmimeparts(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>const</b> <b>char</b> <b>*boundary);</b>
              `ptr' specifies the pointer to the region of multipart data of MIME.  `size' specifies the size of
              the region.  If it is negative, the size is assigned with `strlen(ptr)'.  `boundary' specifies the
              pointer to the region of the boundary string.  The return value is a list handle.  Each element of
              the list is the string of a part.  Because the handle of the  return  value  is  opened  with  the
              function  `cblistopen',  it should be closed with the function `cblistclose' if it is no longer in
              use.

       The function `cbmimeencode' is used in order to encode a string with MIME encoding.

       <b>char</b> <b>*cbmimeencode(const</b> <b>char</b> <b>*str,</b> <b>const</b> <b>char</b> <b>*encname,</b> <b>int</b> <b>base);</b>
              `str' specifies the pointer to a string.   `encname'  specifies  a  string  of  the  name  of  the
              character  encoding.   The  return  value  is  the pointer to the result string.  `base' specifies
              whether to use Base64 encoding.  If it is false, quoted-printable is used.  Because the region  of
              the  return  value is allocated with the `malloc' call, it should be released with the `free' call
              if it is no longer in use.

       The function `cbmimedecode' is used in order to decode a string encoded with MIME encoding.

       <b>char</b> <b>*cbmimedecode(const</b> <b>char</b> <b>*str,</b> <b>char</b> <b>*enp);</b>
              `str' specifies the pointer to an encoded string.  `enp' specifies the pointer to  a  region  into
              which  the  name of encoding is written.  If it is `NULL', it is not used.  The size of the buffer
              should be equal to or more than 32 bytes.  The return value is the pointer to the  result  string.
              Because  the region of the return value is allocated with the `malloc' call, it should be released
              with the `free' call if it is no longer in use.

       The function `cbcsvrows' is used in order to split a string of CSV into rows.

       <b>CBLIST</b> <b>*cbcsvrows(const</b> <b>char</b> <b>*str);</b>
              `str' specifies the pointer to the region of an CSV string.  The return value is  a  list  handle.
              Each  element  of the list is a string of a row.  Because the handle of the return value is opened
              with the function `cblistopen', it should be closed with the function `cblistclose' if  it  is  no
              longer  in use.  The character encoding of the input string should be US-ASCII, UTF-8, ISO-8859-*,
              EUC-*, or Shift_JIS.  Being compatible with MS-Excel, these functions for  CSV  can  handle  cells
              including such meta characters as comma, between double quotation marks.

       The function `cbcsvcells' is used in order to split the string of a row of CSV into cells.

       <b>CBLIST</b> <b>*cbcsvcells(const</b> <b>char</b> <b>*str);</b>
              `str'  specifies  the  pointer  to the region of a row of CSV.  The return value is a list handle.
              Each element of the list is the unescaped string of a cell of the row.  Because the handle of  the
              return  value  is  opened  with  the  function `cblistopen', it should be closed with the function
              `cblistclose' if it is no longer in use.

       The function `cbcsvescape' is used in order to escape a string with the meta characters of CSV.

       <b>char</b> <b>*cbcsvescape(const</b> <b>char</b> <b>*str);</b>
              `str' specifies the pointer to the region of a string.  The return value is  the  pointer  to  the
              escaped  string sanitized of meta characters.  Because the region of the return value is allocated
              with the `malloc' call, it should be released with the `free' call if it is no longer in use.

       The function `cbcsvunescape' is used in order to unescape a string with the escaped  meta  characters  of
       CSV.

       <b>char</b> <b>*cbcsvunescape(const</b> <b>char</b> <b>*str);</b>
              `str'  specifies  the pointer to the region of a string with meta characters.  The return value is
              the pointer to the unescaped string.  Because the region of the return value is allocated with the
              `malloc' call, it should be released with the `free' call if it is no longer in use.

       The function `cbxmlbreak' is used in order to split a string of XML into tags and text sections.

       <b>CBLIST</b> <b>*cbxmlbreak(const</b> <b>char</b> <b>*str,</b> <b>int</b> <b>cr);</b>
              `str' specifies the pointer to the region of an XML string.   `cr'  specifies  whether  to  remove
              comments.   The return value is a list handle.  Each element of the list is the string of a tag or
              a text section.  Because the handle of the return value is opened with the function  `cblistopen',
              it  should  be  closed  with  the function `cblistclose' if it is no longer in use.  The character
              encoding of the input string should be US-ASCII, UTF-8, ISO-8859-*, EUC-*, or Shift_JIS.   Because
              these  functions  for  XML  are  not XML parser with validation check, it can handle also HTML and
              SGML.

       The function `cbxmlattrs' is used in order to get the map of attributes of an XML tag.

       <b>CBMAP</b> <b>*cbxmlattrs(const</b> <b>char</b> <b>*str);</b>
              `str' specifies the pointer to the region of a tag string.  The return  value  is  a  map  handle.
              Each  key  of the map is the name of an attribute.  Each value is unescaped.  You can get the name
              of the tag with the key of an empty string.  Because the handle of the return value is opened with
              the function `cbmapopen', it should be closed with the function `cbmapclose' if it is no longer in
              use.

       The function `cbxmlescape' is used in order to escape a string with the meta characters of XML.

       <b>char</b> <b>*cbxmlescape(const</b> <b>char</b> <b>*str);</b>
              `str' specifies the pointer to the region of a string.  The return value is  the  pointer  to  the
              escaped  string sanitized of meta characters.  This function converts only `&amp;', `&lt;', `&gt;', and `"'.
              Because the region of the return value is allocated with the `malloc' call, it should be  released
              with the `free' call if it is no longer in use.

       The function `cbxmlunescape' is used in order to unescape a string with the entity references of XML.

       <b>char</b> <b>*cbxmlunescape(const</b> <b>char</b> <b>*str);</b>
              `str'  specifies  the  pointer  to the region of a string.  The return value is the pointer to the
              unescaped string.  This function restores only `&amp;amp;', `&amp;lt;', `&amp;gt;', and `&amp;quot;'.  Because the
              region of the return value is allocated with the `malloc' call, it should  be  released  with  the
              `free' call if it is no longer in use.

       The function `cbdeflate' is used in order to compress a serial object with ZLIB.

       <b>char</b> <b>*cbdeflate(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>
              `ptr'  specifies  the  pointer  to  a  region.  `size' specifies the size of the region.  If it is
              negative, the size is assigned with `strlen(ptr)'.  `sp' specifies the pointer to  a  variable  to
              which  the size of the region of the return value is assigned.  If successful, the return value is
              the pointer to the result object, else, it is `NULL'.  Because the region of the return  value  is
              allocated with the `malloc' call, it should be released with the `free' call if it is no longer in
              use.  This function is available only if QDBM was built with ZLIB enabled.

       The function `cbinflate' is used in order to decompress a serial object compressed with ZLIB.

       <b>char</b> <b>*cbinflate(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>
              `ptr' specifies the pointer to a region.  `size' specifies the size of the region.  `sp' specifies
              the  pointer to a variable to which the size of the region of the return value is assigned.  If it
              is `NULL', it is not used.  If successful, the return value is the pointer to the  result  object,
              else,  it  is `NULL'.  Because an additional zero code is appended at the end of the region of the
              return value, the return value can be treated as a character string.  Because the  region  of  the
              return value is allocated with the `malloc' call, it should be released with the `free' call if it
              is no longer in use.  This function is available only if QDBM was built with ZLIB enabled.

       The function `cbgzencode' is used in order to compress a serial object with GZIP.

       <b>char</b> <b>*cbgzencode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>
              `ptr'  specifies  the  pointer  to  a  region.  `size' specifies the size of the region.  If it is
              negative, the size is assigned with `strlen(ptr)'.  `sp' specifies the pointer to  a  variable  to
              which  the size of the region of the return value is assigned.  If successful, the return value is
              the pointer to the result object, else, it is `NULL'.  Because the region of the return  value  is
              allocated with the `malloc' call, it should be released with the `free' call if it is no longer in
              use.  This function is available only if QDBM was built with ZLIB enabled.

       The function `cbgzdecode' is used in order to decompress a serial object compressed with GZIP.

       <b>char</b> <b>*cbgzdecode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>
              `ptr' specifies the pointer to a region.  `size' specifies the size of the region.  `sp' specifies
              the  pointer to a variable to which the size of the region of the return value is assigned.  If it
              is `NULL', it is not used.  If successful, the return value is the pointer to the  result  object,
              else,  it  is `NULL'.  Because an additional zero code is appended at the end of the region of the
              return value, the return value can be treated as a character string.  Because the  region  of  the
              return value is allocated with the `malloc' call, it should be released with the `free' call if it
              is no longer in use.  This function is available only if QDBM was built with ZLIB enabled.

       The function `cbgetcrc' is used in order to get the CRC32 checksum of a serial object.

       <b>unsigned</b> <b>int</b> <b>cbgetcrc(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `ptr'  specifies  the  pointer  to  a  region.  `size' specifies the size of the region.  If it is
              negative, the size is assigned with `strlen(ptr)'.  The return value is the CRC32 checksum of  the
              object.  This function is available only if QDBM was built with ZLIB enabled.

       The function `cblzoencode' is used in order to compress a serial object with LZO.

       <b>char</b> <b>*cblzoencode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>
              `ptr'  specifies  the  pointer  to  a  region.  `size' specifies the size of the region.  If it is
              negative, the size is assigned with `strlen(ptr)'.  `sp' specifies the pointer to  a  variable  to
              which  the size of the region of the return value is assigned.  If successful, the return value is
              the pointer to the result object, else, it is `NULL'.  Because the region of the return  value  is
              allocated with the `malloc' call, it should be released with the `free' call if it is no longer in
              use.  This function is available only if QDBM was built with LZO enabled.

       The function `cblzodecode' is used in order to decompress a serial object compressed with LZO.

       <b>char</b> <b>*cblzodecode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>
              `ptr' specifies the pointer to a region.  `size' specifies the size of the region.  `sp' specifies
              the  pointer to a variable to which the size of the region of the return value is assigned.  If it
              is `NULL', it is not used.  If successful, the return value is the pointer to the  result  object,
              else,  it  is `NULL'.  Because an additional zero code is appended at the end of the region of the
              return value, the return value can be treated as a character string.  Because the  region  of  the
              return value is allocated with the `malloc' call, it should be released with the `free' call if it
              is no longer in use.  This function is available only if QDBM was built with LZO enabled.

       The function `cbbzencode' is used in order to compress a serial object with BZIP2.

       <b>char</b> <b>*cbbzencode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>
              `ptr'  specifies  the  pointer  to  a  region.  `size' specifies the size of the region.  If it is
              negative, the size is assigned with `strlen(ptr)'.  `sp' specifies the pointer to  a  variable  to
              which  the size of the region of the return value is assigned.  If successful, the return value is
              the pointer to the result object, else, it is `NULL'.  Because the region of the return  value  is
              allocated with the `malloc' call, it should be released with the `free' call if it is no longer in
              use.  This function is available only if QDBM was built with BZIP2 enabled.

       The function `cbbzdecode' is used in order to decompress a serial object compressed with BZIP2.

       <b>char</b> <b>*cbbzdecode(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>int</b> <b>*sp);</b>
              `ptr' specifies the pointer to a region.  `size' specifies the size of the region.  `sp' specifies
              the  pointer to a variable to which the size of the region of the return value is assigned.  If it
              is `NULL', it is not used.  If successful, the return value is the pointer to the  result  object,
              else,  it  is `NULL'.  Because an additional zero code is appended at the end of the region of the
              return value, the return value can be treated as a character string.  Because the  region  of  the
              return value is allocated with the `malloc' call, it should be released with the `free' call if it
              is no longer in use.  This function is available only if QDBM was built with BZIP2 enabled.

       The function `cbiconv' is used in order to convert the character encoding of a string.

       <b>char</b> <b>*cbiconv(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size,</b> <b>const</b> <b>char</b> <b>*icode,</b> <b>const</b> <b>char</b> <b>*ocode,</b> <b>int</b> <b>*sp,</b> <b>int</b> <b>*mp);</b>
              `ptr'  specifies  the  pointer  to  a  region.  `size' specifies the size of the region.  If it is
              negative, the size is assigned with `strlen(ptr)'.  `icode' specifies the name of encoding of  the
              input  string.   `ocode'  specifies the name of encoding of the output string.  `sp' specifies the
              pointer to a variable to which the size of the region of the return value is assigned.  If  it  is
              `NULL',  it  is not used.  `mp' specifies the pointer to a variable to which the number of missing
              characters by failure of conversion is assigned.  If it is `NULL', it is not used.  If successful,
              the return value is the pointer to the result object, else, it is `NULL'.  Because  an  additional
              zero  code  is  appended  at  the  end  of the region of the return value, the return value can be
              treated as a character string.  Because the region of the  return  value  is  allocated  with  the
              `malloc'  call,  it  should  be  released  with  the  `free' call if it is no longer in use.  This
              function is available only if QDBM was built with ICONV enabled.

       The function `cbencname' is used in order to detect the encoding of a string automatically.

       <b>const</b> <b>char</b> <b>*cbencname(const</b> <b>char</b> <b>*ptr,</b> <b>int</b> <b>size);</b>
              `ptr' specifies the pointer to a region.  `size' specifies the size  of  the  region.   If  it  is
              negative, the size is assigned with `strlen(ptr)'.  The return value is the string of the encoding
              name of the string.  As it stands, US-ASCII, ISO-2022-JP, Shift_JIS, CP932, EUC-JP, UTF-8, UTF-16,
              UTF-16BE,  and  UTF-16LE  are  supported.   If none of them matches, ISO-8859-1 is selected.  This
              function is available only if QDBM was built with ICONV enabled.

       The function `cbjetlag' is used in order to get the jet lag of the local time in seconds.

       <b>int</b> <b>cbjetlag(void);</b>
              The return value is the jet lag of the local time in seconds.

       The function `cbcalendar' is used in order to get the Gregorian calendar of a time.

       <b>void</b> <b>cbcalendar(time_t</b> <b>t,</b> <b>int</b> <b>jl,</b> <b>int</b> <b>*yearp,</b> <b>int</b> <b>*monp,</b> <b>int</b> <b>*dayp,</b> <b>int</b> <b>*hourp,</b> <b>int</b> <b>*minp,</b> <b>int</b> <b>*secp);</b>
              `t' specifies a source time.  If it is negative, the current time is  specified.   `jl'  specifies
              the  jet  lag  of a location in seconds.  `yearp' specifies the pointer to a variable to which the
              year is assigned.  If it is `NULL', it is not used.  `monp' specifies the pointer to a variable to
              which the month is assigned.  If it is `NULL', it is not used.   1  means  January  and  12  means
              December.   `dayp'  specifies the pointer to a variable to which the day of the month is assigned.
              If it is `NULL', it is not used.  `hourp' specifies the pointer to a variable to which  the  hours
              is  assigned.   If  it  is  `NULL', it is not used.  `minp' specifies the pointer to a variable to
              which the minutes is assigned.  If it is `NULL', it is not used.  `secp' specifies the pointer  to
              a variable to which the seconds is assigned.  If it is `NULL', it is not used.

       The function `cbdayofweek' is used in order to get the day of week of a date.

       <b>int</b> <b>cbdayofweek(int</b> <b>year,</b> <b>int</b> <b>mon,</b> <b>int</b> <b>day);</b>
              `year'  specifies the year of a date.  `mon' specifies the month of the date.  `day' specifies the
              day of the date.  The return value is the day of week of the date.  0 means  Sunday  and  6  means
              Saturday.

       The function `cbdatestrwww' is used in order to get the string for a date in W3CDTF.

       <b>char</b> <b>*cbdatestrwww(time_t</b> <b>t,</b> <b>int</b> <b>jl);</b>
              `t'  specifies  a  source time.  If it is negative, the current time is specified.  `jl' specifies
              the jet lag of a location in seconds.  The return value is  the  string  of  the  date  in  W3CDTF
              (YYYY-MM-DDThh:mm:ddTZD).   Because  the region of the return value is allocated with the `malloc'
              call, it should be released with the `free' call if it is no longer in use.

       The function `cbdatestrhttp' is used in order to get the string for a date in RFC 1123 format.

       <b>char</b> <b>*cbdatestrhttp(time_t</b> <b>t,</b> <b>int</b> <b>jl);</b>
              `t' specifies a source time.  If it is negative, the current time is  specified.   `jl'  specifies
              the  jet  lag  of  a  location in seconds.  The return value is the string of the date in RFC 1123
              format (Wdy, DD-Mon-YYYY hh:mm:dd TZD).  Because the region of the return value is allocated  with
              the `malloc' call, it should be released with the `free' call if it is no longer in use.

       The  function  `cbstrmktime'  is  used  in  order  to  get  the  time  value of a date string in decimal,
       hexadecimal, W3CDTF, or RFC 822 (1123).

       <b>time_t</b> <b>cbstrmktime(const</b> <b>char</b> <b>*str);</b>
              `str' specifies a date string in decimal, hexadecimal, W3CDTF, or  RFC  822  (1123).   The  return
              value is the time value of the date or -1 if the format is invalid.  Decimal can be trailed by "s"
              for in seconds, "m" for in minutes, "h" for in hours, and "d" for in days.

       The function `cbproctime' is used in order to get user and system processing times.

       <b>void</b> <b>cbproctime(double</b> <b>*usrp,</b> <b>double</b> <b>*sysp);</b>
              `usrp'  specifies  the pointer to a variable to which the user processing time is assigned.  If it
              is `NULL', it is not used.  The unit of time is  seconds.   `sysp'  specifies  the  pointer  to  a
              variable  to  which the system processing time is assigned.  If it is `NULL', it is not used.  The
              unit of time is seconds.

       The function `cbstdiobin' is used in order to ensure that the standard I/O is binary mode.

       <b>void</b> <b>cbstdiobin(void);</b>
              This function is useful for applications on dosish file systems.

       Functions of Cabin except for `cbglobalgc' are thread-safe as long as a handle is not accessed by threads
       at the same time, on the assumption that `errno', `malloc', and so on are thread-safe.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/qdbm.3.html">qdbm</a></b>(3), <b><a href="../man3/depot.3.html">depot</a></b>(3), <b><a href="../man3/curia.3.html">curia</a></b>(3), <b><a href="../man3/relic.3.html">relic</a></b>(3), <b><a href="../man3/hovel.3.html">hovel</a></b>(3), <b><a href="../man3/villa.3.html">villa</a></b>(3), <b><a href="../man3/odeum.3.html">odeum</a></b>(3), <b><a href="../man3/ndbm.3.html">ndbm</a></b>(3), <b><a href="../man3/gdbm.3.html">gdbm</a></b>(3)

Man Page                                           2004-04-22                                           <u><a href="../man3/CABIN.3.html">CABIN</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>