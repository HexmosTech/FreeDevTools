<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GC_malloc,   GC_malloc_atomic,   GC_free,   GC_realloc,   GC_enable_incremental,   GC_register_finalizer,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgc-dev">libgc-dev_8.2.8-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       GC_malloc,   GC_malloc_atomic,   GC_free,   GC_realloc,   GC_enable_incremental,   GC_register_finalizer,
       GC_malloc_ignore_off_page, GC_malloc_atomic_ignore_off_page, GC_set_warn_proc - Garbage collecting malloc
       replacement

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;gc/gc.h&gt;
       void * GC_malloc(size_t size);
       void * GC_malloc_atomic(size_t size);
       void GC_free(void *ptr);
       void * GC_realloc(void *ptr, size_t size);
       void GC_enable_incremental(void);
       void * GC_malloc_ignore_off_page(size_t size);
       void * GC_malloc_atomic_ignore_off_page(size_t size);
       void GC_set_warn_proc(void (*proc)(char *, GC_word));

       cc ... -lgc

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>GC_malloc</u> and <u>GC_free</u> are plug-in replacements for standard malloc and  free.   However,  <u>GC_malloc</u>  will
       attempt  to  reclaim  inaccessible  space  automatically  by invoking a conservative garbage collector at
       appropriate points.  The collector traverses all data structures accessible by  following  pointers  from
       the  machines registers, stack(s), data, and bss segments.  Inaccessible structures will be reclaimed.  A
       machine word is considered to be a valid pointer if it is  an  address  inside  an  object  allocated  by
       <u>GC_malloc</u> or friends.

       In  most cases it is preferable to call the macros GC_MALLOC, GC_FREE, etc.  instead of calling GC_malloc
       and friends directly.  This allows debugging versions of the  routines  to  be  substituted  by  defining
       GC_DEBUG before including gc.h.

       See  the  documentation  in  the include files gc_cpp.h and gc_allocator.h, as well as the gcinterface.md
       file in the distribution, for an alternate, C++ specific interface to the garbage collector.   Note  that
       C++  programs  generally need to be careful to ensure that all allocated memory (whether via new, malloc,
       or STL allocators) that may point to garbage collected memory is either itself garbage collected,  or  at
       least traced by the collector.

       Unlike   the   standard  implementations  of  malloc,  <u>GC_malloc</u>  clears  the  newly  allocated  storage.
       <u>GC_malloc_atomic</u> does not.  Furthermore, it informs the collector that the resulting  object  will  never
       contain any pointers, and should therefore not be scanned by the collector.

       <u>GC_free</u>  can  be  used  to  deallocate  objects,  but  its  use  is  optional, and generally discouraged.
       <u>GC_realloc</u> has the standard realloc semantics.  It  preserves  pointer-free-ness.   <u>GC_register_finalizer</u>
       allows for registration of functions that are invoked when an object becomes inaccessible.

       The  garbage collector tries to avoid allocating memory at locations that already appear to be referenced
       before allocation.  (Such apparent ``pointers'' are usually large integers and the like that just  happen
       to look like an address.)  This may make it hard to allocate very large objects.  An attempt to do so may
       generate a warning.

       <u>GC_malloc_ignore_off_page</u>  and <u>GC_malloc_atomic_ignore_off_page</u> inform the collector that the client code
       will always maintain a pointer to near the beginning (i.e. within the first heap block)  of  the  object,
       and  that  pointers  beyond  that  can  be  ignored  by the collector.  This makes it much easier for the
       collector to place large objects.  These are recommended for large object allocation.  (Objects  expected
       to be &gt; ~100 KB should be allocated this way.)

       It  is  also  possible  to  use  the  collector to find storage leaks in programs destined to be run with
       standard malloc/free.  The collector can be compiled for thread-safe operation.  Unlike standard  malloc,
       it is safe to call malloc after a previous malloc call was interrupted by a signal, provided the original
       malloc call is not resumed.

       The  collector may, on rare occasion, produce warning messages.  On UNIX machines these appear on stderr.
       Warning messages can be filtered, redirected, or ignored with <u>GC_set_warn_proc</u> This  is  recommended  for
       production code.  See gc.h for details.

       Fully  portable code should call <u>GC_INIT</u> from the primordial thread of the main program before making any
       other GC calls.  On most platforms this does nothing and the collector is initialized on first use.  On a
       few platforms explicit initialization is necessary.  And it can never hurt.

       Debugging versions of many of the above routines are provided as macros.  Their names  are  identical  to
       the  above,  but  consist  of all capital letters.  If GC_DEBUG is defined before gc.h is included, these
       routines do additional checking, and allow the  leak  detecting  version  of  the  collector  to  produce
       slightly more useful output.  Without GC_DEBUG defined, they behave exactly like the lower-case versions.

       On some machines, collection will be performed incrementally after a call to <u>GC_enable_incremental.</u>  This
       may  temporarily  write  protect pages in the heap.  See the README file for more information on how this
       interacts with system calls that write to the heap.

       Other facilities not discussed here include limited  facilities  to  support  incremental  collection  on
       machines without appropriate VM support, provisions for providing more explicit object layout information
       to  the  garbage  collector, more direct support for ``weak'' pointers, support for ``abortable'' garbage
       collections during idle time, etc.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The README and gc.h files in the distribution.  More detailed definitions of the  functions  exported  by
       the collector are given there.  (The above list is not complete.)

       The web site at <a href="http://www.hboehm.info/gc/">http://www.hboehm.info/gc/</a> (or https://github.com/ivmai/bdwgc/).

       Boehm,  H.,  and  M.  Weiser,  "Garbage Collection in an Uncooperative Environment", "Software Practice &amp;
       Experience", September 1988, pp. 807-820.

       The <a href="../man3/malloc.3.html">malloc</a>(3) man page.

</pre><h4><b>AUTHOR</b></h4><pre>
       Hans-J. Boehm (<a href="mailto:boehm@acm.org">boehm@acm.org</a>).  Some of the code was written by others (see  the  AUTHORS  file  for  the
       details), most notably by Alan Demers, and, recently, Ivan Maidanski.

                                                   23 Aug 2023                                          <u><a href="../man3/BDWGC.3.html">BDWGC</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>