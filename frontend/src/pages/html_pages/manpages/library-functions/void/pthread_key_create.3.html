<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pthread_key_create,  pthread_key_delete, pthread_setspecific, pthread_getspecific - management of thread-</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pthread_key_create,  pthread_key_delete, pthread_setspecific, pthread_getspecific - management of thread-
       specific data

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;</b>

       <b>int</b> <b>pthread_key_create(pthread_key_t</b> <b>*</b><u>key</u><b>,</b>
                              <b>void</b> <b>(*</b><u>destr_function</u><b>)</b> <b>(void</b> <b>*));</b>
       <b>int</b> <b>pthread_key_delete(pthread_key_t</b> <u>key</u><b>);</b>
       <b>int</b> <b>pthread_setspecific(pthread_key_t</b> <u>key</u><b>,</b> <b>const</b> <b>void</b> <b>*</b><u>pointer</u><b>);</b>
       <b>void</b> <b>*</b> <b>pthread_getspecific(pthread_key_t</b> <u>key</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Programs often need global or static variables that have different values in  different  threads.   Since
       threads  share one memory space, this cannot be achieved with regular variables.  Thread-specific data is
       the POSIX threads answer to this need.

       Each thread possesses a private memory block, the thread-specific data area, or TSD area for short.  This
       area is indexed by TSD keys.  The TSD area associates values of type <b>void</b> <b>*</b> to TSD keys.   TSD  keys  are
       common to all threads, but the value associated with a given TSD key can be different in each thread.

       For  concreteness,  the TSD areas can be viewed as arrays of <b>void</b> <b>*</b> pointers, TSD keys as integer indices
       into these arrays, and the value of a TSD key as the value of the  corresponding  array  element  in  the
       calling thread.

       When a thread is created, its TSD area initially associates <b>NULL</b> with all keys.

       <b>pthread_key_create</b>  allocates a new TSD key.  The key is stored in the location pointed to by <u>key</u>.  There
       is a limit of <b>PTHREAD_KEYS_MAX</b> on the number of keys allocated at a  given  time.   The  value  initially
       associated with the returned key is <b>NULL</b> in all currently executing threads.

       The  <u>destr_function</u> argument, if not <b>NULL</b>, specifies a destructor function associated with the key.  When
       a thread terminates via <b>pthread_exit</b> or by cancelation, <u>destr_function</u> is called with arguments the value
       associated with the key in that thread.  The <u>destr_function</u> is not called if that  value  is  <b>NULL</b>.   The
       order in which destructor functions are called at thread termination time is unspecified.

       Before  the  destructor  function  is  called,  the  <b>NULL</b> value is associated with the key in the current
       thread.  A destructor function might, however, re-associate non-<b>NULL</b> values to that  key  or  some  other
       key.  To deal with this, if after all the destructors have been called for all non-<b>NULL</b> values, there are
       still  some  non-<b>NULL</b>  values  with  associated  destructors,  then  the  process is repeated.  The glibc
       implementation stops the process after <b>PTHREAD_DESTRUCTOR_ITERATIONS</b> iterations, even  if  some  non-<b>NULL</b>
       values with associated descriptors remain.  Other implementations may loop indefinitely.

       <b>pthread_key_delete</b>  deallocates a TSD key.  It does not check whether non-<b>NULL</b> values are associated with
       that key in the currently executing threads, nor call the destructor function associated with the key.

       <b>pthread_setspecific</b> changes the value associated with <u>key</u>  in  the  calling  thread,  storing  the  given
       <u>pointer</u> instead.

       <b>pthread_getspecific</b> returns the value currently associated with <u>key</u> in the calling thread.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>pthread_key_create</b>,  <b>pthread_key_delete</b>, and <b>pthread_setspecific</b> return 0 on success and a non-zero error
       code on failure.  If successful, <b>pthread_key_create</b> stores  the  newly  allocated  key  in  the  location
       pointed to by its <u>key</u> argument.

       <b>pthread_getspecific</b> returns the value associated with <u>key</u> on success, and <b>NULL</b> on error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>pthread_key_create</b> returns the following error code on error:

              <b>EAGAIN</b> <b>PTHREAD_KEYS_MAX</b> keys are already allocated.

       <b>pthread_key_delete</b> and <b>pthread_setspecific</b> return the following error code on error:

              <b>EINVAL</b> <u>key</u> is not a valid, allocated TSD key.

       <b>pthread_getspecific</b> returns <b>NULL</b> if <u>key</u> is not a valid, allocated TSD key.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/pthread_create.3.html">pthread_create</a>(3), <a href="../man3/pthread_exit.3.html">pthread_exit</a>(3), <a href="../man3/pthread_testcancel.3.html">pthread_testcancel</a>(3).

</pre><h4><b>EXAMPLE</b></h4><pre>
       The  following  code  fragment  allocates  a  thread-specific  array  of  100  characters, with automatic
       reclamation at thread exit:

              <b>/*</b> <b>Key</b> <b>for</b> <b>the</b> <b>thread-specific</b> <b>buffer</b> <b>*/</b>
              <b>static</b> <b>pthread_key_t</b> <b>buffer_key;</b>

              <b>/*</b> <b>Once-only</b> <b>initialisation</b> <b>of</b> <b>the</b> <b>key</b> <b>*/</b>
              <b>static</b> <b>pthread_once_t</b> <b>buffer_key_once</b> <b>=</b> <b>PTHREAD_ONCE_INIT;</b>

              <b>/*</b> <b>Allocate</b> <b>the</b> <b>thread-specific</b> <b>buffer</b> <b>*/</b>
              <b>void</b> <b>buffer_alloc(void)</b>
              <b>{</b>
                <b>pthread_once(&amp;buffer_key_once,</b> <b>buffer_key_alloc);</b>
                <b>pthread_setspecific(buffer_key,</b> <b><a href="../man100/malloc.100.html">malloc</a>(100));</b>
              <b>}</b>

              <b>/*</b> <b>Return</b> <b>the</b> <b>thread-specific</b> <b>buffer</b> <b>*/</b>
              <b>char</b> <b>*</b> <b>get_buffer(void)</b>
              <b>{</b>
                <b>return</b> <b>(char</b> <b>*)</b> <b>pthread_getspecific(buffer_key);</b>
              <b>}</b>

              <b>/*</b> <b>Allocate</b> <b>the</b> <b>key</b> <b>*/</b>
              <b>static</b> <b>void</b> <b>buffer_key_alloc()</b>
              <b>{</b>
                <b>pthread_key_create(&amp;buffer_key,</b> <b>buffer_destroy);</b>
              <b>}</b>

              <b>/*</b> <b>Free</b> <b>the</b> <b>thread-specific</b> <b>buffer</b> <b>*/</b>
              <b>static</b> <b>void</b> <b>buffer_destroy(void</b> <b>*</b> <b>buf)</b>
              <b>{</b>
                <b>free(buf);</b>
              <b>}</b>

Linux man-pages 6.9.1                              2024-06-16                              <u><a href="../man3/pthread_key_create.3.html">pthread_key_create</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>