<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       pthread_atfork — register fork handlers

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;

       int pthread_atfork(void (*<u>prepare</u>)(void), void (*<u>parent</u>)(void),
           void (*<u>child</u>)(void));

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>pthread_atfork</u>()  function  shall declare fork handlers to be called before and after <u>fork</u>(), in the
       context of the thread that called <u>fork</u>().  The  <u>prepare</u>  fork  handler  shall  be  called  before  <u>fork</u>()
       processing  commences.  The  <u>parent</u>  fork handle shall be called after <u>fork</u>() processing completes in the
       parent process. The <u>child</u> fork handler shall be called after <u>fork</u>() processing  completes  in  the  child
       process.  If  no handling is desired at one or more of these three points, the corresponding fork handler
       address(es) may be set to NULL.

       If a <u>fork</u>() call in a multi-threaded process leads to a <u>child</u> fork handler calling any function  that  is
       not async-signal-safe, the behavior is undefined.

       The order of calls to <u>pthread_atfork</u>() is significant. The <u>parent</u> and <u>child</u> fork handlers shall be called
       in  the  order  in  which  they were established by calls to <u>pthread_atfork</u>().  The <u>prepare</u> fork handlers
       shall be called in the opposite order.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon successful completion, <u>pthread_atfork</u>() shall return a value of zero;  otherwise,  an  error  number
       shall be returned to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>pthread_atfork</u>() function shall fail if:

       <b>ENOMEM</b> Insufficient table space exists to record the fork handler addresses.

       The <u>pthread_atfork</u>() function shall not return an error code of <b>[EINTR]</b>.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       None.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       The  original  usage  pattern  envisaged  for  <u>pthread_atfork</u>()  was for the <u>prepare</u> fork handler to lock
       mutexes and other locks, and for the <u>parent</u> and <u>child</u> handlers to unlock them. However, since all of  the
       relevant  unlocking  functions,  except  <u>sem_post</u>(),  are  not  async-signal-safe,  this usage results in
       undefined behavior in the child process unless the only such unlocking function it calls is <u>sem_post</u>().

</pre><h4><b>RATIONALE</b></h4><pre>
       There are at least two serious problems with the semantics of <u>fork</u>() in  a  multi-threaded  program.  One
       problem has to do with state (for example, memory) covered by mutexes. Consider the case where one thread
       has a mutex locked and the state covered by that mutex is inconsistent while another thread calls <u>fork</u>().
       In  the  child,  the  mutex  is in the locked state (locked by a nonexistent thread and thus can never be
       unlocked). Having the child simply reinitialize the mutex is unsatisfactory since this approach does  not
       resolve the question about how to correct or otherwise deal with the inconsistent state in the child.

       It  is  suggested  that  programs that use <u>fork</u>() call an <u>exec</u> function very soon afterwards in the child
       process, thus resetting all states. In the meantime, only  a  short  list  of  async-signal-safe  library
       routines are promised to be available.

       Unfortunately, this solution does not address the needs of multi-threaded libraries. Application programs
       may  not  be  aware  that  a  multi-threaded  library is in use, and they feel free to call any number of
       library routines between the <u>fork</u>() and <u>exec</u> calls, just as they always have. Indeed, they may be  extant
       single-threaded  programs  and  cannot,  therefore,  be  expected to obey new restrictions imposed by the
       threads library.

       On the other hand, the multi-threaded library needs a way to protect its internal state during <u>fork</u>()  in
       case  it  is  re-entered  later in the child process. The problem arises especially in multi-threaded I/O
       libraries, which are almost sure to  be  invoked  between  the  <u>fork</u>()  and  <u>exec</u>  calls  to  effect  I/O
       redirection.  The  solution  may  require  locking mutex variables during <u>fork</u>(), or it may entail simply
       resetting the state in the child after the <u>fork</u>() processing completes.

       The <u>pthread_atfork</u>() function was intended to provide multi-threaded libraries with a  means  to  protect
       themselves from innocent application programs that call <u>fork</u>(), and to provide multi-threaded application
       programs  with  a  standard mechanism for protecting themselves from <u>fork</u>() calls in a library routine or
       the application itself.

       The expected usage was that the prepare handler would acquire all mutex locks  and  the  other  two  fork
       handlers would release them.

       For example, an application could have supplied a prepare routine that acquires the necessary mutexes the
       library  maintains  and supplied child and parent routines that release those mutexes, thus ensuring that
       the child would have got a consistent snapshot of the state of the library (and  that  no  mutexes  would
       have  been left stranded). This is good in theory, but in reality not practical. Each and every mutex and
       lock in the process must be located and locked.  Every  component  of  a  program  including  third-party
       components  must  participate  and  they  must  agree who is responsible for which mutex or lock. This is
       especially problematic for mutexes and locks in dynamically  allocated  memory.  All  mutexes  and  locks
       internal  to the implementation must be locked, too. This possibly delays the thread calling <u>fork</u>() for a
       long time or even indefinitely since uses of these synchronization objects may not be  under  control  of
       the  application. A final problem to mention here is the problem of locking streams. At least the streams
       under control of the system (like <u>stdin</u>, <u>stdout</u>, <u>stderr</u>) must be protected by  locking  the  stream  with
       <u>flockfile</u>().   But  the  application  itself  could  have  done that, possibly in the same thread calling
       <u>fork</u>().  In this case, the process will deadlock.

       Alternatively, some libraries might have been able to supply just a <u>child</u> routine that reinitializes  the
       mutexes  in  the library and all associated states to some known value (for example, what it was when the
       image was originally executed). This approach  is  not  possible,  though,  because  implementations  are
       allowed  to  fail  <u>*_init</u>()  and  <u>*_destroy</u>()  calls  for mutexes and locks if the mutex or lock is still
       locked. In this case, the <u>child</u> routine is not able to reinitialize the mutexes and locks.

       When <u>fork</u>() is called, only the calling thread is  duplicated  in  the  child  process.   Synchronization
       variables remain in the same state in the child as they were in the parent at the time <u>fork</u>() was called.
       Thus,  for example, mutex locks may be held by threads that no longer exist in the child process, and any
       associated states may be inconsistent. The intention was that the parent process could have avoided  this
       by  explicit  code  that  acquires  and  releases  locks  critical to the child via <u>pthread_atfork</u>().  In
       addition, any critical threads would have needed to be recreated and reinitialized to the proper state in
       the child (also via <u>pthread_atfork</u>()).

       A higher-level package may acquire locks on its own data structures before invoking lower-level packages.
       Under this scenario, the order specified for fork handler calls allows a simple  rule  of  initialization
       for avoiding package deadlock: a package initializes all packages on which it depends before it calls the
       <u>pthread_atfork</u>() function for itself.

       As  explained, there is no suitable solution for functionality which requires non-atomic operations to be
       protected through mutexes and locks. This is why the POSIX.1 standard since  the  1996  release  requires
       that the child process after <u>fork</u>() in a multi-threaded process only calls async-signal-safe interfaces.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       The  <u>pthread_atfork</u>()  function  may  be  formally deprecated (for example, by shading it OB) in a future
       version of this standard.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>atexit</u>(), <u>exec</u>, <u>fork</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;pthread.h&gt;</b>, <b>&lt;sys_types.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                <u><a href="../man3POSIX/PTHREAD_ATFORK.3POSIX.html">PTHREAD_ATFORK</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>