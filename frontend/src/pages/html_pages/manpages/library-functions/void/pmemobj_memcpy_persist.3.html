<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pmemobj_persist(),  pmemobj_xpersist(),  pmemobj_flush(), pmemobj_xflush(), pmemobj_drain(), pmemobj_mem‐</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpmemobj-dev">libpmemobj-dev_1.13.1-1.1ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>pmemobj_persist</b>(),  <b>pmemobj_xpersist</b>(),  <b>pmemobj_flush</b>(), <b>pmemobj_xflush</b>(), <b>pmemobj_drain</b>(), <b>pmemobj_mem‐</b>
       <b>cpy</b>(), <b>pmemobj_memmove</b>(), <b>pmemobj_memset</b>(), <b>pmemobj_memcpy_persist</b>(), <b>pmemobj_memset_persist</b>() - low-lev‐
       el memory manipulation functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;libpmemobj.h&gt;

              void pmemobj_persist(PMEMobjpool *pop, const void *addr,
                  size_t len);
              void pmemobj_flush(PMEMobjpool *pop, const void *addr,
                  size_t len);
              void pmemobj_drain(PMEMobjpool *pop);

              int pmemobj_xpersist(PMEMobjpool *pop, const void *addr,
                  size_t len, unsigned flags);
              int pmemobj_xflush(PMEMobjpool *pop, const void *addr,
                  size_t len, unsigned flags);

              void *pmemobj_memcpy(PMEMobjpool *pop, void *dest,
                  const void *src, size_t len, unsigned flags);
              void *pmemobj_memmove(PMEMobjpool *pop, void *dest,
                  const void *src, size_t len, unsigned flags);
              void *pmemobj_memset(PMEMobjpool *pop, void *dest,
                  int c, size_t len, unsigned flags);

              void *pmemobj_memcpy_persist(PMEMobjpool *pop, void *dest,
                  const void *src, size_t len);
              void *pmemobj_memset_persist(PMEMobjpool *pop, void *dest,
                  int c, size_t len);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>libpmemobj</b>-specific low-level memory manipulation functions described here leverage the knowledge  of
       the  additional  configuration options available for <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) pools, such as replication.  They also
       take advantage of the type of storage behind the pool and use appropriate flush/drain functions.   It  is
       advised to use these functions in conjunction with <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) objects rather than using low-level mem‐
       ory manipulation functions from <b>libpmem</b>.

       <b>pmemobj_persist</b>()  forces  any  changes  in the range [<u>addr</u>, <u>addr</u>+<u>len</u>) to be stored durably in persistent
       memory.  Internally this may call either <b><a href="../man3/pmem_msync.3.html">pmem_msync</a></b>(3) or <b><a href="../man3/pmem_persist.3.html">pmem_persist</a></b>(3).  There are  no  alignment  re‐
       strictions  on  the range described by <u>addr</u> and <u>len</u>, but <b>pmemobj_persist</b>() may expand the range as neces‐
       sary to meet platform alignment requirements.

              WARNING: Like <b><a href="../man2/msync.2.html">msync</a></b>(2), there is nothing atomic or transactional about this call.   Any  unwritten
              stores in the given range will be written, but some stores may have already been written by virtue
              of  normal  cache eviction/replacement policies.  Correctly written code must not depend on stores
              waiting until <b>pmemobj_persist</b>() is called to become persistent - they can become persistent at any
              time before <b>pmemobj_persist</b>() is called.

       The <b>pmemobj_flush</b>() and <b>pmemobj_drain</b>() functions provide partial versions of the <b>pmemobj_persist</b>() func‐
       tion described above.  These functions allow advanced programs to create their own variations  of  <b>pmemo‐</b>
       <b>bj_persist</b>().   For  example,  a program that needs to flush several discontiguous ranges can call <b>pmemo‐</b>
       <b>bj_flush</b>() for each range and then follow up by calling <b>pmemobj_drain</b>() once.  For  more  information  on
       partial flushing operations, see <b><a href="../man3/pmem_flush.3.html">pmem_flush</a></b>(3).

       <b>pmemobj_xpersist</b>()  is  a  version of <b>pmemobj_persist</b>() function with additional <u>flags</u> argument.  It sup‐
       ports only the <b>PMEMOBJ_F_RELAXED</b> flag.  This flag indicates that memory transfer operation does  not  re‐
       quire 8-byte atomicity guarantees.

       <b>pmemobj_xflush</b>()  is  a  version of <b>pmemobj_flush</b>() function with additional <u>flags</u> argument.  It supports
       only the <b>PMEMOBJ_F_RELAXED</b> flag.

       The <b>pmemobj_memmove</b>(), <b>pmemobj_memcpy</b>() and <b>pmemobj_memset</b>() functions provide the same memory copying as
       their namesakes <b><a href="../man3/memmove.3.html">memmove</a></b>(3), <b><a href="../man3/memcpy.3.html">memcpy</a></b>(3), and <b><a href="../man3/memset.3.html">memset</a></b>(3), and ensure that the result has been flushed to per‐
       sistence before returning (unless <b>PMEMOBJ_MEM_NOFLUSH</b> flag was used).  Valid flags for those functions:

       • <b>PMEMOBJ_F_RELAXED</b> - This flag indicates that memory transfer operation does not require 8-byte atomici‐
         ty guarantees.

       • <b>PMEMOBJ_F_MEM_NOFLUSH</b> - Don’t flush anything.  This implies <b>PMEMOBJ_F_MEM_NODRAIN</b>.  Using this flag on‐
         ly makes sense when it’s followed by any function that flushes data.

       The remaining flags say <u>how</u> the operation should be done, and are merely hints.

       • <b>PMEMOBJ_F_MEM_NONTEMPORAL</b> - Use non-temporal instructions.  This flag is mutually exclusive with <b>PMEMO‐</b>
         <b>BJ_F_MEM_TEMPORAL</b>.  On x86_64 this flag is mutually exclusive with <b>PMEMOBJ_F_MEM_NOFLUSH</b>.

       • <b>PMEMOBJ_F_MEM_TEMPORAL</b> - Use temporal instructions.   This  flag  is  mutually  exclusive  with  <b>PMEMO‐</b>
         <b>BJ_F_MEM_NONTEMPORAL</b>.

       • <b>PMEMOBJ_F_MEM_WC</b>  -  Use  write combining mode.  This flag is mutually exclusive with <b>PMEMOBJ_F_MEM_WB</b>.
         On x86_64 this is an alias for <b>PMEMOBJ_F_MEM_NONTEMPORAL</b>.  On x86_64 this flag  is  mutually  exclusive
         with <b>PMEMOBJ_F_MEM_NOFLUSH</b>.

       • <b>PMEMOBJ_F_MEM_WB</b>  -  Use  write  back mode.  This flag is mutually exclusive with <b>PMEMOBJ_F_MEM_WC</b>.  On
         x86_64 this is an alias for <b>PMEMOBJ_F_MEM_TEMPORAL</b>.

       <b>pmemobj_memcpy_persist</b>() is an alias for <b>pmemobj_memcpy</b>() with flags equal to 0.

       <b>pmemobj_memset_persist</b>() is an alias for <b>pmemobj_memset</b>() with flags equal to 0.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>pmemobj_memmove</b>(), <b>pmemobj_memcpy</b>(), <b>pmemobj_memset</b>(), <b>pmemobj_memcpy_persist</b>()  and  <b>pmemobj_memset_per‐</b>
       <b>sist</b>() return destination buffer.

       <b>pmemobj_persist</b>(), <b>pmemobj_flush</b>() and <b>pmemobj_drain</b>() do not return any value.

       <b>pmemobj_xpersist</b>()  and <b>pmemobj_xflush</b>() returns non-zero value and sets errno to EINVAL only if not sup‐
       ported flags has been provided.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following code is functionally equivalent to <b>pmemobj_memcpy_persist</b>():

              void *
              pmemobj_memcpy_persist(PMEMobjpool *pop, void *dest,
                  const void *src, size_t len)
              {
                  void *retval = memcpy(dest, src, len);

                  pmemobj_persist(pop, dest, len);

                  return retval;
              }

       <b>pmemobj_persist</b>() can be thought of as this:

              void
              pmemobj_persist(PMEMobjpool *pop, const void *addr, size_t len)
              {
                  /* flush the processor caches */
                  pmemobj_flush(pop, addr, len);

                  /* wait for any pmem stores to drain from HW buffers */
                  pmemobj_drain(pop);
              }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/memcpy.3.html">memcpy</a></b>(3), <b><a href="../man3/memset.3.html">memset</a></b>(3), <b><a href="../man3/pmem_msync.3.html">pmem_msync</a></b>(3), <b><a href="../man3/pmem_persist.3.html">pmem_persist</a></b>(3), <b><a href="../man7/libpmem.7.html">libpmem</a></b>(7) <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) and <b>&lt;https://pmem.io&gt;</b>
</pre>
 </div>
</div></section>
</div>
</body>
</html>