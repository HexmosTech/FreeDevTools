<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C or C++:</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openmpi-doc">openmpi-doc_5.0.7-1build1_all</a> <br><br><pre>
</pre><h4><b>SYNOPSIS</b></h4><pre>
       C or C++:

          #include &lt;mpp/shmem.h&gt;

          void shmem_broadcast32(void *target, const void *source,
            size_t nelems, int PE_root, int PE_start, int logPE_stride,
            int PE_size, long *pSync)

          void shmem_broadcast64(void *target, const void *source,
            size_t nelems, int PE_root, int PE_start, int logPE_stride,
            int PE_size, long *pSync)

       Fortran:

          INCLUDE "mpp/shmem.fh"

          INTEGER nelems, PE_root, PE_start, logPE_stride, PE_size
          INTEGER pSync(SHMEM_BCAST_SYNC_SIZE)

          CALL SHMEM_BROADCAST4(target, source, nelems, PE_root,
          &amp; PE_start, logPE_stride, PE_size, fIpSync)

          CALL SHMEM_BROADCAST8(target, source, nelems, PE_root,
          &amp; PE_start, logPE_stride, PE_size, pSync)

          CALL SHMEM_BROADCAST32(target, source, nelems,
          &amp; PE_root, PE_start, logPE_stride, PE_size, pSync)

          CALL SHMEM_BROADCAST64(target, source, nelems,
          &amp; PE_root, PE_start, logPE_stride, PE_size, pSync)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  broadcast routines write the data at address source of the PE specified by <b>PE_root</b> to address <b>target</b>
       on all other PEs in the active  set.  The  active  set  of  PEs  is  defined  by  the  triplet  <b>PE_start</b>,
       <b>logPE_stride</b>  and  <b>PE_size</b>.  The data is not copied to the target address on the PE specified by <b>PE_root</b>.
       Before returning, the broadcast routines ensure that the elements of the  pSync  array  are  restored  to
       their initial values.

       As  with  all  SHMEM  collective routines, each of these routines assumes that only PEs in the active set
       call the routine. If a PE not in the active set calls a  SHMEM  collective  routine,  undefined  behavior
       results.

       The arguments are as follows:

       <b>target</b> A symmetric data object with one of the following data types:

              <b>shmem_broadcast8,</b> <u>shmem_broadcast64</u><b>:</b> <b>Any</b> <b>noncharacter</b> <b>type</b> <b>that</b>
                     has an element size of 64 bits. No Fortran derived types or C/C++ structures are allowed.

              <u>shmem_broadcast32</u><b>:</b> <b>Any</b> <b>noncharacter</b> <b>type</b> <b>that</b> <b>has</b> <b>an</b> <b>element</b> <b>size</b>
                     of 32 bits. No Fortran derived types or C/C++ structures are allowed.

              <b>shmem_broadcast4:</b> <b>Any</b> <b>noncharacter</b> <b>type</b> <b>that</b> <b>has</b> <b>an</b> <b>element</b> <b>size</b>
                     of 32 bits.

       <b>source</b> A symmetric data object that can be of any data type that is permissible for the target argument.

       <b>nelems</b> The  number  of elements in source. For <u>shmem_broadcast32</u> and shmem_broadcast4, this is the number
              of 32-bit halfwords. nelems must be of type integer. If you  are  using  Fortran,  it  must  be  a
              default integer value.

       <b>PE_root</b>
              Zero-based  ordinal of the PE, with respect to the active set, from which the data is copied. Must
              be greater than or equal to 0 and less than PE_size. PE_root must be of type integer. If  you  are
              using Fortran, it must be a default integer value.

       <b>PE_start</b>
              The  lowest  virtual  PE number of the active set of PEs. PE_start must be of type integer. If you
              are using Fortran, it must be a default integer value.

       <b>logPE_stride</b>
              The log (base 2) of the  stride  between  consecutive  virtual  PE  numbers  in  the  active  set.
              log_PE_stride  must  be  of  type  integer. If you are using Fortran, it must be a default integer
              value.

       <b>PE_size</b>
              The number of PEs in the active set. PE_size must be of type integer.  If you are  using  Fortran,
              it must be a default integer value.

       <b>pSync</b>  A  symmetric  work array. In C/C++, pSync must be of type long and size _SHMEM_BCAST_SYNC_SIZE. In
              Fortran, pSync must be of type integer and size SHMEM_BCAST_SYNC_SIZE. Every element of this array
              must be initialized with the value _SHMEM_SYNC_VALUE (in C/C++) or SHMEM_SYNC_VALUE  (in  Fortran)
              before any of the PEs in the active set enter shmem_barrier().

       The  values  of  arguments  PE_root,  PE_start, logPE_stride, and PE_size must be equal on all PEs in the
       active set. The same target and source data objects and the same pSync work array must be passed  to  all
       PEs in the active set.

       Before  any  PE  calls  a  broadcast  routine,  you  must  ensure  that  the  following  conditions exist
       (synchronization via a barrier or some other method is often needed to ensure this): The pSync  array  on
       all  PEs in the active set is not still in use from a prior call to a broadcast routine. The target array
       on all PEs in the active set is ready to accept the broadcast data.

       Upon return from a broadcast routine, the following are true for the local PE: If the current PE  is  not
       the  root  PE,  the  target  data  object  is  updated. The values in the pSync array are restored to the
       original values.

</pre><h4><b>NOTES</b></h4><pre>
       The terms collective and symmetric are defined in <u><a href="../man3/intro_shmem.3.html">intro_shmem</a></u>(3).

       All SHMEM broadcast routines restore pSync to its original contents.  Multiple calls  to  SHMEM  routines
       that use the same pSync array do not require that pSync be reinitialized after the first call.

       You  must  ensure  the that the pSync array is not being updated by any PE in the active set while any of
       the PEs participates in processing of a SHMEM broadcast routine. Be careful to avoid these situations: If
       the pSync array is initialized at run time, some type of synchronization is needed to ensure that all PEs
       in the working set have initialized pSync before any of them enter a SHMEM routine called with the  pSync
       synchronization  array.  A pSync array may be reused on a subsequent SHMEM broadcast routine only if none
       of the PEs in the active set are still processing a prior SHMEM broadcast routine call that used the same
       pSync array. In general, this can be ensured only by doing some type of synchronization. However, in  the
       special  case  of SHMEM routines being called with the same active set, you can allocate two pSync arrays
       and alternate between them on successive calls.

</pre><h4><b>EXAMPLES</b></h4><pre>
       In the following examples, the call to <u>shmem_broadcast64</u> copies source on PE 4 to target on PEs 5, 6, and
       7.

       C/C++ example:

          for (i=0; i &lt; _SHMEM_BCAST_SYNC_SIZE; i++) {
            pSync[i] = _SHMEM_SYNC_VALUE;
          }
          shmem_barrier_all(); /* Wait for all PEs to initialize pSync */
          shmem_broadcast64(target, source, nelems, 0, 4, 0, 4, pSync);

       Fortran example:

          INTEGER PSYNC(SHMEM_BCAST_SYNC_SIZE)
          INTEGER TARGET, SOURCE, NELEMS, PE_ROOT, PE_START,
          &amp; LOGPE_STRIDE, PE_SIZE, PSYNC
          COMMON /COM/ TARGET, SOURCE
          DATA PSYNC /SHMEM_BCAST_SYNC_SIZE*SHMEM_SYNC_VALUE/

          CALL SHMEM_BROADCAST64(TARGET, SOURCE, NELEMS, 0, 4, 0, 4,
          &amp; PSYNC)

       <b>SEE</b> <b>ALSO:</b>
          <u><a href="../man3/intro_shmem.3.html">intro_shmem</a></u>(3)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2003-2025, The Open MPI Community

                                                  Jun 07, 2025                              <u><a href="../man3/SHMEM_BROADCAST64.3.html">SHMEM_BROADCAST64</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>