<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>co_thread_init,   co_thread_cleanup,  co_create,  co_call,  co_resume,  co_delete,  co_exit_to,  co_exit,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libpcl1-dev">libpcl1-dev_1.12-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       co_thread_init,   co_thread_cleanup,  co_create,  co_call,  co_resume,  co_delete,  co_exit_to,  co_exit,
       co_current, co_get_data, co_set_data - C coroutine management

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;pcl.h&gt;</b>

       <b>int</b> <b>co_thread_init(void);</b>

       <b>void</b> <b>co_thread_cleanup(void);</b>
       <b>coroutine_t</b> <b>co_create(void</b> <b>*</b><u>func</u><b>,</b> <b>void</b> <b>*</b><u>data</u><b>,</b> <b>void</b> <b>*</b><u>stack</u><b>,</b> <b>int</b> <u>stacksize</u><b>);</b>
       <b>void</b> <b>co_delete(coroutine_t</b> <u>co</u><b>);</b>
       <b>void</b> <b>co_call(coroutine_t</b> <u>co</u><b>);</b>
       <b>void</b> <b>co_resume(void);</b>
       <b>void</b> <b>co_exit_to(coroutine_t</b> <u>co</u><b>);</b>
       <b>void</b> <b>co_exit(void);</b>
       <b>coroutine_t</b> <b>co_current(void);</b>
       <b>void</b> <b>*co_get_data(coroutine_t</b> <u>co</u><b>);</b>
       <b>void</b> <b>*co_set_data(coroutine_t</b> <u>co</u><b>,</b> <b>void</b> <b>*</b><u>data</u><b>);</b>

       Link with <u>-lpthread</u> if you are using a multi-thread version of <b>PCL</b>.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>Portable</b> <b>Coroutine</b> <b>Library</b> <b>(PCL)</b> implements  the  low  level  functionality  for  coroutines.  For  a
       definition  of the term <b>coroutine</b> see <u>The</u> <u>Art</u> <u>of</u> <u>Computer</u> <u>Programming</u> by <u>Donald</u> <u>E.</u> <u>Knuth</u>.  Coroutines are
       a very simple cooperative multitasking environment where the switch from one  task  to  another  is  done
       explicitly by a function call.  Coroutines are a lot faster than processes or threads switch, since there
       is no OS kernel involvement for the operation. This document defines an API for the low level handling of
       coroutines  i.e. creating and deleting coroutines and switching between them.  Higher level functionality
       (scheduler, etc.) is not covered.

   <b>Functions</b>
       The following functions are defined:

       <b>int</b> <b>co_thread_init(void);</b>

              If the <b>PCL</b> library is built in multi-thread mode, and if multi threads  are  actually  used,  this
              function  should be called before calling any <b>PCL</b> function.  If the <b>PCL</b> library is built in multi-
              thread mode, but it is used only from one thread (the main one, likely), then it  is  possible  to
              avoid  to  call <b>co_thread_init</b>().  Returns 0 in case of success, or an negative error code in case
              of error.

       <b>void</b> <b>co_thread_cleanup(void);</b>
              If the <b>PCL</b> library is built in multi-thread mode, and if multi threads  are  actually  used,  this
              function  should  be  called before the thread exits, or whenever the thread decides it won't call
              the <b>PCL</b> functions anymore.  A failure in  calling  <b>co_thread_cleanup</b>()  will  result  in  resource
              leakage by the calling application.

       <b>coroutine_t</b> <b>co_create(void</b> <b>*</b><u>func</u><b>,</b> <b>void</b> <b>*</b><u>data</u><b>,</b> <b>void</b> <b>*</b><u>stack</u><b>,</b> <b>int</b> <u>stacksize</u><b>);</b>

              This  function  creates  a  new  coroutine.  <u>func</u> is the entry point of the coroutine.  It will be
              called with one arg, a <b>void</b> <b>*</b>, which holds the data passed through the  <u>data</u>  parameter.  If  <u>func</u>
              terminates,  the  associated  coroutine is deleted.  <u>stack</u> is the base of the stack this coroutine
              will use and <u>stacksize</u> its size in bytes.  You may pass a <b>NULL</b> pointer for <u>stack</u> in which case the
              memory will be allocated by <b>co_create</b> itself.  Both, <u>stack</u> and <u>stacksize</u>  are  aligned  to  system
              requirements.   A <u>stacksize</u> of less then 4096 bytes will be rejected.  You have to make sure, that
              the stack is large enough for your coroutine and possible signal handlers (see below).  The  stack
              will  not  grow!   (Exception:  the  main coroutine uses the standard system stack which may still
              grow) On success, a handle (<b>coroutine_t</b>) for a new coroutine is returned, otherwise <b>NULL</b>.

       <b>void</b> <b>co_delete(coroutine_t</b> <u>co</u><b>);</b>

              This function deletes the given coroutine <u>co</u>.  If the stack for this coroutine  was  allocated  by
              <b>co_create</b>  it  will  be freed.  After a coroutine handle was passed to <b>co_delete</b> it is invalid and
              may not be used any more.  It is invalid for a coroutine to delete itself with this function.

       <b>void</b> <b>co_call(coroutine_t</b> <u>co</u><b>);</b>

              This function passes execution to the given  coroutine  <u>co</u>.   The  first  time  the  coroutine  is
              executed, its entry point <u>func</u> is called, and the <u>data</u> parameter used during the call to <b>co_create</b>
              is  passed  to  <u>func</u>.   The  current  coroutine  is suspended until another one restarts it with a
              <b>co_call</b> or <b>co_resume</b> call. Calling oneself returns immediately.

       <b>void</b> <b>co_resume(void);</b>

              This function passes execution back to the coroutine which either initially started  this  one  or
              restarted it after a prior <b>co_resume</b>.

       <b>void</b> <b>co_exit_to(coroutine_t</b> <u>co</u><b>);</b>

              This function does the same a <b>co_delete(co_current())</b> followed by a <b>co_call</b> would do.  That is, it
              deletes itself and then passes execution to another coroutine <u>co</u>.

       <b>void</b> <b>co_exit(void);</b>

              This  function does the same a <b>co_delete(co_current())</b> followed by a <b>co_resume</b> would do.  That is,
              it deletes itself and then passes execution back to the coroutine which either  initially  started
              this one or restarted it after a prior <b>co_resume</b>.

       <b>coroutine_t</b> <b>co_current(void);</b>

              This function returns the currently running coroutine.

       <b>void</b> <b>*co_get_data(coroutine_t</b> <u>co</u><b>);</b>

              This function returns the data associated with the <u>co</u>
               coroutine. The data associated with a coroutine is the <u>data</u> parameter passed to <b>co_create</b>().

       <b>void</b> <b>*co_set_data(coroutine_t</b> <u>co</u><b>,</b> <b>void</b> <b>*</b><u>data</u><b>);</b>

              Sets the <u>data</u> associated with the <u>co</u> coroutine, and returns the previously associated data.

   <b>Notes</b>
       Some interactions with other parts of the system are covered here.

       <b>Threads</b>
              If  the  <b>PCL</b>  library has been built in multi-thread mode, then it is possible to use it in multi-
              thread software.  A thread should call <b>co_thread_init</b>()  before  using  the  <b>PCL</b>  APIs,  and  call
              <b>co_thread_cleanup</b>() before exiting, or when it has done using the <b>PCL</b> APIs.
              <b>WARNING:</b> For no reason should two different threads run the same coroutine at the same time.

       <b>Signals</b>
              First, a signal handler is not defined to run in any specific coroutine. The only way to leave the
              signal handler is by a return statement.

              Second, the signal handler may run with the stack of any coroutine, even with the stack of library
              internal  coroutines  which  have  an undefined stack size (just enough to perform a kernel call).
              Using and alternate stack for signal processing (see <b><a href="../man2/sigaltstack.2.html">sigaltstack</a></b>(2)) is recommended!

              Conclusion: avoid signals like a plague.  The only thing you  may  do  reliable  is  setting  some
              global  variables and return.  Simple kernel calls may work too, but nowadays it's pretty hairy to
              tell, which function really is a kernel call.  (Btw, all this applies to normal C  programs,  too.
              The coroutines just add one more problem)

       <b>setjmp</b>/<b>longjmp</b>
              The  use  of  <b><a href="../man2/setjmp.2.html">setjmp</a></b>(2)/<b><a href="../man2/longjmp.2.html">longjmp</a></b>(2)  is limited to jumping inside one coroutine.  Never try to jump
              from one coroutine to another with <b><a href="../man2/longjmp.2.html">longjmp</a></b>(2).

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Some fatal errors are caught by the library.   If  one  occurs,  a  short  message  is  written  to  file
       descriptor 2 (stderr) and a segmentation violation is generated.

       <b>[PCL]:</b> <b>Cannot</b> <b>delete</b> <b>itself</b>
              A coroutine has called <b>co_delete</b> with it's own handle.

       <b>[PCL]:</b> <b>Resume</b> <b>to</b> <b>deleted</b> <b>coroutine</b>
              A  coroutine has deleted itself with <b>co_exit</b> or <b>co_exit_to</b> and the coroutine that was activated by
              the exit tried a <b>co_resume</b>.

       <b>[PCL]:</b> <b>Stale</b> <b>coroutine</b> <b>called</b>
              Someone tried to active a coroutine that has already been deleted.  This error is  only  detected,
              if the stack of the deleted coroutine is still resident in memory.

       <b>[PCL]:</b> <b>Context</b> <b>switch</b> <b>failed</b>
              Low level error generated by the library in case a context switch between two coroutines failes.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Original   <b>coroutine</b>   library  at  <b><a href="http://www.goron.de/~froese/coro/coro.html">http://www.goron.de/~froese/coro/coro.html</a></b>  .   GNU  Pth  library  at
       <b><a href="http://www.gnu.org/software/pth/">http://www.gnu.org/software/pth/</a></b> .

</pre><h4><b>AUTHOR</b></h4><pre>
       Developed by Davide Libenzi &lt; <b><a href="mailto:davidel@xmailserver.org">davidel@xmailserver.org</a></b> &gt;.
       Ideas and man page base source taken by the coroutine library developed by E. Toernig &lt; <b><a href="mailto:froese@gmx.de">froese@gmx.de</a></b> &gt;.
       Also some code and ideas comes from the GNU Pth library available at <b><a href="http://www.gnu.org/software/pth/">http://www.gnu.org/software/pth/</a></b> .

</pre><h4><b>BUGS</b></h4><pre>
       There are no known bugs.  But, this library is still in development even if it results  very  stable  and
       pretty much ready for production use.

       Bug reports and comments to Davide Libenzi &lt; <b><a href="mailto:davidel@xmailserver.org">davidel@xmailserver.org</a></b> &gt;.

GNU                                                   1.12                                                <u><a href="../man3/PCL.3.html">PCL</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>