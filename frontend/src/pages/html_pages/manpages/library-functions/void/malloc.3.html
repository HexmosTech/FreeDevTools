<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>malloc, free, calloc, realloc, reallocarray - allocate and free dynamic memory</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       malloc, free, calloc, realloc, reallocarray - allocate and free dynamic memory

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;</b>

       <b>void</b> <b>*malloc(size_t</b> <u>size</u><b>);</b>
       <b>void</b> <b>free(void</b> <b>*_Nullable</b> <u>ptr</u><b>);</b>
       <b>void</b> <b>*calloc(size_t</b> <u>nmemb</u><b>,</b> <b>size_t</b> <u>size</u><b>);</b>
       <b>void</b> <b>*realloc(void</b> <b>*_Nullable</b> <u>ptr</u><b>,</b> <b>size_t</b> <u>size</u><b>);</b>
       <b>void</b> <b>*reallocarray(void</b> <b>*_Nullable</b> <u>ptr</u><b>,</b> <b>size_t</b> <u>nmemb</u><b>,</b> <b>size_t</b> <u>size</u><b>);</b>

   Feature Test Macro Requirements for glibc (see <b><a href="../man7/feature_test_macros.7.html">feature_test_macros</a></b>(7)):

       <b>reallocarray</b>():
           Since glibc 2.29:
               _DEFAULT_SOURCE
           glibc 2.28 and earlier:
               _GNU_SOURCE

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>malloc()</b>
       The  <b>malloc</b>() function allocates <u>size</u> bytes and returns a pointer to the allocated memory.  <u>The</u> <u>memory</u> <u>is</u>
       <u>not</u> <u>initialized</u>.  If <u>size</u> is 0,  then  <b>malloc</b>()  returns  a  unique  pointer  value  that  can  later  be
       successfully passed to <b>free</b>().  (See "Nonportable behavior" for portability issues.)

   <b>free()</b>
       The <b>free</b>() function frees the memory space pointed to by <u>ptr</u>, which must have been returned by a previous
       call  to  <b>malloc</b>() or related functions.  Otherwise, or if <u>ptr</u> has already been freed, undefined behavior
       occurs.  If <u>ptr</u> is NULL, no operation is performed.

   <b>calloc()</b>
       The <b>calloc</b>() function allocates memory for an array of <u>nmemb</u> elements of <u>size</u> bytes each  and  returns  a
       pointer  to  the  allocated  memory.   The  memory  is set to zero.  If <u>nmemb</u> or <u>size</u> is 0, then <b>calloc</b>()
       returns a unique pointer value that can later be successfully passed to <b>free</b>().

       If the multiplication of <u>nmemb</u> and <u>size</u> would result in integer overflow, then <b>calloc</b>() returns an error.
       By contrast, an integer overflow would not be detected in the following call to <b>malloc</b>(), with the result
       that an incorrectly sized block of memory would be allocated:

           malloc(nmemb * size);

   <b>realloc()</b>
       The <b>realloc</b>() function changes the size of the memory block  pointed  to  by  <u>ptr</u>  to  <u>size</u>  bytes.   The
       contents  of  the memory will be unchanged in the range from the start of the region up to the minimum of
       the old and new sizes.  If the new size is larger than the  old  size,  the  added  memory  will  <u>not</u>  be
       initialized.

       If <u>ptr</u> is NULL, then the call is equivalent to <u>malloc(size)</u>, for all values of <u>size</u>.

       If  <u>size</u>  is  equal  to  zero,  and  <u>ptr</u>  is  not NULL, then the call is equivalent to <u>free(ptr)</u> (but see
       "Nonportable behavior" for portability issues).

       Unless <u>ptr</u> is NULL, it must have been returned by an earlier call to <b>malloc</b> or related functions.  If the
       area pointed to was moved, a <u>free(ptr)</u> is done.

   <b>reallocarray()</b>
       The <b>reallocarray</b>() function changes the size of (and possibly moves) the memory block pointed to  by  <u>ptr</u>
       to  be large enough for an array of <u>nmemb</u> elements, each of which is <u>size</u> bytes.  It is equivalent to the
       call

           realloc(ptr, nmemb * size);

       However, unlike that <b>realloc</b>() call, <b>reallocarray</b>() fails safely in the  case  where  the  multiplication
       would overflow.  If such an overflow occurs, <b>reallocarray</b>() returns an error.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The <b>malloc</b>(), <b>calloc</b>(), <b>realloc</b>(), and <b>reallocarray</b>() functions return a pointer to the allocated memory,
       which  is  suitably  aligned  for  any  type  that fits into the requested size or less.  On error, these
       functions return NULL and set <u>errno</u>.  Attempting to allocate more than <b>PTRDIFF_MAX</b> bytes is considered an
       error, as an object that large could cause later pointer subtraction to overflow.

       The <b>free</b>() function returns no value, and preserves <u>errno</u>.

       The <b>realloc</b>() and <b>reallocarray</b>() functions return NULL if <u>ptr</u> is not NULL and the requested size is zero;
       this is not considered an error.  (See "Nonportable behavior" for portability  issues.)   Otherwise,  the
       returned  pointer  may be the same as <u>ptr</u> if the allocation was not moved (e.g., there was room to expand
       the allocation in-place), or different from <u>ptr</u> if the allocation was moved to a new address.   If  these
       functions fail, the original block is left untouched; it is not freed or moved.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>calloc</b>(), <b>malloc</b>(), <b>realloc</b>(), and <b>reallocarray</b>() can fail with the following error:

       <b>ENOMEM</b> Out  of  memory.   Possibly,  the  application hit the <b>RLIMIT_AS</b> or <b>RLIMIT_DATA</b> limit described in
              <b><a href="../man2/getrlimit.2.html">getrlimit</a></b>(2).  Another reason could be that the number of mappings created by the  caller  process
              exceeded the limit specified by <u><a href="file:/proc/sys/vm/max_map_count">/proc/sys/vm/max_map_count</a></u>.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       For an explanation of the terms used in this section, see <b><a href="../man7/attributes.7.html">attributes</a></b>(7).
       ┌─────────────────────────────────────────────────────────────────────────────┬───────────────┬─────────┐
       │ <b>Interface</b>                                                                   │ <b>Attribute</b>     │ <b>Value</b>   │
       ├─────────────────────────────────────────────────────────────────────────────┼───────────────┼─────────┤
       │ <b>malloc</b>(), <b>free</b>(), <b>calloc</b>(), <b>realloc</b>()                                       │ Thread safety │ MT-Safe │
       └─────────────────────────────────────────────────────────────────────────────┴───────────────┴─────────┘

</pre><h4><b>STANDARDS</b></h4><pre>
       <b>malloc</b>()
       <b>free</b>()
       <b>calloc</b>()
       <b>realloc</b>()
              C11, POSIX.1-2008.

       <b>reallocarray</b>()
              None.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>malloc</b>()
       <b>free</b>()
       <b>calloc</b>()
       <b>realloc</b>()
              POSIX.1-2001, C89.

       <b>reallocarray</b>()
              glibc 2.26.  OpenBSD 5.6, FreeBSD 11.0.

       <b>malloc</b>() and related functions rejected sizes greater than <b>PTRDIFF_MAX</b> starting in glibc 2.30.

       <b>free</b>() preserved <u>errno</u> starting in glibc 2.33.

</pre><h4><b>NOTES</b></h4><pre>
       By  default,  Linux  follows  an  optimistic  memory  allocation strategy.  This means that when <b>malloc</b>()
       returns non-NULL there is no guarantee that the memory really is available.  In case it  turns  out  that
       the  system  is  out  of  memory,  one  or  more  processes  will  be killed by the OOM killer.  For more
       information, see the description of <u><a href="file:/proc/sys/vm/overcommit_memory">/proc/sys/vm/overcommit_memory</a></u> and <u>/proc/sys/vm/oom_adj</u>  in  <b><a href="../man5/proc.5.html">proc</a></b>(5),
       and the Linux kernel source file <u>Documentation/vm/overcommit-accounting.rst</u>.

       Normally,  <b>malloc</b>()  allocates  memory from the heap, and adjusts the size of the heap as required, using
       <b><a href="../man2/sbrk.2.html">sbrk</a></b>(2).  When allocating  blocks  of  memory  larger  than  <b>MMAP_THRESHOLD</b>  bytes,  the  glibc  <b>malloc</b>()
       implementation  allocates  the  memory  as  a private anonymous mapping using <b><a href="../man2/mmap.2.html">mmap</a></b>(2).  <b>MMAP_THRESHOLD</b> is
       128 kB by default, but is adjustable using <b><a href="../man3/mallopt.3.html">mallopt</a></b>(3).  Prior to Linux 4.7  allocations  performed  using
       <b><a href="../man2/mmap.2.html">mmap</a></b>(2)  were  unaffected by the <b>RLIMIT_DATA</b> resource limit; since Linux 4.7, this limit is also enforced
       for allocations performed using <b><a href="../man2/mmap.2.html">mmap</a></b>(2).

       To avoid corruption in multithreaded applications, mutexes are used internally  to  protect  the  memory-
       management  data structures employed by these functions.  In a multithreaded application in which threads
       simultaneously allocate and free memory, there could be contention for these mutexes.  To scalably handle
       memory allocation in multithreaded applications, glibc creates additional  <u>memory</u>  <u>allocation</u>  <u>arenas</u>  if
       mutex contention is detected.  Each arena is a large region of memory that is internally allocated by the
       system (using <b><a href="../man2/brk.2.html">brk</a></b>(2) or <b><a href="../man2/mmap.2.html">mmap</a></b>(2)), and managed with its own mutexes.

       If your program uses a private memory allocator, it should do so by replacing <b>malloc</b>(), <b>free</b>(), <b>calloc</b>(),
       and  <b>realloc</b>().  The replacement functions must implement the documented glibc behaviors, including <u>errno</u>
       handling, size-zero allocations, and overflow checking; otherwise, other library routines  may  crash  or
       operate  incorrectly.   For  example,  if  the replacement <u>free</u>() does not preserve <u>errno</u>, then seemingly
       unrelated library routines may fail without having a valid reason in <u>errno</u>.   Private  memory  allocators
       may also need to replace other glibc functions; see "Replacing malloc" in the glibc manual for details.

       Crashes  in  memory  allocators  are  almost  always  related  to heap corruption, such as overflowing an
       allocated chunk or freeing the same pointer twice.

       The <b>malloc</b>() implementation is tunable via environment variables; see <b><a href="../man3/mallopt.3.html">mallopt</a></b>(3) for details.

   <b>Nonportable</b> <b>behavior</b>
       The behavior of these functions when the requested size is zero is glibc specific; other  implementations
       may  return  NULL  without setting <u>errno</u>, and portable POSIX programs should tolerate such behavior.  See
       <b><a href="../man3p/realloc.3p.html">realloc</a></b>(3p).

       POSIX requires memory allocators to set <u>errno</u> upon failure.  However, the C  standard  does  not  require
       this, and applications portable to non-POSIX platforms should not assume this.

       Portable  programs  should  not  use  private memory allocators, as POSIX and the C standard do not allow
       replacement of <b>malloc</b>(), <b>free</b>(), <b>calloc</b>(), and <b>realloc</b>().

</pre><h4><b>EXAMPLES</b></h4><pre>
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;stddef.h&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;

       #define MALLOCARRAY(n, type)  ((type *) my_mallocarray(n, sizeof(type)))
       #define MALLOC(type)          MALLOCARRAY(1, type)

       static inline void *my_mallocarray(size_t nmemb, size_t size);

       int
       main(void)
       {
           char  *p;

           p = MALLOCARRAY(32, char);
           if (p == NULL)
               err(EXIT_FAILURE, "malloc");

           strlcpy(p, "foo", 32);
           puts(p);
       }

       static inline void *
       my_mallocarray(size_t nmemb, size_t size)
       {
           return reallocarray(NULL, nmemb, size);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/valgrind.1.html">valgrind</a></b>(1), <b><a href="../man2/brk.2.html">brk</a></b>(2), <b><a href="../man2/mmap.2.html">mmap</a></b>(2), <b><a href="../man3/alloca.3.html">alloca</a></b>(3), <b><a href="../man3/malloc_get_state.3.html">malloc_get_state</a></b>(3), <b><a href="../man3/malloc_info.3.html">malloc_info</a></b>(3), <b><a href="../man3/malloc_trim.3.html">malloc_trim</a></b>(3),
       <b><a href="../man3/malloc_usable_size.3.html">malloc_usable_size</a></b>(3), <b><a href="../man3/mallopt.3.html">mallopt</a></b>(3), <b><a href="../man3/mcheck.3.html">mcheck</a></b>(3), <b><a href="../man3/mtrace.3.html">mtrace</a></b>(3), <b><a href="../man3/posix_memalign.3.html">posix_memalign</a></b>(3)

       For details of the GNU C library implementation, see https://sourceware.org/glibc/wiki/MallocInternals.

Linux man-pages 6.9.1                              2024-05-02                                          <u><a href="../man3/malloc.3.html">malloc</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>