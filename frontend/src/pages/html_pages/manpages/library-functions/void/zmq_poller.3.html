<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zmq_poller - input/output multiplexing</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libzmq3-dev">libzmq3-dev_4.3.5-1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       zmq_poller - input/output multiplexing

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>void</b> <b>*zmq_poller_new</b> <b>(void);</b>

       <b>int</b> <b>zmq_poller_destroy</b> <b>(void</b> <b>**poller_p);</b>

       <b>int</b> <b>zmq_poller_size</b> <b>(void</b> <u>*poller</u><b>);</b>

       <b>int</b> <b>zmq_poller_add</b> <b>(void</b> <u>*poller</u><b>,</b> <b>void</b> <u>*socket</u><b>,</b> <b>void</b> <u>*user_data</u><b>,</b> <b>short</b> <u>events</u><b>);</b>

       <b>int</b> <b>zmq_poller_modify</b> <b>(void</b> <u>*poller</u><b>,</b> <b>void</b> <u>*socket</u><b>,</b> <b>short</b> <u>events</u><b>);</b>

       <b>int</b> <b>zmq_poller_remove</b> <b>(void</b> <u>*poller</u><b>,</b> <b>void</b> <u>*socket</u><b>);</b>

       <b>int</b> <b>zmq_poller_add_fd</b> <b>(void</b> <u>*poller</u><b>,</b> <b>int</b> <u>fd</u><b>,</b> <b>void</b> <u>*user_data</u><b>,</b> <b>short</b> <u>events</u><b>);</b>

       <b>int</b> <b>zmq_poller_modify_fd</b> <b>(void</b> <u>*poller</u><b>,</b> <b>int</b> <u>fd</u><b>,</b> <b>short</b> <u>events</u><b>);</b>

       <b>int</b> <b>zmq_poller_remove_fd</b> <b>(void</b> <u>*poller</u><b>,</b> <b>int</b> <u>fd</u><b>);</b>

       <b>int</b> <b>zmq_poller_wait</b> <b>(void</b> <u>*poller</u><b>,</b> <b>zmq_poller_event_t</b> <u>*event</u><b>,</b> <b>long</b> <u>timeout</u><b>);</b>

       <b>int</b> <b>zmq_poller_wait_all</b> <b>(void</b> <u>*poller</u><b>,</b> <b>zmq_poller_event_t</b> <u>*events</u><b>,</b> <b>int</b> <u>n_events</u><b>,</b> <b>long</b> <u>timeout</u><b>);</b>

       <b>int</b> <b>zmq_poller_fd</b> <b>(void</b> <u>*poller</u><b>,</b> <b>zmq_fd_t</b> <u>*fd</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>zmq_poller</u>*_ functions provide a mechanism for applications to multiplex input/output events in a
       level-triggered fashion over a set of sockets.

       <u>zmq_poller_new</u> and <u>zmq_poller_destroy</u> manage the lifetime of a poller instance. <u>zmq_poller_new</u> creates
       and returns a new poller instance, while <u>zmq_poller_destroy</u> destroys it. A pointer to a valid poller must
       be passed as the <u>poller_p</u> argument of <u>zmq_poller_destroy</u>. In particular, <u>zmq_poller_destroy</u> may not be
       called multiple times for the same poller instance. <u>zmq_poller_destroy</u> sets the passed pointer to NULL in
       case of a successful execution. <u>zmq_poller_destroy</u> implicitly unregisters all registered sockets and file
       descriptors.

       <u>zmq_poller_size</u> queries the number of sockets or file descriptors registered with a poller. The initial
       size of a poller is 0, a successful add operation increases the size by 1 and a successful remove
       operation decreases the size by 1. The size is unaffected by the events specified.

       <u>zmq_poller_add</u>, <u>zmq_poller_modify</u> and <u>zmq_poller_remove</u> manage the 0MQ sockets registered with a poller.

       <u>zmq_poller_add</u> registers a new <u>socket</u> with a given <u>poller</u>. Both <u>poller</u> and <u>socket</u> must point to valid 0MQ
       objects. The <u>events</u> parameter specifies which event types the client wants to subscribe to. It is legal
       to specify no events (i.e. 0), and activate them later with <u>zmq_poller_modify</u>. In addition, <u>user_data</u> may
       be specified, which is not used by the poller, but passed back to the caller when an event was signalled
       in a call to <u>zmq_poller_wait</u> or <u>zmq_poller_wait_all</u>. <u>user_data</u> may be NULL. If it is not NULL, it must be
       a valid pointer. Otherwise, behaviour is undefined. You must only add a socket to a single poller
       instance once (unless <u>zmq_poller_remove</u> has been called for that socket before). You may add a socket to
       multiple poller instances, if the socket itself is explicitly thread-safe (Server, Client, ...). If the
       socket is not, you may invoke undefined behavior.

       <u>zmq_poller_modify</u> modifies the subscribed events for a socket. It is legal to specify no events (i.e. 0)
       to disable events temporarily, and reactivate them later with another call to <u>zmq_poller_modify</u>.

       <u>zmq_poller_remove</u> removes a socket registration completely. <u>zmq_poller_remove</u> must be called before a
       socket is closed with <u>zmq_close</u>.

       Note that it is not necessary to call <u>zmq_poller_remove</u> for any socket before calling <u>zmq_poller_destroy</u>.

       Also note that calling <u>zmq_poller_remove</u> is not equivalent to calling <u>zmq_poller_modify</u> with no events.
       <u>zmq_poller_modify</u> does not free resources associated with the socket registration, and requires that the
       <u>socket</u> remains valid.

       <u>zmq_poller_add_fd</u>, <u>zmq_poller_modify_fd</u> and <u>zmq_poller_remove_fd</u> are analogous to the previous functions
       but manage regular file descriptors registered with a poller. On Windows, these functions can only be
       used with WinSock sockets.

       In the following, 0MQ sockets added with <u>zmq_poller_add</u> and file descriptors added with <u>zmq_poller_add_fd</u>
       are referred to as <u>registered</u> <u>objects</u>.

       The <b>zmq_poller_event_t</b> structure is defined as follows:

           typedef struct
           {
               void *socket;
               zmq_fd_t fd;
               void *user_data;
               short events;
           } zmq_poller_event_t;

       For each registered object, <u>zmq_poller_wait_all()</u> shall examine the registered objects for the event(s)
       currently registered.

       If none of the registered events have occurred, <u>zmq_poller_wait_all</u> shall wait <u>timeout</u> milliseconds for
       an event to occur on any of the registered objects. If the value of <u>timeout</u> is 0, <u>zmq_poller_wait_all</u>
       shall return immediately. If the value of <u>timeout</u> is -1, <u>zmq_poller_wait_all</u> shall block indefinitely
       until one event has occurred on any of the registered objects.

       The <u>events</u> argument <u>zmq_poller_wait_all</u> must be a pointer to an array of at least <u>n_events</u> elements.
       Behaviour is undefined if <u>events</u> does not point to an array of at least <u>n_events</u> elements.

       <u>zmq_poller_wait_all</u> returns at most <u>n_events</u> events. If more than <u>n_events</u> events were signalled, only an
       unspecified subset of the signalled events is returned through <u>events</u>.

       A caller is advised to ensure that <u>n_events</u> is equal to the number of registered objects. Otherwise, a
       livelock situation may result: If more than <u>n_events</u> registered objects have an active event on each call
       to <u>zmq_poller_wait_all</u>, it might happen that the same subset of registered objects is always returned,
       and the caller never notices the events on the others. The number of objects registered can be queried
       with <u>zmq_poller_size</u>.

       <u>zmq_poller_wait_all</u> returns the number of valid elements. The valid elements are placed in positions <u>0</u> to
       <u>n_events</u> <u>-</u> <u>1</u> in the <u>events</u> array. All members of a valid element are set to valid values by
       <u>zmq_poller_wait_all</u>. For socket events <u>socket</u> is non-null and <u>fd</u> is an operating system specific value
       for an invalid socket (-1 or INVALID_SOCKET). For fd events <u>socket</u> is NULL and <u>fd</u> is a valid file
       descriptor. The client does therefore not need to initialize the contents of the events array before a
       call to <u>zmq_poller_wait_all</u>. It is unspecified whether the the remaining elements of <u>events</u> are written
       to by <u>zmq_poller_wait_all</u>.

       <u>zmq_poller_fd</u> queries the file descriptor associated with the zmq_poller, and stores it in the address
       pointer to by <u>fd</u>. The zmq_poller is only guaranteed to have a file descriptor if at least one thread-safe
       socket is currently registered.

       Note that closing a socket that is registered in a poller leads to undefined behavior. The socket must be
       unregistered first.

</pre><h4><b>EVENT</b> <b>TYPES</b></h4><pre>
       The <u>events</u> parameter of <u>zmq_poller_add</u> and <u>zmq_poller_modify</u>, and the <u>events</u> member of the
       zmq_poller_event_t structure are bit masks constructed by ORâ€™ing a combination of the following event
       flags:

       <b>ZMQ_POLLIN</b>
           For 0MQ sockets, at least one message may be received from the <u>socket</u> without blocking. For standard
           sockets this is equivalent to the <u>POLLIN</u> flag of the <u>poll()</u> system call and generally means that at
           least one byte of data may be read from <u>fd</u> without blocking.

       <b>ZMQ_POLLOUT</b>
           For 0MQ sockets, at least one message may be sent to the <u>socket</u> without blocking. For standard
           sockets this is equivalent to the <u>POLLOUT</u> flag of the <u>poll()</u> system call and generally means that at
           least one byte of data may be written to <u>fd</u> without blocking.

       <b>ZMQ_POLLERR</b>
           For 0MQ sockets this flag has no effect on the <u>zmq_poller_add</u> and <u>zmq_poller_modify</u> functions, and is
           never set in the <u>events</u> member of the zmq_poller_event_t structure. For standard sockets, this flag
           is passed through <u>zmq_poller_wait_all</u> to the underlying <u>poll()</u> system call and generally means that
           some sort of error condition is present on the socket specified by <u>fd</u>.

       <b>ZMQ_POLLPRI</b>
           For 0MQ sockets this flag has no effect on the <u>zmq_poller_add</u> and <u>zmq_poller_modify</u> functions, and is
           never set in the <u>events</u> member of the zmq_poller_event_t structure. For standard sockets this means
           there is urgent data to read. Refer to the POLLPRI flag for more information. For a file descriptor,
           refer to your OS documentation: as an example, GPIO interrupts are signaled through a POLLPRI event.
           This flag has no effect on Windows.

           <b>Note</b>

           The <u>zmq_poller</u>*_ functions may be implemented or emulated using operating system interfaces other
           than <u>poll()</u>, and as such may be subject to the limits of those interfaces in ways not defined in this
           documentation.

</pre><h4><b>THREAD</b> <b>SAFETY</b></h4><pre>
       Like most other 0MQ objects, a poller is not thread-safe. All operations must be called from the same
       thread. Otherwise, behaviour is undefined.

       In addition to that, if you want to add a socket to multiple existing poller instances, the socket itself
       needs to be thread-safe (Server, Client, ...). Otherwise, behaviour is undefined.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <u>zmq_poller_new</u> returns a valid pointer to a poller, or NULL in case of a failure.

       All functions that return an int, return -1 in case of a failure. In that case, zmq_errno() can be used
       to query the type of the error as described below.

       <u>zmq_poller_wait_all</u> returns the number of events signalled and returned in the events array. It never
       returns 0.

       All other functions return 0 in case of a successful execution.

</pre><h4><b>ERRORS</b></h4><pre>
       On <u>zmq_poller_new</u>:

       <b>ENOMEM</b>
           A new poller could not be allocated successfully.

       On <u>zmq_poller_destroy</u>:

       <b>EFAULT</b>
           <u>poller_p</u> did not point to a valid poller. Note that passing an invalid pointer (e.g. pointer to
           deallocated memory) may cause undefined behaviour (e.g. an access violation).

       On <u>zmq_poller_size</u>:

       <b>EFAULT</b>
           <u>poller</u> did not point to a valid poller. Note that passing an invalid pointer (e.g. pointer to
           deallocated memory) may cause undefined behaviour (e.g. an access violation).

       On <u>zmq_poller_add</u>, <u>zmq_poller_modify</u> and <u>zmq_poller_remove</u>:

       <b>EFAULT</b>
           <u>poller</u> did not point to a valid poller. Note that passing an invalid pointer (e.g. pointer to
           deallocated memory) may cause undefined behaviour (e.g. an access violation).

       <b>ENOTSOCK</b>
           <u>socket</u> did not point to a valid socket. Note that passing an invalid pointer (e.g. pointer to
           deallocated memory) may cause undefined behaviour (e.g. an access violation).

       On <u>zmq_poller_add</u>:

       <b>EMFILE</b>
           TODO

       On <u>zmq_poller_add</u> or <u>zmq_poller_add_fd</u>:

       <b>ENOMEM</b>
           Necessary resources could not be allocated.

       <b>EINVAL</b>
           <u>socket</u> resp.  <u>fd</u> was already registered with the poller.

       On <u>zmq_poller_modify</u>, <u>zmq_poller_modify_fd</u>, <u>zmq_poller_remove</u> or <u>zmq_poller_remove_fd</u>:

       <b>EINVAL</b>
           <u>socket</u> resp.  <u>fd</u> was not registered with the poller.

       On <u>zmq_poller_add_fd</u>, <u>zmq_poller_modify_fd</u> and <u>zmq_poller_remove_fd</u>:

       <b>EBADF</b>
           The <u>fd</u> specified was the retired fd.

       On <u>zmq_poller_wait</u> and <u>zmq_poller_wait_all</u>:

       <b>ENOMEM</b>
           Necessary resources could not be allocated.

       <b>ETERM</b>
           At least one of the registered objects is a <u>socket</u> whose associated 0MQ <u>context</u> was terminated.

       <b>EFAULT</b>
           The provided <u>events</u> was NULL, or <u>poller</u> did not point to a valid poller, or there are no registered
           objects or all event subscriptions are disabled and <u>timeout</u> was negative.

       <b>EINTR</b>
           The operation was interrupted by delivery of a signal before any events were available.

       <b>EAGAIN</b>
           No registered event was signalled before the timeout was reached.

       On <u>zmq_poller_fd</u>:

       <b>EINVAL</b>
           The poller has no associated file descriptor.

       <b>EFAULT</b>
           The provided <u>poller</u> did not point to a valid poller.

</pre><h4><b>EXAMPLE</b></h4><pre>
       <b>Polling</b> <b>indefinitely</b> <b>for</b> <b>input</b> <b>events</b> <b>on</b> <b>both</b> <b>a</b> <b>0MQ</b> <b>socket</b> <b>and</b> <b>a</b> <b>standard</b> <b>socket.</b>.

           void *poller = zmq_poller_new ();

           /* First item refers to 0MQ socket 'socket' */
           zmq_poller_add (poller, socket, NULL, ZMQ_POLLIN);
           /* Second item refers to standard socket 'fd' */
           zmq_poller_add_fd (poller, fd, NULL, ZMQ_POLLIN);

           zmq_poller_event_t events [2];
           /* Poll for events indefinitely */
           int rc = zmq_poller_wait_all (poller, events, 2, -1);
           assert (rc &gt;= 0);
           /* Returned events will be stored in 'events' */
           for (int i = 0; i &lt; 2; ++i) {
               if (events[i].socket == socket &amp;&amp; events[i].events &amp; ZMQ_POLLIN) {
                   // ...
               } else if (events[i].fd == fd &amp;&amp; events[i].events &amp; ZMQ_POLLIN)) {
                   // ...
               }
           }
           zmq_poller_destroy (&amp;poller);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/zmq_socket.3.html">zmq_socket</a></b>(3) <b><a href="../man3/zmq_send.3.html">zmq_send</a></b>(3) <b><a href="../man3/zmq_recv.3.html">zmq_recv</a></b>(3) <b><a href="../man7/zmq.7.html">zmq</a></b>(7)

</pre><h4><b>AUTHORS</b></h4><pre>
       This page was written by the 0MQ community. To make a change please read the 0MQ Contribution Policy at
       <b><a href="http://www.zeromq.org/docs">http://www.zeromq.org/docs</a>:contributing</b>.

0MQ 4.3.5                                          03/31/2024                                      <u><a href="../man3/ZMQ_POLLER.3.html">ZMQ_POLLER</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>