<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dispatch_source_create — dispatch event sources</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libdispatch-dev">libdispatch-dev_0~svn197-3.3ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dispatch_source_create — dispatch event sources

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;dispatch/dispatch.h&gt;</b>

       <u>dispatch_source_t</u>
       <b>dispatch_source_create</b>(<u>dispatch_source_type_t</u> <u>type</u>,         <u>uintptr_t</u> <u>handle</u>,         <u>unsigned</u> <u>long</u> <u>mask</u>,
           <u>dispatch_queue_t</u> <u>queue</u>);

       <u>void</u>
       <b>dispatch_source_set_event_handler</b>(<u>dispatch_source_t</u> <u>source</u>, <u>void</u> <u>(^block)(void)</u>);

       <u>void</u>
       <b>dispatch_source_set_event_handler_f</b>(<u>dispatch_source_t</u> <u>source</u>, <u>void</u> <u>(*function)(void</u> <u>*)</u>);

       <u>void</u>
       <b>dispatch_source_set_cancel_handler</b>(<u>dispatch_source_t</u> <u>source</u>, <u>void</u> <u>(^block)(void)</u>);

       <u>void</u>
       <b>dispatch_source_set_cancel_handler_f</b>(<u>dispatch_source_t</u> <u>source</u>, <u>void</u> <u>(*function)(void</u> <u>*)</u>);

       <u>void</u>
       <b>dispatch_source_cancel</b>(<u>dispatch_source_t</u> <u>source</u>);

       <u>void</u>
       <b>dispatch_source_testcancel</b>(<u>dispatch_source_t</u> <u>source</u>);

       <u>uintptr_t</u>
       <b>dispatch_source_get_handle</b>(<u>dispatch_source_t</u> <u>source</u>);

       <u>unsigned</u> <u>long</u>
       <b>dispatch_source_get_mask</b>(<u>dispatch_source_t</u> <u>source</u>);

       <u>unsigned</u> <u>long</u>
       <b>dispatch_source_get_data</b>(<u>dispatch_source_t</u> <u>source</u>);

       <u>void</u>
       <b>dispatch_source_merge_data</b>(<u>dispatch_source_t</u> <u>source</u>, <u>unsigned</u> <u>long</u> <u>data</u>);

       <u>void</u>
       <b>dispatch_source_set_timer</b>(<u>dispatch_source_t</u> <u>source</u>,       <u>dispatch_time_t</u> <u>start</u>,       <u>uint64_t</u> <u>interval</u>,
           <u>uint64_t</u> <u>leeway</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Dispatch  event  sources  may  be  used  to monitor a variety of system objects and events including file
       descriptors, mach ports, processes, virtual filesystem nodes, signal delivery and timers.

       When a state change occurs, the dispatch source will submit its event handler block to its target queue.

       The <b>dispatch_source_create</b>() function creates a new dispatch source  object  that  may  be  retained  and
       released  with  calls to <b>dispatch_retain</b>() and <b>dispatch_release</b>() respectively. Newly created sources are
       created in a suspended state. After  the  source  has  been  configured  by  setting  an  event  handler,
       cancellation  handler,  context, etc., the source must be activated by a call to <b>dispatch_resume</b>() before
       any events will be delivered.

       Dispatch sources may be one of the following types:
             <b>•</b>   DISPATCH_SOURCE_TYPE_DATA_ADD
             <b>•</b>   DISPATCH_SOURCE_TYPE_DATA_OR
             <b>•</b>   DISPATCH_SOURCE_TYPE_MACH_SEND
             <b>•</b>   DISPATCH_SOURCE_TYPE_MACH_RECV
             <b>•</b>   DISPATCH_SOURCE_TYPE_PROC
             <b>•</b>   DISPATCH_SOURCE_TYPE_READ
             <b>•</b>   DISPATCH_SOURCE_TYPE_SIGNAL
             <b>•</b>   DISPATCH_SOURCE_TYPE_TIMER
             <b>•</b>   DISPATCH_SOURCE_TYPE_VNODE
             <b>•</b>   DISPATCH_SOURCE_TYPE_WRITE

       The  <u>handle</u>  and  <u>mask</u>  arguments  to   <b>dispatch_source_create</b>()   and   the   return   values   of   the
       <b>dispatch_source_get_handle</b>(), <b>dispatch_source_get_mask</b>(), and <b>dispatch_source_get_data</b>() functions should
       be interpreted according to the type of the dispatch source.

       The <b>dispatch_source_get_handle</b>() function returns the underlying handle to the dispatch source (i.e. file
       descriptor,  mach port, process identifer, etc.). The result of this function may be cast directly to the
       underlying type.

       The <b>dispatch_source_get_mask</b>() function returns the set of flags that were specified at  source  creation
       time via the <u>mask</u> argument.

       The <b>dispatch_source_get_data</b>() function returns the currently pending data for the dispatch source.  This
       function  should  only  be  called  from  within  the source's event handler.  The result of calling this
       function from any other context is undefined.

       The <b>dispatch_source_merge_data</b>() function is intended for use with the <u>DISPATCH_SOURCE_TYPE_DATA_ADD</u>  and
       <u>DISPATCH_SOURCE_TYPE_DATA_OR</u>  source  types. The result of using this function with any other source type
       is undefined. Calling this function will atomically add or logical OR the data into  the  source's  data,
       and trigger the delivery of the source's event handler.

</pre><h4><b>SOURCE</b> <b>EVENT</b> <b>HANDLERS</b></h4><pre>
       In  order  to  receive  events  from  the  dispatch  source,  an  event  handler  should be specified via
       <b>dispatch_source_set_event_handler</b>().  The event handler block is submitted to the source's  target  queue
       when the state of the underlying system handle changes, or when an event occurs.

       Dispatch   sources   may   be   suspended   or   resumed  independently  of  their  target  queues  using
       <b>dispatch_suspend</b>() and <b>dispatch_resume</b>() on the dispatch source  directly.  The  data  describing  events
       which occur while a source is suspended are coalesced and delivered once the source is resumed.

       The  <u>handler</u>  block  need  not  be reentrant safe, as it is not resubmitted to the target <u>queue</u> until any
       prior invocation for that dispatch source has completed.  When the handler is set,  the  dispatch  source
       will perform a <b>Block_copy</b>() on the <u>handler</u> block.

</pre><h4><b>CANCELLATION</b></h4><pre>
       The  <b>dispatch_source_cancel</b>() function asynchronously cancels the dispatch source, preventing any further
       invocation of its event handler block. Cancellation does not  interrupt  a  currently  executing  handler
       block (non-preemptive).

       The  <b>dispatch_source_testcancel</b>() function may be used to determine whether the specified source has been
       canceled. A non-zero value will be returned if the source is canceled.

       When a dispatch source is canceled its optional cancellation handler will  be  submitted  to  its  target
       queue.  The  cancellation  handler  may  be  specified  via  <b>dispatch_source_set_cancel_handler</b>().   This
       cancellation  handler  is  invoked  only  once,  and  only   as   a   direct   consequence   of   calling
       <b>dispatch_source_cancel</b>().

       <u>Important:</u> a cancellation handler is required for file descriptor and mach port based sources in order to
       safely  close  the descriptor or destroy the port. Closing the descriptor or port before the cancellation
       handler has run may result in a race condition: if a new descriptor is allocated with the same  value  as
       the  recently  closed descriptor while the source's event handler is still running, the event handler may
       read/write data to the wrong descriptor.

</pre><h4><b>DISPATCH</b> <b>SOURCE</b> <b>TYPES</b></h4><pre>
       The following section contains a summary of supported dispatch event  types  and  the  interpretation  of
       their parameters and returned data.

       <u>DISPATCH_SOURCE_TYPE_DATA_ADD</u>, <u>DISPATCH_SOURCE_TYPE_DATA_OR</u>

       Sources  of  this  type  allow  applications to manually trigger the source's event handler via a call to
       <b>dispatch_source_merge_data</b>().  The data will be merged with the source's pending data via an  atomic  add
       or  logic  OR (based on the source's type), and the event handler block will be submitted to the source's
       target queue. The <u>data</u> is application defined. These sources have no <u>handle</u> or <u>mask</u> and  zero  should  be
       used.

       <u>DISPATCH_SOURCE_TYPE_MACH_SEND</u>

       Sources  of  this  type  monitor a mach port with a send right for state changes.  The <u>handle</u> is the mach
       port (mach_port_t) to monitor and the <u>mask</u> may be:
             • DISPATCH_MACH_SEND_DEAD
                                     The port's corresponding receive right has been destroyed

       The data returned by <b>dispatch_source_get_data</b>() indicates which of the events in the <u>mask</u> were observed.

       <u>DISPATCH_SOURCE_TYPE_MACH_RECV</u>

       Sources of this type monitor a mach port with a receive right for state changes.  The <u>handle</u> is the  mach
       port (mach_port_t) to monitor and the <u>mask</u> is unused and should be zero.  The event handler block will be
       submitted to the target queue when a message on the mach port is waiting to be received.

       <u>DISPATCH_SOURCE_TYPE_PROC</u>

       Sources  of  this type monitor processes for state changes.  The <u>handle</u> is the process identifier (pid_t)
       of the process to monitor and the <u>mask</u> may be one or more of the following:
             • DISPATCH_PROC_EXIT    The process has exited and is available to <u><a href="../man2/wait.2.html">wait</a></u>(2).
             • DISPATCH_PROC_FORK    The process has created one or more child processes.
             • DISPATCH_PROC_EXEC    The process has become another executable image via a call to <u><a href="../man2/execve.2.html">execve</a></u>(2)  or
                                     <u><a href="../man2/posix_spawn.2.html">posix_spawn</a></u>(2).
             • DISPATCH_PROC_REAP    The process status has been collected by its parent process via <u><a href="../man2/wait.2.html">wait</a></u>(2).
             • DISPATCH_PROC_SIGNAL  A signal was delivered to the process.

       The data returned by <b>dispatch_source_get_data</b>() indicates which of the events in the <u>mask</u> were observed.

       <u>DISPATCH_SOURCE_TYPE_READ</u>

       Sources  of this type monitor file descriptors for pending data.  The <u>handle</u> is the file descriptor (int)
       to monitor and the <u>mask</u> is unused and should be zero.

       The data returned by <b>dispatch_source_get_data</b>() is an estimated number of bytes available to be read from
       the descriptor. This estimate should be treated as a suggested <u>minimum</u> read buffer  size.  There  are  no
       guarantees that a complete read of this size will be performed.

       Users  of  this  source type are strongly encouraged to perform non-blocking I/O and handle any truncated
       reads or error conditions that may occur. See <u><a href="../man2/fcntl.2.html">fcntl</a></u>(2)  for  additional  information  about  setting  the
       <u>O_NONBLOCK</u> flag on a file descriptor.

       <u>DISPATCH_SOURCE_TYPE_SIGNAL</u>

       Sources of this type monitor signals delivered to the current process. The <u>handle</u> is the signal number to
       monitor (int) and the <u>mask</u> is unused and should be zero.

       The  data  returned  by  <b>dispatch_source_get_data</b>()  is  the  number  of  signals received since the last
       invocation of the event handler block.

       Unlike signal handlers specified via <b>sigaction</b>(), the execution of  the  event  handler  block  does  not
       interrupt  the  current  thread  of  execution;  therefore the handler block is not limited to the use of
       signal safe interfaces defined in <u><a href="../man2/sigaction.2.html">sigaction</a></u>(2).  Furthermore, multiple observers of a  given  signal  are
       supported;  thus allowing applications and libraries to cooperate safely. However, a dispatch source <u>does</u>
       <u>not</u> install a signal handler or otherwise alter the behavior of signal delivery.  Therefore, applications
       must ignore or at least catch any signal that terminates a process by default. For example, near the  top
       of <b>main</b>():

            signal(SIGTERM, SIG_IGN);

       <u>DISPATCH_SOURCE_TYPE_TIMER</u>

       Sources  of  this  type  periodically  submit  the event handler block to the target queue on an interval
       specified by <b>dispatch_source_set_timer</b>().  The <u>handle</u> and <u>mask</u> arguments are unused and should be zero.

       A best effort attempt is made to submit the event handler block to the  target  queue  at  the  specified
       time; however, actual invocation may occur at a later time.

       The data returned by <b>dispatch_source_get_data</b>() is the number of times the timer has fired since the last
       invocation of the event handler block.

       The  function  <b>dispatch_source_set_timer</b>() takes as an argument the <u>start</u> time of the timer (initial fire
       time) represented as a <u>dispatch_time_t</u>.  The timer dispatch  source  will  use  the  same  clock  as  the
       function  used  to  create  this  value.  (See  <u><a href="../man3/dispatch_time.3.html">dispatch_time</a></u>(3)  for more information.) The <u>interval</u>, in
       nanoseconds, specifies the period at which the timer should repeat. All timers will  repeat  indefinitely
       until <b>dispatch_source_cancel</b>() is called. The <u>leeway</u>, in nanoseconds, is a hint to the system that it may
       defer  the  timer in order to align with other system activity for improved system performance or reduced
       power consumption. (For example, an application might perform a periodic task  every  5  minutes  with  a
       leeway of up to 30 seconds.) Note that some latency is to be expected for all timers even when a value of
       zero is used.

       <u>Note</u>:  Under  the  C  language, untyped numbers default to the <u>int</u> type. This can lead to truncation bugs
       when arithmetic operations with other numbers are expected to generate a <u>uint64_t</u> sized result.  When  in
       doubt, use <u>ull</u> as a suffix. For example:

             3ull * NSEC_PER_SEC

       <u>DISPATCH_SOURCE_TYPE_VNODE</u>

       Sources  of  this  type  monitor  the  virtual  filesystem nodes for state changes.  The <u>handle</u> is a file
       descriptor (int) referencing the node to monitor, and the <u>mask</u> may be one or more of the following:
             • DISPATCH_VNODE_DELETE  The  referenced  node  was  removed  from  the  filesystem  namespace  via
                                      <u><a href="../man2/unlink.2.html">unlink</a></u>(2).
             • DISPATCH_VNODE_WRITE   A write to the referenced file occurred
             • DISPATCH_VNODE_EXTEND  The referenced file was extended
             • DISPATCH_VNODE_ATTRIB  The metadata attributes of the referenced node have changed
             • DISPATCH_VNODE_LINK    The link count on the referenced node has changed
             • DISPATCH_VNODE_RENAME  The referenced node was renamed
             • DISPATCH_VNODE_REVOKE  Access  to the referenced node was revoked via <u><a href="../man2/revoke.2.html">revoke</a></u>(2) or the underlying
                                      fileystem was unmounted.

       The data returned by <b>dispatch_source_get_data</b>() indicates which of the events in the <u>mask</u> were observed.

       <u>DISPATCH_SOURCE_TYPE_WRITE</u>

       Sources of this type monitor file descriptors for available write buffer space.  The <u>handle</u> is  the  file
       descriptor (int) to monitor and the <u>mask</u> is unused and should be zero.

       Users  of  this  source type are strongly encouraged to perform non-blocking I/O and handle any truncated
       reads or error conditions that may occur. See <u><a href="../man2/fcntl.2.html">fcntl</a></u>(2)  for  additional  information  about  setting  the
       <u>O_NONBLOCK</u> flag on a file descriptor.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/dispatch.3.html">dispatch</a></u>(3), <u><a href="../man3/dispatch_object.3.html">dispatch_object</a></u>(3), <u><a href="../man3/dispatch_queue_create.3.html">dispatch_queue_create</a></u>(3)

Darwin                                             May 1, 2009                         <u><a href="../man3/dispatch_source_create.3.html">dispatch_source_create</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>