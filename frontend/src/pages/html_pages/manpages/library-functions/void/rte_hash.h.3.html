<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rte_hash.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dpdk-doc">dpdk-doc_24.11.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rte_hash.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;stddef.h&gt;
       #include &lt;rte_rcu_qsbr.h&gt;

   <b>Data</b> <b>Structures</b>
       struct <b>rte_hash_parameters</b>
       struct <b>rte_hash_rcu_config</b>

   <b>Macros</b>
       #define <b>RTE_HASH_ENTRIES_MAX</b>   (1 &lt;&lt; 30)
       #define <b>RTE_HASH_NAMESIZE</b>   32
       #define <b>RTE_HASH_LOOKUP_BULK_MAX</b>   64
       #define <b>RTE_HASH_EXTRA_FLAGS_TRANS_MEM_SUPPORT</b>   0x01
       #define <b>RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD</b>   0x02
       #define <b>RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY</b>   0x04
       #define <b>RTE_HASH_EXTRA_FLAGS_EXT_TABLE</b>   0x08
       #define <b>RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL</b>   0x10
       #define <b>RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF</b>   0x20

   <b>Typedefs</b>
       <b>typedef</b> uint32_t <b>hash_sig_t</b>
       <b>typedef</b> uint32_t(* <b>rte_hash_function</b>) (const void *key, uint32_t key_len, uint32_t init_val)
       <b>typedef</b> int(* <b>rte_hash_cmp_eq_t</b>) (const void *key1, const void *key2, size_t key_len)
       <b>typedef</b> void(* <b>rte_hash_free_key_data</b>) (void *p, void *key_data)

   <b>Enumerations</b>
       enum <b>rte_hash_qsbr_mode</b> { <b>RTE_HASH_QSBR_MODE_DQ</b> = 0, <b>RTE_HASH_QSBR_MODE_SYNC</b> }

   <b>Functions</b>
       struct <b>rte_hash</b> * <b>rte_hash_create</b> (const struct <b>rte_hash_parameters</b> *params)
       void <b>rte_hash_set_cmp_func</b> (struct <b>rte_hash</b> *h, <b>rte_hash_cmp_eq_t</b> func)
       struct <b>rte_hash</b> * <b>rte_hash_find_existing</b> (const char *name)
       void <b>rte_hash_free</b> (struct <b>rte_hash</b> *h)
       void <b>rte_hash_reset</b> (struct <b>rte_hash</b> *h)
       int32_t <b>rte_hash_count</b> (const struct <b>rte_hash</b> *h)
       int32_t <b>rte_hash_max_key_id</b> (const struct <b>rte_hash</b> *h)
       int <b>rte_hash_add_key_data</b> (const struct <b>rte_hash</b> *h, const void *key, void *data)
       int32_t <b>rte_hash_add_key_with_hash_data</b> (const struct <b>rte_hash</b> *h, const void *key, <b>hash_sig_t</b> sig, void
           *data)
       int32_t <b>rte_hash_add_key</b> (const struct <b>rte_hash</b> *h, const void *key)
       int32_t <b>rte_hash_add_key_with_hash</b> (const struct <b>rte_hash</b> *h, const void *key, <b>hash_sig_t</b> sig)
       int32_t <b>rte_hash_del_key</b> (const struct <b>rte_hash</b> *h, const void *key)
       int32_t <b>rte_hash_del_key_with_hash</b> (const struct <b>rte_hash</b> *h, const void *key, <b>hash_sig_t</b> sig)
       int <b>rte_hash_get_key_with_position</b> (const struct <b>rte_hash</b> *h, const int32_t position, void **key)
       int <b>rte_hash_free_key_with_position</b> (const struct <b>rte_hash</b> *h, const int32_t position)
       int <b>rte_hash_lookup_data</b> (const struct <b>rte_hash</b> *h, const void *key, void **data)
       int <b>rte_hash_lookup_with_hash_data</b> (const struct <b>rte_hash</b> *h, const void *key, <b>hash_sig_t</b> sig, void
           **data)
       int32_t <b>rte_hash_lookup</b> (const struct <b>rte_hash</b> *h, const void *key)
       int32_t <b>rte_hash_lookup_with_hash</b> (const struct <b>rte_hash</b> *h, const void *key, <b>hash_sig_t</b> sig)
       <b>hash_sig_t</b> <b>rte_hash_hash</b> (const struct <b>rte_hash</b> *h, const void *key)
       int <b>rte_hash_lookup_bulk_data</b> (const struct <b>rte_hash</b> *h, const void **keys, uint32_t num_keys, uint64_t
           *hit_mask, void *data[])
       int <b>rte_hash_lookup_with_hash_bulk</b> (const struct <b>rte_hash</b> *h, const void **keys, <b>hash_sig_t</b> *sig,
           uint32_t num_keys, int32_t *positions)
       int <b>rte_hash_lookup_with_hash_bulk_data</b> (const struct <b>rte_hash</b> *h, const void **keys, <b>hash_sig_t</b> *sig,
           uint32_t num_keys, uint64_t *hit_mask, void *data[])
       int <b>rte_hash_lookup_bulk</b> (const struct <b>rte_hash</b> *h, const void **keys, uint32_t num_keys, int32_t
           *positions)
       int32_t <b>rte_hash_iterate</b> (const struct <b>rte_hash</b> *h, const void **key, void **data, uint32_t *next)
       int <b>rte_hash_rcu_qsbr_add</b> (struct <b>rte_hash</b> *h, struct <b>rte_hash_rcu_config</b> *cfg)
       __rte_experimental int <b>rte_hash_rcu_qsbr_dq_reclaim</b> (struct <b>rte_hash</b> *h, unsigned int *freed, unsigned
           int *pending, unsigned int *available)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       RTE Hash Table

       Definition in file <b>rte_hash.h</b>.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>RTE_HASH_ENTRIES_MAX</b>   <b>(1</b> <b>&lt;&lt;</b> <b>30)</b>
       Maximum size of hash table that can be created.

       Definition at line <b>24</b> of file <b>rte_hash.h</b>.

   <b>#define</b> <b>RTE_HASH_NAMESIZE</b>   <b>32</b>
       Maximum number of characters in hash name.

       Definition at line <b>27</b> of file <b>rte_hash.h</b>.

   <b>#define</b> <b>RTE_HASH_LOOKUP_BULK_MAX</b>   <b>64</b>
       Maximum number of keys that can be searched for using rte_hash_lookup_bulk.

       Definition at line <b>30</b> of file <b>rte_hash.h</b>.

   <b>#define</b> <b>RTE_HASH_EXTRA_FLAGS_TRANS_MEM_SUPPORT</b>   <b>0x01</b>
       Enable Hardware transactional memory support.

       Definition at line <b>34</b> of file <b>rte_hash.h</b>.

   <b>#define</b> <b>RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD</b>   <b>0x02</b>
       Default behavior of insertion, single writer/multi writer

       Definition at line <b>37</b> of file <b>rte_hash.h</b>.

   <b>#define</b> <b>RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY</b>   <b>0x04</b>
       Flag to support reader writer concurrency

       Definition at line <b>40</b> of file <b>rte_hash.h</b>.

   <b>#define</b> <b>RTE_HASH_EXTRA_FLAGS_EXT_TABLE</b>   <b>0x08</b>
       Flag to indicate the extendable bucket table feature should be used

       Definition at line <b>43</b> of file <b>rte_hash.h</b>.

   <b>#define</b> <b>RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL</b>   <b>0x10</b>
       Flag to disable freeing of key index on hash delete. Refer to rte_hash_del_xxx APIs for more details.
       This is enabled by default when RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF is enabled. However, if internal
       RCU is enabled, freeing of internal memory/index is done on delete

       Definition at line <b>51</b> of file <b>rte_hash.h</b>.

   <b>#define</b> <b>RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF</b>   <b>0x20</b>
       Flag to support lock free reader writer concurrency. Both single writer and multi writer use cases are
       supported.

       Definition at line <b>56</b> of file <b>rte_hash.h</b>.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>uint32_t</b> <b>hash_sig_t</b>
       The type of hash value of a key. It should be a value of at least 32bit with fully random pattern.

       Definition at line <b>62</b> of file <b>rte_hash.h</b>.

   <b>typedef</b> <b>uint32_t(*</b> <b>rte_hash_function)</b> <b>(const</b> <b>void</b> <b>*key,</b> <b>uint32_t</b> <b>key_len,</b> <b>uint32_t</b> <b>init_val)</b>
       Type of function that can be used for calculating the hash value.

       Definition at line <b>65</b> of file <b>rte_hash.h</b>.

   <b>typedef</b> <b>int(*</b> <b>rte_hash_cmp_eq_t)</b> <b>(const</b> <b>void</b> <b>*key1,</b> <b>const</b> <b>void</b> <b>*key2,</b> <b>size_t</b> <b>key_len)</b>
       Type of function used to compare the hash key.

       Definition at line <b>69</b> of file <b>rte_hash.h</b>.

   <b>typedef</b> <b>void(*</b> <b>rte_hash_free_key_data)</b> <b>(void</b> <b>*p,</b> <b>void</b> <b>*key_data)</b>
       Type of function used to free data stored in the key. Required when using internal RCU to allow
       application to free key-data once the key is returned to the ring of free key-slots.

       Definition at line <b>76</b> of file <b>rte_hash.h</b>.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>rte_hash_qsbr_mode</b>
       RCU reclamation modes

       <b>Enumerator</b>

       <u>RTE_HASH_QSBR_MODE_DQ</u>
              Create defer queue for reclaim.

       <u>RTE_HASH_QSBR_MODE_SYNC</u>
              Use blocking mode reclaim. No defer queue created.

       Definition at line <b>93</b> of file <b>rte_hash.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>struct</b> <b>rte_hash</b> <b>*</b> <b>rte_hash_create</b> <b>(const</b> <b>struct</b> <b>rte_hash_parameters</b> <b>*</b> <b>params)</b>
       Create a new hash table.

       <b>Parameters</b>
           <u>params</u> Parameters used to create and initialise the hash table.

       <b>Returns</b>
           Pointer  to hash table structure that is used in future hash table operations, or NULL on error, with
           error code set in rte_errno. Possible rte_errno errors include:

           • E_RTE_NO_CONFIG - function could not get pointer to rte_config structure

           • E_RTE_SECONDARY - function was called from a secondary process instance

           • ENOENT - missing entry

           • EINVAL - invalid parameter passed to function

           • ENOSPC - the maximum number of memzones has already been allocated

           • EEXIST - a memzone with the same name already exists

           • ENOMEM - no appropriate memory area found in which to create memzone

   <b>void</b> <b>rte_hash_set_cmp_func</b> <b>(struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>rte_hash_cmp_eq_t</b> <b>func)</b>
       Set a new hash compare function other than the default one.

       <b>Note</b>
           Function pointer does not work with multi-process, so do not use it in multi-process mode.

       <b>Parameters</b>
           <u>h</u> Hash table for which the function is to be changed
           <u>func</u> New compare function

   <b>struct</b> <b>rte_hash</b> <b>*</b> <b>rte_hash_find_existing</b> <b>(const</b> <b>char</b> <b>*</b> <b>name)</b>
       Find an existing hash table object and return a pointer to it.

       <b>Parameters</b>
           <u>name</u> Name of the hash table as passed to <b>rte_hash_create()</b>

       <b>Returns</b>
           Pointer to hash table or NULL  if  object  not  found  with  rte_errno  set  appropriately.  Possible
           rte_errno values include:

           • ENOENT - value not available for return

   <b>void</b> <b>rte_hash_free</b> <b>(struct</b> <b>rte_hash</b> <b>*</b> <b>h)</b>
       De-allocate all memory used by hash table.

       <b>Parameters</b>
           <u>h</u> Hash table to free, if NULL, the function does nothing.

   <b>void</b> <b>rte_hash_reset</b> <b>(struct</b> <b>rte_hash</b> <b>*</b> <b>h)</b>
       Reset all hash structure, by zeroing all entries. When RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF is enabled,
       it  is  application's responsibility to make sure that none of the readers are referencing the hash table
       while calling this API.

       <b>Parameters</b>
           <u>h</u> Hash table to reset

   <b>int32_t</b> <b>rte_hash_count</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h)</b>
       Return the number of keys in the hash table

       <b>Parameters</b>
           <u>h</u> Hash table to query from

       <b>Returns</b>

           • -EINVAL if parameters are invalid

           • A value indicating how many keys were inserted in the table.

   <b>int32_t</b> <b>rte_hash_max_key_id</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h)</b>
       Return the maximum key value ID that could possibly be returned by rte_hash_add_key function.

       <b>Parameters</b>
           <u>h</u> Hash table to query from

       <b>Returns</b>

           • -EINVAL if parameters are invalid

           • A value indicating the max key ID of key slots present in the table.

   <b>int</b> <b>rte_hash_add_key_data</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>*</b> <b>key,</b> <b>void</b> <b>*</b> <b>data)</b>
       Add a key-value pair to an existing hash table. This operation is not multi-thread safe and  should  only
       be called from one thread by default. Thread safety can be enabled by setting flag during table creation.
       If  the key exists already in the table, this API updates its value with 'data' passed in this API. It is
       the responsibility of the application to manage any memory associated with the  old  value.  The  readers
       might still be using the old value even after this API has returned.

       <b>Parameters</b>
           <u>h</u> Hash table to add the key to.
           <u>key</u> Key to add to the hash table.
           <u>data</u> Data to add to the hash table.

       <b>Returns</b>

           • 0 if added successfully

           • -EINVAL if the parameters are invalid.

           • -ENOSPC if there is no space in the hash for this key.

   <b>int32_t</b>  <b>rte_hash_add_key_with_hash_data</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>*</b> <b>key,</b> <b>hash_sig_t</b> <b>sig,</b> <b>void</b> <b>*</b>
       <b>data)</b>
       Add a key-value pair with a pre-computed hash value to an existing hash  table.  This  operation  is  not
       multi-thread  safe  and should only be called from one thread by default. Thread safety can be enabled by
       setting flag during table creation. If the key exists already in the table, this API  updates  its  value
       with  'data'  passed  in  this  API.  It  is  the  responsibility of the application to manage any memory
       associated with the old value. The readers might still be using the old value even  after  this  API  has
       returned.

       <b>Parameters</b>
           <u>h</u> Hash table to add the key to.
           <u>key</u> Key to add to the hash table.
           <u>sig</u> Precomputed hash value for 'key'
           <u>data</u> Data to add to the hash table.

       <b>Returns</b>

           • 0 if added successfully

           • -EINVAL if the parameters are invalid.

           • -ENOSPC if there is no space in the hash for this key.

   <b>int32_t</b> <b>rte_hash_add_key</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>*</b> <b>key)</b>
       Add  a  key  to an existing hash table. This operation is not multi-thread safe and should only be called
       from one thread by default. Thread safety can be enabled by setting flag during table creation.

       <b>Parameters</b>
           <u>h</u> Hash table to add the key to.
           <u>key</u> Key to add to the hash table.

       <b>Returns</b>

           • -EINVAL if the parameters are invalid.

           • -ENOSPC if there is no space in the hash for this key.

           • A non-negative value that can be used by the caller as an offset into an array of user  data.  This
             value  is unique for this key. This unique key id may be larger than the user specified entry count
             when RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD flag is set.

   <b>int32_t</b> <b>rte_hash_add_key_with_hash</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>*</b> <b>key,</b> <b>hash_sig_t</b> <b>sig)</b>
       Add a key to an existing hash table. This operation is not multi-thread safe and should  only  be  called
       from one thread by default. Thread safety can be enabled by setting flag during table creation.

       <b>Parameters</b>
           <u>h</u> Hash table to add the key to.
           <u>key</u> Key to add to the hash table.
           <u>sig</u> Precomputed hash value for 'key'.

       <b>Returns</b>

           • -EINVAL if the parameters are invalid.

           • -ENOSPC if there is no space in the hash for this key.

           • A  non-negative  value that can be used by the caller as an offset into an array of user data. This
             value is unique for this key. This unique key ID may be larger than the user specified entry  count
             when RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD flag is set.

   <b>int32_t</b> <b>rte_hash_del_key</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>*</b> <b>key)</b>
       Remove  a  key  from  an  existing hash table. This operation is not multi-thread safe and should only be
       called from one thread by default. Thread safety can be enabled by setting flag during table creation. If
       RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL or RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF is enabled and internal RCU
       is NOT enabled, the key index returned by rte_hash_add_key_xxx APIs  will  not  be  freed  by  this  API.
       rte_hash_free_key_with_position  API  must  be  called additionally to free the index associated with the
       key. rte_hash_free_key_with_position API should be called after all the readers have stopped  referencing
       the entry corresponding to this key. RCU mechanisms could be used to determine such a state.

       <b>Parameters</b>
           <u>h</u> Hash table to remove the key from.
           <u>key</u> Key to remove from the hash table.

       <b>Returns</b>

           • -EINVAL if the parameters are invalid.

           • -ENOENT if the key is not found.

           • A  non-negative  value that can be used by the caller as an offset into an array of user data. This
             value is unique for this key, and is the same value that was returned when the key was added.

   <b>int32_t</b> <b>rte_hash_del_key_with_hash</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>*</b> <b>key,</b> <b>hash_sig_t</b> <b>sig)</b>
       Remove a key from an existing hash table. This operation is not multi-thread  safe  and  should  only  be
       called from one thread by default. Thread safety can be enabled by setting flag during table creation. If
       RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL or RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF is enabled and internal RCU
       is  NOT  enabled,  the  key  index  returned  by rte_hash_add_key_xxx APIs will not be freed by this API.
       rte_hash_free_key_with_position API must be called additionally to free the  index  associated  with  the
       key.  rte_hash_free_key_with_position API should be called after all the readers have stopped referencing
       the entry corresponding to this key. RCU mechanisms could be used to determine such a state.

       <b>Parameters</b>
           <u>h</u> Hash table to remove the key from.
           <u>key</u> Key to remove from the hash table.
           <u>sig</u> Precomputed hash value for 'key'.

       <b>Returns</b>

           • -EINVAL if the parameters are invalid.

           • -ENOENT if the key is not found.

           • A non-negative value that can be used by the caller as an offset into an array of user  data.  This
             value is unique for this key, and is the same value that was returned when the key was added.

   <b>int</b> <b>rte_hash_get_key_with_position</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>int32_t</b> <b>position,</b> <b>void</b> <b>**</b> <b>key)</b>
       Find  a  key  in the hash table given the position. This operation is multi-thread safe with regarding to
       other lookup threads. Read-write concurrency can be enabled by setting flag during table creation.

       <b>Parameters</b>
           <u>h</u> Hash table to get the key from.
           <u>position</u> Position returned when the key was inserted.
           <u>key</u> Output containing a pointer to the key

       <b>Returns</b>

           • 0 if retrieved successfully

           • -EINVAL if the parameters are invalid.

           • -ENOENT if no valid key is found in the given position.

   <b>int</b> <b>rte_hash_free_key_with_position</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>int32_t</b> <b>position)</b>
       Free a hash key in the hash table given the position of the key. This operation is not multi-thread  safe
       and should only be called from one thread by default. Thread safety can be enabled by setting flag during
       table  creation.  If  RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL  or  RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF  is
       enabled and internal RCU is NOT enabled, the key index returned  by  rte_hash_del_key_xxx  APIs  must  be
       freed  using this API. This API should be called after all the readers have stopped referencing the entry
       corresponding to this key. RCU mechanisms could be used to determine such a  state.  This  API  does  not
       validate if the key is already freed.

       <b>Parameters</b>
           <u>h</u> Hash table to free the key from.
           <u>position</u> Position returned when the key was deleted.

       <b>Returns</b>

           • 0 if freed successfully

           • -EINVAL if the parameters are invalid.

   <b>int</b> <b>rte_hash_lookup_data</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>*</b> <b>key,</b> <b>void</b> <b>**</b> <b>data)</b>
       Find  a  key-value  pair  in  the hash table. This operation is multi-thread safe with regarding to other
       lookup threads. Read-write concurrency can be enabled by setting flag during table creation.

       <b>Parameters</b>
           <u>h</u> Hash table to look in.
           <u>key</u> Key to find.
           <u>data</u> Output with pointer to data returned from the hash table.

       <b>Returns</b>

           • A non-negative value that can be used by the caller as an offset into an array of user  data.  This
             value is unique for this key, and is the same value that was returned when the key was added.

           • -EINVAL if the parameters are invalid.

           • -ENOENT if the key is not found.

   <b>int</b>  <b>rte_hash_lookup_with_hash_data</b>  <b>(const</b>  <b>struct</b>  <b>rte_hash</b>  <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>*</b> <b>key,</b> <b>hash_sig_t</b> <b>sig,</b> <b>void</b> <b>**</b>
       <b>data)</b>
       Find a key-value pair with a pre-computed hash value to an existing hash table. This operation is  multi-
       thread safe with regarding to other lookup threads. Read-write concurrency can be enabled by setting flag
       during table creation.

       <b>Parameters</b>
           <u>h</u> Hash table to look in.
           <u>key</u> Key to find.
           <u>sig</u> Precomputed hash value for 'key'
           <u>data</u> Output with pointer to data returned from the hash table.

       <b>Returns</b>

           • A  non-negative  value that can be used by the caller as an offset into an array of user data. This
             value is unique for this key, and is the same value that was returned when the key was added.

           • -EINVAL if the parameters are invalid.

           • -ENOENT if the key is not found.

   <b>int32_t</b> <b>rte_hash_lookup</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>*</b> <b>key)</b>
       Find a key in the hash table. This operation is multi-thread safe with regarding to other lookup threads.
       Read-write concurrency can be enabled by setting flag during table creation.

       <b>Parameters</b>
           <u>h</u> Hash table to look in.
           <u>key</u> Key to find.

       <b>Returns</b>

           • -EINVAL if the parameters are invalid.

           • -ENOENT if the key is not found.

           • A non-negative value that can be used by the caller as an offset into an array of user  data.  This
             value is unique for this key, and is the same value that was returned when the key was added.

   <b>int32_t</b> <b>rte_hash_lookup_with_hash</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>*</b> <b>key,</b> <b>hash_sig_t</b> <b>sig)</b>
       Find a key in the hash table. This operation is multi-thread safe with regarding to other lookup threads.
       Read-write concurrency can be enabled by setting flag during table creation.

       <b>Parameters</b>
           <u>h</u> Hash table to look in.
           <u>key</u> Key to find.
           <u>sig</u> Precomputed hash value for 'key'.

       <b>Returns</b>

           • -EINVAL if the parameters are invalid.

           • -ENOENT if the key is not found.

           • A  non-negative  value that can be used by the caller as an offset into an array of user data. This
             value is unique for this key, and is the same value that was returned when the key was added.

   <b>hash_sig_t</b> <b>rte_hash_hash</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>*</b> <b>key)</b>
       Calc a hash value by key. This operation is not multi-process safe.

       <b>Parameters</b>
           <u>h</u> Hash table to look in.
           <u>key</u> Key to find.

       <b>Returns</b>

           • hash value

   <b>int</b> <b>rte_hash_lookup_bulk_data</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>**</b> <b>keys,</b> <b>uint32_t</b> <b>num_keys,</b>  <b>uint64_t</b>  <b>*</b>
       <b>hit_mask,</b> <b>void</b> <b>*</b> <b>data[])</b>
       Find  multiple keys in the hash table. This operation is multi-thread safe with regarding to other lookup
       threads. Read-write concurrency can be enabled by setting flag during table creation.

       <b>Parameters</b>
           <u>h</u> Hash table to look in.
           <u>keys</u> A pointer to a list of keys to look for.
           <u>num_keys</u> How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX).
           <u>hit_mask</u> Output containing a bitmask with all successful lookups.
           <u>data</u> Output containing array of data returned from all the successful lookups.

       <b>Returns</b>
           -EINVAL if there's an error, otherwise number of successful lookups.

   <b>int</b> <b>rte_hash_lookup_with_hash_bulk</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>**</b> <b>keys,</b> <b>hash_sig_t</b> <b>*</b> <b>sig,</b> <b>uint32_t</b>
       <b>num_keys,</b> <b>int32_t</b> <b>*</b> <b>positions)</b>
       Find multiple keys in the hash table with precomputed hash value array. This  operation  is  multi-thread
       safe with regarding to other lookup threads. Read-write concurrency can be enabled by setting flag during
       table creation.

       <b>Parameters</b>
           <u>h</u> Hash table to look in.
           <u>keys</u> A pointer to a list of keys to look for.
           <u>sig</u> A pointer to a list of precomputed hash values for keys.
           <u>num_keys</u> How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX).
           <u>positions</u>  Output  containing a list of values, corresponding to the list of keys that can be used by
           the caller as an offset into an array of user data. These values are unique for each key, and are the
           same values that were returned when each key was added. If a key in the  list  was  not  found,  then
           -ENOENT will be the value.

       <b>Returns</b>
           -EINVAL if there's an error, otherwise 0.

   <b>int</b>  <b>rte_hash_lookup_with_hash_bulk_data</b>  <b>(const</b>  <b>struct</b>  <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>**</b> <b>keys,</b> <b>hash_sig_t</b> <b>*</b> <b>sig,</b>
       <b>uint32_t</b> <b>num_keys,</b> <b>uint64_t</b> <b>*</b> <b>hit_mask,</b> <b>void</b> <b>*</b> <b>data[])</b>
       Find multiple keys in the hash table with precomputed hash value array. This  operation  is  multi-thread
       safe with regarding to other lookup threads. Read-write concurrency can be enabled by setting flag during
       table creation.

       <b>Parameters</b>
           <u>h</u> Hash table to look in.
           <u>keys</u> A pointer to a list of keys to look for.
           <u>sig</u> A pointer to a list of precomputed hash values for keys.
           <u>num_keys</u> How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX).
           <u>hit_mask</u> Output containing a bitmask with all successful lookups.
           <u>data</u> Output containing array of data returned from all the successful lookups.

       <b>Returns</b>
           -EINVAL if there's an error, otherwise number of successful lookups.

   <b>int</b>  <b>rte_hash_lookup_bulk</b>  <b>(const</b>  <b>struct</b>  <b>rte_hash</b>  <b>*</b>  <b>h,</b>  <b>const</b>  <b>void</b> <b>**</b> <b>keys,</b> <b>uint32_t</b> <b>num_keys,</b> <b>int32_t</b> <b>*</b>
       <b>positions)</b>
       Find multiple keys in the hash table. This operation is multi-thread safe with regarding to other  lookup
       threads. Read-write concurrency can be enabled by setting flag during table creation.

       <b>Parameters</b>
           <u>h</u> Hash table to look in.
           <u>keys</u> A pointer to a list of keys to look for.
           <u>num_keys</u> How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX).
           <u>positions</u>  Output  containing a list of values, corresponding to the list of keys that can be used by
           the caller as an offset into an array of user data. These values are unique for each key, and are the
           same values that were returned when each key was added. If a key in the  list  was  not  found,  then
           -ENOENT will be the value.

       <b>Returns</b>
           -EINVAL if there's an error, otherwise 0.

   <b>int32_t</b> <b>rte_hash_iterate</b> <b>(const</b> <b>struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>const</b> <b>void</b> <b>**</b> <b>key,</b> <b>void</b> <b>**</b> <b>data,</b> <b>uint32_t</b> <b>*</b> <b>next)</b>
       Iterate through the hash table, returning key-value pairs.

       <b>Parameters</b>
           <u>h</u> Hash table to iterate
           <u>key</u> Output containing the key where current iterator was pointing at
           <u>data</u> Output containing the data associated with key. Returns NULL if data was not stored.
           <u>next</u>  Pointer  to  iterator.  Should  be 0 to start iterating the hash table. Iterator is incremented
           after each call of this function.

       <b>Returns</b>
           Position where key was stored, if successful.

           • -EINVAL if the parameters are invalid.

           • -ENOENT if end of the hash table.

   <b>int</b> <b>rte_hash_rcu_qsbr_add</b> <b>(struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>struct</b> <b>rte_hash_rcu_config</b> <b>*</b> <b>cfg)</b>
       Associate RCU QSBR variable with a Hash object. This API should be called to enable  the  integrated  RCU
       QSBR support and should be called immediately after creating the Hash object.

       <b>Parameters</b>
           <u>h</u> the hash object to add RCU QSBR
           <u>cfg</u> RCU QSBR configuration

       <b>Returns</b>
           On success - 0 On error - 1 with error code set in rte_errno. Possible rte_errno codes are:

           • EINVAL - invalid pointer

           • EEXIST - already added QSBR

           • ENOMEM - memory allocation failure

   <b>__rte_experimental</b>  <b>int</b> <b>rte_hash_rcu_qsbr_dq_reclaim</b> <b>(struct</b> <b>rte_hash</b> <b>*</b> <b>h,</b> <b>unsigned</b> <b>int</b> <b>*</b> <b>freed,</b> <b>unsigned</b> <b>int</b>
       <b>*</b> <b>pending,</b> <b>unsigned</b> <b>int</b> <b>*</b> <b>available)</b>
       Reclaim resources from the defer queue. This API reclaim the resources from the defer  queue  if  rcu  is
       enabled.

       <b>Parameters</b>
           <u>h</u> The hash object to reclaim resources.
           <u>freed</u> Number of resources that were freed.
           <u>pending</u>  Number  of resources pending on the defer queue. This number might not be accurate if multi-
           thread safety is configured.
           <u>available</u> Number of resources that can be added to the defer queue. This number might not be accurate
           if multi-thread safety is configured.

       <b>Returns</b>
           On success - 0 On error - 1 with error code set in rte_errno. Possible rte_errno codes are:

           • EINVAL - invalid pointer

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for DPDK from the source code.

DPDK                                             Version 24.11.2                                   <u><a href="../man3/rte_hash.h.3.html">rte_hash.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>