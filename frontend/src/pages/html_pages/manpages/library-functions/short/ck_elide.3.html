<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CK_ELIDE_PROTOTYPE,  CK_ELIDE_LOCK_ADAPTIVE,  CK_ELIDE_UNLOCK_ADAPTIVE,  CK_ELIDE_LOCK,  CK_ELIDE_UNLOCK,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libck-dev">libck-dev_0.7.2-5ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CK_ELIDE_PROTOTYPE,  CK_ELIDE_LOCK_ADAPTIVE,  CK_ELIDE_UNLOCK_ADAPTIVE,  CK_ELIDE_LOCK,  CK_ELIDE_UNLOCK,
       CK_ELIDE_TRYLOCK_PROTOTYPE, CK_ELIDE_TRYLOCK â€” lock elision wrappers

</pre><h4><b>LIBRARY</b></h4><pre>
       Concurrency Kit (libck, -lck)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;ck_elide.h&gt;</b>

       ck_elide_stat_t stat = CK_ELIDE_STAT_INITIALIZER;

       <u>void</u>
       <b>ck_elide_stat_init</b>(<u>ck_elide_stat_t</u> <u>*</u>);

       struct ck_elide_config config = CK_ELIDE_CONFIG_DEFAULT_INITIALIZER;

       struct ck_elide_config {
               unsigned short skip_busy;
               short retry_busy;
               unsigned short skip_other;
               short retry_other;
               unsigned short skip_conflict;
               short retry_conflict;
       };

       <b>CK_ELIDE_PROTOTYPE</b>(<u>NAME</u>, <u>TYPE</u>, <u>LOCK_PREDICATE</u>, <u>LOCK_FUNCTION</u>, <u>UNLOCK_PREDICATE</u>, <u>UNLOCK_FUNCTION</u>);

       <b>CK_ELIDE_LOCK_ADAPTIVE</b>(<u>NAME</u>, <u>ck_elide_stat_t</u> <u>*</u>, <u>struct</u> <u>ck_elide_config</u> <u>*</u>, <u>TYPE</u> <u>*</u>);

       <b>CK_ELIDE_UNLOCK_ADAPTIVE</b>(<u>NAME</u>, <u>ck_elide_stat_t</u> <u>*</u>, <u>TYPE</u> <u>*</u>);

       <b>CK_ELIDE_LOCK</b>(<u>NAME</u>, <u>TYPE</u> <u>*</u>);

       <b>CK_ELIDE_UNLOCK</b>(<u>NAME</u>, <u>TYPE</u> <u>*</u>);

       <b>CK_ELIDE_TRYLOCK_PROTOTYPE</b>(<u>NAME</u>, <u>TYPE</u>, <u>LOCK_PREDICATE</u>, <u>TRYLOCK_FUNCTION</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These macros implement lock elision wrappers for a user-specified  single-argument  lock  interface.  The
       wrappers  will attempt to elide lock acquisition, allowing concurrent execution of critical sections that
       do not issue conflicting memory operations. If any threads have successfully elided a  lock  acquisition,
       conflicting  memory  operations  will  roll-back any side-effects of the critical section and force every
       thread to retry the lock acquisition regularly.

       <b>CK_ELIDE_LOCK</b>(),  <b>CK_ELIDE_UNLOCK</b>(),  <b>CK_ELIDE_LOCK_ADAPTIVE</b>(),  and  <b>CK_ELIDE_UNLOCK_ADAPTIVE</b>()   macros
       require  a  previous <b>CK_ELIDE_PROTOTYPE</b>() with the same <u>NAME</u>.  Elision is attempted if the <u>LOCK_PREDICATE</u>
       function returns false. If <u>LOCK_PREDICATE</u> returns true then  elision  is  aborted  and  <u>LOCK_FUNCTION</u>  is
       executed  instead.  If  any  threads  are in an elided critical section, <u>LOCK_FUNCTION</u> must force them to
       rollback through a conflicting memory operation.  The <u>UNLOCK_PREDICATE</u> function must return true  if  the
       lock  is  acquired  by the caller, meaning that the lock was not successfully elided. If <u>UNLOCK_PREDICATE</u>
       returns true, then the <u>UNLOCK_FUNCTION</u> is executed. If RTM is unsupported  (no  CK_F_PR_RTM  macro)  then
       <b>CK_ELIDE_LOCK</b>()  and  <b>CK_ELIDE_LOCK_ADAPTIVE</b>()  will immediately call <b>LOCK_FUNCTION</b>().  <b>CK_ELIDE_UNLOCK</b>()
       and <b>CK_ELIDE_UNLOCK_ADAPTIVE</b>() will immediately call <b>UNLOCK_FUNCTION</b>().

       <b>CK_ELIDE_TRYLOCK</b>() requires a previous <b>CK_ELIDE_TRYLOCK_PROTOTYPE</b>()  with  the  same  name.   Elision  is
       attempted  if  the  <u>LOCK_PREDICATE</u>  function  returns false. If <u>LOCK_PREDICATE</u> returns true or if elision
       fails then the operation is aborted. If RTM is unsupported (no CK_F_PR_RTM macro) then <b>CK_ELIDE_TRYLOCK</b>()
       will immediately call <b>TRYLOCK_FUNCTION</b>().

       <b>CK_ELIDE_LOCK_ADAPTIVE</b>() and <b>CK_ELIDE_UNLOCK_ADAPTIVE</b>() will adapt the elision behavior  associated  with
       lock  operations  according  to  the  run-time  behavior  of the program. This behavior is defined by the
       ck_elide_config structure pointer  passed  to  <b>CK_ELIDE_LOCK_ADAPTIVE</b>().   A  thread-local  ck_elide_stat
       structure must be passed to both <b>CK_ELIDE_LOCK_ADAPTIVE</b>() and <b>CK_ELIDE_UNLOCK_ADAPTIVE</b>().  This structure
       is  expected  to be unique for different workloads, may not be re-used in recursive acquisitions and must
       match the lifetime of the lock it is associated with. It is safe to mix adaptive calls  with  best-effort
       calls.

       Both  ck_spinlock.h  and  ck_rwlock.h  define  ck_elide  wrappers  under  the  ck_spinlock  and ck_rwlock
       namespace, respectively.

</pre><h4><b>EXAMPLES</b></h4><pre>
       This example utilizes built-in lock elision facilities in ck_rwlock and ck_spinlock.

             #include &lt;ck_rwlock.h&gt;
             #include &lt;ck_spinlock.h&gt;

             static ck_rwlock_t rw = CK_RWLOCK_INITIALIZER;
             static struct ck_elide_config rw_config =
                 CK_ELIDE_CONFIG_DEFAULT_INITIALIZER;
             static __thread ck_elide_stat_t rw_stat =
                 CK_ELIDE_STAT_INITIALIZER;

             static ck_spinlock_t spinlock = CK_SPINLOCK_INITIALIZER;
             static struct ck_elide_config spinlock_config =
                 CK_ELIDE_CONFIG_DEFAULT_INITIALIZER;
             static __thread ck_elide_stat_t spinlock_stat =
                 CK_ELIDE_STAT_INITIALIZER;

             void
             function(void)
             {

                     /* Lock-unlock write-side lock in weak best-effort manner. */
                     CK_ELIDE_LOCK(ck_rwlock_write, &amp;rw);
                     CK_ELIDE_UNLOCK(ck_rwlock_write, &amp;rw);

                     /* Attempt to acquire the write-side lock. */
                     if (CK_ELIDE_TRYLOCK(ck_rwlock_write, &amp;rw) == true)
                             CK_ELIDE_UNLOCK(ck_rwlock_write, &amp;rw);

                     /* Lock-unlock read-side lock in weak best-effort manner. */
                     CK_ELIDE_LOCK(ck_rwlock_read, &amp;rw);
                     CK_ELIDE_UNLOCK(ck_rwlock_read, &amp;rw);

                     /* Attempt to acquire the read-side lock. */
                     if (CK_ELIDE_TRYLOCK(ck_rwlock_read, &amp;rw) == true)
                             CK_ELIDE_UNLOCK(ck_rwlock_read, &amp;rw);

                     /* Lock-unlock write-side lock in an adaptive manner. */
                     CK_ELIDE_LOCK_ADAPTIVE(ck_rwlock_write, &amp;rw_stat,
                         &amp;rw_config, &amp;rw);
                     CK_ELIDE_UNLOCK_ADAPTIVE(ck_rwlock_write, &amp;rw_stat,
                         &amp;rw_config, &amp;rw);

                     /* Lock-unlock read-side lock in an adaptive manner. */
                     CK_ELIDE_LOCK_ADAPTIVE(ck_rwlock_read, &amp;rw_stat,
                         &amp;rw_config, &amp;rw);
                     CK_ELIDE_UNLOCK_ADAPTIVE(ck_rwlock_read, &amp;rw_stat,
                         &amp;rw_config, &amp;rw);

                     /* Lock-unlock spinlock in weak best-effort manner. */
                     CK_ELIDE_LOCK(ck_spinlock, &amp;spinlock);
                     CK_ELIDE_UNLOCK(ck_spinlock, &amp;spinlock);

                     /* Attempt to acquire the lock. */
                     if (CK_ELIDE_TRYLOCK(ck_spinlock, &amp;lock) == true)
                             CK_ELIDE_UNLOCK(ck_spinlock, &amp;spinlock);

                     /* Lock-unlock spinlock in an adaptive manner. */
                     CK_ELIDE_LOCK_ADAPTIVE(ck_spinlock, &amp;spinlock_stat,
                         &amp;spinlock_config, &amp;spinlock);
                     CK_ELIDE_UNLOCK_ADAPTIVE(ck_spinlock, &amp;spinlock_stat,
                         &amp;spinlock_config, &amp;spinlock);
             }

       In this example, user-defined locking functions are provided an elision implementation.

             /* Assume lock_t has been previously defined. */
             #include &lt;ck_elide.h&gt;

             /*
              * This function returns true if the lock is unavailable at the time
              * it was called or false if the lock is available.
              */
             bool is_locked(lock_t *);

             /*
              * This function acquires the supplied lock.
              */
             void lock(lock_t *);

             /*
              * This function releases the lock.
              */
             void unlock(lock_t *);

             CK_ELIDE_PROTOTYPE(my_lock, lock_t, is_locked, lock, is_locked, unlock)

             static lock_t lock;

             void
             function(void)
             {

                     CK_ELIDE_LOCK(my_lock, &amp;lock);
                     CK_ELIDE_UNLOCK(my_lock, &amp;lock);
             }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/ck_rwlock.3.html">ck_rwlock</a></u>(3), <u><a href="../man3/ck_spinlock.3.html">ck_spinlock</a></u>(3)

       Ravi  Rajwar  and  James  R.  Goodman.  2001.  Speculative  lock  elision:  enabling  highly   concurrent
       multithreaded  execution.  In  Proceedings  of  the  34th  annual  ACM/IEEE  international  symposium  on
       Microarchitecture (MICRO 34). IEEE Computer Society, Washington, DC, USA, 294-305.

       Additional information available at <a href="http://en.wikipedia.org/wiki/Transactional_Synchronization_Extensions">http://en.wikipedia.org/wiki/Transactional_Synchronization_Extensions</a>
       and <a href="http://concurrencykit.org/">http://concurrencykit.org/</a>

                                                 July 13, 2013.                                      <u><a href="../man3/ck_elide.3.html">ck_elide</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>