<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C or C++:</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openmpi-doc">openmpi-doc_5.0.7-1build1_all</a> <br><br><pre>
</pre><h4><b>SYNOPSIS</b></h4><pre>
       C or C++:

          #include &lt;mpp/shmem.h&gt;

          void shmem_int_wait(volatile int *var, int value)

          void shmem_int_wait_until(volatile int *var, int cond, int value)

          void shmem_long_wait(volatile long *var, long value)

          void shmem_long_wait_until(volatile long *var, int cond, long value)

          void shmem_longlong_wait(volatile long long *var, long long value)

          void shmem_longlong_wait_until(volatile long long *var, int cond,
            long long value)

          void shmem_short_wait(volatile short *var, short value)

          void shmem_short_wait_until(volatile short *var, int cond,
            short value)

          void shmem_wait(volatile long *ivar, long cmp_value)

          void shmem_wait_until(volatile long *ivar, int cmp, long value)

       Fortran:

          INCLUDE "mpp/shmem.fh"

          CALL SHMEM_INT4_WAIT(ivar, cmp_value)

          CALL SHMEM_INT4_WAIT_UNTIL(ivar, cmp, cmp_value)

          CALL SHMEM_INT8_WAIT(ivar, cmp_value)

          CALL SHMEM_INT8_WAIT_UNTIL(ivar, cmp, cmp_value)

          CALL SHMEM_WAIT(ivar, cmp_value)

          CALL SHMEM_WAIT_UNTIL(ivar, cmp, cmp_value)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>shmem_wait</u> and <u>shmem_wait_until</u> wait for <b>ivar</b> to be changed by a remote write or atomic swap issued by  a
       different  processor.  These routines can be used for point-to- point directed synchronization. A call to
       <u>shmem_wait</u> does not return until some other processor writes a value, not equal to cmp_value,  into  <b>ivar</b>
       on  the  waiting processor. A call to <u>shmem_wait_until</u> does not return until some other processor changes
       <b>ivar</b> to satisfy the condition implied by cmp and cmp_value.  This mechanism is useful  when  a  processor
       needs to tell another processor that it has completed some action.

       The arguments are as follows:

       <b>target</b> The  remotely  accessible  integer  data  object  to be updated on the remote PE. If you are using
              C/C++, the type of target should match that implied in the SYNOPSIS section. If you are using  the
              Fortran  compiler,  it  must be of type integer with an element size of 4 bytes for SHMEM_INT4_ADD
              and 8 bytes for SHMEM_INT8_ADD.

       <b>value</b>  The value to be atomically added to target. If you are using C/C++, the type of value should match
              that implied in the SYNOPSIS section.  If you are using Fortran, it must be of type  integer  with
              an element size of target.

       <b>pe</b>     An  integer  that  indicates  the  PE  number upon which target is to be updated. If you are using
              Fortran, it must be a default integer value.

       <b>ivar</b>   A remotely accessible integer variable that is being updated by  another  PE.  If  you  are  using
              C/C++,  the  type  of  ivar  should  match  that implied in the SYNOPSIS section. If you are using
              Fortran, ivar must be a specific sized integer type according to the  function  being  called,  as
              follows:

              <u>shmem_wait</u>, <u>shmem_wait_until</u>:** default INTEGER

              shmem_int4_wait, shmem_int4_wait_until:** INTEGER*4

              shmem_int8_wait, shmem_int8_wait_until:** INTEGER*8

       <b>cmp</b>    The  compare  operator  that compares ivar with cmp_value. cmp must be of type integer. If you are
              using Fortran, it must be of default kind. If you are using C/C++, the type of  cmp  should  match
              that implied in the SYNOPSIS section. The following cmp values are supported:

              <b>SHMEM_CMP_EQ</b>
                     Equal

              <b>SHMEM_CMP_NE</b>
                     Not equal

              <b>SHMEM_CMP_GT</b>
                     Greater than

              <b>SHMEM_CMP_LE</b>
                     Less than or equal to

              <b>SHMEM_CMP_LT</b>
                     Less than

              <b>SHMEM_CMP_GE</b>
                     Greater than or equal to

       <b>cmp_value</b>
              cmp_value  must  be  of  type  integer. If you are using C/C++, the type of cmp_value should match
              thatimplied in the SYNOPSIS section. If you are using Fortran, cmp_value must be an integer of the
              same size and kind as ivar. The <u>shmem_wait</u> routines  return  when  ivar  is  no  longer  equal  to
              cmp_value.  The  <u>shmem_wait_until</u>  routines return when the compare condition is true. The compare
              condition is defined by the ivar  argument  compared  with  the  cmp_value  using  the  comparison
              operator, cmp.

</pre><h4><b>EXAMPLES</b></h4><pre>
       <b>Example</b> <b>1:</b> The following call returns when variable ivar is not equal to 100:

          INTEGER*8 IVAR

          CALL SHMEM_INT8_WAIT(IVAR, <a href="../man100/INT8.100.html">INT8</a>(100))

       <b>Example</b>  <b>2:</b>  The  following call to SHMEM_INT8_WAIT_UNTIL is equivalent to the call to SHMEM_INT8_WAIT in
       example 1:

          INTEGER*8 IVAR

          CALL SHMEM_INT8_WAIT_UNTIL(IVAR, SHMEM_CMP_NE, <a href="../man100/INT8.100.html">INT8</a>(100))

       <b>Example</b> <b>3:</b> The following C/C++ call waits until the sign bit in ivar is set by a transfer from  a  remote
       PE:

          int ivar;

          shmem_int_wait_until(&amp;ivar, SHMEM_CMP_LT, 0);

       <b>Example</b> <b>4:</b> The following Fortran example is in the context of a subroutine:

          SUBROUTINE EXAMPLE()
            INTEGER FLAG_VAR
            COMMON/FLAG/FLAG_VAR
            . . .
            FLAG_VAR = FLAG_VALUE ! initialize the event variable
            . . .
            IF (FLAG_VAR .EQ. FLAG_VALUE) THEN
              CALL SHMEM_WAIT(FLAG_VAR, FLAG_VALUE)
            ENDIF
            FLAG_VAR = FLAG_VALUE ! reset the event variable for next time
            . . .
          END

       <b>SEE</b> <b>ALSO:</b>
          <u><a href="../man3/intro_shmem.3.html">intro_shmem</a></u>(3) <u><a href="../man3/shmem_put.3.html">shmem_put</a></u>(3)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2003-2025, The Open MPI Community

                                                  Jun 07, 2025                            <u><a href="../man3/SHMEM_LONGLONG_WAIT.3.html">SHMEM_LONGLONG_WAIT</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>