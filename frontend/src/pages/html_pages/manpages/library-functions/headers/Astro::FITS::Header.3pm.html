<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Astro::FITS::Header - Object Orientated interface to FITS HDUs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libastro-fits-header-perl">libastro-fits-header-perl_3.09-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Astro::FITS::Header - Object Orientated interface to FITS HDUs

</pre><h4><b>SYNOPSIS</b></h4><pre>
         $header = new Astro::FITS::Header( Cards =&gt; \@array );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Stores information about a FITS header block in an object. Takes an hash with an array reference as an
       argument. The array should contain a list of FITS header cards as input.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Constructor</b>
       <b>new</b> Create a new instance from an array of FITS header cards.

             $item = new Astro::FITS::Header( Cards =&gt; \@header );

           returns a reference to a Header object.  If you pass in no cards, you get the (required) first SIMPLE
           card for free.

   <b>Accessor</b> <b>Methods</b>
       <b>tiereturnsref</b>
           Indicates  whether the tied object should return multiple values as a single string joined by newline
           characters (false) or it should return a reference to an array containing all the values.

           Only affects the tied interface.

             tie %keywords, "Astro::FITS::Header", $header, tiereturnsref =&gt; 1;
             $ref = $keywords{COMMENT};

           Defaults to returning a single string in all cases (for backwards compatibility)

       <b>subhdrs</b>
           Set or return the subheaders for a Header object. Arguments must be  given  as  "Astro::FITS::Header"
           objects.

               $header-&gt;subhdrs(@hdrs);
               @hdrs = $header-&gt;subhdrs;

           This  method should be used when you have additional header components that should be associated with
           the primary header but they are not associated with a particular name, just an ordering.

           FITS headers that are associated with  a  name  can  be  stored  directly  in  the  header  using  an
           "Astro::FITS::Header::Item" of type 'HEADER'.

       <b>item</b>
           Returns a FITS::Header:Item object referenced by index, "undef" if it does not exist.

              $item = $header-&gt;item($index);

       <b>get_wcs</b>
           Returns a Starlink::AST FrameSet object representing the WCS of the FITS Header.

              $ast = $header-&gt;get_wcs();

       <b>keyword</b>
           Returns keyword referenced by index, "undef" if it does not exist.

              $keyword = $header-&gt;keyword($index);

       <b>itembyname</b>
           Returns  an  array of Header::Items for the requested keyword if called in list context, or the first
           matching Header::Item if called in scalar context. Returns "undef" if the  keyword  does  not  exist.
           The keyword may be a regular expression created with the "qr" operator.

              @items = $header-&gt;itembyname($keyword);
              $item = $header-&gt;itembyname($keyword);

       <b>itembytype</b>
           Returns  an  array  of  Header::Items  for the requested type if called in list context, or the first
           matching Header::Item if called in scalar context. See  "Astro::FITS::Header::Item"  for  a  list  of
           allowed types.

              @items = $header-&gt;itembytype( "COMMENT" );
              @items = $header-&gt;itembytype( "HEADER" );
              $item = $header-&gt;itembytype( "INT" );

       <b>index</b>
           Returns an array of indices for the requested keyword if called in list context, or an empty array if
           it does not exist.  The keyword may be a regular expression created with the "qr" operator.

              @index = $header-&gt;index($keyword);

           If  called  in  scalar context it returns the first item in the array, or "undef" if the keyword does
           not exist.

              $index = $header-&gt;index($keyword);

       <b>value</b>
           Returns an array of values for the requested keyword if called in list context, or an empty array  if
           it does not exist.  The keyword may be a regular expression created with the "qr" operator.

              @value = $header-&gt;value($keyword);

           If  called  in  scalar context it returns the first item in the array, or "undef" if the keyword does
           not exist.

       <b>comment</b>
           Returns an array of comments for the requested keyword if called in list context, or an  empty  array
           if it does not exist.  The keyword may be a regular expression created with the "qr" operator.

              @comment = $header-&gt;comment($keyword);

           If  called  in  scalar context it returns the first item in the array, or "undef" if the keyword does
           not exist.

              $comment = $header-&gt;comment($keyword);

       <b>insert</b>
           Inserts a FITS header card object at position $index

              $header-&gt;insert($index, $item);

           the object $item is not copied, multiple inserts of the same object mean that future modifications to
           the one instance of the inserted object will modify all inserted copies.

           The insert position can be negative.

       <b>replace</b>
           Replace FITS header card at index $index with card $item

              $card = $header-&gt;replace($index, $item);

           returns the replaced card.

       <b>remove</b>
           Removes a FITS header card object at position $index

              $card = $header-&gt;remove($index);

           returns the removed card.

       <b>replacebyname</b>
           Replace FITS header cards with keyword $keyword with card $item

              $card = $header-&gt;replacebyname($keyword, $item);

           returns the replaced card. The keyword may be a regular expression created with the "qr" operator.

       <b>removebyname</b>
           Removes a FITS header card object by name

             @card = $header-&gt;removebyname($keyword);

           returns the removed cards.  The keyword may be a regular expression created with the "qr" operator.

       <b>splice</b>
           Implements a standard splice operation for FITS headers

              @cards = $header-&gt;splice($offset [,$length [, @list]]);
              $last_card = $header-&gt;splice($offset [,$length [, @list]]);

           Removes the FITS header cards from the header designated by $offset and $length,  and  replaces  them
           with  @list  (if  specified)  which must be an array of FITS::Header::Item objects. Returns the cards
           removed. If offset is negative, counts from the end of the FITS header.

       <b>cards</b>
           Return the object contents as an array of FITS cards.

             @array = $header-&gt;cards;

       <b>sizeof</b>
           Returns the highest index in use in the FITS header.  To get the total number of header items, add 1.

             $number = $header-&gt;sizeof;

       <b>allitems</b>
           Returns the header as an array of FITS::Header:Item objects.

              @items = $header-&gt;allitems();

   <b>General</b> <b>Methods</b>
       <b>configure</b>
           Configures the object, takes an array of FITS header cards,  an  array  of  Astro::FITS::Header::Item
           objects or a simple hash as input.  If you feed in nothing at all, it uses a default array containing
           just the SIMPLE card required at the top of all FITS files.

             $header-&gt;configure( Cards =&gt; \@array );
             $header-&gt;configure( Items =&gt; \@array );
             $header-&gt;configure( Hash =&gt; \%hash );

           Does  nothing  if  the  array  is  not supplied. If the hash scheme is used and the hash contains the
           special key of SUBHEADERS pointing to an array of hashes, these will be read as proper  sub  headers.
           All other references in the hash will be ignored. Note that the default key order will be retained in
           the object created via the hash.

       <b>merge_primary</b>
           Given  the  current  header  and  a set of "Astro::FITS::Header" objects, return a merged FITS header
           (with the cards that have the same value and comment across all headers) along with, for each  input,
           header  objects containing all the header items that differ (including, by default, keys that are not
           present in all headers). Only the primary headers are merged, subheaders are ignored.

            ($clone) = $headerr-&gt;merge_primary();
            ($same, @different) = $header-&gt;merge_primary( $fits1, $fits2, ...);
            ($same, @different) = $header-&gt;merge_primary( \%options, $fits1, $fits2 );

           @different can be empty if all headers match (but see the "force_return_diffs"  option)  but  if  any
           headers  are  different  there will always be the same number of headers in @different as supplied to
           the function (including the reference  header).  A  clone  of  the  input  header  (stripped  of  any
           subheaders) is returned if no comparison headers are supplied.

           In scalar context, just returns the merged header.

             $merged = $header-&gt;merge_primary( @hdrs );

           The options hash is itself optional. It contains the following keys:

            merge_unique - if an item is identical across multiple headers and only
                           exists in those headers, propagate to the merged header rather
                           than storing it in the difference headers.

            force_return_diffs - return an empty difference object per input header
                                 even if there are no diffs

       <b>freeze</b>
           Method  to  return  a  blessed  reference to the object so that we can store ths object on disk using
           Data::Dumper module.

       <b>append</b>
           Append or update a card.

             $header-&gt;append( $card );

           This method can take either an Astro::FITS::Header::Item object, an Astro::FITS::Header object, or  a
           reference to an array of Astro::FITS::Header::Item objects.

           In  all  cases,  if  the given Astro::FITS::Header::Item keyword exists in the header, then the value
           will be overwritten with the one passed to the method. Otherwise, the card will be  appended  to  the
           end of the header.

           Nothing is returned.

   <b>Operator</b> <b>Overloading</b>
       These operators are overloaded:

       <b>""</b>  When the object is used in a string context the FITS header block is returned as a single string.

   <b>Private</b> <b>methods</b>
       These methods are for internal use only.

       <b>_rebuild_lookup</b>
           Private  function used to rebuild the lookup table after modifying the header block, its easier to do
           it this way than go through and add one to the indices of all header  cards  following  the  modified
           card.

</pre><h4><b>TIED</b> <b>INTERFACE</b></h4><pre>
       The "FITS::Header" object can also be tied to a hash:

          use Astro::FITS::Header;

          $header = new Astro::FITS::Header( Cards =&gt; \@array );
          tie %hash, "Astro::FITS::Header", $header

          $value = $hash{$keyword};
          $hash{$keyword} = $value;

          print "keyword $keyword is present" if exists $hash{$keyword};

          foreach my $key (keys %hash) {
             print "$key = $hash{$key}\n";
          }

   <b>Basic</b> <b>hash</b> <b>translation</b>
       Header  value  type  is  determined on-the-fly by parsing of the input values.  Anything that parses as a
       number or a logical is converted to that before being put in a card (but see below).

       Per-card comment fields  can  be  accessed  using  the  tied  interface  by  specifying  a  key  name  of
       "key_COMMENT".  This  works  because  in  general "_COMMENT" is too long to be confused with a normal key
       name.

         $comment = $hdr{CRPIX1_COMMENT};

       will return the comment associated with CRPIX1 header item. The comment can be modified in the same way:

         $hdr{CRPIX1_COMMENT} = "An axis";

       You can also modify the comment by slash-delimiting it when setting the associated keyword:

         $hdr{CRPIX1} = "34 / Set this field manually";

       If you want an actual slash character in your string field you must escape  it  with  a  backslash.   (If
       you're in double quotes you have to use a double backslash):

         $hdr{SLASHSTR} = 'foo\/bar / field contains "foo/bar"';

       Keywords  are  CaSE-inNSEnSiTIvE, unlike normal hash keywords.  All keywords are translated to upper case
       internally, per the FITS standard.

       Aside from the SIMPLE and END keywords, which are automagically placed at the beginning and  end  of  the
       header respectively, keywords are included in the header in the order received.  This gives you a modicum
       of  control  over card order, but if you actually care what order they're in, you probably don't want the
       tied interface.

   <b>Comment</b> <b>cards</b>
       Comment cards are a special case because they have no normal value and their comment field is treated  as
       the  hash  value.   The keywords "COMMENT" and "HISTORY" are magic and refer to comment cards; nearly all
       other keywords create normal valued cards.  (see "SIMPLE and END cards", below).

   <b>Multi-card</b> <b>values</b>
       Multiline string values are broken up, one card per line in the string.   Extra-long  string  values  are
       handled  gracefully: they get split among multiple cards, with a backslash at the end of each card image.
       They're transparently reassembled when you access the data, so that there is  a  strong  analogy  between
       multiline string values and multiple cards.

       In  general,  appending  to  hash  entries  that  look  like  strings  does what you think it should.  In
       particular, comment cards have a newline appended automatically on FETCH, so that

         $hash{HISTORY} .= "Added multi-line string support";

       adds a new HISTORY comment card, while

         $hash{TELESCOP} .= " dome B";

       only modifies an existing TELESCOP card.

       You can make multi-line values by feeding in newline-delimited strings, or by  assigning  from  an  array
       ref.  If you ask for a tag that has a multiline value it's always expanded to a multiline string, even if
       you fed in an array ref to start with.  That's by design: multiline string expansion often acts as though
       you  are  getting  just  the  first value back out, because perl string-to-number conversion stops at the
       first newline.  So:

         $hash{CDELT1} = [3,4,5];
         print $hash{CDELT1} + 99,"\n$hash{CDELT1}";

       prints "102\n3\n4\n5", and then

         $hash{CDELT1}++;
         print $hash{CDELT1};

       prints "4".

       In short, most of the time you get what you want.  But you can always fall back on the non-tied interface
       by calling methods like so:

         ((tied $hash)-&gt;method())

       If you prefer to have multi-valued items automagically become array refs, then you can get that  behavior
       using the "tiereturnsref" method:

         tie %keywords, "Astro::FITS::Header", $header, tiereturnsref =&gt; 1;

       When  tiereturnsref is true, multi-valued items will be returned via a reference to an array (ties do not
       respect calling context). Note that if this is configured you will have to test each return value to  see
       whether it is returning a real value or a reference to an array if you are not sure whether there will be
       more than one card with a duplicate name.

   <b>Type</b> <b>forcing</b>
       Because  perl  uses  behind-the-scenes  typing,  there is an ambiguity between strings and numeric and/or
       logical values: sometimes you want to create a STRING card whose value could parse as a number  or  as  a
       logical  value,  and  perl kindly parses it into a number for you.  To force string evaluation, feed in a
       trivial array ref:

         $hash{NUMSTR} = 123;     # generates an INT card containing 123.
         $hash{NUMSTR} = "123";   # generates an INT card containing 123.
         $hash{NUMSTR} = ["123"]; # generates a STRING card containing "123".
         $hash{NUMSTR} = [123];   # generates a STRING card containing "123".

         $hash{ALPHA} = "T";      # generates a LOGICAL card containing T.
         $hash{ALPHA} = ["T"];    # generates a STRING card containing "T".

       Calls to <b>keys()</b> or <b>each()</b> will, by default, return the keywords in the order in which they appear in  the
       header.

   <b>Sub-headers</b>
       When the key refers to a subheader entry (ie an item of type "HEADER"), a hash reference is returned.  If
       a hash reference is stored in a value it is converted to a "Astro::FITS::Header" object.

       If  the  special  key  "SUBHEADERS" is used, it will return the array of subheaders, (as stored using the
       "subhdrs" method) each of which will be tied to a hash. Subheaders  can  be  stored  using  normal  array
       operations.

   <b>SIMPLE</b> <b>and</b> <b>END</b> <b>cards</b>
       No FITS interface would becomplete without special cases.

       When  you  assign to SIMPLE or END, the tied interface ensures that they are first or last, respectively,
       in the deck -- as the FITS standard requires.  Other cards are inserted in between  the  first  and  last
       elements, in the order that you define them.

       The  SIMPLE card is forced to FITS LOGICAL (boolean) type.  The FITS standard forbids you from setting it
       to F, but you can if you want -- we're not the FITS police.

       The END card is forced to a null type, so any value you assign to it will fall on the floor.  If  present
       in  the  deck,  the  END keyword always contains the value " ", which is both more-or-less invisible when
       printed and also true -- so you can test the return value to see if an END card is present.

       SIMPLE and END come pre-defined from the constructor.  If for some nefarious reason you  want  to  remove
       them you must explicitly do so with "delete" or the appropriate method call from the object interface.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       "Astro::FITS::Header::Item",               "Starlink::AST",               "Astro::FITS::Header::CFITSIO",
       "Astro::FITS::Header::Item::NDF".

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2007-2011 Science and Technology  Facilties  Council.   Copyright  (C)  2001-2007  Particle
       Physics and Astronomy Research Council and portions Copyright (C) 2002 Southwest Research Institute.  All
       Rights Reserved.

       This  program  is  free  software;  you  can  redistribute it and/or modify it under the terms of the GNU
       General Public License as published by the Free Software Foundation; either version 3 of the License,  or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the
       implied  warranty  of  MERCHANTABILITY  or  FITNESS  FOR A PARTICULAR PURPOSE. See the GNU General Public
       License for more details.

       You should have received a copy of the GNU General Public License along with this program; if not,  write
       to the Free Software Foundation, Inc., 59 Temple Place,Suite 330, Boston, MA  02111-1307, USA

</pre><h4><b>AUTHORS</b></h4><pre>
       Alasdair   Allan   &lt;<a href="mailto:aa@astro.ex.ac.uk">aa@astro.ex.ac.uk</a>&gt;,   Tim   Jenness   &lt;<a href="mailto:t.jenness@jach.hawaii.edu">t.jenness@jach.hawaii.edu</a>&gt;,   Craig   DeForest
       &lt;<a href="mailto:deforest@boulder.swri.edu">deforest@boulder.swri.edu</a>&gt;, Jim Lewis &lt;<a href="mailto:jrl@ast.cam.ac.uk">jrl@ast.cam.ac.uk</a>&gt;, Brad Cavanagh &lt;<a href="mailto:b.cavanagh@jach.hawaii.edu">b.cavanagh@jach.hawaii.edu</a>&gt;

perl v5.36.0                                       2023-04-21                           <u>Astro::FITS::<a href="../man3pm/Header.3pm.html">Header</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>