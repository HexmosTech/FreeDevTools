<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::Class::Ordered - Modify the position of objects in an ordered list.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-class-perl">libdbix-class-perl_0.082844-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::Class::Ordered - Modify the position of objects in an ordered list.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Create a table for your ordered data.

         CREATE TABLE items (
           item_id INTEGER PRIMARY KEY AUTOINCREMENT,
           name TEXT NOT NULL,
           position INTEGER NOT NULL
         );

       Optionally, add one or more columns to specify groupings, allowing you to maintain independent ordered
       lists within one table:

         CREATE TABLE items (
           item_id INTEGER PRIMARY KEY AUTOINCREMENT,
           name TEXT NOT NULL,
           position INTEGER NOT NULL,
           group_id INTEGER NOT NULL
         );

       Or even

         CREATE TABLE items (
           item_id INTEGER PRIMARY KEY AUTOINCREMENT,
           name TEXT NOT NULL,
           position INTEGER NOT NULL,
           group_id INTEGER NOT NULL,
           other_group_id INTEGER NOT NULL
         );

       In your Schema or DB class add "Ordered" to the top of the component list.

         __PACKAGE__-&gt;load_components(qw( Ordered ... ));

       Specify the column that stores the position number for each row.

         package My::Item;
         __PACKAGE__-&gt;position_column('position');

       If you are using one grouping column, specify it as follows:

         __PACKAGE__-&gt;grouping_column('group_id');

       Or if you have multiple grouping columns:

         __PACKAGE__-&gt;grouping_column(['group_id', 'other_group_id']);

       That's it, now you can change the position of your objects.

         #!/use/bin/perl
         use My::Item;

         my $item = My::Item-&gt;create({ name=&gt;'Matt S. Trout' });
         # If using grouping_column:
         my $item = My::Item-&gt;create({ name=&gt;'Matt S. Trout', group_id=&gt;1 });

         my $rs = $item-&gt;siblings();
         my @siblings = $item-&gt;siblings();

         my $sibling;
         $sibling = $item-&gt;first_sibling();
         $sibling = $item-&gt;last_sibling();
         $sibling = $item-&gt;previous_sibling();
         $sibling = $item-&gt;next_sibling();

         $item-&gt;move_previous();
         $item-&gt;move_next();
         $item-&gt;move_first();
         $item-&gt;move_last();
         $item-&gt;move_to( $position );
         $item-&gt;move_to_group( 'groupname' );
         $item-&gt;move_to_group( 'groupname', $position );
         $item-&gt;move_to_group( {group_id=&gt;'groupname', 'other_group_id=&gt;'othergroupname'} );
         $item-&gt;move_to_group( {group_id=&gt;'groupname', 'other_group_id=&gt;'othergroupname'}, $position );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides a simple interface for modifying the ordered position of DBIx::Class objects.

</pre><h4><b>AUTO</b> <b>UPDATE</b></h4><pre>
       All of the move_* methods automatically update the rows involved in the query.  This is not configurable
       and is due to the fact that if you move a record it always causes other records in the list to be
       updated.

</pre><h4><b>METHODS</b></h4><pre>
   <b>position_column</b>
         __PACKAGE__-&gt;position_column('position');

       Sets and retrieves the name of the column that stores the positional value of each record.  Defaults to
       "position".

   <b>grouping_column</b>
         __PACKAGE__-&gt;grouping_column('group_id');

       This method specifies a column to limit all queries in this module by.  This effectively allows you to
       have multiple ordered lists within the same table.

   <b>null_position_value</b>
         __PACKAGE__-&gt;null_position_value(undef);

       This method specifies a value of "position_column" which <b>would</b> <b>never</b> <b>be</b> <b>assigned</b> <b>to</b> <b>a</b> <b>row</b> during normal
       operation. When a row is moved, its position is set to this value temporarily, so that any unique
       constraints can not be violated. This value defaults to 0, which should work for all cases except when
       your positions do indeed start from 0.

   <b>siblings</b>
         my $rs = $item-&gt;siblings();
         my @siblings = $item-&gt;siblings();

       Returns an <b>ordered</b> resultset of all other objects in the same group excluding the one you called it on.

       The ordering is a backwards-compatibility artifact - if you need a resultset with no ordering applied use
       "_siblings"

   <b>previous_siblings</b>
         my $prev_rs = $item-&gt;previous_siblings();
         my @prev_siblings = $item-&gt;previous_siblings();

       Returns a resultset of all objects in the same group positioned before the object on which this method
       was called.

   <b>next_siblings</b>
         my $next_rs = $item-&gt;next_siblings();
         my @next_siblings = $item-&gt;next_siblings();

       Returns a resultset of all objects in the same group positioned after the object on which this method was
       called.

   <b>previous_sibling</b>
         my $sibling = $item-&gt;previous_sibling();

       Returns the sibling that resides one position back.  Returns 0 if the current object is the first one.

   <b>first_sibling</b>
         my $sibling = $item-&gt;first_sibling();

       Returns the first sibling object, or 0 if the first sibling is this sibling.

   <b>next_sibling</b>
         my $sibling = $item-&gt;next_sibling();

       Returns the sibling that resides one position forward. Returns 0 if the current object is the last one.

   <b>last_sibling</b>
         my $sibling = $item-&gt;last_sibling();

       Returns the last sibling, or 0 if the last sibling is this sibling.

   <b>move_previous</b>
         $item-&gt;move_previous();

       Swaps position with the sibling in the position previous in the list.  Returns 1 on success, and 0 if the
       object is already the first one.

   <b>move_next</b>
         $item-&gt;move_next();

       Swaps position with the sibling in the next position in the list.  Returns 1 on success, and 0 if the
       object is already the last in the list.

   <b>move_first</b>
         $item-&gt;move_first();

       Moves the object to the first position in the list.  Returns 1 on success, and 0 if the object is already
       the first.

   <b>move_last</b>
         $item-&gt;move_last();

       Moves the object to the last position in the list.  Returns 1 on success, and 0 if the object is already
       the last one.

   <b>move_to</b>
         $item-&gt;move_to( $position );

       Moves the object to the specified position.  Returns 1 on success, and 0 if the object is already at the
       specified position.

   <b>move_to_group</b>
         $item-&gt;move_to_group( $group, $position );

       Moves the object to the specified position of the specified group, or to the end of the group if
       $position is undef.  1 is returned on success, and 0 is returned if the object is already at the
       specified position of the specified group.

       $group may be specified as a single scalar if only one grouping column is in use, or as a hashref of
       column =&gt; value pairs if multiple grouping columns are in use.

   <b>insert</b>
       Overrides the DBIC <b>insert()</b> method by providing a default position number.  The default will be the
       number of rows in the table +1, thus positioning the new record at the last position.

   <b>update</b>
       Overrides the DBIC <b>update()</b> method by checking for a change to the position and/or group columns.
       Movement within a group or to another group is handled by repositioning the appropriate siblings.
       Position defaults to the end of a new group if it has been changed to undef.

   <b>delete</b>
       Overrides the DBIC <b>delete()</b> method by first moving the object to the last position, then deleting it,
       thus ensuring the integrity of the positions.

</pre><h4><b>METHODS</b> <b>FOR</b> <b>EXTENDING</b> <b>ORDERED</b></h4><pre>
       You would want to override the methods below if you use sparse (non-linear) or non-numeric position
       values. This can be useful if you are working with preexisting non-normalised position data, or if you
       need to work with materialized path columns.

   <b>_position_from_value</b>
         my $num_pos = $item-&gt;_position_from_value ( $pos_value )

       Returns the <b>absolute</b> <b>numeric</b> <b>position</b> of an object with a <b>position</b> <b>value</b> set to $pos_value. By default
       simply returns $pos_value.

   <b>_position_value</b>
         my $pos_value = $item-&gt;_position_value ( $pos )

       Returns the <b>value</b> of "position_column" of the object at numeric position $pos. By default simply returns
       $pos.

   <b>_initial_position_value</b>
         __PACKAGE__-&gt;<a href="../man0/_initial_position_value.0.html">_initial_position_value</a>(0);

       This method specifies a <b>value</b> of "position_column" which is assigned to the first inserted element of a
       group, if no value was supplied at insertion time. All subsequent values are derived from this one by
       "_next_position_value" below. Defaults to 1.

   <b>_next_position_value</b>
         my $new_value = $item-&gt;_next_position_value ( $position_value )

       Returns a position <b>value</b> that would be considered "next" with regards to $position_value. Can be pretty
       much anything, given that "$position_value &lt; $new_value" where "&lt;" is the SQL comparison operator
       (usually works fine on strings). The default method expects $position_value to be numeric, and returns
       "$position_value + 1"

   <b>_shift_siblings</b>
         $item-&gt;_shift_siblings ($direction, @between)

       Shifts all siblings with <b>positions</b> <b>values</b> in the range @between (inclusive) by one position as specified
       by $direction (left if &lt; 0,
        right if &gt; 0). By default simply increments/decrements each "position_column" value by 1, doing so in a
       way as to not violate any existing constraints.

       Note that if you override this method and have unique constraints including the "position_column" the
       shift is not a trivial task.  Refer to the implementation source of the default method for more
       information.

</pre><h4><b>CAVEATS</b></h4><pre>
   <b>Resultset</b> <b>Methods</b>
       Note that all Insert/Create/Delete overrides are happening on DBIx::Class::Row methods only. If you use
       the DBIx::Class::ResultSet versions of update or delete, all logic present in this module will be
       bypassed entirely (possibly resulting in a broken order-tree). Instead always use the update_all and
       delete_all methods, which will invoke the corresponding row method on every member of the given
       resultset.

   <b>Race</b> <b>Condition</b> <b>on</b> <b>Insert</b>
       If a position is not specified for an insert, a position will be chosen based either on
       "_initial_position_value" or "_next_position_value", depending if there are already some items in the
       current group. The space of time between the necessary selects and insert introduces a race condition.
       Having unique constraints on your position/group columns, and using transactions (see "txn_do" in
       DBIx::Class::Storage) will prevent such race conditions going undetected.

   <b>Multiple</b> <b>Moves</b>
       If you have multiple same-group result objects already loaded from storage, you need to be careful when
       executing "move_*" operations on them: without a "position_column" reload the "_position_value" of the
       "siblings" will be out of sync with the underlying storage.

       Starting from version 0.082800 DBIC will implicitly perform such reloads when the "move_*" happens as a
       part of a transaction (a good example of such situation is "$ordered_resultset-&gt;delete_all").

       If it is not possible for you to wrap the entire call-chain in a transaction, you will need to call
       "discard_changes" in DBIx::Class::Row to get an object up-to-date before proceeding, otherwise undefined
       behavior will result.

   <b>Default</b> <b>Values</b>
       Using a database defined default_value on one of your group columns could result in the position not
       being assigned correctly.

</pre><h4><b>FURTHER</b> <b>QUESTIONS?</b></h4><pre>
       Check the list of additional DBIC resources.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This module is free software copyright by the DBIx::Class (DBIC) authors. You can redistribute it and/or
       modify it under the same terms as the DBIx::Class library.

perl v5.40.0                                       2025-02-01                          <u>DBIx::Class::<a href="../man3pm/Ordered.3pm.html">Ordered</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>