<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wxScrolledWindow  -  The  wxScrolled (not implemented in wx) class manages scrolling for its client area,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       wxScrolledWindow  -  The  wxScrolled (not implemented in wx) class manages scrolling for its client area,
       transforming the coordinates according to the scrollbar positions,  and  setting  the  scroll  positions,
       thumb sizes and ranges according to the area in view.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       There are two commonly used (but not the only possible!) specializations of this class:

       Note:  See <u>wxScrolled::Create()</u> (not implemented in wx) if you want to use <u>wxScrolled</u> (not implemented in
       wx) with a custom class.

       Starting from version 2.4 of wxWidgets, there are several  ways  to  use  a  ?wxScrolledWindow  (and  now
       <u>wxScrolled</u> (not implemented in wx)). In particular, there are three ways to set the size of the scrolling
       area:

       One  way is to set the scrollbars directly using a call to <u>setScrollbars/6</u>. This is the way it used to be
       in any previous version of wxWidgets and it will be kept for backwards compatibility.

       An additional method of manual control, which requires a little less computation of your own, is  to  set
       the   total   size   of   the   scrolling   area   by   calling   either   <u>wxWindow:setVirtualSize/3</u>,  or
       <u>wxWindow:fitInside/1</u>, and setting the scrolling increments for it by calling  <u>setScrollRate/3</u>.  Scrolling
       in some orientation is enabled by setting a non-zero increment for it.

       The  most  automatic and newest way is to simply let sizers determine the scrolling area. This is now the
       default  when  you  set  an  interior  sizer  into  a   <u>wxScrolled</u>   (not   implemented   in   wx)   with
       <u>wxWindow:setSizer/3</u>. The scrolling area will be set to the size requested by the sizer and the scrollbars
       will  be  assigned for each orientation according to the need for them and the scrolling increment set by
       <u>setScrollRate/3</u>. As above, scrolling is only enabled in orientations with a non-zero increment.  You  can
       influence   the   minimum   size   of   the   scrolled   area   controlled   by   a   sizer   by  calling
       wxWindow::SetVirtualSizeHints(). (Calling <u>setScrollbars/6</u> has analogous effects in  wxWidgets  2.4  -  in
       later versions it may not continue to override the sizer.)

       Note  that if maximum size hints are still supported by wxWindow::SetVirtualSizeHints(), use them at your
       own dire risk. They may or may not have been removed for 2.4, but it  really  only  makes  sense  to  set
       minimum   size   hints   here.   We   should   probably   replace   wxWindow::SetVirtualSizeHints()  with
       wxWindow::SetMinVirtualSize() or similar and remove it entirely in future.

       As with all windows, an application can draw onto a <u>wxScrolled</u> (not implemented in  wx)  using  a  device
       context.

       You  have  the  option  of  handling  the  OnPaint  handler  or  overriding the <u>wxScrolled::OnDraw()</u> (not
       implemented in wx) function, which is passed a pre-scrolled device context (prepared by <u>doPrepareDC/2</u>).

       If you don't wish to calculate your own scrolling, you must call  <u>doPrepareDC/2</u>  when  not  drawing  from
       within <u>OnDraw()</u> (not implemented in wx), to set the device origin for the device context according to the
       current scroll position.

       A <u>wxScrolled</u> (not implemented in wx) will normally scroll itself and therefore its child windows as well.
       It  might however be desired to scroll a different window than itself: e.g. when designing a spreadsheet,
       you will normally only have to scroll the (usually white) cell area, whereas  the  (usually  grey)  label
       area  will  scroll very differently. For this special purpose, you can call <u>setTargetWindow/2</u> which means
       that pressing the scrollbars will scroll a different window.

       Note that the underlying system knows nothing about scrolling coordinates, so that all  system  functions
       (mouse  events,  expose  events, refresh calls etc) as well as the position of subwindows are relative to
       the "physical" origin of the scrolled window. If the user insert a child window at position  (10,10)  and
       scrolls  the  window  down 100 pixels (moving the child window out of the visible area), the child window
       will report a position of (10,-90).

       Styles

       This class supports the following styles:

       Note: Don't confuse wxScrollWinEvents generated by this class with  <u>wxScrollEvent</u>  objects  generated  by
       <u>wxScrollBar</u> and <u>wxSlider</u>.

       Remark: Use <u>wxScrolled</u> (not implemented in wx) for applications where the user scrolls by a fixed amount,
       and  where  a  'page'  can  be  interpreted  to  be  the  current visible portion of the window. For more
       sophisticated applications, use the <u>wxScrolled</u> (not implemented in wx) implementation as a guide to build
       your own scroll behaviour or use <u>wxVScrolledWindow</u> (not implemented in wx) or its variants.

       Since: The <u>wxScrolled</u> (not implemented in wx) template exists since version  2.9.0.  In  older  versions,
       only ?wxScrolledWindow (equivalent of wxScrolled&lt;wxPanel&gt;) was available.

       See:  <u>wxScrollBar</u>,  <u>wxClientDC</u>,  <u>wxPaintDC</u>,  <u>wxVScrolledWindow</u> (not implemented in wx), <u>wxHScrolledWindow</u>
       (not implemented in wx), <u>wxHVScrolledWindow</u> (not implemented in wx)

       This class is derived (and can use functions) from: <u>wxPanel</u> <u>wxWindow</u> <u>wxEvtHandler</u>

       wxWidgets docs: wxScrolledWindow

</pre><h4><b>EVENTS</b></h4><pre>
       Event   types   emitted   from   this   class:   <u>scrollwin_top</u>,    <u>scrollwin_bottom</u>,    <u>scrollwin_lineup</u>,
       <u>scrollwin_linedown</u>, <u>scrollwin_pageup</u>, <u>scrollwin_pagedown</u>, <u>scrollwin_thumbtrack</u>, <u>scrollwin_thumbrelease</u>

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>wxScrolledWindow()</b> = wx:wx_object()

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>new()</b> <b>-&gt;</b> <b>wxScrolledWindow()</b>

              Default constructor.

       <b>new(Parent)</b> <b>-&gt;</b> <b>wxScrolledWindow()</b>

              Types:

                 Parent = wxWindow:wxWindow()

       <b>new(Parent,</b> <b>Options</b> <b>::</b> <b>[Option])</b> <b>-&gt;</b> <b>wxScrolledWindow()</b>

              Types:

                 Parent = wxWindow:wxWindow()
                 Option =
                     {winid, integer()} |
                     {pos, {X :: integer(), Y :: integer()}} |
                     {size, {W :: integer(), H :: integer()}} |
                     {style, integer()}

              Constructor.

              Remark:  The  window  is  initially  created  without  visible scrollbars. Call <u>setScrollbars/6</u> to
              specify how big the virtual window size should be.

       <b>calcScrolledPosition(This,</b> <b>Pt)</b> <b>-&gt;</b> <b>{X</b> <b>::</b> <b>integer(),</b> <b>Y</b> <b>::</b> <b>integer()}</b>

              Types:

                 This = wxScrolledWindow()
                 Pt = {X :: integer(), Y :: integer()}

       <b>calcScrolledPosition(This,</b> <b>X,</b> <b>Y)</b> <b>-&gt;</b>
                               {Xx :: integer(), Yy :: integer()}

              Types:

                 This = wxScrolledWindow()
                 X = Y = integer()

              Translates the logical coordinates to the device ones.

              For example, if a window is scrolled 10 pixels to the bottom, the device coordinates of the origin
              are  (0,  0)  (as  always),  but  the  logical  coordinates  are  (0,  10)  and  so  the  call  to
              CalcScrolledPosition(0, 10, xx, yy) will return 0 in yy.

              See: <u>calcUnscrolledPosition/3</u>

       <b>calcUnscrolledPosition(This,</b> <b>Pt)</b> <b>-&gt;</b>
                                 {X :: integer(), Y :: integer()}

              Types:

                 This = wxScrolledWindow()
                 Pt = {X :: integer(), Y :: integer()}

       <b>calcUnscrolledPosition(This,</b> <b>X,</b> <b>Y)</b> <b>-&gt;</b>
                                 {Xx :: integer(), Yy :: integer()}

              Types:

                 This = wxScrolledWindow()
                 X = Y = integer()

              Translates the device coordinates to the logical ones.

              For example, if a window is scrolled 10 pixels to the bottom, the device coordinates of the origin
              are  (0,  0)  (as  always),  but  the  logical  coordinates  are  (0,  10)  and  so  the  call  to
              CalcUnscrolledPosition(0, 0, xx, yy) will return 10 in yy.

              See: <u>calcScrolledPosition/3</u>

       <b>enableScrolling(This,</b> <b>XScrolling,</b> <b>YScrolling)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 This = wxScrolledWindow()
                 XScrolling = YScrolling = boolean()

              Enable or disable use of <u>wxWindow:scrollWindow/4</u> for scrolling.

              By default, when a scrolled window is logically scrolled, <u>wxWindow:scrollWindow/4</u> is called on the
              underlying window which scrolls the window contents and only invalidates the part  of  the  window
              newly  brought  into  view.  If  false is passed as an argument, then this "physical scrolling" is
              disabled  and  the  window  is  entirely  invalidated  whenever  it   is   scrolled   by   calling
              <u>wxWindow:refresh/2</u>.

              It should be rarely necessary to disable physical scrolling, so this method shouldn't be called in
              normal circumstances.

       <b>getScrollPixelsPerUnit(This)</b> <b>-&gt;</b>
                                 {XUnit :: integer(), YUnit :: integer()}

              Types:

                 This = wxScrolledWindow()

              Get the number of pixels per scroll unit (line), in each direction, as set by <u>setScrollbars/6</u>.

              A value of zero indicates no scrolling in that direction.

              See: <u>setScrollbars/6</u>, <u>wxWindow:getVirtualSize/1</u>

       <b>getViewStart(This)</b> <b>-&gt;</b> <b>{X</b> <b>::</b> <b>integer(),</b> <b>Y</b> <b>::</b> <b>integer()}</b>

              Types:

                 This = wxScrolledWindow()

              This is a simple overload of GetViewStart(int*,int*); see that function for more info.

       <b>doPrepareDC(This,</b> <b>Dc)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 This = wxScrolledWindow()
                 Dc = wxDC:wxDC()

              Call this function to prepare the device context for drawing a scrolled image.

              It  sets  the  device  origin  according  to  the current scroll position. <u>doPrepareDC/2</u> is called
              automatically within the default <u>wxEVT_PAINT</u> event handler, so your <u>OnDraw()</u> (not  implemented  in
              wx) override will be passed an already 'pre-scrolled' device context. However, if you wish to draw
              from  outside  of  <u>OnDraw()</u>  (not implemented in wx) (e.g. from your own <u>wxEVT_PAINT</u> handler), you
              must call this function yourself.

              For example:

              Notice that the function sets the origin by moving it relatively to the current  origin  position,
              so  you shouldn't change the origin before calling <u>doPrepareDC/2</u> or, if you do, reset it to (0, 0)
              later. If you call <u>doPrepareDC/2</u> immediately after device context  creation,  as  in  the  example
              above, this problem doesn't arise, of course, so it is customary to do it like this.

       <b>prepareDC(This,</b> <b>Dc)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 This = wxScrolledWindow()
                 Dc = wxDC:wxDC()

              This function is for backwards compatibility only and simply calls <u>doPrepareDC/2</u> now.

              Notice  that  it is not called by the default paint event handle (<u>doPrepareDC/2</u> is), so overriding
              this method in your derived class is useless.

       <b>scroll(This,</b> <b>Pt)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 This = wxScrolledWindow()
                 Pt = {X :: integer(), Y :: integer()}

              This is an overload of <u>scroll/3</u>; see that function for more info.

       <b>scroll(This,</b> <b>X,</b> <b>Y)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 This = wxScrolledWindow()
                 X = Y = integer()

              Scrolls a window so the view start is at the given point.

              Remark: The positions are in scroll units, not pixels, so to convert to pixels you  will  have  to
              multiply  by  the  number  of  pixels per scroll increment. If either parameter is ?wxDefaultCoord
              (-1), that position will be ignored (no change in that direction).

              See: <u>setScrollbars/6</u>, <u>getScrollPixelsPerUnit/1</u>

       <b>setScrollbars(This,</b> <b>PixelsPerUnitX,</b> <b>PixelsPerUnitY,</b> <b>NoUnitsX,</b>
                     NoUnitsY) -&gt;
                        ok

              Types:

                 This = wxScrolledWindow()
                 PixelsPerUnitX = PixelsPerUnitY = NoUnitsX = NoUnitsY = integer()

       <b>setScrollbars(This,</b> <b>PixelsPerUnitX,</b> <b>PixelsPerUnitY,</b> <b>NoUnitsX,</b>
                     NoUnitsY,
                     Options :: [Option]) -&gt;
                        ok

              Types:

                 This = wxScrolledWindow()
                 PixelsPerUnitX = PixelsPerUnitY = NoUnitsX = NoUnitsY = integer()
                 Option =
                     {xPos, integer()} | {yPos, integer()} | {noRefresh, boolean()}

              Sets up vertical and/or horizontal scrollbars.

              The first pair of parameters give the number of pixels per 'scroll step', i.e. amount  moved  when
              the  up or down scroll arrows are pressed. The second pair gives the length of scrollbar in scroll
              steps, which sets the size of the virtual window.

              <u>xPos</u> and <u>yPos</u> optionally specify a position to scroll to immediately.

              For example, the following gives a window horizontal and vertical scrollbars with  20  pixels  per
              scroll step, and a size of 50 steps (1000 pixels) in each direction:

              <u>wxScrolled</u>  (not  implemented in wx) manages the page size itself, using the current client window
              size as the page size.

              Note that for more sophisticated scrolling applications, for example where  scroll  steps  may  be
              variable  according  to  the  position in the document, it will be necessary to derive a new class
              from <u>wxWindow</u>, overriding OnSize() and adjusting the scrollbars appropriately.

              See: <u>wxWindow:setVirtualSize/3</u>

       <b>setScrollRate(This,</b> <b>Xstep,</b> <b>Ystep)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 This = wxScrolledWindow()
                 Xstep = Ystep = integer()

              Set the horizontal and vertical scrolling increment only.

              See the pixelsPerUnit parameter in <u>setScrollbars/6</u>.

       <b>setTargetWindow(This,</b> <b>Window)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 This = wxScrolledWindow()
                 Window = wxWindow:wxWindow()

              Call this function to tell <u>wxScrolled</u> (not implemented in wx) to perform the actual scrolling on a
              different window (and not on itself).

              This method is useful when only a part of the window should be scrolled. A typical  example  is  a
              control  consisting  of  a  fixed  header  and  the scrollable contents window: the scrollbars are
              attached to the main window itself, hence it, and not the contents window  must  be  derived  from
              <u>wxScrolled</u>  (not  implemented in wx), but only the contents window scrolls when the scrollbars are
              used. To implement such setup, you need to call this method with the contents window as argument.

              Notice that if this method is used,  <u>GetSizeAvailableForScrollTarget()</u>  (not  implemented  in  wx)
              method must be overridden.

       <b>destroy(This</b> <b>::</b> <b>wxScrolledWindow())</b> <b>-&gt;</b> <b>ok</b>

              Destroys the object.

wxWidgets team.                                     wx 2.1.1                              <u><a href="../man3erl/wxScrolledWindow.3erl.html">wxScrolledWindow</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>