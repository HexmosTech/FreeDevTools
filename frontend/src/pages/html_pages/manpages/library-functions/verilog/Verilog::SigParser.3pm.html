<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verilog::SigParser - Signal Parsing for Verilog language files</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libverilog-perl">libverilog-perl_3.482-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Verilog::SigParser - Signal Parsing for Verilog language files

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Verilog::Preproc;
         use Verilog::SigParser;

         my $pp = Verilog::Preproc-&gt;new(keep_comments=&gt;0,);

         my $parser = new Verilog::SigParser;
         $parser-&gt;parse_preproc_file($pp);
         # The below described callbacks are then invoked

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Verilog::SigParser builds upon the Verilog::Parser module to provide callbacks for when a signal is
       declared, a module instantiated, or a module defined.

       See the "Which Package" section of Verilog::Language if you are unsure which parsing package to use for a
       new application.  For a higher level interface to this package, see Verilog::Netlist.

</pre><h4><b>METHODS</b></h4><pre>
       The method interface to Verilog::SigParser is described in the Verilog::Parser module which this package
       inherits.  You will probably want to use the preprocessing option of Verilog::Parser with this package.

</pre><h4><b>CALLBACKS</b></h4><pre>
       In order to make the parser do anything interesting, you must make a subclass where you override one or
       more of the following methods as appropriate.

       Note Verilog::Parser callbacks also are invoked when SigParser is parsing.

       $self-&gt;attribute($text)
           Scanned  an  attribute  or  meta-comment.   The  parser  inspects the first word of each comment line
           ("//key rest" to end of line) or  comment  block  ("/*key  rest  */).   It  calls  "$self-"attribute(
           meta_text )" if the first word has a true value in hash "$self-"metacomment&gt;.

       $self-&gt;class($token, $name, $virtual)
           This method is called at a class.

       $self-&gt;covergroup($token, $name)
           This method is called at a covergroup.

       $self-&gt;contassign($token, $lhs, $rhs)
           This  method  is  called  at  a continuous "assign" keyword, with the left and right hand part of the
           assignment.  Note that "wire" initializations are not considered assignments; those are received  via
           the var callback's value parameter.

       $self-&gt;defparam($token, $lhs, $rhs)
           This method is called at a "defparam" keyword, with the left and right hand part of the assignment.

       $self-&gt;endcell($token)
           This method is called at the end of defining a cell. It is useful for writing clean up routines.

       $self-&gt;endgroup($token)
           This  method  is  called  at  the  end  of  defining  a covergroup. It is useful for writing clean up
           routines.

       $self-&gt;endinterface($token)
           This method is called at a endinterface keyword. It is useful for writing clean up routines.

       $self-&gt;endclass($token)
           This method is called at a endclass keyword.  It is useful for writing clean up routines.

       $self-&gt;endtaskfunc($token)
           This method is called at a endfunction or endtask  keyword.   It  is  useful  for  writing  clean  up
           routines.

       $self-&gt;endmodport($token)
           This method is called at a endmodport keyword. It is useful for writing clean up routines.

       $self-&gt;endmodule($token)
           This method is called at a endmodule keyword. It is useful for writing clean up routines.

       $self-&gt;endpackage($token)
           This method is called at a endpackage keyword. It is useful for writing clean up routines.

       $self-&gt;endprogram($token)
           This method is called at a endprogram keyword. It is useful for writing clean up routines.

       $self-&gt;function($keyword, $name, $data-type)
           This  method  is  called  when  a  function  is  defined.   Type is the output size or typename, plus
           "signed", for example "", "[3:0]", "integer", or "signed [2:0]".

       $self-&gt;import($package, $id)
           This method is called when an import is defined.

       $self-&gt;instant($module, $cell, $range)
           This method is called when a instantiation is defined.  The first parameter is the name of the module
           being instantiated. The second parameter is the name of the cell, which may  be  ""  for  primitives.
           The third is the range if the cell was arrayed.

           Prior to version 3.000, the name of the parameters were also included in this callback. This has been
           replaced with the parampin callback.

       $self-&gt;interface($keyword, $name)
           This method is called when an interface is defined.

       $self-&gt;modport($keyword, $name)
           This method is called when an interface modport is defined.

       $self-&gt;module($keyword, $name, ignored, $in_celldefine)
           This method is called when a module is defined.

       $self-&gt;package($keyword, $name)
           This method is called when a package is defined.

       $self-&gt;parampin($name, $connection, $index)
           This  method is called when a parameter is connected to an instantiation, IE the "#(...)" syntax.  It
           is also used for UDP delays (Three calls for "#(delay0,delay1,delay2)"), as the parser does not  know
           if the instantiation is for an UDP versus a module.

       $self-&gt;pin($name, $connection, $index)
           This  method  is  called  when  a  pin  on an instant is defined and "use_pinselects" is not set (the
           default, see <b>pinselects()</b> below.  If a pin name was not provided and the connection is  by  position,
           name will be '' or undef.

           If  you  do  not  need  the pin nor var nor port callbacks, consider the "$self-&gt;new (... use_vars=&gt;0
           ...)"  option to accelerate parsing.

       $self-&gt;pinselects($name, $connections, $index)
           If "$self-&gt;new (... use_pinselects=&gt;1 ...)" is used this function is called  instead  of  "$self-&gt;pin
           (...)".   The  difference  is that the second parameter ("$connections") is a Perl hash that contains
           all connected nets in the case of concatenations including the MSB  and  LSB  bounds  used  at  these
           locations.

       $self-&gt;port($name, $objof, $direction, $data_type, $array, $pinnum)
           This  method  is  called when a module port is defined.  It may be called twice on a port if the 1995
           style is used; the first call is made at the  port  header,  the  second  call  at  the  input/output
           declaration.

           The  first  argument  $name,  is  the  name  of  the  port.   $objof is what the port is an object of
           ('module', 'function', etc).  $direction is the port direction ('input',  'output',  'inout',  'ref',
           'const  ref',  or  'interface').  $data_type is the data type ('reg', 'user_type_t', 'signed [31:0]',
           etc, or for interfaces the "{interface_id}.{modport_name}").  $array is  the  arraying  of  the  port
           ('[1:0][2:0]',  '',  etc).   $pinnum  is set to the pin number for ANSI style declarations, and 0 for
           Verilog 1995 declarations made outside the port list.

           If you do not need the pin nor var nor port callbacks,  consider  the  "$self-&gt;new  (...  use_vars=&gt;0
           ...)"  option to accelerate parsing.

       $self-&gt;program($keyword, $name)
           This method is called when a program is defined.

       $self-&gt;signal_decl($keyword, $signame, $vector, $mem, $signed, $value)
           This method is no longer used, see $self-&gt;var.

       $self-&gt;task($keyword, $name)
           This method is called when a task is defined.

       $self-&gt;var($kwd, $name, $objof, $nettype, $data_type, $array, $value)
           This method is called when a variable or net is defined.

           The  first  argument $kwd is how it was declared ('port', 'var', 'genvar', 'parameter', 'localparam',
           'typedef') or if applicable a net type ('supply0', 'wire', etc). $name is the name of  the  variable.
           $objof is what the variable is an object of ('module', 'function', etc).  $nettype is the net type if
           any  was  defined  ('',  'supply0', 'wire', 'tri', etc).  $data_type is the data type ('user_type_t',
           '[31:0] signed', etc).  $array is the arraying of the variable which is the text AFTER  the  variable
           name ('[1:0][2:0]', '', etc).  $value is what the variable was assigned to ('', or expression).

           Note typedefs are included here, because "parameter type" is both a variable and a type declaration.

           If  you  do  not  need  the pin nor var nor port callbacks, consider the "$self-&gt;new (... use_vars=&gt;0
           ...)"  option to accelerate parsing.

           Below are some example declarations and the callbacks:

              reg [4:0]  vect = 5'b10100;
              # VAR  'var' 'vect' 'module' '' 'reg [4:0]' '' '5'b10100'
              wire (weak0, weak1) value = pullval;
              # VAR  'net' 'value' 'module' 'wire' '' '' 'pullval'
              reg [1:0] mem [12:2];
              # VAR  'var' 'mem' 'module' '' 'reg [1:0]' '[12:2]' ''
              int n[1:2][1:3] = '{'{0,1,2}, '{3{4}}};
              # verilog/parser_sv.v:121: VAR  'var' 'n' 'module' '' 'int' '[1:2][1:3]' ''{'{0,1,2},'{3}}'
              module ( output logic [SZ-1:0] o_sized );
              # VAR  'port' 'o_sized' 'module' '' 'logic [SZ-1:0]' '' ''
              struct packed signed { bit [7:0] m_b; };
              # VAR  'member' 'm_b' 'struct' '' 'bit [7:0]' '' ''

</pre><h4><b>BUGS</b></h4><pre>
       This is being distributed as a baseline for future contributions.  Don't expect  a  lot,  the  Parser  is
       still naive, and there are many awkward cases that aren't covered.

       Note  the  SigParser is focused on extracting signal information.  It does NOT extract enough information
       to derive general interconnect; for example the contents of 'assign' statements are not parsed.

</pre><h4><b>DISTRIBUTION</b></h4><pre>
       Verilog-Perl is part of the &lt;https://www.veripool.org/&gt; free Verilog EDA software tool suite.  The latest
       version is available from CPAN and from &lt;https://www.veripool.org/verilog-perl&gt;.

       Copyright 2000-2024 by Wilson Snyder.  This package is free software;  you  can  redistribute  it  and/or
       modify  it under the terms of either the GNU Lesser General Public License Version 3 or the Perl Artistic
       License Version 2.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       Wilson Snyder &lt;<a href="mailto:wsnyder@wsnyder.org">wsnyder@wsnyder.org</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Verilog-Perl, Verilog::Parser, Verilog::Language, Verilog::Netlist, Verilog::Getopt

perl v5.40.1                                       2025-04-20                                     <u><a href="../man3pm/SigParser.3pm.html">SigParser</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>