<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google::ProtocolBuffers - simple interface to Google Protocol Buffers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgoogle-protocolbuffers-perl">libgoogle-protocolbuffers-perl_0.12-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Google::ProtocolBuffers - simple interface to Google Protocol Buffers

</pre><h4><b>SYNOPSYS</b></h4><pre>
           ##
           ## Define structure of your data and create serializer classes
           ##
           use Google::ProtocolBuffers;
           Google::ProtocolBuffers-&gt;parse("
               message Person {
                 required string name  = 1;
                 required int32 id     = 2; // Unique ID number for this person.
                 optional string email = 3;

                 enum PhoneType {
                   MOBILE = 0;
                   HOME = 1;
                   WORK = 2;
                 }

                 message PhoneNumber {
                   required string number = 1;
                   optional PhoneType type = 2 [default = HOME];
                 }

                 repeated PhoneNumber phone = 4;
               }
           ",
               {create_accessors =&gt; 1 }
           );

           ##
           ## Serialize Perl structure and print it to file
           ##
           open my($fh), "&gt;person.dat";
           binmode $fh;
           print $fh Person-&gt;encode({
               name    =&gt; 'A.U. Thor',
               id      =&gt; 123,
               phone   =&gt; [
                   { number =&gt; 1234567890 },
                   { number =&gt; 987654321, type=&gt;Person::PhoneType::WORK() },
               ],
           });
           close $fh;

           ##
           ## Decode data from serialized form
           ##
           my $person;
           {
               open my($fh), "&lt;person.dat";
               binmode $fh;
               local $/;
               $person = Person-&gt;decode(&lt;$fh&gt;);
               close $fh;
           }
           print $person-&gt;{name}, "\n";
           print $person-&gt;name,   "\n";  ## ditto

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Google Protocol Buffers is a data serialization format.  It is binary (and hence compact and fast for
       serialization) and as extendable as XML; its nearest analogues are Thrift and ASN.1.  There are official
       mappings for C++, Java and Python languages; this library is a mapping for Perl.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Google::ProtocolBuffers-&gt;parse($proto_text,</b> <b>\%options)</b>
   <b>Google::ProtocolBuffers-&gt;parsefile($proto_filename,</b> <b>\%options)</b>
       Protocol Buffers is a typed protocol, so work with it starts with some kind of Interface Definition
       Language named 'proto'.  For the description of the language, please see the official page
       (&lt;<a href="http://code.google.com/p/protobuf/">http://code.google.com/p/protobuf/</a>&gt;) Methods 'parse' and 'parsefile' take the description of data
       structure as text literal or as name of the proto file correspondently.  After successful compilation,
       Perl serializer classes are created for each message, group or enum found in proto. In case of error,
       these methods will die. On success, a list of names of created classes is returned.  Options are given as
       a hash reference, the recognizable options are:

       include_dir =&gt; [ $dir_name ]
           One  proto  file  may include others, this option sets where to look for the included files. Multiple
           dirs should be specificed as an ARRAYREF.

       generate_code =&gt; $filename or $file_handler
           Compilation of proto source  is  a  relatively  slow  and  memory  consuming  operation,  it  is  not
           recommended  in  production  environment.  Instead,  with  this  option  you  may specify filename or
           filehandle where to save Perl code of created serializer classes for future use. Example:

               ## in helper script
               use Google::ProtocolBuffers;
               Google::ProtocolBuffers-&gt;parse(
                   "message Foo {optional int32 a = 1; }",
                   { generate_code =&gt; 'Foo.pm' }
               );

               ## then, in production code
               use Foo;
               my $str = Foo-&gt;encode({a =&gt; 100});

       create_accessors (Boolean)
           If this option is set, then result of 'decode' will be a blessed structure with accessor methods  for
           each field, look at Class::Accessor for more info.  Example:

               use Google::ProtocolBuffers;
               Google::ProtocolBuffers-&gt;parse(
                   "message Foo { optional int32 id = 1; }",
                   { create_accessors =&gt; 1 }
               );
               my $foo = Foo-&gt;decode("\x{08}\x{02}");
               print $foo-&gt;id; ## prints 2
               $foo-&gt;<a href="../man100/id.100.html">id</a>(100);  ## now it is set to 100

       follow_best_practice (Boolean)
           This  option  is from Class::Accessor too; it has no effect without 'create_accessors'. If set, names
           of getters (read accessors) will start with get_ and names of setter with set_:

               use Google::ProtocolBuffers;
               Google::ProtocolBuffers-&gt;parse(
                   "message Foo { optional int32 id = 1; }",
                   { create_accessors =&gt; 1, follow_best_practice =&gt; 1 }
               );
               ## Class::Accessor provides a constructor too
               my $foo = Foo-&gt;new({ id =&gt; 2 });
               print $foo-&gt;get_id;
               $foo-&gt;<a href="../man100/set_id.100.html">set_id</a>(100);

       simple_extensions (Boolean)
           If this option is set, then extensions are treated as if they were  regular  fields  in  messages  or
           groups:

               use Google::ProtocolBuffers;
               use Data::Dumper;
               Google::ProtocolBuffers-&gt;parse(
                   "
                       message Foo {
                           optional int32 id = 1;
                           extensions 10 to max;
                       }
                       extend Foo {
                          optional string name = 10;
                       }
                   ",
                   { simple_extensions=&gt;1, create_accessors =&gt; 1 }
               );
               my $foo = Foo-&gt;decode("\x{08}\x{02}R\x{03}Bob");
               print Dumper $foo; ## { id =&gt; 2, name =&gt; 'Bob' }
               print $foo-&gt;id, "\n";
               $foo-&gt;name("Sponge Bob");

           This  option  is off by default because extensions live in a separate namespace and may have the same
           names as fields. Compilation of such proto with 'simple_extension' option will result in die.  If the
           option is  off,  you  have  to  use  special  accessors  for  extension  fields  -  setExtension  and
           getExtension,  as  in  C++  Protocol  Buffer  API.  Hash  keys  for extended fields in Plain Old Data
           structures will be enclosed in brackets:

               use Google::ProtocolBuffers;
               use Data::Dumper;
               Google::ProtocolBuffers-&gt;parse(
                   "
                       message Foo {
                           optional int32 id = 1;
                           extensions 10 to max;
                       }
                       extend Foo {
                          optional string id = 10; // &lt;-- id again!
                       }
                   ",
                   {   simple_extensions   =&gt; 0,   ## &lt;-- no simple extensions
                       create_accessors    =&gt; 1,
                   }
               );
               my $foo = Foo-&gt;decode("\x{08}\x{02}R\x{05}Kenny");
               print Dumper $foo;      ## { id =&gt; 2, '[id]' =&gt; 'Kenny' }
               print $foo-&gt;id, "\n";                   ## 2
               print $foo-&gt;getExtension('id'), "\n";   ## Kenny
               $foo-&gt;setExtension("id", 'Kenny McCormick');

       no_camel_case (Boolean)
           By default, names of created Perl classes are taken from "camel-cased"  names  of  proto's  packages,
           messages,  groups  and  enums.  First characters are capitalized, all underscores are removed and the
           characters  following  them   are   capitalized   too.   An   example:   a   fully   qualified   name
           'package_test.Message' will result in Perl class 'PackageTest::Message'. Option 'no_camel_case' turns
           name-mangling off.  Names of fields, extensions and enum constants are not affected anyway.

       package_name (String)
           Package  name  to  be  put  into  generated Perl code; has no effect on Perl classes names and has no
           effect unless 'generate_code' is also set.

   <b>MessageClass-&gt;encode($hashref)</b>
       This method may be called as class  or  instance  method.  'MessageClass'  must  already  be  created  by
       compiler.  Input  is a hash reference.  Output is a scalar (string) with serialized data.  Unknown fields
       in hashref are ignored.  In case of errors (e.g. required field is not set and there is no default  value
       for the required field) an exception is thrown.  Examples:

           use Google::ProtocolBuffers;
           Google::ProtocolBuffers-&gt;parse(
               "message Foo {optional int32 id = 1; }",
               {create_accessors =&gt; 1}
           );
           my $string = Foo-&gt;encode({ id =&gt; 2 });
           my $foo = Foo-&gt;new({ id =&gt; 2 });
           $string = $foo-&gt;encode;                 ## ditto

   <b>MessageClass-&gt;decode($scalar)</b>
       Class  method. Input: serialized data string. Output: data object of class 'MessageClass'. Unknown fields
       in serialized data are ignored.  In case of errors (e.g. message is broken or partial) or data string  is
       a wide-character (utf-8) string, an exception is thrown.

</pre><h4><b>PROTO</b> <b>ELEMENTS</b></h4><pre>
   <b>Enums</b>
       For  each  enum  in  proto,  a Perl class will be constructed with constants for each enum value. You may
       import these constants via ClassName-&gt;import(":constants") call. Please note that Perl compiler will know
       nothing about these constants at compile time, because this import occurs at  run  time,  so  parenthesis
       after constant's name are required.

           use Google::ProtocolBuffers;
           Google::ProtocolBuffers-&gt;parse(
               "
                   enum Foo {
                          FOO = 1;
                          BAR = 2;
                   }
               ",
               { generate_code =&gt; 'Foo.pm' }
           );
           print Foo::FOO(), "\n";     ## fully quailified name is fine
           Foo-&gt;import(":constants");
           print FOO(), "\n";          ## now FOO is defined in our namespace
           print FOO;                  ## &lt;-- Error! FOO is bareword!

       Or, do the import inside a BEGIN block:

           use Foo;                    ## Foo.pm was generated in previous example
           BEGIN { Foo-&gt;import(":constants") }
           print FOO, "\n";            ## ok, Perl compiler knows about FOO here

   <b>Groups</b>
       Though  group  are  considered  deprecated  they are supported by Google::ProtocolBuffers.  They are like
       nested messages, except that nested type definition and field definition go together:

           use Google::ProtocolBuffers;
           Google::ProtocolBuffers-&gt;parse(
               "
                   message Foo {
                       optional group Bar = 1 {
                           optional int32 baz = 1;
                       }
                   }
               ",
               { create_accessors =&gt; 1 }
           );
           my $foo = Foo-&gt;new;
           $foo-&gt;Bar( Foo::Bar-&gt;new({ baz =&gt; 2 }) );
           print $foo-&gt;Bar-&gt;baz, ", ", $foo-&gt;{Bar}-&gt;{baz}, "\n";   # 2, 2

   <b>Default</b> <b>values</b>
       Proto file may specify a default value for a field.  The default value is returned by accessor  if  there
       is  no  value  for field or if this value is undefined. The default value is not accessible via plain old
       data hash, though. Default string values are always byte-strings, if you  need  wide-character  (Unicode)
       string, use "decode_utf8" in Encode.

           use Google::ProtocolBuffers;
           Google::ProtocolBuffers-&gt;parse(
               "message Foo {optional string name=1 [default='Kenny'];} ",
               {create_accessors =&gt; 1}
           );

           ## no initial value
           my $foo = Foo-&gt;new;
           print $foo-&gt;name(), ", ", $foo-&gt;{name}, "\n"; # Kenny, (undef)

           ## some defined value
           $foo-&gt;name('Ken');
           print $foo-&gt;name(), ", ", $foo-&gt;{name}, "\n"; # Ken, Ken

           ## empty, but still defined value
           $foo-&gt;name('');
           print $foo-&gt;name(), ", ", $foo-&gt;{name}, "\n"; # (empty), (empty)

           ## undef value == default value
           $foo-&gt;name(undef);
           print $foo-&gt;name(), ", ", $foo-&gt;{name}, "\n"; # Kenny, (undef)

   <b>Extensions</b>
       From the point of view of serialized data, there is no difference if a field is declared as regular field
       or  if  it  is  extension,  as  far  as  field  number  is  the  same.   That  is  why there is an option
       'simple_extensions' (see above) that treats extensions like regular fields.  From the point  of  view  of
       named  accessors,  however,  extensions  live in namespace different from namespace of fields, that's why
       they simple names (i.e. not fully qualified ones) may conflict.  (And that's why this option  is  off  by
       default).   The name of extensions are obtained from their fully qualified names from which leading part,
       most common with the class name to be extended, is stripped. Names of hash  keys  enclosed  in  brackets;
       arguments  to  methods 'getExtension' and 'setExtension' do not.  Here is the self-explanatory example to
       the rules:

           use Google::ProtocolBuffers;
           use Data::Dumper;

           Google::ProtocolBuffers-&gt;parse(
               "
                   package some_package;
                   // message Plugh contains one regular field and three extensions
                   message Plugh {
                       optional int32 foo = 1;
                       extensions 10 to max;
                   }
                   extend Plugh {
                       optional int32 bar = 10;
                   }
                   message Thud {
                       extend Plugh {
                           optional int32 baz = 11;
                       }
                   }

                   // Note: the official Google's proto compiler does not allow
                   // several package declarations in a file (as of version 2.0.1).
                   // To compile this example with the official protoc, put lines
                   // above to some other file, and import that file here.
                   package another_package;
                   // import 'other_file.proto';

                   extend some_package.Plugh {
                       optional int32 qux = 12;
                   }

               ",
               { create_accessors =&gt; 1 }
           );

           my $plugh = SomePackage::Plugh-&gt;decode(
               "\x{08}\x{01}\x{50}\x{02}\x{58}\x{03}\x{60}\x{04}"
           );
           print Dumper $plugh;
           ## {foo=&gt;1, '[bar]'=&gt;2, '[Thud.baz]'=&gt;3, [another_package.qux]=&gt;4}

           print $plugh-&gt;foo, "\n";                            ## 1
           print $plugh-&gt;getExtension('bar'), "\n";            ## 2
           print $plugh-&gt;getExtension('Thud.baz'), "\n";       ## 3
           print $plugh-&gt;getExtension('Thud::baz'), "\n";      ## ditto

       Another point is that 'extend' block doesn't create new  namespace  or  scope,  so  the  following  proto
       declaration is invalid:

           // proto:
           package test;
           message Foo { extensions 10 to max; }
           message Bar { extensions 10 to max; }
           extend Foo { optional int32 a = 10; }
           extend Bar { optional int32 a = 20; }   // &lt;-- Error: name 'a' in package
                                                   // 'test' is already used!

       Well,  extensions are the most complicated part of proto syntax, and I hope that you either got it or you
       don't need it.

</pre><h4><b>RUN-TIME</b> <b>MESSAGE</b> <b>CREATION</b></h4><pre>
       You don't like to mess with proto files?  Structure of your data is known at run-time only?  No  problem,
       create       your       serializer       classes       at       run-time       too       with      method
       Google::ProtocolBuffers-&gt;create_message('ClassName', \@fields, \%options);  (Note:  The  order  of  field
       description  parts  is  the same as in proto file. The API is going to change to accept named parameters,
       but backward compatibility will be preserved).

           use Google::ProtocolBuffers;
           use Google::ProtocolBuffers::Constants(qw/:labels :types/);

           ##
           ## proto:
           ## message Foo {
           ##      message Bar {
           ##           optional int32 a = 1 [default=12];
           ##      }
           ##      required int32 id = 1;
           ##      repeated Bar   bars = 2;
           ## }
           ##
           Google::ProtocolBuffers-&gt;create_message(
               'Foo::Bar',
               [
                   ## optional      int32        a = 1 [default=12]
                   [LABEL_OPTIONAL, TYPE_INT32, 'a', 1, '12']
               ],
               { create_accessors =&gt; 1 }
           );
           Google::ProtocolBuffers-&gt;create_message(
               'Foo',
               [
                   [LABEL_REQUIRED, TYPE_INT32, 'id',   1],
                   [LABEL_REPEATED, 'Foo::Bar', 'bars', 2],
               ],
               { create_accessors =&gt; 1 }
           );
           my $foo = Foo-&gt;new({ id =&gt; 10 });
           $foo-&gt;bars( Foo::Bar-&gt;new({a=&gt;1}), Foo::Bar-&gt;new({a=&gt;2}) );
           print $foo-&gt;encode;

       There are methods 'create_group' and 'create_enum' also; the following  constants  are  exported:  labels
       (LABEL_OPTIONAL,   LABEL_OPTIONAL,  LABEL_REPEATED)  and  types  (TYPE_INT32,  TYPE_UINT32,  TYPE_SINT32,
       TYPE_FIXED32,  TYPE_SFIXED32,  TYPE_INT64,   TYPE_UINT64,   TYPE_SINT64,   TYPE_FIXED64,   TYPE_SFIXED64,
       TYPE_BOOL, TYPE_STRING, TYPE_BYTES, TYPE_DOUBLE, TYPE_FLOAT).

</pre><h4><b>KNOWN</b> <b>BUGS,</b> <b>LIMITATIONS</b> <b>AND</b> <b>TODOs</b></h4><pre>
       All  proto  options  are  ignored  except  default  values for fields; extension numbers are not checked.
       Unknown fields in serialized data are skipped, no stream API (encoding to/decoding from file handlers) is
       present.  Ask for what you need most.

       Introspection API is planned.

       Declarations of RPC services are currently ignored, but their support is planned  (btw,  which  Perl  RPC
       implementation would you recommend?)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Official page of Google's Protocol Buffers project (&lt;<a href="http://code.google.com/p/protobuf/">http://code.google.com/p/protobuf/</a>&gt;)

       Protobuf-PerlXS  project  (&lt;<a href="http://code.google.com/p/protobuf-perlxs/">http://code.google.com/p/protobuf-perlxs/</a>&gt;)  -  creates  XS  wrapper  for C++
       classes generated by official Google's compiler protoc. You have to complile XS files every  time  you've
       changed the proto description, however, this is the fastest way to work with Protocol Buffers from Perl.

       Protobuf-Perl  project  &lt;<a href="http://code.google.com/p/protobuf-perl/">http://code.google.com/p/protobuf-perl/</a>&gt;  -  someday  it may be part of official
       Google's compiler.

       Thrift &lt;<a href="http://developers.facebook.com/thrift/">http://developers.facebook.com/thrift/</a>&gt;

       ASN.1 &lt;<a href="http://en.wikipedia.org/wiki/ASN.1">http://en.wikipedia.org/wiki/ASN.1</a>&gt;, JSON and YAML

</pre><h4><b>AUTHOR,</b> <b>ACKNOWLEDGEMENS,</b> <b>COPYRIGHT</b></h4><pre>
       Author: Igor Gariev &lt;<a href="mailto:gariev@hotmail.com">gariev@hotmail.com</a>&gt;
               the CSIRT Gadgets Foundation &lt;csirtgadgets.org&gt;

       Proto        grammar        is        based         on         work         by         Alek         Storm
       &lt;<a href="http://groups.google.com/group/protobuf/browse_thread/thread/1cccfc624cd612da">http://groups.google.com/group/protobuf/browse_thread/thread/1cccfc624cd612da</a>&gt;

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself, either Perl version 5.10.0 or, at your  option,  any  later  version  of  Perl  5  you  may  have
       available.

perl v5.28.0                                       2018-11-15                       <u>Google::<a href="../man3pm/ProtocolBuffers.3pm.html">ProtocolBuffers</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>