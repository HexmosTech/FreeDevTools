<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geo::Google::MapObject - Code to help with managing the server side of the Google Maps API</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgeo-google-mapobject-perl">libgeo-google-mapobject-perl_0.06-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Geo::Google::MapObject - Code to help with managing the server side of the Google Maps API

</pre><h4><b>VERSION</b></h4><pre>
       Version 0.06

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use HTML::Template::Pluggable;
           use HTML::Template::Plugin::Dot;
           use Geo::Google::MapObject;
           my $map = Geo::Google::MapObject-&gt;new(
               key =&gt; 'ABQFbHAATHwok56Qe3MBtg0s7lgkHBS9HKneet7v0OIFhIwnBhTEGCHLTRRRBa_lUOCy1fDamS5PQt8qULYfYQ',
               zoom =&gt; 13,
               size =&gt; '512x400',
               maptype =&gt; 'terrain',
               markers=&gt;
               [
                       {
                               location=&gt;'51.242844,0.011716',
                               color=&gt;'green',
                               label=&gt;'P',
                               title=&gt;'Periapt Technologies',
                               href=&gt;'<a href="http://www.periapt.co.uk">http://www.periapt.co.uk</a>'
                       },
                       {
                               location=&gt;'51.243757,0.006051',
                               color=&gt;'red',
                               label=&gt;'C',
                               title=&gt;'Crown Roast Butchers',
                               href=&gt;'<a href="http://www.crownroast.co.uk/">http://www.crownroast.co.uk/</a>'
                       },
               ]
           );
           my $template = HTML::Template::Pluggable-&gt;new(file=&gt;'map.tmpl');
           $template-&gt;param(map=&gt;$map);
           return $template-&gt;output;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is intended to provide a server side solution to working with the Google Maps API.  In
       particular an object of this class encapsulates a "map" object that provides support for the static maps
       API, the javascript maps API, AJAX calls and non-javascript fallback data; but without making many
       assumptions about the surrounding framework.  We do assume that a template framework with support for a
       "dot" notation is being used, for example HTML::Template::Pluggable.  An important commitment of the
       module is support for graceful and consistent fallback to a functional non-javascript web page.

       The javascript and static Google map APIs do not behave in quite the same way when zoom and center are
       not specified.  Specifically it works quite well with the static maps
       (&lt;<a href="http://code.google.com/apis/maps/documentation/staticmaps/">http://code.google.com/apis/maps/documentation/staticmaps/</a>#ImplicitPositioning&gt;) but not so well with
       the javascript API.  To compensate for this the module gives a choice between: specifying the center and
       zoom levels; allowing the APIs and client side code to do whatever they think best; using a built in
       algorithm to calculate a sensible zoom and center; and finally supplying ones own algorithm to calculate
       a sensible zoom and center.

</pre><h4><b>INTERFACE</b></h4><pre>
   <b>new</b>
       Supported arguments are

       autozoom
           If  no  center  and/or zoom is specified this parameter can be used to calculate suitable values by a
           process of averaging the markers. If this parameter is an integer between 0 and 21 then  that  number
           is taken as a maximum zoom level and the builtin algorithm, "calculate_zoom_and_center", is used with
           that  maximum  zoom  level.   If the parameter is a CODE ref, then that function is used instead. The
           CODE ref must take an ARRAY ref of marker  specifications  as  an  input,  and  must  return  a  pair
           consisting  of  the zoom level as an integer followed by a latitude-longitude string representing the
           center.  Finally if the argument is blessed and has a "calculate_zoom_and_center" method,  that  will
           be  used.   For  AUTO  calculation  of  the  center  or  zoom  all  the  markers  must be in the form
           "decimal,decimal". The "json" method will delete this as it has no meaning once the  zoom  level  and
           center have been determined.

       center
           This  must  be  a  location  that  would  be recognized by the Google maps API.  If absent, and if no
           autozoom has been set, the Google maps API and client side javascript code must between them work out
           a center.

       zoom
           This                  represents                   the                   zoom                   level
           (&lt;<a href="http://code.google.com/apis/maps/documentation/staticmaps/">http://code.google.com/apis/maps/documentation/staticmaps/</a>#Zoomlevels&gt;),  which is a number between
           0 and 21 inclusive. If absent (with no autozoom set) the API and client will need to set it.

       size
           The size (&lt;<a href="http://code.google.com/apis/maps/documentation/staticmaps/">http://code.google.com/apis/maps/documentation/staticmaps/</a>#Imagesizes&gt;) must either  be  a
           string  consisting  of  two  numbers  joined  by  the symbol "x", or a hash ref with width and height
           parameters. In either case the first number is the width and the second the  height.  If  absent  the
           Google API will be allowed to set the size as it sees fit.

       format
           The  optional format (&lt;<a href="http://code.google.com/apis/maps/documentation/staticmaps/">http://code.google.com/apis/maps/documentation/staticmaps/</a>#ImageFormats&gt;) must
           be one of 'png8',  'png', 'png32', 'gif', 'jpg', 'jpg-baseline'. If absent the  Google  API  will  be
           allowed  to set the format as it sees fit. Note that although the "json" method will pass this on, it
           seems to have no meaning in the dynamic API.

       maptype
           This must be one  of  the  following:  'roadmap',  'satellite',  'terrain',  'hybrid's  described  in
           &lt;<a href="http://code.google.com/apis/maps/documentation/staticmaps/">http://code.google.com/apis/maps/documentation/staticmaps/</a>#MapTypes&gt;.   The   "json"   method   will
           translate these into numerical codes roadmap =&gt; 0, satellite =&gt; 1, terrain =&gt; 2 and hybrid  =&gt;  3  as
           this          makes          it          easy         for         the         javascript         code
           (&lt;<a href="http://code.google.com/apis/maps/documentation/reference.html">http://code.google.com/apis/maps/documentation/reference.html</a>#GMapType.Constants&gt;)   to   translate
           this numerical code into the client side codes. For example:

             var mapping = new Array(G_NORMAL_MAP, G_SATELLITE_MAP, G_PHYSICAL_MAP, G_HYBRID_MAP);
             var maptype = mapping[data.maptype];

       mobile
           This  parameter should be either the string 'true' or 'false' and defaults to 'false'. The static API
           uses      it      to      provide      more      robust       tiles       as       described       in
           &lt;<a href="http://code.google.com/apis/maps/documentation/staticmaps/">http://code.google.com/apis/maps/documentation/staticmaps/</a>#Mobile&gt;.  However  it  seems  to  have no
           meaning for the dynamic API.

       key The mandatory API key. You can sign up for one at &lt;<a href="http://code.google.com/apis/maps/signup.html">http://code.google.com/apis/maps/signup.html</a>&gt;.

       sensor
           This parameter should be either the string 'true' or 'false' and defaults to 'false'.  Both  versions
           of  the  Google  API require it (&lt;<a href="http://code.google.com/apis/maps/documentation/staticmaps/">http://code.google.com/apis/maps/documentation/staticmaps/</a>#Sensor&gt;)
           and this is reflected in this module by it being used by the  "static_map_url"  and  "javascript_url"
           methods.

       markers
           If  present  the  markers should be an array ref of marker specifications so that it can be used in a
           TMPL_LOOP.  Each marker specification should be a hash ref and may contain whatever keys are required
           by the javascript client  side  code.  It  must  however  have  a  "location"  field  which  must  be
           interpretable by the Google API as a location. In general this means the location must be a string of
           the  form "decimal,decimal", where the first decimal is the latitude and the second longitude.  Other
           fields might include for example: id, title, href, icon. Generally these just get passed  through  by
           the  "json" method and should be used by the client side code as it sees fit.  Three fields that have
           a  special  meaning,  "color",  "size",  "label"  are  those  described  by  the  static   maps   API
           (&lt;<a href="http://code.google.com/apis/maps/documentation/staticmaps/">http://code.google.com/apis/maps/documentation/staticmaps/</a>#MarkerStyles&gt;).     The    GIcon   class
           (&lt;<a href="http://code.google.com/apis/maps/documentation/reference.html">http://code.google.com/apis/maps/documentation/reference.html</a>#GIcon&gt;)  contains  lots  of  ways  of
           specialising  the  look  and  feel  of  the markers in the dynamic API; but I can find no easy way of
           consistently replicating the the static marker styles in the dynamic API. The only other field  which
           gets special treatment is "title". The "json" method will encode the title field. So for example if a
           marker  has  a  title  field  of  'Sclo&amp;szlig;',  then  if the javascript code uses this as the title
           attribute when creating a GMarker, then hovering the mouse over that marker will display  the  German
           word for castle.

       hl  This  parameter  specifies  the language to be used. If absent the API will select the language. Only
           the   dynamic   javascript    API    seems    to    use    this    parameter    as    described    in
           &lt;<a href="http://code.google.com/apis/maps/documentation/">http://code.google.com/apis/maps/documentation/</a>#Localization&gt;.   As   such   this  is  used  in  the
           "javascript_url" method.

   <b>calculate_zoom_and_center</b>
       This function tales a reference to an array of marker specifications and a maximum zoom level and returns
       a pair consisting of a suggested zoom level and a center.

       The algorithm works by iteratively building the following objects:

       A set of points, starting with the first element of the array and adding the next one at each iteration.
           Actually we don't actually have a variable for this, but without thinking about this set conceptually
           I cannot state the algorithm. The set starts of consisting of just the first marker location.

       "($ctheta, $cphi)"
           These numbers represent a central point of the set of points represented as  radians.  The  algorithm
           does  not guarantee that the point is the true centre but we treat it as the centre of a circle. This
           starts of by taking the first element and converting its latitude and longitude to radians.

       $radius
           This variable is initialised to 0.

       The contract
           The algorithm requires that at each iteration all the points in the set are at most  $radius  radians
           from ($ctheta, $cphi).

       The iteration
           We  look  at the next point. We look at the distance ($distance) between the new point and "($ctheta,
           $cphi)". If this is less than or equal to $radius the iteration  is  over.  Otherwise  the  following
           happens:

             ($ctheta, $cphi)      = mid point of ($ctheta, $cphi) and the new point
             $radius               = $radius + 0.5 * distance between ($ctheta, $cphi) and the new point

       At the end
           We  convert  "($ctheta, $cphi)" back to latitude and longitude and logarithmically convert the radius
           to a zoom level.

       I doubt that this algorithm is optimal but it seems quick, uses only one pass through the markers and can
       be seen in action at &lt;<a href="http://testmaps.periapt.co.uk">http://testmaps.periapt.co.uk</a>&gt;. Also if you have a better one you can specify it by
       passing a suitable CODE ref or blessed scalar to the "autozoom" parameter of the constructor.

   <b>static_map_url</b>
       Returns a URL suitable for use with  the  static  maps  API  based  upon  the  arguments  passed  to  the
       constructor.

   <b>javascript_url</b>
       Returns a URL suitable for use in loading the dynamic map API.

   <b>markers</b>
       This returns the marker array ref.

   <b>json</b>
       This function uses the JSON module to return a JSON representation of the object.  It removes the API key
       as  that  should  not  be  required by any javascript client side code.  If any marker object has a title
       attribute, then that attribute is encoded so it will display correctly during mouse overs.

   <b>width</b>
       This returns the width of the image or undef if none has been set.

   <b>height</b>
       This returns the height of the image or undef if none has been set.

</pre><h4><b>TUTORIAL</b></h4><pre>
       This module only covers the server side of a two way conversation between server and a talkative  client.
       As  such the tutorial must also consider HTML and javascript.  Also to understand this tutorial we assume
       at least passing familiarity with the following:

       HTML::Template::Pluggable or some other templating framework using the "dot" notation.
       The Google maps API: &lt;<a href="http://code.google.com/apis/maps/documentation/reference.html">http://code.google.com/apis/maps/documentation/reference.html</a>&gt;.
       The static Google maps API: &lt;<a href="http://code.google.com/apis/maps/documentation/staticmaps/">http://code.google.com/apis/maps/documentation/staticmaps/</a>&gt;
       Javascript, AJAX. Specifically we are using the yui framework (&lt;<a href="http://developer.yahoo.com/yui/2/">http://developer.yahoo.com/yui/2/</a>&gt;)
       though any other framework will do.

   <b>The</b> <b>markup</b>
       We probably have a template file, map.tmpl, some thing like the following:

         &lt;html&gt;
           &lt;head&gt;
             &lt;title&gt;Test Map Tutorial&lt;/title&gt;

             &lt;!-- This way we tell the javascript what URL to contact the server with. --&gt;
             &lt;link href="/map_json" id="get_init_data"/&gt;

             &lt;!-- This will be filled in with the correct URL to load the Google maps javascript API. --&gt;
             &lt;script type="text/javascript" src="&lt;TMPL_VAR NAME="maps.javascript_url()"&gt;"&gt;&lt;/script&gt;

             &lt;!-- This will load the yui API. If you use a different javascript API this would obviously change. --&gt;
             &lt;script type="text/javascript" src="<a href="http://yui.yahooapis.com/2.8.0r4/build/yahoo-dom-event/yahoo-dom-event.js">http://yui.yahooapis.com/2.8.0r4/build/yahoo-dom-event/yahoo-dom-event.js</a>"&gt;&lt;/script&gt;
             &lt;script type="text/javascript" src="<a href="http://yui.yahooapis.com/2.8.0r4/build/connection/connection.js">http://yui.yahooapis.com/2.8.0r4/build/connection/connection.js</a>"&gt;&lt;/script&gt;
             &lt;script type="text/javascript" src="<a href="http://yui.yahooapis.com/2.8.0r4/build/json/json-min.js">http://yui.yahooapis.com/2.8.0r4/build/json/json-min.js</a>"&gt;&lt;/script&gt;

             &lt;!-- This loads our javascript code. --&gt;
             &lt;script type="text/javascript" src="/js/maps.js"&gt;&lt;/script&gt;
           &lt;/head&gt;
           &lt;body&gt;

             &lt;!-- This div will be completely replaced by the Google API and is identified by #map_canvas. --&gt;
             &lt;div id="map_canvas"&gt;

               &lt;!-- This image will be loaded by the static Google map API. It will be available whilst the
                       javascript based map is loading and if javascript is turned off
               --&gt;
               &lt;div&gt;&lt;img
                       alt="Test map"
                       src="&lt;TMPL_VAR NAME="maps.static_map_url()"&gt;"
                       width="&lt;TMPL_VAR NAME="maps.width()"&gt;"
                       height="&lt;TMPL_VAR NAME="maps.height()"&gt;"
                       /&gt;
               &lt;/div&gt;

               &lt;!-- The following will be used if javascript is disabled.
                    We can use it display information that would normally be obtained by
                    hovering over or clicking on markers on the dynamic map display.
               --&gt;
               &lt;noscript&gt;
                    &lt;table&gt;
                      &lt;TMPL_LOOP NAME="maps.markers()"&gt;
                        &lt;tr&gt;
                          &lt;td class="google_&lt;TMPL_VAR NAME="this.color"&gt;"&gt;&lt;TMPL_VAR NAME="this.label"&gt;&lt;/td&gt;
                          &lt;td&gt;
                             &lt;TMPL_IF NAME="this.href"&gt;
                             &lt;a href="&lt;TMPL_VAR NAME="this.href"&gt;"&gt;
                             &lt;/TMPL_IF&gt;
                             &lt;TMPL_VAR NAME="this.title"&gt;
                             &lt;TMPL_IF NAME="this.href"&gt;
                             &lt;/a&gt;
                             &lt;/TMPL_IF&gt;
                           &lt;/td&gt;
                        &lt;/tr&gt;
                      &lt;/TMPL_LOOP&gt;
                    &lt;/table&gt;
               &lt;/noscript&gt;

             &lt;/div&gt; &lt;!-- end of #map_canvas --&gt;

           &lt;/body&gt;
         &lt;/html&gt;

   <b>The</b> <b>perl</b>
       The code to actually produce the web page must look something like this:

               use HTML::Template::Pluggable;
               use HTML::Template::Plugin::Dot;
               use Geo::Google::MapObject;
               my $t = HTML::Template::Pluggable-&gt;new(filename =&gt; 'map.tmpl');
               my $map = Geo::Google::MapObject-&gt;new(....);
               $t-&gt;param(maps=&gt;$map);
               print $t-&gt;output;

       This is all that would be needed in a javascript free environment. With javascript enabled the client  is
       going  to  ask  for  the  same  data in a JSON format (at least we are only supporting JSON). The code to
       service that request will look something like:

               use Geo::Google::MapObject;
               my $map = Geo::Google::MapObject-&gt;new(....);
               print $map-&gt;json;

   <b>The</b> <b>javascript</b>
       As indicated in the markup above we are expecting the javascript to be in  a  file  called  maps.js.   We
       expect it to look something like the following:

         function mapInitialize() {

             /* Read the "link" element that tells us how to contact the server. See markup above. */
             var get_init_data = YAHOO.util.Dom.get('get_init_data').href;

             /* Build the AJAX callback object consisting of three parts.  */
             var callback =
             {

                 /* Part I: Function called in the event of a successful call. */
                 success: function(o) {

                       /* Convert the JSON response into a javascript object.
                          This structure corresponds to the Geo::Google::MapObject in perl
                          as intermediated by its "json" method.
                        */
                       var data = YAHOO.lang.JSON.parse(o.responseText);

                       if (GBrowserIsCompatible()) {

                               /* Build up the Map object which will replace #map_canvas in the above markup. */
                               var mapopt = {};
                               if (data.size) {
                                       mapopt.size = new GSize(parseInt(data.size.width), parseInt(data.size.height));
                               }
                               var markers = data.markers;
                               var map = new GMap2(YAHOO.util.Dom.get("map_canvas"), mapopt);
                               var maptype = null;
                               if (data.maptype) {
                                       maptype = o.argument[parseInt(data.maptype)];
                               }
                               var zoom = null;
                               if (data.zoom) {
                                       zoom = parseInt(data.zoom);
                               }
                               var center = markers[0].location;
                               if (data.center) {
                                       center = data.center;
                               }
                               map.setCenter(GLatLng.fromUrlValue(center), zoom, maptype);
                               map.setUIToDefault();

                               /* Now for each marker build and add a GMarker object */
                               for(var i = 0; i &lt; markers.length; i++) {

                                       var opt = {title: markers[i].title};
                                       if (!markers[i].href) {
                                               opt.clickable = false;
                                       }
                                       if (markers[i].icon) {
                                               opt.icon = new GIcon(G_DEFAULT_ICON, markers[i].icon);
                                               if (markers[i].shadow) {
                                                       opt.icon.shadow = markers[i].shadow;
                                               }
                                       }
                                       var mark = new GMarker(GLatLng.fromUrlValue(markers[i].location), opt);
                                       if (markers[i].href) {
                                               mark.href = markers[i].href;
                                               GEvent.addListener(mark, "click", function(){window.location=this.href;});
                                       }
                                       <a href="../manmark/map.addOverlay.mark.html">map.addOverlay</a>(mark);
                               }
                       }
                 },  /* End of Part I */

                 /* Part II: Function called in the event of failure */
                 failure: function(o) {alert(o.statusText);},

                 /* Part III: Data that is passed to the success function.
                    We are using this to map from numerical maptypes that Geo::Google::MapObject has passed us to the
                    forms used in Google maps API.
                  */
                 argument: [G_NORMAL_MAP, G_SATELLITE_MAP, G_PHYSICAL_MAP, G_HYBRID_MAP]

             }; /* End of constructing the AJAX callback object. */

             /* This calls the server which should hopefully kick off callback.success with lots of lovely data. */
             var transaction = YAHOO.util.Connect.asyncRequest('GET', get_init_data, callback, null);

         } /* end of mapInitialize function */

         /* This will make sure that we call the above function at a good time. */
         <a href="../manmapInitialize/YAHOO.util.Event.onDOMReady.mapInitialize.html">YAHOO.util.Event.onDOMReady</a>(mapInitialize);

         /* We still have to do the memory cleanup ourselves. */
         YAHOO.util.Event.addListener(window, 'unload', 'GUnload');

   <b>Taking</b> <b>it</b> <b>further</b>
       There  are  lots of variations that can be done with this. The Geo::Google::MapObject object will pass on
       all fields it does not recognize via the "json" function and these can  be  used  by  the  javascript  in
       whatever way required. Similarly fields added to the marker specification will be passed by the "markers"
       function and can be used in the template in whatever way required.

       You  can also make the markers draggable and have the act of dragging a marker update data on the server.
       There is an example of where this has been done at &lt;<a href="http://testmaps.periapt.co.uk">http://testmaps.periapt.co.uk</a>&gt;.  The details  of  how
       this  is  done  depend  intrinsically  on  the implementation of the data storage on the server.  I would
       suggest that in general the steps required to make the markers draggable might be as follows:

       Clean interface to the data storage.
           I think this is a clear case where an ORM  (&lt;<a href="http://en.wikipedia.org/wiki/Object-relational_mapping">http://en.wikipedia.org/wiki/Object-relational_mapping</a>&gt;)
           offers some advantages.  You could look at DBIx::Class or write your own interface using DBI.

       Derive a class from Geo::Google::MapObject.
           Your  derived  class  constructor should get the data you need from the data storage interface layer,
           use it to create a Geo::Google::MapObject and bless that into your derived class.

       Provide URLs that update the data underlying your map objects.
           These will probably be POST methods and need not return anything other than  an  "OK"  string.   They
           should probably call the data storage interface layer directly to update the data.  There is no point
           creating a map object merely to update the underlying data.

       Add link elements to your markup indicating which URL is needed to update the marker data.
             &lt;link href="/move_marker" id="move_marker"/&gt;

           An  advantage  of using these link elements is that you might have multiple maps to manage.  By using
           the link elements to communicate with the client side, a lot more code and templates can be reused.

       Get the javascript side to read your new link elements.
             var move_marker = YAHOO.util.Dom.get('move_marker').href;

       Add a "draggable" flag to the GMarker constructor
             var opt = {title: markers[i].title, draggable: true};

       Make sure your GMarkers are labelled in a way that your server can understand
           Just after the GMarker object, mark, has been created add

             mark.label = markers[i].label;

       Make your GMarker object subscribe to the "dragend" event.
             GEvent.addListener(mark,
                                "dragend",
                                function(latlng) {
                                        var location = <a href="../man12/latlng.toUrlValue.12.html">latlng.toUrlValue</a>(12);
                                        var postdata = "id="+this.label+"&amp;location="+location;
                                        YAHOO.util.Connect.asyncRequest('POST',
                                                                        move_marker,
                                                                        {
                                                                           success: function(o){},
                                                                           failure: function(o) {alert(o.statusText);},
                                                                           argument: []
                                                                        },
                                                                        postdata);
                                });

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       "markers should be an ARRAY"
           The markers parameter of the constructor must be an ARRAY ref of marker configuration data.

       "no API key"
           To use this module you must sign up for an API key (<a href="http://code.google.com/apis/maps/signup.html">http://code.google.com/apis/maps/signup.html</a>) and
           supply it as the key parameter.

       "zoom not a number: %s"
           There must be a zoom parameter which is a number from 0 to 21.

       "maptype %s  not recognized"
           The maptype must be one of roadmap, satellite, terrain, hybrid.

       "no width"
       "no height"
       "width should be positive and no more than 640"
       "height should be positive and no more than 640"
       "cannot recognize size"
           The  size  parameter  must  either  be   a   string   like   "300x500"   or   a   hash   array   like
           {width=&gt;300,height=&gt;500}.  And both width and height must be between 1 and 640 inclusive.

       "cannot calculate autozoom without markers"
           If you pass an "autozoom" parameter to the constructor you must also pass at least one marker.

       "% not recognized as autozoom"
           An autozoom parameter was passed to the constructor that was not recognized as such.

       "location missing"
           A marker specification was missing a location during autozoom calculation.

       "no location for %s"
           Every marker object must have a location.

</pre><h4><b>CONFIGURATION</b> <b>AND</b> <b>ENVIRONMENT</b></h4><pre>
       Geo::Google::MapObject requires no configuration files or environment variables.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       Templating framework
           We  assume  the  use  of  HTML::Template::Pluggable  and HTML::Template::Plugin though other template
           frameworks may work.

       Google Maps API
           You     need     to     have     one     of     these     which     can     be     obtained      from
           &lt;<a href="http://code.google.com/apis/maps/signup.html">http://code.google.com/apis/maps/signup.html</a>&gt;.

       Javascript and AJAX
           We  assume  a  degree  of  familiarity  with  javascript,  AJAX and client side programming.  For the
           purposes of documentation we  assume  YUI:  &lt;<a href="http://developer.yahoo.com/yui/">http://developer.yahoo.com/yui/</a>&gt;,  but  this  choice  of
           framework is not mandated.

       Math::Trig
           The  autozoom  algorithm  optionally  used  by  this  module  depends  upon  the  Math::Trig  for its
           mathematical calculations. Since alternative algorithms or no algorithm at all can be used,  I  think
           it might be better to have this as a separate module.

</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
       None reported.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       paths etc
           Currently there is no support for paths, polygons or viewports.

       version 3
           We are currently only supporting version 2 of the API.

       testing
           We  encode  the  title  attributes  of  markers in the "json" function as this seems to be necessary.
           However I have not yet managed to get a decent test script for this behaviour.  There are many  other
           cases that should be tested though I think the most critical cases have been tested.

       character encoding
           This  module is only tested against UTF-8 web pages. I have no intention of changing this as I cannot
           think of why anyone would consciously choose to encode web pages in any  other  way.  I  am  open  to
           persuasion however.

       Please  report any bugs or feature requests to "<a href="mailto:bug-geo-google-mapobject@rt.cpan.org">bug-geo-google-mapobject@rt.cpan.org</a>", or through the web
       interface at &lt;<a href="http://rt.cpan.org">http://rt.cpan.org</a>&gt;.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to Andreas Koenig for pointing out that this module had an issue with "Build.PL".

</pre><h4><b>AUTHOR</b></h4><pre>
       Nicholas Bamber  "&lt;<a href="mailto:nicholas@periapt.co.uk">nicholas@periapt.co.uk</a>&gt;"

</pre><h4><b>LICENCE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009, Nicholas Bamber "&lt;<a href="mailto:nicholas@periapt.co.uk">nicholas@periapt.co.uk</a>&gt;". All rights reserved.

       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself. See perlartistic.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       BECAUSE  THIS  SOFTWARE  IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE, TO THE EXTENT
       PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS  AND/OR  OTHER
       PARTIES  PROVIDE  THE  SOFTWARE  "AS  IS"  WITHOUT  WARRANTY  OF  ANY  KIND, EITHER EXPRESSED OR IMPLIED,
       INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS  FOR  A  PARTICULAR
       PURPOSE.  THE  ENTIRE  RISK  AS  TO  THE  QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE
       SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

       IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER,  OR  ANY
       OTHER  PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
       TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING  OUT  OF
       THE  USE  OR  INABILITY  TO  USE  THE  SOFTWARE  (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
       RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE  TO  OPERATE
       WITH  ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
       DAMAGES.

perl v5.36.0                                       2022-12-12                        <u>Geo::Google::<a href="../man3pm/MapObject.3pm.html">MapObject</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>