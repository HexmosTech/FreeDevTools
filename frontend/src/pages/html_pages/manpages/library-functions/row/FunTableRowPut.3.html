<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FunTableRowPut - put Funtools rows</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfuntools-dev">libfuntools-dev_1.4.8-1.1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FunTableRowPut - put Funtools rows

</pre><h4><b>SYNOPSIS</b></h4><pre>
       int FunTableRowPut(Fun fun, void *rows, int nev, int idx, char *plist)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u><b>FunTableRowPut()</b></u>  routine writes rows to a FITS binary table, taking its input from an array of user
       structs that contain column values selected by a previous call  to  <u>FunColumnSelect()</u>.   Selected  column
       values are automatically converted from native data format to FITS data format as necessary.

       The  first  argument  is  the  Fun handle associated with this row data.  The second <b>rows</b> argument is the
       array of user structs to output. The third <b>nrow</b> argument specifies the number number of  rows  to  write.
       The routine will write <b>nrow</b> records, starting from the location specified by <b>rows</b>.

       The fourth <b>idx</b> argument is the index of the first raw input row to write, in the case where rows from the
       user  buffer are being merged with their raw input row counterparts (see below). Note that this <b>idx</b> value
       is has nothing to do with the row buffer specified in argument  1.   It  merely  matches  the  row  being
       written  with  its corresponding (hidden) raw row.  Thus, if you read a number of rows, process them, and
       then write them out all at once starting from the first user row, the value of <b>idx</b> should be 0:

         Ev ebuf, ev;
         /* get rows -- let routine allocate the row array */
         while( (ebuf = (Ev)FunTableRowGet(fun, NULL, MAXROW, NULL, &amp;got)) ){
           /* process all rows */
           for(i=0; i&lt;got; i++){
             /* point to the i'th row */
             ev = ebuf+i;
             ...
           }
           /* write out this batch of rows, starting with the first */
           FunTableRowPut(fun2, (char *)ebuf, got, 0, NULL);
           /* free row data */
           if( ebuf ) free(ebuf);
         }

       On the other hand, if you write out the rows one at a time (possibly skipping rows), then,  when  writing
       the i'th row from the input array of rows, set <b>idx</b> to the value of i:

         Ev ebuf, ev;
         /* get rows -- let routine allocate the row array */
         while( (ebuf = (Ev)FunTableRowGet(fun, NULL, MAXROW, NULL, &amp;got)) ){
           /* process all rows */
           for(i=0; i&lt;got; i++){
             /* point to the i'th row */
             ev = ebuf+i;
             ...
             /* write out the current (i.e., i'th) row */
             FunTableRowPut(fun2, (char *)ev, 1, i, NULL);
           }
           /* free row data */
           if( ebuf ) free(ebuf);
         }

       The  final argument is a param list string that is not currently used.  The routine returns the number of
       rows output.  This should be equal to the value passed in the third nrow&lt;/B argument.

       When <u>FunTableRowPut()</u> is first called for a given binary table, Funtools checks to  see  of  the  primary
       header  has already been written (either by writing a previous row table or by writing an image.) If not,
       a dummy primary header is written to the file specifying that an extension  should  be  expected.   After
       this,  a  binary table header is automatically written containing information about the columns that will
       populate this table.  In addition, if a Funtools reference handle  was  specified  when  this  table  was
       opened, the parameters from this Funtools reference handle are merged into the new binary table header.

       In  a  typical  Funtools  row  loop,  you  read  rows  using  <u>FunTableRowGet()</u>()  and  write  rows  using
       <u>FunTableRowPut()</u>. The columns written by <u>FunTableRowPut()</u>() are those defined as writable by  a  previous
       call to <u>FunColumnSelect()</u>.  If that call to FunColumnSelect also specified <b>merge=[update⎪replace⎪append]</b>,
       then  the  entire  corresponding raw input row record will be merged with the output row according to the
       <b>merge</b> specification (see <u>FunColumnSelect()</u> above).

       A call to write rows can either be done once, after all rows in the input batch have been  processed,  or
       it  can  be  done (slightly less efficiently) one row at a time (or anything in between). We do recommend
       that you write all rows associated with a given batch of input rows before reading  new  rows.   This  is
       <b>required</b>  if  you  are  merging the output rows with the raw input rows (since the raw rows are destroyed
       with each successive call to get new rows).

       For example:

         Ev buf, ev;
         ...
         /* get rows -- let routine allocate the row array */
         while( (buf = (Ev)FunTableRowGet(fun, NULL, MAXROW, NULL, &amp;got)) ){
           /* point to the i'th row */
           ev = buf + i;
           .... process
         }
         /* write out this batch of rows */
         FunTableRowPut(fun2, buf, got, 0, NULL);
         /* free row data */
         if( buf ) free(buf);
         }

       or

         Ev buf, ev;
         ...
         /* get rows -- let routine allocate the row array */
         while( (buf = (Ev)FunTableRowGet(fun, NULL, MAXROW, NULL, &amp;got)) ){
           /* process all rows */
           for(i=0; i&lt;got; i++){
             /* point to the i'th row */
             ev = buf + i;
             ... process
             /* write out this batch of rows with the new column */
             if( dowrite )
               FunTableRowPut(fun2, buf, 1, i, NULL);
           }
           /* free row data */
           if( buf ) free(buf);
         }

       Note that the difference between these calls is that the first one outputs  <b>got</b>  rows  all  at  once  and
       therefore  passes  <b>idx=0</b>  in  argument  four,  so that merging starts at the first raw input row.  In the
       second case, a check it made on each row to see if it needs to be output.  If so, the  value  of  <b>idx</b>  is
       passed  as  the  value  of the <b>i</b> variable which points to the current row being processed in the batch of
       input rows.

       As shown above, successive calls to <u>FunTableRowPut()</u> will write rows sequentially. When you are  finished
       writing  all  rows  in  a  table,  you should call <u>FunFlush()</u> to write out the FITS binary table padding.
       However, this is not necessary if you subsequently call <u>FunClose()</u> without doing any  other  I/O  to  the
       FITS file.

       Note that <u>FunTableRowPut()</u> also can be called as <u>FunEventsPut()</u>, for backward compatibility.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See <a href="../man7/funtools.7.html">funtools</a>(7) for a list of Funtools help pages

version 1.4.5                                    April 14, 2011                                <u><a href="../man3/funtablerowput.3.html">funtablerowput</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>