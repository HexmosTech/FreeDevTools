<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::Class::Row - Basic row methods</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-class-perl">libdbix-class-perl_0.082844-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::Class::Row - Basic row methods

</pre><h4><b>SYNOPSIS</b></h4><pre>
</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class is responsible for defining and doing basic operations on rows derived from
       DBIx::Class::ResultSource objects.

       Result objects are returned from DBIx::Class::ResultSets using the create, find, next and all methods, as
       well as invocations of 'single' ( belongs_to, has_one or might_have) relationship accessors of Result
       objects.

</pre><h4><b>NOTE</b></h4><pre>
       All "Row objects" derived from a Schema-attached DBIx::Class::ResultSet object (such as a typical
       "search-&gt; next" call) are actually Result instances, based on your application's Result Class.

       DBIx::Class::Row implements most of the row-based communication with the underlying storage, but a Result
       class <b>should</b> <b>not</b> <b>inherit</b> <b>from</b> <b>it</b> <b>directly</b>.  Usually, Result classes inherit from DBIx::Class::Core, which
       in turn combines the methods from several classes, one of them being DBIx::Class::Row.  Therefore, while
       many of the methods available to a DBIx::Class::Core-derived Result class are described in the following
       documentation, it does not detail all of the methods available to Result objects.  Refer to
       DBIx::Class::Manual::ResultClass for more info.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
         my $result = My::Class-&gt;new(\%attrs);

         my $result = $schema-&gt;resultset('MySource')-&gt;new(\%colsandvalues);

       Arguments: \%attrs or \%colsandvalues
       Return Value: $result

       While  you  can  create  a  new result object by calling "new" directly on this class, you are better off
       calling it on a DBIx::Class::ResultSet object.

       When calling it directly, you will not get a complete, usable row  object  until  you  pass  or  set  the
       "result_source"   attribute,   to   a   DBIx::Class::ResultSource   instance   that   is  attached  to  a
       DBIx::Class::Schema with a valid connection.

       $attrs is a hashref of column name, value data. It can also contain some other  attributes  such  as  the
       "result_source".

       Passing   an   object,   or   an  arrayref  of  objects  as  a  value  will  call  "set_from_related"  in
       DBIx::Class::Relationship::Base for you. When passed a hashref or an arrayref of hashrefs as  the  value,
       these will be turned into objects via new_related, and treated as if you had passed objects.

       For a more involved explanation, see "create" in DBIx::Class::ResultSet.

       Please  note  that if a value is not passed to new, no value will be sent in the SQL INSERT call, and the
       column will therefore assume whatever default value was specified  in  your  database.  While  DBIC  will
       retrieve  the  value  of  autoincrement columns, it will never make an explicit database trip to retrieve
       default values assigned by the RDBMS. You can explicitly request that all values be fetched back from the
       database by calling "discard_changes", or you can supply an explicit "undef" to columns with NULL as  the
       default, and save yourself a SELECT.

        CAVEAT:

        The behavior described above will backfire if you use a foreign key column
        with a database-defined default. If you call the relationship accessor on
        an object that doesn't have a set value for the FK column, DBIC will throw
        an exception, as it has no way of knowing the PK of the related object (if
        there is one).

   <b>$column_accessor</b>
         # Each pair does the same thing

         # (un-inflated, regular column)
         my $val = $result-&gt;get_column('first_name');
         my $val = $result-&gt;first_name;

         $result-&gt;set_column('first_name' =&gt; $val);
         $result-&gt;first_name($val);

         # (inflated column via DBIx::Class::InflateColumn::DateTime)
         my $val = $result-&gt;get_inflated_column('last_modified');
         my $val = $result-&gt;last_modified;

         $result-&gt;set_inflated_column('last_modified' =&gt; $val);
         $result-&gt;last_modified($val);

       Arguments: $value?
       Return Value: $value

       A column accessor method is created for each column, which is used for getting/setting the value for that
       column.

       The  actual  method  name is based on the accessor name given during the Result Class column definition .
       Like "set_column", this will not store the data in the database until "insert" or "update" is  called  on
       the row.

   <b>insert</b>
         $result-&gt;insert;

       Arguments: none
       Return Value: $result

       Inserts an object previously created by "new" into the database if it isn't already in there. Returns the
       object itself. To insert an entirely new row into the database, use "create" in DBIx::Class::ResultSet.

       To fetch an uninserted result object, call new_result on a resultset.

       This  will  also  insert  any  uninserted,  related  objects  held  inside  this  one,  see  "create"  in
       DBIx::Class::ResultSet for more details.

   <b>in_storage</b>
         $result-&gt;in_storage; # Get value
         $result-&gt;<a href="../man1/in_storage.1.html">in_storage</a>(1); # Set value

       Arguments: none or 1|0
       Return Value: 1|0

       Indicates whether the object exists as a row in the database or not. This is set to true when  "find"  in
       DBIx::Class::ResultSet, "create" in DBIx::Class::ResultSet or "insert" in DBIx::Class::Row are invoked.

       Creating  a  result object using "new_result" in DBIx::Class::ResultSet, or calling "delete" on one, sets
       it to false.

   <b>update</b>
         $result-&gt;update(\%columns?)

       Arguments: none or a hashref
       Return Value: $result

       Throws an exception if the result object is not yet in the database, according to  "in_storage".  Returns
       the object itself.

       This  method  issues  an SQL UPDATE query to commit any changes to the object to the database if required
       (see "get_dirty_columns").  It throws an exception if a proper  WHERE  clause  uniquely  identifying  the
       database row can not be constructed (see significance of primary keys for more details).

       Also  takes  an  optional hashref of "column_name =&gt; value" pairs to update on the object first. Be aware
       that the hashref will be passed to "set_inflated_columns", which might edit it in place, so don't rely on
       it being the same after a call to "update".  If you need to preserve the hashref,  it  is  sufficient  to
       pass a shallow copy to "update", e.g. ( { %{ $href } } )

       If the values passed or any of the column values set on the object contain scalar references, e.g.:

         $result-&gt;last_modified(\'NOW()')-&gt;update();
         # OR
         $result-&gt;update({ last_modified =&gt; \'NOW()' });

       The update will pass the values verbatim into SQL. (See SQL::Abstract::Classic docs).  The values in your
       Result  object  will NOT change as a result of the update call, if you want the object to be updated with
       the actual values from the database, call "discard_changes" after the update.

         $result-&gt;update()-&gt;discard_changes();

       To determine before calling this method, which column values have  changed  and  will  be  updated,  call
       "get_dirty_columns".

       To check if any columns will be updated, call "is_changed".

       To force a column to be updated, call "make_column_dirty" before this method.

   <b>delete</b>
         $result-&gt;delete

       Arguments: none
       Return Value: $result

       Throws  an  exception  if  the  object  is  not in the database according to "in_storage". Also throws an
       exception if a proper WHERE clause uniquely identifying the database row  can  not  be  constructed  (see
       significance of primary keys for more details).

       The  object  is  still  perfectly  usable,  but  "in_storage"  will  now  return 0 and the object must be
       reinserted using "insert" before it can be used to "update" the row again.

       If you delete an object in a class with a "has_many" relationship, an attempt is made to delete  all  the
       related  objects  as well. To turn this behaviour off, pass "cascade_delete =&gt; 0" in the $attr hashref of
       the relationship, see  DBIx::Class::Relationship.  Any  database-level  cascade  or  restrict  will  take
       precedence over a DBIx-Class-based cascading delete, since DBIx-Class <b>deletes</b> <b>the</b> <b>main</b> <b>row</b> <b>first</b> and only
       then attempts to delete any remaining related rows.

       If  you  delete  an  object  within a <b>txn_do()</b> (see "txn_do" in DBIx::Class::Storage) and the transaction
       subsequently fails, the result object will remain marked as not being in storage. If you know for a  fact
       that  the object is still in storage (i.e. by inspecting the cause of the transaction's failure), you can
       use "$obj-&gt;<a href="../man1/in_storage.1.html">in_storage</a>(1)" to restore consistency between the object and the database. This would allow  a
       subsequent "$obj-&gt;delete" to work as expected.

       See also "delete" in DBIx::Class::ResultSet.

   <b>get_column</b>
         my $val = $result-&gt;get_column($col);

       Arguments: $columnname
       Return Value: The value of the column

       Throws an exception if the column name given doesn't exist according to has_column.

       Returns  a  raw  column value from the result object, if it has already been fetched from the database or
       set by an accessor.

       If an inflated value has been set, it will be deflated and returned.

       Note that if you used the "columns" or the "select/as" search attributes  on  the  resultset  from  which
       $result was derived, and <b>did</b> <b>not</b> <b>include</b> $columnname in the list, this method will return "undef" even if
       the database contains some value.

       To retrieve all loaded column values as a hash, use "get_columns".

   <b>has_column_loaded</b>
         if ( $result-&gt;has_column_loaded($col) ) {
            print "$col has been loaded from db";
         }

       Arguments: $columnname
       Return Value: 0|1

       Returns a true value if the column value has been loaded from the database (or set locally).

   <b>get_columns</b>
         my %data = $result-&gt;get_columns;

       Arguments: none
       Return Value: A hash of columnname, value pairs.

       Returns  all  loaded column data as a hash, containing raw values. To get just one value for a particular
       column, use "get_column".

       See "get_inflated_columns" to get the inflated values.

   <b>get_dirty_columns</b>
         my %data = $result-&gt;get_dirty_columns;

       Arguments: none
       Return Value: A hash of column, value pairs

       Only returns the column, value pairs for those columns that have been changed on this  object  since  the
       last "update" or "insert" call.

       See "get_columns" to fetch all column/value pairs.

   <b>make_column_dirty</b>
         $result-&gt;make_column_dirty($col)

       Arguments: $columnname
       Return Value: not defined

       Throws an exception if the column does not exist.

       Marks a column as having been changed regardless of whether it has really changed.

   <b>get_inflated_columns</b>
         my %inflated_data = $obj-&gt;get_inflated_columns;

       Arguments: none
       Return Value: A hash of column, object|value pairs

       Returns a hash of all column keys and associated values. Values for any columns set to use inflation will
       be inflated and returns as objects.

       See "get_columns" to get the uninflated values.

       See DBIx::Class::InflateColumn for how to setup inflation.

   <b>set_column</b>
         $result-&gt;set_column($col =&gt; $val);

       Arguments: $columnname, $value
       Return Value: $value

       Sets  a  raw  column value. If the new value is different from the old one, the column is marked as dirty
       for when you next call "update".

       If passed an object or reference as a value, this method will happily attempt to store it,  and  a  later
       "insert"  or  "update"  will  try  and  stringify/numify  as appropriate. To set an object to be deflated
       instead, see "set_inflated_columns", or better yet, use "$column_accessor".

   <b>set_columns</b>
         $result-&gt;set_columns({ $col =&gt; $val, ... });

       Arguments: \%columndata
       Return Value: $result

       Sets multiple column, raw value pairs at once.

       Works as "set_column".

   <b>set_inflated_columns</b>
         $result-&gt;set_inflated_columns({ $col =&gt; $val, $rel_name =&gt; $obj, ... });

       Arguments: \%columndata
       Return Value: $result

       Sets more than one column value at once. Any inflated values are deflated and the raw values stored.

       Any related values passed as Result objects, using the relation  name  as  a  key,  are  reduced  to  the
       appropriate  foreign  key  values  and stored. If instead of related result objects, a hashref of column,
       value data is passed, will create the related object first then store.

       Will even accept arrayrefs of data as a value to  a  "has_many"  in  DBIx::Class::Relationship  key,  and
       create the related objects if necessary.

       Be aware that the input hashref might be edited in place, so don't rely on it being the same after a call
       to  "set_inflated_columns".  If you need to preserve the hashref, it is sufficient to pass a shallow copy
       to "set_inflated_columns", e.g. ( { %{ $href } } )

       See also "set_from_related" in DBIx::Class::Relationship::Base.

   <b>copy</b>
         my $copy = $orig-&gt;copy({ change =&gt; $to, ... });

       Arguments: \%replacementdata
       Return Value: $result copy

       Inserts a new row into the database, as a copy of the original object. If a hashref of  replacement  data
       is supplied, these will take precedence over data in the original. Also any columns which have the column
       info  attribute "is_auto_increment =&gt; 1" are explicitly removed before the copy, so that the database can
       insert its own autoincremented values into the new object.

       Relationships will be followed by the copy procedure <b>only</b> if the relationship specifies a true value  for
       its cascade_copy attribute. "cascade_copy" is set by default on "has_many" relationships and unset on all
       others.

   <b>store_column</b>
         $result-&gt;store_column($col =&gt; $val);

       Arguments: $columnname, $value
       Return Value: The value sent to storage

       Set  a  raw  value  for  a  column  without  marking  it  as  changed.  This method is used internally by
       "set_column" which you should probably be using.

       This is the lowest level at which data is set on a result object, extend this method to  catch  all  data
       setting methods.

   <b>inflate_result</b>
         Class-&gt;inflate_result($result_source, \%me, \%prefetch?)

       Arguments: $result_source, \%columndata, \%prefetcheddata
       Return Value: $result

       All  DBIx::Class::ResultSet  methods that retrieve data from the database and turn it into result objects
       call this method.

       Extend this method in your Result classes to hook into this process, for example to  rebless  the  result
       into a different class.

       Reblessing  can  also  be  done  more  easily  by  setting  "result_class"  in  your  Result  class.  See
       "result_class" in DBIx::Class::ResultSource.

       Different  types  of  results  can  also  be  created  from  a  particular  DBIx::Class::ResultSet,   see
       "result_class" in DBIx::Class::ResultSet.

   <b>update_or_insert</b>
         $result-&gt;update_or_insert

       Arguments: none
       Return Value: Result of update or insert operation

       "update"s the object if it's already in the database, according to "in_storage", else "insert"s it.

   <b>insert_or_update</b>
         $obj-&gt;insert_or_update

       Alias for "update_or_insert"

   <b>is_changed</b>
         my @changed_col_names = $result-&gt;is_changed();
         if ($result-&gt;is_changed()) { ... }

       Arguments: none
       Return Value: 0|1 or @columnnames

       In  list  context  returns a list of columns with uncommited changes, or in scalar context returns a true
       value if there are uncommitted changes.

   <b>is_column_changed</b>
         if ($result-&gt;is_column_changed('col')) { ... }

       Arguments: $columname
       Return Value: 0|1

       Returns a true value if the column has uncommitted changes.

   <b>result_source</b>
         my $resultsource = $result-&gt;result_source;

       Arguments: $result_source?
       Return Value: $result_source

       Accessor to the DBIx::Class::ResultSource this object was created from.

   <b>register_column</b>
         $column_info = { .... };
         $class-&gt;register_column($column_name, $column_info);

       Arguments: $columnname, \%columninfo
       Return Value: not defined

       Registers a column on the class. If the column_info has an 'accessor'  key,  creates  an  accessor  named
       after the value if defined; if there is no such key, creates an accessor with the same name as the column

       The column_info attributes are described in "add_columns" in DBIx::Class::ResultSource

   <b>get_from_storage</b>
         my $copy = $result-&gt;get_from_storage($attrs)

       Arguments: \%attrs
       Return Value: A Result object

       Fetches  a  fresh  copy  of the Result object from the database and returns it.  Throws an exception if a
       proper WHERE clause identifying the database row can not be constructed (i.e. if the original object does
       not contain its entire
        primary key ). If passed the \%attrs argument, will first apply these attributes to the  resultset  used
       to find the row.

       This copy can then be used to compare to an existing result object, to determine if any changes have been
       made in the database since it was created.

       To  just  update  your  Result  object  with  any latest changes from the database, use "discard_changes"
       instead.

       The \%attrs argument should be compatible with "ATTRIBUTES" in DBIx::Class::ResultSet.

   <b>discard_changes</b>
         $result-&gt;discard_changes

       Arguments: none or $attrs
       Return Value: self (updates object in-place)

       Re-selects the row from the database, losing any changes that had been made. Throws  an  exception  if  a
       proper  "WHERE"  clause  identifying the database row can not be constructed (i.e. if the original object
       does not contain its entire primary key).

       This method can also be used to refresh from storage, retrieving any changes made since the row was  last
       read from storage.

       $attrs,  if  supplied,  is  expected  to  be  a  hashref of attributes suitable for passing as the second
       argument to "$resultset-&gt;search($cond, $attrs)";

       Note: If you are using DBIx::Class::Storage::DBI::Replicated as your storage, a default of "{  force_pool
       =&gt; 'master' }"
         is automatically set for you. Prior to "DBIx::Class 0.08109" (before 2010) one would have been required
       to  explicitly  wrap  the entire operation in a transaction to guarantee that up-to-date results are read
       from the master database.

   <b>throw_exception</b>
       See "throw_exception" in DBIx::Class::Schema.

   <b>id</b>
         my @pk = $result-&gt;id;

       Arguments: none
       Returns: A list of primary key values

       Returns the primary key(s) for a row. Can't be  called  as  a  class  method.   Actually  implemented  in
       DBIx::Class::PK

</pre><h4><b>FURTHER</b> <b>QUESTIONS?</b></h4><pre>
       Check the list of additional DBIC resources.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This  module is free software copyright by the DBIx::Class (DBIC) authors. You can redistribute it and/or
       modify it under the same terms as the DBIx::Class library.

perl v5.40.0                                       2025-02-01                              <u>DBIx::Class::<a href="../man3pm/Row.3pm.html">Row</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>