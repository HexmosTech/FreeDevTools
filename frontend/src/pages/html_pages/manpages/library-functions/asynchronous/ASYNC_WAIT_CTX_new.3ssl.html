<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASYNC_WAIT_CTX_new, ASYNC_WAIT_CTX_free, ASYNC_WAIT_CTX_set_wait_fd, ASYNC_WAIT_CTX_get_fd,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ASYNC_WAIT_CTX_new, ASYNC_WAIT_CTX_free, ASYNC_WAIT_CTX_set_wait_fd, ASYNC_WAIT_CTX_get_fd,
       ASYNC_WAIT_CTX_get_all_fds, ASYNC_WAIT_CTX_get_changed_fds, ASYNC_WAIT_CTX_clear_fd,
       ASYNC_WAIT_CTX_set_callback, ASYNC_WAIT_CTX_get_callback, ASYNC_WAIT_CTX_set_status,
       ASYNC_WAIT_CTX_get_status, ASYNC_callback_fn, ASYNC_STATUS_UNSUPPORTED, ASYNC_STATUS_ERR,
       ASYNC_STATUS_OK, ASYNC_STATUS_EAGAIN - functions to manage waiting for asynchronous jobs to complete

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/async.h&gt;

        #define ASYNC_STATUS_UNSUPPORTED    0
        #define ASYNC_STATUS_ERR            1
        #define ASYNC_STATUS_OK             2
        #define ASYNC_STATUS_EAGAIN         3
        typedef int (*ASYNC_callback_fn)(void *arg);
        ASYNC_WAIT_CTX *ASYNC_WAIT_CTX_new(void);
        void ASYNC_WAIT_CTX_free(ASYNC_WAIT_CTX *ctx);
        int ASYNC_WAIT_CTX_set_wait_fd(ASYNC_WAIT_CTX *ctx, const void *key,
                                       OSSL_ASYNC_FD fd,
                                       void *custom_data,
                                       void (*cleanup)(ASYNC_WAIT_CTX *, const void *,
                                                       OSSL_ASYNC_FD, void *));
        int ASYNC_WAIT_CTX_get_fd(ASYNC_WAIT_CTX *ctx, const void *key,
                                  OSSL_ASYNC_FD *fd, void **custom_data);
        int ASYNC_WAIT_CTX_get_all_fds(ASYNC_WAIT_CTX *ctx, OSSL_ASYNC_FD *fd,
                                       size_t *numfds);
        int ASYNC_WAIT_CTX_get_changed_fds(ASYNC_WAIT_CTX *ctx, OSSL_ASYNC_FD *addfd,
                                           size_t *numaddfds, OSSL_ASYNC_FD *delfd,
                                           size_t *numdelfds);
        int ASYNC_WAIT_CTX_clear_fd(ASYNC_WAIT_CTX *ctx, const void *key);
        int ASYNC_WAIT_CTX_set_callback(ASYNC_WAIT_CTX *ctx,
                                        ASYNC_callback_fn callback,
                                        void *callback_arg);
        int ASYNC_WAIT_CTX_get_callback(ASYNC_WAIT_CTX *ctx,
                                        ASYNC_callback_fn *callback,
                                        void **callback_arg);
        int ASYNC_WAIT_CTX_set_status(ASYNC_WAIT_CTX *ctx, int status);
        int ASYNC_WAIT_CTX_get_status(ASYNC_WAIT_CTX *ctx);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       For an overview of how asynchronous operations are implemented in OpenSSL see <b><a href="../man3/ASYNC_start_job.3.html">ASYNC_start_job</a></b>(3). An
       <b>ASYNC_WAIT_CTX</b> object represents an asynchronous "session", i.e. a related set of crypto operations. For
       example in SSL terms this would have a one-to-one correspondence with an SSL connection.

       Application code must create an <b>ASYNC_WAIT_CTX</b> using the <b>ASYNC_WAIT_CTX_new()</b> function prior to calling
       <b>ASYNC_start_job()</b> (see <b><a href="../man3/ASYNC_start_job.3.html">ASYNC_start_job</a></b>(3)). When the job is started it is associated with the
       <b>ASYNC_WAIT_CTX</b> for the duration of that job. An <b>ASYNC_WAIT_CTX</b> should only be used for one <b>ASYNC_JOB</b> at
       any one time, but can be reused after an <b>ASYNC_JOB</b> has finished for a subsequent <b>ASYNC_JOB</b>. When the
       session is complete (e.g. the SSL connection is closed), application code cleans up with
       <b>ASYNC_WAIT_CTX_free()</b>.

       <b>ASYNC_WAIT_CTX</b>s can have "wait" file descriptors associated with them.  Calling
       <b>ASYNC_WAIT_CTX_get_all_fds()</b> and passing in a pointer to an <b>ASYNC_WAIT_CTX</b> in the <u>ctx</u> parameter will
       return the wait file descriptors associated with that job in <u>*fd</u>. The number of file descriptors returned
       will be stored in <u>*numfds</u>. It is the caller's responsibility to ensure that sufficient memory has been
       allocated in <u>*fd</u> to receive all the file descriptors. Calling <b>ASYNC_WAIT_CTX_get_all_fds()</b> with a NULL <u>fd</u>
       value will return no file descriptors but will still populate <u>*numfds</u>. Therefore, application code is
       typically expected to call this function twice: once to get the number of fds, and then again when
       sufficient memory has been allocated. If only one asynchronous engine is being used then normally this
       call will only ever return one fd. If multiple asynchronous engines are being used then more could be
       returned.

       The function <b>ASYNC_WAIT_CTX_get_changed_fds()</b> can be used to detect if any fds have changed since the
       last call time <b>ASYNC_start_job()</b> returned <b>ASYNC_PAUSE</b> (or since the <b>ASYNC_WAIT_CTX</b> was created if no
       <b>ASYNC_PAUSE</b> result has been received). The <u>numaddfds</u> and <u>numdelfds</u> parameters will be populated with the
       number of fds added or deleted respectively. <u>*addfd</u> and <u>*delfd</u> will be populated with the list of added
       and deleted fds respectively. Similarly to <b>ASYNC_WAIT_CTX_get_all_fds()</b> either of these can be NULL, but
       if they are not NULL then the caller is responsible for ensuring sufficient memory is allocated.

       Implementers of async aware code (e.g. engines) are encouraged to return a stable fd for the lifetime of
       the <b>ASYNC_WAIT_CTX</b> in order to reduce the "churn" of regularly changing fds - although no guarantees of
       this are provided to applications.

       Applications can wait for the file descriptor to be ready for "read" using a system function call such as
       select or poll (being ready for "read" indicates that the job should be resumed). If no file descriptor
       is made available then an application will have to periodically "poll" the job by attempting to restart
       it to see if it is ready to continue.

       Async aware code (e.g. engines) can get the current <b>ASYNC_WAIT_CTX</b> from the job via <b><a href="../man3/ASYNC_get_wait_ctx.3.html">ASYNC_get_wait_ctx</a></b>(3)
       and provide a file descriptor to use for waiting on by calling <b>ASYNC_WAIT_CTX_set_wait_fd()</b>. Typically
       this would be done by an engine immediately prior to calling <b>ASYNC_pause_job()</b> and not by end user code.
       An existing association with a file descriptor can be obtained using <b>ASYNC_WAIT_CTX_get_fd()</b> and cleared
       using <b>ASYNC_WAIT_CTX_clear_fd()</b>. Both of these functions requires a <u>key</u> value which is unique to the
       async aware code.  This could be any unique value but a good candidate might be the <b>ENGINE</b> <b>*</b> for the
       engine. The <u>custom_data</u> parameter can be any value, and will be returned in a subsequent call to
       <b>ASYNC_WAIT_CTX_get_fd()</b>. The <b>ASYNC_WAIT_CTX_set_wait_fd()</b> function also expects a pointer to a "cleanup"
       routine. This can be NULL but if provided will automatically get called when the <b>ASYNC_WAIT_CTX</b> is freed,
       and gives the engine the opportunity to close the fd or any other resources. Note: The "cleanup" routine
       does not get called if the fd is cleared directly via a call to <b>ASYNC_WAIT_CTX_clear_fd()</b>.

       An example of typical usage might be an async capable engine. User code would initiate cryptographic
       operations. The engine would initiate those operations asynchronously and then call
       <b>ASYNC_WAIT_CTX_set_wait_fd()</b> followed by <b>ASYNC_pause_job()</b> to return control to the user code. The user
       code can then perform other tasks or wait for the job to be ready by calling "select" or other similar
       function on the wait file descriptor. The engine can signal to the user code that the job should be
       resumed by making the wait file descriptor "readable". Once resumed the engine should clear the wake
       signal on the wait file descriptor.

       As well as a file descriptor, user code may also be notified via a callback. The callback and data
       pointers are stored within the <b>ASYNC_WAIT_CTX</b> along with an additional status field that can be used for
       the notification of retries from an engine. This additional method can be used when the user thinks that
       a file descriptor is too costly in terms of CPU cycles or in some context where a file descriptor is not
       appropriate.

       <b>ASYNC_WAIT_CTX_set_callback()</b> sets the callback and the callback argument. The callback will be called to
       notify user code when an engine completes a cryptography operation. It is a requirement that the callback
       function is small and nonblocking as it will be run in the context of a polling mechanism or an
       interrupt.

       <b>ASYNC_WAIT_CTX_get_callback()</b> returns the callback set in the <b>ASYNC_WAIT_CTX</b> structure.

       <b>ASYNC_WAIT_CTX_set_status()</b> allows an engine to set the current engine status.  The possible status
       values are the following:

       <b>ASYNC_STATUS_UNSUPPORTED</b>
           The  engine does not support the callback mechanism. This is the default value.  The engine must call
           <b>ASYNC_WAIT_CTX_set_status()</b> to set the status to some value other than <b>ASYNC_STATUS_UNSUPPORTED</b> if it
           intends to enable the callback mechanism.

       <b>ASYNC_STATUS_ERR</b>
           The engine has a fatal problem with this request. The user code should clean up this session.

       <b>ASYNC_STATUS_OK</b>
           The request has been successfully submitted.

       <b>ASYNC_STATUS_EAGAIN</b>
           The engine has some problem which will be recovered soon, such as a buffer  is  full,  so  user  code
           should resume the job.

       <b>ASYNC_WAIT_CTX_get_status()</b>  allows  user  code to obtain the current status value.  If the status is any
       value other than <b>ASYNC_STATUS_OK</b> then the user code should not expect to  receive  a  callback  from  the
       engine even if one has been set.

       An  example  of  the  usage  of  the  callback  method  might  be the following. User code would initiate
       cryptographic operations, and the engine code would dispatch this  operation  to  hardware,  and  if  the
       dispatch  is  successful, then the engine code would call <b>ASYNC_pause_job()</b> to return control to the user
       code. After that, user code can perform other tasks. When the hardware completes the operation,  normally
       it  is  detected  by  a  polling  function  or  an  interrupt, as the user code set a callback by calling
       <b>ASYNC_WAIT_CTX_set_callback()</b> previously, then the registered callback will be called.

       <b>ASYNC_WAIT_CTX_free()</b> frees up a single <b>ASYNC_WAIT_CTX</b> object.  If the argument is NULL, nothing is done.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>ASYNC_WAIT_CTX_new()</b> returns a pointer to the newly allocated <b>ASYNC_WAIT_CTX</b> or NULL on error.

       ASYNC_WAIT_CTX_set_wait_fd,              ASYNC_WAIT_CTX_get_fd,               ASYNC_WAIT_CTX_get_all_fds,
       ASYNC_WAIT_CTX_get_changed_fds,           ASYNC_WAIT_CTX_clear_fd,           ASYNC_WAIT_CTX_set_callback,
       ASYNC_WAIT_CTX_get_callback and ASYNC_WAIT_CTX_set_status  all  return  1  on  success  or  0  on  error.
       <b>ASYNC_WAIT_CTX_get_status()</b> returns the engine status.

</pre><h4><b>NOTES</b></h4><pre>
       On  Windows  platforms  the  <u>&lt;openssl/async.h&gt;</u>  header is dependent on some of the types customarily made
       available by including <u>&lt;windows.h&gt;</u>. The application developer is likely to require control over when  the
       latter  is  included,  commonly  as  one  of  the  first included headers. Therefore, it is defined as an
       application developer's responsibility to include <u>&lt;windows.h&gt;</u> prior to <u>&lt;openssl/async.h&gt;</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/crypto.7.html">crypto</a></b>(7), <b><a href="../man3/ASYNC_start_job.3.html">ASYNC_start_job</a></b>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       <b>ASYNC_WAIT_CTX_new()</b>,   <b>ASYNC_WAIT_CTX_free()</b>,   <b>ASYNC_WAIT_CTX_set_wait_fd()</b>,   <b>ASYNC_WAIT_CTX_get_fd()</b>,
       <b>ASYNC_WAIT_CTX_get_all_fds()</b>,  <b>ASYNC_WAIT_CTX_get_changed_fds()</b>  and <b>ASYNC_WAIT_CTX_clear_fd()</b> were added
       in OpenSSL 1.1.0.

       <b>ASYNC_WAIT_CTX_set_callback()</b>,    <b>ASYNC_WAIT_CTX_get_callback()</b>,     <b>ASYNC_WAIT_CTX_set_status()</b>,     and
       <b>ASYNC_WAIT_CTX_get_status()</b> were added in OpenSSL 3.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2016-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed  under  the  Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain  a  copy  in  the  file  LICENSE  in  the  source  distribution  or  at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                           <u><a href="../man3SSL/ASYNC_WAIT_CTX_NEW.3SSL.html">ASYNC_WAIT_CTX_NEW</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>