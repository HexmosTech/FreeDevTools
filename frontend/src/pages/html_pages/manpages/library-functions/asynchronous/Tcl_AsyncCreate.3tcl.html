<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_AsyncCreate, Tcl_AsyncMark, Tcl_AsyncMarkFromSignal, Tcl_AsyncInvoke, Tcl_AsyncDelete, Tcl_AsyncReady</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_AsyncCreate, Tcl_AsyncMark, Tcl_AsyncMarkFromSignal, Tcl_AsyncInvoke, Tcl_AsyncDelete, Tcl_AsyncReady
       - handle asynchronous events

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       Tcl_AsyncHandler
       <b>Tcl_AsyncCreate</b>(<u>proc,</u> <u>clientData</u>)

       void
       <b>Tcl_AsyncMark</b>(<u>async</u>)

       int
       <b>Tcl_AsyncMarkFromSignal</b>(<u>async</u>, <u>sigNumber</u>)

       int
       <b>Tcl_AsyncInvoke</b>(<u>interp,</u> <u>code</u>)

       void
       <b>Tcl_AsyncDelete</b>(<u>async</u>)

       int
       <b>Tcl_AsyncReady</b>()

</pre><h4><b>ARGUMENTS</b></h4><pre>
       Tcl_AsyncProc <u>*proc</u> (in)                  Procedure to invoke to handle an asynchronous event.

       void <u>*clientData</u> (in)                     One-word value to pass to <u>proc</u>.

       Tcl_AsyncHandler <u>async</u> (in)               Token for asynchronous event handler.

       int <u>sigNumber</u> (in)                        POSIX signal number, when used in a signal context.

       Tcl_Interp <u>*interp</u> (in)                   Tcl  interpreter  in  which  command  was  being evaluated when
                                                 handler was invoked, or NULL if handler was invoked when  there
                                                 was no interpreter active.

       int <u>code</u> (in)                             Completion  code from command that just completed in <u>interp</u>, or
                                                 0 if <u>interp</u> is NULL.
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These procedures provide a safe mechanism for dealing with asynchronous events such as  signals.   If  an
       event  such  as  a  signal  occurs  while a Tcl script is being evaluated then it is not safe to take any
       substantive action to process the event.  For example, it is not safe to evaluate a Tcl script since  the
       interpreter  may  already  be  in  the middle of evaluating a script; it may not even be safe to allocate
       memory, since a memory allocation could have been in progress when the event  occurred.   The  only  safe
       approach  is to set a flag indicating that the event occurred, then handle the event later when the world
       has returned to a clean state, such as after the current Tcl command completes.

       <b>Tcl_AsyncCreate</b>, <b>Tcl_AsyncDelete</b>, and <b>Tcl_AsyncReady</b> are thread sensitive.   They  access  and/or  set  a
       thread-specific  data structure in the event of a core built with <u>--enable-threads</u>.  The token created by
       <b>Tcl_AsyncCreate</b>  contains  the  needed  thread  information  it  was  called   from   so   that   calling
       <b>Tcl_AsyncMarkFromSignal</b>  or  <b>Tcl_AsyncMark</b>  with  this  token  will only yield the origin thread into the
       asynchronous handler.

       <b>Tcl_AsyncCreate</b> creates an asynchronous handler and returns a token for  it.   The  asynchronous  handler
       must be created before any occurrences of the asynchronous event that it is intended to handle (it is not
       safe  to  create  a  handler  at  the time of an event).  When an asynchronous event occurs the code that
       detects the event (such as a POSIX signal handler) should call <b>Tcl_AsyncMarkFromSignal</b> with the token for
       the handler and the POSIX signal number. The return value of this function is true, when the handler will
       be  marked,  false  otherwise.   For  non-signal  contexts,  <b>Tcl_AsyncMark</b>  serves  the   same   purpose.
       <b>Tcl_AsyncMarkFromSignal</b>  and <b>Tcl_AsyncMark</b> will mark the handler as ready to execute, but will not invoke
       the handler immediately. Tcl will call the <u>proc</u> associated with the handler later, when the world is in a
       safe state, and <u>proc</u> can then carry out the actions associated with the asynchronous event.  <u>Proc</u>  should
       have arguments and result that match the type <b>Tcl_AsyncProc</b>:

              typedef int <b>Tcl_AsyncProc</b>(
                      void *<u>clientData</u>,
                      Tcl_Interp *<u>interp</u>,
                      int <u>code</u>);

       The <u>clientData</u> will be the same as the <u>clientData</u> argument passed to <b>Tcl_AsyncCreate</b> when the handler was
       created.   If <u>proc</u> is invoked just after a command has completed execution in an interpreter, then <u>interp</u>
       will identify the interpreter in which the command was evaluated and <u>code</u> will  be  the  completion  code
       returned  by  that command.  The command's result will be present in the interpreter's result.  When <u>proc</u>
       returns, whatever it leaves in the interpreter's result will be returned as the result of the command and
       the integer value returned by <u>proc</u> will be used as the new completion code for the command.

       It is also possible for <u>proc</u> to be invoked when no interpreter is active.  This can happen, for  example,
       if an asynchronous event occurs while the application is waiting for interactive input or an X event.  In
       this case <u>interp</u> will be NULL and <u>code</u> will be 0, and the return value from <u>proc</u> will be ignored.

       The  procedure  <b>Tcl_AsyncInvoke</b>  is  called  to invoke all of the handlers that are ready.  The procedure
       <b>Tcl_AsyncReady</b> will return non-zero whenever any asynchronous handlers are ready;  it can be  checked  to
       avoid  calls  to  <b>Tcl_AsyncInvoke</b>  when there are no ready handlers.  Tcl calls <b>Tcl_AsyncReady</b> after each
       command is evaluated and calls <b>Tcl_AsyncInvoke</b> if needed.  Applications may also call <b>Tcl_AsyncInvoke</b>  at
       interesting times for that application.  For example, Tcl's event handler calls <b>Tcl_AsyncReady</b> after each
       event  and  calls  <b>Tcl_AsyncInvoke</b>  if needed.  The <u>interp</u> and <u>code</u> arguments to <b>Tcl_AsyncInvoke</b> have the
       same meaning as for <u>proc</u>:  they identify the active interpreter, if any, and the completion code from the
       command that just completed.

       <b>Tcl_AsyncDelete</b> removes an asynchronous handler so that its <u>proc</u> will never be invoked again.  A  handler
       can be deleted even when ready, and it will still not be invoked.

       If  multiple  handlers  become  active  at the same time, the handlers are invoked in the order they were
       created (oldest handler first).  The <u>code</u> and the interpreter's result for  later  handlers  reflect  the
       values  returned  by  earlier  handlers, so that the most recently created handler has last say about the
       interpreter's result and completion code.  If new handlers become ready  while  handlers  are  executing,
       <b>Tcl_AsyncInvoke</b>  will  invoke  them  all;   at  each point it invokes the highest-priority (oldest) ready
       handler, repeating this over and over until there are no longer any ready handlers.

</pre><h4><b>WARNING</b></h4><pre>
       It is almost always a bad idea for an asynchronous event handler to modify the  interpreter's  result  or
       return  a  code  different  from  its  <u>code</u> argument.  This sort of behavior can disrupt the execution of
       scripts in subtle ways and result in bugs that are extremely difficult to track down.  If an asynchronous
       event handler needs to evaluate Tcl scripts then it should first save the interpreter's state by  calling
       <b>Tcl_SaveInterpState</b>,  passing  in the <u>code</u> argument.  When the asynchronous handler is finished it should
       restore the interpreter's state by calling <b>Tcl_RestoreInterpState</b>, and then returning the <u>code</u> argument.

</pre><h4><b>KEYWORDS</b></h4><pre>
       asynchronous event, handler, signal, Tcl_SaveInterpState, thread

Tcl                                                    7.0                                 <u><a href="../man3tcl/Tcl_AsyncCreate.3tcl.html">Tcl_AsyncCreate</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>