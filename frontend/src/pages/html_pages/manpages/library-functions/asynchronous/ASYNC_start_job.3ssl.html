<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASYNC_get_wait_ctx, ASYNC_init_thread, ASYNC_cleanup_thread, ASYNC_start_job, ASYNC_pause_job,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ASYNC_get_wait_ctx, ASYNC_init_thread, ASYNC_cleanup_thread, ASYNC_start_job, ASYNC_pause_job,
       ASYNC_get_current_job, ASYNC_block_pause, ASYNC_unblock_pause, ASYNC_is_capable, ASYNC_stack_alloc_fn,
       ASYNC_stack_free_fn, ASYNC_set_mem_functions, ASYNC_get_mem_functions - asynchronous job management
       functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/async.h&gt;

        int ASYNC_init_thread(size_t max_size, size_t init_size);
        void ASYNC_cleanup_thread(void);

        int ASYNC_start_job(ASYNC_JOB **job, ASYNC_WAIT_CTX *ctx, int *ret,
                            int (*func)(void *), void *args, size_t size);
        int ASYNC_pause_job(void);

        ASYNC_JOB *ASYNC_get_current_job(void);
        ASYNC_WAIT_CTX *ASYNC_get_wait_ctx(ASYNC_JOB *job);
        void ASYNC_block_pause(void);
        void ASYNC_unblock_pause(void);

        int ASYNC_is_capable(void);

        typedef void *(*ASYNC_stack_alloc_fn)(size_t *num);
        typedef void (*ASYNC_stack_free_fn)(void *addr);
        int ASYNC_set_mem_functions(ASYNC_stack_alloc_fn alloc_fn,
                                    ASYNC_stack_free_fn free_fn);
        void ASYNC_get_mem_functions(ASYNC_stack_alloc_fn *alloc_fn,
                                     ASYNC_stack_free_fn *free_fn);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       OpenSSL implements asynchronous capabilities through an <b>ASYNC_JOB</b>. This represents code that can be
       started and executes until some event occurs. At that point the code can be paused and control returns to
       user code until some subsequent event indicates that the job can be resumed. It's OpenSSL specific
       implementation of cooperative multitasking.

       The creation of an <b>ASYNC_JOB</b> is a relatively expensive operation. Therefore, for efficiency reasons, jobs
       can be created up front and reused many times. They are held in a pool until they are needed, at which
       point they are removed from the pool, used, and then returned to the pool when the job completes. If the
       user application is multi-threaded, then <b>ASYNC_init_thread()</b> may be called for each thread that will
       initiate asynchronous jobs. Before user code exits per-thread resources need to be cleaned up. This will
       normally occur automatically (see <b><a href="../man3/OPENSSL_init_crypto.3.html">OPENSSL_init_crypto</a></b>(3)) but may be explicitly initiated by using
       <b>ASYNC_cleanup_thread()</b>. No asynchronous jobs must be outstanding for the thread when
       <b>ASYNC_cleanup_thread()</b> is called. Failing to ensure this will result in memory leaks.

       The <u>max_size</u> argument limits the number of <b>ASYNC_JOB</b>s that will be held in the pool. If <u>max_size</u> is set
       to 0 then no upper limit is set. When an <b>ASYNC_JOB</b> is needed but there are none available in the pool
       already then one will be automatically created, as long as the total of <b>ASYNC_JOB</b>s managed by the pool
       does not exceed <u>max_size</u>. When the pool is first initialised <u>init_size</u> <b>ASYNC_JOB</b>s will be created
       immediately. If <b>ASYNC_init_thread()</b> is not called before the pool is first used then it will be called
       automatically with a <u>max_size</u> of 0 (no upper limit) and an <u>init_size</u> of 0 (no <b>ASYNC_JOB</b>s created up
       front).

       An asynchronous job is started by calling the <b>ASYNC_start_job()</b> function.  Initially <u>*job</u> should be NULL.
       <u>ctx</u> should point to an <b>ASYNC_WAIT_CTX</b> object created through the <b><a href="../man3/ASYNC_WAIT_CTX_new.3.html">ASYNC_WAIT_CTX_new</a></b>(3) function. <u>ret</u>
       should point to a location where the return value of the asynchronous function should be stored on
       completion of the job. <u>func</u> represents the function that should be started asynchronously. The data
       pointed to by <u>args</u> and of size <u>size</u> will be copied and then passed as an argument to <u>func</u> when the job
       starts.  ASYNC_start_job will return one of the following values:

       <b>ASYNC_ERR</b>
           An   error   occurred   trying   to  start  the  job.  Check  the  OpenSSL  error  queue  (e.g.   see
           <b><a href="../man3/ERR_print_errors.3.html">ERR_print_errors</a></b>(3)) for more details.

       <b>ASYNC_NO_JOBS</b>
           There are no jobs currently available in the pool. This call can be retried again at a later time.

       <b>ASYNC_PAUSE</b>
           The job was successfully started but was "paused" before it completed (see <b>ASYNC_pause_job()</b>  below).
           A handle to the job is placed in <u>*job</u>. Other work can be performed (if desired) and the job restarted
           at  a  later  time. To restart a job call <b>ASYNC_start_job()</b> again passing the job handle in <u>*job</u>. The
           <u>func</u>, <u>args</u> and <u>size</u> parameters will be  ignored  when  restarting  a  job.   When  restarting  a  job
           <b>ASYNC_start_job()</b>  <b>must</b>  be  called  from  the  same thread that the job was originally started from.
           <b>ASYNC_WAIT_CTX</b> is used to know when a job is ready to be restarted.

       <b>ASYNC_FINISH</b>
           The job completed. <u>*job</u> will be NULL and the return value from <u>func</u> will be placed in <u>*ret</u>.

       At any one time there can be a maximum of one job actively running per thread (you can have many that are
       paused). <b>ASYNC_get_current_job()</b> can be used to get a pointer to the currently executing <b>ASYNC_JOB</b>. If no
       job is currently executing then this will return NULL.

       If executing within the context of a job (i.e. having been called directly or indirectly by the  function
       "func" passed as an argument to <b>ASYNC_start_job()</b>) then <b>ASYNC_pause_job()</b> will immediately return control
       to  the  calling application with <b>ASYNC_PAUSE</b> returned from the <b>ASYNC_start_job()</b> call. A subsequent call
       to ASYNC_start_job passing in the relevant <b>ASYNC_JOB</b> in the <u>*job</u> parameter will resume execution from the
       <b>ASYNC_pause_job()</b> call. If <b>ASYNC_pause_job()</b> is called whilst not within the context of  a  job  then  no
       action is taken and <b>ASYNC_pause_job()</b> returns immediately.

       <b>ASYNC_get_wait_ctx()</b>   can   be   used  to  get  a  pointer  to  the  <b>ASYNC_WAIT_CTX</b>  for  the  <u>job</u>  (see
       <b><a href="../man3/ASYNC_WAIT_CTX_new.3.html">ASYNC_WAIT_CTX_new</a></b>(3)).  <b>ASYNC_WAIT_CTX</b>s contain two different ways to notify applications that a job  is
       ready to be resumed. One is a "wait" file descriptor, and the other is a "callback" mechanism.

       The  "wait"  file descriptor associated with <b>ASYNC_WAIT_CTX</b> is used for applications to wait for the file
       descriptor to be ready for "read" using a system function call such as <b><a href="../man2/select.2.html">select</a></b>(2) or <b><a href="../man2/poll.2.html">poll</a></b>(2) (being  ready
       for  "read"  indicates  that  the job should be resumed). If no file descriptor is made available then an
       application will have to periodically "poll" the job by attempting to restart it to see if it is ready to
       continue.

       <b>ASYNC_WAIT_CTX</b>s also have a "callback" mechanism to notify  applications.  The  callback  is  set  by  an
       application,  and  it  will be automatically called when an engine completes a cryptography operation, so
       that the application can resume the paused work flow without polling. An engine could be written to  look
       whether  the  callback  has been set. If it has then it would use the callback mechanism in preference to
       the file descriptor notifications. If a callback is not set then the engine may use file descriptor based
       notifications. Please note that not all engines may support the callback mechanism, so the  callback  may
       not be used even if it has been set. See <b>ASYNC_WAIT_CTX_new()</b> for more details.

       The  <b>ASYNC_block_pause()</b>  function  will  prevent  the  currently active job from pausing. The block will
       remain in place until a subsequent call to <b>ASYNC_unblock_pause()</b>. These functions can be nested, e.g.  if
       you  call  <b>ASYNC_block_pause()</b> twice then you must call <b>ASYNC_unblock_pause()</b> twice in order to re-enable
       pausing. If these functions are called while there is no currently active job then they have  no  effect.
       This  functionality  can  be  useful  to avoid deadlock scenarios. For example during the execution of an
       <b>ASYNC_JOB</b> an application acquires a lock.  It  then  calls  some  cryptographic  function  which  invokes
       <b>ASYNC_pause_job()</b>.  This  returns  control back to the code that created the <b>ASYNC_JOB</b>. If that code then
       attempts to acquire the same lock before resuming the original job then a deadlock can occur. By  calling
       <b>ASYNC_block_pause()</b>  immediately  after  acquiring  the lock and <b>ASYNC_unblock_pause()</b> immediately before
       releasing it then this situation cannot occur.

       Some platforms cannot support async operations. The <b>ASYNC_is_capable()</b> function can  be  used  to  detect
       whether the current platform is async capable or not.

       Custom  memory  allocation  functions  are  supported  for  the POSIX platform.  Custom memory allocation
       functions allow alternative methods of allocating stack memory such as mmap, or using stack  memory  from
       the  current  thread.  Using an ASYNC_stack_alloc_fn callback also allows manipulation of the stack size,
       which defaults to 32k.  The stack size can be altered by allocating a stack of a size  different  to  the
       requested size, and passing back the new stack size in the callback's <u>*num</u> parameter.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       ASYNC_init_thread returns 1 on success or 0 otherwise.

       ASYNC_start_job returns one of <b>ASYNC_ERR</b>, <b>ASYNC_NO_JOBS</b>, <b>ASYNC_PAUSE</b> or <b>ASYNC_FINISH</b> as described above.

       ASYNC_pause_job  returns 0 if an error occurred or 1 on success. If called when not within the context of
       an <b>ASYNC_JOB</b> then this is counted as success so 1 is returned.

       ASYNC_get_current_job returns a pointer to the currently executing <b>ASYNC_JOB</b> or NULL if  not  within  the
       context of a job.

       <b>ASYNC_get_wait_ctx()</b> returns a pointer to the <b>ASYNC_WAIT_CTX</b> for the job.

       <b>ASYNC_is_capable()</b> returns 1 if the current platform is async capable or 0 otherwise.

       ASYNC_set_mem_functions returns 1 if custom stack allocators are supported by the current platform and no
       allocations have already occurred or 0 otherwise.

</pre><h4><b>NOTES</b></h4><pre>
       On  Windows  platforms  the  <u>&lt;openssl/async.h&gt;</u>  header is dependent on some of the types customarily made
       available by including <u>&lt;windows.h&gt;</u>. The application developer is likely to require control over when  the
       latter  is  included,  commonly  as  one  of  the  first included headers. Therefore, it is defined as an
       application developer's responsibility to include <u>&lt;windows.h&gt;</u> prior to <u>&lt;openssl/async.h&gt;</u>.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following example demonstrates how to use most of the core async APIs:

        #ifdef _WIN32
        # include &lt;windows.h&gt;
        #endif
        #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
        #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
        #include &lt;openssl/async.h&gt;
        #include &lt;openssl/crypto.h&gt;

        int unique = 0;

        void cleanup(ASYNC_WAIT_CTX *ctx, const void *key, OSSL_ASYNC_FD r, void *vw)
        {
            OSSL_ASYNC_FD *w = (OSSL_ASYNC_FD *)vw;

            close(r);
            close(*w);
            OPENSSL_free(w);
        }

        int jobfunc(void *arg)
        {
            ASYNC_JOB *currjob;
            unsigned char *msg;
            int pipefds[2] = {0, 0};
            OSSL_ASYNC_FD *wptr;
            char buf = 'X';

            currjob = ASYNC_get_current_job();
            if (currjob != NULL) {
                printf("Executing within a job\n");
            } else {
                printf("Not executing within a job - should not happen\n");
                return 0;
            }

            msg = (unsigned char *)arg;
            printf("Passed in message is: %s\n", msg);

            /*
             * Create a way to inform the calling thread when this job is ready
             * to resume, in this example we're using file descriptors.
             * For offloading the task to an asynchronous ENGINE it's not necessary,
             * the ENGINE should handle that internally.
             */

            if (pipe(pipefds) != 0) {
                printf("Failed to create pipe\n");
                return 0;
            }
            wptr = OPENSSL_malloc(sizeof(OSSL_ASYNC_FD));
            if (wptr == NULL) {
                printf("Failed to malloc\n");
                return 0;
            }
            *wptr = pipefds[1];
            ASYNC_WAIT_CTX_set_wait_fd(ASYNC_get_wait_ctx(currjob), &amp;unique,
                                       pipefds[0], wptr, cleanup);

            /*
             * Normally some external event (like a network read being ready,
             * disk access being finished, or some hardware offload operation
             * completing) would cause this to happen at some
             * later point - but we do it here for demo purposes, i.e.
             * immediately signalling that the job is ready to be woken up after
             * we return to main via ASYNC_pause_job().
             */
            write(pipefds[1], &amp;buf, 1);

            /*
             * Return control back to main just before calling a blocking
             * method. The main thread will wait until pipefds[0] is ready
             * for reading before returning control to this thread.
             */
            ASYNC_pause_job();

            /* Perform the blocking call (it won't block with this example code) */
            read(pipefds[0], &amp;buf, 1);

            printf ("Resumed the job after a pause\n");

            return 1;
        }

        int main(void)
        {
            ASYNC_JOB *job = NULL;
            ASYNC_WAIT_CTX *ctx = NULL;
            int ret;
            OSSL_ASYNC_FD waitfd;
            fd_set waitfdset;
            size_t numfds;
            unsigned char msg[13] = "Hello world!";

            printf("Starting...\n");

            ctx = ASYNC_WAIT_CTX_new();
            if (ctx == NULL) {
                printf("Failed to create ASYNC_WAIT_CTX\n");
                abort();
            }

            for (;;) {
                switch (ASYNC_start_job(&amp;job, ctx, &amp;ret, jobfunc, msg, <a href="../manmsg/sizeof.msg.html">sizeof</a>(msg))) {
                case ASYNC_ERR:
                case ASYNC_NO_JOBS:
                    printf("An error occurred\n");
                    goto end;
                case ASYNC_PAUSE:
                    printf("Job was paused\n");
                    break;
                case ASYNC_FINISH:
                    printf("Job finished with return value %d\n", ret);
                    goto end;
                }

                /* Get the file descriptor we can use to wait for the job
                 * to be ready to be woken up
                 */
                printf("Waiting for the job to be woken up\n");

                if (!ASYNC_WAIT_CTX_get_all_fds(ctx, NULL, &amp;numfds)
                        || numfds &gt; 1) {
                    printf("Unexpected number of fds\n");
                    abort();
                }
                ASYNC_WAIT_CTX_get_all_fds(ctx, &amp;waitfd, &amp;numfds);
                FD_ZERO(&amp;waitfdset);
                FD_SET(waitfd, &amp;waitfdset);

                /* Wait for the job to be ready for wakeup */
                select(waitfd + 1, &amp;waitfdset, NULL, NULL, NULL);
            }

        end:
            ASYNC_WAIT_CTX_free(ctx);
            printf("Finishing\n");

            return 0;
        }

       The expected output from executing the above example program is:

        Starting...
        Executing within a job
        Passed in message is: Hello world!
        Job was paused
        Waiting for the job to be woken up
        Resumed the job after a pause
        Job finished with return value 1
        Finishing

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/crypto.7.html">crypto</a></b>(7), <b><a href="../man3/ERR_print_errors.3.html">ERR_print_errors</a></b>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       ASYNC_init_thread,   ASYNC_cleanup_thread,   ASYNC_start_job,   ASYNC_pause_job,   ASYNC_get_current_job,
       <b>ASYNC_get_wait_ctx()</b>,  <b>ASYNC_block_pause()</b>, <b>ASYNC_unblock_pause()</b> and <b>ASYNC_is_capable()</b> were first added
       in OpenSSL 1.1.0.  <b>ASYNC_set_mem_functions()</b>, <b>ASYNC_get_mem_functions()</b> were added in OpenSSL 3.2.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2015-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file  except  in  compliance
       with  the  License.   You  can  obtain  a  copy  in  the  file  LICENSE  in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                              <u><a href="../man3SSL/ASYNC_START_JOB.3SSL.html">ASYNC_START_JOB</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>