<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>optimization - Compiler optimization</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/avr-libc">avr-libc_2.2.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       optimization - Compiler optimization

</pre><h4><b>Problems</b> <b>with</b> <b>reordering</b> <b>code</b></h4><pre>
       <b>Author</b>
           Jan Waclawek

       Programs contain sequences of statements, and a naive compiler would execute them exactly in the order as
       they are written. But an optimizing compiler is free to <u>reorder</u> the statements --- or even parts of them
       --- if the resulting 'net effect' is the same. The 'measure' of the 'net effect' is what the standard
       calls 'side effects', and is accomplished exclusively through accesses (reads and writes) to variables
       qualified as volatile. So, as long as all volatile reads and writes are to the same addresses and in the
       same order (and writes write the same values), the program is correct, regardless of other operations in
       it. One important point to note here is, that time duration between consecutive volatile accesses is not
       considered at all.

       Unfortunately, there are also operations which are not covered by volatile accesses. An example of this
       in AVR-GCC/AVR-LibC are the <b>cli()</b> <b>and</b> <b>sei()</b> <b>macros</b> <b>defined</b> <b>in</b> <b>&lt;avr/interrupt.h&gt;,</b> <b>which</b> <b>convert</b> <b>directly</b>
       <b>to</b> <b>the</b> <b>respective</b> <b>assembler</b> <b>mnemonics</b> <b>through</b> <b>the</b> <b>__asm__()</b> <b>statement.</b> <b>They</b> <b>constitute</b> <b>a</b> <b>variable</b> <b>access</b>
       <b>by</b> <b>means</b> <b>of</b> <b>their</b> <b>memory</b> <b>clobber,</b> <b>and</b> <b>they</b> <b>are</b> <b>(implicitly)</b> <b>volatile</b> <b>because</b> <b>they</b> <b>don't</b> <b>have</b> <b>an</b> <b>output</b>
       <b>operand.</b> <b>So</b> <b>the</b> <b>compiler</b> <b>may</b> <b>not</b> <b>reorder</b> <b>these</b> <b>inline</b> <b>asm</b> <b>statements</b> <b>with</b> <b>respect</b> <b>to</b> <b>other</b> <b>memory</b>
       <b>accesses</b> <b>or</b> <b>volatile</b> <b>actions.</b> <b>However,</b> <b>such</b> <b>asm</b> <b>statementy</b> <b>may</b> <b>still</b> <b>be</b> <b>reordered</b> <b>with</b> <b>other</b> <b>statement</b>
       <b>that</b> <b>are</b> <b>neither</b> <b>volatile</b> <b>nor</b> <b>access</b> <b>memory.</b>

       <u>Note</u> <u>that</u> <u>even</u> <u>a</u> <u>volatile</u> <u>asm</u> <u>instruction</u> <u>can</u> <u>be</u> <u>moved</u> <u>relative</u> <u>to</u> <u>other</u> <u>code,</u> <u>including</u> <u>across</u>
       <u>(expensive)</u> <u>arithmetic</u> <u>and</u> <u>jump</u> <u>instructions</u> <u>[...]</u>

       <b>See</b> <b>also</b>
           <a href="http://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">http://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</a>

       However, not even a volatile memory barrier like

       __asm __volatile__ ("" ::: "memory");

       keeps GCC from reordering non-volatile, non-memory accesses across such barriers. Peter Dannegger
       provided a nice example of this effect:

       #define cli() __asm volatile( "cli" ::: "memory" )
       #define sei() __asm volatile( "sei" ::: "memory" )

       unsigned int ivar;

       void test2 (unsigned int val)
       {
         val = 65535U / val;

         cli();

         ivar = val;

         sei();
       }

       avr-gcc v5.4 or v14 compile with optimisations switched on (-Os) to

       00000112 &lt;test2&gt;:
        112: bc 01          movw r22, r24
        114: f8 94          cli
        116: 8f ef          ldi  r24, 0xFF ; 255
        118: 9f ef          ldi  r25, 0xFF ; 255
        11a: 0e 94 96 00    call 0x12c     ; 0x12c &lt;__udivmodhi4&gt;
        11e: 70 93 01 02    sts  0x0201, r23
        122: 60 93 00 02    sts  0x0200, r22
        126: 78 94          sei
        128: 08 95          ret

       where the potentially slow division is moved across <b>cli(),</b> <b>resulting</b> <b>in</b> <b>interrupts</b> <b>to</b> <b>be</b> <b>disabled</b> <b>longer</b>
       <b>than</b> <b>intended.</b> <b>Note,</b> <b>that</b> <b>the</b> <b>volatile</b> <b>access</b> <b>occurs</b> <b>in</b> <b>order</b> <b>with</b> <b>respect</b> <b>to</b> <b>cli()</b> <b>or</b> <b>sei();</b> <b>so</b> <b>the</b> <b>'net</b>
       <b>effect'</b> <b>required</b> <b>by</b> <b>the</b> <b>standard</b> <b>is</b> <b>achieved</b> <b>as</b> <b>intended,</b> <b>it</b> <b>is</b> <b>'only'</b> <b>the</b> <b>timing</b> <b>which</b> <b>is</b> <b>off.</b> <b>However,</b>
       <b>for</b> <b>most</b> <b>of</b> <b>embedded</b> <b>applications,</b> <b>timing</b> <b>is</b> <b>an</b> <b>important,</b> <b>sometimes</b> <b>critical</b> <b>factor.</b>

       <b>See</b> <b>also</b>
           https://www.mikrocontroller.net/topic/65923

       Unfortunately, at the moment, in avr-gcc (nor in the C standard), there is no mechanism to enforce
       complete match of written and executed code ordering --- except maybe of switching the optimization
       completely off (-O0), or writing all the critical code in assembly.

       <b>Note</b>
           The artifact with the __udivmodhi4 function is specific to avr-gcc and how the compiler represents
           the division internally. On other target platforms that are using a library function for division or
           whatever expensive operation, this eccect will not occur. The reason is that avr-gcc does not
           represent the library call as a function call but rather like an ordinary instruction. Outcome is
           that the GCC middle-end concludes that the division is cheap (because the backend has an instruction
           for it) but in fact it's not.

       A work around for the code from above would be to enforce that the division havvens prior to the <b>cli():</b>

       val = 65535U / val;
       __asm __volatile__ ("" : "+r" (val));
       cli();

       • The volatile forces the asm statememt prior to the cli.

       • The  asm  has val as input operand, hence the division must be carried out prior to the asm because val
         is set by the division.

       Notice that this work around does not work in general due to a variety of reasons:

       • The division might be located in an inlined function.

       • The variable might be read-only or may not be appropriate as an asm operand.

       • There may be more such instruction prior to the division, and it is not practical to treat all of  them
         like this.

       To sum it up:

       •
        volatile  memory  barriers  don't ensure statements with no volatile accesses to be reordered across the
        barrier
AVR-LibC                                          Version 2.2.1                               <u><a href="../man3avr/optimization.3avr.html">optimization</a></u>(3avr)
</pre>
 </div>
</div></section>
</div>
</body>
</html>