<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>heevr_2stage - {he,sy}evr_2stage: eig, MRRR</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       heevr_2stage - {he,sy}evr_2stage: eig, MRRR

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>cheevr_2stage</b> (jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz,
           work, lwork, rwork, lrwork, iwork, liwork, info)
            <b>CHEEVR_2STAGE</b> <b>computes</b> <b>the</b> <b>eigenvalues</b> <b>and,</b> <b>optionally,</b> <b>the</b> <b>left</b> <b>and/or</b> <b>right</b> <b>eigenvectors</b> <b>for</b> <b>HE</b>
           <b>matrices</b>
       subroutine <b>dsyevr_2stage</b> (jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz,
           work, lwork, iwork, liwork, info)
            <b>DSYEVR_2STAGE</b> <b>computes</b> <b>the</b> <b>eigenvalues</b> <b>and,</b> <b>optionally,</b> <b>the</b> <b>left</b> <b>and/or</b> <b>right</b> <b>eigenvectors</b> <b>for</b> <b>SY</b>
           <b>matrices</b>
       subroutine <b>ssyevr_2stage</b> (jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz,
           work, lwork, iwork, liwork, info)
            <b>SSYEVR_2STAGE</b> <b>computes</b> <b>the</b> <b>eigenvalues</b> <b>and,</b> <b>optionally,</b> <b>the</b> <b>left</b> <b>and/or</b> <b>right</b> <b>eigenvectors</b> <b>for</b> <b>SY</b>
           <b>matrices</b>
       subroutine <b>zheevr_2stage</b> (jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz,
           work, lwork, rwork, lrwork, iwork, liwork, info)
            <b>ZHEEVR_2STAGE</b> <b>computes</b> <b>the</b> <b>eigenvalues</b> <b>and,</b> <b>optionally,</b> <b>the</b> <b>left</b> <b>and/or</b> <b>right</b> <b>eigenvectors</b> <b>for</b> <b>HE</b>
           <b>matrices</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>cheevr_2stage</b> <b>(character</b> <b>jobz,</b> <b>character</b> <b>range,</b> <b>character</b> <b>uplo,</b> <b>integer</b> <b>n,</b> <b>complex,</b> <b>dimension(</b>
       <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>real</b> <b>vl,</b> <b>real</b> <b>vu,</b> <b>integer</b> <b>il,</b> <b>integer</b> <b>iu,</b> <b>real</b> <b>abstol,</b> <b>integer</b> <b>m,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>w,</b> <b>complex,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>z,</b> <b>integer</b> <b>ldz,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>isuppz,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>rwork,</b> <b>integer</b> <b>lrwork,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>iwork,</b> <b>integer</b> <b>liwork,</b> <b>integer</b> <b>info)</b>
        <b>CHEEVR_2STAGE</b> <b>computes</b> <b>the</b> <b>eigenvalues</b> <b>and,</b> <b>optionally,</b> <b>the</b> <b>left</b> <b>and/or</b> <b>right</b> <b>eigenvectors</b> <b>for</b> <b>HE</b>
       <b>matrices</b>

       <b>Purpose:</b>

            CHEEVR_2STAGE computes selected eigenvalues and, optionally, eigenvectors
            of a complex Hermitian matrix A using the 2stage technique for
            the reduction to tridiagonal.  Eigenvalues and eigenvectors can
            be selected by specifying either a range of values or a range of
            indices for the desired eigenvalues.

            CHEEVR_2STAGE first reduces the matrix A to tridiagonal form T with a call
            to CHETRD.  Then, whenever possible, CHEEVR_2STAGE calls CSTEMR to compute
            eigenspectrum using Relatively Robust Representations.  CSTEMR
            computes eigenvalues by the dqds algorithm, while orthogonal
            eigenvectors are computed from various 'good' L D L^T representations
            (also known as Relatively Robust Representations). Gram-Schmidt
            orthogonalization is avoided as far as possible. More specifically,
            the various steps of the algorithm are as follows.

            For each unreduced block (submatrix) of T,
               (a) Compute T - sigma I  = L D L^T, so that L and D
                   define all the wanted eigenvalues to high relative accuracy.
                   This means that small relative changes in the entries of D and L
                   cause only small relative changes in the eigenvalues and
                   eigenvectors. The standard (unfactored) representation of the
                   tridiagonal matrix T does not have this property in general.
               (b) Compute the eigenvalues to suitable accuracy.
                   If the eigenvectors are desired, the algorithm attains full
                   accuracy of the computed eigenvalues only right before
                   the corresponding vectors have to be computed, see steps c) and d).
               (c) For each cluster of close eigenvalues, select a new
                   shift close to the cluster, find a new factorization, and refine
                   the shifted eigenvalues to suitable accuracy.
               (d) For each eigenvalue with a large enough relative separation compute
                   the corresponding eigenvector by forming a rank revealing twisted
                   factorization. Go back to (c) for any clusters that remain.

            The desired accuracy of the output can be specified by the input
            parameter ABSTOL.

            For more details, see CSTEMR's documentation and:
            - Inderjit S. Dhillon and Beresford N. Parlett: 'Multiple representations
              to compute orthogonal eigenvectors of symmetric tridiagonal matrices,'
              Linear Algebra and its Applications, <a href="../man1/387.1.html">387</a>(1), pp. 1-28, August 2004.
            - Inderjit Dhillon and Beresford Parlett: 'Orthogonal Eigenvectors and
              Relative Gaps,' SIAM Journal on Matrix Analysis and Applications, Vol. 25,
              2004.  Also LAPACK Working Note 154.
            - Inderjit Dhillon: 'A new O(n^2) algorithm for the symmetric
              tridiagonal eigenvalue/eigenvector problem',
              Computer Science Division Technical Report No. UCB/CSD-97-971,
              UC Berkeley, May 1997.

            Note 1 : CHEEVR_2STAGE calls CSTEMR when the full spectrum is requested
            on machines which conform to the ieee-754 floating point standard.
            CHEEVR_2STAGE calls SSTEBZ and CSTEIN on non-ieee machines and
            when partial spectrum requests are made.

            Normal execution of CSTEMR may create NaNs and infinities and
            hence may abort due to a floating point exception in environments
            which do not handle NaNs and infinities in the ieee standard default
            manner.

       <b>Parameters</b>
           <u>JOBZ</u>

                     JOBZ is CHARACTER*1
                     = 'N':  Compute eigenvalues only;
                     = 'V':  Compute eigenvalues and eigenvectors.
                             Not available in this release.

           <u>RANGE</u>

                     RANGE is CHARACTER*1
                     = 'A': all eigenvalues will be found.
                     = 'V': all eigenvalues in the half-open interval (VL,VU]
                            will be found.
                     = 'I': the IL-th through IU-th eigenvalues will be found.
                     For RANGE = 'V' or 'I' and IU - IL &lt; N - 1, SSTEBZ and
                     CSTEIN are called

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA, N)
                     On entry, the Hermitian matrix A.  If UPLO = 'U', the
                     leading N-by-N upper triangular part of A contains the
                     upper triangular part of the matrix A.  If UPLO = 'L',
                     the leading N-by-N lower triangular part of A contains
                     the lower triangular part of the matrix A.
                     On exit, the lower triangle (if UPLO='L') or the upper
                     triangle (if UPLO='U') of A, including the diagonal, is
                     destroyed.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>VL</u>

                     VL is REAL
                     If RANGE='V', the lower bound of the interval to
                     be searched for eigenvalues. VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>VU</u>

                     VU is REAL
                     If RANGE='V', the upper bound of the interval to
                     be searched for eigenvalues. VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>IL</u>

                     IL is INTEGER
                     If RANGE='I', the index of the
                     smallest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>IU</u>

                     IU is INTEGER
                     If RANGE='I', the index of the
                     largest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>ABSTOL</u>

                     ABSTOL is REAL
                     The absolute error tolerance for the eigenvalues.
                     An approximate eigenvalue is accepted as converged
                     when it is determined to lie in an interval [a,b]
                     of width less than or equal to

                             ABSTOL + EPS *   max( |a|,|b| ) ,

                     where EPS is the machine precision.  If ABSTOL is less than
                     or equal to zero, then  EPS*|T|  will be used in its place,
                     where |T| is the 1-norm of the tridiagonal matrix obtained
                     by reducing A to tridiagonal form.

                     See 'Computing Small Singular Values of Bidiagonal Matrices
                     with Guaranteed High Relative Accuracy,' by Demmel and
                     Kahan, LAPACK Working Note #3.

                     If high relative accuracy is important, set ABSTOL to
                     SLAMCH( 'Safe minimum' ).  Doing so will guarantee that
                     eigenvalues are computed to high relative accuracy when
                     possible in future releases.  The current code does not
                     make any guarantees about high relative accuracy, but
                     future releases will. See J. Barlow and J. Demmel,
                     'Computing Accurate Eigensystems of Scaled Diagonally
                     Dominant Matrices', LAPACK Working Note #7, for a discussion
                     of which matrices define their eigenvalues to high relative
                     accuracy.

           <u>M</u>

                     M is INTEGER
                     The total number of eigenvalues found.  0 &lt;= M &lt;= N.
                     If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

           <u>W</u>

                     W is REAL array, dimension (N)
                     The first M elements contain the selected eigenvalues in
                     ascending order.

           <u>Z</u>

                     Z is COMPLEX array, dimension (LDZ, max(1,M))
                     If JOBZ = 'V', then if INFO = 0, the first M columns of Z
                     contain the orthonormal eigenvectors of the matrix A
                     corresponding to the selected eigenvalues, with the i-th
                     column of Z holding the eigenvector associated with W(i).
                     If JOBZ = 'N', then Z is not referenced.
                     Note: the user must ensure that at least max(1,M) columns are
                     supplied in the array Z; if RANGE = 'V', the exact value of M
                     is not known in advance and an upper bound must be used.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1, and if
                     JOBZ = 'V', LDZ &gt;= max(1,N).

           <u>ISUPPZ</u>

                     ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )
                     The support of the eigenvectors in Z, i.e., the indices
                     indicating the nonzero elements in Z. The i-th eigenvector
                     is nonzero only in elements ISUPPZ( 2*i-1 ) through
                     ISUPPZ( 2*i ). This is an output of CSTEMR (tridiagonal
                     matrix). The support of the eigenvectors of A is typically
                     1:N because of the unitary transformations applied by CUNMTR.
                     Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If N &lt;= 1,               LWORK must be at least 1.
                     If JOBZ = 'N' and N &gt; 1, LWORK must be queried.
                                              LWORK = MAX(1, 26*N, dimension) where
                                              dimension = max(stage1,stage2) + (KD+1)*N + N
                                                        = N*KD + N*max(KD+1,FACTOPTNB)
                                                          + max(2*KD*KD, KD*NTHREADS)
                                                          + (KD+1)*N + N
                                              where KD is the blocking size of the reduction,
                                              FACTOPTNB is the blocking used by the QR or LQ
                                              algorithm, usually FACTOPTNB=128 is a good choice
                                              NTHREADS is the number of threads used when
                                              openMP compilation is enabled, otherwise =1.
                     If JOBZ = 'V' and N &gt; 1, LWORK must be queried. Not yet available

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal sizes of the WORK, RWORK and
                     IWORK arrays, returns these values as the first entries of
                     the WORK, RWORK and IWORK arrays, and no error message
                     related to LWORK or LRWORK or LIWORK is issued by XERBLA.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (MAX(1,LRWORK))
                     On exit, if INFO = 0, <a href="../man1/RWORK.1.html">RWORK</a>(1) returns the optimal
                     (and minimal) LRWORK.

           <u>LRWORK</u>

                     LRWORK is INTEGER
                     The length of the array RWORK.
                     If N &lt;= 1, LRWORK &gt;= 1, else LRWORK &gt;= 24*N.

                     If LRWORK = -1, then a workspace query is assumed; the
                     routine only calculates the optimal sizes of the WORK, RWORK
                     and IWORK arrays, returns these values as the first entries
                     of the WORK, RWORK and IWORK arrays, and no error message
                     related to LWORK or LRWORK or LIWORK is issued by XERBLA.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (MAX(1,LIWORK))
                     On exit, if INFO = 0, <a href="../man1/IWORK.1.html">IWORK</a>(1) returns the optimal
                     (and minimal) LIWORK.

           <u>LIWORK</u>

                     LIWORK is INTEGER
                     The dimension of the array IWORK.
                     If N &lt;= 1, LIWORK &gt;= 1, else LIWORK &gt;= 10*N.

                     If LIWORK = -1, then a workspace query is assumed; the
                     routine only calculates the optimal sizes of the WORK, RWORK
                     and IWORK arrays, returns these values as the first entries
                     of the WORK, RWORK and IWORK arrays, and no error message
                     related to LWORK or LRWORK or LIWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  Internal error

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>

           Inderjit Dhillon, IBM Almaden, USA \n
           Osni Marques, LBNL/NERSC, USA \n
           Ken Stanley, Computer Science Division, University of
             California at Berkeley, USA \n
           Jason Riedy, Computer Science Division, University of
             California at Berkeley, USA \n

       <b>Further</b> <b>Details:</b>

             All details about the 2stage techniques are available in:

             Azzam Haidar, Hatem Ltaief, and Jack Dongarra.
             Parallel reduction to condensed forms for symmetric eigenvalue problems
             using aggregated fine-grained and memory-aware kernels. In Proceedings
             of 2011 International Conference for High Performance Computing,
             Networking, Storage and Analysis (SC '11), New York, NY, USA,
             Article 8 , 11 pages.
             <a href="http://doi.acm.org/10.1145/2063384.2063394">http://doi.acm.org/10.1145/2063384.2063394</a>

             A. Haidar, J. Kurzak, P. Luszczek, 2013.
             An improved parallel singular value algorithm and its implementation
             for multicore hardware, In Proceedings of 2013 International Conference
             for High Performance Computing, Networking, Storage and Analysis (SC '13).
             Denver, Colorado, USA, 2013.
             Article 90, 12 pages.
             <a href="http://doi.acm.org/10.1145/2503210.2503292">http://doi.acm.org/10.1145/2503210.2503292</a>

             A. Haidar, R. Solca, S. Tomov, T. Schulthess and J. Dongarra.
             A novel hybrid CPU-GPU generalized eigensolver for electronic structure
             calculations based on fine-grained memory aware tasks.
             International Journal of High Performance Computing Applications.
             Volume 28 Issue 2, Pages 196-209, May 2014.
             <a href="http://hpc.sagepub.com/content/28/2/196">http://hpc.sagepub.com/content/28/2/196</a>

   <b>subroutine</b> <b>dsyevr_2stage</b> <b>(character</b> <b>jobz,</b> <b>character</b> <b>range,</b> <b>character</b> <b>uplo,</b> <b>integer</b> <b>n,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>double</b> <b>precision</b> <b>vl,</b> <b>double</b> <b>precision</b> <b>vu,</b> <b>integer</b> <b>il,</b> <b>integer</b> <b>iu,</b>
       <b>double</b> <b>precision</b> <b>abstol,</b> <b>integer</b> <b>m,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>w,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldz,</b>
       <b>*</b> <b>)</b> <b>z,</b> <b>integer</b> <b>ldz,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>isuppz,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>liwork,</b> <b>integer</b> <b>info)</b>
        <b>DSYEVR_2STAGE</b> <b>computes</b> <b>the</b> <b>eigenvalues</b> <b>and,</b> <b>optionally,</b> <b>the</b> <b>left</b> <b>and/or</b> <b>right</b> <b>eigenvectors</b> <b>for</b> <b>SY</b>
       <b>matrices</b>

       <b>Purpose:</b>

            DSYEVR_2STAGE computes selected eigenvalues and, optionally, eigenvectors
            of a real symmetric matrix A using the 2stage technique for
            the reduction to tridiagonal.  Eigenvalues and eigenvectors can be
            selected by specifying either a range of values or a range of
            indices for the desired eigenvalues.

            DSYEVR_2STAGE first reduces the matrix A to tridiagonal form T with a call
            to DSYTRD.  Then, whenever possible, DSYEVR_2STAGE calls DSTEMR to compute
            the eigenspectrum using Relatively Robust Representations.  DSTEMR
            computes eigenvalues by the dqds algorithm, while orthogonal
            eigenvectors are computed from various 'good' L D L^T representations
            (also known as Relatively Robust Representations). Gram-Schmidt
            orthogonalization is avoided as far as possible. More specifically,
            the various steps of the algorithm are as follows.

            For each unreduced block (submatrix) of T,
               (a) Compute T - sigma I  = L D L^T, so that L and D
                   define all the wanted eigenvalues to high relative accuracy.
                   This means that small relative changes in the entries of D and L
                   cause only small relative changes in the eigenvalues and
                   eigenvectors. The standard (unfactored) representation of the
                   tridiagonal matrix T does not have this property in general.
               (b) Compute the eigenvalues to suitable accuracy.
                   If the eigenvectors are desired, the algorithm attains full
                   accuracy of the computed eigenvalues only right before
                   the corresponding vectors have to be computed, see steps c) and d).
               (c) For each cluster of close eigenvalues, select a new
                   shift close to the cluster, find a new factorization, and refine
                   the shifted eigenvalues to suitable accuracy.
               (d) For each eigenvalue with a large enough relative separation compute
                   the corresponding eigenvector by forming a rank revealing twisted
                   factorization. Go back to (c) for any clusters that remain.

            The desired accuracy of the output can be specified by the input
            parameter ABSTOL.

            For more details, see DSTEMR's documentation and:
            - Inderjit S. Dhillon and Beresford N. Parlett: 'Multiple representations
              to compute orthogonal eigenvectors of symmetric tridiagonal matrices,'
              Linear Algebra and its Applications, <a href="../man1/387.1.html">387</a>(1), pp. 1-28, August 2004.
            - Inderjit Dhillon and Beresford Parlett: 'Orthogonal Eigenvectors and
              Relative Gaps,' SIAM Journal on Matrix Analysis and Applications, Vol. 25,
              2004.  Also LAPACK Working Note 154.
            - Inderjit Dhillon: 'A new O(n^2) algorithm for the symmetric
              tridiagonal eigenvalue/eigenvector problem',
              Computer Science Division Technical Report No. UCB/CSD-97-971,
              UC Berkeley, May 1997.

            Note 1 : DSYEVR_2STAGE calls DSTEMR when the full spectrum is requested
            on machines which conform to the ieee-754 floating point standard.
            DSYEVR_2STAGE calls DSTEBZ and SSTEIN on non-ieee machines and
            when partial spectrum requests are made.

            Normal execution of DSTEMR may create NaNs and infinities and
            hence may abort due to a floating point exception in environments
            which do not handle NaNs and infinities in the ieee standard default
            manner.

       <b>Parameters</b>
           <u>JOBZ</u>

                     JOBZ is CHARACTER*1
                     = 'N':  Compute eigenvalues only;
                     = 'V':  Compute eigenvalues and eigenvectors.
                             Not available in this release.

           <u>RANGE</u>

                     RANGE is CHARACTER*1
                     = 'A': all eigenvalues will be found.
                     = 'V': all eigenvalues in the half-open interval (VL,VU]
                            will be found.
                     = 'I': the IL-th through IU-th eigenvalues will be found.
                     For RANGE = 'V' or 'I' and IU - IL &lt; N - 1, DSTEBZ and
                     DSTEIN are called

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA, N)
                     On entry, the symmetric matrix A.  If UPLO = 'U', the
                     leading N-by-N upper triangular part of A contains the
                     upper triangular part of the matrix A.  If UPLO = 'L',
                     the leading N-by-N lower triangular part of A contains
                     the lower triangular part of the matrix A.
                     On exit, the lower triangle (if UPLO='L') or the upper
                     triangle (if UPLO='U') of A, including the diagonal, is
                     destroyed.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>VL</u>

                     VL is DOUBLE PRECISION
                     If RANGE='V', the lower bound of the interval to
                     be searched for eigenvalues. VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>VU</u>

                     VU is DOUBLE PRECISION
                     If RANGE='V', the upper bound of the interval to
                     be searched for eigenvalues. VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>IL</u>

                     IL is INTEGER
                     If RANGE='I', the index of the
                     smallest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>IU</u>

                     IU is INTEGER
                     If RANGE='I', the index of the
                     largest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>ABSTOL</u>

                     ABSTOL is DOUBLE PRECISION
                     The absolute error tolerance for the eigenvalues.
                     An approximate eigenvalue is accepted as converged
                     when it is determined to lie in an interval [a,b]
                     of width less than or equal to

                             ABSTOL + EPS *   max( |a|,|b| ) ,

                     where EPS is the machine precision.  If ABSTOL is less than
                     or equal to zero, then  EPS*|T|  will be used in its place,
                     where |T| is the 1-norm of the tridiagonal matrix obtained
                     by reducing A to tridiagonal form.

                     See 'Computing Small Singular Values of Bidiagonal Matrices
                     with Guaranteed High Relative Accuracy,' by Demmel and
                     Kahan, LAPACK Working Note #3.

                     If high relative accuracy is important, set ABSTOL to
                     DLAMCH( 'Safe minimum' ).  Doing so will guarantee that
                     eigenvalues are computed to high relative accuracy when
                     possible in future releases.  The current code does not
                     make any guarantees about high relative accuracy, but
                     future releases will. See J. Barlow and J. Demmel,
                     'Computing Accurate Eigensystems of Scaled Diagonally
                     Dominant Matrices', LAPACK Working Note #7, for a discussion
                     of which matrices define their eigenvalues to high relative
                     accuracy.

           <u>M</u>

                     M is INTEGER
                     The total number of eigenvalues found.  0 &lt;= M &lt;= N.
                     If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

           <u>W</u>

                     W is DOUBLE PRECISION array, dimension (N)
                     The first M elements contain the selected eigenvalues in
                     ascending order.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (LDZ, max(1,M))
                     If JOBZ = 'V', then if INFO = 0, the first M columns of Z
                     contain the orthonormal eigenvectors of the matrix A
                     corresponding to the selected eigenvalues, with the i-th
                     column of Z holding the eigenvector associated with W(i).
                     If JOBZ = 'N', then Z is not referenced.
                     Note: the user must ensure that at least max(1,M) columns are
                     supplied in the array Z; if RANGE = 'V', the exact value of M
                     is not known in advance and an upper bound must be used.
                     Supplying N columns is always safe.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1, and if
                     JOBZ = 'V', LDZ &gt;= max(1,N).

           <u>ISUPPZ</u>

                     ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )
                     The support of the eigenvectors in Z, i.e., the indices
                     indicating the nonzero elements in Z. The i-th eigenvector
                     is nonzero only in elements ISUPPZ( 2*i-1 ) through
                     ISUPPZ( 2*i ). This is an output of DSTEMR (tridiagonal
                     matrix). The support of the eigenvectors of A is typically
                     1:N because of the orthogonal transformations applied by DORMTR.
                     Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If N &lt;= 1,               LWORK must be at least 1.
                     If JOBZ = 'N' and N &gt; 1, LWORK must be queried.
                                              LWORK = MAX(1, 26*N, dimension) where
                                              dimension = max(stage1,stage2) + (KD+1)*N + 5*N
                                                        = N*KD + N*max(KD+1,FACTOPTNB)
                                                          + max(2*KD*KD, KD*NTHREADS)
                                                          + (KD+1)*N + 5*N
                                              where KD is the blocking size of the reduction,
                                              FACTOPTNB is the blocking used by the QR or LQ
                                              algorithm, usually FACTOPTNB=128 is a good choice
                                              NTHREADS is the number of threads used when
                                              openMP compilation is enabled, otherwise =1.
                     If JOBZ = 'V' and N &gt; 1, LWORK must be queried. Not yet available

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (MAX(1,LIWORK))
                     On exit, if INFO = 0, <a href="../man1/IWORK.1.html">IWORK</a>(1) returns the optimal LIWORK.

           <u>LIWORK</u>

                     LIWORK is INTEGER
                     The dimension of the array IWORK.
                     If N &lt;= 1, LIWORK &gt;= 1, else LIWORK &gt;= 10*N.

                     If LIWORK = -1, then a workspace query is assumed; the
                     routine only calculates the optimal size of the IWORK array,
                     returns this value as the first entry of the IWORK array, and
                     no error message related to LIWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  Internal error

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>

           Inderjit Dhillon, IBM Almaden, USA \n
           Osni Marques, LBNL/NERSC, USA \n
           Ken Stanley, Computer Science Division, University of
             California at Berkeley, USA \n
           Jason Riedy, Computer Science Division, University of
             California at Berkeley, USA \n

       <b>Further</b> <b>Details:</b>

             All details about the 2stage techniques are available in:

             Azzam Haidar, Hatem Ltaief, and Jack Dongarra.
             Parallel reduction to condensed forms for symmetric eigenvalue problems
             using aggregated fine-grained and memory-aware kernels. In Proceedings
             of 2011 International Conference for High Performance Computing,
             Networking, Storage and Analysis (SC '11), New York, NY, USA,
             Article 8 , 11 pages.
             <a href="http://doi.acm.org/10.1145/2063384.2063394">http://doi.acm.org/10.1145/2063384.2063394</a>

             A. Haidar, J. Kurzak, P. Luszczek, 2013.
             An improved parallel singular value algorithm and its implementation
             for multicore hardware, In Proceedings of 2013 International Conference
             for High Performance Computing, Networking, Storage and Analysis (SC '13).
             Denver, Colorado, USA, 2013.
             Article 90, 12 pages.
             <a href="http://doi.acm.org/10.1145/2503210.2503292">http://doi.acm.org/10.1145/2503210.2503292</a>

             A. Haidar, R. Solca, S. Tomov, T. Schulthess and J. Dongarra.
             A novel hybrid CPU-GPU generalized eigensolver for electronic structure
             calculations based on fine-grained memory aware tasks.
             International Journal of High Performance Computing Applications.
             Volume 28 Issue 2, Pages 196-209, May 2014.
             <a href="http://hpc.sagepub.com/content/28/2/196">http://hpc.sagepub.com/content/28/2/196</a>

   <b>subroutine</b> <b>ssyevr_2stage</b> <b>(character</b> <b>jobz,</b> <b>character</b> <b>range,</b> <b>character</b> <b>uplo,</b> <b>integer</b> <b>n,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b>
       <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>real</b> <b>vl,</b> <b>real</b> <b>vu,</b> <b>integer</b> <b>il,</b> <b>integer</b> <b>iu,</b> <b>real</b> <b>abstol,</b> <b>integer</b> <b>m,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>w,</b> <b>real,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>z,</b> <b>integer</b> <b>ldz,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>isuppz,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b>
       <b>integer</b> <b>lwork,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>liwork,</b> <b>integer</b> <b>info)</b>
        <b>SSYEVR_2STAGE</b> <b>computes</b> <b>the</b> <b>eigenvalues</b> <b>and,</b> <b>optionally,</b> <b>the</b> <b>left</b> <b>and/or</b> <b>right</b> <b>eigenvectors</b> <b>for</b> <b>SY</b>
       <b>matrices</b>

       <b>Purpose:</b>

            SSYEVR_2STAGE computes selected eigenvalues and, optionally, eigenvectors
            of a real symmetric matrix A using the 2stage technique for
            the reduction to tridiagonal.  Eigenvalues and eigenvectors can be
            selected by specifying either a range of values or a range of
            indices for the desired eigenvalues.

            SSYEVR_2STAGE first reduces the matrix A to tridiagonal form T with a call
            to SSYTRD.  Then, whenever possible, SSYEVR_2STAGE calls SSTEMR to compute
            the eigenspectrum using Relatively Robust Representations.  SSTEMR
            computes eigenvalues by the dqds algorithm, while orthogonal
            eigenvectors are computed from various 'good' L D L^T representations
            (also known as Relatively Robust Representations). Gram-Schmidt
            orthogonalization is avoided as far as possible. More specifically,
            the various steps of the algorithm are as follows.

            For each unreduced block (submatrix) of T,
               (a) Compute T - sigma I  = L D L^T, so that L and D
                   define all the wanted eigenvalues to high relative accuracy.
                   This means that small relative changes in the entries of D and L
                   cause only small relative changes in the eigenvalues and
                   eigenvectors. The standard (unfactored) representation of the
                   tridiagonal matrix T does not have this property in general.
               (b) Compute the eigenvalues to suitable accuracy.
                   If the eigenvectors are desired, the algorithm attains full
                   accuracy of the computed eigenvalues only right before
                   the corresponding vectors have to be computed, see steps c) and d).
               (c) For each cluster of close eigenvalues, select a new
                   shift close to the cluster, find a new factorization, and refine
                   the shifted eigenvalues to suitable accuracy.
               (d) For each eigenvalue with a large enough relative separation compute
                   the corresponding eigenvector by forming a rank revealing twisted
                   factorization. Go back to (c) for any clusters that remain.

            The desired accuracy of the output can be specified by the input
            parameter ABSTOL.

            For more details, see SSTEMR's documentation and:
            - Inderjit S. Dhillon and Beresford N. Parlett: 'Multiple representations
              to compute orthogonal eigenvectors of symmetric tridiagonal matrices,'
              Linear Algebra and its Applications, <a href="../man1/387.1.html">387</a>(1), pp. 1-28, August 2004.
            - Inderjit Dhillon and Beresford Parlett: 'Orthogonal Eigenvectors and
              Relative Gaps,' SIAM Journal on Matrix Analysis and Applications, Vol. 25,
              2004.  Also LAPACK Working Note 154.
            - Inderjit Dhillon: 'A new O(n^2) algorithm for the symmetric
              tridiagonal eigenvalue/eigenvector problem',
              Computer Science Division Technical Report No. UCB/CSD-97-971,
              UC Berkeley, May 1997.

            Note 1 : SSYEVR_2STAGE calls SSTEMR when the full spectrum is requested
            on machines which conform to the ieee-754 floating point standard.
            SSYEVR_2STAGE calls SSTEBZ and SSTEIN on non-ieee machines and
            when partial spectrum requests are made.

            Normal execution of SSTEMR may create NaNs and infinities and
            hence may abort due to a floating point exception in environments
            which do not handle NaNs and infinities in the ieee standard default
            manner.

       <b>Parameters</b>
           <u>JOBZ</u>

                     JOBZ is CHARACTER*1
                     = 'N':  Compute eigenvalues only;
                     = 'V':  Compute eigenvalues and eigenvectors.
                             Not available in this release.

           <u>RANGE</u>

                     RANGE is CHARACTER*1
                     = 'A': all eigenvalues will be found.
                     = 'V': all eigenvalues in the half-open interval (VL,VU]
                            will be found.
                     = 'I': the IL-th through IU-th eigenvalues will be found.
                     For RANGE = 'V' or 'I' and IU - IL &lt; N - 1, SSTEBZ and
                     SSTEIN are called

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is REAL array, dimension (LDA, N)
                     On entry, the symmetric matrix A.  If UPLO = 'U', the
                     leading N-by-N upper triangular part of A contains the
                     upper triangular part of the matrix A.  If UPLO = 'L',
                     the leading N-by-N lower triangular part of A contains
                     the lower triangular part of the matrix A.
                     On exit, the lower triangle (if UPLO='L') or the upper
                     triangle (if UPLO='U') of A, including the diagonal, is
                     destroyed.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>VL</u>

                     VL is REAL
                     If RANGE='V', the lower bound of the interval to
                     be searched for eigenvalues. VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>VU</u>

                     VU is REAL
                     If RANGE='V', the upper bound of the interval to
                     be searched for eigenvalues. VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>IL</u>

                     IL is INTEGER
                     If RANGE='I', the index of the
                     smallest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>IU</u>

                     IU is INTEGER
                     If RANGE='I', the index of the
                     largest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>ABSTOL</u>

                     ABSTOL is REAL
                     The absolute error tolerance for the eigenvalues.
                     An approximate eigenvalue is accepted as converged
                     when it is determined to lie in an interval [a,b]
                     of width less than or equal to

                             ABSTOL + EPS *   max( |a|,|b| ) ,

                     where EPS is the machine precision.  If ABSTOL is less than
                     or equal to zero, then  EPS*|T|  will be used in its place,
                     where |T| is the 1-norm of the tridiagonal matrix obtained
                     by reducing A to tridiagonal form.

                     See 'Computing Small Singular Values of Bidiagonal Matrices
                     with Guaranteed High Relative Accuracy,' by Demmel and
                     Kahan, LAPACK Working Note #3.

                     If high relative accuracy is important, set ABSTOL to
                     SLAMCH( 'Safe minimum' ).  Doing so will guarantee that
                     eigenvalues are computed to high relative accuracy when
                     possible in future releases.  The current code does not
                     make any guarantees about high relative accuracy, but
                     future releases will. See J. Barlow and J. Demmel,
                     'Computing Accurate Eigensystems of Scaled Diagonally
                     Dominant Matrices', LAPACK Working Note #7, for a discussion
                     of which matrices define their eigenvalues to high relative
                     accuracy.

           <u>M</u>

                     M is INTEGER
                     The total number of eigenvalues found.  0 &lt;= M &lt;= N.
                     If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

           <u>W</u>

                     W is REAL array, dimension (N)
                     The first M elements contain the selected eigenvalues in
                     ascending order.

           <u>Z</u>

                     Z is REAL array, dimension (LDZ, max(1,M))
                     If JOBZ = 'V', then if INFO = 0, the first M columns of Z
                     contain the orthonormal eigenvectors of the matrix A
                     corresponding to the selected eigenvalues, with the i-th
                     column of Z holding the eigenvector associated with W(i).
                     If JOBZ = 'N', then Z is not referenced.
                     Note: the user must ensure that at least max(1,M) columns are
                     supplied in the array Z; if RANGE = 'V', the exact value of M
                     is not known in advance and an upper bound must be used.
                     Supplying N columns is always safe.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1, and if
                     JOBZ = 'V', LDZ &gt;= max(1,N).

           <u>ISUPPZ</u>

                     ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )
                     The support of the eigenvectors in Z, i.e., the indices
                     indicating the nonzero elements in Z. The i-th eigenvector
                     is nonzero only in elements ISUPPZ( 2*i-1 ) through
                     ISUPPZ( 2*i ). This is an output of SSTEMR (tridiagonal
                     matrix). The support of the eigenvectors of A is typically
                     1:N because of the orthogonal transformations applied by SORMTR.
                     Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If N &lt;= 1,               LWORK must be at least 1.
                     If JOBZ = 'N' and N &gt; 1, LWORK must be queried.
                                              LWORK = MAX(1, 26*N, dimension) where
                                              dimension = max(stage1,stage2) + (KD+1)*N + 5*N
                                                        = N*KD + N*max(KD+1,FACTOPTNB)
                                                          + max(2*KD*KD, KD*NTHREADS)
                                                          + (KD+1)*N + 5*N
                                              where KD is the blocking size of the reduction,
                                              FACTOPTNB is the blocking used by the QR or LQ
                                              algorithm, usually FACTOPTNB=128 is a good choice
                                              NTHREADS is the number of threads used when
                                              openMP compilation is enabled, otherwise =1.
                     If JOBZ = 'V' and N &gt; 1, LWORK must be queried. Not yet available

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (MAX(1,LIWORK))
                     On exit, if INFO = 0, <a href="../man1/IWORK.1.html">IWORK</a>(1) returns the optimal LIWORK.

           <u>LIWORK</u>

                     LIWORK is INTEGER
                     The dimension of the array IWORK.
                     If N &lt;= 1, LIWORK &gt;= 1, else LIWORK &gt;= 10*N.

                     If LIWORK = -1, then a workspace query is assumed; the
                     routine only calculates the optimal size of the IWORK array,
                     returns this value as the first entry of the IWORK array, and
                     no error message related to LIWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  Internal error

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>

           Inderjit Dhillon, IBM Almaden, USA \n
           Osni Marques, LBNL/NERSC, USA \n
           Ken Stanley, Computer Science Division, University of
             California at Berkeley, USA \n
           Jason Riedy, Computer Science Division, University of
             California at Berkeley, USA \n

       <b>Further</b> <b>Details:</b>

             All details about the 2stage techniques are available in:

             Azzam Haidar, Hatem Ltaief, and Jack Dongarra.
             Parallel reduction to condensed forms for symmetric eigenvalue problems
             using aggregated fine-grained and memory-aware kernels. In Proceedings
             of 2011 International Conference for High Performance Computing,
             Networking, Storage and Analysis (SC '11), New York, NY, USA,
             Article 8 , 11 pages.
             <a href="http://doi.acm.org/10.1145/2063384.2063394">http://doi.acm.org/10.1145/2063384.2063394</a>

             A. Haidar, J. Kurzak, P. Luszczek, 2013.
             An improved parallel singular value algorithm and its implementation
             for multicore hardware, In Proceedings of 2013 International Conference
             for High Performance Computing, Networking, Storage and Analysis (SC '13).
             Denver, Colorado, USA, 2013.
             Article 90, 12 pages.
             <a href="http://doi.acm.org/10.1145/2503210.2503292">http://doi.acm.org/10.1145/2503210.2503292</a>

             A. Haidar, R. Solca, S. Tomov, T. Schulthess and J. Dongarra.
             A novel hybrid CPU-GPU generalized eigensolver for electronic structure
             calculations based on fine-grained memory aware tasks.
             International Journal of High Performance Computing Applications.
             Volume 28 Issue 2, Pages 196-209, May 2014.
             <a href="http://hpc.sagepub.com/content/28/2/196">http://hpc.sagepub.com/content/28/2/196</a>

   <b>subroutine</b> <b>zheevr_2stage</b> <b>(character</b> <b>jobz,</b> <b>character</b> <b>range,</b> <b>character</b> <b>uplo,</b> <b>integer</b> <b>n,</b> <b>complex*16,</b> <b>dimension(</b>
       <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>double</b> <b>precision</b> <b>vl,</b> <b>double</b> <b>precision</b> <b>vu,</b> <b>integer</b> <b>il,</b> <b>integer</b> <b>iu,</b> <b>double</b>
       <b>precision</b> <b>abstol,</b> <b>integer</b> <b>m,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>w,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>z,</b>
       <b>integer</b> <b>ldz,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>isuppz,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>rwork,</b> <b>integer</b> <b>lrwork,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>liwork,</b> <b>integer</b>
       <b>info)</b>
        <b>ZHEEVR_2STAGE</b> <b>computes</b> <b>the</b> <b>eigenvalues</b> <b>and,</b> <b>optionally,</b> <b>the</b> <b>left</b> <b>and/or</b> <b>right</b> <b>eigenvectors</b> <b>for</b> <b>HE</b>
       <b>matrices</b>

       <b>Purpose:</b>

            ZHEEVR_2STAGE computes selected eigenvalues and, optionally, eigenvectors
            of a complex Hermitian matrix A using the 2stage technique for
            the reduction to tridiagonal.  Eigenvalues and eigenvectors can
            be selected by specifying either a range of values or a range of
            indices for the desired eigenvalues.

            ZHEEVR_2STAGE first reduces the matrix A to tridiagonal form T with a call
            to ZHETRD.  Then, whenever possible, ZHEEVR_2STAGE calls ZSTEMR to compute
            eigenspectrum using Relatively Robust Representations.  ZSTEMR
            computes eigenvalues by the dqds algorithm, while orthogonal
            eigenvectors are computed from various 'good' L D L^T representations
            (also known as Relatively Robust Representations). Gram-Schmidt
            orthogonalization is avoided as far as possible. More specifically,
            the various steps of the algorithm are as follows.

            For each unreduced block (submatrix) of T,
               (a) Compute T - sigma I  = L D L^T, so that L and D
                   define all the wanted eigenvalues to high relative accuracy.
                   This means that small relative changes in the entries of D and L
                   cause only small relative changes in the eigenvalues and
                   eigenvectors. The standard (unfactored) representation of the
                   tridiagonal matrix T does not have this property in general.
               (b) Compute the eigenvalues to suitable accuracy.
                   If the eigenvectors are desired, the algorithm attains full
                   accuracy of the computed eigenvalues only right before
                   the corresponding vectors have to be computed, see steps c) and d).
               (c) For each cluster of close eigenvalues, select a new
                   shift close to the cluster, find a new factorization, and refine
                   the shifted eigenvalues to suitable accuracy.
               (d) For each eigenvalue with a large enough relative separation compute
                   the corresponding eigenvector by forming a rank revealing twisted
                   factorization. Go back to (c) for any clusters that remain.

            The desired accuracy of the output can be specified by the input
            parameter ABSTOL.

            For more details, see ZSTEMR's documentation and:
            - Inderjit S. Dhillon and Beresford N. Parlett: 'Multiple representations
              to compute orthogonal eigenvectors of symmetric tridiagonal matrices,'
              Linear Algebra and its Applications, <a href="../man1/387.1.html">387</a>(1), pp. 1-28, August 2004.
            - Inderjit Dhillon and Beresford Parlett: 'Orthogonal Eigenvectors and
              Relative Gaps,' SIAM Journal on Matrix Analysis and Applications, Vol. 25,
              2004.  Also LAPACK Working Note 154.
            - Inderjit Dhillon: 'A new O(n^2) algorithm for the symmetric
              tridiagonal eigenvalue/eigenvector problem',
              Computer Science Division Technical Report No. UCB/CSD-97-971,
              UC Berkeley, May 1997.

            Note 1 : ZHEEVR_2STAGE calls ZSTEMR when the full spectrum is requested
            on machines which conform to the ieee-754 floating point standard.
            ZHEEVR_2STAGE calls DSTEBZ and ZSTEIN on non-ieee machines and
            when partial spectrum requests are made.

            Normal execution of ZSTEMR may create NaNs and infinities and
            hence may abort due to a floating point exception in environments
            which do not handle NaNs and infinities in the ieee standard default
            manner.

       <b>Parameters</b>
           <u>JOBZ</u>

                     JOBZ is CHARACTER*1
                     = 'N':  Compute eigenvalues only;
                     = 'V':  Compute eigenvalues and eigenvectors.
                             Not available in this release.

           <u>RANGE</u>

                     RANGE is CHARACTER*1
                     = 'A': all eigenvalues will be found.
                     = 'V': all eigenvalues in the half-open interval (VL,VU]
                            will be found.
                     = 'I': the IL-th through IU-th eigenvalues will be found.
                     For RANGE = 'V' or 'I' and IU - IL &lt; N - 1, DSTEBZ and
                     ZSTEIN are called

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA, N)
                     On entry, the Hermitian matrix A.  If UPLO = 'U', the
                     leading N-by-N upper triangular part of A contains the
                     upper triangular part of the matrix A.  If UPLO = 'L',
                     the leading N-by-N lower triangular part of A contains
                     the lower triangular part of the matrix A.
                     On exit, the lower triangle (if UPLO='L') or the upper
                     triangle (if UPLO='U') of A, including the diagonal, is
                     destroyed.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>VL</u>

                     VL is DOUBLE PRECISION
                     If RANGE='V', the lower bound of the interval to
                     be searched for eigenvalues. VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>VU</u>

                     VU is DOUBLE PRECISION
                     If RANGE='V', the upper bound of the interval to
                     be searched for eigenvalues. VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>IL</u>

                     IL is INTEGER
                     If RANGE='I', the index of the
                     smallest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>IU</u>

                     IU is INTEGER
                     If RANGE='I', the index of the
                     largest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>ABSTOL</u>

                     ABSTOL is DOUBLE PRECISION
                     The absolute error tolerance for the eigenvalues.
                     An approximate eigenvalue is accepted as converged
                     when it is determined to lie in an interval [a,b]
                     of width less than or equal to

                             ABSTOL + EPS *   max( |a|,|b| ) ,

                     where EPS is the machine precision.  If ABSTOL is less than
                     or equal to zero, then  EPS*|T|  will be used in its place,
                     where |T| is the 1-norm of the tridiagonal matrix obtained
                     by reducing A to tridiagonal form.

                     See 'Computing Small Singular Values of Bidiagonal Matrices
                     with Guaranteed High Relative Accuracy,' by Demmel and
                     Kahan, LAPACK Working Note #3.

                     If high relative accuracy is important, set ABSTOL to
                     DLAMCH( 'Safe minimum' ).  Doing so will guarantee that
                     eigenvalues are computed to high relative accuracy when
                     possible in future releases.  The current code does not
                     make any guarantees about high relative accuracy, but
                     future releases will. See J. Barlow and J. Demmel,
                     'Computing Accurate Eigensystems of Scaled Diagonally
                     Dominant Matrices', LAPACK Working Note #7, for a discussion
                     of which matrices define their eigenvalues to high relative
                     accuracy.

           <u>M</u>

                     M is INTEGER
                     The total number of eigenvalues found.  0 &lt;= M &lt;= N.
                     If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

           <u>W</u>

                     W is DOUBLE PRECISION array, dimension (N)
                     The first M elements contain the selected eigenvalues in
                     ascending order.

           <u>Z</u>

                     Z is COMPLEX*16 array, dimension (LDZ, max(1,M))
                     If JOBZ = 'V', then if INFO = 0, the first M columns of Z
                     contain the orthonormal eigenvectors of the matrix A
                     corresponding to the selected eigenvalues, with the i-th
                     column of Z holding the eigenvector associated with W(i).
                     If JOBZ = 'N', then Z is not referenced.
                     Note: the user must ensure that at least max(1,M) columns are
                     supplied in the array Z; if RANGE = 'V', the exact value of M
                     is not known in advance and an upper bound must be used.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1, and if
                     JOBZ = 'V', LDZ &gt;= max(1,N).

           <u>ISUPPZ</u>

                     ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )
                     The support of the eigenvectors in Z, i.e., the indices
                     indicating the nonzero elements in Z. The i-th eigenvector
                     is nonzero only in elements ISUPPZ( 2*i-1 ) through
                     ISUPPZ( 2*i ). This is an output of ZSTEMR (tridiagonal
                     matrix). The support of the eigenvectors of A is typically
                     1:N because of the unitary transformations applied by ZUNMTR.
                     Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If N &lt;= 1,               LWORK must be at least 1.
                     If JOBZ = 'N' and N &gt; 1, LWORK must be queried.
                                              LWORK = MAX(1, 26*N, dimension) where
                                              dimension = max(stage1,stage2) + (KD+1)*N + N
                                                        = N*KD + N*max(KD+1,FACTOPTNB)
                                                          + max(2*KD*KD, KD*NTHREADS)
                                                          + (KD+1)*N + N
                                              where KD is the blocking size of the reduction,
                                              FACTOPTNB is the blocking used by the QR or LQ
                                              algorithm, usually FACTOPTNB=128 is a good choice
                                              NTHREADS is the number of threads used when
                                              openMP compilation is enabled, otherwise =1.
                     If JOBZ = 'V' and N &gt; 1, LWORK must be queried. Not yet available

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal sizes of the WORK, RWORK and
                     IWORK arrays, returns these values as the first entries of
                     the WORK, RWORK and IWORK arrays, and no error message
                     related to LWORK or LRWORK or LIWORK is issued by XERBLA.

           <u>RWORK</u>

                     RWORK is DOUBLE PRECISION array, dimension (MAX(1,LRWORK))
                     On exit, if INFO = 0, <a href="../man1/RWORK.1.html">RWORK</a>(1) returns the optimal
                     (and minimal) LRWORK.

           <u>LRWORK</u>

                     LRWORK is INTEGER
                     The length of the array RWORK.
                     If N &lt;= 1, LRWORK &gt;= 1, else LRWORK &gt;= 24*N.

                     If LRWORK = -1, then a workspace query is assumed; the
                     routine only calculates the optimal sizes of the WORK, RWORK
                     and IWORK arrays, returns these values as the first entries
                     of the WORK, RWORK and IWORK arrays, and no error message
                     related to LWORK or LRWORK or LIWORK is issued by XERBLA.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (MAX(1,LIWORK))
                     On exit, if INFO = 0, <a href="../man1/IWORK.1.html">IWORK</a>(1) returns the optimal
                     (and minimal) LIWORK.

           <u>LIWORK</u>

                     LIWORK is INTEGER
                     The dimension of the array IWORK.
                     If N &lt;= 1, LIWORK &gt;= 1, else LIWORK &gt;= 10*N.

                     If LIWORK = -1, then a workspace query is assumed; the
                     routine only calculates the optimal sizes of the WORK, RWORK
                     and IWORK arrays, returns these values as the first entries
                     of the WORK, RWORK and IWORK arrays, and no error message
                     related to LWORK or LRWORK or LIWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  Internal error

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>

           Inderjit Dhillon, IBM Almaden, USA \n
           Osni Marques, LBNL/NERSC, USA \n
           Ken Stanley, Computer Science Division, University of
             California at Berkeley, USA \n
           Jason Riedy, Computer Science Division, University of
             California at Berkeley, USA \n

       <b>Further</b> <b>Details:</b>

             All details about the 2stage techniques are available in:

             Azzam Haidar, Hatem Ltaief, and Jack Dongarra.
             Parallel reduction to condensed forms for symmetric eigenvalue problems
             using aggregated fine-grained and memory-aware kernels. In Proceedings
             of 2011 International Conference for High Performance Computing,
             Networking, Storage and Analysis (SC '11), New York, NY, USA,
             Article 8 , 11 pages.
             <a href="http://doi.acm.org/10.1145/2063384.2063394">http://doi.acm.org/10.1145/2063384.2063394</a>

             A. Haidar, J. Kurzak, P. Luszczek, 2013.
             An improved parallel singular value algorithm and its implementation
             for multicore hardware, In Proceedings of 2013 International Conference
             for High Performance Computing, Networking, Storage and Analysis (SC '13).
             Denver, Colorado, USA, 2013.
             Article 90, 12 pages.
             <a href="http://doi.acm.org/10.1145/2503210.2503292">http://doi.acm.org/10.1145/2503210.2503292</a>

             A. Haidar, R. Solca, S. Tomov, T. Schulthess and J. Dongarra.
             A novel hybrid CPU-GPU generalized eigensolver for electronic structure
             calculations based on fine-grained memory aware tasks.
             International Journal of High Performance Computing Applications.
             Volume 28 Issue 2, Pages 196-209, May 2014.
             <a href="http://hpc.sagepub.com/content/28/2/196">http://hpc.sagepub.com/content/28/2/196</a>

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                               Thu Aug 7 2025 17:26:25                             <u><a href="../man3/heevr_2stage.3.html">heevr_2stage</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>