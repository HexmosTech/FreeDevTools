<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pt::ast - Abstract Syntax Tree Serialization</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pt::ast - Abstract Syntax Tree Serialization

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>pt::ast</b> <b>?1.2?</b>

       <b>::pt::ast</b> <b>verify</b> <u>serial</u> ?<u>canonvar</u>?

       <b>::pt::ast</b> <b>verify-as-canonical</b> <u>serial</u>

       <b>::pt::ast</b> <b>canonicalize</b> <u>serial</u>

       <b>::pt::ast</b> <b>print</b> <u>serial</u>

       <b>::pt::ast</b> <b>bottomup</b> <u>cmdprefix</u> <u>ast</u>

       <b>cmdprefix</b> <u>ast</u>

       <b>::pt::ast</b> <b>topdown</b> <u>cmdprefix</u> <u>pe</u>

       <b>::pt::ast</b> <b>equal</b> <u>seriala</u> <u>serialb</u>

       <b>::pt::ast</b> <b>new0</b> <u>s</u> <u>loc</u> ?<u>child</u>...?

       <b>::pt::ast</b> <b>new</b> <u>s</u> <u>start</u> <u>end</u> ?<u>child</u>...?

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Are  you lost ?  Do you have trouble understanding this document ?  In that case please read the overview
       provided by the <u>Introduction</u> <u>to</u> <u>Parser</u> <u>Tools</u>. This document is the entrypoint to  the  whole  system  the
       current package is a part of.

       This package provides commands to work with the serializations of abstract syntax trees as managed by the
       Parser Tools, and specified in section <b>AST</b> <b>serialization</b> <b>format</b>.

       This is a supporting package in the Core Layer of Parser Tools.

       IMAGE: arch_core_support

</pre><h4><b>API</b></h4><pre>
       <b>::pt::ast</b> <b>verify</b> <u>serial</u> ?<u>canonvar</u>?
              This  command  verifies  that the content of <u>serial</u> is a valid serialization of an abstract syntax
              tree and will throw an error if that is not the case. The result  of  the  command  is  the  empty
              string.

              If  the  argument <u>canonvar</u> is specified it is interpreted as the name of a variable in the calling
              context. This variable will be written to if and only if <u>serial</u> is a valid regular  serialization.
              Its  value  will  be a boolean, with <b>True</b> indicating that the serialization is not only valid, but
              also <u>canonical</u>. <b>False</b> will be written for a valid, but non-canonical serialization.

              For the specification of serializations see the section <b>AST</b> <b>serialization</b> <b>format</b>.

       <b>::pt::ast</b> <b>verify-as-canonical</b> <u>serial</u>
              This command verifies that the content of <u>serial</u> is a valid <u>canonical</u> serialization of an abstract
              syntax tree and will throw an error if that is not the case. The result  of  the  command  is  the
              empty string.

              For the specification of canonical serializations see the section <b>AST</b> <b>serialization</b> <b>format</b>.

       <b>::pt::ast</b> <b>canonicalize</b> <u>serial</u>
              This  command  assumes  that the content of <u>serial</u> is a valid <u>regular</u> serialization of an abstract
              syntax and will throw an error if that is not the case.

              It will then convert the input into the <u>canonical</u> serialization of the contained tree  and  return
              it as its result. If the input is already canonical it will be returned unchanged.

              For  the  specification  of regular and canonical serializations see the section <b>AST</b> <b>serialization</b>
              <b>format</b>.

       <b>::pt::ast</b> <b>print</b> <u>serial</u>
              This command assumes that the argument <u>serial</u> contains a valid serialization of an abstract syntax
              tree and returns a string containing that tree in a human readable form.

              The exact format of this form is not specified and cannot  be  relied  on  for  parsing  or  other
              machine-based activities.

              For the specification of serializations see the section <b>AST</b> <b>serialization</b> <b>format</b>.

       <b>::pt::ast</b> <b>bottomup</b> <u>cmdprefix</u> <u>ast</u>
              This  command  walks  the  abstract  syntax  tree <u>ast</u> from the bottom up to the root, invoking the
              command prefix <u>cmdprefix</u> for each node. This implies that the children of a  node  N  are  handled
              before N.

              The command prefix has the signature

              <b>cmdprefix</b> <u>ast</u>
                     I.e. it is invoked with the ast node the walk is currently at.

                     The  result  returned  by  the  command  prefix replaces <u>ast</u> in the node it was a child of,
                     allowing transformations of the tree.

                     This also means that for all inner node the contents  of  the  children  elements  are  the
                     results of the command prefix invoked for the children of this node.

       <b>::pt::ast</b> <b>topdown</b> <u>cmdprefix</u> <u>pe</u>
              This  command  walks  the  abstract syntax tree <u>ast</u> from the root down to the leaves, invoking the
              command prefix <u>cmdprefix</u> for each node. This implies that the children of a  node  N  are  handled
              after N.

              The command prefix has the same signature as for <b>bottomup</b>, see above.

              The result returned by the command prefix is <u>ignored</u>.

       <b>::pt::ast</b> <b>equal</b> <u>seriala</u> <u>serialb</u>
              This  command tests the two sbstract syntax trees <u>seriala</u> and <u>serialb</u> for structural equality. The
              result of the command is a boolean value. It will be set to <b>true</b> if the trees are  identical,  and
              <b>false</b> otherwise.

              String equality is usable only if we can assume that the two trees are pure Tcl lists.

       <b>::pt::ast</b> <b>new0</b> <u>s</u> <u>loc</u> ?<u>child</u>...?
              This  command  command constructs the ast for a nonterminal node refering refering to the symbol <u>s</u>
              at position <u>loc</u> in the input, and the set of child nodes <u>child</u> ..., from left  right.  The  latter
              may  be  empty. The constructed node is returned as the result of the command. The end position is
              <u>loc</u>-1, i.e. one character before the start. This type of node is  possible  for  rules  containing
              optional parts.

       <b>::pt::ast</b> <b>new</b> <u>s</u> <u>start</u> <u>end</u> ?<u>child</u>...?
              This  command  command constructs the ast for a nonterminal node refering to the symbol <u>s</u> covering
              the range of positions <u>start</u> to <u>end</u> in the input, and the set of child nodes <u>child</u> ..., from  left
              right. The latter may be empty. The constructed node is returned as the result of the command.

</pre><h4><b>AST</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here  we  specify  the  format  used  by  the  Parser  Tools to serialize Abstract Syntax Trees (ASTs) as
       immutable values for transport, comparison, etc.

       Each node in an AST represents a nonterminal symbol of a grammar, and the range of  tokens/characters  in
       the  input  covered  by  it.  ASTs  do not contain terminal symbols, i.e. tokens/characters. These can be
       recovered from the input given a symbol's location.

       We distinguish between <u>regular</u> and <u>canonical</u> serializations.  While a tree may have more than one regular
       serialization only exactly one of them will be <u>canonical</u>.

       Regular serialization

              [1]    The serialization of any AST is the serialization of its root node.

              [2]    The serialization of any node is a Tcl list containing at least three elements.

                     [1]    The first element is the name of the nonterminal symbol stored in the node.

                     [2]    The second and third element are the locations of the first and last  token  in  the
                            token stream the node represents (covers).

                            [1]    Locations  are provided as non-negative integer offsets from the beginning of
                                   the token stream, with the first token found in the stream located at  offset
                                   0 (zero).

                            [2]    The end location has to be equal to or larger than the start location.

                     [3]    All  elements  after  the  first three represent the children of the node, which are
                            themselves nodes. This means that the serializations of nodes without children, i.e.
                            leaf nodes, have exactly three elements.  The children are stored in the  list  with
                            the leftmost child first, and the rightmost child last.

       Canonical serialization
              The canonical serialization of an abstract syntax tree has the format as specified in the previous
              item,  and  then  additionally satisfies the constraints below, which make it unique among all the
              possible serializations of this tree.

              [1]    The string representation of the value is the canonical representation of a pure Tcl  list.
                     I.e. it does not contain superfluous whitespace.

   <b>EXAMPLE</b>
       Assuming the parsing expression grammar below

              PEG calculator (Expression)
                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'       ;
                  Sign       &lt;- '-' / '+'                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- '*' / '/'                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- '+'/'-'                                       ;
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

       and the input string

               120+5
       then a parser should deliver the abstract syntax tree below (except for whitespace)

              set ast {Expression 0 4
                  {Factor 0 4
                      {Term 0 2
                          {Number 0 2
                              {Digit 0 0}
                              {Digit 1 1}
                              {Digit 2 2}
                          }
                      }
                      {AddOp 3 3}
                      {Term 4 4
                          {Number 4 4
                              {Digit 4 4}
                          }
                      }
                  }
              }

       Or, more graphical

       .nf  +-  Digit  0  0  |  1  |             |  +-  Term  0  2  ---  Number  0  2  -+-  Digit  1  1  |  2  |
       |            | |                           +- Digit 2 2 |  0  |                                         |
       Expression    0    4   ---   Factor   0   4   -+-----------------------------   AddOp   3   3   |   +   |
       | +- Term 4 4 --- Number 4 4 --- Digit 4 4 | 5 .fi

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category <u>pt</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       EBNF,  LL(k),  PEG,  TDPL,  context-free  languages,  expression,  grammar,  matching,  parser,   parsing
       expression,  parsing  expression grammar, push down automaton, recursive descent, state, top-down parsing
       languages, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Parsing and Grammars

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 1.2                                         <u>pt::<a href="../man3tcl/ast.3tcl.html">ast</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>