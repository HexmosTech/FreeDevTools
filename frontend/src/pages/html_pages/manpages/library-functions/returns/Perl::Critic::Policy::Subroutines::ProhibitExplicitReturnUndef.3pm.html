<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perl::Critic::Policy::Subroutines::ProhibitExplicitReturnUndef - Return failure with bare "return"</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libperl-critic-perl">libperl-critic-perl_1.156-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Perl::Critic::Policy::Subroutines::ProhibitExplicitReturnUndef - Return failure with bare "return"
       instead of "return undef".

</pre><h4><b>AFFILIATION</b></h4><pre>
       This Policy is part of the core Perl::Critic distribution.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Returning "undef" upon failure from a subroutine is pretty common.  But if the subroutine is called in
       list context, an explicit "return undef;" statement will return a one-element list containing "(undef)".
       Now if that list is subsequently put in a boolean context to test for failure, then it evaluates to true.
       But you probably wanted it to be false.

         sub read_file {
             my $file = shift;
             -f $file || return undef;  #file doesn't exist!

             #Continue reading file...
         }

         #and later...

         if ( my @data = read_file($filename) ){

             # if $filename doesn't exist,
             # @data will be (undef),
             # but I'll still be in here!

             process(@data);
         }
         else{

             # This is my error handling code.
             # I probably want to be in here
             # if $filename doesn't exist.

             die "$filename not found";
         }

       The solution is to just use a bare "return" statement whenever you want to return failure.  In list
       context, Perl will then give you an empty list (which is false), and "undef" in scalar context (which is
       also false).

         sub read_file {
             my $file = shift;
             -f $file || return;  #DWIM!

             #Continue reading file...
         }

</pre><h4><b>CONFIGURATION</b></h4><pre>
       This Policy is not configurable except for the standard options.

</pre><h4><b>NOTES</b></h4><pre>
       You can fool this policy pretty easily by hiding "undef" in a boolean expression.  But don't bother
       trying.  In fact, using return values to indicate failure is pretty poor technique anyway.  Consider
       using "die" or "croak" with "eval", or the Error module for a much more robust exception-handling model.
       Conway has a real nice discussion on error handling in chapter 13 of PBP.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       There's a discussion of the appropriateness of this policy at
       &lt;<a href="http://perlmonks.org/index.pl">http://perlmonks.org/index.pl</a>?node_id=741847&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       Jeffrey Ryan Thalhammer &lt;<a href="mailto:jeff@imaginative-software.com">jeff@imaginative-software.com</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.

       This program is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.  The full text of this license can be found in the LICENSE file included with this module.

perl v5.40.0                                       2024-10-28             <u>Perl::Critic::<a href="../man3pm/P...icitReturnUndef.3pm.html">P...icitReturnUndef</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>