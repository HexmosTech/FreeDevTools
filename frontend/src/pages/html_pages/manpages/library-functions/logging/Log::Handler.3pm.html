<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log::Handler - Log messages to several outputs.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblog-handler-perl">liblog-handler-perl_0.90-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Log::Handler - Log messages to several outputs.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Log::Handler;

           my $log = Log::Handler-&gt;new();

           $log-&gt;add(
               file =&gt; {
                   filename =&gt; "file.log",
                   maxlevel =&gt; "debug",
                   minlevel =&gt; "warning",
               }
           );

           $log-&gt;warning("message");

       Or

           use Log::Handler;

           my $log = Log::Handler-&gt;new(
               screen =&gt; {
                   log_to   =&gt; "STDOUT",
                   maxlevel =&gt; "debug",
                   minlevel =&gt; "debug",
                   message_layout =&gt; "%T [%L] %m (%C)",
               },
               screen =&gt; {
                   log_to   =&gt; "STDOUT",
                   maxlevel =&gt; "info",
                   minlevel =&gt; "notice",
               },
               screen =&gt; {
                   log_to   =&gt; "STDERR",
                   maxlevel =&gt; "warning",
                   minlevel =&gt; "emergency",
               },
           );

       Or

           use Log::Handler;

           my $log = Log::Handler-&gt;new();

           $log-&gt;config( config =&gt; "logger.conf" );

           # and maybe later

           $log-&gt;reload( config =&gt; "logger.conf" );

       Or

           # create a application wide logger
           package MyApp;
           use Log::Handler;
           my $log = Log::Handler-&gt;create_logger("myapp");
           $log-&gt;add(screen =&gt; { maxlevel =&gt; "info" });
           $log-&gt;info("info message");

           # get logger with get_logger()
           package MyApp::Admin;
           use Log::Handler;
           my $log = Log::Handler-&gt;get_logger("myapp");
           $log-&gt;info("info message from MyApp::Admin");

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The "Log::Handler" is a object oriented handler for logging, tracing and debugging. It is very easy to
       use and provides a simple interface for multiple output objects with lots of configuration parameters.
       You can easily filter the amount of logged information on a per-output base, define priorities, create
       patterns to format the messages and reload the complete logging machine.

       See the documentation for details.

</pre><h4><b>IMPORTANT</b> <b>NOTES</b></h4><pre>
       Note that the default for option "newline" is now set to TRUE and newlines will be appended automatically
       to each message if no newline exists.

       A long time I thought about this serious change and have come to the decision to change it.

       The default for option "mode" from Log::Handler::Output::File is now "append" and not "excl" anymore.

       The methods "reload()" and "validate()" are new since version 0.62.  I tested it with Screen.pm, File.pm
       and DBI.pm and it runs fine.  If you find bugs then open a bug report please :-)

</pre><h4><b>LOG</b> <b>LEVELS</b></h4><pre>
       There are eigth levels available:

           7   debug
           6   info
           5   notice
           4   warning, warn
           3   error, err
           2   critical, crit
           1   alert
           0   emergency, emerg

       "debug" is the highest and "emergency" is the lowest level.

       Level "debug" is the highest level because it basically says to log every peep.

</pre><h4><b>LOG</b> <b>LEVEL</b> <b>METHODS</b></h4><pre>
   <b>Level</b> <b>methods</b>
       <b>debug()</b>
       <b>info()</b>
       <b>notice()</b>
       <b>warning()</b>, <b>warn()</b>
       <b>error()</b>, <b>err()</b>
       <b>critical()</b>, <b>crit()</b>
       <b>alert()</b>
       <b>emergency()</b>, <b>emerg()</b>

       The call of a log level method is very simple:

           $log-&gt;info("Hello World! How are you?");

       Or maybe:

           $log-&gt;info("Hello World!", "How are you?");

       Both calls would log - if level INFO is active:

           Feb 01 12:56:31 [INFO] Hello World! How are you?

   <b>is_*</b> <b>methods</b>
       <b>is_debug()</b>
       <b>is_info()</b>
       <b>is_notice()</b>
       <b>is_warning()</b>, <b>is_warn()</b>
       <b>is_error()</b>, <b>is_err()</b>
       <b>is_critical()</b>, <b>is_crit()</b>
       <b>is_alert()</b>
       <b>is_emergency()</b>, <b>is_emerg()</b>

       These twelve methods could be very useful if you want to kwow if the current level would log the message.
       All  methods returns TRUE if the current set of "minlevel" and "maxlevel" would log the message and FALSE
       if not.

</pre><h4><b>SPECIAL</b> <b>LOG</b> <b>METHODS</b></h4><pre>
       <b>fatal</b>, <b>is_fatal</b>
       <b>trace</b>
       <b>dump</b>
       <b>die</b>
       <b>log</b>

       For a full list take a look into the documentation of Log::Handler::Levels.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new()</b>
       Call "new()" to create a new log handler object.

           my $log = Log::Handler-&gt;new();

   <b>add()</b>
       Call "add()" to add a new output object.

       The method expects 2 parts of options; the options for the handler and the options for the output  module
       you want to use. The output modules got it's own documentation for all options.

       Example:

           use Log::Handler;

           my $log = Log::Handler-&gt;new();

           $log-&gt;add(

               # Add "file output"
               file =&gt; {

                   # handler options (see Log::Handler)
                   timeformat      =&gt; "%Y/%m/%d %H:%M:%S",
                   message_layout  =&gt; "%T [%L] %S: %m",
                   maxlevel        =&gt; "debug",
                   minlevel        =&gt; "emergency",
                   die_on_errors   =&gt; 1,
                   debug_trace     =&gt; 0,
                   debug_mode      =&gt; 2,
                   debug_skip      =&gt; 0,

                   # file options (see Log::Handler::Output::File)
                   filename        =&gt; "file.log",
                   filelock        =&gt; 1,
                   fileopen        =&gt; 1,
                   reopen          =&gt; 1,
                   autoflush       =&gt; 1,
                   permissions     =&gt; "0660",
                   utf8            =&gt; 1,

               }
           );

       Take a look to Log::Handler::Examples for more examples.

       The following options are possible for the handler:

       <b>maxlevel</b> and <b>minlevel</b>
           With these options it's possible to set the log levels for your program.

           Example:

               maxlevel =&gt; "error"
               minlevel =&gt; "emergency"

               # or

               maxlevel =&gt; "err"
               minlevel =&gt; "emerg"

               # or

               maxlevel =&gt; 3
               minlevel =&gt; 0

           It's  possible  to  set  the  log level as string or as number. The default setting for "maxlevel" is
           "warning" and the default setting for "minlevel" is "emergency".

           Example: If "maxlevel" is set to "warning" and "minlevel" to "emergency" then the  levels  "warning",
           "error", "critical", "alert" and "emergency" would be logged.

           You can set both to 8 or "nothing" if you want to disable the logging machine.

       <b>timeformat</b>
           The  option  "timeformat"  is used to set the format for the placeholder %T.  The string is converted
           with "POSIX::strftime". The default format is set to "%b %d %H:%M:%S" and looks like

               Feb 01 12:56:31

           If you would set the format to "%Y/%m/%d %H:%M:%S" it would looks like

               2007/02/01 12:56:31

       <b>dateformat</b>
           This options works like "timeformat". You can set a format that is used for the placeholder %D.  It's
           just useful if you want to split the date and time:

               $log-&gt;add(file =&gt; {
                   filename       =&gt; "file.log",
                   dateformat     =&gt; "%Y-%m-%d",
                   timeformat     =&gt; "%H:%M:%S",
                   message_layout =&gt; "%D %T %L %m",
               });

               $log-&gt;error("an error here");

           This looks like

               2007-02-01 12:56:31 ERROR an error here

           This option is not used by default.

       <b>newline</b>
           "newline"  is  a very helpful option. It let the logger appends a newline to the message if a newline
           doesn't exist.

               0 - do nothing
               1 - append a newline if not exist (default)

           Example:

               $log-&gt;add(
                   screen =&gt; {
                       newline  =&gt; 1,
                       maxlevel =&gt; "info",
                   }
               );

               $log-&gt;info("message\n");
               $log-&gt;info("message");

           In both cases the message would be logged with a newline at the end.

       <b>message_layout</b>
           With this option it's possible to create your own  message  layout  with  different  placeholders  in
           "printf()" style. The available placeholders are:

               %L   Log level
               %T   Time or full timestamp (option timeformat)
               %D   Date (option dateformat)
               %P   PID
               %H   Hostname
               %U   User name
               %G   Group name
               %N   Newline
               %S   Program name
               %C   Caller - filename and line number
               %p   Caller - package name
               %f   Caller - file name
               %l   Caller - line number
               %s   Caller - subroutine name
               %r   Runtime in seconds since program start
               %t   Time measurement - replaced with the time since the last call of $log-&gt;$level
               %m   Message
               %%   Percent

           The default message layout is set to "%T [%L] %m".

           As example the following code

               $log-&gt;alert("foo bar");

           would log

               Feb 01 12:56:31 [ALERT] foo bar

           If you set "message_layout" to

               message_layout =&gt; "%T foo %L bar %m (%C)"

           and call

               $log-&gt;info("baz");

           then it would log

               Feb 01 12:56:31 foo INFO bar baz (script.pl, line 40)

           Traces will be appended after the complete message.

           You can create your own placeholders with the method "set_pattern()".

       <b>message_pattern</b>
           This  option is just useful if you want to forward messages to output modules that needs the parts of
           a message as a hash reference - as example  Log::Handler::Output::Forward,  Log::Handler::Output::DBI
           or Log::Handler::Output::Screen.

           The option expects a list of placeholders:

               # as a array reference
               message_pattern =&gt; [ qw/%T %L %H %m/ ]

               # or as a string
               message_pattern =&gt; "%T %L %H %m"

           The patterns will be replaced with real names as hash keys.

               %L   level
               %T   time
               %D   date
               %P   pid
               %H   hostname
               %U   user
               %G   group
               %N   newline
               %r   runtime
               %C   caller
               %p   package
               %f   filename
               %l   line
               %s   subroutine
               %S   progname
               %t   mtime
               %m   message

           Here a full code example:

               use Log::Handler;

               my $log = Log::Handler-&gt;new();

               $log-&gt;add(forward =&gt; {
                   forward_to      =&gt; \&amp;my_func,
                   message_pattern =&gt; [ qw/%T %L %H %m/ ],
                   message_layout  =&gt; "%m",
                   maxlevel        =&gt; "info",
               });

               $log-&gt;info("a forwarded message");

               # now you can access it

               sub my_func {
                   my $msg = shift;
                   print "Timestamp: $msg-&gt;{time}\n";
                   print "Level:     $msg-&gt;{level}\n";
                   print "Hostname:  $msg-&gt;{hostname}\n";
                   print "Message:   $msg-&gt;{message}\n";
               }

       <b>prepare_message</b>
           "prepare_message"  is useful if you want to do something with the message before it will be logged...
           maybe you want to create your own layout because message_layout doesn't meet your claim.

               $log-&gt;add(
                   screen =&gt; {
                       newline =&gt; 1,
                       message_layout  =&gt; "%m (%t)",
                       message_pattern =&gt; [ qw/%T %L %H %m/ ],
                       prepare_message =&gt; \&amp;format,
                   }
               );

               $log-&gt;error("foo");
               $log-&gt;error("bar");
               $log-&gt;error("baz");

               sub format {
                   my $m = shift;

                   $m-&gt;{message} = sprintf("%-20s %-20s %-20s %s",
                       $m-&gt;{time}, $m-&gt;{level}, $m-&gt;{hostname}, $m-&gt;{message});
               }

           The output looks like

               Mar 08 15:14:20      ERROR                h1434036             foo (0.039694)
               Mar 08 15:14:20      ERROR                h1434036             bar (0.000510)
               Mar 08 15:14:20      ERROR                h1434036             baz (0.000274)

       <b>priority</b>
           With this option you can set the priority of your output objects. This means that  messages  will  be
           logged  at  first  to the outputs with a higher priority.  If this option is not set then the default
           priority begins with 10 and will be increased +1 with each output. Example:

           We add a output with no priority

               $log-&gt;add(file =&gt; { filename =&gt; "file1.log" });

           This output gets the priority of 10. Now we add another output

               $log-&gt;add(file =&gt; { filename =&gt; "file2.log" });

           This output gets the priority of 11... and so on.

           Messages would be logged at first to the output with the priority of 10 and then to the  output  with
           the priority of 11. Now you can add another output and set the priority to 1.

               $log-&gt;add(screen =&gt; { dump =&gt; 1, priority =&gt; 1 });

           Messages would be logged now at first to the screen.

       <b>die_on_errors</b>
           Set "die_on_errors" to 0 if you don't want that the handler dies on failed write operations.

               0 - to disable it
               1 - to enable it

           If you set "die_on_errors" to 0 then you have to control it yourself.

               $log-&gt;info("info message") or die $log-&gt;errstr();

               # or Log::Handler-&gt;errstr()
               # or Log::Handler::errstr()
               # or $Log::Handler::ERRSTR

       <b>remove_on_reload</b>
           This option is set to 1 by default.

           Take a look to the description of the method "reload" for more information about this option.

       <b>filter_message</b>
           With  this  option  it's  possible  to  set a filter. If the filter is set then only messages will be
           logged that match the filter. You can pass a regexp, a code reference or a simple string. Example:

               $log-&gt;add(file =&gt; {
                   filename =&gt; "file.log",
                   maxlevel =&gt; 6,
                   filter_message =&gt; qr/log this/,
                   # or
                   # filter_message =&gt; "log this",
                   # filter_message =&gt; '^log only this$',
               });

               $log-&gt;info("log this");
               $log-&gt;info("but not that");

           If you pass your own code then you have to check the message yourself.

               $log-&gt;add(file =&gt; {
                   filename =&gt; "file.log",
                   maxlevel =&gt; 6,
                   filter_message =&gt; \&amp;my_filter
               });

               # return TRUE if you want to log the message, FALSE if not
               sub my_filter {
                   my $msg = shift;
                   $msg-&gt;{message} =~ /your filter/;
               }

           It's also possible to define a simple condition with matches. Just pass a  hash  reference  with  the
           options "matchN" and "condition". Example:

               $log-&gt;add(file =&gt; {
                   filename =&gt; "file.log",
                   maxlevel =&gt; 6,
                   filter_message =&gt; {
                       match1    =&gt; "log this",
                       match2    =&gt; qr/with that/,
                       match3    =&gt; "(?:or this|or that)",
                       condition =&gt; "(match1 &amp;&amp; match2) || match3",
                   }
               });

           NOTE that re-eval in regexes is not valid! Something like

               match1 =&gt; '(?{unlink("file.txt")})'

           would cause an error!

       <b>skip_message</b>
           This  is  the  opposite  of option "filter_message", but it's only possible to set a simple string or
           regular expression.

               $log-&gt;add(file =&gt; {
                   filename =&gt; "file.log",
                   maxlevel =&gt; 6,
                   skip =&gt; '^do not log this.+$'
               });

       <b>category</b>
           The parameter "category" works like "filter_caller" but is much easier to configure.  You can  set  a
           comma separated list of modules. As example if you would set the category to

               category =&gt; "MyApp::User"

           then all messages of MyApp::User and the submodules would be logged.

           Example:

               my $log = Log::Handler-&gt;new();

               $log-&gt;add(
                   screen =&gt; {
                       maxlevel =&gt; "info",
                       category =&gt; "MyApp::User, MyApp::Session"
                   }
               );

               package MyApp;
               $log-&gt;info(__PACKAGE__);

               package MyApp::Products;
               $log-&gt;info(__PACKAGE__);

               package MyApp::User;
               $log-&gt;info(__PACKAGE__);

               package MyApp::Users;
               $log-&gt;info(__PACKAGE__);

               package MyApp::User::Settings;
               $log-&gt;info(__PACKAGE__);

               package MyApp::Session;
               $log-&gt;info(__PACKAGE__);

               package MyApp::Session::Settings;
               $log-&gt;info(__PACKAGE__);

           The messages of "MyApp" and "MyApp::Products" would not be logged.

           The usage of categories is much faster than to filter by caller.

       <b>filter_caller</b>
           You can use this option to set a package name. Only messages from this packages will be logged.

           Example:

               my $log = Log::Handler-&gt;new();

               $log-&gt;add(screen =&gt; {
                   maxlevel =&gt; "info",
                   filter_caller  =&gt; qr/^Foo::Bar\z/,
                   # or
                   # filter_caller =&gt; "^Foo::Bar\z",
               });

               package Foo::Bar;
               $log-&gt;info("log this");

               package Foo::Baz;
               $log-&gt;info("but not that");

               1;

           This would only log the message from the package "Foo::Bar".

       <b>except_caller</b>
           This option is just the opposite of "filter_caller".

           If you want to log messages from all callers but "Foo::Bar":

               except_caller =&gt; qr/^Foo::Bar\z/

       <b>alias</b>
           You can set an alias if you want to get the output object later. Example:

               my $log = Log::Handler-&gt;new();

               $log-&gt;add(screen =&gt; {
                   maxlevel =&gt; 7,
                   alias    =&gt; "screen-out",
               });

               my $screen = $log-&gt;output("screen-out");

               $screen-&gt;log(message =&gt; "foo");

               # or in one step

               $log-&gt;output("screen-out")-&gt;log(message =&gt; "foo");

       <b>debug_trace</b>
           You  can  activate  a  debugger  that  writes "caller()" information about each active log level. The
           debugger is logging all defined values except "hints"  and  "bitmask".  Set  "debug_trace"  to  1  to
           activate the debugger.  The debugger is set to 0 by default.

       <b>debug_mode</b>
           There are two debug modes: <b><a href="../man1/line.1.html">line</a></b>(1) and <b><a href="../man2/block.2.html">block</a></b>(2) mode. The default mode is 1.

           The line mode looks like this:

               use strict;
               use warnings;
               use Log::Handler;

               my $log = Log::Handler-&gt;new()

               $log-&gt;add(file =&gt; {
                   filename    =&gt; "*STDOUT",
                   maxlevel    =&gt; "debug",
                   debug_trace =&gt; 1,
                   debug_mode  =&gt; 1
               });

               sub test1 { $log-&gt;warning() }
               sub test2 { &amp;test1; }

               &amp;test2;

           Output:

               Apr 26 12:54:11 [WARNING]
                  <a href="../man4/CALL.4.html">CALL</a>(4): <a href="../manmain/package.main.html">package</a>(main) filename(./trace.pl) <a href="../man15/line.15.html">line</a>(15) subroutine(main::test2) <a href="../man0/hasargs.0.html">hasargs</a>(0)
                  <a href="../man3/CALL.3.html">CALL</a>(3): <a href="../manmain/package.main.html">package</a>(main) filename(./trace.pl) <a href="../man13/line.13.html">line</a>(13) subroutine(main::test1) <a href="../man0/hasargs.0.html">hasargs</a>(0)
                  <a href="../man2/CALL.2.html">CALL</a>(2): <a href="../manmain/package.main.html">package</a>(main) filename(./trace.pl) <a href="../man12/line.12.html">line</a>(12) subroutine(Log::Handler::__ANON__) <a href="../man1/hasargs.1.html">hasargs</a>(1)
                  <a href="../man1/CALL.1.html">CALL</a>(1): package(Log::Handler) filename(/usr/local/share/perl/5.8.8/Log/Handler.pm) <a href="../man713/line.713.html">line</a>(713) subroutine(Log::Handler::_write) <a href="../man1/hasargs.1.html">hasargs</a>(1)
                  <a href="../man0/CALL.0.html">CALL</a>(0): package(Log::Handler) filename(/usr/local/share/perl/5.8.8/Log/Handler.pm) <a href="../man1022/line.1022.html">line</a>(1022) subroutine(Devel::Backtrace::new) <a href="../man1/hasargs.1.html">hasargs</a>(1) <a href="../man0/wantarray.0.html">wantarray</a>(0)

           The same code example but the debugger in block mode would looks like this:

                  debug_mode =&gt; 2

           Output:

              Apr 26 12:52:17 [DEBUG]
                 <a href="../man4/CALL.4.html">CALL</a>(4):
                    package     main
                    filename    ./trace.pl
                    line        15
                    subroutine  main::test2
                    hasargs     0
                 <a href="../man3/CALL.3.html">CALL</a>(3):
                    package     main
                    filename    ./trace.pl
                    line        13
                    subroutine  main::test1
                    hasargs     0
                 <a href="../man2/CALL.2.html">CALL</a>(2):
                    package     main
                    filename    ./trace.pl
                    line        12
                    subroutine  Log::Handler::__ANON__
                    hasargs     1
                 <a href="../man1/CALL.1.html">CALL</a>(1):
                    package     Log::Handler
                    filename    /usr/local/share/perl/5.8.8/Log/Handler.pm
                    line        681
                    subroutine  Log::Handler::_write
                    hasargs     1
                 <a href="../man0/CALL.0.html">CALL</a>(0):
                    package     Log::Handler
                    filename    /usr/local/share/perl/5.8.8/Log/Handler.pm
                    line        990
                    subroutine  Devel::Backtrace::new
                    hasargs     1
                    wantarray   0

       <b>debug_skip</b>
           This option let skip the "caller()" information the count of "debug_skip".

   <b>output()</b>
       Call "output($alias)" to get the output object that you added with the option "alias".

       It's possible to access a output directly:

           $log-&gt;output($alias)-&gt;log(message =&gt; "booo");

       For more information take a look to the option "alias".

   <b>flush()</b>
       Call "flush()" if you want to send flush to all outputs that can flush.

       Flush means to flush buffers and/or close and re-open outputs.

       If you want to send it only to some outputs you can pass the aliases.

           $log-&gt;flush(); # flush all
           $log-&gt;flush("foo", "bar"); # flush only foo and bar

       If option "die_on_errors" is set to 0 then you can intercept errors with:

           $log-&gt;flush or die $log-&gt;errstr;

   <b>errstr()</b>
       Call "errstr()" if you want to get the last error message. This is useful if you set "die_on_errors" to 0
       and the handler wouldn't die on failed write operations.

           use Log::Handler;

           my $log = Log::Handler-&gt;new();

           $log-&gt;add(file =&gt; {
               filename      =&gt; "file.log",
               maxlevel      =&gt; "info",
               die_on_errors =&gt; 0,
           });

           $log-&gt;info("Hello World!") or die $log-&gt;errstr;

       Or

           unless ( $log-&gt;info("Hello World!") ) {
               $error_string = $log-&gt;errstr;
               # do something with $error_string
           }

       The  exception  is  that  the handler dies in any case if the call of "new()" or "add()" fails because on
       missing or wrong settings!

   <b>config()</b>
       With this method it's possible to load your output configuration from a file.

           $log-&gt;config(config =&gt; "file.conf");

       Or

           $log-&gt;config(config =&gt; {
               file =&gt; [
                   {
                       alias    =&gt; "error_log",
                       filename =&gt; "error.log",
                       maxlevel =&gt; "warning",
                       minlevel =&gt; "emerg",
                       priority =&gt; 1
                   },
                   {
                       alias    =&gt; "common_log",
                       filename =&gt; "common.log",
                       maxlevel =&gt; "info",
                       minlevel =&gt; "emerg",
                       priority =&gt; 2
                   },
               ],
               screen =&gt; {
                   alias    =&gt; "screen",
                   maxlevel =&gt; "debug",
                   minlevel =&gt; "emerg",
                   log_to   =&gt; "STDERR",
               },
           });

       The key "default" is used here to define  default  parameters  for  all  file  outputs.  All  other  keys
       ("error_log", "common_log") are used as aliases.

       Take a look into the documentation of Log::Handler::Config for more information.

   <b>reload()</b>
       With  the  method  "reload()"  it's  possible  to  reload the logging machine. Just pass the complete new
       configuration for all outputs, it works exaclty like "config()".

       At first you should know that it's highly recommended to set a alias for each output. If you don't set  a
       alias  then  the  logger  doesn't know which output-objects to reload. If a output-objects doesn't have a
       alias then the objects will be removed and the new configuration will be added.

       Example:

       logger.conf

           &lt;file&gt;
               alias    = debug
               filename = debug.log
               maxlevel = debug
               minlevel = emerg
           &lt;/file&gt;

           &lt;file&gt;
               alias    = common
               filename = common.log
               maxlevel = info
               minlevel = emerg
           &lt;/file&gt;

       Load the configuration

           $log-&gt;config(config =&gt; "logger.conf");

       Now change the configuration in logger.conf

           &lt;file&gt;
               alias    = common
               filename = common.log
               maxlevel = notice
               minlevel = emerg
           &lt;/file&gt;

           &lt;sendmail&gt;
               alias   = sendmail
               from    = <a href="mailto:bar@foo.example">bar@foo.example</a>
               to      = <a href="mailto:foo@bar.example">foo@bar.example</a>
               subject = your subject
           &lt;/sendmail&gt;

       What happends now...

       The file-output with the alias "debug" will be removed, the file-output with the alias "common"  will  be
       reloaded and the output with the alias "sendmail" will be added.

       If  you don't want that output-objects will be removed because they were added internal, then you can set
       the option "remove_on_reload" to 0.

       Example:

           $log-&gt;config(config =&gt; "logger.conf");

           $log-&gt;add(
               forward =&gt; {
                   forward_to =&gt; \&amp;my_func,
                   remove_on_reload =&gt; 0,
               }
           );

       The forward-output is not removed after a reload.

   <b>validate()</b>
       The method "validate()" expects the same arguments like "config()" and "reload()".

       Maybe you want to validate your options before you pass them to "config()" or "reload()".

       Example:

           my $log = Log::Handler-&gt;new();

           $log-&gt;config( config =&gt; \%config );

           # and maybe later

           if ( $log-&gt;validate( config =&gt; \%new_config ) ) {
               $log-&gt;reload( config =&gt; \%new_config );
           } else {
               warn "unable to reload configuration";
               warn $log-&gt;errstr;
           }

   <b>set_pattern()</b>
       With this option you can set your own placeholders. Example:

           $log-&gt;set_pattern("%X", "key_name", sub { "value" });

           # or

           $log-&gt;set_pattern("%X", "key_name", "value");

       Then you can use this pattern in your message layout:

           $log-&gt;add(file =&gt; {
               filename        =&gt; "file.log",
               message_layout  =&gt; "%X %m%N",
           });

       Or use it with "message_pattern":

           sub func {
               my $m = shift;
               print "$m-&gt;{key_name} $m-&gt;{message}\n";
           }

           $log-&gt;add(forward =&gt; {
               forward_to      =&gt; \&amp;func,
               message_pattern =&gt; "%X %m",
           });

       Note: valid character for the key name are: "[%\w\-\.]+"

   <b>set_level()</b>
       With this method it's possible to change the log level at runtime.

       To change the log level it's necessary to use a alias - see option "alias".

           $log-&gt;set_level(
               $alias =&gt; { # option alias
                   minlevel =&gt; $new_minlevel,
                   maxlevel =&gt; $new_maxlevel,
               }
           );

   <b>set_default_param()</b>
       With this methods it's possible to overwrite the default settings for new outputs.

       Normally you would do something like

           $log-&gt;add(
               file =&gt; {
                   filename =&gt; "debug.log",
                   maxlevel =&gt; "info",
                   timeformat =&gt; "%b %d %Y %H:%M:%S",
                   message_layout =&gt; "[%T] %L %P %t %m (%C)"
               }
           );

           $log-&gt;add(
               file =&gt; {
                   filename =&gt; "error.log",
                   maxlevel =&gt; "error",
                   timeformat =&gt; "%b %d %Y %H:%M:%S",
                   message_layout =&gt; "[%T] %L %P %t %m (%C)"
               }
           );

       Now you can simplify it with

           $log-&gt;set_default_param(
               timeformat =&gt; "%b %d %Y %H:%M:%S",
               message_layout =&gt; "[%T] %L %P %t %m (%C)"
           );

           $logg-&gt;add(
               file =&gt; {
                   filename =&gt; "debug.log",
                   maxlevel =&gt; "info"
               }
           );

           $log-&gt;add(
               file =&gt; {
                   filename =&gt; "error.log",
                   maxlevel =&gt; "error"
               }
           );

   <b>create_logger()</b>
       "create_logger()" is the same like "new()" but it creates a global logger.

           my $log = Log::Handler-&gt;create_logger("myapp");

   <b>get_logger()</b>
       With "get_logger()" it's possible to get a logger that was created with "create_logger()" or with

           use Log::Handler "myapp";

       Just call

           my $log = Log::Handler-&gt;get_logger("myapp");

       If the logger does not exists then a new logger will be created and returned.

   <b>exists_logger()</b>
       With "exists_logger()" it's possible to check if a logger exists and it returns TRUE or FALSE.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Log::Handler::Examples

</pre><h4><b>BENCHMARK</b></h4><pre>
       The benchmark (examples/benchmark/benchmark.pl) runs on a Intel Core i7-920 with the following result:

           simple pattern output took     :  1 wallclock secs ( 1.26 usr +  0.01 sys =  1.27 CPU) @ 78740.16/s (n=100000)
           default pattern output took    :  2 wallclock secs ( 2.08 usr +  0.15 sys =  2.23 CPU) @ 44843.05/s (n=100000)
           complex pattern output took    :  4 wallclock secs ( 3.22 usr +  0.23 sys =  3.45 CPU) @ 28985.51/s (n=100000)
           message pattern output took    :  3 wallclock secs ( 2.72 usr +  0.16 sys =  2.88 CPU) @ 34722.22/s (n=100000)
           suppressed output took         :  0 wallclock secs ( 0.08 usr +  0.00 sys =  0.08 CPU) @ 1250000.00/s (n=100000)
           filtered caller output took    :  2 wallclock secs ( 2.10 usr +  0.68 sys =  2.78 CPU) @ 35971.22/s (n=100000)
           suppressed caller output took  :  1 wallclock secs ( 0.54 usr +  0.00 sys =  0.54 CPU) @ 185185.19/s (n=100000)
           filtered messages output took  :  3 wallclock secs ( 2.62 usr +  0.08 sys =  2.70 CPU) @ 37037.04/s (n=100000)

</pre><h4><b>EXTENSIONS</b></h4><pre>
       Send me a mail if you have questions.

</pre><h4><b>PREREQUISITES</b></h4><pre>
       Prerequisites for all modules:

           Carp
           Data::Dumper
           Fcntl
           Params::Validate
           POSIX
           Time::HiRes
           Sys::Hostname
           UNIVERSAL

       Recommended modules:

           Config::General
           Config::Properties
           DBI
           IO::Socket
           Net::SMTP
           YAML

       Just for the test suite:

           File::Spec
           Test::More

</pre><h4><b>EXPORTS</b></h4><pre>
       No exports.

</pre><h4><b>REPORT</b> <b>BUGS</b></h4><pre>
       Please report all bugs to &lt;jschulz.cpan(at)bloonix.de&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       Jonny Schulz &lt;jschulz.cpan(at)bloonix.de&gt;.

</pre><h4><b>QUESTIONS</b></h4><pre>
       Do you have any questions or ideas?

       MAIL: &lt;jschulz.cpan(at)bloonix.de&gt;

       IRC: irc.perl.org#perl

       If you send me a mail then add Log::Handler into the subject.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2007-2009 by Jonny Schulz. All rights reserved.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2022-08-28                                  <u>Log::<a href="../man3pm/Handler.3pm.html">Handler</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>