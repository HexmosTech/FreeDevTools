<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>logger - System to control logging of events.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       logger - System to control logging of events.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>logger</b> <b>?0.9.5?</b>

       <b>logger::init</b> <u>service</u>

       <b>logger::import</b> ?<b>-all</b>? ?<b>-force</b>? ?<b>-prefix</b> <u>prefix</u>? ?<b>-namespace</b> <u>namespace</u>? <u>service</u>

       <b>logger::initNamespace</b> <u>ns</u> ?<u>level</u>?

       <b>logger::services</b>

       <b>logger::enable</b> <u>level</u>

       <b>logger::disable</b> <u>level</u>

       <b>logger::setlevel</b> <u>level</u>

       <b>logger::levels</b>

       <b>logger::servicecmd</b> <u>service</u>

       <b>${log}::debug</b> <u>message</u>

       <b>${log}::info</b> <u>message</u>

       <b>${log}::notice</b> <u>message</u>

       <b>${log}::warn</b> <u>message</u>

       <b>${log}::error</b> <u>message</u>

       <b>${log}::critical</b> <u>message</u>

       <b>${log}::alert</b> <u>message</u>

       <b>${log}::emergency</b> <u>message</u>

       <b>${log}::setlevel</b> <u>level</u>

       <b>${log}::enable</b> <u>level</u>

       <b>${log}::disable</b> <u>level</u>

       <b>${log}::lvlchangeproc</b> <u>command</u>

       <b>${log}::lvlchangeproc</b>

       <b>${log}::logproc</b> <u>level</u>

       <b>${log}::logproc</b> <u>level</u> <u>command</u>

       <b>${log}::logproc</b> <u>level</u> <u>argname</u> <u>body</u>

       <b>${log}::services</b>

       <b>${log}::servicename</b>

       <b>${log}::currentloglevel</b>

       <b>${log}::delproc</b> <u>command</u>

       <b>${log}::delproc</b>

       <b>${log}::delete</b>

       <b>${log}::trace</b> <u>command</u>

       <b>${log}::trace</b> <b>on</b>

       <b>${log}::trace</b> <b>off</b>

       <b>${log}::trace</b> <b>status</b> ?procName? ?...?

       <b>${log}::trace</b> <b>add</b> <u>procName</u> ?...?

       <b>${log}::trace</b> <b>add</b> ?-ns? <u>nsName</u> ?...?

       <b>${log}::trace</b> <b>remove</b> <u>procName</u> ?...?

       <b>${log}::trace</b> <b>remove</b> ?-ns? <u>nsName</u> ?...?

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>logger</b>  package provides a flexible system for logging messages from different services, at priority
       levels, with different commands.

       To begin using the logger package, we do the following:

                  package require logger
                  set log [logger::init myservice]
                  ${log}::notice "Initialized myservice logging"

                  ... code ...

                  ${log}::notice "Ending myservice logging"
                  ${log}::delete

       In the above code, after the package is loaded, the following things happen:

       <b>logger::init</b> <u>service</u>
              Initializes the service <u>service</u> for logging.  The service names are actually Tcl namespace  names,
              so they are separated with '::'.  The service name may not be the empty string or only ':'s.  When
              a  logger  service  is  initialized,  it "inherits" properties from its parents.  For instance, if
              there were a service <u>foo</u>, and we did a <b>logger::init</b> <u>foo::bar</u> (to create a <u>bar</u>  service  underneath
              <u>foo</u>),  <u>bar</u>  would  copy the current configuration of the <u>foo</u> service, although it would of course,
              also be possible to then separately configure <u>bar</u>.  If a logger service  is  initialized  and  the
              parent does not yet exist, the parent is also created.  The new logger service is initialized with
              the default loglevel set with <b>logger::setlevel</b>.

       <b>logger::import</b> ?<b>-all</b>? ?<b>-force</b>? ?<b>-prefix</b> <u>prefix</u>? ?<b>-namespace</b> <u>namespace</u>? <u>service</u>
              Import  the  logger  service commands into the current namespace. Without the <b>-all</b> option only the
              commands corresponding to the log levels are imported. If <b>-all</b> is given, all the <b>${log}::cmd</b> style
              commands are imported. If the import would overwrite a command an error is returned and no command
              is imported. Use the <b>-force</b> option to force the import and  overwrite  existing  commands  without
              complaining.   If  the  <b>-prefix</b>  option  is given, the commands are imported with the given <u>prefix</u>
              prepended to their names.  If the <b>-namespace</b> option is given, the commands are imported  into  the
              given  namespace. If the namespace does not exist, it is created. If a namespace without a leading
              :: is given, it is interpreted as a child namespace to the current namespace.

       <b>logger::initNamespace</b> <u>ns</u> ?<u>level</u>?
              Convenience command for setting up a namespace for logging. Creates a logger service  named  after
              the  namespace  <u>ns</u> (a :: prefix is stripped), imports all the log commands into the namespace, and
              sets the default logging level, either as specified by <u>level</u>, or inherited from a service  in  the
              parent namespace, or a hardwired default, <b>warn</b>.

       <b>logger::services</b>
              Returns a list of all the available services.

       <b>logger::enable</b> <u>level</u>
              Globally  enables  logging  at and "above" the given level.  Levels are <b>debug</b>, <b>info</b>, <b>notice</b>, <b>warn</b>,
              <b>error</b>, <b>critical</b>, <b>alert</b>, <b>emergency</b>.

       <b>logger::disable</b> <u>level</u>
              Globally disables logging at and "below" the given level.  Levels are those listed above.

       <b>logger::setlevel</b> <u>level</u>
              Globally enable logging at and "above" the given  level.  Levels  are  those  listed  above.  This
              command changes the default loglevel for new loggers created with <b>logger::init</b>.

       <b>logger::levels</b>
              Returns a list of the available log levels (also listed above under <b>enable</b>).

       <b>logger::servicecmd</b> <u>service</u>
              Returns the <b>${log}</b> token created by <b>logger::init</b> for this service.

       <b>${log}::debug</b> <u>message</u>

       <b>${log}::info</b> <u>message</u>

       <b>${log}::notice</b> <u>message</u>

       <b>${log}::warn</b> <u>message</u>

       <b>${log}::error</b> <u>message</u>

       <b>${log}::critical</b> <u>message</u>

       <b>${log}::alert</b> <u>message</u>

       <b>${log}::emergency</b> <u>message</u>
              These  are  the  commands called to actually log a message about an event.  <b>${log}</b> is the variable
              obtained from <b>logger::init</b>.

       <b>${log}::setlevel</b> <u>level</u>
              Enable logging, in the service referenced by <b>${log}</b>, and its children,  at  and  above  the  level
              specified, and disable logging below it.

       <b>${log}::enable</b> <u>level</u>
              Enable  logging,  in  the  service  referenced by <b>${log}</b>, and its children, at and above the level
              specified.  Note that this does <u>not</u> disable logging below this level, so you should  probably  use
              <b>setlevel</b> instead.

       <b>${log}::disable</b> <u>level</u>
              Disable  logging,  in  the  service referenced by <b>${log}</b>, and its children, at and below the level
              specified. Note that this does <u>not</u> enable logging above this level, so  you  should  probably  use
              <b>setlevel</b>  instead.   Disabling the loglevel <b>emergency</b> switches logging off for the service and its
              children.

       <b>${log}::lvlchangeproc</b> <u>command</u>

       <b>${log}::lvlchangeproc</b>
              Set the script to call when the log instance in question changes its log level.  If called without
              a command it returns the currently registered command. The command gets  two  arguments  appended,
              the  old and the new loglevel. The callback is invoked after all changes have been done.  If child
              loggers are affected, their callbacks are called before their parents callback.

                 proc lvlcallback {old new} {
                     puts "Loglevel changed from $old to $new"
                 }
                 ${log}::lvlchangeproc lvlcallback

       <b>${log}::logproc</b> <u>level</u>

       <b>${log}::logproc</b> <u>level</u> <u>command</u>

       <b>${log}::logproc</b> <u>level</u> <u>argname</u> <u>body</u>
              This command comes in three forms - the third, older one is deprecated and  may  be  removed  from
              future  versions  of the logger package.  The current set version takes one argument, a command to
              be executed when the level is called.  The callback command takes on  argument,  the  text  to  be
              logged.  If  called  only  with  a  valid  level <b>logproc</b> returns the name of the command currently
              registered as callback command.  <b>logproc</b> specifies which command will perform the  actual  logging
              for  a  given  level.  The logger package ships with default commands for all log levels, but with
              <b>logproc</b> it is possible to replace them with custom code.  This would let you send your  logs  over
              the network, to a database, or anything else.  For example:

                  proc logtoserver {txt} {
                      variable socket
                      puts $socket "Notice: $txt"
                  }

                  ${log}::logproc notice logtoserver

              Trace  logs are slightly different: instead of a plain text argument, the argument provided to the
              logproc is a dictionary consisting of the <b>enter</b> or <b>leave</b> keyword along with another dictionary  of
              details about the trace.  These include:

              •      <b>proc</b> - Name of the procedure being traced.

              •      <b>level</b> - The stack level for the procedure invocation (from <b>info</b> <b>level</b>).

              •      <b>script</b>  -  The  name  of  the file in which the procedure is defined, or an empty string if
                     defined in interactive mode.

              •      <b>caller</b> - The name of the procedure calling the procedure being traced, or an  empty  string
                     if the procedure was called from the global scope (stack level 0).

              •      <b>procargs</b>  -  A dictionary consisting of the names of arguments to the procedure paired with
                     values given for those arguments (<b>enter</b> traces only).

              •      <b>status</b> - The Tcl return code (e.g. <b>ok</b>, <b>continue</b>, etc.) (<b>leave</b> traces only).

              •      <b>result</b> - The value returned by the procedure (<b>leave</b> traces only).

       <b>${log}::services</b>
              Returns a list of the registered logging services which are children of this service.

       <b>${log}::servicename</b>
              Returns the name of this service.

       <b>${log}::currentloglevel</b>
              Returns the currently enabled log level for this service. If no logging is enabled returns <b>none</b>.

       <b>${log}::delproc</b> <u>command</u>

       <b>${log}::delproc</b>
              Set the script to call when the log instance in question is deleted.  If called without a  command
              it returns the currently registered command.  For example:

                  ${log}::delproc [list closesock $logsock]

       <b>${log}::delete</b>
              This  command deletes a particular logging service, and its children.  You must call this to clean
              up the resources used by a service.

       <b>${log}::trace</b> <u>command</u>
              This command controls logging of enter/leave traces for  specified  procedures.   It  is  used  to
              enable  and disable tracing, query tracing status, and specify procedures are to be traced.  Trace
              handlers are unregistered when tracing is disabled.  As a result, there is not performance  impact
              to a library when tracing is disabled, just as with other log level commands.

                proc tracecmd { dict } {
                    puts $dict
                }

                set log [::logger::init example]
                ${log}::logproc trace tracecmd

                proc foo { args } {
                    puts "In foo"
                    bar 1
                    return "foo_result"
                }

                proc bar { x } {
                    puts "In bar"
                    return "bar_result"
                }

                ${log}::trace add foo bar
                ${log}::trace on

                foo

              # Output:
              enter {proc ::foo level 1 script {} caller {} procargs {args {}}}
              In foo
              enter {proc ::bar level 2 script {} caller ::foo procargs {x 1}}
              In bar
              leave {proc ::bar level 2 script {} caller ::foo status ok result bar_result}
              leave {proc ::foo level 1 script {} caller {} status ok result foo_result}

       <b>${log}::trace</b> <b>on</b>
              Turns  on  trace logging for procedures registered through the <b>trace</b> <b>add</b> command.  This is similar
              to the <b>enable</b> command for other logging levels, but allows trace logging  to  take  place  at  any
              level.   The trace logging mechanism takes advantage of the execution trace feature of Tcl 8.4 and
              later.  The <b>trace</b> <b>on</b> command will return an error if called from earlier versions of Tcl.

       <b>${log}::trace</b> <b>off</b>
              Turns off trace logging for procedures registered for trace logging through the <b>trace</b> <b>add</b> command.
              This is similar to the <b>disable</b> command for other logging levels, but allows trace logging to  take
              place  at  any  level.  Procedures are not unregistered, so logging for them can be turned back on
              with the <b>trace</b> <b>on</b> command.  There is no overhead imposed by trace registration when trace  logging
              is disabled.

       <b>${log}::trace</b> <b>status</b> ?procName? ?...?
              This  command  returns  a list of the procedures currently registered for trace logging, or a flag
              indicating whether or not a trace is registered for one or more specified procedures.

       <b>${log}::trace</b> <b>add</b> <u>procName</u> ?...?

       <b>${log}::trace</b> <b>add</b> ?-ns? <u>nsName</u> ?...?
              This command registers one or more procedures for logging of entry/exit traces.  Procedures can be
              specified via a list of procedure names or namespace names (in which case all procedure within the
              namespace are targeted by the operation).  By  default,  each  name  is  first  interpreted  as  a
              procedure name or glob-style search pattern, and if not found its interpreted as a namespace name.
              The  <u>-ns</u>  option can be used to force interpretation of all provided arguments as namespace names.
              Procedures must be defined prior to registering them for tracing through the  <b>trace</b>  <b>add</b>  command.
              Any  procedure  or  namespace  names/patterns  that  don't  match  any existing procedures will be
              silently ignored.

       <b>${log}::trace</b> <b>remove</b> <u>procName</u> ?...?

       <b>${log}::trace</b> <b>remove</b> ?-ns? <u>nsName</u> ?...?
              This command unregisters one or more procedures so that they will no  longer  have  trace  logging
              performed, with the same matching rules as that of the <b>trace</b> <b>add</b> command.

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       The  logger  package  is  implemented in such a way as to optimize (for Tcl 8.4 and newer) log procedures
       which are disabled.  They are aliased to a proc which has no body, which  is  compiled  to  a  no  op  in
       bytecode.   This  should  make the peformance hit minimal.  If you really want to pull out all the stops,
       you can replace the ${log} token in your code with the actual namespace and command (${log}::warn becomes
       ::logger::tree::myservice::warn), so that no variable lookup is  done.   This  puts  the  performance  of
       disabled logger commands very close to no logging at all.

       The  "object  orientation"  is  done  through a hierarchy of namespaces.  Using an actual object oriented
       system would probably be a better way of doing things, or at least provide for a cleaner implementation.

       The service "object orientation" is done with namespaces.

</pre><h4><b>LOGPROCS</b> <b>AND</b> <b>CALLSTACK</b></h4><pre>
       The logger package takes extra care to keep the logproc out of the call stack.  This enables logprocs  to
       execute code in the callers scope by using uplevel or linking to local variables by using upvar. This may
       fire traces with all usual side effects.

                   # Print caller and current vars in the calling proc
                   proc log_local_var {txt} {
                        set caller [info level -1]
                        set vars [uplevel 1 info vars]
                        foreach var [lsort $vars] {
                           if {[uplevel 1 [list array exists $var]] == 1} {
                             lappend val $var &lt;Array&gt;
                           } else {
                             lappend val $var [uplevel 1 [list set $var]]
                           }
                        }
                        puts "$txt"
                        puts "Caller: $caller"
                        puts "Variables in callers scope:"
                        foreach {var value} $val {
                          puts "$var = $value"
                        }
                   }

                   # install as logproc
                   ${log}::logproc debug log_local_var

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category <u>logger</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       log, log level, logger, service

</pre><h4><b>CATEGORY</b></h4><pre>
       Programming tools

tcllib                                                0.9.5                                         <u><a href="../man3tcl/logger.3tcl.html">logger</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>