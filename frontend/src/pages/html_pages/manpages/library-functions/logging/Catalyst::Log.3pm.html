<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catalyst::Log - Catalyst Log Class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcatalyst-perl">libcatalyst-perl_5.90132-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Catalyst::Log - Catalyst Log Class

</pre><h4><b>SYNOPSIS</b></h4><pre>
           $log = $c-&gt;log;
           $log-&gt;debug($message);
           $log-&gt;info($message);
           $log-&gt;warn($message);
           $log-&gt;error($message);
           $log-&gt;fatal($message);

           if ( $log-&gt;is_debug ) {
                # expensive debugging
           }

       See Catalyst.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides the default, simple logging functionality for Catalyst.  If you want something
       different set "$c-&gt;log" in your application module, e.g.:

           $c-&gt;log( MyLogger-&gt;new );

       Your logging object is expected to provide the interface described here.  Good alternatives to consider
       are Log::Log4Perl and Log::Dispatch.

       If you want to be able to log arbitrary warnings, you can do something along the lines of

           $SIG{__WARN__} = sub { MyApp-&gt;log-&gt;warn(@_); };

       however this is (a) global, (b) hairy and (c) may have unexpected side effects.  Don't say we didn't warn
       you.

</pre><h4><b>LOG</b> <b>LEVELS</b></h4><pre>
   <b>debug</b>
           $log-&gt;is_debug;
           $log-&gt;debug($message);

   <b>info</b>
           $log-&gt;is_info;
           $log-&gt;info($message);

   <b>warn</b>
           $log-&gt;is_warn;
           $log-&gt;warn($message);

   <b>error</b>
           $log-&gt;is_error;
           $log-&gt;error($message);

   <b>fatal</b>
           $log-&gt;is_fatal;
           $log-&gt;fatal($message);

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       Constructor. Defaults to enable all levels unless levels are provided in arguments.

           $log = Catalyst::Log-&gt;new;
           $log = Catalyst::Log-&gt;new( 'warn', 'error' );

   <b>level</b>
       Contains a bitmask of the currently set log levels.

   <b>levels</b>
       Set log levels

           $log-&gt;levels( 'warn', 'error', 'fatal' );

   <b>enable</b>
       Enable log levels

           $log-&gt;enable( 'warn', 'error' );

   <b>disable</b>
       Disable log levels

           $log-&gt;disable( 'warn', 'error' );

   <b>is_debug</b>
   <b>is_error</b>
   <b>is_fatal</b>
   <b>is_info</b>
   <b>is_warn</b>
       Is the log level active?

   <b>abort</b>
       Should Catalyst emit logs for this request? Will be reset at the end of each request.

       *NOTE* This method is not compatible with other log apis, so if you plan to use Log4Perl or another
       logger, you should call it like this:

           $c-&gt;log-&gt;<a href="../man1/abort.1.html">abort</a>(1) if $c-&gt;log-&gt;can('abort');

   <b>autoflush</b>
       When enabled (default), messages are written to the log immediately instead of queued until the end of
       the request.

       This option, as well as "abort", is provided for modules such as Catalyst::Plugin::Static::Simple to be
       able to programmatically suppress the output of log messages. By turning off "autoflush" (application-
       wide setting) and then setting the "abort" flag within a given request, all log messages for the given
       request will be suppressed. "abort" can still be set independently of turning off "autoflush", however.
       It just means any messages sent to the log up until that point in the request will obviously still be
       emitted, since "autoflush" means they are written in real-time.

       If you need to turn off autoflush you should do it like this (in your main app class):

           after setup_finalize =&gt; sub {
             my $c = shift;
             $c-&gt;log-&gt;<a href="../man0/autoflush.0.html">autoflush</a>(0) if $c-&gt;log-&gt;can('autoflush');
           };

   <b>_send_to_log</b>
        $log-&gt;_send_to_log( @messages );

       This protected method is what actually sends the log information to STDERR.  You may subclass this module
       and override this method to get finer control over the log output.

   <b>psgienv</b> <b>$env</b>
           $log-&gt;psgienv($env);

       NOTE: This is not meant for public consumption.

       Set the PSGI environment for this request. This ensures logs will be sent to the right place. If the
       environment has a "psgix.logger", it will be used. If not, we will send logs to "psgi.errors" if that
       exists. As a last fallback, we will send to STDERR as before.

   <b>clear_psgi</b>
       Clears the PSGI environment attributes set by "psgienv".

   <b>meta</b>
</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Catalyst.

</pre><h4><b>AUTHORS</b></h4><pre>
       Catalyst Contributors, see Catalyst.pm

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This library is free software. You can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.0                                       2024-11-15                                 <u>Catalyst::<a href="../man3pm/Log.3pm.html">Log</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>