<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>keyctl_get_security - retrieve a key's security context</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libkeyutils-dev">libkeyutils-dev_1.6.3-6ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       keyctl_get_security - retrieve a key's security context

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;keyutils.h&gt;</b>

       <b>long</b> <b>keyctl_get_security(key_serial_t</b> <u>key</u><b>,</b> <b>char</b> <b>*</b><u>buffer</u><b>,</b>
       <b>size_t</b> <u>buflen</u><b>);</b>

       <b>long</b> <b>keyctl_get_security_alloc(key_serial_t</b> <u>key</u><b>,</b> <b>char</b> <b>**_</b><u>buffer</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>keyctl_get_security</b>()  retrieves  the security context of a key as a NUL-terminated string.  This will be
       rendered in a form appropriate to the LSM in force - for instance, with SELinux, it may look like

              <b>unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</b>

       The caller must have <b>view</b> permission on a key to be able to get its security context.

       <u>buffer</u> and <u>buflen</u> specify the buffer into which the string will be placed.  If the buffer is  too  small,
       the full size of the string will be returned, and no copy will take place.

       <b>keyctl_get_security_alloc</b>()  is  similar  to  <b>keyctl_get_security</b>() except that it allocates a buffer big
       enough to hold the string and copies the string into it.  If successful,  A  pointer  to  the  buffer  is
       placed in <u>*_buffer</u>.  The caller must free the buffer.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success  <b>keyctl_get_security</b>()  returns the amount of data placed into the buffer.  If the buffer was
       too small, then the size of buffer required will be returned, but no data will be transferred.  On error,
       the value <b>-1</b> will be returned and <u>errno</u> will have been set to an appropriate error.

       On success <b>keyctl_get_security_alloc</b>() returns the amount of data in the buffer, less the NUL terminator.
       On error, the value <b>-1</b> will be returned and <u>errno</u> will have been set to an appropriate error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>ENOKEY</b> The key specified is invalid.

       <b>EKEYEXPIRED</b>
              The key specified has expired.

       <b>EKEYREVOKED</b>
              The key specified had been revoked.

       <b>EACCES</b> The key exists, but is not <b>viewable</b> by the calling process.

</pre><h4><b>LINKING</b></h4><pre>
       This is a library function that can  be  found  in  <u>libkeyutils</u>.   When  linking,  <b>-lkeyutils</b>  should  be
       specified to the linker.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/keyctl.1.html">keyctl</a></b>(1), <b><a href="../man2/add_key.2.html">add_key</a></b>(2), <b><a href="../man2/keyctl.2.html">keyctl</a></b>(2), <b><a href="../man2/request_key.2.html">request_key</a></b>(2), <b><a href="../man3/keyctl.3.html">keyctl</a></b>(3), <b><a href="../man7/keyrings.7.html">keyrings</a></b>(7), <b><a href="../man7/keyutils.7.html">keyutils</a></b>(7)

Linux                                              26 Feb 2010                            <u><a href="../man3/KEYCTL_GET_SECURITY.3.html">KEYCTL_GET_SECURITY</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>