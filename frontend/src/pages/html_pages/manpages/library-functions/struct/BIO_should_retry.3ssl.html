<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIO_should_read, BIO_should_write, BIO_should_io_special, BIO_retry_type, BIO_should_retry,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       BIO_should_read, BIO_should_write, BIO_should_io_special, BIO_retry_type, BIO_should_retry,
       BIO_get_retry_BIO, BIO_get_retry_reason, BIO_set_retry_reason - BIO retry functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/bio.h&gt;

        int BIO_should_read(BIO *b);
        int BIO_should_write(BIO *b);
        int BIO_should_io_special(iBIO *b);
        int BIO_retry_type(BIO *b);
        int BIO_should_retry(BIO *b);

        BIO *BIO_get_retry_BIO(BIO *bio, int *reason);
        int BIO_get_retry_reason(BIO *bio);
        void BIO_set_retry_reason(BIO *bio, int reason);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These functions determine why a BIO is not able to read or write data.  They will typically be called
       after a failed <b>BIO_read_ex()</b> or <b>BIO_write_ex()</b> call.

       <b>BIO_should_retry()</b> is true if the call that produced this condition should then be retried at a later
       time.

       If <b>BIO_should_retry()</b> is false then the cause is an error condition.

       <b>BIO_should_read()</b> is true if the cause of the condition is that the BIO has insufficient data to return.
       Check for readability and/or retry the last operation.

       <b>BIO_should_write()</b> is true if the cause of the condition is that the BIO has pending data to write. Check
       for writability and/or retry the last operation.

       <b>BIO_should_io_special()</b> is true if some "special" condition, that is a reason other than reading or
       writing is the cause of the condition.

       <b>BIO_retry_type()</b> returns a mask of the cause of a retry condition consisting of the values
       <b>BIO_FLAGS_READ</b>, <b>BIO_FLAGS_WRITE</b>, <b>BIO_FLAGS_IO_SPECIAL</b> though current BIO types will only set one of
       these.

       <b>BIO_get_retry_BIO()</b> determines the precise reason for the special condition, it returns the BIO that
       caused this condition and if <b>reason</b> is not NULL it contains the reason code. The meaning of the reason
       code and the action that should be taken depends on the type of BIO that resulted in this condition.

       <b>BIO_get_retry_reason()</b> returns the reason for a special condition if passed the relevant BIO, for example
       as returned by <b>BIO_get_retry_BIO()</b>.

       <b>BIO_set_retry_reason()</b> sets the retry reason for a special condition for a given BIO. This would usually
       only be called by BIO implementations.

</pre><h4><b>NOTES</b></h4><pre>
       <b>BIO_should_read()</b>, <b>BIO_should_write()</b>, <b>BIO_should_io_special()</b>, <b>BIO_retry_type()</b>, and <b>BIO_should_retry()</b>,
       are implemented as macros.

       If <b>BIO_should_retry()</b> returns false then the precise "error condition" depends on the BIO type that
       caused it and the return code of the BIO operation. For example if a call to <b>BIO_read_ex()</b> on a socket
       BIO returns 0 and <b>BIO_should_retry()</b> is false then the cause will be that the connection closed. A
       similar condition on a file BIO will mean that it has reached EOF. Some BIO types may place additional
       information on the error queue. For more details see the individual BIO type manual pages.

       If the underlying I/O structure is in a blocking mode almost all current BIO types will not request a
       retry, because the underlying I/O calls will not. If the application knows that the BIO type will never
       signal a retry then it need not call <b>BIO_should_retry()</b> after a failed BIO I/O call. This is typically
       done with file BIOs.

       SSL BIOs are the only current exception to this rule: they can request a retry even if the underlying I/O
       structure is blocking, if a handshake occurs during a call to <b>BIO_read()</b>. An application can retry the
       failed call immediately or avoid this situation by setting SSL_MODE_AUTO_RETRY on the underlying SSL
       structure.

       While an application may retry a failed non blocking call immediately this is likely to be very
       inefficient because the call will fail repeatedly until data can be processed or is available. An
       application will normally wait until the necessary condition is satisfied. How this is done depends on
       the underlying I/O structure.

       For example if the cause is ultimately a socket and <b>BIO_should_read()</b> is true then a call to <b>select()</b> may
       be made to wait until data is available and then retry the BIO operation. By combining the retry
       conditions of several non blocking BIOs in a single <b>select()</b> call it is possible to service several BIOs
       in a single thread, though the performance may be poor if SSL BIOs are present because long delays can
       occur during the initial handshake process.

       It is possible for a BIO to block indefinitely if the underlying I/O structure cannot process or return
       any data. This depends on the behaviour of the platforms I/O functions. This is often not desirable: one
       solution is to use non blocking I/O and use a timeout on the <b>select()</b> (or equivalent) call.

</pre><h4><b>BUGS</b></h4><pre>
       The OpenSSL ASN1 functions cannot gracefully deal with non blocking I/O: that is they cannot retry after
       a partial read or write. This is usually worked around by only passing the relevant data to ASN1
       functions when the entire structure can be read or written.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>BIO_should_read()</b>, <b>BIO_should_write()</b>, <b>BIO_should_io_special()</b>, and <b>BIO_should_retry()</b> return either 1 or
       0 based on the actual conditions of the <b>BIO</b>.

       <b>BIO_retry_type()</b> returns a flag combination presenting the cause of a retry condition or false if there
       is no retry condition.

       <b>BIO_get_retry_BIO()</b> returns a valid <b>BIO</b> structure.

       <b>BIO_get_retry_reason()</b> returns the reason for a special condition.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bio.7.html">bio</a></b>(7)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>BIO_get_retry_reason()</b> and <b>BIO_set_retry_reason()</b> functions were added in OpenSSL 1.1.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2000-2018 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                             <u><a href="../man3SSL/BIO_SHOULD_RETRY.3SSL.html">BIO_SHOULD_RETRY</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>