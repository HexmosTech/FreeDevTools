<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parsing - Message parsing functions [DEPRECATED]</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnetfilter-queue-doc">libnetfilter-queue-doc_1.0.5-4build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Parsing - Message parsing functions [DEPRECATED]

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       struct nfqnl_msg_packet_hdr * <b>nfq_get_msg_packet_hdr</b> (struct nfq_data *nfad)
       uint32_t <b>nfq_get_nfmark</b> (struct nfq_data *nfad)
       int <b>nfq_get_timestamp</b> (struct nfq_data *nfad, struct timeval *tv)
       uint32_t <b>nfq_get_indev</b> (struct nfq_data *nfad)
       uint32_t <b>nfq_get_physindev</b> (struct nfq_data *nfad)
       uint32_t <b>nfq_get_outdev</b> (struct nfq_data *nfad)
       uint32_t <b>nfq_get_physoutdev</b> (struct nfq_data *nfad)
       int <b>nfq_get_indev_name</b> (struct nlif_handle *nlif_handle, struct nfq_data *nfad, char *name)
       int <b>nfq_get_physindev_name</b> (struct nlif_handle *nlif_handle, struct nfq_data *nfad, char *name)
       int <b>nfq_get_outdev_name</b> (struct nlif_handle *nlif_handle, struct nfq_data *nfad, char *name)
       int <b>nfq_get_physoutdev_name</b> (struct nlif_handle *nlif_handle, struct nfq_data *nfad, char *name)
       struct nfqnl_msg_packet_hw * <b>nfq_get_packet_hw</b> (struct nfq_data *nfad)
       uint32_t <b>nfq_get_skbinfo</b> (struct nfq_data *nfad)
       int <b>nfq_get_uid</b> (struct nfq_data *nfad, uint32_t *uid)
       int <b>nfq_get_gid</b> (struct nfq_data *nfad, uint32_t *gid)
       int <b>nfq_get_secctx</b> (struct nfq_data *nfad, unsigned char **secdata)
       int <b>nfq_get_payload</b> (struct nfq_data *nfad, unsigned char **data)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>int</b> <b>nfq_get_gid</b> <b>(struct</b> <b>nfq_data</b> <b>*</b> <b>nfad,</b> <b>uint32_t</b> <b>*</b> <b>gid)</b>
       nfq_get_gid - get the GID of the user the packet belongs to

       <b>Parameters</b>
           <u>nfad</u> Netlink packet data handle passed to callback function
           <u>gid</u> Set to GID on return

       <b>Warning</b>
           If the NFQA_CFG_F_GSO flag is not set, then fragmented packets may be pushed into the queue. In this
           case, only one fragment will have the GID field set. To deal with this issue always set
           NFQA_CFG_F_GSO.

       <b>Returns</b>
           1 if there is a GID available, 0 otherwise.

       Definition at line <b>1277</b> of file <b>libnetfilter_queue.c</b>.

   <b>uint32_t</b> <b>nfq_get_indev</b> <b>(struct</b> <b>nfq_data</b> <b>*</b> <b>nfad)</b>
       nfq_get_indev - get the interface that the packet was received through

       <b>Parameters</b>
           <u>nfad</u> Netlink packet data handle passed to callback function

       <b>Returns</b>
           The index of the device the queued packet was received via. If the returned index is 0, the packet
           was locally generated or the input interface is not known (ie. POSTROUTING?).

       <b>Warning</b>
           all nfq_get_dev() functions return 0 if not set, since linux only allows ifindex &gt;= 1, see
           net/core/dev.c:2600 (in 2.6.13.1)

       Definition at line <b>1028</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_get_indev_name</b> <b>(struct</b> <b>nlif_handle</b> <b>*</b> <b>nlif_handle,</b> <b>struct</b> <b>nfq_data</b> <b>*</b> <b>nfad,</b> <b>char</b> <b>*</b> <b>name)</b>
       nfq_get_indev_name - get the name of the interface the packet was received through

       <b>Parameters</b>
           <u>nlif_handle</u> pointer to a nlif interface resolving handle
           <u>nfad</u> Netlink packet data handle passed to callback function
           <u>name</u> pointer to the buffer to receive the interface name; not more than IFNAMSIZ bytes will be copied
           to it.

       <b>Returns</b>
           -1 in case of error, &gt;0 if it succeed.

       To use a nlif_handle, You need first to call nlif_open() and to open an handler. Don't forget to store
       the result as it will be used during all your program life:

               h = nlif_open();
               if (h == NULL) {
                       perror('nlif_open');
                       exit(EXIT_FAILURE);
               }

        Once the handler is open, you need to fetch the interface table at a whole via a call to nlif_query.

               nlif_query(h);

        libnfnetlink is able to update the interface mapping when a new interface appears. To do so, you need to
       call nlif_catch() on the handler after each interface related event. The simplest way to get and treat
       event is to run a select() or poll() against the nlif file descriptor. To get this file descriptor, you
       need to use nlif_fd:

               if_fd = nlif_fd(h);

        Don't forget to close the handler when you don't need the feature anymore:

               nlif_close(h);

       Definition at line <b>1116</b> of file <b>libnetfilter_queue.c</b>.

   <b>struct</b> <b>nfqnl_msg_packet_hdr</b> <b>*</b> <b>nfq_get_msg_packet_hdr</b> <b>(struct</b> <b>nfq_data</b> <b>*</b> <b>nfad)</b>
       nfqnl_msg_packet_hdr - return the metaheader that wraps the packet

       <b>Parameters</b>
           <u>nfad</u> Netlink packet data handle passed to callback function

       <b>Returns</b>
           the netfilter queue netlink packet header for the given nfq_data argument. Typically, the nfq_data
           value is passed as the 3rd parameter to the callback function set by a call to <b>nfq_create_queue()</b>.

       The nfqnl_msg_packet_hdr structure is defined in libnetfilter_queue.h as:

               struct nfqnl_msg_packet_hdr {
                       uint32_t        packet_id;      // unique ID of packet in queue
                       uint16_t        hw_protocol;    // hw protocol (network order)
                       uint8_t         hook;           // netfilter hook
               } __attribute__ ((packed));

       Definition at line <b>974</b> of file <b>libnetfilter_queue.c</b>.

   <b>uint32_t</b> <b>nfq_get_nfmark</b> <b>(struct</b> <b>nfq_data</b> <b>*</b> <b>nfad)</b>
       nfq_get_nfmark - get the packet mark

       <b>Parameters</b>
           <u>nfad</u> Netlink packet data handle passed to callback function

       <b>Returns</b>
           the netfilter mark currently assigned to the given queued packet.

       Definition at line <b>987</b> of file <b>libnetfilter_queue.c</b>.

   <b>uint32_t</b> <b>nfq_get_outdev</b> <b>(struct</b> <b>nfq_data</b> <b>*</b> <b>nfad)</b>
       nfq_get_outdev - gets the interface that the packet will be routed out

       <b>Parameters</b>
           <u>nfad</u> Netlink packet data handle passed to callback function

       <b>Returns</b>
           The index of the device the queued packet will be sent out. If the returned index is 0, the packet is
           destined for localhost or the output interface is not yet known (ie. PREROUTING?).

       Definition at line <b>1056</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_get_outdev_name</b> <b>(struct</b> <b>nlif_handle</b> <b>*</b> <b>nlif_handle,</b> <b>struct</b> <b>nfq_data</b> <b>*</b> <b>nfad,</b> <b>char</b> <b>*</b> <b>name)</b>
       nfq_get_outdev_name - get the name of the physical interface the packet will be sent to

       <b>Parameters</b>
           <u>nlif_handle</u> pointer to a nlif interface resolving handle
           <u>nfad</u> Netlink packet data handle passed to callback function
           <u>name</u> pointer to the buffer to receive the interface name; not more than IFNAMSIZ bytes will be copied
           to it.

       See <b>nfq_get_indev_name()</b> documentation for nlif_handle usage.

       <b>Returns</b>
           -1 in case of error, &gt; 0 if it succeed.

       Definition at line <b>1156</b> of file <b>libnetfilter_queue.c</b>.

   <b>struct</b> <b>nfqnl_msg_packet_hw</b> <b>*</b> <b>nfq_get_packet_hw</b> <b>(struct</b> <b>nfq_data</b> <b>*</b> <b>nfad)</b>
       nfq_get_packet_hw

       get hardware address

       <b>Parameters</b>
           <u>nfad</u> Netlink packet data handle passed to callback function

       Retrieves the hardware address associated with the given queued packet. For ethernet packets, the
       hardware address returned (if any) will be the MAC address of the packet source host. The destination MAC
       address is not known until after POSTROUTING and a successful ARP request, so cannot currently be
       retrieved.

       The nfqnl_msg_packet_hw structure is defined in libnetfilter_queue.h as:

               struct nfqnl_msg_packet_hw {
                       uint16_t        hw_addrlen;
                       uint16_t        _pad;
                       uint8_t hw_addr[8];
               } __attribute__ ((packed));

       Definition at line <b>1207</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_get_payload</b> <b>(struct</b> <b>nfq_data</b> <b>*</b> <b>nfad,</b> <b>unsigned</b> <b>char</b> <b>**</b> <b>data)</b>
       nfq_get_payload - get payload

       <b>Parameters</b>
           <u>nfad</u> Netlink packet data handle passed to callback function
           <u>data</u> Pointer of pointer that will be pointed to the payload

       Retrieve the payload for a queued packet. The actual amount and type of data retrieved by this function
       will depend on the mode set with the <b>nfq_set_mode()</b> function.

       <b>Returns</b>
           -1 on error, otherwise &gt; 0.

       Definition at line <b>1324</b> of file <b>libnetfilter_queue.c</b>.

   <b>uint32_t</b> <b>nfq_get_physindev</b> <b>(struct</b> <b>nfq_data</b> <b>*</b> <b>nfad)</b>
       nfq_get_physindev - get the physical interface that the packet was received

       <b>Parameters</b>
           <u>nfad</u> Netlink packet data handle passed to callback function

       <b>Returns</b>
           The index of the physical device the queued packet was received via. If the returned index is 0, the
           packet was locally generated or the physical input interface is no longer known (ie. POSTROUTING?).

       Definition at line <b>1042</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_get_physindev_name</b> <b>(struct</b> <b>nlif_handle</b> <b>*</b> <b>nlif_handle,</b> <b>struct</b> <b>nfq_data</b> <b>*</b> <b>nfad,</b> <b>char</b> <b>*</b> <b>name)</b>
       nfq_get_physindev_name - get the name of the physical interface the packet was received through

       <b>Parameters</b>
           <u>nlif_handle</u> pointer to a nlif interface resolving handle
           <u>nfad</u> Netlink packet data handle passed to callback function
           <u>name</u> pointer to the buffer to receive the interface name; not more than IFNAMSIZ bytes will be copied
           to it.

       See <b>nfq_get_indev_name()</b> documentation for nlif_handle usage.

       <b>Returns</b>
           -1 in case of error, &gt; 0 if it succeed.

       Definition at line <b>1136</b> of file <b>libnetfilter_queue.c</b>.

   <b>uint32_t</b> <b>nfq_get_physoutdev</b> <b>(struct</b> <b>nfq_data</b> <b>*</b> <b>nfad)</b>
       nfq_get_physoutdev - get the physical interface that the packet output

       <b>Parameters</b>
           <u>nfad</u> Netlink packet data handle passed to callback function

       The index of the physical device the queued packet will be sent out. If the returned index is 0, the
       packet is destined for localhost or the physical output interface is not yet known (ie. PREROUTING?).

       <b>Returns</b>
           The index of physical interface that the packet output will be routed out.

       Definition at line <b>1072</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_get_physoutdev_name</b> <b>(struct</b> <b>nlif_handle</b> <b>*</b> <b>nlif_handle,</b> <b>struct</b> <b>nfq_data</b> <b>*</b> <b>nfad,</b> <b>char</b> <b>*</b> <b>name)</b>
       nfq_get_physoutdev_name - get the name of the interface the packet will be sent to

       <b>Parameters</b>
           <u>nlif_handle</u> pointer to a nlif interface resolving handle
           <u>nfad</u> Netlink packet data handle passed to callback function
           <u>name</u> pointer to the buffer to receive the interface name; not more than IFNAMSIZ bytes will be copied
           to it.

       See <b>nfq_get_indev_name()</b> documentation for nlif_handle usage.

       <b>Returns</b>
           -1 in case of error, &gt; 0 if it succeed.

       Definition at line <b>1177</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_get_secctx</b> <b>(struct</b> <b>nfq_data</b> <b>*</b> <b>nfad,</b> <b>unsigned</b> <b>char</b> <b>**</b> <b>secdata)</b>
       nfq_get_secctx - get the security context for this packet

       <b>Parameters</b>
           <u>nfad</u> Netlink packet data handle passed to callback function
           <u>secdata</u> data to write the security context to

       <b>Warning</b>
           If the NFQA_CFG_F_GSO flag is not set, then fragmented packets may be pushed into the queue. In this
           case, only one fragment will have the SECCTX field set. To deal with this issue always set
           NFQA_CFG_F_GSO.

       <b>Returns</b>
           -1 on error, otherwise &gt; 0

       Definition at line <b>1298</b> of file <b>libnetfilter_queue.c</b>.

   <b>uint32_t</b> <b>nfq_get_skbinfo</b> <b>(struct</b> <b>nfq_data</b> <b>*</b> <b>nfad)</b>
       nfq_get_skbinfo - return the NFQA_SKB_INFO meta information

       <b>Parameters</b>
           <u>nfad</u> Netlink packet data handle passed to callback function

       This can be used to obtain extra information about a packet by testing the returned integer for any of
       the following bit flags:

       • NFQA_SKB_CSUMNOTREADY  packet  header  checksums  will  be  computed  by hardware later on, i.e. tcp/ip
         checksums in the packet must not be validated, application should pretend they are correct.

       • NFQA_SKB_GSO packet is an aggregated super-packet. It exceeds device mtu  and  will  be  (re-)split  on
         transmit by hardware.

       • NFQA_SKB_CSUM_NOTVERIFIED  packet  checksum  was  not  yet verified by the kernel/hardware, for example
         because this is an incoming packet and the NIC does not perform checksum validation at hardware level.

       <b>Returns</b>
           the skbinfo value

       <b>See</b> <b>also</b>
           <b><a href="../man3/nfq_set_queue_flags.3.html">nfq_set_queue_flags</a>(3)</b>

       Definition at line <b>1236</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_get_timestamp</b> <b>(struct</b> <b>nfq_data</b> <b>*</b> <b>nfad,</b> <b>struct</b> <b>timeval</b> <b>*</b> <b>tv)</b>
       nfq_get_timestamp - get the packet timestamp

       <b>Parameters</b>
           <u>nfad</u> Netlink packet data handle passed to callback function
           <u>tv</u> structure to fill with timestamp info

       Retrieves the received timestamp when the given queued packet.

       <b>Returns</b>
           0 on success, non-zero on failure.

       Definition at line <b>1002</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_get_uid</b> <b>(struct</b> <b>nfq_data</b> <b>*</b> <b>nfad,</b> <b>uint32_t</b> <b>*</b> <b>uid)</b>
       nfq_get_uid - get the UID of the user the packet belongs to

       <b>Parameters</b>
           <u>nfad</u> Netlink packet data handle passed to callback function
           <u>uid</u> Set to UID on return

       <b>Warning</b>
           If the NFQA_CFG_F_GSO flag is not set, then fragmented packets may be pushed into the queue. In  this
           case,  only  one  fragment  will  have  the  UID  field  set.  To  deal  with  this  issue always set
           NFQA_CFG_F_GSO.

       <b>Returns</b>
           1 if there is a UID available, 0 otherwise.

       Definition at line <b>1256</b> of file <b>libnetfilter_queue.c</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libnetfilter_queue from the source code.

libnetfilter_queue                                Version 1.0.5                                       <u><a href="../man3/Parsing.3.html">Parsing</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>