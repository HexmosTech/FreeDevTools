<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pmemobj_open(),   pmemobj_create(),   pmemobj_close(),  pmemobj_check()  pmemobj_set_user_data(),  pmemo‐</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpmemobj-dev">libpmemobj-dev_1.13.1-1.1ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>pmemobj_open</b>(),   <b>pmemobj_create</b>(),   <b>pmemobj_close</b>(),  <b>pmemobj_check</b>()  <b>pmemobj_set_user_data</b>(),  <b>pmemo‐</b>
       <b>bj_get_user_data</b>() - create, open, close and validate persistent memory transactional object store

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;libpmemobj.h&gt;

              PMEMobjpool *pmemobj_open(const char *path, const char *layout);
              PMEMobjpool *pmemobj_create(const char *path, const char *layout,
                  size_t poolsize, mode_t mode);
              void pmemobj_close(PMEMobjpool *pop);
              int pmemobj_check(const char *path, const char *layout);

              void pmemobj_set_user_data(PMEMobjpool *pop, void *data);
              void *pmemobj_get_user_data(PMEMobjpool *pop);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       To use the pmem-resident transactional object store provided by <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7), a <u>memory</u> <u>pool</u>  must  first
       be  created  with  the  <b>pmemobj_create</b>() function described below.  Existing pools may be opened with the
       <b>pmemobj_open</b>() function.

       As of <b>libpmemobj</b> <b>1.11</b>, these functions are thread-safe; be careful if you have to use earlier versions of
       the library.

       Once created, the memory pool is represented by an opaque handle, of type <u>PMEMobjpool*</u>, which  is  passed
       to  most of the other <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) functions.  Internally, <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) will use either <b><a href="../man3/pmem_persist.3.html">pmem_persist</a></b>(3)
       or <b><a href="../man2/msync.2.html">msync</a></b>(2) when it needs to flush changes, depending on whether the memory pool appears to be persistent
       memory or a regular file (see the <b><a href="../man3/pmem_is_pmem.3.html">pmem_is_pmem</a></b>(3) function in <b><a href="../man7/libpmem.7.html">libpmem</a></b>(7) for more information).  There is
       no need for applications to flush changes directly when using the object memory API provided by <b>libpmemo‐</b>
       <b><a href="../man7/bj.7.html">bj</a></b>(7).

       The <b>pmemobj_create</b>() function creates a transactional object store with the given total  <u>poolsize</u>.   <u>path</u>
       specifies the name of the memory pool file to be created.  <u>layout</u> specifies the application’s layout type
       in the form of a string.  The layout name is not interpreted by <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7), but may be used as a check
       when  <b>pmemobj_open</b>()  is  called.  The layout name, including the terminating null byte (`\0'), cannot be
       longer than <b>PMEMOBJ_MAX_LAYOUT</b> as defined in <b>&lt;libpmemobj.h&gt;</b>.  A NULL <u>layout</u> is  equivalent  to  using  an
       empty  string  as  a  layout  name.  <u>mode</u> specifies the permissions to use when creating the file, as de‐
       scribed by <b><a href="../man2/creat.2.html">creat</a></b>(2).  The memory pool file is fully allocated to the  size  <u>poolsize</u>  using  <b>posix_fallo‐</b>
       <b><a href="../man3/cate.3.html">cate</a></b>(3).   The  caller may choose to take responsibility for creating the memory pool file by creating it
       before calling <b>pmemobj_create</b>(), and then specifying <u>poolsize</u> as zero.   In  this  case  <b>pmemobj_create</b>()
       will  take  the  pool size from the size of the existing file and will verify that the file appears to be
       empty by searching for any non-zero data in the pool header at the beginning of the  file.   The  minimum
       net  pool size allowed by the library for a local transactional object store is defined in <b>&lt;libpmemobj.h&gt;</b>
       as <b>PMEMOBJ_MIN_POOL</b>.

       Depending on the configuration of the system, the available non-volatile memory space may be divided into
       multiple memory devices.  In such case, the maximum size of the pmemobj memory pool could be  limited  by
       the  capacity of a single memory device.  <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) allows building persistent memory resident object
       store spanning multiple memory devices by creation of persistent  memory  pools  consisting  of  multiple
       files,  where  each  part  of  such  a  <u>pool</u> <u>set</u> may be stored on a different memory device or pmem-aware
       filesystem.

       Creation of all the parts of the pool set can be done with  <b>pmemobj_create</b>();  however,  the  recommended
       method for creating pool sets is with the <b><a href="../man1/pmempool.1.html">pmempool</a></b>(1) utility.

       When  creating a pool set consisting of multiple files, the <u>path</u> argument passed to <b>pmemobj_create</b>() must
       point to the special <u>set</u> file that defines the pool layout and the location of all the parts of the  pool
       set.  The <u>poolsize</u> argument must be 0.  The meaning of the <u>layout</u> and <u>mode</u> arguments does not change, ex‐
       cept that the same <u>mode</u> is used for creation of all the parts of the pool set.

       The <u>set</u> file is a plain text file, the structure of which is described in <b><a href="../man5/poolset.5.html">poolset</a></b>(5).

       The  <b>pmemobj_open</b>()  function  opens  an existing object store memory pool.  Similar to <b>pmemobj_create</b>(),
       <u>path</u> must identify either an existing obj memory pool file, or the <u>set</u> file used to create  a  pool  set.
       If  <u>layout</u>  is non-NULL, it is compared to the layout name provided to <b>pmemobj_create</b>() when the pool was
       first created.  This can be used to verify that the layout of the pool matches what  was  expected.   The
       application must have permission to open the file and memory map it with read/write permissions.

       Be  aware  that  if the pool contains bad blocks inside, opening can be aborted by the SIGBUS signal, be‐
       cause currently the pool is not checked against bad blocks during opening.  It can be turned on  by  set‐
       ting  the  CHECK_BAD_BLOCKS compat feature.  For details see description of this feature in <b>pmempool-fea‐</b>
       <b><a href="../man1/ture.1.html">ture</a></b>(1).

       The <b>pmemobj_close</b>() function closes the memory pool indicated by <u>pop</u> and deletes the memory pool  handle.
       The  object store itself lives on in the file that contains it and may be re-opened at a later time using
       <b>pmemobj_open</b>() as described above.

       The <b>pmemobj_check</b>() function performs a consistency check of the file indicated by <u>path</u>.  <b>pmemobj_check</b>()
       opens the given <u>path</u> read-only so it never makes any changes to the file.  This function is not supported
       on Device DAX.

       The <b>pmemobj_set_user_data</b>() function associates custom volatile state, represented by pointer <u>data</u>,  with
       the  given  pool  <u>pop</u>.   This  state can later be retrieved using <b>pmemobj_get_user_data</b>() function.  This
       state does not survive pool close.  If <b>pmemobj_set_user_data</b>() was not called for a  given  pool,  <b>pmemo‐</b>
       <b>bj_get_user_data</b>() will return NULL.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The <b>pmemobj_create</b>() function returns a memory pool handle to be used with most of the functions in <b>libp‐</b>
       <b><a href="../man7/memobj.7.html">memobj</a></b>(7).  On error it returns NULL and sets <u>errno</u> appropriately.

       The  <b>pmemobj_open</b>()  function returns a memory pool handle to be used with most of the functions in <b>libp‐</b>
       <b><a href="../man7/memobj.7.html">memobj</a></b>(7).  If an error prevents the pool from being opened, or if the given <u>layout</u> does  not  match  the
       pool’s layout, <b>pmemobj_open</b>() returns NULL and sets <u>errno</u> appropriately.

       The <b>pmemobj_close</b>() function returns no value.

       The <b>pmemobj_check</b>() function returns 1 if the memory pool is found to be consistent.  Any inconsistencies
       found  will  cause <b>pmemobj_check</b>() to return 0, in which case the use of the file with <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) will
       result in undefined behavior.  The debug version of <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) will provide additional details on  in‐
       consistencies when <b>PMEMOBJ_LOG_LEVEL</b> is at least 1, as described in the <b>DEBUGGING</b> <b>AND</b> <b>ERROR</b> <b>HANDLING</b> sec‐
       tion  in  <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7).   <b>pmemobj_check</b>() returns -1 and sets <u>errno</u> if it cannot perform the consistency
       check due to other errors.

</pre><h4><b>CAVEATS</b></h4><pre>
       Not all file systems support <b><a href="../man3/posix_fallocate.3.html">posix_fallocate</a></b>(3).  <b>pmemobj_create</b>() will fail if the underlying file  sys‐
       tem does not support <b><a href="../man3/posix_fallocate.3.html">posix_fallocate</a></b>(3).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/creat.2.html">creat</a></b>(2),  <b><a href="../man2/msync.2.html">msync</a></b>(2),  <b><a href="../man3/pmem_is_pmem.3.html">pmem_is_pmem</a></b>(3), <b><a href="../man3/pmem_persist.3.html">pmem_persist</a></b>(3), <b><a href="../man3/posix_fallocate.3.html">posix_fallocate</a></b>(3), <b><a href="../man7/libpmem.7.html">libpmem</a></b>(7), <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) and
       <b>&lt;https://pmem.io&gt;</b>
</pre>
 </div>
</div></section>
</div>
</body>
</html>