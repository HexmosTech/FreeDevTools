<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rte_power_intrinsics.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dpdk-doc">dpdk-doc_24.11.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rte_power_intrinsics.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/inttypes.h">inttypes.h</a>&gt;
       #include &lt;rte_spinlock.h&gt;

   <b>Macros</b>
       #define <b>RTE_POWER_MONITOR_OPAQUE_SZ</b>   4

   <b>Typedefs</b>
       <b>typedef</b> int(* <b>rte_power_monitor_clb_t</b>) (const uint64_t val, const uint64_t
           opaque[<b>RTE_POWER_MONITOR_OPAQUE_SZ</b>])

   <b>Functions</b>
       int <b>rte_power_monitor</b> (const struct rte_power_monitor_cond *pmc, const uint64_t tsc_timestamp)
       int <b>rte_power_monitor_wakeup</b> (const unsigned int lcore_id)
       int <b>rte_power_pause</b> (const uint64_t tsc_timestamp)
       int <b>rte_power_monitor_multi</b> (const struct rte_power_monitor_cond pmc[], const uint32_t num, const
           uint64_t tsc_timestamp)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Advanced power management operations.

       This file define APIs for advanced power management, which are architecture-dependent.

       Definition in file <b>rte_power_intrinsics.h</b>.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>RTE_POWER_MONITOR_OPAQUE_SZ</b>   <b>4</b>
       Size of the opaque data in monitor condition

       Definition at line <b>25</b> of file <b>rte_power_intrinsics.h</b>.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>int(*</b> <b>rte_power_monitor_clb_t)</b> <b>(const</b> <b>uint64_t</b> <b>val,</b> <b>const</b> <b>uint64_t</b>
       <b>opaque[RTE_POWER_MONITOR_OPAQUE_SZ])</b>
       Callback definition for monitoring conditions. Callbacks with this signature will be used by
       <b>rte_power_monitor()</b> <b>to</b> <b>check</b> <b>if</b> <b>the</b> <b>entering</b> <b>of</b> <b>power</b> <b>optimized</b> <b>state</b> <b>should</b> <b>be</b> <b>aborted.</b>

       <b>Parameters</b>
           <u>val</u> The value read from memory.
           <u>opaque</u> Callback-specific data.

       <b>Returns</b>
           0 if entering of power optimized state should proceed -1 if entering of power optimized state should
           be aborted

       Definition at line <b>41</b> of file <b>rte_power_intrinsics.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>int</b> <b>rte_power_monitor</b> <b>(const</b> <b>struct</b> <b>rte_power_monitor_cond</b> <b>*</b> <b>pmc,</b> <b>const</b> <b>uint64_t</b> <b>tsc_timestamp)</b>
       Monitor specific address for changes. This will cause the CPU to enter an architecture-defined optimized
       power state until either the specified memory address is written to, a certain TSC timestamp is reached,
       or other reasons cause the CPU to wake up.

       Additionally, an expected value (pmc-&gt;val), mask (pmc-&gt;mask), and data size (pmc-&gt;size) are provided in
       the pmc power monitoring condition. If the mask is non-zero, the current value pointed to by the
       pmc-&gt;addr pointer will be read and compared against the expected value, and if they match, the entering
       of optimized power state will be aborted. This is intended to prevent the CPU from entering optimized
       power state and waiting on a write that has already happened by the time this API is called.

       <b>Warning</b>
           It is responsibility of the user to check if this function is supported at runtime using
           <b>rte_cpu_get_intrinsics_support()</b> <b>API</b> <b>call.</b>

       <b>Parameters</b>
           <u>pmc</u> The monitoring condition structure.
           <u>tsc_timestamp</u> Maximum TSC timestamp to wait for. Note that the wait behavior is architecture-
           dependent.

       <b>Returns</b>
           0 on success -EINVAL on invalid parameters -ENOTSUP if unsupported

   <b>int</b> <b>rte_power_monitor_wakeup</b> <b>(const</b> <b>unsigned</b> <b>int</b> <b>lcore_id)</b>
       Wake up a specific lcore that is in a power optimized state and is monitoring an address.

       <b>Note</b>
           It is safe to call this function if the lcore in question is not sleeping. The function will have no
           effect.

           This function will <u>not</u> wake up a core that is in a power optimized state due to calling
           rte_power_pause.

       <b>Parameters</b>
           <u>lcore_id</u> Lcore ID of a sleeping thread.

   <b>int</b> <b>rte_power_pause</b> <b>(const</b> <b>uint64_t</b> <b>tsc_timestamp)</b>
       Enter an architecture-defined optimized power state until a certain TSC timestamp is reached.

       <b>Warning</b>
           It is responsibility of the user to check if this function is supported at runtime using
           <b>rte_cpu_get_intrinsics_support()</b> <b>API</b> <b>call.</b>

       <b>Parameters</b>
           <u>tsc_timestamp</u> Maximum TSC timestamp to wait for. Note that the wait behavior is architecture-
           dependent.

       <b>Returns</b>
           0 on success -EINVAL on invalid parameters -ENOTSUP if unsupported

   <b>int</b> <b>rte_power_monitor_multi</b> <b>(const</b> <b>struct</b> <b>rte_power_monitor_cond</b> <b>pmc[],</b> <b>const</b> <b>uint32_t</b> <b>num,</b> <b>const</b> <b>uint64_t</b>
       <b>tsc_timestamp)</b>
       Monitor a set of addresses for changes. This will cause the CPU to enter an architecture-defined
       optimized power state until either one of the specified memory addresses is written to, a certain TSC
       timestamp is reached, or other reasons cause the CPU to wake up.

       Additionally, expected 64-bit values and 64-bit masks are provided. If mask is non-zero, the current
       value pointed to by the p pointer will be checked against the expected value, and if they do not match,
       the entering of optimized power state may be aborted.

       <b>Warning</b>
           It is responsibility of the user to check if this function is supported at runtime using
           <b>rte_cpu_get_intrinsics_support()</b> <b>API</b> <b>call.</b> <b>Failing</b> <b>to</b> <b>do</b> <b>so</b> <b>may</b> <b>result</b> <b>in</b> <b>an</b> <b>illegal</b> <b>CPU</b> <b>instruction</b>
           <b>error.</b>

       <b>Parameters</b>
           <u>pmc</u> An array of monitoring condition structures.
           <u>num</u> Length of the pmc array.
           <u>tsc_timestamp</u> Maximum TSC timestamp to wait for. Note that the wait behavior is architecture-
           dependent.

       <b>Returns</b>
           0 on success -EINVAL on invalid parameters -ENOTSUP if unsupported

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for DPDK from the source code.

DPDK                                             Version 24.11.2                       <u><a href="../man3/rte_power_intrinsics.h.3.html">rte_power_intrinsics.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>