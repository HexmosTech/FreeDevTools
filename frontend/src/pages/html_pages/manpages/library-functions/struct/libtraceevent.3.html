<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libtraceevent - Linux kernel trace event library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtraceevent-doc">libtraceevent-doc_1.8.4-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libtraceevent - Linux kernel trace event library

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;event-parse.h&gt;</b>

       Management of tep handler data structure and access of its members:
               struct tep_handle *<b>tep_alloc</b>(void);
               void <b>tep_free</b>(struct tep_handle *<u>tep</u>);
               void <b>tep_ref</b>(struct tep_handle *<u>tep</u>);
               void <b>tep_unref</b>(struct tep_handle *<u>tep</u>);
               int <b>tep_get_ref</b>(struct tep_handle *<u>tep</u>);
               void <b>tep_set_flag</b>(struct tep_handle *<u>tep</u>, enum tep_flag <u>flag</u>);
               void <b>tep_clear_flag</b>(struct tep_handle *<u>tep</u>, enum tep_flag <u>flag</u>);
               bool <b>tep_test_flag</b>(struct tep_handle *<u>tep</u>, enum tep_flag <u>flags</u>);
               int <b>tep_get_cpus</b>(struct tep_handle *<u>tep</u>);
               void <b>tep_set_cpus</b>(struct tep_handle *<u>tep</u>, int <u>cpus</u>);
               int <b>tep_get_long_size</b>(strucqt tep_handle *<u>tep</u>);
               void <b>tep_set_long_size</b>(struct tep_handle *<u>tep</u>, int <u>long_size</u>);
               int <b>tep_get_page_size</b>(struct tep_handle *<u>tep</u>);
               void <b>tep_set_page_size</b>(struct tep_handle *<u>tep</u>, int <u>page_size</u>);
               int <b>tep_get_sub_buffer_size</b>(struct tep_handle *<u>tep</u>);
               int <b>tep_get_sub_buffer_data_size</b>(struct tep_handle *<u>tep</u>);
               int <b>tep_get_sub_buffer_commit_offset</b>(struct tep_handle *<u>tep</u>);
               int <b>tep_get_header_page_size</b>(struct tep_handle *<u>tep</u>);
               int <b>tep_get_header_timestamp_size</b>(struct tep_handle *<u>tep</u>);
               bool <b>tep_is_old_format</b>(struct tep_handle *<u>tep</u>);
               int <b>tep_strerror</b>(struct tep_handle *<u>tep</u>, enum tep_errno <u>errnum</u>, char *<u>buf</u>, size_t <u>buflen</u>);
               struct kbuffer *<b>tep_kbuffer</b>(struct tep_handle *<u>tep</u>);

       Register / unregister APIs:
               int <b>tep_register_function</b>(struct tep_handle *<u>tep</u>, char *<u>name</u>, unsigned long long <u>addr</u>, char *<u>mod</u>);
               int <b>tep_register_event_handler</b>(struct tep_handle *<u>tep</u>, int <u>id</u>, const char *<u>sys_name</u>, const char *<u>event_name</u>, tep_event_handler_func <u>func</u>, void *<u>context</u>);
               int <b>tep_unregister_event_handler</b>(struct tep_handle *tep, int id, const char *sys_name, const char *event_name, tep_event_handler_func func, void *<u>context</u>);
               int <b>tep_register_print_string</b>(struct tep_handle *<u>tep</u>, const char *<u>fmt</u>, unsigned long long <u>addr</u>);
               int <b>tep_register_print_function</b>(struct tep_handle *<u>tep</u>, tep_func_handler <u>func</u>, enum tep_func_arg_type <u>ret_type</u>, char *<u>name</u>, <u>...</u>);
               int <b>tep_unregister_print_function</b>(struct tep_handle *<u>tep</u>, tep_func_handler <u>func</u>, char *<u>name</u>);
               int <b>tep_get_function_count</b>(struct tep_handle <u>tep</u><b>);</b>

       <b>Trace</b> <b>printk</b> <b>parsing:</b>
               <b>void</b> <b>*tep_print_printk</b>(struct tep_handle *tep);
               void <b>tep_print_funcs</b>(struct tep_handle *tep);
               void <b>tep_set_test_filters</b>(struct tep_handle *tep, int test_filters);
               void <b>tep_plugin_print_options</b>(struct trace_seq *s);
               int <b>tep_plugin_add_option</b>(const char *<u>name</u>, const char *<u>val</u>);

       Meta data parsing:
               int <b>tep_parse_saved_cmdlines</b>(struct tep_handle *<u>tep</u>, const char *<u>buf</u>);
               int <b>tep_parse_printk_formats</b>(struct tep_handle *<u>tep</u>, const char *<u>buf</u>);
               int <b>tep_parse_kallsyms</b>(struct tep_handle *<u>tep</u>, const char *<u>buf</u>);

       Plugins management:
               struct tep_plugin_list *<b>tep_load_plugins</b>(struct tep_handle *<u>tep</u>);
               void <b>tep_unload_plugins</b>(struct tep_plugin_list *<u>plugin_list</u>, struct tep_handle *<u>tep</u>);
               char **<b>tep_plugin_list_options</b>(void);
               void <b>tep_plugin_free_options_list</b>(char **<u>list</u>);
               int <b>tep_plugin_add_options</b>(const char *<u>name</u>, struct tep_plugin_option *<u>options</u>);
               void <b>tep_plugin_remove_options</b>(struct tep_plugin_option *<u>options</u>);
               void <b>tep_print_plugins</b>(struct trace_seq *<u>s</u>, const char *<u>prefix</u>, const char *<u>suffix</u>, const struct tep_plugin_list *<u>list</u>);
               void <b>tep_load_plugins_hook</b>(struct tep_handle *<u>tep</u>, const char *<u>suffix</u>,
                                  void (*<u>load_plugin</u>)(struct tep_handle *tep,
                                                      const char *path,
                                                      const char *name,
                                                      void *data),
                                  void *<u>data</u>);
               int <b>tep_add_plugin_path</b>(struct tep_handle *tep, char *path,
                                 enum tep_plugin_load_priority prio);

       Event related APIs:
               struct tep_event *<b>tep_get_event</b>(struct tep_handle *<u>tep</u>, int <u>index</u>);
               struct tep_event *<b>tep_get_first_event</b>(struct tep_handle *<u>tep</u>);
               int <b>tep_get_events_count</b>(struct tep_handle *<u>tep</u>);
               struct tep_event **<b>tep_list_events</b>(struct tep_handle *<u>tep</u>, enum tep_event_sort_type <u>sort_type</u>);
               struct tep_event **<b>tep_list_events_copy</b>(struct tep_handle *<u>tep</u>, enum tep_event_sort_type <u>sort_type</u>);
               void <b>tep_print_event</b>(struct tep_handle *<u>tep</u>, struct trace_seq *<u>s</u>, struct tep_record *<u>record</u>, const char *<u>fmt</u>, <u>...</u>);

       Event finding:
               struct tep_event *<b>tep_find_event</b>(struct tep_handle *<u>tep</u>, int <u>id</u>);
               struct tep_event *<b>tep_find_event_by_name</b>(struct tep_handle *<u>tep</u>, const char *<u>sys</u>, const char *<u>name</u>);
               struct tep_event *<b>tep_find_event_by_record</b>(struct tep_handle *<u>tep</u>, struct tep_record *<u>record</u>);
               bool <b>tep_record_is_event</b>(struct tep_record *record, struct tep_event *event);

       Parsing of event files:
               int <b>tep_parse_header_page</b>(struct tep_handle *<u>tep</u>, char *<u>buf</u>, unsigned long <u>size</u>, int <u>long_size</u>);
               enum tep_errno <b>tep_parse_event</b>(struct tep_handle *<u>tep</u>, const char *<u>buf</u>, unsigned long <u>size</u>, const char *<u>sys</u>);
               enum tep_errno <b>tep_parse_format</b>(struct tep_handle *<u>tep</u>, struct tep_event **<u>eventp</u>, const char *<u>buf</u>, unsigned long <u>size</u>, const char *<u>sys</u>);

       APIs related to fields from eventâ€™s format files:
               struct tep_format_field **<b>tep_event_common_fields</b>(struct tep_event *<u>event</u>);
               struct tep_format_field **<b>tep_event_fields</b>(struct tep_event *<u>event</u>);
               void *<b>tep_get_field_raw</b>(struct trace_seq *<u>s</u>, struct tep_event *<u>event</u>, const char *<u>name</u>, struct tep_record *<u>record</u>, int *<u>len</u>, int <u>err</u>);
               int <b>tep_get_field_val</b>(struct trace_seq *<u>s</u>, struct tep_event *<u>event</u>, const char *<u>name</u>, struct tep_record *<u>record</u>, unsigned long long *<u>val</u>, int <u>err</u>);
               int <b>tep_get_common_field_val</b>(struct trace_seq *<u>s</u>, struct tep_event *<u>event</u>, const char *<u>name</u>, struct tep_record *<u>record</u>, unsigned long long *<u>val</u>, int <u>err</u>);
               int <b>tep_get_any_field_val</b>(struct trace_seq *<u>s</u>, struct tep_event *<u>event</u>, const char *<u>name</u>, struct tep_record *<u>record</u>, unsigned long long *<u>val</u>, int <u>err</u>);
               int <b>tep_read_number_field</b>(struct tep_format_field *<u>field</u>, const void *<u>data</u>, unsigned long long *<u>value</u>);

       Event fields printing:
               void <b>tep_print_field_content</b>(struct trace_seq *<u>s</u>, void *<u>data</u>, int size, struct tep_format_field *<u>field</u>);
               void <b>tep_print_fields</b>(struct trace_seq *<u>s</u>, void *<u>data</u>, int <u>size</u>, struct tep_event *<u>event</u>);
               int <b>tep_print_num_field</b>(struct trace_seq *<u>s</u>, const char *<u>fmt</u>, struct tep_event *<u>event</u>, const char *<u>name</u>, struct tep_record *<u>record</u>, int <u>err</u>);
               int <b>tep_print_func_field</b>(struct trace_seq *<u>s</u>, const char *<u>fmt</u>, struct tep_event *<u>event</u>, const char *<u>name</u>, struct tep_record *<u>record</u>, int <u>err</u>);
               void <b>tep_record_print_fields</b>(struct trace_seq *<u>s</u>, struct tep_record *<u>record</u>, struct tep_event *<u>event</u>);
               void <b>tep_record_print_selected_fields</b>(struct trace_seq *<u>s</u>, struct tep_record *<u>record</u>, struct tep_event *<u>event</u>, int <u>select_mask</u>);

       Event fields finding:
               struct tep_format_field *<b>tep_find_common_field</b>(struct tep_event *<u>event</u>, const char *<u>name</u>);
               struct tep_format_field *<b>tep_find_field</b>(struct tep_event_ormat *<u>event</u>, const char *<u>name</u>);
               struct tep_format_field *<b>tep_find_any_field</b>(struct tep_event *<u>event</u>, const char *<u>name</u>);

       Functions resolver:
               int <b>tep_set_function_resolver</b>(struct tep_handle *<u>tep</u>, tep_func_resolver_t *<u>func</u>, void *<u>priv</u>);
               void <b>tep_reset_function_resolver</b>(struct tep_handle *<u>tep</u>);
               const char *<b>tep_find_function</b>(struct tep_handle *<u>tep</u>, unsigned long long <u>addr</u>);
               unsigned long long <b>tep_find_function_address</b>(struct tep_handle *<u>tep</u>, unsigned long long <u>addr</u>);
               int <b>tep_find_function_info</b>(struct tep_handle *<u>tep</u>, unsigned long long <u>addr</u>, const char **<u>name</u>,
                                  unsigned long long *<u>start</u>, unsigned long *<u>size</u>);

       Filter management:
               struct tep_event_filter *<b>tep_filter_alloc</b>(struct tep_handle *<u>tep</u>);
               enum tep_errno <b>tep_filter_add_filter_str</b>(struct tep_event_filter *<u>filter</u>, const char *<u>filter_str</u>);
               enum tep_errno <b>tep_filter_match</b>(struct tep_event_filter *<u>filter</u>, struct tep_record *<u>record</u>);
               int <b>tep_filter_strerror</b>(struct tep_event_filter *<u>filter</u>, enum tep_errno <u>err</u>, char *buf, size_t <u>buflen</u>);
               int <b>tep_event_filtered</b>(struct tep_event_filter *<u>filter</u>, int <u>event_id</u>);
               void <b>tep_filter_reset</b>(struct tep_event_filter *<u>filter</u>);
               void <b>tep_filter_free</b>(struct tep_event_filter *<u>filter</u>);
               char *<b>tep_filter_make_string</b>(struct tep_event_filter *<u>filter</u>, int <u>event_id</u>);
               int <b>tep_filter_remove_event</b>(struct tep_event_filter *<u>filter</u>, int <u>event_id</u>);
               int <b>tep_filter_copy</b>(struct tep_event_filter *<u>dest</u>, struct tep_event_filter *<u>source</u>);
               int <b>tep_filter_compare</b>(struct tep_event_filter *<u>filter1</u>, struct tep_event_filter *<u>filter2</u>);

       Parsing various data from the records:
               int <b>tep_data_type</b>(struct tep_handle *<u>tep</u>, struct tep_record *<u>rec</u>);
               int <b>tep_data_pid</b>(struct tep_handle *<u>tep</u>, struct tep_record *<u>rec</u>);
               int <b>tep_data_preempt_count</b>(struct tep_handle *<u>tep</u>, struct tep_record *<u>rec</u>);
               int <b>tep_data_flags</b>(struct tep_handle *<u>tep</u>, struct tep_record *<u>rec</u>);

       Command and task related APIs:
               const char *<b>tep_data_comm_from_pid</b>(struct tep_handle *<u>tep</u>, int <u>pid</u>);
               struct cmdline *<b>tep_data_pid_from_comm</b>(struct tep_handle *<u>tep</u>, const char *<u>comm</u>, struct cmdline *<u>next</u>);
               int <b>tep_register_comm</b>(struct tep_handle *<u>tep</u>, const char *<u>comm</u>, int <u>pid</u>);
               int <b>tep_override_comm</b>(struct tep_handle *<u>tep</u>, const char *<u>comm</u>, int <u>pid</u>);
               bool <b>tep_is_pid_registered</b>(struct tep_handle *<u>tep</u>, int <u>pid</u>);
               int <b>tep_cmdline_pid</b>(struct tep_handle *<u>tep</u>, struct cmdline *<u>cmdline</u>);

       Endian related APIs:
               int <b>tep_is_bigendian</b>(void);
               unsigned long long <b>tep_read_number</b>(struct tep_handle *<u>tep</u>, const void *<u>ptr</u>, int <u>size</u>);
               bool <b>tep_is_file_bigendian</b>(struct tep_handle *<u>tep</u>);
               void <b>tep_set_file_bigendian</b>(struct tep_handle *<u>tep</u>, enum tep_endian <u>endian</u>);
               bool <b>tep_is_local_bigendian</b>(struct tep_handle *<u>tep</u>);
               void <b>tep_set_local_bigendian</b>(struct tep_handle *<u>tep</u>, enum tep_endian <u>endian</u>);

       Control library logs:
               int <b>tep_set_loglevel</b>(enum tep_loglevel <u>level</u>);

       KVM plugin calllbacks: (Defined by the application and complied with -rdynamic)
               const char *<b>tep_plugin_kvm_get_func</b>(struct tep_event *event,
                                           struct tep_record *record,
                                           unsigned long long *paddr);
               void <b>tep_plugin_kvm_put_func</b>(const char *func);

       Trace sequences:
       <b>#include</b> <b>&lt;trace-seq.h&gt;</b>
               void <b>trace_seq_init</b>(struct trace_seq *<u>s</u>);
               void <b>trace_seq_reset</b>(struct trace_seq *<u>s</u>);
               void <b>trace_seq_destroy</b>(struct trace_seq *<u>s</u>);
               int <b>trace_seq_printf</b>(struct trace_seq *<u>s</u>, const char *<u>fmt</u>, ...);
               int <b>trace_seq_vprintf</b>(struct trace_seq *<u>s</u>, const char *<u>fmt</u>, va_list <u>args</u>);
               int <b>trace_seq_puts</b>(struct trace_seq *<u>s</u>, const char *<u>str</u>);
               int <b>trace_seq_putc</b>(struct trace_seq *<u>s</u>, unsigned char <u>c</u>);
               void <b>trace_seq_terminate</b>(struct trace_seq *<u>s</u>);
               int <b>trace_seq_do_fprintf</b>(struct trace_seq *<u>s</u>, FILE *<u>fp</u>);
               int <b>trace_seq_do_printf</b>(struct trace_seq *<u>s</u>);

       kbuffer parsing:
       #include &lt;kbuffer.h&gt;
               struct kbuffer *<b>kbuffer_alloc</b>(enum kbuffer_long_size <u>size</u>, enum kbuffer_endian <u>endian</u>);
               struct kbuffer *<b>kbuffer_dup</b>(struct kbuffer *<u>kbuf</u>);
               void <b>kbuffer_free</b>(struct kbuffer *<u>kbuf</u>);
               int <b>kbuffer_load_subbuffer</b>(struct kbuffer *<u>kbuf</u>, void *<u>subbuffer</u>);
               int <b>kbuffer_subbuffer_size</b>(struct kbuffer *<u>kbuf);</u>
               <u>void</u> <u>*</u><b>kbuffer_subbuffer</b><u>(struct</u> <u>kbuffer</u> <u>*_kbuf);</u>
               <u>int</u> <b>kbuffer_refresh</b><u>(struct</u> <u>kbuffer</u> <u>*_kbuf</u>);
               int <b>kbuffer_start_of_data</b>(struct kbuffer *<u>kbuf</u>);
               unsigned long long <b>kbuffer_timestamp</b>(struct kbuffer *<u>kbuf</u>);
               unsigned long long <b>kbuffer_subbuf_timestamp</b>(struct kbuffer *<u>kbuf</u>, void *<u>subbuf</u>);
               void *<b>kbuffer_read_event</b>(struct kbuffer *<u>kbuf</u>, unsigned long long *<u>ts</u>);
               void *<b>kbuffer_next_event</b>(struct kbuffer *<u>kbuf</u>, unsigned long long *<u>ts</u>);
               void *<b>kbuffer_read_at_offset</b>(struct kbuffer *<u>kbuf</u>, int <u>offset</u>, unsigned long long *<u>ts</u>);
               int <b>kbuffer_missed_events</b>(struct kbuffer *<u>kbuf</u>);
               int <b>kbuffer_event_size</b>(struct kbuffer *<u>kbuf</u>);
               int <b>kbuffer_curr_size</b>(struct kbuffer *<u>kbuf</u>);
               int <b>kbuffer_curr_offset</b>(struct kbuffer *<u>kbuf</u>);
               int <b>kbuffer_curr_index</b>(struct kbuffer *<u>kbuf</u>);
               int <b>kbuffer_read_buffer</b>(struct kbuffer *<u>kbuf</u>, void *<u>buffer</u>, int <u>start</u>, int <u>len</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <a href="../man3/libtraceevent.3.html">libtraceevent</a>(3) library provides APIs to access kernel tracepoint events, located in the tracefs
       file system under the events directory.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
           TRACEEVENT_PLUGIN_DIR
                   Additional plugin directory. All shared object files, located in this directory will be loaded as traceevent plugins.

</pre><h4><b>FILES</b></h4><pre>
           <b>event-parse.h</b>
                   Header file to include in order to have access to the library APIs.
           <b>trace-seq.h</b>
                   Header file to include in order to have access to trace sequences related APIs.
                   Trace sequences are used to allow a function to call several other functions
                   to create a string of data to use.
           <b>-ltraceevent</b>
                   Linker switch to add when building a program that uses the library.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/trace-cmd.1.html">trace-cmd</a></b>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
           <b>Steven</b> <b>Rostedt</b> &lt;<b><a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a></b>[1]&gt;, author of <b>libtraceevent</b>.
           <b>Tzvetomir</b> <b>Stoyanov</b> &lt;<b><a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a></b>[2]&gt;, author of this man page.

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<b><a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a></b>[3]&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       libtraceevent is Free Software licensed under the GNU LGPL 2.1

</pre><h4><b>RESOURCES</b></h4><pre>
       <b>https://git.kernel.org/pub/scm/libs/libtrace/libtraceevent.git/</b>

</pre><h4><b>NOTES</b></h4><pre>
        1. <a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a>
           <a href="mailto:rostedt@goodmis.org">mailto:rostedt@goodmis.org</a>

        2. <a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a>
           <a href="mailto:tz.stoyanov@gmail.com">mailto:tz.stoyanov@gmail.com</a>

        3. <a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a>
           <a href="mailto:linux-trace-devel@vger.kernel.org">mailto:linux-trace-devel@vger.kernel.org</a>

libtraceevent 1.8.4                                12/24/2024                                   <u><a href="../man3/LIBTRACEEVENT.3.html">LIBTRACEEVENT</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>