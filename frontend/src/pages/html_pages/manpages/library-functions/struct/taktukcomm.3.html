<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>taktuk - Interface library to "taktuk(1)" communication facilities</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtaktuk-1-dev">libtaktuk-1-dev_3.7.7-3.1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       taktuk - Interface library to "<a href="../man1/taktuk.1.html">taktuk</a>(1)" communication facilities

</pre><h4><b>SYNOPSIS</b></h4><pre>
         #include &lt;taktuk.h&gt;

         const char *taktuk_error_msg(int msg_code);

         int taktuk_init_threads();
         int taktuk_leave_threads();

         int taktuk_get(const char *field, unsigned long *result);

         int taktuk_multi_send(const char *dest, const char *target,
                                 const void *buffer, size_t length);
         int taktuk_multi_sendv(const char *dest, const char *target,
                                const struct iovec *iov, int iovcnt);

         int taktuk_send(unsigned long dest, unsigned long target,
                               const void *buffer, size_t length);
         int taktuk_sendv(unsigned long dest, unsigned long target,
                              const struct iovec *iov, int iovcnt);

         int taktuk_recv(unsigned long *from, void *buffer, size_t *length,
                                                    struct timeval *timeout);
         int taktuk_recvv(unsigned long *from, const struct iovec *iov,
                                    int iovcnt, struct timeval *timeout);

         int taktuk_wait_message(unsigned long *from, size_t *size,
                                            struct timeval *timeout);

         int taktuk_read( void *buffer, size_t length );
         int taktuk_readv( const struct iovec *iov, int iovcnt );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>TakTuk</b> communication layer interface library provides a way for programs executed using the <a href="../man1/taktuk.1.html">taktuk</a>(1)
       command to exchange data. It is based on a simple send/receive model using multicast-like sends and
       optionally timeouted receives.  This is only designed to be a control facility, in particular this is not
       a high performance communication library.

       Any program using <b>TakTuk</b> C communication interface has to link his program to the "taktuk" and "pthread"
       libraries (the "taktuk" library is provided with the distribution).  Headers for communication functions
       and constants definitions can be found in "taktuk.h" also provided with the distribution.

       The communication functions are:

   <b>miscellaneous</b> <b>functions</b>
       <b>int</b> <b>taktuk_init_threads();</b>
       <b>int</b> <b>taktuk_leave_threads();</b>
           functions  to  be  called  once in the process respectively before threads creation and after threads
           destruction if you want <b>TakTuk</b> C interface to be thread-safe.

           Nevertheless, notice that, because of the way <b>TakTuk</b> is implemented, the handling of "recv" functions
           in several threads is completely sequentialized.  This is especially important regarding timeouts: if
           a timeout is given to a "recv" function, it will only be started at the  calling  thread's  turn.  In
           other words, issuing multiple timeouted "recv" in several threads of the same process might result in
           timeouts longer that expected (they become at most the sum of all pending "recv" timeouts).

       <b>int</b> <b>taktuk_get(const</b> <b>char</b> <b>*field,</b> <b>unsigned</b> <b>long</b> <b>*result);</b>
           gets  some  information  from  <b>TakTuk</b>  and places it into result. Currently available information are
           "target", "rank", "count", "father", "child_min" and "child_max". This is a better way to  get  these
           information  than  environment variables as its takes into account renumbering that might occur after
           process spawn.

   <b>multicast</b> <b>send</b> <b>functions</b>
       <b>int</b> <b>taktuk_multi_send(const</b> <b>char</b> <b>*dest,</b> <b>const</b> <b>char</b> <b>*target,</b> <b>const</b> <b>void</b> <b>*buffer,</b> <b>size_t</b> <b>length);</b>
       <b>int</b> <b>taktuk_multi_sendv(const</b> <b>char</b> <b>*dest,</b> <b>const</b> <b>char</b> <b>*target,</b> <b>const</b> <b>struct</b> <b>iovec</b> <b>*iov,</b> <b>int</b> <b>iovcnt);</b>
           "taktuk_multi_send" sends the content of "buffer" made  of  "length"  bytes  to  the  set  of  target
           processes  "target" present on the set of destinations "dest" (nul terminated characters strings, see
           <a href="../man1/taktuk.1.html">taktuk</a>(1) for information about set specifications  for  destination  hosts  and  target  processes).
           "taktuk_multi_sendv"  is  the  vector  variant  of  "taktuk_multi_send"  (similar  to "writev" system
           function).

   <b>single</b> <b>host</b> <b>send/recv</b> <b>functions</b>
       <b>int</b> <b>taktuk_send(unsigned</b> <b>long</b> <b>dest,</b> <b>unsigned</b> <b>long</b> <b>target,</b> <b>const</b> <b>void</b> <b>*buffer,</b> <b>size_t</b> <b>length);</b>
       <b>int</b> <b>taktuk_sendv(unsigned</b> <b>long</b> <b>dest,</b> <b>unsigned</b> <b>long</b> <b>target,</b> <b>const</b> <b>struct</b> <b>iovec</b> <b>*iov,</b> <b>int</b> <b>iovcnt);</b>
           sends the content of "buffer" made of "length" bytes to process "target"  on  the  host  "dest"  (see
           <a href="../man1/taktuk.1.html">taktuk</a>(1) for more information about target processes).  In this case, the target value might also be
           TAKTUK_TARGET_ANY  to  target  the first process performing a "recv", TAKTUK_TARGET_ALL to target all
           processes,  or  TAKTUK_TARGET_OUTPUT  to  target  the  "message"  stream  rather  than   a   process.
           "taktuk_sendv" is the vector variant of "taktuk_send" (similar to "writev" system function).

       <b>int</b> <b>taktuk_recv(unsigned</b> <b>long</b> <b>*from,</b> <b>void</b> <b>*buffer,</b> <b>size_t</b> <b>*length,</b> <b>struct</b> <b>timeval</b> <b>*timeout);</b>
       <b>int</b> <b>taktuk_recvv(unsigned</b> <b>long</b> <b>*from,</b> <b>const</b> <b>struct</b> <b>iovec</b> <b>*iov,</b> <b>int</b> <b>iovcnt,</b> <b>struct</b> <b>timeval</b> <b>*timeout);</b>
           blocks  until  the  reception of a message.  If a regular message is received, "taktuk_recv" sets the
           value of its arguments: "from" to the logical number of the sender, "buffer"  to  the  data  received
           which  is  made  of  "length"  bytes.   If timeout is not NULL, taktuk_recv() might receive a timeout
           notification.  In this case, taktuk_recv() returns the TAKTUK_ETMOUT error code.   "taktuk_recvv"  is
           the vector variant of "taktuk_recv" (similar to "readv" system function).

           WARNING:  the  buffer size should be sufficient to receive all the data of the matching send. If this
           is not the case, the program is likely to end up abruptly with a segmentation fault.

   <b>low-level</b> <b>recv</b> <b>functions</b>
       <b>int</b> <b>taktuk_wait_message(unsigned</b> <b>long*</b> <b>from,</b> <b>size_t</b> <b>*size,</b> <b>struct</b> <b>timeval</b> <b>*timeout);</b>
       <b>int</b> <b>taktuk_read</b> <b>(void*</b> <b>buffer,</b> <b>size_t</b> <b>length);</b>
       <b>int</b> <b>taktuk_readv(const</b> <b>struct</b> <b>iovec</b> <b>*iov,</b> <b>int</b> <b>iovcnt);</b>
           "taktuk_wait_message" waits for a taktuk message to be available and  sets  "from"   to  the  logical
           number  of  the sender and "size" to the size of the received message.  It must be followed by a call
           to  either  "taktuk_read"  or  "taktuk_readv"  to  read  the  data   (using   the   size   given   by
           "taktuk_wait_message").    As  other  <b>TakTuk</b>  receive  functions,  this  function  might  return  the
           TAKTUK_ETMOUT error code if "timeout" is not NULL and expires before the reception.

           If you don't know in advance the size of the data being sent to you, you can use  these  lower  level
           functions.  Actually,  "taktuk_recv"  is  equivalent  to  a call to "taktuk_wait_message" followed by
           errors checks on buffer size and a call to "taktuk_read". This is the same for "taktuk_recvv".

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       When an error occur, all of these functions return one of the following numeric error  code.   A  textual
       description  of  the error is provided by the function taktuk_error_msg() that takes the error code as an
       argument.

       Error codes are the following :

       TAKTUK_ESWRIT
           a call to <a href="../man2/write.2.html">write</a>(2) failed. The code should be accessible using "errno".

       TAKTUK_EFCLSD
           the communication channel to the <b>TakTuk</b> engine has been closed. This typically  occur  when  shutting
           down the logical network (using Ctrl-C on root node for instance).

       TAKTUK_ESREAD (receives only)
           a call to <a href="../man2/read.2.html">read</a>(2) failed. The code should be accessible using "errno".

       TAKTUK_ETMOUT (receives only)
           The call to taktuk_recv() (or its vectorized equivalent) or to "taktuk_wait_message" timeouted.  This
           only occur when giving a non nul "timeout" value to these functions.

       TAKTUK_EALLOC
           An internal memory allocation failure occurred.

       TAKTUK_EIBUFF
           A buffer of incorrect size has been given to store all the data read by a receive function.

       TAKTUK_ENOCON
           The  connector  communication  channels  have  not  been found. This typically occur when launching a
           <b>TakTuk</b> program without using <b>TakTuk</b>.

       TAKTUK_EINVAL (get only)
           The field given to "taktuk_get" is not a valid <b>TakTuk</b> field.

       TAKTUK_EMTXNM (init threads only)
           No memory to allocate a new mutex

       TAKTUK_EMTXAG (init threads only)
           Resources temporarily unavailable for new mutex allocation.

       Other error codes are internal <b>TakTuk</b> errors which should strongly suggest a bug  in  <b>TakTuk</b>.  They  have
       also a textual description that is returned by "taktuk_error_msg".

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/tatkuk.1.html">tatkuk</a>(1), <a href="../man3/TakTuk.3.html">TakTuk</a>(3), TakTuk::<a href="../man3/Pilot.3.html">Pilot</a>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
       The  original concept of <b>TakTuk</b> has been proposed by Cyrille Martin in his PhD thesis. People involved in
       this work include Jacques Briat, Olivier Richard, Thierry Gautier and Guillaume Huard.

       The author of the version 3 (perl version) and current maintainer of the package is Guillaume Huard.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       The "taktukcomm" communication interface library is provided under the terms of the  GNU  General  Public
       License version 2 or later.

perl v5.38.2                                       2024-04-01                                          <u><a href="../man3/TAKTUK.3.html">TAKTUK</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>