<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>procps_pids - API to access process information in the /proc filesystem</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/procps">procps_4.0.4-8ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       procps_pids - API to access process information in the <a href="file:/proc">/proc</a> filesystem

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;libproc2/pids.h&gt;

       int <b>procps_pids_new</b>   (struct pids_info **<u>info</u>, enum pids_item *<u>items</u>, int <u>numitems</u>);
       int <b>procps_pids_ref</b>   (struct pids_info  *<u>info</u>);
       int <b>procps_pids_unref</b> (struct pids_info **<u>info</u>);

       struct pids_stack *<b>procps_pids_get</b> (
           struct pids_info *<u>info</u>,
           enum pids_fetch_type <u>which</u>);

       struct pids_fetch *<b>procps_pids_reap</b> (
           struct pids_info *<u>info</u>,
           enum pids_fetch_type <u>which</u>);

       struct pids_fetch *<b>procps_pids_select</b> (
           struct pids_info *<u>info</u>,
           unsigned *<u>these</u>,
           int <u>numthese</u>,
           enum pids_select_type <u>which</u>);

       struct pids_stack **<b>procps_pids_sort</b> (
           struct pids_info *<u>info</u>,
           struct pids_stack *<u>stacks</u>[],
           int <u>numstacked</u>,
           enum pids_item <u>sortitem</u>,
           enum pids_sort_order <u>order</u>);

       int <b>procps_pids_reset</b> (
           struct pids_info *<u>info</u>,
           enum pids_item *<u>newitems</u>,
           int <u>newnumitems</u>);

       struct pids_stack *<b>fatal_proc_unmounted</b> (
           struct pids_info *<u>info</u>,
           int <u>return_self</u>);

       Link with <u>-lproc2</u>.

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>Overview</b>
       Central  to this interface is a simple `result' structure reflecting an `item' plus its value (in a union
       with standard C language types as members).  All `result'  structures  are  automatically  allocated  and
       provided by the library.

       By  specifying  an array of `items', these structures can be organized as a `stack', potentially yielding
       many results with a single function call.  Thus, a `stack' can be viewed  as  a  variable  length  record
       whose content and order is determined solely by the user.

       As  part  of this interface there are two unique enumerators.  The `noop' and `extra' items exist to hold
       user values.  They are never set by the library, but the `extra' result will be zeroed with each  library
       interaction.

       The  pids.h  file  will  be  an  essential document during user program development.  There you will find
       available items, their return type (the `result' struct member name) and  the  source  for  such  values.
       Additional enumerators and structures are also documented there.

   <b>Usage</b>
       The following would be a typical sequence of calls to this interface.

       1. <b>fatal_proc_unmounted()</b>
       2. <b>procps_pids_new()</b>
       3. <b>procps_pids_get()</b>, <b>procps_pids_reap()</b> or <b>procps_pids_select()</b>
       4. <b>procps_pids_unref()</b>

       The  <b>get</b>  function is an iterator for successive PIDs/TIDs, returning those `items' previously identified
       via <b>new</b> or <b>reset</b>.

       Two functions support unpredictable variable outcomes.  The <b>reap</b> function gathers data for all  processes
       while  the  <b>select</b>  function  deals  with  specific PIDs or UIDs.  Both can return multiple `stacks' each
       containing multiple `result' structures.  Optionally, a user may choose to <b>sort</b> such results

       To exploit any `stack', and access individual `result' structures, a <u>relative_enum</u> is required  as  shown
       in  the  <b>VAL</b> macro defined in the header file.  Such values could be hard coded as: 0 through numitems-1.
       However, this need is typically satisfied by creating your own enumerators corresponding to the order  of
       the `items' array.

   <b>Caveats</b>
       The &lt;pids&gt; API differs from others in that those items of interest must be provided at <b>new</b> or <b>reset</b> time,
       the latter being unique to this API.  If either the <u>items</u> or <u>numitems</u> parameter is zero at <b>new</b> time, then
       <b>reset</b> becomes mandatory before issuing any other call.

       For  the  <b>new</b>  and  <b>unref</b> functions, the address of an <u>info</u> struct pointer must be supplied.  With <b>new</b> it
       must have been initialized to NULL.  With <b>unref</b> it will be reset to NULL if the reference  count  reaches
       zero.

       The  <b>get</b>  and  <b>reap</b>  functions  use  the  <u>which</u> parameter to specify whether just tasks or both tasks and
       threads are to be fetched.

       The <b>select</b> function requires an array of PIDs or UIDs as <u>these</u> along  with  <u>numthese</u>  to  identify  which
       processes are to be fetched.  This function then operates as a subset of <b>reap</b>.

       When  using  the  <b>sort</b> function, the parameters <u>stacks</u> and <u>numstacked</u> would normally be those returned in
       the `pids_fetch' structure.

       Lastly, a <b>fatal_proc_unmounted</b> function may be called before any other function to ensure that the <a href="file:/proc/">/proc/</a>
       directory is mounted.  As such, the <u>info</u> parameter would be NULL and the <u>return_self</u> parameter zero.  If,
       however, some items are desired for the issuing program (a <u>return_self</u> other than zero) then the <b>new</b> call
       must precede it to identify the <u>items</u> and obtain the required <u>info</u> pointer.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
   <b>Functions</b> <b>Returning</b> <b>an</b> <b>`int'</b>
       An error will be indicated by a negative number that is always the inverse of  some  well  known  errno.h
       value.

       Success  is  indicated  by  a zero return value.  However, the <b>ref</b> and <b>unref</b> functions return the current
       <u>info</u> structure reference count.

   <b>Functions</b> <b>Returning</b> <b>an</b> <b>`address'</b>
       An error will be indicated by a NULL return pointer with the reason found in the formal errno value.

       Success  is  indicated  by  a  pointer  to  the  named  structure.   However,   if   one   survives   the
       <b>fatal_proc_unmounted</b> call, NULL is always returned when <u>return_self</u> is zero.

</pre><h4><b>DEBUGGING</b></h4><pre>
       To aid in program development, there are two procps-ng provisions that can be exploited.

       The  first  is  a supplied file named `libproc.supp' which may be useful when developing a <u>multi-threaded</u>
       application.  When used with the valgrind `--suppressions=' option, warnings associated with  the  procps
       library itself are avoided.

       Such  warnings  arise  because  the  library  handles  heap based allocations in a thread-safe manner.  A
       <u>single-threaded</u> application will not receive those warnings.

       The second provision can help ensure `result' member references  agree  with  library  expectations.   It
       assumes that a supplied macro in the header file is used to access the `result' value.

       This  feature  can  be  activated  through  either of the following methods and any discrepancies will be
       written to <b>stderr</b>.

       1) Add CFLAGS='-DXTRA_PROCPS_DEBUG' to any other ./configure options your project may employ.

       2) Add #include &lt;procps/xtra-procps-debug.h&gt; to any program <u>after</u> the #include &lt;procps/pids.h&gt;.

       This verification feature incurs substantial overhead.   Therefore,  it  is  important  that  it  <u>not</u>  be
       activated for a production/release build.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLE(S)</b></h4><pre>
       The value set for the following is unimportant, just its presence.

       LIBPROC_HIDE_KERNEL
              This  will  hide  kernel  threads  which  would  otherwise  be  returned  with  a <b>procps_pids_get</b>,
              <b>procps_pids_select</b> or <b>procps_pids_reap</b> call.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/procps.3.html">procps</a></b>(3), <b><a href="../man3/procps_misc.3.html">procps_misc</a></b>(3), <b><a href="../man5/proc.5.html">proc</a></b>(5).

libproc2                                           August 2022                                    <u><a href="../man3/PROCPS_PIDS.3.html">PROCPS_PIDS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>