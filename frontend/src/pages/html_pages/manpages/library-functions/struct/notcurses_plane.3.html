<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>notcurses_plane - operations on ncplanes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnotcurses-core-dev">libnotcurses-core-dev_3.0.7+dfsg.1-1ubuntu8_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       notcurses_plane - operations on ncplanes

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;notcurses/notcurses.h&gt;</b>

              #define NCPLANE_OPTION_HORALIGNED   0x0001ull
              #define NCPLANE_OPTION_VERALIGNED   0x0002ull
              #define NCPLANE_OPTION_MARGINALIZED 0x0004ull
              #define NCPLANE_OPTION_FIXED        0x0008ull
              #define NCPLANE_OPTION_AUTOGROW     0x0010ull
              #define NCPLANE_OPTION_VSCROLL      0x0020ull

              typedef struct ncplane_options {
                int y;            // vertical placement relative to parent plane
                int x;            // horizontal placement relative to parent plane
                int rows;         // number of rows, must be positive
                int cols;         // number of columns, must be positive
                void* userptr;    // user curry, may be NULL
                const char* name; // name (used only for debugging), may be NULL
                int (*resizecb)(struct ncplane*); // called on parent resize
                uint64_t flags;   // closure over NCPLANE_OPTION_*
                unsigned margin_b, margin_r; // bottom and right margins
              } ncplane_options;

              #define NCSTYLE_MASK      0xffffu
              #define NCSTYLE_ITALIC    0x0010u
              #define NCSTYLE_UNDERLINE 0x0008u
              #define NCSTYLE_UNDERCURL 0x0004u
              #define NCSTYLE_BOLD      0x0002u
              #define NCSTYLE_STRUCK    0x0001u
              #define NCSTYLE_NONE      0

       <b>struct</b> <b>ncplane*</b> <b>ncplane_create(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>const</b> <b>ncplane_options*</b> <u>nopts</u><b>);</b>

       <b>struct</b> <b>ncplane*</b> <b>ncpile_create(struct</b> <b>notcurses*</b> <u>n</u><b>,</b> <b>const</b> <b>ncplane_options*</b> <u>nopts</u><b>);</b>

       <b>struct</b> <b>ncplane*</b> <b>ncplane_reparent(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>struct</b> <b>ncplane*</b> <u>newparent</u><b>);</b>

       <b>struct</b> <b>ncplane*</b> <b>ncplane_reparent_family(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>struct</b> <b>ncplane*</b> <u>newparent</u><b>);</b>

       <b>int</b> <b>ncplane_descendant_p(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>const</b> <b>struct</b> <b>ncplane*</b> <u>ancestor</u><b>);</b>

       <b>int</b> <b>ncplane_resize_realign(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>int</b> <b>ncplane_resize_maximize(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>int</b> <b>ncplane_resize_marginalized(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>int</b> <b>ncplane_resize_placewithin(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>void</b> <b>ncplane_set_resizecb(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>int(</b><u><b>resizecb)(struct</b></u> <u><b>ncplane</b></u><b>));</b>

       <b>int</b> <b>(</b><u><b>ncplane_resizecb(const</b></u> <u><b>struct</b></u> <u><b>ncplane</b></u> <u>n</u>**))(struct ncplane*);**

       <b>struct</b> <b>ncplane*</b> <b>ncplane_dup(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>void*</b> <u>opaque</u><b>);</b>

       <b>int</b>  <b>ncplane_resize(struct</b>  <b>ncplane*</b>  <u>n</u><b>,</b>  <b>int</b> <u>keepy</u><b>,</b> <b>int</b> <u>keepx</u><b>,</b> <b>int</b> <u>keepleny</u><b>,</b> <b>int</b> <u>keeplenx</u><b>,</b> <b>int</b> <u>yoff</u><b>,</b> <b>int</b>
       <u>xoff</u><b>,</b> <b>int</b> <u>ylen</u><b>,</b> <b>int</b> <u>xlen</u><b>);</b>

       <b>int</b> <b>ncplane_move_yx(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>int</b> <u>y</u><b>,</b> <b>int</b> <u>x</u><b>);</b>

       <b>int</b> <b>ncplane_move_rel(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>int</b> <u>y</u><b>,</b> <b>int</b> <u>x</u><b>);</b>

       <b>void</b> <b>ncplane_yx(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>int*</b> <b>restrict</b> <u>y</u><b>,</b> <b>int*</b> <b>restrict</b> <u>x</u><b>);</b>

       <b>int</b> <b>ncplane_y(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>int</b> <b>ncplane_x(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>void</b> <b>ncplane_abs_yx(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>int*</b> <u>y</u><b>,</b> <b>int*</b> <u>x</u><b>);</b>

       <b>int</b> <b>ncplane_abs_y(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>int</b> <b>ncplane_abs_x(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>struct</b> <b>ncplane*</b> <b>ncplane_parent(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>const</b> <b>struct</b> <b>ncplane*</b> <b>ncplane_parent_const(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>int</b> <b>ncplane_set_base_cell(struct</b> <b>ncplane*</b> <u>ncp</u><b>,</b> <b>const</b> <b>nccell*</b> <u>c</u><b>);</b>

       <b>int</b> <b>ncplane_set_base(struct</b> <b>ncplane*</b> <u>ncp</u><b>,</b> <b>const</b> <b>char*</b> <u>egc</u><b>,</b> <b>uint16_t</b> <u>stylemask</u><b>,</b> <b>uint64_t</b> <u>channels</u><b>);</b>

       <b>int</b> <b>ncplane_base(struct</b> <b>ncplane*</b> <u>ncp</u><b>,</b> <b>nccell*</b> <u>c</u><b>);</b>

       <b>static</b> <b>inline</b> <b>void</b> <b>ncplane_move_top(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>static</b> <b>inline</b> <b>void</b> <b>ncplane_move_bottom(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>void</b> <b>ncplane_move_family_top(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>void</b> <b>ncplane_move_family_bottom(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>int</b> <b>ncplane_move_above(struct</b> <b>ncplane*</b> <b>restrict</b> <u>n</u><b>,</b> <b>struct</b> <b>ncplane*</b> <b>restrict</b> <u>targ</u><b>);</b>

       <b>int</b> <b>ncplane_move_below(struct</b> <b>ncplane*</b> <b>restrict</b> <u>n</u><b>,</b> <b>struct</b> <b>ncplane*</b> <b>restrict</b> <u>targ</u><b>);</b>

       <b>int</b> <b>ncplane_move_family_above(struct</b> <b>ncplane*</b> <b>restrict</b> <u>n</u><b>,</b> <b>struct</b> <b>ncplane*</b> <b>restrict</b> <u>targ</u><b>);</b>

       <b>int</b> <b>ncplane_move_family_below(struct</b> <b>ncplane*</b> <b>restrict</b> <u>n</u><b>,</b> <b>struct</b> <b>ncplane*</b> <b>restrict</b> <u>targ</u><b>);</b>

       <b>struct</b> <b>ncplane*</b> <b>ncplane_below(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>struct</b> <b>ncplane*</b> <b>ncplane_above(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>char*</b> <b>ncplane_at_cursor(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>uint16_t*</b> <u>stylemask</u><b>,</b> <b>uint64_t*</b> <u>channels</u><b>);</b>

       <b>int</b> <b>ncplane_at_cursor_cell(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>nccell*</b> <u>c</u><b>);</b>

       <b>char*</b> <b>ncplane_at_yx(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>int</b> <u>y</u><b>,</b> <b>int</b> <u>x</u><b>,</b> <b>uint16_t*</b> <u>stylemask</u><b>,</b> <b>uint64_t*</b> <u>channels</u><b>);</b>

       <b>int</b> <b>ncplane_at_yx_cell(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>int</b> <u>y</u><b>,</b> <b>int</b> <u>x</u><b>,</b> <b>nccell*</b> <u>c</u><b>);</b>

       <b>uint32_t*</b> <b>ncplane_as_rgba(const</b> <b>struct</b> <b>ncplane*</b> <u>nc</u><b>,</b> <b>ncblitter_e</b> <u>blit</u><b>,</b> <b>unsigned</b> <u>begy</u><b>,</b> <b>unsigned</b>  <u>begx</u><b>,</b>  <b>un‐</b>
       <b>signed</b> <u>leny</u><b>,</b> <b>unsigned</b> <u>lenx</u><b>,</b> <b>unsigned*</b> <u>pxdimy</u><b>,</b> <b>unsigned*</b> <u>pxdimx</u><b>);</b>

       <b>char*</b> <b>ncplane_contents(const</b> <b>struct</b> <b>ncplane*</b> <u>nc</u><b>,</b> <b>int</b> <u>begy</u><b>,</b> <b>int</b> <u>begx</u><b>,</b> <b>unsigned</b> <u>leny</u><b>,</b> <b>unsigned</b> <u>lenx</u><b>);</b>

       <b>void*</b> <b>ncplane_set_userptr(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>void*</b> <u>opaque</u><b>);</b>

       <b>void*</b> <b>ncplane_userptr(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>void</b> <b>ncplane_dim_yx(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned*</b> <b>restrict</b> <u>rows</u><b>,</b> <b>unsigned*</b> <b>restrict</b> <u>cols</u><b>);</b>

       <b>static</b> <b>inline</b> <b>unsigned</b> <b>ncplane_dim_y(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>static</b> <b>inline</b> <b>unsigned</b> <b>ncplane_dim_x(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>void</b> <b>ncplane_cursor_yx(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned*</b> <b>restrict</b> <u>y</u><b>,</b> <b>unsigned*</b> <b>restrict</b> <u>x</u><b>);</b>

       <b>unsigned</b> <b>ncplane_cursor_y(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>unsigned</b> <b>ncplane_cursor_x(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>void</b>  <b>ncplane_translate(const</b>  <b>struct</b>  <b>ncplane*</b> <u>src</u><b>,</b> <b>const</b> <b>struct</b> <b>ncplane*</b> <u>dst</u><b>,</b> <b>int*</b> <b>restrict</b> <u>y</u><b>,</b> <b>int*</b> <b>re‐</b>
       <b>strict</b> <u>x</u><b>);</b>

       <b>bool</b> <b>ncplane_translate_abs(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>int*</b> <b>restrict</b> <u>y</u><b>,</b> <b>int*</b> <b>restrict</b> <u>x</u><b>);</b>

       <b>uint64_t</b> <b>ncplane_channels(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>void</b> <b>ncplane_set_channels(struct</b> <b>ncplane*</b> <u>nc</u><b>,</b> <b>uint64_t</b> <u>channels</u><b>);</b>

       <b>static</b> <b>inline</b> <b>unsigned</b> <b>ncplane_bchannel(struct</b> <b>ncplane*</b> <u>nc</u><b>);</b>

       <b>static</b> <b>inline</b> <b>unsigned</b> <b>ncplane_fchannel(struct</b> <b>ncplane*</b> <u>nc</u><b>);</b>

       <b>uint64_t</b> <b>ncplane_set_bchannel(struct</b> <b>ncplane*</b> <u>nc</u><b>,</b> <b>uint32_t</b> <u>channel</u><b>);</b>

       <b>uint64_t</b> <b>ncplane_set_fchannel(struct</b> <b>ncplane*</b> <u>nc</u><b>,</b> <b>uint32_t</b> <u>channel</u><b>);</b>

       <b>static</b> <b>inline</b> <b>unsigned</b> <b>ncplane_fg_rgb(struct</b> <b>ncplane*</b> <u>nc</u><b>);</b>

       <b>static</b> <b>inline</b> <b>unsigned</b> <b>ncplane_bg_rgb(struct</b> <b>ncplane*</b> <u>nc</u><b>);</b>

       <b>int</b> <b>ncplane_set_fg_rgb(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>uint32_t</b> <u>channel</u><b>);</b>

       <b>int</b> <b>ncplane_set_bg_rgb(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>uint32_t</b> <u>channel</u><b>);</b>

       <b>static</b> <b>inline</b> <b>unsigned</b> <b>ncplane_fg_alpha(struct</b> <b>ncplane*</b> <u>nc</u><b>);</b>

       <b>static</b> <b>inline</b> <b>unsigned</b> <b>ncplane_bg_alpha(struct</b> <b>ncplane*</b> <u>nc</u><b>);</b>

       <b>int</b> <b>ncplane_set_fg_alpha(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned</b> <u>alpha</u><b>);</b>

       <b>int</b> <b>ncplane_set_bg_alpha(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned</b> <u>alpha</u><b>);</b>

       <b>static</b> <b>inline</b> <b>unsigned</b> <b>ncplane_fg_rgb8(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned*</b> <u>r</u><b>,</b> <b>unsigned*</b> <u>g</u><b>,</b> <b>unsigned*</b> <u>b</u><b>);</b>

       <b>static</b> <b>inline</b> <b>unsigned</b> <b>ncplane_bg_rgb8(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned*</b> <u>r</u><b>,</b> <b>unsigned*</b> <u>g</u><b>,</b> <b>unsigned*</b> <u>b</u><b>);</b>

       <b>int</b> <b>ncplane_set_fg_rgb8(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned</b> <u>r</u><b>,</b> <b>unsigned</b> <u>g</u><b>,</b> <b>unsigned</b> <u>b</u><b>);</b>

       <b>int</b> <b>ncplane_set_bg_rgb8(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned</b> <u>r</u><b>,</b> <b>unsigned</b> <u>g</u><b>,</b> <b>unsigned</b> <u>b</u><b>);</b>

       <b>void</b> <b>ncplane_set_fg_rgb8_clipped(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>int</b> <u>r</u><b>,</b> <b>int</b> <u>g</u><b>,</b> <b>int</b> <u>b</u><b>);</b>

       <b>void</b> <b>ncplane_set_bg_rgb8_clipped(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>int</b> <u>r</u><b>,</b> <b>int</b> <u>g</u><b>,</b> <b>int</b> <u>b</u><b>);</b>

       <b>void</b> <b>ncplane_set_fg_default(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>void</b> <b>ncplane_set_bg_default(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>int</b> <b>ncplane_set_fg_palindex(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned</b> <u>idx</u><b>);</b>

       <b>int</b> <b>ncplane_set_bg_palindex(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned</b> <u>idx</u><b>);</b>

       <b>uint16_t</b> <b>ncplane_styles(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>void</b> <b>ncplane_set_styles(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned</b> <u>stylebits</u><b>);</b>

       <b>void</b> <b>ncplane_on_styles(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned</b> <u>stylebits</u><b>);</b>

       <b>void</b> <b>ncplane_off_styles(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned</b> <u>stylebits</u><b>);</b>

       <b>void</b> <b>ncplane_greyscale(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>int</b> <b>ncplane_blit_bgrx(struct</b> <b>ncplane*</b> <u>nc</u><b>,</b> <b>int</b> <u>placey</u><b>,</b> <b>int</b> <u>placex</u><b>,</b> <b>int</b> <u>linesize</u><b>,</b> <b>ncblitter_e</b> <u>blitter</u><b>,</b> <b>con‐</b>
       <b>st</b> <b>unsigned</b> <b>char*</b> <u>data</u><b>,</b> <b>int</b> <u>begy</u><b>,</b> <b>int</b> <u>begx</u><b>,</b> <b>int</b> <u>leny</u><b>,</b> <b>int</b> <u>lenx</u><b>);</b>

       <b>int</b> <b>ncplane_blit_rgba(struct</b> <b>ncplane*</b> <u>nc</u><b>,</b> <b>int</b> <u>placey</u><b>,</b> <b>int</b> <u>placex</u><b>,</b> <b>int</b> <u>linesize</u><b>,</b> <b>ncblitter_e</b> <u>blitter</u><b>,</b> <b>con‐</b>
       <b>st</b> <b>unsigned</b> <b>char*</b> <u>data</u><b>,</b> <b>int</b> <u>begy</u><b>,</b> <b>int</b> <u>begx</u><b>,</b> <b>int</b> <u>leny</u><b>,</b> <b>int</b> <u>lenx</u><b>);</b>

       <b>int</b> <b>ncplane_destroy(struct</b> <b>ncplane*</b> <u>ncp</u><b>);</b>

       <b>void</b> <b>notcurses_drop_planes(struct</b> <b>notcurses*</b> <u>nc</u><b>);</b>

       <b>int</b> <b>ncplane_mergedown(struct</b> <b>ncplane*</b> <u>src</u><b>,</b> <b>struct</b> <b>ncplane*</b> <u>dst</u><b>,</b> <b>int</b> <u>begsrcy</u><b>,</b> <b>int</b> <u>begsrcx</u><b>,</b> <b>unsigned</b>  <u>leny</u><b>,</b>
       <b>unsigned</b> <u>lenx</u><b>,</b> <b>int</b> <u>dsty</u><b>,</b> <b>int</b> <u>dstx</u><b>);</b>

       <b>int</b> <b>ncplane_mergedown_simple(struct</b> <b>ncplane*</b> <b>restrict</b> <u>src</u><b>,</b> <b>struct</b> <b>ncplane*</b> <b>restrict</b> <u>dst</u><b>);</b>

       <b>void</b> <b>ncplane_erase(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>int</b> <b>ncplane_erase_region(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>int</b> <u>ystart</u><b>,</b> <b>int</b> <u>xstart</u><b>,</b> <b>int</b> <u>ylen</u><b>,</b> <b>int</b> <u>xlen</u><b>);</b>

       <b>bool</b> <b>ncplane_set_scrolling(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned</b> <u>scrollp</u><b>);</b>

       <b>bool</b> <b>ncplane_scrolling_p(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>bool</b> <b>ncplane_set_autogrow(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>unsigned</b> <u>growp</u><b>);</b>

       <b>bool</b> <b>ncplane_autogrow_p(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>int</b> <b>ncplane_scrollup(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>int</b> <u>r</u><b>);</b>

       <b>int</b> <b>ncplane_scrollup_child(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>const</b> <b>struct</b> <b>ncplane*</b> <u>child</u><b>);</b>

       <b>int</b> <b>ncplane_rotate_cw(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>int</b> <b>ncplane_rotate_ccw(struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

       <b>void</b>  <b>ncplane_pixel_geom(const</b>  <b>struct</b>  <b>notcurses*</b> <u>n</u><b>,</b> <b>unsigned*</b> <b>restrict</b> <u>pxy</u><b>,</b> <b>unsigned*</b> <b>restrict</b> <u>pxx</u><b>,</b> <b>un‐</b>
       <b>signed*</b> <b>restrict</b> <u>celldimy</u><b>,</b> <b>unsigned*</b> <b>restrict</b> <u>celldimx</u><b>,</b> <b>unsigned*</b> <b>restrict</b> <u>maxbmapy</u><b>,</b>  <b>unsigned*</b>  <b>restrict</b>
       <u>maxbmapx</u><b>);</b>

       <b>int</b> <b>ncplane_set_name(struct</b> <b>ncplane*</b> <u>n</u><b>,</b> <b>const</b> <b>char*</b> <u>name</u><b>);</b>

       <b>char*</b> <b>ncplane_name(const</b> <b>struct</b> <b>ncplane*</b> <u>n</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Ncplanes  are the fundamental drawing object of notcurses.  All output functions take a <b>struct</b> <b>ncplane</b> as
       an argument.  They can be any size, and placed anywhere.  In addition to its  framebuffer--a  rectilinear
       matrix of <b>nccell</b>s (see <b><a href="../man3/notcurses_cell.3.html">notcurses_cell</a>(3)</b>)--an ncplane is defined by:

       • a base <b>nccell</b>, used for any cell on the plane without a glyph,

       • the egcpool backing its <b>nccell</b>s,

       • a current cursor location,

       • a current style, foreground channel, and background channel,

       • its geometry,

       • a configured user pointer,

       • position relative to the standard plane,

       • the plane, if any, to which it is bound,

       • the next plane bound by the plane to which it is bound,

       • the head of the list of its bound planes,

       • its resize methodology,

       • whether a sprixel (see <b><a href="../man3/notcurses_visual.3.html">notcurses_visual</a>(3)</b>) is associated,

       • its z-index, and

       • a name (used only for debugging).

       New  planes  can be created with <b>ncplane_create</b>.  If a plane is bound to another, x and y coordinates are
       relative to the plane to which it is bound, and if this latter plane moves, all  its  bound  planes  move
       along  with  it.   When  a  plane is destroyed, all planes bound to it (directly or transitively) are de‐
       stroyed.

       If the <b>NCPLANE_OPTION_HORALIGNED</b> flag is provided, <u><b>x</b></u> is interpreted as an <b>ncalign_e</b> rather  than  an  ab‐
       solute  position.   If  the  <b>NCPLANE_OPTION_VERALIGNED</b> flag is provided, <u><b>y</b></u> is interpreted as an <b>ncalign_e</b>
       rather than an absolute postiion.  Either way, all positions are  relative  to  the  parent  plane.   <b>nc‐</b>
       <b>plane_resize_realign</b> should usually be used together with these flags, so that the plane is automatically
       realigned upon a resize of its parent.

       If  the  <b>NCPLANE_OPTION_MARGINALIZED</b>  flag is provided, neither <b>NCPLANE_OPTION_HORALIGNED</b> nor <b>NCPLANE_OP‐</b>
       <b>TION_VERALIGNED</b> may be provided, and <u><b>rows</b></u> and <u><b>cols</b></u> must both be 0.  <u><b>y</b></u> and <u><b>x</b></u> will be  interpreted  as  top
       and left margins.  <u><b>margin_b</b></u> and <u><b>margin_r</b></u> will be interpreted as bottom and right margins.  The plane will
       take  the maximum space possible subject to its parent planes and these margins.  The plane cannot become
       smaller than 1x1 (the margins are best-effort).  <b>ncplane_resize_marginalized</b> should usually be  used  to‐
       gether with this flag, so that the plane is automatically resized.

       <b>ncplane_reparent</b>  detaches  the  plane  <u><b>n</b></u> from any plane to which it is bound, and binds it to <u><b>newparent</b></u>.
       Its children are reparented to its previous parent.  The standard plane cannot be reparented.  If <u><b>newpar‐</b></u>
       <u><b>ent</b></u> is <b>NULL</b>, the plane becomes the root plane of a new, unrendered stack.   When  <b>ncplane_reparent_family</b>
       is used, all planes bound to <u><b>n</b></u> move along with it during a reparenting operation.  See Piles below.

       <b>ncplane_destroy</b>  destroys  a  particular  ncplane,  after  which  it  must  not  be used again.  <b>notcurs‐</b>
       <b>es_drop_planes</b> destroys all ncplanes other than the stdplane.  Any references  to  such  planes  are,  of
       course,  invalidated.  It is undefined to destroy a plane concurrently with any other operation involving
       that plane, or any operation involving the z-axis.

       It is an error for two threads to concurrently mutate a single ncplane.  So long as rendering is not tak‐
       ing place, however, multiple threads may safely output to multiple ncplanes.  So long as all threads  are
       readers, multiple threads may work with a single ncplane.  A reading function is any which accepts a <b>con‐</b>
       <b>st</b> <b>struct</b> <b>ncplane</b>.

       A  plane  can  be  moved relative to its parent plane's origin with <b>ncplane_move_yx</b>.  If the plane has no
       parent, the move is relative to the rendering area.  A plane can be moved off-screen entirely,  in  which
       case it will not be visible following rasterization; it can also be partially off-screen.

       A  plane has a virtual cursor; Set its new position with <b>ncplane_cursor_move_yx</b>.  Specifying -1 as one or
       both coordinates will hold that axis constant.  You may move a cursor relatively to its current  position
       with  <b>ncplane_cursor_move_rel</b>.   Unless  coordinates  are specified for a call, action takes place at the
       plane's virtual cursor, which automatically moves along with output.  The current virtual cursor location
       can be acquired with <b>ncplane_cursor_yx</b>.

       <b>ncplane_yx</b> returns the coordinates of the specified plane's origin, relative to the plane to which it  is
       bound.   Either or both of <u><b>y</b></u> and <u><b>x</b></u> may be <b>NULL</b>.  <b>ncplane_y</b> and <b>ncplane_x</b> allow a single component of this
       location to be retrieved.  <b>ncplane_abs_yx</b> returns the coordinates of the specified plane's  origin  rela‐
       tive to its pile.

       <b>ncplane_translate</b>  translates coordinates expressed relative to the plane <u><b>src</b></u>, and writes the coordinates
       of that cell relative to <u><b>dst</b></u>.  The cell need not intersect with <u><b>dst</b></u>, though this will  yield  coordinates
       which  are  invalid  for writing or reading on <u><b>dst</b></u>.  If <u><b>dst</b></u> is <b>NULL</b>, it is taken to refer to the standard
       plane.  <b>ncplane_translate_abs</b> takes coordinates expressed relative to the standard plane, and returns co‐
       ordinates relative to <u><b>dst</b></u>, returning <b>false</b> if the coordinates are invalid for <u><b>dst</b></u>.

       <b>ncplane_mergedown</b> writes to <u><b>dst</b></u> the frame that would be rendered if only <u><b>src</b></u> and <u><b>dst</b></u> existed on the z-ax‐
       is, ad <u><b>dst</b></u> represented the entirety of the rendering region.  Only those cells where <u><b>src</b></u> intersects  with
       <u><b>dst</b></u> might see changes.  It is an error to merge a plane onto itself.

       <b>ncplane_erase</b> zeroes out every cell of the plane, dumps the egcpool, and homes the cursor.  The base cell
       is  preserved,  as  are the active attributes.  <b>ncplane_erase_region</b> does the same for a subregion of the
       plane.  For the latter, supply 0 for <u><b>ylen</b></u> and/or <u><b>xlen</b></u> to erase through that dimension,  starting  at  the
       specified point.  Supply -1 for <u><b>ystart</b></u> and/or <u><b>xstart</b></u> to use the cursor's current position along that axis
       for a starting point.  Negative <u><b>ylen</b></u> and <u><b>xlen</b></u> move up and to the left from the starting coordinate; posi‐
       tive <u><b>ylen</b></u> and <u><b>xlen</b></u> move down and to the right from same.  See BUGS below.

       When  a plane is resized (whether by <b>ncplane_resize</b>, <b>SIGWINCH</b>, or any other mechanism), a depth-first re‐
       cursion is performed on its children.  Each child plane having a non-<b>NULL</b> <b>resizecb</b> will see that callback
       invoked following resizing of its parent's plane.  If it returns non-zero, the  resizing  cascade  termi‐
       nates, returning non-zero.  Otherwise, resizing proceeds recursively.

       <b>ncplane_move_top</b> and <b>ncplane_move_bottom</b> extract their argument <u><b>n</b></u> from the z-axis, and reinsert it at the
       top  or  bottom,  respectively, of its pile.  These functions are both <a href="../man1/O.1.html">O</a>(1).  <b>ncplane_move_family_top</b> and
       <b>ncplane_move_family_bottom</b> do the same, and move any bound descendants along with  the  plane.   Ordering
       among  the plane and its descendants will be maintained.  For example, assume a pile with A at the top of
       its z-axis, followed by B, C, D, and E, where E is bound to C.  Calling <b>ncplane_move_family_top</b> on C will
       result in the order CEABD.  Calling <b>ncplane_move_family_bottom</b> on C  will  result  in  the  order  ABDCE.
       Calling <b>ncplane_move_family_top</b> or <b>ncplane_move_top</b> on E will result in EABCD.  Calling <b>ncplane_move_fam‐</b>
       <b>ily_bottom</b> on E is a no-op.  These two functions are O(N) on the number of planes in the pile.

       <b>ncplane_move_above</b>  and <b>ncplane_move_below</b> move the argument <u><b>n</b></u> above or below, respectively, the argument
       <u><b>targ</b></u>.  Both operate in <a href="../man1/O.1.html">O</a>(1).

       <b>ncplane_at_yx</b> and <b>ncplane_at_yx_cell</b> retrieve the contents of the plane at the specified coordinate.  The
       content is returned as it will be used during rendering, and thus integrates any base cell  as  appropri‐
       ate.   If called on the secondary columns of a wide glyph, <b>ncplane_at_yx</b> returns the EGC, and thus cannot
       be used to distinguish between primary and secondary  columns.   <b>ncplane_at_yx_cell</b>,  however,  preserves
       this  information: retrieving a secondary column of a wide glyph with <b>ncplane_at_yx_cell</b> will fill in the
       <b>nccell</b> argument such that <b><a href="../man3/nccell_extended_gcluster.3.html">nccell_extended_gcluster</a>(3)</b> returns an empty string, and <b><a href="../man3/nccell_wide_right_p.3.html">nccell_wide_right_p</a>(3)</b>
       returns <b>true</b>.

       If <b>ncplane_at_yx</b> is invoked upon a sprixel plane, the control sequence will be returned for any valid co‐
       ordinates (note that this may be quite large).  This does not apply to <b>ncplane_at_yx_cell</b>, which will re‐
       turn an error.

       <b>ncplane_set_name</b> sets the plane's name, freeing any old name.  <u><b>name</b></u> may be <b>NULL</b>.  <b>ncplane_set_name</b> dupli‐
       cates the provided name internally.

   <b>Base</b> <b>cells</b>
       Each plane has a base cell, initialized to all zeroes.  When rendering, the cells of the plane are  exam‐
       ined  in  turn.  Each cell has three independent rendering elements--its EGC, its foreground channel, and
       its background channel.  Any default channel is replaced with the corresponding channel from that plane's
       base cell.  <b>ncplane_erase</b> has no effect on the base cell.  Calling <b>ncplane_erase</b> on a  plane  whose  base
       cell is a purple 'A' results (for rendering purposes) in a plane made up entirely of purple 'A's.

       <b>ncplane_set_base_cell</b>  uses  the  <b>nccell</b> <u><b>c</b></u> (which must be bound to the <b>ncplane</b> <u><b>ncp</b></u>, and must be the first
       <b>nccell</b> of a multicolumn sequence) to set the base cell.  <b>ncplane_set_base</b> does the same with <u><b>egc</b></u>,  <u><b>style‐</b></u>
       <u><b>mask</b></u>, and <u><b>channels</b></u>.

   <b>Piles</b>
       A single <b>notcurses</b> context is made up of one or more piles.  A pile is a set of one or more <b>ncplane</b>s, in‐
       cluding  the partial orderings made up of their binding and z-axis pointers.  A pile has a top and bottom
       <b>ncplane</b> (this might be a single plane), and one or more root planes (planes  which  are  bound  to  them‐
       selves).   Multiple threads can concurrently operate on distinct piles, even changing one while rendering
       another.

       Each plane is part of one and only one pile.  By default, a plane is part of  the  same  pile  containing
       that  plane  to which it is bound.  If <b>ncpile_create</b> is used in the place of <b>ncplane_create</b>, the returned
       plane becomes the root plane, top, and bottom of a new pile.  As a root plane, it is bound to itself.   A
       new  pile  can  also  be  created by reparenting a plane to itself, though if the plane is already a root
       plane, this is a no-op.

       When a plane is moved to a different pile (whether new or preexisting), any planes which were bound to it
       are rebound to its previous parent.  If the plane was a root plane of some pile, any bound planes  become
       root planes.  The new plane is placed immediately atop its new parent on its new pile's z-axis.  When <b>nc‐</b>
       <b>plane_reparent_family</b>  is  used, all planes bound to the reparented plane are moved along with it.  Their
       relative z-order is maintained.

       More information is available from <b><a href="../man3/notcurses_pile.3.html">notcurses_pile</a>(3)</b>.

   <b>Binding</b>
       The planes of a pile make up a directed acyclic forest.  Planes bound to  themselves  make  up  the  root
       planes  of  the  pile.   Every plane is either a root plane, or bound to some other plane in its pile.  A
       plane and its descendants make up a family.  When a plane is moved using <b>ncplane_move_yx</b>, its  family  is
       moved along with it.

   <b>Scrolling</b>
       All  planes,  including  the standard plane, are created with scrolling disabled.  Control scrolling on a
       per-plane basis with <b>ncplane_set_scrolling</b>.  Attempting to print past the end of a line will stop at  the
       plane  boundary,  and  indicate  an  error.   On  a  plane  10  columns  wide and two rows high, printing
       "0123456789" at the origin should succeed, but  printing  "01234567890"  will  by  default  fail  at  the
       eleventh  character.   In  either case, the cursor will be left at location 0x10; it must be moved before
       further printing can take place.  If scrolling is enabled, the first row will be filled with 01234546789,
       the second row will have 0 written to its first column, and the cursor will end up at 1x1.  Note that  it
       is still an error to manually attempt to move the cursor off-plane, or to specify off-plane output.  Box-
       drawing  does  not result in scrolling; attempting to draw a 2x11 box on our 2x10 plane will result in an
       error and no output.  When scrolling is enabled, and output takes place while the cursor is past the  end
       of  the  last  row, the first row is discarded, all other rows are moved up, the last row is cleared, and
       output begins at the beginning of the last row.  This does not take place until output is generated (i.e.
       it is possible to fill a plane when scrolling is enabled).

       Creating a  plane  with  the  <b>NCPLANE_OPTION_VSCROLL</b>  flag  is  equivalent  to  immediately  calling  <b>nc‐</b>
       <b>plane_set_scrolling</b> on that plane with an argument of <b>true</b>.

       By  default,  planes  bound  to a scrolling plane will scroll along with it, if they intersect the plane.
       This can be disabled by creating them with the <b>NCPLANE_OPTION_FIXED</b> flag.

   <b>Autogrow</b>
       Normally, once output reaches the right boundary of a plane, it is impossible to place more output unless
       the cursor is first moved.  If scrolling is enabled, the cursor will automatically move down and  to  the
       left in this case, but upon reaching the bottom right corner of the plane, it is impossible to place more
       output  without  a  scrolling event.  If autogrow is in play, the plane will automatically be enlarged to
       accommodate output.  If scrolling is disabled, growth takes place to the right; it otherwise takes  place
       at  the  bottom.   The  plane  only  grows in one dimension.  Autogrow cannot be enabled for the standard
       plane.

       Creating a plane  with  the  <b>NCPLANE_OPTION_AUTOGROW</b>  flag  is  equivalent  to  immediately  calling  <b>nc‐</b>
       <b>plane_set_autogrow</b> on that plane with an argument of <b>true</b>.

   <b>Bitmaps</b>
       <b>ncplane_pixel_geom</b> retrieves pixel geometry details.  <b>pxy</b> and <b>pxx</b> return the size of the plane in pixels.
       <b>celldimy</b>  and  <b>celldimx</b>  return  the  size  of  a cell in pixels (these ought be the same across planes).
       <b>maxbmapy</b> and <b>maxbmapx</b> describe the largest bitmap which can be displayed in  the  plane.   Any  parameter
       (save <b>n</b>) may be <b>NULL</b>.

       When  a  plane is blitted to using <b>ncvisual_blit</b> and <b>NCBLIT_PIXEL</b> (see <b><a href="../man3/notcurses_visual.3.html">notcurses_visual</a>(3)</b>), it ceases to
       accept cell-based output.  The sprixel will remain associated until a  new  sprixel  is  blitted  to  the
       plane,  the plane is resized, the plane is erased, or the plane is destroyed.  The base cell of a sprixe‐
       lated plane has no effect; if the sprixel is not even multiples of the cell geometry, the "excess  plane"
       is ignored during rendering.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>ncplane_create</b> and <b>ncplane_dup</b> return a new <b>struct</b> <b>ncplane</b> on success, or <b>NULL</b> on failure.

       <b>ncplane_userptr</b> returns the configured user pointer for the ncplane, and cannot fail.

       <b>ncplane_below</b>  returns  the  plane  below the specified ncplane.  If the provided plane is the bottommost
       plane, NULL is returned.  It cannot fail.

       <b>ncplane_set_scrolling</b> returns <b>true</b> if scrolling was previously enabled, and <b>false</b> otherwise.

       <b>ncplane_at_yx</b> and <b>ncplane_at_cursor</b> return a heap-allocated copy of the EGC at the relevant cell, or <b>NULL</b>
       if the cell is invalid.  The caller should free  this  result.   <b>ncplane_at_yx_cell</b>  and  <b>ncplane_at_cur‐</b>
       <b>sor_cell</b>  instead  load  these values into an <b>nccell</b>, which is invalidated if the associated plane is de‐
       stroyed.  The caller should release this <b>nccell</b> with <b>nccell_release</b>.

       <b>ncplane_as_rgba</b> returns a heap-allocated array of <b>uint32_t</b> values, each representing a single RGBA pixel,
       or <b>NULL</b> on failure.

       <b>ncplane_erase_region</b> returns -1 if <b>ystart</b> or <b>xstart</b> are less than -1, or outside the plane.

       <b>ncplane_cursor_move_yx</b> returns -1 if the coordinates are beyond the dimensions  of  the  specified  plane
       (except for the special value -1).

       <b>ncplane_cursor_move_rel</b> returns -1 if the coordinates are beyond the dimensions of the specified plane.

       <b>ncplane_name</b> returns a heap-allocated copy of the plane's name, or NULL if it has no name (or on error).

       Functions returning <b>int</b> return 0 on success, and non-zero on error.

       All other functions cannot fail (and return <b>void</b>).

</pre><h4><b>NOTES</b></h4><pre>
</pre><h4><b>BUGS</b></h4><pre>
       <b>ncplane_at_yx</b>  doesn't  yet account for bitmap-based graphics (see <b><a href="../man3/notcurses_visual.3.html">notcurses_visual</a>(3)</b>).  Whatever glyph-
       based contents existed on the plane when the bitmap was blitted will continue to be returned.

       When the alternate screen is not used (see <b><a href="../man3/notcurses_init.3.html">notcurses_init</a>(3)</b>), the contents of the  terminal  at  startup
       remain  present until obliterated on a cell-by-cell basis.  <b>ncplane_erase</b> and <b>ncplane_erase_region</b> <b>cannot</b>
       be used to clear the terminal of startup content.  If you want the screen cleared on startup, but do  not
       want to use (or rely on) the alternate screen, use something like:

              ncplane_set_base(notcurses_stdplane(nc), " ", 0, 0);
              notcurses_render(nc);

       or simply:

              notcurses_refresh(nc);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/notcurses.3.html">notcurses</a>(3)</b>,   <b><a href="../man3/notcurses_capabilities.3.html">notcurses_capabilities</a>(3)</b>,   <b><a href="../man3/notcurses_cell.3.html">notcurses_cell</a>(3)</b>,  <b><a href="../man3/notcurses_output.3.html">notcurses_output</a>(3)</b>,  <b><a href="../man3/notcurses_pile.3.html">notcurses_pile</a>(3)</b>,
       <b><a href="../man3/notcurses_stdplane.3.html">notcurses_stdplane</a>(3)</b>, <b><a href="../man3/notcurses_visual.3.html">notcurses_visual</a>(3)</b>

</pre><h4><b>AUTHORS</b></h4><pre>
       nick black &lt;<a href="mailto:nickblack@linux.com">nickblack@linux.com</a>&gt;.

                                                     v3.0.7                                   <u><a href="../man3/notcurses_plane.3.html">notcurses_plane</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>