<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       putmsg, putpmsg — send a message on a STREAM (<b>STREAMS</b>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;stropts.h&gt;

       int putmsg(int <u>fildes</u>, const struct strbuf *<u>ctlptr</u>,
           const struct strbuf *<u>dataptr</u>, int <u>flags</u>);
       int putpmsg(int <u>fildes</u>, const struct strbuf *<u>ctlptr</u>,
           const struct strbuf *<u>dataptr</u>, int <u>band</u>, int <u>flags</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>putmsg</u>()  function shall create a message from a process buffer(s) and send the message to a STREAMS
       file. The message may contain either a data part, a control part, or both. The data and control parts are
       distinguished by placement in separate buffers, as described  below.  The  semantics  of  each  part  are
       defined by the STREAMS module that receives the message.

       The  <u>putpmsg</u>() function is equivalent to <u>putmsg</u>(), except that the process can send messages in different
       priority bands.  Except where noted, all requirements on <u>putmsg</u>() also pertain to <u>putpmsg</u>().

       The <u>fildes</u> argument specifies a file descriptor referencing  an  open  STREAM.  The  <u>ctlptr</u>  and  <u>dataptr</u>
       arguments each point to a <b>strbuf</b> structure.

       The  <u>ctlptr</u>  argument  points to the structure describing the control part, if any, to be included in the
       message. The <u>buf</u> member in the <b>strbuf</b> structure points  to  the  buffer  where  the  control  information
       resides,  and  the  <u>len</u> member indicates the number of bytes to be sent. The <u>maxlen</u> member is not used by
       <u>putmsg</u>().  In a similar manner, the argument <u>dataptr</u> specifies the data, if any, to be  included  in  the
       message. The <u>flags</u> argument indicates what type of message should be sent and is described further below.

       To  send  the data part of a message, the application shall ensure that <u>dataptr</u> is not a null pointer and
       the <u>len</u> member of <u>dataptr</u> is 0 or greater. To send the control part of a message, the  application  shall
       ensure  that the corresponding values are set for <u>ctlptr</u>.  No data (control) part shall be sent if either
       <u>dataptr</u>(<u>ctlptr</u>) is a null pointer or the <u>len</u> member of <u>dataptr</u>(<u>ctlptr</u>) is set to -1.

       For <u>putmsg</u>(), if a control part is specified and <u>flags</u> is set to RS_HIPRI, a high priority message  shall
       be sent. If no control part is specified, and <u>flags</u> is set to RS_HIPRI, <u>putmsg</u>() shall fail and set <u>errno</u>
       to  <b>[EINVAL]</b>.   If  <u>flags</u>  is  set to 0, a normal message (priority band equal to 0) shall be sent.  If a
       control part and data part are not specified and <u>flags</u> is set to 0, no message shall be sent and 0  shall
       be returned.

       For  <u>putpmsg</u>(),  the  flags  are  different. The <u>flags</u> argument is a bitmask with the following mutually-
       exclusive flags defined: MSG_HIPRI and MSG_BAND. If <u>flags</u> is set to 0, <u>putpmsg</u>() shall fail and set <u>errno</u>
       to <b>[EINVAL]</b>.  If a control part is specified and <u>flags</u> is set to MSG_HIPRI and <u>band</u> is set to 0, a  high-
       priority  message  shall be sent. If <u>flags</u> is set to MSG_HIPRI and either no control part is specified or
       <u>band</u> is set to a non-zero value, <u>putpmsg</u>() shall fail and set <u>errno</u> to <b>[EINVAL]</b>.   If  <u>flags</u>  is  set  to
       MSG_BAND,  then  a  message  shall be sent in the priority band specified by <u>band</u>.  If a control part and
       data part are not specified and <u>flags</u> is set to MSG_BAND, no  message  shall  be  sent  and  0  shall  be
       returned.

       The  <u>putmsg</u>()  function  shall  block  if  the  STREAM  write  queue is full due to internal flow control
       conditions, with the following exceptions:

        *  For high-priority messages, <u>putmsg</u>() shall not block on this condition and continues  processing  the
           message.

        *  For  other  messages,  <u>putmsg</u>()  shall  not  block  but  shall  fail when the write queue is full and
           O_NONBLOCK is set.

       The <u>putmsg</u>() function shall also block, unless prevented by lack of internal resources, while waiting for
       the availability of message blocks in the STREAM, regardless of priority or whether O_NONBLOCK  has  been
       specified. No partial message shall be sent.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon  successful  completion,  <u>putmsg</u>() and <u>putpmsg</u>() shall return 0; otherwise, they shall return -1 and
       set <u>errno</u> to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>putmsg</u>() and <u>putpmsg</u>() functions shall fail if:

       <b>EAGAIN</b> A non-priority message was specified, the O_NONBLOCK flag is set, and the STREAM  write  queue  is
              full  due  to  internal flow control conditions; or buffers could not be allocated for the message
              that was to be created.

       <b>EBADF</b>  <u>fildes</u> is not a valid file descriptor open for writing.

       <b>EINTR</b>  A signal was caught during <u>putmsg</u>().

       <b>EINVAL</b> An undefined value is specified in <u>flags</u>, or <u>flags</u> is set to RS_HIPRI or MSG_HIPRI and no  control
              part  is  supplied,  or  the  STREAM  or  multiplexer  referenced by <u>fildes</u> is linked (directly or
              indirectly) downstream from a multiplexer, or <u>flags</u> is set to MSG_HIPRI and <u>band</u> is non-zero  (for
              <u>putpmsg</u>() only).

       <b>ENOSR</b>  Buffers  could not be allocated for the message that was to be created due to insufficient STREAMS
              memory resources.

       <b>ENOSTR</b> A STREAM is not associated with <u>fildes</u>.

       <b>ENXIO</b>  A hangup condition was generated downstream for the specified STREAM.

       <b>EPIPE</b> or <b>EIO</b>
              The <u>fildes</u> argument refers to a STREAMS-based pipe and the other end of  the  pipe  is  closed.  A
              SIGPIPE signal is generated for the calling thread.

       <b>ERANGE</b> The  size  of the data part of the message does not fall within the range specified by the maximum
              and minimum packet sizes of the topmost STREAM module. This value is also returned if the  control
              part  of  the message is larger than the maximum configured size of the control part of a message,
              or if the data part of a message is larger than the maximum configured size of the data part of  a
              message.

       In  addition,  <u>putmsg</u>()  and  <u>putpmsg</u>() shall fail if the STREAM head had processed an asynchronous error
       before the call. In this case, the value of <u>errno</u> does not reflect the result of <u>putmsg</u>()  or  <u>putpmsg</u>(),
       but reflects the prior error.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Sending</b> <b>a</b> <b>High-Priority</b> <b>Message</b>
       The value of <u>fd</u> is assumed to refer to an open STREAMS file. This call to <u>putmsg</u>() does the following:

        1. Creates  a high-priority message with a control part and a data part, using the buffers pointed to by
           <u>ctrlbuf</u> and <u>databuf</u>, respectively.

        2. Sends the message to the STREAMS file identified by <u>fd</u>.

           #include &lt;stropts.h&gt;
           #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
           ...
           int fd;
           char *ctrlbuf = "This is the control part";
           char *databuf = "This is the data part";
           struct strbuf ctrl;
           struct strbuf data;
           int ret;

           ctrl.buf = ctrlbuf;
           ctrl.len = strlen(ctrlbuf);

           data.buf = databuf;
           data.len = strlen(databuf);

           ret = putmsg(fd, &amp;ctrl, &amp;data, MSG_HIPRI);

   <b>Using</b> <b>putpmsg()</b>
       This example has the same effect as the  previous  example.  In  this  example,  however,  the  <u>putpmsg</u>()
       function creates and sends the message to the STREAMS file.

           #include &lt;stropts.h&gt;
           #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
           ...
           int fd;
           char *ctrlbuf = "This is the control part";
           char *databuf = "This is the data part";
           struct strbuf ctrl;
           struct strbuf data;
           int ret;

           ctrl.buf = ctrlbuf;
           ctrl.len = strlen(ctrlbuf);

           data.buf = databuf;
           data.len = strlen(databuf);

           ret = putpmsg(fd, &amp;ctrl, &amp;data, 0, MSG_HIPRI);

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       None.

</pre><h4><b>RATIONALE</b></h4><pre>
       None.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       The <u>putmsg</u>() and <u>putpmsg</u>() functions may be removed in a future version.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u> <u>2.6</u>, <u>STREAMS</u>, <u>getmsg</u>(), <u>poll</u>(), <u>read</u>(), <u>write</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;stropts.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                        <u><a href="../man3POSIX/PUTMSG.3POSIX.html">PUTMSG</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>