<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pam_conv - PAM conversation function</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpam-doc">libpam-doc_1.7.0-5ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pam_conv - PAM conversation function

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;security/pam_appl.h&gt;</b>

       struct pam_message {
           int msg_style;
           const char *msg;
       };

       struct pam_response {
           char *resp;
           int resp_retcode;
       };

       struct pam_conv {
           int (*conv)(int num_msg, const struct pam_message **msg,
                       struct pam_response **resp, void *appdata_ptr);
           void *appdata_ptr;
       };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The PAM library uses an application-defined callback to allow a direct communication between a loaded
       module and the application. This callback is specified by the <u>struct</u> <u>pam_conv</u> passed to <b><a href="../man3/pam_start.3.html">pam_start</a></b>(3) at
       the start of the transaction.

       When a module calls the referenced conv() function, the argument <u>appdata_ptr</u> is set to the second element
       of this structure.

       The other arguments of a call to conv() concern the information exchanged by module and application. That
       is to say, <u>num_msg</u> holds the length of the array of pointers, <u>msg</u>. After a successful return, the pointer
       <u>resp</u> points to an array of pam_response structures, holding the application supplied text. The
       <u>resp_retcode</u> member of this struct is unused and should be set to zero. It is the caller's responsibility
       to release both, this array and the responses themselves, using <b><a href="../man3/free.3.html">free</a></b>(3). Note, <u>*resp</u> is a <u>struct</u>
       <u>pam_response</u> array and not an array of pointers.

       The number of responses is always equal to the <u>num_msg</u> conversation function argument. This does require
       that the response array is <b><a href="../man3/free.3.html">free</a></b>(3)'d after every call to the conversation function. The index of the
       responses corresponds directly to the prompt index in the pam_message array.

       On failure, the conversation function should release any resources it has allocated, and return one of
       the predefined PAM error codes.

       Each message can have one of four types, specified by the <u>msg_style</u> member of <u>struct</u> <u>pam_message</u>:

       PAM_PROMPT_ECHO_OFF
           Obtain a string without echoing any text.

       PAM_PROMPT_ECHO_ON
           Obtain a string whilst echoing text.

       PAM_ERROR_MSG
           Display an error message.

       PAM_TEXT_INFO
           Display some text.

       The point of having an array of messages is that it becomes possible to pass a number of things to the
       application in a single call from the module. It can also be convenient for the application that related
       things come at once: a windows based application can then present a single form with many
       messages/prompts on at once.

       In passing, it is worth noting that there is a discrepancy between the way Linux-PAM handles the const
       struct pam_message **msg conversation function argument and the way that Solaris' PAM (and derivatives,
       known to include HP/UX, are there others?) does. Linux-PAM interprets the msg argument as entirely
       equivalent to the following prototype const struct pam_message *msg[] (which, in spirit, is consistent
       with the commonly used prototypes for argv argument to the familiar main() function: char **argv; and
       char *argv[]). Said another way Linux-PAM interprets the msg argument as a pointer to an array of num_msg
       read only 'struct pam_message' pointers. Solaris' PAM implementation interprets this argument as a
       pointer to a pointer to an array of num_msg pam_message structures. Fortunately, perhaps, for most
       module/application developers when num_msg has a value of one these two definitions are entirely
       equivalent. Unfortunately, casually raising this number to two has led to unanticipated compatibility
       problems.

       For what its worth the two known module writer work-arounds for trying to maintain source level
       compatibility with both PAM implementations are:

       •   never call the conversation function with num_msg greater than one.

       •   set up msg as doubly referenced so both types of conversation function can find the messages. That
           is, make

                      msg[n] = &amp; (( *msg )[n])

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       PAM_BUF_ERR
           Memory buffer error.

       PAM_CONV_ERR
           Conversation failure. The application should not set <u>*resp</u>.

       PAM_SUCCESS
           Success.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/pam_start.3.html">pam_start</a></b>(3), <b><a href="../man3/pam_set_item.3.html">pam_set_item</a></b>(3), <b><a href="../man3/pam_get_item.3.html">pam_get_item</a></b>(3), <b><a href="../man3/pam_strerror.3.html">pam_strerror</a></b>(3), <b><a href="../man7/pam.7.html">pam</a></b>(7)

Linux-PAM                                          07/03/2025                                        <u><a href="../man3/PAM_CONV.3.html">PAM_CONV</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>