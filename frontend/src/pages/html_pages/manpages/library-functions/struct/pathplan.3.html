<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libpathplan - finds and smooths shortest paths</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgraphviz-dev">libgraphviz-dev_2.42.4-3build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>libpathplan</b> - finds and smooths shortest paths

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;graphviz/pathplan.h&gt;

       typedef struct Pxy_t {
           double x, y;
       } Pxy_t;

       typedef struct Pxy_t Ppoint_t;
       typedef struct Pxy_t Pvector_t;

       typedef struct Ppoly_t {
           Ppoint_t *ps;
           int pn;
       } Ppoly_t;

       typedef Ppoly_t Ppolyline_t;

       typedef struct Pedge_t {
           Ppoint_t a, b;
       } Pedge_t;

       typedef struct vconfig_s vconfig_t;

       #define POLYID_NONE
       #define POLYID_UNKNOWN

       int Pshortestpath(Ppoly_t *boundary, Ppoint_t endpoints[2], Ppolyline_t *output_route);

       vconfig_t *Pobsopen(Ppoly_t **obstacles, int n_obstacles);
       int Pobspath(vconfig_t *config, Ppoint_t p0, int poly0, Ppoint_t p1, int poly1, Ppolyline_t *output_route);
       void Pobsclose(vconfig_t *config);

       int Proutespline (Pedge_t *barriers, int n_barriers, Ppolyline_t input_route, Pvector_t endpoint_slopes[2],
              Ppolyline_t *output_route);

       int Ppolybarriers(Ppoly_t **polys, int n_polys, Pedge_t **barriers, int *n_barriers);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>libpathplan</b> provides functions for creating spline paths in the plane that are constrained by a polygonal
       boundary or obstacles to avoid.  All polygons must be simple, but need not be convex.

      <b>int</b> <b>Pshortestpath(Ppoly_t</b> <b>*boundary,</b> <b>Ppoint_t</b> <b>endpoints[2],</b> <b>Ppolyline_t</b> <b>*output_route);</b>
       The  function <u>Pshortestpath</u> finds a shortest path between two points in a simple polygon.  The polygon is
       specified by a list of its vertices, in either clockwise or counterclockwise order.  You  pass  endpoints
       interior  to  the polygon boundary.  A shortest path connecting the points that remains in the polygon is
       returned in <u>output_route</u>.  If either endpoint does not lie in the polygon, -1 is returned;  otherwise,  0
       is  returned  on success.  The array of points in <u>output_route</u> is static to the library. It should not be
       freed, and should be used before another call to <u>Pshortestpath</u>.

       <b>vconfig_t</b> <b>*Pobsopen(Ppoly_t</b> <b>**obstacles,</b> <b>int</b> <b>n_obstacles);</b>
       <b>Pobspath(vconfig_t</b> <b>*config,</b> <b>Ppoint_t</b> <b>p0,</b> <b>int</b> <b>poly0,</b> <b>Ppoint_t</b> <b>p1,</b> <b>int</b> <b>poly1,</b> <b>Ppolyline_t</b> <b>*output_route);</b>
       <b>void</b> <b>Pobsclose(vconfig_t</b> <b>*config);</b>
       These functions find a shortest path between two points in the plane that  contains  polygonal  obstacles
       (holes).   <u>Pobsopen</u>  creates  a configuration (an opaque struct of type vconfig_t<u>)</u> <u>on</u> <u>a</u> <u>set</u> <u>of</u> <u>obstacles.</u>
       <u>The</u> <u>n_obstacles</u> <u>obstacles</u> <u>are</u> <u>given</u> <u>in</u> <u>the</u> <u>array</u> <u>obstacles;</u> <u>the</u> <u>points</u>  <u>of</u>  <u>each</u>  <u>polygon</u>  <u>should</u>  <u>be</u>  <u>in</u>
       <u>clockwise</u> <u>order.</u>  <u>The</u> <u>function</u> <u>Pobsclose</u> <u>frees</u> <u>the</u> <u>data</u> <u>allocated</u> <u>in</u> <u>Pobsopen.</u>

       Pobspath  <u>finds</u>  <u>a</u>  <u>shortest</u>  <u>path</u>  <u>between</u>  <u>the</u>  <u>endpoints</u>  <u>that</u>  <u>remains</u> <u>outside</u> <u>the</u> <u>obstacles.</u>  <u>If</u> <u>the</u>
       <u>endpoints</u> <u>are</u> <u>known</u> <u>to</u> <u>lie</u> <u>inside</u> <u>obstacles,</u> <u>poly0</u> or poly1 <u>should</u> <u>be</u> <u>set</u> <u>to</u> <u>the</u> <u>index</u> <u>in</u>  <u>the</u>  <u>obstacles</u>
       array.   If  an endpoint is definitely not inside an obstacle, then POLYID_NONE <u>should</u> <u>be</u> <u>passed.</u>  <u>If</u> <u>the</u>
       <u>caller</u> <u>has</u> <u>not</u> <u>checked,</u> <u>then</u> <u>POLYID_UNKNOWN</u> should be passed, and the path library will perform the test.
       The resulting shortest path is returned in <u>output_route</u>. Note that this function does not provide  for  a
       boundary  polygon. The array of points stored in <u>output_route</u> are allocated by the library, but should be
       freed by the user.

        <b>int</b>   <b>Proutespline</b>   <b>(Pedge_t</b>   <b>*barriers,</b>   <b>int</b>   <b>n_barriers,</b>   <b>Ppolyline_t</b>   <b>input_route,</b>    <b>Pvector_t</b>
       <b>endpoint_slopes[2],</b> <b>Ppolyline_t</b> <b>*output_route);</b>
       This function fits a cubic B-spline curve to a polyline path.  The curve is constructed to avoid a set of
       <u>n_barriers</u>  barrier line segments specified in the array <u>barriers</u>. If you start with polygonal obstacles,
       you can supply each polygon's edges as part of the barrier list.  The  polyline  input_route  <u>provides</u>  <u>a</u>
       <u>template</u>  <u>for</u>  <u>the</u> <u>final</u> <u>path;</u> <u>it</u> <u>is</u> <u>usually</u> <u>the</u> <u>output_route</u> of one of the shortest path finders, but it
       can be any simple path that doesn't cross any barrier segment.  The input also allows  the  specification
       of  desired slopes at the endpoints via <u>endpoint_slopes</u>. These are specified as vectors.  For example, to
       have an angle of <u>T</u> at an endpoing, one could use <u>(cos(T),sin(T))</u>.  A  vector  (0,0)  means  unconstrained
       slope.   The  output  is returned in <u>output_route</u> and consists of the control points of the B-spline. The
       function return 0 on success;  a  return  value  of  -1  indicates  failure.   The  array  of  points  in
       <u>output_route</u>  is static to the library. It should not be freed, and should be used before another call to
       <u>Proutespline</u>.

      <b>int</b> <b>Ppolybarriers(Ppoly_t</b> <b>**polys,</b> <b>int</b> <b>n_polys,</b> <b>Pedge_t</b> <b>**barriers,</b> <b>int</b> <b>*n_barriers);</b>
       This is a utility function that converts an input list  of  polygons  into  an  output  list  of  barrier
       segments.   The  array of points in <u>barriers</u> is static to the library. It should not be freed, and should
       be used before another call to <u>Ppolybarriers</u>.  The function returns 1 on success.

</pre><h4><b>BUGS</b></h4><pre>
       The function <u>Proutespline</u> does not guarantee that it will preserve the topology  of  the  input  path  as
       regards  the  boundaries.  For  example, if some of the segments correspond to a small polygon, it may be
       possible that the final path has flipped over the obstacle.

</pre><h4><b>AUTHORS</b></h4><pre>
       David  Dobkin  (<a href="mailto:dpd@cs.princeton.edu">dpd@cs.princeton.edu</a>),  Eleftherios  Koutsofios  (<a href="mailto:ek@research.att.com">ek@research.att.com</a>),   Emden   Gansner
       (<a href="mailto:erg@research.att.com">erg@research.att.com</a>).

                                                  01 APRIL 1997                                       <u><a href="../man3/LIBPATH.3.html">LIBPATH</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>