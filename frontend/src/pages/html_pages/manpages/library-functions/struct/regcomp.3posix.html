<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       regcomp, regerror, regexec, regfree — regular expression matching

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/regex.h">regex.h</a>&gt;

       int regcomp(regex_t *restrict <u>preg</u>, const char *restrict <u>pattern</u>,
           int <u>cflags</u>);
       size_t regerror(int <u>errcode</u>, const regex_t *restrict <u>preg</u>,
           char *restrict <u>errbuf</u>, size_t <u>errbuf_size</u>);
       int regexec(const regex_t *restrict <u>preg</u>, const char *restrict <u>string</u>,
           size_t <u>nmatch</u>, regmatch_t <u>pmatch</u>[restrict], int <u>eflags</u>);
       void regfree(regex_t *<u>preg</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  functions  interpret  <u>basic</u>  and <u>extended</u> regular expressions as described in the Base Definitions
       volume of POSIX.1‐2017, <u>Chapter</u> <u>9</u>, <u>Regular</u> <u>Expressions</u>.

       The <b>regex_t</b> structure is defined in <u>&lt;regex.h&gt;</u> and contains at least the following member:
                             ┌───────────────┬──────────────┬───────────────────────────┐
                             │ <b>Member</b> <b>Type</b>   │ <b>Member</b> <b>Name</b>  │        <b>Description</b>        │
                             ├───────────────┼──────────────┼───────────────────────────┤
                             │ <b>size_t</b>        │<u>re_nsub</u>       │ Number  of  parenthesized │
                             │               │              │ subexpressions.           │
                             └───────────────┴──────────────┴───────────────────────────┘

       The <b>regmatch_t</b> structure is defined in <u>&lt;regex.h&gt;</u> and contains at least the following members:
                             ┌───────────────┬──────────────┬───────────────────────────┐
                             │ <b>Member</b> <b>Type</b>   │ <b>Member</b> <b>Name</b>  │        <b>Description</b>        │
                             ├───────────────┼──────────────┼───────────────────────────┤
                             │ <b>regoff_t</b>      │<u>rm_so</u>         │ Byte offset from start of │
                             │               │              │ <u>string</u>    to   start   of │
                             │               │              │ substring.                │
                             │ <b>regoff_t</b>      │<u>rm_eo</u>         │ Byte offset from start of │
                             │               │              │ <u>string</u>   of   the   first │
                             │               │              │ character  after  the end │
                             │               │              │ of substring.             │
                             └───────────────┴──────────────┴───────────────────────────┘

       The <u>regcomp</u>() function shall compile the regular expression contained in the string  pointed  to  by  the
       <u>pattern</u>  argument  and place the results in the structure pointed to by <u>preg</u>.  The <u>cflags</u> argument is the
       bitwise-inclusive OR of zero or more of the following flags, which are defined in the <u>&lt;regex.h&gt;</u> header:

       REG_EXTENDED  Use Extended Regular Expressions.

       REG_ICASE     Ignore case in match (see the Base Definitions volume of POSIX.1‐2017, <u>Chapter</u>  <u>9</u>,  <u>Regular</u>
                     <u>Expressions</u>).

       REG_NOSUB     Report only success/fail in <u>regexec</u>().

       REG_NEWLINE   Change the handling of &lt;newline&gt; characters, as described in the text.

       The  default  regular  expression  type  for  <u>pattern</u>  is a Basic Regular Expression. The application can
       specify Extended Regular Expressions using the REG_EXTENDED <u>cflags</u> flag.

       If the REG_NOSUB flag was not set  in  <u>cflags</u>,  then  <u>regcomp</u>()  shall  set  <u>re_nsub</u>  to  the  number  of
       parenthesized  subexpressions  (delimited  by  <b>"\(\)"</b>  in  basic  regular expressions or <b>"()"</b> in extended
       regular expressions) found in <u>pattern</u>.

       The <u>regexec</u>() function compares the null-terminated string specified by <u>string</u> with the compiled  regular
       expression <u>preg</u> initialized by a previous call to <u>regcomp</u>().  If it finds a match, <u>regexec</u>() shall return
       0; otherwise, it shall return non-zero indicating either no match or an error. The <u>eflags</u> argument is the
       bitwise-inclusive OR of zero or more of the following flags, which are defined in the <u>&lt;regex.h&gt;</u> header:

       REG_NOTBOL    The  first  character  of the string pointed to by <u>string</u> is not the beginning of the line.
                     Therefore, the &lt;circumflex&gt; character (<b>'^'</b>), when taken as a special character,  shall  not
                     match the beginning of <u>string</u>.

       REG_NOTEOL    The  last  character  of  the  string  pointed  to  by  <u>string</u>  is not the end of the line.
                     Therefore, the &lt;dollar-sign&gt; (<b>'$'</b>), when taken as a special character, shall not match  the
                     end of <u>string</u>.

       If  <u>nmatch</u> is 0 or REG_NOSUB was set in the <u>cflags</u> argument to <u>regcomp</u>(), then <u>regexec</u>() shall ignore the
       <u>pmatch</u> argument. Otherwise, the application shall ensure that the <u>pmatch</u> argument points to an array with
       at least <u>nmatch</u> elements, and <u>regexec</u>() shall fill in the elements of that  array  with  offsets  of  the
       substrings  of  <u>string</u>  that  correspond  to the parenthesized subexpressions of <u>pattern</u>: <u>pmatch</u>[<u>i</u>].<u>rm_so</u>
       shall be the byte offset of the beginning and <u>pmatch</u>[<u>i</u>].<u>rm_eo</u> shall be one greater than the  byte  offset
       of  the  end  of substring <u>i</u>.  (Subexpression <u>i</u> begins at the <u>i</u>th matched open parenthesis, counting from
       1.) Offsets in <u>pmatch</u>[0] identify the substring that corresponds to the entire regular expression. Unused
       elements of <u>pmatch</u> up to <u>pmatch</u>[<u>nmatch</u>-1] shall be  filled  with  -1.  If  there  are  more  than  <u>nmatch</u>
       subexpressions  in  <u>pattern</u> (<u>pattern</u> itself counts as a subexpression), then <u>regexec</u>() shall still do the
       match, but shall record only the first <u>nmatch</u> substrings.

       When matching a basic or extended regular expression, any given parenthesized  subexpression  of  <u>pattern</u>
       might  participate  in  the  match  of  several different substrings of <u>string</u>, or it might not match any
       substring even though the pattern as a whole did match. The following rules shall be  used  to  determine
       which substrings to report in <u>pmatch</u> when matching regular expressions:

        1. If  subexpression  <u>i</u>  in  a  regular expression is not contained within another subexpression, and it
           participated in the match several times, then the byte offsets in <u>pmatch</u>[<u>i</u>] shall  delimit  the  last
           such match.

        2. If  subexpression  <u>i</u>  is not contained within another subexpression, and it did not participate in an
           otherwise successful match, the byte offsets in <u>pmatch</u>[<u>i</u>] shall  be  -1.  A  subexpression  does  not
           participate in the match when:

           <b>'*'</b> or <b>"\{\}"</b> appears immediately after the subexpression in a basic regular expression, or <b>'*'</b>, <b>'?'</b>,
           or  <b>"{}"</b>  appears  immediately  after  the  subexpression  in an extended regular expression, and the
           subexpression did not match (matched 0 times)

           or:

                  <b>'|'</b> is used in an extended regular expression to select this subexpression or another, and the
                  other subexpression matched.

        3. If subexpression <u>i</u> is contained within another subexpression <u>j</u>, and <u>i</u> is  not  contained  within  any
           other  subexpression  that  is  contained  within  <u>j</u>,  and  a match of subexpression <u>j</u> is reported in
           <u>pmatch</u>[<u>j</u>], then the match or non-match of subexpression <u>i</u> reported in <u>pmatch</u>[<u>i</u>] shall be as described
           in 1. and 2. above, but within the substring reported in <u>pmatch</u>[<u>j</u>] rather than the whole string.  The
           offsets in <u>pmatch</u>[<u>i</u>] are still relative to the start of <u>string</u>.

        4. If  subexpression  <u>i</u>  is contained in subexpression <u>j</u>, and the byte offsets in <u>pmatch</u>[<u>j</u>] are -1, then
           the pointers in <u>pmatch</u>[<u>i</u>] shall also be -1.

        5. If subexpression <u>i</u> matched a zero-length string, then both byte offsets in  <u>pmatch</u>[<u>i</u>]  shall  be  the
           byte offset of the character or null terminator immediately following the zero-length string.

       If,  when <u>regexec</u>() is called, the locale is different from when the regular expression was compiled, the
       result is undefined.

       If REG_NEWLINE is not set in <u>cflags</u>, then a &lt;newline&gt; in  <u>pattern</u>  or  <u>string</u>  shall  be  treated  as  an
       ordinary  character.  If  REG_NEWLINE  is  set,  then &lt;newline&gt; shall be treated as an ordinary character
       except as follows:

        1. A &lt;newline&gt; in <u>string</u> shall not be matched by a &lt;period&gt; outside a bracket expression or by any  form
           of  a  non-matching  list  (see  the  Base  Definitions  volume  of  POSIX.1‐2017, <u>Chapter</u> <u>9</u>, <u>Regular</u>
           <u>Expressions</u>).

        2. A &lt;circumflex&gt; (<b>'^'</b>) in <u>pattern</u>, when used to specify expression anchoring (see the Base  Definitions
           volume  of POSIX.1‐2017, <u>Section</u> <u>9.3.8</u>, <u>BRE</u> <u>Expression</u> <u>Anchoring</u>), shall match the zero-length string
           immediately after a &lt;newline&gt; in <u>string</u>, regardless of the setting of REG_NOTBOL.

        3. A &lt;dollar-sign&gt; (<b>'$'</b>) in <u>pattern</u>, when used to specify expression anchoring, shall  match  the  zero-
           length string immediately before a &lt;newline&gt; in <u>string</u>, regardless of the setting of REG_NOTEOL.

       The <u>regfree</u>() function frees any memory allocated by <u>regcomp</u>() associated with <u>preg</u>.

       The  following  constants  are  defined  as the minimum set of error return values, although other errors
       listed as implementation extensions in <u>&lt;regex.h&gt;</u> are possible:

       REG_BADBR     Content of <b>"\{\}"</b> invalid: not a number, number too large, more  than  two  numbers,  first
                     larger than second.

       REG_BADPAT    Invalid regular expression.

       REG_BADRPT    <b>'?'</b>, <b>'*'</b>, or <b>'+'</b> not preceded by valid regular expression.

       REG_EBRACE    <b>"\{\}"</b> imbalance.

       REG_EBRACK    <b>"[]"</b> imbalance.

       REG_ECOLLATE  Invalid collating element referenced.

       REG_ECTYPE    Invalid character class type referenced.

       REG_EESCAPE   Trailing &lt;backslash&gt; character in pattern.

       REG_EPAREN    <b>"\(\)"</b> or <b>"()"</b> imbalance.

       REG_ERANGE    Invalid endpoint in range expression.

       REG_ESPACE    Out of memory.

       REG_ESUBREG   Number in <b>"\digit"</b> invalid or in error.

       REG_NOMATCH   <u>regexec</u>() failed to match.

       If  more  than  one  error occurs in processing a function call, any one of the possible constants may be
       returned, as the order of detection is unspecified.

       The <u>regerror</u>() function provides a mapping from error  codes  returned  by  <u>regcomp</u>()  and  <u>regexec</u>()  to
       unspecified  printable strings. It generates a string corresponding to the value of the <u>errcode</u> argument,
       which the application shall ensure is the last non-zero value returned by <u>regcomp</u>() or <u>regexec</u>() with the
       given value of <u>preg</u>.  If <u>errcode</u> is not such a value, the content of the generated string is unspecified.

       If <u>preg</u> is a null pointer, but <u>errcode</u> is a value returned by a previous call to <u>regexec</u>() or  <u>regcomp</u>(),
       the <u>regerror</u>() still generates an error string corresponding to the value of <u>errcode</u>, but it might not be
       as detailed under some implementations.

       If the <u>errbuf_size</u> argument is not 0, <u>regerror</u>() shall place the generated string into the buffer of size
       <u>errbuf_size</u> bytes pointed to by <u>errbuf</u>.  If the string (including the terminating null) cannot fit in the
       buffer, <u>regerror</u>() shall truncate the string and null-terminate the result.

       If  <u>errbuf_size</u>  is  0,  <u>regerror</u>()  shall  ignore the <u>errbuf</u> argument, and return the size of the buffer
       needed to hold the generated string.

       If the <u>preg</u> argument to <u>regexec</u>()  or  <u>regfree</u>()  is  not  a  compiled  regular  expression  returned  by
       <u>regcomp</u>(), the result is undefined. A <u>preg</u> is no longer treated as a compiled regular expression after it
       is given to <u>regfree</u>().

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon  successful completion, the <u>regcomp</u>() function shall return 0. Otherwise, it shall return an integer
       value indicating an error as described in <u>&lt;regex.h&gt;</u>, and the content of <u>preg</u> is undefined. If a  code  is
       returned, the interpretation shall be as given in <u>&lt;regex.h&gt;</u>.

       If  <u>regcomp</u>()  detects  an  invalid RE, it may return REG_BADPAT, or it may return one of the error codes
       that more precisely describes the error.

       Upon successful completion, the <u>regexec</u>() function shall return 0. Otherwise, it shall return REG_NOMATCH
       to indicate no match.

       Upon successful completion, the <u>regerror</u>() function shall return the number of bytes needed to  hold  the
       entire generated string, including the null termination. If the return value is greater than <u>errbuf_size</u>,
       the string returned in the buffer pointed to by <u>errbuf</u> has been truncated.

       The <u>regfree</u>() function shall not return a value.

</pre><h4><b>ERRORS</b></h4><pre>
       No errors are defined.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
           #include &lt;<a href="file:/usr/include/regex.h">regex.h</a>&gt;

           /*
            * Match string against the extended regular expression in
            * pattern, treating errors as no match.
            *
            * Return 1 for match, 0 for no match.
            */

           int
           match(const char *string, char *pattern)
           {
               int    status;
               regex_t    re;

               if (regcomp(&amp;re, pattern, REG_EXTENDED|REG_NOSUB) != 0) {
                   <a href="../man0/return.0.html">return</a>(0);      /* Report error. */
               }
               status = regexec(&amp;re, string, (size_t) 0, NULL, 0);
               regfree(&amp;re);
               if (status != 0) {
                   <a href="../man0/return.0.html">return</a>(0);      /* Report error. */
               }
               <a href="../man1/return.1.html">return</a>(1);
           }

       The following demonstrates how the REG_NOTBOL flag could be used with <u>regexec</u>() to find all substrings in
       a  line  that  match  a  pattern  supplied  by a user.  (For simplicity of the example, very little error
       checking is done.)

           (void) regcomp (&amp;re, pattern, 0);
           /* This call to regexec() finds the first match on the line. */
           error = regexec (&amp;re, &amp;buffer[0], 1, &amp;pm, 0);
           while (error == 0) {  /* While matches found. */
               /* Substring found between pm.rm_so and pm.rm_eo. */
               /* This call to regexec() finds the next match. */
               error = regexec (&amp;re, buffer + pm.rm_eo, 1, &amp;pm, REG_NOTBOL);
           }

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       An application could use:

           regerror(code,preg,(char *)NULL,(size_t)0)

       to find out how big a buffer is needed for the generated string, <u>malloc</u>() a buffer to  hold  the  string,
       and then call <u>regerror</u>() again to get the string. Alternatively, it could allocate a fixed, static buffer
       that  is  big  enough to hold most strings, and then use <u>malloc</u>() to allocate a larger buffer if it finds
       that this is too small.

       To match a pattern as described in the Shell and Utilities volume of POSIX.1‐2017, <u>Section</u> <u>2.13</u>,  <u>Pattern</u>
       <u>Matching</u> <u>Notation</u>, use the <u>fnmatch</u>() function.

</pre><h4><b>RATIONALE</b></h4><pre>
       The  <u>regexec</u>()  function must fill in all <u>nmatch</u> elements of <u>pmatch</u>, where <u>nmatch</u> and <u>pmatch</u> are supplied
       by the application, even if some elements of <u>pmatch</u> do not correspond to subexpressions in <u>pattern</u>.   The
       application  developer  should  note that there is probably no reason for using a value of <u>nmatch</u> that is
       larger than <u>preg</u>-&gt;<u>re_nsub</u>+1.

       The REG_NEWLINE flag supports a use of RE matching that is needed in some applications like text editors.
       In such applications, the user supplies an RE asking the application to find  a  line  that  matches  the
       given  expression.  An  anchor  in  such  an  RE  anchors  at  the  beginning or end of any line. Such an
       application can pass a sequence of &lt;newline&gt;-separated lines to <u>regexec</u>() as a  single  long  string  and
       specify  REG_NEWLINE to <u>regcomp</u>() to get the desired behavior. The application must ensure that there are
       no explicit &lt;newline&gt; characters in <u>pattern</u> if it wants to ensure that any match occurs entirely within a
       single line.

       The REG_NEWLINE flag affects the behavior of <u>regexec</u>(), but it is in the <u>cflags</u> parameter to <u>regcomp</u>() to
       allow flexibility of implementation. Some implementations will want to generate the same compiled  RE  in
       <u>regcomp</u>() regardless of the setting of REG_NEWLINE and have <u>regexec</u>() handle anchors differently based on
       the  setting  of  the  flag.  Other  implementations  will  generate  different compiled REs based on the
       REG_NEWLINE.

       The REG_ICASE flag supports the operations taken by the <u>grep</u> <b>-i</b> option and the historical implementations
       of <u>ex</u> and <u>vi</u>.  Including this flag will make it easier for application code to be written that  does  the
       same thing as these utilities.

       The  substrings  reported  in <u>pmatch</u>[] are defined using offsets from the start of the string rather than
       pointers. This allows type-safe access to both constant and non-constant strings.

       The type <b>regoff_t</b> is used for the elements of <u>pmatch</u>[] to ensure that the application can represent large
       arrays in memory (important  for  an  application  conforming  to  the  Shell  and  Utilities  volume  of
       POSIX.1‐2017).

       The 1992 edition of this standard required <b>regoff_t</b> to be at least as wide as <b>off_t</b>, to facilitate future
       extensions in which the string to be searched is taken from a file. However, these future extensions have
       not  appeared.   The requirement rules out popular implementations with 32-bit <b>regoff_t</b> and 64-bit <b>off_t</b>,
       so it has been removed.

       The standard developers rejected the  inclusion  of  a  <u>regsub</u>()  function  that  would  be  used  to  do
       substitutions  for  a  matched RE. While such a routine would be useful to some applications, its utility
       would be much more limited than the matching function described here. Both RE  parsing  and  substitution
       are possible to implement without support other than that required by the ISO C standard, but matching is
       much  more  complex  than  substituting.  The  only difficult part of substitution, given the information
       supplied by <u>regexec</u>(), is finding the next character in a string when there can be multi-byte characters.
       That is a much larger issue, and one that needs a more general solution.

       The <u>errno</u> variable has not been used for error returns to avoid filling the <u>errno</u>  name  space  for  this
       feature.

       The  interface  is  defined  so  that the matched substrings <u>rm_sp</u> and <u>rm_ep</u> are in a separate <b>regmatch_t</b>
       structure instead of in <b>regex_t</b>.  This allows a single compiled RE to be used simultaneously  in  several
       contexts;  in <u>main</u>() and a signal handler, perhaps, or in multiple threads of lightweight processes. (The
       <u>preg</u> argument to <u>regexec</u>() is declared with type <b>const</b>, so the implementation is not permitted to use the
       structure to store intermediate results.) It also allows an application to request an arbitrary number of
       substrings from an RE. The number of subexpressions in the RE is reported in <u>re_nsub</u> in <u>preg</u>.  With  this
       change  to  <u>regexec</u>(),  consideration  was  given  to  dropping the REG_NOSUB flag since the user can now
       specify  this  with  a  zero  <u>nmatch</u>  argument  to  <u>regexec</u>().   However,  keeping  REG_NOSUB  allows  an
       implementation  to  use  a  different (perhaps more efficient) algorithm if it knows in <u>regcomp</u>() that no
       subexpressions need be reported. The implementation is only required to fill in <u>pmatch</u> if <u>nmatch</u>  is  not
       zero  and  if REG_NOSUB is not specified. Note that the <b>size_t</b> type, as defined in the ISO C standard, is
       unsigned, so the description of <u>regexec</u>() does not need to address negative values of <u>nmatch</u>.

       REG_NOTBOL was added to allow an application to do repeated searches for the same pattern in a  line.  If
       the pattern contains a &lt;circumflex&gt; character that should match the beginning of a line, then the pattern
       should  only  match  when  matched  against  the beginning of the line.  Without the REG_NOTBOL flag, the
       application could rewrite the expression for subsequent matches, but  in  the  general  case  this  would
       require parsing the expression. The need for REG_NOTEOL is not as clear; it was added for symmetry.

       The addition of the <u>regerror</u>() function addresses the historical need for conforming application programs
       to  have  access  to  error  information more than ``Function failed to compile/match your RE for unknown
       reasons''.

       This interface provides for two different methods of dealing with error conditions.  The  specific  error
       codes  (REG_EBRACE,  for example), defined in <u>&lt;regex.h&gt;</u>, allow an application to recover from an error if
       it is so able. Many applications, especially those that use patterns supplied by a user, will not try  to
       deal  with specific error cases, but will just use <u>regerror</u>() to obtain a human-readable error message to
       present to the user.

       The <u>regerror</u>() function uses a scheme similar to <u>confstr</u>() to deal with the problem of allocating  memory
       to  hold  the  generated  string.  The  scheme  used  by  <u>strerror</u>() in the ISO C standard was considered
       unacceptable since it creates difficulties for multi-threaded applications.

       The <u>preg</u> argument is provided to <u>regerror</u>() to allow an implementation to  generate  a  more  descriptive
       message  than  would  be  possible  with  <u>errcode</u>  alone.  An implementation might, for example, save the
       character offset of the offending character of the pattern in a field of <u>preg</u>, and then include  that  in
       the generated message string. The implementation may also ignore <u>preg</u>.

       A  REG_FILENAME  flag  was  considered,  but  omitted.  This  flag  caused <u>regexec</u>() to match patterns as
       described in the Shell and Utilities volume of POSIX.1‐2017,  <u>Section</u>  <u>2.13</u>,  <u>Pattern</u>  <u>Matching</u>  <u>Notation</u>
       instead of REs. This service is now provided by the <u>fnmatch</u>() function.

       Notice that there is a difference in philosophy between the ISO POSIX‐2:1993 standard and POSIX.1‐2008 in
       how  to  handle a ``bad'' regular expression. The ISO POSIX‐2:1993 standard says that many bad constructs
       ``produce undefined results'', or that ``the interpretation is undefined''. POSIX.1‐2008,  however,  says
       that  the  interpretation of such REs is unspecified. The term ``undefined'' means that the action by the
       application is an error, of similar severity to passing a bad pointer to a function.

       The <u>regcomp</u>() and <u>regexec</u>() functions are required to accept any null-terminated string  as  the  <u>pattern</u>
       argument. If the meaning of the string is ``undefined'', the behavior of the function is ``unspecified''.
       POSIX.1‐2008  does  not  specify  how  the  functions will interpret the pattern; they might return error
       codes, or they might do pattern matching in some completely  unexpected  way,  but  they  should  not  do
       something like abort the process.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>fnmatch</u>(), <u>glob</u>()

       The Base Definitions volume of POSIX.1‐2017, <u>Chapter</u> <u>9</u>, <u>Regular</u> <u>Expressions</u>, <b>&lt;regex.h&gt;</b>, <b>&lt;sys_types.h&gt;</b>

       The Shell and Utilities volume of POSIX.1‐2017, <u>Section</u> <u>2.13</u>, <u>Pattern</u> <u>Matching</u> <u>Notation</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                       <u><a href="../man3POSIX/REGCOMP.3POSIX.html">REGCOMP</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>