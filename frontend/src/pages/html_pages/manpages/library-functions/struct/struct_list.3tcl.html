<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>struct::list - Procedures for manipulating lists</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       struct::list - Procedures for manipulating lists

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>struct::list</b> <b>?1.9?</b>

       <b>::struct::list</b> <b>longestCommonSubsequence</b> <u>sequence1</u> <u>sequence2</u> ?<u>maxOccurs</u>?

       <b>::struct::list</b> <b>longestCommonSubsequence2</b> <u>sequence1</u> <u>sequence2</u> ?<u>maxOccurs</u>?

       <b>::struct::list</b> <b>lcsInvert</b> <u>lcsData</u> <u>len1</u> <u>len2</u>

       <b>::struct::list</b> <b>lcsInvert2</b> <u>lcs1</u> <u>lcs2</u> <u>len1</u> <u>len2</u>

       <b>::struct::list</b> <b>lcsInvertMerge</b> <u>lcsData</u> <u>len1</u> <u>len2</u>

       <b>::struct::list</b> <b>lcsInvertMerge2</b> <u>lcs1</u> <u>lcs2</u> <u>len1</u> <u>len2</u>

       <b>::struct::list</b> <b>reverse</b> <u>sequence</u>

       <b>::struct::list</b> <b>shuffle</b> <u>list</u>

       <b>::struct::list</b> <b>assign</b> <u>sequence</u> <u>varname</u> ?<u>varname</u>?...

       <b>::struct::list</b> <b>flatten</b> ?<b>-full</b>? ?<b>--</b>? <u>sequence</u>

       <b>::struct::list</b> <b>map</b> <u>sequence</u> <u>cmdprefix</u>

       <b>::struct::list</b> <b>mapfor</b> <u>var</u> <u>sequence</u> <u>script</u>

       <b>::struct::list</b> <b>filter</b> <u>sequence</u> <u>cmdprefix</u>

       <b>::struct::list</b> <b>filterfor</b> <u>var</u> <u>sequence</u> <u>expr</u>

       <b>::struct::list</b> <b>split</b> <u>sequence</u> <u>cmdprefix</u> ?<u>passVar</u> <u>failVar</u>?

       <b>::struct::list</b> <b>fold</b> <u>sequence</u> <u>initialvalue</u> <u>cmdprefix</u>

       <b>::struct::list</b> <b>shift</b> <u>listvar</u>

       <b>::struct::list</b> <b>iota</b> <u>n</u>

       <b>::struct::list</b> <b>equal</b> ?<b>-simple</b>? ?<b>--</b>? <u>a</u> <u>b</u>

       <b>::struct::list</b> <b>repeat</b> <u>size</u> <u>element1</u> ?<u>element2</u> <u>element3</u>...?

       <b>::struct::list</b> <b>repeatn</b> <u>value</u> <u>size</u>...

       <b>::struct::list</b> <b>dbJoin</b> ?<b>-inner</b>|<b>-left</b>|<b>-right</b>|<b>-full</b>? ?<b>-keys</b> <u>varname</u>? {<u>keycol</u> <u>table</u>}...

       <b>::struct::list</b> <b>dbJoinKeyed</b> ?<b>-inner</b>|<b>-left</b>|<b>-right</b>|<b>-full</b>? ?<b>-keys</b> <u>varname</u>? <u>table</u>...

       <b>::struct::list</b> <b>swap</b> <u>listvar</u> <u>i</u> <u>j</u>

       <b>::struct::list</b> <b>firstperm</b> <u>list</u>

       <b>::struct::list</b> <b>nextperm</b> <u>perm</u>

       <b>::struct::list</b> <b>permutations</b> <u>list</u>

       <b>::struct::list</b> <b>foreachperm</b> <u>var</u> <u>list</u> <u>body</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>::struct::list</b>  namespace  contains  several  useful  commands  for  processing Tcl lists. Generally
       speaking, they implement algorithms more complex or specialized than the ones provided by Tcl itself.

       It exports only a single command, <b>struct::list</b>. All functionality provided here can be reached through  a
       subcommand of this command.

</pre><h4><b>COMMANDS</b></h4><pre>
       <b>::struct::list</b> <b>longestCommonSubsequence</b> <u>sequence1</u> <u>sequence2</u> ?<u>maxOccurs</u>?
              Returns a list of indices into <u>sequence1</u> and a corresponding list where each item is an index into
              <u>sequence2</u>  of  the  matching  value  according  to  the longest common subsequences algorithm.  If
              <u>maxOccurs</u> is provided, the common subsequence is restricted to elements that occur  no  more  than
              <u>maxOccurs</u> times in <u>sequence2</u>.

       <b>::struct::list</b> <b>longestCommonSubsequence2</b> <u>sequence1</u> <u>sequence2</u> ?<u>maxOccurs</u>?
              Returns  the  longest common subsequence of elements in the two lists <u>sequence1</u> and <u>sequence2</u>.  If
              <u>maxOccurs</u> is provided, the result is only an approximation, where the longest  common  subsequence
              is approximated by first determining the longest common sequence of only those elements that occur
              no  more  than  <u>maxOccurs</u>  times  in <u>sequence2</u>, and then using that result to align the two lists,
              determining the longest common subsequences of the sublists between the two elements.

              The result is the same as for <b>longestCommonSubsequence</b>.

       <b>::struct::list</b> <b>lcsInvert</b> <u>lcsData</u> <u>len1</u> <u>len2</u>
              Takes a description of a longest common subsequence (<u>lcsData</u>), inverts it, and returns the result.
              Inversion means here that as the input describes which parts of the two  sequences  are  identical
              the output describes the differences instead.

              To  be  fully  defined the lengths of the two sequences have to be known and are specified through
              <u>len1</u> and <u>len2</u>.

              The result is a list where each element describes one chunk of the  differences  between  the  two
              sequences.  This  description is a list containing three elements, a type and two pairs of indices
              into <u>sequence1</u> and <u>sequence2</u> respectively, in this order.  The type can be one of three values:

              <b>added</b>  Describes an addition. I.e. items which are missing in <u>sequence1</u> can be found in <u>sequence2</u>.
                     The pair of indices into <u>sequence1</u> describes where the added range had been expected to  be
                     in  <u>sequence1</u>.  The  first  index  refers  to the item just before the added range, and the
                     second index refers to the item just after the added  range.   The  pair  of  indices  into
                     <u>sequence2</u>  describes  the range of items which has been added to it. The first index refers
                     to the first item in the range, and the second index refers to the last item in the range.

              <b>deleted</b>
                     Describes a deletion. I.e. items which are in <u>sequence1</u> are missing  from  <u>sequence2</u>.   The
                     pair  of  indices  into  <u>sequence1</u> describes the range of items which has been deleted. The
                     first index refers to the first item in the range, and the second index refers to the  last
                     item  in  the  range.  The pair of indices into <u>sequence2</u> describes where the deleted range
                     had been expected to be in <u>sequence2</u>. The first index refers to the item  just  before  the
                     deleted range, and the second index refers to the item just after the deleted range.

              <b>changed</b>
                     Describes  a  general  change.  I.e  a  range  of items in <u>sequence1</u> has been replaced by a
                     different range of items in <u>sequence2</u>.  The pair of indices into  <u>sequence1</u>  describes  the
                     range  of  items  which  has been replaced. The first index refers to the first item in the
                     range, and the second index refers to the last item in the range.  The pair of indices into
                     <u>sequence2</u> describes the range of items replacing the original range. Again the first  index
                     refers  to the first item in the range, and the second index refers to the last item in the
                     range.

                  sequence 1 = {a b r a c a d a b r a}
                  lcs 1      =   {1 2   4 5     8 9 10}
                  lcs 2      =   {0 1   3 4     5 6 7}
                  sequence 2 =   {b r i c a     b r a c}

                  Inversion  = {{deleted  {0  0} {-1 0}}
                                {changed  {3  3}  {2 2}}
                                {deleted  {6  7}  {4 5}}
                                {added   {10 11}  {8 8}}}

              <u>Notes:</u>

              •      An index of <b>-1</b> in a <u>deleted</u> chunk refers to just before the first  element  of  the  second
                     sequence.

              •      Also  an  index  equal to the length of the first sequence in an <u>added</u> chunk refers to just
                     behind the end of the sequence.

       <b>::struct::list</b> <b>lcsInvert2</b> <u>lcs1</u> <u>lcs2</u> <u>len1</u> <u>len2</u>
              Similar to <b>lcsInvert</b>. Instead of directly taking the result of a call to  <b>longestCommonSubsequence</b>
              this subcommand expects the indices for the two sequences in two separate lists.

       <b>::struct::list</b> <b>lcsInvertMerge</b> <u>lcsData</u> <u>len1</u> <u>len2</u>
              Similar  to  <b>lcsInvert</b>.  It returns essentially the same structure as that command, except that it
              may contain chunks of type <b>unchanged</b> too.

              These new chunks describe the parts which are unchanged between the two sequences. This means that
              the result of this command describes both the changed and unchanged parts of the two sequences  in
              one structure.

                  sequence 1 = {a b r a c a d a b r a}
                  lcs 1      =   {1 2   4 5     8 9 10}
                  lcs 2      =   {0 1   3 4     5 6 7}
                  sequence 2 =   {b r i c a     b r a c}

                  Inversion/Merge  = {{deleted   {0  0} {-1 0}}
                                      {unchanged {1  2}  {0 1}}
                                      {changed   {3  3}  {2 2}}
                                      {unchanged {4  5}  {3 4}}
                                      {deleted   {6  7}  {4 5}}
                                      {unchanged {8 10}  {5 7}}
                                      {added    {10 11}  {8 8}}}

       <b>::struct::list</b> <b>lcsInvertMerge2</b> <u>lcs1</u> <u>lcs2</u> <u>len1</u> <u>len2</u>
              Similar   to   <b>lcsInvertMerge</b>.   Instead   of   directly   taking   the   result   of  a  call  to
              <b>longestCommonSubsequence</b> this subcommand expects the indices for the two sequences in two separate
              lists.

       <b>::struct::list</b> <b>reverse</b> <u>sequence</u>
              The subcommand takes a single <u>sequence</u> as argument and  returns  a  new  sequence  containing  the
              elements of the input sequence in reverse order.

       <b>::struct::list</b> <b>shuffle</b> <u>list</u>
              The  subcommand  takes  a  <u>list</u>  and  returns a copy of that list with the elements it contains in
              random order. Every possible ordering of elements is equally likely to be generated.  The  Fisher-
              Yates shuffling algorithm is used internally.

       <b>::struct::list</b> <b>assign</b> <u>sequence</u> <u>varname</u> ?<u>varname</u>?...
              The  subcommand  assigns  the  first <b>n</b> elements of the input <u>sequence</u> to the one or more variables
              whose names were listed after the sequence, where <b>n</b> is the number of specified variables.

              If there are more variables specified than there are elements in the  <u>sequence</u>  the  empty  string
              will be assigned to the superfluous variables.

              If  there are more elements in the <u>sequence</u> than variable names specified the subcommand returns a
              list containing the unassigned elements. Else an empty list is returned.

                  tclsh&gt; ::struct::list assign {a b c d e} foo bar
                  c d e
                  tclsh&gt; set foo
                  a
                  tclsh&gt; set bar
                  b

       <b>::struct::list</b> <b>flatten</b> ?<b>-full</b>? ?<b>--</b>? <u>sequence</u>
              The subcommand takes a single <u>sequence</u> and returns a new sequence where one level of  nesting  was
              removed  from  the input sequence. In other words, the sublists in the input sequence are replaced
              by their elements.

              The subcommand will remove any nesting it finds if the option <b>-full</b> is specified.

                  tclsh&gt; ::struct::list flatten {1 2 3 {4 5} {6 7} {{8 9}} 10}
                  1 2 3 4 5 6 7 {8 9} 10
                  tclsh&gt; ::struct::list flatten -full {1 2 3 {4 5} {6 7} {{8 9}} 10}
                  1 2 3 4 5 6 7 8 9 10

       <b>::struct::list</b> <b>map</b> <u>sequence</u> <u>cmdprefix</u>
              The subcommand takes a <u>sequence</u> to operate on and  a  command  prefix  (<u>cmdprefix</u>)  specifying  an
              operation,  applies  the  command  prefix  to  each element of the sequence and returns a sequence
              consisting of the results of that application.

              The command prefix will be evaluated with a single word appended to it. The evaluation takes place
              in the context of the caller of the subcommand.

                  tclsh&gt; # squaring all elements in a list

                  tclsh&gt; proc sqr {x} {expr {$x*$x}}
                  tclsh&gt; ::struct::list map {1 2 3 4 5} sqr
                  1 4 9 16 25

                  tclsh&gt; # Retrieving the second column from a matrix
                  tclsh&gt; # given as list of lists.

                  tclsh&gt; proc projection {n list} {::lindex $list $n}
                  tclsh&gt; ::struct::list map {{a b c} {1 2 3} {d f g}} {projection 1}
                  b 2 f

       <b>::struct::list</b> <b>mapfor</b> <u>var</u> <u>sequence</u> <u>script</u>
              The subcommand takes a <u>sequence</u> to operate on and a tcl <u>script</u>, applies the script to each element
              of the sequence and returns a sequence consisting of the results of that application.

              The script will be evaluated as is, and has  access  to  the  current  list  element  through  the
              specified  iteration  variable <u>var</u>. The evaluation takes place in the context of the caller of the
              subcommand.

                  tclsh&gt; # squaring all elements in a list

                  tclsh&gt; ::struct::list mapfor x {1 2 3 4 5} {
                expr {$x * $x}
                  }
                  1 4 9 16 25

                  tclsh&gt; # Retrieving the second column from a matrix
                  tclsh&gt; # given as list of lists.

                  tclsh&gt; ::struct::list mapfor x {{a b c} {1 2 3} {d f g}} {
                lindex $x 1
                  }
                  b 2 f

       <b>::struct::list</b> <b>filter</b> <u>sequence</u> <u>cmdprefix</u>
              The subcommand takes a <u>sequence</u> to operate on and  a  command  prefix  (<u>cmdprefix</u>)  specifying  an
              operation,  applies  the  command  prefix  to  each element of the sequence and returns a sequence
              consisting of all elements of the <u>sequence</u> for which the command prefix returned <b>true</b>.   In  other
              words,  this  command  filters  out  all  elements  of  the input <u>sequence</u> which fail the test the
              <u>cmdprefix</u> represents, and returns the remaining elements.

              The command prefix will be evaluated with a single word appended to it. The evaluation takes place
              in the context of the caller of the subcommand.

                  tclsh&gt; # removing all odd numbers from the input

                  tclsh&gt; proc even {x} {expr {($x % 2) == 0}}
                  tclsh&gt; ::struct::list filter {1 2 3 4 5} even
                  2 4

       <u>Note:</u> The <b>filter</b> is a specialized application of <b>fold</b> where the result is extended with the current  item
       or not, depending o nthe result of the test.

       <b>::struct::list</b> <b>filterfor</b> <u>var</u> <u>sequence</u> <u>expr</u>
              The  subcommand takes a <u>sequence</u> to operate on and a tcl expression (<u>expr</u>) specifying a condition,
              applies the conditionto each element of the sequence and returns  a  sequence  consisting  of  all
              elements  of  the  <u>sequence</u>  for which the expression returned <b>true</b>.  In other words, this command
              filters out all elements of the input <u>sequence</u> which fail the test the condition <u>expr</u>  represents,
              and returns the remaining elements.

              The  expression  will  be  evaluated as is, and has access to the current list element through the
              specified iteration variable <u>var</u>. The evaluation takes place in the context of the caller  of  the
              subcommand.

                  tclsh&gt; # removing all odd numbers from the input

                  tclsh&gt; ::struct::list filterfor x {1 2 3 4 5} {($x % 2) == 0}
                  2 4

       <b>::struct::list</b> <b>split</b> <u>sequence</u> <u>cmdprefix</u> ?<u>passVar</u> <u>failVar</u>?
              This  is a variant of method <b>filter</b>, see above. Instead of returning just the elements passing the
              test we get lists of both passing and failing elements.

              If no variable names are specified then the result of the command will be a  list  containing  the
              list  of passing elements, and the list of failing elements, in this order. Otherwise the lists of
              passing and failing elements are stored into the two specified variables, and the result will be a
              list containing two numbers, the number of elements passing the test, and the number  of  elements
              failing, in this order.

              The interface to the test is the same as used by <b>filter</b>.

       <b>::struct::list</b> <b>fold</b> <u>sequence</u> <u>initialvalue</u> <u>cmdprefix</u>
              The  subcommand  takes  a  <u>sequence</u> to operate on, an arbitrary string <u>initial</u> <u>value</u> and a command
              prefix (<u>cmdprefix</u>) specifying an operation.

              The command prefix will be evaluated with two words appended to it. The second of these words will
              always be an element of the sequence. The evaluation takes place in the context of the  caller  of
              the subcommand.

              It  then  reduces  the  sequence  into  a single value through repeated application of the command
              prefix and returns that value. This reduction is done by

              <b>1</b>      Application of the command to the initial value and the first element of the list.

              <b>2</b>      Application of the command to the result of the last call and the  second  element  of  the
                     list.

              <b>...</b>

              <b>i</b>      Application of the command to the result of the last call and the <b>i</b>'th element of the list.

              <b>...</b>

              <b>end</b>    Application of the command to the result of the last call and the last element of the list.
                     The result of this call is returned as the result of the subcommand.

                  tclsh&gt; # summing the elements in a list.
                  tclsh&gt; proc + {a b} {expr {$a + $b}}
                  tclsh&gt; ::struct::list fold {1 2 3 4 5} 0 +
                  15

       <b>::struct::list</b> <b>shift</b> <u>listvar</u>
              The  subcommand  takes  the list contained in the variable named by <u>listvar</u> and shifts it down one
              element.  After the call <u>listvar</u> will contain a list containing the second to last elements of the
              input list. The first element of the ist is returned as the result of the  command.  Shifting  the
              empty list does nothing.

       <b>::struct::list</b> <b>iota</b> <u>n</u>
              The  subcommand  returns  a list containing the integer numbers in the range <b>[0,n)</b>. The element at
              index <b>i</b> of the list contain the number <b>i</b>.

              For "<u>n</u> == <b>0</b>" an empty list will be returned.

       <b>::struct::list</b> <b>equal</b> ?<b>-simple</b>? ?<b>--</b>? <u>a</u> <u>b</u>
              The subcommand compares the two lists <u>a</u> and <u>b</u> for equality. In other words, they have to be of the
              same length and have to contain the same elements in the same order.

              By default equality checks are applied recursively to list elements which  are  lists  themselves.
              This behaviour is disabled when specifying the option <b>-simple</b>.

              The option <b>--</b> disables option processing even if the following argument looks like such.

              A boolean value will be returned as the result of the command.  This value will be <b>true</b> if the two
              lists are equal, and <b>false</b> else.

       <b>::struct::list</b> <b>repeat</b> <u>size</u> <u>element1</u> ?<u>element2</u> <u>element3</u>...?
              The  subcommand  creates  a list of length "<u>size</u> * <u>number</u> <u>of</u> <u>elements</u>" by repeating <u>size</u> times the
              sequence of elements <u>element1</u> <u>element2</u> <u>...</u>.  <u>size</u> must be a positive integer, <u>element</u><b>n</b> can be  any
              Tcl  value.   Note that <b>repeat</b> <b>1</b> <b>arg</b> <b>...</b>  is identical to <b>list</b> <b>arg</b> <b>...</b>, though the <u>arg</u> is required
              with <b>repeat</b>.

              <u>Examples:</u>

                  tclsh&gt; ::struct::list repeat 3 a
                  a a a
                  tclsh&gt; ::struct::list repeat 3 [::struct::list repeat 3 0]
                  {0 0 0} {0 0 0} {0 0 0}
                  tclsh&gt; ::struct::list repeat 3 a b c
                  a b c a b c a b c
                  tclsh&gt; ::struct::list repeat 3 [::struct::list repeat 2 a] b c
                  {a a} b c {a a} b c {a a} b c

       <b>::struct::list</b> <b>repeatn</b> <u>value</u> <u>size</u>...
              The subcommand creates a (nested) list containing the <u>value</u> in all positions. The exact  size  and
              degree  of  nesting  is  determined by the <u>size</u> arguments, all of which have to be integer numbers
              greater than or equal to zero.

              A single argument <u>size</u> which is a list of more than one element will be treated as  if  more  than
              argument <u>size</u> was specified.

              If  only  one  argument  <u>size</u>  is present the returned list will not be nested, of length <u>size</u> and
              contain <u>value</u> in all positions.  If more than one <u>size</u> argument is present the returned list  will
              be nested, and of the length specified by the last <u>size</u> argument given to it. The elements of that
              list  are  defined  as  the  result of <b>Repeat</b> for the same arguments, but with the last <u>size</u> value
              removed.

              An empty list will be returned if no <u>size</u> arguments are present.

                  tclsh&gt; ::struct::list repeatn  0 3 4
                  {0 0 0} {0 0 0} {0 0 0} {0 0 0}
                  tclsh&gt; ::struct::list repeatn  0 {3 4}
                  {0 0 0} {0 0 0} {0 0 0} {0 0 0}
                  tclsh&gt; ::struct::list repeatn  0 {3 4 5}
                  {{0 0 0} {0 0 0} {0 0 0} {0 0 0}} {{0 0 0} {0 0 0} {0 0 0} {0 0 0}} {{0 0 0} {0 0 0} {0 0 0} {0 0 0}} {{0 0 0} {0 0 0} {0 0 0} {0 0 0}} {{0 0 0} {0 0 0} {0 0 0} {0 0 0}}

       <b>::struct::list</b> <b>dbJoin</b> ?<b>-inner</b>|<b>-left</b>|<b>-right</b>|<b>-full</b>? ?<b>-keys</b> <u>varname</u>? {<u>keycol</u> <u>table</u>}...
              The method performs a table join according to relational algebra. The  execution  of  any  of  the
              possible  outer  join  operation  is  triggered by the presence of either option <b>-left</b>, <b>-right</b>, or
              <b>-full</b>. If none of these options is present a regular inner join will be performed. This  can  also
              be triggered by specifying <b>-inner</b>. The various possible join operations are explained in detail in
              section <b>TABLE</b> <b>JOIN</b>.

              If  the  <b>-keys</b>  is  present its argument is the name of a variable to store the full list of found
              keys into. Depending on the exact nature of the input table and the join mode the output table may
              not contain all the keys by default. In such a case the caller can declare  a  variable  for  this
              information and then insert it into the output table on its own, as she will have more information
              about the placement than this command.

              What is left to explain is the format of the arguments.

              The  <u>keycol</u> arguments are the indices of the columns in the tables which contain the key values to
              use for the joining. Each argument applies to  the  table  following  immediately  after  it.  The
              columns  are  counted  from  <b>0</b>,  which  references the first column. The table associated with the
              column index has to have at least <u>keycol</u>+1 columns. An error will be thrown if there are less.

              The <u>table</u> arguments represent a table or matrix of rows and columns of values.  We  use  the  same
              representation  as  generated and consumed by the methods <b>get</b> <b>rect</b> and <b>set</b> <b>rect</b> of <b>matrix</b> objects.
              In other words, each argument is a list, representing the whole matrix.  Its  elements  are  lists
              too,  each  representing a single rows of the matrix. The elements of the row-lists are the column
              values.

              The table resulting from the join operation is returned as the result of the command. We  use  the
              same representation as described above for the input <u>table</u>s.

       <b>::struct::list</b> <b>dbJoinKeyed</b> ?<b>-inner</b>|<b>-left</b>|<b>-right</b>|<b>-full</b>? ?<b>-keys</b> <u>varname</u>? <u>table</u>...
              The  operations  performed  by  this  method  are the same as described above for <b>dbJoin</b>. The only
              difference is in the specification of the keys to use. Instead of using  column  indices  separate
              from  the table here the keys are provided within the table itself. The row elements in each <u>table</u>
              are not the lists of column values, but a two-element list where the second element is the regular
              list of column values and the first element is the key to use.

       <b>::struct::list</b> <b>swap</b> <u>listvar</u> <u>i</u> <u>j</u>
              The subcommand exchanges the elements at the indices <u>i</u> and <u>j</u> in the list stored  in  the  variable
              named  by  <u>listvar</u>.  The  list  is  modified  in  place,  and  also  returned as the result of the
              subcommand.

       <b>::struct::list</b> <b>firstperm</b> <u>list</u>
              This subcommand returns the lexicographically first permutation of the input <u>list</u>.

       <b>::struct::list</b> <b>nextperm</b> <u>perm</u>
              This subcommand accepts a permutation of a set of elements (provided by <u>perm</u>) and returns the next
              permutatation in lexicographic sequence.

              The algorithm used here is by Donal E. Knuth, see section <b>REFERENCES</b> for details.

       <b>::struct::list</b> <b>permutations</b> <u>list</u>
              This subcommand returns a list containing all permutations of  the  input  <u>list</u>  in  lexicographic
              order.

       <b>::struct::list</b> <b>foreachperm</b> <u>var</u> <u>list</u> <u>body</u>
              This  subcommand  executes  the  script  <u>body</u> once for each permutation of the specified <u>list</u>. The
              permutations are visited in lexicographic order, and the variable <u>var</u> is set  to  the  permutation
              for which <u>body</u> is currently executed. The result of the loop command is the empty string.

</pre><h4><b>LONGEST</b> <b>COMMON</b> <b>SUBSEQUENCE</b> <b>AND</b> <b>FILE</b> <b>COMPARISON</b></h4><pre>
       The  <b>longestCommonSubsequence</b>  subcommand  forms  the  core  of  a flexible system for doing differential
       comparisons of files, similar to the capability offered by the Unix command <b>diff</b>.  While  this  procedure
       is quite rapid for many tasks of file comparison, its performance degrades severely if <u>sequence2</u> contains
       many equal elements (as, for instance, when using this procedure to compare two files, a quarter of whose
       lines are blank.  This drawback is intrinsic to the algorithm used (see the Reference for details).

       One  approach  to  dealing  with  the  performance  problem  that  is  sometimes effective in practice is
       arbitrarily to exclude elements that appear more than a certain number of times.  This number is provided
       as the <u>maxOccurs</u> parameter.  If frequent lines are excluded in this manner, they will not appear  in  the
       common  subsequence  that  is  computed;  the result will be the longest common subsequence of infrequent
       elements.  The procedure <b>longestCommonSubsequence2</b> implements this heuristic.  It functions as a  wrapper
       around  <b>longestCommonSubsequence</b>;  it computes the longest common subsequence of infrequent elements, and
       then subdivides the subsequences that lie between the matches to  approximate  the  true  longest  common
       subsequence.

</pre><h4><b>TABLE</b> <b>JOIN</b></h4><pre>
       This is an operation from relational algebra for relational databases.

       The  easiest way to understand the regular inner join is that it creates the cartesian product of all the
       tables involved first and then keeps only all those rows in the resulting table for which the  values  in
       the specified key columns are equal to each other.

       Implementing  this description naively, i.e. as described above will generate a <u>huge</u> intermediate result.
       To avoid this the cartesian product and the filtering of row are done at the same time. What is  required
       is  a  fast  way  to  determine  if  a key is present in a table. In a true database this is done through
       indices. Here we use arrays internally.

       An <u>outer</u> join is an extension of the inner join for two tables. There are three variants  of  outerjoins,
       called  <u>left</u>,  <u>right</u>,  and <u>full</u> outer joins. Their result always contains all rows from an inner join and
       then some additional rows.

       [1]    For the left outer join the additional rows are all rows from the left table for which there is no
              key in the right table. They are joined to an empty row of the right table to fit  them  into  the
              result.

       [2]    For  the right outer join the additional rows are all rows from the right table for which there is
              no key in the left table. They are joined to an empty row of the left table to fit them  into  the
              result.

       [3]    The  full  outer join combines both left and right outer join. In other words, the additional rows
              are as defined for left outer join, and right outer join, combined.

       We extend all the joins from two to <b>n</b> tables (<b>n</b> &gt; 2) by executing

                  (...((table1 join table2) join table3) ...) join tableN

       Examples for all the joins:

                  Inner Join

                  {0 foo}              {0 bagel}    {0 foo   0 bagel}
                  {1 snarf} inner join {1 snatz}  = {1 snarf 1 snatz}
                  {2 blue}             {3 driver}

                  Left Outer Join

                  {0 foo}                   {0 bagel}    {0 foo   0 bagel}
                  {1 snarf} left outer join {1 snatz}  = {1 snarf 1 snatz}
                  {2 blue}                  {3 driver}   {2 blue  {} {}}

                  Right Outer Join

                  {0 foo}                    {0 bagel}    {0 foo   0 bagel}
                  {1 snarf} right outer join {1 snatz}  = {1 snarf 1 snatz}
                  {2 blue}                   {3 driver}   {{} {}   3 driver}

                  Full Outer Join

                  {0 foo}                   {0 bagel}    {0 foo   0 bagel}
                  {1 snarf} full outer join {1 snatz}  = {1 snarf 1 snatz}
                  {2 blue}                  {3 driver}   {2 blue  {} {}}
                                                         {{} {}   3 driver}

</pre><h4><b>REFERENCES</b></h4><pre>
       [1]    J. W. Hunt and M. D. McIlroy, "An algorithm for differential file comparison,"  Comp.  Sci.  Tech.
              Rep. #41, Bell Telephone Laboratories (1976). Available on the Web at the second author's personal
              site: <u><a href="http://www.cs.dartmouth.edu/~doug/">http://www.cs.dartmouth.edu/~doug/</a></u>

       [2]    Donald E. Knuth, "Fascicle 2b of 'The Art of Computer Programming' volume 4". Available on the Web
              at the author's personal site: <u><a href="http://www-cs-faculty.stanford.edu/~knuth/fasc2b.ps.gz">http://www-cs-faculty.stanford.edu/~knuth/fasc2b.ps.gz</a></u>.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category <u>struct</u> <u>::</u> <u>list</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       Fisher-Yates, assign, common, comparison, diff, differential, equal, equality, filter, first permutation,
       flatten, folding, full outer join, generate permutations,  inner  join,  join,  left  outer  join,  list,
       longest   common  subsequence,  map,  next  permutation,  outer  join,  permutation,  reduce,  repeating,
       repetition, reshuffle, reverse, right outer join, shuffle, subsequence, swapping

</pre><h4><b>CATEGORY</b></h4><pre>
       Data structures

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2003-2005 by Kevin B. Kenny. All rights reserved
       Copyright (c) 2003-2012 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 1.9                                    <u>struct::<a href="../man3tcl/list.3tcl.html">list</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>