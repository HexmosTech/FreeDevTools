<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tracefs_cpu_read_size, tracefs_cpu_read, tracefs_cpu_buffered_read, tracefs_cpu_write, tracefs_cpu_stop,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtracefs-doc">libtracefs-doc_1.8.1-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tracefs_cpu_read_size, tracefs_cpu_read, tracefs_cpu_buffered_read, tracefs_cpu_write, tracefs_cpu_stop,
       tracefs_cpu_flush, tracefs_cpu_flush_write, tracefs_cpu_pipe - Reading trace_pipe_raw data

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tracefs.h&gt;</b>

       int <b>tracefs_cpu_read_size</b>(struct tracefs_cpu *<u>tcpu</u>);
       int <b>tracefs_cpu_read</b>(struct tracefs_cpu *<u>tcpu</u>, void *<u>buffer</u>, bool <u>nonblock</u>);
       int <b>tracefs_cpu_buffered_read</b>(struct tracefs_cpu *<u>tcpu</u>, void *<u>buffer</u>, bool <u>nonblock</u>);
       int <b>tracefs_cpu_write</b>(struct tracefs_cpu *<u>tcpu</u>, int <u>wfd</u>, bool <u>nonblock</u>);
       int <b>tracefs_cpu_stop</b>(struct tracefs_cpu *<u>tcpu</u>);
       int <b>tracefs_cpu_flush</b>(struct tracefs_cpu *<u>tcpu</u>, void *<u>buffer</u>);
       int <b>tracefs_cpu_flush_write</b>(struct tracefs_cpu *<u>tcpu</u>, int <u>wfd</u>);
       int <b>tracefs_cpu_pipe</b>(struct tracefs_cpu *<u>tcpu</u>, int <u>wfd</u>, bool <u>nonblock</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This set of APIs can be used to read the raw data from the trace_pipe_raw files in the tracefs file
       system.

       The <b>tracefs_cpu_read_size()</b> returns the subbuffer size of the trace_pipe_raw. This returns the minimum
       size of the buffer that is passed to the below functions.

       The <b>tracefs_cpu_read()</b> reads the trace_pipe_raw files associated to <u>tcpu</u> into <u>buffer</u>. <u>buffer</u> must be at
       least the size of the sub buffer of the ring buffer, which is returned by <b>tracefs_cpu_read_size()</b>. If
       <u>nonblock</u> is set, and there’s no data available, it will return immediately. Otherwise depending on how
       <u>tcpu</u> was opened, it will block. If <u>tcpu</u> was opened with nonblock set, then this <u>nonblock</u> will make no
       difference.

       The <b>tracefs_cpu_buffered_read()</b> is basically the same as <b>tracefs_cpu_read()</b> except that it uses a pipe
       through splice to buffer reads. This will batch reads keeping the reading from the ring buffer less
       intrusive to the system, as just reading all the time can cause quite a disturbance. Note, one difference
       between this and <b>tracefs_cpu_read()</b> is that it will read only in sub buffer pages. If the ring buffer has
       not filled a page, then it will not return anything, even with <u>nonblock</u> set. Calls to <b>tracefs_cpu_flush()</b>
       should be done to read the rest of the file at the end of the trace.

       The <b>tracefs_cpu_write()</b> will pipe the data from the trace_pipe_raw file associated with <u>tcpu</u> into the <u>wfd</u>
       file descriptor. If <u>nonblock</u> is set, then it will not block on if there’s nothing to write. Note, it will
       only write sub buffer size data to <u>wfd</u>. Calls to tracefs_cpu_flush_write() are needed to write out the
       rest.

       The <b>tracefs_cpu_stop()</b> will attempt to unblock a task blocked on <u>tcpu</u> reading it. On older kernels, it
       may not do anything for the pipe reads, as older kernels do not wake up tasks waiting on the ring buffer.
       Returns 0 if it definitely woke up any possible waiters, but returns 1 if it is not sure it worked and
       waiters may need to have a signal sent to them.

       The <b>tracefs_cpu_flush()</b> reads the trace_pipe_raw file associated by the <u>tcpu</u> and puts it into <u>buffer</u>,
       which must be the size of the sub buffer which is retrieved. by <b>tracefs_cpu_read_size()</b>. This should be
       called at the end of tracing to get the rest of the data. This call will convert the file descriptor of
       trace_pipe_raw into non-blocking mode.

       The <b>tracefs_cpu_flush_write()</b> same as <b>trace_cpu_flush()</b> except it takes a file descriptor <u>wfd</u> to flush
       the data into.

       The <b>tracefs_cpu_pipe()</b> is similar to <b>tracefs_cpu_write()</b> but the <u>wfd</u> file descriptor must be a pipe. This
       call is an optimization of <b>tracefs_cpu_write()</b> that uses two calls to <b><a href="../man2/splice.2.html">splice</a></b>(2) in order to connect the
       trace_pipe_raw file descriptor with the write file descriptor. <b><a href="../man2/splice.2.html">splice</a></b>(2) requires that one of the passed
       in file descriptors is a pipe. If the application wants to pass the data to an existing pipe, there’s no
       reason for there to be two <b><a href="../man2/splice.2.html">splice</a></b>(2) system calls and <b>tracefs_cpu_pipe()</b> can simply use a single call to
       <u>wfd</u>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The <b>tracefs_cpu_open()</b> returns a struct tracefs_cpu descriptor that can be used by the other functions or
       NULL on error.

       The <b>tracefs_cpu_read_size()</b> returns the minimum size of the buffers to be used with <b>tracefs_cpu_read()</b>,
       <b>tracefs_cpu_buffered_read()</b> and <b>tracefs_cpu_flush()</b>. Returns negative on error.

       The <b>tracefs_cpu_read()</b> returns the number of bytes read, or negative on error.

       The <b>tracefs_cpu_buffered_read()</b> returns the number of bytes read or negative on error.

       The <b>tracefs_cpu_write()</b> returns the number of bytes written to the file or negative on error.

       The <b>tracefs_cpu_stop()</b> returns zero if any waiters were guaranteed to be woken up from waiting on input,
       or returns one if this is an older kernel that does not supply that guarantee, and a signal may need to
       be sent to any waiters. Returns negative on error.

       The <b>tracefs_cpu_flush()</b> returns the number of bytes read or negative on error.

       The <b>tracefs_cpu_flush_write()</b> returns the number of bytes written to the file or negative on error.

</pre><h4><b>EXAMPLE</b></h4><pre>
           #define _LARGEFILE64_SOURCE
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/ctype.h">ctype.h</a>&gt;
           #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           #include &lt;tracefs.h&gt;

           struct thread_data {
                   struct tracefs_cpu      *tcpu;
                   int                     done;
                   int                     fd;
           };

           static void *thread_run(void *arg)
           {
                   struct thread_data *data = arg;
                   struct tracefs_cpu *tcpu = data-&gt;tcpu;
                   int fd = data-&gt;fd;
                   int ret;

                   while (!data-&gt;done) {
                           ret = tracefs_cpu_write(tcpu, fd, false);
                           printf("wrote %d\n", ret);
                   }
                   return NULL;
           }

           int main (int argc, char **argv)
           {
                   struct tracefs_instance *instance;
                   struct thread_data data;
                   pthread_t thread;
                   char *file;
                   int secs = 10;
                   int cpu;
                   int ret;

                   if (argc &lt; 3 || !isdigit(argv[1][0])) {
                           printf("usage: %s cpu file_destination [sleep secs]\n\n", argv[0]);
                           exit(-1);
                   }

                   cpu = atoi(argv[1]);
                   file = argv[2];

                   if (argc &gt; 3)
                           secs = atoi(argv[3]);

                   instance = tracefs_instance_create("cpu_write");
                   if (!instance) {
                           perror("create instance");
                           exit(-1);
                   }

                   memset(&amp;data, 0, sizeof(data));

                   data.tcpu = tracefs_cpu_open(instance, cpu, 0);
                   if (!data.tcpu) {
                           perror("Open instance");
                           exit(-1);
                   }

                   data.fd = open(file, O_WRONLY | O_CREAT | O_TRUNC | O_LARGEFILE, 0644);
                   if (data.fd &lt; 0) {
                           perror(file);
                           exit(-1);
                   }

                   pthread_create(&amp;thread, NULL, thread_run, &amp;data);

                   sleep(secs);

                   data.done = 1;
                   printf("stopping\n");
                   ret = tracefs_cpu_stop(data.tcpu);

                   printf("joining %d\n", ret);
                   pthread_join(thread, NULL);

                   tracefs_trace_off(instance);
                   do {
                           ret = tracefs_cpu_flush_write(data.tcpu, data.fd);
                           printf("flushed %d\n", ret);
                   } while (ret &gt; 0);
                   tracefs_trace_on(instance);

                   tracefs_cpu_close(data.tcpu);
                   close(data.fd);

                   return 0;
           }

</pre><h4><b>FILES</b></h4><pre>
           <b>tracefs.h</b>
                   Header file to include in order to have access to the library APIs.
           <b>-ltracefs</b>
                   Linker switch to add when building a program that uses the library.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/tracefs_cpu_open.3.html">tracefs_cpu_open</a></b>(3) <b><a href="../man3/tracefs_cpu_close.3.html">tracefs_cpu_close</a></b>(3) <b><a href="../man3/tracefs_cpu_read_buf.3.html">tracefs_cpu_read_buf</a></b>(3) <b><a href="../man3/tracefs_cpu_buffered_read_buf.3.html">tracefs_cpu_buffered_read_buf</a></b>(3)
       <b><a href="../man3/tracefs_cpu_flush_buf.3.html">tracefs_cpu_flush_buf</a></b>(3) <b><a href="../man3/libtracefs.3.html">libtracefs</a></b>(3), <b><a href="../man3/libtraceevent.3.html">libtraceevent</a></b>(3), <b><a href="../man1/trace-cmd.1.html">trace-cmd</a></b>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
           <b>Steven</b> <b>Rostedt</b> &lt;<b><a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a></b>[1]&gt;

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<b><a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a></b>[2]&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       libtracefs is Free Software licensed under the GNU LGPL 2.1

</pre><h4><b>RESOURCES</b></h4><pre>
       <b>https://git.kernel.org/pub/scm/libs/libtrace/libtracefs.git/</b>

</pre><h4><b>COPYING</b></h4><pre>
       Copyright (C) 2022 Google, Inc. Free use of this software is granted under the terms of the GNU Public
       License (GPL).

</pre><h4><b>NOTES</b></h4><pre>
        1. <a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a>
           <a href="mailto:rostedt@goodmis.org">mailto:rostedt@goodmis.org</a>

        2. <a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a>
           <a href="mailto:linux-trace-devel@vger.kernel.org">mailto:linux-trace-devel@vger.kernel.org</a>

libtracefs 1.8.1                                   06/05/2025                                      <u><a href="../man3/LIBTRACEFS.3.html">LIBTRACEFS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>