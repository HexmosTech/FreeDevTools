<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ibv_flow_action_esp - Flow action esp for verbs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libibverbs-dev">libibverbs-dev_56.1-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ibv_flow_action_esp - Flow action esp for verbs

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;infiniband/verbs.h&gt;

              struct ibv_flow_action *
              ibv_create_flow_action_esp(struct ibv_context *ctx,
                             struct ibv_flow_action_esp *esp);
              int
              ibv_modify_flow_action_esp(struct ibv_flow_action *action,
                             struct ibv_flow_action_esp *esp);

              int ibv_destroy_flow_action(struct ibv_flow_action *action);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       An  IPSEC  ESP  flow  steering  action  allows  a flow steering rule to decrypt or encrypt a packet after
       matching.  Each action contains the necessary information for this operation in the <u>params</u> argument.

       After the crypto operation the packet will continue to be processed  by  flow  steering  rules  until  it
       reaches a final action of discard or delivery.

       After  the  action  is  created,  then  it  should be associated with a <u>struct</u> <u>ibv_flow_attr</u> using <u>struct</u>
       <u>ibv_flow_spec_action_handle</u> flow specification.  Each action can be associated with multiple  flows,  and
       <u>ibv_modify_flow_action_esp</u> will alter all associated flows simultaneously.

</pre><h4><b>ARGUMENTS</b></h4><pre>
       <u>ctx</u>    RDMA device context to create the action on.

       <u>esp</u>    ESP parameters and key material for the action.

       <u>action</u> Existing action to modify ESP parameters.

   <u><b>action</b></u> Argument
              struct ibv_flow_action_esp {
                  struct ibv_flow_action_esp_attr *esp_attr;

                  /* See Key Material */
                  uint16_t        keymat_proto;
                  uint16_t        keymat_len;
                  void           *keymat_ptr;

                  /* See Replay Protection */
                  uint16_t        replay_proto;
                  uint16_t        replay_len;
                  void           *replay_ptr;

                  struct ibv_flow_action_esp_encap *esp_encap;

                  uint32_t        comp_mask;
                  uint32_t        esn;
              };

       <u>comp_mask</u>
              Bitmask specifying what fields in the structure are valid.

       <u>esn</u>    The    starting    value    of    the    ESP    extended   sequence   number.    Valid   only   if
              <u>IBV_FLOW_ACTION_ESP_MASK_ESN</u> is set in <u>comp_mask</u>.

              The 32 bits of <u>esn</u> will be used to compute the full 64 bit ESN required for the AAD construction.

              When in <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_INLINE_CRYPTO</u> mode, the implementation will  automatically
              track rollover of the lower 32 bits of the ESN.  However, an update of the window is required once
              every 2^31 sequences.

              When  in <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLOAD</u> mode this value is automatically incremended
              and it is also used for anti-replay checks.

       <u>esp_attr</u>
              See <u>ESP</u> <u>Attributes</u>.  May be NULL on modify.

       <u>keymat_proto</u>, <u>keymat_len</u>, <u>keymat_ptr</u>
              Describe the key material and encryption standard to use.  May be NULL on modify.

       <u>replay_proto</u>, <u>replay_len</u>, <u>replay_ptr</u>
              Describe the replay protection scheme used to manage sequence numbers and prevent replay  attacks.
              This field is only valid in full offload mode.  May be NULL on modify.

       <u>esp_encap</u>
              Describe  the  encapsulation  of ESP packets such as the IP tunnel and/or UDP encapsulation.  This
              field is only valid in full offload mode.  May be NULL on modify.

   <b>ESP</b> <b>attributes</b>
              struct ibv_flow_action_esp_attr {
                  uint32_t   spi;
                  uint32_t   seq;
                  uint32_t   tfc_pad;
                  uint32_t   flags;
                  uint64_t   hard_limit_pkts;
              };

       <u>flags</u>  A bitwise OR of the various <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS</u> described below.

              <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_DECRYPT</u>, <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ENCRYPT</u>
                     The action will decrypt or encrypt a packet using the provided keying material.

                     The implementation may require that encrypt is only used with an egress flow steering rule,
                     and that decrypt is only used with an ingress flow steering rule.

   <b>Full</b> <b>Offload</b> <b>Mode</b>
       When <u>esp_attr</u> flag <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLOAD</u> is set the ESP  header  and  trailer  are
       added  and  removed  automatically during the cipher operation.  In this case the <u>esn</u> and <u>spi</u> are used to
       populate and check the ESP header, and any information from the <u>keymat</u> (eg a IV) is placed in the headers
       and otherwise handled automatically.

       For decrypt the hardware will perform anti-replay.

       Decryption failure will cause the packet to be dropped.

       This action must be combined with the flow steering that identifies  the  packets  protected  by  the  SA
       defined in this action.

       The following members of the esp_attr are used only in full offload mode:

       <u>spi</u>    The    value    for    the    ESP    Security   Parameters   Index.    It   is   only   used   for
              <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLAOD</u>.

       <u>seq</u>    The initial 32 lower bytes of the sequence number.  This is the value of the ESP sequence  number.
              It is only used for <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLAOD</u>.

       <u>tfc_pad</u>
              The  length of Traffic Flow Confidentiality Padding as specified by RFC4303.  If it is set to zero
              no additional padding is added.  It is only used for <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLAOD</u>.

       <u>hard_limit_pkts</u>
              The hard lifetime of the SA measured in number of packets.  As specified by RFC4301.   After  this
              limit  is  reached the action will drop future packets to prevent breaking the crypto.  It is only
              used for <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLAOD</u>.

   <b>Inline</b> <b>Crypto</b> <b>Mode</b>
       When <u>esp_attr</u> flag <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_INLINE_CRYPTO</u> is set the user must  providate  packets
       with additional headers.

       For  encrypt  the  packet  must  contain  a  fully populated IPSEC packet except the data payload is left
       un-encrypted and there is no IPsec trailer.  If the IV must be unpredictable, then a flag should indicate
       the transofrmation such as <u>IB_UVERBS_FLOW_ACTION_IV_ALGO_SEQ</u>.

       <u>IB_UVERBS_FLOW_ACTION_IV_ALGO_SEQ</u> means that the IV is incremented sequentually.  If the IV algorithm  is
       supported by HW, then it could provide support for LSO offload with ESP inline crypto.

       Finally,  the  IV used to encrypt the packet replaces the IV field provided, the payload is encrypted and
       authenticated, a trailer with padding is added and the ICV is added as well.

       For decrypt the packet is authenticated and decrypted in-place, resulting in  a  decrypted  IPSEC  packet
       with  no  trailer.   The result of decryption and authentication can be retrieved from an extended CQ via
       the <u><a href="../man3/ibv_wc_read_XXX.3.html">ibv_wc_read_XXX</a>(3)</u> function.

       This mode must be combined with the flow steering including <u>IBV_FLOW_SPEC_IPV4</u> and  <u>IBV_FLOW_SPEC_ESP</u>  to
       match  the  outer  packet  headers  to  ensure  that the action is only applied to IPSEC packets with the
       correct identifiers.

       For inline crypto, we have some special requirements to maintain a stateless ESN  while  maintaining  the
       same  parameters  as  software.   The  system supports offloading a portion of the IPSEC flow, enabling a
       single flow to be split between multiple NICs.

   <b>Determining</b> <b>the</b> <b>ESN</b> <b>for</b> <b>Ingress</b> <b>Packets</b>
       We require a “modify” command once every 2^31 packets.  This modify command allows the implementation  in
       HW to be stateless, as follows:

                         ESN 1                       ESN 2                      ESN 3
              |-------------*-------------|-------------*-------------|-------------*
              ^             ^             ^             ^             ^             ^

       ^ - marks where command invoked to update the SA ESN state machine.
       |  - marks the start of the ESN scope (0-2^32-1).  At this point move SA ESN “new_window” bit to zero and
       increment ESN.
       * - marks the middle of the ESN scope (2^31).  At this point move SA ESN “new_window” bit to one.

       For decryption the implementation uses the following state machine to determine ESN:

              if (!overlap) {
                  use esn // regardless of packet.seq
              } else { // new_window
                  if (packet.seq &gt;= 2^31)
                      use esn
                  else // packet.seq &lt; 2^31
                      use esn+1
              }

       This mechanism is controlled by the <u>esp_attr</u> flag:

       <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ESN_NEW_WINDOW</u>
              This flag is only used to provide stateless ESN support for inline crypto.  It is  used  only  for
              <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_INLINE_CRYPTO</u> and <u>IBV_FLOW_ACTION_ESP_MASK_ESN</u>.

              Setting this flag indicates that the bottom of the replay window is between 2^31 - 2^32.

   <b>Key</b> <b>Material</b> <b>for</b> <b>AES</b> <b>GCM</b> <b>(</b><u><b>IBV_ACTION_ESP_KEYMAT_AES_GCM</b></u>)
       The  AES  GCM  crypto  algorithm as defined by RFC4106.  This struct is to be provided in <u>keymat_ptr</u> when
       <u>keymat_proto</u> is set to <u>IBV_ACTION_ESP_KEYMAT_AES_GCM</u>.

              struct ibv_flow_action_esp_aes_keymat_aes_gcm {
                  uint64_t   iv;
                  uint32_t   iv_algo; /* Use enum ib_uverbs_flow_action_esp_aes_gcm_keymat_iv_algo */

                  uint32_t   salt;
                  uint32_t   icv_len;

                  uint32_t   key_len;
                  uint32_t   aes_key[256 / 32];
              };

       <u>iv</u>     The    starting     value     for     the     initialization     vector     used     only     with
              <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLOAD</u>  encryption  as  defined  in  RFC4106.  This field is
              ignored for <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_INLINE_CRYPTO</u>.

              For a given key, the IV MUST NOT be reused.

       <u>iv_algo</u>
              The algorithm used to transform/generate new IVs with <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLOAD</u>
              encryption.

              The only supported value is <u>IB_UVERBS_FLOW_ACTION_IV_ALGO_SEQ</u> to generate sequantial IVs.

       <u>salt</u>   The salt as defined by RFC4106.

       <u>icv_len</u>
              The length of the Integrity Check Value in bytes as defined by RFC4106.

       <u>aes_key</u>, <u>key_len</u>
              The cipher key data.  It must be either 16, 24 or 32 bytes as defined by RFC4106.

   <b>Bitmap</b> <b>Replay</b> <b>Protection</b> <b>(</b><u><b>IBV_FLOW_ACTION_ESP_REPLAY_BMP</b></u>)
       A shifting bitmap is used to identify which packets have already  been  transmitted.   Each  bit  in  the
       bitmap  represents a packet, it is set if a packet with this ESP sequence number has been received and it
       passed authentication.  If a packet with the same sequence is received, then  the  bit  is  already  set,
       causing  replay  protection to drop the packet.  The bitmap represents a window of <u>size</u> sequence numbers.
       If a newer sequence number is received, then the bitmap will shift to represent this as in RFC6479.   The
       replay window cannot shift more than 2^31 sequence numbers forward.

       This  struct  is  to be provided in <u>replay_ptr</u> when <u>reply_proto</u> is set to <u>IBV_FLOW_ACTION_ESP_REPLAY_BMP</u>.
       In this mode reply_ptr and reply_len should point to a struct ibv_flow_action_esp_replay_bmp  containing:
       <u>size</u> : The size of the bitmap.

   <b>ESP</b> <b>Encapsulation</b>
       An <u>esp_encap</u> specification is required when <u>eps_attr</u> flags <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_TUNNEL</u> is set.
       It  is  used  to  provide  the fields for the encapsulation header that is added/removed to/from packets.
       Tunnel and Transport mode are defined as in RFC4301.  UDP  encapsulation  of  ESP  can  be  specified  by
       providing the appropriate UDP header.

       This setting is only used in <u>IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLOAD</u> mode.

              struct ibv_flow_action_esp_encap {
                  void        *val;        /* pointer to struct ibv_flow_xxxx_filter */
                  struct ibv_flow_action_esp_encap   *next_ptr;
                  uint16_t    len;            /* Len of mask and pointer (separately) */
                  uint16_t    type;           /* Use flow_spec enum */
              };

       Each link in the list specifies a network header in the same manner as the flow steering API.  The header
       should be selected from a supported header in `enum ibv_flow_spec_type'.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon  success  <u>ibv_create_flow_action_esp</u>  will return a new <u>struct</u> <u>ibv_flow_action</u> object, on error NULL
       will be returned and errno will be set.

       Upon success <u>ibv_modify_action_esp</u> will return 0.  On error the value of  errno  will  be  returned.   If
       ibv_modify_flow_action  fails,  it is guaranteed that the last action still holds.  If it succeeds, there
       is a point in the future where the old action is applied on all packets until this point and the new  one
       is applied on all packets from this point and on.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/ibv_create_flow.3.html">ibv_create_flow</a>(3)</u>, <u><a href="../man3/ibv_destroy_action.3.html">ibv_destroy_action</a>(3)</u>, <u>RFC</u> <u>4106</u>

                                                                                          <u><a href="../man3/ibv_flow_action_esp.3.html">ibv_flow_action_esp</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>