<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tracecmd_iterate_events, tracecmd_iterate_events_multi, tracecmd_follow_event,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/trace-cmd">trace-cmd_3.3.1-1ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tracecmd_iterate_events, tracecmd_iterate_events_multi, tracecmd_follow_event,
       tracecmd_follow_missed_events, tracecmd_filter_add, tracecmd_iterate_reset - Read events from a trace
       file

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;trace-cmd.h&gt;</b>

       int <b>tracecmd_iterate_events</b>(struct tracecmd_input *<u>handle</u>,
                                   cpu_set_t *<u>cpus</u>, int <u>cpu_size</u>,
                                   int (*<u>callback</u>)(struct tracecmd_input *,
                                                   struct tep_record *,
                                                   int, void *),
                                   void *<u>callback_data</u>);
       int <b>tracecmd_iterate_events_multi</b>(struct tracecmd_input **<u>handles</u>,
                                         int <u>nr_handles</u>,
                                         int (*<u>callback</u>)(struct tracecmd_input *,
                                                                  struct tep_record *,
                                                                  int, void *),
                                         void *<u>callback_data</u>);
       int <b>tracecmd_iterate_events_reverse</b>(struct tracecmd_input *<u>handle</u>,
                                   cpu_set_t *<u>cpus</u>, int <u>cpu_size</u>,
                                   int (*<u>callback</u>)(struct tracecmd_input *,
                                                   struct tep_record *,
                                                   int, void *),
                                   void *<u>callback_data</u>, bool <u>cont</u>);
       int <b>tracecmd_follow_event</b>(struct tracecmd_input *<u>handle</u>,
                                 const char *<u>system</u>, const char *<u>event_name</u>,
                                 int (*<u>callback</u>)(struct tracecmd_input *,
                                                 struct tep_event *,
                                                 struct tep_record *,
                                                 int, void *),
                                 void *<u>callback_data</u>);
       int <b>tracecmd_follow_missed_events</b>(struct tracecmd_input *<u>handle</u>,
                                          int (*<u>callback</u>)(struct tracecmd_input *,
                                                          struct tep_event *,
                                                          struct tep_record *,
                                                          int, void *),
                                          void *<u>callback_data</u>);
       struct tracecmd_filter *<b>tracecmd_filter_add</b>(struct tracecmd_input <u>handle</u><b>,</b>
                                                   <b>const</b> <b>char</b> <b>*</b><u>filter_str</u><b>,</b> <b>bool</b> <u>neg</u><b>);</b>
       <b>int</b> <b>*tracecmd_iterate_reset</b>(struct tracecmd_input *<u>handle</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This set of APIs can be used to iterate over events after opening a trace file using one of the open
       functions like <b><a href="../man3/tracecmd_open.3.html">tracecmd_open</a>(3)</b> or <b><a href="../man3/tracecmd_open_fd.3.html">tracecmd_open_fd</a>(3)</b>.

       The function <b>tracecmd_iterate_events()</b> will iterate through all the events in the trace file defined by
       <u>handle</u>, where <u>handle</u> is returned from one of the <b><a href="../man3/tracecmd_open.3.html">tracecmd_open</a>(3)</b> functions. It will call the <u>callback</u>()
       function on the events on the CPUs defined by <u>cpus</u>. The <u>cpu_size</u> must be the size of <u>cpus</u> (see
       <b><a href="../man3/CPU_SET.3.html">CPU_SET</a>(3)</b>). If <u>cpus</u> is NULL, then <u>cpu_size</u> is ignored and <u>callback()</u> will be called for all events on
       all CPUs in the trace file. The <u>callback_data</u> is passed to the <u>callback()</u> as its last parameter. <u>callback</u>
       may be NULL, which is useful if <b>tracecmd_follow_event()</b> is used, but note if <u>callback</u> is NULL, then
       <u>callback_data</u> is ignored and not sent to the <u>callback</u> of <b>tracecmd_follow_event()</b>.

       The function <b>tracecmd_iterate_events_multi()</b> is similar to <b>tracecmd_iterate_events()</b> except that it
       allows to iterate over more than one trace file. If <b>tracecmd</b> <b><a href="../man1/agent.1.html">agent</a>(1)</b> is used to get a trace file for
       both the host and guest, make sure that the host trace file is the first entry in <u>handles</u> and
       <b>tracecmd_iterate_events_multi()</b> will do the synchronization of the meta data for the guest files that
       come later in <u>handles</u>. <u>handles</u> is an array of trace file descriptors that were opened by <b><a href="../man3/tracecmd_open.3.html">tracecmd_open</a>(3)</b>
       and friends. Note, unlike <b>tracecmd_iterate_events()</b>, <b>tracecmd_iterate_events_multi()</b> does not filter on
       CPUs, as it will cause the API to become too complex in knowing which handle to filter the CPUs on. If
       CPU filtering is desired, then the <u>callback</u> should check the <u>record</u>→cpu to and return 0 if it is not the
       desired CPU to process. <u>nr_handles</u> denotes the number of elements in <u>handles</u>. The <u>callback_data</u> is passed
       to the <u>callback</u> as its last parameter. <u>callback</u> may be NULL, which is useful if <b>tracecmd_follow_event()</b>
       is used, but note if <u>callback</u> is NULL, then <u>callback_data</u> is ignored and not sent to the <u>callback</u> of
       <b>tracecmd_follow_event()</b>.

       The function <b>tracecmd_iterate_events_reverse()</b> works pretty much the same way as
       <b>tracecmd_iterate_events()</b> works, but instead of calling the <u>callback</u>() function for each event in order
       of the timestamp, it will call the <u>callback</u>() function for each event in reverse order of the timestamp.
       If <u>cont</u> is false, it will start by calling the event with the oldest timestamp in the trace.dat file. If
       <u>cont</u> is set to true, then it will start whereever the current position of the tracing data is. For
       instance, if the <u>callback()</u> return something other than zero it will exit the iteration. If
       <b>tracecmd_iterate_events_reverse()</b> is called again with <u>cont</u> to true it will continue where it left off.
       If <u>cont</u> is false, it will start again at the event with the oldest timestamp. The <u>handle</u>, <u>cpus</u>, <u>cpu_size</u>,
       and <u>callback_data</u> act the same as <b>tracecmd_iterate_events()</b>.

       The <u>callback()</u> for both <b>tracecmd_iterate_events()</b>, <b>tracecmd_iterate_events_reverse()</b> and
       <b>tracecmd_iterate_events_multi()</b> is of the prototype:

       int <u>callback()</u>(struct tracecmd_input *<u>handle</u>, struct tep_record *<u>record</u>, int <u>cpu</u>, void *<u>data</u>);

       The <u>handle</u> is the same <u>handle</u> passed to <b>tracecmd_iterate_events()</b> or the current handle of <u>handles</u> passed
       to <b>tracecmd_iterate_events_multi()</b> that the <u>record</u> belongs to. The <u>record</u> is the current event record.
       The <u>cpu</u> is the current CPU being processed. Note, for <b>tracecmd_iterate_events_multi()</b> it may not be the
       actual CPU of the file, but the nth CPU of all the <u>handles</u> put together. Use <u>record</u>→cpu to get the actual
       CPU that the event is on.

       The <b>tracecmd_follow_event()</b> function will attach to a trace file descriptor <u>handle</u> and call the <u>callback</u>
       when the event described by <u>system</u> and <u>name</u> matches an event in the iteration of
       <b>tracecmd_iterate_events()</b> or <b>tracecmd_iterate_events_multi()</b>. Note, the <u>cpu</u> is the nth CPU for both
       <b>tracecmd_iterate_events()</b> and <b>tracecmd_iterate_events_multi()</b>. If the actual CPU of the <u>record</u> is needed,
       use <u>record</u>→cpu. For <b>tracecmd_iterate_events_multi()</b>, the <u>callback</u> is only called if the <u>handle</u> matches
       the current trace file descriptor within <u>handles</u>. The <u>callback_data</u> is passed as the last parameter to
       the <u>callback()</u> function. Note, this <u>callback()</u> function will be called before the <u>callback()</u> function of
       either <b>tracecmd_iterate_events()</b> or <b>tracecmd_iterate_events_multi()</b>.

       The <u>callback()</u> prototype for *tracecmd_follow_event()_ is:

       int <u>callback()</u>(struct tracecmd_input *<u>handle</u>, struct tep_event *<u>event,</u> <u>struct</u> <u>tep_record</u> <u>*_record</u>, int
       <u>cpu</u>, void *<u>data</u>);

       The <b>tracecmd_follow_missed_events()</b> function will attach to a trace file descriptor <u>handle</u> and call the
       <u>callback</u> when missed events are detected. The <u>event</u> will hold the type of event that the <u>record</u> is. The
       <u>record</u> will hold the information of the missed events. The <u>cpu</u> is the nth CPU for both
       <b>tracecmd_iterate_events()</b> and <b>tracecmd_iterate_events_multi()</b>. If the CPU that the missed events are for
       is needed, use <u>record</u>→cpu. If <u>record</u>→missed_events is a positive number, then it holds the number of
       missed events since the last event on its CPU, otherwise it will be negative, and that will mean that the
       number of missed events is unknown but missed events exist since the last event on the CPU. The <u>callback</u>
       and <u>callback_data</u> is the same format as <b>tracecmd_follow_event()</b> above. The missed events <u>callback</u> is
       called before any of the other <u>callbacks</u> and any filters that were added by <b>tracecmd_filter_add()</b> are
       ignored. If <u>callback</u> returns a non zero, it will stop the iterator before it calls any of the other
       iterator callbacks for the given record.

       The <b>tracecmd_filter_add()</b> function, adds a filter to <u>handle</u> that affects both <b>tracecmd_iterate_events()</b>
       and <b>tracecmd_iterate_events_multi()</b>. The <u>filter_str</u> is a character string defining a filter in a format
       that is defined by <b><a href="../man3/tep_filter_add_filter_str.3.html">tep_filter_add_filter_str</a>(3)</b>. If <u>neg</u> is true, then the events that match the filter
       will be skipped, otherwise the events that match will execute the <u>callback()</u> function in the iterators.

       The <b>tracecmd_iterate_reset()</b> sets the <u>handle</u> back to start at the beginning, so that the next call to
       <b>tracecmd_iterate_events()</b> starts back at the first event again, instead of continuing where it left off.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Both <b>tracecmd_iterate_events()</b>, <b>tracecmd_iterate_events_reverse()</b> and <b>tracecmd_iterate_events_multi()</b>
       return zero if they successfully iterated all events (handling the follow and filters appropriately). Or
       an error value, which can include returning a non-zero result from the <u>callback()</u> function.

       <b>tracecmd_iterate_reset()</b> returns 0 on success and -1 if an error occurred. Note, if -1 is returned, a
       partial reset may have also happened.

</pre><h4><b>EXAMPLE</b></h4><pre>
           #define _GNU_SOURCE
           #include &lt;<a href="file:/usr/include/sched.h">sched.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/getopt.h">getopt.h</a>&gt;
           #include &lt;trace-cmd.h&gt;

           struct private_data {
                   int             cpu;
                   const char      *file;
           };

           static int print_events(struct tracecmd_input *handle, struct tep_record *record, int cpu, void *data)
           {
                   static struct trace_seq seq;
                   struct tep_handle *tep = tracecmd_get_tep(handle);
                   struct private_data *pdata = tracecmd_get_private(handle);

                   /* For multi handles we need this */
                   if (pdata-&gt;cpu &gt;= 0 &amp;&amp; pdata-&gt;cpu != record-&gt;cpu)
                           return 0;

                   if (!seq.buffer)
                           trace_seq_init(&amp;seq);

                   trace_seq_reset(&amp;seq);
                   trace_seq_printf(&amp;seq, "%s: ", pdata-&gt;file);
                   tep_print_event(tep, &amp;seq, record, "%6.1000d [%03d] %s-%d %s: %s\n",
                                   TEP_PRINT_TIME, TEP_PRINT_CPU, TEP_PRINT_COMM, TEP_PRINT_PID,
                                   TEP_PRINT_NAME, TEP_PRINT_INFO);
                   trace_seq_terminate(&amp;seq);
                   trace_seq_do_printf(&amp;seq);
                   return 0;
           }

           static int print_event(struct tracecmd_input *handle, struct tep_event *event,
                                  struct tep_record *record, int cpu, void *data)
           {
                   return print_events(handle, record, cpu, data);
           }

           static int missed_events(struct tracecmd_input *handle, struct tep_event *event,
                                    struct tep_record *record, int cpu, void *data)
           {
                   if (record-&gt;missed_events &gt; 0)
                           printf("CPU [%03d] has %d missed events\n",
                                    record-&gt;cpu, record-&gt;missed_events);
                   else
                           printf("CPU [%03d] has missed events\n", record-&gt;cpu);
                   return 0;
           }

           static void usage(const char *argv0)
           {
                   printf("usage: [-c cpu][-f filter][-e event] %s trace.dat [trace.dat ...]\n",
                          argv0);
                   exit(-1);
           }

           int main(int argc, char **argv)
           {
                   struct tracecmd_input **handles = NULL;
                   const char *filter_str = NULL;
                   const char *argv0 = argv[0];
                   struct private_data *priv;
                   cpu_set_t *cpuset = NULL;
                   char *event = NULL;
                   size_t cpusize = 0;
                   int nr_handles = 0;
                   int cpu = -1;
                   int i;
                   int c;

                   while ((c = getopt(argc, argv, "c:f:e:")) &gt;= 0) {
                           switch (c) {
                           case 'c':
                                   /* filter all trace data to this one CPU. */
                                   cpu = atoi(optarg);
                                   break;
                           case 'f':
                                   filter_str = optarg;
                                   break;
                           case 'e':
                                   event = optarg;
                                   break;
                           default:
                                   usage(argv0);
                           }
                   }
                   argc -= optind;
                   argv += optind;

                   if (argc == 0)
                           usage(argv0);

                   for (i = 0; i &lt; argc; i++) {
                           handles = realloc(handles, sizeof(*handles) * (nr_handles + 1));
                           if (!handles)
                                   exit(-1);
                           handles[nr_handles] = tracecmd_open(argv[i], 0);
                           if (!handles[nr_handles]) {
                                   perror(argv[i]);
                                   exit(-1);
                           }
                           if (filter_str) {
                                   if (tracecmd_filter_add(handles[nr_handles], filter_str, false) == NULL) {
                                           perror("adding filter");
                                           exit(-1);
                                   }
                           }
                           priv = calloc(1, sizeof(*priv));
                           if (!priv)
                                   exit(-1);
                           priv-&gt;file = argv[i];
                           priv-&gt;cpu = cpu;
                           tracecmd_set_private(handles[nr_handles], priv);
                           if (event) {
                                   if (tracecmd_follow_event(handles[nr_handles], NULL, event, print_event, NULL) &lt; 0) {
                                           printf("Could not follow event %s for file %s\n", event, argv[i]);
                                           exit(-1);
                                   }
                           }
                           tracecmd_follow_missed_events(handles[nr_handles], missed_events, NULL);
                           nr_handles++;
                   }

                   /* Shortcut */
                   if (nr_handles == 1) {
                           if (cpu &gt;= 0) {
                                   cpuset = CPU_ALLOC(cpu + 1);
                                   if (!cpuset)
                                           exit(-1);
                                   cpusize = CPU_ALLOC_SIZE(cpu + 1);
                                   CPU_SET_S(cpu, cpusize, cpuset);
                           }
                           if (event)
                                   tracecmd_iterate_events(handles[0], cpuset, cpusize, NULL, NULL);
                           else
                                   tracecmd_iterate_events(handles[0], cpuset, cpusize, print_events, NULL);
                   } else {
                           if (event)
                                   tracecmd_iterate_events_multi(handles, nr_handles, NULL, NULL);
                           else
                                   tracecmd_iterate_events_multi(handles, nr_handles, print_events, NULL);
                   }

                   for (i = 0; i &lt; nr_handles; i++) {
                           priv = tracecmd_get_private(handles[i]);
                           free(priv);
                           tracecmd_close(handles[i]);
                   }
                   free(handles);
           }

</pre><h4><b>FILES</b></h4><pre>
           <b>trace-cmd.h</b>
                   Header file to include in order to have access to the library APIs.
           <b>-ltracecmd</b>
                   Linker switch to add when building a program that uses the library.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/libtracefs.3.html">libtracefs</a>(3)</b>, <b><a href="../man3/libtraceevent.3.html">libtraceevent</a>(3)</b>, <b><a href="../man1/trace-cmd.1.html">trace-cmd</a>(1)</b> <b><a href="../man5/trace-cmd.dat.5.html">trace-cmd.dat</a>(5)</b>

</pre><h4><b>AUTHOR</b></h4><pre>
           <b>Steven</b> <b>Rostedt</b> &lt;<b><a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a></b>[1]&gt;
           <b>Tzvetomir</b> <b>Stoyanov</b> &lt;<b><a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a></b>[2]&gt;

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<b><a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a></b>[3]&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       libtracecmd is Free Software licensed under the GNU LGPL 2.1

</pre><h4><b>RESOURCES</b></h4><pre>
       <b>https://git.kernel.org/pub/scm/utils/trace-cmd/trace-cmd.git/</b>

</pre><h4><b>COPYING</b></h4><pre>
       Copyright (C) 2020 VMware, Inc. Free use of this software is granted under the terms of the GNU Public
       License (GPL).

</pre><h4><b>NOTES</b></h4><pre>
        1. <a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a>
           <a href="mailto:rostedt@goodmis.org">mailto:rostedt@goodmis.org</a>

        2. <a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a>
           <a href="mailto:tz.stoyanov@gmail.com">mailto:tz.stoyanov@gmail.com</a>

        3. <a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a>
           <a href="mailto:linux-trace-devel@vger.kernel.org">mailto:linux-trace-devel@vger.kernel.org</a>

libtracefs                                         06/23/2025                                     <u><a href="../man3/LIBTRACECMD.3.html">LIBTRACECMD</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>