<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libdlm - dlm_get_fd, dlm_dispatch, dlm_pthread_init, dlm_ls_pthread_init, dlm_cleanup</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdlm-dev">libdlm-dev_4.3.0-3build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libdlm - dlm_get_fd, dlm_dispatch, dlm_pthread_init, dlm_ls_pthread_init, dlm_cleanup

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;libdlm.h&gt;
       int dlm_pthread_init();
       int dlm_ls_pthread_init(dlm_lshandle_t lockspace);
       int dlm_pthread_cleanup();
       int dlm_get_fd(void);
       int dlm_dispatch(int fd);

       link with -ldlm

</pre><h4><b>DESCRIPTION</b></h4><pre>
       libdlm provides the programmatic userspace interface to the Distributed Lock manager. It provides all the
       calls you need to manipulate locks &amp; lockspaces
       libdlm  can  be  used  in  pthread  or non-pthread applications. For pthread applications simply call the
       following function before doing any lock  operations.  If  you're  using  pthreads,  remember  to  define
       _REENTRANT at the top of the program or using -D_REENTRANT on the compile line.
       pthreads  is the normal way of using the DLM. This way you simply initialize the DLM's thread and all the
       AST routines will be delivered in that thread. You just call the dlm_lock() etc routines in the main line
       of your program.
       If you don't want to use pthreads or you want to handle the dlm callback ASTs yourself then you  can  get
       an  FD  handle  to the DLM device and call <b>dlm_dispatch()</b> on it whenever it becomes active. That was ASTs
       will be delivered in the context of the thread/process that called <b>dlm_dispatch().</b>

   <b>int</b> <b>dlm_pthread_init()</b>
       Creates a thread to receive all lock ASTs. The AST callback function for lock operations will  be  called
       in  the  context  of  this  thread.  If there is a potential for local resource access conflicts you must
       provide your own pthread-based locking in the AST routine.

   <b>int</b> <b>dlm_ls_pthread_init(dlm_lshandle_t</b> <b>lockspace)</b>
       As dlm_pthread_init but initializes a thread for the specified lockspace.

   <b>int</b> <b>dlm_pthread_cleanup()</b>
       Cleans up the default lockspace threads after use. Normally you don't need  to  call  this,  but  if  the
       locking code is in a dynamically loadable shared library this will probably be necessary.
       For  non-pthread  based  applications  the  DLM provides a file descriptor that the program can feed into
       poll/select. If activity is detected on that FD then a dispatch function should be called:

   <b>int</b> <b>dlm_get_fd()</b>
       Returns a file-descriptor for the DLM suitable for passing in to poll() or select().

   <b>int</b> <b>dlm_dispatch(int</b> <b>fd)</b>
       Reads from the DLM and calls any AST routines that may be needed. This routine runs in the context of the
       caller so no extra locking is needed to protect local resources.

</pre><h4><b>libdlm_lt</b></h4><pre>
       There also exists a "light" version of the libdlm library called libdlm_lt. This is  provided  for  those
       applications that do not want to use pthread functions. If you use this library it is important that your
       application is NOT compiled with -D_REENTRANT or linked with libpthread.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Create a lockspace and start a thread to deliver its callbacks:
       dlm_lshandle_t ls;

       ls = dlm_create_lockspace("myLS", 0660);
       dlm_ls_pthread_init(ls);

        ...

       status = dlm_ls_lock(ls,
                            ... );

        Using <a href="../man2/poll.2.html">poll</a>(2) to wait for and dispatch ASTs

       static int poll_for_ast(dlm_lshandle_t ls)
       {
           struct pollfd pfd;

           pfd.fd = dlm_ls_get_fd(ls);
           pfd.events = POLLIN;
           while (!ast_called)
           {
               if (poll(&amp;pfd, 1, 0) &lt; 0)
               {
                   perror("poll");
                   return -1;
               }
               dlm_dispatch(dlm_ls_get_fd(ls));
           }
           ast_called = 0;
           return 0;
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/libdlm.3.html">libdlm</a></b>(3),      <b><a href="../man3/dlm_lock.3.html">dlm_lock</a></b>(3),      <b><a href="../man3/dlm_unlock.3.html">dlm_unlock</a></b>(3),      <b><a href="../man3/dlm_open_lockspace.3.html">dlm_open_lockspace</a></b>(3),     <b><a href="../man3/dlm_create_lockspace.3.html">dlm_create_lockspace</a></b>(3),
       <b><a href="../man3/dlm_close_lockspace.3.html">dlm_close_lockspace</a></b>(3), <b><a href="../man3/dlm_release_lockspace.3.html">dlm_release_lockspace</a></b>(3)

libdlm functions                                  July 5, 2007                                         <u><a href="../man3/LIBDLM.3.html">LIBDLM</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>