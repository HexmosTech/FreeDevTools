<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rte_memory.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dpdk-doc">dpdk-doc_24.11.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rte_memory.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;stddef.h&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;rte_bitops.h&gt;
       #include &lt;rte_common.h&gt;
       #include &lt;rte_config.h&gt;
       #include &lt;rte_eal_memconfig.h&gt;
       #include &lt;rte_fbarray.h&gt;

   <b>Data</b> <b>Structures</b>
       struct <b>rte_memseg</b>
       struct <b>rte_memseg_list</b>

   <b>Macros</b>
       #define <b>SOCKET_ID_ANY</b>   -1
       #define <b>RTE_MEMSEG_FLAG_DO_NOT_FREE</b>   <b><a href="../man0/RTE_BIT32.0.html">RTE_BIT32</a></b>(0)
       #define <b>RTE_MEMSEG_FLAG_DIRTY</b>   <b><a href="../man1/RTE_BIT32.1.html">RTE_BIT32</a></b>(1)
       #define <b>RTE_MEM_EVENT_CALLBACK_NAME_LEN</b>   64
       #define <b>RTE_MEM_ALLOC_VALIDATOR_NAME_LEN</b>   64

   <b>Typedefs</b>
       <b>typedef</b> int(* <b>rte_memseg_walk_t</b>) (const struct <b>rte_memseg_list</b> *msl, const struct <b>rte_memseg</b> *ms, void
           *arg)
       <b>typedef</b> int(* <b>rte_memseg_contig_walk_t</b>) (const struct <b>rte_memseg_list</b> *msl, const struct <b>rte_memseg</b> *ms,
           size_t len, void *arg)
       <b>typedef</b> int(* <b>rte_memseg_list_walk_t</b>) (const struct <b>rte_memseg_list</b> *msl, void *arg)
       <b>typedef</b> void(* <b>rte_mem_event_callback_t</b>) (enum <b>rte_mem_event</b> event_type, const void *addr, size_t len,
           void *arg)
       <b>typedef</b> int(* <b>rte_mem_alloc_validator_t</b>) (int socket_id, size_t cur_limit, size_t new_len)

   <b>Enumerations</b>
       enum <b>rte_mem_event</b> { <b>RTE_MEM_EVENT_ALLOC</b> = 0, <b>RTE_MEM_EVENT_FREE</b> }

   <b>Functions</b>
       int <b>rte_mem_lock_page</b> (const void *virt)
       <b>phys_addr_t</b> <b>rte_mem_virt2phy</b> (const void *virt)
       <b>rte_iova_t</b> <b>rte_mem_virt2iova</b> (const void *virt)
       void * <b>rte_mem_iova2virt</b> (<b>rte_iova_t</b> iova)
       struct <b>rte_memseg</b> * <b>rte_mem_virt2memseg</b> (const void *virt, const struct <b>rte_memseg_list</b> *msl)
       struct <b>rte_memseg_list</b> * <b>rte_mem_virt2memseg_list</b> (const void *virt)
       int <b>rte_memseg_walk</b> (<b>rte_memseg_walk_t</b> func, void *arg)
       int <b>rte_memseg_contig_walk</b> (<b>rte_memseg_contig_walk_t</b> func, void *arg)
       int <b>rte_memseg_list_walk</b> (<b>rte_memseg_list_walk_t</b> func, void *arg)
           __rte_locks_excluded(<b>rte_mcfg_mem_get_lock</b>())
       int <b>rte_memseg_walk_thread_unsafe</b> (<b>rte_memseg_walk_t</b> func, void *arg)
       int <b>rte_memseg_contig_walk_thread_unsafe</b> (<b>rte_memseg_contig_walk_t</b> func, void *arg)
       int <b>rte_memseg_list_walk_thread_unsafe</b> (<b>rte_memseg_list_walk_t</b> func, void *arg)
       int <b>rte_memseg_get_fd</b> (const struct <b>rte_memseg</b> *ms)
       int <b>rte_memseg_get_fd_thread_unsafe</b> (const struct <b>rte_memseg</b> *ms)
       int <b>rte_memseg_get_fd_offset</b> (const struct <b>rte_memseg</b> *ms, size_t *offset)
       int <b>rte_memseg_get_fd_offset_thread_unsafe</b> (const struct <b>rte_memseg</b> *ms, size_t *offset)
       int <b>rte_extmem_register</b> (void *va_addr, size_t len, <b>rte_iova_t</b> iova_addrs[], unsigned int n_pages, size_t
           page_sz)
       int <b>rte_extmem_unregister</b> (void *va_addr, size_t len)
       int <b>rte_extmem_attach</b> (void *va_addr, size_t len)
       int <b>rte_extmem_detach</b> (void *va_addr, size_t len)
       void <b>rte_dump_physmem_layout</b> (FILE *f)
       uint64_t <b>rte_eal_get_physmem_size</b> (void)
       unsigned <b>rte_memory_get_nchannel</b> (void)
       unsigned <b>rte_memory_get_nrank</b> (void)
       int <b>rte_mem_check_dma_mask</b> (uint8_t maskbits)
       int <b>rte_mem_check_dma_mask_thread_unsafe</b> (uint8_t maskbits)
       void <b>rte_mem_set_dma_mask</b> (uint8_t maskbits)
       int <b>rte_eal_using_phys_addrs</b> (void)
       int <b>rte_mem_event_callback_register</b> (const char *name, <b>rte_mem_event_callback_t</b> clb, void *arg)
       int <b>rte_mem_event_callback_unregister</b> (const char *name, void *arg)
       int <b>rte_mem_alloc_validator_register</b> (const char *name, <b>rte_mem_alloc_validator_t</b> clb, int socket_id,
           size_t limit)
           Register validator callback for memory allocations.
       int <b>rte_mem_alloc_validator_unregister</b> (const char *name, int socket_id)
           Unregister validator callback for memory allocations.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Memory-related RTE API.

       Definition in file <b>rte_memory.h</b>.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>SOCKET_ID_ANY</b>   <b>-1</b>
       Any NUMA socket.

       Definition at line <b>39</b> of file <b>rte_memory.h</b>.

   <b>#define</b> <b>RTE_MEMSEG_FLAG_DO_NOT_FREE</b>   <b><a href="../man0/RTE_BIT32.0.html">RTE_BIT32</a>(0)</b>
       Prevent this segment from being freed back to the OS.

       Definition at line <b>42</b> of file <b>rte_memory.h</b>.

   <b>#define</b> <b>RTE_MEMSEG_FLAG_DIRTY</b>   <b><a href="../man1/RTE_BIT32.1.html">RTE_BIT32</a>(1)</b>
       This segment is not filled with zeros.

       Definition at line <b>44</b> of file <b>rte_memory.h</b>.

   <b>#define</b> <b>RTE_MEM_EVENT_CALLBACK_NAME_LEN</b>   <b>64</b>
       maximum length of callback name

       Definition at line <b>610</b> of file <b>rte_memory.h</b>.

   <b>#define</b> <b>RTE_MEM_ALLOC_VALIDATOR_NAME_LEN</b>   <b>64</b>
       maximum length of alloc validator name

       Definition at line <b>666</b> of file <b>rte_memory.h</b>.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>int(*</b> <b>rte_memseg_walk_t)</b> <b>(const</b> <b>struct</b> <b>rte_memseg_list</b> <b>*msl,</b> <b>const</b> <b>struct</b> <b>rte_memseg</b> <b>*ms,</b> <b>void</b> <b>*arg)</b>
       Memseg walk function prototype.

       Returning 0 will continue walk Returning 1 will stop the walk Returning -1 will stop the walk and report
       error

       Definition at line <b>167</b> of file <b>rte_memory.h</b>.

   <b>typedef</b> <b>int(*</b> <b>rte_memseg_contig_walk_t)</b> <b>(const</b> <b>struct</b> <b>rte_memseg_list</b> <b>*msl,</b> <b>const</b> <b>struct</b> <b>rte_memseg</b> <b>*ms,</b>
       <b>size_t</b> <b>len,</b> <b>void</b> <b>*arg)</b>
       Memseg contig walk function prototype. This will trigger a callback on every VA-contiguous area starting
       at memseg ms, so total valid VA space at each callback call will be [ms-&gt;addr, ms-&gt;addr + len).

       Returning 0 will continue walk Returning 1 will stop the walk Returning -1 will stop the walk and report
       error

       Definition at line <b>179</b> of file <b>rte_memory.h</b>.

   <b>typedef</b> <b>int(*</b> <b>rte_memseg_list_walk_t)</b> <b>(const</b> <b>struct</b> <b>rte_memseg_list</b> <b>*msl,</b> <b>void</b> <b>*arg)</b>
       Memseg list walk function prototype. This will trigger a callback on every allocated memseg list.

       Returning 0 will continue walk Returning 1 will stop the walk Returning -1 will stop the walk and report
       error

       Definition at line <b>190</b> of file <b>rte_memory.h</b>.

   <b>typedef</b> <b>void(*</b> <b>rte_mem_event_callback_t)</b> <b>(enum</b> <b>rte_mem_event</b> <b>event_type,</b> <b>const</b> <b>void</b> <b>*addr,</b> <b>size_t</b> <b>len,</b> <b>void</b>
       <b>*arg)</b>
       Function typedef used to register callbacks for memory events.

       Definition at line <b>615</b> of file <b>rte_memory.h</b>.

   <b>typedef</b> <b>int(*</b> <b>rte_mem_alloc_validator_t)</b> <b>(int</b> <b>socket_id,</b> <b>size_t</b> <b>cur_limit,</b> <b>size_t</b> <b>new_len)</b>
       Function typedef used to register memory allocation validation callbacks.

       Returning 0 will allow allocation attempt to continue. Returning -1 will prevent allocation from
       succeeding.

       Definition at line <b>673</b> of file <b>rte_memory.h</b>.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>rte_mem_event</b>
       Enum indicating which kind of memory event has happened. Used by callbacks to distinguish between memory
       allocations and deallocations.

       <b>Enumerator</b>

       <u>RTE_MEM_EVENT_ALLOC</u>
              Allocation event.

       <u>RTE_MEM_EVENT_FREE</u>
              Deallocation event.

       Definition at line <b>605</b> of file <b>rte_memory.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>int</b> <b>rte_mem_lock_page</b> <b>(const</b> <b>void</b> <b>*</b> <b>virt)</b>
       Lock page in physical memory and prevent from swapping.

       <b>Parameters</b>
           <u>virt</u> The virtual address.

       <b>Returns</b>
           0 on success, negative on error.

   <b>phys_addr_t</b> <b>rte_mem_virt2phy</b> <b>(const</b> <b>void</b> <b>*</b> <b>virt)</b>
       Get  physical  address  of any mapped virtual address in the current process. It is found by browsing the
       <a href="file:/proc/self/pagemap">/proc/self/pagemap</a> special file. The page must be locked.

       <b>Parameters</b>
           <u>virt</u> The virtual address.

       <b>Returns</b>
           The physical address or RTE_BAD_IOVA on error.

   <b>rte_iova_t</b> <b>rte_mem_virt2iova</b> <b>(const</b> <b>void</b> <b>*</b> <b>virt)</b>
       Get IO virtual address of any mapped virtual address in the current process.

       <b>Note</b>
           This function will not check internal page table. Instead, in IOVA as PA mode, it will fall  back  to
           getting  real physical address (which may not match the expected IOVA, such as what was specified for
           external memory).

       <b>Parameters</b>
           <u>virt</u> The virtual address.

       <b>Returns</b>
           The IO address or RTE_BAD_IOVA on error.

   <b>void</b> <b>*</b> <b>rte_mem_iova2virt</b> <b>(rte_iova_t</b> <b>iova)</b>
       Get virtual memory address corresponding to iova address.

       <b>Note</b>
           This function read-locks the memory hotplug subsystem, and thus cannot be used within  memory-related
           callback functions.

       <b>Parameters</b>
           <u>iova</u> The iova address.

       <b>Returns</b>
           Virtual  address  corresponding to iova address (or NULL if address does not exist within DPDK memory
           map).

   <b>struct</b> <b>rte_memseg</b> <b>*</b> <b>rte_mem_virt2memseg</b> <b>(const</b> <b>void</b> <b>*</b> <b>virt,</b> <b>const</b> <b>struct</b> <b>rte_memseg_list</b> <b>*</b> <b>msl)</b>
       Get memseg to which a particular virtual address belongs.

       <b>Parameters</b>
           <u>virt</u> The virtual address.
           <u>msl</u> The memseg list in which to look up based on virt address (can be NULL).

       <b>Returns</b>
           Memseg pointer on success, or NULL on error.

   <b>struct</b> <b>rte_memseg_list</b> <b>*</b> <b>rte_mem_virt2memseg_list</b> <b>(const</b> <b>void</b> <b>*</b> <b>virt)</b>
       Get memseg list corresponding to virtual memory address.

       <b>Parameters</b>
           <u>virt</u> The virtual address.

       <b>Returns</b>
           Memseg list to which this virtual address belongs to.

   <b>int</b> <b>rte_memseg_walk</b> <b>(rte_memseg_walk_t</b> <b>func,</b> <b>void</b> <b>*</b> <b>arg)</b>
       Walk list of all memsegs.

       <b>Note</b>
           This function read-locks the memory hotplug subsystem, and thus cannot be used within  memory-related
           callback functions.

           This  function  will  also walk through externally allocated segments. It is up to the user to decide
           whether to skip through these segments.

       <b>Parameters</b>
           <u>func</u> Iterator function
           <u>arg</u> Argument passed to iterator

       <b>Returns</b>
           0 if walked over the entire list 1 if stopped by the user -1 if user function reported error

   <b>int</b> <b>rte_memseg_contig_walk</b> <b>(rte_memseg_contig_walk_t</b> <b>func,</b> <b>void</b> <b>*</b> <b>arg)</b>
       Walk each VA-contiguous area.

       <b>Note</b>
           This function read-locks the memory hotplug subsystem, and thus cannot be used within  memory-related
           callback functions.

           This  function  will  also walk through externally allocated segments. It is up to the user to decide
           whether to skip through these segments.

       <b>Parameters</b>
           <u>func</u> Iterator function
           <u>arg</u> Argument passed to iterator

       <b>Returns</b>
           0 if walked over the entire list 1 if stopped by the user -1 if user function reported error

   <b>int</b> <b>rte_memseg_list_walk</b> <b>(rte_memseg_list_walk_t</b> <b>func,</b> <b>void</b> <b>*</b> <b>arg)</b>
       Walk each allocated memseg list.

       <b>Note</b>
           This function read-locks the memory hotplug subsystem, and thus cannot be used within  memory-related
           callback functions.

           This  function  will  also walk through externally allocated segments. It is up to the user to decide
           whether to skip through these segments.

       <b>Parameters</b>
           <u>func</u> Iterator function
           <u>arg</u> Argument passed to iterator

       <b>Returns</b>
           0 if walked over the entire list 1 if stopped by the user -1 if user function reported error

   <b>int</b> <b>rte_memseg_walk_thread_unsafe</b> <b>(rte_memseg_walk_t</b> <b>func,</b> <b>void</b> <b>*</b> <b>arg)</b>
       Walk list of all memsegs without performing any locking.

       <b>Note</b>
           This function does not perform any locking, and is only  safe  to  call  from  within  memory-related
           callback functions.

       <b>Parameters</b>
           <u>func</u> Iterator function
           <u>arg</u> Argument passed to iterator

       <b>Returns</b>
           0 if walked over the entire list 1 if stopped by the user -1 if user function reported error

   <b>int</b> <b>rte_memseg_contig_walk_thread_unsafe</b> <b>(rte_memseg_contig_walk_t</b> <b>func,</b> <b>void</b> <b>*</b> <b>arg)</b>
       Walk each VA-contiguous area without performing any locking.

       <b>Note</b>
           This  function  does  not  perform  any  locking, and is only safe to call from within memory-related
           callback functions.

       <b>Parameters</b>
           <u>func</u> Iterator function
           <u>arg</u> Argument passed to iterator

       <b>Returns</b>
           0 if walked over the entire list 1 if stopped by the user -1 if user function reported error

   <b>int</b> <b>rte_memseg_list_walk_thread_unsafe</b> <b>(rte_memseg_list_walk_t</b> <b>func,</b> <b>void</b> <b>*</b> <b>arg)</b>
       Walk each allocated memseg list without performing any locking.

       <b>Note</b>
           This function does not perform any locking, and is only  safe  to  call  from  within  memory-related
           callback functions.

       <b>Parameters</b>
           <u>func</u> Iterator function
           <u>arg</u> Argument passed to iterator

       <b>Returns</b>
           0 if walked over the entire list 1 if stopped by the user -1 if user function reported error

   <b>int</b> <b>rte_memseg_get_fd</b> <b>(const</b> <b>struct</b> <b>rte_memseg</b> <b>*</b> <b>ms)</b>
       Return file descriptor associated with a particular memseg (if available).

       <b>Note</b>
           This  function read-locks the memory hotplug subsystem, and thus cannot be used within memory-related
           callback functions.

           This returns an internal file descriptor. Performing  any  operations  on  this  file  descriptor  is
           inherently dangerous, so it should be treated as read-only for all intents and purposes.

       <b>Parameters</b>
           <u>ms</u> A pointer to memseg for which to get file descriptor.

       <b>Returns</b>
           Valid  file  descriptor  in case of success. -1 in case of error, with rte_errno set to the following
           values:

           • EINVAL - ms pointer was NULL or did not point to a valid memseg

           • ENODEV - ms fd is not available

           • ENOENT - ms is an unused segment

           • ENOTSUP - segment fd's are not supported

   <b>int</b> <b>rte_memseg_get_fd_thread_unsafe</b> <b>(const</b> <b>struct</b> <b>rte_memseg</b> <b>*</b> <b>ms)</b>
       Return file descriptor associated with a particular memseg (if available).

       <b>Note</b>
           This function does not perform any locking, and is only  safe  to  call  from  within  memory-related
           callback functions.

           This  returns  an  internal  file  descriptor.  Performing  any operations on this file descriptor is
           inherently dangerous, so it should be treated as read-only for all intents and purposes.

       <b>Parameters</b>
           <u>ms</u> A pointer to memseg for which to get file descriptor.

       <b>Returns</b>
           Valid file descriptor in case of success. -1 in case of error, with rte_errno set  to  the  following
           values:

           • EINVAL - ms pointer was NULL or did not point to a valid memseg

           • ENODEV - ms fd is not available

           • ENOENT - ms is an unused segment

           • ENOTSUP - segment fd's are not supported

   <b>int</b> <b>rte_memseg_get_fd_offset</b> <b>(const</b> <b>struct</b> <b>rte_memseg</b> <b>*</b> <b>ms,</b> <b>size_t</b> <b>*</b> <b>offset)</b>
       Get offset into segment file descriptor associated with a particular memseg (if available).

       <b>Note</b>
           This  function read-locks the memory hotplug subsystem, and thus cannot be used within memory-related
           callback functions.

       <b>Parameters</b>
           <u>ms</u> A pointer to memseg for which to get file descriptor.
           <u>offset</u> A pointer to offset value where the result will be stored.

       <b>Returns</b>
           Valid file descriptor in case of success. -1 in case of error, with rte_errno set  to  the  following
           values:

           • EINVAL - ms pointer was NULL or did not point to a valid memseg

           • EINVAL - offset pointer was NULL

           • ENODEV - ms fd is not available

           • ENOENT - ms is an unused segment

           • ENOTSUP - segment fd's are not supported

   <b>int</b> <b>rte_memseg_get_fd_offset_thread_unsafe</b> <b>(const</b> <b>struct</b> <b>rte_memseg</b> <b>*</b> <b>ms,</b> <b>size_t</b> <b>*</b> <b>offset)</b>
       Get offset into segment file descriptor associated with a particular memseg (if available).

       <b>Note</b>
           This  function  does  not  perform  any  locking, and is only safe to call from within memory-related
           callback functions.

       <b>Parameters</b>
           <u>ms</u> A pointer to memseg for which to get file descriptor.
           <u>offset</u> A pointer to offset value where the result will be stored.

       <b>Returns</b>
           Valid file descriptor in case of success. -1 in case of error, with rte_errno set  to  the  following
           values:

           • EINVAL - ms pointer was NULL or did not point to a valid memseg

           • EINVAL - offset pointer was NULL

           • ENODEV - ms fd is not available

           • ENOENT - ms is an unused segment

           • ENOTSUP - segment fd's are not supported

   <b>int</b>  <b>rte_extmem_register</b>  <b>(void</b>  <b>*</b> <b>va_addr,</b> <b>size_t</b> <b>len,</b> <b>rte_iova_t</b> <b>iova_addrs[],</b> <b>unsigned</b> <b>int</b> <b>n_pages,</b> <b>size_t</b>
       <b>page_sz)</b>
       Register external memory chunk with DPDK.

       <b>Note</b>
           Using this API is mutually exclusive with rte_malloc family of API's.

           This API will not perform any DMA mapping. It is expected that user will do that themselves.

           Before accessing this memory in other processes, it needs to be attached in each of  those  processes
           by calling rte_extmem_attach in each other process.

       <b>Parameters</b>
           <u>va_addr</u> Start of virtual area to register. Must be aligned by page_sz.
           <u>len</u> Length of virtual area to register. Must be aligned by page_sz.
           <u>iova_addrs</u>  Array of page IOVA addresses corresponding to each page in this memory area. Can be NULL,
           in which case page IOVA addresses will be set to RTE_BAD_IOVA.
           <u>n_pages</u> Number of elements in the iova_addrs array. Ignored if iova_addrs is NULL.
           <u>page_sz</u> Page size of the underlying memory

       <b>Returns</b>

           • 0 on success

           • -1 in case of error, with rte_errno set to one of the following: EINVAL - one of the parameters was
             invalid EEXIST - memory chunk is already registered ENOSPC - no more space in  internal  config  to
             store a new memory chunk

   <b>int</b> <b>rte_extmem_unregister</b> <b>(void</b> <b>*</b> <b>va_addr,</b> <b>size_t</b> <b>len)</b>
       Unregister external memory chunk with DPDK.

       <b>Note</b>
           Using this API is mutually exclusive with rte_malloc family of API's.

           This API will not perform any DMA unmapping. It is expected that user will do that themselves.

           Before  calling  this  function,  all  other processes must call rte_extmem_detach to detach from the
           memory area.

       <b>Parameters</b>
           <u>va_addr</u> Start of virtual area to unregister
           <u>len</u> Length of virtual area to unregister

       <b>Returns</b>

           • 0 on success

           • -1 in case of error, with rte_errno set to one of the following: EINVAL - one of the parameters was
             invalid ENOENT - memory chunk was not found

   <b>int</b> <b>rte_extmem_attach</b> <b>(void</b> <b>*</b> <b>va_addr,</b> <b>size_t</b> <b>len)</b>
       Attach to external memory chunk registered in another process.

       <b>Note</b>
           Using this API is mutually exclusive with rte_malloc family of API's.

           This API will not perform any DMA mapping. It is expected that user will do that themselves.

       <b>Parameters</b>
           <u>va_addr</u> Start of virtual area to register
           <u>len</u> Length of virtual area to register

       <b>Returns</b>

           • 0 on success

           • -1 in case of error, with rte_errno set to one of the following: EINVAL - one of the parameters was
             invalid ENOENT - memory chunk was not found

   <b>int</b> <b>rte_extmem_detach</b> <b>(void</b> <b>*</b> <b>va_addr,</b> <b>size_t</b> <b>len)</b>
       Detach from external memory chunk registered in another process.

       <b>Note</b>
           Using this API is mutually exclusive with rte_malloc family of API's.

           This API will not perform any DMA unmapping. It is expected that user will do that themselves.

       <b>Parameters</b>
           <u>va_addr</u> Start of virtual area to unregister
           <u>len</u> Length of virtual area to unregister

       <b>Returns</b>

           • 0 on success

           • -1 in case of error, with rte_errno set to one of the following: EINVAL - one of the parameters was
             invalid ENOENT - memory chunk was not found

   <b>void</b> <b>rte_dump_physmem_layout</b> <b>(FILE</b> <b>*</b> <b>f)</b>
       Dump the physical memory layout to a file.

       <b>Note</b>
           This function read-locks the memory hotplug subsystem, and thus cannot be used within  memory-related
           callback functions.

       <b>Parameters</b>
           <u>f</u> A pointer to a file for output

   <b>uint64_t</b> <b>rte_eal_get_physmem_size</b> <b>(void)</b>
       Get the total amount of available physical memory.

       <b>Note</b>
           This  function read-locks the memory hotplug subsystem, and thus cannot be used within memory-related
           callback functions.

       <b>Returns</b>
           The total amount of available physical memory in bytes.

   <b>unsigned</b> <b>rte_memory_get_nchannel</b> <b>(void)</b>
       Get the number of memory channels.

       <b>Returns</b>
           The number of memory channels on the system. The value is 0  if  unknown  or  not  the  same  on  all
           devices.

   <b>unsigned</b> <b>rte_memory_get_nrank</b> <b>(void)</b>
       Get the number of memory ranks.

       <b>Returns</b>
           The number of memory ranks on the system. The value is 0 if unknown or not the same on all devices.

   <b>int</b> <b>rte_mem_check_dma_mask</b> <b>(uint8_t</b> <b>maskbits)</b>
       Check if all currently allocated memory segments are compliant with supplied DMA address width.

       <b>Parameters</b>
           <u>maskbits</u> Address width to check against.

   <b>int</b> <b>rte_mem_check_dma_mask_thread_unsafe</b> <b>(uint8_t</b> <b>maskbits)</b>
       Check  if  all  currently  allocated  memory segments are compliant with supplied DMA address width. This
       function will use rte_memseg_walk_thread_unsafe instead of rte_memseg_walk  implying  memory_hotplug_lock
       will not be acquired avoiding deadlock during memory initialization.

       This   function   is   just   for  EAL  core  memory  internal  use.  Drivers  should  use  the  previous
       rte_mem_check_dma_mask.

       <b>Parameters</b>
           <u>maskbits</u> Address width to check against.

   <b>void</b> <b>rte_mem_set_dma_mask</b> <b>(uint8_t</b> <b>maskbits)</b>
       Set dma mask to use once memory initialization is done.  Previous  functions  rte_mem_check_dma_mask  and
       rte_mem_check_dma_mask_thread_unsafe can not be used safely until memory has been initialized.

   <b>int</b> <b>rte_eal_using_phys_addrs</b> <b>(void)</b>
       Drivers  based  on uio will not load unless physical addresses are obtainable. It is only possible to get
       physical addresses when running as a privileged user.

       <b>Returns</b>
           1 if the system is able to obtain physical addresses. 0 if using DMA addresses through an IOMMU.

   <b>int</b> <b>rte_mem_event_callback_register</b> <b>(const</b> <b>char</b> <b>*</b> <b>name,</b> <b>rte_mem_event_callback_t</b> <b>clb,</b> <b>void</b> <b>*</b> <b>arg)</b>
       Function used to register callbacks for memory events.

       <b>Note</b>
           callbacks will happen while memory hotplug subsystem is write-locked, therefore some functions  (e.g.
           <b>rte_memseg_walk())</b> <b>will</b> <b>cause</b> <b>a</b> <b>deadlock</b> <b>when</b> <b>called</b> <b>from</b> <b>within</b> <b>such</b> <b>callbacks.</b>

           mem  event callbacks not being supported is an expected error condition, so user code needs to handle
           this situation. In these cases, return value will be -1, and rte_errno will be set to ENOTSUP.

       <b>Parameters</b>
           <u>name</u> Name associated with specified callback to be added to the list.
           <u>clb</u> Callback function pointer.
           <u>arg</u> Argument to pass to the callback.

       <b>Returns</b>
           0 on successful callback  register  -1  on  unsuccessful  callback  register,  with  rte_errno  value
           indicating reason for failure.

   <b>int</b> <b>rte_mem_event_callback_unregister</b> <b>(const</b> <b>char</b> <b>*</b> <b>name,</b> <b>void</b> <b>*</b> <b>arg)</b>
       Function used to unregister callbacks for memory events.

       <b>Parameters</b>
           <u>name</u> Name associated with specified callback to be removed from the list.
           <u>arg</u> Argument to look for among callbacks with specified callback name.

       <b>Returns</b>
           0  on  successful  callback  unregister  -1 on unsuccessful callback unregister, with rte_errno value
           indicating reason for failure.

   <b>int</b> <b>rte_mem_alloc_validator_register</b> <b>(const</b> <b>char</b> <b>*</b> <b>name,</b> <b>rte_mem_alloc_validator_t</b> <b>clb,</b> <b>int</b> <b>socket_id,</b> <b>size_t</b>
       <b>limit)</b>
       Register validator callback for memory allocations. Callbacks registered by this function will be  called
       right  before  memory  allocator  is  about  to  trigger allocation of more pages from the system if said
       allocation will bring total memory usage above specified limit on specified socket. User will be able  to
       cancel pending allocation if callback returns -1.

       <b>Note</b>
           callbacks  will happen while memory hotplug subsystem is write-locked, therefore some functions (e.g.
           <b>rte_memseg_walk())</b> <b>will</b> <b>cause</b> <b>a</b> <b>deadlock</b> <b>when</b> <b>called</b> <b>from</b> <b>within</b> <b>such</b> <b>callbacks.</b>

           validator callbacks not being supported is an expected error condition, so user code needs to  handle
           this situation. In these cases, return value will be -1, and rte_errno will be set to ENOTSUP.

       <b>Parameters</b>
           <u>name</u> Name associated with specified callback to be added to the list.
           <u>clb</u> Callback function pointer.
           <u>socket_id</u> Socket ID on which to watch for allocations.
           <u>limit</u> Limit above which to trigger callbacks.

       <b>Returns</b>
           0  on  successful  callback  register  -1  on  unsuccessful  callback  register, with rte_errno value
           indicating reason for failure.

   <b>int</b> <b>rte_mem_alloc_validator_unregister</b> <b>(const</b> <b>char</b> <b>*</b> <b>name,</b> <b>int</b> <b>socket_id)</b>
       Unregister validator callback for memory allocations.

       <b>Parameters</b>
           <u>name</u> Name associated with specified callback to be removed from the list.
           <u>socket_id</u> Socket ID on which to watch for allocations.

       <b>Returns</b>
           0 on successful callback unregister -1 on unsuccessful  callback  unregister,  with  rte_errno  value
           indicating reason for failure.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for DPDK from the source code.

DPDK                                             Version 24.11.2                                 <u><a href="../man3/rte_memory.h.3.html">rte_memory.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>