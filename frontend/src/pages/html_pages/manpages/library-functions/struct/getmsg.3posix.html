<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       getmsg, getpmsg — receive next message from a STREAMS file (<b>STREAMS</b>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;stropts.h&gt;

       int getmsg(int <u>fildes</u>, struct strbuf *restrict <u>ctlptr</u>,
           struct strbuf *restrict <u>dataptr</u>, int *restrict <u>flagsp</u>);
       int getpmsg(int <u>fildes</u>, struct strbuf *restrict <u>ctlptr</u>,
           struct strbuf *restrict <u>dataptr</u>, int *restrict <u>bandp</u>,
           int *restrict <u>flagsp</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>getmsg</u>()  function  shall  retrieve the contents of a message located at the head of the STREAM head
       read queue associated with a STREAMS file and place the contents into one or more  buffers.  The  message
       contains  either a data part, a control part, or both. The data and control parts of the message shall be
       placed into separate buffers, as described  below.  The  semantics  of  each  part  are  defined  by  the
       originator of the message.

       The  <u>getpmsg</u>()  function  shall be equivalent to <u>getmsg</u>(), except that it provides finer control over the
       priority of the messages received. Except where noted, all  requirements  on  <u>getmsg</u>()  also  pertain  to
       <u>getpmsg</u>().

       The <u>fildes</u> argument specifies a file descriptor referencing a STREAMS-based file.

       The  <u>ctlptr</u>  and  <u>dataptr</u> arguments each point to a <b>strbuf</b> structure, in which the <u>buf</u> member points to a
       buffer in which the data or control information is to be placed, and  the  <u>maxlen</u>  member  indicates  the
       maximum number of bytes this buffer can hold. On return, the <u>len</u> member shall contain the number of bytes
       of  data  or  control information actually received. The <u>len</u> member shall be set to 0 if there is a zero-
       length control or data part and <u>len</u> shall be set to -1 if no data or control information  is  present  in
       the message.

       When <u>getmsg</u>() is called, <u>flagsp</u> should point to an integer that indicates the type of message the process
       is able to receive. This is described further below.

       The <u>ctlptr</u> argument is used to hold the control part of the message, and <u>dataptr</u> is used to hold the data
       part of the message. If <u>ctlptr</u> (or <u>dataptr</u>) is a null pointer or the <u>maxlen</u> member is -1, the control (or
       data)  part of the message shall not be processed and shall be left on the STREAM head read queue, and if
       the <u>ctlptr</u> (or <u>dataptr</u>) is not a null pointer, <u>len</u> shall be set to -1. If the <u>maxlen</u> member is set  to  0
       and  there  is a zero-length control (or data) part, that zero-length part shall be removed from the read
       queue and <u>len</u> shall be set to 0. If the <u>maxlen</u> member is set to 0 and there are  more  than  0  bytes  of
       control  (or  data) information, that information shall be left on the read queue and <u>len</u> shall be set to
       0. If the <u>maxlen</u> member in <u>ctlptr</u> (or <u>dataptr</u>) is less than the control (or data) part  of  the  message,
       <u>maxlen</u>  bytes  shall be retrieved. In this case, the remainder of the message shall be left on the STREAM
       head read queue and a non-zero return value shall be provided.

       By default, <u>getmsg</u>() shall process the first available message on the STREAM head read queue. However,  a
       process may choose to retrieve only high-priority messages by setting the integer pointed to by <u>flagsp</u> to
       RS_HIPRI.  In  this  case, <u>getmsg</u>() shall only process the next message if it is a high-priority message.
       When the integer pointed to by <u>flagsp</u> is 0, any available message shall be retrieved. In  this  case,  on
       return,  the  integer  pointed  to  by  <u>flagsp</u>  shall  be  set to RS_HIPRI if a high-priority message was
       retrieved, or 0 otherwise.

       For <u>getpmsg</u>(), the flags are different. The <u>flagsp</u> argument  points  to  a  bitmask  with  the  following
       mutually-exclusive  flags  defined:  MSG_HIPRI,  MSG_BAND,  and  MSG_ANY.  Like <u>getmsg</u>(), <u>getpmsg</u>() shall
       process the first available message on the STREAM head read queue. A process may choose to retrieve  only
       high-priority  messages  by setting the integer pointed to by <u>flagsp</u> to MSG_HIPRI and the integer pointed
       to by <u>bandp</u> to 0. In this case, <u>getpmsg</u>() shall only process the next message if it  is  a  high-priority
       message.  In a similar manner, a process may choose to retrieve a message from a particular priority band
       by  setting  the  integer  pointed  to  by  <u>flagsp</u> to MSG_BAND and the integer pointed to by <u>bandp</u> to the
       priority band of interest. In this case, <u>getpmsg</u>() shall only process the next message  if  it  is  in  a
       priority  band  equal  to,  or greater than, the integer pointed to by <u>bandp</u>, or if it is a high-priority
       message. If a process wants to get the first message off the queue, the  integer  pointed  to  by  <u>flagsp</u>
       should  be  set  to  MSG_ANY  and  the  integer pointed to by <u>bandp</u> should be set to 0. On return, if the
       message retrieved was a high-priority message, the integer pointed to by <u>flagsp</u> shall be set to MSG_HIPRI
       and the integer pointed to by <u>bandp</u> shall be set to 0. Otherwise, the integer pointed to by <u>flagsp</u>  shall
       be set to MSG_BAND and the integer pointed to by <u>bandp</u> shall be set to the priority band of the message.

       If  O_NONBLOCK  is  not  set, <u>getmsg</u>() and <u>getpmsg</u>() shall block until a message of the type specified by
       <u>flagsp</u> is available at the front of the STREAM head read queue. If O_NONBLOCK is set and a message of the
       specified type is not present at the front of the read queue, <u>getmsg</u>() and <u>getpmsg</u>() shall fail  and  set
       <u>errno</u> to <b>[EAGAIN]</b>.

       If a hangup occurs on the STREAM from which messages are retrieved, <u>getmsg</u>() and <u>getpmsg</u>() shall continue
       to  operate  normally,  as  described  above, until the STREAM head read queue is empty. Thereafter, they
       shall return 0 in the <u>len</u> members of <u>ctlptr</u> and <u>dataptr</u>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon successful completion, <u>getmsg</u>() and <u>getpmsg</u>() shall return  a  non-negative  value.  A  value  of  0
       indicates  that  a  full  message  was  read  successfully. A return value of MORECTL indicates that more
       control information is waiting for retrieval. A return value of MOREDATA  indicates  that  more  data  is
       waiting  for  retrieval.  A return value of the bitwise-logical OR of MORECTL and MOREDATA indicates that
       both types of information remain. Subsequent <u>getmsg</u>() and <u>getpmsg</u>() calls shall retrieve the remainder of
       the message. However, if a message of higher priority has come in on the STREAM head read queue, the next
       call to <u>getmsg</u>() or <u>getpmsg</u>() shall retrieve that higher-priority message before retrieving the remainder
       of the previous message.

       If the high priority control part of the message is consumed, the message shall be  placed  back  on  the
       queue as a normal message of band 0. Subsequent <u>getmsg</u>() and <u>getpmsg</u>() calls shall retrieve the remainder
       of  the  message.  If,  however,  a  priority  message  arrives or already exists on the STREAM head, the
       subsequent call to <u>getmsg</u>() or <u>getpmsg</u>() shall retrieve the higher-priority message before retrieving the
       remainder of the message that was put back.

       Upon failure, <u>getmsg</u>() and <u>getpmsg</u>() shall return -1 and set <u>errno</u> to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>getmsg</u>() and <u>getpmsg</u>() functions shall fail if:

       <b>EAGAIN</b> The O_NONBLOCK flag is set and no messages are available.

       <b>EBADF</b>  The <u>fildes</u> argument is not a valid file descriptor open for reading.

       <b>EBADMSG</b>
              The queued message to be read is not valid for <u>getmsg</u>() or <u>getpmsg</u>() or a pending file  descriptor
              is at the STREAM head.

       <b>EINTR</b>  A signal was caught during <u>getmsg</u>() or <u>getpmsg</u>().

       <b>EINVAL</b> An  illegal  value  was  specified by <u>flagsp</u>, or the STREAM or multiplexer referenced by <u>fildes</u> is
              linked (directly or indirectly) downstream from a multiplexer.

       <b>ENOSTR</b> A STREAM is not associated with <u>fildes</u>.

       In addition, <u>getmsg</u>() and <u>getpmsg</u>() shall fail if the STREAM head had  processed  an  asynchronous  error
       before  the  call.  In this case, the value of <u>errno</u> does not reflect the result of <u>getmsg</u>() or <u>getpmsg</u>()
       but reflects the prior error.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Getting</b> <b>Any</b> <b>Message</b>
       In the following example, the value of <u>fd</u> is assumed to refer to  an  open  STREAMS  file.  The  call  to
       <u>getmsg</u>()  retrieves any available message on the associated STREAM-head read queue, returning control and
       data information to the buffers pointed to by <u>ctrlbuf</u> and <u>databuf</u>, respectively.

           #include &lt;stropts.h&gt;
           ...
           int fd;
           char ctrlbuf[128];
           char databuf[512];
           struct strbuf ctrl;
           struct strbuf data;
           int flags = 0;
           int ret;

           ctrl.buf = ctrlbuf;
           ctrl.maxlen = sizeof(ctrlbuf);

           data.buf = databuf;
           data.maxlen = sizeof(databuf);

           ret = getmsg (fd, &amp;ctrl, &amp;data, &amp;flags);

   <b>Getting</b> <b>the</b> <b>First</b> <b>Message</b> <b>off</b> <b>the</b> <b>Queue</b>
       In the following example, the call to <u>getpmsg</u>() retrieves the first available message on  the  associated
       STREAM-head read queue.

           #include &lt;stropts.h&gt;
           ...

           int fd;
           char ctrlbuf[128];
           char databuf[512];
           struct strbuf ctrl;
           struct strbuf data;
           int band = 0;
           int flags = MSG_ANY;
           int ret;

           ctrl.buf = ctrlbuf;
           ctrl.maxlen = sizeof(ctrlbuf);

           data.buf = databuf;
           data.maxlen = sizeof(databuf);

           ret = getpmsg (fd, &amp;ctrl, &amp;data, &amp;band, &amp;flags);

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       None.

</pre><h4><b>RATIONALE</b></h4><pre>
       None.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       The <u>getmsg</u>() and <u>getpmsg</u>() functions may be removed in a future version.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u> <u>2.6</u>, <u>STREAMS</u>, <u>poll</u>(), <u>putmsg</u>(), <u>read</u>(), <u>write</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;stropts.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                        <u><a href="../man3POSIX/GETMSG.3POSIX.html">GETMSG</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>