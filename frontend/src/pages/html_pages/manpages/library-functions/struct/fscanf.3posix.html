<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       fscanf, scanf, sscanf — convert formatted input

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

       int fscanf(FILE *restrict <u>stream</u>, const char *restrict <u>format</u>, ...);
       int scanf(const char *restrict <u>format</u>, ...);
       int sscanf(const char *restrict <u>s</u>, const char *restrict <u>format</u>, ...);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  functionality  described  on  this  reference  page is aligned with the ISO C standard. Any conflict
       between the requirements described  here  and  the  ISO C  standard  is  unintentional.  This  volume  of
       POSIX.1‐2017 defers to the ISO C standard.

       The  <u>fscanf</u>()  function shall read from the named input <u>stream</u>.  The <u>scanf</u>() function shall read from the
       standard input stream <u>stdin</u>.  The <u>sscanf</u>() function shall read from the string <u>s</u>.   Each  function  reads
       bytes,  interprets  them according to a format, and stores the results in its arguments. Each expects, as
       arguments, a control string <u>format</u> described below, and a set of <u>pointer</u> arguments indicating  where  the
       converted  input  should  be  stored. The result is undefined if there are insufficient arguments for the
       format. If the format is exhausted while arguments remain, the excess arguments shall  be  evaluated  but
       otherwise ignored.

       Conversions  can be applied to the <u>n</u>th argument after the <u>format</u> in the argument list, rather than to the
       next unused argument. In this case, the conversion specifier character <b>%</b> (see below) is replaced  by  the
       sequence "%<u>n</u>$", where <u>n</u> is a decimal integer in the range [1,{NL_ARGMAX}].  This feature provides for the
       definition  of  format  strings  that  select arguments in an order appropriate to specific languages. In
       format strings containing the "%<u>n</u>$" form of conversion specifications, it is unspecified whether numbered
       arguments in the argument list can be referenced from the format string more than once.

       The <u>format</u> can contain either form of a conversion specification—that is, <b>%</b> or "%<u>n</u>$"—but  the  two  forms
       cannot  be  mixed within a single <u>format</u> string. The only exception to this is that <b>%%</b> or <b>%*</b> can be mixed
       with the "%<u>n</u>$" form. When numbered argument specifications are used, specifying the <u>N</u>th argument requires
       that all the leading arguments, from the first to the (<u>N</u>-1)th, are pointers.

       The <u>fscanf</u>() function in all its forms shall allow detection of a language-dependent radix  character  in
       the  input  string.  The  radix character is defined in the current locale (category <u>LC_NUMERIC</u>).  In the
       POSIX locale, or in a locale where the radix character is not defined, the radix character shall  default
       to a &lt;period&gt; (<b>'.'</b>).

       The  format  is  a character string, beginning and ending in its initial shift state, if any, composed of
       zero or more directives. Each directive is composed of one of the  following:  one  or  more  white-space
       characters  (&lt;space&gt;,  &lt;tab&gt;,  &lt;newline&gt;, &lt;vertical-tab&gt;, or &lt;form-feed&gt;); an ordinary character (neither
       <b>'%'</b> nor a white-space character);  or  a  conversion  specification.  Each  conversion  specification  is
       introduced  by  the  character  <b>'%'</b>  or the character sequence "%<u>n</u>$", after which the following appear in
       sequence:

        *  An optional assignment-suppressing character <b>'*'</b>.

        *  An optional non-zero decimal integer that specifies the maximum field width.

        *  An optional assignment-allocation character <b>'m'</b>.

        *  An option length modifier that specifies the size of the receiving object.

        *  A <u>conversion</u> <u>specifier</u> character that specifies the type of  conversion  to  be  applied.  The  valid
           conversion specifiers are described below.

       The  <u>fscanf</u>()  functions  shall  execute  each  directive of the format in turn. If a directive fails, as
       detailed below, the function shall  return.  Failures  are  described  as  input  failures  (due  to  the
       unavailability of input bytes) or matching failures (due to inappropriate input).

       A  directive  composed  of one or more white-space characters shall be executed by reading input until no
       more valid input can be read, or up to the first byte which is not a white-space character, which remains
       unread.

       A directive that is an ordinary character shall be executed as follows: the next byte shall be read  from
       the  input and compared with the byte that comprises the directive; if the comparison shows that they are
       not equivalent, the directive shall fail, and the differing and subsequent  bytes  shall  remain  unread.
       Similarly,  if  end-of-file, an encoding error, or a read error prevents a character from being read, the
       directive shall fail.

       A directive that is a conversion specification defines a set of matching input  sequences,  as  described
       below for each conversion character. A conversion specification shall be executed in the following steps.

       Input  white-space  characters  (as  specified  by  <u>isspace</u>())  shall  be  skipped, unless the conversion
       specification includes a <b>[</b>, <b>c</b>, <b>C</b>, or <b>n</b> conversion specifier.

       An item shall be read from the input, unless  the  conversion  specification  includes  an  <b>n</b>  conversion
       specifier.  An  input  item  shall be defined as the longest sequence of input bytes (up to any specified
       maximum field width, which may be measured in characters or bytes dependent on the conversion  specifier)
       which  is  an  initial  subsequence  of a matching sequence. The first byte, if any, after the input item
       shall remain unread. If the length of the input item is 0, the execution of the conversion  specification
       shall  fail; this condition is a matching failure, unless end-of-file, an encoding error, or a read error
       prevented input from the stream, in which case it is an input failure.

       Except in the case of a <b>%</b> conversion specifier, the input item (or,  in  the  case  of  a  <b>%n</b>  conversion
       specification,  the  count  of  input  bytes)  shall be converted to a type appropriate to the conversion
       character. If the input item is not a matching sequence, the execution of  the  conversion  specification
       fails;  this  condition  is a matching failure. Unless assignment suppression was indicated by a <b>'*'</b>, the
       result of the conversion shall be placed in the object pointed to by the  first  argument  following  the
       <u>format</u>  argument  that  has  not  already received a conversion result if the conversion specification is
       introduced by <b>%</b>, or in the <u>n</u>th argument if introduced by the character sequence "%<u>n</u>$".   If  this  object
       does  not have an appropriate type, or if the result of the conversion cannot be represented in the space
       provided, the behavior is undefined.

       The <b>%c</b>, <b>%s</b>, and <b>%[</b> conversion specifiers shall accept an optional  assignment-allocation  character  <b>'m'</b>,
       which  shall  cause  a memory buffer to be allocated to hold the string converted including a terminating
       null character. In such a case, the argument corresponding  to  the  conversion  specifier  should  be  a
       reference  to  a  pointer  variable that will receive a pointer to the allocated buffer. The system shall
       allocate a buffer as if <u>malloc</u>() had been called. The application shall be responsible  for  freeing  the
       memory after usage. If there is insufficient memory to allocate a buffer, the function shall set <u>errno</u> to
       <b>[ENOMEM]</b>  and  a  conversion  error  shall  result.  If the function returns EOF, any memory successfully
       allocated for parameters using assignment-allocation character <b>'m'</b> by this call shall be freed before the
       function returns.

       The length modifiers and their meanings are:

       hh      Specifies that a following <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, <b>X</b>, or <b>n</b> conversion specifier  applies  to  an  argument
               with type pointer to <b>signed</b> <b>char</b> or <b>unsigned</b> <b>char</b>.

       h       Specifies  that  a  following  <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, <b>X</b>, or <b>n</b> conversion specifier applies to an argument
               with type pointer to <b>short</b> or <b>unsigned</b> <b>short</b>.

       l (ell) Specifies that a following <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, <b>X</b>, or <b>n</b> conversion specifier  applies  to  an  argument
               with type pointer to <b>long</b> or <b>unsigned</b> <b>long</b>; that a following <b>a</b>, <b>A</b>, <b>e</b>, <b>E</b>, <b>f</b>, <b>F</b>, <b>g</b>, or <b>G</b> conversion
               specifier  applies  to  an  argument  with type pointer to <b>double</b>; or that a following <b>c</b>, <b>s</b>, or <b>[</b>
               conversion specifier applies to an argument with type pointer to <b>wchar_t</b>.  If the <b>'m'</b> assignment-
               allocation character is specified, the conversion applies to an argument with the type pointer to
               a pointer to <b>wchar_t</b>.

       ll (ell-ell)
               Specifies that a following <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, <b>X</b>, or <b>n</b> conversion specifier  applies  to  an  argument
               with type pointer to <b>long</b> <b>long</b> or <b>unsigned</b> <b>long</b> <b>long</b>.

       j       Specifies  that  a  following  <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, <b>X</b>, or <b>n</b> conversion specifier applies to an argument
               with type pointer to <b>intmax_t</b> or <b>uintmax_t</b>.

       z       Specifies that a following <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, <b>X</b>, or <b>n</b> conversion specifier  applies  to  an  argument
               with type pointer to <b>size_t</b> or the corresponding signed integer type.

       t       Specifies  that  a  following  <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, <b>X</b>, or <b>n</b> conversion specifier applies to an argument
               with type pointer to <b>ptrdiff_t</b> or the corresponding <b>unsigned</b> type.

       L       Specifies that a following <b>a</b>, <b>A</b>, <b>e</b>, <b>E</b>, <b>f</b>, <b>F</b>, <b>g</b>, or <b>G</b> conversion specifier applies to an  argument
               with type pointer to <b>long</b> <b>double</b>.

       If a length modifier appears with any conversion specifier other than as specified above, the behavior is
       undefined.

       The following conversion specifiers are valid:

       d       Matches  an  optionally  signed  decimal  integer,  whose  format is the same as expected for the
               subject sequence of <u>strtol</u>() with the value 10 for the <u>base</u> argument. In the absence  of  a  size
               modifier, the application shall ensure that the corresponding argument is a pointer to <b>int</b>.

       i       Matches  an  optionally  signed  integer,  whose  format  is the same as expected for the subject
               sequence of <u>strtol</u>() with 0 for the <u>base</u> argument.  In  the  absence  of  a  size  modifier,  the
               application shall ensure that the corresponding argument is a pointer to <b>int</b>.

       o       Matches  an optionally signed octal integer, whose format is the same as expected for the subject
               sequence of <u>strtoul</u>() with the value 8 for the <u>base</u> argument. In the absence of a size  modifier,
               the application shall ensure that the corresponding argument is a pointer to <b>unsigned</b>.

       u       Matches  an  optionally  signed  decimal  integer,  whose  format is the same as expected for the
               subject sequence of <u>strtoul</u>() with the value 10 for the <u>base</u> argument. In the absence of  a  size
               modifier, the application shall ensure that the corresponding argument is a pointer to <b>unsigned</b>.

       x       Matches  an  optionally  signed hexadecimal integer, whose format is the same as expected for the
               subject sequence of <u>strtoul</u>() with the value 16 for the <u>base</u> argument. In the absence of  a  size
               modifier, the application shall ensure that the corresponding argument is a pointer to <b>unsigned</b>.

       a, e, f, g
               Matches an optionally signed floating-point number, infinity, or NaN, whose format is the same as
               expected  for  the  subject  sequence  of  <u>strtod</u>().   In  the  absence  of  a size modifier, the
               application shall ensure that the corresponding argument is a pointer to <b>float</b>.

               If the <u>fprintf</u>() family of functions generates character string representations for infinity  and
               NaN  (a  symbolic  entity  encoded  in  floating-point  format) to support IEEE Std 754‐1985, the
               <u>fscanf</u>() family of functions shall recognize them as input.

       s       Matches a sequence of bytes that are not white-space characters. If the <b>'m'</b> assignment-allocation
               character is not specified, the application shall ensure that the  corresponding  argument  is  a
               pointer  to  the  initial byte of an array of <b>char</b>, <b>signed</b> <b>char</b>, or <b>unsigned</b> <b>char</b> large enough to
               accept the sequence and a terminating null character code, which shall  be  added  automatically.
               Otherwise, the application shall ensure that the corresponding argument is a pointer to a pointer
               to a <b>char</b>.

               If  an  <b>l</b>  (ell)  qualifier  is present, the input is a sequence of characters that begins in the
               initial shift state. Each character shall be converted to a wide character as if by a call to the
               <u>mbrtowc</u>() function, with the conversion state described by an  <b>mbstate_t</b>  object  initialized  to
               zero  before the first character is converted.  If the <b>'m'</b> assignment-allocation character is not
               specified, the application shall ensure that the corresponding argument is a pointer to an  array
               of  <b>wchar_t</b>  large  enough  to accept the sequence and the terminating null wide character, which
               shall be added automatically.  Otherwise, the application shall  ensure  that  the  corresponding
               argument is a pointer to a pointer to a <b>wchar_t</b>.

       [       Matches  a  non-empty  sequence  of bytes from a set of expected bytes (the <u>scanset</u>).  The normal
               skip over white-space characters shall be  suppressed  in  this  case.  If  the  <b>'m'</b>  assignment-
               allocation  character  is  not  specified,  the  application  shall ensure that the corresponding
               argument is a pointer to the initial byte of an array of <b>char</b>,  <b>signed</b>  <b>char</b>,  or  <b>unsigned</b>  <b>char</b>
               large  enough  to  accept  the  sequence  and  a  terminating  null  byte,  which  shall be added
               automatically.  Otherwise, the application shall ensure that  the  corresponding  argument  is  a
               pointer to a pointer to a <b>char</b>.

               If  an  <b>l</b>  (ell)  qualifier  is present, the input is a sequence of characters that begins in the
               initial shift state. Each character in the sequence shall be converted to a wide character as  if
               by  a  call to the <u>mbrtowc</u>() function, with the conversion state described by an <b>mbstate_t</b> object
               initialized to zero before the first character is converted.  If  the  <b>'m'</b>  assignment-allocation
               character  is  not  specified,  the application shall ensure that the corresponding argument is a
               pointer to an array of <b>wchar_t</b> large enough to accept the sequence and the terminating null  wide
               character, which shall be added automatically.
               Otherwise, the application shall ensure that the corresponding argument is a pointer to a pointer
               to a <b>wchar_t</b>.

               The  conversion  specification  includes  all  subsequent  bytes  in  the <u>format</u> string up to and
               including the matching &lt;right-square-bracket&gt; (<b>']'</b>).  The bytes between the square brackets  (the
               <u>scanlist</u>) comprise the scanset, unless the byte after the &lt;left-square-bracket&gt; is a &lt;circumflex&gt;
               (<b>'^'</b>),  in  which  case the scanset contains all bytes that do not appear in the scanlist between
               the &lt;circumflex&gt; and the &lt;right-square-bracket&gt;.  If the  conversion  specification  begins  with
               <b>"[]"</b> or <b>"[^]"</b>, the &lt;right-square-bracket&gt; is included in the scanlist and the next &lt;right-square-
               bracket&gt;   is  the  matching  &lt;right-square-bracket&gt;  that  ends  the  conversion  specification;
               otherwise, the first &lt;right-square-bracket&gt; is the one that ends the conversion specification. If
               a <b>'-'</b> is in the scanlist and is not the first character, nor the second where the first character
               is a <b>'^'</b>, nor the last character, the behavior is implementation-defined.

       c       Matches a sequence of bytes of the number specified by the field width (1 if no  field  width  is
               present in the conversion specification). No null byte is added. The normal skip over white-space
               characters  shall  be  suppressed in this case. If the <b>'m'</b> assignment-allocation character is not
               specified, the application shall ensure that the corresponding  argument  is  a  pointer  to  the
               initial  byte  of  an  array  of  <b>char</b>,  <b>signed</b> <b>char</b>, or <b>unsigned</b> <b>char</b> large enough to accept the
               sequence.  Otherwise, the application shall ensure that the corresponding argument is  a  pointer
               to a pointer to a <b>char</b>.

               If  an  <b>l</b>  (ell) qualifier is present, the input shall be a sequence of characters that begins in
               the initial shift state. Each character in the sequence is converted to a wide character as if by
               a call to the <u>mbrtowc</u>() function, with the conversion state  described  by  an  <b>mbstate_t</b>  object
               initialized to zero before the first character is converted.  No null wide character is added. If
               the  <b>'m'</b>  assignment-allocation character is not specified, the application shall ensure that the
               corresponding argument is a pointer to an array of <b>wchar_t</b> large enough to accept  the  resulting
               sequence  of  wide  characters.   Otherwise,  the application shall ensure that the corresponding
               argument is a pointer to a pointer to a <b>wchar_t</b>.

       p       Matches an implementation-defined set of sequences, which  shall  be  the  same  as  the  set  of
               sequences  that  is  produced  by  the <b>%p</b> conversion specification of the corresponding <u>fprintf</u>()
               functions. The application shall ensure that the corresponding argument is a pointer to a pointer
               to <b>void</b>.  The interpretation of the input item is implementation-defined. If the input item is  a
               value converted earlier during the same program execution, the pointer that results shall compare
               equal to that value; otherwise, the behavior of the <b>%p</b> conversion specification is undefined.

       n       No  input  is consumed. The application shall ensure that the corresponding argument is a pointer
               to the integer into which shall be written the number of bytes read from the input so far by this
               call to the <u>fscanf</u>() functions. Execution of a <b>%n</b> conversion specification  shall  not  increment
               the  assignment  count returned at the completion of execution of the function. No argument shall
               be converted, but one shall be consumed. If the conversion specification includes an  assignment-
               suppressing character or a field width, the behavior is undefined.

       C       Equivalent to <b>lc</b>.

       S       Equivalent to <b>ls</b>.

       %       Matches  a  single  <b>'%'</b>  character;  no  conversion or assignment occurs. The complete conversion
               specification shall be <b>%%</b>.

       If a conversion specification is invalid, the behavior is undefined.

       The conversion specifiers <b>A</b>, <b>E</b>, <b>F</b>, <b>G</b>, and <b>X</b> are also valid and shall be equivalent to <b>a</b>, <b>e</b>, <b>f</b>, <b>g</b>, and  <b>x</b>,
       respectively.

       If  end-of-file is encountered during input, conversion shall be terminated. If end-of-file occurs before
       any bytes matching the current conversion specification (except  for  <b>%n</b>)  have  been  read  (other  than
       leading white-space characters, where permitted), execution of the current conversion specification shall
       terminate  with  an input failure. Otherwise, unless execution of the current conversion specification is
       terminated with a matching failure, execution of the following conversion specification (if any) shall be
       terminated with an input failure.

       Reaching the end of the string in <u>sscanf</u>() shall be equivalent to encountering end-of-file for <u>fscanf</u>().

       If conversion terminates on a conflicting input, the offending input is left unread  in  the  input.  Any
       trailing white space (including &lt;newline&gt; characters) shall be left unread unless matched by a conversion
       specification.  The  success  of literal matches and suppressed assignments is only directly determinable
       via the <b>%n</b> conversion specification.

       The <u>fscanf</u>() and <u>scanf</u>() functions may mark the last data access timestamp of the  file  associated  with
       <u>stream</u>  for  update.  The  last  data access timestamp shall be marked for update by the first successful
       execution of <u>fgetc</u>(), <u>fgets</u>(), <u>fread</u>(), <u>getc</u>(), <u>getchar</u>(), <u>getdelim</u>(), <u>getline</u>(),  <u>gets</u>(),  <u>fscanf</u>(),  or
       <u>scanf</u>() using <u>stream</u> that returns data not supplied by a prior call to <u>ungetc</u>().

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon  successful completion, these functions shall return the number of successfully matched and assigned
       input items; this number can be zero in the event of an early matching failure. If the input ends  before
       the first conversion (if any) has completed, and without a matching failure having occurred, EOF shall be
       returned.  If  an error occurs before the first conversion (if any) has completed, and without a matching
       failure having occurred, EOF shall be returned and <u>errno</u> shall be set to indicate the error.  If  a  read
       error occurs, the error indicator for the stream shall be set.

</pre><h4><b>ERRORS</b></h4><pre>
       For the conditions under which the <u>fscanf</u>() functions fail and may fail, refer to <u>fgetc</u>() or <u>fgetwc</u>().

       In addition, the <u>fscanf</u>() function shall fail if:

       <b>EILSEQ</b> Input byte sequence does not form a valid character.

       <b>ENOMEM</b> Insufficient storage space is available.

       In addition, the <u>fscanf</u>() function may fail if:

       <b>EINVAL</b> There are insufficient arguments.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       The call:

           int i, n; float x; char name[50];
           n = scanf("%d%f%s", &amp;i, &amp;x, name);

       with the input line:

           25 54.32E-1 Hamster

       assigns  to  <u>n</u>  the  value  3,  to  <u>i</u>  the  value  25, to <u>x</u> the value 5.432, and <u>name</u> contains the string
       <b>"Hamster"</b>.

       The call:

           int i; float x; char name[50];
           (void) scanf("%2d%f%*d %[0123456789]", &amp;i, &amp;x, name);

       with input:

           56789 0123 56a72

       assigns 56 to <u>i</u>, 789.0 to <u>x</u>, skips 0123, and places  the  string  <b>"56\0"</b>  in  <u>name</u>.   The  next  call  to
       <u>getchar</u>() shall return the character <b>'a'</b>.

   <b>Reading</b> <b>Data</b> <b>into</b> <b>an</b> <b>Array</b>
       The  following call uses <u>fscanf</u>() to read three floating-point numbers from standard input into the <u>input</u>
       array.

           float input[3]; fscanf (stdin, "%f %f %f", input, input+1, input+2);

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       If the application calling <u>fscanf</u>() has any objects of type <b>wint_t</b> or <b>wchar_t</b>, it must also  include  the
       <u>&lt;wchar.h&gt;</u> header to have these objects defined.

       For  functions that allocate memory as if by <u>malloc</u>(), the application should release such memory when it
       is no longer required by a call to <u>free</u>().  For <u>fscanf</u>(), this is memory allocated via  use  of  the  <b>'m'</b>
       assignment-allocation character.

</pre><h4><b>RATIONALE</b></h4><pre>
       This  function  is  aligned with the ISO/IEC 9899:1999 standard, and in doing so a few ``obvious'' things
       were not included. Specifically, the set of characters allowed in a scanset  is  limited  to  single-byte
       characters.   In  other similar places, multi-byte characters have been permitted, but for alignment with
       the ISO/IEC 9899:1999 standard, it has not been done  here.  Applications  needing  this  could  use  the
       corresponding wide-character functions to achieve the desired results.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u>  <u>2.5</u>,  <u>Standard</u>  <u>I/O</u>  <u>Streams</u>,  <u>fprintf</u>(),  <u>getc</u>(),  <u>setlocale</u>(),  <u>strtod</u>(), <u>strtol</u>(), <u>strtoul</u>(),
       <u>wcrtomb</u>()

       The Base Definitions volume of POSIX.1‐2017, <u>Chapter</u> <u>7</u>, <u>Locale</u>,  <b>&lt;inttypes.h&gt;</b>,  <b>&lt;langinfo.h&gt;</b>,  <b>&lt;stdio.h&gt;</b>,
       <b>&lt;wchar.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                        <u><a href="../man3POSIX/FSCANF.3POSIX.html">FSCANF</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>