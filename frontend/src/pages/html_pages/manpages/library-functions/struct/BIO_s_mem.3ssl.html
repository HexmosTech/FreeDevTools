<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIO_s_secmem, BIO_s_dgram_mem, BIO_s_mem, BIO_set_mem_eof_return, BIO_get_mem_data, BIO_set_mem_buf,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       BIO_s_secmem, BIO_s_dgram_mem, BIO_s_mem, BIO_set_mem_eof_return, BIO_get_mem_data, BIO_set_mem_buf,
       BIO_get_mem_ptr, BIO_new_mem_buf - memory BIO

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/bio.h&gt;

        const BIO_METHOD *BIO_s_mem(void);
        const BIO_METHOD *BIO_s_dgram_mem(void);
        const BIO_METHOD *BIO_s_secmem(void);

        BIO_set_mem_eof_return(BIO *b, int v);
        long BIO_get_mem_data(BIO *b, char **pp);
        BIO_set_mem_buf(BIO *b, BUF_MEM *bm, int c);
        BIO_get_mem_ptr(BIO *b, BUF_MEM **pp);

        BIO *BIO_new_mem_buf(const void *buf, int len);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>BIO_s_mem()</b> returns the memory BIO method function.

       A memory BIO is a source/sink BIO which uses memory for its I/O. Data written to a memory BIO is stored
       in a BUF_MEM structure which is extended as appropriate to accommodate the stored data.

       <b>BIO_s_secmem()</b> is like <b>BIO_s_mem()</b> except that the secure heap is used for buffer storage.

       <b>BIO_s_dgram_mem()</b> is a memory BIO that respects datagram semantics. A single call to <b><a href="../man3/BIO_write.3.html">BIO_write</a></b>(3) will
       write a single datagram to the memory BIO. A subsequent call to <b><a href="../man3/BIO_read.3.html">BIO_read</a></b>(3) will read the data in that
       datagram. The <b><a href="../man3/BIO_read.3.html">BIO_read</a></b>(3) call will never return more data than was written in the original <b><a href="../man3/BIO_write.3.html">BIO_write</a></b>(3)
       call even if there were subsequent <b><a href="../man3/BIO_write.3.html">BIO_write</a></b>(3) calls that wrote more datagrams. Each successive call to
       <b><a href="../man3/BIO_read.3.html">BIO_read</a></b>(3) will read the next datagram. If a <b><a href="../man3/BIO_read.3.html">BIO_read</a></b>(3) call supplies a read buffer that is smaller
       than the size of the datagram, then the read buffer will be completely filled and the remaining data from
       the datagram will be discarded.

       It is not possible to write a zero length datagram. Calling <b><a href="../man3/BIO_write.3.html">BIO_write</a></b>(3) in this case will return 0 and
       no datagrams will be written. Calling <b><a href="../man3/BIO_read.3.html">BIO_read</a></b>(3) when there are no datagrams in the BIO to read will
       return a negative result and the "retry" flags will be set (i.e. calling <b><a href="../man3/BIO_should_retry.3.html">BIO_should_retry</a></b>(3) will return
       true). A datagram mem BIO will never return true from <b><a href="../man3/BIO_eof.3.html">BIO_eof</a></b>(3).

       Any data written to a memory BIO can be recalled by reading from it.  Unless the memory BIO is read only
       any data read from it is deleted from the BIO.

       Memory BIOs except <b>BIO_s_dgram_mem()</b> support <b>BIO_gets()</b> and <b>BIO_puts()</b>.

       <b>BIO_s_dgram_mem()</b> supports <b><a href="../man3/BIO_sendmmsg.3.html">BIO_sendmmsg</a></b>(3) and <b><a href="../man3/BIO_recvmmsg.3.html">BIO_recvmmsg</a></b>(3) calls and calls related to <b>BIO_ADDR</b> and
       MTU handling similarly to the <b><a href="../man3/BIO_s_dgram_pair.3.html">BIO_s_dgram_pair</a></b>(3).

       If the BIO_CLOSE flag is set when a memory BIO is freed then the underlying BUF_MEM structure is also
       freed.

       Calling <b>BIO_reset()</b> on a read write memory BIO clears any data in it if the flag BIO_FLAGS_NONCLEAR_RST
       is not set, otherwise it just restores the read pointer to the state it was just after the last write was
       performed and the data can be read again. On a read only BIO it similarly restores the BIO to its
       original state and the read only data can be read again.

       <b>BIO_eof()</b> is true if no data is in the BIO.

       <b>BIO_ctrl_pending()</b> returns the number of bytes currently stored.

       <b>BIO_set_mem_eof_return()</b> sets the behaviour of memory BIO <b>b</b> when it is empty. If the <b>v</b> is zero then an
       empty memory BIO will return EOF (that is it will return zero and BIO_should_retry(b) will be false. If <b>v</b>
       is non zero then it will return <b>v</b> when it is empty and it will set the read retry flag (that is
       BIO_read_retry(b) is true). To avoid ambiguity with a normal positive return value <b>v</b> should be set to a
       negative value, typically -1.  Calling this macro will fail for datagram mem BIOs.

       <b>BIO_get_mem_data()</b> sets *<b>pp</b> to a pointer to the start of the memory BIOs data and returns the total
       amount of data available. It is implemented as a macro.  Note the pointer returned by this call is
       informative, no transfer of ownership of this memory is implied.  See notes on <b>BIO_set_close()</b>.

       <b>BIO_set_mem_buf()</b> sets the internal BUF_MEM structure to <b>bm</b> and sets the close flag to <b>c</b>, that is <b>c</b>
       should be either BIO_CLOSE or BIO_NOCLOSE.  It is a macro.

       <b>BIO_get_mem_ptr()</b> places the underlying BUF_MEM structure in *<b>pp</b>. It is a macro.

       <b>BIO_new_mem_buf()</b> creates a memory BIO using <b>len</b> bytes of data at <b>buf</b>, if <b>len</b> is -1 then the <b>buf</b> is
       assumed to be nul terminated and its length is determined by <b>strlen</b>. The BIO is set to a read only state
       and as a result cannot be written to. This is useful when some data needs to be made available from a
       static area of memory in the form of a BIO. The supplied data is read directly from the supplied buffer:
       it is <b>not</b> copied first, so the supplied area of memory must be unchanged until the BIO is freed.

       All of the five functions described above return an error with <b>BIO_s_dgram_mem()</b>.

</pre><h4><b>NOTES</b></h4><pre>
       Writes to memory BIOs will always succeed if memory is available: that is their size can grow
       indefinitely. An exception is <b>BIO_s_dgram_mem()</b> when <b><a href="../man3/BIO_set_write_buf_size.3.html">BIO_set_write_buf_size</a></b>(3) is called on it. In such
       case the write buffer size will be fixed and any writes that would overflow the buffer will return an
       error.

       Every write after partial read (not all data in the memory buffer was read) to a read write memory BIO
       will have to move the unread data with an internal copy operation, if a BIO contains a lot of data and it
       is read in small chunks intertwined with writes the operation can be very slow. Adding a buffering BIO to
       the chain can speed up the process.

       Calling <b>BIO_set_mem_buf()</b> on a secmem or dgram BIO will give undefined results, including perhaps a
       program crash.

       Switching a memory BIO from read write to read only is not supported and can give undefined results
       including a program crash. There are two notable exceptions to the rule. The first one is to assign a
       static memory buffer immediately after BIO creation and set the BIO as read only.

       The other supported sequence is to start with a read write BIO then temporarily switch it to read only
       and call <b>BIO_reset()</b> on the read only BIO immediately before switching it back to read write. Before the
       BIO is freed it must be switched back to the read write mode.

       Calling <b>BIO_get_mem_ptr()</b> on read only BIO will return a BUF_MEM that contains only the remaining data to
       be read. If the close status of the BIO is set to BIO_NOCLOSE, before freeing the BUF_MEM the data
       pointer in it must be set to NULL as the data pointer does not point to an allocated memory.

       Calling <b>BIO_reset()</b> on a read write memory BIO with BIO_FLAGS_NONCLEAR_RST flag set can have unexpected
       outcome when the reads and writes to the BIO are intertwined. As documented above the BIO will be reset
       to the state after the last completed write operation. The effects of reads preceding that write
       operation cannot be undone.

       Calling <b>BIO_get_mem_ptr()</b> prior to a <b>BIO_reset()</b> call with BIO_FLAGS_NONCLEAR_RST set has the same effect
       as a write operation.

       Calling <b>BIO_set_close()</b> with BIO_NOCLOSE orphans the BUF_MEM internal to the BIO, _not_ its actual data
       buffer. See the examples section for the proper method for claiming ownership of the data pointer for a
       deferred free operation.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>BIO_s_mem()</b>, <b>BIO_s_dgram_mem()</b> and <b>BIO_s_secmem()</b> return a valid memory <b>BIO_METHOD</b> structure.

       <b>BIO_set_mem_eof_return()</b>, <b>BIO_set_mem_buf()</b> and <b>BIO_get_mem_ptr()</b> return 1 on success or a value which is
       less than or equal to 0 if an error occurred.

       <b>BIO_get_mem_data()</b> returns the total number of bytes available on success, 0 if b is NULL, or a negative
       value in case of other errors.

       <b>BIO_new_mem_buf()</b> returns a valid <b>BIO</b> structure on success or NULL on error.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Create a memory BIO and write some data to it:

        BIO *mem = BIO_new(BIO_s_mem());

        BIO_puts(mem, "Hello World\n");

       Create a read only memory BIO:

        char data[] = "Hello World";
        BIO *mem = BIO_new_mem_buf(data, -1);

       Extract the BUF_MEM structure from a memory BIO and then free up the BIO:

        BUF_MEM *bptr;

        BIO_get_mem_ptr(mem, &amp;bptr);
        BIO_set_close(mem, BIO_NOCLOSE); /* So BIO_free() leaves BUF_MEM alone */
        <a href="../manmem/BIO_free.mem.html">BIO_free</a>(mem);

       Extract the BUF_MEM ptr, claim ownership of the internal data and free the BIO and BUF_MEM structure:

        BUF_MEM *bptr;
        char *data;

        BIO_get_mem_data(bio, &amp;data);
        BIO_get_mem_ptr(bio, &amp;bptr);
        BIO_set_close(mem, BIO_NOCLOSE); /* So BIO_free orphans BUF_MEM */
        BIO_free(bio);
        bptr-&gt;data = NULL; /* Tell BUF_MEM to orphan data */
        BUF_MEM_free(bptr);
        ...
        free(data);

</pre><h4><b>HISTORY</b></h4><pre>
       <b>BIO_s_dgram_mem()</b> was added in OpenSSL 3.2.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2000-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                    <u><a href="../man3SSL/BIO_S_MEM.3SSL.html">BIO_S_MEM</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>