<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSL_CTX_set_tlsext_ticket_key_evp_cb, SSL_CTX_set_tlsext_ticket_key_cb - set a callback for session</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SSL_CTX_set_tlsext_ticket_key_evp_cb, SSL_CTX_set_tlsext_ticket_key_cb - set a callback for session
       ticket processing

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/tls1.h&gt;

        int SSL_CTX_set_tlsext_ticket_key_evp_cb(SSL_CTX sslctx,
            int (*cb)(SSL *s, unsigned char key_name[16],
                      unsigned char iv[EVP_MAX_IV_LENGTH],
                      EVP_CIPHER_CTX *ctx, EVP_MAC_CTX *hctx, int enc));

       The following function has been deprecated since OpenSSL 3.0, and can be hidden entirely by defining
       <b>OPENSSL_API_COMPAT</b> with a suitable version value, see <b><a href="../man7/openssl_user_macros.7.html">openssl_user_macros</a></b>(7):

        int SSL_CTX_set_tlsext_ticket_key_cb(SSL_CTX sslctx,
            int (*cb)(SSL *s, unsigned char key_name[16],
                      unsigned char iv[EVP_MAX_IV_LENGTH],
                      EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, int enc));

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>SSL_CTX_set_tlsext_ticket_key_evp_cb()</b> sets a callback function <u>cb</u> for handling session tickets for the
       ssl context <u>sslctx</u>. Session tickets, defined in RFC5077 provide an enhanced session resumption capability
       where the server implementation is not required to maintain per session state. It only applies to TLS and
       there is no SSLv3 implementation.

       The callback function <u>cb</u> will be called for every client instigated TLS session when session ticket
       extension is presented in the TLS hello message. It is the responsibility of this function to create or
       retrieve the cryptographic parameters and to maintain their state.

       The OpenSSL library uses your callback function to help implement a common TLS ticket construction state
       according to RFC5077 Section 4 such that per session state is unnecessary and a small set of
       cryptographic variables needs to be maintained by the callback function implementation.

       In order to reuse a session, a TLS client must send the session ticket extension to the server. The
       client must send exactly one session ticket.  The server, through the callback function, either agrees to
       reuse the session ticket information or it starts a full TLS handshake to create a new session ticket.

       Before the callback function is started <u>ctx</u> and <u>hctx</u> have been initialised with <b><a href="../man3/EVP_CIPHER_CTX_reset.3.html">EVP_CIPHER_CTX_reset</a></b>(3)
       and <b><a href="../man3/EVP_MAC_CTX_new.3.html">EVP_MAC_CTX_new</a></b>(3) respectively.

       For new sessions tickets, when the client doesn't present a session ticket, or an attempted retrieval of
       the ticket failed, or a renew option was indicated, the callback function will be called with <u>enc</u> equal
       to 1. The OpenSSL library expects that the function will set an arbitrary <u>name</u>, initialize <u>iv</u>, and set
       the cipher context <u>ctx</u> and the hash context <u>hctx</u>.

       The <u>name</u> is 16 characters long and is used as a key identifier.

       The <u>iv</u> length is the length of the IV of the corresponding cipher. The maximum IV length is
       <b>EVP_MAX_IV_LENGTH</b> bytes defined in <u>&lt;openssl/evp.h&gt;</u>.

       The initialization vector <u>iv</u> should be a random value. The cipher context <u>ctx</u> should use the
       initialisation vector <u>iv</u>. The cipher context can be set using <b><a href="../man3/EVP_EncryptInit_ex.3.html">EVP_EncryptInit_ex</a></b>(3). The hmac context and
       digest can be set using <b><a href="../man3/EVP_MAC_CTX_set_params.3.html">EVP_MAC_CTX_set_params</a></b>(3) with the <b>OSSL_MAC_PARAM_KEY</b> and <b>OSSL_MAC_PARAM_DIGEST</b>
       parameters respectively.

       When the client presents a session ticket, the callback function with be called with <u>enc</u> set to 0
       indicating that the <u>cb</u> function should retrieve a set of parameters. In this case <u>name</u> and <u>iv</u> have
       already been parsed out of the session ticket. The OpenSSL library expects that the <u>name</u> will be used to
       retrieve a cryptographic parameters and that the cryptographic context <u>ctx</u> will be set with the retrieved
       parameters and the initialization vector <u>iv</u>. using a function like <b><a href="../man3/EVP_DecryptInit_ex.3.html">EVP_DecryptInit_ex</a></b>(3). The key
       material and digest for <u>hctx</u> need to be set using <b><a href="../man3/EVP_MAC_CTX_set_params.3.html">EVP_MAC_CTX_set_params</a></b>(3) with the <b>OSSL_MAC_PARAM_KEY</b>
       and <b>OSSL_MAC_PARAM_DIGEST</b> parameters respectively.

       If the <u>name</u> is still valid but a renewal of the ticket is required the callback function should return 2.
       The library will call the callback again with an argument of enc equal to 1 to set the new ticket.

       The return value of the <u>cb</u> function is used by OpenSSL to determine what further processing will occur.
       The following return values have meaning:

       2   This  indicates that the <u>ctx</u> and <u>hctx</u> have been set and the session can continue on those parameters.
           Additionally it indicates that the session ticket is in a renewal period and should be replaced.  The
           OpenSSL  library  will call <u>cb</u> again with an enc argument of 1 to set the new ticket (see RFC5077 3.3
           paragraph 2).

       1   This indicates that the <u>ctx</u> and <u>hctx</u> have been set and the session can continue on those parameters.

       0   This indicates that it was not possible to set/retrieve a session ticket and the SSL/TLS session will
           continue by negotiating a set of cryptographic parameters or using the alternate  SSL/TLS  resumption
           mechanism, session ids.

           If called with enc equal to 0 the library will call the <u>cb</u> again to get a new set of parameters.

       less than 0
           This indicates an error.

       The  <b>SSL_CTX_set_tlsext_ticket_key_cb()</b>  function  is identical to <b>SSL_CTX_set_tlsext_ticket_key_evp_cb()</b>
       except that it takes a deprecated HMAC_CTX pointer instead of an EVP_MAC_CTX one.  Before  this  callback
       function  is  started  <u>hctx</u>  will  have  been initialised with <b><a href="../man3/EVP_MAC_CTX_new.3.html">EVP_MAC_CTX_new</a></b>(3) and the digest set with
       <b><a href="../man3/EVP_MAC_CTX_set_params.3.html">EVP_MAC_CTX_set_params</a></b>(3).  The <u>hctx</u> key material can be set using <b><a href="../man3/HMAC_Init_ex.3.html">HMAC_Init_ex</a></b>(3).

</pre><h4><b>NOTES</b></h4><pre>
       Session resumption shortcuts the TLS handshake so that the client certificate negotiation doesn't  occur.
       It  makes  up  for  this  by  storing  the  client certificate and all other negotiated state information
       encrypted within the ticket. In a resumed session the applications will have all this  state  information
       available exactly as if a full negotiation had occurred.

       If an attacker can obtain the key used to encrypt a session ticket, they can obtain the master secret for
       any  ticket  using that key and decrypt any traffic using that session: even if the cipher suite supports
       forward secrecy. As a result applications may wish to use multiple keys and avoid using  long  term  keys
       stored in files.

       Applications  can  use  longer  keys to maintain a consistent level of security.  For example if a cipher
       suite uses 256 bit ciphers but only a 128 bit ticket key the overall security is only  128  bits  because
       breaking the ticket key will enable an attacker to obtain the session keys.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       Returns 1 to indicate the callback function was set and 0 otherwise.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Reference Implementation:

        SSL_CTX_set_tlsext_ticket_key_evp_cb(SSL, ssl_tlsext_ticket_key_cb);
        ...

        static int ssl_tlsext_ticket_key_cb(SSL *s, unsigned char key_name[16],
                                            unsigned char *iv, EVP_CIPHER_CTX *ctx,
                                            EVP_MAC_CTX *hctx, int enc)
        {
            OSSL_PARAM params[3];
            your_type_t *key; /* something that you need to implement */

            if (enc) { /* create new session */
                if (RAND_bytes(iv, EVP_MAX_IV_LENGTH) &lt;= 0)
                    return -1; /* insufficient random */

                key = currentkey(); /* something that you need to implement */
                if (key == NULL) {
                    /* current key doesn't exist or isn't valid */
                    key = createkey(); /*
                                        * Something that you need to implement.
                                        * createkey needs to initialise a name,
                                        * an aes_key, a hmac_key and optionally
                                        * an expire time.
                                        */
                    if (key == NULL) /* key couldn't be created */
                        return 0;
                }
                memcpy(key_name, key-&gt;name, 16);

                if (EVP_EncryptInit_ex(&amp;ctx, EVP_aes_256_cbc(), NULL, key-&gt;aes_key,
                                       iv) == 0)
                   return -1; /* error in cipher initialisation */

                params[0] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,
                                                              key-&gt;hmac_key, 32);
                params[1] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,
                                                             "sha256", 0);
                params[2] = OSSL_PARAM_construct_end();
                if (EVP_MAC_CTX_set_params(hctx, params) == 0)
                   return -1; /* error in mac initialisation */

                return 1;

            } else { /* retrieve session */
                time_t t = time(NULL);
                key = findkey(key_name); /* something that you need to implement */

                if (key == NULL || key-&gt;expire &lt; t)
                    return 0;

                params[0] = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,
                                                              key-&gt;hmac_key, 32);
                params[1] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,
                                                             "sha256", 0);
                params[2] = OSSL_PARAM_construct_end();
                if (EVP_MAC_CTX_set_params(hctx, params) == 0)
                   return -1; /* error in mac initialisation */

                if (EVP_DecryptInit_ex(&amp;ctx, EVP_aes_256_cbc(), NULL, key-&gt;aes_key,
                                       iv) == 0)
                   return -1; /* error in cipher initialisation */

                if (key-&gt;expire &lt; t - RENEW_TIME) { /* RENEW_TIME: implement */
                    /*
                     * return 2 - This session will get a new ticket even though the
                     * current one is still valid.
                     */
                    return 2;
                }
                return 1;
            }
        }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/ssl.7.html">ssl</a></b>(7),   <b><a href="../man3/SSL_set_session.3.html">SSL_set_session</a></b>(3),   <b><a href="../man3/SSL_session_reused.3.html">SSL_session_reused</a></b>(3),   <b><a href="../man3/SSL_CTX_add_session.3.html">SSL_CTX_add_session</a></b>(3),  <b><a href="../man3/SSL_CTX_sess_number.3.html">SSL_CTX_sess_number</a></b>(3),
       <b><a href="../man3/SSL_CTX_sess_set_get_cb.3.html">SSL_CTX_sess_set_get_cb</a></b>(3), <b><a href="../man3/SSL_CTX_set_session_id_context.3.html">SSL_CTX_set_session_id_context</a></b>(3),

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>SSL_CTX_set_tlsext_ticket_key_cb()</b> function was deprecated in OpenSSL 3.0.

       The <b>SSL_CTX_set_tlsext_ticket_key_evp_cb()</b> function was introduced in OpenSSL 3.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2014-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file  except  in  compliance
       with  the  License.   You  can  obtain  a  copy  in  the  file  LICENSE  in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04             <u><a href="../man3SSL/SSL_CTX_SET_TLSEXT_TICKET_KEY_CB.3SSL.html">SSL_CTX_SET_TLSEXT_TICKET_KEY_CB</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>