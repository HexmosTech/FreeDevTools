<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSSL_HTTP_open, OSSL_HTTP_bio_cb_t, OSSL_HTTP_proxy_connect, OSSL_HTTP_set1_request, OSSL_HTTP_exchange,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       OSSL_HTTP_open, OSSL_HTTP_bio_cb_t, OSSL_HTTP_proxy_connect, OSSL_HTTP_set1_request, OSSL_HTTP_exchange,
       OSSL_HTTP_get, OSSL_HTTP_transfer, OSSL_HTTP_close -  HTTP client high-level functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/http.h&gt;

        typedef BIO *(*OSSL_HTTP_bio_cb_t)(BIO *bio, void *arg,
                                           int connect, int detail);
        OSSL_HTTP_REQ_CTX *OSSL_HTTP_open(const char *server, const char *port,
                                          const char *proxy, const char *no_proxy,
                                          int use_ssl, BIO *bio, BIO *rbio,
                                          OSSL_HTTP_bio_cb_t bio_update_fn, void *arg,
                                          int buf_size, int overall_timeout);
        int OSSL_HTTP_proxy_connect(BIO *bio, const char *server, const char *port,
                                    const char *proxyuser, const char *proxypass,
                                    int timeout, BIO *bio_err, const char *prog);
        int OSSL_HTTP_set1_request(OSSL_HTTP_REQ_CTX *rctx, const char *path,
                                   const STACK_OF(CONF_VALUE) *headers,
                                   const char *content_type, BIO *req,
                                   const char *expected_content_type, int expect_asn1,
                                   size_t max_resp_len, int timeout, int keep_alive);
        BIO *OSSL_HTTP_exchange(OSSL_HTTP_REQ_CTX *rctx, char **redirection_url);
        BIO *OSSL_HTTP_get(const char *url, const char *proxy, const char *no_proxy,
                           BIO *bio, BIO *rbio,
                           OSSL_HTTP_bio_cb_t bio_update_fn, void *arg,
                           int buf_size, const STACK_OF(CONF_VALUE) *headers,
                           const char *expected_content_type, int expect_asn1,
                           size_t max_resp_len, int timeout);
        BIO *OSSL_HTTP_transfer(OSSL_HTTP_REQ_CTX **prctx,
                                const char *server, const char *port,
                                const char *path, int use_ssl,
                                const char *proxy, const char *no_proxy,
                                BIO *bio, BIO *rbio,
                                OSSL_HTTP_bio_cb_t bio_update_fn, void *arg,
                                int buf_size, const STACK_OF(CONF_VALUE) *headers,
                                const char *content_type, BIO *req,
                                const char *expected_content_type, int expect_asn1,
                                size_t max_resp_len, int timeout, int keep_alive);
        int OSSL_HTTP_close(OSSL_HTTP_REQ_CTX *rctx, int ok);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>OSSL_HTTP_open()</b> initiates an HTTP session using the <u>bio</u> argument if not NULL, else by connecting to a
       given <u>server</u> optionally via a <u>proxy</u>.

       Typically the OpenSSL build supports sockets and the <u>bio</u> parameter is NULL.  In this case <u>rbio</u> must be
       NULL as well and the <u>server</u> must be non-NULL.  The function creates a network BIO internally using
       <b><a href="../man3/BIO_new_connect.3.html">BIO_new_connect</a></b>(3) for connecting to the given server and the optionally given <u>port</u>, defaulting to 80 for
       HTTP or 443 for HTTPS.  Then this internal BIO is used for setting up a connection and for exchanging one
       or more request and response.

       If <u>bio</u> is given and <u>rbio</u> is NULL then this <u>bio</u> is used instead.  If both <u>bio</u> and <u>rbio</u> are given (which
       may be memory BIOs for instance) then no explicit connection is set up, but <u>bio</u> is used for writing
       requests and <u>rbio</u> for reading responses.  As soon as the client has flushed <u>bio</u> the server must be ready
       to provide a response or indicate a waiting condition via <u>rbio</u>.

       If <u>bio</u> is given, it is an error to provide non-NULL <u>proxy</u> or <u>no_proxy</u> arguments, while <u>server</u> and <u>port</u>
       arguments may be given to support diagnostic output.  If <u>bio</u> is NULL the optional <u>proxy</u> parameter can be
       used to set an HTTP(S) proxy to use (unless overridden by "no_proxy" settings).  If TLS is not used this
       defaults to the environment variable "http_proxy" if set, else "HTTP_PROXY".  If <u>use_ssl</u> != 0 it defaults
       to "https_proxy" if set, else "HTTPS_PROXY".  An empty proxy string "" forbids using a proxy.  Otherwise,
       the format is "[http[s]://][userinfo@]host[:port][/path][?query][#fragment]", where any userinfo, path,
       query, and fragment given is ignored.  If the host string is an IPv6 address, it must be enclosed in "["
       and "]".  The default proxy port number is 80, or 443 in case "https:" is given.  The HTTP client
       functions connect via the given proxy unless the <u>server</u> is found in the optional list <u>no_proxy</u> of proxy
       hostnames or IP addresses separated by "," and/or whitespace (if not NULL; default is the environment
       variable "no_proxy" if set, else "NO_PROXY").  Proxying plain HTTP is supported directly, while using a
       proxy for HTTPS connections requires a suitable callback function such as <b>OSSL_HTTP_proxy_connect()</b>,
       described below.

       If <u>use_ssl</u> is nonzero a TLS connection is requested and the <u>bio_update_fn</u> parameter must be provided.

       The parameter <u>bio_update_fn</u>, which is optional if <u>use_ssl</u> is 0, may be used to modify the connection BIO
       used by the HTTP client, but cannot be used when both <u>bio</u> and <u>rbio</u> are given.  <u>bio_update_fn</u> is a BIO
       connect/disconnect callback function with prototype

        BIO *(*OSSL_HTTP_bio_cb_t)(BIO *bio, void *arg, int connect, int detail)

       The callback function may modify the BIO provided in the <u>bio</u> argument, whereby it may use an optional
       custom defined argument <u>arg</u>, which can for instance point to an <b>SSL_CTX</b> structure.  During connection
       establishment, just after calling <b>BIO_do_connect_retry()</b>, the callback function is invoked with the
       <u>connect</u> argument being 1 and <u>detail</u> being 1 if <u>use_ssl</u> is nonzero (i.e., HTTPS is requested), else 0.  On
       disconnect <u>connect</u> is 0 and <u>detail</u> is 1 if no error occurred, else 0.  For instance, on connect the
       callback may push an SSL BIO to implement HTTPS; after disconnect it may do some diagnostic output and
       pop and free the SSL BIO.

       The callback function must return either the potentially modified BIO <u>bio</u> or NULL to indicate failure, in
       which case it should not modify the BIO.

       Here is a simple example that supports TLS connections (but not via a proxy):

        BIO *http_tls_cb(BIO *bio, void *arg, int connect, int detail)
        {
            if (connect &amp;&amp; detail) { /* connecting with TLS */
                SSL_CTX *ctx = (SSL_CTX *)arg;
                BIO *sbio = BIO_new_ssl(ctx, 1);

                bio = sbio != NULL ? BIO_push(sbio, bio) : NULL;
            } else if (!connect) { /* disconnecting */
                BIO *hbio;

                if (!detail) { /* an error has occurred */
                    /* optionally add diagnostics here */
                }
                BIO_ssl_shutdown(bio);
                hbio = BIO_pop(bio);
                BIO_free(bio); /* SSL BIO */
                bio = hbio;
            }
            return bio;
        }

       After disconnect the modified BIO will be deallocated using <b>BIO_free_all()</b>.  The optional callback
       function argument <u>arg</u> is not consumed, so must be freed by the caller when not needed any more.

       The <u>buf_size</u> parameter specifies the response header maximum line length.  A value &lt;= 0 means that the
       <b>OSSL_HTTP_DEFAULT_MAX_LINE_LEN</b> (4KiB) is used.  <u>buf_size</u> is also used as the number of content bytes that
       are read at a time.

       If the <u>overall_timeout</u> parameter is &gt; 0 this indicates the maximum number of seconds the overall HTTP
       transfer (i.e., connection setup if needed, sending requests, and receiving responses) is allowed to take
       until completion.  A value &lt;= 0 enables waiting indefinitely, i.e., no timeout.

       <b>OSSL_HTTP_proxy_connect()</b> may be used by an above BIO connect callback function to set up an SSL/TLS
       connection via an HTTPS proxy.  It promotes the given BIO <u>bio</u> representing a connection pre-established
       with a TLS proxy using the HTTP CONNECT method, optionally using proxy client credentials <u>proxyuser</u> and
       <u>proxypass</u>, to connect with TLS protection ultimately to <u>server</u> and <u>port</u>.  If the <u>port</u> argument is NULL or
       the empty string it defaults to "443".  If the <u>timeout</u> parameter is &gt; 0 this indicates the maximum number
       of seconds the connection setup is allowed to take.  A value &lt;= 0 enables waiting indefinitely, i.e., no
       timeout.  Since this function is typically called by applications such as <b><a href="../man1/openssl-s_client.1.html">openssl-s_client</a></b>(1) it uses the
       <u>bio_err</u> and <u>prog</u> parameters (unless NULL) to print additional diagnostic information in a user-oriented
       way.

       <b>OSSL_HTTP_set1_request()</b> sets up in <u>rctx</u> the request header and content data and expectations on the
       response using the following parameters.  If &lt;rctx&gt; indicates using a proxy for HTTP (but not HTTPS), the
       server host (and optionally port) needs to be placed in the header; thus it must be present in <u>rctx</u>.  For
       backward compatibility, the server (and optional port) may also be given in the <u>path</u> argument beginning
       with "http://" (thus giving an absoluteURI).  If <u>path</u> is NULL it defaults to "/".  If <u>req</u> is NULL the
       HTTP GET method will be used to send the request else HTTP POST with the contents of <u>req</u> and optional
       <u>content_type</u>, where the length of the data in <u>req</u> does not need to be determined in advance: the BIO will
       be read on-the-fly while sending the request, which supports streaming.  The optional list <u>headers</u> may
       contain additional custom HTTP header lines.  The <u>max_resp_len</u> parameter specifies the maximum allowed
       response content length, where the value 0 indicates no limit.  For the meaning of the
       <u>expected_content_type</u>, <u>expect_asn1</u>, <u>timeout</u>, and <u>keep_alive</u> parameters, see
       <b><a href="../man3/OSSL_HTTP_REQ_CTX_set_expected.3.html">OSSL_HTTP_REQ_CTX_set_expected</a></b>(3).

       <b>OSSL_HTTP_exchange()</b> exchanges any form of HTTP request and response as specified by <u>rctx</u>, which must
       include both connection and request data, typically set up using <b>OSSL_HTTP_open()</b> and
       <b>OSSL_HTTP_set1_request()</b>.  It implements the core of the functions described below.  If the HTTP method
       is GET and <u>redirection_url</u> is not NULL the latter pointer is used to provide any new location that the
       server may return with HTTP code 301 (MOVED_PERMANENTLY) or 302 (FOUND).  In this case the function
       returns NULL and the caller is responsible for deallocating the URL with <b><a href="../man3/OPENSSL_free.3.html">OPENSSL_free</a></b>(3).  If the
       response header contains one or more "Content-Length" lines and/or an ASN.1-encoded response is expected,
       which should include a total length, the length indications received are checked for consistency and for
       not exceeding any given maximum response length.  If an ASN.1-encoded response is expected, the function
       returns on success the contents buffered in a memory BIO, which does not support streaming.  Otherwise it
       returns directly the read BIO that holds the response contents, which allows a response of indefinite
       length and may support streaming.  The caller is responsible for freeing the BIO pointer obtained.

       <b>OSSL_HTTP_get()</b> uses HTTP GET to obtain data from <u>bio</u> if non-NULL, else from the server contained in the
       <u>url</u>, and returns it as a BIO.  It supports redirection via HTTP status code 301 or 302.  It is meant for
       transfers with a single round trip, so does not support persistent connections.  If <u>bio</u> is non-NULL, any
       host and port components in the <u>url</u> are not used for connecting but the hostname is used, as usual, for
       the "Host" header.  Any userinfo and fragment components in the <u>url</u> are ignored.  Any query component is
       handled as part of the path component.  If the scheme component of the <u>url</u> is "https" a TLS connection is
       requested and the <u>bio_update_fn</u>, as described for <b>OSSL_HTTP_open()</b>, must be provided.  Also the remaining
       parameters are interpreted as described for <b>OSSL_HTTP_open()</b> and <b>OSSL_HTTP_set1_request()</b>, respectively.
       The caller is responsible for freeing the BIO pointer obtained.

       <b>OSSL_HTTP_transfer()</b> exchanges an HTTP request and response over a connection managed via <u>prctx</u> without
       supporting redirection.  It combines <b>OSSL_HTTP_open()</b>, <b>OSSL_HTTP_set1_request()</b>, <b>OSSL_HTTP_exchange()</b>,
       and <b>OSSL_HTTP_close()</b>.  If <u>prctx</u> is not NULL it reuses any open connection represented by a non-NULL
       <u>*prctx</u>.  It keeps the connection open if a persistent connection is requested or required and this was
       granted by the server, else it closes the connection and assigns NULL to <u>*prctx</u>.  The remaining
       parameters are interpreted as described for <b>OSSL_HTTP_open()</b> and <b>OSSL_HTTP_set1_request()</b>, respectively.
       The caller is responsible for freeing the BIO pointer obtained.

       <b>OSSL_HTTP_close()</b> closes the connection and releases <u>rctx</u>.  The <u>ok</u> parameter is passed to any BIO update
       function given during setup as described above for <b>OSSL_HTTP_open()</b>.  It must be 1 if no error occurred
       during the HTTP transfer and 0 otherwise.

</pre><h4><b>NOTES</b></h4><pre>
       The names of the environment variables used by this implementation: "http_proxy", "HTTP_PROXY",
       "https_proxy", "HTTPS_PROXY", "no_proxy", and "NO_PROXY", have been chosen for maximal compatibility with
       other HTTP client implementations such as wget, curl, and git.

       When built with tracing enabled, <b>OSSL_HTTP_transfer()</b> and all functions using it may be traced using
       <b>OSSL_TRACE_CATEGORY_HTTP</b>.  See also <b><a href="../man3/OSSL_trace_enabled.3.html">OSSL_trace_enabled</a></b>(3) and <b><a href="../man7/openssl-env.7.html">openssl-env</a></b>(7).

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>OSSL_HTTP_open()</b> returns on success a <b>OSSL_HTTP_REQ_CTX</b>, else NULL.

       <b>OSSL_HTTP_proxy_connect()</b> and <b>OSSL_HTTP_set1_request()</b> return 1 on success, 0 on error.

       On success, <b>OSSL_HTTP_exchange()</b>, <b>OSSL_HTTP_get()</b>, and <b>OSSL_HTTP_transfer()</b> return a memory BIO that
       buffers all the data received if an ASN.1-encoded response is expected, otherwise a BIO that may support
       streaming.  The BIO must be freed by the caller.  On failure, they return NULL.  Failure conditions
       include connection/transfer timeout, parse errors, etc.  The caller is responsible for freeing the BIO
       pointer obtained.

       <b>OSSL_HTTP_close()</b> returns 0 if anything went wrong while disconnecting, else 1.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/OSSL_HTTP_parse_url.3.html">OSSL_HTTP_parse_url</a></b>(3), <b><a href="../man3/BIO_new_connect.3.html">BIO_new_connect</a></b>(3), <b><a href="../man3/ASN1_item_i2d_mem_bio.3.html">ASN1_item_i2d_mem_bio</a></b>(3), <b><a href="../man3/ASN1_item_d2i_bio.3.html">ASN1_item_d2i_bio</a></b>(3),
       <b><a href="../man3/OSSL_HTTP_REQ_CTX_set_expected.3.html">OSSL_HTTP_REQ_CTX_set_expected</a></b>(3), <b><a href="../man3/OSSL_HTTP_is_alive.3.html">OSSL_HTTP_is_alive</a></b>(3), <b><a href="../man3/OSSL_trace_enabled.3.html">OSSL_trace_enabled</a></b>(3), and <b><a href="../man7/openssl-env.7.html">openssl-env</a></b>(7).

</pre><h4><b>HISTORY</b></h4><pre>
       All the functions described here were added in OpenSSL 3.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2019-2025 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                           <u><a href="../man3SSL/OSSL_HTTP_TRANSFER.3SSL.html">OSSL_HTTP_TRANSFER</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>