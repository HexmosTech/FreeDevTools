<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pmemkv_iterator - Iterator API for libpmemkv</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libpmemkv-dev">libpmemkv-dev_1.5.0-4build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>pmemkv_iterator</b> - Iterator API for libpmemkv

       This API is <b>EXPERIMENTAL</b> and might change.

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;libpmemkv.h&gt;

              int pmemkv_iterator_new(pmemkv_db *db, pmemkv_iterator **it);
              int pmemkv_write_iterator_new(pmemkv_db *db, pmemkv_write_iterator **it);

              void pmemkv_iterator_delete(pmemkv_iterator *it);
              void pmemkv_write_iterator_delete(pmemkv_write_iterator *it);

              int pmemkv_iterator_seek(pmemkv_iterator *it, const char *k, size_t kb);
              int pmemkv_iterator_seek_lower(pmemkv_iterator *it, const char *k, size_t kb);
              int pmemkv_iterator_seek_lower_eq(pmemkv_iterator *it, const char *k, size_t kb);
              int pmemkv_iterator_seek_higher(pmemkv_iterator *it, const char *k, size_t kb);
              int pmemkv_iterator_seek_higher_eq(pmemkv_iterator *it, const char *k, size_t kb);

              int pmemkv_iterator_seek_to_first(pmemkv_iterator *it);
              int pmemkv_iterator_seek_to_last(pmemkv_iterator *it);

              int pmemkv_iterator_is_next(pmemkv_iterator *it);
              int pmemkv_iterator_next(pmemkv_iterator *it);
              int pmemkv_iterator_prev(pmemkv_iterator *it);

              int pmemkv_iterator_key(pmemkv_iterator *it, const char **k, size_t *kb);

              int pmemkv_iterator_read_range(pmemkv_iterator *it, size_t pos, size_t n,
                                  const char **data, size_t *rb);
              int pmemkv_write_iterator_write_range(pmemkv_write_iterator *it, size_t pos, size_t n,
                                  char **data, size_t *wb);

              int pmemkv_write_iterator_commit(pmemkv_write_iterator *it);
              void pmemkv_write_iterator_abort(pmemkv_write_iterator *it);

       For general description of pmemkv and available engines see <b><a href="../man7/libpmemkv.7.html">libpmemkv</a></b>(7).  For description of pmemkv core
       API see <b><a href="../man3/libpmemkv.3.html">libpmemkv</a></b>(3).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Iterators provide methods to iterate over records in db.

       Both  iterator  types  (pmemkv_iterator  (read) and pmemkv_write_iterator) allow reading record’s key and
       value.   To  use  pmemkv_write_iterator  as  a  pmemkv_iterator  you  need  to  get  its  member   “iter”
       (write_it-&gt;iter).

       Example of calling pmemkv_iterator_seek_to_first() with both iterator types.

              /* read_it is already created, by pmemkv_iterator */
              int status = pmemkv_iterator_seek_to_first(read_it);

              /* write_it is already created, by pmemkv_write_iterator */
              int status = pmemkv_iterator_seek_to_first(write_it-&gt;iter);

       A pmemkv_write_iterator additionally can modify record’s value transactionally.

       Some of the functions are not guaranteed to be implemented by all engines.  If an engine does not support
       a certain function, it will return PMEMKV_STATUS_NOT_SUPPORTED.

       Holding simultaneously in the same thread more than one iterator is undefined behavior.

       <b>int</b> <b>pmemkv_iterator_new(pmemkv_db</b> <b>*db,</b> <b>pmemkv_iterator</b> <b>**it);</b>
              Creates a new pmemkv_iterator instance and stores a pointer to it in *it.

       <b>int</b> <b>pmemkv_write_iterator_new(pmemkv_db</b> <b>*db,</b> <b>pmemkv_write_iterator</b> <b>**it);</b>
              Creates a new pmemkv_write_iterator instance and stores a pointer to it in *it.

       <b>void</b> <b>pmemkv_iterator_delete(pmemkv_iterator</b> <b>*it);</b>
              Deletes pmemkv_iterator.

       <b>void</b> <b>pmemkv_write_iterator_delete(pmemkv_write_iterator</b> <b>*it);</b>
              Deletes pmemkv_write_iterator

       <b>int</b> <b>pmemkv_iterator_seek(pmemkv_iterator</b> <b>*it,</b> <b>const</b> <b>char</b> <b>*k,</b> <b>size_t</b> <b>kb);</b>
              Changes  iterator  position to the record with given key k of length kb.  If the record is present
              and no errors occurred, returns PMEMKV_STATUS_OK.  If  the  record  does  not  exist,  PMEMKV_STA‐
              TUS_NOT_FOUND  is  returned  and  the  iterator  position  is undefined.  It internally aborts all
              changes made to an element previously pointed by the iterator.

       <b>int</b> <b>pmemkv_iterator_seek_lower(pmemkv_iterator</b> <b>*it,</b> <b>const</b> <b>char</b> <b>*k,</b> <b>size_t</b> <b>kb);</b>
              Changes iterator position to the record with key lower than given key k  of  length  kb.   If  the
              record is present and no errors occurred, returns PMEMKV_STATUS_OK.  If the record does not exist,
              PMEMKV_STATUS_NOT_FOUND  is returned and the iterator position is undefined.  It internally aborts
              all changes made to an element previously pointed by the iterator.

       <b>int</b> <b>pmemkv_iterator_seek_lower_eq(pmemkv_iterator</b> <b>*it,</b> <b>const</b> <b>char</b> <b>*k,</b> <b>size_t</b> <b>kb);</b>
              Changes iterator position to the record with key equal or lower than given key k of length kb.  If
              the record is present and no errors occurred, returns PMEMKV_STATUS_OK.  If the  record  does  not
              exist,  PMEMKV_STATUS_NOT_FOUND is returned and the iterator position is undefined.  It internally
              aborts all changes made to an element previously pointed by the iterator.

       <b>int</b> <b>pmemkv_iterator_seek_higher(pmemkv_iterator</b> <b>*it,</b> <b>const</b> <b>char</b> <b>*k,</b> <b>size_t</b> <b>kb);</b>
              Changes iterator position to the record with key higher than given key k of  length  kb.   If  the
              record is present and no errors occurred, returns PMEMKV_STATUS_OK.  If the record does not exist,
              PMEMKV_STATUS_NOT_FOUND  is returned and the iterator position is undefined.  It internally aborts
              all changes made to an element previously pointed by the iterator.

       <b>int</b> <b>pmemkv_iterator_seek_higher_eq(pmemkv_iterator</b> <b>*it,</b> <b>const</b> <b>char</b> <b>*k,</b> <b>size_t</b> <b>kb);</b>
              Changes iterator position to the record with key equal or higher than given key k  of  length  kb.
              If the record is present and no errors occurred, returns PMEMKV_STATUS_OK.  If the record does not
              exist,  PMEMKV_STATUS_NOT_FOUND is returned and the iterator position is undefined.  It internally
              aborts all changes made to an element previously pointed by the iterator.

       <b>int</b> <b>pmemkv_iterator_seek_to_first(pmemkv_iterator</b> <b>*it);</b>
              Changes iterator position to the first record.  If db isn’t empty, and no errors occurred, returns
              PMEMKV_STATUS_OK.  If db is empty, PMEMKV_STATUS_NOT_FOUND is returned and the  iterator  position
              is undefined.  It internally aborts all changes made to an element previously pointed by the iter‐
              ator.

       <b>int</b> <b>pmemkv_iterator_seek_to_last(pmemkv_iterator</b> <b>*it);</b>
              Changes  iterator position to the last record.  If db isn’t empty, and no errors occurred, returns
              PMEMKV_STATUS_OK.  If db is empty, PMEMKV_STATUS_NOT_FOUND is returned and the  iterator  position
              is undefined.  It internally aborts all changes made to an element previously pointed by the iter‐
              ator.

       <b>int</b> <b>pmemkv_iterator_is_next(pmemkv_iterator</b> <b>*it);</b>
              Checks if there is a next record available.  If true is returned, it is guaranteed that pmemkv_it‐
              erator_next(it)  will  return  PMEMKV_STATUS_OK, otherwise iterator is already on the last element
              and pmemkv_iterator_next(it) will return PMEMKV_STATUS_NOT_FOUND.

       <b>int</b> <b>pmemkv_iterator_next(pmemkv_iterator</b> <b>*it);</b>
              Changes iterator position to the next record.  If the  next  record  exists,  returns  PMEMKV_STA‐
              TUS_OK,  otherwise PMEMKV_STATUS_NOT_FOUND is returned and the iterator position is undefined.  It
              internally aborts all changes made to an element previously pointed by the iterator.

       <b>int</b> <b>pmemkv_iterator_prev(pmemkv_iterator</b> <b>*it);</b>
              Changes iterator position to  the  previous  record.   If  the  previous  record  exists,  returns
              PMEMKV_STATUS_OK, otherwise PMEMKV_STATUS_NOT_FOUND is returned and the iterator position is unde‐
              fined.  It internally aborts all changes made to an element previously pointed by the iterator.

       <b>int</b> <b>pmemkv_iterator_key(pmemkv_iterator</b> <b>*it,</b> <b>const</b> <b>char</b> <b>**k,</b> <b>size_t</b> <b>*kb);</b>
              Assigns  record’s  key’s  address to k and key’s length to kb.  If the iterator is on an undefined
              position, calling this method is undefined behaviour.

       <b>int</b> <b>pmemkv_iterator_read_range(pmemkv_iterator</b> <b>*it,</b> <b>size_t</b> <b>pos,</b> <b>size_t</b> <b>n,</b> <b>const</b> <b>char</b> <b>**data,</b> <b>size_t</b> <b>*rb);</b>
              Allows getting record’s value’s range which can be only read.  You can  request  for  either  full
              value  or  only value’s subrange (n elements starting from pos).  Assigns pointer to the beginning
              of the requested range to data, and number of elements in range to rb.  If n is bigger than length
              of a value it’s automatically shrunk.  If the iterator is on an undefined position,  calling  this
              method is undefined behaviour.

       <b>int</b> <b>pmemkv_write_iterator_write_range(pmemkv_write_iterator</b> <b>*it,</b> <b>size_t</b> <b>pos,</b> <b>size_t</b> <b>n,</b> <b>char</b> <b>**data,</b>
       <b>size_t</b> <b>*wb);</b>
              Allows getting record’s value’s range which can be modified.  You can request for either full val‐
              ue  or  only value’s subrange (n elements starting from pos).  Assigns pointer to the beginning of
              the requested range to data, and number of elements in range to wb.  If n is bigger than length of
              a value it’s automatically shrunk.  Changes made on a requested range  are  not  persistent  until
              <u>pmemkv_write_iterator_commit()</u>  is  called.   If the iterator is on an undefined position, calling
              this method is undefined behaviour.

       <b>int</b> <b>pmemkv_write_iterator_commit(pmemkv_write_iterator</b> <b>*it);</b>
              Commits modifications made on the current record.  Calling this method is the  only  way  to  save
              modifications  made  by  the  iterator on the current record.  You need to call this method before
              changing the iterator position, otherwise modifications will be automatically aborted.

       <b>void</b> <b>pmemkv_write_iterator_abort(pmemkv_write_iterator</b> <b>*it);</b>
              Aborts uncommitted modifications made on the current record.

   <b>ERRORS</b>
       Each function, except for <u>pmemkv_iterator_delete()</u>, <u>pmemkv_write_iterator_delete()</u> and <u>pmemkv_write_iter‐</u>
       <u>ator_abort()</u>, returns one of the pmemkv status codes.  To check possible options see <b><a href="../man3/libpmemkv.3.html">libpmemkv</a></b>(3).

</pre><h4><b>EXAMPLE</b></h4><pre>
       The following example is taken from examples/pmemkv_iterator_c directory.

       Usage of basic iterator functions to iterate over all records and modify one of them.

              #include "libpmemkv.h"

              #include &lt;<a href="file:/usr/include/assert.h">assert.h</a>&gt;
              #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
              #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
              #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;

              #define ASSERT(expr)                                                                     \
                  do {                                                                             \
                      if (!(expr))                                                             \
                          puts(pmemkv_errormsg());                                         \
                      assert(expr);                                                            \
                  } while (0)

              #define <a href="../manmsg/LOG.msg.html">LOG</a>(msg) <a href="../manmsg/puts.msg.html">puts</a>(msg)

              static const uint64_t SIZE = 1024UL * 1024UL * 1024UL;

              int main(int argc, char *argv[])
              {
                  if (argc &lt; 2) {
                      fprintf(stderr, "Usage: %s file\n", argv[0]);
                      <a href="../man1/exit.1.html">exit</a>(1);
                  }

                  const size_t n_elements = 10;
                  char buffer[64];

                  /* See <a href="../man3/libpmemkv_config.3.html">libpmemkv_config</a>(3) for more detailed example of config creation */
                  LOG("Creating config");
                  pmemkv_config *cfg = pmemkv_config_new();
                  ASSERT(cfg != NULL);

                  int s = pmemkv_config_put_path(cfg, argv[1]);
                  ASSERT(s == PMEMKV_STATUS_OK);
                  s = pmemkv_config_put_size(cfg, SIZE);
                  ASSERT(s == PMEMKV_STATUS_OK);
                  s = pmemkv_config_put_create_if_missing(cfg, true);
                  ASSERT(s == PMEMKV_STATUS_OK);

                  LOG("Opening pmemkv database with 'radix' engine");
                  pmemkv_db *db = NULL;
                  s = pmemkv_open("radix", cfg, &amp;db);
                  ASSERT(s == PMEMKV_STATUS_OK);
                  ASSERT(db != NULL);

                  LOG("Putting new keys");
                  for (size_t i = 0; i &lt; n_elements; ++i) {
                      char key[10];
                      const char *value = "value";
                      sprintf(key, "key%zu", i);
                      s = pmemkv_put(db, key, strlen(key), value, strlen(value));
                      ASSERT(s == PMEMKV_STATUS_OK);
                  }

                  /* get a new read iterator */
                  pmemkv_iterator *it;
                  s = pmemkv_iterator_new(db, &amp;it);
                  ASSERT(s == PMEMKV_STATUS_OK);

                  LOG("Iterate from first to last element");
                  s = pmemkv_iterator_seek_to_first(it);
                  ASSERT(s == PMEMKV_STATUS_OK);

                  size_t element_number = 0;
                  do {
                      const char *str;
                      size_t cnt;
                      /* read a key */
                      s = pmemkv_iterator_key(it, &amp;str, &amp;cnt);
                      ASSERT(s == PMEMKV_STATUS_OK);
                      sprintf(buffer, "Key %zu = %s", element_number++, str);
                      LOG(buffer);
                  } while (pmemkv_iterator_next(it) != PMEMKV_STATUS_NOT_FOUND);

                  /* iterator must be deleted manually */
                  pmemkv_iterator_delete(it);

                  /* get a new write_iterator */
                  pmemkv_write_iterator *w_it;
                  s = pmemkv_write_iterator_new(db, &amp;w_it);
                  ASSERT(s == PMEMKV_STATUS_OK);

                  /* if you want to get a pmemkv_iterator (read iterator) from a
                   * pmemkv_write_iterator, you should do: write_it-&gt;iter */
                  s = pmemkv_iterator_seek_to_last(w_it-&gt;iter);
                  ASSERT(s == PMEMKV_STATUS_OK);

                  /* get a write range, to modify last element's value */
                  char *data;
                  size_t cnt;
                  s = pmemkv_write_iterator_write_range(w_it, 0, 5, &amp;data, &amp;cnt);
                  ASSERT(s == PMEMKV_STATUS_OK);

                  for (size_t i = 0; i &lt; cnt; ++i)
                      data[i] = 'x';

                  /* commit changes */
                  s = pmemkv_write_iterator_commit(w_it);
                  ASSERT(s == PMEMKV_STATUS_OK);

                  /* get a read range, to read modified value */
                  const char *str;
                  s = pmemkv_iterator_read_range(w_it-&gt;iter, 0, 5, &amp;str, &amp;cnt);
                  ASSERT(s == PMEMKV_STATUS_OK);

                  /* verify a modified value */
                  ASSERT(strcmp(str, "xxxxx") == 0);
                  sprintf(buffer, "Modified value = %s", str);
                  LOG(buffer);

                  /* iterator must be deleted manually */
                  pmemkv_write_iterator_delete(w_it);

                  LOG("Closing database");
                  pmemkv_close(db);

                  return 0;
              }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/libpmemkv.7.html">libpmemkv</a></b>(7), <b><a href="../man3/libpmemkv.3.html">libpmemkv</a></b>(3) and <b>&lt;https://pmem.io&gt;</b>

PMEMKV - pmemkv version 1.5.0                      2022-03-09                                 <u><a href="../man3/PMEMKV_ITERATOR.3.html">PMEMKV_ITERATOR</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>