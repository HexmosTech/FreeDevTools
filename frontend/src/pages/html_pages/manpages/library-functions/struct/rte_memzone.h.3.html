<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rte_memzone.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dpdk-doc">dpdk-doc_24.11.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rte_memzone.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;rte_memory.h&gt;
       #include &lt;rte_common.h&gt;

   <b>Data</b> <b>Structures</b>
       struct <b>rte_memzone</b>

   <b>Macros</b>
       #define <b>RTE_MEMZONE_2MB</b>   0x00000001
       #define <b>RTE_MEMZONE_1GB</b>   0x00000002
       #define <b>RTE_MEMZONE_16MB</b>   0x00000100
       #define <b>RTE_MEMZONE_16GB</b>   0x00000200
       #define <b>RTE_MEMZONE_256KB</b>   0x00010000
       #define <b>RTE_MEMZONE_256MB</b>   0x00020000
       #define <b>RTE_MEMZONE_512MB</b>   0x00040000
       #define <b>RTE_MEMZONE_4GB</b>   0x00080000
       #define <b>RTE_MEMZONE_SIZE_HINT_ONLY</b>   0x00000004
       #define <b>RTE_MEMZONE_IOVA_CONTIG</b>   0x00100000
       #define <b>RTE_MEMZONE_NAMESIZE</b>   32

   <b>Functions</b>
       int <b>rte_memzone_max_set</b> (size_t max)
       size_t <b>rte_memzone_max_get</b> (void)
       const struct <b>rte_memzone</b> * <b>rte_memzone_reserve</b> (const char *name, size_t len, int socket_id, unsigned
           flags)
       const struct <b>rte_memzone</b> * <b>rte_memzone_reserve_aligned</b> (const char *name, size_t len, int socket_id,
           unsigned flags, unsigned align)
       const struct <b>rte_memzone</b> * <b>rte_memzone_reserve_bounded</b> (const char *name, size_t len, int socket_id,
           unsigned flags, unsigned align, unsigned bound)
       int <b>rte_memzone_free</b> (const struct <b>rte_memzone</b> *mz)
       const struct <b>rte_memzone</b> * <b>rte_memzone_lookup</b> (const char *name)
       void <b>rte_memzone_dump</b> (FILE *f)
       void <b>rte_memzone_walk</b> (void(*func)(const struct <b>rte_memzone</b> *, void *arg), void *arg)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       RTE Memzone

       The goal of the memzone allocator is to reserve contiguous portions of physical memory. These zones are
       identified by a name.

       The memzone descriptors are shared by all partitions and are located in a known place of physical memory.
       This zone is accessed using rte_eal_get_configuration(). The lookup (by name) of a memory zone can be
       done in any partition and returns the same physical address.

       A reserved memory zone cannot be unreserved. The reservation shall be done at initialization time only.

       Definition in file <b>rte_memzone.h</b>.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>RTE_MEMZONE_2MB</b>   <b>0x00000001</b>
       Use 2MB pages.

       Definition at line <b>33</b> of file <b>rte_memzone.h</b>.

   <b>#define</b> <b>RTE_MEMZONE_1GB</b>   <b>0x00000002</b>
       Use 1GB pages.

       Definition at line <b>34</b> of file <b>rte_memzone.h</b>.

   <b>#define</b> <b>RTE_MEMZONE_16MB</b>   <b>0x00000100</b>
       Use 16MB pages.

       Definition at line <b>35</b> of file <b>rte_memzone.h</b>.

   <b>#define</b> <b>RTE_MEMZONE_16GB</b>   <b>0x00000200</b>
       Use 16GB pages.

       Definition at line <b>36</b> of file <b>rte_memzone.h</b>.

   <b>#define</b> <b>RTE_MEMZONE_256KB</b>   <b>0x00010000</b>
       Use 256KB pages.

       Definition at line <b>37</b> of file <b>rte_memzone.h</b>.

   <b>#define</b> <b>RTE_MEMZONE_256MB</b>   <b>0x00020000</b>
       Use 256MB pages.

       Definition at line <b>38</b> of file <b>rte_memzone.h</b>.

   <b>#define</b> <b>RTE_MEMZONE_512MB</b>   <b>0x00040000</b>
       Use 512MB pages.

       Definition at line <b>39</b> of file <b>rte_memzone.h</b>.

   <b>#define</b> <b>RTE_MEMZONE_4GB</b>   <b>0x00080000</b>
       Use 4GB pages.

       Definition at line <b>40</b> of file <b>rte_memzone.h</b>.

   <b>#define</b> <b>RTE_MEMZONE_SIZE_HINT_ONLY</b>   <b>0x00000004</b>
       Use available page size

       Definition at line <b>41</b> of file <b>rte_memzone.h</b>.

   <b>#define</b> <b>RTE_MEMZONE_IOVA_CONTIG</b>   <b>0x00100000</b>
       Ask for IOVA-contiguous memzone.

       Definition at line <b>42</b> of file <b>rte_memzone.h</b>.

   <b>#define</b> <b>RTE_MEMZONE_NAMESIZE</b>   <b>32</b>
       Maximum length of memory zone name.

       Definition at line <b>50</b> of file <b>rte_memzone.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>int</b> <b>rte_memzone_max_set</b> <b>(size_t</b> <b>max)</b>
       Set the maximum number of memzones.

       This function can only be called prior to <b>rte_eal_init()</b>.

       <b>Parameters</b>
           <u>max</u> Maximum number of memzones.

       <b>Returns</b>
           0 on success, -1 otherwise.

   <b>size_t</b> <b>rte_memzone_max_get</b> <b>(void)</b>
       Get the maximum number of memzones.

       <b>Note</b>
           : The maximum value will not change after calling <b>rte_eal_init()</b>.

       <b>Returns</b>
           Maximum number of memzones.

   <b>const</b> <b>struct</b> <b>rte_memzone</b> <b>*</b> <b>rte_memzone_reserve</b> <b>(const</b> <b>char</b> <b>*</b> <b>name,</b> <b>size_t</b> <b>len,</b> <b>int</b> <b>socket_id,</b> <b>unsigned</b> <b>flags)</b>

       Reserve a portion of physical memory.

       This function reserves some memory and returns a pointer to a correctly filled memzone descriptor. If the
       allocation cannot be done, return NULL.

       <b>Note</b>
           Reserving memzones with len set to 0 will only attempt to allocate memzones from memory that is
           already available. It will not trigger any new allocations.

           : When reserving memzones with len set to 0, it is preferable to also set a valid socket_id. Setting
           socket_id to SOCKET_ID_ANY is supported, but will likely not yield expected results. Specifically,
           the resulting memzone may not necessarily be the biggest memzone available, but rather biggest
           memzone available on socket id corresponding to an lcore from which reservation was called.

       <b>Parameters</b>
           <u>name</u> The name of the memzone. If it already exists, the function will fail and return NULL.
           <u>len</u> The size of the memory to be reserved. If it is 0, the biggest contiguous zone will be reserved.
           <u>socket_id</u> The socket identifier in the case of NUMA. The value can be SOCKET_ID_ANY if there is no
           NUMA constraint for the reserved zone.
           <u>flags</u> The flags parameter is used to request memzones to be taken from specifically sized hugepages.

           • RTE_MEMZONE_2MB - Reserved from 2MB pages

           • RTE_MEMZONE_1GB - Reserved from 1GB pages

           • RTE_MEMZONE_16MB - Reserved from 16MB pages

           • RTE_MEMZONE_16GB - Reserved from 16GB pages

           • RTE_MEMZONE_256KB - Reserved from 256KB pages

           • RTE_MEMZONE_256MB - Reserved from 256MB pages

           • RTE_MEMZONE_512MB - Reserved from 512MB pages

           • RTE_MEMZONE_4GB - Reserved from 4GB pages

           • RTE_MEMZONE_SIZE_HINT_ONLY  -  Allow alternative page size to be used if the requested page size is
             unavailable. If this flag is not set, the  function  will  return  error  on  an  unavailable  size
             request.

           • RTE_MEMZONE_IOVA_CONTIG  -  Ensure  reserved memzone is IOVA-contiguous. This option should be used
             when allocating memory intended for hardware rings etc.

       <b>Returns</b>
           A pointer to a correctly-filled read-only memzone descriptor,  or  NULL  on  error.  On  error  case,
           rte_errno will be set appropriately:

           • E_RTE_NO_CONFIG - function could not get pointer to rte_config structure

           • ENOSPC - the maximum number of memzones has already been allocated

           • EEXIST - a memzone with the same name already exists

           • ENOMEM - no appropriate memory area found in which to create memzone

           • EINVAL - invalid parameters

   <b>const</b>  <b>struct</b>  <b>rte_memzone</b>  <b>*</b>  <b>rte_memzone_reserve_aligned</b>  <b>(const</b>  <b>char</b>  <b>*</b>  <b>name,</b> <b>size_t</b> <b>len,</b> <b>int</b> <b>socket_id,</b>
       <b>unsigned</b> <b>flags,</b> <b>unsigned</b> <b>align)</b>
       Reserve a portion of physical memory with alignment on a specified boundary.

       This function reserves some memory with alignment on a specified boundary, and returns  a  pointer  to  a
       correctly  filled memzone descriptor. If the allocation cannot be done or if the alignment is not a power
       of 2, returns NULL.

       <b>Note</b>
           Reserving memzones with len set to 0 will only attempt to  allocate  memzones  from  memory  that  is
           already available. It will not trigger any new allocations.

           :  When reserving memzones with len set to 0, it is preferable to also set a valid socket_id. Setting
           socket_id to SOCKET_ID_ANY is supported, but will likely not yield  expected  results.  Specifically,
           the  resulting  memzone  may  not  necessarily  be  the biggest memzone available, but rather biggest
           memzone available on socket id corresponding to an lcore from which reservation was called.

       <b>Parameters</b>
           <u>name</u> The name of the memzone. If it already exists, the function will fail and return NULL.
           <u>len</u> The size of the memory to be reserved. If it is 0, the biggest contiguous zone will be reserved.
           <u>socket_id</u> The socket identifier in the case of NUMA. The value can be SOCKET_ID_ANY if  there  is  no
           NUMA constraint for the reserved zone.
           <u>flags</u> The flags parameter is used to request memzones to be taken from specifically sized hugepages.

           • RTE_MEMZONE_2MB - Reserved from 2MB pages

           • RTE_MEMZONE_1GB - Reserved from 1GB pages

           • RTE_MEMZONE_16MB - Reserved from 16MB pages

           • RTE_MEMZONE_16GB - Reserved from 16GB pages

           • RTE_MEMZONE_256KB - Reserved from 256KB pages

           • RTE_MEMZONE_256MB - Reserved from 256MB pages

           • RTE_MEMZONE_512MB - Reserved from 512MB pages

           • RTE_MEMZONE_4GB - Reserved from 4GB pages

           • RTE_MEMZONE_SIZE_HINT_ONLY  -  Allow alternative page size to be used if the requested page size is
             unavailable. If this flag is not set, the  function  will  return  error  on  an  unavailable  size
             request.

           • RTE_MEMZONE_IOVA_CONTIG  -  Ensure  reserved memzone is IOVA-contiguous. This option should be used
             when allocating memory intended for hardware rings etc.

           <u>align</u> Alignment for resulting memzone. Must be a power of 2.

       <b>Returns</b>
           A pointer to a correctly-filled read-only memzone descriptor,  or  NULL  on  error.  On  error  case,
           rte_errno will be set appropriately:

           • E_RTE_NO_CONFIG - function could not get pointer to rte_config structure

           • ENOSPC - the maximum number of memzones has already been allocated

           • EEXIST - a memzone with the same name already exists

           • ENOMEM - no appropriate memory area found in which to create memzone

           • EINVAL - invalid parameters

   <b>const</b>  <b>struct</b>  <b>rte_memzone</b>  <b>*</b>  <b>rte_memzone_reserve_bounded</b>  <b>(const</b>  <b>char</b>  <b>*</b>  <b>name,</b> <b>size_t</b> <b>len,</b> <b>int</b> <b>socket_id,</b>
       <b>unsigned</b> <b>flags,</b> <b>unsigned</b> <b>align,</b> <b>unsigned</b> <b>bound)</b>
       Reserve a portion of physical memory with specified alignment and boundary.

       This function reserves some memory with specified alignment and boundary, and  returns  a  pointer  to  a
       correctly filled memzone descriptor. If the allocation cannot be done or if the alignment or boundary are
       not  a  power  of  2,  returns NULL. Memory buffer is reserved in a way, that it wouldn't cross specified
       boundary. That implies that requested length should be less or equal then boundary.

       <b>Note</b>
           Reserving memzones with len set to 0 will only attempt to  allocate  memzones  from  memory  that  is
           already available. It will not trigger any new allocations.

           :  When reserving memzones with len set to 0, it is preferable to also set a valid socket_id. Setting
           socket_id to SOCKET_ID_ANY is supported, but will likely not yield  expected  results.  Specifically,
           the  resulting  memzone  may  not  necessarily  be  the biggest memzone available, but rather biggest
           memzone available on socket id corresponding to an lcore from which reservation was called.

       <b>Parameters</b>
           <u>name</u> The name of the memzone. If it already exists, the function will fail and return NULL.
           <u>len</u> The size of the memory to be reserved. If it is 0, the biggest contiguous zone will be reserved.
           <u>socket_id</u> The socket identifier in the case of NUMA. The value can be SOCKET_ID_ANY if  there  is  no
           NUMA constraint for the reserved zone.
           <u>flags</u> The flags parameter is used to request memzones to be taken from specifically sized hugepages.

           • RTE_MEMZONE_2MB - Reserved from 2MB pages

           • RTE_MEMZONE_1GB - Reserved from 1GB pages

           • RTE_MEMZONE_16MB - Reserved from 16MB pages

           • RTE_MEMZONE_16GB - Reserved from 16GB pages

           • RTE_MEMZONE_256KB - Reserved from 256KB pages

           • RTE_MEMZONE_256MB - Reserved from 256MB pages

           • RTE_MEMZONE_512MB - Reserved from 512MB pages

           • RTE_MEMZONE_4GB - Reserved from 4GB pages

           • RTE_MEMZONE_SIZE_HINT_ONLY  -  Allow alternative page size to be used if the requested page size is
             unavailable. If this flag is not set, the  function  will  return  error  on  an  unavailable  size
             request.

           • RTE_MEMZONE_IOVA_CONTIG  -  Ensure  reserved memzone is IOVA-contiguous. This option should be used
             when allocating memory intended for hardware rings etc.

           <u>align</u> Alignment for resulting memzone. Must be a power of 2.
           <u>bound</u> Boundary for resulting memzone. Must be a power of 2 or zero. Zero value  implies  no  boundary
           condition.

       <b>Returns</b>
           A  pointer  to  a  correctly-filled  read-only  memzone  descriptor, or NULL on error. On error case,
           rte_errno will be set appropriately:

           • E_RTE_NO_CONFIG - function could not get pointer to rte_config structure

           • ENOSPC - the maximum number of memzones has already been allocated

           • EEXIST - a memzone with the same name already exists

           • ENOMEM - no appropriate memory area found in which to create memzone

           • EINVAL - invalid parameters

   <b>int</b> <b>rte_memzone_free</b> <b>(const</b> <b>struct</b> <b>rte_memzone</b> <b>*</b> <b>mz)</b>
       Free a memzone.

       <b>Parameters</b>
           <u>mz</u> A pointer to the memzone

       <b>Returns</b>
           -EINVAL - invalid parameter. 0 - success

   <b>const</b> <b>struct</b> <b>rte_memzone</b> <b>*</b> <b>rte_memzone_lookup</b> <b>(const</b> <b>char</b> <b>*</b> <b>name)</b>
       Lookup for a memzone.

       Get a pointer to a descriptor of an already reserved memory zone identified  by  the  name  given  as  an
       argument.

       <b>Parameters</b>
           <u>name</u> The name of the memzone.

       <b>Returns</b>
           A pointer to a read-only memzone descriptor.

   <b>void</b> <b>rte_memzone_dump</b> <b>(FILE</b> <b>*</b> <b>f)</b>
       Dump all reserved memzones to a file.

       <b>Parameters</b>
           <u>f</u> A pointer to a file for output

   <b>void</b> <b>rte_memzone_walk</b> <b>(void(*)(const</b> <b>struct</b> <b>rte_memzone</b> <b>*,</b> <b>void</b> <b>*arg)</b> <b>func,</b> <b>void</b> <b>*</b> <b>arg)</b>
       Walk list of all memzones

       <b>Parameters</b>
           <u>func</u> Iterator function
           <u>arg</u> Argument passed to iterator

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for DPDK from the source code.

DPDK                                             Version 24.11.2                                <u><a href="../man3/rte_memzone.h.3.html">rte_memzone.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>