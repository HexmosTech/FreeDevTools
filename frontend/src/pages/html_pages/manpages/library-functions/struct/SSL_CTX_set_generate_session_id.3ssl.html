<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSL_CTX_set_generate_session_id, SSL_set_generate_session_id, SSL_has_matching_session_id, GEN_SESSION_CB</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SSL_CTX_set_generate_session_id, SSL_set_generate_session_id, SSL_has_matching_session_id, GEN_SESSION_CB
       - manipulate generation of SSL session IDs (server only)

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/ssl.h&gt;

        typedef int (*GEN_SESSION_CB)(SSL *ssl, unsigned char *id,
                                      unsigned int *id_len);

        int SSL_CTX_set_generate_session_id(SSL_CTX *ctx, GEN_SESSION_CB cb);
        int SSL_set_generate_session_id(SSL *ssl, GEN_SESSION_CB, cb);
        int SSL_has_matching_session_id(const SSL *ssl, const unsigned char *id,
                                        unsigned int id_len);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>SSL_CTX_set_generate_session_id()</b> sets the callback function for generating new session ids for SSL/TLS
       sessions for <b>ctx</b> to be <b>cb</b>.

       <b>SSL_set_generate_session_id()</b> sets the callback function for generating new session ids for SSL/TLS
       sessions for <b>ssl</b> to be <b>cb</b>.

       <b>SSL_has_matching_session_id()</b> checks, whether a session with id <b>id</b> (of length <b>id_len</b>) is already
       contained in the internal session cache of the parent context of <b>ssl</b>.

</pre><h4><b>NOTES</b></h4><pre>
       When a new session is established between client and server, the server generates a session id. The
       session id is an arbitrary sequence of bytes.  The length of the session id is between 1 and 32 bytes.
       The session id is not security critical but must be unique for the server. Additionally, the session id
       is transmitted in the clear when reusing the session so it must not contain sensitive information.

       Without a callback being set, an OpenSSL server will generate a unique session id from pseudo random
       numbers of the maximum possible length.  Using the callback function, the session id can be changed to
       contain additional information like e.g. a host id in order to improve load balancing or external caching
       techniques.

       The callback function receives a pointer to the memory location to put <b>id</b> into and a pointer to the
       maximum allowed length <b>id_len</b>. The buffer at location <b>id</b> is only guaranteed to have the size <b>id_len</b>.  The
       callback is only allowed to generate a shorter id and reduce <b>id_len</b>; the callback <b>must</b> <b>never</b> increase
       <b>id_len</b> or write to the location <b>id</b> exceeding the given limit.

       The location <b>id</b> is filled with 0x00 before the callback is called, so the callback may only fill part of
       the possible length and leave <b>id_len</b> untouched while maintaining reproducibility.

       Since the sessions must be distinguished, session ids must be unique.  Without the callback a random
       number is used, so that the probability of generating the same session id is extremely small (2^256 for
       SSLv3/TLSv1).  In order to assure the uniqueness of the generated session id, the callback must call
       <b>SSL_has_matching_session_id()</b> and generate another id if a conflict occurs.  If an id conflict is not
       resolved, the handshake will fail.  If the application codes e.g. a unique host id, a unique process
       number, and a unique sequence number into the session id, uniqueness could easily be achieved without
       randomness added (it should however be taken care that no confidential information is leaked this way).
       If the application can not guarantee uniqueness, it is recommended to use the maximum <b>id_len</b> and fill in
       the bytes not used to code special information with random data to avoid collisions.

       <b>SSL_has_matching_session_id()</b> will only query the internal session cache, not the external one. Since the
       session id is generated before the handshake is completed, it is not immediately added to the cache. If
       another thread is using the same internal session cache, a race condition can occur in that another
       thread generates the same session id.  Collisions can also occur when using an external session cache,
       since the external cache is not tested with <b>SSL_has_matching_session_id()</b> and the same race condition
       applies.

       The callback must return 0 if it cannot generate a session id for whatever reason and return 1 on
       success.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>SSL_CTX_set_generate_session_id()</b> and <b>SSL_set_generate_session_id()</b> return 1 on success and 0 for
       failure.

       <b>SSL_has_matching_session_id()</b> returns 1 if another session with the same id is already in the cache, or 0
       otherwise.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The callback function listed will generate a session id with the server id given, and will fill the rest
       with pseudo random bytes:

        const char session_id_prefix = "www-18";

        #define MAX_SESSION_ID_ATTEMPTS 10
        static int generate_session_id(SSL *ssl, unsigned char *id,
                                       unsigned int *id_len)
        {
            unsigned int count = 0;

            do {
                RAND_pseudo_bytes(id, *id_len);
                /*
                 * Prefix the session_id with the required prefix. NB: If our
                 * prefix is too long, clip it - but there will be worse effects
                 * anyway, e.g. the server could only possibly create 1 session
                 * ID (i.e. the prefix!) so all future session negotiations will
                 * fail due to conflicts.
                 */
                memcpy(id, session_id_prefix, strlen(session_id_prefix) &lt; *id_len ?
                                              strlen(session_id_prefix) : *id_len);
            } while (SSL_has_matching_session_id(ssl, id, *id_len)
                      &amp;&amp; ++count &lt; MAX_SESSION_ID_ATTEMPTS);
            if (count &gt;= MAX_SESSION_ID_ATTEMPTS)
                return 0;
            return 1;
        }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/ssl.7.html">ssl</a></b>(7), <b><a href="../man3/SSL_get_version.3.html">SSL_get_version</a></b>(3)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2001-2020 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04              <u><a href="../man3SSL/SSL_CTX_SET_GENERATE_SESSION_ID.3SSL.html">SSL_CTX_SET_GENERATE_SESSION_ID</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>