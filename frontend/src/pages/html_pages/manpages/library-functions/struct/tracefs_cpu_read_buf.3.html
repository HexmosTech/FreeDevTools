<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tracefs_cpu_read_buf, tracefs_cpu_buffered_read_buf, tracefs_cpu_flush_buf - Reading trace_pipe_raw data</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtracefs-doc">libtracefs-doc_1.8.1-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tracefs_cpu_read_buf, tracefs_cpu_buffered_read_buf, tracefs_cpu_flush_buf - Reading trace_pipe_raw data
       returning a kbuffer

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tracefs.h&gt;</b>

       struct kbuffer *<b>tracefs_cpu_read_buf</b>(struct tracefs_cpu *<u>tcpu</u>, bool <u>nonblock</u>);
       struct kbuffer *<b>tracefs_cpu_buffered_read_buf</b>(struct tracefs_cpu *<u>tcpu</u>, bool <u>nonblock</u>);
       struct kbuffer *<b>tracefs_cpu_flush_buf</b>(struct tracefs_cpu *<u>tcpu</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This set of APIs can be used to read the raw data from the trace_pipe_raw files in the tracefs file
       system and return a kbuffer structure to read it with.

       The <b>tracefs_cpu_read_buf()</b> reads the trace_pipe_raw files associated to <u>tcpu</u> and returns a kbuffer
       structure that can be used to iterate the events. If <u>nonblock</u> is set, and thereâ€™s no data available, it
       will return immediately. Otherwise depending on how <u>tcpu</u> was opened, it will block. If <u>tcpu</u> was opened
       with nonblock set, then this <u>nonblock</u> will make no difference.

       The <b>tracefs_cpu_buffered_read_buf()</b> is basically the same as <b>tracefs_cpu_read_buf()</b> except that it uses a
       pipe through splice to buffer reads. This will batch reads keeping the reading from the ring buffer less
       intrusive to the system, as just reading all the time can cause quite a disturbance. Note, one difference
       between this and <b>tracefs_cpu_read()</b> is that it will read only in sub buffer pages. If the ring buffer has
       not filled a page, then it will not return anything, even with <u>nonblock</u> set. Calls to
       <b>tracefs_cpu_flush_buf()</b> or <b>tracefs_cpu_flush()</b> should be done to read the rest of the file at the end of
       the trace.

       The <b>tracefs_cpu_flush_buf()</b> reads the trace_pipe_raw file associated by the <u>tcpu</u> and puts it into <u>buffer</u>,
       which must be the size of the sub buffer which is retrieved. This should be called at the end of tracing
       to get the rest of the data. This call will convert the file descriptor of trace_pipe_raw into
       non-blocking mode.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The functions <b>tracefs_cpu_read_buf()</b>, tracefs_cpu_buffered_read_buf()* and <b>tracefs_cpu_flush()</b> returns a
       kbuffer descriptor that can be iterated over to find the events. Note, this descriptor is part of the
       tracefs_cpu structure and should not be freed. It will be freed. It returns NULL on error or if nonblock
       is set and there are no events available. In the case of no events, errno will be set with EAGAIN.

</pre><h4><b>EXAMPLE</b></h4><pre>
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/ctype.h">ctype.h</a>&gt;
           #include &lt;tracefs.h&gt;

           static void read_page(struct tep_handle *tep, struct kbuffer *kbuf)
           {
                   static struct trace_seq seq;
                   struct tep_record record;

                   if (seq.buffer)
                           trace_seq_reset(&amp;seq);
                   else
                           trace_seq_init(&amp;seq);

                   while ((record.data = kbuffer_read_event(kbuf, &amp;record.ts))) {
                           record.size = kbuffer_event_size(kbuf);
                           kbuffer_next_event(kbuf, NULL);
                           tep_print_event(tep, &amp;seq, &amp;record,
                                           "%s-%d %9d\t%s: %s\n",
                                           TEP_PRINT_COMM,
                                           TEP_PRINT_PID,
                                           TEP_PRINT_TIME,
                                           TEP_PRINT_NAME,
                                           TEP_PRINT_INFO);
                           trace_seq_do_printf(&amp;seq);
                           trace_seq_reset(&amp;seq);
                   }
           }

           int main (int argc, char **argv)
           {
                   struct tracefs_cpu *tcpu;
                   struct tep_handle *tep;
                   struct kbuffer *kbuf;
                   int cpu;

                   if (argc &lt; 2 || !isdigit(argv[1][0])) {
                           printf("usage: %s cpu\n\n", argv[0]);
                           exit(-1);
                   }

                   cpu = atoi(argv[1]);

                   tep = tracefs_local_events(NULL);
                   if (!tep) {
                           perror("Reading trace event formats");
                           exit(-1);
                   }

                   tcpu = tracefs_cpu_open(NULL, cpu, 0);
                   if (!tcpu) {
                           perror("Open CPU 0 file");
                           exit(-1);
                   }

                   while ((kbuf = tracefs_cpu_buffered_read_buf(tcpu, true))) {
                           read_page(tep, kbuf);
                   }

                   kbuf = tracefs_cpu_flush_buf(tcpu);
                   if (kbuf)
                           read_page(tep, kbuf);

                   tracefs_cpu_close(tcpu);
                   tep_free(tep);

                   return 0;
           }

</pre><h4><b>FILES</b></h4><pre>
           <b>tracefs.h</b>
                   Header file to include in order to have access to the library APIs.
           <b>-ltracefs</b>
                   Linker switch to add when building a program that uses the library.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/tracefs_cpu_open.3.html">tracefs_cpu_open</a></b>(3) <b><a href="../man3/tracefs_cpu_close.3.html">tracefs_cpu_close</a></b>(3) <b><a href="../man3/tracefs_cpu_read.3.html">tracefs_cpu_read</a></b>(3) <b><a href="../man3/tracefs_cpu_buffered_read.3.html">tracefs_cpu_buffered_read</a></b>(3)
       <b><a href="../man3/tracefs_cpu_flush.3.html">tracefs_cpu_flush</a></b>(3) <b><a href="../man3/libtracefs.3.html">libtracefs</a></b>(3), <b><a href="../man3/libtraceevent.3.html">libtraceevent</a></b>(3), <b><a href="../man1/trace-cmd.1.html">trace-cmd</a></b>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
           <b>Steven</b> <b>Rostedt</b> &lt;<b><a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a></b>[1]&gt;

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<b><a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a></b>[2]&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       libtracefs is Free Software licensed under the GNU LGPL 2.1

</pre><h4><b>RESOURCES</b></h4><pre>
       <b>https://git.kernel.org/pub/scm/libs/libtrace/libtracefs.git/</b>

</pre><h4><b>COPYING</b></h4><pre>
       Copyright (C) 2022 Google, Inc. Free use of this software is granted under the terms of the GNU Public
       License (GPL).

</pre><h4><b>NOTES</b></h4><pre>
        1. <a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a>
           <a href="mailto:rostedt@goodmis.org">mailto:rostedt@goodmis.org</a>

        2. <a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a>
           <a href="mailto:linux-trace-devel@vger.kernel.org">mailto:linux-trace-devel@vger.kernel.org</a>

libtracefs 1.8.1                                   06/05/2025                                      <u><a href="../man3/LIBTRACEFS.3.html">LIBTRACEFS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>