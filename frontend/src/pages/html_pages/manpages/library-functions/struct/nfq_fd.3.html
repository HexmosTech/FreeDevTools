<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Queue - Queue handling [DEPRECATED]</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnetfilter-queue-doc">libnetfilter-queue-doc_1.0.5-4build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Queue - Queue handling [DEPRECATED]

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       int <b>nfq_fd</b> (struct nfq_handle *h)
       struct nfq_q_handle * <b>nfq_create_queue</b> (struct nfq_handle *h, uint16_t num, nfq_callback *cb, void *data)
       int <b>nfq_destroy_queue</b> (struct nfq_q_handle *qh)
       int <b>nfq_handle_packet</b> (struct nfq_handle *h, char *buf, int len)
       int <b>nfq_set_mode</b> (struct nfq_q_handle *qh, uint8_t mode, uint32_t range)
       int <b>nfq_set_queue_flags</b> (struct nfq_q_handle *qh, uint32_t mask, uint32_t flags)
       int <b>nfq_set_queue_maxlen</b> (struct nfq_q_handle *qh, uint32_t queuelen)
       int <b>nfq_set_verdict</b> (struct nfq_q_handle *qh, uint32_t id, uint32_t verdict, uint32_t data_len, const
           unsigned char *buf)
       int <b>nfq_set_verdict2</b> (struct nfq_q_handle *qh, uint32_t id, uint32_t verdict, uint32_t mark, uint32_t
           data_len, const unsigned char *buf)
       int <b>nfq_set_verdict_batch</b> (struct nfq_q_handle *qh, uint32_t id, uint32_t verdict)
       int <b>nfq_set_verdict_batch2</b> (struct nfq_q_handle *qh, uint32_t id, uint32_t verdict, uint32_t mark)
       int <b>nfq_set_verdict_mark</b> (struct nfq_q_handle *qh, uint32_t id, uint32_t verdict, uint32_t mark, uint32_t
           data_len, const unsigned char *buf)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Once libnetfilter_queue library has been initialised (See <b>LibrarySetup</b>), it is possible to bind the
       program to a specific queue. This can be done by using <b>nfq_create_queue()</b>.

       The queue can then be tuned via <b>nfq_set_mode()</b> or <b>nfq_set_queue_maxlen()</b>.

       Here's a little code snippet that create queue numbered 0:

               printf('binding this socket to queue '0'\n');
               qh = nfq_create_queue(h,  0, &amp;cb, NULL);
               if (!qh) {
                       fprintf(stderr, 'error during nfq_create_queue()\n');
                       <a href="../man1/exit.1.html">exit</a>(1);
               }

               printf('setting copy_packet mode\n');
               if (nfq_set_mode(qh, NFQNL_COPY_PACKET, 0xffff) &lt; 0) {
                       fprintf(stderr, 'can't set packet_copy mode\n');
                       <a href="../man1/exit.1.html">exit</a>(1);
               }

       Next step is the handling of incoming packets which can be done via a loop:

               fd = nfq_fd(h);

               while ((rv = recv(fd, buf, sizeof(buf), 0)) &gt;= 0) {
                       printf('pkt received\n');
                       nfq_handle_packet(h, buf, rv);
               }

        When the decision on a packet has been choosed, the verdict has to be given by calling <b>nfq_set_verdict()</b>
       or <b>nfq_set_verdict2()</b>. The verdict determines the destiny of the packet as follows:

       • NF_DROP discarded the packet

       • NF_ACCEPT the packet passes, continue iterations

       • NF_QUEUE  inject  the  packet into a different queue (the target queue number is in the high 16 bits of
         the verdict)

       • NF_REPEAT iterate the same cycle once more

       • NF_STOP accept, but don't continue iterations

       The verdict NF_STOLEN must not be used, as it has special meaning in the kernel.  When  using  NF_REPEAT,
       one  way  to  prevent re-queueing of the same packet is to also set an nfmark using nfq_set_verdict2, and
       set up the nefilter rules to only queue a packet when the mark is not (yet) set.

       Data and information about the packet can be fetch by using message parsing functions (See <b>Parsing</b>).

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>struct</b> <b>nfq_q_handle</b> <b>*</b> <b>nfq_create_queue</b> <b>(struct</b> <b>nfq_handle</b> <b>*</b> <b>h,</b> <b>uint16_t</b> <b>num,</b> <b>nfq_callback</b> <b>*</b> <b>cb,</b> <b>void</b> <b>*</b> <b>data)</b>
       nfq_create_queue - create a new queue handle and return it.

       <b>Parameters</b>
           <u>h</u> Netfilter queue connection handle obtained via call to <b>nfq_open()</b>
           <u>num</u> the number of the queue to bind to
           <u>cb</u> callback function to call for each queued packet
           <u>data</u> custom data to pass to the callback function

       <b>Returns</b>
           a nfq_q_handle pointing to the newly created queue

       Creates a new queue handle, and returns it. The  new  queue  is  identified  by  <b>num</b>,  and  the  callback
       specified  by  <b>cb</b>  will be called for each enqueued packet. The <b>data</b> argument will be passed unchanged to
       the callback. If a queue entry with id <b>num</b> already exists, this function  will  return  failure  and  the
       existing entry is unchanged.

       The nfq_callback type is defined in libnetfilter_queue.h as:

       typedef int nfq_callback(struct nfq_q_handle *qh,
                                struct nfgenmsg *nfmsg,
                                struct nfq_data *nfad, void *data);

       Parameters:

       • qh The queue handle returned by nfq_create_queue

       • nfmsg message objetc that contains the packet

       • nfad Netlink packet data handle

       • data the value passed to the data parameter of nfq_create_queue

       The callback should return &lt; 0 to stop processing.

       Definition at line <b>538</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_destroy_queue</b> <b>(struct</b> <b>nfq_q_handle</b> <b>*</b> <b>qh)</b>
       nfq_destroy_queue - destroy a queue handle

       <b>Parameters</b>
           <u>qh</u> queue handle that we want to destroy created via nfq_create_queue

       Removes  the  binding  for the specified queue handle. This call also unbind from the nfqueue handler, so
       you don't have to call nfq_unbind_pf.

       Definition at line <b>585</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_fd</b> <b>(struct</b> <b>nfq_handle</b> <b>*</b> <b>h)</b>
       nfq_fd - get the file descriptor associated with the nfqueue handler

       <b>Parameters</b>
           <u>h</u> Netfilter queue connection handle obtained via call to <b>nfq_open()</b>

       <b>Returns</b>
           a file descriptor for the netlink connection associated with the given queue connection  handle.  The
           file descriptor can then be used for receiving the queued packets for processing.

       This  function  returns  a file descriptor that can be used for communication over the netlink connection
       associated with the given queue connection handle.

       Definition at line <b>308</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_handle_packet</b> <b>(struct</b> <b>nfq_handle</b> <b>*</b> <b>h,</b> <b>char</b> <b>*</b> <b>buf,</b> <b>int</b> <b>len)</b>
       nfq_handle_packet - handle a packet received from the nfqueue subsystem

       <b>Parameters</b>
           <u>h</u> Netfilter queue connection handle obtained via call to <b>nfq_open()</b>
           <u>buf</u> data to pass to the callback
           <u>len</u> length of packet data in buffer

       Triggers an associated callback for the given packet received from the queue. Packets can  be  read  from
       the queue using <b>nfq_fd()</b> and recv(). See example code for <b>nfq_fd()</b>.

       <b>Returns</b>
           0 on success, non-zero on failure.

       Definition at line <b>609</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_set_mode</b> <b>(struct</b> <b>nfq_q_handle</b> <b>*</b> <b>qh,</b> <b>uint8_t</b> <b>mode,</b> <b>uint32_t</b> <b>range)</b>
       nfq_set_mode - set the amount of packet data that nfqueue copies to userspace

       <b>Parameters</b>
           <u>qh</u> Netfilter queue handle obtained by call to <b>nfq_create_queue()</b>.
           <u>mode</u> the part of the packet that we are interested in
           <u>range</u> size of the packet that we want to get

       Sets the amount of data to be copied to userspace for each packet queued to the given queue.

       • NFQNL_COPY_NONE - noop, do not use it

       • NFQNL_COPY_META - copy only packet metadata

       • NFQNL_COPY_PACKET - copy entire packet

       <b>Returns</b>
           -1 on error; &gt;=0 otherwise.

       Definition at line <b>630</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_set_queue_flags</b> <b>(struct</b> <b>nfq_q_handle</b> <b>*</b> <b>qh,</b> <b>uint32_t</b> <b>mask,</b> <b>uint32_t</b> <b>flags)</b>
       nfq_set_queue_flags - set flags (options) for the kernel queue

       <b>Parameters</b>
           <u>qh</u> Netfilter queue handle obtained by call to <b>nfq_create_queue()</b>.
           <u>mask</u> specifies which flag bits to modify
           <u>flags</u> bitmask of flags

       Existing flags, that you may want to combine, are:

       • NFQA_CFG_F_FAIL_OPEN  (requires  Linux kernel &gt;= 3.6): the kernel will accept the packets if the kernel
         queue gets full. If this flag is not set, the default action in this case is to drop packets.

       • NFQA_CFG_F_CONNTRACK (requires Linux kernel &gt;= 3.6): the kernel will include  the  Connection  Tracking
         system information.

       • NFQA_CFG_F_GSO  (requires  Linux  kernel  &gt;= 3.10): the kernel will not normalize offload packets, i.e.
         your application will need to be able to handle packets larger than the mtu.

       Normalization is expensive, so this flag should always be set. Because attributes in netlink messages are
       limited to 65531 bytes, you also need to check the NFQA_CAP_LEN attribute, it contains the original  size
       of  the  captured packet on the kernel side. If it is set and differs from the payload length, the packet
       was truncated. This also happens when limiting capture size with the NFQNL_COPY_PACKET setting,  or  when
       e.g. a local user sends a very large packet.

       If  your  application  validates  checksums  (e.g.,  tcp  checksum),  then  you  must  also  check if the
       NFQA_SKB_INFO attribute is present. If it is, you need to test the NFQA_SKB_CSUMNOTREADY bit:

               if (attr[NFQA_SKB_INFO]) {
                       uint32_t info = ntohl(mnl_attr_get_u32(attr[NFQA_SKB_INFO]));
                       if (info &amp; NFQA_SKB_CSUMNOTREADY)
                               validate_checksums = false;
               }

        if this bit is set, the layer 3/4 checksums of the packet appear incorrect, but are  not  (because  they
       will  be  corrected  later by the kernel). Please see example/nf-queue.c in the libnetfilter_queue source
       for more details.

         • NFQA_CFG_F_UID_GID: the kernel will dump UID and GID of the socket to which each packet belongs.

       Here's a little code snippet to show how to use this API:

               uint32_t flags = NFQA_CFG_F_FAIL_OPEN;
               uint32_t mask = NFQA_CFG_F_FAIL_OPEN;

               printf('Enabling fail-open on this q\n');
               err = nfq_set_queue_flags(qh, mask, flags);

               printf('Disabling fail-open on this q\n');
               flags &amp;= ~NFQA_CFG_F_FAIL_OPEN;
               err = nfq_set_queue_flags(qh, mask, flags);

       • NFQA_CFG_F_SECCTX: the kernel will dump security context of the socket to which each packet belongs.

       <b>Warning</b>
           When fragmentation occurs and NFQA_CFG_F_GSO is NOT set then the kernel dumps  UID/GID  and  security
           context fields only for one fragment. To deal with this limitation always set NFQA_CFG_F_GSO.

       <b>Returns</b>
           -1 on error with errno set appropriately; =0 otherwise.

       Definition at line <b>719</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_set_queue_maxlen</b> <b>(struct</b> <b>nfq_q_handle</b> <b>*</b> <b>qh,</b> <b>uint32_t</b> <b>queuelen)</b>
       nfq_set_queue_maxlen - Set kernel queue maximum length parameter

       <b>Parameters</b>
           <u>qh</u> Netfilter queue handle obtained by call to <b>nfq_create_queue()</b>.
           <u>queuelen</u> the length of the queue

       Sets  the  size  of  the  queue in kernel. This fixes the maximum number of packets the kernel will store
       before internally before dropping upcoming packets.

       <b>Returns</b>
           -1 on error; &gt;=0 otherwise.

       Definition at line <b>752</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_set_verdict</b> <b>(struct</b> <b>nfq_q_handle</b> <b>*</b> <b>qh,</b>  <b>uint32_t</b>  <b>id,</b>  <b>uint32_t</b>  <b>verdict,</b>  <b>uint32_t</b>  <b>data_len,</b>  <b>const</b>
       <b>unsigned</b> <b>char</b> <b>*</b> <b>buf)</b>
       nfq_set_verdict - issue a verdict on a packet

       <b>Parameters</b>
           <u>qh</u> Netfilter queue handle obtained by call to <b>nfq_create_queue()</b>.
           <u>id</u> ID assigned to packet by netfilter.
           <u>verdict</u> verdict to return to netfilter (NF_ACCEPT, NF_DROP)
           <u>data_len</u> number of bytes of data pointed to by <b>buf</b>
           <u>buf</u> the buffer that contains the packet data

       Can be obtained by:

               int id;
               struct nfqnl_msg_packet_hdr *ph = nfq_get_msg_packet_hdr(tb);
               if (ph)
                       id = ntohl(ph-&gt;packet_id);

       Notifies netfilter of the userspace verdict for the given packet. Every queued packet <u>must</u> have a verdict
       specified  by  userspace, either by calling this function, the <b>nfq_set_verdict2()</b> function, or the _batch
       versions of these functions.

       <b>Returns</b>
           -1 on error; &gt;= 0 otherwise.

       Definition at line <b>856</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_set_verdict2</b> <b>(struct</b> <b>nfq_q_handle</b> <b>*</b> <b>qh,</b>  <b>uint32_t</b>  <b>id,</b>  <b>uint32_t</b>  <b>verdict,</b>  <b>uint32_t</b>  <b>mark,</b>  <b>uint32_t</b>
       <b>data_len,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>buf)</b>
       nfq_set_verdict2 - like nfq_set_verdict, but you can set the mark.

       <b>Parameters</b>
           <u>qh</u> Netfilter queue handle obtained by call to <b>nfq_create_queue()</b>.
           <u>id</u> ID assigned to packet by netfilter.
           <u>verdict</u> verdict to return to netfilter (NF_ACCEPT, NF_DROP)
           <u>mark</u> mark to put on packet
           <u>data_len</u> number of bytes of data pointed to by <b>buf</b>
           <u>buf</u> the buffer that contains the packet data

       Definition at line <b>874</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_set_verdict_batch</b> <b>(struct</b> <b>nfq_q_handle</b> <b>*</b> <b>qh,</b> <b>uint32_t</b> <b>id,</b> <b>uint32_t</b> <b>verdict)</b>
       nfq_set_verdict_batch - issue verdicts on several packets at once

       <b>Parameters</b>
           <u>qh</u> Netfilter queue handle obtained by call to <b>nfq_create_queue()</b>.
           <u>id</u> maximum ID of the packets that the verdict should be applied to.
           <u>verdict</u> verdict to return to netfilter (NF_ACCEPT, NF_DROP)

       Unlike  nfq_set_verdict, the verdict is applied to all queued packets whose packet id is smaller or equal
       to <b>id</b>.

       batch support was added in Linux 3.1. These functions will fail silently on older kernels.

       Definition at line <b>895</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_set_verdict_batch2</b> <b>(struct</b> <b>nfq_q_handle</b> <b>*</b> <b>qh,</b> <b>uint32_t</b> <b>id,</b> <b>uint32_t</b> <b>verdict,</b> <b>uint32_t</b> <b>mark)</b>
       nfq_set_verdict_batch2 - like nfq_set_verdict_batch, but you can set a mark.

       <b>Parameters</b>
           <u>qh</u> Netfilter queue handle obtained by call to <b>nfq_create_queue()</b>.
           <u>id</u> maximum ID of the packets that the verdict should be applied to.
           <u>verdict</u> verdict to return to netfilter (NF_ACCEPT, NF_DROP)
           <u>mark</u> mark to put on packet

       Definition at line <b>910</b> of file <b>libnetfilter_queue.c</b>.

   <b>int</b> <b>nfq_set_verdict_mark</b> <b>(struct</b> <b>nfq_q_handle</b> <b>*</b> <b>qh,</b> <b>uint32_t</b> <b>id,</b> <b>uint32_t</b> <b>verdict,</b>  <b>uint32_t</b>  <b>mark,</b>  <b>uint32_t</b>
       <b>data_len,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>buf)</b>
       nfq_set_verdict_mark - like nfq_set_verdict, but you can set the mark.

       <b>Parameters</b>
           <u>qh</u> Netfilter queue handle obtained by call to <b>nfq_create_queue()</b>.
           <u>id</u> ID assigned to packet by netfilter.
           <u>verdict</u> verdict to return to netfilter (NF_ACCEPT, NF_DROP)
           <u>mark</u> the mark to put on the packet, in network byte order.
           <u>data_len</u> number of bytes of data pointed to by <b>buf</b>
           <u>buf</u> the buffer that contains the packet data

       <b>Returns</b>
           -1 on error; &gt;= 0 otherwise.

       This   function  is  deprecated  since  it  is  broken,  its  use  is  highly  discouraged.  Please,  use
       nfq_set_verdict2 instead.

       Definition at line <b>932</b> of file <b>libnetfilter_queue.c</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libnetfilter_queue from the source code.

libnetfilter_queue                                Version 1.0.5                                         <u><a href="../man3/Queue.3.html">Queue</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>