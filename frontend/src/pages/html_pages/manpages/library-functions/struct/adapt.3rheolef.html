<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>adapt - adaptive mesh generation (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librheolef-dev">librheolef-dev_7.2-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       adapt - adaptive mesh generation (rheolef-7.2)

</pre><h4><b>SYNOPSIS</b></h4><pre>
           geo adapt (const field&amp; criterion);
           geo adapt (const field&amp; criterion, const adapt_option&amp; aopt);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The adapt function implements an adaptive mesh procedure, based either on the gmsh (isotropic) or <b><a href="../man1/bamg.1.html">bamg</a>(1)</b>
       (anisotropic) mesh generators. The <b><a href="../man1/bamg.1.html">bamg</a>(1)</b> mesh generator is the default in two dimension. For dimension
       one or three, gmsh is the only generator supported yet. In the two dimensional case, the gmsh correspond
       to the option aopt.generator='gmsh', where aopt is an adap_option variable (see <b><a href="../man3/adapt.3.html">adapt</a>(3)</b>).

</pre><h4><b>CRITERION</b> <b>AND</b> <b>METRIC</b></h4><pre>
       The strategy bases on a metric determined by the Hessian of a scalar criterion field, denoted here as
       phi, and that is supplied by the user as the first argument of the adapt function.

       Let us denote by H=Hessian(phi) the Hessian tensor field of the scalar field phi. Then, |H| denotes the
       tensor that has the same eigenvector as H, but with absolute value of its eigenvalues:

           |H| = Q*diag(|lambda_i|)*Qt

        The metric M is determined from |H|. Recall that an isotropic metric is such that M(x)=hloc(x)^(-2)*Id
       where hloc(x) is the element size field and Id is the identity d*d matrix, and d=1,2,3 is the physical
       space dimension.

</pre><h4><b>GMSH</b> <b>ISOTROPIC</b> <b>METRIC</b></h4><pre>
                      max_(i=0..d-1)(|lambda_i(x)|)*Id
           M(x) = -----------------------------------------
                  err*hcoef^2*(sup_y(phi(y))-inf_y(phi(y)))

        Notice that the denominator involves a global (absolute) normalization sup_y(phi(y))-inf_y(phi(y)) of
       the criterion field phi and the two parameters aopt.err, the target error, and aopt.hcoef, a secondary
       normalization parameter (defaults to 1).

</pre><h4><b>BAMG</b> <b>ANISOTROPIC</b> <b>METRIC</b></h4><pre>
       There are two approach for the normalization of the metric. The first one involves a global (absolute)
       normalization:

                                  |H(x))|
           M(x) = -----------------------------------------
                  err*hcoef^2*(sup_y(phi(y))-inf_y(phi(y)))

        The first one involves a local (relative) normalization:

                                  |H(x))|
           M(x) = -----------------------------------------
                  err*hcoef^2*(|phi(x)|, cutoff*max_y|phi(y)|)

        Notice that the denominator involves a local value phi(x). The parameter is provided by the optional
       variable aopt.cutoff; its default value is 1e-7. The default strategy is the local normalization. The
       global normalization can be enforced by setting aopt.additional='-AbsError'.

       When choosing global or local normalization ?

       When the governing field phi is bounded, i.e. when err*hcoef^2*(sup_y(phi(y))-inf_y(phi(y))) will
       converge versus mesh refinement to a bounded value, the global normalization defines a metric that is
       mesh-independent and thus the adaptation loop will converge.

       Otherwise, when phi presents singularities, with unbounded values (such as corner singularity, i.e.
       presents picks when represented in elevation view), then the mesh adaptation procedure is more difficult.
       The global normalization divides by quantities that can be very large and the mesh adaptation can
       diverges when focusing on the singularities. In that case, the local normalization is preferable.
       Moreover, the focus on singularities can also be controlled by setting aopt.hmin not too small.

       The local normalization has been chosen as the default since it is more robust. When your field phi does
       not present singularities, then you can switch to the global numbering that leads to a best
       equirepartition of the error over the domain.

</pre><h4><b>OPTIONS</b></h4><pre>
       struct adapt_option {
           typedef std::vector&lt;int&gt;::size_type size_type;
           std::string generator;
           bool isotropic;
           Float err;
           Float errg;
           Float hcoef;
           Float hmin;
           Float hmax;
           Float ratio;
           Float cutoff;
           size_type n_vertices_max;
           size_type n_smooth_metric;
           bool splitpbedge;
           Float thetaquad;
           Float anisomax;
           bool clean;
           std::string additional;
           bool double_precision;
           Float anglecorner;  // angle below which bamg considers 2 consecutive edge to be part of
                               // the same spline
           adapt_option() :
               generator(""),
               isotropic(true), err(1e-2), errg(1e-1), <a href="../man1/hcoef.1.html">hcoef</a>(1), hmin(0.0001), hmax(0.3), <a href="../man0/ratio.0.html">ratio</a>(0), cutoff(1e-7),
               <a href="../man50000/n_vertices_max.50000.html">n_vertices_max</a>(50000), <a href="../man1/n_smooth_metric.1.html">n_smooth_metric</a>(1),
               splitpbedge(true), thetaquad(std::numeric_limits&lt;Float&gt;::max()),
               <a href="../man1e6/anisomax.1e6.html">anisomax</a>(1e6), clean(false), additional("-RelError"), double_precision(false),
               <a href="../man0/anglecorner.0.html">anglecorner</a>(0)
            {}
       };

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file main/lib/adapt.h

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                                   <u><a href="../man3rheolef/adapt.3rheolef.html">adapt</a></u>(3rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>