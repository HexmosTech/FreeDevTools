<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSL_write_ex2, SSL_write_ex, SSL_write, SSL_sendfile, SSL_WRITE_FLAG_CONCLUDE - write bytes to a TLS/SSL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SSL_write_ex2, SSL_write_ex, SSL_write, SSL_sendfile, SSL_WRITE_FLAG_CONCLUDE - write bytes to a TLS/SSL
       connection

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/ssl.h&gt;

        #define SSL_WRITE_FLAG_CONCLUDE

        ossl_ssize_t SSL_sendfile(SSL *s, int fd, off_t offset, size_t size, int flags);
        int SSL_write_ex2(SSL *s, const void *buf, size_t num,
                          uint64_t flags,
                          size_t *written);
        int SSL_write_ex(SSL *s, const void *buf, size_t num, size_t *written);
        int SSL_write(SSL *ssl, const void *buf, int num);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>SSL_write_ex()</b> and <b>SSL_write()</b> write <b>num</b> bytes from the buffer <b>buf</b> into the specified <b>ssl</b> connection. On
       success <b>SSL_write_ex()</b> will store the number of bytes written in <b>*written</b>.

       <b>SSL_write_ex2()</b> functions similarly to <b>SSL_write_ex()</b> but can also accept optional flags which modify its
       behaviour. Calling <b>SSL_write_ex2()</b> with a <u>flags</u> argument of 0 is exactly equivalent to calling
       <b>SSL_write_ex()</b>.

       <b>SSL_sendfile()</b> writes <b>size</b> bytes from offset <b>offset</b> in the file descriptor <b>fd</b> to the specified SSL
       connection <b>s</b>. This function provides efficient zero-copy semantics. <b>SSL_sendfile()</b> is available only when
       Kernel TLS is enabled, which can be checked by calling <b>BIO_get_ktls_send()</b>.  It is provided here to allow
       users to maintain the same interface.  The meaning of <b>flags</b> is platform dependent.  Currently, under
       Linux it is ignored.

       The <u>flags</u> argument to <b>SSL_write_ex2()</b> can accept zero or more of the following flags. Note that which
       flags are supported will depend on the kind of SSL object and underlying protocol being used:

       <b>SSL_WRITE_FLAG_CONCLUDE</b>
           This flag is only supported on QUIC stream SSL objects (or QUIC connection SSL objects with a default
           stream attached).

           If this flag is set, and the call to <b>SSL_write_ex2()</b> succeeds, and all of the data passed to the call
           is  written  (meaning  that  "*written  ==  num"),  the relevant QUIC stream's send part is concluded
           automatically as though <b><a href="../man3/SSL_stream_conclude.3.html">SSL_stream_conclude</a></b>(3) was called (causing transmission  of  a  FIN  for  the
           stream).

           While using this flag is semantically equivalent to calling <b><a href="../man3/SSL_stream_conclude.3.html">SSL_stream_conclude</a></b>(3) after a successful
           call  to  this  function,  using this flag enables greater efficiency than making these two API calls
           separately, as it enables the written stream data and the FIN flag indicating the end of  the  stream
           to be scheduled as part of the same QUIC STREAM frame and QUIC packet.

           Setting  this  flag does not cause a stream's send part to be concluded if not all of the data passed
           to the call was consumed.

       A call to <b>SSL_write_ex2()</b> fails if a flag is passed which is not supported or understood by the given SSL
       object. An application should determine if a flag is supported (for example, for <b>SSL_WRITE_FLAG_CONCLUDE</b>,
       that a QUIC stream SSL object is being used) before attempting to use it.

</pre><h4><b>NOTES</b></h4><pre>
       In the paragraphs below a "write function" is defined as one of either <b>SSL_write_ex()</b>, or <b>SSL_write()</b>.

       If necessary, a write function will negotiate a TLS/SSL session, if not already explicitly  performed  by
       <b><a href="../man3/SSL_connect.3.html">SSL_connect</a></b>(3)   or  <b><a href="../man3/SSL_accept.3.html">SSL_accept</a></b>(3).  If  the  peer  requests  a  re-negotiation,  it  will  be  performed
       transparently during the write function operation. The behaviour of the write functions  depends  on  the
       underlying BIO.

       For  the transparent negotiation to succeed, the <b>ssl</b> must have been initialized to client or server mode.
       This is being done by calling <b><a href="../man3/SSL_set_connect_state.3.html">SSL_set_connect_state</a></b>(3) or <b>SSL_set_accept_state()</b> before the first call to
       a write function.

       If the underlying BIO is <b>blocking</b>, the write functions will only return, once  the  write  operation  has
       been finished or an error occurred.

       If  the  underlying BIO is <b>nonblocking</b> the write functions will also return when the underlying BIO could
       not satisfy the needs of the function to continue the operation. In this case a call to  <b><a href="../man3/SSL_get_error.3.html">SSL_get_error</a></b>(3)
       with the return value of the write function will yield <b>SSL_ERROR_WANT_READ</b> or <b>SSL_ERROR_WANT_WRITE</b>. As at
       any  time  a  re-negotiation  is possible, a call to a write function can also cause read operations! The
       calling process then must repeat the call after taking appropriate action to satisfy  the  needs  of  the
       write  function. The action depends on the underlying BIO. When using a nonblocking socket, nothing is to
       be done, but <b>select()</b> can be used to check for the required condition. When using a buffering BIO, like a
       BIO pair, data must be written into or retrieved out of the BIO before being able to continue.

       The write functions will only return with success when the complete contents of <b>buf</b>  of  length  <b>num</b>  has
       been  written.  This  default  behaviour  can be changed with the SSL_MODE_ENABLE_PARTIAL_WRITE option of
       <b><a href="../man3/SSL_CTX_set_mode.3.html">SSL_CTX_set_mode</a></b>(3). When this flag is set the write functions will  also  return  with  success  when  a
       partial  write  has  been successfully completed. In this case the write function operation is considered
       completed. The bytes are sent and a new write call with  a  new  buffer  (with  the  already  sent  bytes
       removed) must be started. A partial write is performed with the size of a message block, which is 16kB.

       When  used  with  a  QUIC SSL object, calling an I/O function such as <b>SSL_write()</b> allows internal network
       event processing to be performed. It is important that this processing  is  performed  regularly.  If  an
       application  is not using thread assisted mode, an application should ensure that an I/O function such as
       <b>SSL_write()</b> is called regularly, or alternatively ensure that <b>SSL_handle_events()</b>  is  called  regularly.
       See <b><a href="../man7/openssl-quic.7.html">openssl-quic</a></b>(7) and <b><a href="../man3/SSL_handle_events.3.html">SSL_handle_events</a></b>(3) for more information.

</pre><h4><b>WARNINGS</b></h4><pre>
       When  a  write  function call has to be repeated because <b><a href="../man3/SSL_get_error.3.html">SSL_get_error</a></b>(3) returned <b>SSL_ERROR_WANT_READ</b> or
       <b>SSL_ERROR_WANT_WRITE</b>, it must be repeated with the same arguments.  The data that was passed  might  have
       been partially processed.  When <b>SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER</b> was set using <b><a href="../man3/SSL_CTX_set_mode.3.html">SSL_CTX_set_mode</a></b>(3) the
       pointer can be different, but the data and length should still be the same.

       You  should  not call <b>SSL_write()</b> with num=0, it will return an error.  <b>SSL_write_ex()</b> can be called with
       num=0, but will not send application data to the peer.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>SSL_write_ex()</b> and <b>SSL_write_ex2()</b> return 1 for success  or  0  for  failure.   Success  means  that  all
       requested    application    data   bytes   have   been   written   to   the   SSL   connection   or,   if
       SSL_MODE_ENABLE_PARTIAL_WRITE is in use, at least 1 application data byte has been  written  to  the  SSL
       connection.   Failure   means   that   not   all   the   requested   bytes  have  been  written  yet  (if
       SSL_MODE_ENABLE_PARTIAL_WRITE is not in use) or no bytes could be  written  to  the  SSL  connection  (if
       SSL_MODE_ENABLE_PARTIAL_WRITE  is  in  use). Failures can be retryable (e.g. the network write buffer has
       temporarily filled up) or non-retryable (e.g. a fatal network error). In the  event  of  a  failure  call
       <b><a href="../man3/SSL_get_error.3.html">SSL_get_error</a></b>(3) to find out the reason which indicates whether the call is retryable or not.

       For <b>SSL_write()</b> the following return values can occur:

       &gt; 0 The  write  operation was successful, the return value is the number of bytes actually written to the
           TLS/SSL connection.

       &lt;= 0
           The write operation was not successful, because either the connection was closed, an  error  occurred
           or  action  must  be taken by the calling process.  Call <b>SSL_get_error()</b> with the return value <b>ret</b> to
           find out the reason.

           Old documentation indicated a difference between 0 and -1, and that -1  was  retryable.   You  should
           instead call <b>SSL_get_error()</b> to find out if it's retryable.

       For <b>SSL_sendfile()</b>, the following return values can occur:

       &gt;= 0
           The  write  operation  was successful, the return value is the number of bytes of the file written to
           the TLS/SSL connection. The return value can be less than <b>size</b> for a partial write.

       &lt; 0 The write operation was not successful, because either the connection was closed, an  error  occurred
           or  action  must be taken by the calling process.  Call <b>SSL_get_error()</b> with the return value to find
           out the reason.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/SSL_get_error.3.html">SSL_get_error</a></b>(3),  <b><a href="../man3/SSL_read_ex.3.html">SSL_read_ex</a></b>(3),  <b><a href="../man3/SSL_read.3.html">SSL_read</a></b>(3)  <b><a href="../man3/SSL_CTX_set_mode.3.html">SSL_CTX_set_mode</a></b>(3),   <b><a href="../man3/SSL_CTX_new.3.html">SSL_CTX_new</a></b>(3),   <b><a href="../man3/SSL_connect.3.html">SSL_connect</a></b>(3),
       <b><a href="../man3/SSL_accept.3.html">SSL_accept</a></b>(3) <b><a href="../man3/SSL_set_connect_state.3.html">SSL_set_connect_state</a></b>(3), <b><a href="../man3/BIO_ctrl.3.html">BIO_ctrl</a></b>(3), <b><a href="../man7/ssl.7.html">ssl</a></b>(7), <b><a href="../man7/bio.7.html">bio</a></b>(7)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>SSL_write_ex()</b> function was added in OpenSSL 1.1.1.  The <b>SSL_sendfile()</b> function was added in OpenSSL
       3.0.  The <b>SSL_write_ex2()</b> function was added in OpenSSL 3.3.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2000-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed  under  the  Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain  a  copy  in  the  file  LICENSE  in  the  source  distribution  or  at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                    <u><a href="../man3SSL/SSL_WRITE.3SSL.html">SSL_WRITE</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>