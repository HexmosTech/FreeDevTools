<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gl_io_mode, gl_raw_io, gl_normal_io, gl_tty_signals, gl_abandon_line,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtecla-dev">libtecla-dev_1.6.3-3.1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
        gl_io_mode, gl_raw_io, gl_normal_io, gl_tty_signals, gl_abandon_line,
        gl_handle_signal, gl_pending_io - How to use gl_get_line() from an external event loop.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;libtecla.h&gt;

       int gl_io_mode(GetLine *gl, GlIOMode mode);

       int gl_raw_io(GetLine *gl);

       int gl_normal_io(GetLine *gl);

       int gl_tty_signals(void (*term_handler)(int),
                          void (*susp_handler)(int),
                          void (*cont_handler)(int),
                          void (*size_handler)(int));

       void gl_abandon_line(GetLine *gl);

       void gl_handle_signal(int signo, GetLine *gl, int ngl);

       GlPendingIO gl_pending_io(GetLine *gl);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>gl_get_line()</b>  function, which is documented separately in the <b><a href="../man3/gl_get_line.3.html">gl_get_line</a>(3)</b> man page, supports two
       different I/O modes.  These are selected by calling the <b>gl_io_mode()</b> function.

         int gl_io_mode(GetLine *gl, GlIOMode mode);

       The <b>mode</b> argument of this function specifies the new I/O mode, and must be one of the following.

         GL_NORMAL_MODE   -  Select the normal blocking-I/O mode.
                             In this mode <b>gl_get_line()</b>
                             doesn't return until either an error
                             occurs of the user finishes entering a
                             new line. This mode is the focus of
                             the <b><a href="../man3/gl_get_line.3.html">gl_get_line</a>(3)</b> man page.

         GL_SERVER_MODE   -  Select non-blocking server I/O mode.
                             In this mode, since non-blocking
                             terminal I/O is used, the entry of
                             each new input line typically requires
                             many calls to <b>gl_get_line()</b> from
                             an external I/O-driven event loop.
                             This mode is the focus of this man
                             page.

       Newly created <b>GetLine</b> objects start in normal I/O mode, so to switch to non-blocking server mode requires
       an initial call to <b>gl_io_mode()</b>.

</pre><h4><b>SERVER</b> <b>I/O</b> <b>MODE</b></h4><pre>
       In non-blocking server I/O mode,  the  application  is  required  to  have  an  event  loop  which  calls
       <b>gl_get_line()</b>  whenever  the  terminal  file descriptor can do the type I/O that <b>gl_get_line()</b> is waiting
       for.  To  determine  which  type  of  I/O  <b>gl_get_line()</b>  is  waiting  for,  the  application  calls  the
       <b>gl_pending_io()</b> function.

         GlPendingIO gl_pending_io(GetLine *gl);

       The return value of this function is one of the following two enumerated values.

         GLP_READ    -  gl_get_line() is waiting to write a
                        character to the terminal.

         GLP_WRITE   -  gl_get_line() is waiting to read a
                        character from the keyboad.

       If  the  application  is  using either the <b>select()</b> or <b>poll()</b> system calls to watch for I/O on a group of
       file descriptors, then it should call the <b>gl_pending_io()</b> function before each call to these functions to
       see which direction of I/O it should tell them to watch for, and configure their  arguments  accordingly.
       In  the  case  of  the <b>select()</b> system call, this means using the <b>FD_SET()</b> macro to add the terminal file
       descriptor either to the set of file descriptors to be watched for readability, or the set to be  watched
       for writability.

       As  in  normal I/O mode, the return value of <b>gl_get_line()</b> is either a pointer to a completed input line,
       or <b>NULL</b>. However, whereas in normal I/O mode a <b>NULL</b> return value always means that an error occurred,  in
       non-blocking  server  mode,  <b>NULL</b> is also returned when <b>gl_get_line()</b> can't read or write to the terminal
       without blocking. Thus in non-blocking server mode, in order  to  determine  when  a  <b>NULL</b>  return  value
       signifies that an error occurred or not, it is necessary to call the <b>gl_return_status()</b> function. If this
       function  returns  the  enumerated value, <b>GLR_BLOCKED</b>, as documented in the <b><a href="../man3/gl_get_line.3.html">gl_get_line</a>(3)</b> man page, this
       means that <b>gl_get_line()</b> is waiting for I/O, and no error has occurred.

       When <b>gl_get_line()</b> returns <b>NULL</b> and <b>gl_return_status()</b> indicates that this is  due  to  blocked  terminal
       I/O,  the  application  should  call <b>gl_get_line()</b> again when the type of I/O reported by <b>gl_pending_io()</b>
       becomes possible. The <b>prompt</b>, <b>start_line</b> and <b>start_pos</b> arguments of  <b>gl_get_line()</b>  will  be  ignored  on
       these  calls.   If you need to change the prompt of the line that is currently being edited, then you can
       call the <b>gl_replace_prompt()</b> function (documented in  the  <b><a href="../man3/gl_get_line.3.html">gl_get_line</a>(3)</b>  <b>man</b>  <b>page)</b>  <b>between</b>  <b>calls</b>  <b>to</b>
       <b>gl_get_line()</b>.

</pre><h4><b>GIVING</b> <b>UP</b> <b>THE</b> <b>TERMINAL</b></h4><pre>
       A  complication  that is unique to non-blocking server mode is that it requires that the terminal be left
       in raw mode between calls to <b>gl_get_line()</b>. If this weren't the case, the external event loop wouldn't be
       able to detect individual key-presses, and the basic line editing  implemented  by  the  terminal  driver
       would  clash  with  the  editing  provided  by  <b>gl_get_line()</b>.  What this means is that any time that the
       terminal needs to be used for other things than entering a new input line with <b>gl_get_line()</b>, it needs to
       be restored to a usable state. In particular, whenever  the  process  is  suspended  or  terminated,  the
       terminal must be returned to a normal state. If this isn't done, then depending on the characteristics of
       the shell that was used to invoke the program, the user may end up with a hung terminal. To this end, the
       <b>gl_normal_io()</b>  function is provided for switching the terminal back to the state that it was in when raw
       mode was last established.

         int gl_normal_io(GetLine *gl);

       What this function does is first flush any pending output to the terminal, then move the  cursor  to  the
       start of the terminal line which follows the end of the incompletely entered input line. At this point it
       is  safe to suspend or terminate the process, and it is safe for the application to read and write to the
       terminal. To resume entry of the input line, the application should call the <b>gl_raw_io()</b> function.

         int gl_raw_io(GetLine *gl);

       This function starts a new line, redisplays the partially completed input line  (if  any),  restores  the
       cursor  position  within  this line to where it was when <b>gl_normal_io()</b> was called, then switches back to
       raw, non-blocking terminal mode ready to continue entry of the input  line  when  <b>gl_get_line()</b>  is  next
       called.

       Note that in non-blocking server mode, if <b>gl_get_line()</b> is called after a call to <b>gl_normal_io()</b>, without
       an  intervening  call to <b>gl_raw_io()</b>, <b>gl_get_line()</b> will call <b>gl_raw_mode()</b> itself, and the terminal will
       remain in this mode when <b>gl_get_line()</b> returns.

</pre><h4><b>SIGNAL</b> <b>HANDLING</b></h4><pre>
       In the previous section it was pointed out that  in  non-blocking  server  mode,  the  terminal  must  be
       restored to a sane state whenever a signal is received that either suspends or terminates the process. In
       normal  I/O  mode,  this  is  done  for  you by <b>gl_get_line()</b>, but in non-blocking server mode, since the
       terminal is left in raw mode between calls to <b>gl_get_line()</b>, this signal handling has to be done  by  the
       application.  Since  there  are  many  signals  that can suspend or terminate a process, as well as other
       signals that are important to <b>gl_get_line()</b>, such as  the  <b>SIGWINCH</b>  signal,  which  tells  it  when  the
       terminal  size  has changed, the <b>gl_tty_signals()</b> function is provided for installing signal handlers for
       all pertinent signals.

         int gl_tty_signals(void (*term_handler)(int),
                            void (*susp_handler)(int),
                            void (*cont_handler)(int),
                            void (*size_handler)(int));

       What this does is use <b>gl_get_line()</b>'s internal list of signals to assign  specified  signal  handlers  to
       groups of signals. The arguments of this function are as follows.

         term_handler  -  This is the signal handler that is to be
                          used to trap signals that by default
                          terminate any process that receives
                          them (eg. SIGINT or SIGTERM).

         susp_handler  -  This is the signal handler that is to be
                          used to trap signals that by default
                          suspend any process that receives them,
                          (eg. SIGTSTP or SIGTTOU).

         cont_handler  -  This is the signal handler that is to be
                          used to trap signals that are usually
                          sent when a process resumes after being
                          suspended (usually SIGCONT). Beware that there is
                          nothing to stop a user from sending one of these
                          signals at other times.

         size_handler  -  This signal handler is used to trap
                          signals that are sent to processes when
                          their controlling terminals are resized
                          by the user (eg. SIGWINCH).

       These  arguments  can all be the same, if so desired, and you can specify <b>SIG_IGN</b> (ignore this signal) or
       <b>SIG_DFL</b> (use the system-provided default signal handler)  instead  of  a  function  where  pertinent.  In
       particular,  it is rarely useful to trap <b>SIGCONT</b>, so the <b>cont_handler</b> argument will usually be <b>SIG_DFL</b> or
       <b>SIG_IGN</b>.

       The <b>gl_tty_signals()</b> function uses the POSIX <b>sigaction()</b> function to install these signal  handlers,  and
       it  is  careful  to  use  the <b>sa_mask</b> member of each sigaction structure to ensure that only one of these
       signals is ever delivered at a time. This guards against different instances  of  these  signal  handlers
       from  simultaneously  trying  to  write  to  common global data, such as a shared <b>sigsetjmp()</b> buffer or a
       signal-received flag.

       The signal handlers that are installed by this function, should call the <b>gl_handle_signal().</b>

         <b>void</b> <b>gl_handle_signal(int</b> <b>signo,</b> <b>GetLine</b> <b>*gl,</b> <b>int</b> <b>ngl);</b>

       <b>The</b> <b>signo</b> argument tells this function which signal it is being asked to respond to, and the <b>gl</b>  argument
       should be a pointer to the first element of an array of <b>ngl</b> <b>GetLine</b> objects. If your application only has
       one of these objects, just pass its pointer as the <b>gl</b> argument and specify <b>ngl</b> as <b>1</b>.

       Depending on the signal that is being handled, this function does different things.

   <b>Terminal</b> <b>resize</b> <b>signals</b> <b>(SIGWINCH)</b>
       If  the  signal  indicates  that  the  terminal  was  resized,  then  it  arranges  for  the next call to
       <b>gl_get_line()</b> to ask the terminal for its new size and redraw the input line accordingly. In  order  that
       <b>gl_get_line()</b>  be  called  as soon as possible to do this, <b>gl_handle_signal()</b> also arranges that the next
       call to <b>gl_pending_io()</b> will return <b>GLP_WRITE</b>. Thus if the application  waits  for  I/O  in  <b>select()</b>  or
       <b>poll()</b>,  then the application needs to ensure that these functions will be reliably aborted when a signal
       is caught and handled by the application. More on this below.

</pre><h4><b>Process</b> <b>termination</b> <b>signals.</b></h4><pre>
       If the signal that was caught is one of those that by default terminates any process  that  receives  it,
       then <b>gl_handle_signal()</b> does the following steps.

       1. First it blocks the delivery of all signals that can be
          blocked (ie. <b>SIGKILL</b> and <b>SIGSTOP</b> can't be blocked)

       2. Next it calls <b>gl_normal_io()</b> for each of the <b>ngl</b>
          <b>GetLine</b> objects. Note that this does nothing to any of the
          <b>GetLine</b> objects that aren't currently in raw mode.

       3. Next it sets the signal handler of the signal to its default,
          process-termination disposition.

       4. Next it re-sends the process the signal that was caught.

       5. Finally it unblocks delivery of this signal, which
          results in the process being terminated.

</pre><h4><b>Process</b> <b>suspension</b> <b>signals.</b></h4><pre>
       If  the  default  disposition of the signal is to suspend the process, the same steps are executed as for
       process termination signals, except that when the process is later resumed, <b>gl_handle_signal()</b> continues,
       and does the following steps.

       6. It re-blocks delivery of the signal.

       7. It reinstates the signal handler of the signal to the one
          that was displaced when its default disposition was substituted.

       8. For any of the <b>GetLine</b> objects that were in raw mode when
          <b>gl_handle_signal()</b> was called, <b>gl_handle_signal()</b> then
          calls <b>gl_raw_io()</b>, to resume entry of the input lines on
          those terminals.

       9. Finally, it restores the signal process mask to how it
          was when <b>gl_handle_signal()</b> was called.

       Note that the process is suspended or terminated using the original signal that was caught,  rather  than
       using the uncatchable <b>SIGSTOP</b> and <b>SIGKILL</b> signals. This is important, because when a process is suspended
       or  terminated,  the parent of the process may wish to use the status value returned by the <b>wait()</b> system
       call to figure out which signal was responsible. In particular, most shells use this information to print
       a corresponding message to the terminal. Users would be rightly confused if when their process received a
       <b>SIGPIPE</b> signal, the program responded by sending itself a <b>SIGKILL</b> signal, and the shell then printed  out
       the provocative statement, "Killed!".

</pre><h4><b>INTERRUPTING</b> <b>THE</b> <b>EVENT</b> <b>LOOP</b></h4><pre>
       If  a  signal  is  caught and handled when the application's event loop is waiting in <b>select()</b> or <b>poll()</b>,
       these functions will be aborted with <b>errno</b> set to <b>EINTR</b>. When this happens the  event  loop  should  call
       <b>gl_pending_io()</b>,  before  calling <b>select()</b> or <b>poll()</b> again. It should then arrange for <b>select()</b> or <b>poll()</b>
       to wait for the type of I/O that this reports. This is necessary, because any signal handler which  calls
       <b>gl_handle_signal()</b>, will frequently change the type of I/O that <b>gl_get_line()</b> is waiting for.

       Unfortunately,  if  a  signal arrives between the statements which configure the arguments of <b>select()</b> or
       <b>poll()</b> and the calls to these functions, then the signal will not be seen by these functions, which  will
       then  not  be aborted. If these functions are waiting for keyboard input from the user when the signal is
       received, and the signal handler arranges to redraw the input line to accommodate a  terminal  resize  or
       the  resumption  of the process, then this redisplay will be end up being delayed until the user hits the
       next key. Apart from puzzling the user, this clearly isn't a serious problem. However  there  is  a  way,
       albeit complicated, to completely avoid this race condition. The following steps illustrate this.

       1. Block all of the signals that <b>gl_get_line()</b> catches,
          by passing the signal set returned by <b>gl_list_signals()</b> to
          <b>sigprocmask()</b>.

       2. Call <b>gl_pending_io()</b> and set up the arguments of
          <b>select()</b> or <b>poll()</b> accordingly.

       3. Call <b>sigsetjmp()</b> with a non-zero <b>savesigs</b> argument.

       4. Initially this <b>sigsetjmp()</b> statement will return zero,
          indicating that control isn't resuming there after a matching
          call to <b>siglongjmp()</b>.

       5. Replace all of the handlers of the signals that <b>gl_get_line()</b>
          is configured to catch, with a signal handler that first records
          the number of the signal that was caught, in a file-scope variable,
          then calls <b>siglongjmp()</b> with a non-zero value argument, to
          return execution to the above <b>sigsetjmp()</b>
          statement.  Registering these signal handlers can conveniently be
          done using the <b>gl_tty_signals()</b> function.

       6. Set the file-scope variable that the above signal handler uses to
          record any signal that is caught to -1, so that we can check
          whether a signal was caught by seeing if it contains a valid signal
          number.

       7. Now unblock the signals that were blocked in step 1. Any signal
          that was received by the process in between step 1 and now will
          now be delivered, and trigger our signal handler, as will any
          signal that is received until we block these signals again.

       8. Now call <b>select()</b> or <b>poll()</b>.

       9. When <b>select()</b> returns, again block the signals that were
          unblocked in step 7.

       If  a  signal  is arrived any time during the above steps, our signal handler will be triggered and cause
       control to return to the <b>sigsetjmp()</b> statement,  where  this  time,  <b>sigsetjmp()</b>  will  return  non-zero,
       indicating  that a signal was caught. When this happens we simply skip the above block of statements, and
       continue with the following statements, which are executed regardless of  whether  or  not  a  signal  is
       caught.  Note  that  when  <b>sigsetjmp()</b> returns, regardless of why it returned, the process signal mask is
       returned to how it was when <b>sigsetjmp()</b> was called. Thus the following  statements  are  always  executed
       with all of our signals blocked.

       9. Reinstate the signal handlers that were displaced in step 5.

       10. Check wether a signal was caught, by checking the file-scope
           variable that the signal handler records signal numbers in.

       11. If a signal was caught, send this signal to the application
           again, and unblock just this signal, so that it invokes the
           signal handler which we just reinstated in step 10.

       12. Unblock all of the signals that were blocked in step 7.

       Since  this  is  complicated,  note that <b>demo3.c</b> includes a working example of how to do this. The method
       used there however, is more general than the above.  What  it  provides  is  a  wrapper  function  around
       <b>select()</b>  which  encompasses  steps 3 to 11. In this wrapper, rather than use <b>gl_list_signals()</b> to figure
       out the signals to block, and and <b>gl_tty_signals()</b> to assign and  revert  signal  handlers,  one  of  its
       arguments  is  a  <b>sigset_t</b>  which  specifies  which  signals to block and assign signal handlers to. This
       function thus doesn't depend on <b>gl_get_line()</b> and can thus  be  used  in  other  situations  where  race-
       condition-free signal handling is required.

</pre><h4><b>SIGNALS</b> <b>CAUGHT</b> <b>BY</b> <b>GL_GET_LINE</b></h4><pre>
       Since  the  application  is expected to handle signals in non-blocking server mode, <b>gl_get_line()</b> doesn't
       attempt to duplicate this when it is being called. If one of the signals that it is configured  to  catch
       is  sent  to  the  application while <b>gl_get_line()</b> is being called, <b>gl_get_line()</b> reinstates the caller's
       signal handlers, then just before returning, re-sends the signal to the process to let the  application's
       signal handler handle it. If the process isn't terminated by this signal, <b>gl_get_line()</b> returns <b>NULL</b>, and
       a following call to <b>gl_return_status()</b> returns the enumerated value <b>GLR_SIGNAL</b>.

</pre><h4><b>ABORTING</b> <b>LINE</b> <b>INPUT</b></h4><pre>
       Often,  rather  than  letting it terminate the process, applications respond to the SIGINT user-interrupt
       signal by aborting the current input line. The way to do this in non-blocking server-I/O mode is  to  not
       call <b>gl_handle_signal()</b> when this signal is caught, but instead to call the <b>gl_abandon_line()</b>.

         void gl_abandon_line(GetLine *gl);

       This function arranges that when <b>gl_get_line()</b> is next called, it first flushes any pending output to the
       terminal,  then  discardes  the  current  input  line, outputs a new prompt on the next line, and finally
       starts accepting input of a new input line from the user.

</pre><h4><b>SIGNAL</b> <b>SAFE</b> <b>FUNCTIONS</b></h4><pre>
       Provided that certain rules are followed, the following functions can have  been  written  to  be  safely
       callable from signal handlers. Other functions in this library should not be called from signal handlers.

         gl_normal_io()
         gl_raw_io()
         gl_handle_signal()
         gl_abandon_line()

       In  order for this to be true, all signal handlers that call these functions must be registered in such a
       way that only one instance of any one of them can be running at one time. The way to do this  is  to  use
       the  POSIX  <b>sigaction()</b>  function  to  register all signal handlers, and when doing this, use the <b>sa_mask</b>
       member of the corresponding sigaction structure, to indicate that  all  of  the  signals  who's  handlers
       invoke the above functions, should be blocked when the current signal is being handled. This prevents two
       signal handlers from operating on a <b>GetLine</b> object at the same time.

       To  prevent  signal handlers from accessing a <b>GetLine</b> object while <b>gl_get_line()</b> or any of its associated
       public functions are operating on it, all  public  functions  associated  with  <b>gl_get_line()</b>,  including
       <b>gl_get_line()</b>  itself, temporarily block the delivery of signals when they are accessing <b>GetLine</b> objects.
       Beware that the only signals that they block are the signals that <b>gl_get_line()</b> is  currently  configured
       to  catch,  so be sure that if you call any of the above functions from signal handlers, that the signals
       that these handlers are assigned to are configured to be caught by <b>gl_get_line()</b> (see <b>gl_trap_signal()</b>).

</pre><h4><b>USING</b> <b>TIMEOUTS</b> <b>TO</b> <b>POLL</b></h4><pre>
       If instead of using <b>select()</b> or <b>poll()</b> to wait for I/O,  your  application  just  needs  to  get  out  of
       <b>gl_get_line()</b>  periodically  to briefly do something else before returning to accept input from the user,
       this can be done  in  non-blocking  server  mode  by  using  the  <b>gl_inactivity_timeout()</b>  function  (see
       <b><a href="../man3/gl_get_line.3.html">gl_get_line</a>(3)</b>), to specify that a callback function that returns <b>GLTO_CONTINUE</b> should be called whenever
       <b>gl_get_line()</b> has been waiting for I/O for more than a specified amount of time.

       When   this   callback   is   triggered,  <b>gl_get_line()</b>  will  return  <b>NULL</b>,  and  a  following  call  to
       <b>gl_return_status()</b> will return <b>GLR_BLOCKED</b>.

       Beware that <b>gl_get_line()</b> won't return until the user hasn't typed a key for the specified  interval,  so
       if  the  interval  is long, and the user keeps typing, <b>gl_get_line()</b> may not return for a while. In other
       words there is no guarantee that it will return in the time specified.

</pre><h4><b>THE</b> <b>SERVER</b> <b>DEMO</b> <b>PROGRAM</b></h4><pre>
       The <b>demo3</b> program that is distributed with the library, provides a working example of  how  to  use  non-
       blocking  server  I/O  mode  in  a  real  program. As far as the user is concerned, this program operates
       identically to the main demo program (called <b>demo</b>), except that whereas the main demo  program  uses  the
       normal blocking I/O mode, <b>demo3</b> using non-blocking I/O and an external event loop. The source code can be
       found in <b>demo3.c</b>, and the comments therein explain the various steps.

</pre><h4><b>FILES</b></h4><pre>
       libtecla.a      -    The tecla library
       libtecla.h      -    The tecla header file.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/libtecla.3.html">libtecla</a>(3), <a href="../man3/gl_get_line.3.html">gl_get_line</a>(3), <a href="../man7/tecla.7.html">tecla</a>(7), <a href="../man3/ef_expand_file.3.html">ef_expand_file</a>(3),
       <a href="../man3/cpl_complete_word.3.html">cpl_complete_word</a>(3), <a href="../man3/pca_lookup_file.3.html">pca_lookup_file</a>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
       Martin Shepherd  (<a href="mailto:mcs@astro.caltech.edu">mcs@astro.caltech.edu</a>)

                                                                                                   <u><a href="../man3/gl_io_mode.3.html">gl_io_mode</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>