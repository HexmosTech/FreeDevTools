<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pmemkv - Key/Value Datastore for Persistent Memory</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libpmemkv-dev">libpmemkv-dev_1.5.0-4build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>pmemkv</b> - Key/Value Datastore for Persistent Memory

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;libpmemkv.h&gt;

              typedef int pmemkv_get_kv_callback(const char *key, size_t keybytes, const char *value,
                          size_t valuebytes, void *arg);
              typedef void pmemkv_get_v_callback(const char *value, size_t valuebytes, void *arg);

              int pmemkv_open(const char *engine, pmemkv_config *config, pmemkv_db **db);
              void pmemkv_close(pmemkv_db *kv);

              int pmemkv_count_all(pmemkv_db *db, size_t *cnt);
              int pmemkv_count_above(pmemkv_db *db, const char *k, size_t kb, size_t *cnt);
              int pmemkv_count_below(pmemkv_db *db, const char *k, size_t kb, size_t *cnt);
              int pmemkv_count_between(pmemkv_db *db, const char *k1, size_t kb1, const char *k2,
                          size_t kb2, size_t *cnt);

              int pmemkv_get_all(pmemkv_db *db, pmemkv_get_kv_callback *c, void *arg);
              int pmemkv_get_above(pmemkv_db *db, const char *k, size_t kb, pmemkv_get_kv_callback *c,
                          void *arg);
              int pmemkv_get_below(pmemkv_db *db, const char *k, size_t kb, pmemkv_get_kv_callback *c,
                          void *arg);
              int pmemkv_get_between(pmemkv_db *db, const char *k1, size_t kb1, const char *k2,
                          size_t kb2, pmemkv_get_kv_callback *c, void *arg);

              int pmemkv_exists(pmemkv_db *db, const char *k, size_t kb);

              int pmemkv_get(pmemkv_db *db, const char *k, size_t kb, pmemkv_get_v_callback *c,
                          void *arg);
              int pmemkv_get_copy(pmemkv_db *db, const char *k, size_t kb, char *buffer,
                          size_t buffer_size, size_t *value_size);
              int pmemkv_put(pmemkv_db *db, const char *k, size_t kb, const char *v, size_t vb);

              int pmemkv_remove(pmemkv_db *db, const char *k, size_t kb);

              int pmemkv_defrag(pmemkv_db *db, double start_percent, double amount_percent);

              const char *pmemkv_errormsg(void);

       For  pmemkv  configuration  API description see <b><a href="../man3/libpmemkv_config.3.html">libpmemkv_config</a></b>(3).  For pmemkv iterator API description
       see <b><a href="../man3/libpmemkv_iterator.3.html">libpmemkv_iterator</a></b>(3).  For general pmemkv information, engine descriptions and bindings details  see
       <b><a href="../man7/libpmemkv.7.html">libpmemkv</a></b>(7).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Keys  and  values  stored in a pmemkv database can be arbitrary binary data and can contain multiple null
       characters.  Every function which accepts key expects const char *k pointer  to  data  and  its  size  as
       size_t.

       Some  of  the functions (mainly range-query API) are not guaranteed to be implemented by all engines.  If
       an engine does not support a certain function, it will return PMEMKV_STATUS_NOT_SUPPORTED.

       Note: There are no explicit upper_bound/lower_bound functions.  If you want to obtain an element(s) above
       or below the selected key, you can use pmemkv_get_above() or  pmemkv_get_below().   See  descriptions  of
       these functions for details.

       <b>int</b> <b>pmemkv_open(const</b> <b>char</b> <b>*engine,</b> <b>pmemkv_config</b> <b>*config,</b> <b>pmemkv_db</b> <b>**db);</b>
              Opens the pmemkv database and stores a pointer to a <u>pmemkv_db</u> instance in *db.  The engine parame‐
              ter  specifies  the  engine name (see <b><a href="../man7/libpmemkv.7.html">libpmemkv</a></b>(7) for the list of available engines).  The config
              parameter specifies configuration (see <b><a href="../man3/libpmemkv_config.3.html">libpmemkv_config</a></b>(3) for details).  Pmemkv  takes  ownership
              of  the  config  parameter  - this means that pmemkv_config_delete() must NOT be called after open
              (successful or failed).

       <b>void</b> <b>pmemkv_close(pmemkv_db</b> <b>*kv);</b>
              Closes pmemkv database.

       <b>int</b> <b>pmemkv_count_all(pmemkv_db</b> <b>*db,</b> <b>size_t</b> <b>*cnt);</b>
              Stores in *cnt the number of records in db.

       <b>int</b> <b>pmemkv_count_above(pmemkv_db</b> <b>*db,</b> <b>const</b> <b>char</b> <b>*k,</b> <b>size_t</b> <b>kb,</b> <b>size_t</b> <b>*cnt);</b>
              Stores in *cnt the number of records in db whose keys are greater than the key  k  of  length  kb.
              Order of the elements is specified by a comparator (see <b><a href="../man7/libpmemkv.7.html">libpmemkv</a></b>(7)).

       <b>int</b> <b>pmemkv_count_below(pmemkv_db</b> <b>*db,</b> <b>const</b> <b>char</b> <b>*k,</b> <b>size_t</b> <b>kb,</b> <b>size_t</b> <b>*cnt);</b>
              Stores in *cnt the number of records in db whose keys are less than the key k of length kb.  Order
              of the elements is specified by a comparator (see <b><a href="../man7/libpmemkv.7.html">libpmemkv</a></b>(7)).

       <b>int</b> <b>pmemkv_count_between(pmemkv_db</b> <b>*db,</b> <b>const</b> <b>char</b> <b>*k1,</b> <b>size_t</b> <b>kb1,</b> <b>const</b> <b>char</b> <b>*k2,</b> <b>size_t</b> <b>kb2,</b> <b>size_t</b>
       <b>*cnt);</b>
              Stores  in *cnt the number of records in db whose keys are greater than key k1 (of length kb1) and
              less than key k2 (of length kb2).  Order of the elements is specified by a comparator  (see  <b>libp‐</b>
              <b><a href="../man7/memkv.7.html">memkv</a></b>(7)).

       <b>int</b> <b>pmemkv_get_all(pmemkv_db</b> <b>*db,</b> <b>pmemkv_get_kv_callback</b> <b>*c,</b> <b>void</b> <b>*arg);</b>
              Executes  function c for every record stored in db.  Arguments passed to the function are: pointer
              to a key, size of the key, pointer to a value, size of the value and arg specified  by  the  user.
              Function  c can stop iteration by returning non-zero value.  In that case <u>pmemkv_get_all()</u> returns
              PMEMKV_STATUS_STOPPED_BY_CB.  Returning 0 continues iteration.  Order of the elements is specified
              by a comparator (see <b><a href="../man7/libpmemkv.7.html">libpmemkv</a></b>(7)).

       <b>int</b> <b>pmemkv_get_above(pmemkv_db</b> <b>*db,</b> <b>const</b> <b>char</b> <b>*k,</b> <b>size_t</b> <b>kb,</b> <b>pmemkv_get_kv_callback</b> <b>*c,</b> <b>void</b> <b>*arg);</b>
              Executes function c for every record stored in db whose keys are greater than  key  k  (of  length
              kb).   Arguments  passed  to c are: pointer to a key, size of the key, pointer to a value, size of
              the value and arg specified by the user.  Function c can stop iteration by returning non-zero val‐
              ue.  In that case <u>pmemkv_get_above()</u> returns PMEMKV_STATUS_STOPPED_BY_CB.  Returning  0  continues
              iteration.  Order of the elements is specified by a comparator (see <b><a href="../man7/libpmemkv.7.html">libpmemkv</a></b>(7)).

       <b>int</b> <b>pmemkv_get_below(pmemkv_db</b> <b>*db,</b> <b>const</b> <b>char</b> <b>*k,</b> <b>size_t</b> <b>kb,</b> <b>pmemkv_get_kv_callback</b> <b>*c,</b> <b>void</b> <b>*arg);</b>
              Executes  function  c for every record stored in db whose keys are less than key k (of length kb).
              Arguments passed to c are: pointer to a key, size of the key, pointer to a value, size of the val‐
              ue and arg specified by the user.  Function c can stop iteration by returning non-zero value.   In
              that  case  <u>pmemkv_get_below()</u>  returns PMEMKV_STATUS_STOPPED_BY_CB.  Returning 0 continues itera‐
              tion.  Order of the elements is specified by a comparator (see <b><a href="../man7/libpmemkv.7.html">libpmemkv</a></b>(7)).

       <b>int</b> <b>pmemkv_get_between(pmemkv_db</b> <b>*db,</b> <b>const</b> <b>char</b> <b>*k1,</b> <b>size_t</b> <b>kb1,</b> <b>const</b> <b>char</b> <b>*k2,</b> <b>size_t</b> <b>kb2,</b>
       <b>pmemkv_get_kv_callback</b> <b>*c,</b> <b>void</b> <b>*arg);</b>
              Executes function c for every record stored in db whose keys are greater than key  k1  (of  length
              kb1)  and  less than key k2 (of length kb2).  Arguments passed to c are: pointer to a key, size of
              the key, pointer to a value, size of the value and arg specified by the user.  Function c can stop
              iteration by returning non-zero value.  In  that  case  <u>pmemkv_get_between()</u>  returns  PMEMKV_STA‐
              TUS_STOPPED_BY_CB.  Returning 0 continues iteration.  Order of the elements is specified by a com‐
              parator (see <b><a href="../man7/libpmemkv.7.html">libpmemkv</a></b>(7)).

       <b>int</b> <b>pmemkv_exists(pmemkv_db</b> <b>*db,</b> <b>const</b> <b>char</b> <b>*k,</b> <b>size_t</b> <b>kb);</b>
              Checks  existence of record with key k of length kb.  If record is present PMEMKV_STATUS_OK is re‐
              turned, otherwise PMEMKV_STATUS_NOT_FOUND is returned.  Other possible return values are described
              in the <u>ERRORS</u> section.

       <b>int</b> <b>pmemkv_get(pmemkv_db</b> <b>*db,</b> <b>const</b> <b>char</b> <b>*k,</b> <b>size_t</b> <b>kb,</b> <b>pmemkv_get_v_callback</b> <b>*c,</b> <b>void</b> <b>*arg);</b>
              Executes function c on record with key k (of length kb).  If record is present and  no  error  oc‐
              curred the function returns PMEMKV_STATUS_OK.  If record does not exist PMEMKV_STATUS_NOT_FOUND is
              returned.  Other possible return values are described in the <u>ERRORS</u> section.  Function c is called
              with  the  following  parameters:  pointer  to a value, size of the value and arg specified by the
              user.  Value points to the location where data is actually stored (no copy occurs).  This function
              is guaranteed to be implemented by all engines.

       <b>int</b> <b>pmemkv_get_copy(pmemkv_db</b> <b>*db,</b> <b>const</b> <b>char</b> <b>*k,</b> <b>size_t</b> <b>kb,</b> <b>char</b> <b>*buffer,</b> <b>size_t</b> <b>buffer_size,</b> <b>size_t</b>
       <b>*value_size);</b>
              Copies value of record with key k of length kb to user provided buffer.  buffer points to the val‐
              ue buffer, buffer_size specifies its size and *value_size is filled in by this function.   If  the
              value  doesn’t  fit in the provided buffer then this function returns PMEMKV_STATUS_UNKNOWN_ERROR.
              Otherwise, in absence of any errors, PMEMKV_STATUS_OK is returned.  Other possible  return  values
              are  described  in  the  <u>ERRORS</u> section.  This function is guaranteed to be implemented by all en‐
              gines.

       <b>int</b> <b>pmemkv_put(pmemkv_db</b> <b>*db,</b> <b>const</b> <b>char</b> <b>*k,</b> <b>size_t</b> <b>kb,</b> <b>const</b> <b>char</b> <b>*v,</b> <b>size_t</b> <b>vb);</b>
              Inserts a key-value pair into pmemkv database.  kb is the length of key k and vb is the length  of
              value  v.   When  this  function  returns, caller is free to reuse both buffers.  This function is
              guaranteed to be implemented by all engines.

       <b>int</b> <b>pmemkv_remove(pmemkv_db</b> <b>*db,</b> <b>const</b> <b>char</b> <b>*k,</b> <b>size_t</b> <b>kb);</b>
              Removes record with key k of length kb.  This function is guaranteed to be implemented by all  en‐
              gines.

       <b>int</b> <b>pmemkv_defrag(pmemkv_db</b> <b>*db,</b> <b>double</b> <b>start_percent,</b> <b>double</b> <b>amount_percent);</b>
              Defragments  approximately  `amount_percent'  percent  of  elements  in the database starting from
              `start_percent' percent of elements.

       <b>const</b> <b>char</b> <b>*pmemkv_errormsg(void);</b>
              Returns a human readable string describing the last error.

   <b>ERRORS</b>
       Each function, except for <u>pmemkv_close()</u> and <u>pmemkv_errormsg()</u>,  returns  one  of  the  following  status
       codes:

       • <b>PMEMKV_STATUS_OK</b> – no error

       • <b>PMEMKV_STATUS_UNKNOWN_ERROR</b> – unknown error

       • <b>PMEMKV_STATUS_NOT_FOUND</b> – record not found

       • <b>PMEMKV_STATUS_NOT_SUPPORTED</b> – function is not implemented by current engine

       • <b>PMEMKV_STATUS_INVALID_ARGUMENT</b> – argument to function has wrong value

       • <b>PMEMKV_STATUS_CONFIG_PARSING_ERROR</b> – parsing data to config failed

       • <b>PMEMKV_STATUS_CONFIG_TYPE_ERROR</b> – config item has different type than expected

       • <b>PMEMKV_STATUS_STOPPED_BY_CB</b> – iteration was stopped by user’s callback

       • <b>PMEMKV_STATUS_OUT_OF_MEMORY</b>  – operation failed because there is not enough memory (or space on the de‐
         vice)

       • <b>PMEMKV_STATUS_WRONG_ENGINE_NAME</b> – engine name does not match any available engine

       • <b>PMEMKV_STATUS_TRANSACTION_SCOPE_ERROR</b> – an error with the scope of the libpmemobj transaction

       • <b>PMEMKV_STATUS_DEFRAG_ERROR</b> – the defragmentation process failed (possibly in the middle of a run)

       Status returned from a function can change in a future version of a library to a more specific one.   For
       example,  if  a  function  returns PMEMKV_STATUS_UNKNOWN_ERROR, it is possible that in future versions it
       will return PMEMKV_STATUS_INVALID_ARGUMENT.  Recommended way to check for an error is to  compare  status
       with PMEMKV_STATUS_OK.

</pre><h4><b>EXAMPLE</b></h4><pre>
       The following example is taken from examples/pmemkv_basic_c directory.

       Basic pmemkv usage in C:

              #include &lt;<a href="file:/usr/include/assert.h">assert.h</a>&gt;
              #include &lt;libpmemkv.h&gt;
              #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
              #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
              #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;

              #define ASSERT(expr)                                                                     \
                  do {                                                                             \
                      if (!(expr))                                                             \
                          puts(pmemkv_errormsg());                                         \
                      assert(expr);                                                            \
                  } while (0)

              #define <a href="../manmsg/LOG.msg.html">LOG</a>(msg) <a href="../manmsg/puts.msg.html">puts</a>(msg)
              #define MAX_VAL_LEN 64

              static const uint64_t SIZE = 1024UL * 1024UL * 1024UL;

              int get_kv_callback(const char *k, size_t kb, const char *value, size_t value_bytes,
                          void *arg)
              {
                  printf("   visited: %s\n", k);

                  return 0;
              }

              int main(int argc, char *argv[])
              {
                  if (argc &lt; 2) {
                      fprintf(stderr, "Usage: %s file\n", argv[0]);
                      <a href="../man1/exit.1.html">exit</a>(1);
                  }

                  /* See <a href="../man3/libpmemkv_config.3.html">libpmemkv_config</a>(3) for more detailed example of config creation */
                  LOG("Creating config");
                  pmemkv_config *cfg = pmemkv_config_new();
                  ASSERT(cfg != NULL);

                  int s = pmemkv_config_put_path(cfg, argv[1]);
                  ASSERT(s == PMEMKV_STATUS_OK);
                  s = pmemkv_config_put_size(cfg, SIZE);
                  ASSERT(s == PMEMKV_STATUS_OK);
                  s = pmemkv_config_put_create_if_missing(cfg, true);
                  ASSERT(s == PMEMKV_STATUS_OK);

                  /* Alternatively create_or_error_if_exists flag can be set, to fail if file exists
                   * For differences between the two flags, see manpage <a href="../man7/libpmemkv.7.html">libpmemkv</a>(7). */
                  /* s = pmemkv_config_put_create_or_error_if_exists(cfg, true); */

                  LOG("Opening pmemkv database with 'cmap' engine");
                  pmemkv_db *db = NULL;
                  s = pmemkv_open("cmap", cfg, &amp;db);
                  ASSERT(s == PMEMKV_STATUS_OK);
                  ASSERT(db != NULL);

                  LOG("Putting new key");
                  const char *key1 = "key1";
                  const char *value1 = "value1";
                  s = pmemkv_put(db, key1, strlen(key1), value1, strlen(value1));
                  ASSERT(s == PMEMKV_STATUS_OK);

                  size_t cnt;
                  s = pmemkv_count_all(db, &amp;cnt);
                  ASSERT(s == PMEMKV_STATUS_OK);
                  ASSERT(cnt == 1);

                  LOG("Reading key back");
                  char val[MAX_VAL_LEN];
                  s = pmemkv_get_copy(db, key1, strlen(key1), val, MAX_VAL_LEN, NULL);
                  ASSERT(s == PMEMKV_STATUS_OK);
                  ASSERT(!strcmp(val, "value1"));

                  LOG("Iterating existing keys");
                  const char *key2 = "key2";
                  const char *value2 = "value2";
                  const char *key3 = "key3";
                  const char *value3 = "value3";
                  pmemkv_put(db, key2, strlen(key2), value2, strlen(value2));
                  pmemkv_put(db, key3, strlen(key3), value3, strlen(value3));
                  pmemkv_get_all(db, &amp;get_kv_callback, NULL);

                  LOG("Removing existing key");
                  s = pmemkv_remove(db, key1, strlen(key1));
                  ASSERT(s == PMEMKV_STATUS_OK);
                  ASSERT(pmemkv_exists(db, key1, strlen(key1)) == PMEMKV_STATUS_NOT_FOUND);

                  LOG("Defragmenting the database");
                  s = pmemkv_defrag(db, 0, 100);
                  ASSERT(s == PMEMKV_STATUS_OK);

                  LOG("Closing database");
                  pmemkv_close(db);

                  return 0;
              }

   <b>Common</b> <b>usage</b> <b>mistake</b>
       Common  mistake in pmemkv API usage (especially when using C++ API) is to dereference pointer to the data
       stored in pmemkv outside of a callback function scope.

              std::string value;
              const char* ptr;
              size_t sz;
              kv-&gt;get("key1", [&amp;](string_view v) {
                  /* Save pointer to the data to use it later outside of a callback scope */
                  ptr = v.data();
                  sz = v.size();
              });
              kv-&gt;remove("key");
              /* ERROR!
               * Using this pointer outside of a callback function may cause access to some random data
               * or a segmentation fault. At that point, ptr should be considered as invalid.
               */
              value.append(ptr, sz);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/libpmemkv.7.html">libpmemkv</a></b>(7), <b><a href="../man3/libpmemkv_config.3.html">libpmemkv_config</a></b>(3), <b><a href="../man3/libpmemkv_iterator.3.html">libpmemkv_iterator</a></b>(3) and <b>&lt;https://pmem.io&gt;</b>

PMEMKV - pmemkv version 1.5.0                      2022-03-09                                          <u><a href="../man3/PMEMKV.3.html">PMEMKV</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>