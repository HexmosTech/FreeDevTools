<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>avr_stdlib - <stdlib.h>: General utilities</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/avr-libc">avr-libc_2.2.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       avr_stdlib - &lt;stdlib.h&gt;: General utilities

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Data</b> <b>Structures</b>
       struct <b>div_t</b>
       struct <b>ldiv_t</b>

   <b>Macros</b>
       #define <b>RAND_MAX</b>   0x7FFF

   <b>Typedefs</b>
       typedef int(* <b>__compar_fn_t</b>) (const void *, const void *)

   <b>Functions</b>
       void <b>abort</b> (void)
       int <b>abs</b> (int __i)
       long <b>labs</b> (long __i)
       void * <b>bsearch</b> (const void *__key, const void *__base, size_t __nmemb, size_t __size,
           int(*__compar)(const void *, const void *))
       <b>div_t</b> <b>div</b> (int __num, int __denom) __asm__('__divmodhi4')
       <b>ldiv_t</b> <b>ldiv</b> (long __num, long __denom) __asm__('__divmodsi4')
       void <b>qsort</b> (void *__base, size_t __nmemb, size_t __size, <b>__compar_fn_t</b> __compar)
       long <b>strtol</b> (const char *__nptr, char **__endptr, int __base)
       unsigned long <b>strtoul</b> (const char *__nptr, char **__endptr, int __base)
       long <b>atol</b> (const char *__s)
       int <b>atoi</b> (const char *__s)
       void <b>exit</b> (int __status)
       void * <b>malloc</b> (size_t __size)
       void <b>free</b> (void *__ptr)
       void * <b>calloc</b> (size_t __nele, size_t __size)
       void * <b>realloc</b> (void *__ptr, size_t __size)
       float <b>strtof</b> (const char *__nptr, char **__endptr)
       double <b>strtod</b> (const char *__nptr, char **__endptr)
       long double <b>strtold</b> (const char *__nptr, char **__endptr)
       int <b>atexit</b> (void(*func)(void))
       float <b>atoff</b> (const char *__nptr)
       double <b>atof</b> (const char *__nptr)
       long double <b>atofl</b> (const char *__nptr)
       int <b>rand</b> (void)
       void <b>srand</b> (unsigned int __seed)
       int <b>rand_r</b> (unsigned long *__ctx)

   <b>Variables</b>
       size_t <b>__malloc_margin</b>
       char * <b>__malloc_heap_start</b>
       char * <b>__malloc_heap_end</b>

   <b>Non-standard</b> <b>(i.e.</b> <b>non-ISO</b> <b>C)</b> <b>functions.</b>
       char * <b>ltoa</b> (long val, char *s, int radix)
       char * <b>utoa</b> (unsigned int val, char *s, int radix)
       char * <b>ultoa</b> (unsigned long val, char *s, int radix)
       long <b>random</b> (void)
       void <b>srandom</b> (unsigned long __seed)
       long <b>random_r</b> (unsigned long *__ctx)
       char * <b>itoa</b> (int val, char *s, int radix)
       #define <b>RANDOM_MAX</b>   0x7FFFFFFF

   <b>Conversion</b> <b>functions</b> <b>for</b> <b>double</b> <b>arguments.</b>
       char * <b>ftostre</b> (float __val, char *__s, unsigned char __prec, unsigned char __flags)
       char * <b>dtostre</b> (double __val, char *__s, unsigned char __prec, unsigned char __flags)
       char * <b>ldtostre</b> (long double __val, char *__s, unsigned char __prec, unsigned char __flags)
       char * <b>ftostrf</b> (float __val, signed char __width, unsigned char __prec, char *__s)
       char * <b>dtostrf</b> (double __val, signed char __width, unsigned char __prec, char *__s)
       char * <b>ldtostrf</b> (long double __val, signed char __width, unsigned char __prec, char *__s)
       #define <b>DTOSTR_ALWAYS_SIGN</b>   0x01        /* put '+' or ' ' for positives */
       #define <b>DTOSTR_PLUS_SIGN</b>   0x02        /* put '+' rather than ' ' */
       #define <b>DTOSTR_UPPERCASE</b>   0x04        /* put 'E' rather 'e' */
       #define <b>EXIT_SUCCESS</b>   0
       #define <b>EXIT_FAILURE</b>   1

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

       This file declares some basic C macros and functions as defined by the ISO standard, plus some AVR-
       specific extensions.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>DTOSTR_ALWAYS_SIGN</b>   <b>0x01</b>        <b>/*</b> <b>put</b> <b>'+'</b> <b>or</b> <b>'</b> <b>'</b> <b>for</b> <b>positives</b> <b>*/</b>
       Bit value that can be passed in flags to <b>ftostre()</b>, <b>dtostre()</b> and <b>ldtostre()</b>.

   <b>#define</b> <b>DTOSTR_PLUS_SIGN</b>   <b>0x02</b>        <b>/*</b> <b>put</b> <b>'+'</b> <b>rather</b> <b>than</b> <b>'</b> <b>'</b> <b>*/</b>
       Bit value that can be passed in flags to <b>ftostre()</b>, <b>dtostre()</b> and <b>ldtostre()</b>.

   <b>#define</b> <b>DTOSTR_UPPERCASE</b>   <b>0x04</b>        <b>/*</b> <b>put</b> <b>'E'</b> <b>rather</b> <b>'e'</b> <b>*/</b>
       Bit value that can be passed in flags to <b>ftostre()</b>, <b>dtostre()</b> and <b>ldtostre()</b>.

   <b>#define</b> <b>EXIT_FAILURE</b>   <b>1</b>
       Unsuccessful termination for <b>exit()</b>; evaluates to a non-zero value.

   <b>#define</b> <b>EXIT_SUCCESS</b>   <b>0</b>
       Successful termination for <b>exit()</b>; evaluates to 0.

   <b>#define</b> <b>RAND_MAX</b>   <b>0x7FFF</b>
       Highest number that can be generated by <b>rand()</b>.

   <b>#define</b> <b>RANDOM_MAX</b>   <b>0x7FFFFFFF</b>
       Highest number that can be generated by <b>random()</b>.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>int(*</b> <b>__compar_fn_t)</b> <b>(const</b> <b>void</b> <b>*,</b> <b>const</b> <b>void</b> <b>*)</b>
       Comparision function type for <b>qsort()</b>, just for convenience.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>abort</b> <b>(void)</b> <b>[extern]</b>
       The <b>abort()</b> function causes abnormal program termination to occur. This realization disables interrupts
       and jumps to _exit() function with argument equal to 1. In the limited AVR environment, execution is
       effectively halted by entering an infinite loop.

   <b>int</b> <b>abs</b> <b>(int</b> <b>__i)</b> <b>[extern]</b>
       The <b>abs()</b> function computes the absolute value of the integer i.

       <b>Note</b>
           The <b>abs()</b> and <b>labs()</b> functions are builtins of gcc.

   <b>int</b> <b>atexit</b> <b>(void(*)(void)</b> <b>func)</b> <b>[extern]</b>
       The <b>atexit()</b> function registers function <u>func</u> to be run as part of the <b>exit()</b> <b>function</b> <b>during</b> <b>.fini8.</b>
       <b>atexit()</b> <b>calls</b> <b>malloc().</b>

   <b>double</b> <b>atof</b> <b>(const</b> <b>char</b> <b>*</b> <b>nptr)</b> <b>[extern]</b>
       The <b>atof()</b> function converts the initial portion of the string pointed to by <u>nptr</u> to double
       representation.

       It is equivalent to calling

       strtod(nptr, (char**) 0);

   <b>float</b> <b>atoff</b> <b>(const</b> <b>char</b> <b>*</b> <b>nptr)</b> <b>[extern]</b>
       The <b>atoff()</b> function converts the initial portion of the string pointed to by <u>nptr</u> to float
       representation.

       It is equivalent to calling

       strtof(nptr, (char**) 0);

   <b>long</b> <b>double</b> <b>atofl</b> <b>(const</b> <b>char</b> <b>*</b> <b>nptr)</b> <b>[extern]</b>
       The <b>atofl()</b> function converts the initial portion of the string pointed to by <u>nptr</u> to long double
       representation.

       It is equivalent to calling

       strtold(nptr, (char**) 0);

   <b>int</b> <b>atoi</b> <b>(const</b> <b>char</b> <b>*</b> <b>__s)</b> <b>[extern]</b>
       The <b>atoi()</b> function converts the initial portion of the string pointed to by s to integer representation.
       In contrast to

       (int)strtol(s, (char **)NULL, 10);

       this function does not detect overflow (errno is not changed and the result value is not predictable),
       uses smaller memory (flash and stack) and works more quickly.

   <b>long</b> <b>atol</b> <b>(const</b> <b>char</b> <b>*</b> <b>__s)</b> <b>[extern]</b>
       The <b>atol()</b> function converts the initial portion of the string pointed to by s to long integer
       representation. In contrast to

       strtol(s, (char **)NULL, 10);

       this function does not detect overflow (errno is not changed and the result value is not predictable),
       uses smaller memory (flash and stack) and works more quickly.

   <b>void</b> <b>*</b> <b>bsearch</b> <b>(const</b> <b>void</b> <b>*</b> <b>__key,</b> <b>const</b> <b>void</b> <b>*</b> <b>__base,</b> <b>size_t</b> <b>__nmemb,</b> <b>size_t</b> <b>__size,</b> <b>int(*)(const</b> <b>void</b> <b>*,</b>
       <b>const</b> <b>void</b> <b>*)</b> <b>__compar)</b> <b>[extern]</b>
       The <b>bsearch()</b> function searches an array of nmemb objects, the initial member of which is pointed to by
       base, for a member that matches the object pointed to by key. The size of each member of the array is
       specified by size.

       The contents of the array should be in ascending sorted order according to the comparison function
       referenced by compar. The compar routine is expected to have two arguments which point to the key object
       and to an array member, in that order, and should return an integer less than, equal to, or greater than
       zero if the key object is found, respectively, to be less than, to match, or be greater than the array
       member.

       The <b>bsearch()</b> function returns a pointer to a matching member of the array, or a null pointer if no match
       is found. If two members compare as equal, which member is matched is unspecified.

   <b>void</b> <b>*</b> <b>calloc</b> <b>(size_t</b> <b>__nele,</b> <b>size_t</b> <b>__size)</b> <b>[extern]</b>
       Allocate nele elements of size each. Identical to calling malloc() using nele * size as argument, except
       the allocated memory will be cleared to zero.

   <b>div_t</b> <b>div</b> <b>(int</b> <b>__num,</b> <b>int</b> <b>__denom)</b> <b>[extern]</b>
       The <b>div()</b> function computes the value num/denom and returns the quotient and remainder in a structure
       named <b>div_t</b> <b>that</b> <b>contains</b> <b>two</b> <b>int</b> <b>members</b> <b>named</b> <b>quot</b> <b>and</b> <b>rem.</b>

   <b>char</b> <b>*</b> <b>dtostre</b> <b>(double</b> <b>__val,</b> <b>char</b> <b>*</b> <b>__s,</b> <b>unsigned</b> <b>char</b> <b>__prec,</b> <b>unsigned</b> <b>char</b> <b>__flags)</b> <b>[extern]</b>
       The <b>dtostre()</b> function is similar to the <b>ftostre()</b> function, except that it converts a double value
       instead of a float value.

       <b>dtostre()</b> is currently only supported when double is a 32-bit type.

   <b>char</b> <b>*</b> <b>dtostrf</b> <b>(double</b> <b>__val,</b> <b>signed</b> <b>char</b> <b>__width,</b> <b>unsigned</b> <b>char</b> <b>__prec,</b> <b>char</b> <b>*</b> <b>__s)</b> <b>[extern]</b>
       The <b>dtostrf()</b> function is similar to the <b>ftostrf()</b> function, except that converts a double value instead
       of a float value.

       <b>ldtostre()</b> is currently only supported when double is a 32-bit type.

   <b>void</b> <b>exit</b> <b>(int</b> <b>__status)</b> <b>[extern]</b>
       The <b>exit()</b> function terminates the application. Since there is no environment to return to, status is
       ignored, and code execution will eventually reach an infinite loop, thereby effectively halting all code
       processing. Before entering the infinite loop, interrupts are globally disabled.

       Global destructors will be called before halting execution, see the <b>.fini</b> sections.

   <b>void</b> <b>free</b> <b>(void</b> <b>*</b> <b>__ptr)</b> <b>[extern]</b>
       The free() function causes the allocated memory referenced by ptr to be made available for future
       allocations. If ptr is NULL, no action occurs.

   <b>char</b> <b>*</b> <b>ftostre</b> <b>(float</b> <b>__val,</b> <b>char</b> <b>*</b> <b>__s,</b> <b>unsigned</b> <b>char</b> <b>__prec,</b> <b>unsigned</b> <b>char</b> <b>__flags)</b> <b>[extern]</b>
       The <b>ftostre()</b> function converts the float value passed in val into an ASCII representation that will be
       stored under s. The caller is responsible for providing sufficient storage in s.

       Conversion is done in the format "[-]d.dddedd" where there is one digit before the decimal-point
       character and the number of digits after it is equal to the precision prec; if the precision is zero, no
       decimal-point character appears. If flags has the <b>DTOSTR_UPPERCASE</b> bit set, the letter 'E' (rather than
       'e' ) will be used to introduce the exponent. The exponent always contains two digits; if the value is
       zero, the exponent is '00'.

       If flags has the <b>DTOSTR_ALWAYS_SIGN</b> bit set, a space character will be placed into the leading position
       for positive numbers.

       If flags has the <b>DTOSTR_PLUS_SIGN</b> bit set, a plus sign will be used instead of a space character in this
       case.

       The <b>ftostre()</b> function returns the pointer to the converted string s.

   <b>char</b> <b>*</b> <b>ftostrf</b> <b>(float</b> <b>__val,</b> <b>signed</b> <b>char</b> <b>__width,</b> <b>unsigned</b> <b>char</b> <b>__prec,</b> <b>char</b> <b>*</b> <b>__s)</b> <b>[extern]</b>
       The <b>ftostrf()</b> function converts the float value passed in val into an ASCII representationthat will be
       stored in s. The caller is responsible for providing sufficient storage in s.

       Conversion is done in the format '[-]d.ddd'. The minimum field width of the output string (including the
       possible '.' and the possible sign for negative values) is given in width, and prec determines the number
       of digits after the decimal sign. width is signed value, negative for left adjustment.

       The <b>ftostrf()</b> function returns the pointer to the converted string s.

   <b>char</b> <b>*</b> <b>itoa</b> <b>(int</b> <b>val,</b> <b>char</b> <b>*</b> <b>s,</b> <b>int</b> <b>radix)</b> <b>[extern]</b>
       Convert an integer to a string. The function <b>itoa()</b> converts the integer value from val into an ASCII
       representation that will be stored under s. The caller is responsible for providing sufficient storage in
       s.

       <b>Note</b>
           The minimal size of the buffer s depends on the choice of radix. For example, if the radix is 2
           (binary), you need to supply a buffer with a minimal length of 8 * sizeof (int) + 1 characters, i.e.
           one character for each bit plus one for the string terminator. Using a larger radix will require a
           smaller minimal buffer size.

       <b>Warning</b>
           If the buffer is too small, you risk a buffer overflow.

       Conversion is done using the radix as base, which may be a number between 2 (binary conversion) and up to
       36. If radix is greater than 10, the next digit after '9' will be the letter 'a'.

       If radix is 10 and val is negative, a minus sign will be prepended.

       The <b>itoa()</b> function returns the pointer passed as s.

   <b>long</b> <b>labs</b> <b>(long</b> <b>__i)</b> <b>[extern]</b>
       The <b>labs()</b> function computes the absolute value of the long integer i.

       <b>Note</b>
           The <b>abs()</b> and <b>labs()</b> functions are builtins of gcc.

   <b>ldiv_t</b> <b>ldiv</b> <b>(long</b> <b>__num,</b> <b>long</b> <b>__denom)</b> <b>[extern]</b>
       The <b>ldiv()</b> function computes the value num/denom and returns the quotient and remainder in a structure
       named <b>ldiv_t</b> <b>that</b> <b>contains</b> <b>two</b> <b>long</b> <b>integer</b> <b>members</b> <b>named</b> <b>quot</b> <b>and</b> <b>rem.</b>

   <b>char</b> <b>*</b> <b>ldtostre</b> <b>(long</b> <b>double</b> <b>__val,</b> <b>char</b> <b>*</b> <b>__s,</b> <b>unsigned</b> <b>char</b> <b>__prec,</b> <b>unsigned</b> <b>char</b> <b>__flags)</b> <b>[extern]</b>
       The <b>ldtostre()</b> function is similar to the <b>ftostre()</b> function, except that it converts a long double value
       instead of a float value.

       <b>ldtostre()</b> is currently only supported when long double is a 32-bit type.

   <b>char</b> <b>*</b> <b>ldtostrf</b> <b>(long</b> <b>double</b> <b>__val,</b> <b>signed</b> <b>char</b> <b>__width,</b> <b>unsigned</b> <b>char</b> <b>__prec,</b> <b>char</b> <b>*</b> <b>__s)</b> <b>[extern]</b>
       The <b>ldtostrf()</b> function is similar to the <b>ftostrf()</b> function, except that converts a long double value
       instead of a float value.

       <b>ldtostre()</b> is currently only supported when long double is a 32-bit type.

   <b>char</b> <b>*</b> <b>ltoa</b> <b>(long</b> <b>val,</b> <b>char</b> <b>*</b> <b>s,</b> <b>int</b> <b>radix)</b> <b>[extern]</b>
       Convert a long integer to a string. The function <b>ltoa()</b> converts the long integer value from val into an
       ASCII representation that will be stored under s. The caller is responsible for providing sufficient
       storage in s.

       <b>Note</b>
           The minimal size of the buffer s depends on the choice of radix. For example, if the radix is 2
           (binary), you need to supply a buffer with a minimal length of 8 * sizeof (long int) + 1 characters,
           i.e. one character for each bit plus one for the string terminator. Using a larger radix will require
           a smaller minimal buffer size.

       <b>Warning</b>
           If the buffer is too small, you risk a buffer overflow.

       Conversion is done using the radix as base, which may be a number between 2 (binary conversion) and up to
       36. If radix is greater than 10, the next digit after '9' will be the letter 'a'.

       If radix is 10 and val is negative, a minus sign will be prepended.

       The <b>ltoa()</b> function returns the pointer passed as s.

   <b>void</b> <b>*</b> <b>malloc</b> <b>(size_t</b> <b>__size)</b> <b>[extern]</b>
       The malloc() function allocates size bytes of memory. If malloc() fails, a NULL pointer is returned.

       Note that malloc() does <u>not</u> initialize the returned memory to zero bytes.

       See the chapter about <b>malloc()</b> <b>usage</b> for implementation details.

   <b>void</b> <b>qsort</b> <b>(void</b> <b>*</b> <b>__base,</b> <b>size_t</b> <b>__nmemb,</b> <b>size_t</b> <b>__size,</b> <b>__compar_fn_t</b> <b>__compar)</b> <b>[extern]</b>
       The <b>qsort()</b> function is a modified partition-exchange sort, or quicksort.

       The <b>qsort()</b> function sorts an array of nmemb objects, the initial member of which is pointed to by base.
       The size of each object is specified by size. The contents of the array base are sorted in ascending
       order according to a comparison function pointed to by compar, which requires two arguments pointing to
       the objects being compared.

       The comparison function must return an integer less than, equal to, or greater than zero if the first
       argument is considered to be respectively less than, equal to, or greater than the second.

   <b>int</b> <b>rand</b> <b>(void)</b> <b>[extern]</b>
       The <b>rand()</b> function computes a sequence of pseudo-random integers in the range of 0 to RAND_MAX (as
       defined by the header file &lt;<b>stdlib.h</b>&gt;).

       The <b>srand()</b> function sets its argument seed as the seed for a new sequence of pseudo-random numbers to be
       returned by <b>rand()</b>. These sequences are repeatable by calling <b>srand()</b> with the same seed value.

       If no seed value is provided, the functions are automatically seeded with a value of 1.

       In compliance with the C standard, these functions operate on int arguments. Since the underlying
       algorithm already uses 32-bit calculations, this causes a loss of precision. See <b>random()</b> <b>for</b> <b>an</b>
       <b>alternate</b> <b>set</b> <b>of</b> <b>functions</b> <b>that</b> <b>retains</b> <b>full</b> <b>32-bit</b> <b>precision.</b>

   <b>int</b> <b>rand_r</b> <b>(unsigned</b> <b>long</b> <b>*</b> <b>__ctx)</b> <b>[extern]</b>
       Variant of <b>rand()</b> that stores the context in the user-supplied variable located at ctx instead of a
       static library variable so the function becomes re-entrant.

   <b>long</b> <b>random</b> <b>(void)</b> <b>[extern]</b>
       The <b>random()</b> function computes a sequence of pseudo-random integers in the range of 0 to RANDOM_MAX (as
       defined by the header file &lt;<b>stdlib.h</b>&gt;).

       The <b>srandom()</b> function sets its argument seed as the seed for a new sequence of pseudo-random numbers to
       be returned by <b>rand()</b>. These sequences are repeatable by calling <b>srandom()</b> with the same seed value.

       If no seed value is provided, the functions are automatically seeded with a value of 1.

   <b>long</b> <b>random_r</b> <b>(unsigned</b> <b>long</b> <b>*</b> <b>__ctx)</b> <b>[extern]</b>
       Variant of <b>random()</b> that stores the context in the user-supplied variable located at ctx instead of a
       static library variable so the function becomes re-entrant.

   <b>void</b> <b>*</b> <b>realloc</b> <b>(void</b> <b>*</b> <b>__ptr,</b> <b>size_t</b> <b>__size)</b> <b>[extern]</b>
       The realloc() function tries to change the size of the region allocated at ptr to the new size value. It
       returns a pointer to the new region. The returned pointer might be the same as the old pointer, or a
       pointer to a completely different region.

       The contents of the returned region up to either the old or the new size value (whatever is less) will be
       identical to the contents of the old region, even in case a new region had to be allocated.

       It is acceptable to pass ptr as NULL, in which case realloc() will behave identical to malloc().

       If the new memory cannot be allocated, realloc() returns NULL, and the region at ptr will not be changed.

   <b>void</b> <b>srand</b> <b>(unsigned</b> <b>int</b> <b>__seed)</b> <b>[extern]</b>
       Pseudo-random number generator seeding; see <b>rand()</b>.

   <b>void</b> <b>srandom</b> <b>(unsigned</b> <b>long</b> <b>__seed)</b> <b>[extern]</b>
       Pseudo-random number generator seeding; see <b>random()</b>.

   <b>double</b> <b>strtod</b> <b>(const</b> <b>char</b> <b>*</b> <b>__nptr,</b> <b>char</b> <b>**</b> <b>__endptr)</b> <b>[extern]</b>
       The <b>strtod()</b> function is similar to <b>strtof()</b>, except that the conversion result is of type double instead
       of float.

       <b>strtod()</b> is currently only supported when double is a 32-bit type.

   <b>float</b> <b>strtof</b> <b>(const</b> <b>char</b> <b>*</b> <b>nptr,</b> <b>char</b> <b>**</b> <b>endptr)</b> <b>[extern]</b>
       The <b>strtof()</b> function converts the initial portion of the string pointed to by <u>nptr</u> to float
       representation.

       The expected form of the string is an optional plus ( '+' ) or minus sign ( '-' ) followed by a sequence
       of digits optionally containing a decimal-point character, optionally followed by an exponent. An
       exponent consists of an 'E' or 'e', followed by an optional plus or minus sign, followed by a sequence of
       digits.

       Leading white-space characters in the string are skipped.

       The <b>strtof()</b> function returns the converted value, if any.

       If <u>endptr</u> is not NULL, a pointer to the character after the last character used in the conversion is
       stored in the location referenced by <u>endptr</u>.

       If no conversion is performed, zero is returned and the value of <u>nptr</u> is stored in the location
       referenced by <u>endptr</u>.

       If the correct value would cause overflow, plus or minus INFINITY is returned (according to the sign of
       the value), and ERANGE is stored in errno. If the correct value would cause underflow, zero is returned
       and ERANGE is stored in errno.

   <b>long</b> <b>strtol</b> <b>(const</b> <b>char</b> <b>*</b> <b>__nptr,</b> <b>char</b> <b>**</b> <b>__endptr,</b> <b>int</b> <b>__base)</b> <b>[extern]</b>
       The <b>strtol()</b> function converts the string in nptr to a long value. The conversion is done according to
       the given base, which must be between 2 and 36 inclusive, or be the special value 0.

       The string may begin with an arbitrary amount of white space (as determined by <b>isspace()</b>) followed by a
       single optional '+' or '-' sign. If base is zero or 16, the string may then include a '0x' prefix, and
       the number will be read in base 16; otherwise, a zero base is taken as 10 (decimal) unless the next
       character is '0', in which case it is taken as 8 (octal).

       The remainder of the string is converted to a long value in the obvious manner, stopping at the first
       character which is not a valid digit in the given base. (In bases above 10, the letter 'A' in either
       upper or lower case represents 10, 'B' represents 11, and so forth, with 'Z' representing 35.)

       If endptr is not NULL, <b>strtol()</b> stores the address of the first invalid character in *endptr. If there
       were no digits at all, however, <b>strtol()</b> stores the original value of nptr in endptr. (Thus, if *nptr is
       not '\0' but **endptr is '\0' on return, the entire string was valid.)

       The <b>strtol()</b> function returns the result of the conversion, unless the value would underflow or overflow.
       If no conversion could be performed, 0 is returned. If an overflow or underflow occurs, errno is set to
       <b>ERANGE</b> and the function return value is clamped to LONG_MIN or LONG_MAX, respectively.

   <b>long</b> <b>double</b> <b>strtold</b> <b>(const</b> <b>char</b> <b>*</b> <b>__nptr,</b> <b>char</b> <b>**</b> <b>__endptr)</b> <b>[extern]</b>
       The <b>strtold()</b> function is similar to <b>strtof()</b>, except that the conversion result is of type long double
       instead of float.

       <b>strtold()</b> is currently only supported when long double is a 32-bit type.

   <b>unsigned</b> <b>long</b> <b>strtoul</b> <b>(const</b> <b>char</b> <b>*</b> <b>__nptr,</b> <b>char</b> <b>**</b> <b>__endptr,</b> <b>int</b> <b>__base)</b> <b>[extern]</b>
       The <b>strtoul()</b> function converts the string in nptr to an unsigned long value. The conversion is done
       according to the given base, which must be between 2 and 36 inclusive, or be the special value 0.

       The string may begin with an arbitrary amount of white space (as determined by <b>isspace()</b>) followed by a
       single optional '+' or '-' sign. If base is zero or 16, the string may then include a '0x' prefix, and
       the number will be read in base 16; otherwise, a zero base is taken as 10 (decimal) unless the next
       character is '0', in which case it is taken as 8 (octal).

       The remainder of the string is converted to an unsigned long value in the obvious manner, stopping at the
       first character which is not a valid digit in the given base. (In bases above 10, the letter 'A' in
       either upper or lower case represents 10, 'B' represents 11, and so forth, with 'Z' representing 35.)

       If endptr is not NULL, <b>strtoul()</b> stores the address of the first invalid character in *endptr. If there
       were no digits at all, however, <b>strtoul()</b> stores the original value of nptr in endptr. (Thus, if *nptr is
       not '\0' but **endptr is '\0' on return, the entire string was valid.)

       The <b>strtoul()</b> function return either the result of the conversion or, if there was a leading minus sign,
       the negation of the result of the conversion, unless the original (non-negated) value would overflow; in
       the latter case, <b>strtoul()</b> returns ULONG_MAX, and errno is set to <b>ERANGE</b>. If no conversion could be
       performed, 0 is returned.

   <b>char</b> <b>*</b> <b>ultoa</b> <b>(unsigned</b> <b>long</b> <b>val,</b> <b>char</b> <b>*</b> <b>s,</b> <b>int</b> <b>radix)</b> <b>[extern]</b>
       Convert an unsigned long integer to a string. The function <b>ultoa()</b> converts the unsigned long integer
       value from val into an ASCII representation that will be stored under s. The caller is responsible for
       providing sufficient storage in s.

       <b>Note</b>
           The minimal size of the buffer s depends on the choice of radix. For example, if the radix is 2
           (binary), you need to supply a buffer with a minimal length of 8 * sizeof (unsigned long int) + 1
           characters, i.e. one character for each bit plus one for the string terminator. Using a larger radix
           will require a smaller minimal buffer size.

       <b>Warning</b>
           If the buffer is too small, you risk a buffer overflow.

       Conversion is done using the radix as base, which may be a number between 2 (binary conversion) and up to
       36. If radix is greater than 10, the next digit after '9' will be the letter 'a'.

       The <b>ultoa()</b> function returns the pointer passed as s.

   <b>char</b> <b>*</b> <b>utoa</b> <b>(unsigned</b> <b>int</b> <b>val,</b> <b>char</b> <b>*</b> <b>s,</b> <b>int</b> <b>radix)</b> <b>[extern]</b>
       Convert an unsigned integer to a string. The function <b>utoa()</b> converts the unsigned integer value from val
       into an ASCII representation that will be stored under s. The caller is responsible for providing
       sufficient storage in s.

       <b>Note</b>
           The minimal size of the buffer s depends on the choice of radix. For example, if the radix is 2
           (binary), you need to supply a buffer with a minimal length of 8 * sizeof (unsigned int) + 1
           characters, i.e. one character for each bit plus one for the string terminator. Using a larger radix
           will require a smaller minimal buffer size.

       <b>Warning</b>
           If the buffer is too small, you risk a buffer overflow.

       Conversion is done using the radix as base, which may be a number between 2 (binary conversion) and up to
       36. If radix is greater than 10, the next digit after '9' will be the letter 'a'.

       The <b>utoa()</b> function returns the pointer passed as s.

</pre><h4><b>Variable</b> <b>Documentation</b></h4><pre>
   <b>char*</b> <b>__malloc_heap_end</b> <b>[extern]</b>
       malloc() <b>tunable</b>.

   <b>char*</b> <b>__malloc_heap_start</b> <b>[extern]</b>
       malloc() <b>tunable</b>.

   <b>size_t</b> <b>__malloc_margin</b> <b>[extern]</b>
       malloc() <b>tunable</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for AVR-LibC from the source code.

AVR-LibC                                          Version 2.2.1                                 <u><a href="../man3avr/avr_stdlib.3avr.html">avr_stdlib</a></u>(3avr)
</pre>
 </div>
</div></section>
</div>
</body>
</html>