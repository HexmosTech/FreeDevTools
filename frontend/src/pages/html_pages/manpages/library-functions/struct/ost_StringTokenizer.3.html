<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ost::StringTokenizer - Splits delimited string into tokens.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libcommoncpp2-doc">libcommoncpp2-doc_1.8.1-10_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ost::StringTokenizer - Splits delimited string into tokens.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;tokenizer.h&gt;

   <b>Classes</b>
       class <b>iterator</b>
           The input forward iterator for tokens.
       class <b>NoSuchElementException</b>
           Exception thrown, if someone tried to read beyond the end of the tokens.

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>StringTokenizer</b> (const char *str, const char *delim, bool skipAllDelim=false, bool trim=false)
           creates a new <b>StringTokenizer</b> for a string and a given set of delimiters.
       <b>StringTokenizer</b> (const char *s)
           create a new <b>StringTokenizer</b> which splits the input string at whitespaces.
       <b>iterator</b> <b>begin</b> () const
           returns the begin iterator
       void <b>setDelimiters</b> (const char *d)
           changes the set of delimiters used in subsequent iterations.
       <b>iterator</b> <b>begin</b> (const char *d)
           returns a begin iterator with an alternate set of delimiters.
       const <b>iterator</b> &amp; <b>end</b> () const
           the iterator marking the end.

   <b>Static</b> <b>Public</b> <b>Attributes</b>
       static const char *const <b>SPACE</b>
           a delimiter string containing all usual whitespace delimiters.

   <b>Friends</b>
       class <b>StringTokenizer::iterator</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Splits delimited string into tokens.

       The <b>StringTokenizer</b> takes a pointer to a string and a pointer to a string containing a number of possible
       delimiters. The <b>StringTokenizer</b> provides an input forward iterator which allows to iterate through all
       tokens. An iterator behaves like a logical pointer to the tokens, i.e. to shift to the next token, you've
       to increment the iterator, you get the token by dereferencing the iterator.

       Memory consumption: This class operates on the original string and only allocates memory for the
       individual tokens actually requested, so this class allocates at maximum the space required for the
       longest token in the given string. Since for each iteration, memory is reclaimed for the last token, you
       MAY NOT store pointers to them; if you need them afterwards, copy them. You may not modify the original
       string while you operate on it with the <b>StringTokenizer</b>; the behaviour is undefined in that case.

       The iterator has one special method 'nextDelimiter()' which returns a character containing the next
       delimiter following this tokenization process or '\0', if there are no following delimiters. In case of
       skipAllDelim, it returns the FIRST delimiter.

       With the method '<b>setDelimiters(const</b> <b>char*)</b>' you may change the set of delimiters. It affects all running
       iterators.

       Example:

        <b>StringTokenizer</b> st('mary had a little lamb;its fleece was..', ' ;');
        <b>StringTokenizer::iterator</b> i;
        for (i = st.begin() ; i != st.end() ; ++i) {
              cout &lt;&lt; 'Token: '' &lt;&lt; *i &lt;&lt; ''\t';
              cout &lt;&lt; ' next Delim: '' &lt;&lt; i.nextDelimiter() &lt;&lt; ''' &lt;&lt; endl;
        }

       <b>Author</b>
           Henner Zeller <a href="mailto:H.Zeller@acm.org">H.Zeller@acm.org</a>

       <b>License:\n</b> <b>LGPL</b>

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>ost::StringTokenizer::StringTokenizer</b> <b>(const</b> <b>char</b> <b>*</b> <b>str,</b> <b>const</b> <b>char</b> <b>*</b> <b>delim,</b> <b>bool</b> <b>skipAllDelim</b> <b>=</b> <b>false,</b> <b>bool</b>
       <b>trim</b> <b>=</b> <b>false)</b>
       creates a new <b>StringTokenizer</b> for a string and a given set of delimiters.

       <b>Parameters</b>
           <u>str</u> <b>String</b> to be split up. This string will not be modified by this <b>StringTokenizer</b>, but you may as
           well not modfiy this string while tokenizing is in process, which may lead to undefined behaviour.
           <u>delim</u> <b>String</b> containing the characters which should be regarded as delimiters.
           <u>skipAllDelim</u> OPTIONAL. true, if subsequent delimiters should be skipped at once or false, if empty
           tokens should be returned for two delimiters with no other text inbetween. The first behaviour may be
           desirable for whitespace skipping, the second for input with delimited entry e.g. <a href="file:/etc/passwd">/etc/passwd</a> like
           files or CSV input. NOTE, that 'true' here resembles the ANSI-C strtok(char *s,char *d) behaviour.
           DEFAULT = false
           <u>trim</u> OPTIONAL. true, if the tokens returned should be trimmed, so that they don't have any
           whitespaces at the beginning or end. Whitespaces are any of the characters defined in
           <b>StringTokenizer::SPACE</b>. If delim itself is <b>StringTokenizer::SPACE</b>, this will result in a behaviour
           with skipAllDelim = true. DEFAULT = false

   <b>ost::StringTokenizer::StringTokenizer</b> <b>(const</b> <b>char</b> <b>*</b> <b>s)</b>
       create a new <b>StringTokenizer</b> which splits the input string at whitespaces. The tokens are stripped from
       whitespaces. This means, if you change the set of delimiters in either the '<b>begin(const</b> <b>char</b> <b>*delim)</b>'
       method or in '<b>setDelimiters()</b>', you then get whitespace trimmed tokens, delimited by the new set. Behaves
       like StringTokenizer(s, StringTokenizer::SPACE,false,true);

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>iterator</b> <b>ost::StringTokenizer::begin</b> <b>()</b> <b>const</b> <b>[inline]</b>
       returns the begin iterator

   <b>iterator</b> <b>ost::StringTokenizer::begin</b> <b>(const</b> <b>char</b> <b>*</b> <b>d)</b> <b>[inline]</b>
       returns a begin iterator with an alternate set of delimiters.

   <b>const</b> <b>iterator&amp;</b> <b>ost::StringTokenizer::end</b> <b>(void)</b> <b>const</b> <b>[inline]</b>
       the iterator marking the end.

   <b>void</b> <b>ost::StringTokenizer::setDelimiters</b> <b>(const</b> <b>char</b> <b>*</b> <b>d)</b> <b>[inline]</b>
       changes the set of delimiters used in subsequent iterations.

</pre><h4><b>Friends</b> <b>And</b> <b>Related</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>friend</b> <b>class</b> <b>StringTokenizer::iterator</b> <b>[friend]</b>
</pre><h4><b>Member</b> <b>Data</b> <b>Documentation</b></h4><pre>
   <b>const</b> <b>char*</b> <b>const</b> <b>ost::StringTokenizer::SPACE</b> <b>[static]</b>
       a delimiter string containing all usual whitespace delimiters. These are space, tab, newline, carriage
       return, formfeed and vertical tab. (see isspace() manpage).

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for GNU CommonC++ from the source code.

GNU CommonC++                                    Sun Dec 27 2020                         <u>ost::<a href="../man3/StringTokenizer.3.html">StringTokenizer</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>