<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hal_stream - non-blocking realtime streams</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/linuxcnc-uspace-dev">linuxcnc-uspace-dev_2.9.4-2ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       hal_stream - non-blocking realtime streams

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>#include</b> <b>&lt;hal.h&gt;</b>

   int hal_stream_create(hal_stream_t *stream, int comp_id, int key, int depth, const char *typestring);
   void hal_stream_destroy(hal_stream_t *stream);
   int hal_stream_attach(hal_stream_t *stream, int comp_id, int key, const char *typestring);
   int hal_stream_detach(hal_stream_t *stream);

   int hal_stream_element_count(hal_stream_t *stream);
   hal_type_t hal_stream_element_type(hal_stream_t *stream, int idx);
   int hal_stream_depth(hal_stream_t *stream);
   int hal_stream_maxdepth(hal_stream_t *stream);
   int hal_stream_num_underruns(hal_stream_t *stream);
   int hal_stream_num_overruns(hal_stream_t *stream);

   int hal_stream_read(hal_stream_t *stream, union hal_stream_data *buf, unsigned *sampleno);
   bool hal_stream_readable(hal_stream_t *stream);

   int hal_stream_write(hal_stream_t *stream, union hal_stream_data *buf);
   bool hal_stream_writable(hal_stream_t *stream);

   <b>#ifdef</b> <b>ULAPI</b>
   void hal_stream_wait_writable(hal_stream_t *stream, sig_atomic_t *stop);
   void hal_stream_wait_readable(hal_stream_t *stream, sig_atomic_t *stop);
   <b>#endif</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A  HAL stream provides a limited ability for two components to communicate data which does not fit within
       the model of HAL pins.  A reader and a writer must agree on a <u>key</u> (32-bit integer identifier) and a  data
       structure  specified  by  <u>typestring.</u>   They  must also agree which component (the first one loaded) will
       <b>hal_stream_create</b> the stream, and which component (the second one loaded) will <b>hal_stream_attach</b>  to  the
       already-created stream.

       The non-realtime part can be <b>halstreamer</b> or <b>halsampler</b>.  In the case of <b>halstreamer</b> the key is 0x48535430
       plus the channel number.  In the case of <b>halsampler</b> the key is 0x48534130 plus the channel number.

   <b>hal_stream_create</b>
       Create  the  given  stream,  initializing  the <u>stream</u> which is passed by reference.  It is an undiagnosed
       error if a stream has already been created with the same <u>key</u>.

   <b>hal_stream_destroy</b>
       Destroy the given stream.  It is an undiagnosed  error  if  the  stream  is  still  attached  by  another
       component.   It  is  an  undiagnosed  error if the stream was attached with <b>hal_stream_attach</b> rather than
       created with <b>hal_stream_create</b>.  It is an undiagnosed error if the call to <b>hal_stream_destroy</b> is omitted.

   <b>hal_stream_attach</b>
       Attach the given stream, which was already created by <b>hal_stream_create</b>.  If the typestring is specified,
       this call fails if it does not match the typestring the stream  was  created  with.   If  the  typestring
       argument is NULL, then any typestring is accepted.

   <b>hal_stream_detach</b>
       Detach  the  given  stream.   It is an undiagnosed error if the stream was created with <b>hal_stream_create</b>
       rather than attached with <b>hal_stream_attach</b>.  It is an undiagnosed error if the call to <b>hal_stream_detach</b>
       is omitted.

   <b>hal_stream_element_count</b>
       Returns the number of pins.

   <b>hal_stream_element_type</b>
       Returns the type of the given pin number.

   <b>hal_stream_readable</b>
       Returns true if the stream has at least one sample to read

   <b>hal_stream_read</b>
       If the stream has one sample to read, stores it in buf.

   <b>hal_stream_writable</b>
       Returns true if the stream has room for at least one sample to be written.

   <b>hal_stream_depth</b>
       Returns the number of samples waiting to be read.

   <b>hal_stream_maxdepth</b>
       Returns the <b>depth</b> argument that the stream was created with.

   <b>hal_stream_num_overruns</b>
       Returns a number which is incremented each time <b>hal_stream_write</b> is called without space available.

   <b>hal_stream_num_underruns</b>
       Returns a number which is incremented each time <b>hal_stream_read</b> is called without a sample available.

   <b>hal_stream_wait_readable</b>
       Waits until the stream is readable or the stop flag is set.

   <b>hal_stream_wait_writable</b>
       Waits until the stream is writable or the stop flag is set.

   <b>hal_stream_read</b>
       Reads a record from stream.  If successful, it is stored in the given  buffer.   Optionally,  the  sample
       number  can  be retrieved.  If no sample is available, <u>num_underruns</u> is incremented.  It is an undetected
       error if more than one component or real-time function calls <b>hal_stream_read</b> concurrently.

   <b>hal_stream_write</b>
       Writes a record to the stream.  If successful, it copied from the given buffer.  If no room is available,
       <u>num_overruns</u> is incremented.  In either case, the internal <u>sampleno</u> value is incremented.
         It is an undetected error if more than one  component  or  real-time  function  calls  <b>hal_stream_write</b>
       concurrently.

</pre><h4><b>ARGUMENTS</b></h4><pre>
       <u>stream</u> A  pointer  to a stream object.  In the case of <b>hal_stream_create</b> and <b>hal_stream_attach</b> this is an
              uninitialized stream; in other cases, it must be a stream created or attached by an  earlier  call
              and not yet detached or destroyed.

       <u>hal_id</u> An HAL component identifier returned by an earlier call to <b>hal_init</b>.

       <u>key</u>    The key for the shared memory segment.

       <u>depth</u>  The number of samples that can be unread before any samples are lost (overrun)

       <u>typestring</u>
              A  typestring  is  a  case-insensitive  string which consists of one or more of the following type
              characters:

           B      for bool / hal_bit_t

           S      for int32_t / hal_s32_t

           U      for uint32_t / hal_u32_t

           F      for real_t / hal_float_t
       A typestring is limited to 16 characters.

       <u>buf</u>    A buffer big enough to hold all the data in one sample.

       <u>sampleno</u>
              If non-NULL, the last sample number is stored here.   Gaps  in  this  sequence  indicate  that  an
              overrun  occurred  between  the previous read and this one.  May be NULL, in which case the sample
              number is not retrieved.

       <u>stop</u>   A pointer to a value which is monitored while waiting.  If  it  is  nonzero,  the  wait  operation
              returns early.  This allows a wait call to be safely terminated in the case of a signal.

</pre><h4><b>SAMPLE</b> <b>CODE</b></h4><pre>
       In  the  source tree under <u>src/hal/components</u>, <b>sampler.c</b> and <b>streamer.c</b> are realtime components that read
       and write HAL streams.

</pre><h4><b>REALTIME</b> <b>CONSIDERATIONS</b></h4><pre>
       <b>hal_stream_read</b>, <b>hal_stream_readable</b>,  <b>hal_stream_write</b>,  <b>hal_stream_writable</b>,  <b>hal_stream_element_count</b>,
       <b>hal_tream_pin_type</b>,        <b>hal_stream_depth</b>,        <b>hal_stream_maxdepth</b>,        <b>hal_stream_num_underruns</b>,
       <b>hal_stream_number_overruns</b> may be called from realtime code.

       <b>hal_stream_wait_writable</b>, <b>hal_stream_wait_writable</b> may be called from ULAPI code.

       Other functions may be called in any context, including realtime contexts.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>hal_stream_create</b> , <b>hal_stream_attach</b>  ,  <b>hal_stream_read</b>  ,  <b>hal_stream_write</b>  ,  <b>hal_stream_detach</b>  and
       <b>hal_stream_destroy</b> return an RTAPI status code.  Other functions' return values are explained above.

</pre><h4><b>BUGS</b></h4><pre>
       The  memory  overhead  of a stream can be large.  Each element in a record uses 8 bytes, and the implicit
       sample number also uses 8 bytes.  As a result, a stream which is used to transport 8-bit values uses  94%
       of  its  memory  as  overhead.   However,  for modest stream sizes this overhead is not important.  (this
       memory is part of its own shared memory region and does not count against the HAL  shared  memory  region
       used for pins, parameters and signals)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man9/sampler.9.html">sampler</a></b>(9), <b><a href="../man9/streamer.9.html">streamer</a></b>(9), <b><a href="../man1/halsampler.1.html">halsampler</a></b>(1), <b><a href="../man1/halstreamer.1.html">halstreamer</a></b>(1)

LinuxCNC Documentation                             2006-10-12                                   <u><a href="../man3hal/hal_stream.3hal.html">hal_stream</a></u>(3hal)
</pre>
 </div>
</div></section>
</div>
</body>
</html>