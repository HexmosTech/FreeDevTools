<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSL_key_update, SSL_get_key_update_type, SSL_renegotiate, SSL_renegotiate_abbreviated,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SSL_key_update, SSL_get_key_update_type, SSL_renegotiate, SSL_renegotiate_abbreviated,
       SSL_renegotiate_pending - initiate and obtain information about updating connection keys

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/ssl.h&gt;

        int SSL_key_update(SSL *s, int updatetype);
        int SSL_get_key_update_type(const SSL *s);

        int SSL_renegotiate(SSL *s);
        int SSL_renegotiate_abbreviated(SSL *s);
        int SSL_renegotiate_pending(const SSL *s);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>SSL_key_update()</b> schedules an update of the keys for the current TLS connection.  If the <b>updatetype</b>
       parameter is set to <b>SSL_KEY_UPDATE_NOT_REQUESTED</b> then the sending keys for this connection will be
       updated and the peer will be informed of the change. If the <b>updatetype</b> parameter is set to
       <b>SSL_KEY_UPDATE_REQUESTED</b> then the sending keys for this connection will be updated and the peer will be
       informed of the change along with a request for the peer to additionally update its sending keys. It is
       an error if <b>updatetype</b> is set to <b>SSL_KEY_UPDATE_NONE</b>.

       <b>SSL_key_update()</b> must only be called after the initial handshake has been completed and TLSv1.3 or QUIC
       has been negotiated, at the same time, the application needs to ensure that the writing of data has been
       completed. The key update will not take place until the next time an IO operation such as <b>SSL_read_ex()</b>
       or <b>SSL_write_ex()</b> takes place on the connection. Alternatively <b>SSL_do_handshake()</b> can be called to force
       the update to take place immediately.

       <b>SSL_get_key_update_type()</b> can be used to determine whether a key update operation has been scheduled but
       not yet performed. The type of the pending key update operation will be returned if there is one, or
       SSL_KEY_UPDATE_NONE otherwise.

       <b>SSL_renegotiate()</b> and <b>SSL_renegotiate_abbreviated()</b> should only be called for connections that have
       negotiated TLSv1.2 or less. Calling them on any other connection will result in an error.

       When called from the client side, <b>SSL_renegotiate()</b> schedules a completely new handshake over an existing
       SSL/TLS connection. The next time an IO operation such as <b>SSL_read_ex()</b> or <b>SSL_write_ex()</b> takes place on
       the connection a check will be performed to confirm that it is a suitable time to start a renegotiation.
       If so, then it will be initiated immediately. OpenSSL will not attempt to resume any session associated
       with the connection in the new handshake.

       When called from the client side, <b>SSL_renegotiate_abbreviated()</b> works in the same was as
       <b>SSL_renegotiate()</b> except that OpenSSL will attempt to resume the session associated with the current
       connection in the new handshake.

       When called from the server side, <b>SSL_renegotiate()</b> and <b>SSL_renegotiate_abbreviated()</b> behave identically.
       They both schedule a request for a new handshake to be sent to the client. The next time an IO operation
       is performed then the same checks as on the client side are performed and then, if appropriate, the
       request is sent. The client may or may not respond with a new handshake and it may or may not attempt to
       resume an existing session. If a new handshake is started then this will be handled transparently by
       calling any OpenSSL IO function.

       If an OpenSSL client receives a renegotiation request from a server then again this will be handled
       transparently through calling any OpenSSL IO function. For a TLS connection the client will attempt to
       resume the current session in the new handshake. For historical reasons, DTLS clients will not attempt to
       resume the session in the new handshake.

       The <b>SSL_renegotiate_pending()</b> function returns 1 if a renegotiation or renegotiation request has been
       scheduled but not yet acted on, or 0 otherwise.

</pre><h4><b>USAGE</b> <b>WITH</b> <b>QUIC</b></h4><pre>
       <b>SSL_key_update()</b> can also be used to perform a key update when using QUIC. The function must be called on
       a QUIC connection SSL object. This is normally done automatically when needed. Since a locally initiated
       QUIC key update always causes a peer to also trigger a key update, passing <b>SSL_KEY_UPDATE_NOT_REQUESTED</b>
       as <b>updatetype</b> has the same effect as passing <b>SSL_KEY_UPDATE_REQUESTED</b>.

       The QUIC connection must have been fully established before a key update can be performed, and other QUIC
       protocol rules govern how frequently QUIC key update can be performed. <b>SSL_key_update()</b> will fail if
       these requirements are not met.

       Because QUIC key updates are always handled immediately, <b>SSL_get_key_update_type()</b> always returns
       SSL_KEY_UPDATE_NONE when called on a QUIC connection SSL object.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>SSL_key_update()</b>, <b>SSL_renegotiate()</b> and <b>SSL_renegotiate_abbreviated()</b> return 1 on success or 0 on error.

       <b>SSL_get_key_update_type()</b> returns the update type of the pending key update operation or
       SSL_KEY_UPDATE_NONE if there is none.

       <b>SSL_renegotiate_pending()</b> returns 1 if a renegotiation or renegotiation request has been scheduled but
       not yet acted on, or 0 otherwise.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/ssl.7.html">ssl</a></b>(7), <b><a href="../man3/SSL_read_ex.3.html">SSL_read_ex</a></b>(3), <b><a href="../man3/SSL_write_ex.3.html">SSL_write_ex</a></b>(3), <b><a href="../man3/SSL_do_handshake.3.html">SSL_do_handshake</a></b>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>SSL_key_update()</b> and <b>SSL_get_key_update_type()</b> functions were added in OpenSSL 1.1.1.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2017-2023 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                               <u><a href="../man3SSL/SSL_KEY_UPDATE.3SSL.html">SSL_KEY_UPDATE</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>