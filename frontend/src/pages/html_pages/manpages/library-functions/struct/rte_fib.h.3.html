<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rte_fib.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dpdk-doc">dpdk-doc_24.11.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rte_fib.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;rte_rcu_qsbr.h&gt;

   <b>Data</b> <b>Structures</b>
       struct <b>rte_fib_conf</b>
       struct <b>rte_fib_rcu_config</b>

   <b>Macros</b>
       #define <b>RTE_FIB_MAXDEPTH</b>   32
       #define <b>RTE_FIB_F_LOOKUP_NETWORK_ORDER</b>   1

   <b>Typedefs</b>
       <b>typedef</b> int(* <b>rte_fib_modify_fn_t</b>) (struct rte_fib *fib, uint32_t ip, uint8_t depth, uint64_t next_hop,
           int op)
       <b>typedef</b> void(* <b>rte_fib_lookup_fn_t</b>) (void *fib, const uint32_t *ips, uint64_t *next_hops, const unsigned
           int n)

   <b>Enumerations</b>
       enum <b>rte_fib_qsbr_mode</b> { <b>RTE_FIB_QSBR_MODE_DQ</b> = 0, <b>RTE_FIB_QSBR_MODE_SYNC</b> }
       enum <b>rte_fib_type</b> { <b>RTE_FIB_DUMMY</b>, <b>RTE_FIB_DIR24_8</b> }
       enum <b>rte_fib_dir24_8_nh_sz</b>
       enum <b>rte_fib_lookup_type</b> { <b>RTE_FIB_LOOKUP_DEFAULT</b>, <b>RTE_FIB_LOOKUP_DIR24_8_SCALAR_MACRO</b>,
           <b>RTE_FIB_LOOKUP_DIR24_8_SCALAR_INLINE</b>, <b>RTE_FIB_LOOKUP_DIR24_8_SCALAR_UNI</b>,
           <b>RTE_FIB_LOOKUP_DIR24_8_VECTOR_AVX512</b> }

   <b>Functions</b>
       struct rte_fib * <b>rte_fib_create</b> (const char *name, int socket_id, struct <b>rte_fib_conf</b> *conf)
       struct rte_fib * <b>rte_fib_find_existing</b> (const char *name)
       void <b>rte_fib_free</b> (struct rte_fib *fib)
       int <b>rte_fib_add</b> (struct rte_fib *fib, uint32_t ip, uint8_t depth, uint64_t next_hop)
       int <b>rte_fib_delete</b> (struct rte_fib *fib, uint32_t ip, uint8_t depth)
       int <b>rte_fib_lookup_bulk</b> (struct rte_fib *fib, uint32_t *ips, uint64_t *next_hops, int n)
       void * <b>rte_fib_get_dp</b> (struct rte_fib *fib)
       struct rte_rib * <b>rte_fib_get_rib</b> (struct rte_fib *fib)
       int <b>rte_fib_select_lookup</b> (struct rte_fib *fib, enum <b>rte_fib_lookup_type</b> type)
       __rte_experimental int <b>rte_fib_rcu_qsbr_add</b> (struct rte_fib *fib, struct <b>rte_fib_rcu_config</b> *cfg)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       RTE FIB library.

       FIB (Forwarding information base) implementation for IPv4 Longest Prefix Match

       Definition in file <b>rte_fib.h</b>.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>RTE_FIB_MAXDEPTH</b>   <b>32</b>
       Maximum depth value possible for IPv4 FIB.

       Definition at line <b>30</b> of file <b>rte_fib.h</b>.

   <b>#define</b> <b>RTE_FIB_F_LOOKUP_NETWORK_ORDER</b>   <b>1</b>
       If set, fib lookup is expecting IPv4 address in network byte order

       Definition at line <b>91</b> of file <b>rte_fib.h</b>.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>int(*</b> <b>rte_fib_modify_fn_t)</b> <b>(struct</b> <b>rte_fib</b> <b>*fib,</b> <b>uint32_t</b> <b>ip,</b> <b>uint8_t</b> <b>depth,</b> <b>uint64_t</b> <b>next_hop,</b> <b>int</b>
       <b>op)</b>
       Modify FIB function

       Definition at line <b>52</b> of file <b>rte_fib.h</b>.

   <b>typedef</b> <b>void(*</b> <b>rte_fib_lookup_fn_t)</b> <b>(void</b> <b>*fib,</b> <b>const</b> <b>uint32_t</b> <b>*ips,</b> <b>uint64_t</b> <b>*next_hops,</b> <b>const</b> <b>unsigned</b> <b>int</b>
       <b>n)</b>
       FIB bulk lookup function

       Definition at line <b>55</b> of file <b>rte_fib.h</b>.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>rte_fib_qsbr_mode</b>
       RCU reclamation modes

       <b>Enumerator</b>

       <u>RTE_FIB_QSBR_MODE_DQ</u>
              Create defer queue for reclaim.

       <u>RTE_FIB_QSBR_MODE_SYNC</u>
              Use blocking mode reclaim. No defer queue created.

       Definition at line <b>38</b> of file <b>rte_fib.h</b>.

   <b>enum</b> <b>rte_fib_type</b>
       Type of FIB struct

       <b>Enumerator</b>

       <u>RTE_FIB_DUMMY</u>
              RIB tree based FIB

       <u>RTE_FIB_DIR24_8</u>
              DIR24_8 based FIB

       Definition at line <b>46</b> of file <b>rte_fib.h</b>.

   <b>enum</b> <b>rte_fib_dir24_8_nh_sz</b>
       Size of nexthop (1 &lt;&lt; nh_sz) bits for DIR24_8 based FIB

       Definition at line <b>64</b> of file <b>rte_fib.h</b>.

   <b>enum</b> <b>rte_fib_lookup_type</b>
       Type of lookup function implementation

       <b>Enumerator</b>

       <u>RTE_FIB_LOOKUP_DEFAULT</u>
              Selects the best implementation based on the max simd bitwidth

       <u>RTE_FIB_LOOKUP_DIR24_8_SCALAR_MACRO</u>
              Macro based lookup function

       <u>RTE_FIB_LOOKUP_DIR24_8_SCALAR_INLINE</u>
              Lookup implementation using inlined functions for different next hop sizes

       <u>RTE_FIB_LOOKUP_DIR24_8_SCALAR_UNI</u>
              Unified lookup function for all next hop sizes

       <u>RTE_FIB_LOOKUP_DIR24_8_VECTOR_AVX512</u>
              Vector implementation using AVX512

       Definition at line <b>72</b> of file <b>rte_fib.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>struct</b> <b>rte_fib</b> <b>*</b> <b>rte_fib_create</b> <b>(const</b> <b>char</b> <b>*</b> <b>name,</b> <b>int</b> <b>socket_id,</b> <b>struct</b> <b>rte_fib_conf</b> <b>*</b> <b>conf)</b>
       Create FIB

       <b>Parameters</b>
           <u>name</u> FIB name
           <u>socket_id</u> NUMA socket ID for FIB table memory allocation
           <u>conf</u> Structure containing the configuration

       <b>Returns</b>
           Handle to the FIB object on success NULL otherwise with rte_errno set to an appropriate values.

   <b>struct</b> <b>rte_fib</b> <b>*</b> <b>rte_fib_find_existing</b> <b>(const</b> <b>char</b> <b>*</b> <b>name)</b>
       Find an existing FIB object and return a pointer to it.

       <b>Parameters</b>
           <u>name</u> Name of the fib object as passed to <b>rte_fib_create()</b>

       <b>Returns</b>
           Pointer  to  fib  object  or  NULL  if  object  not  found with rte_errno set appropriately. Possible
           rte_errno values include:

           • ENOENT - required entry not available to return.

   <b>void</b> <b>rte_fib_free</b> <b>(struct</b> <b>rte_fib</b> <b>*</b> <b>fib)</b>
       Free an FIB object.

       <b>Parameters</b>
           <u>fib</u> FIB object handle created by <b>rte_fib_create()</b>. If fib is NULL, no operation is performed.

   <b>int</b> <b>rte_fib_add</b> <b>(struct</b> <b>rte_fib</b> <b>*</b> <b>fib,</b> <b>uint32_t</b> <b>ip,</b> <b>uint8_t</b> <b>depth,</b> <b>uint64_t</b> <b>next_hop)</b>
       Add a route to the FIB.

       <b>Parameters</b>
           <u>fib</u> FIB object handle
           <u>ip</u> IPv4 prefix address to be added to the FIB
           <u>depth</u> Prefix length
           <u>next_hop</u> Next hop to be added to the FIB

       <b>Returns</b>
           0 on success, negative value otherwise

   <b>int</b> <b>rte_fib_delete</b> <b>(struct</b> <b>rte_fib</b> <b>*</b> <b>fib,</b> <b>uint32_t</b> <b>ip,</b> <b>uint8_t</b> <b>depth)</b>
       Delete a rule from the FIB.

       <b>Parameters</b>
           <u>fib</u> FIB object handle
           <u>ip</u> IPv4 prefix address to be deleted from the FIB
           <u>depth</u> Prefix length

       <b>Returns</b>
           0 on success, negative value otherwise

   <b>int</b> <b>rte_fib_lookup_bulk</b> <b>(struct</b> <b>rte_fib</b> <b>*</b> <b>fib,</b> <b>uint32_t</b> <b>*</b> <b>ips,</b> <b>uint64_t</b> <b>*</b> <b>next_hops,</b> <b>int</b> <b>n)</b>
       Lookup multiple IP addresses in the FIB.

       <b>Parameters</b>
           <u>fib</u> FIB object handle
           <u>ips</u> Array of IPs to be looked up in the FIB
           <u>next_hops</u> Next hop of the most specific rule found for IP. This is an array of eight byte values.  If
           the  lookup  for  the given IP failed, then corresponding element would contain default nexthop value
           configured for a FIB.
           <u>n</u> Number of elements in ips (and next_hops) array to lookup.

       <b>Returns</b>
           -EINVAL for incorrect arguments, otherwise 0

   <b>void</b> <b>*</b> <b>rte_fib_get_dp</b> <b>(struct</b> <b>rte_fib</b> <b>*</b> <b>fib)</b>
       Get pointer to the dataplane specific struct

       <b>Parameters</b>
           <u>fib</u> FIB object handle

       <b>Returns</b>
           Pointer on the dataplane struct on success NULL otherwise

   <b>struct</b> <b>rte_rib</b> <b>*</b> <b>rte_fib_get_rib</b> <b>(struct</b> <b>rte_fib</b> <b>*</b> <b>fib)</b>
       Get pointer to the RIB

       <b>Parameters</b>
           <u>fib</u> FIB object handle

       <b>Returns</b>
           Pointer on the RIB on success NULL otherwise

   <b>int</b> <b>rte_fib_select_lookup</b> <b>(struct</b> <b>rte_fib</b> <b>*</b> <b>fib,</b> <b>enum</b> <b>rte_fib_lookup_type</b> <b>type)</b>
       Set lookup function based on type

       <b>Parameters</b>
           <u>fib</u> FIB object handle
           <u>type</u> type of lookup function

       <b>Returns</b>
           0 on success -EINVAL on failure

   <b>__rte_experimental</b> <b>int</b> <b>rte_fib_rcu_qsbr_add</b> <b>(struct</b> <b>rte_fib</b> <b>*</b> <b>fib,</b> <b>struct</b> <b>rte_fib_rcu_config</b> <b>*</b> <b>cfg)</b>
       Associate RCU QSBR variable with a FIB object.

       <b>Parameters</b>
           <u>fib</u> FIB object handle
           <u>cfg</u> RCU QSBR configuration

       <b>Returns</b>
           0 on success Negative otherwise Possible error codes are:

           • -EINVAL - invalid parameters

           • -EEXIST - already added QSBR

           • -ENOMEM - memory allocation failure

           • -ENOTSUP - not supported by configured dataplane algorithm

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for DPDK from the source code.

DPDK                                             Version 24.11.2                                    <u><a href="../man3/rte_fib.h.3.html">rte_fib.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>