<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dbz - Database routines for InterNetNews</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/inn2-dev">inn2-dev_2.7.3-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dbz - Database routines for InterNetNews

</pre><h4><b>SYNOPSIS</b></h4><pre>
           #include &lt;inn/dbz.h&gt;

           #define DBZMAXKEY              ...
           #define DBZ_INTERNAL_HASH_SIZE ...

           typedef enum
           {
               DBZSTORE_OK,
               DBZSTORE_EXISTS,
               DBZSTORE_ERROR
           } DBZSTORE_RESULT;

           typedef enum
           {
               INCORE_NO,
               INCORE_MEM,
               INCORE_MMAP
           } dbz_incore_val;

           typedef struct {
               bool writethrough;
               dbz_incore_val pag_incore;
               dbz_incore_val exists_incore;
               bool nonblock;
           } dbzoptions;

           typedef struct {
               char hash[DBZ_INTERNAL_HASH_SIZE];
           } __attribute__((__packed__)) erec;

           extern bool dbzinit(const char *name);
           extern bool dbzclose(void);

           extern bool dbzfresh(const char *name, off_t size);
           extern bool dbzagain(const char *name, const char *oldname);
           extern bool dbzexists(const HASH key);
           extern bool dbzfetch(const HASH key, off_t *value);
           extern DBZSTORE_RESULT dbzstore(const HASH key, off_t data);
           extern bool dbzsync(void);
           extern long dbzsize(off_t contents);
           extern void dbzsetoptions(const dbzoptions options);
           extern void dbzgetoptions(dbzoptions *options);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These functions provide an indexing system for rapid random access to a text file, hereafter named the
       <u>base</u> file.

       <u>dbz</u> stores offsets into the base file for rapid retrieval.  All retrievals are keyed on a hash value that
       is generated by the <b>HashMessageID</b> function in <a href="../man3/libinn.3.html">libinn</a>(3).

       <b>dbzinit</b> opens a database, an index into the base file <u>name</u>, consisting of files <u>name.dir</u>, <u>name.index</u>, and
       <u>name.hash</u> which must already exist.  (If the database is new, they should be zero-length files.)
       Subsequent accesses go to that database until <b>dbzclose</b> is called to close the database.  When tagged hash
       format is used (if <b>--enable-tagged-hash</b> was given at configure time), a <u>name.pag</u> file is used instead of
       <u>.index</u> and <u>.hash</u>.

       <b>dbzfetch</b> searches the database for the specified <u>key</u>, assigning the offset of the base file for the
       corresponding <u>key</u> to <u>value</u>, if any.

       <b>dbzstore</b> stores the <u>key</u>-<u>data</u> pair in the database.  It will return "DBZSTORE_EXISTS" for duplicates
       (already existing entries), and "DBZSTORE_OK" for success.  It will fail with "DBZSTORE_ERROR" if the
       database files are not writable or not opened, or if any other error occurs.

       <b>dbzexists</b> will verify whether or not the given hash exists or not.  <u>dbz</u> is optimized for this operation
       and it may be significantly faster than <b>dbzfetch</b>.

       <b>dbzfresh</b> is a variant of <b>dbzinit</b> for creating a new database with more control over details.  The <u>size</u>
       parameter specifies the size of the first hash table within the database, in number of key-value pairs.
       Performance will be best if the number of key-value pairs stored in the database does not exceed about
       2/3 of <u>size</u>, or 1/2 of <u>size</u> when the tagged hash format is used.  (The <b>dbzsize</b> function, given the
       expected number of key-value pairs, will suggest a database size that meets these criteria.)  Assuming
       that an <u>fseek</u> offset is 4 bytes, the <u>.index</u> file will be 4 * <u>size</u> bytes.  The <u>.hash</u> file will be
       "DBZ_INTERNAL_HASH_SIZE" * <u>size</u> bytes (the <u>.dir</u> file is tiny and roughly constant in size) until the
       number of key-value pairs exceeds about 80% of <u>size</u>.  (Nothing awful will happen if the database grows
       beyond 100% of <u>size</u>, but accesses will slow down quite a bit and the <u>.index</u> and <u>.hash</u> files will grow
       somewhat.)

       <u>dbz</u> stores up to "DBZ_INTERNAL_HASH_SIZE" bytes (by default, 4 bytes if tagged hash format is used, 6
       otherwise) of the Message-ID's hash in the <u>.hash</u> file to confirm a hit.  This eliminates the need to read
       the base file to handle collisions.

       A <u>size</u> of "0" given to <b>dbzfresh</b> is synonymous with the local default; the normal default is suitable for
       tables of about 6,000,000 key-value pairs (or 500,000 key-value pairs when the tagged hash format is
       used).  That default value is used by <b>dbzinit</b>.

       When databases are regenerated periodically, as it is the case for the <u>history</u> file, it is simplest to
       pick the parameters for a new database based on the old one.  This also permits some memory of past sizes
       of the old database, so that a new database size can be chosen to cover expected fluctuations.  <b>dbzagain</b>
       is a variant of <b>dbzinit</b> for creating a new database as a new generation of an old database.  The database
       files for <u>oldname</u> must exist.  <b>dbzagain</b> is equivalent to calling <b>dbzfresh</b> with a <u>size</u> equal to the result
       of applying <b>dbzsize</b> to the largest number of entries in the <u>oldname</u> database and its previous 10
       generations.

       When many accesses are being done by the same program, <u>dbz</u> is massively faster if its first hash table is
       in memory.  If the <u>pag_incore</u> flag is set to "INCORE_MEM", an attempt is made to read the table in when
       the database is opened, and <b>dbzclose</b> writes it out to disk again (if it was read successfully and has
       been modified).  <b>dbzsetoptions</b> can be used to set the <u>pag_incore</u> and <u>exists_incore</u> flags to different
       values which should be "INCORE_NO" (read from disk), "INCORE_MEM" (read from memory) or "INCORE_MMAP"
       (read from a mmap'ed file) for the <u>.hash</u> and <u>.index</u> files separately; this does not affect the status of
       a database that has already been opened.  The default is "INCORE_NO" for the <u>.index</u> file and
       "INCORE_MMAP" for the <u>.hash</u> file.  The attempt to read the table in may fail due to memory shortage; in
       this case <u>dbz</u> fails with an error.  Stores to an in-memory database are not (in general) written out to
       the file until <b>dbzclose</b> or <b>dbzsync</b>, so if robustness in the presence of crashes or concurrent accesses is
       crucial, in-memory databases should probably be avoided or the <u>writethrough</u> option should be set to true
       (telling to systematically write to the filesystem in addition to updating the in-memory database).

       If the <u>nonblock</u> option is true, then writes to the <u>.hash</u> and <u>.index</u> files will be done using non-blocking
       I/O.  This can be significantly faster if your platform supports non-blocking I/O with files.  It is only
       applicable if you're not mmap'ing the database.

       <b>dbzsync</b> causes all buffers etc. to be flushed out to the files.  It is typically used as a precaution
       against crashes or concurrent accesses when a <u>dbz</u>-using process will be running for a long time.  It is a
       somewhat expensive operation, especially for an in-memory database.

       Concurrent reading of databases is fairly safe, but there is no (inter)locking, so concurrent updating is
       not.

       An open database occupies three <u>stdio</u> streams and two file descriptors; Memory consumption is negligible
       except for in-memory databases (and <u>stdio</u> buffers).

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Functions returning <u>bool</u> values return true for success, false for failure.

       <b>dbzinit</b> attempts to have <u>errno</u> set plausibly on return, but otherwise this is not guaranteed.  An <u>errno</u>
       of "EDOM" from <b>dbzinit</b> indicates that the database did not appear to be in <u>dbz</u> format.

       If "DBZTEST" is defined at compile-time, then a <b>main()</b> function will be included.  This will do
       performance tests and integrity test.

</pre><h4><b>BUGS</b></h4><pre>
       Unlike <u>dbm</u>, <u>dbz</u> will refuse to <b>dbzstore</b> with a key already in the database.  The user is responsible for
       avoiding this.

       The RFC5322 case mapper implements only a first approximation to the hideously-complex RFC5322 case
       rules.

       <u>dbz</u> no longer tries to be call-compatible with <u>dbm</u> in any way.

</pre><h4><b>HISTORY</b></h4><pre>
       The original <u>dbz</u> was written by Jon Zeeff &lt;<a href="mailto:zeeff@b-tech.ann-arbor.mi.us">zeeff@b-tech.ann-arbor.mi.us</a>&gt;.  Later contributions by David
       Butler and Mark Moraes.  Extensive reworking, including this documentation, by Henry Spencer
       &lt;<a href="mailto:henry@zoo.toronto.edu">henry@zoo.toronto.edu</a>&gt; as part of the C News project.  MD5 code borrowed from RSA.  Extensive reworking
       to remove backwards compatibility and to add hashes into <u>dbz</u> files by Clayton O'Neill
       &lt;<a href="mailto:coneill@oneill.net">coneill@oneill.net</a>&gt;.  Rewritten into POD by Julien Elie.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/dbm.3.html">dbm</a>(3), <a href="../man5/history.5.html">history</a>(5), <a href="../man3/libinn.3.html">libinn</a>(3).

INN 2.7.3                                          2025-05-19                                      <u><a href="../man3/libinn_dbz.3.html">libinn_dbz</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>