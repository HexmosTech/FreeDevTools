<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>memmgr - memory manager abstraction functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/ion-doc">ion-doc_3.2.1+dfsg-1.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       memmgr - memory manager abstraction functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
           #include "memmgr.h"

           typedef void *(* MemAllocator)
               (char *fileName, int lineNbr, size_t size);
           typedef void (* MemDeallocator)
               (char *fileName, int lineNbr, void * blk);
           typedef void *(* MemAtoPConverter) (unsigned int address);
           typedef unsigned int (* MemPtoAConverter) (void * pointer);

           unsigned int memmgr_add       (char *name,
                                          MemAllocator take,
                                          MemDeallocator release,
                                          MemAtoPConverter AtoP,
                                          MemPtoAConverter PtoA);
           int memmgr_find               (char *name);
           char *memmgr_name             (int mgrId);
           MemAllocator memmgr_take      (int mgrId);
           MemDeallocator memmgr_release (int mgrId);
           MemAtoPConverter memmgr_AtoP  (int mgrId);
           MemPtoAConverter memmgr_PtoA  (int mgrId;

           int memmgr_open               (int memKey,
                                          unsigned long memSize,
                                          char **memPtr,
                                          int *smId,
                                          char *partitionName,
                                          PsmPartition *partition,
                                          int *memMgr,
                                          MemAllocator afn,
                                          MemDeallocator ffn,
                                          MemAtoPConverter apfn,
                                          MemPtoAConverter pafn);
           void memmgr_destroy           (int smId,
                                          PsmPartition *partition);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "memmgr" is an abstraction layer for administration of memory management.  It enables multiple memory
       managers to coexist in a single application.  Each memory manager specification is required to include
       pointers to a memory allocation function, a memory deallocation function, and functions for translating
       between local memory pointers and "addresses", which are abstract memory locations that have private
       meaning to the manager.  The allocation function is expected to return a block of memory of size "size"
       (in bytes), initialized to all binary zeroes.  The <u>fileName</u> and <u>lineNbr</u> arguments to the allocation and
       deallocation functions are expected to be the values of __FILE__ and __LINE__ at the point at which the
       functions are called; this supports any memory usage tracing via <u><a href="../man3/sptrace.3.html">sptrace</a></u>(3) that may be implemented by
       the underlying memory management system.

       Memory managers are identified by number and by name.  The identifying number for a memory manager is an
       index into a private, fixed-length array of up to 8 memory manager configuration structures; that is,
       memory manager number must be in the range 0-7.  However, memory manager numbers are assigned dynamically
       and not always predictably.  To enable multiple applications to use the same memory manager for a given
       segment of shared memory, a memory manager may be located by a predefined name of up to 15 characters
       that is known to all the applications.

       The memory manager with manager number 0 is always available; its name is "std".  Its memory allocation
       function is <u>calloc()</u>, its deallocation function is <u>free()</u>, and its pointer/address translation functions
       are merely casts.

       unsigned int memmgr_add(char *name, MemAllocator take, MemDeallocator release, MemAtoPConverter AtoP,
       MemPtoAConverter PtoA)
           Add  a  memory  manager  to  the  memory  manager  array, if not already defined; attempting to add a
           previously added memory manager is not considered an error.  <u>name</u> is the name of the memory  manager.
           <u>take</u>  is a pointer to the manager's memory allocation function; <u>release</u> is a pointer to the manager's
           memory deallocation function.  <u>AtoP</u> is a pointer to the manager's function for converting an  address
           to  a local memory pointer; <u>PtoA</u> is a pointer to the manager's pointer-to-address converter function.
           Returns the memory manager ID number assigned to the named manager, or -1 on any error.

           <u>NOTE</u>: <u>memmgr_add()</u> is NOT thread-safe.  In a  multithreaded  execution  image  (e.g.,  VxWorks),  all
           memory managers should be loaded <u>before</u> any subordinate threads or tasks are spawned.

       int memmgr_find(char *name)
           Return the memmgr ID of the named manager, or -1 if not found.

       char *memmgr_name(int mgrId)
           Return the name of the manager given by <u>mgrId</u>.

       MemAllocator memmgr_take(int mgrId)
           Return the allocator function pointer for the manager given by <u>mgrId</u>.

       memDeallocator memmgr_release(int mgrId)
           Return the deallocator function pointer for the manager given by <u>mgrId</u>.

       MemAtoPConverter memmgr_AtoP(int mgrId)
           Return the address-to-pointer converter function pointer for the manager given by <u>mgrId</u>.

       MemPtoAConverter memmgr_PtoA(int mgrId)
           Return the pointer-to-address converter function pointer for the manager given by <u>mgrId</u>.

       int memmgr_open(int memKey, unsigned long memSize, char **memPtr, int *smId, char *partitionName,
       PsmPartition *partition, int *memMgr, MemAllocator afn, MemDeallocator ffn, MemAtoPConverter apfn,
       MemPtoAConverter pafn);
           <u>memmgr_open()</u>  opens  one  avenue of access to a PSM managed region of shared memory, initializing as
           necessary.

           In order for multiple tasks to share access to this memory region, all must cite the same <u>memkey</u>  and
           <u>partitionName</u>  when  they  call <u>memmgr_open()</u>.  If shared access is not necessary, then <u>memKey</u> can be
           SM_NO_KEY and <u>partitionName</u> can be any valid partition name.

           If it is known that a prior invocation of <u>memmgr_open()</u> has  already  initialized  the  region,  then
           <u>memSize</u> can be zero and <u>memPtr</u> must be NULL.  Otherwise <u>memSize</u> is required and the required value of
           <u>memPtr</u>  depends  on  whether  or  not  the  memory  that is to be shared and managed has already been
           allocated (e.g., it's a fixed region of bus memory).  If so, then the memory  pointer  variable  that
           <u>memPtr</u>  points  to  must  contain the address of that memory region.  Otherwise, <u>*memPtr</u> must contain
           NULL.

           <u>memmgr_open()</u> will allocate system memory as necessary and will in any case return the address of the
           shared memory region in <u>*memPtr</u>.

           If the shared memory is newly allocated or otherwise not yet under PSM management, then <u>memmgr_open()</u>
           will invoke <u>psm_manage()</u> to manage the shared memory region.  It will also add a  catalogue  for  the
           managed shared memory region as necessary.

           If  <u>memMgr</u>  is  non-NULL,  then  <u>memmgr_open()</u> will additionally call <u>memmgr_add()</u> to establish a new
           memory manager for this managed shared memory region, as necessary.   The  index  of  the  applicable
           memory  manager  will  be  returned  in  <u>memMgr</u>.   If  that memory manager is newly created, then the
           supplied <u>afn</u>, <u>ffn</u>, <u>apfn</u>, and <u>pafn</u> functions (which can  be  written  with  reference  to  the  memory
           manager  index value returned in <u>memMgr</u>) have been established as the memory management functions for
           local private access to this managed shared memory region.

           Returns 0 on success, -1 on any error.

       void memmgr_destroy(int smId, PsmPartition *partition);
           <u>memmgr_destroy()</u> terminates all access to a PSM managed region of shared memory, invoking <u>psm_erase()</u>
           to destroy the partition and <u>sm_ShmDestroy()</u> to destroy the shared memory object.

</pre><h4><b>EXAMPLE</b></h4><pre>
           /* this example uses the calloc/free memory manager, which is
            * called "std", and is always defined in memmgr. */

            #include "memmgr.h"

            main()
            {
                int mgrId;
                MemAllocator myalloc;
                MemDeallocator myfree;
                char *newBlock;

                mgrId = memmgr_find("std");
                myalloc = <a href="../manmgrId/memmgr_take.mgrId.html">memmgr_take</a>(mgrId);
                myfree = <a href="../manmgrId/memmgr_release.mgrId.html">memmgr_release</a>(mgrId);
                ...

                newBlock = <a href="../man5000/myalloc.5000.html">myalloc</a>(5000);
                ...
                myfree(newBlock);
            }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/psm.3.html">psm</a></u>(3)

perl v5.24.1                                       2016-07-07                          <u>ici::doc::pod3::<a href="../man3/memmgr.3.html">memmgr</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>