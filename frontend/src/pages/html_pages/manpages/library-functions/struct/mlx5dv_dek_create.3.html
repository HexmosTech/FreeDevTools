<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mlx5dv_dek_create - Creates a DEK</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libibverbs-dev">libibverbs-dev_56.1-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mlx5dv_dek_create - Creates a DEK

       mlx5dv_dek_query - Queries a DEK’s attributes

       mlx5dv_dek_destroy - Destroys a DEK

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;infiniband/mlx5dv.h&gt;

              struct mlx5dv_dek *mlx5dv_dek_create(struct ibv_context *context,
                                   struct mlx5dv_dek_init_attr *init_attr);

              int mlx5dv_dek_query(struct mlx5dv_dek *dek, struct mlx5dv_dek_attr *attr);

              int mlx5dv_dek_destroy(struct mlx5dv_dek *dek);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Data Encryption Keys (DEKs) are used to encrypt and decrypt transmitted data.  After a DEK is created, it
       can be configured in MKeys for crypto offload operations.  DEKs are not persistent and are destroyed upon
       process exit.  Therefore, software process needs to re-create all needed DEKs on startup.

       <b>mlx5dv_dek_create()</b> creates a new DEK with the attributes specified in <u>init_attr</u>.  A pointer to the newly
       created dek is returned, which can be used for DEK query, DEK destruction and when configuring a MKey for
       crypto offload operations.

       The  DEK  can  be  either wrapped or in plaintext and the format that should be used is determined by the
       specified crypto_login object.

       To create a wrapped DEK, the application must have a valid crypto login object prior to creating the DEK.
       Creating a wrapped DEK can be performed in two ways: 1.  Call <b>mlx5dv_crypto_login_create()</b>  to  obtain  a
       crypto login object.  Indicate that the DEK is wrapped by setting <b>MLX5DV_DEK_INIT_ATTR_CRYPTO_LOGIN</b> value
       in  <u>comp_mask</u> and passing the crypto login object in <u>crypto_login</u> field of <u>init_attr</u>.  Fill the other DEK
       attributes and create the DEK.

       2. Call <b>mlx5dv_crypto_login()</b> i.e., the old API.  Supply credential, import_kek_id

       To create a plaintext DEK, the application must  indicate  that  the  DEK  is  in  plaintext  by  setting
       <b>MLX5DV_DEK_INIT_ATTR_CRYPTO_LOGIN</b>  value  in  <u>comp_mask</u>  and  passing NULL value in <u>crypto_login</u> field of
       <u>init_attr</u>, fill the other DEK attributes and create the DEK.

       To use the created DEK (either wrapped or plaintext) in a MKey, a valid crypto login object or session is
       not needed.  Revoking the import KEK or credential that were used for the crypto login object or  session
       (and therefore rendering the crypto login invalid) does not prevent using a created DEK.

       <b>mlx5dv_dek_query()</b>  queries the DEK specified by <u>dek</u> and returns the queried attributes in <u>attr</u>.  A valid
       crypto login object or session is not required to query a plaintext DEK.  On the other hand, to  query  a
       wrapped DEK a valid crypto login object or session must be present.

       <b>mlx5dv_dek_destroy()</b> destroys the DEK specified by <u>dek</u>.

</pre><h4><b>ARGUMENTS</b></h4><pre>
   <b>context</b>
       The device context to create the DEK with.

   <b>init_attr</b>
              enum mlx5dv_dek_init_attr_mask {
                  MLX5DV_DEK_INIT_ATTR_CRYPTO_LOGIN = 1 &lt;&lt; 0,
              };

              struct mlx5dv_dek_init_attr {
                  enum mlx5dv_crypto_key_size key_size;
                  bool has_keytag;
                  enum mlx5dv_crypto_key_purpose key_purpose;
                  struct ibv_pd *pd;
                  char opaque[8];
                  char key[128];
                  uint64_t comp_mask; /* Use enum mlx5dv_dek_init_attr_mask */
                  struct mlx5dv_crypto_login_obj *crypto_login;
              };

       <u>key_size</u>
              The size of the key, can be one of the following

              <b>MLX5DV_CRYPTO_KEY_SIZE_128</b>
                     Key size is 128 bit.

              <b>MLX5DV_CRYPTO_KEY_SIZE_256</b>
                     Key size is 256 bit.

       <u>has_keytag</u>
              Whether  the DEK has a keytag or not.  If set, the key should include a 8 Bytes keytag.  Keytag is
              used to verify that the DEK being used by a MKey is the expected DEK.  This is done  by  comparing
              the  keytag  that  was  defined  during  DEK  creation with the keytag provided in the MKey crypto
              configuration, and failing the operation if they are different.

       <u>key_purpose</u>
              The purpose of the key, currently can only be the following value

              <b>MLX5DV_CRYPTO_KEY_PURPOSE_AES_XTS</b>
                     The key will be used for AES-XTS crypto engine.

       <u>pd</u>     The protection domain to be associated with the DEK.

       <u>opaque</u> Plaintext metadata to describe the key.

       <u>key</u>    The key that will be used for encryption and decryption of transmitted data.   For  plaintext  DEK
              <u>key</u> must be provided in plaintext.  For wrapped DEK <u>key</u> must be provided wrapped by the import KEK
              that  was  specified  in  the  crypto  login.   Actual size and layout of this field depend on the
              provided <u>key_size</u> and <u>has_keytag</u> fields, as well as  on  the  format  of  the  key  (plaintext  or
              wrapped).  <u>key</u> should be constructed according to the following table.

              DEK <u>key</u> Field Construction.
              Import         Has Keytag   Key size     Key Layout
              Method
              ─────────────────────────────────────────────────────────────────────────────────
              Plaintext      No           128 Bit      key1_128b + key2_128b

              Plaintext      No           256 Bit      key1_256b + key2_256b

              Plaintext      Yes          128 Bit      key1_128b + key2_128b + keytag_64b

              Plaintext      Yes          256 Bit      key1_256b + key2_256b + keytag_64b

              Wrapped        No           128 Bit      ENC(iv_64b + key1_128b + key2_128b)

              Wrapped        No           256 Bit      ENC(iv_64b + key1_256b + key2_256b)

              Wrapped        Yes          128 Bit      ENC(iv_64b  +  key1_128b  + key2_128b +
                                                       keytag_64b)

              Wrapped        Yes          256 Bit      ENC(iv_64b + key1_256b  +  key2_256b  +
                                                       keytag_64b)

              Where  ENC() is AES key wrap algorithm and iv_64b is 0xA6A6A6A6A6A6A6A6 as per the NIST SP 800-38F
              AES key wrap spec.

              The following example shows how to wrap a 128 bit key that has keytag using a 128 bit  import  KEK
              in OpenSSL:

                     #include &lt;openssl/evp.h&gt;

                     unsigned char import_kek[16]; /* 128 bit import KEK in plaintext for wrapping */
                     unsigned char iv[8] = {0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6};

                     /*
                      * Indexes 0-15 are key1 in plaintext, indexes 16-31 are key2 in plaintext,
                      * and indexes 32-39 are key_tag in plaintext.
                      */
                     unsigned char key[40];

                     unsigned char wrapped_key[48];
                     EVP_CIPHER_CTX *ctx;
                     int len;

                     ctx = EVP_CIPHER_CTX_new();
                     EVP_CIPHER_CTX_set_flags(ctx, EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);
                     EVP_EncryptInit_ex(ctx, EVP_aes_128_wrap(), NULL, import_kek, iv);
                     EVP_EncryptUpdate(ctx, wrapped_key, &amp;len, key, sizeof(key));
                     EVP_EncryptFinal_ex(ctx, wrapped_key + len, &amp;len);
                     EVP_CIPHER_CTX_free(ctx);

       <u>comp_mask</u>
              Currently can be the following value:

              <b>MLX5DV_DEK_INIT_ATTR_CRYPTO_LOGIN</b>, which indicates that <u>crypto_login</u> field is applicable.

       <u>crypto_login</u>
              Pointer to a crypto login object.  If set to a valid crypto login object, indicates that this is a
              wrapped  DEK  that will be created using the given crypto login object.  If set to NULL, indicates
              that this is a plaintext DEK.  Must be NULL if <b>MLX5DV_DEK_INIT_ATTR_CRYPTO_LOGIN</b> is not set.  Only
              relevant when comp_mask is set with <u>MLX5DV_DEK_INIT_ATTR_CRYPTO_LOGIN</u>

   <b>dek</b>
              Pointer to an existing DEK to query or to destroy.

   <b>attr</b>
              DEK attributes to be populated when querying a DEK.

              struct mlx5dv_dek_attr {
                  enum mlx5dv_dek_state state;
                  char opaque[8];
                  uint64_t comp_mask;
              };

       <u>state</u>  The state of the DEK, can be one of the following

              <b>MLX5DV_DEK_STATE_READY</b>
                     The key is ready for use.  This is the state of the key when it is first created.

              <b>MLX5DV_DEK_STATE_ERROR</b>
                     The key is unusable.  The key needs to be destroyed and re-created in  order  to  be  used.
                     This can happen, for example, due to DEK memory corruption.

       <u>opaque</u> Plaintext metadata to describe the key.

       <u>comp_mask</u>
              Reserved for future extension, must be 0 now.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>mlx5dv_dek_create()</b>  returns  a pointer to a new <u>struct</u> <u>mlx5dv_dek</u> on success.  On error NULL is returned
       and errno is set.

       <b>mlx5dv_dek_query()</b> returns 0 on success and updates <u>attr</u> with the queried DEK attributes.  On error errno
       value is returned.

       <b>mlx5dv_dek_destroy()</b> returns 0 on success and errno value on error.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/mlx5dv_crypto_login.3.html">mlx5dv_crypto_login</a></b>(3), <b><a href="../man3/mlx5dv_crypto_login_create.3.html">mlx5dv_crypto_login_create</a></b>(3), <b><a href="../man3/mlx5dv_query_device.3.html">mlx5dv_query_device</a></b>(3)

</pre><h4><b>AUTHORS</b></h4><pre>
       Avihai Horon <a href="mailto:avihaih@nvidia.com">avihaih@nvidia.com</a>

                                                         <u>mlx5dv_dek_create</u> <u>/</u> <u>mlx5...uery</u> <u>/</u> <u><a href="../man3/mlx5dv_dek_destroy.3.html">mlx5dv_dek_destroy</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>