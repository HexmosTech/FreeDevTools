<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>remctl_open - Connect to a remote remctl server</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libremctl-dev">libremctl-dev_3.18-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       remctl_open - Connect to a remote remctl server

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;remctl.h&gt;

       int <b>remctl_open</b>(struct remctl *<u>r</u>, const char *<u>host</u>,
                          unsigned short <u>port</u>,
                          const char *<u>principal</u>);

       int <b>remctl_open_addrinfo</b>(struct remctl *<u>r</u>, const char *<u>host</u>,
                                   const struct addrinfo *<u>ai</u>,
                                   const char *<u>principal</u>);

       int <b>remctl_open_sockaddr</b>(struct remctl *<u>r</u>, const char *<u>host</u>,
                                   const struct sockaddr *<u>addr</u>, int <u>addrlen</u>,
                                   const char *<u>principal</u>);

       int <b>remctl_open_fd</b>(struct remctl *<u>r</u>, const char *<u>host</u>,
                             int <u>fd</u>, const char *<u>principal</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>remctl_open()</b> opens a TCP connection to the given <u>host</u> on the given <u>port</u> and then authenticates using the
       remctl protocol and the service principal <u>principal</u>.  <u>r</u> is a remctl struct created via <b>remctl_new()</b>.
       <u>host</u> must not be NULL.  If <u>port</u> is 0, the library first attempts to connect to the registered port of
       4373 and then tries the legacy port of 4444 if that fails.  Future versions of the library will drop this
       fallback to 4444.  If <u>principal</u> is NULL, a service principal of "host/<u>host</u>" is used, with the realm
       determined by domain-realm mapping.

       <b>remctl_open_addrinfo()</b> operates in the same manner as <b>remctl_open()</b>, but connects to the first usable
       address in <u>ai</u>, which must be a list of results as returned by <b><a href="../man3/getaddrinfo.3.html">getaddrinfo</a></b>(3).  The <u>host</u> is used only to
       form the default service principal, and may be NULL if <u>principal</u> is not NULL.

       <b>remctl_open_sockaddr()</b> is equivalent to <b>remctl_open_addrinfo()</b> with a single addrinfo structure
       specifying the use of TCP with socket address <u>addr</u> and length <u>addrlen</u>.

       <b>remctl_open_fd()</b> operates in the same manner as <b>remctl_open_addrinfo()</b>, but uses an already-established
       TCP connection identified by the file descriptor <u>fd</u>.  On Windows, <u>fd</u> is of type "SOCKET" and must be a
       valid socket descriptor.

       If no principal is specified and the default is used, the underlying GSS-API library may canonicalize
       <u>host</u> via DNS before determining the service principal, depending on your library configuration.
       Specifying a principal disables this behavior.

       The remctl protocol uses Kerberos via GSS-API for authentication.  The underlying GSS-API library will
       use the default ticket cache for authentication, so to successfully use <b>remctl_open()</b>, the caller should
       already have Kerberos tickets for an appropriate realm stored in its default ticket cache.  The
       environment variable KRB5CCNAME or the <b><a href="../man3/remctl_set_ccache.3.html">remctl_set_ccache</a></b>(3) function can be used to control which ticket
       cache is used.

       To control the timeout for the connect and for subsequent calls, see the <b><a href="../man3/remctl_set_timeout.3.html">remctl_set_timeout</a></b>(3) function.
       To control the source IP used by <b>remctl_open()</b>, <b>remctl_open_addrinfo()</b>, and <b>remctl_open_sockaddr()</b>, see
       the <b><a href="../man3/remctl_set_source_ip.3.html">remctl_set_source_ip</a></b>(3) function.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>remctl_open()</b> returns true on success and false on failure.  On failure, the caller should call
       <b>remctl_error()</b> to retrieve the error message.

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       The <b>remctl_open()</b> interface has been provided by the remctl client library since its initial release in
       version 2.0.  <b>remctl_open_addrinfo()</b>, <b>remctl_open_sockaddr()</b>, and <b>remctl_open_fd()</b> were added in version
       3.4.

       The default port was changed to the IANA-registered port of 4373 in version 2.11.

       Support for IPv6 was added in version 2.4.

</pre><h4><b>CAVEATS</b></h4><pre>
       If the <u>principal</u> argument to <b>remctl_open()</b> is NULL, most GSS-API libraries will canonicalize the <u>host</u>
       using DNS before deriving the principal name from it.  This means that when connecting to a remctl server
       via a CNAME, <b>remctl_open()</b> will normally authenticate using a principal based on the canonical name of
       the host instead of the specified <u>host</u> parameter.  This behavior may cause problems if two consecutive
       DNS lookups of <u>host</u> may return two different results, such as with some DNS-based load-balancing systems.

       The canonicalization behavior is controlled by the GSS-API library; with the MIT Kerberos GSS-API
       library, canonicalization can be disabled by setting "rdns" to false in the [libdefaults] section of
       <u>krb5.conf</u>.  It can also be disabled by passing an explicit Kerberos principal name via the <u>principal</u>
       argument, which will then be used without changes.  If canonicalization is desired, the caller may wish
       to canonicalize <u>host</u> before calling <b>remctl_open()</b> to avoid problems with multiple DNS calls returning
       different results.

       The default behavior, when a port of 0 is given, of trying 4373 and falling back to 4444 will be removed
       in a future version of this library in favor of using the "remctl" service in <u><a href="file:/etc/services">/etc/services</a></u> if set and
       then falling back on only 4373.  4444 was the poorly-chosen original remctl port and should be phased
       out.

       Connections established using the alternate-open interfaces <b>remctl_open_fd()</b>, <b>remctl_open_addrinfo()</b>, and
       <b>remctl_open_sockaddr()</b> do not support the automatic connection-reopening which is used to give the
       illusion of a single long-lived connection when sending multiple commands to a server which supports only
       version 1 of the remctl protocol.  Therefore, when using these interfaces to open a connection to such a
       server, it will only be possible to send a single command, after which the connection must be closed and
       reopened before another command can be sent.

</pre><h4><b>NOTES</b></h4><pre>
       The remctl port number, 4373, was derived by tracing the diagonals of a QWERTY keyboard up from the
       letters "remc" to the number row.

</pre><h4><b>AUTHOR</b></h4><pre>
       Russ Allbery &lt;<a href="mailto:eagle@eyrie.org">eagle@eyrie.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2007-2009, 2014 The Board of Trustees of the Leland Stanford Junior University

       Copying and distribution of this file, with or without modification, are permitted in any medium without
       royalty provided the copyright notice and this notice are preserved.  This file is offered as-is, without
       any warranty.

       SPDX-License-Identifier: FSFAP

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/remctl_new.3.html">remctl_new</a></b>(3), <b><a href="../man3/remctl_error.3.html">remctl_error</a></b>(3), <b><a href="../man3/remctl_set_ccache.3.html">remctl_set_ccache</a></b>(3), <b><a href="../man3/remctl_set_source_ip.3.html">remctl_set_source_ip</a></b>(3), <b><a href="../man3/remctl_set_timeout.3.html">remctl_set_timeout</a></b>(3)

       The current version of the remctl library and complete details of the remctl protocol are available from
       its web page at &lt;https://www.eyrie.org/~eagle/software/remctl/&gt;.

3.18                                               2022-05-09                                     <u><a href="../man3/REMCTL_OPEN.3.html">REMCTL_OPEN</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>