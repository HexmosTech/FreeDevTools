<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rte_eal.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dpdk-doc">dpdk-doc_24.11.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rte_eal.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;<a href="file:/usr/include/time.h">time.h</a>&gt;
       #include &lt;rte_config.h&gt;
       #include &lt;rte_compat.h&gt;
       #include &lt;rte_per_lcore.h&gt;
       #include &lt;rte_uuid.h&gt;
       #include &lt;rte_pci_dev_feature_defs.h&gt;

   <b>Macros</b>
       #define <b>RTE_MAGIC</b>   19820526

   <b>Typedefs</b>
       <b>typedef</b> int(* <b>rte_mp_t</b>) (const struct rte_mp_msg *msg, const void *peer)
       <b>typedef</b> int(* <b>rte_mp_async_reply_t</b>) (const struct rte_mp_msg *request, const struct rte_mp_reply *reply)
       <b>typedef</b> void(* <b>rte_usage_hook_t</b>) (const char *prgname)

   <b>Enumerations</b>
       enum <b>rte_proc_type_t</b>
       enum <b>rte_iova_mode</b>

   <b>Functions</b>
       enum <b>rte_proc_type_t</b> <b>rte_eal_process_type</b> (void)
       int <b>rte_eal_iopl_init</b> (void)
       int <b>rte_eal_init</b> (int argc, char **argv)
       int <b>rte_eal_cleanup</b> (void)
       int <b>rte_eal_primary_proc_alive</b> (const char *config_file_path)
       bool <b>rte_mp_disable</b> (void)
       int <b>rte_mp_action_register</b> (const char *name, <b>rte_mp_t</b> action)
       void <b>rte_mp_action_unregister</b> (const char *name)
       int <b>rte_mp_sendmsg</b> (struct rte_mp_msg *msg)
       int <b>rte_mp_request_sync</b> (struct rte_mp_msg *req, struct rte_mp_reply *reply, const struct timespec *ts)
       int <b>rte_mp_request_async</b> (struct rte_mp_msg *req, const struct timespec *ts, <b>rte_mp_async_reply_t</b> clb)
       int <b>rte_mp_reply</b> (struct rte_mp_msg *msg, const char *peer)
       <b>rte_usage_hook_t</b> <b>rte_set_application_usage_hook</b> (<b>rte_usage_hook_t</b> usage_func)
       int <b>rte_eal_has_hugepages</b> (void)
       int <b>rte_eal_has_pci</b> (void)
       int <b>rte_eal_create_uio_dev</b> (void)
       enum rte_intr_mode <b>rte_eal_vfio_intr_mode</b> (void)
       void <b>rte_eal_vfio_get_vf_token</b> (<b>rte_uuid_t</b> vf_token)
       int <b>rte_sys_gettid</b> (void)
       static int <b>rte_gettid</b> (void)
       __rte_internal uint64_t <b>rte_eal_get_baseaddr</b> (void)
       enum <b>rte_iova_mode</b> <b>rte_eal_iova_mode</b> (void)
       const char * <b>rte_eal_mbuf_user_pool_ops</b> (void)
       const char * <b>rte_eal_get_runtime_dir</b> (void)
       __rte_internal int <b>rte_eal_parse_coremask</b> (const char *coremask, int *cores)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       EAL Configuration API

       Definition in file <b>rte_eal.h</b>.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>RTE_MAGIC</b>   <b>19820526</b>
       Magic number written by the main partition when ready.

       Definition at line <b>28</b> of file <b>rte_eal.h</b>.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>int(*</b> <b>rte_mp_t)</b> <b>(const</b> <b>struct</b> <b>rte_mp_msg</b> <b>*msg,</b> <b>const</b> <b>void</b> <b>*peer)</b>
       Action function typedef used by other components.

       As we create socket channel for primary/secondary communication, use this function typedef to register
       action for coming messages.

       <b>Note</b>
           When handling IPC request callbacks, the reply must be sent even in cases of error handling. Simply
           returning success or failure will <u>not</u> send a response to the requestor. Implementation of error
           signalling mechanism is up to the application.

           No memory allocations should take place inside the callback.

       Definition at line <b>188</b> of file <b>rte_eal.h</b>.

   <b>typedef</b> <b>int(*</b> <b>rte_mp_async_reply_t)</b> <b>(const</b> <b>struct</b> <b>rte_mp_msg</b> <b>*request,</b> <b>const</b> <b>struct</b> <b>rte_mp_reply</b> <b>*reply)</b>
       Asynchronous reply function typedef used by other components.

       As we create socket channel for primary/secondary communication, use this function typedef to register
       action for coming responses to asynchronous requests.

       <b>Note</b>
           When handling IPC request callbacks, the reply must be sent even in cases of error handling. Simply
           returning success or failure will <u>not</u> send a response to the requestor. Implementation of error
           signalling mechanism is up to the application.

           No memory allocations should take place inside the callback.

       Definition at line <b>204</b> of file <b>rte_eal.h</b>.

   <b>typedef</b> <b>void(*</b> <b>rte_usage_hook_t)</b> <b>(const</b> <b>char</b> <b>*prgname)</b>
       Usage function typedef used by the application usage function.

       Use this function typedef to define and call <b>rte_set_application_usage_hook()</b> routine.

       Definition at line <b>350</b> of file <b>rte_eal.h</b>.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>rte_proc_type_t</b>
       The type of process in a linux, multi-process setup

       Definition at line <b>33</b> of file <b>rte_eal.h</b>.

   <b>enum</b> <b>rte_iova_mode</b>
       IOVA mapping mode.

       IOVA mapping mode is iommu programming mode of a device. That device (for example: IOMMU backed DMA
       device) based on rte_iova_mode will generate physical or virtual address.

       Definition at line <b>461</b> of file <b>rte_eal.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>rte_proc_type_t</b> <b>rte_eal_process_type</b> <b>(void)</b>
       Get the process type in a multi-process setup

       <b>Returns</b>
           The process type

   <b>int</b> <b>rte_eal_iopl_init</b> <b>(void)</b>
       Request iopl privilege for all RPL.

       This function should be called by pmds which need access to ioports.

       <b>Returns</b>

           • On success, returns 0.

           • On failure, returns -1.

   <b>int</b> <b>rte_eal_init</b> <b>(int</b> <b>argc,</b> <b>char</b> <b>**</b> <b>argv)</b>
       Initialize the Environment Abstraction Layer (EAL).

       This  function  is to be executed on the MAIN lcore only, as soon as possible in the application's main()
       function. It puts the WORKER lcores in the WAIT state.

       <b>Parameters</b>
           <u>argc</u> A non-negative value. If it is greater than 0, the array members for argv[0] through  argv[argc]
           (non-inclusive) shall contain pointers to strings.
           <u>argv</u>  An  array of strings. The contents of the array, as well as the strings which are pointed to by
           the array, may be modified by this function. The program name pointer argv[0] is copied into the last
           parsed argv so that argv[0] is still the same after deducing the parsed arguments.

       <b>Returns</b>

           • On success, the number of parsed arguments, which is greater or equal to zero. After  the  call  to
             <b>rte_eal_init()</b>, all arguments argv[x] with x &lt; ret may have been modified by this function call and
             should  not  be  further interpreted by the application. The EAL does not take any ownership of the
             memory used for either the argv array, or its members.

           • On failure, -1 and rte_errno is set to a value indicating the cause for failure. In some instances,
             the application will need to be restarted as part of clearing the issue.

       Error codes returned via rte_errno: EACCES indicates a permissions issue.

       EAGAIN indicates either a bus or system resource was not available, setup may be attempted again.

       EALREADY indicates that the rte_eal_init function has already been called, and cannot be called again.

       EFAULT indicates the tailq configuration name was not found in memory configuration.

       EINVAL indicates invalid parameters were passed as argv/argc.

       ENOMEM indicates failure likely caused by an out-of-memory condition.

       ENODEV indicates memory setup issues.

       ENOTSUP indicates that the EAL cannot initialize on this system.

       EPROTO indicates that the PCI bus is either not present, or is not readable by the eal.

       ENOEXEC indicates that a service core failed to launch successfully.

   <b>int</b> <b>rte_eal_cleanup</b> <b>(void)</b>
       Clean up the Environment Abstraction Layer (EAL)

       This function  must  be  called  to  release  any  internal  resources  that  EAL  has  allocated  during
       <b>rte_eal_init()</b>.  After this call, no DPDK function calls may be made. It is expected that common usage of
       this function is to call it just before terminating the process.

       <b>Returns</b>

           • 0 Successfully released all internal EAL resources.

           • -EFAULT There was an error in releasing all resources.

   <b>int</b> <b>rte_eal_primary_proc_alive</b> <b>(const</b> <b>char</b> <b>*</b> <b>config_file_path)</b>
       Check if a primary process is currently alive

       This function returns true when a primary process is currently active.

       <b>Parameters</b>
           <u>config_file_path</u> The config_file_path argument provided should point at the location that the primary
           process will create its config file. If NULL, the default config file path is used.

       <b>Returns</b>

           • If alive, returns 1.

           • If dead, returns 0.

   <b>bool</b> <b>rte_mp_disable</b> <b>(void)</b>
       Disable multiprocess.

       This function can be called to indicate that multiprocess won't be used for the rest of  the  application
       life.

       <b>Returns</b>

           • true if called from a primary process that had no secondary processes attached,

           • false, otherwise.

   <b>int</b> <b>rte_mp_action_register</b> <b>(const</b> <b>char</b> <b>*</b> <b>name,</b> <b>rte_mp_t</b> <b>action)</b>
       Register an action function for primary/secondary communication.

       Call  this  function  to register an action, if the calling component wants to response the messages from
       the corresponding component in its primary process or secondary processes.

       <b>Note</b>
           IPC may be unsupported in certain circumstances, so caller should check for ENOTSUP error.

       <b>Parameters</b>
           <u>name</u> The name argument plays as the nonredundant key to find the action.
           <u>action</u> The action argument is the function pointer to the action function.

       <b>Returns</b>

           • 0 on success.

           • (&lt;0) on failure.

   <b>void</b> <b>rte_mp_action_unregister</b> <b>(const</b> <b>char</b> <b>*</b> <b>name)</b>
       Unregister an action function for primary/secondary communication.

       Call this function to unregister an action if the  calling  component  does  not  want  to  response  the
       messages from the corresponding component in its primary process or secondary processes.

       <b>Note</b>
           IPC may be unsupported in certain circumstances, so caller should check for ENOTSUP error.

       <b>Parameters</b>
           <u>name</u> The name argument plays as the nonredundant key to find the action.

   <b>int</b> <b>rte_mp_sendmsg</b> <b>(struct</b> <b>rte_mp_msg</b> <b>*</b> <b>msg)</b>
       Send a message to the peer process.

       This  function  will  send a message which will be responded by the action identified by name in the peer
       process.

       <b>Parameters</b>
           <u>msg</u> The msg argument contains the customized message.

       <b>Returns</b>

           • On success, return 0.

           • On failure, return -1, and the reason will be stored in rte_errno.

   <b>int</b> <b>rte_mp_request_sync</b> <b>(struct</b> <b>rte_mp_msg</b> <b>*</b> <b>req,</b> <b>struct</b> <b>rte_mp_reply</b> <b>*</b> <b>reply,</b> <b>const</b> <b>struct</b> <b>timespec</b> <b>*</b> <b>ts)</b>
       Send a request to the peer process and expect a reply.

       This function sends a request message to the peer process, and will block until receiving  reply  message
       from the peer process.

       <b>Note</b>
           The caller is responsible to free reply-&gt;replies.

           This  API  must  not be used inside memory-related or IPC callbacks, and no memory allocations should
           take place inside such callback.

           IPC may be unsupported in certain circumstances, so caller should check for ENOTSUP error.

       <b>Parameters</b>
           <u>req</u> The req argument contains the customized request message.
           <u>reply</u> The reply argument will be for storing all the replied messages; the caller is responsible  for
           free reply-&gt;msgs.
           <u>ts</u> The ts argument specifies how long we can wait for the peer(s) to reply.

       <b>Returns</b>

           • On success, return 0.

           • On failure, return -1, and the reason will be stored in rte_errno.

   <b>int</b> <b>rte_mp_request_async</b> <b>(struct</b> <b>rte_mp_msg</b> <b>*</b> <b>req,</b> <b>const</b> <b>struct</b> <b>timespec</b> <b>*</b> <b>ts,</b> <b>rte_mp_async_reply_t</b> <b>clb)</b>
       Send a request to the peer process and expect a reply in a separate callback.

       This  function  sends  a  request message to the peer process, and will not block. Instead, reply will be
       received in a separate callback.

       <b>Note</b>
           IPC may be unsupported in certain circumstances, so caller should check for ENOTSUP error.

       <b>Parameters</b>
           <u>req</u> The req argument contains the customized request message.
           <u>ts</u> The ts argument specifies how long we can wait for the peer(s) to reply.
           <u>clb</u> The callback to trigger when all responses for this request have arrived.

       <b>Returns</b>

           • On success, return 0.

           • On failure, return -1, and the reason will be stored in rte_errno.

   <b>int</b> <b>rte_mp_reply</b> <b>(struct</b> <b>rte_mp_msg</b> <b>*</b> <b>msg,</b> <b>const</b> <b>char</b> <b>*</b> <b>peer)</b>
       Send a reply to the peer process.

       This function will send a reply message in response to a request message received previously.

       <b>Note</b>
           When handling IPC request callbacks, the reply must be sent even in cases of error  handling.  Simply
           returning  success  or  failure  will  <u>not</u>  send a response to the requestor. Implementation of error
           signalling mechanism is up to the application.

       <b>Parameters</b>
           <u>msg</u> The msg argument contains the customized message.
           <u>peer</u> The peer argument is the pointer to the peer socket path.

       <b>Returns</b>

           • On success, return 0.

           • On failure, return -1, and the reason will be stored in rte_errno.

   <b>rte_usage_hook_t</b> <b>rte_set_application_usage_hook</b> <b>(rte_usage_hook_t</b> <b>usage_func)</b>
       Add application usage routine callout from the eal_usage() routine.

       This function allows the application to include its usage message in the EAL system  usage  message.  The
       routine  <b>rte_set_application_usage_hook()</b>  needs  to  be  called before the <b>rte_eal_init()</b> routine in the
       application.

       This routine is optional for the application and will behave as if the set routine was  never  called  as
       the default behavior.

       <b>Parameters</b>
           <u>usage_func</u>  The func argument is a function pointer to the application usage routine. Called function
           is defined using rte_usage_hook_t typedef, which is of the  form  void  rte_usage_func(const  char  *
           prgname).

       Calling  this  routine  with a NULL value will reset the usage hook routine and return the current value,
       which could be NULL.

       <b>Returns</b>

           • Returns the current value of the rte_application_usage pointer to allow the caller to  daisy  chain
             the usage routines if needing more then one.

   <b>int</b> <b>rte_eal_has_hugepages</b> <b>(void)</b>
       Whether  EAL  is using huge pages (disabled by --no-huge option). The no-huge mode is not compatible with
       all drivers or features.

       <b>Returns</b>
           Nonzero if hugepages are enabled.

   <b>int</b> <b>rte_eal_has_pci</b> <b>(void)</b>
       Whether EAL is using PCI bus. Disabled by --no-pci option.

       <b>Returns</b>
           Nonzero if the PCI bus is enabled.

   <b>int</b> <b>rte_eal_create_uio_dev</b> <b>(void)</b>
       Whether the EAL was asked to create UIO device.

       <b>Returns</b>
           Nonzero if true.

   <b>enum</b> <b>rte_intr_mode</b> <b>rte_eal_vfio_intr_mode</b> <b>(void)</b>
       The user-configured vfio interrupt mode.

       <b>Returns</b>
           Interrupt mode configured with the command line, RTE_INTR_MODE_NONE by default.

   <b>void</b> <b>rte_eal_vfio_get_vf_token</b> <b>(rte_uuid_t</b> <b>vf_token)</b>
       Copy the user-configured vfio VF token.

       <b>Parameters</b>
           <u>vf_token</u> vfio VF token configured with the command line is copied into this parameter, zero  uuid  by
           default.

   <b>int</b> <b>rte_sys_gettid</b> <b>(void)</b>
       A wrap API for syscall gettid.

       <b>Returns</b>
           On success, returns the thread ID of calling process. It is always successful.

   <b>static</b> <b>int</b> <b>rte_gettid</b> <b>(void)</b> <b>[inline],</b>  <b>[static]</b>
       Get system unique thread id.

       <b>Returns</b>
           On success, returns the thread ID of calling process. It is always successful.

       Definition at line <b>438</b> of file <b>rte_eal.h</b>.

   <b>__rte_internal</b> <b>uint64_t</b> <b>rte_eal_get_baseaddr</b> <b>(void)</b>
       Get the OS-specific EAL base address.

       <b>Returns</b>
           The base address.

   <b>enum</b> <b>rte_iova_mode</b> <b>rte_eal_iova_mode</b> <b>(void)</b>
       Get the iova mode

       <b>Returns</b>
           enum rte_iova_mode value.

   <b>const</b> <b>char</b> <b>*</b> <b>rte_eal_mbuf_user_pool_ops</b> <b>(void)</b>
       Get user provided pool ops name for mbuf

       <b>Returns</b>
           returns user provided pool ops name.

   <b>const</b> <b>char</b> <b>*</b> <b>rte_eal_get_runtime_dir</b> <b>(void)</b>
       Get the runtime directory of DPDK

       <b>Returns</b>
           The runtime directory path of DPDK

   <b>__rte_internal</b> <b>int</b> <b>rte_eal_parse_coremask</b> <b>(const</b> <b>char</b> <b>*</b> <b>coremask,</b> <b>int</b> <b>*</b> <b>cores)</b>
       Convert a string describing a mask of core ids into an array of core ids.

       On success, the passed array is filled with the orders of the core ids present in the mask (-1 indicating
       that a core id is absent). For example, passing a 0xa coremask results in cores[1] = 0, cores[3] = 1, and
       the rest of the array is set to -1.

       <b>Parameters</b>
           <u>coremask</u> A string describing a mask of core ids.
           <u>cores</u> An array where to store the core ids orders. This array must be at least RTE_MAX_LCORE large.

       <b>Returns</b>
           0 on success, -1 if the string content was invalid.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for DPDK from the source code.

DPDK                                             Version 24.11.2                                    <u><a href="../man3/rte_eal.h.3.html">rte_eal.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>