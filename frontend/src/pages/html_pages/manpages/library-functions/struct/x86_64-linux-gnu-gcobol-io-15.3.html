<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gcobol — GCC COBOL Front-end I/O function API</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgcobol-15-dev">libgcobol-15-dev_15.2.0-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gcobol — GCC COBOL Front-end I/O function API

</pre><h4><b>LIBRARY</b></h4><pre>
       <u>libgcobol</u>

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;symbols.h&gt;</b>
       <b>#include</b> <b>&lt;io.h&gt;</b>
       <b>#include</b> <b>&lt;gcobolio.h&gt;</b>

       <u>gcobol_io_t</u>
       <b>gcobol_fileops</b>();

       class gcobol_io_t {
       public:
         static const char constexpr marquee[64];
         typedef void (open_t)( cblc_file_t *file,
                                char *filename,
                                int mode_char,
                                int is_quoted );
         typedef void (close_t)( cblc_file_t *file,
                                 int how );
         typedef void (start_t)( cblc_file_t *file,
                                 int relop, // needs enum
                                 int first_last_key,
                                 size_t length );
         typedef void (read_t)( cblc_file_t *file,
                                int where );
         typedef void (write_t)( cblc_file_t *file,
                                 unsigned char  *data,
                                 size_t length,
                                 int after,
                                 int lines,
                                 int is_random );
         typedef void (rewrite_t)( cblc_file_t *file,
                                   size_t length, bool is_random );
         typedef void (delete_t)( cblc_file_t *file,
                                 bool is_random );
         open_t      *Open;
         close_t     *Close;
         start_t     *Start;
         read_t      *Read;
         write_t     *Write;
         rewrite_t   *Rewrite;
         delete_t    *Delete;
         ...
       };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>gcobol</b>  supplies replaceable I/O functionality via <b>gcobol_fileops</b>().  It returns a pointer to a structure
       of C function pointers that implement sequential, relative, and indexed file operations over files  whose
       On  Disk  Format  (ODF)  is defined by <b>gcobol</b>.  A user wishing to use another library that implements the
       same functionality over a different ODF must supply a different implementation of <b>gcobol_fileops</b>(),  plus
       7  functions, as described in this document.  The pointers to those user-implemented functions are placed
       in a C++ object of type <u>gcobol_io_t</u> and an instantiation of that type is  returned  by  <b>gcobol_fileops</b>().
       The  compiled  program  initializes  I/O  operations  by calling that function the first time any file is
       opened.

       Each function takes as its first argument a pointer to a <u>cblc_file_t</u> object, which is analogous to a <u>FILE</u>
       object used in the C <b>stdio</b> functions.  The <u>cblc_file_t</u> structure acts as a communication area between the
       compiled program and the I/O library.  Any information needed about the file is kept there.  Notably, the
       outcome of any operation is stored in that structure in the <u>file_status</u> member, not  as  a  return  code.
       Information about the <u>operation</u> (as opposed to the <u>file</u>) appear as parameters to the function.

       <u>cblc_file_t</u> has one member, not used by <b>gcobol</b>, that is reserved for the user:
             <u>void</u> <u>*</u> <u>implementation</u>.

       User-supplied  I/O  functions may assign and dereference <u>implementation</u>.  <b>gcobol</b> will preserve the value,
       but never references it.

       The 7 function pointers in <u>gcobol_io_t</u> are

       Open     <u>void</u> <b>open_t</b>(<u>cblc_file_t</u> <u>*file</u>, <u>char</u> <u>*filename</u>, <u>int</u> <u>mode_char</u>, <u>int</u> <u>is_quoted</u>)
                parameters:
                <u>filename</u>   is the filename, as known to the OS
                <u>mode_char</u>  is one of
                           ‘r’ OPEN INPUT: read-only mode
                           ‘w’ OPEN OUTPUT: create a new file or overwrite an existing one
                           ‘a’ EXTEND: append to sequential file
                           ‘+’ modify existing file
                <u>is_quoted</u>  If <b>true</b>, <u>filename</u> is taken literally.  If <b>false</b>, <u>filename</u> is interpreted as the  name
                           of  an  environment variable, the contents of which, if extant, are taken as the name
                           of the file to be opened.   If  no  such  variable  exists,  then  <u>filename</u>  is  used
                           verbatim.

       Close    <u>void</u> <b>close_t</b>(<u>cblc_file_t</u> <u>*file</u>, <u>int</u> <u>how</u>)
                parameters:
                <u>how</u>  A  value  of  0x08  closes a “REEL unit”.  Because no such thing is supported, the function
                     sets the file status to “07”, meaning <u>not</u> <u>a</u> <u>tape</u>.

       Start    <u>void</u> <b>start_t</b>(<u>cblc_file_t</u> <u>*file</u>, <u>int</u> <u>relop</u>, <u>int</u> <u>first_last_key</u>, <u>size_t</u> <u>length</u>)
                parameters:
                <u>relop</u>   is one of
                        <b>0</b>   means ‘&lt;’
                        <b>1</b>   means ‘&lt;=’
                        <b>2</b>   means ‘=’
                        <b>3</b>   means ‘!=’
                        <b>4</b>   means ‘&gt;=’
                        <b>5</b>   means ‘&gt;’
                <u>first_last_key</u>
                        is the key number (starting at 1) of the key within the <u>cblc_file_t</u> structure.
                <u>length</u>  is the size of the key (TODO: per the START statement?)

       Read     <u>void</u> <b>read_t</b>(<u>cblc_file_t</u> <u>*file</u>, <u>int</u> <u>where</u>) parameters:
                <u>where</u>
                       <b>-2</b> PREVIOUS
                       <b>-1</b> NEXT
                        <u>N</u> represents a key number, starting with 1, in the <u>cblc_file_t</u> structure. The  value  of
                         that key is used to find the record, and read it.

       Write    <u>void</u>  <b>write_t</b>(<u>cblc_file_t</u>  <u>*file</u>, <u>unsigned</u> <u>char</u>  <u>*data</u>, <u>size_t</u> <u>length</u>, <u>int</u> <u>after</u>, <u>int</u> <u>lines</u>, <u>int</u>
                <u>is_random</u>)
                parameters:
                <u>data</u>       address of in-memory buffer to write
                <u>length</u>     length of in-memory buffer to write
                <u>after</u>      has the value 1 if the
                                 AFTER ADVANCING n LINES
                           phrase was present in the <b>WRITE</b> statement, else 0
                <u>lines</u>      may be one of
                           <b>-666</b> ADVANCING PAGE
                             <b>-1</b> no <b>ADVANCING</b> phrase appeared
                              0 ADVANCING 0 LINES is valid
                             &gt;0 the value of <u>n</u> in ADVANCING <u>n</u> LINES
                <u>is_random</u>  is <b>true</b> if the <u>access</u> <u>mode</u> is RANDOM

       Rewrite  <u>void</u> <b>rewrite_t</b>(<u>cblc_file_t</u> <u>*file</u>, <u>size_t</u> <u>length</u>, <u>bool</u> <u>is_random</u>) parameters:
                <u>length</u>     number of bytes to write
                <u>is_random</u>  <b>true</b> if <u>access</u> <u>mode</u> is RANDOM

       Delete   <u>void</u> <b>delete_t</b>(<u>cblc_file_t</u> <u>*file</u>, <u>bool</u> <u>is_random</u>) parameters:
                <u>is_random</u>  <b>true</b> if <u>access</u> <u>mode</u> is RANDOM

       The library implements one function that the <b>gcobol</b>-produced binary calls directly:

       <u>gcobol_io_t</u> <u>*</u> <b>gcobol_fileops</b>()
       This function populates a <u>gcobol_io_t</u> object with the  above  function  pointers.   The  compiled  binary
       begins by calling <b>gcobol_fileops</b>(), and then uses the supplied pointers to effect I/O.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       I/O functions return <b>void</b>.  <b>gcobol_fileops</b>() returns <u>gcobol_io_t*</u>.

</pre><h4><b>STANDARDS</b></h4><pre>
       The  I/O library supplied by <b>gcobol</b>, <b>libgcobolio.so</b>, supports the I/O semantics defined by ISO COBOL.  It
       is not intended to be compatible with any other ODF. That is, <b>libgcobolio.so</b> cannot be used  to  exchange
       data with any other COBOL implementation.

       The  purpose of the <u>gcobol_io_t</u> structure is to allow the use of other I/O implementations with other ODF
       representations.

</pre><h4><b>CAVEATS</b></h4><pre>
       The library is not well tested, not least because it is not implemented.

</pre><h4><b>BUGS</b></h4><pre>
       The future is yet to come.

Linux                                               March 2024                                         <u><a href="../man3/GCOBOL.3.html">GCOBOL</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>