<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cap_get_file,   cap_set_file,  cap_get_fd,  cap_set_fd,  cap_get_nsowner,  cap_set_nsowner  -  capability</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcap-dev">libcap-dev_2.75-7ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cap_get_file,   cap_set_file,  cap_get_fd,  cap_set_fd,  cap_get_nsowner,  cap_set_nsowner  -  capability
       manipulation on files

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;sys/capability.h&gt;

       cap_t cap_get_file(const char *path_p);
       int cap_set_file(const char *path_p, cap_t cap_p);
       cap_t cap_get_fd(int fd);
       int cap_set_fd(int fd, cap_t caps);
       uid_t cap_get_nsowner(cap_t caps);
       int cap_set_nsowner(cap_t caps, uid_t rootuid);

       Link with <u>-lcap</u>.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>cap_get_file</b>() and <b>cap_get_fd</b>() allocate a capability state in working storage and set  it  to  represent
       the  capability  state  of  the  pathname  pointed to by <u>path_p</u> or the file open on descriptor <u>fd</u>.  These
       functions return a pointer to the newly created capability state.  The effects of reading the  capability
       state  from  any  file  other  than  a  regular file is undefined.  The caller should free any releasable
       memory, when the capability state in working storage is no longer required, by  calling  <b>cap_free</b>()  with
       the used <u>cap_t</u> as an argument.

       <b>cap_set_file</b>()  and  <b>cap_set_fd</b>()  set  the  values for all capability flags for all capabilities for the
       pathname pointed to by <u>path_p</u> or the file open on descriptor <u>fd</u>, with the capability state identified  by
       <u>cap_p</u>.   The  new capability state of the file is completely determined by the contents of <u>cap_p</u>.  A NULL
       value for <u>cap_p</u> is used to indicate that  capabilities  for  the  file  should  be  deleted.   For  these
       functions  to  succeed, the calling process must have the <b>CAP_SETFCAP</b> capability in its effective set and
       either the effective user ID of the process must match the file owner or the calling  process  must  have
       the  <b>CAP_FOWNER</b>  capability in its effective capability set.  The effects of writing the capability state
       to any file type other than a regular file are undefined.

       A capability set held in memory can be associated with the root  user  ID  in  use  in  a  specific  user
       namespace.  It  is  possible  to  get  and set this value (in the memory copy) with <b>cap_get_nsowner</b>() and
       <b>cap_set_nsowner</b>() respectively. The root user ID is ignored by the libcap library in all cases other than
       when the capability is written to a file. Only if the value is  non-zero  will  the  library  attempt  to
       include it in the written file capability set.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>cap_get_file</b>() and <b>cap_get_fd</b>() return a non-NULL value on success, and NULL on failure.

       <b>cap_set_file</b>() and <b>cap_set_fd</b>() return zero on success, and -1 on failure.

       On failure, <u>errno</u> is set to <b>EACCES</b>, <b>EBADFD</b>, <b>ENAMETOOLONG</b>, <b>ENOENT</b>, <b>ENOMEM</b>, <b>ENOTDIR</b>, <b>EPERM</b>, or <b>EROFS</b>.

</pre><h4><b>CONFORMING</b> <b>TO</b></h4><pre>
       These functions are specified by withdrawn POSIX.1e draft specification.

</pre><h4><b>NOTES</b></h4><pre>
       Support for file capabilities is provided on Linux since version 2.6.24.

       On  Linux, the file Effective set is a single bit.  If it is enabled, then all Permitted capabilities are
       enabled in the Effective set of the calling process when the file is executed; otherwise, no capabilities
       are enabled in the process's Effective set following an <b><a href="../man2/execve.2.html">execve</a></b>(2).  Because the file Effective set  is  a
       single  bit,  if  any  capability is enabled in the Effective set of the <u>cap_t</u> given to <b>cap_set_file</b>() or
       <b>cap_set_fd</b>(), then all capabilities whose Permitted or Inheritable flag is enabled  must  also  have  the
       Effective  flag  enabled.  Conversely, if the Effective bit is enabled on a file, then the <u>cap_t</u> returned
       by <b>cap_get_file()</b> and <b>cap_get_fd()</b> will have the Effective flag enabled for each capability that has  the
       Permitted or Inheritable flag enabled.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/libcap.3.html">libcap</a></b>(3),     <b><a href="../man3/cap_clear.3.html">cap_clear</a></b>(3),    <b><a href="../man3/cap_copy_ext.3.html">cap_copy_ext</a></b>(3),    <b><a href="../man3/cap_from_text.3.html">cap_from_text</a></b>(3),    <b><a href="../man3/cap_get_proc.3.html">cap_get_proc</a></b>(3),    <b><a href="../man3/cap_init.3.html">cap_init</a></b>(3),
       <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/user_namespaces.7.html">user_namespaces</a></b>(7)

                                                   2022-10-16                                    <u><a href="../man3/CAP_GET_FILE.3.html">CAP_GET_FILE</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>