<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSSL_ENCODER_to_data, OSSL_ENCODER_to_bio, OSSL_ENCODER_to_fp - Routines to perform an encoding</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       OSSL_ENCODER_to_data, OSSL_ENCODER_to_bio, OSSL_ENCODER_to_fp - Routines to perform an encoding

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/encoder.h&gt;

        int OSSL_ENCODER_to_data(OSSL_ENCODER_CTX *ctx, unsigned char **pdata,
                                 size_t *pdata_len);
        int OSSL_ENCODER_to_bio(OSSL_ENCODER_CTX *ctx, BIO *out);
        int OSSL_ENCODER_to_fp(OSSL_ENCODER_CTX *ctx, FILE *fp);

       Feature availability macros:

       <b>OSSL_ENCODER_to_fp()</b> is only available when <b>OPENSSL_NO_STDIO</b> is undefined.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>OSSL_ENCODER_to_data()</b> runs the encoding process for the context <u>ctx</u>, with the output going to the <u>*pdata</u>
       and  <u>*pdata_len</u>.   If  <u>*pdata</u>  is  NULL when <b>OSSL_ENCODER_to_data()</b> is called, a buffer will be allocated
       using <b><a href="../man3/OPENSSL_zalloc.3.html">OPENSSL_zalloc</a></b>(3), and <u>*pdata</u> will be set to point at the start of that buffer, and <u>*pdata_len</u> will
       be  assigned  its  length  when   <b>OSSL_ENCODER_to_data()</b>   returns.    If   <u>*pdata</u>   is   non-NULL   when
       <b>OSSL_ENCODER_to_data()</b>  is  called, <u>*pdata_len</u> is assumed to have its size.  In this case, <u>*pdata</u> will be
       set to point after the encoded bytes, and <u>*pdata_len</u> will be assigned the number of remaining bytes.

       <b>OSSL_ENCODER_to_bio()</b> runs the encoding process for the context <u>ctx</u>, with the output  going  to  the  <b>BIO</b>
       <u>out</u>.

       <b>OSSL_ENCODER_to_fp()</b> does the same thing as <b>OSSL_ENCODER_to_bio()</b>, except that the output is going to the
       <b>FILE</b> <u>fp</u>.

       For <b>OSSL_ENCODER_to_bio()</b> and <b>OSSL_ENCODER_to_fp()</b>, the application is required to set up the <b>BIO</b> or <b>FILE</b>
       properly, for example to have it in text or binary mode as is appropriate for the encoder output type.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>OSSL_ENCODER_to_bio()</b>,  <b>OSSL_ENCODER_to_fp()</b>  and  <b>OSSL_ENCODER_to_data()</b>  return  1  on success, or 0 on
       failure.

</pre><h4><b>EXAMPLES</b></h4><pre>
       To encode a pkey as PKCS#8 with PEM format into a bio:

        OSSL_ENCODER_CTX *ectx;
        const char *format = "PEM";
        const char *structure = "PrivateKeyInfo"; /* PKCS#8 structure */
        const unsigned char *pass = "my password";

        ectx = OSSL_ENCODER_CTX_new_for_pkey(pkey,
                                             OSSL_KEYMGMT_SELECT_KEYPAIR
                                             | OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS,
                                             format, structure,
                                             NULL);
        if (ectx == NULL) {
            /* error: no suitable potential encoders found */
        }
        if (pass != NULL)
            OSSL_ENCODER_CTX_set_passphrase(ectx, pass, strlen(pass));
        if (OSSL_ENCODER_to_bio(ectx, bio)) {
            /* pkey was successfully encoded into the bio */
        } else {
            /* encoding failure */
        }
        OSSL_ENCODER_CTX_free(ectx);

       To encode a pkey as PKCS#8 with DER format encrypted with AES-256-CBC into a buffer:

        OSSL_ENCODER_CTX *ectx;
        const char *format = "DER";
        const char *structure = "PrivateKeyInfo"; /* PKCS#8 structure */
        const unsigned char *pass = "my password";
        unsigned char *data = NULL;
        size_t datalen;

        ectx = OSSL_ENCODER_CTX_new_for_pkey(pkey,
                                             OSSL_KEYMGMT_SELECT_KEYPAIR
                                             | OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS,
                                             format, structure,
                                             NULL);
        if (ectx == NULL) {
            /* error: no suitable potential encoders found */
        }
        if (pass != NULL) {
            OSSL_ENCODER_CTX_set_passphrase(ectx, pass, strlen(pass));
            OSSL_ENCODER_CTX_set_cipher(ctx, "AES-256-CBC", NULL);
        }
        if (OSSL_ENCODER_to_data(ectx, &amp;data, &amp;datalen)) {
            /*
             * pkey was successfully encoded into a newly allocated
             * data buffer
             */
        } else {
            /* encoding failure */
        }
        OSSL_ENCODER_CTX_free(ectx);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/provider.7.html">provider</a></b>(7), <b><a href="../man3/OSSL_ENCODER_CTX.3.html">OSSL_ENCODER_CTX</a></b>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       The functions described here were added in OpenSSL 3.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2019-2021 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file  except  in  compliance
       with  the  License.   You  can  obtain  a  copy  in  the  file  LICENSE  in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                          <u><a href="../man3SSL/OSSL_ENCODER_TO_BIO.3SSL.html">OSSL_ENCODER_TO_BIO</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>