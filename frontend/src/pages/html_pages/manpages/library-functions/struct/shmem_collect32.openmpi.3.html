<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C or C++:</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openmpi-doc">openmpi-doc_5.0.7-1build1_all</a> <br><br><pre>
</pre><h4><b>SYNOPSIS</b></h4><pre>
       C or C++:

          #include &lt;mpp/shmem.h&gt;

          void shmem_collect32(void *target, const void *source,
            size_t nelems, int PE_start, int logPE_stride, int PE_size,
            long *pSync)

          void shmem_collect64(void *target, const void *source,
            size_t nelems, int PE_start, int logPE_stride, int PE_size,
            long *pSync)

          void shmem_fcollect32(void *target, const void *source,
            size_t nelems, int PE_start, int logPE_stride, int PE_size,
            long *pSync)

          void shmem_fcollect64(void *target, const void *source,
            size_t nelems, int PE_start, int logPE_stride, int PE_size,
            long *pSync)

       Fortran:

          INCLUDE "mpp/shmem.fh"

          INTEGER nelems
          INTEGER PE_start, logPE_stride, PE_size
          INTEGER pSync(SHMEM_COLLECT_SYNC_SIZE)

          CALL SHMEM_COLLECT4(target, source, nelems, PE_start,
          &amp; logPE_stride, PE_size, pSync)

          CALL SHMEM_COLLECT8(target, source, nelems, PE_start,
          &amp; logPE_stride, PE_size, pSync)

          CALL SHMEM_FCOLLECT4(target, source, nelems, PE_start,
          &amp; logPE_stride, PE_size, pSync)

          CALL SHMEM_FCOLLECT8(target, source, nelems, PE_start,
          &amp; logPE_stride, PE_size, pSync)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  shared  memory  (SHMEM) collect and fcollect routines concatenate nelems 64-bit or 32-bit data items
       from the source array into the target array, over the set of PEs defined by PE_start, log2PE_stride,  and
       PE_size, in processor number order. The resultant target array contains the contribution from PE PE_start
       first,  then  the  contribution  from  PE PE_start + PE_stride second, and so on. The collected result is
       written to the target array for all PEs in the active set.

       The fcollect routines require that nelems be the same value in all participating PEs, while  the  collect
       routines allow nelems to vary from PE to PE.

       The resulting target array is as follows:

          ----------------------------------------------------------
             source(1..nelems)
                 from PE (PE_start + 0 * (2**logPE_stride))
          ----------------------------------------------------------
             source(1..nelems)
                 from PE (PE_start + 1 * (2**logPE_stride))
          ----------------------------------------------------------
             ...
          ----------------------------------------------------------
             source(1..nelems) from
                 PE (PE_start + (PE_size - 1) * (2**logPE_stride))
          ----------------------------------------------------------

       As  with  all  SHMEM  collective routines, each of these routines assumes that only PEs in the active set
       call the routine. If a PE not in the active set calls a  SHMEM  collective  routine,  undefined  behavior
       results.

       The arguments are as follows:

       <b>target</b> A  symmetric  array.  The  target argument must be large enough to accept the concatenation of the
              source arrays on all PEs. The data types are as follows:

              <b>[shmem_collect8,</b> <u>shmem_collect64</u><b>,</b> <b>shmem_fcollect8,</b> <b>and</b>
                     shmem_fcollect64] any data type with an element size of 64 bits.   Fortran  derived  types,
                     Fortran character type, and C/C++ structures are not permitted.

              <b>[shmem_collect4,</b> <u>shmem_collect32</u><b>,</b> <b>shmem_fcollect4,</b> <b>and</b>
                     shmem_fcollect32]  any  data  type with an element size of 32 bits.  Fortran derived types,
                     Fortran character type, and C/C++ structures are not permitted.

       <b>source</b> A symmetric data object that can be of any type permissible for the target argument.

       <b>nelems</b> The number of elements in the source array. nelems must be of  type  integer.  If  you  are  using
              Fortran, it must be a default integer value.

       <b>PE_start</b>
              The  lowest  virtual  PE number of the active set of PEs. PE_start must be of type integer. If you
              are using Fortran, it must be a default integer value.

       <b>logPE_stride</b>
              The log (base 2) of the  stride  between  consecutive  virtual  PE  numbers  in  the  active  set.
              logPE_stride  must  be  of  type  integer.  If you are using Fortran, it must be a default integer
              value.

       <b>PE_size</b>
              The number of PEs in the active set. PE_size must be of type integer.  If you are  using  Fortran,
              it must be a default integer value.

       <b>pSync</b>  A  symmetric work array. In C/C++, pSync must be of type int and size _SHMEM_COLLECT_SYNC_SIZE. In
              Fortran, pSync must be of type integer and size SHMEM_COLLECT_SYNC_SIZE. If you are using Fortran,
              it must be a default integer value. Every element of this array must be initialized with the value
              _SHMEM_SYNC_VALUE in C/C++ or SHMEM_SYNC_VALUE in Fortran before any of the PEs in the active  set
              enter shmem_barrier().

       The  values  of arguments PE_start, logPE_stride, and PE_size must be equal on all PEs in the active set.
       The same target and source arrays and the same pSync work array must be passed to all PEs in  the  active
       set.

       Upon  return  from  a  collective  routine,  the following are true for the local PE: The target array is
       updated. The values in the pSync array are restored to the original values.

</pre><h4><b>NOTES</b></h4><pre>
       The terms collective and symmetric are defined in <u><a href="../man3/intro_shmem.3.html">intro_shmem</a></u>(3).  All SHMEM  collective  routines  reset
       the  values  in pSync before they return, so a particular pSync buffer need only be initialized the first
       time it is used.

       You must ensure that the pSync array is not being updated on any PE in the active set while  any  of  the
       PEs participate in processing of a SHMEM collective routine. Be careful to avoid these situations: If the
       pSync  array is initialized at run time, some type of synchronization is needed to ensure that all PEs in
       the working set have initialized pSync before any of them enter a SHMEM routine  called  with  the  pSync
       synchronization  array. A pSync array can be reused on a subsequent SHMEM collective routine only if none
       of the PEs in the active set are still processing a prior SHMEM collective routine  call  that  used  the
       same  pSync  array. In general, this may be ensured only by doing some type of synchronization.  However,
       in the special case of SHMEM routines being called with the same active set, you can allocate  two  pSync
       arrays and alternate between them on successive calls.

       The  collective  routines  operate  on  active  PE  sets  that  have a non-power-of-two PE_size with some
       performance degradation. They operate with no performance degradation when nelems is  a  non-power-of-two
       value.

</pre><h4><b>EXAMPLES</b></h4><pre>
       C/C++:

          for (i=0; i &lt; _SHMEM_COLLECT_SYNC_SIZE; i++) {
            pSync[i] = _SHMEM_SYNC_VALUE;
          }
          shmem_barrier_all(); /* Wait for all PEs to initialize pSync */
          shmem_collect32(target, source, 64, pe_start, logPE_stride,
             pe_size, pSync);

       Fortran:

          INTEGER PSYNC(SHMEM_COLLECT_SYNC_SIZE)
          DATA PSYNC /SHMEM_COLLECT_SYNC_SIZE*SHMEM_SYNC_VALUE/

          CALL SHMEM_COLLECT4(TARGET, SOURCE, 64, PE_START,
          &amp; LOGPE_STRIDE, PE_SIZE, PSYNC)

       <b>SEE</b> <b>ALSO:</b>
          <u><a href="../man3/intro_shmem.3.html">intro_shmem</a></u>(3)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2003-2025, The Open MPI Community

                                                  Jun 07, 2025                                <u><a href="../man3/SHMEM_COLLECT32.3.html">SHMEM_COLLECT32</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>