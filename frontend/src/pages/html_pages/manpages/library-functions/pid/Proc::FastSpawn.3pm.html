<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proc::FastSpawn - fork+exec, or spawn, a subprocess as quickly as possible</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libproc-fastspawn-perl">libproc-fastspawn-perl_1.2-2build5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Proc::FastSpawn - fork+exec, or spawn, a subprocess as quickly as possible

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use Proc::FastSpawn;

          # simple use
          my $pid = spawn "<a href="file:/bin/echo">/bin/echo</a>", ["echo", "hello, world"];
          ...
          waitpid $pid, 0;

          # with environment
          my $pid = spawn "<a href="file:/bin/echo">/bin/echo</a>", ["echo", "hello, world"], ["PATH=<a href="file:/bin">/bin</a>", "HOME=<a href="file:/tmp">/tmp</a>"];

          # inheriting file descriptors
          pipe R, W or die;
          fd_inherit fileno W;
          my $pid = spawn "<a href="file:/bin/sh">/bin/sh</a>", ["sh", "-c", "echo a pipe &gt;&amp;" . fileno W];
          close W;
          print &lt;R&gt;;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The purpose of this small (in scope and footprint) module is simple: spawn a subprocess asynchronously as
       efficiently and/or fast as possible. Basically the same as calling fork+exec (on POSIX), but hopefully
       faster than those two syscalls.

       Apart from fork overhead, this module also allows you to fork+exec programs when otherwise you couldn't -
       for example, when you use POSIX threads in your perl process then it generally isn't safe to call fork
       from perl, but it is safe to use this module to execute external processes.

       If neither of these are problems for you, you can safely ignore this module.

       So when is fork+exec not fast enough, how can you do it faster, and why would it matter?

       Forking a process requires making a complete copy of a process. Even thought almost every implementation
       only copies page tables and not the memory itself, this is still not free. For example, on my 3.6GHz
       amd64 box, I can fork a 5GB process only twenty times a second. For a real-time process that must meet
       stricter deadlines, this is too slow. For a busy and big web server, starting CGI scripts might mean
       unacceptable overhead.

       A workaround is to use "vfork" - this function isn't very portable, but it avoids the memory copy that
       "fork" has to do. Some systems have an optimised implementation of "spawn", and some systems have
       nothing.

       This module tries to abstract these differences away.

       As for what improvements to expect - on the 3.6GHz amd64 box that this module was originally developed
       on, a 3MB perl process (basically just perl + Proc::FastSpawn) takes 3.6s to run <a href="file:/bin/true">/bin/true</a> 10000 times
       using fork+exec, and only 2.6s when using vfork+exec. In a 22MB process, the difference is already 5.0s
       vs 2.6s, and so on.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       All the following functions are currently exported by default.

       $pid = spawn $path, \@argv[, \@envp]
           Creates a new process and tries to make it execute $path, with the given arguments and optionally the
           given environment variables, similar to calling fork + execv, or execve.

           Returns  the  PID  of  the  new  process  if successful. On any error, "undef" is currently returned.
           Failure to execution might or might not be reported as "undef", or via a subprocess  exit  status  of
           127.

       $pid = spawnp $file, \@argv[, \@envp]
           Like "spawn", but searches $file in $ENV{PATH} like the shell would do.

       fd_inherit $fileno[, $on]
           File  descriptors  can  be  inherited  by the spawned processes or not. This is decided on a per file
           descriptor basis. This module does nothing to any preexisting handles, but with this  call,  you  can
           change  the  state of a single file descriptor to either be inherited ($on is true or missing) or not
           $on is false).

           Free portability pro-tip: it seems native win32 perls ignore $^F and  set  all  file  handles  to  be
           inherited by default - but this function can switch it off.

</pre><h4><b>PORTABILITY</b> <b>NOTES</b></h4><pre>
       On POSIX systems, this module currently calls vfork+exec, spawn, or fork+exec, depending on the platform.
       If your platform has a good vfork or spawn but is misdetected and falls back to slow fork+exec, drop me a
       note.

       On  win32,  the  "_spawn" family of functions is used, and the module tries hard to patch the new process
       into perl's internal pid table, so the pid returned  should  work  with  other  Perl  functions  such  as
       waitpid. Also, win32 doesn't have a meaningful way to quote arguments containing "special" characters, so
       this  module  tries  it's best to quote those strings itself. Other typical platform limitations (such as
       being able to only have 64 or so subprocesses) are not worked around.

</pre><h4><b>AUTHOR</b></h4><pre>
        Marc Lehmann &lt;<a href="mailto:schmorp@schmorp.de">schmorp@schmorp.de</a>&gt;
        <a href="http://home.schmorp.de/">http://home.schmorp.de/</a>

perl v5.40.0                                       2024-10-20                                     <u><a href="../man3pm/FastSpawn.3pm.html">FastSpawn</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>