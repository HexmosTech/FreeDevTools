<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPC::Open3 - open a process for reading, writing, and error handling using open3()</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IPC::Open3 - open a process for reading, writing, and error handling using open3()

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Symbol 'gensym'; # vivify a separate handle for STDERR
           my $pid = open3(my $chld_in, my $chld_out, my $chld_err = gensym,
                           'some', 'cmd', 'and', 'args');
           # or pass the command through the shell
           my $pid = open3(my $chld_in, my $chld_out, my $chld_err = gensym,
                           'some cmd and args');

           # read from parent STDIN
           # send STDOUT and STDERR to already open handle
           open my $outfile, '&gt;&gt;', 'output.txt' or die "open failed: $!";
           my $pid = open3('&lt;&amp;STDIN', $outfile, undef,
                           'some', 'cmd', 'and', 'args');

           # write to parent STDOUT and STDERR
           my $pid = open3(my $chld_in, '&gt;&amp;STDOUT', '&gt;&amp;STDERR',
                           'some', 'cmd', 'and', 'args');

           # reap zombie and retrieve exit status
           waitpid( $pid, 0 );
           my $child_exit_status = $? &gt;&gt; 8;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Extremely similar to <b>open2()</b>, <b>open3()</b> spawns the given command and connects $chld_out for reading from
       the child, $chld_in for writing to the child, and $chld_err for errors.  If $chld_err is false, or the
       same file descriptor as $chld_out, then STDOUT and STDERR of the child are on the same filehandle.  This
       means that an autovivified lexical cannot be used for the STDERR filehandle, but gensym from Symbol can
       be used to vivify a new glob reference, see "SYNOPSIS".  The $chld_in will have autoflush turned on.

       If $chld_in begins with "&lt;&amp;", then $chld_in will be closed in the parent, and the child will read from it
       directly.  If $chld_out or $chld_err begins with "&gt;&amp;", then the child will send output directly to that
       filehandle.  In both cases, there will be a <b><a href="../man2/dup.2.html">dup</a></b>(2) instead of a <b><a href="../man2/pipe.2.html">pipe</a></b>(2) made.

       If either reader or writer is the empty string or undefined, this will be replaced by an autogenerated
       filehandle.  If so, you must pass a valid lvalue in the parameter slot so it can be overwritten in the
       caller, or an exception will be raised.

       The filehandles may also be integers, in which case they are understood as file descriptors.

       <b>open3()</b> returns the process ID of the child process.  It doesn't return on failure: it just raises an
       exception matching "/^open3:/".  However, "exec" failures in the child (such as no such file or
       permission denied), are just reported to $chld_err under Windows and OS/2, as it is not possible to trap
       them.

       If the child process dies for any reason, the next write to $chld_in is likely to generate a SIGPIPE in
       the parent, which is fatal by default.  So you may wish to handle this signal.

       Note if you specify "-" as the command, in an analogous fashion to "open(my $fh, "-|")" the child process
       will just be the forked Perl process rather than an external command.  This feature isn't yet supported
       on Win32 platforms.

       <b>open3()</b> does not wait for and reap the child process after it exits.  Except for short programs where
       it's acceptable to let the operating system take care of this, you need to do this yourself.  This is
       normally as simple as calling "waitpid $pid, 0" when you're done with the process.  Failing to do this
       can result in an accumulation of defunct or "zombie" processes.  See "waitpid" in perlfunc for more
       information.

       If you try to read from the child's stdout writer and their stderr writer, you'll have problems with
       blocking, which means you'll want to use <b>select()</b> or IO::Select, which means you'd best use <b>sysread()</b>
       instead of <b>readline()</b> for normal stuff.

       This is very dangerous, as you may block forever.  It assumes it's going to talk to something like <b><a href="../man1/bc.1.html">bc</a></b>(1),
       both writing to it and reading from it.  This is presumably safe because you "know" that commands like
       <b><a href="../man1/bc.1.html">bc</a></b>(1) will read a line at a time and output a line at a time.  Programs like <b><a href="../man1/sort.1.html">sort</a></b>(1) that read their
       entire input stream first, however, are quite apt to cause deadlock.

       The big problem with this approach is that if you don't have control over source code being run in the
       child process, you can't control what it does with pipe buffering.  Thus you can't just open a pipe to
       "cat -v" and continually read and write a line from it.

</pre><h4><b>See</b> <b>Also</b></h4><pre>
       IPC::Open2
           Like Open3 but without STDERR capture.

       IPC::Run
           This is a CPAN module that has better error handling and more facilities than Open3.

</pre><h4><b>WARNING</b></h4><pre>
       The order of arguments differs from that of <b>open2()</b>.

perl v5.40.1                                       2025-07-27                                  <u>IPC::<a href="../man3perl/Open3.3perl.html">Open3</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>