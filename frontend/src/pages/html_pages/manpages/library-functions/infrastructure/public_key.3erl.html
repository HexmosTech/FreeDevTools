<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>public_key - API module for public-key infrastructure.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       public_key - API module for public-key infrastructure.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Provides functions to handle public-key infrastructure, for details see <a href="../man7/public_key.7.html">public_key</a>(7).

</pre><h4><b>COMMON</b> <b>RECORDS</b> <b>AND</b> <b>ASN.1</b> <b>TYPES</b></h4><pre>
   <b>Note:</b>
       All  records  used in this Reference Manual are generated from ASN.1 specifications and are documented in
       the User's Guide. See Public-key Records.

       Use the following include directive to get access to the records and constant macros described  here  and
       in the User's Guide:

        -include_lib("public_key/include/public_key.hrl").

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>oid()</b> = tuple()

              Object identifier, a tuple of integers as generated by the <u>ASN.1</u> compiler.

       <b>key_oid_name()</b> =
           rsaEncryption | 'id-RSASSA-PSS' | 'id-ecPublicKey' |
           'id-Ed25519' | 'id-Ed448' | 'id-dsa'

              Macro names for key object identifiers used by prefixing with ?

       <b>der_encoded()</b> = binary()

       <b>pki_asn1_type()</b> =
           'Certificate' | 'RSAPrivateKey' | 'RSAPublicKey' |
           'DSAPrivateKey' | 'DSAPublicKey' | 'DHParameter' |
           'SubjectPublicKeyInfo' | 'PrivateKeyInfo' |
           'CertificationRequest' | 'CertificateList' | 'ECPrivateKey' |
           'EcpkParameters'

       <b>asn1_type()</b> = atom()

              ASN.1 type present in the Public Key applications ASN.1 specifications.

       <b>pem_entry()</b> =
           {pki_asn1_type(),
            der_or_encrypted_der(),
            not_encrypted | cipher_info()}

       <b>der_or_encrypted_der()</b> = binary()

       <b>cipher_info()</b> = {cipher(), cipher_info_params()}

       <b>cipher()</b> = string()

       <b>salt()</b> = binary()

       <b>cipher_info_params()</b> =
           salt() |
           {#'PBEParameter'{}, digest_type()} |
           #'PBES2-params'{}

              Cipher = "RC2-CBC" | "DES-CBC" | "DES-EDE3-CBC"

              <u>Salt</u> could be generated with <u>crypto:<a href="../man8/strong_rand_bytes.8.html">strong_rand_bytes</a>(8)</u>.

       <b>public_key()</b> =
           rsa_public_key() |
           rsa_pss_public_key() |
           dsa_public_key() |
           ec_public_key() |
           ed_public_key()

       <b>rsa_public_key()</b> = #'RSAPublicKey'{}

       <b>dss_public_key()</b> = integer()

       <b>rsa_pss_public_key()</b> =
           {rsa_pss_public_key(), #'RSASSA-PSS-params'{}}

       <b>dsa_public_key()</b> = {dss_public_key(), #'Dss-Parms'{}}

       <b>ec_public_key()</b> = {#'ECPoint'{}, ecpk_parameters_api()}

       <b>public_key_params()</b> =
           'NULL' |
           #'RSASSA-PSS-params'{} |
           {namedCurve, oid()} |
           #'ECParameters'{} |
           #'Dss-Parms'{}

       <b>ecpk_parameters()</b> =
           {ecParameters, #'ECParameters'{}} |
           {namedCurve, Oid :: tuple()}

       <b>ecpk_parameters_api()</b> =
           ecpk_parameters() |
           #'ECParameters'{} |
           {namedCurve, Name :: crypto:ec_named_curve()}

       <b>public_key_info()</b> =
           {key_oid_name(),
            rsa_public_key() | #'ECPoint'{} | dss_public_key(),
            public_key_params()}

       <b>ed_public_key()</b> = {#'ECPoint'{}, ed_params()}

       <b>ed_legacy_pubkey()</b> = {ed_pub, ed25519 | ed448, Key :: binary()}

          <b>Warning:</b>
              The  tagged  ed_pub  format  will not be returned from any public_key functions but can be used as
              input, should be considered deprecated.

       <b>ed_params()</b> = {namedCurve, ed_oid_name()}

       <b>private_key()</b> =
           rsa_private_key() |
           rsa_pss_private_key() |
           dsa_private_key() |
           ec_private_key() |
           ed_private_key()

       <b>rsa_private_key()</b> = #'RSAPrivateKey'{}

       <b>rsa_pss_private_key()</b> =
           {#'RSAPrivateKey'{}, #'RSASSA-PSS-params'{}}

       <b>dsa_private_key()</b> = #'DSAPrivateKey'{}

       <b>ec_private_key()</b> = #'ECPrivateKey'{}

       <b>ed_private_key()</b> = #'ECPrivateKey'{parameters = ed_params()}

       <b>ed_legacy_privkey()</b> =
           {ed_pri, ed25519 | ed448, Pub :: binary(), Priv :: binary()}

          <b>Warning:</b>
              The tagged ed_pri format will not be returned from any public_key functions but  can  be  used  as
              input, should be considered deprecated.

       <b>ed_oid_name()</b> = 'id-Ed25519' | 'id-Ed448'

              Macro names for object identifiers for EDDSA curves used by prefixing with ?

       <b>key_params()</b> =
           #'DHParameter'{} |
           {namedCurve, oid()} |
           #'ECParameters'{} |
           {rsa, Size :: integer(), PubExp :: integer()}

       <b>digest_type()</b> =
           none | sha1 |
           crypto:rsa_digest_type() |
           crypto:dss_digest_type() |
           crypto:ecdsa_digest_type()

       <b>issuer_name()</b> = {rdnSequence, [[#'AttributeTypeAndValue'{}]]}

       <b>referenceIDs()</b> = [referenceID()]

       <b>referenceID()</b> =
           {uri_id | dns_id | ip | srv_id | atom() | oid(), string()} |
           {ip, inet:ip_address() | string()}

       <b>cert_id()</b> = {SerialNr :: integer(), issuer_name()}

       <b>cert()</b> = der_cert() | otp_cert()

       <b>otp_cert()</b> = #'OTPCertificate'{}

       <b>der_cert()</b> = der_encoded()

       <b>combined_cert()</b> =
           #cert{der = public_key:der_encoded(),
                 otp = #'OTPCertificate'{}}

       <b>bad_cert_reason()</b> =
           cert_expired | invalid_issuer | invalid_signature |
           name_not_permitted | missing_basic_constraint |
           invalid_key_usage |
           {revoked, crl_reason()} |
           atom()

       <b>crl_reason()</b> =
           unspecified | keyCompromise | cACompromise |
           affiliationChanged | superseded | cessationOfOperation |
           certificateHold | privilegeWithdrawn | aACompromise

       <b>chain_opts()</b> =
           #{chain_end() := [cert_opt()],
             intermediates =&gt; [[cert_opt()]]}

       <b>chain_end()</b> = root | peer

       <b>cert_opt()</b> =
           {digest, public_key:digest_type()} |
           {key, public_key:key_params() | public_key:private_key()} |
           {validity,
            {From :: erlang:timestamp(), To :: erlang:timestamp()}} |
           {extensions, [#'Extension'{}]}

       <b>test_root_cert()</b> =
           #{cert := der_encoded(), key := public_key:private_key()}

       <b>test_config()</b> =
           #{server_config := [conf_opt()],
             client_config := [conf_opt()]}

       <b>conf_opt()</b> =
           {cert, public_key:der_encoded()} |
           {key, public_key:private_key()} |
           {cacerts, [public_key:der_encoded()]}

       <b>ssh_file()</b> =
           openssh_public_key | rfc4716_public_key | known_hosts |
           auth_keys

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>compute_key(OthersECDHkey,</b> <b>MyECDHkey)</b> <b>-&gt;</b> <b>SharedSecret</b>

              Types:

                 OthersECDHkey = #'ECPoint'{}
                 MyECDHkey = #'ECPrivateKey'{}
                 SharedSecret = binary()

              Computes shared secret.

       <b>compute_key(OthersDHkey,</b> <b>MyDHkey,</b> <b>DHparms)</b> <b>-&gt;</b> <b>SharedSecret</b>

              Types:

                 OthersDHkey = crypto:dh_public()
                 MyDHkey = crypto:dh_private()
                 DHparms = #'DHParameter'{}
                 SharedSecret = binary()

              Computes shared secret.

       <b>decrypt_private(CipherText,</b> <b>Key)</b> <b>-&gt;</b> <b>PlainText</b>

       <b>decrypt_private(CipherText,</b> <b>Key,</b> <b>Options)</b> <b>-&gt;</b> <b>PlainText</b>

              Types:

                 CipherText = binary()
                 Key = rsa_private_key()
                 Options = crypto:pk_encrypt_decrypt_opts()
                 PlainText = binary()

              Public-key decryption using the private key. See also crypto:private_decrypt/4

       <b>decrypt_public(CipherText,</b> <b>Key)</b> <b>-&gt;</b> <b>PlainText</b>

       <b>decrypt_public(CipherText,</b> <b>Key,</b> <b>Options)</b> <b>-&gt;</b> <b>PlainText</b>

              Types:

                 CipherText = binary()
                 Key = rsa_public_key()
                 Options = crypto:pk_encrypt_decrypt_opts()
                 PlainText = binary()

              Public-key decryption using the public key. See also crypto:public_decrypt/4

       <b>der_decode(Asn1Type,</b> <b>Der)</b> <b>-&gt;</b> <b>Entity</b>

              Types:

                 Asn1Type = asn1_type()
                 Der = der_encoded()
                 Entity = term()

              Decodes a public-key ASN.1 DER encoded entity.

       <b>der_encode(Asn1Type,</b> <b>Entity)</b> <b>-&gt;</b> <b>Der</b>

              Types:

                 Asn1Type = asn1_type()
                 Entity = term()
                 Der = binary()

              Encodes a public-key entity with ASN.1 DER encoding.

       <b>dh_gex_group(MinSize,</b> <b>SuggestedSize,</b> <b>MaxSize,</b> <b>Groups)</b> <b>-&gt;</b>
                       {ok, {Size, Group}} | {error, term()}

              Types:

                 MinSize = SuggestedSize = MaxSize = integer() &gt;= 1
                 Groups = undefined | [{Size, [Group]}]
                 Size = integer() &gt;= 1
                 Group = {G, P}
                 G = P = integer() &gt;= 1

              Selects  a  group for Diffie-Hellman key exchange with the key size in the range <u>MinSize...MaxSize</u>
              and as close to <u>SuggestedSize</u> as possible. If <u>Groups</u> <u>==</u> <u>undefined</u> a  default  set  will  be  used,
              otherwise the group is selected from <u>Groups</u>.

              First  a  size,  as  close as possible to SuggestedSize, is selected. Then one group with that key
              size is randomly selected from the specified set of groups.  If  no  size  within  the  limits  of
              <u>MinSize</u> and <u>MaxSize</u> is available, <u>{error,no_group_found}</u> is returned.

              The  default  set  of groups is listed in <u>lib/public_key/priv/moduli</u>. This file may be regenerated
              like this:

                   $&gt; cd $ERL_TOP/lib/public_key/priv/
                   $&gt; generate
                       ---- wait until all background jobs has finished. It may take several days !
                   $&gt; cat moduli-* &gt; moduli
                   $&gt; cd ..; make

       <b>encrypt_private(PlainText,</b> <b>Key)</b> <b>-&gt;</b> <b>CipherText</b>

       <b>encrypt_private(PlainText,</b> <b>Key,</b> <b>Options)</b> <b>-&gt;</b> <b>CipherText</b>

              Types:

                 PlainText = binary()
                 Key = rsa_private_key()
                 Options = crypto:pk_encrypt_decrypt_opts()
                 CipherText = binary()

              Public-key encryption using the private key. See also crypto:private_encrypt/4.

       <b>encrypt_public(PlainText,</b> <b>Key)</b> <b>-&gt;</b> <b>CipherText</b>

       <b>encrypt_public(PlainText,</b> <b>Key,</b> <b>Options)</b> <b>-&gt;</b> <b>CipherText</b>

              Types:

                 PlainText = binary()
                 Key = rsa_public_key()
                 Options = crypto:pk_encrypt_decrypt_opts()
                 CipherText = binary()

              Public-key encryption using the public key. See also crypto:public_encrypt/4.

       <b>generate_key(Params</b> <b>::</b> <b>DHparams</b> <b>|</b> <b>ECparams</b> <b>|</b> <b>RSAparams)</b> <b>-&gt;</b>
                       DHkeys | ECkey | RSAkey

              Types:

                 DHparams = #'DHParameter'{}
                 DHkeys = {PublicDH :: binary(), PrivateDH :: binary()}
                 ECparams = ecpk_parameters_api()
                 ECkey = #'ECPrivateKey'{}
                 RSAparams = {rsa, Size, PubExp}
                 Size = PubExp = integer() &gt;= 1
                 RSAkey = #'RSAPrivateKey'{}

              Generates a new key pair. Note that except for Diffie-Hellman the public key is  included  in  the
              private key structure. See also crypto:generate_key/2

       <b>pem_decode(PemBin</b> <b>::</b> <b>binary())</b> <b>-&gt;</b> <b>[pem_entry()]</b>

              Decodes PEM binary data and returns entries as ASN.1 DER encoded entities.

              Example <u>{ok,</u> <u>PemBin}</u> <u>=</u> <u>file:read_file("cert.pem").</u> <u>PemEntries</u> <u>=</u> <u>public_key:pem_decode(PemBin).</u>

       <b>pem_encode(PemEntries</b> <b>::</b> <b>[pem_entry()])</b> <b>-&gt;</b> <b>binary()</b>

              Creates a PEM binary.

       <b>pem_entry_decode(PemEntry)</b> <b>-&gt;</b> <b>term()</b>

       <b>pem_entry_decode(PemEntry,</b> <b>Password)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 PemEntry = pem_entry()
                 Password = string()

              Decodes  a  PEM entry. <u>pem_decode/1</u> returns a list of PEM entries. Notice that if the PEM entry is
              of type 'SubjectPublickeyInfo', it is further decoded to an <u>rsa_public_key()</u> or <u>dsa_public_key()</u>.

       <b>pem_entry_encode(Asn1Type,</b> <b>Entity)</b> <b>-&gt;</b> <b>pem_entry()</b>

       <b>pem_entry_encode(Asn1Type,</b> <b>Entity,</b> <b>InfoPwd)</b> <b>-&gt;</b> <b>pem_entry()</b>

              Types:

                 Asn1Type = pki_asn1_type()
                 Entity = term()
                 InfoPwd = {CipherInfo, Password}
                 CipherInfo = cipher_info()
                 Password = string()

              Creates a PEM entry that can be feed to <u>pem_encode/1</u>.

              If <u>Asn1Type</u> is <u>'SubjectPublicKeyInfo'</u>, <u>Entity</u> must be either an <u>rsa_public_key()</u>, <u>dsa_public_key()</u>
              or an <u>ec_public_key()</u> and this function creates the appropriate <u>'SubjectPublicKeyInfo'</u> entry.

       <b>pkix_decode_cert(Cert,</b> <b>Type)</b> <b>-&gt;</b> <b>#'Certificate'{}</b> <b>|</b> <b>otp_cert()</b>

              Types:

                 Cert = der_cert()
                 Type = plain | otp

              Decodes an ASN.1 DER-encoded PKIX certificate. Option <u>otp</u> uses the customized ASN.1  specification
              OTP-PKIX.asn1 for decoding and also recursively decode most of the standard parts.

       <b>pkix_encode(Asn1Type,</b> <b>Entity,</b> <b>Type)</b> <b>-&gt;</b> <b>Der</b>

              Types:

                 Asn1Type = asn1_type()
                 Entity = term()
                 Type = otp | plain
                 Der = der_encoded()

              DER  encodes a PKIX x509 certificate or part of such a certificate. This function must be used for
              encoding certificates or parts of certificates that are decoded/created in the <u>otp</u> format, whereas
              for the plain format this function directly calls <u>der_encode/2</u>.

          <b>Note:</b>
              Subtle ASN-1 encoding errors in certificates may be worked around when decoding, this may have the
              affect that the encoding a certificate back to DER may generate different bytes then the  supplied
              original.

       <b>pkix_is_issuer(CertorCRL,</b> <b>IssuerCert)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 CertorCRL = cert() | #'CertificateList'{}
                 IssuerCert = cert()

              Checks if <u>IssuerCert</u> issued <u>Cert</u>.

       <b>pkix_is_fixed_dh_cert(Cert)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Cert = cert()

              Checks if a certificate is a fixed Diffie-Hellman certificate.

       <b>pkix_is_self_signed(Cert)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Cert = cert()

              Checks if a certificate is self-signed.

       <b>pkix_issuer_id(Cert,</b> <b>IssuedBy)</b> <b>-&gt;</b>
                         {ok, ID :: cert_id()} | {error, Reason}

              Types:

                 Cert = cert()
                 IssuedBy = self | other
                 Reason = term()

              Returns the x509 certificate issuer id, if it can be determined.

       <b>pkix_normalize_name(Issuer)</b> <b>-&gt;</b> <b>Normalized</b>

              Types:

                 Issuer = Normalized = issuer_name()

              Normalizes an issuer name so that it can be easily compared to another issuer name.

       <b>pkix_path_validation(Cert,</b> <b>CertChain,</b> <b>Options)</b> <b>-&gt;</b>
                               {ok, {PublicKeyInfo, PolicyTree}} |
                               {error,
                                {bad_cert, Reason :: bad_cert_reason()}}

              Types:

                 Cert = cert() | atom()
                 CertChain = [cert() | combined_cert()]
                 Options =
                     [{max_path_length, integer()} |
                      {verify_fun, {function(), term()}}]
                 PublicKeyInfo = public_key_info()
                 PolicyTree = list()

              Performs a basic path validation according to RFC 5280. However, CRL validation is done separately
              by  pkix_crls_validate/3   and  is  to be called from the supplied <u>verify_fun</u>. The optional policy
              tree check is currently not implemented but an empty place holder list is returned instead.

              Available options:

                <b>{verify_fun,</b> <b>{fun(),</b> <b>InitialUserState::term()}:</b>
                  The fun must be defined as:

                fun(OtpCert :: #'OTPCertificate'{},
                    Event :: {bad_cert, Reason :: atom() | {revoked, atom()}} |
                             {extension, #'Extension'{}},
                    InitialUserState :: term()) -&gt;
                     {valid, UserState :: term()} |
                     {valid_peer, UserState :: term()} |
                     {fail, Reason :: term()} |
                     {unknown, UserState :: term()}.

                  If the verify callback fun returns <u>{fail,</u> <u>Reason}</u>, the  verification  process  is  immediately
                  stopped.  If  the  verify callback fun returns <u>{valid,</u> <u>UserState}</u>, the verification process is
                  continued.  This  can  be  used  to  accept  specific  path   validation   errors,   such   as
                  <u>selfsigned_peer</u>,  as  well  as  verifying  application-specific  extensions. If called with an
                  extension unknown to the user application, the return value  <u>{unknown,</u>  <u>UserState}</u>  is  to  be
                  used.

            <b>Warning:</b>
                Note  that  user  defined  custom  <u>verify_fun</u>  may  alter  original  path  validation error (e.g
                <u>selfsigned_peer</u>). Use with caution.

                <b>{max_path_length,</b> <b>integer()}:</b>
                   The <u>max_path_length</u> is the maximum number of non-self-issued intermediate  certificates  that
                  can  follow  the  peer certificate in a valid certification path. So, if <u>max_path_length</u> is 0,
                  the PEER must be signed by the trusted ROOT-CA directly, if it is 1, the path can be PEER, CA,
                  ROOT-CA, if it is 2, the path can be PEER, CA, CA, ROOT-CA, and so on.

              Explanations of reasons for a bad certificate:

                <b>cert_expired:</b>
                  Certificate is no longer valid as its expiration date has passed.

                <b>invalid_issuer:</b>
                  Certificate issuer name does not match the name of the issuer certificate in the chain.

                <b>invalid_signature:</b>
                  Certificate was not signed by its issuer certificate in the chain.

                <b>name_not_permitted:</b>
                  Invalid Subject Alternative Name extension.

                <b>missing_basic_constraint:</b>
                  Certificate, required to  have  the  basic  constraints  extension,  does  not  have  a  basic
                  constraints extension.

                <b>invalid_key_usage:</b>
                  Certificate key is used in an invalid way according to the key-usage extension.

                <b>{revoked,</b> <b>crl_reason()}:</b>
                  Certificate has been revoked.

                <b>atom():</b>
                  Application-specific error reason that is to be checked by the <u>verify_fun</u>.

       <b>pkix_crl_issuer(CRL)</b> <b>-&gt;</b> <b>Issuer</b>

              Types:

                 CRL = der_encoded() | #'CertificateList'{}
                 Issuer = issuer_name()

              Returns the issuer of the <u>CRL</u>.

       <b>pkix_crls_validate(OTPcertificate,</b> <b>DPandCRLs,</b> <b>Options)</b> <b>-&gt;</b>
                             CRLstatus

              Types:

                 OTPcertificate = #'OTPCertificate'{}
                 DPandCRLs = [DPandCRL]
                 DPandCRL = {DP, {DerCRL, CRL}}
                 DP = #'DistributionPoint'{}
                 DerCRL = der_encoded()
                 CRL = #'CertificateList'{}
                 Options = [{atom(), term()}]
                 CRLstatus = valid | {bad_cert, BadCertReason}
                 BadCertReason =
                     revocation_status_undetermined |
                     {revocation_status_undetermined, Reason :: term()} |
                     {revoked, crl_reason()}

              Performs   CRL   validation.   It   is   intended   to   be   called   from   the  verify  fun  of
              pkix_path_validation/3 .

              Available options:

                <b>{update_crl,</b> <b>fun()}:</b>
                  The fun has the following type specification:

                 fun(#'DistributionPoint'{}, #'CertificateList'{}) -&gt;
                        #'CertificateList'{}

                  The fun uses the information in the distribution point to access the latest  possible  version
                  of the CRL. If this fun is not specified, Public Key uses the default implementation:

                 fun(_DP, CRL) -&gt; CRL end

                <b>{issuer_fun,</b> <b>fun()}:</b>
                  The fun has the following type specification:

                fun(#'DistributionPoint'{}, #'CertificateList'{},
                    {rdnSequence,[#'AttributeTypeAndValue'{}]}, term()) -&gt;
                     {ok, #'OTPCertificate'{}, [der_encoded]}

                  The fun returns the root certificate and certificate chain that has signed the CRL.

                 fun(DP, CRL, Issuer, UserState) -&gt; {ok, RootCert, CertChain}

                <b>{undetermined_details,</b> <b>boolean()}:</b>
                  Defaults  to  false.  When  revocation  status cannot be determined, and this option is set to
                  true, details of why no CRLs where accepted are included in the return value.

       <b>pkix_crl_verify(CRL,</b> <b>Cert)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 CRL = der_encoded() | #'CertificateList'{}
                 Cert = cert()

              Verify that <u>Cert</u> is the <u>CRL</u> signer.

       <b>pkix_dist_point(Cert)</b> <b>-&gt;</b> <b>DistPoint</b>

              Types:

                 Cert = cert()
                 DistPoint = #'DistributionPoint'{}

              Creates a distribution point for CRLs issued by the same issuer as <u>Cert</u>. Can be used as  input  to
              pkix_crls_validate/3

       <b>pkix_dist_points(Cert)</b> <b>-&gt;</b> <b>DistPoints</b>

              Types:

                 Cert = cert()
                 DistPoints = [#'DistributionPoint'{}]

              Extracts distribution points from the certificates extensions.

       <b>pkix_hash_type(HashOid</b> <b>::</b> <b>oid())</b> <b>-&gt;</b>
                         DigestType ::
                             md5 | crypto:sha1() | crypto:sha2()

              Translates OID to Erlang digest type

       <b>pkix_match_dist_point(CRL,</b> <b>DistPoint)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 CRL = der_encoded() | #'CertificateList'{}
                 DistPoint = #'DistributionPoint'{}

              Checks  whether the given distribution point matches the Issuing Distribution Point of the CRL, as
              described in RFC 5280. If the CRL doesn't  have  an  Issuing  Distribution  Point  extension,  the
              distribution point always matches.

       <b>pkix_sign(Cert,</b> <b>Key)</b> <b>-&gt;</b> <b>Der</b>

              Types:

                 Cert = #'OTPTBSCertificate'{}
                 Key = private_key()
                 Der = der_encoded()

              Signs an 'OTPTBSCertificate'. Returns the corresponding DER-encoded certificate.

       <b>pkix_sign_types(AlgorithmId)</b> <b>-&gt;</b> <b>{DigestType,</b> <b>SignatureType}</b>

              Types:

                 AlgorithmId = oid()
                 DigestType = crypto:rsa_digest_type() | none
                 SignatureType = rsa | dsa | ecdsa

              Translates signature algorithm OID to Erlang digest and signature types.

              The <u>AlgorithmId</u> is the signature OID from a certificate or a certificate revocation list.

       <b>pkix_test_data(ChainConf)</b> <b>-&gt;</b> <b>TestConf</b>

              Types:

                 ChainConf =
                     #{server_chain := chain_opts(), client_chain := chain_opts()} |
                     chain_opts()
                 TestConf = test_config() | [conf_opt()]

              Creates  certificate  configuration(s)  consisting  of  certificate  and  its  private key plus CA
              certificate bundle, for a client and  a  server,  intended  to  facilitate  automated  testing  of
              applications  using  X509-certificates,  often through SSL/TLS. The test data can be used when you
              have control over both the client and the server in a test scenario.

              When this function is called with a map containing client  and  server  chain  specifications;  it
              generates  both  a client and a server certificate chain where the <u>cacerts</u> returned for the server
              contains the root cert the server should trust and the intermediate certificates the server should
              present to connecting clients. The root cert the server should trust is the one used  as  root  of
              the  client certificate chain. Vice versa applies to the <u>cacerts</u> returned for the client. The root
              cert(s) can either be pre-generated with  pkix_test_root_cert/2 , or if options are specified;  it
              is (they are) generated.

              When this function is called with a list of certificate options; it generates a configuration with
              just  one  node  certificate  where <u>cacerts</u> contains the root cert and the intermediate certs that
              should be presented to a peer. In this case the same root cert must be used for all peers. This is
              useful in for example an Erlang distributed cluster where any node,  towards  another  node,  acts
              either  as  a  server  or as a client depending on who connects to whom. The generated certificate
              contains a subject altname, which is not needed in a client certificate, but makes the certificate
              useful for both roles.

              Explanation of the options used to customize certificates in the generated chains:

                  {digest, digest_type()}: Hash algorithm to be used for signing the certificate  together  with
                  the key option. Defaults to sha that is sha1.

                  {key,  key_params() | private_key()}: Parameters to be used to call public_key:generate_key/1,
                  to generate a key, or an existing key. Defaults to generating an ECDSA key.  Note  this  could
                  fail if Erlang/OTP is compiled with a very old cryptolib.

                  {validity,  {From::erlang:timestamp(),  To::erlang:timestamp()}}  : The validity period of the
                  certificate.

                  {extensions, [#'Extension'{}]}: Extensions to include in the certificate.

                  Default extensions included in CA certificates if not otherwise specified are:

                [#'Extension'{extnID = ?'id-ce-keyUsage',
                              extnValue = [keyCertSign, cRLSign],
                              critical = false},
                #'Extension'{extnID = ?'id-ce-basicConstraints',
                             extnValue = #'BasicConstraints'{cA = true},
                             critical = true}]

                  Default extensions included in the server peer cert if not otherwise specified are:

                [#'Extension'{extnID = ?'id-ce-keyUsage',
                              extnValue = [digitalSignature, keyAgreement],
                              critical = false},
                #'Extension'{extnID = ?'id-ce-subjectAltName',
                             extnValue = [{dNSName, Hostname}],
                             critical = false}]

                  Hostname is the result of calling net_adm:localhost() in the Erlang node where this funcion is
                  called.

          <b>Note:</b>
              Note that the generated certificates and keys does not provide a formally correct PKIX-trust-chain
              and they cannot be used to achieve real security. This function is provided for  testing  purposes
              only.

       <b>pkix_test_root_cert(Name,</b> <b>Options)</b> <b>-&gt;</b> <b>RootCert</b>

              Types:

                 Name = string()
                 Options = [cert_opt()]
                 RootCert = test_root_cert()

              Generates  a root certificate that can be used in multiple calls to pkix_test_data/1 when you want
              the same root certificate for several generated certificates.

       <b>pkix_subject_id(Cert)</b> <b>-&gt;</b> <b>ID</b>

              Types:

                 Cert = cert()
                 ID = cert_id()

              Returns the X509 certificate subject id.

       <b>pkix_verify(Cert,</b> <b>Key)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Cert = der_cert()
                 Key = public_key()

              Verifies PKIX x.509 certificate signature.

       <b>pkix_verify_hostname(Cert,</b> <b>ReferenceIDs)</b> <b>-&gt;</b> <b>boolean()</b>

       <b>pkix_verify_hostname(Cert,</b> <b>ReferenceIDs,</b> <b>Options)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Cert = cert()
                 ReferenceIDs = referenceIDs()
                 Options = [{match_fun | fail_callback | fqdn_fun, function()}]

              This function checks that the <u>Presented</u> <u>Identifier</u>  (e.g hostname) in a  peer  certificate  is  in
              agreement  with  at least one of the <u>Reference</u> <u>Identifier</u>  that the client expects to be connected
              to. The function is intended to be added as an extra client check of  the  peer  certificate  when
              performing public_key:pkix_path_validation/3

              See  RFC  6125  for  detailed  information  about hostname verification. The User's Guide and code
              examples describes this function more detailed.

              The option funs are described here:

                <u>match_fun</u>:

                fun(ReferenceId::ReferenceId() | FQDN::string(),
                    PresentedId::{dNSName,string()} | {uniformResourceIdentifier,string() |
                                 {iPAddress,list(byte())} | {OtherId::atom()|oid(),term()}})

                fun(....) -&gt; true;   % My special case
                   (_, _) -&gt; default % all others falls back to the inherit tests
                end

                See pkix_verify_hostname_match_fun/1 for a function that takes a protocol name as  argument  and
                returns a <u>fun/2</u> suitable for this option and Re-defining the match operation in the User's Guide
                for an example.

            <b>Note:</b>
                Reference  Id  values  given  as binaries will be converted to strings, and ip references may be
                given in string format that is  "10.0.1.1"  or  "1234::5678:9012"  as  well  as  on  the  format
                inet:ip_address()

                <u>fail_callback</u>:
                  If  a  matching  fails,  there  could be circumstances when the certificate should be accepted
                  anyway. Think for example of a web browser where you choose to accept an outdated certificate.
                  This option enables implementation of such an exception  but  for  hostnames.  This  <u>fun/1</u>  is
                  called  when  no  <u>ReferenceID</u>  matches.  The return value of the fun (a <u>boolean()</u>) decides the
                  outcome. If <u>true</u> the the certificate is accepted otherwise it is  rejected.  See  "Pinning"  a
                  Certificate in the User's Guide.

                <u>fqdn_fun</u>:
                  This  option augments the host name extraction from URIs and other Reference IDs. It could for
                  example be a very special URI that is not standardised.  The  fun  takes  a  Reference  ID  as
                  argument and returns one of:

                  * the hostname

                  * the atom <u>default</u>: the default host name extract function will be used

                  * the  atom  <u>undefined</u>:  a  host  name could not be extracted. The pkix_verify_hostname/3 will
                    return <u>false</u>.

                For an example, see Hostname extraction in the User's Guide.

       <b>pkix_verify_hostname_match_fun(Protocol)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Protocol = https
                 Result = function()

              The return value of calling this function is intended to  be  used  in  the  <u>match_fun</u>  option  in
              pkix_verify_hostname/3.

              The  returned  fun  augments  the verify hostname matching according to the specific rules for the
              protocol in the argument.

          <b>Note:</b>
              Currently supported https fun will allow wildcard certificate matching as specified  by  the  HTTP
              standard.  Note  that for instance LDAP have a different set of wildcard matching rules. If you do
              not want to allow wildcard certificates (recommended from a  security  perspective)  or  otherwise
              customize  the  hostname  match  the  default  match  function  used  by  ssl  application will be
              sufficient.

       <b>sign(Msg,</b> <b>DigestType,</b> <b>Key)</b> <b>-&gt;</b> <b>Signature</b>

       <b>sign(Msg,</b> <b>DigestType,</b> <b>Key,</b> <b>Options)</b> <b>-&gt;</b> <b>Signature</b>

              Types:

                 Msg = binary() | {digest, binary()}
                 DigestType = digest_type()
                 Key = private_key() | ed_legacy_privkey()
                 Options = crypto:pk_sign_verify_opts()
                 Signature = binary()

              Creates a digital signature.

              The <u>Msg</u> is either the binary "plain text" data to be signed or it is the hashed  value  of  "plain
              text", that is, the digest.

       <b>ssh_decode(SshBin,</b> <b>Type)</b> <b>-&gt;</b> <b>Decoded</b>

              Types:

                 SshBin = binary()
                 Type = ssh2_pubkey | OtherType | InternalType
                 OtherType = public_key | ssh_file()
                 InternalType = new_openssh
                 Decoded = Decoded_ssh2_pubkey | Decoded_OtherType
                 Decoded_ssh2_pubkey = public_key() | ed_legacy_pubkey()
                 Decoded_OtherType =
                     [{public_key() | ed_legacy_pubkey(), Attributes}]
                 Attributes = [{atom(), term()}]

          <b>Note:</b>
              This function is deprecated and should not be used in new programs. Use ssh_file:decode/2 instead.

              Decodes an SSH file-binary. In the case of <u>known_hosts</u> or <u>auth_keys</u>, the binary can include one or
              more  lines  of  the  file. Returns a list of public keys and their attributes, possible attribute
              values depends on the file type represented by the binary.

              If the <u>Type</u> is  <u>ssh2_pubkey</u>,  the  result  will  be  <u>Decoded_ssh2_pubkey</u>.  Otherwise  it  will  be
              <u>Decoded_OtherType</u>.

                <b>RFC4716</b> <b>attributes</b> <b>-</b> <b>see</b> <b>RFC</b> <b>4716.:</b>
                  {headers, [{string(), utf8_string()}]}

                <b>auth_key</b> <b>attributes</b> <b>-</b> <b>see</b> <b>manual</b> <b>page</b> <b>for</b> <b>sshd.:</b>
                  {comment, string()}{options, [string()]}{bits, integer()} - In SSH version 1 files.

                <b>known_host</b> <b>attributes</b> <b>-</b> <b>see</b> <b>manual</b> <b>page</b> <b>for</b> <b>sshd.:</b>
                  {hostnames, [string()]}{comment, string()}{bits, integer()} - In SSH version 1 files.

              Example: <u>{ok,</u> <u>SshBin}</u> <u>=</u> <u>file:read_file("known_hosts")</u>.

              If <u>Type</u> is <u>public_key</u> the binary can be either an RFC4716 public key or an OpenSSH public key.

       <b>ssh_encode(InData,</b> <b>Type)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Type = ssh2_pubkey | OtherType
                 OtherType = public_key | ssh_file()
                 InData = InData_ssh2_pubkey | OtherInData
                 InData_ssh2_pubkey = public_key() | ed_legacy_pubkey()
                 OtherInData = [{Key, Attributes}]
                 Key = public_key() | ed_legacy_pubkey()
                 Attributes = [{atom(), term()}]

          <b>Note:</b>
              This function is deprecated and should not be used in new programs. Use ssh_file:encode/2 instead.

              Encodes  a  list of SSH file entries (public keys and attributes) to a binary. Possible attributes
              depend on the file type, see  ssh_decode/2 .

              If the <u>Type</u> is <u>ssh2_pubkey</u>,  the  <u>InData</u>  shall  be  <u>InData_ssh2_pubkey</u>.  Otherwise  it  shall  be
              <u>OtherInData</u>.

       <b>ssh_hostkey_fingerprint(HostKey)</b> <b>-&gt;</b> <b>string()</b>
       <b>ssh_hostkey_fingerprint(DigestType,</b> <b>HostKey)</b> <b>-&gt;</b> <b>string()</b>
       <b>ssh_hostkey_fingerprint([DigestType],</b> <b>HostKey)</b> <b>-&gt;</b> <b>[string()]</b>

              Types:

                 HostKey = public_key()
                 DigestType = digest_type()

              Calculates a ssh fingerprint from a public host key as openssh does.

          <b>Note:</b>
              This  function is deprecated and should not be used in new programs. Use ssh:hostkey_fingerprint/1
              or ssh:hostkey_fingerprint/2 instead.

              The algorithm in <u>ssh_hostkey_fingerprint/1</u> is md5 to be compatible with older ssh-keygen commands.
              The string from the second variant is prepended by the algorithm name in  uppercase  as  in  newer
              ssh-keygen commands.

              Examples:

               2&gt; public_key:ssh_hostkey_fingerprint(Key).
               "f5:64:a6:c1:5a:cb:9f:0a:10:46:a2:5c:3e:2f:57:84"

               3&gt; public_key:ssh_hostkey_fingerprint(md5,Key).
               "MD5:f5:64:a6:c1:5a:cb:9f:0a:10:46:a2:5c:3e:2f:57:84"

               4&gt; public_key:ssh_hostkey_fingerprint(sha,Key).
               "SHA1:bSLY/C4QXLDL/Iwmhyg0PGW9UbY"

               5&gt; public_key:ssh_hostkey_fingerprint(sha256,Key).
               "SHA256:aZGXhabfbf4oxglxltItWeHU7ub3Dc31NcNw2cMJePQ"

               6&gt; public_key:ssh_hostkey_fingerprint([sha,sha256],Key).
               ["SHA1:bSLY/C4QXLDL/Iwmhyg0PGW9UbY",
                "SHA256:aZGXhabfbf4oxglxltItWeHU7ub3Dc31NcNw2cMJePQ"]

       <b>verify(Msg,</b> <b>DigestType,</b> <b>Signature,</b> <b>Key)</b> <b>-&gt;</b> <b>boolean()</b>

       <b>verify(Msg,</b> <b>DigestType,</b> <b>Signature,</b> <b>Key,</b> <b>Options)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Msg = binary() | {digest, binary()}
                 DigestType = digest_type()
                 Signature = binary()
                 Key = public_key() | ed_legacy_pubkey()
                 Options = crypto:pk_sign_verify_opts()

              Verifies a digital signature.

              The <u>Msg</u> is either the binary "plain text" data or it is the hashed value of "plain text", that is,
              the digest.

       <b>short_name_hash(Name)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Name = issuer_name()

              Generates  a  short  hash  of  an  issuer  name. The hash is returned as a string containing eight
              hexadecimal digits.

              The return value of this function is the same as the result of the commands <u>openssl</u> <u>crl</u> <u>-hash</u>  and
              <u>openssl</u>  <u>x509</u>  <u>-issuer_hash</u>,  when passed the issuer name of a CRL or a certificate, respectively.
              This hash is used by the <u>c_rehash</u> tool to maintain a directory of symlinks to CRL files, in  order
              to facilitate looking up a CRL by its issuer name.

Ericsson AB                                     public_key 1.11.3                               <u><a href="../man3erl/public_key.3erl.html">public_key</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>