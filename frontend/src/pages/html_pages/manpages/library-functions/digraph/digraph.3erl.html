<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>digraph - Directed graphs.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       digraph - Directed graphs.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides a version of labeled directed graphs ("digraphs").

       The digraphs managed by this module are stored in ETS tables. That implies the following:

         * Only the process that created the digraph is allowed to update it.

         * Digraphs  will  not be garbage collected. The ETS tables used for a digraph will only be deleted when
           <u>delete/1</u> is called or the process that created the digraph terminates.

         * A digraph is a mutable data structure.

       What makes the graphs provided here non-proper directed graphs is that multiple  edges  between  vertices
       are allowed. However, the customary definition of directed graphs is used here.

         * A  <u>directed</u> <u>graph</u> (or just "digraph") is a pair (V, E) of a finite set V of <u>vertices</u> and a finite set
           E of <u>directed</u> <u>edges</u> (or just "edges"). The set of edges E is a subset of V x V (the Cartesian product
           of V with itself).

           In this module, V is allowed to be empty. The so obtained unique digraph is called the <u>empty</u> <u>digraph</u>.
           Both vertices and edges are represented by unique Erlang terms.

         * Digraphs can be annotated with more information. Such information can be attached to the vertices and
           to the edges of the digraph. An annotated digraph is called a <u>labeled</u> <u>digraph</u>,  and  the  information
           attached to a vertex or an edge is called a <u>label</u>. Labels are Erlang terms.

         * An edge e = (v, w) is said to <u>emanate</u> from vertex v and to be <u>incident</u> on vertex w.

         * The <u>out-degree</u> of a vertex is the number of edges emanating from that vertex.

         * The <u>in-degree</u> of a vertex is the number of edges incident on that vertex.

         * If an edge is emanating from v and incident on w, then w is said to be an <u>out-neighbor</u> of v, and v is
           said to be an <u>in-neighbor</u> of w.

         * A  <u>path</u>  P  from  v[1]  to  v[k] in a digraph (V, E) is a non-empty sequence v[1], v[2], ..., v[k] of
           vertices in V such that there is an edge (v[i],v[i+1]) in E for 1 &lt;= i &lt; k.

         * The <u>length</u> of path P is k-1.

         * Path P is <u>simple</u> if all vertices are distinct, except that the first and the last vertices can be the
           same.

         * Path P is a <u>cycle</u> if the length of P is not zero and v[1] = v[k].

         * A <u>loop</u> is a cycle of length one.

         * A <u>simple</u> <u>cycle</u> is a path that is both a cycle and simple.

         * An <u>acyclic</u> <u>digraph</u> is a digraph without cycles.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>d_type()</b> = d_cyclicity() | d_protection()

       <b>d_cyclicity()</b> = acyclic | cyclic

       <b>d_protection()</b> = private | protected

       <b>graph()</b>

              A digraph as returned by <u>new/0,1</u>.

       <b>edge()</b>

       <b>label()</b> = term()

       <b>vertex()</b>

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>add_edge(G,</b> <b>V1,</b> <b>V2)</b> <b>-&gt;</b> <b>edge()</b> <b>|</b> <b>{error,</b> <b>add_edge_err_rsn()}</b>

       <b>add_edge(G,</b> <b>V1,</b> <b>V2,</b> <b>Label)</b> <b>-&gt;</b> <b>edge()</b> <b>|</b> <b>{error,</b> <b>add_edge_err_rsn()}</b>

       <b>add_edge(G,</b> <b>E,</b> <b>V1,</b> <b>V2,</b> <b>Label)</b> <b>-&gt;</b>
                   edge() | {error, add_edge_err_rsn()}

              Types:

                 G = graph()
                 E = edge()
                 V1 = V2 = vertex()
                 Label = label()
                 <b>add_edge_err_rsn()</b> =
                     {bad_edge, Path :: [vertex()]} | {bad_vertex, V :: vertex()}

              <u>add_edge/5</u> creates (or modifies) edge <u>E</u> of digraph <u>G</u>, using <u>Label</u> as the (new) label of the  edge.
              The edge is emanating from <u>V1</u> and incident on <u>V2</u>. Returns <u>E</u>.

              <u>add_edge(G,</u>  <u>V1,</u>  <u>V2,</u>  <u>Label)</u> is equivalent to <u>add_edge(G,</u> <u>E,</u> <u>V1,</u> <u>V2,</u> <u>Label)</u>, where <u>E</u> is a created
              edge. The created edge is represented by term <u>['$e'</u> <u>|</u> <u>N]</u>, where <u>N</u> is an integer &gt;= 0.

              <u>add_edge(G,</u> <u>V1,</u> <u>V2)</u> is equivalent to <u>add_edge(G,</u> <u>V1,</u> <u>V2,</u> <u>[])</u>.

              If the edge would create a cycle in an acyclic digraph, <u>{error,</u> <u>{bad_edge,</u> <u>Path}}</u> is returned.  If
              <u>G</u>  already  has  an  edge with value <u>E</u> connecting a different pair of vertices, <u>{error,</u> <u>{bad_edge,</u>
              <u>[V1,</u> <u>V2]}}</u> is returned. If either of <u>V1</u> or <u>V2</u> is not a vertex of digraph <u>G</u>,  <u>{error,</u>  <u>{bad_vertex,</u>
              V<u>}}</u> is returned, V = <u>V1</u> or V = <u>V2</u>.

       <b>add_vertex(G)</b> <b>-&gt;</b> <b>vertex()</b>

       <b>add_vertex(G,</b> <b>V)</b> <b>-&gt;</b> <b>vertex()</b>

       <b>add_vertex(G,</b> <b>V,</b> <b>Label)</b> <b>-&gt;</b> <b>vertex()</b>

              Types:

                 G = graph()
                 V = vertex()
                 Label = label()

              <u>add_vertex/3</u>  creates  (or  modifies) vertex <u>V</u> of digraph <u>G</u>, using <u>Label</u> as the (new) label of the
              vertex. Returns <u>V</u>.

              <u>add_vertex(G,</u> <u>V)</u> is equivalent to <u>add_vertex(G,</u> <u>V,</u> <u>[])</u>.

              <u>add_vertex/1</u> creates a vertex using the empty list as label, and returns the created  vertex.  The
              created vertex is represented by term <u>['$v'</u> <u>|</u> <u>N]</u>, where <u>N</u> is an integer &gt;= 0.

       <b>del_edge(G,</b> <b>E)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 G = graph()
                 E = edge()

              Deletes edge <u>E</u> from digraph <u>G</u>.

       <b>del_edges(G,</b> <b>Edges)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 G = graph()
                 Edges = [edge()]

              Deletes the edges in list <u>Edges</u> from digraph <u>G</u>.

       <b>del_path(G,</b> <b>V1,</b> <b>V2)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 G = graph()
                 V1 = V2 = vertex()

              Deletes edges from digraph <u>G</u> until there are no paths from vertex <u>V1</u> to vertex <u>V2</u>.

              A sketch of the procedure employed:

                * Find an arbitrary simple path v[1], v[2], ..., v[k] from <u>V1</u> to <u>V2</u> in <u>G</u>.

                * Remove  all  edges  of  <u>G</u> emanating from v[i] and incident to v[i+1] for 1 &lt;= i &lt; k (including
                  multiple edges).

                * Repeat until there is no path between <u>V1</u> and <u>V2</u>.

       <b>del_vertex(G,</b> <b>V)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 G = graph()
                 V = vertex()

              Deletes vertex <u>V</u> from digraph <u>G</u>. Any edges emanating from <u>V</u> or incident on <u>V</u> are also deleted.

       <b>del_vertices(G,</b> <b>Vertices)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 G = graph()
                 Vertices = [vertex()]

              Deletes the vertices in list <u>Vertices</u> from digraph <u>G</u>.

       <b>delete(G)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 G = graph()

              Deletes digraph <u>G</u>. This call is important as digraphs  are  implemented  with  ETS.  There  is  no
              garbage  collection of ETS tables. However, the digraph is deleted if the process that created the
              digraph terminates.

       <b>edge(G,</b> <b>E)</b> <b>-&gt;</b> <b>{E,</b> <b>V1,</b> <b>V2,</b> <b>Label}</b> <b>|</b> <b>false</b>

              Types:

                 G = graph()
                 E = edge()
                 V1 = V2 = vertex()
                 Label = label()

              Returns <u>{E,</u> <u>V1,</u> <u>V2,</u> <u>Label}</u>, where <u>Label</u> is the label of edge <u>E</u> emanating from <u>V1</u> and  incident  on
              <u>V2</u> of digraph <u>G</u>. If no edge <u>E</u> of digraph <u>G</u> exists, <u>false</u> is returned.

       <b>edges(G)</b> <b>-&gt;</b> <b>Edges</b>

              Types:

                 G = graph()
                 Edges = [edge()]

              Returns a list of all edges of digraph <u>G</u>, in some unspecified order.

       <b>edges(G,</b> <b>V)</b> <b>-&gt;</b> <b>Edges</b>

              Types:

                 G = graph()
                 V = vertex()
                 Edges = [edge()]

              Returns  a  list  of  all  edges emanating from or incident on <u>V</u> of digraph <u>G</u>, in some unspecified
              order.

       <b>get_cycle(G,</b> <b>V)</b> <b>-&gt;</b> <b>Vertices</b> <b>|</b> <b>false</b>

              Types:

                 G = graph()
                 V = vertex()
                 Vertices = [vertex(), ...]

              If a simple cycle of length two or more exists through vertex <u>V</u>, the cycle is returned as  a  list
              <u>[V,</u>  <u>...,</u>  <u>V]</u>  of  vertices. If a loop through <u>V</u> exists, the loop is returned as a list <u>[V]</u>. If no
              cycles through <u>V</u> exist, <u>false</u> is returned.

              <u>get_path/3</u> is used for finding a simple cycle through <u>V</u>.

       <b>get_path(G,</b> <b>V1,</b> <b>V2)</b> <b>-&gt;</b> <b>Vertices</b> <b>|</b> <b>false</b>

              Types:

                 G = graph()
                 V1 = V2 = vertex()
                 Vertices = [vertex(), ...]

              Tries to find a simple path from vertex <u>V1</u> to vertex <u>V2</u> of digraph <u>G</u>. Returns the path as  a  list
              <u>[V1,</u> <u>...,</u> <u>V2]</u> of vertices, or <u>false</u> if no simple path from <u>V1</u> to <u>V2</u> of length one or more exists.

              Digraph <u>G</u> is traversed in a depth-first manner, and the first found path is returned.

       <b>get_short_cycle(G,</b> <b>V)</b> <b>-&gt;</b> <b>Vertices</b> <b>|</b> <b>false</b>

              Types:

                 G = graph()
                 V = vertex()
                 Vertices = [vertex(), ...]

              Tries  to  find  an  as  short as possible simple cycle through vertex <u>V</u> of digraph <u>G</u>. Returns the
              cycle as a list <u>[V,</u> <u>...,</u> <u>V]</u> of vertices, or <u>false</u> if no simple cycle through <u>V</u> exists. Notice that
              a loop through <u>V</u> is returned as list <u>[V,</u> <u>V]</u>.

              <u>get_short_path/3</u> is used for finding a simple cycle through <u>V</u>.

       <b>get_short_path(G,</b> <b>V1,</b> <b>V2)</b> <b>-&gt;</b> <b>Vertices</b> <b>|</b> <b>false</b>

              Types:

                 G = graph()
                 V1 = V2 = vertex()
                 Vertices = [vertex(), ...]

              Tries to find an as short as possible simple path from vertex  <u>V1</u>  to  vertex  <u>V2</u>  of  digraph  <u>G</u>.
              Returns  the path as a list <u>[V1,</u> <u>...,</u> <u>V2]</u> of vertices, or <u>false</u> if no simple path from <u>V1</u> to <u>V2</u> of
              length one or more exists.

              Digraph <u>G</u> is traversed in a breadth-first manner, and the first found path is returned.

       <b>in_degree(G,</b> <b>V)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 G = graph()
                 V = vertex()

              Returns the in-degree of vertex <u>V</u> of digraph <u>G</u>.

       <b>in_edges(G,</b> <b>V)</b> <b>-&gt;</b> <b>Edges</b>

              Types:

                 G = graph()
                 V = vertex()
                 Edges = [edge()]

              Returns a list of all edges incident on <u>V</u> of digraph <u>G</u>, in some unspecified order.

       <b>in_neighbours(G,</b> <b>V)</b> <b>-&gt;</b> <b>Vertex</b>

              Types:

                 G = graph()
                 V = vertex()
                 Vertex = [vertex()]

              Returns a list of all in-neighbors of <u>V</u> of digraph <u>G</u>, in some unspecified order.

       <b>info(G)</b> <b>-&gt;</b> <b>InfoList</b>

              Types:

                 G = graph()
                 InfoList =
                     [{cyclicity, Cyclicity :: d_cyclicity()} |
                      {memory, NoWords :: integer() &gt;= 0} |
                      {protection, Protection :: d_protection()}]
                 <b>d_cyclicity()</b> = acyclic | cyclic
                 <b>d_protection()</b> = private | protected

              Returns a list of <u>{Tag,</u> <u>Value}</u> pairs describing digraph <u>G</u>. The following pairs are returned:

                * <u>{cyclicity,</u> <u>Cyclicity}</u>, where <u>Cyclicity</u> is <u>cyclic</u> or <u>acyclic</u>, according to the  options  given
                  to <u>new</u>.

                * <u>{memory,</u> <u>NoWords}</u>, where <u>NoWords</u> is the number of words allocated to the ETS tables.

                * <u>{protection,</u>  <u>Protection}</u>,  where <u>Protection</u> is <u>protected</u> or <u>private</u>, according to the options
                  given to <u>new</u>.

       <b>new()</b> <b>-&gt;</b> <b>graph()</b>

              Equivalent to <u>new([])</u>.

       <b>new(Type)</b> <b>-&gt;</b> <b>graph()</b>

              Types:

                 Type = [d_type()]
                 <b>d_type()</b> = d_cyclicity() | d_protection()
                 <b>d_cyclicity()</b> = acyclic | cyclic
                 <b>d_protection()</b> = private | protected

              Returns an empty digraph with properties according to the options in <u>Type</u>:

                <u>cyclic</u>:
                  Allows cycles in the digraph (default).

                <u>acyclic</u>:
                  The digraph is to be kept acyclic.

                <u>protected</u>:
                  Other processes can read the digraph (default).

                <u>private</u>:
                  The digraph can be read and modified by the creating process only.

              If an unrecognized type option <u>T</u> is specified or <u>Type</u> is not a proper list, a <u>badarg</u> exception  is
              raised.

       <b>no_edges(G)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 G = graph()

              Returns the number of edges of digraph <u>G</u>.

       <b>no_vertices(G)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 G = graph()

              Returns the number of vertices of digraph <u>G</u>.

       <b>out_degree(G,</b> <b>V)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 G = graph()
                 V = vertex()

              Returns the out-degree of vertex <u>V</u> of digraph <u>G</u>.

       <b>out_edges(G,</b> <b>V)</b> <b>-&gt;</b> <b>Edges</b>

              Types:

                 G = graph()
                 V = vertex()
                 Edges = [edge()]

              Returns a list of all edges emanating from <u>V</u> of digraph <u>G</u>, in some unspecified order.

       <b>out_neighbours(G,</b> <b>V)</b> <b>-&gt;</b> <b>Vertices</b>

              Types:

                 G = graph()
                 V = vertex()
                 Vertices = [vertex()]

              Returns a list of all out-neighbors of <u>V</u> of digraph <u>G</u>, in some unspecified order.

       <b>vertex(G,</b> <b>V)</b> <b>-&gt;</b> <b>{V,</b> <b>Label}</b> <b>|</b> <b>false</b>

              Types:

                 G = graph()
                 V = vertex()
                 Label = label()

              Returns <u>{V,</u> <u>Label}</u>, where <u>Label</u> is the label of the vertex <u>V</u> of digraph <u>G</u>, or <u>false</u> if no vertex <u>V</u>
              of digraph <u>G</u> exists.

       <b>vertices(G)</b> <b>-&gt;</b> <b>Vertices</b>

              Types:

                 G = graph()
                 Vertices = [vertex()]

              Returns a list of all vertices of digraph <u>G</u>, in some unspecified order.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/digraph_utils.3erl.html">digraph_utils</a>(3erl)</u>, <u><a href="../man3erl/ets.3erl.html">ets</a>(3erl)</u>

Ericsson AB                                        stdlib 3.17                                     <u><a href="../man3erl/digraph.3erl.html">digraph</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>