<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ost::Thread - Every thread of execution in an application is created by instantiating an object of a</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libcommoncpp2-doc">libcommoncpp2-doc_1.8.1-10_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ost::Thread - Every thread of execution in an application is created by instantiating an object of a
       class derived from the <b>Thread</b> class.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;thread.h&gt;

       Inherited by <b>ost::PosixThread</b>, <b>ost::SerialService</b>, <b>ost::SocketService</b>, <b>ost::TCPSession</b>, <b>ost::ThreadQueue</b>,
       <b>ost::TTYSession</b>, and <b>ost::UnixSession</b>.

   <b>Public</b> <b>Types</b>
       enum <b>Throw</b> { <b>throwNothing</b>, <b>throwObject</b>, <b>throwException</b> }
           How to raise error.
       enum <b>Cancel</b> { <b>cancelInitial</b> =0, <b>cancelDeferred</b> =1, <b>cancelImmediate</b>, <b>cancelDisabled</b>, <b>cancelManual</b>,
           <b>cancelDefault</b> =cancelDeferred }
           How work cancellation.
       enum <b>Suspend</b> { <b>suspendEnable</b>, <b>suspendDisable</b> }
           How work suspend.
       typedef enum <b>ost::Thread::Throw</b> <b>Throw</b>
           How to raise error.
       typedef enum <b>ost::Thread::Cancel</b> <b>Cancel</b>
           How work cancellation.
       typedef enum <b>ost::Thread::Suspend</b> <b>Suspend</b>
           How work suspend.

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>Thread</b> (bool isMain)
           This is actually a special constructor that is used to create a thread 'object' for the current
           execution context when that context is not created via an instance of a derived <b>Thread</b> object itself.
       <b>Thread</b> (int pri=0, size_t stack=0)
           When a thread object is contructed, a new thread of execution context is created.
       <b>Thread</b> (const <b>Thread</b> &amp;th)
           A thread of execution can also be specified by cloning an existing thread.
       virtual <b>~Thread</b> ()
           The thread destructor should clear up any resources that have been allocated by the thread.
       int <b>start</b> (<b>Semaphore</b> *start=0)
           When a new thread is created, it does not begin immediate execution.
       int <b>detach</b> (<b>Semaphore</b> *<b>start</b>=0)
           Start a new thread as 'detached'.
       <b>Thread</b> * <b>getParent</b> (void)
           Gets the pointer to the <b>Thread</b> class which created the current thread object.
       void <b>suspend</b> (void)
           Suspends execution of the selected thread.
       void <b>resume</b> (void)
           Resumes execution of the selected thread.
       <b>Cancel</b> <b>getCancel</b> (void)
           Used to retrieve the cancellation mode in effect for the selected thread.
       bool <b>isRunning</b> (void) const
           Verifies if the thread is still running or has already been terminated but not yet deleted.
       bool <b>isDetached</b> (void) const
           Check if this thread is detached.
       void <b>join</b> (void)
           Blocking call which unlocks when thread terminates.
       bool <b>isThread</b> (void) const
           Tests to see if the current execution context is the same as the specified thread object.
       <b>cctid_t</b> <b>getId</b> (void) const
           Get system thread numeric identifier.
       const char * <b>getName</b> (void) const
           Get the name string for this thread, to use in debug messages.

   <b>Static</b> <b>Public</b> <b>Member</b> <b>Functions</b>
       static <b>Thread</b> * <b>get</b> (void)
       static void <b>setStack</b> (size_t size=0)
           Set base stack limit before manual stack sizes have effect.
       static void <b>sleep</b> (<b>timeout_t</b> msec)
           A thread-safe sleep call.
       static void <b>yield</b> (void)
           Yields the current thread's CPU time slice to allow another thread to begin immediate execution.
       static <b>Throw</b> <b>getException</b> (void)
           Get exception mode of the current thread.
       static void <b>setException</b> (<b>Throw</b> mode)
           Set exception mode of the current thread.
       static <b>Cancel</b> <b>enterCancel</b> (void)
           This is used to help build wrapper functions in libraries around system calls that should behave as
           cancellation points but don't.
       static void <b>exitCancel</b> (<b>Cancel</b> cancel)
           This is used to restore a cancel block.

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       void <b>setName</b> (const char *text)
           Set the name of the current thread.
       virtual void <b>run</b> (void)=0
           All threads execute by deriving the Run method of <b>Thread</b>.
       virtual void <b>final</b> (void)
           A thread that is self terminating, either by invoking <b>exit()</b> or leaving it's <b>run()</b>, will have this
           method called.
       virtual void <b>initial</b> (void)
           The initial method is called by a newly created thread when it starts execution.
       virtual void * <b>getExtended</b> (void)
           Since <b>getParent()</b> and <b>getThread()</b> only refer to an object of the <b>Thread</b> 'base' type, this virtual
           method can be replaced in a derived class with something that returns data specific to the derived
           class that can still be accessed through the pointer returned by <b>getParent()</b> and <b>getThread()</b>.
       virtual void <b>notify</b> (<b>Thread</b> *)
           When a thread terminates, it now sends a notification message to the parent thread which created it.
       void <b>exit</b> (void)
           Used to properly exit from a <b>Thread</b> derived <b>run()</b> or <b>initial()</b> method.
       void <b>sync</b> (void)
           Used to wait for a join or cancel, in place of explicit exit.
       bool <b>testCancel</b> (void)
           test a cancellation point for deferred thread cancellation.
       void <b>setCancel</b> (<b>Cancel</b> mode)
           Sets thread cancellation mode.
       void <b>setSuspend</b> (<b>Suspend</b> mode)
           Sets the thread's ability to be suspended from execution.
       void <b>terminate</b> (void)
           Used by another thread to terminate the current thread.
       void <b>clrParent</b> (void)
           clear parent thread relationship.

   <b>Friends</b>
       class <b>PosixThread</b>
       class <b>DummyThread</b>
       class <b>Cancellation</b>
       class <b>postream_type</b>
       class <b>Slog</b>
       class <b>ThreadImpl</b>
       void <b>operator++</b> (<b>Thread</b> &amp;th)
           Signal the semaphore that the specified thread is waiting for before beginning execution.
       void <b>operator--</b> (<b>Thread</b> &amp;th)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Every thread of execution in an application is created by instantiating an object of a class derived from
       the <b>Thread</b> class.

       Classes derived from <b>Thread</b> must implement the <b>run()</b> method, which specifies the code of the thread. The
       base <b>Thread</b> class supports encapsulation of the generic threading methods implemented on various target
       operating systems. This includes the ability to start and stop threads in a synchronized and controllable
       manner, the ability to specify thread execution priority, and thread specific 'system call' wrappers,
       such as for sleep and yield. A thread exception is thrown if the thread cannot be created. Threading was
       the first part of Common C++ I wrote, back when it was still the APE library. My goal for Common C++
       threading has been to make threading as natural and easy to use in C++ application development as
       threading is in Java. With this said, one does not need to use threading at all to take advantage of
       Common C++. However, all Common C++ classes are designed at least to be thread-aware/thread-safe as
       appropriate and necessary.

       Common C++ threading is currently built either from the Posix 'pthread' library or using the win32 SDK.
       In that the Posix 'pthread' draft has gone through many revisions, and many system implementations are
       only marginally compliant, and even then usually in different ways, I wrote a large series of autoconf
       macros found in ost_pthread.m4 which handle the task of identifying which pthread features and
       capabilities your target platform supports. In the process I learned much about what autoconf can and
       cannot do for you..

       Currently the GNU Portable <b>Thread</b> library (GNU pth) is not directly supported in Common C++. While GNU
       'Pth' doesn't offer direct native threading support or benefit from SMP hardware, many of the design
       advantages of threading can be gained from it's use, and the Pth pthread 'emulation' library should be
       usable with Common C++. In the future, Common C++ will directly support Pth, as well as OS/2 and BeOS
       native threading API's.

       Common C++ itself defines a fairly 'neutral' threading model that is not tied to any specific API such as
       pthread, win32, etc. This neutral thread model is contained in a series of classes which handle threading
       and synchronization and which may be used together to build reliable threaded applications.

       Common C++ defines application specific threads as objects which are derived from the Common C++ 'Thread'
       base class. At minimum the 'Run' method must be implemented, and this method essentially is the 'thread',
       for it is executed within the execution context of the thread, and when the Run method terminates the
       thread is assumed to have terminated.

       Common C++ allows one to specify the running priority of a newly created thread relative to the 'parent'
       thread which is the thread that is executing when the constructor is called. Since most newer C++
       implementations do not allow one to call virtual constructors or virtual methods from constructors, the
       thread must be 'started' after the constructor returns. This is done either by defining a 'starting'
       semaphore object that one or more newly created thread objects can wait upon, or by invoking an explicit
       'start' member function.

       Threads can be 'suspended' and 'resumed'. As this behavior is not defined in the Posix 'pthread'
       specification, it is often emulated through signals. Typically SIGUSR1 will be used for this purpose in
       Common C++ applications, depending in the target platform. On Linux, since threads are indeed processes,
       SIGSTP and SIGCONT can be used. On solaris, the Solaris thread library supports suspend and resume
       directly.

       Threads can be canceled. Not all platforms support the concept of externally cancelable threads. On those
       platforms and API implementations that do not, threads are typically canceled through the action of a
       signal handler.

       As noted earlier, threads are considered running until the 'Run' method returns, or until a cancellation
       request is made. Common C++ threads can control how they respond to cancellation, using
       setCancellation(). <b>Cancellation</b> requests can be ignored, set to occur only when a cancellation 'point'
       has been reached in the code, or occur immediately. Threads can also exit by returning from Run() or by
       invoking the Exit() method.

       Generally it is a good practice to initialize any resources the thread may require within the constructor
       of your derived thread class, and to purge or restore any allocated resources in the destructor. In most
       cases, the destructor will be executed after the thread has terminated, and hence will execute within the
       context of the thread that requested a join rather than in the context of the thread that is being
       terminated. Most destructors in derived thread classes should first call Terminate() to make sure the
       thread has stopped running before releasing resources.

       A Common C++ thread is normally canceled by deleting the thread object. The process of deletion invokes
       the thread's destructor, and the destructor will then perform a 'join' against the thread using the
       Terminate() function. This behavior is not always desirable since the thread may block itself from
       cancellation and block the current 'delete' operation from completing. One can alternately invoke
       Terminate() directly before deleting a thread object.

       When a given Common C++ thread exits on it's own through it's Run() method, a 'Final' method will be
       called. This Final method will be called while the thread is 'detached'. If a thread object is
       constructed through a 'new' operator, it's final method can be used to 'self delete' when done, and
       allows an independent thread to construct and remove itself autonomously.

       A special global function, <b>getThread()</b>, is provided to identify the thread object that represents the
       current execution context you are running under. This is sometimes needed to deliver signals to the
       correct thread. Since all thread manipulation should be done through the Common C++ (base) thread class
       itself, this provides the same functionality as things like 'pthread_self' for Common C++.

       All Common C++ threads have an exception 'mode' which determines their behavior when an exception is
       thrown by another Common C++ class. Extensions to Common C++ should respect the current exception mode
       and use <b>getException()</b> to determine what to do when they are about to throw an object. The default
       exception mode (defined in the <b>Thread()</b> constructor) is throwObject, which causes a pointer to an
       instance of the class where the error occured to be thrown. Other exception modes are throwException,
       which causes a class-specific exception class to be thrown, and throwNothing, which causes errors to be
       ignored.

       As an example, you could try to call the <b>Socket</b> class with an invalid address that the system could not
       bind to. This would cause an object of type <b>Socket</b> * to be thrown by default, as the default exception
       mode is throwObject. If you call setException(throwException) before the bad call to the <b>Socket</b>
       constructor, an object of type SockException (the exception class for class <b>Socket</b>) will be thrown
       instead.

       To determine what exception class is thrown by a given Common C++ class when the exception mode is set to
       throwException, search the source files for the class you are interested in for a class which inherits
       directly or indirectly from class Exception. This is the exception class which would be thrown when the
       exception mode is set to throwException.

       The advantage of using throwException versus throwObject is that more information is available to the
       programmer from the thrown object. All class-specific exceptions inherit from class Exception, which
       provides a getString() method which can be called to get a human-readable error string.

       Common C++ threads are often aggregated into other classes to provide services that are 'managed' from or
       operate within the context of a thread, even within the Common C++ framework itself. A good example of
       this is the <b>TCPSession</b> class, which essentially is a combination of a TCP client connection and a
       separate thread the user can define by deriving a class with a Run() method to handle the connected
       service. This aggregation logically connects the successful allocation of a given resource with the
       construction of a thread to manage and perform operations for said resource.

       Threads are also used in 'service pools'. In Common C++, a service pool is one or more threads that are
       used to manage a set of resources. While Common C++ does not provide a direct 'pool' class, it does
       provide a model for their implementation, usually by constructing an array of thread 'service' objects,
       each of which can then be assigned the next new instance of a given resource in turn or algorithmically.

       Threads have signal handlers associated with them. Several signal types are 'predefined' and have special
       meaning. All signal handlers are defined as virtual member functions of the <b>Thread</b> class which are called
       when a specific signal is received for a given thread. The 'SIGPIPE' event is defined as a 'Disconnect'
       event since it's normally associated with a socket disconnecting or broken fifo. The Hangup() method is
       associated with the SIGHUP signal. All other signals are handled through the more generic Signal().

       Incidently, unlike Posix, the win32 API has no concept of signals, and certainly no means to define or
       deliver signals on a per-thread basis. For this reason, no signal handling is supported or emulated in
       the win32 implementation of Common C++ at this time.

       In addition to <b>TCPStream</b>, there is a <b>TCPSession</b> class which combines a thread with a <b>TCPStream</b> object.
       The assumption made by <b>TCPSession</b> is that one will service each TCP connection with a separate thread,
       and this makes sense for systems where extended connections may be maintained and complex protocols are
       being used over TCP.

       <b>Author</b>
           David Sugar <a href="mailto:dyfet@ostel.com">dyfet@ostel.com</a>

       base class used to derive all threads of execution.

       <b>Examples</b>
           <b>bug1.cpp</b>, <b>bug2.cpp</b>, <b>tcpservice.cpp</b>, <b>tcpstr1.cpp</b>, <b>thread1.cpp</b>, and <b>thread2.cpp</b>.

</pre><h4><b>Member</b> <b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>enum</b> <b>ost::Thread::Cancel</b> <b>ost::Thread::Cancel</b>
       How work cancellation.

   <b>typedef</b> <b>enum</b> <b>ost::Thread::Suspend</b> <b>ost::Thread::Suspend</b>
       How work suspend.

   <b>typedef</b> <b>enum</b> <b>ost::Thread::Throw</b> <b>ost::Thread::Throw</b>
       How to raise error.

</pre><h4><b>Member</b> <b>Enumeration</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>ost::Thread::Cancel</b>
       How work cancellation.

       <b>Enumerator</b>

       <u>cancelInitial</u>
              used internally, do not use

       <u>cancelDeferred</u>
              exit thread on cancellation pointsuch as yield

       <u>cancelImmediate</u>
              exit befor cancellation

       <u>cancelDisabled</u>
              ignore cancellation

       <u>cancelManual</u>
              unimplemented (working in progress)

       <u>cancelDefault</u>
              default you should use this for compatibility instead of deferred

   <b>enum</b> <b>ost::Thread::Suspend</b>
       How work suspend.

       <b>Enumerator</b>

       <u>suspendEnable</u>
              suspend enabled

       <u>suspendDisable</u>
              suspend disabled, Suspend do nothing

   <b>enum</b> <b>ost::Thread::Throw</b>
       How to raise error.

       <b>Enumerator</b>

       <u>throwNothing</u>
              continue without throwing error

       <u>throwObject</u>
              throw object that cause error (throw this)

       <u>throwException</u>
              throw an object relative to error

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>ost::Thread::Thread</b> <b>(bool</b> <b>isMain)</b>
       This is actually a special constructor that is used to create a thread 'object' for the current execution
       context  when  that  context  is  not  created  via  an  instance of a derived <b>Thread</b> object itself. This
       constructor does not support First.

       <b>Parameters</b>
           <u>isMain</u> bool used if the main 'thread' of the application.

   <b>ost::Thread::Thread</b> <b>(int</b> <b>pri</b> <b>=</b> <b>0,</b> <b>size_t</b> <b>stack</b> <b>=</b> <b>0)</b>
       When a thread object is contructed, a new thread of execution context is created. This constructor allows
       basic properties of that context (thread  priority,  stack  space,  etc)  to  be  defined.  The  starting
       condition is also specified for whether the thread is to wait on a semaphore before begining execution or
       wait until it's start method is called.

       <b>Parameters</b>
           <u>pri</u> thread base priority relative to it's parent.
           <u>stack</u> space as needed in some implementations.

   <b>ost::Thread::Thread</b> <b>(const</b> <b>Thread</b> <b>&amp;</b> <b>th)</b>
       A  thread  of  execution  can  also  be  specified  by  cloning an existing thread. The existing thread's
       properties (cancel mode, priority, etc), are also duplicated.

       <b>Parameters</b>
           <u>th</u> currently executing thread object to clone.

   <b>virtual</b> <b>ost::Thread::~Thread</b> <b>()</b> <b>[virtual]</b>
       The thread destructor should clear up  any  resources  that  have  been  allocated  by  the  thread.  The
       desctructor  of a derived thread should begin with Terminate() and is presumed to then execute within the
       context of the thread causing terminaton.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>ost::Thread::clrParent</b> <b>(void)</b> <b>[inline],</b>  <b>[protected]</b>
       clear parent thread relationship.

   <b>int</b> <b>ost::Thread::detach</b> <b>(Semaphore</b> <b>*</b> <b>start</b> <b>=</b> <b>0)</b>
       Start a new thread as 'detached'. This is an alternative <b>start()</b> method that resolves  some  issues  with
       later glibc implimentations which incorrectly impliment self-detach.

       <b>Returns</b>
           error code if execution fails.

       <b>Parameters</b>
           <u>start</u> optional starting semaphore to alternately use.

       <b>Examples</b>
           <b>thread2.cpp</b>.

   <b>static</b> <b>Cancel</b> <b>ost::Thread::enterCancel</b> <b>(void)</b> <b>[static]</b>
       This  is  used  to  help  build  wrapper functions in libraries around system calls that should behave as
       cancellation points but don't.

       <b>Returns</b>
           saved cancel type.

   <b>void</b> <b>ost::Thread::exit</b> <b>(void)</b> <b>[protected]</b>
       Used to properly exit from a <b>Thread</b> derived <b>run()</b>  or  <b>initial()</b>  method.  Terminates  execution  of  the
       current thread and calls the derived classes <b>final()</b> method.

   <b>static</b> <b>void</b> <b>ost::Thread::exitCancel</b> <b>(Cancel</b> <b>cancel)</b> <b>[static]</b>
       This is used to restore a cancel block.

       <b>Parameters</b>
           <u>cancel</u> type that was saved.

   <b>virtual</b> <b>void</b> <b>ost::Thread::final</b> <b>(void)</b> <b>[protected],</b>  <b>[virtual]</b>
       A thread that is self terminating, either by invoking <b>exit()</b> or leaving it's <b>run()</b>, will have this method
       called.  It can be used to self delete the current object assuming the object was created with new on the
       heap rather than stack local, hence one may often see final defined as 'delete this' in a derived  thread
       class.  A  final  method,  while  running,  cannot be terminated or cancelled by another thread. Final is
       called for all cancellation type (even immediate).

       You can safe delete thread ('delete this') class on final, but you should exit ASAP (or  do  not  try  to
       call CommonC++ methods...)

       <b>Note</b>
           A thread cannot delete its own context or join itself. To make a thread that is a self running object
           that self-deletes, one has to detach the thread by using <b>detach()</b> instead of <b>start()</b>.

       <b>See</b> <b>also</b>
           <b>exit</b>

           <b>run</b>

       Reimplemented in <b>ost::ThreadQueue</b>.

   <b>static</b> <b>Thread*</b> <b>ost::Thread::get</b> <b>(void)</b> <b>[static]</b>
       Referenced by ost::getThread().

   <b>Cancel</b> <b>ost::Thread::getCancel</b> <b>(void)</b> <b>[inline]</b>
       Used to retrieve the cancellation mode in effect for the selected thread.

       <b>Returns</b>
           cancellation mode constant.

   <b>static</b> <b>Throw</b> <b>ost::Thread::getException</b> <b>(void)</b> <b>[static]</b>
       Get exception mode of the current thread.

       <b>Returns</b>
           exception mode.

   <b>virtual</b> <b>void*</b> <b>ost::Thread::getExtended</b> <b>(void)</b> <b>[protected],</b>  <b>[virtual]</b>
       Since  <b>getParent()</b> and <b>getThread()</b> only refer to an object of the <b>Thread</b> 'base' type, this virtual method
       can be replaced in a derived class with something that returns data specific to the  derived  class  that
       can still be accessed through the pointer returned by <b>getParent()</b> and <b>getThread()</b>.

       <b>Returns</b>
           pointer to derived class specific data.

   <b>cctid_t</b> <b>ost::Thread::getId</b> <b>(void)</b> <b>const</b>
       Get system thread numeric identifier.

       <b>Returns</b>
           numeric identifier of this thread.

   <b>const</b> <b>char*</b> <b>ost::Thread::getName</b> <b>(void)</b> <b>const</b> <b>[inline]</b>
       Get the name string for this thread, to use in debug messages.

       <b>Returns</b>
           debug name.

   <b>Thread*</b> <b>ost::Thread::getParent</b> <b>(void)</b> <b>[inline]</b>
       Gets the pointer to the <b>Thread</b> class which created the current thread object.

       <b>Returns</b>
           a <b>Thread</b> *, or '(Thread *)this' if no parent.

   <b>virtual</b> <b>void</b> <b>ost::Thread::initial</b> <b>(void)</b> <b>[protected],</b>  <b>[virtual]</b>
       The  initial method is called by a newly created thread when it starts execution. This method is ran with
       deferred cancellation disabled by default. The Initial method is given a separate handler so that it  can
       create  temporary  objects  on it's own stack frame, rather than having objects created on <b>run()</b> that are
       only needed by startup and yet continue to consume stack space.

       <b>See</b> <b>also</b>
           <b>run</b>

           <b>final</b>

       Reimplemented in <b>ost::UnixSession</b>, and <b>ost::TCPSession</b>.

   <b>bool</b> <b>ost::Thread::isDetached</b> <b>(void)</b> <b>const</b>
       Check if this thread is detached.

       <b>Returns</b>
           true if the thread is detached.

   <b>bool</b> <b>ost::Thread::isRunning</b> <b>(void)</b> <b>const</b>
       Verifies if the thread is still running or has already been terminated but not yet deleted.

       <b>Returns</b>
           true if the thread is still executing.

   <b>bool</b> <b>ost::Thread::isThread</b> <b>(void)</b> <b>const</b>
       Tests to see if the current execution context is the same as the specified thread object.

       <b>Returns</b>
           true if the current context is this object.

   <b>void</b> <b>ost::Thread::join</b> <b>(void)</b>
       Blocking call which unlocks when thread terminates.

   <b>virtual</b> <b>void</b> <b>ost::Thread::notify</b> <b>(Thread</b> <b>*)</b> <b>[protected],</b>  <b>[virtual]</b>
       When a thread terminates, it now sends a notification message to the parent thread which created it.  The
       actual use of this notification is left to be defined in a derived class.

       <b>Parameters</b>
           <u>-</u> the thread that has terminated.

   <b>void</b> <b>ost::Thread::resume</b> <b>(void)</b>
       Resumes execution of the selected thread.

   <b>virtual</b> <b>void</b> <b>ost::Thread::run</b> <b>(void)</b> <b>[protected],</b>  <b>[pure</b> <b>virtual]</b>
       All  threads  execute  by deriving the Run method of <b>Thread</b>. This method is called after Initial to begin
       normal operation of the thread. If the method terminates, then  the  thread  will  also  terminate  after
       notifying it's parent and calling it's Final() method.

       <b>See</b> <b>also</b>
           #Initial

   <b>void</b> <b>ost::Thread::setCancel</b> <b>(Cancel</b> <b>mode)</b> <b>[protected]</b>
       Sets  thread  cancellation mode. Threads can either be set immune to termination (cancelDisabled), can be
       set to terminate when reaching specific 'thread cancellation points' (cancelDeferred) or immediately when
       Terminate is requested (cancelImmediate).

       <b>Parameters</b>
           <u>mode</u> for cancellation of the current thread.

   <b>static</b> <b>void</b> <b>ost::Thread::setException</b> <b>(Throw</b> <b>mode)</b> <b>[static]</b>
       Set exception mode of the current thread.

       <b>Returns</b>
           exception mode.

   <b>void</b> <b>ost::Thread::setName</b> <b>(const</b> <b>char</b> <b>*</b> <b>text)</b> <b>[protected]</b>
       Set the name of the current thread. If the name is passed as NULL, then the default name is set  (usually
       object pointer).

       <b>Parameters</b>
           <u>text</u> name to use.

   <b>static</b> <b>void</b> <b>ost::Thread::setStack</b> <b>(size_t</b> <b>size</b> <b>=</b> <b>0)</b> <b>[inline],</b>  <b>[static]</b>
       Set base stack limit before manual stack sizes have effect.

       <b>Parameters</b>
           <u>size</u> stack size to set, or use 0 to clear autostack.

   <b>void</b> <b>ost::Thread::setSuspend</b> <b>(Suspend</b> <b>mode)</b> <b>[protected]</b>
       Sets  the  thread's  ability  to  be suspended from execution. The thread may either have suspend enabled
       (suspendEnable) or disabled (suspendDisable).

       <b>Parameters</b>
           <u>mode</u> for suspend.

   <b>static</b> <b>void</b> <b>ost::Thread::sleep</b> <b>(timeout_t</b> <b>msec)</b> <b>[static]</b>
       A thread-safe sleep call. On most Posix systems, 'sleep()' is implimented with SIGALRM making it unusable
       from multipe threads. Pthread libraries often define an  alternate  'sleep'  handler  such  as  usleep(),
       nanosleep(), or nap(), that is thread safe, and also offers a higher timer resolution.

       <b>Parameters</b>
           <u>msec</u> timeout in milliseconds.

       <b>Examples</b>
           <b>thread1.cpp</b>.

   <b>int</b> <b>ost::Thread::start</b> <b>(Semaphore</b> <b>*</b> <b>start</b> <b>=</b> <b>0)</b>
       When  a  new  thread is created, it does not begin immediate execution. This is because the derived class
       virtual tables are not properly loaded at the time the C++  object  is  created  within  the  constructor
       itself,  at  least  in  some  compiler/system  combinations. The thread can either be told to wait for an
       external semaphore, or it can be started directly after the constructor completes by calling the  <b>start()</b>
       method.

       <b>Returns</b>
           error code if execution fails.

       <b>Parameters</b>
           <u>start</u> optional starting semaphore to alternately use.

   <b>void</b> <b>ost::Thread::suspend</b> <b>(void)</b>
       Suspends  execution  of the selected thread. Pthreads do not normally support suspendable threads, so the
       behavior is simulated with signals. On systems such as Linux that define threads  as  processes,  SIGSTOP
       and SIGCONT may be used.

   <b>void</b> <b>ost::Thread::sync</b> <b>(void)</b> <b>[protected]</b>
       Used to wait for a join or cancel, in place of explicit exit.

   <b>void</b> <b>ost::Thread::terminate</b> <b>(void)</b> <b>[protected]</b>
       Used  by another thread to terminate the current thread. Termination actually occurs based on the current
       <b>setCancel()</b> mode. When the current thread does terminate, control is returned to the  requesting  thread.
       <b>terminate()</b>  should  always  be  called  at the start of any destructor of a class derived from <b>Thread</b> to
       assure the remaining part of the destructor is called without the thread still executing.

   <b>bool</b> <b>ost::Thread::testCancel</b> <b>(void)</b> <b>[protected]</b>
       test a cancellation point for deferred thread cancellation.

   <b>static</b> <b>void</b> <b>ost::Thread::yield</b> <b>(void)</b> <b>[static]</b>
       Yields the current thread's CPU time slice to allow another thread to begin immediate execution.

</pre><h4><b>Friends</b> <b>And</b> <b>Related</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>friend</b> <b>class</b> <b>Cancellation</b> <b>[friend]</b>
   <b>friend</b> <b>class</b> <b>DummyThread</b> <b>[friend]</b>
   <b>void</b> <b>operator++</b> <b>(Thread</b> <b>&amp;</b> <b>th)</b> <b>[friend]</b>
       Signal the semaphore that the specified thread is waiting for before beginning execution.

       <b>Parameters</b>
           <u>th</u> specified thread.

   <b>void</b> <b>operator--</b> <b>(Thread</b> <b>&amp;</b> <b>th)</b> <b>[friend]</b>
   <b>friend</b> <b>class</b> <b>PosixThread</b> <b>[friend]</b>
   <b>friend</b> <b>class</b> <b>postream_type</b> <b>[friend]</b>
   <b>friend</b> <b>class</b> <b>Slog</b> <b>[friend]</b>
   <b>friend</b> <b>class</b> <b>ThreadImpl</b> <b>[friend]</b>
</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for GNU CommonC++ from the source code.

GNU CommonC++                                    Sun Dec 27 2020                                  <u>ost::<a href="../man3/Thread.3.html">Thread</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>