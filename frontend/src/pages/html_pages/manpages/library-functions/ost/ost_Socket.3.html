<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ost::Socket - The Socket is used as the base for all Internet protocol services under Common C++.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libcommoncpp2-doc">libcommoncpp2-doc_1.8.1-10_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ost::Socket - The <b>Socket</b> is used as the base for all Internet protocol services under Common C++.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;socket.h&gt;

       Inherited by <b>ost::DCCPSocket</b>, <b>ost::SimpleTCPStream</b>, <b>ost::SocketPort</b>, <b>ost::TCPSocket</b> [protected],
       <b>ost::TCPStream</b>, <b>ost::TCPV6Socket</b> [protected], <b>ost::UDPSocket</b>, <b>ost::UnixSocket</b> [protected], and
       <b>ost::UnixStream</b>.

   <b>Public</b> <b>Types</b>
       enum <b>Family</b> { <b>IPV6</b> = AF_INET6, <b>IPV4</b> = AF_INET }
       enum <b>Error</b> { <b>errSuccess</b> = 0, <b>errCreateFailed</b>, <b>errCopyFailed</b>, <b>errInput</b>, <b>errInputInterrupt</b>,
           <b>errResourceFailure</b>, <b>errOutput</b>, <b>errOutputInterrupt</b>, <b>errNotConnected</b>, <b>errConnectRefused</b>,
           <b>errConnectRejected</b>, <b>errConnectTimeout</b>, <b>errConnectFailed</b>, <b>errConnectInvalid</b>, <b>errConnectBusy</b>,
           <b>errConnectNoRoute</b>, <b>errBindingFailed</b>, <b>errBroadcastDenied</b>, <b>errRoutingDenied</b>, <b>errKeepaliveDenied</b>,
           <b>errServiceDenied</b>, <b>errServiceUnavailable</b>, <b>errMulticastDisabled</b>, <b>errTimeout</b>, <b>errNoDelay</b>, <b>errExtended</b>,
           <b>errLookupFail</b>, <b>errSearchErr</b>, <b>errInvalidValue</b> }
       enum <b>Tos</b> { <b>tosLowDelay</b> = 0, <b>tosThroughput</b>, <b>tosReliability</b>, <b>tosMinCost</b>, <b>tosInvalid</b> }
       enum <b>Pending</b> { <b>pendingInput</b>, <b>pendingOutput</b>, <b>pendingError</b> }
       typedef enum <b>Family</b> <b>Family</b>
       typedef enum <b>Error</b> <b>Error</b>
       typedef enum <b>Tos</b> <b>Tos</b>
       typedef enum <b>Pending</b> <b>Pending</b>

   <b>Public</b> <b>Member</b> <b>Functions</b>
       virtual <b>~Socket</b> ()
           The socket base class may be 'thrown' as a result of an error, and the 'catcher' may then choose to
           destroy the object.
       <b>Socket</b> &amp; <b>operator=</b> (const <b>Socket</b> &amp;from)
           Sockets may also be duplicated by the assignment operator.
       virtual <b>IPV4Host</b> <b>getIPV4Sender</b> (<b>tpport_t</b> *port=NULL) const
           May be used to examine the origin of data waiting in the socket receive queue.
       <b>IPV4Host</b> <b>getSender</b> (<b>tpport_t</b> *port=NULL) const
       virtual <b>IPV6Host</b> <b>getIPV6Sender</b> (<b>tpport_t</b> *port=NULL) const
       <b>IPV4Host</b> <b>getIPV4Peer</b> (<b>tpport_t</b> *port=NULL) const
           Get the host address and port of the socket this socket is connected to.
       <b>IPV4Host</b> <b>getPeer</b> (<b>tpport_t</b> *port=NULL) const
       <b>IPV6Host</b> <b>getIPV6Peer</b> (<b>tpport_t</b> *port=NULL) const
       <b>IPV4Host</b> <b>getIPV4Local</b> (<b>tpport_t</b> *port=NULL) const
           Get the local address and port number this socket is currently bound to.
       <b>IPV4Host</b> <b>getLocal</b> (<b>tpport_t</b> *port=NULL) const
       <b>IPV6Host</b> <b>getIPV6Local</b> (<b>tpport_t</b> *port=NULL) const
       <b>IPV4Host</b> <b>getIPV4NAT</b> (<b>tpport_t</b> *port=NULL) const
           Perform NAT table lookup for this socket.
       <b>IPV4Host</b> <b>getNAT</b> (<b>tpport_t</b> *port) const
       <b>IPV6Host</b> <b>getIPV6NAT</b> (<b>tpport_t</b> *port=NULL) const
       void <b>setCompletion</b> (bool immediate)
           Used to specify blocking mode for the socket.
       <b>Error</b> <b>setLinger</b> (bool <b>linger</b>)
           Enable lingering sockets on close.
       <b>Error</b> <b>setKeepAlive</b> (bool enable)
           Set the keep-alive status of this socket and if keep-alive messages will be sent.
       <b>Error</b> <b>setTypeOfService</b> (<b>Tos</b> service)
           Set packet scheduling on platforms which support ip quality of service conventions.
       bool <b>isConnected</b> (void) const
           Can test to see if this socket is 'connected', and hence whether a 'catch' can safely call <b>getPeer()</b>.
       bool <b>isActive</b> (void) const
           Test to see if the socket is at least operating or if it is mearly initialized.
       bool <b>operator!</b> () const
           Operator based testing to see if a socket is currently active.
       bool <b>isBroadcast</b> (void) const
           Return if broadcast has been enabled for the specified socket.
       bool <b>isRouted</b> (void) const
           Return if socket routing is enabled.
       <b>Error</b> <b>getErrorNumber</b> (void) const
           Often used by a 'catch' to fetch the last error of a thrown socket.
       const char * <b>getErrorString</b> (void) const
           Often used by a 'catch' to fetch the user set error string of a thrown socket, but only if EXTENDED
           error codes are used.
       long <b>getSystemError</b> (void) const
       const char * <b>getSystemErrorString</b> (void) const
       virtual bool <b>isPending</b> (<b>Pending</b> pend, <b>timeout_t</b> timeout=<b>TIMEOUT_INF</b>)
           Get the status of pending operations.

   <b>Static</b> <b>Public</b> <b>Member</b> <b>Functions</b>
       static bool <b>check</b> (<b>Family</b> fam)
           See if a specific protocol family is available in the current runtime environment.

   <b>Protected</b> <b>Types</b>
       enum <b>State</b> { <b>INITIAL</b>, <b>AVAILABLE</b>, <b>BOUND</b>, <b>CONNECTED</b>, <b>CONNECTING</b>, <b>STREAM</b> }
       typedef enum <b>State</b> <b>State</b>

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       <b>Error</b> <b>error</b> (<b>Error</b> error, const char *err=NULL, long systemError=0) const
           This service is used to throw all socket errors which usually occur during the socket constructor.
       void <b>error</b> (const char *err) const
           This service is used to throw application defined socket errors where the application specific error
           code is a string.
       void <b>setError</b> (bool enable)
           This service is used to turn the error handler on or off for 'throwing' exceptions by manipulating
           the thrown flag.
       void <b>endSocket</b> (void)
           Used as the default destructor for ending a socket.
       <b>Error</b> <b>connectError</b> (void)
           Used as a common handler for connection failure processing.
       <b>Error</b> <b>sendLimit</b> (int limit=2048)
           Set the send limit.
       <b>Error</b> <b>receiveLimit</b> (int limit=1)
           Set thr receive limit.
       <b>Error</b> <b>sendTimeout</b> (<b>timeout_t</b> timer)
           Set the send timeout for sending raw network data.
       <b>Error</b> <b>receiveTimeout</b> (<b>timeout_t</b> timer)
           Receive timeout for receiving raw network data.
       <b>Error</b> <b>sendBuffer</b> (unsigned size)
           Set the protocol stack network kernel send buffer size associated with the socket.
       <b>Error</b> <b>receiveBuffer</b> (unsigned size)
           Set the protocol stack network kernel receive buffer size associated with the socket.
       <b>Error</b> <b>bufferSize</b> (unsigned size)
           Set the total protocol stack network kernel buffer size for both send and receive together.
       <b>Error</b> <b>setBroadcast</b> (bool enable)
           Set the subnet broadcast flag for the socket.
       <b>Error</b> <b>setMulticastByFamily</b> (bool enable, <b>Family</b> family=<b>IPV4</b>)
           Setting multicast binds the multicast interface used for the socket to the interface the socket
           itself has been implicitly bound to.
       <b>Error</b> <b>setLoopbackByFamily</b> (bool enable, <b>Family</b> family=<b>IPV4</b>)
           Set the multicast loopback flag for the socket.
       <b>Error</b> <b>setTimeToLiveByFamily</b> (unsigned char <b>ttl</b>, <b>Family</b> fam=<b>IPV4</b>)
           Set the multicast time to live for a multicast socket.
       <b>Error</b> <b>join</b> (const <b>IPV4Multicast</b> &amp;ia)
           Join a multicast group.
       <b>Error</b> <b>join</b> (const <b>IPV6Multicast</b> &amp;ia)
       <b>Error</b> <b>drop</b> (const <b>IPV4Multicast</b> &amp;ia)
           Drop membership from a multicast group.
       <b>Error</b> <b>drop</b> (const <b>IPV6Multicast</b> &amp;ia)
       <b>Error</b> <b>setRouting</b> (bool enable)
           Set the socket routing to indicate if outgoing messages should bypass normal routing (set false).
       <b>Error</b> <b>setNoDelay</b> (bool enable)
           Enable/disable delaying packets (Nagle algorithm)
       <b>Socket</b> (int domain, int type, int protocol=0)
           An unconnected socket may be created directly on the local machine.
       <b>Socket</b> (<b>SOCKET</b> fd)
           A socket object may be created from a file descriptor when that descriptor was created either through
           a socket() or accept() call.
       <b>Socket</b> ()
           Create an inactive socket object for base constructors.
       <b>Socket</b> (const <b>Socket</b> &amp;source)
           A socket can also be constructed from an already existing <b>Socket</b> object.
       ssize_t <b>readLine</b> (char *buf, size_t len, <b>timeout_t</b> timeout=0)
           <b>Process</b> a logical input line from a socket descriptor directly.
       virtual ssize_t <b>readData</b> (void *buf, size_t len, char separator=0, <b>timeout_t</b> t=0)
           Read in a block of len bytes with specific separator.
       virtual ssize_t <b>writeData</b> (const void *buf, size_t len, <b>timeout_t</b> t=0)
           Write a block of len bytes to socket.

   <b>Protected</b> <b>Attributes</b>
       struct {
          bool <b>thrown</b>: 1
          bool <b>broadcast</b>: 1
          bool <b>route</b>: 1
          bool <b>keepalive</b>: 1
          bool <b>loopback</b>: 1
          bool <b>multicast</b>: 1
          bool <b>completion</b>: 1
          bool <b>linger</b>: 1
          unsigned <b>ttl</b>: 8
       } <b>flags</b>
       <b>SOCKET</b> volatile <b>so</b>
           the actual socket descriptor, in Windows, unlike posix it <u>cannot</u> be used as an file descriptor that
           way madness lies -- jfc
       <b>State</b> volatile <b>state</b>

   <b>Static</b> <b>Protected</b> <b>Attributes</b>
       static <b>Mutex</b> <b>mutex</b>

   <b>Friends</b>
       <b>SOCKET</b> <b>dupSocket</b> (<b>SOCKET</b> s, <b>Socket::State</b> <b>state</b>)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       The <b>Socket</b> is used as the base for all Internet protocol services under Common C++.

       A socket is a system resource (or winsock descriptor) that occupies a specific port address (and may be
       bound to a specific network interface) on the local machine. The socket may also be directly connected to
       a specific socket on a remote internet host.

       This base class is not directly used, but is provided to offer properties common to other Common C++
       socket classes, including the socket exception model and the ability to set socket properties such as
       QoS, 'sockopts' properties like Dont-Route and Keep-Alive, etc.

       <b>Author</b>
           David Sugar <a href="mailto:dyfet@ostel.com">dyfet@ostel.com</a>

       base class of all sockets.

       <b>Examples</b>
           <b>tcpthread.cpp</b>.

</pre><h4><b>Member</b> <b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>enum</b> <b>Error</b> <b>ost::Socket::Error</b>
   <b>typedef</b> <b>enum</b> <b>Family</b> <b>ost::Socket::Family</b>
   <b>typedef</b> <b>enum</b> <b>Pending</b> <b>ost::Socket::Pending</b>
   <b>typedef</b> <b>enum</b> <b>State</b> <b>ost::Socket::State</b> <b>[protected]</b>
   <b>typedef</b> <b>enum</b> <b>Tos</b> <b>ost::Socket::Tos</b>
</pre><h4><b>Member</b> <b>Enumeration</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>ost::Socket::Error</b>
       <b>Enumerator</b>

       <u>errSuccess</u>

       <u>errCreateFailed</u>

       <u>errCopyFailed</u>

       <u>errInput</u>

       <u>errInputInterrupt</u>

       <u>errResourceFailure</u>

       <u>errOutput</u>

       <u>errOutputInterrupt</u>

       <u>errNotConnected</u>

       <u>errConnectRefused</u>

       <u>errConnectRejected</u>

       <u>errConnectTimeout</u>

       <u>errConnectFailed</u>

       <u>errConnectInvalid</u>

       <u>errConnectBusy</u>

       <u>errConnectNoRoute</u>

       <u>errBindingFailed</u>

       <u>errBroadcastDenied</u>

       <u>errRoutingDenied</u>

       <u>errKeepaliveDenied</u>

       <u>errServiceDenied</u>

       <u>errServiceUnavailable</u>

       <u>errMulticastDisabled</u>

       <u>errTimeout</u>

       <u>errNoDelay</u>

       <u>errExtended</u>

       <u>errLookupFail</u>

       <u>errSearchErr</u>

       <u>errInvalidValue</u>

   <b>enum</b> <b>ost::Socket::Family</b>
       <b>Enumerator</b>

       <u>IPV6</u>

       <u>IPV4</u>

   <b>enum</b> <b>ost::Socket::Pending</b>
       <b>Enumerator</b>

       <u>pendingInput</u>

       <u>pendingOutput</u>

       <u>pendingError</u>

   <b>enum</b> <b>ost::Socket::State</b> <b>[protected]</b>
       <b>Enumerator</b>

       <u>INITIAL</u>

       <u>AVAILABLE</u>

       <u>BOUND</u>

       <u>CONNECTED</u>

       <u>CONNECTING</u>

       <u>STREAM</u>

   <b>enum</b> <b>ost::Socket::Tos</b>
       <b>Enumerator</b>

       <u>tosLowDelay</u>

       <u>tosThroughput</u>

       <u>tosReliability</u>

       <u>tosMinCost</u>

       <u>tosInvalid</u>

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>ost::Socket::Socket</b> <b>(int</b> <b>domain,</b> <b>int</b> <b>type,</b> <b>int</b> <b>protocol</b> <b>=</b> <b>0)</b> <b>[protected]</b>
       An  unconnected socket may be created directly on the local machine. Sockets can occupy both the internet
       domain (AF_INET) and UNIX socket domain (AF_UNIX) under unix. The socket type  (SOCK_STREAM,  SOCK_DGRAM)
       and protocol may also be specified. If the socket cannot be created, an exception is thrown.

       <b>Parameters</b>
           <u>domain</u> socket domain to use.
           <u>type</u> base type and protocol family of the socket.
           <u>protocol</u> specific protocol to apply.

   <b>ost::Socket::Socket</b> <b>(SOCKET</b> <b>fd)</b> <b>[protected]</b>
       A  socket  object may be created from a file descriptor when that descriptor was created either through a
       socket() or accept() call. This constructor is mostly for internal use.

       <b>Parameters</b>
           <u>fd</u> file descriptor of an already existing socket.

   <b>ost::Socket::Socket</b> <b>()</b> <b>[protected]</b>
       Create an inactive socket object for base constructors.

   <b>ost::Socket::Socket</b> <b>(const</b> <b>Socket</b> <b>&amp;</b> <b>source)</b> <b>[protected]</b>
       A socket can also be constructed from an already existing <b>Socket</b> object. On  POSIX  systems,  the  socket
       file descriptor is dup()'d. On Win32, DuplicateHandle() is used.

       <b>Parameters</b>
           <u>source</u> of existing socket to clone.

   <b>virtual</b> <b>ost::Socket::~Socket</b> <b>()</b> <b>[virtual]</b>
       The  socket  base  class  may  be  'thrown' as a result of an error, and the 'catcher' may then choose to
       destroy the object. By assuring the socket base class is a virtual destructor, we  can  assure  the  full
       object is properly terminated.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>Error</b> <b>ost::Socket::bufferSize</b> <b>(unsigned</b> <b>size)</b> <b>[protected]</b>
       Set the total protocol stack network kernel buffer size for both send and receive together.

       <b>Returns</b>
           errSuccess on success

       <b>Parameters</b>
           <u>size</u> of buffer.

   <b>static</b> <b>bool</b> <b>ost::Socket::check</b> <b>(Family</b> <b>fam)</b> <b>[static]</b>
       See if a specific protocol family is available in the current runtime environment.

       <b>Returns</b>
           true if family available.

   <b>Error</b> <b>ost::Socket::connectError</b> <b>(void)</b> <b>[protected]</b>
       Used as a common handler for connection failure processing.

       <b>Returns</b>
           correct failure code to apply.

   <b>Error</b> <b>ost::Socket::drop</b> <b>(const</b> <b>IPV4Multicast</b> <b>&amp;</b> <b>ia)</b> <b>[protected]</b>
       Drop membership from a multicast group.

       <b>Returns</b>
           0 (errSuccess) on success, else error code.

       <b>Parameters</b>
           <u>ia</u> address of multicast group to drop.

       Referenced by ost::UDPReceive::drop().

   <b>Error</b> <b>ost::Socket::drop</b> <b>(const</b> <b>IPV6Multicast</b> <b>&amp;</b> <b>ia)</b> <b>[protected]</b>
   <b>void</b> <b>ost::Socket::endSocket</b> <b>(void)</b> <b>[protected]</b>
       Used as the default destructor for ending a socket. This will cleanly terminate the socket connection. It
       is provided for use in derived virtual destructors.

       Referenced by ost::UDPReceive::endReceiver(), and ost::UDPTransmit::endTransmitter().

   <b>void</b> <b>ost::Socket::error</b> <b>(const</b> <b>char</b> <b>*</b> <b>err)</b> <b>const</b> <b>[inline],</b>  <b>[protected]</b>
       This service is used to throw application defined socket errors where the application specific error code
       is a string.

       <b>Parameters</b>
           <u>err</u> string or message to pass.

       References ost::error().

   <b>Error</b> <b>ost::Socket::error</b> <b>(Error</b> <b>error,</b> <b>const</b> <b>char</b> <b>*</b> <b>err</b> <b>=</b> <b>NULL,</b> <b>long</b> <b>systemError</b> <b>=</b> <b>0)</b> <b>const</b> <b>[protected]</b>
       This service is used to throw all socket errors which usually occur during the socket constructor.

       <b>Parameters</b>
           <u>error</u> defined socket error id.
           <u>err</u> string or message to pass.
           <u>systemError</u> the system error# that caused the error

   <b>Error</b> <b>ost::Socket::getErrorNumber</b> <b>(void)</b> <b>const</b> <b>[inline]</b>
       Often used by a 'catch' to fetch the last error of a thrown socket.

       <b>Returns</b>
           error number of Error error.

       <b>Examples</b>
           <b>tcpthread.cpp</b>.

   <b>const</b> <b>char*</b> <b>ost::Socket::getErrorString</b> <b>(void)</b> <b>const</b> <b>[inline]</b>
       Often used by a 'catch' to fetch the user set error string of a thrown socket, but only if EXTENDED error
       codes are used.

       <b>Returns</b>
           string for error message.

   <b>IPV4Host</b> <b>ost::Socket::getIPV4Local</b> <b>(tpport_t</b> <b>*</b> <b>port</b> <b>=</b> <b>NULL)</b> <b>const</b>
       Get the local address and port number this socket is currently bound to.

       <b>Parameters</b>
           <u>port</u> ptr to port number on local host.

       <b>Returns</b>
           host address of interface this socket is bound to.

       Referenced by ost::TCPSocket::getLocal().

   <b>IPV4Host</b> <b>ost::Socket::getIPV4NAT</b> <b>(tpport_t</b> <b>*</b> <b>port</b> <b>=</b> <b>NULL)</b> <b>const</b>
       Perform  NAT table lookup for this socket. Used to allow an application to know the original ip:port pair
       the the client 'thinks'  it  is  connecting  to.  Used  mostly  to  transparently  impersonate  a  remote
       server/service.

       On  error,  0.0.0.0:0 is returned and one of the following error codes is set: errServiceUnavailable - if
       nat is not supported on the current platform or if it was  not  compiled;  errLookupFail  -  if  the  nat
       syscall  failed  for  some  reason  (extended error code); errSearchErr - if the socket does not have nat
       information (i.e. is not nated).

       NAT lookup is supported on NetFilter for ipv4 and ipv6 (Linux), IPFilter for ipv4 (Solaris,  *BSD  except
       OpenBSD,  HP-UX,  etc.)  and  Packet  Filter  for  ipv4 and ipv6 (OpenBSD). When using IPFilter or Packet
       Filter, the first NAT lookup must be performed as root (the NAT device is  read  only  for  root  and  is
       opened once, unless an error occurs). Permissions on the nat device may be changed to solve this.

       <b>Warning</b>
           When  using IPFilter and Packet Filter, application data model must be the same as the running kernel
           (32/64 bits).

       <b>Parameters</b>
           <u>port</u> ptr to NATed port number on local host.

       <b>Returns</b>
           NATed host address that this socket is related to.

   <b>IPV4Host</b> <b>ost::Socket::getIPV4Peer</b> <b>(tpport_t</b> <b>*</b> <b>port</b> <b>=</b> <b>NULL)</b> <b>const</b>
       Get the host address and port of the socket this socket is connected to. If the socket is  currently  not
       in a connected state, then a host address of 0.0.0.0 is returned.

       <b>Parameters</b>
           <u>port</u> ptr to port number of remote socket.

       <b>Returns</b>
           host address of remote socket.

   <b>virtual</b> <b>IPV4Host</b> <b>ost::Socket::getIPV4Sender</b> <b>(tpport_t</b> <b>*</b> <b>port</b> <b>=</b> <b>NULL)</b> <b>const</b> <b>[virtual]</b>
       May be used to examine the origin of data waiting in the socket receive queue. This can tell a TCP server
       where pending 'connect' requests are coming from, or a UDP socket where it's next packet arrived from.

       <b>Parameters</b>
           <u>port</u> ptr to port number of sender.

       <b>Returns</b>
           host address, test with 'isInetAddress()'.

       Reimplemented in <b>ost::DCCPSocket</b>.

       Referenced by ost::TCPSocket::getRequest().

   <b>IPV6Host</b> <b>ost::Socket::getIPV6Local</b> <b>(tpport_t</b> <b>*</b> <b>port</b> <b>=</b> <b>NULL)</b> <b>const</b>
       Referenced by ost::TCPV6Socket::getLocal().

   <b>IPV6Host</b> <b>ost::Socket::getIPV6NAT</b> <b>(tpport_t</b> <b>*</b> <b>port</b> <b>=</b> <b>NULL)</b> <b>const</b>
   <b>IPV6Host</b> <b>ost::Socket::getIPV6Peer</b> <b>(tpport_t</b> <b>*</b> <b>port</b> <b>=</b> <b>NULL)</b> <b>const</b>
   <b>virtual</b> <b>IPV6Host</b> <b>ost::Socket::getIPV6Sender</b> <b>(tpport_t</b> <b>*</b> <b>port</b> <b>=</b> <b>NULL)</b> <b>const</b> <b>[virtual]</b>
       Reimplemented in <b>ost::DCCPSocket</b>.

       Referenced by ost::TCPV6Socket::getRequest().

   <b>IPV4Host</b> <b>ost::Socket::getLocal</b> <b>(tpport_t</b> <b>*</b> <b>port</b> <b>=</b> <b>NULL)</b> <b>const</b> <b>[inline]</b>
   <b>IPV4Host</b> <b>ost::Socket::getNAT</b> <b>(tpport_t</b> <b>*</b> <b>port)</b> <b>const</b> <b>[inline]</b>
   <b>IPV4Host</b> <b>ost::Socket::getPeer</b> <b>(tpport_t</b> <b>*</b> <b>port</b> <b>=</b> <b>NULL)</b> <b>const</b> <b>[inline]</b>
       <b>Examples</b>
           <b>tcp.cpp</b>, and <b>tcpthread.cpp</b>.

   <b>IPV4Host</b> <b>ost::Socket::getSender</b> <b>(tpport_t</b> <b>*</b> <b>port</b> <b>=</b> <b>NULL)</b> <b>const</b> <b>[inline]</b>
   <b>long</b> <b>ost::Socket::getSystemError</b> <b>(void)</b> <b>const</b> <b>[inline]</b>
   <b>const</b> <b>char*</b> <b>ost::Socket::getSystemErrorString</b> <b>(void)</b> <b>const</b>
   <b>bool</b> <b>ost::Socket::isActive</b> <b>(void)</b> <b>const</b>
       Test to see if the socket is at least operating or if it is mearly initialized. 'initialized' sockets may
       be the result of failed constructors.

       <b>Returns</b>
           true if not in initial state.

   <b>bool</b> <b>ost::Socket::isBroadcast</b> <b>(void)</b> <b>const</b> <b>[inline]</b>
       Return if broadcast has been enabled for the specified socket.

       <b>Returns</b>
           true if broadcast socket.

   <b>bool</b> <b>ost::Socket::isConnected</b> <b>(void)</b> <b>const</b>
       Can  test to see if this socket is 'connected', and hence whether a 'catch' can safely call <b>getPeer()</b>. Of
       course, an unconnected socket will return a 0.0.0.0 address from <b>getPeer()</b> as well.

       <b>Returns</b>
           true when socket is connected to a peer.

   <b>virtual</b> <b>bool</b> <b>ost::Socket::isPending</b> <b>(Pending</b> <b>pend,</b> <b>timeout_t</b> <b>timeout</b> <b>=</b> <b>TIMEOUT_INF)</b> <b>[virtual]</b>
       Get the status of pending operations. This can be used to examine if input or output is waiting, or if an
       error has occured on the descriptor.

       <b>Returns</b>
           true if ready, false on timeout.

       <b>Parameters</b>
           <u>pend</u> ready check to perform.
           <u>timeout</u> in milliseconds, inf. if not specified.

       Reimplemented in <b>ost::UnixStream</b>, <b>ost::SimpleTCPStream</b>, and <b>ost::TCPStream</b>.

       Referenced         by         ost::UDPReceive::isInputReady(),         ost::UDPTransmit::isOutputReady(),
       ost::DCCPSocket::isPendingConnection(),                            ost::TCPSocket::isPendingConnection(),
       ost::TCPV6Socket::isPendingConnection(),           ost::UnixSocket::isPendingConnection(),            and
       ost::UDPReceive::isPendingReceive().

   <b>bool</b> <b>ost::Socket::isRouted</b> <b>(void)</b> <b>const</b> <b>[inline]</b>
       Return if socket routing is enabled.

       <b>Returns</b>
           true if routing enabled.

   <b>Error</b> <b>ost::Socket::join</b> <b>(const</b> <b>IPV4Multicast</b> <b>&amp;</b> <b>ia)</b> <b>[protected]</b>
       Join a multicast group.

       <b>Returns</b>
           0 (errSuccess) on success, else error code.

       <b>Parameters</b>
           <u>ia</u> address of multicast group to join.

       Referenced by ost::UDPReceive::join().

   <b>Error</b> <b>ost::Socket::join</b> <b>(const</b> <b>IPV6Multicast</b> <b>&amp;</b> <b>ia)</b> <b>[protected]</b>
   <b>bool</b> <b>ost::Socket::operator!</b> <b>()</b> <b>const</b>
       Operator based testing to see if a socket is currently active.

   <b>Socket&amp;</b> <b>ost::Socket::operator=</b> <b>(const</b> <b>Socket</b> <b>&amp;</b> <b>from)</b>
       Sockets may also be duplicated by the assignment operator.

   <b>virtual</b>  <b>ssize_t</b>  <b>ost::Socket::readData</b>  <b>(void</b>  <b>*</b>  <b>buf,</b>  <b>size_t</b>  <b>len,</b>  <b>char</b>  <b>separator</b>  <b>=</b> <b>0,</b> <b>timeout_t</b> <b>t</b> <b>=</b> <b>0)</b>
       <b>[protected],</b>  <b>[virtual]</b>
       Read in a block of len bytes with specific separator. Can be zero, or any other char. If \n or  \r,  it's
       treated just like a <b>readLine()</b>. Otherwise it looks for the separator.

       <b>Parameters</b>
           <u>buf</u> pointer to byte allocation.
           <u>len</u> maximum length to read.
           <u>separator</u> separator for a particular ASCII character
           <u>t</u> timeout for pending data in milliseconds.

       <b>Returns</b>
           number of bytes actually read.

       Reimplemented in <b>ost::SSLStream</b>.

   <b>ssize_t</b> <b>ost::Socket::readLine</b> <b>(char</b> <b>*</b> <b>buf,</b> <b>size_t</b> <b>len,</b> <b>timeout_t</b> <b>timeout</b> <b>=</b> <b>0)</b> <b>[protected]</b>
       <b>Process</b> a logical input line from a socket descriptor directly.

       <b>Parameters</b>
           <u>buf</u> pointer to string.
           <u>len</u> maximum length to read.
           <u>timeout</u> for pending data in milliseconds.

       <b>Returns</b>
           number of bytes actually read.

   <b>Error</b> <b>ost::Socket::receiveBuffer</b> <b>(unsigned</b> <b>size)</b> <b>[protected]</b>
       Set the protocol stack network kernel receive buffer size associated with the socket.

       <b>Returns</b>
           errSuccess on success, or error.

       <b>Parameters</b>
           <u>size</u> of buffer in bytes.

   <b>Error</b> <b>ost::Socket::receiveLimit</b> <b>(int</b> <b>limit</b> <b>=</b> <b>1)</b> <b>[protected]</b>
       Set thr receive limit.

   <b>Error</b> <b>ost::Socket::receiveTimeout</b> <b>(timeout_t</b> <b>timer)</b> <b>[protected]</b>
       Receive timeout for receiving raw network data.

       <b>Returns</b>
           errSuccess if set.

       <b>Parameters</b>
           <u>timer</u> value in milliseconds.

   <b>Error</b> <b>ost::Socket::sendBuffer</b> <b>(unsigned</b> <b>size)</b> <b>[protected]</b>
       Set the protocol stack network kernel send buffer size associated with the socket.

       <b>Returns</b>
           errSuccess on success, or error.

       <b>Parameters</b>
           <u>size</u> of buffer in bytes.

   <b>Error</b> <b>ost::Socket::sendLimit</b> <b>(int</b> <b>limit</b> <b>=</b> <b>2048)</b> <b>[protected]</b>
       Set the send limit.

   <b>Error</b> <b>ost::Socket::sendTimeout</b> <b>(timeout_t</b> <b>timer)</b> <b>[protected]</b>
       Set the send timeout for sending raw network data.

       <b>Returns</b>
           errSuccess if set.

       <b>Parameters</b>
           <u>timer</u> value in millisec.

   <b>Error</b> <b>ost::Socket::setBroadcast</b> <b>(bool</b> <b>enable)</b> <b>[protected]</b>
       Set  the  subnet  broadcast flag for the socket. This enables sending to a subnet and may require special
       image privileges depending on the operating system.

       <b>Returns</b>
           0 (errSuccess) on success, else error code.

       <b>Parameters</b>
           <u>enable</u> when set to true.

       Referenced by ost::UDPTransmit::setBroadcast().

   <b>void</b> <b>ost::Socket::setCompletion</b> <b>(bool</b> <b>immediate)</b>
       Used  to  specify  blocking  mode  for  the  socket.  A  socket  can  be  made  non-blocking  by  setting
       setCompletion(false)  or  set to block on all access with setCompletion(true). I do not believe this form
       of non-blocking socket I/O is supported in winsock, though it provides an alternate asynchronous  set  of
       socket services.

       <b>Parameters</b>
           <u>immediate</u> mode specify socket I/O call blocking mode.

   <b>void</b> <b>ost::Socket::setError</b> <b>(bool</b> <b>enable)</b> <b>[inline],</b>  <b>[protected]</b>
       This  service  is  used to turn the error handler on or off for 'throwing' exceptions by manipulating the
       thrown flag.

       <b>Parameters</b>
           <u>enable</u> true to enable handler.

   <b>Error</b> <b>ost::Socket::setKeepAlive</b> <b>(bool</b> <b>enable)</b>
       Set the keep-alive status of this socket and if keep-alive messages will be sent.

       <b>Returns</b>
           0 on success.

       <b>Parameters</b>
           <u>enable</u> keep alive messages.

   <b>Error</b> <b>ost::Socket::setLinger</b> <b>(bool</b> <b>linger)</b>
       Enable lingering sockets on close.

       <b>Parameters</b>
           <u>linger</u> specify linger enable.

   <b>Error</b> <b>ost::Socket::setLoopbackByFamily</b> <b>(bool</b> <b>enable,</b> <b>Family</b> <b>family</b> <b>=</b> <b>IPV4)</b> <b>[protected]</b>
       Set the multicast loopback flag for the socket. Loopback enables a socket to hear what it is sending.

       <b>Returns</b>
           0 (errSuccess) on success, else error code.

       <b>Parameters</b>
           <u>enable</u> when set to true.
           <u>family</u> of protocol.

       Referenced by ost::UDPSocket::setLoopback().

   <b>Error</b> <b>ost::Socket::setMulticastByFamily</b> <b>(bool</b> <b>enable,</b> <b>Family</b> <b>family</b> <b>=</b> <b>IPV4)</b> <b>[protected]</b>
       Setting multicast binds the multicast interface used for the socket to the interface  the  socket  itself
       has  been  implicitly  bound to. It is also used as a check flag to make sure multicast is enabled before
       multicast operations are used.

       <b>Returns</b>
           0 (errSuccess) on success, else error code.

       <b>Parameters</b>
           <u>enable</u> when set to true.
           <u>family</u> of protocol.

       Referenced      by      ost::UDPSocket::setMulticast(),       ost::UDPTransmit::setMulticast(),       and
       ost::UDPReceive::setMulticast().

   <b>Error</b> <b>ost::Socket::setNoDelay</b> <b>(bool</b> <b>enable)</b> <b>[protected]</b>
       Enable/disable delaying packets (Nagle algorithm)

       <b>Returns</b>
           0 on success.

       <b>Parameters</b>
           <u>enable</u> disable Nagle algorithm when set to true.

   <b>Error</b> <b>ost::Socket::setRouting</b> <b>(bool</b> <b>enable)</b> <b>[protected]</b>
       Set the socket routing to indicate if outgoing messages should bypass normal routing (set false).

       <b>Returns</b>
           0 on success.

       <b>Parameters</b>
           <u>enable</u> normal routing when set to true.

       Referenced by ost::UDPTransmit::setRouting(), and ost::UDPReceive::setRouting().

   <b>Error</b> <b>ost::Socket::setTimeToLiveByFamily</b> <b>(unsigned</b> <b>char</b> <b>ttl,</b> <b>Family</b> <b>fam</b> <b>=</b> <b>IPV4)</b> <b>[protected]</b>
       Set the multicast time to live for a multicast socket.

       <b>Returns</b>
           0 (errSuccess) on success, else error code.

       <b>Parameters</b>
           <u>ttl</u> time to live.
           <u>fam</u> family of protocol.

       Referenced by ost::UDPSocket::setTimeToLive(), and ost::UDPTransmit::setTimeToLive().

   <b>Error</b> <b>ost::Socket::setTypeOfService</b> <b>(Tos</b> <b>service)</b>
       Set  packet  scheduling  on  platforms  which support ip quality of service conventions. This effects how
       packets in the queue are scheduled through the interface.

       <b>Returns</b>
           0 on success, error code on failure.

       <b>Parameters</b>
           <u>service</u> type of service enumerated type.

       Referenced by ost::UDPTransmit::setTypeOfService().

   <b>virtual</b> <b>ssize_t</b> <b>ost::Socket::writeData</b> <b>(const</b>  <b>void</b>  <b>*</b>  <b>buf,</b>  <b>size_t</b>  <b>len,</b>  <b>timeout_t</b>  <b>t</b>  <b>=</b>  <b>0)</b>  <b>[protected],</b>
       <b>[virtual]</b>
       Write a block of len bytes to socket.

       <b>Parameters</b>
           <u>buf</u> pointer to byte allocation.
           <u>len</u> maximum length to write.
           <u>t</u> timeout for pending data in milliseconds.

       <b>Returns</b>
           number of bytes actually written.

</pre><h4><b>Friends</b> <b>And</b> <b>Related</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>SOCKET</b> <b>dupSocket</b> <b>(SOCKET</b> <b>s,</b> <b>Socket::State</b> <b>state)</b> <b>[friend]</b>
</pre><h4><b>Member</b> <b>Data</b> <b>Documentation</b></h4><pre>
   <b>bool</b> <b>ost::Socket::broadcast</b>
   <b>bool</b> <b>ost::Socket::completion</b>
   <b>struct</b> <b>{</b> <b>...</b> <b>}</b>  <b>ost::Socket::flags</b> <b>[protected]</b>
   <b>bool</b> <b>ost::Socket::keepalive</b>
   <b>bool</b> <b>ost::Socket::linger</b>
   <b>bool</b> <b>ost::Socket::loopback</b>
   <b>bool</b> <b>ost::Socket::multicast</b>
   <b>Mutex</b> <b>ost::Socket::mutex</b> <b>[static],</b>  <b>[protected]</b>
   <b>bool</b> <b>ost::Socket::route</b>
   <b>SOCKET</b> <b>volatile</b> <b>ost::Socket::so</b> <b>[protected]</b>
       the  actual  socket descriptor, in Windows, unlike posix it <u>cannot</u> be used as an file descriptor that way
       madness lies -- jfc

   <b>State</b> <b>volatile</b> <b>ost::Socket::state</b> <b>[protected]</b>
   <b>bool</b> <b>ost::Socket::thrown</b>
   <b>unsigned</b> <b>ost::Socket::ttl</b>
</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for GNU CommonC++ from the source code.

GNU CommonC++                                    Sun Dec 27 2020                                  <u>ost::<a href="../man3/Socket.3.html">Socket</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>