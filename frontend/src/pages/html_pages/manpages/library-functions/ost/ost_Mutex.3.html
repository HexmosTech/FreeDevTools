<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ost::Mutex - The Mutex class is used to protect a section of code so that at any given time only a single</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libcommoncpp2-doc">libcommoncpp2-doc_1.8.1-10_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ost::Mutex - The <b>Mutex</b> class is used to protect a section of code so that at any given time only a single
       thread can perform the protected operation.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;thread.h&gt;

       Inherited by <b>ost::MapTable</b>, <b>ost::MutexCounter</b>, <b>ost::RandomFile</b> [protected], <b>ost::Runlist</b>,
       <b>ost::SerialService</b> [private], <b>ost::SharedMemPager</b>, <b>ost::SocketService</b> [private], and <b>ost::ThreadQueue</b>.

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>Mutex</b> (const char *name=NULL)
           The mutex is always initialized as a recursive entity.
       virtual <b>~Mutex</b> ()
           Destroying the mutex removes any system resources associated with it.
       void <b>nameMutex</b> (const char *name)
           Enable setting of mutex name for deadlock debug.
       void <b>enterMutex</b> (void)
           Entering a <b>Mutex</b> locks the mutex for the current thread.
       void <b>enter</b> (void)
           Future abi will use enter/leave/test members.
       void <b>leave</b> (void)
           Future abi will use enter/leave/test members.
       bool <b>test</b> (void)
           Future abi will use enter/leave/test members.
       bool <b>tryEnterMutex</b> (void)
           Tries to lock the mutex for the current thread.
       void <b>leaveMutex</b> (void)
           Leaving a mutex frees that mutex for use by another thread.

   <b>Static</b> <b>Public</b> <b>Member</b> <b>Functions</b>
       static void <b>setDebug</b> (bool mode)
           Enable or disable deadlock debugging.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       The <b>Mutex</b> class is used to protect a section of code so that at any given time only a single thread can
       perform the protected operation.

       The <b>Mutex</b> can be used as a base class to protect access in a derived class. When used in this manner, the
       ENTER_CRITICAL and LEAVE_CRITICAL macros can be used to specify when code written for the derived class
       needs to be protected by the default <b>Mutex</b> of the derived class, and hence is presumed to be 'thread
       safe' from multiple instance execution. One of the most basic Common C++ synchronization object is the
       <b>Mutex</b> class. A <b>Mutex</b> only allows one thread to continue execution at a given time over a specific section
       of code. <b>Mutex</b>'s have a enter and leave method; only one thread can continue from the Enter until the
       Leave is called. The next thread waiting can then get through. <b>Mutex</b>'s are also known as 'CRITICAL
       SECTIONS' in win32-speak.

       The <b>Mutex</b> is always recursive in that if the same thread invokes the same mutex lock multiple times, it
       must release it multiple times. This allows a function to call another function which also happens to use
       the same mutex lock when called directly. This was deemed essential because a mutex might be used to
       block individual file requests in say, a database, but the same mutex might be needed to block a whole
       series of database updates that compose a 'transaction' for one thread to complete together without
       having to write alternate non-locking member functions to invoke for each part of a transaction.

       Strangely enough, the original pthread draft standard does not directly support recursive mutexes. In
       fact this is the most common 'NP' extension for most pthread implementations. Common C++ emulates
       recursive mutex behavior when the target platform does not directly support it.

       In addition to the <b>Mutex</b>, Common C++ supports a rwlock class. This implements the X/Open recommended
       'rwlock'. On systems which do not support rwlock's, the behavior is emulated with a <b>Mutex</b>; however, the
       advantage of a rwlock over a mutex is then entirely lost. There has been some suggested clever hacks for
       'emulating' the behavior of a rwlock with a pair of mutexes and a semaphore, and one of these will be
       adapted for Common C++ in the future for platforms that do not support rwlock's directly.

       <b>Author</b>
           David Sugar <a href="mailto:dyfet@ostel.com">dyfet@ostel.com</a>

       <b>Mutex</b> lock for protected access.

       <b>Examples</b>
           <b>tcpservice.cpp</b>, and <b>tcpthread.cpp</b>.

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>ost::Mutex::Mutex</b> <b>(const</b> <b>char</b> <b>*</b> <b>name</b> <b>=</b> <b>NULL)</b>
       The mutex is always initialized as a recursive entity.

       <b>Parameters</b>
           <u>name</u> of mutex for optional deadlock detection

   <b>virtual</b> <b>ost::Mutex::~Mutex</b> <b>()</b> <b>[virtual]</b>
       Destroying the mutex removes any system resources associated with it. If a mutex lock is currently in
       place, it is presumed to terminate when the <b>Mutex</b> is destroyed.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>ost::Mutex::enter</b> <b>(void)</b> <b>[inline]</b>
       Future abi will use enter/leave/test members.

   <b>void</b> <b>ost::Mutex::enterMutex</b> <b>(void)</b>
       Entering a <b>Mutex</b> locks the mutex for the current thread. This also can be done using the ENTER_CRITICAL
       macro or by using the ++ operator on a mutex.

       <b>See</b> <b>also</b>
           <b>leaveMutex</b>

       Referenced by ost::SysTime::lock(), and ost::MutexLock::MutexLock().

   <b>void</b> <b>ost::Mutex::leave</b> <b>(void)</b> <b>[inline]</b>
       Future abi will use enter/leave/test members.

   <b>void</b> <b>ost::Mutex::leaveMutex</b> <b>(void)</b>
       Leaving a mutex frees that mutex for use by another thread. If the mutex has been entered (invoked)
       multiple times (recursivily) by the same thread, then it will need to be exited the same number of
       instances before it is free for re-use. This operation can also be done using the LEAVE_CRITICAL macro or
       by the -- operator on a mutex.

       <b>See</b> <b>also</b>
           <b>enterMutex</b>

       Referenced by ost::SysTime::unlock(), and ost::MutexLock::~MutexLock().

   <b>void</b> <b>ost::Mutex::nameMutex</b> <b>(const</b> <b>char</b> <b>*</b> <b>name)</b> <b>[inline]</b>
       Enable setting of mutex name for deadlock debug.

       <b>Parameters</b>
           <u>name</u> for mutex.

   <b>static</b> <b>void</b> <b>ost::Mutex::setDebug</b> <b>(bool</b> <b>mode)</b> <b>[inline],</b>  <b>[static]</b>
       Enable or disable deadlock debugging.

       <b>Parameters</b>
           <u>mode</u> debug mode.

   <b>bool</b> <b>ost::Mutex::test</b> <b>(void)</b> <b>[inline]</b>
       Future abi will use enter/leave/test members.

       <b>Returns</b>
           true if entered.

   <b>bool</b> <b>ost::Mutex::tryEnterMutex</b> <b>(void)</b>
       Tries to lock the mutex for the current thread. Behaves like <b>enterMutex</b> , except that it doesn't block
       the calling thread if the mutex is already locked by another thread.

       <b>Returns</b>
           true if locking the mutex was succesful otherwise false

       <b>See</b> <b>also</b>
           <b>enterMutex</b>

           <b>leaveMutex</b>

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for GNU CommonC++ from the source code.

GNU CommonC++                                    Sun Dec 27 2020                                   <u>ost::<a href="../man3/Mutex.3.html">Mutex</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>