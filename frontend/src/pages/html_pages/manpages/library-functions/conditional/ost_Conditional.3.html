<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ost::Conditional - A conditional variable synchcronization object for one to one and one to many signal</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libcommoncpp2-doc">libcommoncpp2-doc_1.8.1-10_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ost::Conditional - A conditional variable synchcronization object for one to one and one to many signal
       and control events between processes.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;thread.h&gt;

       Inherited by <b>ost::Buffer</b>.

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>Conditional</b> (const char *id=NULL)
           Create an instance of a conditional.
       virtual <b>~Conditional</b> ()
           Destroy the conditional.
       void <b>signal</b> (bool broadcast)
           Signal a conditional object and a waiting threads.
       bool <b>wait</b> (<b>timeout_t</b> timer=0, bool locked=false)
           Wait to be signaled from another thread.
       void <b>enterMutex</b> (void)
           Locks the conditional's mutex for this thread.
       void <b>lock</b> (void)
           In the future we will use lock in place of enterMutex since the conditional composite is not a
           recursive mutex, and hence using enterMutex may cause confusion in expectation with the behavior of
           the <b>Mutex</b> class.
       bool <b>tryEnterMutex</b> (void)
           Tries to lock the conditional for the current thread.
       bool <b>test</b> (void)
       void <b>leaveMutex</b> (void)
           Leaving a mutex frees that mutex for use by another thread.
       void <b>unlock</b> (void)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       A conditional variable synchcronization object for one to one and one to many signal and control events
       between processes.

       <b>Conditional</b> variables may wait for and receive signals to notify when to resume or perform operations.
       Multiple waiting threads may be woken with a broadcast signal.

       <b>Warning</b>
           While this class inherits from <b>Mutex</b>, the methods of the class <b>Conditional</b> just handle the system
           conditional variable, so the user is responsible for calling enterMutex and leaveMutex so as to avoid
           race conditions. Another thing to note is that if you have several threads waiting on one condition,
           not uncommon in thread pools, each thread must take care to manually unlock the mutex if cancellation
           occurs. Otherwise the first thread cancelled will deadlock the rest of the thread.

       <b>Author</b>
           David Sugar

       conditional.

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>ost::Conditional::Conditional</b> <b>(const</b> <b>char</b> <b>*</b> <b>id</b> <b>=</b> <b>NULL)</b>
       Create an instance of a conditional.

       <b>Parameters</b>
           <u>id</u> name of conditional, optional for deadlock testing.

   <b>virtual</b> <b>ost::Conditional::~Conditional</b> <b>()</b> <b>[virtual]</b>
       Destroy the conditional.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>ost::Conditional::enterMutex</b> <b>(void)</b>
       Locks the conditional's mutex for this thread. Remember that <b>Conditional</b>'s mutex is NOT a recursive
       mutex!

       <b>See</b> <b>also</b>
           <b>leaveMutex</b>

   <b>void</b> <b>ost::Conditional::leaveMutex</b> <b>(void)</b>
       Leaving a mutex frees that mutex for use by another thread.

       <b>See</b> <b>also</b>
           <b>enterMutex</b>

   <b>void</b> <b>ost::Conditional::lock</b> <b>(void)</b> <b>[inline]</b>
       In the future we will use lock in place of enterMutex since the conditional composite is not a recursive
       mutex, and hence using enterMutex may cause confusion in expectation with the behavior of the <b>Mutex</b>
       class.

       <b>See</b> <b>also</b>
           <b>enterMutex</b>

   <b>void</b> <b>ost::Conditional::signal</b> <b>(bool</b> <b>broadcast)</b>
       Signal a conditional object and a waiting threads.

       <b>Parameters</b>
           <u>broadcast</u> this signal to all waiting threads if true.

   <b>bool</b> <b>ost::Conditional::test</b> <b>(void)</b> <b>[inline]</b>
   <b>bool</b> <b>ost::Conditional::tryEnterMutex</b> <b>(void)</b>
       Tries to lock the conditional for the current thread. Behaves like <b>enterMutex</b> , except that it doesn't
       block the calling thread.

       <b>Returns</b>
           true if locking the mutex was succesful otherwise false

       <b>See</b> <b>also</b>
           <b>enterMutex</b>

           <b>leaveMutex</b>

   <b>void</b> <b>ost::Conditional::unlock</b> <b>(void)</b> <b>[inline]</b>
   <b>bool</b> <b>ost::Conditional::wait</b> <b>(timeout_t</b> <b>timer</b> <b>=</b> <b>0,</b> <b>bool</b> <b>locked</b> <b>=</b> <b>false)</b>
       Wait to be signaled from another thread.

       <b>Parameters</b>
           <u>timer</u> time period to wait.
           <u>locked</u> flag if already locked the mutex.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for GNU CommonC++ from the source code.

GNU CommonC++                                    Sun Dec 27 2020                             <u>ost::<a href="../man3/Conditional.3.html">Conditional</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>