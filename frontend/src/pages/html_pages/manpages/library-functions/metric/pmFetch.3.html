<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pmFetch, pmFetchHighRes, pmHighResFetch - get performance metric values</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpcp3-dev">libpcp3-dev_6.3.8-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>pmFetch</b>, <b>pmFetchHighRes</b>, <b>pmHighResFetch</b> - get performance metric values

</pre><h4><b>C</b> <b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;pcp/pmapi.h&gt;</b>

       <b>int</b> <b>pmFetch(int</b> <u>numpmid</u><b>,</b> <b>pmID</b> <b>*</b><u>pmidlist</u><b>,</b> <b>pmResult</b> <b>**</b><u>result</u><b>);</b>
       <b>int</b> <b>pmFetchHighRes(int</b> <u>numpmid</u><b>,</b> <b>pmID</b> <b>*</b><u>pmidlist</u><b>,</b> <b>pmHighResResult</b> <b>**</b><u>result</u><b>);</b>

       <b>cc</b> <b>...</b> <b>-lpcp</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Given  a  list  of  Performance  Metric  Identifiers (PMID)s, e.g. as constructed by <b><a href="../man3/pmLookupName.3.html">pmLookupName</a></b>(3), via
       <u>pmidlist</u> and <u>numpmid</u>, fetch the values for these performance metrics.

       A call to either <b>pmFetch</b> or <b>pmFetchHighRes</b> is executed in the context of a source  of  metrics,  instance
       profile  and  collection  time,  previously  established  by calls to the appropriate context and profile
       functions,  namely  some   of   <b><a href="../man3/pmNewContext.3.html">pmNewContext</a></b>(3),   <b><a href="../man3/pmDupContext.3.html">pmDupContext</a></b>(3),   <b><a href="../man3/pmUseContext.3.html">pmUseContext</a></b>(3),   <b><a href="../man3/pmAddProfile.3.html">pmAddProfile</a></b>(3),
       <b><a href="../man3/pmDelProfile.3.html">pmDelProfile</a></b>(3) and <b><a href="../man3/pmSetMode.3.html">pmSetMode</a></b>(3).

       The  principal  result  from  <b>pmFetch</b>  is  returned in the argument <u>result</u> as a tree, using the following
       component data structures;

            typedef struct {
                  unsigned int vtype : 8;        /* value type (same as pmDesc.type) */
                  unsigned int vlen : 24;        /* bytes for vtype/vlen + vbuf */
                  char         vbuf[1];          /* one or more values */
            } pmValueBlock;

            typedef struct {
                  int      inst;                 /* instance identifier */
                  union {
                        pmValueBlock *pval;      /* pointer to value-block */
                        int          lval;       /* integer value insitu */
                  } value;
            } pmValue;

            typedef struct {
                  pmID      pmid;                /* metric identifier */
                  int       numval;              /* number of values or error code */
                  int       valfmt;              /* value style, insitu or ptr */
                  pmValue   vlist[1];            /* set of instances/values */
            } pmValueSet;

            /* Result returned by pmFetch() */
            typedef struct {
                  struct timeval timestamp;      /* time stamped by collector */
                  int            numpmid;        /* number of PMIDs */
                  pmValueSet     *vset[1];       /* set of value sets */
            } pmResult;

       The principal result from <b>pmFetchHighRes</b> is exactly the same in terms of value  sets,  however  a  higher
       resolution  timestamp  (nanosecond  instead of microsecond precision) is available in the <u>pmHighResResult</u>
       structure.

            /* Result returned by pmFetchHighRes() */
            typedef struct {
                  struct timespec timestamp;      /* time stamped by collector */
                  int             numpmid;        /* number of PMIDs */
                  pmValueSet      *vset[1];       /* set of value sets */
            } pmHighResResult;

       To accommodate metrics with multiple value instances, the <u>numval</u> field  indicates  how  many  values  are
       returned  for  each requested PMID.  The field <u>valfmt</u> in the <u>pmValueSet</u> structure indicates if the values
       for this metric are stored <u>insitu</u> in the <u>lval</u> field, i.e. a 32-bit integer quantity (either int, unsigned
       int, long or unsigned long) or if the  values  are  held  in  associated  <u>pmValueBlock</u>  structures.   The
       <u>pmValueBlock</u>  structure  is always used for floating point values (float or double) and also accommodates
       arbitrary sized binary data such as `string-valued' metrics and metrics with aggregated or  complex  data
       types.  The maximum length of a <u>pmValueBlock</u> buffer is <b>PM_VAL_VLEN_MAX</b> bytes.  If the <u>pmValueBlock</u> format
       is used, the <u>vtype</u> field indicates the data type of the value.  This field has the same interpretation as
       the <u>type</u> field in the <b>pmDesc</b> structure, see <b><a href="../man3/pmLookupDesc.3.html">pmLookupDesc</a></b>(3).

       Note  that  the  insitu  value may be a signed or unsigned 32 bit integer, signed or unsigned 32 bit long
       value (on 32 bit platforms), In the special cases described below, it may also be a 32 bit floating point
       value.  If the application needs to know the type of an insitu value, which is almost always the case, it
       is necessary to fetch the descriptor for the metric and interpret the <b>type</b> field, as described in  detail
       in  <b><a href="../man3/pmLookupDesc.3.html">pmLookupDesc</a></b>(3).   When the <u>pmResult</u> is received from a PCP1.x <b>pmcd</b>, insitu values may also be 32 bit
       floating point values (of type <b>PM_TYPE_FLOAT</b>).  In all cases, it is good practice to use  <b><a href="../man3/pmLookupDesc.3.html">pmLookupDesc</a></b>(3)
       to fetch the descriptor for the metric and interpret the <b>type</b> field therein.  Note also that the <b><a href="../man3/PMAPI.3.html">PMAPI</a></b>(3)
       will automatically translate from the PCP2.0 format to the PCP1.x format when a PCP1.x client requests 32
       bit  floating  point  values  from a PCP2.0 <b>pmcd</b>, but the reverse translation does not occur (because the
       PCP2.0 <b>pmcd</b> cannot automatically distinguish between arbitrary 32 bit floating point values  and  32  bit
       integers).

       If one value (i.e. associated with a particular instance) for a requested metric is `unavailable' (at the
       requested  time), then there is no associated <u>pmValue</u> structure in the <u>result</u>.  If there are no available
       values for a metric, then <u>numval</u> will be zero and the associated <u>pmValue[]</u> instance will be empty (<u>valfmt</u>
       is undefined in these circumstances, however <u>pmid</u> will be correctly set to the PMID of the metric with no
       values).

       As an extension of this protocol, if the Performance Metrics Collection System (PMCS) is able to  provide
       a reason why no values are available for a particular metric, this is encoded as a standard error code in
       the  corresponding  <u>numval</u>.   Since  the  error codes are all negative, values for a requested metric are
       `unavailable' if <u>numval</u> is  less  than,  or  equal  to,  zero.   A  performance  metric's  value  may  be
       `unavailable'  for  a  number  of  reasons; the following list is illustrative but not exhaustive: of the
       software for the associated Performance Metric Domain

       +      Collection is not currently activated in the software for the associated Performance Metric Domain

       +      The associated PMID is not known

       +      The current system configuration does not include the associated  hardware  component  and/or  the
              associated software module, e.g. a disk is not installed, or off-line, or Oracle is not installed

       +      The  metric  is  one for which an instance profile is required, and none was provided (there are a
              small number of metrics in this category, typically ones with  very  large,  and/or  very  dynamic
              instance domains, and/or expensive metric instantiation methods).

       +      If the current context involves fetching metrics from an archive, values may be unavailable in the
              region  around a <u>&lt;mark&gt;</u> record (see <b><a href="../man1/pmlogextract.1.html">pmlogextract</a></b>(1)) that indicate a temporal discontinuity in the
              time-series of metric values.

       In general, we may not be able to differentiate between the various cases, and if differentiation is  not
       possible, <u>numval</u> will simply be zero.

       The  argument definition and the result specifications have been constructed to ensure that for each PMID
       in the requested <u>pmidlist</u> there is exactly one <u>pmValueSet</u> in the <u>result</u>, and further the PMIDs appear  in
       exactly  the  same  sequence  in both <u>pmidlist</u> and <u>result</u>.  This makes the number and order of entries in
       <u>result</u> completely deterministic, and greatly simplifies the application programming logic after the  call
       to <b>pmFetchHighRes</b> or <b>pmFetch</b>.

       The  <u>result</u> structure returned by <b>pmFetch</b> is dynamically allocated using a combination of <b><a href="../man3/malloc.3.html">malloc</a></b>(3) calls
       and specialized allocation strategies, and  should  be  released  when  no  longer  required  by  calling
       <b><a href="../man3/pmFreeResult.3.html">pmFreeResult</a></b>(3) - under no circumstances should <b><a href="../man3/free.3.html">free</a></b>(3) be called directly to release this space.

       As  common error conditions are encoded in the <u>result</u> data structure, we'd expect only cataclysmic events
       to cause an error value to be returned.  One example would be if the metrics source context was a  remote
       host,  and  that  host  or the PMCS on that host became unreachable.  Otherwise the value returned by the
       <b>pmFetch</b> function will be non-negative.

       Similarly, the <u>result</u> structure returned by <b>pmFetchHighRes</b> operates under the same principles, and should
       be released via <b><a href="../man3/pmFreeHighResResult.3.html">pmFreeHighResResult</a></b>(3).

       If the current context involves fetching metrics from a Performance Metrics Collector Daemon (PMCD), then
       the return value may be used to encode out-of-band changes in the state of the PMCD  and  the  associated
       Performance Metrics Daemon Agents (PMDAs), as a bit-wise ``or'' of the following values:

       <b>PMCD_RESTART_AGENT</b>  An attempt has been made to restart at least one failed PMDA.

       <b>PMCD_ADD_AGENT</b>      At least one PMDA has been started.

       <b>PMCD_DROP_AGENT</b>     PMCD has noticed the termination of at least one PMDA.

       <b>PMCD_AGENT_CHANGE</b>   A convenience macro for any of the three PMDA changes.

       <b>PMCD_LABEL_CHANGE</b>   PMCD  has  been  informed  of changes to global (context) labels, or new metrics have
                           appeared which have associated labels.

       <b>PMCD_NAMES_CHANGE</b>   PMCD has been informed that the namespace has been modified, such  that  new  metrics
                           have appeared or existing metrics have been removed.

       <b>PMCD_HOSTNAME_CHANGE</b>
                           The  hostname  on the host where PMCD is running has changed.  This may be the result
                           of changes from temporary to  permanent  hostname  after  a  system  reboot  or  some
                           subsequent explicit change to the system's hostname.

       The  default  is  to return zero to indicate no change in state, however the <u>pmResult</u> returned by <b>pmFetch</b>
       (or <u>pmHighResResult</u> returned by <b>pmFetchHighRes</b>) has the same interpretation  independent  of  the  return
       value being zero or greater than zero.

       <b>pmHighResFetch</b>   is   a  previous  name  for  <b>pmFetchHighRes</b>  that  has  been  maintained  for  backwards
       compatibility.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/pmcd.1.html">pmcd</a></b>(1),    <b><a href="../man3/pmAddProfile.3.html">pmAddProfile</a></b>(3),    <b><a href="../man3/PMAPI.3.html">PMAPI</a></b>(3),    <b><a href="../man3/pmDelProfile.3.html">pmDelProfile</a></b>(3),     <b><a href="../man3/pmDupContext.3.html">pmDupContext</a></b>(3),     <b><a href="../man3/pmExtractValue.3.html">pmExtractValue</a></b>(3),
       <b><a href="../man3/pmFetchArchive.3.html">pmFetchArchive</a></b>(3),     <b><a href="../man3/pmFreeHighResResult.3.html">pmFreeHighResResult</a></b>(3),     <b><a href="../man3/pmFreeResult.3.html">pmFreeResult</a></b>(3),    <b><a href="../man3/pmGetInDom.3.html">pmGetInDom</a></b>(3),    <b><a href="../man3/pmLookupDesc.3.html">pmLookupDesc</a></b>(3),
       <b><a href="../man3/pmLookupLabels.3.html">pmLookupLabels</a></b>(3), <b><a href="../man3/pmLookupName.3.html">pmLookupName</a></b>(3), <b><a href="../man3/pmNewContext.3.html">pmNewContext</a></b>(3), <b><a href="../man3/pmSetMode.3.html">pmSetMode</a></b>(3), <b><a href="../man3/pmUseContext.3.html">pmUseContext</a></b>(3) and <b><a href="../man3/pmWhichContext.3.html">pmWhichContext</a></b>(3).

       Note that <b>pmFetch</b> and <b>pmFetchHighRes</b> are the most primitive methods of fetching metric  values  from  the
       PMCS.  See the <b><a href="../man3/pmFetchGroup.3.html">pmFetchGroup</a></b>(3) API for a higher level method that insulates the user from the intricacies
       of  looking  up metric names and metadata, setting up instance profiles, <u>pmResult</u> traversal, conversions,
       and scaling.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       As mentioned above, <b>pmFetch</b> and <b>pmFetchHighRes</b> return error codes <u>insitu</u> in the argument <u>result</u>.   If  no
       result  is  returned,  e.g.  due  to  IPC  failure  using the current PMAPI context, or end of file on an
       archive, then these routines will return a negative error code which may be examined using <b><a href="../man3/pmErrStr.3.html">pmErrStr</a></b>(3).

       <b>PM_ERR_EOL</b>
              When fetching records from an archive, <b>pmFetch</b> returns this error code to indicate the end of  the
              archive  has  been  passed  (or  the  start  of  the  archive has been passed, if the direction of
              traversal is backwards in time).  If the ``mode'' for the current PMAPI context (see <b><a href="../man3/pmSetMode.3.html">pmSetMode</a></b>(3))
              is <b>PM_MODE_INTERP</b> then the time origin is advanced, even when this error  code  is  returned.   In
              this  way  applications  that  position  the  time outside the range defined by the records in the
              archive, and then commence to <b>pmFetch</b> will eventually see valid results once the time origin moves
              inside the temporal span of the archive.

       <b>-EAGAIN</b>
              If the current context involves fetching metrics  from  <b>pmcd</b>,  then  a  return  value  of  <b>-EAGAIN</b>
              indicates the caller has created too many contexts.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       Many  of  the performance metrics exported from PCP agents have the semantics of <u>counter</u> meaning they are
       expected to be monotonically increasing.  Under some circumstances, one value of  these  metrics  may  be
       smaller than the previously fetched value.  This can happen when a counter of finite precision overflows,
       or  when  the  PCP agent has been reset or restarted, or when the PCP agent is exporting values from some
       underlying instrumentation that is subject to some asynchronous discontinuity.
       The environment variable <b>PCP_COUNTER_WRAP</b> may be set to indicate that all  such  cases  of  a  decreasing
       ``counter''  should  be  treated  as a counter overflow, and hence the values are assumed to have wrapped
       once in the interval between consecutive samples.  This ``wrapping'' behavior was the default in  earlier
       PCP versions, but by default has been disabled in PCP version 1.3 and later.

Performance Co-Pilot                                   PCP                                            <u><a href="../man3/PMFETCH.3.html">PMFETCH</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>