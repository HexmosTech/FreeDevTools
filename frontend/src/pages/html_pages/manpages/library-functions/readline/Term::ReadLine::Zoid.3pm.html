<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Term::ReadLine::Zoid - another ReadLine package</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libterm-readline-zoid-perl">libterm-readline-zoid-perl_0.07-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Term::ReadLine::Zoid - another ReadLine package

</pre><h4><b>SYNOPSIS</b></h4><pre>
               # In your app:
               use Term::ReadLine;
               my $term = Term::ReadLine-&gt;new("my app");

               my $prompt = "eval: ";
               my $OUT = $term-&gt;OUT || \*STDOUT;
               while ( defined ($_ = $term-&gt;readline($prompt)) ) {
                       # Think while (&lt;STDIN&gt;) {}
                       my $res = eval($_);
                       warn $@ if $@;
                       print $OUT $res, "\n" unless $@;
               }

               # In some rc file
               export PERL_RL=Zoid

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This package provides a set of modules that form an interactive input buffer written in plain perl with
       minimal dependencies. It features almost all key-bindings described in the posix spec for the <b><a href="../man1/sh.1.html">sh</a></b>(1)
       utility with some extensions like multiline editing; this includes a vi-command mode with a save-buffer
       (for copy-pasting) and an undo-stack.

       Historically this code was part of the Zoidberg shell, but this implementation is complete independent
       from zoid and uses the  Term::ReadLine interface, so it can be used with other perl programs.

       ( The documentation sometimes referes to 'the application', this is the program using the ReadLine module
       for input. )

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       The Term::ReadLine interface module uses the "PERL_RL" variable to decide which module to load; so if you
       want to use this module for all your perl applications, try something like:

               export PERL_RL=Zoid

</pre><h4><b>KEY</b> <b>MAPPING</b></h4><pre>
       The function name is given between parenthesis, these can be used for privat key maps.

   <b>Default</b> <b>keymap</b>
       The default key mapping is as follows:

       escape, ^[  (<u>switch_mode_command</u>)
           Place the line editor in command mode, see Term::ReadLine::Zoid::ViCommand.

       ^C  (<u>return_empty_string</u>)
           End editing and return an empty string.

       ^D  (<u>delete_char_or_eof</u>)
           For  a  single  line  buffer ends editing and returns "undef" if the line is empty, else it deletes a
           char.  For a multiline buffer, ends editing and returns the lines to the application if the cursor is
           on the last line and this line is empty, else it deletes a char.

           Note that the <u>delete_char_or_eof</u> function does what <u>delete_char</u> should do to be compatible  with  GNU
           readline lib.

       delete  (<u>delete_char</u>)
       backspace, ^H, ^?  (<u>backward_delete_char</u>)
           Delete and backspace kill the current or previous character.  The key '^?' is by default considered a
           backspace  because  most modern keyboards use this key for the "backspace" key and an escape sequence
           for the "delete" key.  Of course '^H' is also considered a backspace.

       tab, ^I  (<u>complete</u>)
           Try to complete the bigword on left of the cursor.

           There is no default completion included in this package, so unless you define a custom  expansion  it
           doesn't do anything. See the "completion_function" option.

           Uses  the  PAGER  environment variable to find a suitable pager when there are more completions to be
           shown then would fit on the screen.

           See also the "autolist" and "maxcomplete" options.

       return, ^J  (<u>accept_line</u>)
           End editing and return the edit line to the application unless the newline is escaped.

           If _all_ lines in the buffer end with a single  '\',  the  newline  is  considered  escaped  you  can
           continue  typing  on  the  next  line. This behaviour can be a bit unexpected because this module has
           multiline support which historic readline implementations have not, historically the  escaping  of  a
           newline  is  done  by  the  application not by the library.  The suppress this behaviour, and let the
           application do it's thing, disable the "automultiline" option.

           To enter the real multiline editing mode, press 'escape m', see Term::ReadLine::Zoid::MultiLine.

       ^O  (<u>operate_and_get_next</u>)
           Return the current buffer to the application but remember where we are in history.  This can be  used
           to quickly (re-)execute series of commands from history.

       ^K  (<u>kill_line</u>)
           Delete from cursor to the end of the line.

       ^L  (<u>clear_screen</u>)
           Clear  entire screen. In contrast with other readline libraries, the prompt will remain at the bottom
           of the screen.

       ^R  (<u>switch_mode_isearch</u>)
           Enter incremental search mode, see Term::ReadLine::Zoid::ISearch.

       ^U  (<u>unix_line_discard</u>)
           This is also known as the "kill" char. It deletes all characters on the edit line and  puts  them  in
           the save buffer. You can paste them back in later with 'escape-p'.

       ^V  (<u>quoted_insert</u>)
           Insert next key literally, ignoring any key-bindings.

           WARNING: control or escape chars in the editline can cause unexpected results

       ^W  (<u>unix_word_rubout</u>)
           Delete the word before the cursor.

       insert  (<u>overwrite_mode</u>)
           Toggle replace bit.

       home, ^A  (<u>beginning_of_line</u>)
           Move cursor to the begin of the edit line.

       end, ^E  (<u>end_of_line</u>)
           Move cursor to the end of the edit line.

       left, ^B  (<u>backward_char</u>)
       right, ^F  (<u>forward_char</u>)
           These keys can be used to move the cursor in the edit line.

       up, page_up, ^P  (<u>previous_history</u>)
       down, page_down, ^N  (<u>next_history</u>)
           These keys are used to rotate the history.

   <b>Multi-line</b> <b>keymap</b>
       The following keys are different in mutline mode, the others fall back to the default behaviour.

       return (<u>insert_line</u>)
           Insert a newline at the current cursor position.

       up (<u>backward_line</u>)
           Move the cursor one line up.

       down (<u>forward_line</u>)
           Move the cursor one line down.

       page_up (<u>page_up</u>)
           Move the cursor one screen down, or to the bottom of the buffer.

       page_down (<u>page_down</u>)
           Move the cursor one screen up, or to the top of the buffer.

   <b>Unmapped</b> <b>functions</b>
       <u>return_eof</u>
           End editing and return "undef".

       <u>return_eof_maybe</u>
           End editing and return "undef" if the buffer is completely empty.

       <u>possible_completions</u>
           Like <u>complete</u> but only shows the completions without actually doing them.

       <u>redraw_current_line</u>
           Redraw  the current line. This is done all the time automatically so you'll almost never need to call
           this one explicitly.

</pre><h4><b>ATTRIBS</b></h4><pre>
       The hash with options can be accessed with the "Attribs" method.  These can be modified from the  rc-file
       (see  "FILES")  or  can  be  set  from  the  "PERL_RL"  environment  variable. For example to disable the
       "autolist" feature you can set "PERL_RL='Zoid autolist=0'" before you start the application.

       (  Also  they  can  be  altered  interactively  using  the  mini-buffer  of   the   command   mode,   see
       Term::ReadLine::Zoid::ViCommand. )

       autohistory
           If enabled lines are added to the history automatically, subject to "MinLine". By default enabled.

       autoenv
           If enabled the environment variables "COLUMNS" and "LINES" are kept up to date. By default enabled.

       autolist
           If  set  completions  are listed directly when a completion fails, if not set you need to press "tab"
           twice to see a list of possible completions.  By default enabled.

       automultiline
           See "return" for a description. By default enabled.

       beat
           This option can contain a CODE reference.  It is called on the heartbeat event.

       bell
           This option can contain a CODE reference.  The default is "print "\cG"",  which  makes  the  terminal
           ring a bell.

       comment_begin
           This  option can be set to a string, if the edit line starts with this string the line is regarded to
           be a comment and is not  returned  to  the  application,  but  it  will  appear  in  the  history  if
           'autohistory' is also set. Defaults to "#".

           When  there  are  multiple lines in the buffer they all need to start with the comment string for the
           buffer to be regarded as a comment.

       completion_function
           This option can contain either a code ref or the name  of  a  function  to  perform  completion.  For
           compatibility  with  Term::ReadLine::Perl the global scalar $readline::rl_completion_function will be
           checked if this option isn't defined.

           The function will get the following arguments: $word, $buffer,  $start.   Where  $word  is  the  word
           before  the  cursor,  while $buffer is the complete text on the command line; $start is the offset of
           $word in $buffer.

           The function should return a list of possible completions of $word.  The completion list  is  checked
           for double entries.

           There is <b>no</b> default.

           FIXME tell about the meta fields for advanced completion

       default_mode
           Specifies  the  mode the buffer starts in when you do a "readline()", also other modes return to this
           mode if you exit them.  The default is 'insert' which is the single-line insert mode.  If you  always
           want to edit in multiline mode set this option to 'multiline'.

       maxcomplete
           Maximum  number  of completions to be displayed, when the number of completions is bigger the user is
           asked before displaying them. If set to zero completions are always displayed.

           If this option is set to the string 'pager' the user is asked when the number of  completions  is  to
           big to fit on screen and a pager would be used.

       minline
           This  option  controls  which  lines  are included in the history, lines shorter then this number are
           ignored. When set to "0" all lines are included in the history, when set to  "undef"  all  lines  are
           ignored.  Defaults to "0".

       PS2 This option can contain the prompt to be used for extra buffer lines.  It defaults to "&gt; ".

           Although  the  "PS1"  prompt  (as  specified  as  an argument to the "readline()" method) can contain
           newlines, the PS2 prompt can't.

       RPS1
           This option can contain a string that will be shown on the right side of the screen.  This  is  known
           as the "right prompt" and the idea is stolen from <b><a href="../man1/zsh.1.html">zsh</a></b>(1).

       title
           Used to set the terminal title, defaults to the appname.

       low_latency
           Changes  the  escape  sequences are read from input.  If true delays evalution of the escape key till
           the next char is known.  By default disabled.

</pre><h4><b>FILES</b></h4><pre>
       This module reads a rc-file on initialisation, either <u>$HOME/.perl_rl_zoid_rc</u>, <u>$HOME/.zoid/perl_rl_zoid_rc</u>
       or <u>/etc/perl_rl_zoid_rc</u>.  The rc-file is a perl script with access  to  the  Term::ReadLine::Zoid  object
       through  the method "current()".  If you want to have different behaviour for different applications, try
       to check for "$rl-&gt;{appname}".

               # in for example <a href="file:~/.perl_rl_zoid_rc">~/.perl_rl_zoid_rc</a>
               my $rl = Term::ReadLine::Zoid-&gt;current();

               # set low latency
               $rl-&gt;Attribs()-&gt;{low_latency} = 1;

               # alias control-space to escape
               $rl-&gt;bindchr( <a href="../man0/chr.0.html">chr</a>(0), 'escape' );

               # create an ad hoc macro
               $rl-&gt;bindkey('^P', sub { $rl-&gt;press('mplayer -vo sdl ') } );

</pre><h4><b>METHODS</b></h4><pre>
   <b>ReadLine</b> <b>api</b>
       Functions specified by the Term::ReadLine documentation.

       "new($appname, $IN, $OUT)"
           Simple constructor. Arguments are the application name (used for default prompt and title string) and
           optional filehandles for input and output.

       "ReadLine()"
           Returns the name of the current ReadLine module actually used.

       "readline($prompt, $preput)"
           Returns a string entered by the user.  The final newline is stripped, though the string might contain
           newlines elsewhere.

           The prompt only supports the escape "!" for the history number of the current line, use  "!!"  for  a
           literal  "!".  All other escapes you need to parse yourself, before supplying the prompt.  The prompt
           defaults to "$appname !&gt; ".

           If you want to do more with your prompt see Env::PS1.

           $preput can be used to set some text on the edit line already.

       "addhistory($line)"
       "AddHistory($line)"
           Add a command to the history (subject to the "minline" option).

           If "autohistory" is set this method will be called automatically by "readline".

       "IN()"
           Returns the filehandle used for input.

       "OUT()"
           Returns the filehandle used for output.

       "MinLine($value)"
           Sets "minline" option to $value and returns old value.

       "findConsole()"
           TODO - what uses does this have ?

       "Attribs()"
           Returns a reference to the options hash.

       "Features()"
           Returns a reference to a hash with names of implemented features.

           Be  aware  that  the  naming  scheme  is  quite  arbitrary,  this  module  uses  the  same  names  as
           Term::ReadLine::Gnu for common features.

   <b>Extended</b> <b>api</b>
       "SetHistory(@hist)"
       "GetHistory()"
           Simple  acces to the history arry, the "set" function supports both a list and a reference, the "get"
           function uses "wantarray".  Not sure which behaviour is compatible with T:RL::Gnu.

       "TermSize()"
           Returns number of columns and lines on the terminal.

       "continue()"
           This method can be called to continue the previous "readline()" call.  Can be used to build a  custom
           auto-mulitline feature.

       "current()"
           Returns the current T:RL::Zoid object, for use in rc files, see "FILES".

       "bindkey($key, $sub, $map)"
           Bind  a  CODE reference to a key, the function gets called when the key is typed with the key name as
           an argument. The $map argument is optional and can  be  either  "default",  "command",  "isearch"  or
           "multiline".

           If $sub is not a reference it is considered an alias; these aliases are not recursive.

           For  alphanumeric  characters the name is the character itself, special characters have long speaking
           names and control characters are prefixed with a '^'.

           Binding combination with the meta- or alt-key is not supported (see "NOTES").

   <b>Private</b> <b>api</b>
       Methods for use in overload classes.

       <u>Avoid</u> <u>using</u> <u>these</u> <u>methods</u> <u>from</u> <u>the</u> <u>application.</u>

       "switch_mode($mode)"
           Switch to input mode $mode; changes the key map and reblesses the  object  if  the  "_on_switch"  key
           returns a class name.

       "reset()"
           Reset all temporary attributes.

       "save()"
           Returns  a ref with a copy of some temporary attributes.  Can be used to switch between multiple edit
           lines in combination with "restore".

       "restore($save)"
           Restores saved attributes.

       "set_history($int)"
           Sets history entry $int in the buffer.

       "longest_match(@completion)"
           Returns the longest match among  the  completions  followed  by  the  completions  itself.  Used  for
           completion functions.

</pre><h4><b>DEVELOPMENT</b></h4><pre>
       FIXME minimum subroutines new mode-class

       FIXME how to set up a keymap

       FIXME how to add a keymap/mode

</pre><h4><b>NOTES</b></h4><pre>
       With  most  modern  keymappings  the combination of the meta key (alt) with a letter is identical with an
       escape character followed by that letter.

       Some functioality may in time be moved to the ::Base package.

</pre><h4><b>TODO</b></h4><pre>
       UTF8 support, or general charset support, would be nice but at the moment I lack the means to test  these
       things. If anyone has ideas or suggestions about this please contact me.

</pre><h4><b>BUGS</b></h4><pre>
       Line wrap doesn't always displays the last character on the line right, no functional bug though.

       If the buffer size exceeds the screen size some bugs appear in the rendering.

       Please mail the author if you find any other bugs.

</pre><h4><b>AUTHOR</b></h4><pre>
       Jaap Karssenberg || Pardus [Larus] &lt;<a href="mailto:pardus@cpan.org">pardus@cpan.org</a>&gt;

       Copyright  (c)  2004  Jaap  G  Karssenberg.  All rights reserved.  This program is free software; you can
       redistribute it and/or modify it under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Term::ReadLine::Zoid::ViCommand,     Term::ReadLine::Zoid::MultiLine,      Term::ReadLine::Zoid::ISearch,
       Term::ReadLine::Zoid::FileBrowse, Term::ReadLine::Zoid::Base, Term::ReadLine, Env::PS1, Zoidberg

perl v5.34.0                                       2022-06-17                          <u>Term::ReadLine::<a href="../man3pm/Zoid.3pm.html">Zoid</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>