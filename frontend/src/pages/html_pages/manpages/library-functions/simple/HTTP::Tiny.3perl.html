<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP::Tiny - A small, simple, correct HTTP/1.1 client</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTTP::Tiny - A small, simple, correct HTTP/1.1 client

</pre><h4><b>VERSION</b></h4><pre>
       version 0.088

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use HTTP::Tiny;

           my $response = HTTP::Tiny-&gt;new-&gt;get('<a href="http://example.com/">http://example.com/</a>');

           die "Failed!\n" unless $response-&gt;{success};

           print "$response-&gt;{status} $response-&gt;{reason}\n";

           while (my ($k, $v) = each %{$response-&gt;{headers}}) {
               for (ref $v eq 'ARRAY' ? @$v : $v) {
                   print "$k: $_\n";
               }
           }

           print $response-&gt;{content} if length $response-&gt;{content};

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a very simple HTTP/1.1 client, designed for doing simple requests without the overhead of a large
       framework like LWP::UserAgent.

       It is more correct and more complete than HTTP::Lite.  It supports proxies and redirection.  It also
       correctly resumes after EINTR.

       If IO::Socket::IP 0.25 or later is installed, HTTP::Tiny will use it instead of IO::Socket::INET for
       transparent support for both IPv4 and IPv6.

       Cookie support requires HTTP::CookieJar or an equivalent class.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
           $http = HTTP::Tiny-&gt;new( %attributes );

       This constructor returns a new HTTP::Tiny object.  Valid attributes include:

       •   "agent"  —  A  user-agent  string  (defaults  to  'HTTP-Tiny/$VERSION'). If "agent" — ends in a space
           character, the default user-agent string is appended.

       •   "cookie_jar" — An instance of HTTP::CookieJar — or equivalent  class  that  supports  the  "add"  and
           "cookie_header" methods

       •   "default_headers" — A hashref of default headers to apply to requests

       •   "local_address" — The local IP address to bind to

       •   "keep_alive" — Whether to reuse the last connection (if for the same scheme, host and port) (defaults
           to 1)

       •   "max_redirect" — Maximum number of redirects allowed (defaults to 5)

       •   "max_size"  —  Maximum  response  size  in  bytes (only when not using a data callback).  If defined,
           requests with responses larger than this will return a 599 status code.

       •   "http_proxy" — URL of a proxy server to use for HTTP connections (default is  $ENV{http_proxy}  —  if
           set)

       •   "https_proxy" — URL of a proxy server to use for HTTPS connections (default is $ENV{https_proxy} — if
           set)

       •   "proxy"  —  URL  of  a  generic  proxy  server  for  both  HTTP  and  HTTPS  connections  (default is
           $ENV{all_proxy} — if set)

       •   "no_proxy" — List of domain suffixes that should not be proxied.  Must be a comma-separated string or
           an array reference. (default is $ENV{no_proxy} —)

       •   "timeout" — Request timeout in seconds (default is 60) If a socket open, read or write  takes  longer
           than the timeout, the request response status code will be 599.

       •   "verify_SSL"  —  A boolean that indicates whether to validate the TLS/SSL certificate of an "https" —
           connection (default is true). Changed from false to true in version 0.083.

       •   "SSL_options" — A hashref of "SSL_*" — options to pass through to IO::Socket::SSL

       •   $ENV{PERL_HTTP_TINY_SSL_INSECURE_BY_DEFAULT} - Changes the default certificate verification  behavior
           to not check server identity if set to 1. Only effective if "verify_SSL" is not set. Added in version
           0.083.

       An accessor/mutator method exists for each attribute.

       Passing  an  explicit  "undef"  for  "proxy",  "http_proxy"  or  "https_proxy"  will  prevent getting the
       corresponding proxies from the environment.

       Errors during request execution will result in a pseudo-HTTP status code of 599 and a reason of "Internal
       Exception". The content field in the response will contain the text of the error.

       The "keep_alive" parameter enables a persistent connection, but only to a single destination scheme, host
       and port.  If any connection-relevant attributes are modified via accessor,  or  if  the  process  ID  or
       thread  ID  change, the persistent connection will be dropped.  If you want persistent connections across
       multiple destinations, use multiple HTTP::Tiny objects.

       See "SSL SUPPORT" for more on the "verify_SSL" and "SSL_options" attributes.

   <b>get|head|put|post|patch|delete</b>
           $response = $http-&gt;get($url);
           $response = $http-&gt;get($url, \%options);
           $response = $http-&gt;head($url);

       These methods are shorthand for calling request() for  the  given  method.   The  URL  must  have  unsafe
       characters  escaped  and  international  domain  names  encoded.   See  request() for valid options and a
       description of the response.

       The "success" field of the response will be true if the status code is 2XX.

   <b>post_form</b>
           $response = $http-&gt;post_form($url, $form_data);
           $response = $http-&gt;post_form($url, $form_data, \%options);

       This method executes a "POST" request and sends the key/value pairs  from  a  form  data  hash  or  array
       reference  to  the  given  URL  with a "content-type" of "application/x-www-form-urlencoded".  If data is
       provided as an array reference, the order is preserved; if provided as a hash reference,  the  terms  are
       sorted  on  key  and  value  for  consistency.  See documentation for the "www_form_urlencode" method for
       details on the encoding.

       The URL must have unsafe characters escaped and international domain names encoded.   See  request()  for
       valid  options  and  a  description of the response.  Any "content-type" header or content in the options
       hashref will be ignored.

       The "success" field of the response will be true if the status code is 2XX.

   <b>mirror</b>
           $response = $http-&gt;mirror($url, $file, \%options)
           if ( $response-&gt;{success} ) {
               print "$file is up to date\n";
           }

       Executes a "GET" request for the URL and saves the response body to the file name provided.  The URL must
       have unsafe characters escaped and international domain names encoded.  If the file already  exists,  the
       request  will include an "If-Modified-Since" header with the modification timestamp of the file.  You may
       specify a different "If-Modified-Since" header yourself in the "$options-&gt;{headers}" hash.

       The "success" field of the response will be true if the status code is 2XX or if the status code  is  304
       (unmodified).

       If  the  file  was modified and the server response includes a properly formatted "Last-Modified" header,
       the file modification time will be updated accordingly.

   <b>request</b>
           $response = $http-&gt;request($method, $url);
           $response = $http-&gt;request($method, $url, \%options);

       Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST', 'PUT', etc.) on the given  URL.
       The URL must have unsafe characters escaped and international domain names encoded.

       <b>NOTE</b>:  Method  names  are <b>case-sensitive</b> per the HTTP/1.1 specification.  Don't use "get" when you really
       want "GET".  See LIMITATIONS for how this applies to redirection.

       If the URL includes a "user:password" stanza, they will be used for  Basic-style  authorization  headers.
       (Authorization headers will not be included in a redirected request.) For example:

           $http-&gt;request('GET', '<a href="http://Aladdin">http://Aladdin</a>:open <a href="mailto:sesame@example.com">sesame@example.com</a>/');

       If the "user:password" stanza contains reserved characters, they must be percent-escaped:

           $http-&gt;request('GET', '<a href="http://john">http://john</a>%40example.com:<a href="mailto:password@example.com">password@example.com</a>/');

       A hashref of options may be appended to modify the request.

       Valid options are:

       •   "headers"  —  A hashref containing headers to include with the request.  If the value for a header is
           an array reference, the header will be output multiple times with each value  in  the  array.   These
           headers over-write any default headers.

       •   "content"  —  A  scalar to include as the body of the request OR a code reference that will be called
           iteratively to produce the body of the request

       •   "trailer_callback" — A code reference that will be called if  it  exists  to  provide  a  hashref  of
           trailing headers (only used with chunked transfer-encoding)

       •   "data_callback" — A code reference that will be called for each chunks of the response body received.

       •   "peer"  —  Override  host resolution and force all connections to go only to a specific peer address,
           regardless of the URL of the request.  This will include any redirections!  This  options  should  be
           used with extreme caution (e.g. debugging or very special circumstances). It can be given as either a
           scalar  or  a  code  reference that will receive the hostname and whose response will be taken as the
           address.

       The "Host" header is generated from the URL in accordance with RFC 2616.  It is a fatal error to  specify
       "Host"  in  the "headers" option.  Other headers may be ignored or overwritten if necessary for transport
       compliance.

       If the "content" option is a code reference, it will be called iteratively to provide the content body of
       the request.  It should return the empty string or undef when the iterator is exhausted.

       If the "content" option is the empty string,  no  "content-type"  or  "content-length"  headers  will  be
       generated.

       If  the  "data_callback" option is provided, it will be called iteratively until the entire response body
       is received.  The first argument will be a string containing a chunk of the  response  body,  the  second
       argument  will  be the in-progress response hash reference, as described below.  (This allows customizing
       the action of the callback based on the "status" or "headers" received prior to the content body.)

       Content data in the request/response is handled as "raw bytes".  Any encoding/decoding  (with  associated
       headers) are the responsibility of the caller.

       The  "request"  method  returns  a  hashref containing the response.  The hashref will have the following
       keys:

       •   "success" — Boolean indicating whether the operation returned a 2XX status code

       •   "url" — URL that  provided  the  response.  This  is  the  URL  of  the  request  unless  there  were
           redirections, in which case it is the last URL queried in a redirection chain

       •   "status" — The HTTP status code of the response

       •   "reason" — The response phrase returned by the server

       •   "content"  —  The  body  of  the  response.   If  the response does not have any content or if a data
           callback is provided to consume the response body, this will be the empty string

       •   "headers" — A hashref of header fields.  All header field names will be normalized to be lower  case.
           If  a  header  is  repeated,  the  value  will  be  an arrayref; it will otherwise be a scalar string
           containing the value

       •   "protocol" - If this field exists, it is the protocol of the response such as HTTP/1.0 or HTTP/1.1

       •   "redirects" If this field exists, it is an arrayref of response hash references from redirects in the
           same order that redirections occurred.  If it does not exist, then no redirections occurred.

       On an error during the execution of the request, the "status" field will contain 599, and  the  "content"
       field will contain the text of the error.

   <b>www_form_urlencode</b>
           $params = $http-&gt;www_form_urlencode( $data );
           $response = $http-&gt;get("<a href="http://example.com/query">http://example.com/query</a>?$params");

       This   method   converts   the   key/value   pairs   from   a   data  hash  or  array  reference  into  a
       "x-www-form-urlencoded" string.  The keys and values from the data reference will be  UTF-8  encoded  and
       escaped per RFC 3986.  If a value is an array reference, the key will be repeated with each of the values
       of  the  array  reference.  If data is provided as a hash reference, the key/value pairs in the resulting
       string will be sorted by key and value for consistent ordering.

   <b>can_ssl</b>
           $ok         = HTTP::Tiny-&gt;can_ssl;
           ($ok, $why) = HTTP::Tiny-&gt;can_ssl;
           ($ok, $why) = $http-&gt;can_ssl;

       Indicates if SSL support is available.  When called as a class object, it checks for the correct  version
       of  Net::SSLeay  and  IO::Socket::SSL.   When  called as an object methods, if "SSL_verify" is true or if
       "SSL_verify_mode" is set in "SSL_options", it checks that a CA file is available.

       In scalar context, returns a boolean indicating if SSL  is  available.   In  list  context,  returns  the
       boolean and a (possibly multi-line) string of errors indicating why SSL isn't available.

   <b>connected</b>
           $host = $http-&gt;connected;
           ($host, $port) = $http-&gt;connected;

       Indicates if a connection to a peer is being kept alive, per the "keep_alive" option.

       In  scalar  context,  returns  the  peer  host  and  port, joined with a colon, or "undef" (if no peer is
       connected).  In list context, returns the peer host and port or an empty list (if no peer is connected).

       <b>Note</b>: This method cannot reliably be used to discover whether the remote host has closed its end  of  the
       socket.

</pre><h4><b>TLS/SSL</b> <b>SUPPORT</b></h4><pre>
       Direct  "https" connections are supported only if IO::Socket::SSL 1.56 or greater and Net::SSLeay 1.49 or
       greater are installed. An error will occur if new enough versions of these modules are not  installed  or
       if the TLS encryption fails. You can also use HTTP::Tiny::can_ssl() utility function that returns boolean
       to see if the required modules are installed.

       An  "https" connection may be made via an "http" proxy that supports the CONNECT command (i.e. RFC 2817).
       You may not proxy "https" via a proxy that itself requires "https" to communicate.

       TLS/SSL provides two distinct capabilities:

       •   Encrypted communication channel

       •   Verification of server identity

       <b>By</b> <b>default,</b> <b>HTTP::Tiny</b> <b>verifies</b> <b>server</b> <b>identity</b>.

       This was changed in version 0.083 due to security concerns. The previous default behavior can be  enabled
       by setting $ENV{PERL_HTTP_TINY_SSL_INSECURE_BY_DEFAULT} to 1.

       Verification  is  done by checking that that the TLS/SSL connection has a valid certificate corresponding
       to the host name of the connection and that the certificate has been verified by a CA. Assuming you trust
       the CA, this will protect against machine-in-the-middle attacks &lt;<a href="http://en.wikipedia.org/wiki/Machine-in">http://en.wikipedia.org/wiki/Machine-in</a>-
       the-middle_attack&gt;.

       Certificate verification requires a file containing trusted CA certificates.

       If the environment variable "SSL_CERT_FILE" is present, HTTP::Tiny will try to find a CA certificate file
       in that location.

       If the Mozilla::CA module is installed, HTTP::Tiny will use the CA file included with it as a  source  of
       trusted CA's.

       If  that  module  is not available, then HTTP::Tiny will search several system-specific default locations
       for a CA certificate file:

       •   <a href="file:/etc/ssl/certs/ca-certificates.crt">/etc/ssl/certs/ca-certificates.crt</a>

       •   /etc/pki/tls/certs/ca-bundle.crt

       •   /etc/ssl/ca-bundle.pem

       •   /etc/openssl/certs/ca-certificates.crt

       •   /etc/ssl/cert.pem

       •   /usr/local/share/certs/ca-root-nss.crt

       •   /etc/pki/tls/cacert.pem

       •   /etc/certs/ca-certificates.crt

       An error will be occur if "verify_SSL" is true and no CA certificate file is available.

       If you desire complete control over TLS/SSL connections, the "SSL_options" attribute lets you  provide  a
       hash reference that will be passed through to IO::Socket::SSL::start_SSL(), overriding any options set by
       HTTP::Tiny. For example, to provide your own trusted CA file:

           SSL_options =&gt; {
               SSL_ca_file =&gt; $file_path,
           }

       The  "SSL_options"  attribute  could  also  be used for such things as providing a client certificate for
       authentication to a server or controlling the choice of cipher  used  for  the  TLS/SSL  connection.  See
       IO::Socket::SSL documentation for details.

</pre><h4><b>PROXY</b> <b>SUPPORT</b></h4><pre>
       HTTP::Tiny  can  proxy both "http" and "https" requests.  Only Basic proxy authorization is supported and
       it must be provided as part of the proxy URL: "<a href="http://user">http://user</a>:<a href="mailto:pass@proxy.example.com">pass@proxy.example.com</a>/".

       HTTP::Tiny supports the following proxy environment variables:

       •   http_proxy or HTTP_PROXY

       •   https_proxy or HTTPS_PROXY

       •   all_proxy or ALL_PROXY

       If the "REQUEST_METHOD" environment variable is set, then this might be a CGI  process  and  "HTTP_PROXY"
       would  be  set  from  the  "Proxy:"  header,  which  is  a  security  risk.   If "REQUEST_METHOD" is set,
       "HTTP_PROXY" (the upper case variant only) is ignored, but "CGI_HTTP_PROXY" is considered instead.

       Tunnelling "https" over an "http" proxy using the CONNECT  method  is  supported.   If  your  proxy  uses
       "https" itself, you can not tunnel "https" over it.

       Be  warned that proxying an "https" connection opens you to the risk of a man-in-the-middle attack by the
       proxy server.

       The "no_proxy" environment variable is supported in the  format  of  a  comma-separated  list  of  domain
       extensions proxy should not be used for.

       Proxy arguments passed to "new" will override their corresponding environment variables.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       HTTP::Tiny is <u>conditionally</u> <u>compliant</u> with the HTTP/1.1 specifications &lt;<a href="http://www.w3.org/Protocols/">http://www.w3.org/Protocols/</a>&gt;:

       •   "Message Syntax and Routing" [RFC7230]

       •   "Semantics and Content" [RFC7231]

       •   "Conditional Requests" [RFC7232]

       •   "Range Requests" [RFC7233]

       •   "Caching" [RFC7234]

       •   "Authentication" [RFC7235]

       It  attempts  to  meet  all "MUST" requirements of the specification, but does not implement all "SHOULD"
       requirements.  (Note: it was developed against the earlier RFC 2616 specification and may  not  yet  meet
       the revised RFC 7230-7235 spec.) Additionally, HTTP::Tiny supports the "PATCH" method of RFC 5789.

       Some particular limitations of note include:

       •   HTTP::Tiny  focuses  on  correct  transport.   Users  are  responsible for ensuring that user-defined
           headers and content are compliant with the HTTP/1.1 specification.

       •   Users must ensure that URLs are properly escaped for unsafe characters and that international  domain
           names are properly encoded to ASCII. See URI::Escape, URI::_punycode and Net::IDN::Encode.

       •   Redirection  is  very  strict  against the specification.  Redirection is only automatic for response
           codes 301, 302, 307 and 308 if the request method is 'GET' or 'HEAD'.  Response code  303  is  always
           converted  into a 'GET' redirection, as mandated by the specification.  There is no automatic support
           for status 305 ("Use proxy") redirections.

       •   There is no provision for delaying a  request  body  using  an  "Expect"  header.   Unexpected  "1XX"
           responses are silently ignored as per the specification.

       •   Only 'chunked' "Transfer-Encoding" is supported.

       •   There is no support for a Request-URI of '*' for the 'OPTIONS' request.

       •   Headers  mentioned  in the RFCs and some other, well-known headers are generated with their canonical
           case.  Other headers are sent in the case provided by the user.  Except for  control  headers  (which
           are sent first), headers are sent in arbitrary order.

       Despite  the  limitations  listed above, HTTP::Tiny is considered feature-complete.  New feature requests
       should be directed to HTTP::Tiny::UA.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   HTTP::Tiny::UA - Higher level UA features for HTTP::Tiny

       •   HTTP::Thin - HTTP::Tiny wrapper with HTTP::Request/HTTP::Response compatibility

       •   HTTP::Tiny::Mech - Wrap WWW::Mechanize instance in HTTP::Tiny compatible interface

       •   IO::Socket::IP - Required for IPv6 support

       •   IO::Socket::SSL - Required for SSL support

       •   LWP::UserAgent - If HTTP::Tiny isn't enough for you, this is the "standard" way to do things

       •   Mozilla::CA - Required if you want to validate SSL certificates

       •   Net::SSLeay - Required for SSL support

</pre><h4><b>SUPPORT</b></h4><pre>
   <b>Bugs</b> <b>/</b> <b>Feature</b> <b>Requests</b>
       Please    report    any    bugs    or    feature    requests    through    the    issue    tracker     at
       &lt;https://github.com/Perl-Toolchain-Gang/HTTP-Tiny/issues&gt;.   You  will  be  notified automatically of any
       progress on your issue.

   <b>Source</b> <b>Code</b>
       This is open source software.  The code repository is available for public review and contribution  under
       the terms of the license.

       &lt;https://github.com/Perl-Toolchain-Gang/HTTP-Tiny&gt;

         git clone https://github.com/Perl-Toolchain-Gang/HTTP-Tiny.git

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Christian Hansen &lt;<a href="mailto:chansen@cpan.org">chansen@cpan.org</a>&gt;

       •   David Golden &lt;<a href="mailto:dagolden@cpan.org">dagolden@cpan.org</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Alan Gardner &lt;<a href="mailto:gardner@pythian.com">gardner@pythian.com</a>&gt;

       •   Alessandro Ghedini &lt;<a href="mailto:al3xbio@gmail.com">al3xbio@gmail.com</a>&gt;

       •   A. Sinan Unur &lt;<a href="mailto:nanis@cpan.org">nanis@cpan.org</a>&gt;

       •   Brad Gilbert &lt;<a href="mailto:bgills@cpan.org">bgills@cpan.org</a>&gt;

       •   brian m. carlson &lt;<a href="mailto:sandals@crustytoothpaste.net">sandals@crustytoothpaste.net</a>&gt;

       •   Chris Nehren &lt;<a href="mailto:apeiron@cpan.org">apeiron@cpan.org</a>&gt;

       •   Chris Weyl &lt;<a href="mailto:cweyl@alumni.drew.edu">cweyl@alumni.drew.edu</a>&gt;

       •   Claes Jakobsson &lt;<a href="mailto:claes@surfar.nu">claes@surfar.nu</a>&gt;

       •   Clinton Gormley &lt;<a href="mailto:clint@traveljury.com">clint@traveljury.com</a>&gt;

       •   Craig A. Berry &lt;<a href="mailto:craigberry@mac.com">craigberry@mac.com</a>&gt;

       •   Craig Berry &lt;<a href="mailto:cberry@cpan.org">cberry@cpan.org</a>&gt;

       •   David Golden &lt;<a href="mailto:xdg@xdg.me">xdg@xdg.me</a>&gt;

       •   David Mitchell &lt;<a href="mailto:davem@iabyn.com">davem@iabyn.com</a>&gt;

       •   Dean Pearce &lt;<a href="mailto:pearce@pythian.com">pearce@pythian.com</a>&gt;

       •   Edward Zborowski &lt;<a href="mailto:ed@rubensteintech.com">ed@rubensteintech.com</a>&gt;

       •   Felipe Gasper &lt;<a href="mailto:felipe@felipegasper.com">felipe@felipegasper.com</a>&gt;

       •   Graham Knop &lt;<a href="mailto:haarg@haarg.org">haarg@haarg.org</a>&gt;

       •   Greg Kennedy &lt;<a href="mailto:kennedy.greg@gmail.com">kennedy.greg@gmail.com</a>&gt;

       •   James E Keenan &lt;<a href="mailto:jkeenan@cpan.org">jkeenan@cpan.org</a>&gt;

       •   James Raspass &lt;<a href="mailto:jraspass@gmail.com">jraspass@gmail.com</a>&gt;

       •   Jeremy Mates &lt;<a href="mailto:jmates@cpan.org">jmates@cpan.org</a>&gt;

       •   Jess Robinson &lt;<a href="mailto:castaway@desert-island.me.uk">castaway@desert-island.me.uk</a>&gt;

       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   Lukas Eklund &lt;<a href="mailto:leklund@gmail.com">leklund@gmail.com</a>&gt;

       •   Martin J. Evans &lt;<a href="mailto:mjegh@ntlworld.com">mjegh@ntlworld.com</a>&gt;

       •   Martin-Louis Bright &lt;<a href="mailto:mlbright@gmail.com">mlbright@gmail.com</a>&gt;

       •   Matthew Horsfall &lt;<a href="mailto:wolfsage@gmail.com">wolfsage@gmail.com</a>&gt;

       •   Michael R. Davis &lt;<a href="mailto:mrdvt92@users.noreply.github.com">mrdvt92@users.noreply.github.com</a>&gt;

       •   Mike Doherty &lt;<a href="mailto:doherty@cpan.org">doherty@cpan.org</a>&gt;

       •   Nicolas Rochelemagne &lt;<a href="mailto:rochelemagne@cpanel.net">rochelemagne@cpanel.net</a>&gt;

       •   Olaf Alders &lt;<a href="mailto:olaf@wundersolutions.com">olaf@wundersolutions.com</a>&gt;

       •   Olivier Mengué &lt;<a href="mailto:dolmen@cpan.org">dolmen@cpan.org</a>&gt;

       •   Petr Písař &lt;<a href="mailto:ppisar@redhat.com">ppisar@redhat.com</a>&gt;

       •   sanjay-cpu &lt;<a href="mailto:snjkmr32@gmail.com">snjkmr32@gmail.com</a>&gt;

       •   Serguei Trouchelle &lt;<a href="mailto:stro@cpan.org">stro@cpan.org</a>&gt;

       •   Shoichi Kaji &lt;<a href="mailto:skaji@cpan.org">skaji@cpan.org</a>&gt;

       •   SkyMarshal &lt;<a href="mailto:skymarshal1729@gmail.com">skymarshal1729@gmail.com</a>&gt;

       •   Sören Kornetzki &lt;<a href="mailto:soeren.kornetzki@delti.com">soeren.kornetzki@delti.com</a>&gt;

       •   Steve Grazzini &lt;<a href="mailto:steve.grazzini@grantstreet.com">steve.grazzini@grantstreet.com</a>&gt;

       •   Stig Palmquist &lt;<a href="mailto:git@stig.io">git@stig.io</a>&gt;

       •   Syohei YOSHIDA &lt;<a href="mailto:syohex@gmail.com">syohex@gmail.com</a>&gt;

       •   Tatsuhiko Miyagawa &lt;<a href="mailto:miyagawa@bulknews.net">miyagawa@bulknews.net</a>&gt;

       •   Tom Hukins &lt;<a href="mailto:tom@eborcom.com">tom@eborcom.com</a>&gt;

       •   Tony Cook &lt;<a href="mailto:tony@develop-help.com">tony@develop-help.com</a>&gt;

       •   Xavier Guimard &lt;<a href="mailto:yadd@debian.org">yadd@debian.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2023 by Christian Hansen.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.1                                       2025-07-03                                  <u>HTTP::<a href="../man3perl/Tiny.3perl.html">Tiny</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>